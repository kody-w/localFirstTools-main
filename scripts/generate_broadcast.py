#!/usr/bin/env python3
"""Generate RappterZooNation podcast episodes.

Two hosts — Rapptr (enthusiastic optimist) and ZooKeeper (critical realist) —
discuss actual RappterZoo apps with real scores, community data, and deep links.

Usage:
    python3 scripts/generate_broadcast.py                    # Generate next episode
    python3 scripts/generate_broadcast.py --verbose          # Show generation details
    python3 scripts/generate_broadcast.py --push             # Generate + commit + push
    python3 scripts/generate_broadcast.py --frame N          # Generate for specific frame
    python3 scripts/generate_broadcast.py --regenerate-all   # Regenerate all episodes

Output: apps/broadcasts/feed.json
"""

import json
import random
import sys
import subprocess
from pathlib import Path
from datetime import datetime

ROOT = Path(__file__).resolve().parent.parent
APPS_DIR = ROOT / "apps"
MANIFEST = APPS_DIR / "manifest.json"
RANKINGS = APPS_DIR / "rankings.json"
COMMUNITY = APPS_DIR / "community.json"
MOLTER_STATE = APPS_DIR / "molter-state.json"
BROADCAST_DIR = APPS_DIR / "broadcasts"
FEED_FILE = BROADCAST_DIR / "feed.json"
LORE_FILE = BROADCAST_DIR / "lore.json"

SITE_BASE = "https://kody-w.github.io/localFirstTools-main"

VERBOSE = "--verbose" in sys.argv or "-v" in sys.argv

# ── Host Definitions ──────────────────────────────────────────────

HOSTS = {
    "Rapptr": {
        "color": "#00e5ff",
        "avatar": "rapptr",
        "bio": "Enthusiastic optimist. Gets excited about weird experimental stuff. Sees the beauty in broken games. Will play anything once — and probably twice.",
    },
    "ZooKeeper": {
        "color": "#ff6e40",
        "avatar": "zookeeper",
        "bio": "Critical realist. Data-driven. Cares about quality scores and playability. Snarky but fair. Respects craftsmanship over ambition.",
    },
}

# Static template pools REMOVED — all dialogue now generated by Copilot CLI.
# See generate_review_dialogue(), generate_roast_dialogue(), and generate_episode() for LLM-powered generation.

def load_lore():
    """Load the lore tracker — persistent history across episodes."""
    if LORE_FILE.exists():
        with open(LORE_FILE) as f:
            return json.load(f)
    return {
        "reviewed_apps": {},      # file -> {episodes: [ep_nums], scores: [scores], grades: [grades]}
        "category_counts": {},    # category -> count of times featured
        "total_reviewed": 0,      # total app reviews across all episodes
        "running_jokes": [],      # list of {type, data, started_ep}
        "milestones": [],         # list of {type, ep, value}
        "episode_summaries": [],  # list of {ep, title, apps_reviewed, top_score, date}
    }


def save_lore(lore):
    """Save lore tracker to disk."""
    BROADCAST_DIR.mkdir(parents=True, exist_ok=True)
    with open(LORE_FILE, "w") as f:
        json.dump(lore, f, indent=2)


def update_lore(lore, episode):
    """Update lore with data from a new episode."""
    ep_num = episode["number"]
    reviewed_files = []

    for seg in episode.get("segments", []):
        if seg.get("type") in ("review", "roast") and seg.get("app"):
            app = seg["app"]
            file_key = app["file"]
            reviewed_files.append(file_key)

            # Track per-app history
            if file_key not in lore["reviewed_apps"]:
                lore["reviewed_apps"][file_key] = {
                    "title": app["title"],
                    "episodes": [],
                    "scores": [],
                    "grades": [],
                }
            entry = lore["reviewed_apps"][file_key]
            entry["episodes"].append(ep_num)
            entry["scores"].append(app.get("score", 0))
            entry["grades"].append(app.get("grade", "?"))
            entry["title"] = app["title"]  # Update to latest title

            # Track category frequency
            cat = app.get("category", "unknown")
            lore["category_counts"][cat] = lore["category_counts"].get(cat, 0) + 1

    lore["total_reviewed"] += len(reviewed_files)

    # Episode summary
    top_score = 0
    for seg in episode.get("segments", []):
        if seg.get("app"):
            top_score = max(top_score, seg["app"].get("score", 0))

    lore["episode_summaries"].append({
        "ep": ep_num,
        "title": episode["title"],
        "apps_reviewed": reviewed_files,
        "top_score": top_score,
        "date": episode.get("generated", ""),
    })

    # Keep summaries manageable
    lore["episode_summaries"] = lore["episode_summaries"][-100:]

    return lore


def generate_lore_dialogue(app, lore, episode_number, rng):
    """Generate lore-aware dialogue lines via Copilot CLI if this app has been reviewed before."""
    from copilot_utils import copilot_call, parse_llm_json

    lines = []
    file_key = app["file"]

    if file_key not in lore.get("reviewed_apps", {}):
        return lines

    history = lore["reviewed_apps"][file_key]
    past_episodes = history.get("episodes", [])
    past_scores = history.get("scores", [])
    past_grades = history.get("grades", [])

    if not past_episodes:
        return lines

    last_ep = past_episodes[-1]
    old_score = past_scores[-1] if past_scores else 0
    old_grade = past_grades[-1] if past_grades else "?"
    new_score = app.get("score", 0)
    new_grade = app.get("grade", "?")
    appearances = len(past_episodes)
    delta = new_score - old_score

    prompt = f"""Generate 2 lore callback dialogue lines for a podcast about "{app['title']}".

This app was previously reviewed in episode {last_ep} with score {old_score}/100 ({old_grade} grade).
Now it scores {new_score}/100 ({new_grade} grade). Delta: {delta:+d} points. Reviewed {appearances} times total.

Return JSON array:
[
  {{"host": "Rapptr", "text": "excited callback referencing the history (1-2 sentences)"}},
  {{"host": "ZooKeeper", "text": "data-driven comparison with the previous score (1-2 sentences)"}}
]

Rapptr is enthusiastic, ZooKeeper is analytical. Return ONLY the JSON array."""

    raw = copilot_call(prompt, timeout=30)
    result = parse_llm_json(raw) if raw else None
    if result and isinstance(result, list):
        for item in result[:2]:
            if isinstance(item, dict) and "host" in item and "text" in item:
                lines.append({"host": item["host"], "text": item["text"]})

    if not lines:
        lines = [
            {"host": "Rapptr", "text": f"We reviewed {app['title']} back in episode {last_ep} at {old_score}/100!"},
            {"host": "ZooKeeper", "text": f"Delta of {delta:+d} points since episode {last_ep}."},
        ]

    return lines


def generate_milestone_dialogue(lore, episode_number, total_apps, rng):
    """Generate milestone/meta commentary via Copilot CLI."""
    from copilot_utils import copilot_call, parse_llm_json

    lines = []
    ep_count = len(lore.get("episode_summaries", [])) + 1

    if ep_count % 5 != 0 and ep_count != 1:
        return lines

    total_reviewed = lore.get("total_reviewed", 0)
    avg_score = 0
    all_scores = []
    for app_data in lore.get("reviewed_apps", {}).values():
        all_scores.extend(app_data.get("scores", []))
    if all_scores:
        avg_score = sum(all_scores) / len(all_scores)

    remaining = max(0, total_apps - len(lore.get("reviewed_apps", {})))
    pct = (len(lore.get("reviewed_apps", {})) / total_apps * 100) if total_apps else 0

    cat_counts = lore.get("category_counts", {})
    streak_cat = None
    for cat, count in cat_counts.items():
        if count >= 3 and count % 3 == 0:
            streak_cat = cat.replace("_", " ")
            break

    prompt = f"""Generate milestone commentary for podcast episode #{episode_number}.

Stats: {ep_count} episodes total, {total_reviewed} apps reviewed, average score {avg_score:.0f}/100.
Coverage: {pct:.0f}% of {total_apps} total apps reviewed. {remaining} apps untouched.
{f'Category streak: {streak_cat} category has been reviewed {cat_counts.get(streak_cat, 3)} times in a row.' if streak_cat else ''}

Return JSON array of 1-2 dialogue lines:
[
  {{"host": "ZooKeeper", "text": "data-driven milestone observation (1 sentence)"}},
  {{"host": "Rapptr", "text": "fun reaction to the milestone (1 sentence)"}}
]

Return ONLY the JSON array."""

    raw = copilot_call(prompt, timeout=30)
    result = parse_llm_json(raw) if raw else None
    if result and isinstance(result, list):
        for item in result[:2]:
            if isinstance(item, dict) and "host" in item and "text" in item:
                lines.append({"host": item["host"], "text": item["text"]})

    if not lines:
        lines = [{"host": "ZooKeeper", "text": f"Episode {ep_count}. {total_reviewed} apps reviewed, {remaining} remaining."}]

    return lines


def log(msg):
    if VERBOSE:
        print(f"  [broadcast] {msg}")


def load_json(path):
    if not path.exists():
        return None
    with open(path) as f:
        return json.load(f)


def get_app_stem(filename):
    """Get the stem key used in community.json (filename without .html)."""
    return Path(filename).stem


def build_app_index(manifest, rankings, community):
    """Build a unified index of all apps with scores, community data, etc."""
    index = {}

    # Index manifest entries by file
    cat_map = {}
    for cat_key, cat_data in manifest.get("categories", {}).items():
        folder = cat_data.get("folder", cat_key.replace("_", "-"))
        for app in cat_data.get("apps", []):
            key = app["file"]
            index[key] = {
                "title": app.get("title", key),
                "file": key,
                "category": cat_key,
                "folder": folder,
                "category_title": cat_data.get("title", cat_key),
                "description": app.get("description", ""),
                "tags": app.get("tags", []),
                "complexity": app.get("complexity", "intermediate"),
                "type": app.get("type", "interactive"),
                "path": f"apps/{folder}/{key}",
                "url": f"{SITE_BASE}/apps/{folder}/{key}",
                "score": 0,
                "grade": "F",
                "playability": 0,
                "community": {"avgRating": 0, "totalRatings": 0, "totalComments": 0, "topComments": []},
            }
            cat_map[key] = cat_key

    # Merge ranking data
    if rankings:
        for entry in rankings.get("rankings", []):
            key = entry.get("file", "")
            if key in index:
                index[key]["score"] = entry.get("score", 0)
                index[key]["grade"] = entry.get("grade", "F")
                playability_dim = entry.get("dimensions", {}).get("playability", {})
                index[key]["playability"] = playability_dim.get("score", 0)

    # Merge community data
    if community:
        comments = community.get("comments", {})
        ratings = community.get("ratings", {})

        for key, app in index.items():
            stem = get_app_stem(key)
            # Comments
            app_comments = comments.get(stem, [])
            all_comments = []
            for c in app_comments:
                all_comments.append(c)
                for child in c.get("children", []):
                    all_comments.append(child)
            all_comments.sort(key=lambda x: x.get("upvotes", 0), reverse=True)
            top = all_comments[:3]

            # Ratings
            app_ratings = ratings.get(stem, [])
            stars = [r.get("stars", 3) for r in app_ratings]
            avg = sum(stars) / len(stars) if stars else 0

            app["community"] = {
                "avgRating": round(avg, 1),
                "totalRatings": len(app_ratings),
                "totalComments": len(all_comments),
                "topComments": [
                    {"author": c.get("author", "anon"), "text": c.get("text", ""), "upvotes": c.get("upvotes", 0)}
                    for c in top
                ],
            }

    return index


def select_episode_apps(index, rng, frame):
    """Select 3-5 apps for this episode using diverse criteria."""
    apps = list(index.values())
    if not apps:
        return []

    selected = []
    used_files = set()

    # 1. Top scoring app (highlight)
    by_score = sorted(apps, key=lambda a: a["score"], reverse=True)
    for app in by_score:
        if app["file"] not in used_files:
            selected.append(app)
            used_files.add(app["file"])
            break

    # 2. Trending — highest community activity
    by_activity = sorted(apps, key=lambda a: a["community"]["totalComments"] + a["community"]["totalRatings"], reverse=True)
    for app in by_activity:
        if app["file"] not in used_files:
            selected.append(app)
            used_files.add(app["file"])
            break

    # 3. Hidden gem — good score (60+) but low community attention
    gems = [a for a in apps if a["score"] >= 60 and a["community"]["totalRatings"] < 20 and a["file"] not in used_files]
    if gems:
        gem = rng.choice(gems)
        selected.append(gem)
        used_files.add(gem["file"])

    # 4. Random pick from a random category (for variety)
    categories = list(set(a["category"] for a in apps))
    if categories:
        cat = rng.choice(categories)
        cat_apps = [a for a in apps if a["category"] == cat and a["file"] not in used_files and a["score"] >= 30]
        if cat_apps:
            pick = rng.choice(cat_apps)
            selected.append(pick)
            used_files.add(pick["file"])

    # 5. Worst app (for roast segment)
    by_score_asc = sorted(apps, key=lambda a: a["score"])
    for app in by_score_asc:
        if app["file"] not in used_files and app["score"] > 0:
            selected.append(app)
            used_files.add(app["file"])
            break

    # Shuffle the middle reviews (keep first as top pick, last as roast)
    if len(selected) > 2:
        middle = selected[1:-1]
        rng.shuffle(middle)
        selected = [selected[0]] + middle + [selected[-1]]

    return selected


def generate_review_dialogue(app, rng):
    """Generate review dialogue via Copilot CLI — zero templates."""
    from copilot_utils import copilot_call, parse_llm_json

    tags = app.get("tags", [])
    community = app.get("community", {})
    top_comments = community.get("topComments", [])
    top_comment_text = top_comments[0]["text"][:120] if top_comments else ""
    avg_rating = community.get("avgRating", 0)
    total_ratings = community.get("totalRatings", 0)

    prompt = f"""Generate a podcast dialogue between two hosts reviewing a browser game.

HOSTS:
- Rapptr: Enthusiastic optimist. Gets excited about weird stuff. Sees beauty in broken games. Casual, funny.
- ZooKeeper: Critical realist. Data-driven, snarky but fair. Respects craftsmanship over ambition.

APP DATA:
- Title: {app.get('title','')}
- Description: {app.get('description','')}
- Category: {app.get('category_title','')}
- Tags: {', '.join(tags)}
- Score: {app.get('score',0)}/100 (Grade: {app.get('grade','?')})
- Playability: {app.get('playability',0)}/25
- Community rating: {avg_rating}/5 from {total_ratings} ratings
- Top comment: "{top_comment_text}"

Generate 6-10 dialogue lines as a JSON array:
[{{"host": "Rapptr", "text": "..."}}, {{"host": "ZooKeeper", "text": "..."}}, ...]

RULES:
- Rapptr opens with excitement about the app
- ZooKeeper responds with data and analysis
- They discuss specific tags/mechanics
- Reference the community comment if available
- If score < 50, ZooKeeper is harsher; Rapptr finds silver linings
- If score > 80, both are enthusiastic but ZooKeeper stays analytical
- Every line must be UNIQUE — never reusable for another app
- Natural podcast banter, not stiff Q&A

Return ONLY the JSON array."""

    raw = copilot_call(prompt, timeout=60)
    parsed = parse_llm_json(raw) if raw else None

    if parsed and isinstance(parsed, list):
        return [{"host": d.get("host", "Rapptr"), "text": d.get("text", "")} for d in parsed if d.get("text")]

    # Minimal fallback — should rarely hit this
    return [
        {"host": "Rapptr", "text": f"Let's talk about {app.get('title','')} — score {app.get('score',0)}."},
        {"host": "ZooKeeper", "text": f"Grade {app.get('grade','?')}. The data speaks for itself."},
    ]


def generate_roast_dialogue(app, rng):
    """Generate roast segment via Copilot CLI — zero templates."""
    from copilot_utils import copilot_call, parse_llm_json

    prompt = f"""Generate a podcast "roast" segment where two hosts roast a low-scoring browser game.

HOSTS:
- Rapptr: Tries to defend the game but can't help laughing. Finds silver linings.
- ZooKeeper: Delivers brutal but fair critique. Data-driven burns.

APP TO ROAST:
- Title: {app.get('title','')}
- Description: {app.get('description','')}
- Tags: {', '.join(app.get('tags',[]))}
- Score: {app.get('score',0)}/100 (Grade: {app.get('grade','?')})
- Playability: {app.get('playability',0)}/25

Generate 4-6 dialogue lines as a JSON array:
[{{"host": "Rapptr", "text": "..."}}, {{"host": "ZooKeeper", "text": "..."}}, ...]

RULES:
- ZooKeeper roasts the specific weaknesses shown by the low score/tags
- Rapptr defends but acknowledges the problems
- Humor comes from specificity, not meanness
- End with hope — "molting exists for a reason"
- Every line completely unique to this app

Return ONLY the JSON array."""

    raw = copilot_call(prompt, timeout=60)
    parsed = parse_llm_json(raw) if raw else None

    if parsed and isinstance(parsed, list):
        return [{"host": d.get("host", "Rapptr"), "text": d.get("text", "")} for d in parsed if d.get("text")]

    return [
        {"host": "Rapptr", "text": f"OK so... {app.get('title','')} at {app.get('score',0)} points."},
        {"host": "ZooKeeper", "text": "Molting exists for a reason."},
    ]


def estimate_duration(segments):
    """Estimate episode duration from total word count (~150 words/min)."""
    words = 0
    for seg in segments:
        if "text" in seg:
            words += len(seg["text"].split())
        for line in seg.get("dialogue", []):
            words += len(line.get("text", "").split())
    minutes = words / 150
    m = int(minutes)
    s = int((minutes - m) * 60)
    return f"{m}:{s:02d}"


def generate_episode(index, rng, frame, episode_number, rankings_summary, lore=None):
    """Generate a complete episode — all dialogue via Copilot CLI."""
    from copilot_utils import copilot_call, parse_llm_json

    apps = select_episode_apps(index, rng, frame)
    if not apps:
        return None

    if lore is None:
        lore = load_lore()

    num_reviews = len(apps) - 1
    total_apps = len(index)
    median = rankings_summary.get("median_score", 49) if rankings_summary else 49
    top_app = apps[0] if apps else None
    review_apps = apps[:-1] if len(apps) > 1 else apps
    roast_app = apps[-1] if len(apps) > 1 else None

    # Generate episode title + intro/outro via LLM
    app_summaries = [{"title": a["title"], "score": a["score"], "grade": a["grade"],
                      "category": a.get("category_title", ""), "tags": a.get("tags", [])}
                     for a in apps[:6]]

    meta_prompt = f"""Generate metadata for podcast episode #{episode_number} of RappterZooNation.

Hosts: Rapptr (enthusiast) and ZooKeeper (data-driven critic)
Apps reviewed this episode: {json.dumps(app_summaries)}
Total apps in arcade: {total_apps}, Median score: {median}

Return JSON:
{{
  "title": "creative episode title referencing the top app or theme",
  "intro_rapptr": "Rapptr's opening line (1-2 sentences, excited, references episode number)",
  "intro_zookeeper": "ZooKeeper's response (1-2 sentences, data-driven)",
  "outro_rapptr": "Rapptr's closing line (1-2 sentences, positive energy)",
  "outro_zookeeper": "ZooKeeper's closing line (1-2 sentences, analytical)"
}}

Every line must be UNIQUE to this episode. Return ONLY the JSON."""

    raw = copilot_call(meta_prompt, timeout=45)
    meta = parse_llm_json(raw) if raw else None
    if not meta:
        meta = {
            "title": f"Episode {episode_number}: The RappterZoo Review",
            "intro_rapptr": f"Welcome to episode {episode_number}!",
            "intro_zookeeper": f"We've got {num_reviews} apps to review.",
            "outro_rapptr": "That's a wrap!",
            "outro_zookeeper": "The data doesn't lie.",
        }

    segments = []

    # Intro
    segments.append({"type": "intro", "host": "Rapptr", "text": meta.get("intro_rapptr", "")})
    segments.append({"type": "intro", "host": "ZooKeeper", "text": meta.get("intro_zookeeper", "")})

    # Milestone/meta commentary from lore
    milestone_lines = generate_milestone_dialogue(lore, episode_number, total_apps, rng)
    for line in milestone_lines:
        segments.append({"type": "intro", **line})

    # Reviews (each via LLM)
    for i, app in enumerate(review_apps):
        if i > 0:
            segments.append({"type": "transition", "host": "Rapptr",
                             "text": f"Alright, next up..."})

        dialogue = generate_review_dialogue(app, rng)

        lore_lines = generate_lore_dialogue(app, lore, episode_number, rng)
        if lore_lines:
            insert_at = min(2, len(dialogue))
            for j, line in enumerate(lore_lines):
                dialogue.insert(insert_at + j, line)

        segments.append({
            "type": "review",
            "app": {
                "title": app["title"], "file": app["file"],
                "category": app["category"], "folder": app["folder"],
                "path": app["path"], "url": app["url"],
                "score": app["score"], "grade": app["grade"],
                "playability": app["playability"], "tags": app["tags"],
                "description": app["description"], "community": app["community"],
            },
            "dialogue": dialogue,
        })

    # Roast segment
    if roast_app and roast_app["score"] < review_apps[0]["score"]:
        roast_dialogue = generate_roast_dialogue(roast_app, rng)
        segments.append({
            "type": "roast",
            "app": {
                "title": roast_app["title"], "file": roast_app["file"],
                "category": roast_app["category"], "folder": roast_app["folder"],
                "path": roast_app["path"], "url": roast_app["url"],
                "score": roast_app["score"], "grade": roast_app["grade"],
                "playability": roast_app["playability"], "tags": roast_app["tags"],
                "description": roast_app["description"], "community": roast_app["community"],
            },
            "dialogue": roast_dialogue,
        })

    # Outro
    segments.append({"type": "outro", "host": "Rapptr", "text": meta.get("outro_rapptr", "")})
    segments.append({"type": "outro", "host": "ZooKeeper", "text": meta.get("outro_zookeeper", "")})

    title = meta.get("title", f"Episode {episode_number}")
    duration = estimate_duration(segments)

    episode = {
        "id": f"ep-{episode_number:03d}",
        "number": episode_number,
        "title": title,
        "description": f"Rapptr and ZooKeeper review {num_reviews} apps — including {top_app['title'] if top_app else 'some favorites'}.",
        "frame": frame,
        "generated": datetime.now().isoformat(),
        "duration": duration,
        "audioFile": f"apps/broadcasts/audio/ep-{episode_number:03d}.wav",
        "segments": segments,
    }

    return episode


def generate_feed(frame=None, regenerate_all=False):
    """Generate or update the broadcast feed."""
    manifest = load_json(MANIFEST)
    rankings = load_json(RANKINGS)
    community = load_json(COMMUNITY)
    molter_state = load_json(MOLTER_STATE)

    if not manifest:
        print("ERROR: manifest.json not found")
        return None

    if frame is None:
        frame = molter_state.get("frame", 0) if molter_state else 0

    rankings_summary = rankings.get("summary", {}) if rankings else {}

    # Build unified app index
    index = build_app_index(manifest, rankings, community)
    log(f"Indexed {len(index)} apps")

    # Load existing feed or create new
    existing_feed = load_json(FEED_FILE) if not regenerate_all else None

    if existing_feed:
        episodes = existing_feed.get("episodes", [])
        next_number = max((e.get("number", 0) for e in episodes), default=0) + 1
    else:
        episodes = []
        next_number = 1

    # Seed RNG on frame + episode number for determinism
    seed = frame * 1000 + next_number
    rng = random.Random(seed)

    # Load lore tracker for continuity
    lore = load_lore()

    log(f"Generating episode {next_number} for frame {frame} (seed={seed})")
    log(f"Lore: {len(lore.get('reviewed_apps', {}))} apps tracked, {len(lore.get('episode_summaries', []))} past episodes")

    episode = generate_episode(index, rng, frame, next_number, rankings_summary, lore)
    if not episode:
        print("ERROR: No apps to generate episode from")
        return None

    # Update lore with this episode's data
    lore = update_lore(lore, episode)
    save_lore(lore)
    log(f"Lore updated: {lore['total_reviewed']} total reviews tracked")

    episodes.append(episode)

    feed = {
        "meta": {
            "showTitle": "RappterZooNation",
            "tagline": "Two hosts. 500+ games. Zero humans required.",
            "hosts": [
                {**HOSTS["Rapptr"], "name": "Rapptr"},
                {**HOSTS["ZooKeeper"], "name": "ZooKeeper"},
            ],
            "totalEpisodes": len(episodes),
            "generated": datetime.now().isoformat(),
        },
        "episodes": episodes,
    }

    # Write feed
    BROADCAST_DIR.mkdir(parents=True, exist_ok=True)
    with open(FEED_FILE, "w") as f:
        json.dump(feed, f, indent=2)

    log(f"Wrote {FEED_FILE} ({len(episodes)} episodes)")
    print(f"Generated episode {next_number}: {episode['title']}")
    print(f"  Duration: {episode['duration']}")
    print(f"  Segments: {len(episode['segments'])}")
    review_count = sum(1 for s in episode["segments"] if s["type"] == "review")
    print(f"  Reviews: {review_count} apps")

    return feed


def main():
    args = sys.argv[1:]

    frame = None
    regenerate_all = "--regenerate-all" in args

    for i, arg in enumerate(args):
        if arg == "--frame" and i + 1 < len(args):
            frame = int(args[i + 1])

    feed = generate_feed(frame=frame, regenerate_all=regenerate_all)

    if feed and "--push" in args:
        print("\nCommitting and pushing...")
        subprocess.run(["git", "add", str(FEED_FILE), str(LORE_FILE)], cwd=ROOT)
        subprocess.run(
            ["git", "commit", "-m", "chore: generate RappterZooNation episode"],
            cwd=ROOT,
        )
        subprocess.run(["git", "push"], cwd=ROOT)
        print("Pushed!")


if __name__ == "__main__":
    main()
