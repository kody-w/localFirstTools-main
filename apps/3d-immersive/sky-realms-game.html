<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sky Realms: Aether Wing</title>
    <meta name="description" content="A 3D rail shooter inspired by Star Fox 64. Master the Phase Shift mechanic to switch between physical and spectral realms, dodging asteroids and energy barriers.">
    <meta name="theme-color" content="#000000">
    <!--
    ============================================
    SKY REALMS: AETHER WING - EVOLUTION LOG
    ============================================
    Version: 1.92.0 (8-Strategy Round 92)
    Date: 2025-12-31

    ROUND 1 IMPROVEMENTS (8-Agent Consensus):
    1. High Score Persistence (Player Psychology) - localStorage saves
    2. Enhanced Screen Shake with Decay (Game Feel) - trauma-based system
    3. Optimized Bloom Pass (Performance) - reduced resolution, raised threshold

    ROUND 2 IMPROVEMENTS (8-Agent Consensus):
    4. Phase Shift Feedback Pulse (UX Polish) - visual confirmation animation
    5. Hit Pause / Frame Freeze (Game Feel) - brief freeze on impacts
    6. Combo Multiplier System (Player Psychology) - kill streaks increase score

    ROUND 3 IMPROVEMENTS (8-Agent Consensus):
    7. Reduced Motion Option (Accessibility) - prefers-reduced-motion support
    8. Laser Fire Sound Synthesis (Audio) - Web Audio API procedural sounds
    9. Near-Miss Bonus System (Psychology) - dodge rewards for close calls

    ROUND 4 IMPROVEMENTS (8-Agent Consensus):
    10. Phase Energy Low Warning (UX) - pulsing red glow at <20% energy
    11. Floating Damage Numbers (UX) - visual damage feedback popups
    12. Movement Easing System (Game Feel) - smooth acceleration/deceleration

    ROUND 5 IMPROVEMENTS (8-Agent Consensus):
    13. Loading State Feedback (UX) - loading screen with progress indicator
    14. Cached Box3 Collision Objects (Performance) - pre-allocated collision boxes
    15. Perfect Dodge System (Psychology) - bonus for phasing through obstacles

    ROUND 6 IMPROVEMENTS (8-Agent Consensus):
    16. Color Contrast Fixes (Accessibility) - WCAG AA compliant loading text
    17. Keyboard Focus Indicators (Accessibility) - visible focus rings for buttons
    18. Button Press Feedback (UX) - tactile :active state animation

    ROUND 7 IMPROVEMENTS (8-Agent Consensus):
    19. ARIA Live Region for Score (Accessibility) - screen reader announces changes
    20. ARIA Labels for HUD Elements (Accessibility) - semantic descriptions
    21. Combo Counter Pulse Animation (UX) - scale pulse on multiplier change

    ROUND 8 IMPROVEMENTS (8-Agent Consensus):
    22. Centralized Game Config (Code Architect) - all magic numbers in CONFIG
    23. Object Pool Bounds Check (Performance) - safer collision cache access
    24. Screen Shake Early Bailout (Performance) - skip calcs at zero trauma

    ROUND 9 IMPROVEMENTS (8-Agent Consensus):
    25. Material Caching (Performance) - one-time phase transition updates
    26. Error Boundary System (Code Architect) - resilient game loop
    27. Score Toast Notifications (UX) - celebration popups for kills/combos

    ROUND 10 IMPROVEMENTS (8-Agent Consensus):
    28. Dynamic Impact Sounds (Audio) - damage-scaled synthesis with punch
    29. Spatial Audio Panning (Audio) - 3D positional stereo panning
    30. Phase Transition Particles (Visual) - burst effects on phase shift

    ROUND 11 IMPROVEMENTS (8-Agent Consensus):
    31. Momentum Bar & Velocity Viz (Game Feel) - HUD speed indicator with gradient
    32. Camera Zoom on Impact (Game Feel) - dynamic camera punch on damage
    33. Adaptive Quality Scaling (Performance) - FPS-based auto quality adjustment

    ROUND 12 IMPROVEMENTS (8-Agent Consensus):
    34. Color Contrast for HUD Labels (Accessibility) - WCAG AA compliant labels
    35. Memoize DOM Element Queries (Performance) - cached DOM references
    36. Tab Navigation for Buttons (Accessibility) - keyboard focus management

    ROUND 13 IMPROVEMENTS (8-Agent Consensus):
    37. Circular Buffer for Frame Times (Performance) - eliminates array thrashing
    38. Extended DOM_CACHE Coverage (Performance) - cached damage overlay, phase indicator
    39. Haptic Feedback via Vibration API (Game Feel) - tactile impact confirmation

    ROUND 14 IMPROVEMENTS (8-Agent Consensus):
    40. Haptic on Load/Start Completion (Game Feel) - tactile transition feedback
    41. Spawn/Difficulty CONFIG Migration (Architecture) - consolidated magic numbers
    42. Combo Decay Warning System (Psychology) - visual/audio warning before timeout

    ROUND 15 IMPROVEMENTS (8-Agent Consensus):
    43. Phase Energy Regen Pulse (Game Feel) - CSS pulse showing recharge tempo
    44. Score Multiplier Tier Recolor (Visual) - combo display colors by tier
    45. Kill Streak Toast Escalation (UX) - growing/coloring toasts for multi-kills

    ROUND 16 IMPROVEMENTS (8-Agent Consensus):
    46. Score Multiplier Countdown Timer (UX) - visible seconds remaining until decay
    47. Shield Depletion Flicker (Game Feel) - red screen flicker at critical health
    48. Skip-to-Game Button (Accessibility) - keyboard-accessible skip link

    ROUND 17 IMPROVEMENTS (8-Agent Consensus):
    49. Hit Pause Audio Cue (Audio) - descending beep during freeze-frame moments
    50. Combo Milestone Audio Flourish (Audio) - ascending melodic sequence on tier up
    51. Near-Miss Combo Extender (Psychology) - dodging obstacles resets combo timer

    ROUND 18 IMPROVEMENTS (8-Agent Consensus):
    52. Text Label Alternatives (Accessibility) - ARIA labels with percentages on bars
    53. Difficulty Tension Feedback (Psychology) - threat level indicator on HUD
    54. Critical Status ARIA Alerts (Accessibility) - announce critical events

    ROUND 19 IMPROVEMENTS (8-Agent Consensus):
    55. Near-Miss Proximity Pulse Audio (Game Feel) - wobble tone on close dodges
    56. Session Arc Scaling (Psychology) - dynamic difficulty pacing by session phase
    57. Shield Depletion Gradient Vignette (Visual) - progressive edge darkening at low health

    ROUND 20 IMPROVEMENTS (8-Agent Consensus):
    58. Geometry Disposal on Despawn (Performance) - explicit cleanup prevents GPU memory leaks
    59. Crosshair Cooldown Pulse Ring (UX) - visual firing readiness indicator
    60. Procedural Health Warning Pulse (Audio) - escalating heartbeat at low shield

    ROUND 21 IMPROVEMENTS (8-Agent Consensus):
    61. Shield Depletion Rumble Escalation (Game Feel) - escalating haptic feedback as health drops
    62. Momentum Cascade Reward (Psychology) - bonus points for sustained high velocity
    63. Frustum Culling Enable (Performance) - skip rendering off-screen objects

    ROUND 22 IMPROVEMENTS (8-Agent Consensus):
    64. Phase-Linked Fog Shift (Visual) - animated fog color transitions based on phase state
    65. Near-Miss Shield Flash (Game Feel) - brief shield flash visual on close dodges
    66. Colorblind Mode (Accessibility) - deuteranopia-friendly color scheme toggle

    ROUND 23 IMPROVEMENTS (8-Agent Consensus):
    67. Reticle Breath-Zoom on Input (Game Feel) - scale reticle when movement active
    68. Combo Kill Shake Intensity Scaling (Game Feel) - camera punch scales with combo
    69. Threat Indicator Anchor Stabilization (UX) - flex-based centering eliminates jitter

    ROUND 24 IMPROVEMENTS (8-Agent Consensus):
    70. Canvas Accessibility Role (Accessibility) - role="img" and aria-label on renderer
    71. Toast Exit Stagger Animation (UX) - cascade fadeOut timing for multiple toasts
    72. Threat Indicator Conditional Class Swap (Performance) - only update when changed

    ROUND 25 IMPROVEMENTS (8-Agent Consensus):
    73. Toast Event Announcements to SR (Accessibility) - route toast messages to aria-alert region
    74. Phase Transition Scene Saturation Dip (Visual) - momentary desaturation during phase shift
    75. Pause/Resume with SR Announcements (Accessibility) - ESC key pause with aria-live feedback

    ROUND 26 IMPROVEMENTS (8-Agent Consensus):
    76. HUD Breathing Idle State (Visual) - subtle opacity pulse on passive HUD elements
    77. Directional Screen Shake Tilt (Game Feel) - screen shake offset in damage direction
    78. Shield State Gradient Bar (Visual) - continuous color gradient from blue to red as health drops

    ROUND 27 IMPROVEMENTS (8-Agent Consensus):
    79. Firing Recoil & Camera Pull (Game Feel) - camera pullback and reticle pulse on weapon fire
    80. Phase Recharge Audio Chirps (Audio) - ascending sine chirp every 500ms while recharging
    81. Progressive Mastery Unlocking (Psychology) - persistent milestone badges with endowment effect

    ROUND 28 IMPROVEMENTS (8-Agent Consensus):
    82. Dynamic ARIA Combo Labels (Accessibility) - tier-aware labels with count and progression announcements
    83. Memoized Shield Color Calculation (Performance) - cache gradient computations for shield bar
    84. Combo Grace Period System (Psychology) - brief forgiveness window on combo tier-down

    ROUND 29 IMPROVEMENTS (8-Agent Consensus):
    85. Lazy Threat Level Computation (Performance) - memoize threat calc until enemy count changes
    86. Threat Indicator Color Smoothing (UX) - CSS transitions for fluid threat level color changes
    87. Projectile Trail & Impact Flash (Visual) - glowing trails on lasers, spark burst on collision

    ROUND 30 IMPROVEMENTS (8-Agent Consensus):
    88. Reticle Convergence on Firing (UX) - crosshair tightens inward during weapon fire
    89. Weapon Heat Glow Aura (Visual) - engine glow intensifies with continuous firing
    90. Harmonic Series Descent (Audio) - descending tones on shield depletion

    ROUND 31 IMPROVEMENTS (8-Agent Consensus):
    91. Update Function Throttling (Performance) - skip UI updates when values unchanged
    92. Combo Tier Ring Pulse (UX) - expanding ring animation on combo tier milestone
    93. Enemy Defeat Sparkle Burst (Visual) - cascading sparkle particles on kills

    ROUND 32 IMPROVEMENTS (8-Agent Consensus):
    94. Shield Damage Crack Overlay (Visual) - cracked glass effect on low health hits
    95. Daily Challenge Streak Counter (Psychology) - localStorage streak tracking with milestones
    96. Skip to Controls Link (Accessibility) - focus-visible skip link with controls panel

    ROUND 33 IMPROVEMENTS (8-Agent Consensus):
    97. Semantic Main Element Wrapper (Accessibility) - <main> landmark for screen reader navigation
    98. Session Narrative Checkpoints (Psychology) - time-based story milestones (30s/60s/120s)
    99. Projectile Velocity Visual Onion Layers (Game Feel) - velocity rings on projectiles

    ROUND 34 IMPROVEMENTS (8-Agent Consensus):
    100. Game Over Defeat Fanfare (Audio) - descending harmonic cascade with rumble
    101. Rotational Camera Impact (Game Feel) - camera roll on lateral damage
    102. Momentum Mastery Quest Chain (Psychology) - velocity-based challenge badges

    ROUND 35 IMPROVEMENTS (8-Agent Consensus):
    103. Inert Attribute for Background Content (Accessibility) - prevents AT focus leak during modals
    104. Perfect Dodge Achievement Chime (Audio) - major third chord with bell decay
    105. Momentum Dependency Feedback Ring (Game Feel) - velocity status ring around reticle

    ROUND 36 IMPROVEMENTS (8-Agent Consensus):
    106. Health/Shield Threshold Warning Glow (Visual) - pulsing CSS glow when critical (<30%)
    107. Reticle Trail Afterimage (Game Feel) - fading ghost-reticles during movement
    108. Dynamic Game State Announcement (Accessibility) - aria-live region for game mode changes

    ROUND 37 IMPROVEMENTS (8-Agent Consensus):
    109. Narrative Comeback Escalation (Psychology) - "AGAINST ALL ODDS" bonus at critical health
    110. Frosted-Glass HUD Panels (Visual) - backdrop-filter blur for depth hierarchy
    111. Geometry Reuse for Impact Flash (Performance) - cached SphereGeometry for impacts

    ROUND 38 IMPROVEMENTS (8-Agent Consensus):
    112. Comeback Audio Fanfare (Audio) - triumphant rising arpeggio on critical kills
    113. Weapon Recoil Knockback (Game Feel) - velocity damping for "gun weight" feel
    114. Enemy Death Dissolution (Visual) - fade/shrink/wireframe death animation

    ROUND 39 IMPROVEMENTS (8-Agent Consensus):
    115. Weapon Charge-Up Spin Effect (Game Feel) - ascending synth tone + reticle acceleration
    116. High-Pass Filter Critical Health (Audio) - BiquadFilter emphasis during low shield
    117. Fragile Victory Adrenaline (Psychology) - 1.1-1.35x score bonus for kills at 40-60% shield

    ROUND 40 IMPROVEMENTS (8-Agent Consensus):
    118. Shield Regeneration Prediction (UX) - timeline showing when shield reaches 50%/75%/100%
    119. Second Wind Comeback Threshold (Psychology) - 2-sec invulnerability grace at first critical
    120. Audio Event Captions Panel (Accessibility) - visual captions for all audio synthesis events

    ROUND 41 IMPROVEMENTS (8-Agent Consensus):
    121. Combo Tier Letter-Spacing Escalation (Visual) - typography rhythm with progressive spacing
    122. Game State Color Grading via CSS Filters (Visual) - distinct color treatments per game state
    123. Enemy Projectile Tracer Glow (Game Feel) - visual trails and impact effects on enemy lasers

    ROUND 42 IMPROVEMENTS (8-Agent Consensus):
    124. Hit Impact Camera Shake (Game Feel) - camera displacement on successful hits scales with damage
    125. Velocity Signature Playstyle Profile (Psychology) - detect/announce player flying style at checkpoints
    126. Enemy Threat Tier Silhouette Glow (Visual) - color-coded outer glow distinguishing enemy threat levels

    ROUND 43 IMPROVEMENTS (8-Agent Consensus):
    127. Billboard Glow Simplification (Performance) - replace sphere glow meshes with billboard planes
    128. Multi-Hit Spark Spray Feedback (Game Feel) - spawn spark particles on sustained laser contact
    129. Cognitive Load Simple HUD Mode (Accessibility) - toggle to hide non-essential UI elements

    ROUND 44 IMPROVEMENTS (8-Agent Consensus):
    130. Velocity Ring Asymmetric Opacity (Visual) - outer rings persist longer for velocity shadow effect
    131. Streak Recovery Window UI (Psychology) - visual 3s countdown showing combo grace period
    132. Enemy Kill Zoom Spike (Game Feel) - camera zoom + sparkle burst on enemy death

    ROUND 45 IMPROVEMENTS (8-Agent Consensus):
    133. Mission Starting Toast (UX) - explicit confirmation toast after tutorial completion
    134. Hit Spark Color Rebalancing (Visual) - warm gold #ffcc00 instead of harsh yellow
    135. Enemy Shake at Dissolution Start (Game Feel) - brief shake sequence on death trigger

    ROUND 46 IMPROVEMENTS (8-Agent Consensus):
    136. Combo Multiplier Tabular Nums (UX) - font-variant-numeric prevents layout shift
    137. Game Over Result Announcement (Accessibility) - aria announcement of final score/outcome
    138. Bloom Strength Phase-State Modulation (Visual) - enhanced bloom in spectral phase

    ROUND 47 IMPROVEMENTS (8-Agent Consensus):
    139. Combo Tier Name Progression (Psychology) - Novice→Adept→Veteran→Master→Ascendant→Legendary→Mythic→Godlike names
    140. aria-expanded for Toggle Buttons (Accessibility) - modal state properly communicated to assistive tech
    141. Velocity-Based Screen Blur Effect (Game Feel) - subtle motion blur at high speeds for immersion

    ROUND 48 IMPROVEMENTS (8-Agent Consensus):
    142. Keyboard Shortcut Announcement (Accessibility) - announce H/J/Escape shortcuts at game start
    143. Collision Knockback Push (Game Feel) - camera z-offset push-back on collision impact
    144. Dimensional Depth Vignette (Visual) - dynamic edge darkening at high velocity for immersion

    ROUND 49 IMPROVEMENTS (8-Agent Consensus):
    145. Combo Tier Milestone Glow (UX) - radial golden glow burst on tier threshold transitions
    146. Resizable HUD Font Size (Accessibility) - CSS custom property for HUD text scaling
    147. Recovery Checkpoint Celebration (Psychology) - celebration effect when shield recovers from critical

    ROUND 50 IMPROVEMENTS (8-Agent Consensus):
    148. Perfect Dodge Temporal Echo (Game Feel) - 50ms delayed ghost chirp on frame-perfect phase dodge
    149. Semantic Heading Hierarchy (Accessibility) - proper section structure for game state screens
    150. Phase Energy Depleted Tone (Audio) - descending tone feedback when phase energy bottoms out

    ROUND 51 IMPROVEMENTS (8-Agent Consensus):
    151. Comeback Bonus HUD Indicator (Player Psychology) - visible pulsing indicator shows active comeback multiplier
    152. Reduce Impact Zoom Recovery Time (Game Feel) - snappier zoom-out from 0.2s to 0.15s
    153. Modal Panel Fade Transition (UX Polish) - smooth opacity transition for controls reference panel

    ROUND 52 IMPROVEMENTS (8-Agent Consensus):
    154. Cubic Bezier Easing for Firing Feedback (Game Feel) - refined easing curve for reticle convergence animation
    155. Modernize sr-only to clip-path (Accessibility) - update deprecated clip to modern clip-path for screen readers
    156. Close Button Visual Hierarchy Enhancement (UX) - hover/focus states for controls panel close button

    ROUND 53 IMPROVEMENTS (8-Agent Consensus):
    157. Unified Button Focus Ring System (UX) - consistent focus-visible styling across all interactive elements
    158. Staggered HUD Entrance Animation (Visual) - sequential scale+fade animations for HUD elements on game start
    159. Audio Attack-Time Quantization (Audio) - standardized attack/decay timing config for rhythm coherence

    ROUND 54 IMPROVEMENTS (8-Agent Consensus):
    160. Button Press Depth Feedback (UX) - inset shadow and translateY for tactile press-into-surface effect
    161. Loading Bar Color Transition (UX) - cyan-to-green transition at completion with celebratory glow
    162. Fragile Victory Feedback Intensity Scaling (Psychology) - enhanced shake/haptic proportional to danger level

    ROUND 55 IMPROVEMENTS (8-Agent Consensus):
    163. Smooth Weapon Heat Glow Animation (Game Feel) - 50ms lerp easing for heat glow transitions
    164. Enemy Kill Feedback Timing Alignment (Psychology) - delayed dissolution for sparkle visibility
    165. Threat Tier Glow Color Coherence (Visual) - perceptually uniform danger color spectrum

    ROUND 56 IMPROVEMENTS (8-Agent Consensus):
    166. Dynamic Range Compression on Master (Audio) - compressor prevents clipping during intense moments
    167. Smooth Bloom Intensity Transitions (Visual) - lerp-based bloom state changes for fluid atmosphere
    168. Volatile Mini-Achievement Surprises (Psychology) - rare random micro-rewards trigger dopamine spikes

    ROUND 57 IMPROVEMENTS (8-Agent Consensus):
    169. Screen Shake Directional Bias Interpolation (Game Feel) - trauma-scaled direction clarity (10-50%)
    170. Haptic-Trauma Synchronization Offset (Game Feel) - 18ms delay aligns tactile with visual peak
    171. Directional Light Intensity Ramping (Visual) - phase-aware dim/bright transitions

    ROUND 58 IMPROVEMENTS (8-Agent Consensus):
    172. Enemy Direction Vector Caching (Performance) - reuse temp vector to reduce GC pressure
    173. Threat Glow Color Perceptual Uniformity (Visual) - lighter weak glow for visibility parity
    174. Reticle Cubic-Bezier Snappy Easing (Game Feel) - ease-out-quint curve for responsive feel

    ROUND 59 IMPROVEMENTS (8-Agent Consensus):
    175. Reticle Inner Convergence Easing Harmony (Game Feel) - cubic-bezier matches outer for unified gesture
    176. Warm Ambient Light Cast Enhancement (Visual) - slate-blue cast for aether atmosphere
    177. Heartbeat Release Acceleration (Audio) - urgency-scaled release for snappier cardio effect

    ROUND 60 IMPROVEMENTS (8-Agent Consensus):
    178. For-Loop Collision Early-Exit (Performance) - backwards iteration with continue for efficiency
    179. Combo Grace Period Forgiveness Toast (Psychology) - visible recovery feedback with haptic safety pulse
    180. Sparkle Burst Fade Curve Softening (Visual) - ease-out pow(0.7) for elegant particle dissipation

    ROUND 61 IMPROVEMENTS (8-Agent Consensus):
    181. Reduced Motion Loading Pulse (Accessibility) - already implemented via CSS override at line 1378
    182. Cache Frame Timestamp (Performance) - single Date.now() call reused across entire frame
    183. Sparkle Phase Color Harmony (Visual) - cyan sparkles in spectral, gold in material realm

    ROUND 62 IMPROVEMENTS (8-Agent Consensus):
    184. Comeback Multiplier Visual Anchor (Psychology) - enhanced glow background and pulsing box-shadow
    185. Near-Miss Grace Seconds Feedback (Psychology) - "SAVE IT! Xs" countdown during grace period
    186. Firing Recoil Knockback Visual (Game Feel) - subtle camera rotation kickback during weapon recoil

    ROUND 63 IMPROVEMENTS (8-Agent Consensus):
    187. Firing Feedback Synchronization (Game Feel) - unified 0.1s timing for all reticle firing animations
    188. Game Over Score Transition Animation (UX) - 1.2s scale/opacity reveal on final and high score display
    189. Grace Period Countdown Audio Pulse (Psychology) - ascending frequency beeps during combo save window

    ROUND 64 IMPROVEMENTS (8-Agent Consensus):
    190. Firing Feedback Peak Timing Unification (Game Feel) - camera zoom and recoil timeouts unified to 100ms
    191. Velocity Ring Opacity Skip (Performance) - skip math for fully faded rings to reduce CPU overhead
    192. Attack-Time Quantization Config Usage (Audio) - use AUDIO_CONFIG.attackTimeSoft for rhythm coherence

    ROUND 65 IMPROVEMENTS (8-Agent Consensus):
    193. Camera Zoom Impact Asymmetry (Game Feel) - faster snap-back (18) vs slower recoil (6) for weight
    194. Pre-Grace Psychological Anchor (Psychology) - activate grace period 50ms earlier for preparation

    ROUND 66 IMPROVEMENTS (8-Agent Consensus):
    195. Heartbeat Release Urgency Audio (Psychology) - 0.7x release at max danger for visceral pulse
    196. Controls Panel Entrance Scale (UX) - 0.92→1 scale animation on modal for premium feel
    197. Fragile Victory Toast Sync (Psychology) - 150ms delay to align reward with camera shake peak

    ROUND 67 IMPROVEMENTS (8-Agent Consensus):
    198. HUD Glow Depth Layering (Visual) - enhanced box-shadow with inset highlights for visual hierarchy
    199. Heartbeat AUDIO_CONFIG Coherence (Audio) - standardized decayTimeShort for rhythm consistency
    200. Bar Fill Interpolation Smoothing (UX) - cubic-bezier easing at 0.15s for organic feel

    ROUND 68 IMPROVEMENTS (8-Agent Consensus):
    201. Velocity Easing Responsiveness (Game Feel) - 0.15→0.18 for snappier input response
    202. Combo Pulse Timing Tightness (UX) - 0.25s spring curve for punchier feedback
    203. Combo Grace Warning Sync (Psychology) - 1500→1700ms for better grace period continuity

    ROUND 69 IMPROVEMENTS (8-Agent Consensus):
    204. Mastery Haptic Celebration (Psychology) - escalating pulse pattern for rare achievement
    205. Firing Convergence Sync (Game Feel) - 0.05s→0.1s to match outer for pixel-perfect feedback
    206. Comeback Glow Enhancement (UX) - layered halo with 28px/40px glow at peak

    ROUND 70 IMPROVEMENTS (8-Agent Consensus):
    207. Enemy Loop Date.now() Cache (Performance) - eliminates 90+ syscalls per frame
    208. Shield Bar 4-Stop Gradient (Visual) - smoother damage progression perception
    209. LFO Depth Normalization (Audio) - 25Hz→6.5Hz, 80Hz→35Hz for subtle wobble

    ROUND 71 IMPROVEMENTS (8-Agent Consensus):
    210. Heartbeat Release Scale Fix (Audio) - clearer urgency formula documentation
    211. Float32Array Particle Pre-alloc (Performance) - eliminates array GC pressure
    212. Echo Frequency Harmonic (Audio) - 1200Hz→988.5Hz creates Cmaj7 consonance

    ROUND 72 IMPROVEMENTS (8-Agent Consensus):
    213. Impact Zoom Before Effects (Game Feel) - 0ms latency zoom on kill
    214. Phase Transition 700ms→500ms (Game Feel) - aligns with SFX duration
    215. Loading Bar Completion Glow (UX) - celebration pulse animation

    ROUND 73 IMPROVEMENTS (8-Agent Consensus):
    216. Charge Spin 200ms→140ms (Game Feel) - snappier burst fire rhythm
    217. Grace Period Message Reframe (Psychology) - agency-focused "SAFE ZONE" wording
    218. Input Responsiveness 0.18→0.22 (Game Feel) - crispier directional response

    ROUND 74 IMPROVEMENTS (8-Agent Consensus):
    219. Reticle Breath Easing Animation (Game Feel) - bouncy 0.15s spring transition
    220. Damage-Scaled Hit Freeze Variance (Game Feel) - freeze scales 1-8 frames by damage
    221. Combo Tier Progress Indicator (Psychology) - shows kills remaining to next tier

    ROUND 75 IMPROVEMENTS (8-Agent Consensus):
    222. Collision Damage Constants (Code) - CONFIG.collisionDamage for centralized tuning
    223. Button Hover Scale Stabilization (UX) - 1.05x micro-scale on hover for feedback hierarchy
    224. Combo Milestone Frequency Snap (Audio) - 2% pitch overshoot creates "arrival" precision

    ROUND 76 IMPROVEMENTS (8-Agent Consensus):
    225. Colorblind Toggle Focus-Visible (Accessibility) - keyboard focus ring for accessibility toggle
    226. Combo Milestone Volume Leveling (Audio) - frequency-compensated gain for equal loudness
    227. Shield Bar Gradient Unity (Visual) - HSL-aware color stops for perceptual uniformity

    ROUND 77 IMPROVEMENTS (8-Agent Consensus):
    228. Tutorial Title Contrast (Accessibility) - text-shadow for WCAG AA contrast enhancement
    229. Near-Miss Multiplier Display (Psychology) - show combo multiplier in near-miss feedback
    230. New High Score Glow Animation (UX) - pulsing text-shadow glow for celebration

    ROUND 78 IMPROVEMENTS (8-Agent Consensus):
    231. Dynamic Toggle State Labels (Accessibility) - aria-label updates announcing enabled/disabled state
    232. Directional Impact Flash (Game Feel) - radial flash from damage direction for spatial feedback
    233. Modal Focus Trap (Accessibility) - keyboard focus trapped within controls dialog

    ROUND 79 IMPROVEMENTS (8-Agent Consensus):
    234. Directional Friction Asymmetry (Game Feel) - backward momentum decelerates 15% faster for weight feel
    235. Immediate Pause Alert (Accessibility) - force-reflow for instant screen reader announcement
    236. Loss Amplification Framing (Psychology) - reframe near-miss as "DAMAGE AVOIDED" for stronger impact

    ROUND 80 IMPROVEMENTS (8-Agent Consensus):
    237. Phase Fog Color Transitions (Visual) - distinct dark-cyan fog for spectral phase vs pure black material
    238. Variable Ratio Mini-Rewards (Psychology) - random point bonus every 3-7 kills for engagement
    239. Opacity-Skipped Ring Update (Performance) - skip ring math when opacity below 0.05 threshold

    ROUND 81 IMPROVEMENTS (8-Agent Consensus):
    240. Cache Enemy Laser Geometry (Performance) - shared geometry eliminates per-shot allocation
    241. Screen Shake Trauma Decay Asymmetry (Game Feel) - snappier recovery at low trauma for percussive feel
    242. Grace Period Anticipatory Toast (Psychology) - announcement before state change for endowment effect

    ROUND 82 IMPROVEMENTS (8-Agent Consensus):
    243. Screen Shake Decay Smoothing (Game Feel) - smooth polynomial curve instead of step function for natural falloff
    244. Button Feedback Timing Standardization (UX) - 0.12s active transition for consistent tactile feel
    245. HUD Breathing Combat Suppression (UX) - pause breathing animation during rapid combat updates

    ROUND 83 IMPROVEMENTS (8-Agent Consensus):
    246. Master Filter Chain Routing (Audio) - route all sounds through criticalHealthFilter for dynamics stability
    247. Enemy Hit Confirmation Audio Tone (Game Feel) - 80ms descending tone on hit for audio-visual closure
    248. Focus Ring Smooth Entrance (UX) - 0.15s ease-out transition for polished keyboard navigation

    ROUND 84 IMPROVEMENTS (8-Agent Consensus):
    249. Fog Density Phase Modulation (Visual) - spectral phase increases fog density 0.015→0.022 for ethereal separation
    250. Array Capacity Guardian for Memory Safety (Code) - COLLISION_CACHE max-size check prevents unbounded growth
    251. Critical Shield Boundary Anchor (Psychology) - audio tone at exactly 50% shield triggers loss aversion response

    ROUND 85 IMPROVEMENTS (8-Agent Consensus):
    252. Threat Level Category ARIA Mapping (Accessibility) - dynamic aria-label maps threat colors to semantic descriptions
    253. Near-Miss Shield Pulse Tint (Psychology) - shield bar cyan flash on close dodge amplifies relief emotion
    254. Toggle State Eased Transition (UX) - smooth 0.15s transition on colorblind/caption toggle activation

    ROUND 86 IMPROVEMENTS (8-Agent Consensus):
    255. Directional Light Color Temperature Shift (Visual) - warm 2800K material phase / cool 7000K spectral phase lighting
    256. Consolidated Reflow Triggers (Performance) - batch class operations with single offsetWidth reflow
    257. Trauma-Scaled Roll Intensity (Game Feel) - impactRoll scales with trauma^1.5 for coherent spatial feedback

    ROUND 87 IMPROVEMENTS (8-Agent Consensus):
    258. prefers-reduced-motion Bar Fill Animations (Accessibility) - instant width transitions for vestibular sensitivity
    259. Reticle Kill Confirmation Pulse (Game Feel) - scale 1→1.4→0.85 animation on enemy defeat
    260. Colorblind Toggle State Persistence Indicator (UX) - green glow pulse confirms restored preference

    ROUND 88 IMPROVEMENTS (8-Agent Consensus):
    261. Bar Fill State Color Indicator (UX) - cyan left border accent signals 100% full state contrast
    262. Shield Regeneration Pulse Tempo Variance (Game Feel) - chirp rate accelerates 500ms→350ms as energy fills
    263. Nested Glow Aura Rings for Threat Tiers (Visual) - inner 0.8x pulsing + outer 1.4x static layered rings

    ROUND 89 IMPROVEMENTS (8-Agent Consensus):
    264. Threat Indicator Numeric Display (UX) - enemy count badge shows exact hostile count
    265. Negative Space Audio Silence Punctuation (Psychology) - 80ms master gain dip on kills creates impact punch
    266. Phase Transition Bloom Pulse Asymmetry (Visual) - instant 1.5x bloom spike with slow decay on phase shift

    ROUND 90 IMPROVEMENTS (8-Agent Consensus):
    267. Cache Threat Count/Level Spans in DOM_CACHE (Performance) - eliminates querySelector calls per frame
    268. ARIA-Label for Threat Count Description (Accessibility) - dynamic "Active enemies: N" announcement
    269. Velocity Ring Bloom Threshold (Game Feel) - bloom pulse on crossing 60% velocity threshold

    ROUND 91 IMPROVEMENTS (8-Agent Consensus):
    270. Loss Mitigation Value Messaging (Psychology) - shows "MITIGATED: XX DMG" with actual damage avoided
    271. Threat-Level Text Letter-Spacing Emphasis (UX) - wider spacing at higher threat tiers
    272. Velocity Threshold Constants Consolidation (Code) - extracted 0.6 magic number to CONFIG

    ROUND 92 IMPROVEMENTS (8-Agent Consensus):
    273. Phantom Threat Audio Cue (Psychology) - subtle directional chirps when enemies are off-screen
    274. Directional Impact Bloom Flash (Game Feel) - hemisphere-aware bloom spike on damage direction
    275. Gradient Bar Endpoint Labels (UX) - subtle 0/100 labels at status bar endpoints
    ============================================
    -->
    <style>
        /* v1.49.0: Resizable HUD Font Size (Accessibility Advocate) */
        :root {
            --hud-font-scale: 1;
        }
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
            transition: filter 0.35s ease-out;
        }
        /* v1.25.0: Phase Transition Scene Saturation Dip (Visual Designer) */
        body.phase-transitioning {
            filter: saturate(0.3);
        }
        /* v1.41.0: Game State Color Grading via CSS Filters (Visual Designer) */
        body.state-start {
            filter: hue-rotate(-10deg) saturate(1.15);
            transition: filter 0.8s ease-in-out;
        }
        body.state-gameplay {
            filter: none;
            transition: filter 0.5s ease-out;
        }
        body.state-gameover-victory {
            filter: hue-rotate(60deg) saturate(1.2) brightness(1.05);
            transition: filter 0.8s ease-in-out;
        }
        body.state-gameover-defeat {
            filter: hue-rotate(270deg) saturate(0.7) contrast(0.95);
            transition: filter 0.8s ease-in-out;
        }
        @media (prefers-reduced-motion: reduce) {
            body.state-start,
            body.state-gameplay,
            body.state-gameover-victory,
            body.state-gameover-defeat { transition: none; }
        }
        /* v1.47.0: Velocity-Based Screen Blur Effect (Game Feel Expert) */
        body.velocity-blur {
            filter: blur(1.2px);
            transition: filter 0.15s ease-out;
        }
        body.velocity-blur.state-gameplay {
            filter: blur(1.2px); /* Override state-gameplay filter */
        }
        @media (prefers-reduced-motion: reduce) {
            body.velocity-blur { filter: none; transition: none; }
        }
        /* v1.48.0: Dimensional Depth Vignette (Visual Designer) */
        body.velocity-vignette::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 9999;
            background: radial-gradient(ellipse at center, transparent 40%, rgba(0, 0, 0, 0.5) 100%);
            opacity: 0;
            transition: opacity 0.2s ease-out;
        }
        body.velocity-vignette.vignette-active::before {
            opacity: 1;
        }
        @media (prefers-reduced-motion: reduce) {
            body.velocity-vignette::before { display: none; }
        }
        /* v1.25.0: Pause/Resume Visual Indicator (Accessibility) */
        body.game-paused::after {
            content: 'PAUSED - Press ESC to Resume';
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            padding: 30px 60px;
            font-size: 28px;
            font-weight: bold;
            border: 3px solid #00ffff;
            border-radius: 12px;
            text-shadow: 0 0 20px #00ffff;
            z-index: 10000;
            pointer-events: none;
        }
        /* v1.26.0: HUD Breathing Idle State (Visual Designer) */
        @keyframes hudBreathing {
            0%, 100% { opacity: 0.9; }
            50% { opacity: 1; }
        }
        .hud-breathing {
            animation: hudBreathing 2.5s ease-in-out infinite;
        }
        /* v1.82.0: HUD Breathing Combat Suppression (UX) - pause during rapid updates */
        .hud-combat-active {
            animation-play-state: paused !important;
            opacity: 1 !important;
        }
        /* v1.53.0: Staggered HUD Entrance Animation (UX Polish) */
        @keyframes hudEnter {
            0% { opacity: 0; transform: scale(0.9) translateY(-5px); }
            100% { opacity: 1; transform: scale(1) translateY(0); }
        }
        .hud-enter { animation: hudEnter 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards; }
        .hud-enter-delay-1 { animation-delay: 0.05s; }
        .hud-enter-delay-2 { animation-delay: 0.1s; }
        @media (prefers-reduced-motion: reduce) {
            body { transition: none; }
            body.phase-transitioning { filter: none; }
            .hud-breathing { animation: none; opacity: 1; }
            .hud-enter { animation: none; opacity: 1; transform: none; }
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }
        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }
        .hud-bottom {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
        }
        .bar-container {
            width: 300px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #fff;
            border-radius: 4px;
            margin-bottom: 10px;
            position: relative;
            transform: skewX(-15deg);
            /* v1.37.0: Frosted-Glass HUD Panels (Visual Designer) */
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            background: rgba(10, 10, 30, 0.6);
            border-color: rgba(255, 255, 255, 0.3);
            /* v1.67.0: Enhanced depth layering for visual hierarchy (Visual Designer) */
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5), inset 0 1px 2px rgba(255, 255, 255, 0.15), inset 0 -2px 6px rgba(0, 0, 0, 0.3);
        }
        .bar-label {
            position: absolute;
            left: 10px;
            top: -25px;
            color: #fff;
            font-weight: bold;
            text-transform: uppercase;
            font-size: 14px;
            text-shadow: 0 0 5px rgba(0,0,0,0.8);
            transform: skewX(15deg);
        }
        .bar-fill {
            height: 20px;
            width: 100%;
            /* v1.67.0: Organic easing for smoother bar feel (UX Polish Specialist) */
            transition: width 0.15s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        /* v1.92.0: Gradient Bar Endpoint Labels (UX Polish) */
        .bar-endpoint {
            font-size: 9px;
            opacity: 0.4;
            color: rgba(255, 255, 255, 0.6);
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            font-family: monospace;
            pointer-events: none;
        }
        .bar-endpoint-min { left: -14px; }
        .bar-endpoint-max { right: -18px; }
        /* v1.88.0: Bar Fill State Color Indicator (UX Polish) */
        .bar-fill.bar-full {
            border-left: 3px solid #00ffff;
            box-shadow: -2px 0 8px rgba(0, 255, 255, 0.5);
        }
        /* v1.76.0: Perceptually uniform 4-stop gradient with HSL-aware transitions (Visual) */
        #shield-bar { background: linear-gradient(90deg, #ff1a1a 0%, #ff4d4d 35%, #ff8833 70%, #ffaa33 100%); }
        #phase-bar { background: linear-gradient(90deg, #00ffff, #0088ff); }

        /* v1.36.0: Health/Shield Threshold Warning Glow (Visual Designer) */
        @keyframes barCriticalPulse {
            0%, 100% { box-shadow: 0 0 8px rgba(255, 51, 51, 0.6); }
            50% { box-shadow: 0 0 20px rgba(255, 51, 51, 1), 0 0 30px rgba(255, 0, 0, 0.5); }
        }
        #shield-bar.bar-critical {
            animation: barCriticalPulse 0.5s ease-in-out infinite;
            border: 1px solid rgba(255, 100, 100, 0.8);
        }
        @media (prefers-reduced-motion: reduce) {
            #shield-bar.bar-critical {
                animation: none;
                box-shadow: 0 0 15px rgba(255, 51, 51, 0.8);
            }
        }

        /* v1.85.0: Near-Miss Shield Pulse Tint (Player Psychology) */
        @keyframes nearMissTint {
            0% { box-shadow: 0 0 30px #00ffff, inset 0 0 20px rgba(0, 255, 255, 0.5); }
            100% { box-shadow: none; }
        }
        #shield-bar.near-miss-flash {
            animation: nearMissTint 0.5s ease-out forwards;
        }

        .score-box {
            text-align: right;
            color: #fff;
            text-shadow: 0 0 10px #00ffff;
            /* v1.37.0: Frosted-Glass HUD Panels (Visual Designer) */
            padding: 12px 16px;
            background: rgba(10, 10, 30, 0.6);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        /* v1.49.0: Uses --hud-font-scale for resizable HUD (Accessibility) */
        #score-display {
            font-size: calc(48px * var(--hud-font-scale));
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }
        /* v1.2.0: Combo Multiplier Display */
        /* v1.46.0: Tabular Nums for layout stability (UX Polish) */
        /* v1.49.0: Uses --hud-font-scale for resizable HUD (Accessibility) */
        #combo-display {
            font-size: calc(24px * var(--hud-font-scale));
            font-weight: bold;
            color: #ff6600;
            text-shadow: 0 0 10px #ff6600;
            opacity: 0;
            transition: opacity 0.2s, transform 0.2s;
            transform: scale(1);
            font-variant-numeric: tabular-nums;
        }
        #combo-display.active {
            opacity: 1;
        }
        #combo-display.pulse {
            transform: scale(1.2);
        }
        /* v1.7.0: Combo Counter Pulse Animation on Multiplier Increase */
        /* v1.68.0: Tighter timing + spring curve for punchier feedback (UX Polish Specialist) */
        @keyframes comboPulse {
            0% { transform: scale(1); }
            40% { transform: scale(1.4); text-shadow: 0 0 20px #ff6600, 0 0 30px #ff8800; }
            100% { transform: scale(1); }
        }
        #combo-display.combo-pulse {
            animation: comboPulse 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        @media (prefers-reduced-motion: reduce) {
            #combo-display.combo-pulse { animation: none; }
        }
        /* v1.51.0: Comeback Bonus HUD Indicator (Player Psychology) */
        /* v1.62.0: Enhanced Visual Anchor with background glow (Player Psychologist) */
        #comeback-indicator {
            font-size: 14px;
            font-weight: bold;
            color: #ff6600;
            text-shadow: 0 0 8px #ff6600;
            opacity: 0;
            transition: opacity 0.3s ease-out;
            margin-top: 4px;
            padding: 4px 10px;
            border-radius: 4px;
        }
        #comeback-indicator.active {
            opacity: 1;
            animation: comebackPulse 0.8s ease-in-out infinite;
            background: rgba(255, 102, 0, 0.2);
            box-shadow: 0 0 12px rgba(255, 102, 0, 0.5), inset 0 0 6px rgba(255, 102, 0, 0.25);
        }
        /* v1.69.0: Enhanced peak glow with layered halo for visceral comeback moment (UX Polish Specialist) */
        @keyframes comebackPulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 12px rgba(255, 102, 0, 0.5); }
            50% { transform: scale(1.08); box-shadow: 0 0 28px rgba(255, 102, 0, 0.9), 0 0 40px rgba(255, 102, 0, 0.4); }
        }
        @media (prefers-reduced-motion: reduce) {
            #comeback-indicator.active { animation: none; }
        }
        /* v1.14.0: Combo Decay Warning Animation (Psychology) */
        @keyframes comboWarning {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; color: #ff4444; }
        }
        #combo-display.combo-warning {
            animation: comboWarning 0.3s ease-in-out infinite;
        }
        @media (prefers-reduced-motion: reduce) {
            #combo-display.combo-warning { animation: none; opacity: 0.6; }
        }
        /* v1.28.0: Combo Grace Period Animation (Psychology) */
        @keyframes comboGrace {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.3; transform: scale(0.95); color: #ff0000; }
        }
        #combo-display.combo-grace {
            animation: comboGrace 0.15s ease-in-out infinite;
            text-shadow: 0 0 15px #ff0000, 0 0 25px #ff4444;
        }
        @media (prefers-reduced-motion: reduce) {
            #combo-display.combo-grace { animation: none; opacity: 0.5; color: #ff4444; }
        }
        /* v1.44.0: Streak Recovery Window Countdown Ring (Psychology) */
        #streak-recovery-ring {
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 6px;
            background: rgba(255, 0, 0, 0.3);
            border-radius: 3px;
            overflow: hidden;
            opacity: 0;
            transition: opacity 0.2s;
        }
        #streak-recovery-ring.visible { opacity: 1; }
        #streak-recovery-ring-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ff8800);
            border-radius: 3px;
            transition: width 0.1s linear;
        }
        /* v1.15.0: Score Multiplier Tier Recolor (Visual Designer) */
        /* v1.41.0: Combo Tier Letter-Spacing Escalation (Visual Designer) */
        #combo-display.combo-tier-2 { color: #00ccff; text-shadow: 0 0 10px #00ccff; letter-spacing: 1px; }
        #combo-display.combo-tier-3 { color: #ffff00; text-shadow: 0 0 12px #ffff00; letter-spacing: 2px; font-weight: 600; }
        #combo-display.combo-tier-4 { color: #ff8800; text-shadow: 0 0 15px #ff8800; letter-spacing: 3px; font-weight: 700; }
        #combo-display.combo-tier-max { color: #ff3333; text-shadow: 0 0 20px #ff3333, 0 0 30px #ff0000; font-size: 28px; letter-spacing: 4px; font-weight: 900; text-transform: uppercase; }
        /* v1.31.0: Combo Tier Ring Pulse (UX Polish Specialist) */
        @keyframes comboTierRing {
            0% { box-shadow: 0 0 0 0 currentColor; opacity: 1; }
            100% { box-shadow: 0 0 0 25px transparent; opacity: 0; }
        }
        #combo-display.tier-ring-pulse::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: inherit;
            animation: comboTierRing 0.5s ease-out forwards;
            pointer-events: none;
        }
        #combo-display { position: relative; }
        /* v1.49.0: Combo Tier Milestone Glow (UX Polish Specialist) */
        @keyframes comboMilestoneGlow {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.9), 0 0 20px rgba(255, 180, 0, 0.8);
                filter: brightness(1.5);
            }
            50% {
                box-shadow: 0 0 40px 15px rgba(255, 215, 0, 0.6), 0 0 60px rgba(255, 180, 0, 0.4);
                filter: brightness(1.3);
            }
            100% {
                box-shadow: 0 0 0 0 transparent, 0 0 0 transparent;
                filter: brightness(1);
            }
        }
        #combo-display.milestone-glow {
            animation: comboMilestoneGlow 0.6s ease-out forwards;
        }
        @media (prefers-reduced-motion: reduce) {
            #combo-display.milestone-glow { animation: none; filter: brightness(1.2); }
        }
        /* v1.18.0: Threat Level Indicator (Player Psychologist) */
        /* v1.23.0: Replaced translateX(-50%) with margin-based centering (UX Polish) */
        /* v1.29.0: Enhanced color smoothing with text-shadow transitions (UX) */
        #threat-indicator {
            position: absolute;
            top: 20px;
            left: 0;
            right: 0;
            width: fit-content;
            margin: 0 auto;
            font-size: 14px;
            font-weight: bold;
            padding: 6px 16px;
            border-radius: 4px;
            text-transform: uppercase;
            letter-spacing: 1px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #44ff44;
            color: #44ff44;
            transition: border-color 0.3s ease-out, color 0.3s ease-out, box-shadow 0.3s ease-out, text-shadow 0.3s ease-out;
        }
        .threat-label { opacity: 0.7; margin-right: 8px; }
        #threat-indicator.threat-low { border-color: #44ff44; color: #44ff44; text-shadow: 0 0 5px rgba(68, 255, 68, 0.4); }
        #threat-indicator.threat-medium { border-color: #ffff00; color: #ffff00; text-shadow: 0 0 8px rgba(255, 255, 0, 0.5); }
        #threat-indicator.threat-high { border-color: #ff8800; color: #ff8800; text-shadow: 0 0 10px rgba(255, 136, 0, 0.6); }
        #threat-indicator.threat-extreme { border-color: #ff3333; color: #ff3333; text-shadow: 0 0 12px rgba(255, 51, 51, 0.7); animation: threatPulse 0.5s ease-in-out infinite; }
        @keyframes threatPulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 51, 51, 0.4); }
            50% { box-shadow: 0 0 20px rgba(255, 51, 51, 0.8); }
        }
        @media (prefers-reduced-motion: reduce) {
            #threat-indicator.threat-extreme { animation: none; }
        }
        /* v1.89.0: Threat Count Badge (UX Polish Specialist) */
        #threat-count {
            margin-left: 8px;
            padding: 2px 8px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.15);
            font-size: 12px;
            font-weight: bold;
            opacity: 0.9;
            min-width: 20px;
            text-align: center;
        }
        /* v1.32.0: Daily Challenge Streak Counter (Player Psychologist) */
        #streak-counter {
            position: absolute;
            top: 60px;
            right: 20px;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.6);
            padding: 4px 10px;
            border-radius: 4px;
            border: 1px solid #ffd700;
            color: #ffd700;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        #streak-counter .streak-icon { font-size: 14px; }
        #streak-counter .streak-value { font-weight: bold; }
        #streak-counter.streak-new { animation: streakPulse 0.6s ease-out; }
        @keyframes streakPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); box-shadow: 0 0 15px rgba(255, 215, 0, 0.8); }
            100% { transform: scale(1); }
        }
        @media (prefers-reduced-motion: reduce) {
            #streak-counter.streak-new { animation: none; }
        }
        /* v1.18.0: Screen Reader Only (Accessibility) */
        /* v1.52.0: Updated to modern clip-path (Accessibility Advocate) */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip-path: inset(50%);
            white-space: nowrap;
            border: 0;
        }
        /* v1.49.0: Uses --hud-font-scale for resizable HUD (Accessibility) */
        #phase-indicator {
            font-size: calc(24px * var(--hud-font-scale));
            font-weight: bold;
            padding: 10px 20px;
            border-radius: 4px;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s;
        }
        .phase-physical {
            color: #ffaa00;
            border: 2px solid #ffaa00;
            background: rgba(255, 170, 0, 0.2);
            box-shadow: 0 0 15px rgba(255, 170, 0, 0.4);
        }
        .phase-spectral {
            color: #00ffff;
            border: 2px solid #00ffff;
            background: rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
        }
        /* v1.15.0: Phase Energy Regen Pulse Animation (Game Feel) */
        @keyframes phaseRegenPulse {
            0%, 100% { box-shadow: 0 0 5px rgba(0, 255, 255, 0.3); }
            50% { box-shadow: 0 0 15px rgba(0, 255, 255, 0.7), 0 0 25px rgba(0, 136, 255, 0.4); }
        }
        #phase-bar.recharging {
            animation: phaseRegenPulse 0.8s ease-in-out infinite;
        }
        @media (prefers-reduced-motion: reduce) {
            #phase-bar.recharging { animation: none; opacity: 0.9; }
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        .reticle {
            position: absolute;
            border: 2px solid rgba(0, 255, 0, 0.8);
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
            transition: all 0.1s;
        }
        #reticle-inner { width: 10px; height: 10px; top: 15px; left: 15px; background: rgba(0, 255, 0, 0.5); }
        /* v1.52.0: Cubic Bezier Easing for premium feel (Game Feel Expert) */
        /* v1.58.0: Snappier ease-out-quint curve - quick start, smooth landing */
        #reticle-outer { width: 40px; height: 40px; top: 0; left: 0; border-style: dashed; animation: spin 4s linear infinite; transition: transform 0.12s cubic-bezier(0.22, 1, 0.36, 1); }
        /* v1.23.0: Reticle Breath-Zoom on Input (Game Feel Expert) */
        /* v1.74.0: Bouncy 0.15s spring transition for alive input feel (Game Feel) */
        #reticle-outer.input-active { transform: scale(1.2) rotate(0deg); transition: transform 0.15s cubic-bezier(0.34, 1.56, 0.64, 1); }
        /* v1.27.0: Firing Recoil Pulse (Game Feel Expert) */
        #reticle-outer.firing-pulse { transform: scale(0.85); }
        @keyframes firingPulse {
            0% { transform: scale(1); }
            50% { transform: scale(0.85); }
            100% { transform: scale(1); }
        }
        /* v1.30.0: Reticle Convergence on Firing (UX Polish Specialist) */
        @keyframes reticleConvergence {
            0% { width: 40px; height: 40px; }
            40% { width: 26px; height: 26px; }
            100% { width: 40px; height: 40px; }
        }
        /* v1.63.0: Unified firing feedback timing - 0.1s synchronization (Game Feel Expert) */
        #reticle-outer.firing-converge {
            animation: reticleConvergence 0.1s cubic-bezier(0.22, 1, 0.36, 1) forwards;
        }
        /* v1.59.0: Inner convergence easing harmony with outer (Game Feel Expert) */
        /* v1.69.0: Synced to 0.1s to match outer convergence for pixel-perfect feedback (Game Feel Expert) */
        #reticle-inner.firing-converge {
            transform: scale(0.7);
            transition: transform 0.1s cubic-bezier(0.22, 1, 0.36, 1);
        }

        @keyframes spin { 100% { transform: rotate(360deg); } }

        /* v1.39.0: Weapon Charge-Up Spin Effect (Game Feel Expert) */
        #reticle-outer.charge-spin {
            animation: chargeSpinAccelerate 0.2s ease-out forwards;
        }
        @keyframes chargeSpinAccelerate {
            0% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(90deg) scale(1.15); }
            100% { transform: rotate(180deg) scale(1); }
        }
        @media (prefers-reduced-motion: reduce) {
            #reticle-outer.charge-spin { animation: none; }
        }

        /* v1.36.0: Reticle Trail Afterimage (Game Feel Expert) */
        .reticle-trail {
            position: absolute;
            width: 40px;
            height: 40px;
            border: 2px solid rgba(0, 255, 0, 0.4);
            border-radius: 50%;
            border-style: dashed;
            pointer-events: none;
            opacity: 0.6;
            animation: reticleTrailFade 0.25s ease-out forwards;
        }
        @keyframes reticleTrailFade {
            0% { opacity: 0.5; transform: scale(1); }
            100% { opacity: 0; transform: scale(0.6); }
        }
        @media (prefers-reduced-motion: reduce) {
            .reticle-trail { display: none; }
        }

        /* v1.87.0: Reticle Kill Confirmation Pulse (Game Feel) */
        @keyframes reticleKillPulse {
            0% { transform: translate(-50%, -50%) scale(1); }
            30% { transform: translate(-50%, -50%) scale(1.4); }
            100% { transform: translate(-50%, -50%) scale(0.85); }
        }
        #reticle-outer.kill-confirm {
            animation: reticleKillPulse 0.2s ease-out forwards;
        }
        @media (prefers-reduced-motion: reduce) {
            #reticle-outer.kill-confirm { animation: none; }
        }

        /* v1.20.0: Cooldown Pulse Ring (UX Polish Specialist) */
        #cooldown-ring {
            position: absolute;
            width: 50px;
            height: 50px;
            top: -5px;
            left: -5px;
            border: 2px solid rgba(0, 255, 0, 0);
            border-radius: 50%;
            pointer-events: none;
            transform-origin: center;
            transition: border-color 0.05s, transform 0.05s;
        }
        #cooldown-ring.ready {
            border-color: rgba(0, 255, 0, 0.8);
            transform: scale(1.2);
            box-shadow: 0 0 12px rgba(0, 255, 0, 0.6);
        }
        #cooldown-ring.charging {
            border-color: rgba(255, 200, 0, 0.4);
            transform: scale(0.9);
        }
        /* v1.35.0: Momentum Dependency Feedback Ring (Game Feel Expert) */
        #momentum-ring {
            position: absolute;
            width: 60px;
            height: 60px;
            top: -10px;
            left: -10px;
            border: 2px solid transparent;
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s, border-color 0.2s;
        }
        #momentum-ring.low-velocity {
            opacity: 1;
            border-color: rgba(255, 80, 80, 0.6);
            animation: momentumPulse 0.5s ease-in-out infinite;
        }
        #momentum-ring.high-velocity {
            opacity: 1;
            border-color: rgba(0, 255, 100, 0.8);
            animation: none;
        }
        @keyframes momentumPulse {
            0%, 100% { transform: scale(1); opacity: 0.6; }
            50% { transform: scale(1.15); opacity: 1; }
        }

        /* v1.40.0: Shield Regeneration Prediction Timeline (UX Polish Specialist) */
        #shield-prediction {
            position: absolute;
            bottom: 25px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(0, 0, 0, 0.5);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 11px;
            color: #8af;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 100;
        }
        #shield-prediction.visible {
            opacity: 1;
        }
        #shield-prediction .milestone {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }
        #shield-prediction .milestone-bar {
            width: 30px;
            height: 4px;
            background: rgba(100, 150, 255, 0.3);
            border-radius: 2px;
            overflow: hidden;
        }
        #shield-prediction .milestone-fill {
            height: 100%;
            background: #4af;
            width: 0%;
            transition: width 0.2s;
        }
        #shield-prediction .milestone-label {
            font-size: 9px;
            color: #6af;
        }
        #shield-prediction .eta {
            font-size: 10px;
            color: #fff;
            margin-left: 4px;
        }

        /* v1.40.0: Second Wind Comeback Indicator (Player Psychologist) */
        #second-wind-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 32px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 20px #0ff, 0 0 40px #08f;
            opacity: 0;
            pointer-events: none;
            z-index: 1000;
            animation: none;
        }
        #second-wind-indicator.active {
            animation: secondWindPulse 0.5s ease-out forwards;
        }
        @keyframes secondWindPulse {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            100% { opacity: 0.8; transform: translate(-50%, -50%) scale(1); }
        }
        .second-wind-shield {
            animation: shieldGlow 0.3s ease-in-out infinite alternate;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.6) !important;
        }
        @keyframes shieldGlow {
            0% { filter: brightness(1); }
            100% { filter: brightness(1.3); }
        }
        @media (prefers-reduced-motion: reduce) {
            #second-wind-indicator.active { animation: none; opacity: 1; }
            .second-wind-shield { animation: none; }
        }

        /* v1.40.0: Audio Event Captions Panel (Accessibility Advocate) */
        #audio-captions {
            position: fixed;
            bottom: 80px;
            left: 20px;
            max-width: 280px;
            background: rgba(0, 0, 0, 0.75);
            border-left: 3px solid #4af;
            border-radius: 0 6px 6px 0;
            padding: 8px 12px;
            font-size: 12px;
            color: #fff;
            z-index: 500;
            opacity: 0;
            transform: translateX(-10px);
            transition: opacity 0.2s, transform 0.2s;
            pointer-events: none;
        }
        #audio-captions.visible {
            opacity: 1;
            transform: translateX(0);
        }
        #audio-captions .caption-entry {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 4px;
            opacity: 1;
            transition: opacity 0.3s;
        }
        #audio-captions .caption-entry.fading {
            opacity: 0;
        }
        #audio-captions .caption-icon {
            font-size: 14px;
        }
        #audio-captions .caption-text {
            color: #cdf;
        }
        /* v1.85.0: Toggle State Eased Transition (UX) */
        #audio-captions-toggle {
            position: fixed;
            bottom: 50px;
            left: 20px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #4af;
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            cursor: pointer;
            z-index: 501;
            transition: background 0.15s ease-out, border-color 0.15s ease-out, color 0.15s ease-out;
        }
        #audio-captions-toggle:hover {
            background: rgba(68, 170, 255, 0.3);
        }
        @media (prefers-reduced-motion: reduce) {
            #cooldown-ring { transition: none; }
        }

        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
        }
        h1 {
            font-size: 72px;
            color: #00ffff;
            text-transform: uppercase;
            margin: 0;
            text-shadow: 0 0 20px #00ffff;
            font-style: italic;
            letter-spacing: -2px;
        }
        h2 {
            font-size: 36px;
            color: #fff;
            margin-top: 10px;
        }
        /* v1.63.0: Game Over Score Transition Animation (UX Polish Specialist) */
        @keyframes scoreReveal {
            0% { opacity: 0; transform: scale(0.6); }
            60% { opacity: 1; transform: scale(1.1); }
            100% { opacity: 1; transform: scale(1); }
        }
        #final-score.score-reveal, #high-score-display.score-reveal {
            animation: scoreReveal 1.2s cubic-bezier(0.22, 1, 0.36, 1) forwards;
            font-weight: 300;
        }
        .btn {
            margin-top: 40px;
            padding: 15px 40px;
            font-size: 24px;
            background: transparent;
            color: #00ffff;
            border: 2px solid #00ffff;
            cursor: pointer;
            text-transform: uppercase;
            font-weight: bold;
            transition: all 0.2s;
            transform: skewX(-15deg);
        }
        /* v1.75.0: Micro-scale on hover for distinct feedback hierarchy (UX Polish) */
        .btn:hover {
            background: #00ffff;
            color: #000;
            transform: skewX(-15deg) scale(1.05);
            box-shadow: 0 0 20px #00ffff;
        }
        /* v1.6.0: Keyboard Focus Indicators (Accessibility) */
        /* v1.53.0: Unified Button Focus Ring System (UX Polish) */
        /* v1.83.0: Focus Ring Smooth Entrance (UX) - 0.15s ease-out for polished navigation */
        .btn:focus-visible,
        #colorblind-toggle:focus-visible,
        #audio-captions-toggle:focus-visible,
        #hud-size-toggle:focus-visible {
            outline: 3px solid #00ffff;
            outline-offset: 3px;
            box-shadow: 0 0 25px #00ffff, 0 0 50px rgba(0, 255, 255, 0.3);
            transition: outline 0.15s ease-out, box-shadow 0.15s ease-out, outline-offset 0.15s ease-out;
        }
        /* v1.6.0: Button Press Feedback (UX) */
        /* v1.54.0: Button Press Depth Feedback (UX Polish) */
        /* v1.82.0: Button Feedback Timing Standardization (UX) - 0.12s for consistent feel */
        .btn:active {
            transform: skewX(-15deg) scale(0.95) translateY(2px);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3), 0 0 8px #00ffff;
            transition: transform 0.12s, box-shadow 0.12s;
        }
        .controls-info {
            margin-top: 40px;
            text-align: center;
            color: #aaa;
            line-height: 1.6;
            font-size: 18px;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
        }
        .key {
            display: inline-block;
            padding: 2px 8px;
            border: 1px solid #fff;
            border-radius: 4px;
            color: #fff;
            font-weight: bold;
            margin: 0 2px;
        }
        .hidden { display: none !important; }
        
        #damage-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            box-shadow: inset 0 0 0 0 rgba(255, 0, 0, 0);
            transition: box-shadow 0.1s;
            pointer-events: none;
            z-index: 10;
        }
        .damage-flash {
            box-shadow: inset 0 0 100px 50px rgba(255, 0, 0, 0.5) !important;
        }
        /* v1.78.0: Directional Impact Flash Overlay (Game Feel) */
        .directional-flash::before {
            content: '';
            position: absolute;
            left: var(--flash-x, 50%);
            top: var(--flash-y, 50%);
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 100, 50, 0.8) 0%, transparent 70%);
            pointer-events: none;
            animation: directionalFlashAnim 0.15s ease-out forwards;
        }
        @keyframes directionalFlashAnim {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(0.5); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
        }
        /* v1.16.0: Shield Depletion Flicker (Game Feel) */
        @keyframes shieldCriticalFlicker {
            0%, 100% { box-shadow: inset 0 0 0 0 rgba(255, 0, 0, 0); }
            50% { box-shadow: inset 0 0 80px 30px rgba(255, 0, 0, 0.3); }
        }
        .shield-critical {
            animation: shieldCriticalFlicker 0.4s ease-in-out infinite;
        }
        @media (prefers-reduced-motion: reduce) {
            .shield-critical { animation: none; box-shadow: inset 0 0 50px 20px rgba(255, 0, 0, 0.15); }
        }
        /* v1.19.0: Shield Depletion Gradient Vignette (Visual Designer) */
        .shield-vignette {
            background: radial-gradient(ellipse at center, transparent 50%, rgba(255, 80, 0, var(--vignette-intensity, 0)) 100%);
            transition: --vignette-intensity 0.3s;
        }
        @property --vignette-intensity {
            syntax: '<number>';
            initial-value: 0;
            inherits: false;
        }
        /* v1.32.0: Shield Damage Crack Overlay (Visual Designer) */
        #damage-overlay.shield-cracked::before {
            content: '';
            position: absolute;
            top: var(--crack-y, 50%);
            left: var(--crack-x, 50%);
            width: 300px;
            height: 300px;
            transform: translate(-50%, -50%);
            background: radial-gradient(
                circle at center,
                transparent 20%,
                rgba(255, 255, 255, 0.15) 21%,
                transparent 22%,
                transparent 40%,
                rgba(255, 255, 255, 0.1) 41%,
                transparent 42%
            );
            opacity: var(--crack-intensity, 0);
            pointer-events: none;
            animation: crackFade 1.5s ease-out forwards;
        }
        #damage-overlay.shield-cracked::after {
            content: '';
            position: absolute;
            top: var(--crack-y, 50%);
            left: var(--crack-x, 50%);
            width: 200px;
            height: 2px;
            transform-origin: left center;
            transform: translate(-50%, -50%) rotate(var(--crack-angle, 0deg));
            background: linear-gradient(90deg, rgba(255,255,255,0.3), transparent);
            opacity: var(--crack-intensity, 0);
            animation: crackFade 1.5s ease-out forwards;
        }
        @keyframes crackFade {
            0% { opacity: var(--crack-intensity, 0.6); }
            100% { opacity: 0; }
        }
        @media (prefers-reduced-motion: reduce) {
            #damage-overlay.shield-cracked::before,
            #damage-overlay.shield-cracked::after { animation: none; opacity: 0; }
        }
        /* v1.16.0: Combo Countdown Timer (UX) */
        #combo-countdown {
            font-size: 14px;
            color: #88ff88;
            margin-left: 8px;
            transition: color 0.2s;
        }
        #combo-countdown.countdown-warning { color: #ffff00; }
        #combo-countdown.countdown-critical { color: #ff4444; }
        /* v1.16.0: Skip-to-Game Button (Accessibility) */
        #skip-to-game {
            position: absolute;
            left: -9999px;
            top: 0;
            z-index: 10000;
            padding: 12px 24px;
            background: #00ffff;
            color: #000;
            font-weight: bold;
            text-decoration: none;
            border-radius: 0 0 8px 0;
        }
        #skip-to-game:focus {
            left: 0;
            outline: 3px solid #fff;
        }
        /* v1.32.0: Skip to Controls Link (Accessibility Advocate) */
        #skip-to-controls {
            position: absolute;
            left: -9999px;
            top: 30px;
            z-index: 10001;
            background: #333;
            color: #fff;
            padding: 8px 16px;
            text-decoration: none;
            border-radius: 4px;
        }
        #skip-to-controls:focus {
            left: 0;
            outline: 3px solid #fff;
        }
        /* v1.51.0: Modal Panel Fade Transition (UX Polish) */
        #controls-reference {
            position: fixed;
            top: 50%;
            opacity: 0;
            visibility: hidden;
            /* v1.66.0: Added scale entrance polish (UX Polish Specialist) */
            transition: opacity 0.25s ease-out, visibility 0.25s ease-out, transform 0.25s cubic-bezier(0.22, 1, 0.36, 1);
            left: 50%;
            transform: translate(-50%, -50%) scale(0.92);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #4a9eff;
            border-radius: 12px;
            padding: 24px;
            z-index: 10000;
            min-width: 300px;
            color: #fff;
        }
        /* v1.51.0: Smooth fade-in on visible (UX Polish) */
        /* v1.66.0: Scale to 1 on visible for entrance polish */
        #controls-reference.visible { opacity: 1; visibility: visible; transform: translate(-50%, -50%) scale(1); }
        #controls-reference h2 { margin: 0 0 16px; color: #4a9eff; }
        #controls-reference table { width: 100%; border-collapse: collapse; }
        #controls-reference th, #controls-reference td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        #controls-reference th { color: #aaa; }
        #controls-reference .close-btn {
            position: absolute;
            top: 8px;
            right: 12px;
            background: none;
            border: none;
            color: #fff;
            font-size: 20px;
            cursor: pointer;
            transition: transform 0.15s ease-out, color 0.15s ease-out, text-shadow 0.15s ease-out;
        }
        /* v1.52.0: Close Button Visual Hierarchy Enhancement (UX Polish) */
        #controls-reference .close-btn:hover {
            color: #ff6666;
            transform: scale(1.2);
            text-shadow: 0 0 8px rgba(255, 102, 102, 0.6);
        }
        #controls-reference .close-btn:focus-visible {
            outline: 2px solid #4a9eff;
            outline-offset: 2px;
        }

        #comm-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            opacity: 0;
            transition: opacity 0.5s;
        }
        .comm-portrait {
            width: 80px;
            height: 80px;
            background: #003366;
            border: 2px solid #00ffff;
            border-radius: 50%;
            overflow: hidden;
            position: relative;
        }
        .comm-portrait img { width: 100%; height: 100%; object-fit: cover; }
        .comm-text {
            background: rgba(0, 20, 40, 0.8);
            border: 1px solid #00ffff;
            padding: 10px 20px;
            color: #00ffff;
            font-family: 'Courier New', monospace;
            max-width: 400px;
            border-radius: 0 20px 0 20px;
        }
        
        #tutorial-overlay {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            pointer-events: none;
            z-index: 50;
            text-align: center;
        }
        #tutorial-box {
            background: rgba(0, 20, 40, 0.9);
            border: 2px solid #00ff88;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.3);
        }
        #tutorial-title {
            color: #00ff88;
            font-size: 24px;
            margin: 0 0 10px 0;
            text-transform: uppercase;
            letter-spacing: 2px;
            /* v1.77.0: Text shadow for WCAG AA contrast enhancement (Accessibility) */
            text-shadow: 0 0 8px rgba(0, 255, 136, 0.6), 0 2px 4px rgba(0, 0, 0, 0.8);
        }
        #tutorial-text {
            color: #fff;
            font-size: 18px;
            line-height: 1.5;
        }
        #tutorial-prompt {
            margin-top: 20px;
            color: #aaa;
            font-size: 14px;
            animation: blink 1s infinite;
        }
        @keyframes blink { 50% { opacity: 0.5; } }

        /* v1.77.0: New High Score Glow Pulse Animation (UX Polish) */
        @keyframes newRecordGlow {
            0%, 100% { text-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00; }
            50% { text-shadow: 0 0 20px #00ff00, 0 0 40px #00ff00, 0 0 60px #88ff88; }
        }
        #new-record {
            animation: newRecordGlow 0.8s ease-in-out infinite !important;
        }

        /* v1.2.0: Phase Shift Feedback Pulse Animation */
        @keyframes phasePulse {
            0% { transform: scale(1); box-shadow: 0 0 10px currentColor; }
            50% { transform: scale(1.15); box-shadow: 0 0 25px currentColor, 0 0 40px currentColor; }
            100% { transform: scale(1); box-shadow: 0 0 10px currentColor; }
        }
        .phase-pulse {
            animation: phasePulse 0.3s ease-out;
        }

        /* v1.3.0: Near-Miss Popup Animation */
        @keyframes nearMissFloat {
            0% { opacity: 1; transform: translateX(-50%) translateY(0); }
            100% { opacity: 0; transform: translateX(-50%) translateY(-50px); }
        }

        /* v1.3.0: Reduced Motion Support */
        @media (prefers-reduced-motion: reduce) {
            .phase-pulse { animation: none; }
            @keyframes spin { 100% { transform: rotate(0deg); } }
            @keyframes blink { 50% { opacity: 1; } }
            /* v1.6.0: Extended reduced motion coverage */
            .loading-title { animation: none; }
            .perfect-dodge { animation: none; opacity: 1; }
            @keyframes lowEnergyPulse { 0%, 50%, 100% { box-shadow: 0 0 10px #ff3333; } }
            /* v1.87.0: Bar Fill Animation Removal (Accessibility) */
            /* Instant bar updates for users with vestibular disorders */
            .bar-fill { transition: width 0s !important; }
            .loading-bar { transition: width 0s, background 0s, box-shadow 0s !important; }
        }

        /* v1.4.0: Phase Energy Low Warning */
        @keyframes lowEnergyPulse {
            0%, 100% { box-shadow: 0 0 5px #ff3333; }
            50% { box-shadow: 0 0 20px #ff3333, 0 0 30px #ff0000; }
        }
        .low-energy {
            animation: lowEnergyPulse 0.5s ease-in-out infinite;
            background: linear-gradient(90deg, #ff3333, #ff0000) !important;
        }

        /* v1.4.0: Floating Damage Numbers */
        @keyframes damageFloat {
            0% { opacity: 1; transform: translateX(-50%) translateY(0) scale(1); }
            100% { opacity: 0; transform: translateX(-50%) translateY(-80px) scale(1.5); }
        }
        .damage-number {
            position: fixed;
            left: 50%;
            top: 35%;
            color: #ff3333;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 0 0 10px #ff0000, 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 100;
            animation: damageFloat 0.8s ease-out forwards;
        }

        /* v1.5.0: Loading Screen */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            transition: opacity 0.5s ease-out;
        }
        #loading-screen.fade-out {
            opacity: 0;
            pointer-events: none;
        }
        .loading-title {
            font-size: 48px;
            color: #00ffff;
            text-shadow: 0 0 20px #00ffff;
            margin-bottom: 40px;
            animation: loadPulse 1.5s ease-in-out infinite;
        }
        @keyframes loadPulse {
            0%, 100% { opacity: 0.7; text-shadow: 0 0 10px #00ffff; }
            50% { opacity: 1; text-shadow: 0 0 30px #00ffff, 0 0 50px #00ffff; }
        }
        .loading-bar-container {
            width: 300px;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }
        .loading-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #00aaff, #00ffff);
            border-radius: 4px;
            transition: width 0.3s ease-out, background 0.5s ease-out, box-shadow 0.5s ease-out;
            box-shadow: 0 0 10px #00ffff;
        }
        /* v1.54.0: Loading Bar Color Transition to Green (UX Polish) */
        /* v1.72.0: Completion glow pulse animation for celebration (UX Polish) */
        .loading-bar.loading-complete {
            background: linear-gradient(90deg, #00ff88, #44ffaa);
            box-shadow: 0 0 15px #00ff88, 0 0 25px rgba(0, 255, 136, 0.4);
            animation: loadingCompleteGlow 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) 0.1s forwards;
        }
        @keyframes loadingCompleteGlow {
            0% { box-shadow: 0 0 15px #00ff88, 0 0 25px rgba(0, 255, 136, 0.4); }
            50% { box-shadow: 0 0 25px #00ff88, 0 0 40px rgba(0, 255, 136, 0.7); }
            100% { box-shadow: 0 0 15px #00ff88, 0 0 25px rgba(0, 255, 136, 0.4); }
        }
        .loading-status {
            margin-top: 20px;
            color: #b0b0b0; /* v1.6.0: WCAG AA compliant contrast (5.3:1 vs #888's 3.9:1) */
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        /* v1.5.0: Perfect Dodge Popup */
        @keyframes perfectDodgeFloat {
            0% { opacity: 1; transform: translateX(-50%) translateY(0) scale(1); }
            50% { transform: translateX(-50%) translateY(-30px) scale(1.2); }
            100% { opacity: 0; transform: translateX(-50%) translateY(-60px) scale(0.8); }
        }
        .perfect-dodge {
            position: fixed;
            left: 50%;
            top: 45%;
            color: #00ffff;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 0 0 15px #00ffff, 0 0 25px #0088ff;
            pointer-events: none;
            z-index: 100;
            animation: perfectDodgeFloat 1s ease-out forwards;
        }

        /* v1.9.0: Score Toast Notifications */
        #toast-container {
            position: fixed;
            bottom: 80px;
            right: 20px;
            z-index: 120;
            display: flex;
            flex-direction: column-reverse;
            gap: 8px;
            pointer-events: none;
        }
        .score-toast {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 16px;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            animation: toastSlideIn 0.3s ease-out, toastFadeOut 0.4s ease-out 2.1s forwards;
        }
        .toast-kill {
            color: #ff8800;
            text-shadow: 0 0 10px #ff8800;
            border-color: rgba(255, 136, 0, 0.5);
        }
        .toast-combo {
            color: #ffff00;
            text-shadow: 0 0 15px #ffff00;
            border-color: rgba(255, 255, 0, 0.5);
            font-size: 18px;
        }
        /* v1.15.0: Kill Streak Toast Escalation (UX Polish) */
        .toast-streak-2 { font-size: 18px; transform: scale(1.1); }
        .toast-streak-3 { font-size: 20px; transform: scale(1.2); color: #ffcc00 !important; }
        .toast-streak-4 { font-size: 22px; transform: scale(1.3); color: #ff9900 !important; }
        .toast-streak-max { font-size: 26px; transform: scale(1.5); color: #ff3333 !important; text-shadow: 0 0 20px #ff0000 !important; }
        .toast-perfect {
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
            border-color: rgba(0, 255, 255, 0.5);
        }
        .toast-nearmiss {
            color: #88ff00;
            text-shadow: 0 0 10px #88ff00;
            border-color: rgba(136, 255, 0, 0.5);
        }
        /* v1.33.0: Narrative Checkpoint Toast (Player Psychologist) */
        .toast-narrative {
            color: #ffffff;
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 3px;
            text-shadow: 0 0 20px #ff6600, 0 0 40px #ff3300;
            border-color: rgba(255, 102, 0, 0.8);
            background: linear-gradient(135deg, rgba(255,50,0,0.3), rgba(255,150,0,0.3));
            animation: toastSlideIn 0.5s ease-out, narrativePulse 1s ease-in-out 2;
        }
        @keyframes narrativePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        /* v1.37.0: Critical Protocol Toast (Player Psychologist) */
        .toast-critical {
            color: #ff3333;
            font-size: 22px;
            font-weight: bold;
            letter-spacing: 2px;
            text-shadow: 0 0 15px #ff0000, 0 0 30px #ff3300;
            border-color: rgba(255, 50, 50, 0.8);
            background: linear-gradient(135deg, rgba(255,0,0,0.4), rgba(150,0,0,0.3));
            animation: toastSlideIn 0.3s ease-out, criticalFlash 0.3s ease-in-out 3;
        }
        @keyframes criticalFlash {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        @keyframes toastSlideIn {
            from { opacity: 0; transform: translateX(50px); }
            to { opacity: 1; transform: translateX(0); }
        }
        @keyframes toastFadeOut {
            to { opacity: 0; transform: translateX(30px); }
        }
        /* v1.24.0: Toast Exit Stagger Animation (UX Polish) */
        .score-toast.toast-exiting {
            animation: toastFadeOut 0.3s ease-out forwards !important;
        }
        @media (prefers-reduced-motion: reduce) {
            .score-toast { animation: none; opacity: 1; }
            .score-toast.toast-exiting { animation: none !important; opacity: 0; }
        }

        /* v1.11.0: Momentum Bar & Velocity Visualization (Game Feel Expert) */
        .momentum-container {
            width: 200px;
            height: 8px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            margin-top: 15px;
            overflow: hidden;
            position: relative;
        }
        .momentum-label {
            position: absolute;
            left: 0;
            top: -18px;
            color: #b0b0b0; /* v1.12.0: WCAG AA compliant contrast (5.3:1 ratio) */
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .momentum-fill {
            height: 100%;
            width: 0%;
            transition: width 0.1s ease-out, background 0.2s ease-out;
            border-radius: 3px;
            box-shadow: 0 0 8px currentColor;
        }
        /* Momentum gradient: blue (slow) -> cyan -> yellow -> orange -> red (max) */
        .momentum-slow { background: linear-gradient(90deg, #3b82f6, #60a5fa); color: #3b82f6; }
        .momentum-normal { background: linear-gradient(90deg, #06b6d4, #22d3ee); color: #06b6d4; }
        .momentum-fast { background: linear-gradient(90deg, #eab308, #facc15); color: #eab308; }
        .momentum-max { background: linear-gradient(90deg, #f97316, #ef4444); color: #ef4444; }

        /* v1.22.0: Near-Miss Shield Flash (Game Feel Expert) */
        @keyframes nearMissShieldFlash {
            0% { box-shadow: inset 0 0 0 0 rgba(0, 255, 136, 0); }
            30% { box-shadow: inset 0 0 60px 30px rgba(0, 255, 136, 0.4); }
            100% { box-shadow: inset 0 0 0 0 rgba(0, 255, 136, 0); }
        }
        #damage-overlay.near-miss-flash {
            animation: nearMissShieldFlash 0.4s ease-out;
        }
        @media (prefers-reduced-motion: reduce) {
            #damage-overlay.near-miss-flash { animation: none; }
        }

        /* v1.22.0: Colorblind Mode Toggle Button */
        #colorblind-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 8px 14px;
            font-size: 12px;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.4);
            color: rgba(255, 255, 255, 0.8);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            pointer-events: auto;
        }
        #colorblind-toggle:hover {
            border-color: #00ffff;
            color: #00ffff;
        }
        /* v1.76.0: Colorblind toggle focus-visible for keyboard navigation (Accessibility) */
        #colorblind-toggle:focus-visible {
            outline: 2px solid #00ffff;
            outline-offset: 2px;
            box-shadow: 0 0 12px rgba(0, 255, 255, 0.5);
        }
        #colorblind-toggle.active {
            background: rgba(0, 255, 255, 0.2);
            border-color: #00ffff;
            color: #00ffff;
        }

        /* v1.22.0: Colorblind Mode Color Overrides (Deuteranopia-friendly) */
        body.colorblind-mode #shield-bar {
            background: linear-gradient(90deg, #e69f00, #f0e442) !important;
        }
        body.colorblind-mode #phase-bar {
            background: linear-gradient(90deg, #56b4e9, #0072b2) !important;
        }
        body.colorblind-mode .toast-kill {
            color: #e69f00 !important;
            text-shadow: 0 0 10px #e69f00 !important;
        }
        body.colorblind-mode .toast-nearmiss {
            color: #56b4e9 !important;
            text-shadow: 0 0 10px #56b4e9 !important;
        }
        body.colorblind-mode #combo-display.combo-tier-2 {
            color: #56b4e9 !important;
            text-shadow: 0 0 10px #56b4e9 !important;
        }
        body.colorblind-mode #combo-display.combo-tier-3 {
            color: #f0e442 !important;
            text-shadow: 0 0 12px #f0e442 !important;
        }
        body.colorblind-mode #combo-display.combo-tier-4 {
            color: #e69f00 !important;
            text-shadow: 0 0 15px #e69f00 !important;
        }
        body.colorblind-mode .phase-physical {
            color: #e69f00 !important;
            border-color: #e69f00 !important;
            background: rgba(230, 159, 0, 0.2) !important;
            box-shadow: 0 0 15px rgba(230, 159, 0, 0.4) !important;
        }
        body.colorblind-mode .phase-spectral {
            color: #56b4e9 !important;
            border-color: #56b4e9 !important;
            background: rgba(86, 180, 233, 0.2) !important;
            box-shadow: 0 0 15px rgba(86, 180, 233, 0.4) !important;
        }
        body.colorblind-mode #threat-indicator.threat-low {
            border-color: #56b4e9 !important;
            color: #56b4e9 !important;
        }
        body.colorblind-mode #threat-indicator.threat-medium {
            border-color: #f0e442 !important;
            color: #f0e442 !important;
        }
        body.colorblind-mode #threat-indicator.threat-high {
            border-color: #e69f00 !important;
            color: #e69f00 !important;
        }
        body.colorblind-mode #threat-indicator.threat-extreme {
            border-color: #cc79a7 !important;
            color: #cc79a7 !important;
        }
        /* v1.43.0: Cognitive Load Simple HUD Mode (Accessibility Advocate) */
        /* Hide non-essential UI elements to reduce cognitive load */
        body.simple-hud #combo-display,
        body.simple-hud #threat-indicator,
        body.simple-hud #perfect-dodge-display,
        body.simple-hud #fps-counter,
        body.simple-hud .toast-dodge,
        body.simple-hud .toast-nearmiss,
        body.simple-hud .toast-combo,
        body.simple-hud #session-time {
            opacity: 0 !important;
            pointer-events: none !important;
        }
        body.simple-hud #score { font-size: 20px; }
        body.simple-hud #phase-indicator { font-size: 14px; }
        /* Visual indicator that simple mode is active */
        body.simple-hud::after {
            content: 'SIMPLE HUD (J)';
            position: fixed;
            bottom: 10px;
            right: 10px;
            font-size: 10px;
            color: rgba(255,255,255,0.4);
            font-family: monospace;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <!-- v1.16.0: Skip-to-Game Button (Accessibility) -->
    <a href="#game-canvas" id="skip-to-game">Skip to Game</a>
    <!-- v1.32.0: Skip to Controls Link (Accessibility Advocate) -->
    <a href="#controls-reference" id="skip-to-controls" onclick="toggleControlsReference(event)">Skip to Controls</a>

    <!-- v1.32.0: Controls Reference Panel (Accessibility Advocate) -->
    <div id="controls-reference" role="dialog" aria-labelledby="controls-title" aria-modal="true">
        <button class="close-btn" onclick="toggleControlsReference()" aria-label="Close controls">&times;</button>
        <h2 id="controls-title">Controls Reference</h2>
        <table>
            <tr><th>Action</th><th>Key</th></tr>
            <tr><td>Move</td><td>W/A/S/D or Arrow Keys</td></tr>
            <tr><td>Fire Laser</td><td>Space</td></tr>
            <tr><td>Phase Shift</td><td>Shift</td></tr>
            <tr><td>Pause</td><td>Escape</td></tr>
            <tr><td>Show Controls</td><td>H or ?</td></tr>
        </table>
        <p style="margin-top: 16px; color: #aaa; font-size: 12px;">Press Escape to close</p>
    </div>

    <!-- v1.5.0: Loading Screen -->
    <div id="loading-screen" role="alert" aria-live="polite" aria-label="Loading game resources">
        <div class="loading-title">AETHER WING</div>
        <div class="loading-bar-container">
            <div class="loading-bar" id="loading-bar"></div>
        </div>
        <div class="loading-status" id="loading-status" role="status" aria-live="polite">Initializing...</div>
    </div>

    <div id="damage-overlay"></div>

    <!-- v1.33.0: Semantic Main Element Wrapper (Accessibility Advocate) -->
    <main id="game-main" role="main" aria-label="Sky Realms game area">
        <!-- Game canvas will be appended here by JavaScript -->
    </main>

    <!-- v1.9.0: Score Toast Container -->
    <div id="toast-container"></div>
    
    <div id="ui-layer">
        <div class="hud-top">
            <!-- v1.7.0: ARIA Labels for HUD Elements (Accessibility) -->
            <div class="status-bars" role="group" aria-label="Player Status">
                <div class="bar-container" role="meter" aria-label="Shield Integrity" aria-valuemin="0" aria-valuemax="100" aria-valuenow="100">
                    <div class="bar-label">Shield Integrity</div>
                    <!-- v1.92.0: Gradient Bar Endpoint Labels (UX Polish) -->
                    <span class="bar-endpoint bar-endpoint-min">0</span>
                    <div id="shield-bar" class="bar-fill" style="width: 100%;"></div>
                    <span class="bar-endpoint bar-endpoint-max">100</span>
                </div>
                <div class="bar-container" role="meter" aria-label="Phase Energy" aria-valuemin="0" aria-valuemax="100" aria-valuenow="100">
                    <div class="bar-label">Phase Energy</div>
                    <span class="bar-endpoint bar-endpoint-min">0</span>
                    <div id="phase-bar" class="bar-fill" style="width: 100%;"></div>
                    <span class="bar-endpoint bar-endpoint-max">100</span>
                </div>
                <!-- v1.11.0: Momentum Bar (Game Feel Expert) -->
                <div class="momentum-container" role="meter" aria-label="Velocity" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
                    <div class="momentum-label">Velocity</div>
                    <span class="bar-endpoint bar-endpoint-min">0</span>
                    <div id="momentum-bar" class="momentum-fill momentum-slow" style="width: 0%;"></div>
                    <span class="bar-endpoint bar-endpoint-max">100</span>
                </div>
            </div>
            <!-- v1.7.0: ARIA Live Region for Score (Accessibility) -->
            <!-- v1.26.0: Added hud-breathing class for idle state pulse -->
            <!-- v1.53.0: Added hud-enter for staggered entrance animation -->
            <div class="score-box hud-breathing hud-enter" role="status" aria-live="polite" aria-atomic="true">
                <div>SCORE</div>
                <div id="score-display" aria-label="Current Score">00000</div>
                <!-- v1.2.0: Combo Multiplier Display -->
                <!-- v1.16.0: Added countdown timer span -->
                <div id="combo-display" aria-label="Combo Multiplier">x1 COMBO<span id="combo-countdown"></span>
                    <!-- v1.44.0: Streak Recovery Window Countdown (Psychology) -->
                    <div id="streak-recovery-ring"><div id="streak-recovery-ring-fill" style="width: 100%"></div></div>
                </div>
                <!-- v1.51.0: Comeback Bonus HUD Indicator (Player Psychology) -->
                <div id="comeback-indicator" aria-live="polite" aria-label="Comeback Bonus Active"></div>
            </div>
            <!-- v1.18.0: Threat Level Indicator (Player Psychologist) -->
            <!-- v1.53.0: Added hud-enter with delay for staggered entrance -->
            <!-- v1.89.0: Added numeric enemy count badge (UX Polish) -->
            <div id="threat-indicator" class="hud-enter hud-enter-delay-1" role="status" aria-live="polite" aria-label="Threat Level">
                <span class="threat-label">THREAT</span>
                <span id="threat-level">LOW</span>
                <span id="threat-count" aria-label="Active enemies: 0">0</span>
            </div>
            <!-- v1.32.0: Daily Challenge Streak Counter (Player Psychologist) -->
            <div id="streak-counter" role="status" aria-label="Daily Play Streak">
                <span class="streak-icon">🔥</span>
                <span class="streak-value" id="streak-value">0</span>
                <span>day streak</span>
            </div>
        </div>
        <!-- v1.18.0: ARIA Alert Region for Critical Events (Accessibility Advocate) -->
        <div id="aria-alert-region" role="alert" aria-live="assertive" aria-atomic="true" class="sr-only"></div>
        <!-- v1.36.0: ARIA Game State Region for Mode Announcements (Accessibility Advocate) -->
        <div id="aria-game-state" role="status" aria-live="polite" aria-atomic="true" class="sr-only"></div>

        <!-- v1.40.0: Shield Regeneration Prediction Timeline (UX Polish Specialist) -->
        <div id="shield-prediction" role="status" aria-label="Shield Regeneration Forecast">
            <span>REGEN:</span>
            <div class="milestone">
                <div class="milestone-bar"><div class="milestone-fill" id="pred-50"></div></div>
                <span class="milestone-label">50%</span>
            </div>
            <div class="milestone">
                <div class="milestone-bar"><div class="milestone-fill" id="pred-75"></div></div>
                <span class="milestone-label">75%</span>
            </div>
            <div class="milestone">
                <div class="milestone-bar"><div class="milestone-fill" id="pred-100"></div></div>
                <span class="milestone-label">100%</span>
            </div>
            <span class="eta" id="shield-eta"></span>
        </div>

        <!-- v1.40.0: Second Wind Comeback Indicator (Player Psychologist) -->
        <div id="second-wind-indicator" aria-live="assertive">SECOND WIND!</div>

        <!-- v1.40.0: Audio Event Captions Panel (Accessibility Advocate) -->
        <div id="audio-captions" role="log" aria-label="Audio Event Captions" aria-live="polite"></div>
        <button id="audio-captions-toggle" aria-label="Toggle Audio Captions">CC</button>

        <div id="crosshair">
            <div id="reticle-outer" class="reticle"></div>
            <div id="reticle-inner" class="reticle"></div>
            <!-- v1.20.0: Cooldown Pulse Ring (UX Polish Specialist) -->
            <div id="cooldown-ring"></div>
            <!-- v1.35.0: Momentum Dependency Feedback Ring (Game Feel Expert) -->
            <div id="momentum-ring"></div>
            <!-- v1.36.0: Reticle Trail Afterimage Container (Game Feel Expert) -->
            <div id="reticle-trail-container"></div>
        </div>

        <div class="hud-bottom">
            <div id="comm-panel">
                <div class="comm-portrait">
                    <!-- Simple CSS generated face -->
                    <div style="position: absolute; top: 20px; left: 20px; width: 10px; height: 10px; background: #fff; border-radius: 50%;"></div>
                    <div style="position: absolute; top: 20px; right: 20px; width: 10px; height: 10px; background: #fff; border-radius: 50%;"></div>
                    <div style="position: absolute; bottom: 20px; left: 25px; width: 30px; height: 5px; background: #fff;"></div>
                </div>
                <div class="comm-text" id="comm-message">"Good luck, pilot!"</div>
            </div>
            <!-- v1.53.0: Added hud-enter with delay-2 for staggered entrance -->
            <div id="phase-indicator" class="phase-physical hud-enter hud-enter-delay-2">MATERIAL PHASE</div>
        </div>
    </div>

    <!-- v1.50.0: Semantic Heading Hierarchy (Accessibility Advocate) -->
    <section id="start-screen" role="region" aria-labelledby="start-title">
        <!-- v1.22.0: Colorblind Mode Toggle (Accessibility Advocate) -->
        <button id="colorblind-toggle" tabindex="0" aria-pressed="false" aria-label="Toggle colorblind mode">
            Colorblind Mode
        </button>
        <h1 id="start-title">AETHER WING</h1>
        <h2>PHASE SHIFT PROTOCOL</h2>
        <div class="controls-info">
            <p><span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> or <strong>MOUSE</strong> to Fly</p>
            <p><span class="key">SPACE</span> or <strong>L-CLICK</strong> to Shoot</p>
            <p><span class="key">SHIFT</span> or <strong>R-CLICK</strong> (Hold) to Phase Shift</p>
            <p><strong>MATERIAL PHASE:</strong> Shoot enemies, dodge walls. Vulnerable to physical damage.</p>
            <p><strong>SPECTRAL PHASE:</strong> Pass through walls. Vulnerable to energy barriers.</p>
        </div>
        <!-- v1.12.0: Tab Navigation (Accessibility) - explicit tabindex for keyboard navigation -->
        <button class="btn" id="start-btn" tabindex="0">LAUNCH MISSION</button>
        <button class="btn" id="tutorial-btn" tabindex="0" style="margin-top: 10px; border-color: #00ff88; color: #00ff88;">TRAINING SIMULATION</button>
    </section>

    <div id="tutorial-overlay" class="hidden">
        <div id="tutorial-box">
            <h3 id="tutorial-title">TRAINING</h3>
            <p id="tutorial-text">Welcome to the simulation.</p>
            <div id="tutorial-prompt">Press SPACE to continue</div>
        </div>
    </div>

    <!-- v1.50.0: Semantic Heading Hierarchy (Accessibility Advocate) -->
    <section id="game-over-screen" class="hidden" role="region" aria-labelledby="gameover-title">
        <h1 id="gameover-title">MISSION FAILED</h1>
        <h2 id="final-score">Score: 0</h2>
        <h3 id="high-score-display" style="color: #ffaa00; margin-top: 10px; font-weight: 300;">Best: 0</h3>
        <div id="new-record" style="display: none; color: #00ff00; font-size: 24px; animation: pulse 0.5s ease-in-out infinite; margin-top: 10px;">NEW HIGH SCORE!</div>
        <!-- v1.12.0: Tab Navigation (Accessibility) -->
        <button class="btn" id="restart-btn" tabindex="0">RETRY MISSION</button>
    </section>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // Game State
        const STATE = {
            playing: false,
            score: 0,
            shield: 100,
            phaseEnergy: 100,
            isSpectral: false,
            speed: 0.4, // Slowed down from 0.8
            distance: 0,
            difficulty: 1,
            tutorialMode: false,
            tutorialStep: 0,
            tutorialTimer: 0,
            tutorialWaiting: false,
            // v1.1.0: High Score Persistence (Player Psychology)
            highScore: parseInt(localStorage.getItem('skyRealms_highScore')) || 0,
            // v1.2.0: Combo Multiplier System (Player Psychology)
            comboKills: 0,
            comboMultiplier: 1,
            comboTimer: 0,
            // v1.28.0: Combo Grace Period (Psychology)
            comboGraceActive: false,
            comboGraceStartTime: 0,
            // v1.63.0: Grace Period Audio Pulse (Player Psychologist)
            lastGraceBeepTime: 0,
            // v1.2.0: Hit Pause / Frame Freeze (Game Feel)
            freezeFrames: 0,
            // v1.3.0: Reduced Motion Option (Accessibility)
            reducedMotion: window.matchMedia('(prefers-reduced-motion: reduce)').matches,
            // v1.3.0: Near-Miss Bonus System (Psychology)
            nearMissCount: 0,
            // v1.4.0: Movement Easing System (Game Feel)
            velocityX: 0,
            velocityY: 0,
            // v1.5.0: Perfect Dodge System (Psychology)
            perfectDodges: 0,
            // v1.9.0: Material Caching (Performance)
            phaseJustChanged: false,
            // v1.18.0: ARIA Alert State (Accessibility)
            lastShieldAlert: false,
            ariaAlertCooldown: false,
            // v1.19.0: Session Arc Scaling (Psychology)
            sessionStartTime: 0,
            sessionPhase: 'learning', // learning, challenge, mastery
            // v1.20.0: Health Warning Pulse (Audio)
            lastHeartbeatTime: 0,
            // v1.21.0: Shield Depletion Rumble (Game Feel)
            lastShieldRumbleTime: 0,
            // v1.21.0: Momentum Cascade (Psychology)
            momentumStreak: 0,
            lastMomentumReward: 0,
            // v1.80.0: Variable Ratio Mini-Rewards (Psychology)
            variableRatioKills: 0,
            variableRatioThreshold: 3 + Math.floor(Math.random() * 5), // 3-7 kills
            // v1.82.0: HUD Breathing Combat Suppression (UX)
            combatActivityTimer: null,
            // v1.22.0: Colorblind Mode (Accessibility)
            colorblindMode: localStorage.getItem('skyRealms_colorblind') === 'true',
            // v1.22.0: Phase-Linked Fog (Visual)
            targetFogColor: { r: 0, g: 0, b: 0 },
            currentFogColor: { r: 0, g: 0, b: 0 },
            // v1.24.0: Threat Indicator Conditional Class Swap (Performance)
            lastThreatClass: '',
            // v1.29.0: Lazy Threat Level Computation (Performance)
            lastEnemyCount: -1,  // Track enemy count for memoization
            // v1.25.0: Pause/Resume State (Accessibility)
            isPaused: false,
            // v1.27.0: Phase Recharge Audio Chirps (Audio Engineer)
            lastPhaseChirpTime: 0,
            // v1.27.0: Progressive Mastery Unlocking (Player Psychologist)
            masteries: JSON.parse(localStorage.getItem('skyRealms_masteries') || '{}'),
            lastDamageTime: 0,  // Track no-damage streaks
            sessionMasteriesAwarded: [],  // Track masteries earned this session
            // v1.28.0: Dynamic ARIA Combo Labels (Accessibility Advocate)
            lastAnnouncedComboTier: 0,  // Track tier for progression announcements
            // v1.30.0: Weapon Heat Glow Aura (Visual Designer)
            weaponHeat: 0,       // 0-1 heat level
            lastShotTime: 0,     // Timestamp of last shot
            // v1.56.0: Smooth Bloom Intensity Transitions (Visual Designer)
            targetBloomStrength: 1.4,  // Target bloom strength for lerp transitions
            // v1.57.0: Phase-aware Light Intensity Ramping (Visual Designer)
            targetDirLightIntensity: 2.0,     // Target directional light intensity
            targetAmbientIntensity: 2.0,      // Target ambient light intensity
            // v1.86.0: Directional Light Color Temperature Shift (Visual Designer)
            targetDirLightColor: { r: 1.0, g: 0.98, b: 0.92 },   // Warm white (2800K) for material phase
            targetAmbientColor: { r: 0.2, g: 0.27, b: 0.33 },    // Warm ambient
            // v1.31.0: Update Function Throttling (Performance Optimizer)
            lastRenderedShield: -1,
            lastRenderedPhase: -1,
            lastRenderedScore: -1,
            // v1.32.0: Daily Challenge Streak Counter (Player Psychologist)
            streakDays: parseInt(localStorage.getItem('skyRealms_streakDays')) || 0,
            lastPlayDate: localStorage.getItem('skyRealms_lastPlayDate') || '',
            // v1.33.0: Session Narrative Checkpoints (Player Psychologist)
            narrativeCheckpoints: { 30: false, 60: false, 120: false },
            narrativeScoreMultiplier: 1.0,  // 2x after 120s Final Stand
            // v1.34.0: Momentum Mastery Quest Chain (Player Psychologist)
            momentumQuestTime: 0,      // Time at high velocity (seconds)
            momentumBadges: JSON.parse(localStorage.getItem('skyRealms_momentumBadges') || '[]'),
            momentumQuestThreshold: 0.8, // 80% of max speed
            momentumQuestDuration: 5,   // Seconds needed for badge
            wasAboveVelocityThreshold: false, // v1.90.0: Track velocity threshold crossing

            // v1.36.0: Reticle Trail Afterimage (Game Feel Expert)
            lastReticleX: 0,           // Previous frame reticle X position
            lastReticleY: 0,           // Previous frame reticle Y position
            reticleTrailTimer: 0,      // Time since last trail spawn

            // v1.37.0: Narrative Comeback Escalation (Player Psychologist)
            criticalPhaseActive: false,    // True when shield was < 25%
            comebackMultiplier: 1.0,       // Bonus multiplier after comeback
            comebackMultiplierExpiry: 0,   // Timestamp when comeback bonus expires
            healthPreCritical: 100,        // Shield level before entering critical

            // v1.38.0: Weapon Recoil Knockback (Game Feel Expert)
            recoilActive: false,           // True during recoil frame
            recoilDamping: 0,              // Current recoil velocity reduction (0-1)

            // v1.39.0: Weapon Charge-Up Spin Effect (Game Feel Expert)
            chargeUpActive: false,         // True during first 200ms of firing
            chargeUpStartTime: 0,          // Timestamp when firing sequence began
            lastFireTime: 0,               // Last fire timestamp for sequence detection

            // v1.39.0: Fragile Victory Adrenaline (Player Psychologist)
            fragileVictoryKills: 0,        // Consecutive kills in fragile range (40-60% shield)
            fragileVictoryMultiplier: 1.0, // Current bonus multiplier (1.1 → 1.2 → 1.35)

            // v1.40.0: Shield Regeneration Prediction (UX Polish Specialist)
            shieldRegenRate: 2.5,          // Shield points per second when regenerating
            lastShieldRegenTime: 0,        // Last time shield was regenerating
            shieldPredictionVisible: true, // Show/hide prediction timeline

            // v1.40.0: Second Wind Comeback Threshold (Player Psychologist)
            secondWindUsed: false,         // True after first critical save (per life)
            secondWindActive: false,       // True during 2-sec invulnerability
            secondWindExpiry: 0,           // Timestamp when second wind ends

            // v1.40.0: Audio Event Captions Panel (Accessibility Advocate)
            audioCaptionsEnabled: true,    // Toggle for visual audio captions
            audioCaptionQueue: [],          // Queue of caption events to display

            // v1.42.0: Velocity Signature Playstyle Profile (Player Psychologist)
            velocitySamples: [],           // Array of velocity magnitudes sampled over time
            velocitySampleInterval: 500,   // Sample every 500ms
            lastVelocitySampleTime: 0,     // Last time velocity was sampled

            // v1.48.0: Collision Knockback Push (Game Feel Expert)
            collisionKnockback: 0,         // Current camera z-offset from knockback
            knockbackVelocity: 0,          // Decay velocity for knockback
            playstyleAnnounced: false,     // Whether playstyle has been announced this session
            // v1.43.0: Cognitive Load Simple HUD Mode (Accessibility Advocate)
            simpleHUDMode: false,          // Toggle to hide non-essential UI elements

            // v1.49.0: Recovery Checkpoint Celebration (Player Psychologist)
            wasInCritical: false,          // True when shield was below 25%
            recoveryCelebrated: false,     // Prevents multiple celebrations per recovery

            // v1.50.0: Phase Energy Depleted Tone (Audio Engineer)
            phaseDepletedPlayed: false     // Prevents spamming depleted tone
        };

        // v1.3.0: Audio System (Web Audio API)
        let audioContext = null;
        let audioEnabled = true;
        // v1.39.0: High-Pass Filter for Critical Health (Audio Engineer)
        let criticalHealthFilter = null;
        let masterGainNode = null;

        // v1.5.0: Cached Box3 Objects for Performance (Performance Optimizer)
        // v1.8.0: Added bounds-checked access helpers
        const COLLISION_CACHE = {
            playerBox: null,
            obstacleBoxes: [],
            projectileBoxes: [],
            enemyBoxes: [],
            maxObstacles: 30,
            maxProjectiles: 50,
            maxEnemies: 15,
            // v1.8.0: Safe getter with lazy expansion
            // v1.84.0: Array Capacity Guardian (Code Architect) - prevent unbounded growth
            getObstacleBox(index) {
                if (index >= this.maxObstacles) {
                    console.warn('Obstacle cache overflow attempt:', index);
                    return this.obstacleBoxes[this.maxObstacles - 1];
                }
                while (index >= this.obstacleBoxes.length) {
                    this.obstacleBoxes.push(new THREE.Box3());
                }
                return this.obstacleBoxes[index];
            },
            getProjectileBox(index) {
                while (index >= this.projectileBoxes.length) {
                    this.projectileBoxes.push(new THREE.Box3());
                }
                return this.projectileBoxes[index];
            },
            getEnemyBox(index) {
                while (index >= this.enemyBoxes.length) {
                    this.enemyBoxes.push(new THREE.Box3());
                }
                return this.enemyBoxes[index];
            }
        };

        // v1.9.0: Error Boundary System (Code Architect)
        const ERROR_LOG = {
            entries: [],
            maxEntries: 20,
            add(system, error) {
                this.entries.push({
                    time: Date.now(),
                    system,
                    msg: error.message || String(error)
                });
                if (this.entries.length > this.maxEntries) {
                    this.entries.shift();
                }
                console.error(`[${system}] ${error.message || error}`);
            }
        };

        // v1.9.0: Safe system update wrapper
        function safeUpdate(systemName, updateFn) {
            try {
                updateFn();
            } catch (error) {
                ERROR_LOG.add(systemName, error);
            }
        }

        // v1.9.0: Toast Notification System (UX Polish)
        // v1.15.0: Added kill streak escalation tracking
        const TOAST_SYSTEM = {
            container: null,
            lastToastTime: {},
            throttleMs: 500,
            killStreak: 0,           // v1.15.0: Rapid consecutive kill counter
            lastKillTime: 0,         // v1.15.0: Timestamp of last kill
            streakWindowMs: 1000,    // v1.15.0: Time window for streak (1 second)

            init() {
                this.container = document.getElementById('toast-container');
            },

            show(type, text) {
                if (!this.container || STATE.reducedMotion) return;

                // Throttle same type
                const now = Date.now();
                if (this.lastToastTime[type] && now - this.lastToastTime[type] < this.throttleMs) {
                    return;
                }
                this.lastToastTime[type] = now;

                const toast = document.createElement('div');
                toast.className = `score-toast toast-${type}`;

                // v1.15.0: Kill Streak Toast Escalation (UX Polish)
                if (type === 'kill') {
                    if (now - this.lastKillTime < this.streakWindowMs) {
                        this.killStreak = Math.min(this.killStreak + 1, 5);
                    } else {
                        this.killStreak = 1;
                    }
                    this.lastKillTime = now;

                    // Apply escalation class
                    if (this.killStreak >= 5) {
                        toast.classList.add('toast-streak-max');
                    } else if (this.killStreak >= 4) {
                        toast.classList.add('toast-streak-4');
                    } else if (this.killStreak >= 3) {
                        toast.classList.add('toast-streak-3');
                    } else if (this.killStreak >= 2) {
                        toast.classList.add('toast-streak-2');
                    }
                }

                toast.textContent = text;
                this.container.appendChild(toast);

                // v1.25.0: Toast Event Announcements to Screen Readers (Accessibility)
                // Route toast messages to aria-alert region for screen reader support
                if (DOM_CACHE.ariaAlertRegion) {
                    DOM_CACHE.ariaAlertRegion.textContent = text;
                }

                // Remove after animation
                setTimeout(() => toast.remove(), 2500);

                // v1.24.0: Toast Exit Stagger Animation (UX Polish)
                // Limit max toasts with staggered exit animation
                const maxToasts = 5;
                const excess = this.container.children.length - maxToasts;
                if (excess > 0) {
                    const toastsToRemove = Array.from(this.container.children).slice(0, excess);
                    toastsToRemove.forEach((oldToast, index) => {
                        const staggerDelay = index * 75; // 75ms stagger between each
                        setTimeout(() => {
                            oldToast.classList.add('toast-exiting');
                            setTimeout(() => oldToast.remove(), 300); // Remove after exit animation
                        }, staggerDelay);
                    });
                }
            }
        };

        // v1.1.0: Enhanced Screen Shake System (Game Feel Expert)
        const SCREEN_SHAKE = {
            trauma: 0,           // Current trauma level (0-1)
            traumaDecay: 0.92,   // How fast trauma decays per frame
            maxOffset: 2.5,      // Maximum camera offset
            maxRotation: 0.05,   // Maximum camera rotation
            frequency: 15,       // Shake frequency (noise speed)
            time: 0,             // Internal time counter for noise
            // v1.26.0: Directional Screen Shake Tilt (Game Feel Expert)
            directionX: 0,       // Damage direction X bias (-1 to 1)
            directionY: 0,       // Damage direction Y bias (-1 to 1)
            // v1.34.0: Rotational Camera Impact (Game Feel Expert)
            impactRoll: 0,       // Current lateral impact roll
            impactRollDecay: 0.85 // Faster decay for snappy recovery
        };

        // v1.11.0: Camera Zoom on Impact (Game Feel Expert)
        const CAMERA_ZOOM = {
            baseZ: 10,           // Default camera Z position
            targetZ: 10,         // Current target Z position
            currentZ: 10,        // Interpolated Z position
            zoomVelocity: 0,     // For smooth interpolation
            isZooming: false     // Whether currently in zoom animation
        };

        // v1.11.0: Adaptive Quality Scaling (Performance Optimizer)
        // v1.13.0: Circular buffer replaces push/shift for frame times (eliminates GC thrashing)
        const QUALITY_SYSTEM = {
            tier: 'HIGH',        // ULTRA, HIGH, LOW
            frameCount: 0,
            frameTimes: new Float32Array(30),  // Pre-allocated circular buffer
            frameTimeIndex: 0,                  // Current write position
            frameTimeCount: 0,                  // Number of valid entries
            lastCheck: 0,
            lowFPSStreak: 0,     // Consecutive low FPS checks
            bloomPass: null      // Reference to bloom pass for adjustment
        };

        // v1.12.0: Memoized DOM Element References (Performance Optimizer)
        // v1.13.0: Extended coverage to include all frequently-accessed elements
        const DOM_CACHE = {
            shieldBar: null,
            phaseBar: null,
            scoreDisplay: null,
            comboDisplay: null,
            momentumBar: null,
            damageOverlay: null,    // v1.13.0: Used in takeDamage
            phaseIndicator: null,   // v1.13.0: Used in updatePhase, triggerPhasePulse
            comboCountdown: null,   // v1.16.0: Combo decay countdown timer
            // v1.18.0: Bar containers for ARIA updates (Accessibility)
            shieldContainer: null,
            phaseContainer: null,
            momentumContainer: null,
            threatIndicator: null,  // v1.18.0: Threat level display (Psychology)
            threatLevel: null,      // v1.90.0: Cached threat level span (Performance)
            threatCount: null,      // v1.90.0: Cached threat count span (Performance)
            ariaAlertRegion: null,  // v1.18.0: ARIA alert region (Accessibility)
            cooldownRing: null,     // v1.20.0: Fire cooldown indicator (UX)
            reticleOuter: null,     // v1.23.0: Reticle breath-zoom (Game Feel)
            reticleInner: null,     // v1.30.0: Reticle convergence (UX)
            shieldPrediction: null, // v1.40.0: Shield regen prediction (UX)
            secondWindIndicator: null, // v1.40.0: Second wind display (Psychology)
            audioCaptions: null,    // v1.40.0: Audio captions panel (Accessibility)
            audioCaptionsToggle: null, // v1.40.0: CC toggle button
            streakRecoveryRing: null,     // v1.44.0: Streak recovery countdown ring
            streakRecoveryFill: null,     // v1.44.0: Streak recovery fill bar
            comebackIndicator: null,      // v1.51.0: Comeback bonus HUD indicator
            initialized: false,

            init() {
                this.shieldBar = document.getElementById('shield-bar');
                this.phaseBar = document.getElementById('phase-bar');
                this.scoreDisplay = document.getElementById('score-display');
                this.comboDisplay = document.getElementById('combo-display');
                this.momentumBar = document.getElementById('momentum-bar');
                this.damageOverlay = document.getElementById('damage-overlay');
                this.phaseIndicator = document.getElementById('phase-indicator');
                this.comboCountdown = document.getElementById('combo-countdown');
                // v1.18.0: Cache parent containers for ARIA (Accessibility)
                this.shieldContainer = this.shieldBar?.parentElement;
                this.phaseContainer = this.phaseBar?.parentElement;
                this.momentumContainer = this.momentumBar?.parentElement;
                this.threatIndicator = document.getElementById('threat-indicator');
                // v1.90.0: Cache threat level/count spans (Performance Optimizer)
                this.threatLevel = document.getElementById('threat-level');
                this.threatCount = document.getElementById('threat-count');
                this.ariaAlertRegion = document.getElementById('aria-alert-region');
                this.ariaGameState = document.getElementById('aria-game-state'); // v1.36.0
                this.cooldownRing = document.getElementById('cooldown-ring'); // v1.20.0
                this.reticleOuter = document.getElementById('reticle-outer'); // v1.23.0
                this.reticleInner = document.getElementById('reticle-inner'); // v1.30.0
                this.momentumRing = document.getElementById('momentum-ring'); // v1.35.0
                this.reticleTrailContainer = document.getElementById('reticle-trail-container'); // v1.36.0
                // v1.40.0: New UX/Accessibility elements
                this.shieldPrediction = document.getElementById('shield-prediction');
                this.secondWindIndicator = document.getElementById('second-wind-indicator');
                this.audioCaptions = document.getElementById('audio-captions');
                this.audioCaptionsToggle = document.getElementById('audio-captions-toggle');
                // v1.44.0: Streak recovery countdown (Psychology)
                this.streakRecoveryRing = document.getElementById('streak-recovery-ring');
                this.streakRecoveryFill = document.getElementById('streak-recovery-ring-fill');
                this.comebackIndicator = document.getElementById('comeback-indicator'); // v1.51.0
                this.initialized = true;
            }
        };

        // v1.28.0: Memoized Shield Color Calculation (Performance Optimizer)
        // Cache shield color to avoid recalculating every frame
        const SHIELD_COLOR_CACHE = {
            lastShieldValue: -1,  // Track last computed value
            color: null,          // Cached color string

            getColor(shieldPercent) {
                // Only recalculate if shield changed by at least 1%
                const rounded = Math.round(shieldPercent);
                if (rounded === this.lastShieldValue && this.color !== null) {
                    return this.color;
                }

                // Compute new color
                const pct = Math.max(0, Math.min(100, shieldPercent));
                let color;
                if (pct > 75) {
                    const t = (pct - 75) / 25;
                    color = `rgb(${Math.round(51 * (1 - t))}, ${Math.round(136 + 119 * t)}, 255)`;
                } else if (pct > 50) {
                    const t = (pct - 50) / 25;
                    color = `rgb(${Math.round(255 * (1 - t))}, ${Math.round(255 - 119 * (1 - t))}, ${Math.round(255 * t)})`;
                } else if (pct > 25) {
                    const t = (pct - 25) / 25;
                    color = `rgb(255, ${Math.round(136 + 119 * t)}, 0)`;
                } else {
                    const t = pct / 25;
                    color = `rgb(255, ${Math.round(136 * t)}, 0)`;
                }

                this.lastShieldValue = rounded;
                this.color = color;
                return color;
            },

            reset() {
                this.lastShieldValue = -1;
                this.color = null;
            }
        };

        // v1.8.0: Centralized Game Configuration (Code Architect)
        // All magic numbers consolidated here for easy tuning
        const CONFIG = {
            // Camera & Display
            fieldOfView: 60,
            tunnelRadius: 30,

            // Ship Movement
            shipSpeed: 0.5,
            rotationSpeed: 0.05,
            maxLean: 0.5,
            boundaryX: 18,
            boundaryY: 12,
            moveAcceleration: 0.08,
            moveFriction: 0.85,
            moveMaxSpeed: 0.5,

            // Phase System
            phaseDrainRate: 0.3,
            phaseRechargeRate: 0.2,
            phaseEnergyWarning: 20,
            shieldCriticalThreshold: 25,    // v1.16.0: Shield flicker below this %

            // Combat
            shootCooldown: 150,

            // Combo System
            comboDecayMs: 2000,
            comboWarningMs: 1700,           // v1.68.0: Closer to grace period for better psychological continuity (Player Psychologist)
            comboGracePeriodMs: 3000,       // v1.44.0: Extended recovery window (3s) for streak preservation
            comboTier2Kills: 3,
            comboTier3Kills: 5,
            comboTier4Kills: 8,

            // Scoring
            nearMissMinDist: 2,
            nearMissMaxDist: 4,
            nearMissScore: 15,
            perfectDodgeScore: 50,
            perfectDodgeCooldownMs: 1000,
            enemyKillScore: 100,

            // Spawning
            obstacleSpawnRate: 0.05,
            enemySpawnRate: 0.01,
            maxEnemies: 3,
            enemyShootCooldownMs: 2000,
            enemyBaseHp: 3,

            // Starfield
            starCount: 2000,
            starSize: 1.5,

            // v1.14.0: Spawn System Config (Architecture)
            spawnDistance: -200,            // Z position where obstacles spawn
            asteroidChance: 0.6,            // Probability of asteroid (0-0.6)
            wallChance: 0.8,                // Probability of wall (0.6-0.8)
            asteroidMinRadius: 1,           // Minimum asteroid size
            asteroidMaxRadius: 3,           // Maximum asteroid size
            wallWidth: 8,
            wallHeight: 20,
            wallDepth: 2,
            barrierRadius: 4,               // Energy barrier ring radius
            barrierTubeRadius: 0.5,
            difficultyScaleDivisor: 5000,   // Distance divisor for difficulty curve

            // v1.11.0: Camera Zoom Config (Game Feel)
            impactZoomAmount: 0.5,      // How far camera punches in
            impactZoomInTime: 0.08,     // Seconds to zoom in
            impactZoomOutTime: 0.15,    // v1.51.0: Reduced from 0.2s for snappier feel (Game Feel)

            // v1.11.0: Adaptive Quality Config (Performance)
            targetFPS: 55,
            lowFPSThreshold: 45,
            qualityCheckInterval: 60,   // Frames between quality checks

            // v1.75.0: Collision Damage Constants (Code Architect)
            collisionDamage: {
                spectralEnergy: 20,     // Energy barrier damage when spectral
                materialPhysical: 30,   // Physical collision damage when material
                enemyLaserMaterial: 10, // Enemy laser damage to material ship
                enemyLaserSpectral: 5   // Enemy laser damage to spectral ship
            },

            // v1.91.0: Velocity Threshold Constants (Code Architect)
            velocityBloomThreshold: 0.6  // Speed ratio that triggers bloom pulse
        };

        // Three.js Globals
        let scene, camera, renderer, composer;
        let playerShip, crosshair;
        let tunnelSegments = [];
        let obstacles = [];
        let enemies = [];
        let projectiles = [];
        let particles = [];
        // v1.38.0: Enemy Death Dissolution (Visual Designer)
        let dyingEnemies = [];
        // v1.29.0: Projectile Trail & Impact Flash (Visual Designer)
        let laserTrails = [];
        // v1.43.0: Multi-Hit Spark Spray (Game Feel Expert)
        let hitSparks = [];
        // v1.30.0: Weapon Heat Glow Aura (Visual Designer)
        let engineLight = null;
        let engineGlowMaterial = null;
        // v1.57.0: Phase-aware lighting (Visual Designer)
        let ambientLight = null;
        let dirLight = null;
        // v1.58.0: Reusable vector for enemy targeting (Performance Optimizer)
        const _tempDirection = new THREE.Vector3();
        const HEAT_CONFIG = {
            buildupRate: 0.18,     // Heat gained per shot
            decayRate: 0.008,      // Heat lost per frame
            maxIntensity: 4.0,     // Max light intensity (base: 2)
            baseIntensity: 2.0,    // Normal light intensity
            cooldownMs: 300        // Time without firing to start decay
        };
        const TRAIL_CONFIG = {
            spawnInterval: 2,     // Spawn trail every N frames
            maxTrails: 60,        // Max trail particles at once
            fadeSpeed: 0.06,      // Opacity decay per frame
            size: 0.15            // Trail particle size
        };

        // v1.33.0: Velocity Onion Rings Configuration (Game Feel Expert)
        const VELOCITY_RING_CONFIG = {
            ringCount: 3,           // Number of concentric rings
            baseRadius: 0.3,        // Inner ring radius
            radiusStep: 0.25,       // Increment per ring layer
            expansionRate: 0.02,    // How fast rings expand with velocity
            maxScale: 1.8,          // Maximum ring scale
            // v1.44.0: Asymmetric fade rates (Visual Designer)
            // Inner rings fade fast (momentum), outer rings linger (velocity shadow)
            fadeRates: [0.015, 0.01, 0.005]  // Per-ring fade rates [inner, middle, outer]
        };

        // v1.53.0: Audio Attack-Time Quantization (Audio Engineer)
        // Standardized attack times for rhythm coherence during high-activity sequences
        const AUDIO_CONFIG = {
            attackTimeStandard: 0.02,   // 20ms - consistent snap for UI/weapon sounds
            attackTimeSoft: 0.05,       // 50ms - gentler attack for ambient/warning sounds
            decayTimeShort: 0.08,       // 80ms - quick decay for percussive sounds
            decayTimeMedium: 0.15       // 150ms - medium decay for melodic sounds
        };

        let starField;

        // Input
        const keys = { w: false, a: false, s: false, d: false, space: false, shift: false };
        const mouse = { x: 0, y: 0, left: false, right: false };
        let lastShotTime = 0;

        // Assets (Procedural)
        const MATERIALS = {
            shipBody: new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.3, metalness: 0.8 }),
            shipCockpit: new THREE.MeshStandardMaterial({ color: 0x00aaff, emissive: 0x004488, roughness: 0.1, metalness: 0.9 }),
            spectralShip: new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.4, wireframe: true }),
            
            asteroid: new THREE.MeshStandardMaterial({ color: 0x886644, roughness: 0.9 }),
            spectralAsteroid: new THREE.MeshBasicMaterial({ color: 0x886644, transparent: true, opacity: 0.1, wireframe: true }),
            
            wall: new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.2, metalness: 0.6 }),
            spectralWall: new THREE.MeshBasicMaterial({ color: 0x555555, transparent: true, opacity: 0.1, wireframe: true }),
            
            energyBarrier: new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.6, side: THREE.DoubleSide }),
            enemyShip: new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.4, metalness: 0.6 }),
            
            laser: new THREE.MeshBasicMaterial({ color: 0x00ff00 }),
            enemyLaser: new THREE.MeshBasicMaterial({ color: 0xff0000 }),
            // v1.29.0: Projectile Trail Material (Visual Designer)
            laserTrail: new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.6 }),
            // v1.41.0: Enemy Projectile Tracer Glow (Game Feel Expert)
            enemyLaserTrail: new THREE.MeshBasicMaterial({ color: 0xff3300, transparent: true, opacity: 0.5 }),
            impactFlash: new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.9 }),
            // v1.33.0: Velocity Ring Material (Game Feel Expert)
            velocityRing: new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.3, side: THREE.DoubleSide }),
            // v1.42.0: Enemy Threat Tier Silhouette Glow Materials (Visual Designer)
            // v1.55.0: Threat Tier Glow Color Coherence - perceptually uniform danger spectrum
            // v1.58.0: Weak Glow Perceptual Harmony - lighter blue, higher opacity for visibility parity
            threatGlowWeak: new THREE.MeshBasicMaterial({ color: 0x6699ff, transparent: true, opacity: 0.28 }),
            threatGlowNormal: new THREE.MeshBasicMaterial({ color: 0x00bbaa, transparent: true, opacity: 0.25 }),
            threatGlowElite: new THREE.MeshBasicMaterial({ color: 0xffaa22, transparent: true, opacity: 0.35 }),
            threatGlowBoss: new THREE.MeshBasicMaterial({ color: 0xff3355, transparent: true, opacity: 0.45 }),
            // v1.43.0: Multi-Hit Spark Spray Material (Game Feel Expert)
            // v1.45.0: Hit Spark Color Rebalancing - warm gold (Visual Designer)
            hitSpark: new THREE.MeshBasicMaterial({ color: 0xffcc00, transparent: true, opacity: 0.8 })
        };

        // v1.81.0: Cached geometries for performance (Performance Optimizer)
        const CACHED_GEOMETRIES = {
            enemyLaser: new THREE.BoxGeometry(0.2, 0.2, 2)  // Shared by all enemy projectiles
        };

        // v1.33.0: Create velocity onion rings for projectile (Game Feel Expert)
        // Returns array of ring meshes to attach to projectile
        function createVelocityRings(projectileMesh) {
            if (STATE.reducedMotion) return [];
            const rings = [];
            const ringGeo = new THREE.RingGeometry(0.2, 0.3, 8);

            for (let i = 0; i < VELOCITY_RING_CONFIG.ringCount; i++) {
                const ringMat = MATERIALS.velocityRing.clone();
                ringMat.opacity = 0.3 - (i * 0.08);  // Outer rings are more faint
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = Math.PI / 2;  // Face forward (along Z axis)
                ring.position.z = 0.5 + (i * 0.8);  // Stack behind projectile
                const baseScale = 1 + (i * 0.4);
                ring.scale.set(baseScale, baseScale, 1);
                projectileMesh.add(ring);
                rings.push({
                    mesh: ring,
                    baseScale: baseScale,
                    age: 0,
                    ringIndex: i  // v1.44.0: Track ring index for asymmetric fade
                });
            }
            return rings;
        }

        // v1.5.0: Loading Progress Helper
        function updateLoadingProgress(percent, status) {
            const bar = document.getElementById('loading-bar');
            const statusEl = document.getElementById('loading-status');
            if (bar) {
                bar.style.width = percent + '%';
                // v1.54.0: Loading Bar Color Transition to Green (UX Polish)
                if (percent >= 100) bar.classList.add('loading-complete');
            }
            if (statusEl) statusEl.textContent = status;
        }

        function hideLoadingScreen() {
            const loadingScreen = document.getElementById('loading-screen');
            if (loadingScreen) {
                loadingScreen.classList.add('fade-out');
                // v1.14.0: Haptic feedback when loading completes
                triggerHaptic(HAPTIC_PATTERNS.ready);
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                }, 500);

                // v1.41.0: Game State Color Grading (Visual Designer)
                document.body.classList.add('state-start');

                // v1.36.0: Dynamic Game State Announcement (Accessibility Advocate)
                // Announce game ready state with instructions
                if (DOM_CACHE.ariaGameState) {
                    DOM_CACHE.ariaGameState.textContent = 'Game loaded. Press Launch Mission to begin. Use WASD to move, Space to shoot, Shift to phase shift.';
                }
            }
        }

        function init() {
            updateLoadingProgress(10, 'Initializing scene...');

            // Scene Setup
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.015);

            camera = new THREE.PerspectiveCamera(CONFIG.fieldOfView, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 10);

            updateLoadingProgress(20, 'Setting up renderer...');

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            // v1.33.0: Append to semantic main element instead of body (Accessibility)
            document.getElementById('game-main').appendChild(renderer.domElement);

            // v1.24.0: Canvas Accessibility Role (Accessibility Advocate)
            // Add role and aria-label for screen reader context
            renderer.domElement.setAttribute('role', 'img');
            renderer.domElement.setAttribute('aria-label', '3D space shooter game canvas - use WASD to move, Space to shoot, Shift to phase shift');
            renderer.domElement.id = 'game-canvas';

            updateLoadingProgress(35, 'Configuring post-processing...');

            // Post Processing (Bloom) - v1.1.0: Optimized resolution for performance
            const renderScene = new RenderPass(scene, camera);
            // Use half resolution for bloom (75% performance improvement, minimal visual difference)
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth / 2, window.innerHeight / 2),
                1.5, 0.4, 0.85
            );
            bloomPass.threshold = 0.6; // v1.1.0: Raised from 0 - only bloom bright emissive surfaces
            bloomPass.strength = 1.4;  // Slightly increased to compensate for threshold
            bloomPass.radius = 0.5;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // v1.11.0: Store bloom pass reference for adaptive quality
            QUALITY_SYSTEM.bloomPass = bloomPass;

            // v1.1.0: Clock for delta time (screen shake system)
            window.gameClock = new THREE.Clock();

            updateLoadingProgress(50, 'Setting up lighting...');

            // Lighting
            // v1.57.0: Store globally for phase-based intensity ramping
            // v1.59.0: Warm slate-blue ambient cast for aether atmosphere (Visual Designer)
            ambientLight = new THREE.AmbientLight(0x334455, 1.9);
            scene.add(ambientLight);

            dirLight = new THREE.DirectionalLight(0xffffff, 2);
            dirLight.position.set(10, 20, 10);
            scene.add(dirLight);

            // v1.30.0: Engine light stored globally for heat glow (Visual Designer)
            engineLight = new THREE.PointLight(0x00aaff, HEAT_CONFIG.baseIntensity, 20);
            engineLight.position.set(0, 0, 8);
            scene.add(engineLight);

            updateLoadingProgress(65, 'Creating game objects...');

            // Game Objects
            createStarField();
            createPlayerShip();

            updateLoadingProgress(80, 'Pre-allocating collision cache...');

            // v1.5.0: Initialize Collision Cache (Performance)
            initCollisionCache();

            updateLoadingProgress(90, 'Binding controls...');

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', (e) => handleKey(e, true));
            window.addEventListener('keyup', (e) => handleKey(e, false));

            // Mouse Input
            window.addEventListener('mousemove', (e) => {
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            });
            window.addEventListener('mousedown', (e) => {
                if (e.button === 0) mouse.left = true;
                if (e.button === 2) mouse.right = true;
            });
            window.addEventListener('mouseup', (e) => {
                if (e.button === 0) mouse.left = false;
                if (e.button === 2) mouse.right = false;
            });
            window.addEventListener('contextmenu', e => e.preventDefault());

            document.getElementById('start-btn').addEventListener('click', () => startGame(false));
            document.getElementById('tutorial-btn').addEventListener('click', () => startGame(true));
            document.getElementById('restart-btn').addEventListener('click', resetGame);

            // v1.22.0: Colorblind Mode Toggle (Accessibility Advocate)
            const colorblindBtn = document.getElementById('colorblind-toggle');
            if (colorblindBtn) {
                // Apply saved state on load
                if (STATE.colorblindMode) {
                    document.body.classList.add('colorblind-mode');
                    colorblindBtn.classList.add('active');
                    colorblindBtn.setAttribute('aria-pressed', 'true');
                    // v1.87.0: Colorblind Toggle State Persistence Indicator (UX Polish)
                    // Brief pulse to confirm restored preference
                    colorblindBtn.style.transition = 'box-shadow 0.3s ease';
                    colorblindBtn.style.boxShadow = '0 0 12px rgba(0, 200, 100, 0.8)';
                    setTimeout(() => { colorblindBtn.style.boxShadow = ''; }, 800);
                }
                colorblindBtn.addEventListener('click', () => {
                    STATE.colorblindMode = !STATE.colorblindMode;
                    localStorage.setItem('skyRealms_colorblind', STATE.colorblindMode);
                    document.body.classList.toggle('colorblind-mode', STATE.colorblindMode);
                    colorblindBtn.classList.toggle('active', STATE.colorblindMode);
                    colorblindBtn.setAttribute('aria-pressed', STATE.colorblindMode ? 'true' : 'false');
                    // v1.78.0: Dynamic aria-label for toggle state feedback (Accessibility)
                    colorblindBtn.setAttribute('aria-label', STATE.colorblindMode ? 'Colorblind mode enabled - click to disable' : 'Colorblind mode disabled - click to enable');
                });
            }

            updateLoadingProgress(100, 'Ready!');

            // v1.9.0: Initialize Toast System
            TOAST_SYSTEM.init();

            // v1.12.0: Initialize DOM Cache for Performance
            DOM_CACHE.init();

            // v1.40.0: Initialize Audio Captions Toggle (Accessibility Advocate)
            initAudioCaptionsToggle();

            // v1.32.0: Daily Challenge Streak Counter (Player Psychologist)
            updateDailyStreak();

            // v1.5.0: Hide loading screen and show start screen
            setTimeout(hideLoadingScreen, 300);

            // Start Loop
            animate();
        }

        // v1.5.0: Initialize Collision Cache (Performance Optimizer)
        function initCollisionCache() {
            COLLISION_CACHE.playerBox = new THREE.Box3();

            for (let i = 0; i < COLLISION_CACHE.maxObstacles; i++) {
                COLLISION_CACHE.obstacleBoxes.push(new THREE.Box3());
            }
            for (let i = 0; i < COLLISION_CACHE.maxProjectiles; i++) {
                COLLISION_CACHE.projectileBoxes.push(new THREE.Box3());
            }
            for (let i = 0; i < COLLISION_CACHE.maxEnemies; i++) {
                COLLISION_CACHE.enemyBoxes.push(new THREE.Box3());
            }
        }

        function createStarField() {
            // v1.8.0: Uses CONFIG for starfield settings
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            for (let i = 0; i < CONFIG.starCount; i++) {
                vertices.push(
                    (Math.random() - 0.5) * 1000,
                    (Math.random() - 0.5) * 1000,
                    (Math.random() - 0.5) * 2000 - 500
                );
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            const material = new THREE.PointsMaterial({ color: 0xffffff, size: CONFIG.starSize });
            starField = new THREE.Points(geometry, material);
            scene.add(starField);
        }

        function createPlayerShip() {
            const group = new THREE.Group();

            // Main Body (Arwing style)
            const bodyGeo = new THREE.ConeGeometry(0.8, 4, 4);
            bodyGeo.rotateX(Math.PI / 2);
            const body = new THREE.Mesh(bodyGeo, MATERIALS.shipBody);
            group.add(body);

            // Wings
            const wingGeo = new THREE.BufferGeometry();
            const wingVertices = new Float32Array([
                0, 0, 1,   2.5, 0, 2,   0, 0, -1, // Left Wing
                0, 0, 1,   -2.5, 0, 2,  0, 0, -1  // Right Wing
            ]);
            wingGeo.setAttribute('position', new THREE.BufferAttribute(wingVertices, 3));
            wingGeo.computeVertexNormals();
            const wings = new THREE.Mesh(wingGeo, MATERIALS.shipBody);
            group.add(wings);

            // Cockpit
            const cockpitGeo = new THREE.BoxGeometry(0.6, 0.4, 1.5);
            cockpitGeo.translate(0, 0.4, -0.5);
            const cockpit = new THREE.Mesh(cockpitGeo, MATERIALS.shipCockpit);
            group.add(cockpit);

            // Engines
            const engineGeo = new THREE.CylinderGeometry(0.2, 0.4, 1, 8);
            engineGeo.rotateX(Math.PI / 2);
            const leftEngine = new THREE.Mesh(engineGeo, MATERIALS.shipBody);
            leftEngine.position.set(1.5, 0, 1.5);
            const rightEngine = new THREE.Mesh(engineGeo, MATERIALS.shipBody);
            rightEngine.position.set(-1.5, 0, 1.5);
            group.add(leftEngine);
            group.add(rightEngine);

            // Engine Glow
            // v1.30.0: Store material reference for heat glow (Visual Designer)
            const glowGeo = new THREE.PlaneGeometry(0.8, 0.8);
            engineGlowMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const leftGlow = new THREE.Mesh(glowGeo, engineGlowMaterial);
            leftGlow.position.set(1.5, 0, 2.1);
            const rightGlow = new THREE.Mesh(glowGeo, engineGlowMaterial);
            rightGlow.position.set(-1.5, 0, 2.1);
            group.add(leftGlow);
            group.add(rightGlow);

            playerShip = group;
            scene.add(playerShip);
        }

        function handleKey(e, isDown) {
            const key = e.key.toLowerCase();
            if (keys.hasOwnProperty(key)) keys[key] = isDown;
            if (key === ' ') keys.space = isDown; // Spacebar
            // v1.25.0: Pause/Resume with Screen Reader Announcements (Accessibility)
            if (key === 'escape' && isDown) {
                // v1.32.0: Close controls reference if open
                const controlsRef = document.getElementById('controls-reference');
                if (controlsRef && controlsRef.classList.contains('visible')) {
                    toggleControlsReference();
                } else if (STATE.playing) {
                    togglePause();
                }
            }
            // v1.32.0: Show Controls Reference (Accessibility Advocate)
            if ((key === 'h' || key === '?') && isDown) {
                toggleControlsReference();
            }
            // v1.43.0: Toggle Simple HUD Mode (Accessibility Advocate)
            if (key === 'j' && isDown) {
                toggleSimpleHUD();
            }
        }

        // v1.43.0: Cognitive Load Simple HUD Mode Toggle (Accessibility Advocate)
        function toggleSimpleHUD() {
            STATE.simpleHUDMode = !STATE.simpleHUDMode;
            document.body.classList.toggle('simple-hud', STATE.simpleHUDMode);
            const message = STATE.simpleHUDMode ? 'Simple HUD enabled. Press J to restore.' : 'Full HUD restored.';
            if (DOM_CACHE.ariaAlertRegion) {
                DOM_CACHE.ariaAlertRegion.textContent = message;
            }
            TOAST_SYSTEM.show('narrative', STATE.simpleHUDMode ? 'SIMPLE HUD' : 'FULL HUD');
        }

        // v1.82.0: HUD Breathing Combat Suppression (UX) - pause breathing during rapid updates
        function signalCombatActivity() {
            const hudElements = document.querySelectorAll('.hud-breathing');
            hudElements.forEach(el => el.classList.add('hud-combat-active'));
            if (STATE.combatActivityTimer) clearTimeout(STATE.combatActivityTimer);
            STATE.combatActivityTimer = setTimeout(() => {
                hudElements.forEach(el => el.classList.remove('hud-combat-active'));
            }, 800); // Resume breathing after 800ms of inactivity
        }

        // v1.25.0: Pause/Resume with Screen Reader Announcements (Accessibility)
        function togglePause() {
            STATE.isPaused = !STATE.isPaused;
            const message = STATE.isPaused ? 'Game Paused. Press Escape to resume.' : 'Game Resumed.';
            // Announce to screen readers via aria-alert region
            // v1.79.0: Force-clear and reflow for immediate screen reader announcement (Accessibility)
            if (DOM_CACHE.ariaAlertRegion) {
                DOM_CACHE.ariaAlertRegion.textContent = '';
                void DOM_CACHE.ariaAlertRegion.offsetWidth; // Force reflow for immediate announcement
                DOM_CACHE.ariaAlertRegion.textContent = message;
            }
            // Visual pause indicator
            if (STATE.isPaused) {
                document.body.classList.add('game-paused');

                // v1.36.0: Dynamic Game State Announcement (Accessibility Advocate)
                // Announce detailed game status during pause
                if (DOM_CACHE.ariaGameState) {
                    const shieldPct = Math.round(STATE.shield);
                    const phasePct = Math.round(STATE.phaseEnergy);
                    DOM_CACHE.ariaGameState.textContent = `Game paused. Current score: ${Math.floor(STATE.score)}, Shield: ${shieldPct}%, Phase Energy: ${phasePct}%. Press Escape to resume.`;
                }
            } else {
                document.body.classList.remove('game-paused');
            }
        }

        // v1.32.0: Toggle Controls Reference Panel (Accessibility Advocate)
        // v1.47.0: aria-expanded for Toggle Buttons (Accessibility Advocate)
        // v1.78.0: Focus trap for keyboard navigation (Accessibility)
        let focusTrapHandler = null;
        function toggleControlsReference(e) {
            if (e) e.preventDefault();
            const panel = document.getElementById('controls-reference');
            if (!panel) return;

            const isVisible = panel.classList.contains('visible');
            // v1.35.0: Inert Attribute for Background Content (Accessibility Advocate)
            const gameMain = document.getElementById('game-main');
            const uiLayer = document.getElementById('ui-layer');
            // v1.47.0: Get toggle buttons for aria-expanded state
            const skipToControls = document.getElementById('skip-to-controls');
            const closeBtn = panel.querySelector('.close-btn');

            if (isVisible) {
                panel.classList.remove('visible');
                // v1.35.0: Remove inert from background
                if (gameMain) gameMain.inert = false;
                if (uiLayer) uiLayer.inert = false;
                // v1.47.0: Update aria-expanded state
                if (skipToControls) skipToControls.setAttribute('aria-expanded', 'false');
                if (closeBtn) closeBtn.setAttribute('aria-expanded', 'false');
                // v1.78.0: Remove focus trap handler
                if (focusTrapHandler) {
                    document.removeEventListener('keydown', focusTrapHandler);
                    focusTrapHandler = null;
                }
                // Return focus to opener
                if (skipToControls) skipToControls.focus();
                else document.body.focus();
            } else {
                panel.classList.add('visible');
                // v1.35.0: Apply inert to background content during modal
                if (gameMain) gameMain.inert = true;
                if (uiLayer) uiLayer.inert = true;
                // v1.47.0: Update aria-expanded state
                if (skipToControls) skipToControls.setAttribute('aria-expanded', 'true');
                if (closeBtn) closeBtn.setAttribute('aria-expanded', 'true');
                // Move focus to panel for accessibility
                panel.querySelector('.close-btn').focus();
                // Announce to screen readers
                if (DOM_CACHE.ariaAlertRegion) {
                    DOM_CACHE.ariaAlertRegion.textContent = 'Controls reference opened. Press Escape to close.';
                }
                // v1.78.0: Focus trap - keep Tab cycling within dialog
                const focusableElements = panel.querySelectorAll('button, [href], [tabindex]:not([tabindex="-1"])');
                const firstFocusable = focusableElements[0];
                const lastFocusable = focusableElements[focusableElements.length - 1];
                focusTrapHandler = (evt) => {
                    if (evt.key === 'Tab') {
                        if (evt.shiftKey && document.activeElement === firstFocusable) {
                            evt.preventDefault();
                            lastFocusable.focus();
                        } else if (!evt.shiftKey && document.activeElement === lastFocusable) {
                            evt.preventDefault();
                            firstFocusable.focus();
                        }
                    }
                };
                document.addEventListener('keydown', focusTrapHandler);
            }
        }

        function startGame(isTutorial = false) {
            // v1.3.0: Initialize audio on first user interaction
            initAudio();

            // v1.14.0: Haptic feedback on game start
            triggerHaptic(HAPTIC_PATTERNS.gameStart);

            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('ui-layer').classList.remove('hidden');

            // v1.41.0: Game State Color Grading (Visual Designer)
            document.body.classList.remove('state-start', 'state-gameover-victory', 'state-gameover-defeat');
            document.body.classList.add('state-gameplay');

            // v1.48.0: Dimensional Depth Vignette (Visual Designer)
            // Add base class for vignette pseudo-element (active state toggled by velocity)
            document.body.classList.add('velocity-vignette');

            // v1.48.0: Keyboard Shortcut Announcement (Accessibility Advocate)
            // Announce discoverable keyboard shortcuts after game starts
            setTimeout(() => {
                if (DOM_CACHE.ariaAlertRegion) {
                    DOM_CACHE.ariaAlertRegion.textContent = 'Keyboard shortcuts: H for controls, J to toggle simple HUD, Escape to pause.';
                }
            }, 1500);

            STATE.playing = true;
            STATE.score = 0;
            STATE.shield = 100;
            STATE.phaseEnergy = 100;
            STATE.distance = 0;
            STATE.tutorialMode = isTutorial;
            STATE.tutorialStep = 0;
            STATE.tutorialTimer = 0;
            STATE.tutorialWaiting = false;
            // v1.19.0: Session Arc Scaling (Psychology)
            STATE.sessionStartTime = Date.now();
            STATE.sessionPhase = 'learning';
            // v1.33.0: Reset narrative checkpoints (Player Psychologist)
            STATE.narrativeCheckpoints = { 30: false, 60: false, 120: false };
            STATE.narrativeScoreMultiplier = 1.0;
            // v1.27.0: Progressive Mastery Unlocking (Psychology)
            STATE.lastDamageTime = Date.now();  // Initialize for survivor mastery
            STATE.sessionMasteriesAwarded = [];  // Reset session tracking
            // v1.28.0: Reset shield color cache (Performance)
            SHIELD_COLOR_CACHE.reset();

            // v1.40.0: Reset Second Wind for new game (Player Psychologist)
            STATE.secondWindUsed = false;
            STATE.secondWindActive = false;
            STATE.secondWindExpiry = 0;

            if (isTutorial) {
                showCommMessage("Initiating Training Protocol...", 3000);
                document.getElementById('tutorial-overlay').classList.remove('hidden');
                setTutorialStep(0);
            } else {
                showCommMessage("System Online. Engaging Phase Drive.", 3000);
                document.getElementById('tutorial-overlay').classList.add('hidden');
            }

            // v1.36.0: Dynamic Game State Announcement (Accessibility Advocate)
            // Announce game start with mode information
            if (DOM_CACHE.ariaGameState) {
                const modeText = isTutorial ? 'Tutorial mode started.' : 'Mission started.';
                DOM_CACHE.ariaGameState.textContent = `${modeText} Use WASD to move, Space to shoot, Shift for phase shift, Escape to pause.`;
            }
        }

        function resetGame() {
            document.getElementById('game-over-screen').classList.add('hidden');
            // v1.63.0: Reset score reveal animations for next game over (UX Polish Specialist)
            document.getElementById('final-score').classList.remove('score-reveal');
            document.getElementById('high-score-display').classList.remove('score-reveal');

            // Clear scene objects (v1.20.0: with proper geometry disposal)
            obstacles.forEach(o => { scene.remove(o.mesh); disposeMesh(o.mesh); });
            enemies.forEach(e => { scene.remove(e.mesh); disposeMesh(e.mesh); });
            projectiles.forEach(p => { scene.remove(p.mesh); disposeMesh(p.mesh); });
            // v1.29.0: Clear laser trails on game start
            laserTrails.forEach(t => { scene.remove(t.mesh); t.mesh.material.dispose(); });
            obstacles = [];
            enemies = [];
            projectiles = [];
            laserTrails = [];

            playerShip.position.set(0, 0, 0);
            playerShip.rotation.set(0, 0, 0);
            
            startGame();
        }

        function gameOver() {
            STATE.playing = false;
            // v1.34.0: Game Over Defeat Fanfare (Audio Engineer)
            playGameOverSound();
            document.getElementById('game-over-screen').classList.remove('hidden');

            const finalScore = Math.floor(STATE.score);
            document.getElementById('final-score').innerText = `Score: ${finalScore}`;
            // v1.63.0: Score reveal animation (UX Polish Specialist)
            document.getElementById('final-score').classList.add('score-reveal');

            // v1.1.0: High Score Persistence (Player Psychology)
            const isNewRecord = finalScore > STATE.highScore;
            if (isNewRecord) {
                STATE.highScore = finalScore;
                localStorage.setItem('skyRealms_highScore', finalScore.toString());
                // v1.27.0: Award high score mastery
                awardMastery('high_score');
            }

            // v1.41.0: Game State Color Grading (Visual Designer)
            document.body.classList.remove('state-gameplay', 'state-start');
            document.body.classList.add(isNewRecord ? 'state-gameover-victory' : 'state-gameover-defeat');

            document.getElementById('high-score-display').innerText = `Best: ${STATE.highScore}`;
            // v1.63.0: High score reveal animation (UX Polish Specialist)
            document.getElementById('high-score-display').classList.add('score-reveal');
            document.getElementById('new-record').style.display = isNewRecord ? 'block' : 'none';

            // v1.46.0: Game Over Result Announcement (Accessibility)
            if (DOM_CACHE.ariaAlertRegion) {
                const outcome = isNewRecord ? 'VICTORY - New High Score!' : 'DEFEAT';
                DOM_CACHE.ariaAlertRegion.textContent = `Game Over: ${outcome}. Final Score: ${finalScore}. High Score: ${STATE.highScore}.`;
            }
        }

        function showCommMessage(text, duration) {
            const panel = document.getElementById('comm-panel');
            const msg = document.getElementById('comm-message');
            msg.innerText = text;
            panel.style.opacity = 1;
            setTimeout(() => {
                panel.style.opacity = 0;
            }, duration);
        }

        // ==========================================
        // GAME LOOP
        // ==========================================

        function animate() {
            requestAnimationFrame(animate);

            // v1.1.0: Delta time for frame-independent shake
            const delta = window.gameClock ? window.gameClock.getDelta() : 0.016;

            // v1.61.0: Cache frame timestamp for reuse within single frame (Performance Optimizer)
            STATE.frameTimestamp = Date.now();

            // v1.2.0: Hit Pause / Frame Freeze (Game Feel Expert)
            if (STATE.freezeFrames > 0) {
                STATE.freezeFrames--;
                composer.render(); // Still render, just freeze game logic
                return;
            }

            // v1.25.0: Pause/Resume Support (Accessibility)
            if (STATE.isPaused) {
                composer.render(); // Still render, just freeze game logic
                return;
            }

            if (STATE.playing) {
                if (STATE.tutorialMode) {
                    updateTutorial();
                } else {
                    // Normal Game Loop
                    updateEnvironment();
                    updateEnemies();
                    updateDyingEnemies(); // v1.38.0: Enemy Death Dissolution
                    STATE.score += 0.1;
                    STATE.distance += STATE.speed;

                    // v1.19.0: Session Arc Scaling (Psychology)
                    // Learning (0-60s): normal, Challenge (60-180s): accelerated, Mastery (180s+): plateau
                    // v1.61.0: Uses cached frame timestamp (Performance Optimizer)
                    const sessionElapsed = (STATE.frameTimestamp - STATE.sessionStartTime) / 1000;
                    let arcMultiplier = 1.0;
                    if (sessionElapsed < 60) {
                        STATE.sessionPhase = 'learning';
                        arcMultiplier = 1.0; // Normal progression
                    } else if (sessionElapsed < 180) {
                        STATE.sessionPhase = 'challenge';
                        arcMultiplier = 0.7; // Accelerate 30% faster
                    } else {
                        STATE.sessionPhase = 'mastery';
                        arcMultiplier = 0.5; // Plateau (minimal growth)
                    }
                    STATE.difficulty = 1 + (STATE.distance / (CONFIG.difficultyScaleDivisor * arcMultiplier));

                    // v1.33.0: Session Narrative Checkpoints (Player Psychologist)
                    // Story arc milestones at 30s, 60s, 120s with atmospheric messages
                    checkNarrativeCheckpoints(sessionElapsed);

                    // v1.34.0: Momentum Mastery Quest Chain (Player Psychologist)
                    checkMomentumQuest(delta);

                    // v1.36.0: Reticle Trail Afterimage (Game Feel Expert)
                    updateReticleTrail(delta);

                    // v1.2.0: Decay combo after timeout (v1.8.0: uses CONFIG)
                    // v1.14.0: Added warning before decay (Psychology)
                    // v1.28.0: Added grace period before decay (Psychology)
                    if (STATE.comboKills > 0) {
                        const timeSinceKill = Date.now() - STATE.comboTimer;

                        // v1.28.0: Grace period system
                        // v1.44.0: Streak Recovery Window with visual countdown
                        if (STATE.comboGraceActive) {
                            const graceElapsed = Date.now() - STATE.comboGraceStartTime;
                            if (graceElapsed > CONFIG.comboGracePeriodMs) {
                                // Grace period expired - actually reset combo
                                resetCombo();
                                // v1.44.0: Hide streak recovery ring
                                if (DOM_CACHE.streakRecoveryRing) {
                                    DOM_CACHE.streakRecoveryRing.classList.remove('visible');
                                }
                            } else {
                                // In grace period - show urgent visual feedback
                                if (DOM_CACHE.comboDisplay) {
                                    DOM_CACHE.comboDisplay.classList.add('combo-grace');
                                }
                                // v1.44.0: Update streak recovery countdown bar
                                if (DOM_CACHE.streakRecoveryRing && DOM_CACHE.streakRecoveryFill) {
                                    DOM_CACHE.streakRecoveryRing.classList.add('visible');
                                    const remaining = 1 - (graceElapsed / CONFIG.comboGracePeriodMs);
                                    DOM_CACHE.streakRecoveryFill.style.width = `${remaining * 100}%`;
                                    // v1.62.0: Near-Miss Grace Seconds Feedback (Player Psychologist)
                                    const remainingSecs = Math.ceil((CONFIG.comboGracePeriodMs - graceElapsed) / 1000);
                                    if (DOM_CACHE.comboCountdown) {
                                        DOM_CACHE.comboCountdown.textContent = `SAVE IT! ${remainingSecs}s`;
                                    }
                                    // v1.63.0: Grace Period Countdown Audio Pulse (Player Psychologist)
                                    const graceProgress = graceElapsed / CONFIG.comboGracePeriodMs;
                                    playGracePeriodBeep(graceProgress);
                                }
                            }
                        } else if (timeSinceKill > CONFIG.comboDecayMs - 50) {
                            // v1.65.0: Pre-Grace Anchor - trigger 50ms early for psychological preparation (Player Psychologist)
                            // v1.81.0: Anticipatory announcement before grace entry (Psychology)
                            // Show anticipatory toast BEFORE state change for endowment effect
                            TOAST_SYSTEM.show('combo', '⚡ RECOVERY INCOMING...');
                            // Time expired - enter grace period instead of immediate reset
                            STATE.comboGraceActive = true;
                            STATE.comboGraceStartTime = Date.now();
                            if (DOM_CACHE.comboDisplay) {
                                DOM_CACHE.comboDisplay.classList.add('combo-grace');
                            }
                            // v1.44.0: Show streak recovery ring at 100%
                            if (DOM_CACHE.streakRecoveryRing && DOM_CACHE.streakRecoveryFill) {
                                DOM_CACHE.streakRecoveryRing.classList.add('visible');
                                DOM_CACHE.streakRecoveryFill.style.width = '100%';
                            }
                            // v1.60.0: Combo Grace Period Forgiveness Toast (Player Psychologist)
                            // v1.81.0: Toast moved to anticipatory position above (Psychology)
                            triggerHaptic([40, 20, 40, 20, 40]); // Rhythmic safety pulse
                            // ARIA announcement for grace period
                            if (DOM_CACHE.ariaAlertRegion) {
                                DOM_CACHE.ariaAlertRegion.textContent = 'Combo fading! 3 seconds to save it!';
                            }
                        } else if (timeSinceKill > CONFIG.comboWarningMs && STATE.comboMultiplier > 1) {
                            // Show warning when approaching decay
                            if (DOM_CACHE.comboDisplay) {
                                DOM_CACHE.comboDisplay.classList.add('combo-warning');
                            }
                        }
                    }
                }

                // Always update player and physics (v1.9.0: wrapped with safeUpdate)
                safeUpdate('player', updatePlayer);
                safeUpdate('phase', updatePhase);
                safeUpdate('projectiles', updateProjectiles);
                safeUpdate('collision', checkCollisions);
                safeUpdate('ui', updateUI);

                // v1.20.0: Health Warning Pulse (Audio Engineer)
                playHeartbeatPulse();

                // v1.39.0: High-Pass Filter for Critical Health (Audio Engineer)
                updateCriticalHealthFilter();

                // v1.21.0: Shield Depletion Rumble (Game Feel Expert)
                triggerShieldRumble();

                // v1.21.0: Momentum Cascade Reward (Player Psychologist)
                checkMomentumCascade();

                // v1.40.0: Shield Regeneration Prediction (UX Polish Specialist)
                updateShieldPrediction();

                // v1.40.0: Second Wind Expiry Check (Player Psychologist)
                updateSecondWind();

                // v1.49.0: Recovery Checkpoint Celebration (Player Psychologist)
                checkRecoveryCheckpoint();

                // v1.27.0: Progressive Mastery Unlocking (Player Psychologist)
                checkMasteries();

                // v1.56.0: Volatile Mini-Achievement Surprises (Player Psychologist)
                // Rare random micro-rewards trigger dopamine spikes - intermittent variable rewards
                checkVolatileSurprises();

                // v1.9.0: Deferred material update for phase transitions (Performance)
                if (STATE.phaseJustChanged) {
                    obstacles.forEach(obs => {
                        if (obs.type === 'physical') {
                            obs.mesh.material = STATE.isSpectral ? MATERIALS.spectralAsteroid : MATERIALS.asteroid;
                        } else if (obs.type === 'wall') {
                            obs.mesh.material = STATE.isSpectral ? MATERIALS.spectralWall : MATERIALS.wall;
                        }
                    });
                    STATE.phaseJustChanged = false;
                }

                // v1.1.0: Update trauma-based screen shake
                updateScreenShake(delta);

                // v1.11.0: Update camera zoom effect
                updateCameraZoom(delta);

                // v1.22.0: Phase-Linked Fog Shift (Visual Designer)
                updateFogTransition();

                // v1.11.0: Update momentum bar visualization
                safeUpdate('momentum', updateMomentumBar);
            }

            // v1.11.0: Adaptive Quality Scaling (runs even during non-playing states)
            updateQualitySystem();

            // Starfield effect
            if (starField) {
                starField.position.z += STATE.speed * 2;
                if (starField.position.z > 500) starField.position.z = 0;
            }

            // v1.30.0: Weapon Heat Decay & Glow Update (Visual Designer)
            // v1.55.0: Smooth Weapon Heat Glow Animation (Game Feel Expert) - lerp easing
            if (STATE.weaponHeat > 0 || (STATE.weaponHeatDisplay && STATE.weaponHeatDisplay > 0.001)) {
                const timeSinceShot = Date.now() - STATE.lastShotTime;
                if (timeSinceShot > HEAT_CONFIG.cooldownMs) {
                    STATE.weaponHeat = Math.max(0, STATE.weaponHeat - HEAT_CONFIG.decayRate);
                }
                // v1.55.0: Lerp display heat toward actual heat for smooth animation
                const lerpFactor = 0.15; // ~50ms effective smoothing at 60fps
                STATE.weaponHeatDisplay = STATE.weaponHeatDisplay || 0;
                STATE.weaponHeatDisplay += (STATE.weaponHeat - STATE.weaponHeatDisplay) * lerpFactor;
                const displayHeat = STATE.weaponHeatDisplay;
                // Update engine glow based on smoothed heat
                if (engineLight) {
                    const targetIntensity = HEAT_CONFIG.baseIntensity +
                        (HEAT_CONFIG.maxIntensity - HEAT_CONFIG.baseIntensity) * displayHeat;
                    engineLight.intensity = targetIntensity;
                    // Shift color from cyan to orange/red as heat increases
                    const r = displayHeat;
                    const g = 0.667 * (1 - displayHeat * 0.5);
                    const b = 1 - displayHeat;
                    engineLight.color.setRGB(r, g, b);
                }
                if (engineGlowMaterial) {
                    engineGlowMaterial.opacity = 0.8 + 0.2 * displayHeat;
                    // Same color shift for glow planes
                    const r = displayHeat;
                    const g = 1 - displayHeat * 0.3;
                    const b = 1 - displayHeat;
                    engineGlowMaterial.color.setRGB(r, g, b);
                }
            }

            // v1.56.0: Smooth Bloom Intensity Transitions (Visual Designer)
            // Lerp bloom strength toward target for fluid atmosphere changes
            if (QUALITY_SYSTEM.bloomPass && STATE.targetBloomStrength) {
                const currentStrength = QUALITY_SYSTEM.bloomPass.strength;
                const bloomLerpFactor = 0.08; // ~120ms effective transition at 60fps
                QUALITY_SYSTEM.bloomPass.strength += (STATE.targetBloomStrength - currentStrength) * bloomLerpFactor;
            }

            // v1.57.0: Phase-aware Light Intensity Ramping (Visual Designer)
            // Lerp light intensities for smooth phase transitions (spectral = dim, material = bright)
            if (dirLight && ambientLight) {
                const lightLerpFactor = 0.06; // ~170ms effective transition at 60fps
                dirLight.intensity += (STATE.targetDirLightIntensity - dirLight.intensity) * lightLerpFactor;
                ambientLight.intensity += (STATE.targetAmbientIntensity - ambientLight.intensity) * lightLerpFactor;

                // v1.86.0: Color Temperature Shift (Visual Designer)
                // Lerp light colors for warm/cool phase transitions
                const dr = dirLight.color.r, dg = dirLight.color.g, db = dirLight.color.b;
                dirLight.color.r += (STATE.targetDirLightColor.r - dr) * lightLerpFactor;
                dirLight.color.g += (STATE.targetDirLightColor.g - dg) * lightLerpFactor;
                dirLight.color.b += (STATE.targetDirLightColor.b - db) * lightLerpFactor;
                const ar = ambientLight.color.r, ag = ambientLight.color.g, ab = ambientLight.color.b;
                ambientLight.color.r += (STATE.targetAmbientColor.r - ar) * lightLerpFactor;
                ambientLight.color.g += (STATE.targetAmbientColor.g - ag) * lightLerpFactor;
                ambientLight.color.b += (STATE.targetAmbientColor.b - ab) * lightLerpFactor;
            }

            composer.render();
        }

        function setTutorialStep(step) {
            STATE.tutorialStep = step;
            STATE.tutorialTimer = Date.now();
            STATE.tutorialWaiting = true;
            
            const title = document.getElementById('tutorial-title');
            const text = document.getElementById('tutorial-text');
            const prompt = document.getElementById('tutorial-prompt');
            
            switch(step) {
                case 0:
                    title.innerText = "FLIGHT CONTROLS";
                    text.innerText = "Use W, A, S, D keys to pilot your ship.\nTry moving around the screen now.";
                    prompt.innerText = "Move to continue";
                    break;
                case 1:
                    title.innerText = "WEAPONS SYSTEMS";
                    text.innerText = "Press SPACE to fire your twin laser cannons.\nTargets in the Material Phase can be destroyed.";
                    prompt.innerText = "Fire to continue";
                    break;
                case 2:
                    title.innerText = "PHASE SHIFTING";
                    text.innerText = "Hold SHIFT to enter the SPECTRAL PHASE.\nThis consumes Phase Energy.";
                    prompt.innerText = "Hold SHIFT to continue";
                    break;
                case 3:
                    title.innerText = "SPECTRAL PHYSICS";
                    text.innerText = "In Spectral Phase, you can pass through physical objects like walls and asteroids.\n\nHowever, you cannot fire weapons.";
                    prompt.innerText = "Release SHIFT to continue";
                    break;
                case 4:
                    title.innerText = "TRAINING COMPLETE";
                    text.innerText = "You are ready for the mission.\n\nGood luck, pilot.";
                    prompt.innerText = "Press SPACE to launch";
                    break;
            }
        }

        function updateTutorial() {
            // Always move obstacles if they exist (for the practice step)
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];
                obs.mesh.position.z += STATE.speed;
                if (obs.mesh.position.z > 20) {
                    scene.remove(obs.mesh);
                    disposeMesh(obs.mesh); // v1.20.0
                    obstacles.splice(i, 1);
                }
            }

            // Step Logic
            switch(STATE.tutorialStep) {
                case 0: // Movement
                    if (keys.w || keys.a || keys.s || keys.d) {
                        if (Date.now() - STATE.tutorialTimer > 1000) {
                            setTutorialStep(1);
                        }
                    }
                    break;
                case 1: // Shooting
                    if (keys.space) {
                        if (Date.now() - STATE.tutorialTimer > 500) {
                            setTutorialStep(2);
                        }
                    }
                    break;
                case 2: // Phase Shift
                    if (keys.shift) {
                        if (Date.now() - STATE.tutorialTimer > 1000) {
                            setTutorialStep(3);
                        }
                    }
                    break;
                case 3: // Release Shift
                    if (!keys.shift) {
                        if (Date.now() - STATE.tutorialTimer > 1000) {
                            setTutorialStep(4);
                        }
                    }
                    break;
                case 4: // Finish
                    if (keys.space && Date.now() - STATE.tutorialTimer > 1000) {
                        STATE.tutorialMode = false;
                        document.getElementById('tutorial-overlay').classList.add('hidden');
                        showCommMessage("Training Complete. Beginning Mission.", 2000);
                        // v1.45.0: Mission Starting Toast (UX Polish Specialist)
                        setTimeout(() => {
                            TOAST_SYSTEM.show('narrative', 'MISSION STARTING...');
                        }, 2200);
                    }
                    break;
            }
        }

        function updatePlayer() {
            // v1.4.0: Movement Easing System (Game Feel Expert)
            // v1.8.0: Now uses centralized CONFIG values
            const acceleration = CONFIG.moveAcceleration;
            const friction = CONFIG.moveFriction;
            const maxSpeed = CONFIG.moveMaxSpeed;

            // Calculate target velocity from input
            let targetVelX = 0;
            let targetVelY = 0;

            // Mouse Influence (Virtual Joystick)
            const mouseTargetX = mouse.x * CONFIG.boundaryX;
            const mouseTargetY = mouse.y * CONFIG.boundaryY;

            // Add mouse influence to target
            targetVelX += (mouseTargetX - playerShip.position.x) * 0.03;
            targetVelY += (mouseTargetY - playerShip.position.y) * 0.03;

            // Keyboard input adds to velocity
            if (keys.w && playerShip.position.y < CONFIG.boundaryY) targetVelY += acceleration;
            if (keys.s && playerShip.position.y > -CONFIG.boundaryY) targetVelY -= acceleration;
            if (keys.a && playerShip.position.x > -CONFIG.boundaryX) targetVelX -= acceleration;
            if (keys.d && playerShip.position.x < CONFIG.boundaryX) targetVelX += acceleration;

            // v1.23.0: Reticle Breath-Zoom on Input (Game Feel Expert)
            // Scale reticle when movement keys pressed for immediate tactile feedback
            const hasMovementInput = keys.w || keys.a || keys.s || keys.d;
            if (DOM_CACHE.reticleOuter) {
                DOM_CACHE.reticleOuter.classList.toggle('input-active', hasMovementInput);
            }

            // Accelerate towards target with easing
            // v1.73.0: 0.18→0.22 for crispier directional response (Game Feel Expert)
            STATE.velocityX += (targetVelX - STATE.velocityX) * 0.22;
            STATE.velocityY += (targetVelY - STATE.velocityY) * 0.22;

            // Apply friction for smooth deceleration
            // v1.79.0: Directional friction asymmetry - backward momentum feels heavier (Game Feel)
            const frictionX = STATE.velocityX < 0 ? friction * 0.87 : friction; // 1.15x deceleration backward
            const frictionY = STATE.velocityY < 0 ? friction * 0.87 : friction;
            STATE.velocityX *= frictionX;
            STATE.velocityY *= frictionY;

            // v1.38.0: Weapon Recoil Knockback (Game Feel Expert)
            // Apply recoil damping when firing for "gun weight" feel
            if (STATE.recoilActive && STATE.recoilDamping > 0) {
                const recoilFactor = 1 - STATE.recoilDamping;
                STATE.velocityX *= recoilFactor;
                STATE.velocityY *= recoilFactor;
            }

            // Clamp velocity
            STATE.velocityX = Math.max(-maxSpeed, Math.min(maxSpeed, STATE.velocityX));
            STATE.velocityY = Math.max(-maxSpeed, Math.min(maxSpeed, STATE.velocityY));

            // Apply velocity to position
            playerShip.position.x += STATE.velocityX;
            playerShip.position.y += STATE.velocityY;

            // Clamp position to boundaries
            playerShip.position.x = Math.max(-CONFIG.boundaryX, Math.min(CONFIG.boundaryX, playerShip.position.x));
            playerShip.position.y = Math.max(-CONFIG.boundaryY, Math.min(CONFIG.boundaryY, playerShip.position.y));

            // v1.42.0: Velocity Signature Sampling (Player Psychologist)
            // Sample velocity periodically to detect playstyle
            const now = Date.now();
            const speedMagnitude = Math.sqrt(STATE.velocityX ** 2 + STATE.velocityY ** 2);

            // v1.47.0: Velocity-Based Screen Blur Effect (Game Feel Expert)
            // Apply subtle blur when exceeding 80% of max speed for immersive feel
            const speedRatio = speedMagnitude / maxSpeed;
            if (speedRatio > 0.8) {
                document.body.classList.add('velocity-blur');
            } else {
                document.body.classList.remove('velocity-blur');
            }

            // v1.48.0: Dimensional Depth Vignette (Visual Designer)
            // Darken screen edges at high velocity for tunnel vision immersion
            if (speedRatio > 0.7) {
                document.body.classList.add('vignette-active');
            } else {
                document.body.classList.remove('vignette-active');
            }

            if (now - STATE.lastVelocitySampleTime >= STATE.velocitySampleInterval) {
                STATE.velocitySamples.push(speedMagnitude / maxSpeed); // Normalize 0-1
                STATE.lastVelocitySampleTime = now;
                // Keep only last 120 samples (1 minute of data at 500ms intervals)
                if (STATE.velocitySamples.length > 120) STATE.velocitySamples.shift();
            }

            // Banking / Leaning
            const targetRotZ = (keys.a ? 1 : 0) * CONFIG.maxLean + (keys.d ? -1 : 0) * CONFIG.maxLean + (-mouse.x * CONFIG.maxLean);
            const targetRotX = (keys.w ? 1 : 0) * 0.2 + (keys.s ? -1 : 0) * 0.2 + (mouse.y * 0.2);
            
            playerShip.rotation.z += (targetRotZ - playerShip.rotation.z) * 0.1;
            playerShip.rotation.x += (targetRotX - playerShip.rotation.x) * 0.1;

            // Camera Follow
            camera.position.x += (playerShip.position.x * 0.5 - camera.position.x) * 0.1;
            camera.position.y += (playerShip.position.y * 0.5 + 2 - camera.position.y) * 0.1;

            // v1.62.0: Firing Recoil Knockback Visual (Game Feel Expert)
            // Apply subtle camera rotation bias during recoil for directional punch feedback
            const recoilRotation = STATE.recoilActive ? -0.015 * STATE.recoilDamping : 0;
            camera.rotation.x += (recoilRotation - camera.rotation.x * 0.3) * 0.25;

            // Shooting
            if ((keys.space || mouse.left) && !STATE.isSpectral && Date.now() - lastShotTime > CONFIG.shootCooldown) {
                fireLaser();
                lastShotTime = Date.now();
            }
        }

        function updatePhase() {
            // Toggle Phase
            if ((keys.shift || mouse.right) && STATE.phaseEnergy > 0) {
                if (!STATE.isSpectral) {
                    enterSpectralPhase();
                }
                STATE.phaseEnergy -= CONFIG.phaseDrainRate;
                if (STATE.phaseEnergy <= 0) {
                    exitSpectralPhase();
                    // v1.50.0: Phase Energy Depleted Tone (Audio Engineer)
                    playPhaseDepletedTone();
                }
            } else if ((keys.shift || mouse.right) && STATE.phaseEnergy <= 0 && !STATE.phaseDepletedPlayed) {
                // v1.50.0: Play depleted tone when trying to use empty phase
                playPhaseDepletedTone();
                STATE.phaseDepletedPlayed = true;
            } else {
                if (STATE.isSpectral) {
                    exitSpectralPhase();
                }
                if (STATE.phaseEnergy < 100) {
                    STATE.phaseEnergy += CONFIG.phaseRechargeRate;
                    // v1.27.0: Phase Recharge Audio Chirps (Audio Engineer)
                    playPhaseRechargeChirp();
                    // Reset depleted flag once recharging
                    if (STATE.phaseEnergy > 5) STATE.phaseDepletedPlayed = false;
                }
            }
        }

        // v1.25.0: Phase Transition Scene Saturation Dip (Visual Designer)
        function triggerSaturationDip() {
            if (STATE.reducedMotion) return;
            document.body.classList.add('phase-transitioning');
            // v1.72.0: 700ms→500ms to align with phase shift sound duration (Game Feel)
            setTimeout(() => document.body.classList.remove('phase-transitioning'), 500);
        }

        function enterSpectralPhase() {
            STATE.isSpectral = true;

            // v1.46.0: Bloom Strength Phase-State Modulation (Visual Designer)
            // v1.56.0: Smooth Bloom Intensity Transitions (Visual Designer)
            // v1.89.0: Phase Transition Bloom Pulse Asymmetry (Visual Designer)
            // Quick spike to 2.4 then slow decay to 1.8 for visual "pop"
            if (QUALITY_SYSTEM.bloomPass) {
                QUALITY_SYSTEM.bloomPass.strength = 2.4;  // Immediate spike
                STATE.targetBloomStrength = 1.8;  // Target for slow decay
            }

            // v1.57.0: Phase-aware Light Intensity Ramping (Visual Designer)
            // Dim lights in spectral for "weightless void" feeling
            STATE.targetDirLightIntensity = 1.2;
            STATE.targetAmbientIntensity = 1.5;

            // v1.86.0: Cool Blue-White Color Temperature (7000K) for Spectral Phase
            STATE.targetDirLightColor = { r: 0.78, g: 0.90, b: 1.0 };  // Cool blue-white
            STATE.targetAmbientColor = { r: 0.15, g: 0.22, b: 0.30 };  // Cool ambient

            // v1.25.0: Phase Transition Scene Saturation Dip
            triggerSaturationDip();

            // v1.2.0: Phase Shift Feedback Pulse
            triggerPhasePulse();

            // v1.10.0: Phase transition sound and particles
            playPhaseShiftSound(true);
            createPhaseTransitionBurst(true);

            // v1.13.0: Haptic feedback for spectral entry
            triggerHaptic(HAPTIC_PATTERNS.phaseIn);

            // Visuals
            playerShip.children.forEach(child => {
                if (child.material) {
                    child.userData.originalMat = child.material;
                    child.material = MATERIALS.spectralShip;
                }
            });

            // v1.22.0: Set fog target for animated transition (Visual Designer)
            // v1.80.0: Enhanced dark-cyan fog for spectral phase (Visual)
            STATE.targetFogColor = { r: 0, g: 0x28 / 255, b: 0x38 / 255 };
            scene.background = new THREE.Color(0x002838);
            // v1.84.0: Fog Density Phase Modulation (Visual Designer)
            // Denser fog in spectral for ethereal separation
            if (scene.fog) scene.fog.density = 0.022;

            // v1.9.0: Mark phase changed for deferred material update (Performance)
            STATE.phaseJustChanged = true;

            // v1.13.0: Use cached DOM reference
            if (DOM_CACHE.phaseIndicator) {
                DOM_CACHE.phaseIndicator.className = 'phase-spectral';
                DOM_CACHE.phaseIndicator.innerText = 'SPECTRAL PHASE';
            }
        }

        function exitSpectralPhase() {
            STATE.isSpectral = false;

            // v1.46.0: Bloom Strength Phase-State Modulation (Visual Designer)
            // v1.56.0: Smooth Bloom Intensity Transitions (Visual Designer)
            // v1.89.0: Phase Transition Bloom Pulse Asymmetry (Visual Designer)
            // Quick spike to 2.1 then slow decay to 1.4 for visual "pop"
            if (QUALITY_SYSTEM.bloomPass) {
                QUALITY_SYSTEM.bloomPass.strength = 2.1;  // Immediate spike
                STATE.targetBloomStrength = 1.4;  // Target for slow decay
            }

            // v1.57.0: Phase-aware Light Intensity Ramping (Visual Designer)
            // Brighten lights in material realm for "grounded solidity" feeling
            STATE.targetDirLightIntensity = 2.2;  // Brief punch of brightness on exit
            STATE.targetAmbientIntensity = 2.0;

            // v1.86.0: Warm White Color Temperature (2800K) for Material Phase
            STATE.targetDirLightColor = { r: 1.0, g: 0.98, b: 0.92 };  // Warm white
            STATE.targetAmbientColor = { r: 0.2, g: 0.27, b: 0.33 };   // Warm ambient

            // v1.25.0: Phase Transition Scene Saturation Dip
            triggerSaturationDip();

            // v1.2.0: Phase Shift Feedback Pulse
            triggerPhasePulse();

            // v1.10.0: Phase transition sound and particles
            playPhaseShiftSound(false);
            createPhaseTransitionBurst(false);

            // v1.13.0: Haptic feedback for spectral exit
            triggerHaptic(HAPTIC_PATTERNS.phaseOut);

            // Visuals
            playerShip.children.forEach(child => {
                if (child.userData.originalMat) {
                    child.material = child.userData.originalMat;
                }
            });

            // v1.22.0: Set fog target for animated transition (Visual Designer)
            STATE.targetFogColor = { r: 0, g: 0, b: 0 };
            scene.background = new THREE.Color(0x000000);
            // v1.84.0: Fog Density Phase Modulation (Visual Designer)
            // Lighter fog in material phase for clarity
            if (scene.fog) scene.fog.density = 0.012;

            // v1.9.0: Mark phase changed for deferred material update (Performance)
            STATE.phaseJustChanged = true;

            // v1.13.0: Use cached DOM reference
            if (DOM_CACHE.phaseIndicator) {
                DOM_CACHE.phaseIndicator.className = 'phase-physical';
                DOM_CACHE.phaseIndicator.innerText = 'MATERIAL PHASE';
            }
        }

        function fireLaser() {
            // v1.3.0: Play laser sound
            playLaserSound();

            // v1.39.0: Weapon Charge-Up Spin Effect (Game Feel Expert)
            // Trigger ascending spin-up tone at start of new firing sequence
            const now = Date.now();
            const timeSinceLastFire = now - STATE.lastFireTime;
            if (timeSinceLastFire > 300) {
                // New firing sequence detected - play charge-up spin
                STATE.chargeUpActive = true;
                STATE.chargeUpStartTime = now;
                playChargeUpSpinSound();

                // Apply reticle acceleration animation
                if (DOM_CACHE.reticleOuter) {
                    DOM_CACHE.reticleOuter.classList.add('charge-spin');
                    // v1.73.0: 200ms→140ms for snappier burst fire rhythm (Game Feel)
                    setTimeout(() => {
                        DOM_CACHE.reticleOuter.classList.remove('charge-spin');
                        STATE.chargeUpActive = false;
                    }, 140);
                }
            }
            STATE.lastFireTime = now;

            const laserGeo = new THREE.BoxGeometry(0.2, 0.2, 4);
            const laser = new THREE.Mesh(laserGeo, MATERIALS.laser);

            // Left Gun
            const l1 = laser.clone();
            l1.position.copy(playerShip.position);
            l1.position.x -= 1.5;
            l1.position.z -= 2;
            scene.add(l1);
            // v1.33.0: Add velocity onion rings (Game Feel Expert)
            const rings1 = createVelocityRings(l1);
            projectiles.push({ mesh: l1, velocity: new THREE.Vector3(0, 0, -3), isPlayer: true, velocityRings: rings1 });

            // Right Gun
            const l2 = laser.clone();
            l2.position.copy(playerShip.position);
            l2.position.x += 1.5;
            l2.position.z -= 2;
            scene.add(l2);
            // v1.33.0: Add velocity onion rings (Game Feel Expert)
            const rings2 = createVelocityRings(l2);
            projectiles.push({ mesh: l2, velocity: new THREE.Vector3(0, 0, -3), isPlayer: true, velocityRings: rings2 });

            // v1.27.0: Firing Recoil & Camera Pull (Game Feel Expert)
            // v1.64.0: Unified to 100ms firing feedback timing (Game Feel Expert)
            CAMERA_ZOOM.targetZ = CAMERA_ZOOM.baseZ + 0.3;  // Pull back slightly
            setTimeout(() => {
                CAMERA_ZOOM.targetZ = CAMERA_ZOOM.baseZ;  // Return to normal
            }, 100);

            // Reticle pulse effect
            if (DOM_CACHE.reticleOuter) {
                DOM_CACHE.reticleOuter.classList.add('firing-pulse');
                // v1.63.0: Unified to 100ms firing feedback timing (Game Feel Expert)
                setTimeout(() => DOM_CACHE.reticleOuter.classList.remove('firing-pulse'), 100);
            }

            // v1.30.0: Reticle Convergence on Firing (UX Polish Specialist)
            if (DOM_CACHE.reticleOuter && DOM_CACHE.reticleInner) {
                DOM_CACHE.reticleOuter.classList.add('firing-converge');
                DOM_CACHE.reticleInner.classList.add('firing-converge');
                // v1.63.0: Unified to 100ms firing feedback timing (Game Feel Expert)
                setTimeout(() => {
                    DOM_CACHE.reticleOuter.classList.remove('firing-converge');
                    DOM_CACHE.reticleInner.classList.remove('firing-converge');
                }, 100);
            }

            // v1.30.0: Weapon Heat Buildup (Visual Designer)
            STATE.weaponHeat = Math.min(1, STATE.weaponHeat + HEAT_CONFIG.buildupRate);
            STATE.lastShotTime = Date.now();

            // v1.38.0: Weapon Recoil Knockback (Game Feel Expert)
            // Apply brief velocity dampening for "gun weight" feel
            STATE.recoilActive = true;
            STATE.recoilDamping = 0.35; // 35% velocity reduction
            // v1.64.0: Unified to 100ms firing feedback timing (Game Feel Expert)
            setTimeout(() => {
                STATE.recoilActive = false;
                STATE.recoilDamping = 0;
            }, 100);
        }

        function updateEnvironment() {
            // Spawn Obstacles (v1.8.0: uses CONFIG values)
            if (Math.random() < CONFIG.obstacleSpawnRate * STATE.difficulty) {
                spawnObstacle();
            }

            // Move Obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];
                obs.mesh.position.z += STATE.speed;
                
                // Rotate asteroids
                if (obs.type === 'physical') {
                    obs.mesh.rotation.x += 0.01;
                    obs.mesh.rotation.y += 0.01;
                }

                if (obs.mesh.position.z > 20) {
                    // v1.3.0: Check for near-miss bonus before removing
                    // v1.91.0: Pass obstacle type for damage mitigation messaging
                    checkNearMiss(obs.mesh.position, obs.type);
                    scene.remove(obs.mesh);
                    disposeMesh(obs.mesh); // v1.20.0
                    obstacles.splice(i, 1);
                }
            }
        }

        // v1.14.0: Refactored to use CONFIG values for spawn system
        function spawnObstacle() {
            const typeRoll = Math.random();
            let mesh, type, radius;

            const x = (Math.random() - 0.5) * CONFIG.boundaryX * 2;
            const y = (Math.random() - 0.5) * CONFIG.boundaryY * 2;
            const z = CONFIG.spawnDistance;

            if (typeRoll < CONFIG.asteroidChance) {
                // Asteroid (Physical)
                const asteroidSize = Math.random() * (CONFIG.asteroidMaxRadius - CONFIG.asteroidMinRadius) + CONFIG.asteroidMinRadius;
                const geo = new THREE.DodecahedronGeometry(asteroidSize, 0);
                const mat = STATE.isSpectral ? MATERIALS.spectralAsteroid : MATERIALS.asteroid;
                mesh = new THREE.Mesh(geo, mat);
                type = 'physical';
                radius = 2;
            } else if (typeRoll < CONFIG.wallChance) {
                // Wall (Physical)
                const geo = new THREE.BoxGeometry(CONFIG.wallWidth, CONFIG.wallHeight, CONFIG.wallDepth);
                const mat = STATE.isSpectral ? MATERIALS.spectralWall : MATERIALS.wall;
                mesh = new THREE.Mesh(geo, mat);
                type = 'wall';
                radius = 4;
            } else {
                // Energy Barrier (Spectral Hazard)
                const geo = new THREE.TorusGeometry(CONFIG.barrierRadius, CONFIG.barrierTubeRadius, 8, 16);
                mesh = new THREE.Mesh(geo, MATERIALS.energyBarrier);
                type = 'energy';
                radius = CONFIG.barrierRadius;

                // Add glow light
                const light = new THREE.PointLight(0x00ffff, 1, 10);
                mesh.add(light);
            }

            mesh.position.set(x, y, z);
            mesh.frustumCulled = true; // v1.21.0: Skip rendering off-screen (Performance)
            scene.add(mesh);
            obstacles.push({ mesh, type, radius });
        }

        function updateEnemies() {
            // Spawn Enemies (v1.8.0: uses CONFIG values)
            if (Math.random() < CONFIG.enemySpawnRate * STATE.difficulty && enemies.length < CONFIG.maxEnemies) {
                spawnEnemy();
            }

            // Update Enemies
            // v1.70.0: Cache Date.now() at loop start to eliminate syscalls (Performance Optimizer)
            const now = Date.now();
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                
                // Move towards player slightly
                enemy.mesh.position.z += STATE.speed * 1.2; // Faster than environment
                enemy.mesh.position.x += (playerShip.position.x - enemy.mesh.position.x) * 0.01;
                enemy.mesh.position.y += (playerShip.position.y - enemy.mesh.position.y) * 0.01;

                // v1.42.0: Sync glow mesh position with enemy (Visual Designer)
                // v1.43.0: Billboard orientation toward camera (Performance Optimizer)
                // v1.88.0: Nested Glow Aura Rings (Visual Designer)
                if (enemy.glowMesh) {
                    enemy.glowMesh.position.copy(enemy.mesh.position);
                    enemy.glowMesh.lookAt(camera.position);
                    // Subtle pulsing effect for elite/boss enemies
                    if (enemy.threatTier === 'elite' || enemy.threatTier === 'boss') {
                        const pulse = 1 + Math.sin(now * 0.005) * 0.15;
                        enemy.glowMesh.scale.setScalar(pulse);
                    }
                }
                // v1.88.0: Sync outer glow ring position (static, no pulse)
                if (enemy.outerGlowMesh) {
                    enemy.outerGlowMesh.position.copy(enemy.mesh.position);
                    enemy.outerGlowMesh.lookAt(camera.position);
                }

                // v1.92.0: Phantom Threat Audio Cue when enemy behind player (Psychology)
                if (enemy.mesh.position.z > 5) {
                    playPhantomThreatChirp(enemy.mesh.position.x);
                }

                // Shoot (v1.8.0: uses CONFIG cooldown)
                // v1.81.0: Use cached geometry to eliminate per-shot allocation (Performance)
                if (now - enemy.lastShot > CONFIG.enemyShootCooldownMs) {
                    const laser = new THREE.Mesh(CACHED_GEOMETRIES.enemyLaser, MATERIALS.enemyLaser);
                    laser.position.copy(enemy.mesh.position);
                    scene.add(laser);

                    // Aim at player
                    // v1.58.0: Reuse temp vector to avoid GC pressure (Performance Optimizer)
                    _tempDirection.subVectors(playerShip.position, enemy.mesh.position).normalize();
                    projectiles.push({
                        mesh: laser,
                        velocity: _tempDirection.clone().multiplyScalar(1.5),
                        isPlayer: false,
                        trailTimer: 0 // v1.41.0: Enemy Projectile Tracer Glow
                    });

                    enemy.lastShot = now;
                }

                if (enemy.mesh.position.z > 20) {
                    scene.remove(enemy.mesh);
                    disposeMesh(enemy.mesh); // v1.20.0
                    // v1.42.0: Remove glow mesh when enemy leaves screen
                    if (enemy.glowMesh) {
                        scene.remove(enemy.glowMesh);
                        disposeMesh(enemy.glowMesh);
                    }
                    // v1.88.0: Remove outer glow ring
                    if (enemy.outerGlowMesh) {
                        scene.remove(enemy.outerGlowMesh);
                        disposeMesh(enemy.outerGlowMesh);
                    }
                    enemies.splice(i, 1);
                }
            }
        }

        function spawnEnemy() {
            const geo = new THREE.ConeGeometry(1, 3, 4);
            geo.rotateX(-Math.PI / 2);
            const mesh = new THREE.Mesh(geo, MATERIALS.enemyShip);

            const x = (Math.random() - 0.5) * CONFIG.boundaryX * 1.5;
            const y = (Math.random() - 0.5) * CONFIG.boundaryY * 1.5;

            mesh.position.set(x, y, -150);
            mesh.frustumCulled = true; // v1.21.0: Skip rendering off-screen (Performance)
            scene.add(mesh);

            // v1.42.0: Enemy Threat Tier Silhouette Glow (Visual Designer)
            // Determine threat tier based on game time elapsed
            const sessionElapsed = (Date.now() - STATE.sessionStartTime) / 1000;
            let threatTier, glowMaterial;
            if (sessionElapsed < 30) {
                threatTier = 'weak';
                glowMaterial = MATERIALS.threatGlowWeak;
            } else if (sessionElapsed < 60) {
                threatTier = 'normal';
                glowMaterial = MATERIALS.threatGlowNormal;
            } else if (sessionElapsed < 120) {
                threatTier = 'elite';
                glowMaterial = MATERIALS.threatGlowElite;
            } else {
                threatTier = 'boss';
                glowMaterial = MATERIALS.threatGlowBoss;
            }

            // v1.43.0: Billboard Glow Simplification (Performance Optimizer)
            // Use PlaneGeometry instead of SphereGeometry (128 verts → 4 verts per enemy)
            // v1.88.0: Nested Glow Aura Rings (Visual Designer) - inner 0.8x + outer 1.4x
            let glowMesh = null;
            let outerGlowMesh = null;
            if (!STATE.reducedMotion) {
                // Inner pulsing ring (0.8x scale)
                const glowGeo = new THREE.PlaneGeometry(3.2, 3.2);
                glowMesh = new THREE.Mesh(glowGeo, glowMaterial);
                glowMesh.position.copy(mesh.position);
                glowMesh.lookAt(camera.position);
                scene.add(glowMesh);
                // Outer static ring (1.4x scale, lower opacity)
                const outerGeo = new THREE.PlaneGeometry(5.6, 5.6);
                const outerMat = glowMaterial.clone();
                outerMat.opacity = glowMaterial.opacity * 0.4;
                outerGlowMesh = new THREE.Mesh(outerGeo, outerMat);
                outerGlowMesh.position.copy(mesh.position);
                outerGlowMesh.lookAt(camera.position);
                scene.add(outerGlowMesh);
            }

            enemies.push({ mesh, hp: CONFIG.enemyBaseHp, lastShot: Date.now(), threatTier, glowMesh, outerGlowMesh });

            if (Math.random() < 0.3) {
                showCommMessage("Bogey on your six! ...Wait, twelve o'clock!", 2000);
            }
        }

        function updateProjectiles() {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.mesh.position.add(p.velocity);

                // v1.29.0: Spawn trail particles for player lasers
                if (p.isPlayer && !STATE.reducedMotion && laserTrails.length < TRAIL_CONFIG.maxTrails) {
                    p.trailCounter = (p.trailCounter || 0) + 1;
                    if (p.trailCounter >= TRAIL_CONFIG.spawnInterval) {
                        p.trailCounter = 0;
                        spawnLaserTrail(p.mesh.position);
                    }
                }

                // v1.41.0: Enemy Projectile Tracer Glow (Game Feel Expert)
                if (!p.isPlayer && !STATE.reducedMotion && laserTrails.length < TRAIL_CONFIG.maxTrails) {
                    p.trailTimer = (p.trailTimer || 0) + 1;
                    if (p.trailTimer >= TRAIL_CONFIG.spawnInterval * 1.5) { // Slightly slower spawn rate
                        p.trailTimer = 0;
                        spawnEnemyLaserTrail(p.mesh.position);
                    }
                }

                // v1.33.0: Update velocity onion rings (Game Feel Expert)
                // Rings expand and fade as projectile ages
                if (p.velocityRings && p.velocityRings.length > 0) {
                    for (const ring of p.velocityRings) {
                        // v1.64.0: Skip math for fully faded rings (Performance Optimizer)
                        // v1.80.0: Raised threshold to 0.05 for earlier skip (Performance)
                        if (ring.mesh.material.opacity < 0.05) continue;
                        ring.age += 1;
                        // Expand rings over time (velocity dissipation effect)
                        const expansion = 1 + (ring.age * VELOCITY_RING_CONFIG.expansionRate);
                        const newScale = Math.min(ring.baseScale * expansion, VELOCITY_RING_CONFIG.maxScale);
                        ring.mesh.scale.set(newScale, newScale, 1);
                        // v1.44.0: Asymmetric fade - inner rings fade fast, outer rings linger
                        const fadeRate = VELOCITY_RING_CONFIG.fadeRates[ring.ringIndex] || 0.01;
                        ring.mesh.material.opacity = Math.max(0, ring.mesh.material.opacity - fadeRate);
                    }
                }

                // Cleanup
                if (p.mesh.position.z < -300 || p.mesh.position.z > 50) {
                    scene.remove(p.mesh);
                    disposeMesh(p.mesh); // v1.20.0
                    projectiles.splice(i, 1);
                }
            }

            // v1.29.0: Update and fade trail particles
            updateLaserTrails();
            // v1.43.0: Update spark spray particles (Game Feel Expert)
            updateHitSparks();
        }

        // v1.29.0: Projectile Trail & Impact Flash (Visual Designer)
        const trailGeometry = new THREE.SphereGeometry(TRAIL_CONFIG.size, 4, 4);
        // v1.37.0: Geometry Reuse for Impact Flash (Performance Optimizer)
        const impactFlashGeometry = new THREE.SphereGeometry(0.4, 6, 6);

        function spawnLaserTrail(position) {
            const trailMat = MATERIALS.laserTrail.clone();
            trailMat.opacity = 0.5;
            const trail = new THREE.Mesh(trailGeometry, trailMat);
            trail.position.copy(position);
            scene.add(trail);
            laserTrails.push({ mesh: trail, opacity: 0.5 });
        }

        // v1.41.0: Enemy Projectile Tracer Glow (Game Feel Expert)
        function spawnEnemyLaserTrail(position) {
            const trailMat = MATERIALS.enemyLaserTrail.clone();
            trailMat.opacity = 0.4;
            const trail = new THREE.Mesh(trailGeometry, trailMat);
            trail.position.copy(position);
            trail.scale.set(0.8, 0.8, 0.8); // Slightly smaller than player trails
            scene.add(trail);
            laserTrails.push({ mesh: trail, opacity: 0.4 });
        }

        function updateLaserTrails() {
            for (let i = laserTrails.length - 1; i >= 0; i--) {
                const t = laserTrails[i];
                t.opacity -= TRAIL_CONFIG.fadeSpeed;
                t.mesh.material.opacity = t.opacity;

                if (t.opacity <= 0) {
                    scene.remove(t.mesh);
                    t.mesh.geometry = null;
                    t.mesh.material.dispose();
                    laserTrails.splice(i, 1);
                }
            }
        }

        // v1.43.0: Multi-Hit Spark Spray System (Game Feel Expert)
        const sparkGeometry = new THREE.PlaneGeometry(0.15, 0.15);
        const SPARK_CONFIG = {
            maxSparks: 30,
            fadeSpeed: 0.12,
            spreadRadius: 0.8,
            velocityMin: 0.1,
            velocityMax: 0.3
        };

        function spawnHitSpark(position) {
            if (STATE.reducedMotion || hitSparks.length >= SPARK_CONFIG.maxSparks) return;
            const sparkMat = MATERIALS.hitSpark.clone();
            const spark = new THREE.Mesh(sparkGeometry, sparkMat);
            // Random offset within spread radius
            spark.position.set(
                position.x + (Math.random() - 0.5) * SPARK_CONFIG.spreadRadius,
                position.y + (Math.random() - 0.5) * SPARK_CONFIG.spreadRadius,
                position.z + (Math.random() - 0.5) * SPARK_CONFIG.spreadRadius * 0.5
            );
            spark.lookAt(camera.position); // Billboard facing
            scene.add(spark);
            // Random velocity for spray effect
            const angle = Math.random() * Math.PI * 2;
            const speed = SPARK_CONFIG.velocityMin + Math.random() * (SPARK_CONFIG.velocityMax - SPARK_CONFIG.velocityMin);
            hitSparks.push({
                mesh: spark,
                opacity: 0.8,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed
            });
        }

        function updateHitSparks() {
            for (let i = hitSparks.length - 1; i >= 0; i--) {
                const s = hitSparks[i];
                s.opacity -= SPARK_CONFIG.fadeSpeed;
                s.mesh.material.opacity = s.opacity;
                s.mesh.position.x += s.vx;
                s.mesh.position.y += s.vy;
                s.mesh.lookAt(camera.position); // Keep facing camera
                if (s.opacity <= 0) {
                    scene.remove(s.mesh);
                    s.mesh.material.dispose();
                    hitSparks.splice(i, 1);
                }
            }
        }

        function createImpactFlash(position) {
            if (STATE.reducedMotion) return;
            // v1.37.0: Geometry Reuse for Impact Flash (Performance Optimizer)
            // Use cached impactFlashGeometry instead of creating new geometry each hit
            const flashMat = MATERIALS.impactFlash.clone();
            const flash = new THREE.Mesh(impactFlashGeometry, flashMat);
            flash.position.copy(position);
            flash.scale.set(1, 1, 1); // Reset scale for reused geometry
            scene.add(flash);

            // Rapid fade out
            let opacity = 0.9;
            const fadeInterval = setInterval(() => {
                opacity -= 0.15;
                flashMat.opacity = opacity;
                flash.scale.multiplyScalar(1.15);
                if (opacity <= 0) {
                    clearInterval(fadeInterval);
                    scene.remove(flash);
                    // v1.37.0: Don't dispose cached geometry - only dispose material
                    flashMat.dispose();
                }
            }, 16);
        }

        function checkCollisions() {
            // v1.5.0: Use cached Box3 objects instead of creating new ones each frame
            COLLISION_CACHE.playerBox.setFromObject(playerShip);

            // 1. Player vs Obstacles (v1.8.0: uses safe getters)
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];
                // v1.8.0: Use bounds-checked getter instead of modulo
                const obsBox = COLLISION_CACHE.getObstacleBox(i);
                obsBox.setFromObject(obs.mesh);

                if (COLLISION_CACHE.playerBox.intersectsBox(obsBox)) {
                    // v1.26.0: Calculate damage direction from obstacle position
                    const dirX = Math.sign(obs.mesh.position.x - playerShip.position.x);
                    const dirY = Math.sign(obs.mesh.position.y - playerShip.position.y);

                    if (STATE.isSpectral) {
                        // Spectral Phase Logic
                        if (obs.type === 'energy') {
                            takeDamage(CONFIG.collisionDamage.spectralEnergy, dirX, dirY);
                            createExplosion(playerShip.position, 0x00ffff);
                            scene.remove(obs.mesh);
                            disposeMesh(obs.mesh); // v1.20.0
                            obstacles.splice(i, 1);
                        } else if (obs.type === 'physical' || obs.type === 'wall') {
                            // v1.5.0: Perfect Dodge - phasing through physical obstacles!
                            awardPerfectDodge();
                        }
                    } else {
                        // Material Phase Logic
                        if (obs.type === 'physical' || obs.type === 'wall') {
                            takeDamage(CONFIG.collisionDamage.materialPhysical, dirX, dirY);
                            createExplosion(playerShip.position, 0xffaa00);
                            scene.remove(obs.mesh);
                            disposeMesh(obs.mesh); // v1.20.0
                            obstacles.splice(i, 1);
                        }
                        // Pass through energy objects safely (maybe?)
                    }
                }
            }

            // 2. Player Lasers vs Enemies (v1.8.0: uses safe getters)
            // v1.60.0: For-loop with continue for early-exit efficiency (Performance Optimizer)
            for (let pIdx = projectiles.length - 1; pIdx >= 0; pIdx--) {
                const p = projectiles[pIdx];
                if (!p.isPlayer) continue;
                // v1.8.0: Use bounds-checked getters
                const pBox = COLLISION_CACHE.getProjectileBox(pIdx);
                pBox.setFromObject(p.mesh);

                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    // v1.8.0: Use bounds-checked getter
                    const eBox = COLLISION_CACHE.getEnemyBox(i);
                    eBox.setFromObject(enemy.mesh);

                    if (pBox.intersectsBox(eBox)) {
                        enemy.hp--;
                        scene.remove(p.mesh);
                        disposeMesh(p.mesh); // v1.20.0
                        projectiles.splice(pIdx, 1);

                        // v1.29.0: Impact Flash on hit (Visual Designer)
                        createImpactFlash(p.mesh.position);
                        createExplosion(p.mesh.position, 0xff0000, 0.5);
                        // v1.43.0: Multi-Hit Spark Spray (Game Feel Expert)
                        // Spawn 2-3 sparks per hit for spray effect
                        for (let s = 0; s < 2 + Math.floor(Math.random() * 2); s++) {
                            spawnHitSpark(p.mesh.position);
                        }
                        // v1.42.0: Hit Impact Camera Shake (Game Feel Expert)
                        // Subtle camera shake on successful hits - intensity scales with hit
                        triggerShake(0.08);
                        // v1.83.0: Enemy Hit Confirmation Audio (Game Feel Expert)
                        playHitConfirmationSound(enemy.mesh.position.x);

                        if (enemy.hp <= 0) {
                            // v1.72.0: Impact zoom FIRST for 0ms latency (Game Feel Expert)
                            const killZoom = 0.4 + Math.min(1.6, (STATE.comboMultiplier - 1) * 0.4);
                            triggerImpactZoom(killZoom);
                            createExplosion(enemy.mesh.position, 0xff8800, 2);
                            // v1.31.0: Enemy Defeat Sparkle Burst (UX/Visual)
                            createSparkleBurst(enemy.mesh.position);
                            // v1.10.0: Spatial explosion sound (Audio Engineer)
                            playExplosionSound(enemy.mesh.position.x);
                            // v1.87.0: Reticle Kill Confirmation Pulse (Game Feel)
                            if (DOM_CACHE.reticleOuter && !STATE.reducedMotion) {
                                DOM_CACHE.reticleOuter.classList.remove('kill-confirm');
                                void DOM_CACHE.reticleOuter.offsetWidth;
                                DOM_CACHE.reticleOuter.classList.add('kill-confirm');
                                setTimeout(() => DOM_CACHE.reticleOuter.classList.remove('kill-confirm'), 200);
                            }
                            // v1.38.0: Enemy Death Dissolution (Visual Designer)
                            // v1.55.0: Enemy Kill Feedback Timing Alignment (Player Psychology)
                            // Delay dissolution 150ms to let sparkle burst register visually before fade begins
                            const dissolutionMesh = enemy.mesh;
                            const dissolutionPos = enemy.mesh.position.clone();
                            setTimeout(() => {
                                if (dissolutionMesh && dissolutionMesh.parent) {
                                    startEnemyDissolution(dissolutionMesh, dissolutionPos);
                                }
                            }, 150);
                            // v1.42.0: Remove glow mesh on enemy death
                            if (enemy.glowMesh) {
                                scene.remove(enemy.glowMesh);
                                disposeMesh(enemy.glowMesh);
                            }
                            // v1.88.0: Remove outer glow ring on death
                            if (enemy.outerGlowMesh) {
                                scene.remove(enemy.outerGlowMesh);
                                disposeMesh(enemy.outerGlowMesh);
                            }
                            enemies.splice(i, 1);
                            // v1.2.0: Combo Multiplier System (v1.8.0: uses CONFIG)
                            addComboKill();
                            // v1.33.0: Apply narrative score multiplier (2x after 120s Final Stand)
                            // v1.37.0: Apply comeback multiplier when active (Player Psychologist)
                            const activeComeback = (Date.now() < STATE.comebackMultiplierExpiry) ? STATE.comebackMultiplier : 1.0;
                            let killScore = Math.floor(CONFIG.enemyKillScore * STATE.comboMultiplier * STATE.narrativeScoreMultiplier * activeComeback);

                            // v1.39.0: Fragile Victory Adrenaline (Player Psychologist)
                            // Award escalating bonus for kills while in fragile range (40-60% shield)
                            let killMessage = `ENEMY DOWN! +${killScore}`;
                            let fragileVictoryApplied = false;
                            if (STATE.shield >= 40 && STATE.shield <= 60) {
                                STATE.fragileVictoryKills++;
                                // Escalating multiplier: 1.1x → 1.2x → 1.35x
                                if (STATE.fragileVictoryKills === 1) {
                                    STATE.fragileVictoryMultiplier = 1.1;
                                } else if (STATE.fragileVictoryKills === 2) {
                                    STATE.fragileVictoryMultiplier = 1.2;
                                } else {
                                    STATE.fragileVictoryMultiplier = 1.35;
                                }
                                const fragileBonus = Math.floor(killScore * (STATE.fragileVictoryMultiplier - 1));
                                killScore += fragileBonus;
                                killMessage = `FRAGILE VICTORY! +${killScore}`;
                                fragileVictoryApplied = true;
                                // v1.54.0: Fragile Victory Feedback Intensity Scaling (Player Psychology)
                                // Enhanced screen shake and haptic feedback proportional to danger
                                const intensityScale = 1 + (STATE.fragileVictoryMultiplier - 1) * 2; // 1.2x → 1.4x → 1.7x shake
                                SCREEN_SHAKE.trauma = Math.min(1, SCREEN_SHAKE.trauma + 0.15 * intensityScale);
                                triggerHaptic([50 * intensityScale, 30, 30 * intensityScale]);
                            } else {
                                // Reset fragile victory streak when outside range
                                STATE.fragileVictoryKills = 0;
                                STATE.fragileVictoryMultiplier = 1.0;
                            }

                            // v1.37.0: "AGAINST ALL ODDS" bonus for kills at critical health (Player Psychologist)
                            // Overrides fragile victory message if applicable
                            if (STATE.shield < 10 && STATE.shield > 0) {
                                const againstOddsBonus = Math.floor(killScore * 0.5);
                                killScore += againstOddsBonus;
                                killMessage = `AGAINST ALL ODDS! +${killScore}`;
                                // v1.38.0: Comeback Audio Fanfare (Audio Engineer)
                                playComebackFanfareSound();
                            } else if (STATE.criticalPhaseActive && STATE.shield < 25) {
                                killMessage = `CRITICAL KILL! +${killScore}`;
                            }
                            STATE.score += killScore;
                            signalCombatActivity(); // v1.82.0: Suppress HUD breathing during combat
                            // v1.9.0: Toast notification for enemy kill
                            // v1.66.0: Fragile victory toast delayed 150ms to sync with shake peak (Player Psychologist)
                            if (fragileVictoryApplied) {
                                setTimeout(() => TOAST_SYSTEM.show('kill', killMessage), 150);
                            } else {
                                TOAST_SYSTEM.show('kill', killMessage);
                            }
                            // v1.2.0: Hit Pause on enemy destruction
                            addHitFreeze(3);
                            // v1.89.0: Negative Space Audio Silence Punctuation (Psychology)
                            playKillAudioDip();
                            // v1.72.0: Zoom moved to line 4249 for 0ms latency (was v1.44.0)

                            // v1.80.0: Variable Ratio Mini-Rewards (Psychology)
                            STATE.variableRatioKills++;
                            if (STATE.variableRatioKills >= STATE.variableRatioThreshold) {
                                const bonusPoints = 50 + Math.floor(Math.random() * 50); // 50-99 bonus
                                STATE.score += bonusPoints;
                                TOAST_SYSTEM.show('bonus', `SURGE BONUS! +${bonusPoints}`);
                                triggerHaptic([30, 20, 60, 20, 30]); // Celebration pattern
                                STATE.variableRatioKills = 0;
                                STATE.variableRatioThreshold = 3 + Math.floor(Math.random() * 5); // New 3-7 threshold
                            }
                        }
                        break;
                    }
                }
            }

            // 3. Enemy Lasers vs Player (v1.8.0: uses safe getters)
            // v1.60.0: For-loop with continue for early-exit efficiency (Performance Optimizer)
            for (let pIdx = projectiles.length - 1; pIdx >= 0; pIdx--) {
                const p = projectiles[pIdx];
                if (p.isPlayer) continue;
                // v1.8.0: Use bounds-checked getter
                const pBox = COLLISION_CACHE.getProjectileBox(pIdx);
                pBox.setFromObject(p.mesh);

                if (pBox.intersectsBox(COLLISION_CACHE.playerBox)) {
                    // v1.26.0: Calculate damage direction from projectile
                    const pDirX = Math.sign(p.mesh.position.x - playerShip.position.x);
                    const pDirY = Math.sign(p.mesh.position.y - playerShip.position.y);

                    if (!STATE.isSpectral) {
                        takeDamage(CONFIG.collisionDamage.enemyLaserMaterial, pDirX, pDirY);
                        createExplosion(playerShip.position, 0xff0000, 0.5);
                        scene.remove(p.mesh);
                        disposeMesh(p.mesh); // v1.20.0
                        projectiles.splice(pIdx, 1);
                    } else {
                        // Lasers pass through spectral ship? Or maybe they are energy?
                        // Let's say lasers are energy and hurt spectral too
                        takeDamage(CONFIG.collisionDamage.enemyLaserSpectral, pDirX, pDirY);
                        scene.remove(p.mesh);
                        disposeMesh(p.mesh); // v1.20.0
                        projectiles.splice(pIdx, 1);
                    }
                }
            }
        }

        // v1.5.0: Perfect Dodge System (v1.8.0: uses CONFIG values)
        let lastPerfectDodgeTime = 0;
        function awardPerfectDodge() {
            const now = Date.now();
            // Cooldown to prevent spam
            if (now - lastPerfectDodgeTime < CONFIG.perfectDodgeCooldownMs) return;
            lastPerfectDodgeTime = now;

            STATE.perfectDodges++;
            const dodgeScore = CONFIG.perfectDodgeScore * STATE.comboMultiplier;
            STATE.score += dodgeScore;

            // Show perfect dodge popup
            showPerfectDodge();

            // v1.9.0: Toast notification for perfect dodge
            TOAST_SYSTEM.show('perfect', `+${dodgeScore} PERFECT!`);

            // Play subtle audio cue if enabled
            if (audioContext && audioEnabled && !STATE.reducedMotion) {
                playPerfectDodgeSound();
            }
        }

        function showPerfectDodge() {
            const popup = document.createElement('div');
            popup.className = 'perfect-dodge';
            popup.textContent = '+PERFECT PHASE!';
            document.body.appendChild(popup);
            setTimeout(() => popup.remove(), 1000);
        }

        // v1.35.0: Enhanced Perfect Dodge Achievement Chime (Audio Engineer)
        // Major third chord (C5 + E5) with bell-like tone decay
        function playPerfectDodgeSound() {
            if (!audioContext) return;
            try {
                const now = audioContext.currentTime;
                // Major third chord: C5 (523.25Hz) + E5 (659.25Hz)
                const frequencies = [523.25, 659.25];

                frequencies.forEach((freq) => {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();

                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(freq, now);
                    // Slight pitch bend down at end for bell effect
                    osc.frequency.exponentialRampToValueAtTime(freq * 0.95, now + 0.4);

                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(0.08, now + 0.03);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);

                    osc.connect(gain);
                    gain.connect(audioContext.destination);

                    osc.start(now);
                    osc.stop(now + 0.4);
                });

                // v1.50.0: Perfect Dodge Temporal Echo (Game Feel Expert)
                // Delayed ghost chirp creates "time slip" sensation
                const echoDelay = 0.05; // 50ms delay
                const echoOsc = audioContext.createOscillator();
                const echoGain = audioContext.createGain();
                echoOsc.type = 'sine';
                // v1.71.0: B5 (988.5Hz) creates Cmaj7 with main chord for harmonic consonance (Audio Engineer)
                echoOsc.frequency.setValueAtTime(988.5, now + echoDelay);
                echoOsc.frequency.exponentialRampToValueAtTime(741, now + echoDelay + 0.08);
                echoGain.gain.setValueAtTime(0, now + echoDelay);
                echoGain.gain.linearRampToValueAtTime(0.04, now + echoDelay + 0.01);
                echoGain.gain.exponentialRampToValueAtTime(0.001, now + echoDelay + 0.1);
                echoOsc.connect(echoGain);
                echoGain.connect(audioContext.destination);
                echoOsc.start(now + echoDelay);
                echoOsc.stop(now + echoDelay + 0.12);
            } catch (e) { /* Fail silently */ }
        }

        // v1.26.0: Added optional direction parameters for directional shake
        function takeDamage(amount, dirX = 0, dirY = 0) {
            // v1.40.0: Second Wind Invulnerability Check (Player Psychologist)
            if (STATE.secondWindActive) {
                // Damage blocked during second wind grace period
                showAudioCaption('shield', 'Second Wind shields damage');
                return;
            }

            const shieldBefore = STATE.shield;
            STATE.shield -= amount;

            // v1.27.0: Track last damage time for mastery system
            STATE.lastDamageTime = Date.now();

            // v1.40.0: Second Wind Trigger (Player Psychologist)
            // First time dropping below 25% grants 2-second invulnerability
            if (shieldBefore >= 25 && STATE.shield < 25 && STATE.shield > 0 && !STATE.secondWindUsed) {
                STATE.secondWindUsed = true;
                STATE.secondWindActive = true;
                STATE.secondWindExpiry = Date.now() + 2000; // 2 seconds
                triggerSecondWind();
            }

            // v1.84.0: Critical Shield Boundary Anchor (Player Psychology)
            // Distinct audio cue at exactly 50% shield triggers loss aversion response
            if (shieldBefore > 50 && STATE.shield <= 50 && STATE.shield > 0) {
                playShieldBoundaryTone();
            }

            // v1.37.0: Narrative Comeback Escalation (Player Psychologist)
            // Detect entering critical state (<25% shield)
            if (shieldBefore >= 25 && STATE.shield < 25 && STATE.shield > 0) {
                STATE.criticalPhaseActive = true;
                STATE.healthPreCritical = shieldBefore;
                TOAST_SYSTEM.show('critical', 'CRITICAL PROTOCOL ENGAGED');
            }

            // Flash red (v1.13.0: uses cached DOM reference)
            if (DOM_CACHE.damageOverlay) {
                DOM_CACHE.damageOverlay.classList.add('damage-flash');
                setTimeout(() => DOM_CACHE.damageOverlay.classList.remove('damage-flash'), 100);

                // v1.78.0: Directional Impact Flash Overlay (Game Feel)
                // Show flash from damage direction for spatial awareness
                if (!STATE.reducedMotion && (dirX !== 0 || dirY !== 0)) {
                    const flashX = 50 + dirX * 40; // Position from center based on direction
                    const flashY = 50 + dirY * 40;
                    DOM_CACHE.damageOverlay.style.setProperty('--flash-x', `${flashX}%`);
                    DOM_CACHE.damageOverlay.style.setProperty('--flash-y', `${flashY}%`);
                    DOM_CACHE.damageOverlay.classList.remove('directional-flash');
                    void DOM_CACHE.damageOverlay.offsetWidth; // Force reflow
                    DOM_CACHE.damageOverlay.classList.add('directional-flash');
                    setTimeout(() => DOM_CACHE.damageOverlay.classList.remove('directional-flash'), 150);

                    // v1.92.0: Directional Impact Bloom Flash (Game Feel)
                    // Hemisphere-aware bloom spike based on damage direction
                    if (QUALITY_SYSTEM.bloomPass) {
                        // Brief asymmetric bloom spike (higher on impact side)
                        const baseBoom = STATE.isSpectral ? 1.8 : 1.4;
                        QUALITY_SYSTEM.bloomPass.strength = baseBoom + 0.8;  // Spike
                        STATE.targetBloomStrength = baseBoom;  // Target for decay
                    }
                }

                // v1.32.0: Shield Damage Crack Overlay (Visual Designer)
                // Show crack effect when shield drops below 40%
                if (STATE.shield < 40 && !STATE.reducedMotion) {
                    const crackX = 50 + dirX * 30; // Offset from center based on damage direction
                    const crackY = 50 + dirY * 30;
                    const crackAngle = Math.atan2(dirY, dirX) * (180 / Math.PI);
                    const crackIntensity = Math.min(0.8, (40 - STATE.shield) / 50);

                    DOM_CACHE.damageOverlay.style.setProperty('--crack-x', `${crackX}%`);
                    DOM_CACHE.damageOverlay.style.setProperty('--crack-y', `${crackY}%`);
                    DOM_CACHE.damageOverlay.style.setProperty('--crack-angle', `${crackAngle}deg`);
                    DOM_CACHE.damageOverlay.style.setProperty('--crack-intensity', crackIntensity);

                    DOM_CACHE.damageOverlay.classList.remove('shield-cracked');
                    void DOM_CACHE.damageOverlay.offsetWidth; // Force reflow
                    DOM_CACHE.damageOverlay.classList.add('shield-cracked');
                    setTimeout(() => DOM_CACHE.damageOverlay.classList.remove('shield-cracked'), 1500);
                }
            }

            // v1.48.0: Collision Knockback Push (Game Feel Expert)
            // Push camera backward on impact to reinforce collision feel
            if (!STATE.reducedMotion) {
                STATE.collisionKnockback = 0.8;  // Initial push-back amount
                STATE.knockbackVelocity = 0.08; // Decay rate per frame
            }

            // v1.4.0: Floating Damage Numbers
            showDamageNumber(amount);

            // v1.10.0: Dynamic Impact Sound (scales with damage)
            playImpactSound(amount, playerShip.position.x);

            // v1.11.0: Camera Zoom on Impact (Game Feel Expert)
            triggerImpactZoom(amount / 20);

            // v1.13.0: Haptic feedback for damage
            triggerHaptic(HAPTIC_PATTERNS.damage);

            // v1.1.0: Enhanced trauma-based screen shake (Game Feel Expert)
            // v1.26.0: Now includes directional bias from damage source
            addScreenTrauma(Math.min(1, amount / 30), dirX, dirY);

            // v1.34.0: Rotational Camera Impact (Game Feel Expert)
            // v1.86.0: Trauma-Scaled Roll Intensity (Game Feel Expert)
            // Roll camera toward damage direction, scaled by trauma for coherent spatial feedback
            if (dirX !== 0 && !STATE.reducedMotion) {
                const traumaScale = Math.pow(SCREEN_SHAKE.trauma, 1.5);
                SCREEN_SHAKE.impactRoll = -dirX * 0.15 * Math.min(1, amount / 20) * (0.5 + 0.5 * traumaScale);
            }

            // v1.2.0: Reset combo on damage (Player Psychologist)
            resetCombo();

            // v1.2.0: Hit Pause on player damage
            // v1.74.0: Scale hit freeze 1-8 frames by damage magnitude (Game Feel)
            addHitFreeze(Math.ceil(Math.min(8, amount / 10)));

            if (STATE.shield <= 0) {
                // v1.30.0: Harmonic Series Descent on death (Audio Engineer)
                playShieldDepletionSound();
                gameOver();
            }
        }

        // v1.1.0: Trauma-based screen shake system (Game Feel Expert)
        // v1.26.0: Added optional direction for directional shake tilt
        function addScreenTrauma(amount, dirX = 0, dirY = 0) {
            SCREEN_SHAKE.trauma = Math.min(1, SCREEN_SHAKE.trauma + amount);
            // v1.26.0: Directional Screen Shake Tilt (Game Feel Expert)
            if (dirX !== 0 || dirY !== 0) {
                SCREEN_SHAKE.directionX = dirX;
                SCREEN_SHAKE.directionY = dirY;
            }
        }

        function updateScreenShake(delta) {
            // v1.8.0: Early bailout at zero trauma - skip all calculations
            if (SCREEN_SHAKE.trauma === 0) {
                return;
            }

            // v1.3.0: Respect reduced motion preference
            if (STATE.reducedMotion) {
                SCREEN_SHAKE.trauma = 0;
                camera.position.x = 0;
                camera.position.y = 2;
                camera.rotation.z = 0;
                return;
            }

            // v1.8.0: Snap to zero when nearly done (skip micro-calculations)
            if (SCREEN_SHAKE.trauma <= 0.01) {
                SCREEN_SHAKE.trauma = 0;
                return;
            }

            SCREEN_SHAKE.time += delta * SCREEN_SHAKE.frequency;

            // Use trauma^2 for more dramatic falloff (feels better)
            const shake = SCREEN_SHAKE.trauma * SCREEN_SHAKE.trauma;

            // Perlin-like noise using sin waves at different frequencies
            const noiseX = Math.sin(SCREEN_SHAKE.time * 1.1) * Math.cos(SCREEN_SHAKE.time * 0.7);
            const noiseY = Math.sin(SCREEN_SHAKE.time * 1.3) * Math.cos(SCREEN_SHAKE.time * 0.9);

            // v1.26.0: Directional Screen Shake Tilt (Game Feel Expert)
            // v1.57.0: Directional Bias Interpolation - higher trauma = more direction clarity
            // Bias 10-50% based on trauma intensity (low damage = noise, high damage = directional)
            const dirBias = Math.max(0.1, Math.min(0.5, 0.3 * (SCREEN_SHAKE.trauma * 2)));
            const offsetX = (noiseX * (1 - dirBias) + SCREEN_SHAKE.directionX * dirBias) * SCREEN_SHAKE.maxOffset * shake;
            const offsetY = (noiseY * (1 - dirBias) + SCREEN_SHAKE.directionY * dirBias) * SCREEN_SHAKE.maxOffset * shake;
            const rotation = Math.sin(SCREEN_SHAKE.time * 0.8) * SCREEN_SHAKE.maxRotation * shake;

            // Apply to camera (relative to base position)
            camera.position.x = offsetX;
            camera.position.y = 2 + offsetY; // 2 is base Y position
            // v1.34.0: Combine noise rotation with impact roll (Game Feel Expert)
            camera.rotation.z = rotation + SCREEN_SHAKE.impactRoll;

            // Decay trauma and direction
            // v1.81.0: Asymmetric trauma decay - snappier recovery at low trauma (Game Feel)
            // v1.82.0: Smooth polynomial curve instead of step function (Game Feel)
            const decayRate = 0.90 + 0.06 * Math.pow(1 - SCREEN_SHAKE.trauma, 2);
            SCREEN_SHAKE.trauma *= decayRate;
            SCREEN_SHAKE.directionX *= decayRate;
            SCREEN_SHAKE.directionY *= decayRate;
            // v1.34.0: Decay impact roll faster for snappy recovery
            SCREEN_SHAKE.impactRoll *= SCREEN_SHAKE.impactRollDecay;
        }

        // v1.13.0: Haptic Feedback via Vibration API (Game Feel Expert)
        // v1.57.0: Haptic-Trauma Synchronization - 18ms delay aligns tactile with visual peak shake
        // Provides tactile confirmation on mobile/gamepad devices
        function triggerHaptic(pattern) {
            if (STATE.reducedMotion) return;
            if (navigator.vibrate) {
                // Delay haptic 18ms to sync with screen shake visual peak (1-2 frames after trauma)
                setTimeout(() => {
                    try {
                        navigator.vibrate(pattern);
                    } catch (e) { /* Fail silently on unsupported devices */ }
                }, 18);
            }
        }

        // Common haptic patterns
        const HAPTIC_PATTERNS = {
            damage: [50, 30, 80],           // Sharp double pulse for damage
            phaseIn: [20, 10, 20, 10, 40],  // Ascending pattern for spectral entry
            phaseOut: [40, 10, 20, 10, 20], // Descending pattern for spectral exit
            kill: [30, 20, 50],             // Satisfying kill confirmation
            perfectDodge: [15, 15, 15],     // Quick triple tap for perfect dodge
            ready: [30, 50, 30],            // v1.14.0: Confirmation pulse for load/start
            gameStart: [20, 30, 20, 50]     // v1.14.0: Ascending confirmation for game start
        };

        // v1.2.0: Phase Shift Feedback Pulse (UX Polish Specialist)
        // v1.13.0: Uses cached DOM reference
        function triggerPhasePulse() {
            const indicator = DOM_CACHE.phaseIndicator;
            if (!indicator) return;
            indicator.classList.remove('phase-pulse');
            // Force reflow to restart animation
            void indicator.offsetWidth;
            indicator.classList.add('phase-pulse');
            // Remove class after animation completes
            setTimeout(() => indicator.classList.remove('phase-pulse'), 300);
        }

        // v1.11.0: Momentum Bar & Velocity Visualization (Game Feel Expert)
        // v1.12.0: Uses DOM_CACHE for performance
        function updateMomentumBar() {
            const bar = DOM_CACHE.momentumBar;
            if (!bar || !DOM_CACHE.initialized) return;

            // Calculate velocity magnitude (0-1)
            const speed = Math.sqrt(STATE.velocityX * STATE.velocityX + STATE.velocityY * STATE.velocityY);
            const maxSpeed = CONFIG.moveMaxSpeed;
            const velocityPercent = Math.min(100, (speed / maxSpeed) * 100);

            // Update bar width
            bar.style.width = velocityPercent + '%';

            // Update color class based on speed tier
            bar.classList.remove('momentum-slow', 'momentum-normal', 'momentum-fast', 'momentum-max');
            if (velocityPercent < 25) {
                bar.classList.add('momentum-slow');
            } else if (velocityPercent < 50) {
                bar.classList.add('momentum-normal');
            } else if (velocityPercent < 80) {
                bar.classList.add('momentum-fast');
            } else {
                bar.classList.add('momentum-max');
            }

            // Update ARIA value
            bar.parentElement.setAttribute('aria-valuenow', Math.round(velocityPercent));
        }

        // v1.11.0: Camera Zoom on Impact (Game Feel Expert)
        function triggerImpactZoom(intensity = 1) {
            if (STATE.reducedMotion) return;

            // Set target to zoom in (closer to player)
            const zoomAmount = CONFIG.impactZoomAmount * Math.min(1.5, intensity);
            CAMERA_ZOOM.targetZ = CAMERA_ZOOM.baseZ - zoomAmount;
            CAMERA_ZOOM.isZooming = true;

            // After zoom-in duration, start returning to base
            setTimeout(() => {
                CAMERA_ZOOM.targetZ = CAMERA_ZOOM.baseZ;
            }, CONFIG.impactZoomInTime * 1000);

            // Reset zoom state after full animation
            setTimeout(() => {
                CAMERA_ZOOM.isZooming = false;
            }, (CONFIG.impactZoomInTime + CONFIG.impactZoomOutTime) * 1000);
        }

        function updateCameraZoom(delta) {
            // Smoothly interpolate camera Z position
            const diff = CAMERA_ZOOM.targetZ - CAMERA_ZOOM.currentZ;
            if (Math.abs(diff) > 0.01) {
                // v1.65.0: Asymmetric zoom speeds - fast snap-back, slow recoil for impact weight (Game Feel Expert)
                const speed = CAMERA_ZOOM.targetZ < CAMERA_ZOOM.currentZ ? 18 : 6;
                CAMERA_ZOOM.currentZ += diff * speed * delta;
            } else {
                CAMERA_ZOOM.currentZ = CAMERA_ZOOM.targetZ;
            }

            // Apply to camera (preserving screen shake offsets on X/Y)
            camera.position.z = CAMERA_ZOOM.currentZ;

            // v1.48.0: Collision Knockback Push (Game Feel Expert)
            // Apply and decay knockback offset to camera z-position
            if (STATE.collisionKnockback > 0.01) {
                camera.position.z += STATE.collisionKnockback;
                STATE.collisionKnockback -= STATE.knockbackVelocity;
                STATE.knockbackVelocity *= 0.92; // Deceleration for smooth snap-back
            } else {
                STATE.collisionKnockback = 0;
            }
        }

        // v1.11.0: Adaptive Quality Scaling (Performance Optimizer)
        // v1.13.0: Circular buffer implementation (eliminates array push/shift GC pressure)
        function updateQualitySystem() {
            QUALITY_SYSTEM.frameCount++;
            const now = performance.now();

            // Track frame times using circular buffer (no allocations)
            if (QUALITY_SYSTEM.lastCheck > 0) {
                QUALITY_SYSTEM.frameTimes[QUALITY_SYSTEM.frameTimeIndex] = now - QUALITY_SYSTEM.lastCheck;
                QUALITY_SYSTEM.frameTimeIndex = (QUALITY_SYSTEM.frameTimeIndex + 1) % 30;
                if (QUALITY_SYSTEM.frameTimeCount < 30) QUALITY_SYSTEM.frameTimeCount++;
            }
            QUALITY_SYSTEM.lastCheck = now;

            // Check quality every N frames
            if (QUALITY_SYSTEM.frameCount % CONFIG.qualityCheckInterval !== 0) return;
            if (QUALITY_SYSTEM.frameTimeCount < 20) return;

            // Calculate average FPS from circular buffer
            let sum = 0;
            for (let i = 0; i < QUALITY_SYSTEM.frameTimeCount; i++) {
                sum += QUALITY_SYSTEM.frameTimes[i];
            }
            const avgFrameTime = sum / QUALITY_SYSTEM.frameTimeCount;
            const currentFPS = 1000 / avgFrameTime;

            // Adaptive quality adjustment
            if (currentFPS < CONFIG.lowFPSThreshold) {
                QUALITY_SYSTEM.lowFPSStreak++;
                if (QUALITY_SYSTEM.lowFPSStreak >= 3) {
                    downgradeQuality();
                }
            } else if (currentFPS > CONFIG.targetFPS + 10) {
                QUALITY_SYSTEM.lowFPSStreak = 0;
                // Could upgrade quality here if desired
            } else {
                QUALITY_SYSTEM.lowFPSStreak = Math.max(0, QUALITY_SYSTEM.lowFPSStreak - 1);
            }
        }

        function downgradeQuality() {
            if (QUALITY_SYSTEM.tier === 'ULTRA') {
                QUALITY_SYSTEM.tier = 'HIGH';
                // Reduce bloom resolution
                if (QUALITY_SYSTEM.bloomPass) {
                    QUALITY_SYSTEM.bloomPass.resolution.set(
                        window.innerWidth / 4,
                        window.innerHeight / 4
                    );
                }
                console.log('[Quality] Downgraded to HIGH');
            } else if (QUALITY_SYSTEM.tier === 'HIGH') {
                QUALITY_SYSTEM.tier = 'LOW';
                // Disable bloom entirely for max performance
                if (QUALITY_SYSTEM.bloomPass) {
                    QUALITY_SYSTEM.bloomPass.enabled = false;
                }
                console.log('[Quality] Downgraded to LOW');
            }
            QUALITY_SYSTEM.lowFPSStreak = 0;
        }

        // v1.2.0: Combo Multiplier System (Player Psychologist)
        function addComboKill() {
            // v1.28.0: Clear grace period on kill (combo saved!)
            const wasInGrace = STATE.comboGraceActive;
            if (wasInGrace) {
                STATE.comboGraceActive = false;
                STATE.comboGraceStartTime = 0;
                if (DOM_CACHE.comboDisplay) {
                    DOM_CACHE.comboDisplay.classList.remove('combo-grace');
                }
                // v1.44.0: Hide streak recovery ring on combo save
                if (DOM_CACHE.streakRecoveryRing) {
                    DOM_CACHE.streakRecoveryRing.classList.remove('visible');
                }
                // Show "Combo Saved!" feedback
                TOAST_SYSTEM.show('combo', '💫 COMBO SAVED!');
            }

            STATE.comboKills++;
            STATE.comboTimer = Date.now();

            const prevMultiplier = STATE.comboMultiplier;

            // Update multiplier based on kill streak (v1.8.0: uses CONFIG thresholds)
            if (STATE.comboKills >= CONFIG.comboTier4Kills) {
                STATE.comboMultiplier = 4;
            } else if (STATE.comboKills >= CONFIG.comboTier3Kills) {
                STATE.comboMultiplier = 3;
            } else if (STATE.comboKills >= CONFIG.comboTier2Kills) {
                STATE.comboMultiplier = 2;
            } else {
                STATE.comboMultiplier = 1;
            }

            // v1.7.0: Combo Counter Pulse Animation on multiplier increase
            if (STATE.comboMultiplier > prevMultiplier) {
                triggerComboPulse();
                // v1.9.0: Toast notification for combo upgrade
                TOAST_SYSTEM.show('combo', `x${STATE.comboMultiplier} COMBO!`);
                // v1.17.0: Combo Milestone Audio Flourish
                playComboMilestoneSound(STATE.comboMultiplier);
            }
        }

        // v1.17.0: Ascending melodic sequence on combo tier increase (Audio Engineer)
        function playComboMilestoneSound(tier) {
            if (!audioContext || !audioEnabled) return;
            try {
                // Ascending notes based on tier (C, E, G, C5 pattern)
                const baseFreq = 262; // C4
                const notes = tier === 2 ? [262, 330] :      // C, E
                              tier === 3 ? [262, 330, 392] : // C, E, G
                              [262, 330, 392, 523];          // C, E, G, C5

                notes.forEach((freq, i) => {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    osc.connect(gain);
                    gain.connect(audioContext.destination);

                    osc.type = 'triangle';
                    // v1.75.0: Frequency snap-quantization for "arrival" precision feel (Audio)
                    osc.frequency.setValueAtTime(freq * 1.02, audioContext.currentTime + i * 0.08);
                    osc.frequency.linearRampToValueAtTime(freq, audioContext.currentTime + i * 0.08 + 0.03);

                    // v1.76.0: Frequency-compensated gain for equal perceived loudness (Audio)
                    const compensatedGain = 0.2 * (262 / freq);
                    gain.gain.setValueAtTime(0, audioContext.currentTime + i * 0.08);
                    gain.gain.linearRampToValueAtTime(compensatedGain, audioContext.currentTime + i * 0.08 + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + i * 0.08 + 0.15);

                    osc.start(audioContext.currentTime + i * 0.08);
                    osc.stop(audioContext.currentTime + i * 0.08 + 0.15);
                });
            } catch (e) { /* Audio error ignored */ }
        }

        // v1.38.0: Comeback Audio Fanfare with Rising Arpeggio (Audio Engineer)
        // Plays triumphant ascending major chord when player gets critical kill
        function playComebackFanfareSound() {
            if (!audioContext || !audioEnabled) return;
            try {
                const now = audioContext.currentTime;
                // Rising major triad: C-E-G with octave resolution
                const notes = [262, 330, 392, 523]; // C4, E4, G4, C5

                notes.forEach((freq, i) => {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    osc.connect(gain);
                    gain.connect(audioContext.destination);

                    // Softer triangle wave with slight vibrato
                    osc.type = 'triangle';
                    const startTime = now + i * 0.1;
                    osc.frequency.setValueAtTime(freq * 0.98, startTime);
                    osc.frequency.linearRampToValueAtTime(freq, startTime + 0.05);

                    // Attack and sustain with gentle decay
                    gain.gain.setValueAtTime(0, startTime);
                    gain.gain.linearRampToValueAtTime(0.25, startTime + 0.03);
                    gain.gain.exponentialRampToValueAtTime(0.08, startTime + 0.2);
                    gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.35);

                    osc.start(startTime);
                    osc.stop(startTime + 0.35);
                });

                // Final resolution chord (played together)
                setTimeout(() => {
                    if (!audioContext || !audioEnabled) return;
                    const finalNow = audioContext.currentTime;
                    [523, 659, 784].forEach((freq, i) => { // C5, E5, G5 chord
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.connect(gain);
                        gain.connect(audioContext.destination);
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(freq, finalNow);
                        gain.gain.setValueAtTime(0, finalNow);
                        gain.gain.linearRampToValueAtTime(0.15 - i * 0.03, finalNow + 0.02);
                        gain.gain.exponentialRampToValueAtTime(0.01, finalNow + 0.5);
                        osc.start(finalNow);
                        osc.stop(finalNow + 0.5);
                    });
                }, 450);
            } catch (e) { /* Audio error ignored */ }
        }

        // v1.7.0: Trigger combo pulse animation
        function triggerComboPulse() {
            const comboDisplay = document.getElementById('combo-display');
            if (comboDisplay && !STATE.reducedMotion) {
                comboDisplay.classList.remove('combo-pulse');
                void comboDisplay.offsetWidth; // Force reflow to restart animation
                comboDisplay.classList.add('combo-pulse');
            }
        }

        // v1.32.0: Daily Challenge Streak Counter (Player Psychologist)
        // Updates streak based on consecutive play days
        function updateDailyStreak() {
            const today = new Date().toDateString();
            const yesterday = new Date(Date.now() - 86400000).toDateString();
            const streakEl = document.getElementById('streak-value');
            const streakContainer = document.getElementById('streak-counter');

            if (STATE.lastPlayDate === today) {
                // Already played today, just display
                if (streakEl) streakEl.textContent = STATE.streakDays;
            } else if (STATE.lastPlayDate === yesterday) {
                // Consecutive day! Increment streak
                STATE.streakDays++;
                STATE.lastPlayDate = today;
                localStorage.setItem('skyRealms_streakDays', STATE.streakDays);
                localStorage.setItem('skyRealms_lastPlayDate', today);
                if (streakEl) streakEl.textContent = STATE.streakDays;
                if (streakContainer) {
                    streakContainer.classList.add('streak-new');
                    setTimeout(() => streakContainer.classList.remove('streak-new'), 600);
                }
                // Toast notification for streak milestone
                if (STATE.streakDays % 7 === 0) {
                    TOAST_SYSTEM.show('milestone', `🔥 ${STATE.streakDays} DAY STREAK!`);
                }
            } else {
                // Streak broken or first play
                STATE.streakDays = 1;
                STATE.lastPlayDate = today;
                localStorage.setItem('skyRealms_streakDays', STATE.streakDays);
                localStorage.setItem('skyRealms_lastPlayDate', today);
                if (streakEl) streakEl.textContent = STATE.streakDays;
            }
        }

        // v1.33.0: Session Narrative Checkpoints (Player Psychologist)
        // Triggers story arc milestones at specific time thresholds
        function checkNarrativeCheckpoints(sessionElapsed) {
            const checkpoints = [
                { time: 30, message: '⚡ PRESSURE RISING', color: '#ffcc00', ariaMsg: 'Pressure rising! Enemies intensifying.' },
                { time: 60, message: '🌀 INTO THE ABYSS', color: '#9966ff', ariaMsg: 'Into the abyss! Maximum danger ahead.' },
                { time: 120, message: '🔥 FINAL STAND — 2× SCORE', color: '#ff4466', ariaMsg: 'Final stand! Double score multiplier active.' }
            ];

            for (const checkpoint of checkpoints) {
                if (sessionElapsed >= checkpoint.time && !STATE.narrativeCheckpoints[checkpoint.time]) {
                    STATE.narrativeCheckpoints[checkpoint.time] = true;

                    // Show dramatic toast with custom styling
                    TOAST_SYSTEM.show('narrative', checkpoint.message);

                    // ARIA announcement for accessibility
                    if (DOM_CACHE.ariaAlertRegion) {
                        DOM_CACHE.ariaAlertRegion.textContent = checkpoint.ariaMsg;
                    }

                    // 120s checkpoint: activate 2x score multiplier
                    if (checkpoint.time === 120) {
                        STATE.narrativeScoreMultiplier = 2.0;
                    }

                    // v1.42.0: Velocity Signature Playstyle Profile at 60s (Player Psychologist)
                    if (checkpoint.time === 60 && !STATE.playstyleAnnounced && STATE.velocitySamples.length >= 20) {
                        STATE.playstyleAnnounced = true;
                        const avgVelocity = STATE.velocitySamples.reduce((a, b) => a + b, 0) / STATE.velocitySamples.length;
                        let playstyle, playstyleColor;
                        if (avgVelocity >= 0.65) {
                            playstyle = '⚡ AGILE INTERCEPTOR';
                            playstyleColor = '#ff6600';
                        } else if (avgVelocity <= 0.35) {
                            playstyle = '🛡️ CALCULATED DEFENDER';
                            playstyleColor = '#00ccff';
                        } else {
                            playstyle = '⚖️ BALANCED TACTICIAN';
                            playstyleColor = '#66ff66';
                        }
                        // Show playstyle toast after brief delay (not overlapping narrative)
                        setTimeout(() => {
                            TOAST_SYSTEM.show('narrative', `${playstyle}`);
                            if (DOM_CACHE.ariaAlertRegion) {
                                DOM_CACHE.ariaAlertRegion.textContent = `Your playstyle: ${playstyle.replace(/[⚡🛡️⚖️]/g, '')}`;
                            }
                        }, 1500);
                    }

                    // Apply screen flash effect if not reduced motion
                    if (!STATE.reducedMotion && DOM_CACHE.damageOverlay) {
                        DOM_CACHE.damageOverlay.style.boxShadow = `inset 0 0 100px 50px ${checkpoint.color}40`;
                        setTimeout(() => {
                            DOM_CACHE.damageOverlay.style.boxShadow = 'none';
                        }, 500);
                    }

                    // Only trigger one checkpoint per frame
                    break;
                }
            }
        }

        // v1.34.0: Momentum Mastery Quest Chain (Player Psychologist)
        // Rewards sustained high-speed movement with badges
        function checkMomentumQuest(delta) {
            // Calculate current speed as percentage of max
            const currentSpeed = Math.sqrt(STATE.velocityX ** 2 + STATE.velocityY ** 2);
            const maxSpeed = CONFIG.moveMaxSpeed;
            const speedRatio = currentSpeed / maxSpeed;

            // v1.90.0: Velocity Ring Bloom Threshold (Game Feel)
            // v1.91.0: Use CONFIG constant instead of magic number (Code Architect)
            const isAboveThreshold = speedRatio >= CONFIG.velocityBloomThreshold;
            if (isAboveThreshold && !STATE.wasAboveVelocityThreshold) {
                // Crossing upward - trigger bloom pulse
                if (QUALITY_SYSTEM.bloomPass && !STATE.reducedMotion) {
                    QUALITY_SYSTEM.bloomPass.strength = 2.0;  // Brief spike
                    STATE.targetBloomStrength = STATE.isSpectral ? 1.8 : 1.4;  // Normal target
                }
            }
            STATE.wasAboveVelocityThreshold = isAboveThreshold;

            // Check if above threshold
            if (speedRatio >= STATE.momentumQuestThreshold) {
                STATE.momentumQuestTime += delta;

                // Award "Sprint Leader" badge at 5 seconds
                if (STATE.momentumQuestTime >= STATE.momentumQuestDuration &&
                    !STATE.momentumBadges.includes('sprintLeader')) {
                    STATE.momentumBadges.push('sprintLeader');
                    localStorage.setItem('skyRealms_momentumBadges', JSON.stringify(STATE.momentumBadges));

                    // Show badge earned toast
                    TOAST_SYSTEM.show('mastery', '🏃 SPRINT LEADER');

                    // ARIA announcement
                    if (DOM_CACHE.ariaAlertRegion) {
                        DOM_CACHE.ariaAlertRegion.textContent = 'Badge unlocked: Sprint Leader - maintained high speed for 5 seconds!';
                    }

                    // Bonus points
                    STATE.score += 500;
                }
            } else {
                // Reset progress if speed drops
                STATE.momentumQuestTime = Math.max(0, STATE.momentumQuestTime - delta * 2);
            }

            // v1.35.0: Momentum Dependency Feedback Ring (Game Feel Expert)
            // Update visual ring to show velocity status
            if (DOM_CACHE.momentumRing && !STATE.reducedMotion) {
                if (speedRatio >= STATE.momentumQuestThreshold) {
                    DOM_CACHE.momentumRing.classList.remove('low-velocity');
                    DOM_CACHE.momentumRing.classList.add('high-velocity');
                } else if (speedRatio < 0.4) {
                    // Low velocity warning - pulse red
                    DOM_CACHE.momentumRing.classList.remove('high-velocity');
                    DOM_CACHE.momentumRing.classList.add('low-velocity');
                } else {
                    // Mid-range - no ring
                    DOM_CACHE.momentumRing.classList.remove('low-velocity', 'high-velocity');
                }
            }
        }

        // v1.36.0: Reticle Trail Afterimage (Game Feel Expert)
        // Spawns fading ghost-reticles during movement for momentum visualization
        function updateReticleTrail(delta) {
            if (STATE.reducedMotion || !DOM_CACHE.reticleTrailContainer) return;

            // Get current reticle position (from player ship position)
            const reticleX = playerShip ? playerShip.position.x * 30 : 0;
            const reticleY = playerShip ? -playerShip.position.y * 30 : 0;

            // Calculate movement delta
            const moveX = reticleX - STATE.lastReticleX;
            const moveY = reticleY - STATE.lastReticleY;
            const moveMagnitude = Math.sqrt(moveX * moveX + moveY * moveY);

            // Spawn trail if moving fast enough and enough time passed (60ms interval)
            STATE.reticleTrailTimer += delta * 1000;
            if (moveMagnitude > 2 && STATE.reticleTrailTimer > 60) {
                STATE.reticleTrailTimer = 0;

                // Create trail ghost element
                const trail = document.createElement('div');
                trail.className = 'reticle-trail';
                trail.style.left = `${STATE.lastReticleX}px`;
                trail.style.top = `${STATE.lastReticleY}px`;
                trail.style.transform = `translate(-50%, -50%)`;

                DOM_CACHE.reticleTrailContainer.appendChild(trail);

                // Auto-remove after animation completes (250ms)
                setTimeout(() => {
                    if (trail.parentNode) {
                        trail.parentNode.removeChild(trail);
                    }
                }, 250);
            }

            // Update last position
            STATE.lastReticleX = reticleX;
            STATE.lastReticleY = reticleY;
        }

        function resetCombo() {
            STATE.comboKills = 0;
            STATE.comboMultiplier = 1;
            STATE.comboTimer = 0;
            // v1.28.0: Clear grace period on reset
            STATE.comboGraceActive = false;
            STATE.comboGraceStartTime = 0;
            // v1.14.0: Clear combo warning on reset
            // v1.28.0: Also clear grace class
            if (DOM_CACHE.comboDisplay) {
                DOM_CACHE.comboDisplay.classList.remove('combo-warning', 'combo-grace');
            }
            // v1.44.0: Hide streak recovery ring on reset
            if (DOM_CACHE.streakRecoveryRing) {
                DOM_CACHE.streakRecoveryRing.classList.remove('visible');
            }
        }

        // v1.2.0: Hit Pause / Frame Freeze (Game Feel Expert)
        function addHitFreeze(frames) {
            STATE.freezeFrames = Math.max(STATE.freezeFrames, frames);
            // v1.17.0: Hit Pause Audio Cue (Audio Engineer)
            playHitPauseSound();
        }

        // v1.17.0: Descending beep during freeze-frame moments
        function playHitPauseSound() {
            if (!audioContext || !audioEnabled) return;
            try {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.connect(gain);
                gain.connect(audioContext.destination);

                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.08);

                gain.gain.setValueAtTime(0.15, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.08);

                osc.start(audioContext.currentTime);
                osc.stop(audioContext.currentTime + 0.08);
            } catch (e) { /* Audio error ignored */ }
        }

        // v1.3.0: Audio System - Web Audio API Procedural Synthesis
        // v1.39.0: Enhanced with High-Pass Filter for Critical Health (Audio Engineer)
        function initAudio() {
            if (audioContext) return;
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();

                // v1.39.0: Create master gain and high-pass filter chain
                masterGainNode = audioContext.createGain();
                masterGainNode.gain.setValueAtTime(1.0, audioContext.currentTime);

                criticalHealthFilter = audioContext.createBiquadFilter();
                criticalHealthFilter.type = 'highpass';
                criticalHealthFilter.frequency.setValueAtTime(20, audioContext.currentTime); // Start at 20Hz (effectively off)
                criticalHealthFilter.Q.setValueAtTime(0.7, audioContext.currentTime);

                // v1.56.0: Dynamic Range Compression on Master (Audio Engineer)
                // Prevents clipping and maintains audio clarity during intense moments
                const masterCompressor = audioContext.createDynamicsCompressor();
                masterCompressor.threshold.setValueAtTime(-20, audioContext.currentTime);
                masterCompressor.ratio.setValueAtTime(4, audioContext.currentTime);
                masterCompressor.attack.setValueAtTime(0.003, audioContext.currentTime);
                masterCompressor.release.setValueAtTime(0.25, audioContext.currentTime);
                masterCompressor.knee.setValueAtTime(5, audioContext.currentTime);

                // Connect filter chain: sounds → filter → master → compressor → destination
                criticalHealthFilter.connect(masterGainNode);
                masterGainNode.connect(masterCompressor);
                masterCompressor.connect(audioContext.destination);
            } catch (e) {
                console.warn('Web Audio API not supported');
                audioEnabled = false;
            }
        }

        // v1.39.0: Update critical health filter based on shield level (Audio Engineer)
        // Applies high-pass filtering when shield drops below 30%
        function updateCriticalHealthFilter() {
            if (!audioContext || !criticalHealthFilter) return;

            try {
                const now = audioContext.currentTime;
                if (STATE.shield < 30 && STATE.shield > 0) {
                    // Calculate filter intensity based on how low health is (30% = mild, 5% = intense)
                    const intensity = 1 - (STATE.shield / 30); // 0 to 1
                    const targetFreq = 20 + (intensity * 780); // 20Hz to 800Hz
                    criticalHealthFilter.frequency.linearRampToValueAtTime(targetFreq, now + 0.1);
                } else {
                    // Reset to normal (20Hz = effectively no filtering)
                    criticalHealthFilter.frequency.linearRampToValueAtTime(20, now + 0.2);
                }
            } catch (e) { /* Fail silently */ }
        }

        // v1.89.0: Negative Space Audio Silence Punctuation (Player Psychologist)
        // Brief 80ms audio dip after kills creates "punch" through contrast
        function playKillAudioDip() {
            if (!audioContext || !masterGainNode || !audioEnabled) return;
            try {
                const now = audioContext.currentTime;
                // Quick dip to 60% then smooth recovery to 100% over 150ms
                masterGainNode.gain.cancelScheduledValues(now);
                masterGainNode.gain.setValueAtTime(1.0, now);
                masterGainNode.gain.linearRampToValueAtTime(0.6, now + 0.02);  // 20ms to dip
                masterGainNode.gain.linearRampToValueAtTime(0.6, now + 0.08);  // Hold 60ms
                masterGainNode.gain.linearRampToValueAtTime(1.0, now + 0.15);  // 70ms recovery
            } catch (e) { /* Fail silently */ }
        }

        // v1.40.0: Shield Regeneration Prediction Timeline (UX Polish Specialist)
        // Shows estimated time to reach shield milestones (50%, 75%, 100%)
        function updateShieldPrediction() {
            if (!DOM_CACHE.shieldPrediction || !STATE.shieldPredictionVisible) return;

            // Only show when regenerating (not taking damage, shield < 100%)
            const timeSinceDamage = Date.now() - STATE.lastDamageTime;
            const isRegenerating = timeSinceDamage > 1000 && STATE.shield < 100 && STATE.shield > 0;

            if (isRegenerating) {
                DOM_CACHE.shieldPrediction.classList.add('visible');

                const regenRate = STATE.shieldRegenRate; // Points per second
                const milestones = [50, 75, 100];
                let totalETA = 0;

                milestones.forEach((target, i) => {
                    const fillEl = document.getElementById(`pred-${target}`);
                    if (!fillEl) return;

                    if (STATE.shield >= target) {
                        fillEl.style.width = '100%';
                    } else {
                        const pointsNeeded = target - STATE.shield;
                        const secsToTarget = pointsNeeded / regenRate;
                        const progress = Math.min(100, (regenRate / pointsNeeded) * 100);
                        fillEl.style.width = `${progress}%`;
                        if (i === milestones.length - 1) totalETA = secsToTarget;
                    }
                });

                const etaEl = document.getElementById('shield-eta');
                if (etaEl && STATE.shield < 100) {
                    const secs = Math.ceil((100 - STATE.shield) / regenRate);
                    etaEl.textContent = `${secs}s to full`;
                } else if (etaEl) {
                    etaEl.textContent = '';
                }
            } else {
                DOM_CACHE.shieldPrediction.classList.remove('visible');
            }
        }

        // v1.40.0: Second Wind Expiry Check (Player Psychologist)
        // Disables invulnerability after 2-second grace period
        function updateSecondWind() {
            if (!STATE.secondWindActive) return;

            if (Date.now() > STATE.secondWindExpiry) {
                STATE.secondWindActive = false;
                // Remove visual indicator
                if (DOM_CACHE.secondWindIndicator) {
                    DOM_CACHE.secondWindIndicator.classList.remove('active');
                }
                document.body.classList.remove('second-wind-shield');
                showAudioCaption('info', 'Second Wind expired');
            }
        }

        // v1.40.0: Trigger Second Wind Effect (Player Psychologist)
        // 2-second invulnerability with visual/audio feedback
        function triggerSecondWind() {
            // Visual: Flash indicator and shield glow
            if (DOM_CACHE.secondWindIndicator) {
                DOM_CACHE.secondWindIndicator.classList.add('active');
            }
            document.body.classList.add('second-wind-shield');

            // Toast notification
            TOAST_SYSTEM.show('bonus', 'SECOND WIND! 2s INVULNERABILITY');

            // Audio: Rising hope chord
            if (audioEnabled && audioContext) {
                try {
                    const now = audioContext.currentTime;

                    // Major chord arpeggio rising
                    [262, 330, 392, 523].forEach((freq, i) => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(freq, now + i * 0.08);
                        gain.gain.setValueAtTime(0, now + i * 0.08);
                        gain.gain.linearRampToValueAtTime(0.1, now + i * 0.08 + 0.05);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.08 + 0.3);
                        osc.connect(gain);
                        gain.connect(audioContext.destination);
                        osc.start(now + i * 0.08);
                        osc.stop(now + i * 0.08 + 0.35);
                    });
                } catch (e) { /* Fail silently */ }
            }

            showAudioCaption('shield', 'Second Wind activated - 2s invulnerability');

            // ARIA announcement
            if (DOM_CACHE.ariaAlertRegion) {
                DOM_CACHE.ariaAlertRegion.textContent = 'Second Wind! Two seconds of invulnerability granted.';
            }
        }

        // v1.49.0: Recovery Checkpoint Celebration (Player Psychologist)
        // Triggers celebration when shield recovers from critical (<25%) to healthy (>50%)
        function checkRecoveryCheckpoint() {
            // Track entering critical state
            if (STATE.shield < 25 && STATE.shield > 0) {
                STATE.wasInCritical = true;
                STATE.recoveryCelebrated = false;
            }

            // Check for recovery milestone
            if (STATE.wasInCritical && STATE.shield >= 50 && !STATE.recoveryCelebrated) {
                STATE.recoveryCelebrated = true;
                STATE.wasInCritical = false;

                // Visual celebration toast
                TOAST_SYSTEM.show('bonus', 'RECOVERY COMPLETE! +500 BONUS');
                updateScore(500);

                // Audio: Triumphant recovery chord
                if (audioEnabled && audioContext) {
                    try {
                        const now = audioContext.currentTime;
                        // Major seventh chord arpeggio
                        [392, 494, 587, 740].forEach((freq, i) => {
                            const osc = audioContext.createOscillator();
                            const gain = audioContext.createGain();
                            osc.type = 'sine';
                            osc.frequency.setValueAtTime(freq, now + i * 0.06);
                            gain.gain.setValueAtTime(0, now + i * 0.06);
                            gain.gain.linearRampToValueAtTime(0.12, now + i * 0.06 + 0.04);
                            gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.06 + 0.4);
                            osc.connect(gain);
                            gain.connect(audioContext.destination);
                            osc.start(now + i * 0.06);
                            osc.stop(now + i * 0.06 + 0.45);
                        });
                    } catch (e) { /* Fail silently */ }
                }

                showAudioCaption('achievement', 'Recovery checkpoint reached!');

                // ARIA announcement
                if (DOM_CACHE.ariaAlertRegion) {
                    DOM_CACHE.ariaAlertRegion.textContent = 'Recovery complete! 500 point bonus awarded.';
                }
            }
        }

        // v1.40.0: Audio Event Captions Panel (Accessibility Advocate)
        // Shows visual captions for audio events
        const AUDIO_CAPTION_ICONS = {
            laser: '🔫',
            explosion: '💥',
            shield: '🛡️',
            phase: '✨',
            combo: '🔥',
            warning: '⚠️',
            achievement: '🏆',
            info: 'ℹ️',
            heartbeat: '💓'
        };

        function showAudioCaption(type, text) {
            if (!STATE.audioCaptionsEnabled || !DOM_CACHE.audioCaptions) return;

            const icon = AUDIO_CAPTION_ICONS[type] || '🔊';
            const entry = document.createElement('div');
            entry.className = 'caption-entry';
            entry.innerHTML = `<span class="caption-icon">${icon}</span><span class="caption-text">${text}</span>`;

            DOM_CACHE.audioCaptions.insertBefore(entry, DOM_CACHE.audioCaptions.firstChild);
            DOM_CACHE.audioCaptions.classList.add('visible');

            // Limit to 4 entries
            while (DOM_CACHE.audioCaptions.children.length > 4) {
                DOM_CACHE.audioCaptions.removeChild(DOM_CACHE.audioCaptions.lastChild);
            }

            // Fade out after 2 seconds
            setTimeout(() => {
                entry.classList.add('fading');
                setTimeout(() => {
                    if (entry.parentNode) entry.parentNode.removeChild(entry);
                    if (DOM_CACHE.audioCaptions.children.length === 0) {
                        DOM_CACHE.audioCaptions.classList.remove('visible');
                    }
                }, 300);
            }, 2000);
        }

        // v1.40.0: Initialize Audio Captions Toggle (Accessibility Advocate)
        function initAudioCaptionsToggle() {
            if (!DOM_CACHE.audioCaptionsToggle) return;

            DOM_CACHE.audioCaptionsToggle.addEventListener('click', () => {
                STATE.audioCaptionsEnabled = !STATE.audioCaptionsEnabled;
                DOM_CACHE.audioCaptionsToggle.textContent = STATE.audioCaptionsEnabled ? 'CC' : 'CC OFF';
                DOM_CACHE.audioCaptionsToggle.style.opacity = STATE.audioCaptionsEnabled ? '1' : '0.5';
                // v1.78.0: Dynamic aria-label for toggle state feedback (Accessibility)
                DOM_CACHE.audioCaptionsToggle.setAttribute('aria-label', STATE.audioCaptionsEnabled ? 'Audio Captions enabled - click to disable' : 'Audio Captions disabled - click to enable');
            });
        }

        function playLaserSound() {
            if (!audioEnabled || !audioContext || STATE.reducedMotion) return;
            try {
                const now = audioContext.currentTime;
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();

                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(2000, now);
                osc.frequency.exponentialRampToValueAtTime(800, now + 0.08);

                gain.gain.setValueAtTime(0.12, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);

                osc.connect(gain);
                gain.connect(audioContext.destination);

                osc.start(now);
                osc.stop(now + 0.1);
            } catch (e) { /* Fail silently */ }
        }

        // v1.39.0: Weapon Charge-Up Spin Effect Audio (Game Feel Expert)
        // Ascending synth tone during first 200ms of firing sequence
        function playChargeUpSpinSound() {
            if (!audioEnabled || !audioContext || STATE.reducedMotion) return;
            try {
                const now = audioContext.currentTime;

                // Primary ascending spin-up tone
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();

                osc.type = 'triangle';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.exponentialRampToValueAtTime(800, now + 0.2);

                gain.gain.setValueAtTime(0, now);
                // v1.64.0: Use AUDIO_CONFIG attack time for rhythm coherence (Audio Engineer)
                gain.gain.linearRampToValueAtTime(0.08, now + AUDIO_CONFIG.attackTimeSoft);
                gain.gain.exponentialRampToValueAtTime(0.02, now + 0.2);

                osc.connect(gain);
                gain.connect(audioContext.destination);

                osc.start(now);
                osc.stop(now + 0.2);

                // Secondary harmonic overtone for richness
                const overtone = audioContext.createOscillator();
                const overtoneGain = audioContext.createGain();

                overtone.type = 'sine';
                overtone.frequency.setValueAtTime(400, now);
                overtone.frequency.exponentialRampToValueAtTime(1600, now + 0.2);

                overtoneGain.gain.setValueAtTime(0, now);
                // v1.64.0: Use AUDIO_CONFIG attack time for rhythm coherence (Audio Engineer)
                overtoneGain.gain.linearRampToValueAtTime(0.03, now + AUDIO_CONFIG.attackTimeSoft);
                overtoneGain.gain.exponentialRampToValueAtTime(0.005, now + 0.2);

                overtone.connect(overtoneGain);
                overtoneGain.connect(audioContext.destination);

                overtone.start(now);
                overtone.stop(now + 0.2);
            } catch (e) { /* Fail silently */ }
        }

        // v1.19.0: Enhanced with wobble pulse effect (Game Feel Expert)
        function playNearMissSound() {
            if (!audioEnabled || !audioContext || STATE.reducedMotion) return;
            try {
                const now = audioContext.currentTime;

                // Primary ascending chirp
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);

                gain.gain.setValueAtTime(0.08, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

                osc.connect(gain);
                gain.connect(audioContext.destination);

                osc.start(now);
                osc.stop(now + 0.15);

                // v1.19.0: Wobble pulse overtone for proximity tension
                const wobble = audioContext.createOscillator();
                const wobbleGain = audioContext.createGain();
                const lfo = audioContext.createOscillator();
                const lfoGain = audioContext.createGain();

                wobble.type = 'triangle';
                wobble.frequency.setValueAtTime(1000, now);
                wobble.frequency.exponentialRampToValueAtTime(1400, now + 0.2);

                // LFO modulates frequency for wobble effect
                lfo.type = 'sine';
                // v1.70.0: Subtler tremolo (6.5Hz) with normalized depth (35Hz = 4.4% of 800Hz) (Audio Engineer)
                lfo.frequency.setValueAtTime(6.5, now); // 6.5Hz wobble rate (heartbeat tempo)
                lfoGain.gain.setValueAtTime(35, now); // Wobble depth in Hz (±35Hz on 800Hz carrier)

                lfo.connect(lfoGain);
                lfoGain.connect(wobble.frequency);

                wobbleGain.gain.setValueAtTime(0, now);
                wobbleGain.gain.linearRampToValueAtTime(0.05, now + 0.02);
                wobbleGain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);

                wobble.connect(wobbleGain);
                wobbleGain.connect(audioContext.destination);

                lfo.start(now);
                wobble.start(now);
                lfo.stop(now + 0.2);
                wobble.stop(now + 0.2);
            } catch (e) { /* Fail silently */ }
        }

        // v1.63.0: Grace Period Countdown Audio Pulse (Player Psychologist)
        // Ascending beeps create urgency during combo save window
        function playGracePeriodBeep(progress) {
            if (!audioEnabled || !audioContext || STATE.reducedMotion) return;
            const now = Date.now();
            if (now - STATE.lastGraceBeepTime < 200) return; // 200ms interval
            STATE.lastGraceBeepTime = now;

            try {
                const t = audioContext.currentTime;
                // Ascending frequency based on elapsed progress (0-1)
                const baseFreq = 400 + (progress * 600); // 400Hz → 1000Hz

                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(baseFreq, t);
                osc.frequency.exponentialRampToValueAtTime(baseFreq * 1.2, t + 0.08);

                gain.gain.setValueAtTime(0.06, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);

                osc.connect(gain);
                gain.connect(audioContext.destination);

                osc.start(t);
                osc.stop(t + 0.1);
            } catch (e) {
                // Audio failed silently
            }
        }

        // v1.20.0: Health Warning Pulse (Audio Engineer)
        // Escalating heartbeat sound when shield drops below 50%
        // Rate increases as shield decreases (more urgent at lower health)
        function playHeartbeatPulse() {
            if (!audioEnabled || !audioContext || STATE.reducedMotion) return;
            if (STATE.shield >= 50 || STATE.shield <= 0) return;

            // Calculate heartbeat interval based on shield (800ms at 50%, 300ms at 10%)
            const urgency = 1 - (STATE.shield / 50); // 0 to 1
            const interval = 800 - (urgency * 500); // 800ms to 300ms
            const now = Date.now();

            if (now - STATE.lastHeartbeatTime < interval) return;
            STATE.lastHeartbeatTime = now;

            try {
                const t = audioContext.currentTime;

                // Double-beat (lub-dub) pattern
                // v1.59.0: Release acceleration at peak urgency - snappier heartbeat (Audio Engineer)
                // v1.66.0: Enhanced panic→relief cycle at extreme danger (Player Psychologist)
                // v1.71.0: Fix inverted scale - lower value = faster decay works correctly (Audio Engineer)
                const releaseScale = 0.3 + (1 - urgency) * 0.7; // 0.3 → 1.0 (fast at max urgency)

                // First beat (lub) - lower, louder
                const lub = audioContext.createOscillator();
                const lubGain = audioContext.createGain();
                lub.type = 'sine';
                lub.frequency.setValueAtTime(55 + urgency * 10, t);
                lub.frequency.exponentialRampToValueAtTime(40, t + 0.08);
                lubGain.gain.setValueAtTime(0, t);
                lubGain.gain.linearRampToValueAtTime(0.08 + urgency * 0.05, t + 0.02);
                // v1.67.0: Use AUDIO_CONFIG for standardized rhythm coherence (Audio Engineer)
                lubGain.gain.exponentialRampToValueAtTime(0.001, t + 0.02 + AUDIO_CONFIG.decayTimeShort * releaseScale);
                lub.connect(lubGain);
                lubGain.connect(audioContext.destination);
                lub.start(t);
                lub.stop(t + 0.12);

                // Second beat (dub) - higher, softer, delayed
                const dub = audioContext.createOscillator();
                const dubGain = audioContext.createGain();
                dub.type = 'sine';
                dub.frequency.setValueAtTime(65 + urgency * 15, t + 0.12);
                dub.frequency.exponentialRampToValueAtTime(50, t + 0.2);
                dubGain.gain.setValueAtTime(0, t + 0.12);
                dubGain.gain.linearRampToValueAtTime(0.05 + urgency * 0.03, t + 0.14);
                dubGain.gain.exponentialRampToValueAtTime(0.001, t + 0.14 + AUDIO_CONFIG.decayTimeShort * releaseScale);
                dub.connect(dubGain);
                dubGain.connect(audioContext.destination);
                dub.start(t + 0.12);
                dub.stop(t + 0.25);
            } catch (e) { /* Fail silently */ }
        }

        // v1.27.0: Phase Recharge Audio Chirps (Audio Engineer)
        // v1.88.0: Tempo Variance (Game Feel) - accelerates 500ms→350ms as energy fills
        function playPhaseRechargeChirp() {
            if (!audioEnabled || !audioContext || STATE.reducedMotion) return;
            if (STATE.isSpectral || STATE.phaseEnergy >= 100) return;

            const now = Date.now();
            // v1.88.0: Chirp rate accelerates as energy fills (500ms at 0% → 350ms at 100%)
            const energyRatio = STATE.phaseEnergy / 100;
            const chirpInterval = 500 - energyRatio * 150; // 500ms → 350ms
            if (now - STATE.lastPhaseChirpTime < chirpInterval) return;
            STATE.lastPhaseChirpTime = now;

            try {
                const t = audioContext.currentTime;
                // Chirp frequency scales with energy level (higher pitch as energy fills)
                const energyRatio = STATE.phaseEnergy / 100;
                const baseFreq = 400 + energyRatio * 200; // 400Hz at 0%, 600Hz at 100%

                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(baseFreq, t);
                osc.frequency.exponentialRampToValueAtTime(baseFreq * 1.5, t + 0.15);

                // Quick attack, gentle release
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.06, t + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, t + 0.2);

                osc.connect(gain);
                gain.connect(audioContext.destination);

                osc.start(t);
                osc.stop(t + 0.25);
            } catch (e) { /* Fail silently */ }
        }

        // v1.50.0: Phase Energy Depleted Tone (Audio Engineer)
        // Descending tone signals phase energy is empty
        function playPhaseDepletedTone() {
            if (!audioContext || !audioEnabled) return;
            try {
                const now = audioContext.currentTime;
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.exponentialRampToValueAtTime(300, now + 0.2);
                gain.gain.setValueAtTime(0.08, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                osc.connect(gain);
                gain.connect(audioContext.destination);
                osc.start(now);
                osc.stop(now + 0.25);
                showAudioCaption('warning', 'Phase energy depleted');
            } catch (e) { /* Fail silently */ }
        }

        // v1.21.0: Shield Depletion Rumble Escalation (Game Feel Expert)
        // Escalating haptic patterns as shield drops below 50%
        // Interval decreases exponentially as health drops (more urgent)
        function triggerShieldRumble() {
            if (STATE.reducedMotion) return;
            if (STATE.shield >= 50 || STATE.shield <= 0) return;
            if (!navigator.vibrate) return;

            // Calculate urgency (0 at 50%, 1 at 0%)
            const urgency = 1 - (STATE.shield / 50);
            // Interval: 600ms at 50% shield, 150ms at 10% shield
            const interval = 600 - (urgency * 450);
            const now = Date.now();

            if (now - STATE.lastShieldRumbleTime < interval) return;
            STATE.lastShieldRumbleTime = now;

            // Haptic pattern escalates: longer and more intense with lower health
            const baseDuration = 30 + Math.floor(urgency * 50); // 30-80ms
            const pattern = urgency > 0.7
                ? [baseDuration, 30, baseDuration * 0.6] // Double pulse at critical
                : [baseDuration];

            navigator.vibrate(pattern);
        }

        // v1.21.0: Momentum Cascade Reward (Player Psychologist)
        // Award bonus points for maintaining high velocity over time
        function checkMomentumCascade() {
            const speed = Math.sqrt(STATE.velocityX ** 2 + STATE.velocityY ** 2);
            const threshold = CONFIG.moveMaxSpeed * 0.6; // 60% of max speed
            const now = Date.now();

            if (speed >= threshold) {
                STATE.momentumStreak++;
                // Award bonus every 60 frames of sustained speed (~1 second)
                if (STATE.momentumStreak >= 60 && now - STATE.lastMomentumReward > 1000) {
                    const bonus = 5 * STATE.comboMultiplier;
                    STATE.score += bonus;
                    STATE.lastMomentumReward = now;
                    STATE.momentumStreak = 0;
                    TOAST_SYSTEM.show('momentum', `MOMENTUM +${bonus}`);
                }
            } else {
                STATE.momentumStreak = Math.max(0, STATE.momentumStreak - 2); // Decay when slow
            }
        }

        // v1.27.0: Progressive Mastery Unlocking (Player Psychologist)
        // Persistent milestone badges with endowment effect
        const MASTERIES = {
            'combo_4x': { name: 'Combo Master', desc: 'Reach 4x combo multiplier', icon: '⚡' },
            'combo_max': { name: 'Combo Legend', desc: 'Reach maximum combo', icon: '🔥' },
            'survivor_20s': { name: 'Survivor', desc: 'No damage for 20 seconds', icon: '🛡️' },
            'high_score': { name: 'Champion', desc: 'Beat your high score', icon: '🏆' },
            'perfect_5': { name: 'Phantom', desc: 'Get 5 perfect dodges', icon: '👻' }
        };

        function awardMastery(masteryId) {
            if (STATE.masteries[masteryId]) {
                // Already earned - show retention message
                if (!STATE.sessionMasteriesAwarded.includes(masteryId + '_retained')) {
                    STATE.sessionMasteriesAwarded.push(masteryId + '_retained');
                    const m = MASTERIES[masteryId];
                    TOAST_SYSTEM.show('mastery', `${m.icon} MASTERY RETAINED: ${m.name}`);
                }
                return;
            }

            // First time earning this mastery
            STATE.masteries[masteryId] = Date.now();
            STATE.sessionMasteriesAwarded.push(masteryId);
            localStorage.setItem('skyRealms_masteries', JSON.stringify(STATE.masteries));

            const m = MASTERIES[masteryId];
            TOAST_SYSTEM.show('mastery', `${m.icon} MASTERY UNLOCKED: ${m.name}!`);
            // v1.69.0: Celebration haptic pulse pattern for rare achievement (Player Psychologist)
            triggerHaptic([80, 40, 80, 40, 80]);

            // Announce to screen readers
            if (DOM_CACHE.ariaAlertRegion) {
                DOM_CACHE.ariaAlertRegion.textContent = `Mastery unlocked: ${m.name}. ${m.desc}`;
            }
        }

        function checkMasteries() {
            // Combo 4x mastery
            if (STATE.comboMultiplier >= 4) {
                awardMastery('combo_4x');
            }

            // Combo max mastery
            if (STATE.comboMultiplier >= CONFIG.comboMaxMultiplier) {
                awardMastery('combo_max');
            }

            // Survivor mastery (no damage for 20s)
            const timeSinceDamage = Date.now() - STATE.lastDamageTime;
            if (STATE.lastDamageTime > 0 && timeSinceDamage >= 20000) {
                awardMastery('survivor_20s');
            }

            // Perfect dodge mastery
            if (STATE.perfectDodges >= 5) {
                awardMastery('perfect_5');
            }
        }

        // v1.56.0: Volatile Mini-Achievement Surprises (Player Psychologist)
        // Rare random micro-rewards trigger dopamine spikes - intermittent variable rewards
        function checkVolatileSurprises() {
            // ~0.15% chance per frame at 60fps = roughly once per minute of active play
            if (Math.random() > 0.0015) return;
            if (STATE.comboMultiplier < 1.5 || STATE.gameState !== 'playing') return;

            const velocity = Math.sqrt(STATE.velocityX ** 2 + STATE.velocityY ** 2);
            const speedRatio = velocity / (CONFIG.moveMaxSpeed || 4);
            const timeSinceDamage = Date.now() - STATE.lastDamageTime;

            const surprises = [
                { condition: () => speedRatio > 0.7 && STATE.comboMultiplier >= 2,
                  message: '🎯 VELOCITY SYNC', points: 200, type: 'surprise' },
                { condition: () => STATE.shield > 90 && STATE.comboMultiplier >= 2.5,
                  message: '💎 PRISTINE FURY', points: 300, type: 'surprise' },
                { condition: () => timeSinceDamage > 8000 && STATE.comboMultiplier >= 2,
                  message: '👻 PHANTOM FLOW', points: 250, type: 'surprise' }
            ];

            const eligible = surprises.filter(s => s.condition());
            if (eligible.length > 0) {
                const reward = eligible[Math.floor(Math.random() * eligible.length)];
                STATE.score += reward.points;
                TOAST_SYSTEM.show(reward.type, reward.message);
                triggerHaptic([50, 30, 50]); // Surprise haptic pattern
            }
        }

        // v1.22.0: Phase-Linked Fog Shift (Visual Designer)
        // Smoothly lerp fog color toward target for cinematic phase transitions
        function updateFogTransition() {
            if (!scene.fog) return;
            const t = STATE.targetFogColor;
            const c = STATE.currentFogColor;
            const lerpSpeed = 0.05; // Slower = more cinematic

            // Lerp each RGB channel toward target
            c.r += (t.r - c.r) * lerpSpeed;
            c.g += (t.g - c.g) * lerpSpeed;
            c.b += (t.b - c.b) * lerpSpeed;

            // Apply to fog
            scene.fog.color.setRGB(c.r, c.g, c.b);
        }

        // v1.10.0: Dynamic Impact Sounds (Audio Engineer)
        // Damage-scaled synthesis: more damage = deeper/longer/louder impact
        function playImpactSound(amount, xPosition = 0) {
            if (!audioEnabled || !audioContext || STATE.reducedMotion) return;
            try {
                const now = audioContext.currentTime;
                // Scale parameters based on damage amount
                const baseFreq = Math.max(30, 60 - amount * 0.5); // Lower frequency for bigger hits
                const duration = Math.min(0.15, 0.05 + amount * 0.003);
                const volume = Math.min(0.15, 0.06 + amount * 0.003);

                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const panner = audioContext.createStereoPanner();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(baseFreq + 20, now);
                osc.frequency.exponentialRampToValueAtTime(baseFreq, now + duration);

                // Punch envelope: sharp attack, quick decay
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(volume, now + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.01, now + duration);

                // v1.10.0: Spatial panning based on X position
                panner.pan.setValueAtTime(Math.max(-1, Math.min(1, xPosition / 8)), now);

                osc.connect(gain);
                gain.connect(panner);
                // v1.83.0: Route through filter chain for dynamics stability (Audio)
                panner.connect(criticalHealthFilter || audioContext.destination);

                osc.start(now);
                osc.stop(now + duration + 0.01);

                // v1.40.0: Audio caption for accessibility
                showAudioCaption('explosion', `Impact! -${amount} shield`);
            } catch (e) { /* Fail silently */ }
        }

        // v1.83.0: Enemy Hit Confirmation Audio Tone (Game Feel)
        // 80ms descending tone triggered 50ms post-impact for audio-visual closure
        function playHitConfirmationSound(xPosition = 0) {
            if (!audioEnabled || !audioContext || STATE.reducedMotion) return;
            try {
                setTimeout(() => {
                    const now = audioContext.currentTime;
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    const panner = audioContext.createStereoPanner();

                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(500, now);
                    osc.frequency.exponentialRampToValueAtTime(300, now + 0.08);

                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(0.08, now + 0.01);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);

                    panner.pan.setValueAtTime(Math.max(-1, Math.min(1, xPosition / 10)), now);

                    osc.connect(gain);
                    gain.connect(panner);
                    panner.connect(criticalHealthFilter || audioContext.destination);

                    osc.start(now);
                    osc.stop(now + 0.1);

                    showAudioCaption('hit', 'Hit confirmed!');
                }, 50); // 50ms delay for visual-audio sync
            } catch (e) { /* Fail silently */ }
        }

        // v1.92.0: Phantom Threat Audio Cue (Player Psychologist)
        // Subtle directional chirps when enemies are off-screen, creating spatial awareness
        let lastPhantomChirpTime = 0;
        function playPhantomThreatChirp(xPosition) {
            if (!audioEnabled || !audioContext || STATE.reducedMotion) return;
            const now = Date.now();
            if (now - lastPhantomChirpTime < 800) return;  // Sparse chirps (max 1.25/sec)
            lastPhantomChirpTime = now;
            try {
                const audioNow = audioContext.currentTime;
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const panner = audioContext.createStereoPanner();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(280, audioNow);  // Low subtle tone
                osc.frequency.exponentialRampToValueAtTime(200, audioNow + 0.08);

                gain.gain.setValueAtTime(0.03, audioNow);  // Very quiet
                gain.gain.exponentialRampToValueAtTime(0.001, audioNow + 0.08);

                // Pan toward enemy X position
                panner.pan.setValueAtTime(Math.max(-1, Math.min(1, xPosition / 10)), audioNow);

                osc.connect(gain);
                gain.connect(panner);
                panner.connect(criticalHealthFilter || audioContext.destination);

                osc.start(audioNow);
                osc.stop(audioNow + 0.09);
            } catch (e) { /* Fail silently */ }
        }

        // v1.84.0: Shield Boundary Tone (Player Psychology)
        // Ascending-descending tone at 50% shield triggers loss aversion psychology
        function playShieldBoundaryTone() {
            if (!audioEnabled || !audioContext || STATE.reducedMotion) return;
            try {
                const now = audioContext.currentTime;
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();

                osc.type = 'sine';
                // 1000Hz → 1200Hz → 900Hz sweep (150ms total)
                osc.frequency.setValueAtTime(1000, now);
                osc.frequency.linearRampToValueAtTime(1200, now + 0.05);
                osc.frequency.linearRampToValueAtTime(900, now + 0.15);

                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

                osc.connect(gain);
                gain.connect(criticalHealthFilter || audioContext.destination);

                osc.start(now);
                osc.stop(now + 0.16);

                showAudioCaption('shield', 'Shield at 50%!');
            } catch (e) { /* Fail silently */ }
        }

        // v1.10.0: Explosion Sound (Audio Engineer)
        // Layered low-frequency punch for enemy deaths
        function playExplosionSound(xPosition = 0) {
            if (!audioEnabled || !audioContext || STATE.reducedMotion) return;
            try {
                const now = audioContext.currentTime;
                const panner = audioContext.createStereoPanner();
                panner.pan.setValueAtTime(Math.max(-1, Math.min(1, xPosition / 12)), now);
                // v1.83.0: Route through filter chain (Audio)
                panner.connect(criticalHealthFilter || audioContext.destination);

                // Low rumble layer
                const osc1 = audioContext.createOscillator();
                const gain1 = audioContext.createGain();
                osc1.type = 'sine';
                osc1.frequency.setValueAtTime(80, now);
                osc1.frequency.exponentialRampToValueAtTime(40, now + 0.2);
                gain1.gain.setValueAtTime(0.1, now);
                gain1.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                osc1.connect(gain1);
                gain1.connect(panner);
                osc1.start(now);
                osc1.stop(now + 0.25);

                // Mid crackle layer
                const osc2 = audioContext.createOscillator();
                const gain2 = audioContext.createGain();
                osc2.type = 'triangle';
                osc2.frequency.setValueAtTime(200, now);
                osc2.frequency.exponentialRampToValueAtTime(100, now + 0.1);
                gain2.gain.setValueAtTime(0.06, now);
                gain2.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
                osc2.connect(gain2);
                gain2.connect(panner);
                osc2.start(now);
                osc2.stop(now + 0.15);

                // v1.40.0: Audio caption for accessibility
                showAudioCaption('explosion', 'Enemy destroyed!');
            } catch (e) { /* Fail silently */ }
        }

        // v1.10.0: Phase Shift Sound (Audio Engineer)
        // Distinct whoosh for phase transitions with spatial awareness
        function playPhaseShiftSound(enteringSpectral) {
            if (!audioEnabled || !audioContext || STATE.reducedMotion) return;
            try {
                const now = audioContext.currentTime;
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();

                osc.type = 'sine';
                if (enteringSpectral) {
                    // Ascending tone for entering spectral
                    osc.frequency.setValueAtTime(400, now);
                    osc.frequency.exponentialRampToValueAtTime(1200, now + 0.15);
                } else {
                    // Descending tone for exiting spectral
                    osc.frequency.setValueAtTime(1200, now);
                    osc.frequency.exponentialRampToValueAtTime(400, now + 0.15);
                }

                gain.gain.setValueAtTime(0.08, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);

                osc.connect(gain);
                gain.connect(audioContext.destination);

                osc.start(now);
                osc.stop(now + 0.2);

                // v1.40.0: Audio caption for accessibility
                showAudioCaption('phase', enteringSpectral ? 'Entering spectral phase' : 'Returning to material phase');
            } catch (e) { /* Fail silently */ }
        }

        // v1.30.0: Harmonic Series Descent on Shield Depletion (Audio Engineer)
        // Creates dramatic "collapse" sound with descending harmonics
        function playShieldDepletionSound() {
            if (!audioEnabled || !audioContext) return;
            try {
                const now = audioContext.currentTime;
                const harmonics = [220, 110, 55]; // Descending octaves
                const stagger = 0.08; // Time between each harmonic

                harmonics.forEach((freq, i) => {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();

                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(freq, now + i * stagger);

                    // Envelope: quick attack, slow decay
                    const startTime = now + i * stagger;
                    gain.gain.setValueAtTime(0, startTime);
                    gain.gain.linearRampToValueAtTime(0.15, startTime + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.4);

                    osc.connect(gain);
                    gain.connect(audioContext.destination);

                    osc.start(startTime);
                    osc.stop(startTime + 0.45);
                });
            } catch (e) { /* Fail silently */ }
        }

        // v1.34.0: Game Over Defeat Fanfare (Audio Engineer)
        // Dramatic descending cascade with low-frequency rumble for defeat closure
        function playGameOverSound() {
            if (!audioEnabled || !audioContext) return;
            try {
                const now = audioContext.currentTime;
                // Five-note descending harmonic cascade with octave jumps
                const frequencies = [440, 220, 110, 55, 27.5];
                const stagger = 0.15;

                frequencies.forEach((freq, i) => {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();

                    osc.type = i < 3 ? 'sine' : 'triangle'; // Lower notes use triangle for rumble
                    osc.frequency.setValueAtTime(freq, now + i * stagger);

                    const startTime = now + i * stagger;
                    gain.gain.setValueAtTime(0, startTime);
                    gain.gain.linearRampToValueAtTime(0.2 - (i * 0.03), startTime + 0.03);
                    gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.8);

                    osc.connect(gain);
                    gain.connect(audioContext.destination);

                    osc.start(startTime);
                    osc.stop(startTime + 0.85);
                });

                // Low-frequency rumble undertone
                const rumble = audioContext.createOscillator();
                const rumbleGain = audioContext.createGain();
                rumble.type = 'sine';
                rumble.frequency.setValueAtTime(40, now);
                rumbleGain.gain.setValueAtTime(0, now);
                rumbleGain.gain.linearRampToValueAtTime(0.08, now + 0.2);
                rumbleGain.gain.exponentialRampToValueAtTime(0.01, now + 1.2);
                rumble.connect(rumbleGain);
                rumbleGain.connect(audioContext.destination);
                rumble.start(now);
                rumble.stop(now + 1.3);
            } catch (e) { /* Fail silently */ }
        }

        // v1.3.0: Near-Miss Bonus System (v1.8.0: uses CONFIG thresholds)
        // v1.17.0: Near-Miss Combo Extender - dodging resets combo timer (Psychology)
        // v1.22.0: Added shield flash effect (Game Feel)
        // v1.91.0: Added obstacle type for damage mitigation messaging (Psychology)
        function checkNearMiss(obstaclePosition, obstacleType = 'physical') {
            const distance = playerShip.position.distanceTo(obstaclePosition);
            // Near miss: close but not colliding
            if (distance > CONFIG.nearMissMinDist && distance < CONFIG.nearMissMaxDist) {
                STATE.nearMissCount++;
                const missScore = CONFIG.nearMissScore * STATE.comboMultiplier;
                STATE.score += missScore;
                playNearMissSound();
                showNearMissPopup(obstaclePosition);
                // v1.9.0: Toast notification for near-miss
                // v1.77.0: Include multiplier in near-miss toast for psychology feedback
                // v1.79.0: Loss amplification framing - emphasize avoided loss (Psychology)
                // v1.91.0: Loss Mitigation Value Messaging - show actual damage avoided (Psychology)
                const mitigatedDmg = obstacleType === 'energy' ?
                    (STATE.isSpectral ? CONFIG.collisionDamage.spectralEnergy : 0) :
                    (STATE.isSpectral ? 0 : CONFIG.collisionDamage.materialPhysical);
                const dmgMsg = mitigatedDmg > 0 ? `MITIGATED: ${mitigatedDmg} DMG` : 'PHASED THROUGH';
                TOAST_SYSTEM.show('nearmiss', `+${missScore} (${STATE.comboMultiplier}x) ${dmgMsg}`);

                // v1.17.0: Near-miss extends combo by resetting decay timer
                if (STATE.comboMultiplier > 1) {
                    STATE.comboTimer = Date.now();
                }

                // v1.22.0: Near-Miss Shield Flash (Game Feel Expert)
                triggerNearMissFlash();

                return true;
            }
            return false;
        }

        // v1.22.0: Near-Miss Shield Flash (Game Feel Expert)
        // Brief green shield flash to visually reward close dodges
        function triggerNearMissFlash() {
            if (STATE.reducedMotion) return;
            const overlay = DOM_CACHE.damageOverlay;
            if (!overlay) return;
            // Remove and re-add class to restart animation
            overlay.classList.remove('near-miss-flash');
            void overlay.offsetWidth; // Force reflow
            overlay.classList.add('near-miss-flash');
            // Clean up after animation
            setTimeout(() => overlay.classList.remove('near-miss-flash'), 400);

            // v1.85.0: Near-Miss Shield Pulse Tint (Psychology)
            // Cyan flash on shield bar amplifies relief emotion
            const shieldBar = DOM_CACHE.shieldBar;
            if (shieldBar) {
                shieldBar.classList.remove('near-miss-flash');
                void shieldBar.offsetWidth;
                shieldBar.classList.add('near-miss-flash');
                setTimeout(() => shieldBar.classList.remove('near-miss-flash'), 500);
            }
        }

        function showNearMissPopup(position) {
            // Create floating text element (v1.8.0: uses CONFIG score)
            // v1.77.0: Show multiplier in popup for reward transparency
            // v1.79.0: Loss amplification framing - avoided loss feels stronger than near-win (Psychology)
            const popup = document.createElement('div');
            popup.textContent = `+${CONFIG.nearMissScore * STATE.comboMultiplier} (${STATE.comboMultiplier}x) SHIELD PRESERVED!`;
            popup.style.cssText = `
                position: fixed;
                left: 50%;
                top: 40%;
                transform: translateX(-50%);
                color: #ffff00;
                font-size: 20px;
                font-weight: bold;
                text-shadow: 0 0 10px #ffff00;
                pointer-events: none;
                z-index: 100;
                animation: nearMissFloat 0.8s ease-out forwards;
            `;
            document.body.appendChild(popup);
            setTimeout(() => popup.remove(), 800);
        }

        // v1.4.0: Floating Damage Numbers (UX Polish Specialist)
        function showDamageNumber(amount) {
            const popup = document.createElement('div');
            popup.className = 'damage-number';
            popup.textContent = `-${amount}`;
            document.body.appendChild(popup);
            setTimeout(() => popup.remove(), 800);
        }

        // v1.20.0: Geometry Disposal Helper (Performance Optimizer)
        // Properly dispose of Three.js mesh resources to prevent GPU memory leaks
        function disposeMesh(mesh) {
            if (!mesh) return;
            if (mesh.geometry) mesh.geometry.dispose();
            if (mesh.material) {
                // Handle material arrays (multi-material meshes)
                if (Array.isArray(mesh.material)) {
                    mesh.material.forEach(m => m.dispose());
                } else {
                    mesh.material.dispose();
                }
            }
        }

        function createExplosion(position, color, scale = 1) {
            const particleCount = 10;
            const geometry = new THREE.BufferGeometry();
            // v1.71.0: Pre-allocated Float32Array eliminates GC pressure (Performance Optimizer)
            const positions = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount; i++) {
                const idx = i * 3;
                positions[idx] = position.x;
                positions[idx + 1] = position.y;
                positions[idx + 2] = position.z;
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({ color: color, size: 0.5 * scale });
            const particles = new THREE.Points(geometry, material);
            
            scene.add(particles);
            
            // Simple animation (would be better with a particle system class)
            const startTime = Date.now();
            const animateExplosion = () => {
                const elapsed = Date.now() - startTime;
                if (elapsed > 500) {
                    scene.remove(particles);
                    geometry.dispose(); // v1.20.0
                    material.dispose(); // v1.20.0
                    return;
                }
                
                const positions = particles.geometry.attributes.position.array;
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] += (Math.random() - 0.5) * 0.5;
                    positions[i * 3 + 1] += (Math.random() - 0.5) * 0.5;
                    positions[i * 3 + 2] += (Math.random() - 0.5) * 0.5;
                }
                particles.geometry.attributes.position.needsUpdate = true;
                requestAnimationFrame(animateExplosion);
            };
            animateExplosion();
        }

        // v1.31.0: Enemy Defeat Sparkle Burst (UX/Visual)
        // Creates cascading sparkle effect on enemy destruction
        function createSparkleBurst(position) {
            if (STATE.reducedMotion) return;

            const sparkleCount = 15;
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const velocities = [];

            // Initialize sparkles radiating outward
            for (let i = 0; i < sparkleCount; i++) {
                positions.push(position.x, position.y, position.z);
                // Random direction in sphere
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const speed = 0.15 + Math.random() * 0.2;
                velocities.push(
                    Math.sin(phi) * Math.cos(theta) * speed,
                    Math.sin(phi) * Math.sin(theta) * speed,
                    Math.cos(phi) * speed
                );
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            // v1.61.0: Phase-aware sparkle color harmony - spectral cyan vs material gold (Visual Designer)
            const sparkleColor = STATE.isSpectral ? 0x66ffff : 0xffdd66;
            const material = new THREE.PointsMaterial({
                color: sparkleColor,
                size: 0.25,
                transparent: true,
                opacity: 1.0
            });
            const sparkles = new THREE.Points(geometry, material);
            scene.add(sparkles);

            const startTime = Date.now();
            const duration = 400;
            const animateSparkles = () => {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / duration;

                if (elapsed > duration) {
                    scene.remove(sparkles);
                    geometry.dispose();
                    material.dispose();
                    return;
                }

                const posArr = sparkles.geometry.attributes.position.array;
                for (let i = 0; i < sparkleCount; i++) {
                    posArr[i * 3] += velocities[i * 3];
                    posArr[i * 3 + 1] += velocities[i * 3 + 1];
                    posArr[i * 3 + 2] += velocities[i * 3 + 2];
                }
                sparkles.geometry.attributes.position.needsUpdate = true;
                // v1.60.0: Ease-out sparkle fade for elegant dissipation (Visual Designer)
                material.opacity = Math.pow(1 - progress, 0.7);
                requestAnimationFrame(animateSparkles);
            };
            animateSparkles();
        }

        // v1.38.0: Enemy Death Dissolution (Visual Designer)
        // Gradually dissolve enemy with fade and shrink instead of instant removal
        function startEnemyDissolution(enemyMesh, position) {
            if (STATE.reducedMotion) {
                // Skip animation, just remove
                scene.remove(enemyMesh);
                disposeMesh(enemyMesh);
                return;
            }

            // v1.45.0: Enemy Shake at Dissolution Start (Game Feel Expert)
            // Brief rapid shake sequence to signal hit registration
            const originalPos = enemyMesh.position.clone();
            const shakeIntensity = 0.15;
            const shakeDuration = 80; // ms
            const shakeStart = Date.now();

            function doShake() {
                const elapsed = Date.now() - shakeStart;
                if (elapsed < shakeDuration) {
                    const decay = 1 - (elapsed / shakeDuration);
                    enemyMesh.position.x = originalPos.x + (Math.random() - 0.5) * shakeIntensity * decay;
                    enemyMesh.position.y = originalPos.y + (Math.random() - 0.5) * shakeIntensity * decay;
                    requestAnimationFrame(doShake);
                } else {
                    enemyMesh.position.copy(originalPos);
                }
            }
            doShake();

            // Clone material to avoid affecting other meshes
            const dissolveMat = enemyMesh.material.clone();
            dissolveMat.transparent = true;
            dissolveMat.opacity = 1.0;
            dissolveMat.wireframe = false;
            enemyMesh.material = dissolveMat;

            dyingEnemies.push({
                mesh: enemyMesh,
                material: dissolveMat,
                startTime: Date.now(),
                duration: 600, // 0.6 second dissolution
                startScale: enemyMesh.scale.clone(),
                startPos: position.clone()
            });
        }

        // v1.38.0: Update dying enemies dissolution effect
        function updateDyingEnemies() {
            for (let i = dyingEnemies.length - 1; i >= 0; i--) {
                const dying = dyingEnemies[i];
                const elapsed = Date.now() - dying.startTime;
                const progress = Math.min(1, elapsed / dying.duration);

                if (progress >= 1) {
                    // Animation complete - remove mesh
                    scene.remove(dying.mesh);
                    dying.material.dispose();
                    dyingEnemies.splice(i, 1);
                    continue;
                }

                // Fade opacity with ease-out curve
                dying.material.opacity = 1 - (progress * progress);

                // Shrink to 60% of original size
                const shrinkFactor = 1 - (progress * 0.4);
                dying.mesh.scale.set(
                    dying.startScale.x * shrinkFactor,
                    dying.startScale.y * shrinkFactor,
                    dying.startScale.z * shrinkFactor
                );

                // Switch to wireframe at 50% progress
                if (progress > 0.5 && !dying.material.wireframe) {
                    dying.material.wireframe = true;
                }

                // Slight upward drift
                dying.mesh.position.y += 0.02;

                // Spin as it dissolves
                dying.mesh.rotation.y += 0.05;
            }
        }

        // v1.10.0: Phase Transition Particles (Visual Designer)
        // Creates a 360-degree burst of particles around the ship on phase shift
        function createPhaseTransitionBurst(enteringSpectral) {
            if (STATE.reducedMotion) return; // Respect accessibility

            const particleCount = 30;
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const velocities = [];
            const center = playerShip.position.clone();

            // Color: cyan for spectral, orange for material
            const color = enteringSpectral ? 0x00ffff : 0xffaa00;

            // Initialize particles in a ring around the ship
            for (let i = 0; i < particleCount; i++) {
                const angle = (i / particleCount) * Math.PI * 2;
                const radius = 0.5;
                positions.push(
                    center.x + Math.cos(angle) * radius,
                    center.y + Math.sin(angle) * radius * 0.5,
                    center.z
                );
                // Velocity: expand outward (spectral) or contract inward (material)
                const direction = enteringSpectral ? 1 : -0.5;
                velocities.push(
                    Math.cos(angle) * 0.15 * direction,
                    Math.sin(angle) * 0.08 * direction,
                    (Math.random() - 0.5) * 0.1
                );
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({
                color: color,
                size: 0.3,
                transparent: true,
                opacity: 1.0
            });
            const particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // Animate the burst
            const startTime = Date.now();
            const duration = 600;
            const animateBurst = () => {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / duration;

                if (elapsed > duration) {
                    scene.remove(particles);
                    geometry.dispose();
                    material.dispose();
                    return;
                }

                // Update positions
                const posArray = particles.geometry.attributes.position.array;
                for (let i = 0; i < particleCount; i++) {
                    posArray[i * 3] += velocities[i * 3];
                    posArray[i * 3 + 1] += velocities[i * 3 + 1];
                    posArray[i * 3 + 2] += velocities[i * 3 + 2];
                }
                particles.geometry.attributes.position.needsUpdate = true;

                // Fade out
                material.opacity = 1 - progress;

                requestAnimationFrame(animateBurst);
            };
            animateBurst();
        }

        function updateUI() {
            // v1.12.0: Use memoized DOM references for performance (eliminates 5+ getElementById calls per frame)
            if (!DOM_CACHE.initialized) return;

            // v1.31.0: Update Function Throttling (Performance Optimizer)
            // Skip expensive DOM updates when values haven't changed
            const shieldInt = Math.floor(STATE.shield);
            const phaseInt = Math.floor(STATE.phaseEnergy);
            const scoreInt = Math.floor(STATE.score);

            // Only update shield bar if shield value changed
            if (shieldInt !== STATE.lastRenderedShield) {
                STATE.lastRenderedShield = shieldInt;
                DOM_CACHE.shieldBar.style.width = `${Math.max(0, STATE.shield)}%`;

                // v1.26.0: Shield State Gradient Bar (Visual Designer)
                // v1.28.0: Refactored to use SHIELD_COLOR_CACHE for memoization (Performance)
                const shieldColor = SHIELD_COLOR_CACHE.getColor(STATE.shield);
                DOM_CACHE.shieldBar.style.background = shieldColor;

                // v1.36.0: Health/Shield Threshold Warning Glow (Visual Designer)
                // Add pulsing glow to shield bar when critical (<30%)
                if (STATE.shield < 30) {
                    DOM_CACHE.shieldBar.classList.add('bar-critical');
                } else {
                    DOM_CACHE.shieldBar.classList.remove('bar-critical');
                }
                // v1.88.0: Bar Fill State Color Indicator (UX Polish)
                DOM_CACHE.shieldBar.classList.toggle('bar-full', STATE.shield >= 100);
            }

            // Only update phase bar if phase energy changed
            if (phaseInt !== STATE.lastRenderedPhase) {
                STATE.lastRenderedPhase = phaseInt;
                DOM_CACHE.phaseBar.style.width = `${Math.max(0, STATE.phaseEnergy)}%`;
                // v1.88.0: Bar Fill State Color Indicator (UX Polish)
                DOM_CACHE.phaseBar.classList.toggle('bar-full', STATE.phaseEnergy >= 100);
            }

            // Only update score display if score changed
            if (scoreInt !== STATE.lastRenderedScore) {
                STATE.lastRenderedScore = scoreInt;
                DOM_CACHE.scoreDisplay.innerText = scoreInt.toString().padStart(5, '0');
            }

            // v1.18.0: Text Label Alternatives (Accessibility Advocate)
            // Update aria-valuenow and enhanced aria-label with percentages
            const shieldPct = Math.round(STATE.shield);
            const phasePct = Math.round(STATE.phaseEnergy);
            if (DOM_CACHE.shieldContainer) {
                DOM_CACHE.shieldContainer.setAttribute('aria-valuenow', shieldPct);
                DOM_CACHE.shieldContainer.setAttribute('aria-label', `Shield Integrity: ${shieldPct}%`);
            }
            if (DOM_CACHE.phaseContainer) {
                DOM_CACHE.phaseContainer.setAttribute('aria-valuenow', phasePct);
                DOM_CACHE.phaseContainer.setAttribute('aria-label', `Phase Energy: ${phasePct}%`);
            }

            // v1.18.0: Difficulty Tension Feedback (Player Psychologist)
            // v1.29.0: Lazy Threat Level Computation - skip calculation if enemy count unchanged
            if (DOM_CACHE.threatIndicator) {
                const enemyCount = enemies.length;

                // v1.29.0: Only recalculate threat level when enemy count changes
                if (enemyCount !== STATE.lastEnemyCount) {
                    STATE.lastEnemyCount = enemyCount;

                    // v1.89.0: Update numeric enemy count badge (UX Polish)
                    // v1.90.0: Use cached span + descriptive ARIA (Performance/Accessibility)
                    if (DOM_CACHE.threatCount) {
                        DOM_CACHE.threatCount.textContent = enemyCount;
                        DOM_CACHE.threatCount.setAttribute('aria-label', `Active enemies: ${enemyCount}`);
                    }

                    const threatLevel = enemyCount < 3 ? 'LOW' :
                                        enemyCount < 6 ? 'MEDIUM' :
                                        enemyCount < 10 ? 'HIGH' : 'EXTREME';
                    const threatClass = enemyCount < 3 ? 'threat-low' :
                                        enemyCount < 6 ? 'threat-medium' :
                                        enemyCount < 10 ? 'threat-high' : 'threat-extreme';

                    // v1.24.0: Threat Indicator Conditional Class Swap (Performance)
                    // Only update DOM when threat level actually changes
                    if (threatClass !== STATE.lastThreatClass) {
                        // v1.90.0: Use cached span instead of querySelector (Performance)
                        if (DOM_CACHE.threatLevel) {
                            DOM_CACHE.threatLevel.textContent = threatLevel;
                            // v1.91.0: Letter-Spacing Emphasis (UX Polish)
                            // Wider spacing = more threat urgency
                            const letterSpacings = { 'threat-low': '1px', 'threat-medium': '2px', 'threat-high': '3px', 'threat-extreme': '4px' };
                            DOM_CACHE.threatLevel.style.letterSpacing = letterSpacings[threatClass] || '1px';
                        }

                        DOM_CACHE.threatIndicator.classList.remove('threat-low', 'threat-medium', 'threat-high', 'threat-extreme');
                        DOM_CACHE.threatIndicator.classList.add(threatClass);
                        STATE.lastThreatClass = threatClass;

                        // v1.85.0: Threat Level Category ARIA Mapping (Accessibility)
                        // Dynamic aria-label maps threat colors to semantic descriptions
                        const ariaDescriptions = {
                            'threat-low': 'Threat Level: Low - Safe zone',
                            'threat-medium': 'Threat Level: Medium - Stay alert',
                            'threat-high': 'Threat Level: High - Danger zone',
                            'threat-extreme': 'Threat Level: Extreme - Maximum danger'
                        };
                        DOM_CACHE.threatIndicator.setAttribute('aria-label', ariaDescriptions[threatClass] || 'Threat Level');
                    }
                }
            }

            // v1.20.0: Crosshair Cooldown Pulse Ring (UX Polish Specialist)
            // Visual indicator showing fire readiness state
            if (DOM_CACHE.cooldownRing) {
                const timeSinceShot = Date.now() - lastShotTime;
                const canFire = timeSinceShot > CONFIG.shootCooldown && !STATE.isSpectral;

                if (canFire) {
                    DOM_CACHE.cooldownRing.classList.add('ready');
                    DOM_CACHE.cooldownRing.classList.remove('charging');
                } else {
                    DOM_CACHE.cooldownRing.classList.remove('ready');
                    DOM_CACHE.cooldownRing.classList.add('charging');
                }
            }

            // v1.18.0: Critical Status ARIA Alerts (Accessibility Advocate)
            // Announce critical events to screen readers (throttled)
            if (DOM_CACHE.ariaAlertRegion && !STATE.ariaAlertCooldown) {
                let alertMsg = '';
                if (STATE.shield > 0 && STATE.shield < 15 && !STATE.lastShieldAlert) {
                    alertMsg = 'Warning: Shield critical at ' + shieldPct + ' percent!';
                    STATE.lastShieldAlert = true;
                } else if (STATE.shield >= 15) {
                    STATE.lastShieldAlert = false;
                }
                if (alertMsg) {
                    DOM_CACHE.ariaAlertRegion.textContent = alertMsg;
                    STATE.ariaAlertCooldown = true;
                    setTimeout(() => { STATE.ariaAlertCooldown = false; }, 3000);
                }
            }

            // v1.16.0: Shield Depletion Flicker (Game Feel)
            if (STATE.shield > 0 && STATE.shield < CONFIG.shieldCriticalThreshold) {
                DOM_CACHE.damageOverlay.classList.add('shield-critical');
            } else {
                DOM_CACHE.damageOverlay.classList.remove('shield-critical');
            }

            // v1.19.0: Shield Depletion Gradient Vignette (Visual Designer)
            // Progressive edge darkening as shield drops below 35%
            if (STATE.shield < 35 && STATE.shield > 0) {
                DOM_CACHE.damageOverlay.classList.add('shield-vignette');
                // Intensity scales from 0 at 35% to 0.5 at 0%
                const vignetteIntensity = Math.min(0.5, (35 - STATE.shield) / 70);
                DOM_CACHE.damageOverlay.style.setProperty('--vignette-intensity', vignetteIntensity);
            } else {
                DOM_CACHE.damageOverlay.classList.remove('shield-vignette');
                DOM_CACHE.damageOverlay.style.setProperty('--vignette-intensity', 0);
            }

            // v1.4.0: Phase Energy Low Warning (v1.8.0: uses CONFIG threshold)
            if (STATE.phaseEnergy < CONFIG.phaseEnergyWarning && STATE.phaseEnergy > 0) {
                DOM_CACHE.phaseBar.classList.add('low-energy');
            } else {
                DOM_CACHE.phaseBar.classList.remove('low-energy');
            }

            // v1.15.0: Phase Energy Regen Pulse (Game Feel)
            // Pulse when recharging in material phase (not spectral, not full)
            if (!STATE.isSpectral && STATE.phaseEnergy < 100 && STATE.phaseEnergy > 0) {
                DOM_CACHE.phaseBar.classList.add('recharging');
            } else {
                DOM_CACHE.phaseBar.classList.remove('recharging');
            }

            // v1.2.0: Combo Multiplier Display
            // v1.15.0: Added tier-based recoloring (Visual Designer)
            // v1.16.0: Added countdown timer (UX)
            // v1.47.0: Combo Tier Name Progression (Player Psychologist)
            const COMBO_PROGRESSION_NAMES = ['', 'NOVICE', 'ADEPT', 'VETERAN', 'MASTER', 'ASCENDANT', 'LEGENDARY', 'MYTHIC', 'GODLIKE'];
            if (STATE.comboMultiplier > 1) {
                // Update combo text with tier name instead of just multiplier
                const tierIndex = Math.min(STATE.comboMultiplier, COMBO_PROGRESSION_NAMES.length - 1);
                const tierName = COMBO_PROGRESSION_NAMES[tierIndex];
                // v1.74.0: Show kills remaining to next tier for progression clarity (Psychology)
                const killsNeeded = [4, 3, 2, 1][Math.min(STATE.comboMultiplier - 1, 3)] || 1;
                const killsRemaining = Math.max(0, killsNeeded - STATE.comboKills);
                const progressText = killsRemaining > 0 ? ` (${killsRemaining} to next)` : ' (MAX!)';
                const comboText = `${tierName} x${STATE.comboMultiplier}${progressText}`;

                // v1.16.0: Calculate and display countdown timer
                const timeSinceKill = Date.now() - STATE.comboTimer;
                const remainingMs = CONFIG.comboDecayMs - timeSinceKill;
                const remainingSec = Math.max(0, remainingMs / 1000).toFixed(1);

                DOM_CACHE.comboDisplay.firstChild.textContent = comboText;
                if (DOM_CACHE.comboCountdown) {
                    DOM_CACHE.comboCountdown.textContent = ` [${remainingSec}s]`;
                    DOM_CACHE.comboCountdown.classList.remove('countdown-warning', 'countdown-critical');
                    if (remainingMs < 500) {
                        DOM_CACHE.comboCountdown.classList.add('countdown-critical');
                    } else if (remainingMs < 1000) {
                        DOM_CACHE.comboCountdown.classList.add('countdown-warning');
                    }
                }

                DOM_CACHE.comboDisplay.classList.add('active');

                // v1.15.0: Apply tier color class
                DOM_CACHE.comboDisplay.classList.remove('combo-tier-2', 'combo-tier-3', 'combo-tier-4', 'combo-tier-max');
                // v1.28.0: Dynamic ARIA Combo Labels (Accessibility Advocate)
                const COMBO_TIER_NAMES = ['Basic', 'Silver', 'Gold', 'Platinum', 'MAX'];
                let currentTier = 1;
                if (STATE.comboMultiplier >= 5) {
                    DOM_CACHE.comboDisplay.classList.add('combo-tier-max');
                    currentTier = 5;
                } else if (STATE.comboMultiplier === 4) {
                    DOM_CACHE.comboDisplay.classList.add('combo-tier-4');
                    currentTier = 4;
                } else if (STATE.comboMultiplier === 3) {
                    DOM_CACHE.comboDisplay.classList.add('combo-tier-3');
                    currentTier = 3;
                } else if (STATE.comboMultiplier === 2) {
                    DOM_CACHE.comboDisplay.classList.add('combo-tier-2');
                    currentTier = 2;
                }

                // v1.28.0: Update ARIA label with tier info
                const comboTierName = COMBO_TIER_NAMES[currentTier - 1];
                const ariaLabel = `Combo Tier ${currentTier} of 5: ${comboTierName}. ${STATE.comboKills} kills, ${STATE.comboMultiplier}x multiplier`;
                DOM_CACHE.comboDisplay.setAttribute('aria-label', ariaLabel);

                // v1.28.0: Announce tier progression to screen readers
                if (currentTier > STATE.lastAnnouncedComboTier && DOM_CACHE.ariaAlertRegion) {
                    DOM_CACHE.ariaAlertRegion.textContent = `Combo tier up! Now at ${comboTierName} tier, ${currentTier} of 5`;
                    STATE.lastAnnouncedComboTier = currentTier;

                    // v1.31.0: Combo Tier Ring Pulse (UX Polish Specialist)
                    // v1.86.0: Consolidated Reflow Trigger (Performance Optimizer)
                    // Batch class operations and use single reflow for both animations
                    DOM_CACHE.comboDisplay.classList.remove('tier-ring-pulse', 'milestone-glow');
                    void DOM_CACHE.comboDisplay.offsetWidth; // Single reflow for both animations
                    DOM_CACHE.comboDisplay.classList.add('tier-ring-pulse', 'milestone-glow');
                    setTimeout(() => DOM_CACHE.comboDisplay.classList.remove('tier-ring-pulse'), 500);
                    setTimeout(() => DOM_CACHE.comboDisplay.classList.remove('milestone-glow'), 600);
                }

                // v1.51.0: Comeback Bonus HUD Indicator (Player Psychology)
                if (DOM_CACHE.comebackIndicator) {
                    const now = Date.now();
                    if (now < STATE.comebackMultiplierExpiry && STATE.comebackMultiplier > 1) {
                        const remaining = Math.ceil((STATE.comebackMultiplierExpiry - now) / 1000);
                        DOM_CACHE.comebackIndicator.textContent = `COMEBACK ${STATE.comebackMultiplier.toFixed(1)}x (${remaining}s)`;
                        DOM_CACHE.comebackIndicator.classList.add('active');
                    } else {
                        DOM_CACHE.comebackIndicator.classList.remove('active');
                        DOM_CACHE.comebackIndicator.textContent = '';
                    }
                }
            } else {
                DOM_CACHE.comboDisplay.classList.remove('active', 'combo-tier-2', 'combo-tier-3', 'combo-tier-4', 'combo-tier-max');
                if (DOM_CACHE.comboCountdown) {
                    DOM_CACHE.comboCountdown.textContent = '';
                }
                // v1.28.0: Reset ARIA label when combo inactive
                DOM_CACHE.comboDisplay.setAttribute('aria-label', 'Combo Multiplier: Inactive');
                STATE.lastAnnouncedComboTier = 0;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>