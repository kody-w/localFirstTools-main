<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Starfield Traders - Elite Space Trading & Combat Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #0f0;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            background: #000;
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .ui-overlay > * {
            pointer-events: auto;
        }

        .hud {
            position: absolute;
            font-size: 14px;
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.8);
        }

        .hud-top-left {
            top: 10px;
            left: 10px;
        }

        .hud-top-right {
            top: 10px;
            right: 10px;
            text-align: right;
        }

        .hud-bottom-left {
            bottom: 10px;
            left: 10px;
        }

        .hud-bottom-right {
            bottom: 10px;
            right: 10px;
            text-align: right;
        }

        .bar {
            width: 200px;
            height: 20px;
            border: 2px solid #0f0;
            position: relative;
            margin: 5px 0;
        }

        .bar-fill {
            height: 100%;
            transition: width 0.3s;
        }

        .bar-shields { background: rgba(0, 150, 255, 0.7); }
        .bar-hull { background: rgba(255, 100, 0, 0.7); }
        .bar-fuel { background: rgba(255, 255, 0, 0.7); }

        .bar-label {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: #fff;
            text-shadow: 1px 1px 2px #000;
        }

        .modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 20, 0, 0.95);
            border: 3px solid #0f0;
            padding: 20px;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.5);
        }

        .modal h2 {
            color: #0ff;
            margin-bottom: 15px;
            border-bottom: 2px solid #0f0;
            padding-bottom: 10px;
        }

        .modal h3 {
            color: #ff0;
            margin-top: 15px;
            margin-bottom: 10px;
        }

        .btn {
            background: rgba(0, 100, 0, 0.8);
            border: 2px solid #0f0;
            color: #0f0;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            transition: all 0.2s;
        }

        .btn:hover {
            background: rgba(0, 255, 0, 0.3);
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.8);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-danger {
            background: rgba(100, 0, 0, 0.8);
            border-color: #f00;
            color: #f00;
        }

        .btn-danger:hover {
            background: rgba(255, 0, 0, 0.3);
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.8);
        }

        .btn-primary {
            background: rgba(0, 0, 100, 0.8);
            border-color: #0ff;
            color: #0ff;
        }

        .btn-primary:hover {
            background: rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.8);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
        }

        th, td {
            border: 1px solid #0f0;
            padding: 8px;
            text-align: left;
        }

        th {
            background: rgba(0, 100, 0, 0.5);
            color: #0ff;
        }

        tr:hover {
            background: rgba(0, 255, 0, 0.1);
        }

        input, select {
            background: rgba(0, 50, 0, 0.8);
            border: 2px solid #0f0;
            color: #0f0;
            padding: 5px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }

        .card {
            border: 2px solid #0f0;
            padding: 15px;
            background: rgba(0, 50, 0, 0.3);
        }

        .card.selected {
            border-color: #0ff;
            background: rgba(0, 150, 150, 0.3);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        .radar {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            border: 2px solid #0f0;
            border-radius: 50%;
            background: rgba(0, 20, 0, 0.7);
        }

        .target-info {
            position: absolute;
            top: 100px;
            right: 20px;
            width: 250px;
            background: rgba(0, 20, 0, 0.9);
            border: 2px solid #f90;
            padding: 10px;
        }

        .notification {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 100, 100, 0.9);
            border: 2px solid #0ff;
            padding: 15px 30px;
            font-size: 16px;
            animation: slideDown 0.3s ease-out;
            z-index: 1000;
        }

        @keyframes slideDown {
            from { top: -50px; opacity: 0; }
            to { top: 50px; opacity: 1; }
        }

        .faction-rep {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }

        .faction-rep-bar {
            flex: 1;
            height: 15px;
            background: #333;
            border: 1px solid #0f0;
            margin: 0 10px;
            position: relative;
        }

        .faction-rep-fill {
            height: 100%;
            background: linear-gradient(to right, #f00, #ff0, #0f0);
            transition: width 0.3s;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #0ff;
            padding: 10px;
            pointer-events: none;
            z-index: 2000;
            max-width: 300px;
        }

        .controls-help {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #0f0;
            padding: 5px 15px;
            font-size: 12px;
        }

        .mission-badge {
            display: inline-block;
            padding: 3px 8px;
            margin: 2px;
            border: 1px solid;
            font-size: 11px;
            border-radius: 3px;
        }

        .mission-easy { border-color: #0f0; color: #0f0; }
        .mission-medium { border-color: #ff0; color: #ff0; }
        .mission-hard { border-color: #f90; color: #f90; }
        .mission-extreme { border-color: #f00; color: #f00; }

        .scroll-container {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #0f0;
            padding: 10px;
            margin: 10px 0;
        }

        .scroll-container::-webkit-scrollbar {
            width: 10px;
        }

        .scroll-container::-webkit-scrollbar-track {
            background: rgba(0, 50, 0, 0.3);
        }

        .scroll-container::-webkit-scrollbar-thumb {
            background: #0f0;
            border: 1px solid #000;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div class="ui-overlay" id="uiOverlay"></div>

    <script>
        // ===== GAME STATE =====
        const GAME = {
            version: '1.0.0',
            state: 'menu', // menu, galaxy, system, station, combat
            time: 0,
            timePlayed: 0,
            canvas: null,
            ctx: null,
            width: 0,
            height: 0,
            keys: {},
            mouse: { x: 0, y: 0, down: false },
            camera: { x: 0, y: 0, zoom: 1 },
            particles: [],
            notifications: [],
            currentModal: null
        };

        // ===== PLAYER STATE =====
        const PLAYER = {
            name: 'Commander',
            level: 1,
            xp: 0,
            credits: 1000,
            ship: null,
            inventory: {},
            location: null, // current system
            position: { x: 0, y: 0 },
            velocity: { x: 0, y: 0 },
            rotation: 0,
            target: null,
            missions: [],
            completedMissions: 0,
            reputation: {
                'Trade Federation': 0,
                'Military Authority': 0,
                'Pirate Clans': -50,
                'Free Systems': 10
            },
            achievements: [],
            stats: {
                systemsVisited: [],
                killCount: 0,
                tradesMade: 0,
                distanceTraveled: 0,
                damageDealt: 0,
                damageTaken: 0
            }
        };

        // ===== GALAXY DATA =====
        const GALAXY = {
            systems: [],
            factions: ['Trade Federation', 'Military Authority', 'Pirate Clans', 'Free Systems'],
            events: []
        };

        // ===== SHIP TEMPLATES =====
        const SHIP_TEMPLATES = {
            scout: {
                name: 'Scout MkI',
                class: 'Scout',
                cost: 0,
                maxHull: 100,
                maxShields: 50,
                maxFuel: 100,
                cargoCapacity: 10,
                speed: 200,
                turnRate: 3,
                weapons: [{ type: 'laser', damage: 10, cooldown: 0.5 }],
                scanRange: 500
            },
            freighter: {
                name: 'Bulk Hauler',
                class: 'Freighter',
                cost: 50000,
                maxHull: 300,
                maxShields: 100,
                maxFuel: 200,
                cargoCapacity: 100,
                speed: 80,
                turnRate: 1,
                weapons: [{ type: 'laser', damage: 5, cooldown: 1 }],
                scanRange: 300
            },
            fighter: {
                name: 'Viper Fighter',
                class: 'Fighter',
                cost: 75000,
                maxHull: 150,
                maxShields: 150,
                maxFuel: 80,
                cargoCapacity: 5,
                speed: 250,
                turnRate: 5,
                weapons: [
                    { type: 'laser', damage: 15, cooldown: 0.3 },
                    { type: 'missile', damage: 50, cooldown: 3, ammo: 10 }
                ],
                scanRange: 400
            },
            explorer: {
                name: 'Deep Space Explorer',
                class: 'Explorer',
                cost: 100000,
                maxHull: 200,
                maxShields: 120,
                maxFuel: 300,
                cargoCapacity: 30,
                speed: 150,
                turnRate: 2.5,
                weapons: [{ type: 'laser', damage: 12, cooldown: 0.6 }],
                scanRange: 800
            },
            battlecruiser: {
                name: 'Titan Battlecruiser',
                class: 'Battlecruiser',
                cost: 500000,
                maxHull: 500,
                maxShields: 300,
                maxFuel: 250,
                cargoCapacity: 50,
                speed: 120,
                turnRate: 1.5,
                weapons: [
                    { type: 'laser', damage: 20, cooldown: 0.4 },
                    { type: 'plasma', damage: 80, cooldown: 2 },
                    { type: 'missile', damage: 60, cooldown: 2.5, ammo: 20 }
                ],
                scanRange: 600
            }
        };

        // ===== COMMODITY DATA =====
        const COMMODITIES = [
            { id: 'food', name: 'Food', basePrice: 50 },
            { id: 'water', name: 'Water', basePrice: 30 },
            { id: 'ore', name: 'Ore', basePrice: 100 },
            { id: 'electronics', name: 'Electronics', basePrice: 200 },
            { id: 'weapons', name: 'Weapons', basePrice: 500 },
            { id: 'luxury', name: 'Luxury Goods', basePrice: 1000 },
            { id: 'medicine', name: 'Medicine', basePrice: 300 },
            { id: 'contraband', name: 'Contraband', basePrice: 2000 }
        ];

        // ===== NAME GENERATORS =====
        const NAME_PREFIXES = ['Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Nova', 'Sigma', 'Omega', 'Proxima', 'Centauri', 'Kepler', 'Sol', 'Vega', 'Sirius', 'Rigel', 'Betelgeuse', 'Arcturus', 'Aldebaran', 'Antares'];
        const NAME_SUFFIXES = ['Prime', 'Secundus', 'Minor', 'Major', 'Station', 'Outpost', 'Hub', 'Port', 'Gateway', 'Nexus', 'Haven', 'Bastion', 'Terminus'];
        const STAR_TYPES = [
            { type: 'Red Dwarf', color: '#ff6666', size: 0.6 },
            { type: 'Yellow Star', color: '#ffff66', size: 1.0 },
            { type: 'Blue Giant', color: '#6666ff', size: 1.5 },
            { type: 'Neutron Star', color: '#ffffff', size: 0.4 }
        ];

        // ===== UTILITY FUNCTIONS =====
        function random(min, max) {
            return Math.random() * (max - min) + min;
        }

        function randomInt(min, max) {
            return Math.floor(random(min, max + 1));
        }

        function randomChoice(arr) {
            return arr[randomInt(0, arr.length - 1)];
        }

        function seededRandom(seed) {
            const x = Math.sin(seed++) * 10000;
            return x - Math.floor(x);
        }

        function distance(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }

        function angleTo(x1, y1, x2, y2) {
            return Math.atan2(y2 - y1, x2 - x1);
        }

        function clamp(val, min, max) {
            return Math.min(Math.max(val, min), max);
        }

        function formatNumber(num) {
            return num.toLocaleString();
        }

        function showNotification(message, duration = 3000) {
            const notif = document.createElement('div');
            notif.className = 'notification';
            notif.textContent = message;
            document.getElementById('uiOverlay').appendChild(notif);
            setTimeout(() => notif.remove(), duration);
        }

        // ===== GALAXY GENERATION =====
        function generateGalaxy() {
            const systems = [];
            const systemCount = 50;

            for (let i = 0; i < systemCount; i++) {
                const seed = i * 123.456;
                const x = seededRandom(seed) * 4000 - 2000;
                const y = seededRandom(seed + 1) * 4000 - 2000;
                const starType = STAR_TYPES[Math.floor(seededRandom(seed + 2) * STAR_TYPES.length)];
                const faction = GALAXY.factions[Math.floor(seededRandom(seed + 3) * GALAXY.factions.length)];

                const system = {
                    id: i,
                    name: `${randomChoice(NAME_PREFIXES)} ${randomChoice(NAME_SUFFIXES.slice(0, -6))}`,
                    x: x,
                    y: y,
                    starType: starType.type,
                    starColor: starType.color,
                    starSize: starType.size,
                    faction: faction,
                    planets: [],
                    stations: [],
                    asteroidBelts: [],
                    connections: [],
                    discovered: i === 0
                };

                // Generate planets
                const planetCount = randomInt(2, 8);
                for (let p = 0; p < planetCount; p++) {
                    const planetSeed = seed + 100 + p;
                    system.planets.push({
                        name: `${system.name} ${String.fromCharCode(65 + p)}`,
                        distance: 200 + p * 150,
                        angle: seededRandom(planetSeed) * Math.PI * 2,
                        size: seededRandom(planetSeed + 1) * 20 + 10,
                        color: `hsl(${seededRandom(planetSeed + 2) * 360}, 70%, 50%)`,
                        rotationSpeed: seededRandom(planetSeed + 3) * 0.02
                    });
                }

                // Generate stations
                const stationCount = randomInt(1, 3);
                for (let s = 0; s < stationCount; s++) {
                    const stationSeed = seed + 200 + s;
                    const stationType = seededRandom(stationSeed) > 0.7 ? 'Military' : 'Trade';
                    const station = {
                        name: `${randomChoice(NAME_PREFIXES)} ${randomChoice(NAME_SUFFIXES.slice(-6))}`,
                        type: stationType,
                        x: (seededRandom(stationSeed + 1) - 0.5) * 800,
                        y: (seededRandom(stationSeed + 2) - 0.5) * 800,
                        faction: faction,
                        market: {}
                    };

                    // Generate market prices
                    COMMODITIES.forEach(comm => {
                        const variance = seededRandom(stationSeed + comm.id.length) * 0.5 + 0.75;
                        const demand = seededRandom(stationSeed + comm.id.length * 2);
                        station.market[comm.id] = {
                            buyPrice: Math.floor(comm.basePrice * variance * (1 + demand * 0.3)),
                            sellPrice: Math.floor(comm.basePrice * variance * (1 - demand * 0.3)),
                            stock: randomInt(50, 500)
                        };
                    });

                    system.stations.push(station);
                }

                // Generate asteroid belts
                if (seededRandom(seed + 50) > 0.6) {
                    system.asteroidBelts.push({
                        distance: randomInt(300, 800),
                        count: randomInt(20, 50)
                    });
                }

                systems.push(system);
            }

            // Generate hyperspace connections
            systems.forEach((system, i) => {
                const connectionCount = randomInt(2, 5);
                const distances = systems.map((s, idx) => ({
                    idx: idx,
                    dist: distance(system.x, system.y, s.x, s.y)
                })).filter(d => d.idx !== i).sort((a, b) => a.dist - b.dist);

                for (let c = 0; c < Math.min(connectionCount, distances.length); c++) {
                    const targetIdx = distances[c].idx;
                    if (!system.connections.includes(targetIdx)) {
                        system.connections.push(targetIdx);
                    }
                    if (!systems[targetIdx].connections.includes(i)) {
                        systems[targetIdx].connections.push(i);
                    }
                }
            });

            GALAXY.systems = systems;
            PLAYER.location = systems[0];
            PLAYER.position = { x: 0, y: 0 };
        }

        // ===== SHIP MANAGEMENT =====
        function createShip(template) {
            return {
                ...JSON.parse(JSON.stringify(template)),
                hull: template.maxHull,
                shields: template.maxShields,
                fuel: template.maxFuel,
                weaponCooldowns: template.weapons.map(() => 0),
                ammo: template.weapons.map(w => w.ammo || Infinity)
            };
        }

        function getCargoUsed() {
            return Object.values(PLAYER.inventory).reduce((sum, qty) => sum + qty, 0);
        }

        function canAddCargo(amount) {
            return getCargoUsed() + amount <= PLAYER.ship.cargoCapacity;
        }

        // ===== NPC SHIPS =====
        const NPC_SHIPS = [];

        function spawnNPCShip(type, x, y) {
            const templates = {
                pirate: {
                    name: 'Pirate Raider',
                    class: 'Fighter',
                    maxHull: 100,
                    hull: 100,
                    maxShields: 80,
                    shields: 80,
                    speed: 180,
                    turnRate: 4,
                    weapons: [{ type: 'laser', damage: 12, cooldown: 0.5 }],
                    hostile: true,
                    faction: 'Pirate Clans',
                    bounty: 500
                },
                trader: {
                    name: 'Trade Vessel',
                    class: 'Freighter',
                    maxHull: 150,
                    hull: 150,
                    maxShields: 50,
                    shields: 50,
                    speed: 100,
                    turnRate: 1.5,
                    weapons: [],
                    hostile: false,
                    faction: 'Trade Federation',
                    cargo: randomInt(10, 50)
                },
                military: {
                    name: 'Military Patrol',
                    class: 'Fighter',
                    maxHull: 200,
                    hull: 200,
                    maxShields: 150,
                    shields: 150,
                    speed: 200,
                    turnRate: 3.5,
                    weapons: [
                        { type: 'laser', damage: 15, cooldown: 0.4 },
                        { type: 'missile', damage: 50, cooldown: 3, ammo: 5 }
                    ],
                    hostile: false,
                    faction: 'Military Authority',
                    scanPlayer: true
                }
            };

            const template = templates[type];
            const ship = {
                ...JSON.parse(JSON.stringify(template)),
                id: Date.now() + Math.random(),
                position: { x, y },
                velocity: { x: 0, y: 0 },
                rotation: random(0, Math.PI * 2),
                target: null,
                weaponCooldowns: template.weapons.map(() => 0),
                ammo: template.weapons.map(w => w.ammo || Infinity),
                ai: type
            };

            NPC_SHIPS.push(ship);
            return ship;
        }

        function updateNPCShips(dt) {
            NPC_SHIPS.forEach((ship, idx) => {
                // AI behavior
                if (ship.ai === 'pirate' && ship.hostile) {
                    const dx = PLAYER.position.x - ship.position.x;
                    const dy = PLAYER.position.y - ship.position.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 600) {
                        const targetAngle = Math.atan2(dy, dx);
                        let angleDiff = targetAngle - ship.rotation;
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                        ship.rotation += Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), ship.turnRate * dt);

                        if (Math.abs(angleDiff) < 0.2) {
                            ship.velocity.x += Math.cos(ship.rotation) * ship.speed * dt;
                            ship.velocity.y += Math.sin(ship.rotation) * ship.speed * dt;
                        }

                        // Shoot at player
                        if (dist < 400 && Math.abs(angleDiff) < 0.3) {
                            ship.weaponCooldowns.forEach((cooldown, widx) => {
                                if (cooldown <= 0) {
                                    fireWeapon(ship, widx, true);
                                    ship.weaponCooldowns[widx] = ship.weapons[widx].cooldown;
                                }
                            });
                        }
                    }
                } else if (ship.ai === 'trader') {
                    // Fly toward nearest station
                    if (PLAYER.location.stations.length > 0) {
                        const station = PLAYER.location.stations[0];
                        const dx = station.x - ship.position.x;
                        const dy = station.y - ship.position.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist > 50) {
                            const targetAngle = Math.atan2(dy, dx);
                            ship.rotation = targetAngle;
                            ship.velocity.x += Math.cos(ship.rotation) * ship.speed * dt * 0.5;
                            ship.velocity.y += Math.sin(ship.rotation) * ship.speed * dt * 0.5;
                        }
                    }
                } else if (ship.ai === 'military' && ship.scanPlayer) {
                    // Scan player for contraband
                    const dx = PLAYER.position.x - ship.position.x;
                    const dy = PLAYER.position.y - ship.position.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 300 && PLAYER.inventory.contraband > 0) {
                        ship.hostile = true;
                        ship.scanPlayer = false;
                        showNotification('MILITARY SCAN: CONTRABAND DETECTED! PREPARE FOR COMBAT!');
                        changeReputation('Military Authority', -20);
                    }
                }

                // Update weapon cooldowns
                ship.weaponCooldowns = ship.weaponCooldowns.map(c => Math.max(0, c - dt));

                // Update position
                ship.position.x += ship.velocity.x * dt;
                ship.position.y += ship.velocity.y * dt;
                ship.velocity.x *= 0.98;
                ship.velocity.y *= 0.98;

                // Check if destroyed
                if (ship.hull <= 0) {
                    createExplosion(ship.position.x, ship.position.y, 50);
                    if (ship.hostile) {
                        PLAYER.stats.killCount++;
                        PLAYER.credits += ship.bounty || 0;
                        PLAYER.xp += 50;
                        showNotification(`Enemy destroyed! +${ship.bounty || 0} credits`);
                        changeReputation(ship.faction, -5);

                        // Drop loot
                        if (Math.random() > 0.5) {
                            const loot = randomChoice(COMMODITIES);
                            const amount = randomInt(1, 5);
                            PLAYER.inventory[loot.id] = (PLAYER.inventory[loot.id] || 0) + amount;
                            showNotification(`Salvaged ${amount}x ${loot.name}`);
                        }
                    }
                    NPC_SHIPS.splice(idx, 1);
                }
            });
        }

        // ===== COMBAT SYSTEM =====
        function fireWeapon(ship, weaponIdx, isNPC = false) {
            const weapon = ship.weapons[weaponIdx];

            if (ship.weaponCooldowns[weaponIdx] > 0) return;
            if (ship.ammo[weaponIdx] <= 0) return;

            if (weapon.ammo !== undefined) {
                ship.ammo[weaponIdx]--;
            }

            ship.weaponCooldowns[weaponIdx] = weapon.cooldown;

            const projectile = {
                x: ship.position.x,
                y: ship.position.y,
                vx: Math.cos(ship.rotation) * 500,
                vy: Math.sin(ship.rotation) * 500,
                rotation: ship.rotation,
                damage: weapon.damage,
                type: weapon.type,
                owner: isNPC ? 'npc' : 'player',
                lifetime: 3
            };

            GAME.particles.push({
                type: 'projectile',
                data: projectile
            });

            // Play sound effect (visual feedback)
            createMuzzleFlash(ship.position.x + Math.cos(ship.rotation) * 30,
                             ship.position.y + Math.sin(ship.rotation) * 30);
        }

        function updateProjectiles(dt) {
            GAME.particles = GAME.particles.filter(p => {
                if (p.type !== 'projectile') return true;

                const proj = p.data;
                proj.x += proj.vx * dt;
                proj.y += proj.vy * dt;
                proj.lifetime -= dt;

                if (proj.lifetime <= 0) return false;

                // Check collision with player
                if (proj.owner === 'npc') {
                    const dist = distance(proj.x, proj.y, PLAYER.position.x, PLAYER.position.y);
                    if (dist < 30) {
                        damagePlayer(proj.damage);
                        createImpact(proj.x, proj.y);
                        return false;
                    }
                }

                // Check collision with NPCs
                if (proj.owner === 'player') {
                    for (let ship of NPC_SHIPS) {
                        const dist = distance(proj.x, proj.y, ship.position.x, ship.position.y);
                        if (dist < 30) {
                            damageShip(ship, proj.damage);
                            createImpact(proj.x, proj.y);
                            PLAYER.stats.damageDealt += proj.damage;
                            return false;
                        }
                    }
                }

                return true;
            });
        }

        function damagePlayer(amount) {
            if (PLAYER.ship.shields > 0) {
                PLAYER.ship.shields -= amount;
                if (PLAYER.ship.shields < 0) {
                    PLAYER.ship.hull += PLAYER.ship.shields;
                    PLAYER.ship.shields = 0;
                }
            } else {
                PLAYER.ship.hull -= amount;
            }

            PLAYER.stats.damageTaken += amount;

            if (PLAYER.ship.hull <= 0) {
                PLAYER.ship.hull = 0;
                gameOver();
            }
        }

        function damageShip(ship, amount) {
            if (ship.shields > 0) {
                ship.shields -= amount;
                if (ship.shields < 0) {
                    ship.hull += ship.shields;
                    ship.shields = 0;
                }
            } else {
                ship.hull -= amount;
            }
        }

        // ===== PARTICLE EFFECTS =====
        function createExplosion(x, y, size) {
            for (let i = 0; i < size; i++) {
                GAME.particles.push({
                    type: 'explosion',
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 200,
                    vy: (Math.random() - 0.5) * 200,
                    life: 1,
                    maxLife: 1,
                    size: Math.random() * 5 + 2,
                    color: randomChoice(['#ff0', '#f80', '#f00', '#fff'])
                });
            }
        }

        function createMuzzleFlash(x, y) {
            for (let i = 0; i < 5; i++) {
                GAME.particles.push({
                    type: 'flash',
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 50,
                    vy: (Math.random() - 0.5) * 50,
                    life: 0.2,
                    maxLife: 0.2,
                    size: Math.random() * 3 + 1,
                    color: '#0ff'
                });
            }
        }

        function createImpact(x, y) {
            for (let i = 0; i < 10; i++) {
                GAME.particles.push({
                    type: 'impact',
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 100,
                    vy: (Math.random() - 0.5) * 100,
                    life: 0.5,
                    maxLife: 0.5,
                    size: Math.random() * 4 + 1,
                    color: '#f90'
                });
            }
        }

        function createThrustParticles(x, y, rotation) {
            const angle = rotation + Math.PI;
            for (let i = 0; i < 2; i++) {
                GAME.particles.push({
                    type: 'thrust',
                    x: x + Math.cos(angle) * 20,
                    y: y + Math.sin(angle) * 20,
                    vx: Math.cos(angle) * 100 + (Math.random() - 0.5) * 50,
                    vy: Math.sin(angle) * 100 + (Math.random() - 0.5) * 50,
                    life: 0.3,
                    maxLife: 0.3,
                    size: Math.random() * 3 + 1,
                    color: randomChoice(['#ff0', '#f80', '#f00'])
                });
            }
        }

        function updateParticles(dt) {
            GAME.particles = GAME.particles.filter(p => {
                if (p.type === 'projectile') return true;

                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.life -= dt;

                return p.life > 0;
            });
        }

        // ===== REPUTATION SYSTEM =====
        function changeReputation(faction, amount) {
            PLAYER.reputation[faction] = clamp((PLAYER.reputation[faction] || 0) + amount, -100, 100);
        }

        function getReputationStatus(faction) {
            const rep = PLAYER.reputation[faction] || 0;
            if (rep >= 75) return 'Exalted';
            if (rep >= 50) return 'Honored';
            if (rep >= 25) return 'Friendly';
            if (rep >= 0) return 'Neutral';
            if (rep >= -25) return 'Unfriendly';
            if (rep >= -50) return 'Hostile';
            return 'Hated';
        }

        // ===== MISSION SYSTEM =====
        function generateMission(station) {
            const types = ['delivery', 'bounty', 'exploration', 'smuggling', 'escort', 'mining'];
            const type = randomChoice(types);
            const difficulty = randomChoice(['easy', 'medium', 'hard', 'extreme']);
            const difficultyMult = { easy: 1, medium: 2, hard: 4, extreme: 8 };

            const mission = {
                id: Date.now() + Math.random(),
                type: type,
                difficulty: difficulty,
                station: station.name,
                system: PLAYER.location.name,
                reward: randomInt(500, 5000) * difficultyMult[difficulty],
                reputation: randomInt(5, 20),
                timeLimit: null,
                progress: {},
                active: false
            };

            switch (type) {
                case 'delivery':
                    const targetSystem = randomChoice(GALAXY.systems.filter(s => s.id !== PLAYER.location.id && s.discovered));
                    const targetStation = randomChoice(targetSystem.stations);
                    const commodity = randomChoice(COMMODITIES);
                    mission.description = `Deliver ${randomInt(5, 20)} units of ${commodity.name} to ${targetStation.name} in ${targetSystem.name}`;
                    mission.target = { system: targetSystem, station: targetStation, commodity: commodity.id, amount: randomInt(5, 20) };
                    mission.timeLimit = randomInt(300, 600);
                    break;

                case 'bounty':
                    mission.description = `Eliminate ${randomInt(3, 8)} pirate ships in this system`;
                    mission.target = { kills: randomInt(3, 8), current: 0 };
                    break;

                case 'exploration':
                    const unexplored = GALAXY.systems.filter(s => !s.discovered);
                    if (unexplored.length > 0) {
                        const exploreTarget = randomChoice(unexplored);
                        mission.description = `Explore and scan ${exploreTarget.name}`;
                        mission.target = { system: exploreTarget };
                    } else {
                        mission.description = 'Scan 5 asteroid fields';
                        mission.target = { scans: 5, current: 0 };
                    }
                    break;

                case 'smuggling':
                    const smuggleTarget = randomChoice(GALAXY.systems.filter(s => s.id !== PLAYER.location.id && s.discovered));
                    const smuggleStation = randomChoice(smuggleTarget.stations);
                    mission.description = `Smuggle ${randomInt(10, 30)} units of Contraband to ${smuggleStation.name} in ${smuggleTarget.name}`;
                    mission.target = { system: smuggleTarget, station: smuggleStation, amount: randomInt(10, 30) };
                    mission.timeLimit = randomInt(400, 700);
                    break;

                case 'escort':
                    const escortTarget = randomChoice(GALAXY.systems.filter(s => s.id !== PLAYER.location.id && s.discovered));
                    mission.description = `Escort trade vessel to ${escortTarget.name}`;
                    mission.target = { system: escortTarget };
                    break;

                case 'mining':
                    mission.description = `Mine ${randomInt(20, 50)} units of Ore from asteroid belts`;
                    mission.target = { ore: randomInt(20, 50), current: 0 };
                    break;
            }

            return mission;
        }

        function checkMissionProgress() {
            PLAYER.missions.forEach(mission => {
                if (!mission.active) return;

                if (mission.timeLimit !== null) {
                    mission.timeLimit -= 1/60;
                    if (mission.timeLimit <= 0) {
                        showNotification(`Mission "${mission.description}" FAILED - Time expired`);
                        PLAYER.missions = PLAYER.missions.filter(m => m.id !== mission.id);
                        return;
                    }
                }

                // Check completion conditions
                let completed = false;

                if (mission.type === 'bounty' && mission.target.current >= mission.target.kills) {
                    completed = true;
                }

                if (completed) {
                    PLAYER.credits += mission.reward;
                    PLAYER.xp += mission.reward / 10;
                    changeReputation(PLAYER.location.faction, mission.reputation);
                    PLAYER.completedMissions++;
                    showNotification(`Mission completed! +${mission.reward} credits`);
                    PLAYER.missions = PLAYER.missions.filter(m => m.id !== mission.id);
                }
            });
        }

        // ===== XP & LEVELING =====
        function checkLevelUp() {
            const xpNeeded = PLAYER.level * 1000;
            if (PLAYER.xp >= xpNeeded) {
                PLAYER.level++;
                PLAYER.xp -= xpNeeded;
                showNotification(`LEVEL UP! You are now level ${PLAYER.level}`);
            }
        }

        // ===== UI SYSTEM =====
        function showModal(content, title = '') {
            clearModal();

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.innerHTML = `
                ${title ? `<h2>${title}</h2>` : ''}
                ${content}
            `;

            document.getElementById('uiOverlay').appendChild(modal);
            GAME.currentModal = modal;
        }

        function clearModal() {
            if (GAME.currentModal) {
                GAME.currentModal.remove();
                GAME.currentModal = null;
            }
        }

        function updateHUD() {
            const overlay = document.getElementById('uiOverlay');
            overlay.innerHTML = '';

            if (GAME.state === 'system') {
                // Top left - Ship status
                const hudTL = document.createElement('div');
                hudTL.className = 'hud hud-top-left';
                hudTL.innerHTML = `
                    <div><strong>${PLAYER.ship.name}</strong></div>
                    <div class="bar">
                        <div class="bar-fill bar-shields" style="width: ${(PLAYER.ship.shields / PLAYER.ship.maxShields * 100)}%"></div>
                        <div class="bar-label">SHIELDS: ${Math.floor(PLAYER.ship.shields)}/${PLAYER.ship.maxShields}</div>
                    </div>
                    <div class="bar">
                        <div class="bar-fill bar-hull" style="width: ${(PLAYER.ship.hull / PLAYER.ship.maxHull * 100)}%"></div>
                        <div class="bar-label">HULL: ${Math.floor(PLAYER.ship.hull)}/${PLAYER.ship.maxHull}</div>
                    </div>
                    <div class="bar">
                        <div class="bar-fill bar-fuel" style="width: ${(PLAYER.ship.fuel / PLAYER.ship.maxFuel * 100)}%"></div>
                        <div class="bar-label">FUEL: ${Math.floor(PLAYER.ship.fuel)}/${PLAYER.ship.maxFuel}</div>
                    </div>
                    <div style="margin-top: 10px;">Cargo: ${getCargoUsed()}/${PLAYER.ship.cargoCapacity}</div>
                `;
                overlay.appendChild(hudTL);

                // Top right - Player info
                const hudTR = document.createElement('div');
                hudTR.className = 'hud hud-top-right';
                hudTR.innerHTML = `
                    <div><strong>${PLAYER.name}</strong> - Level ${PLAYER.level}</div>
                    <div>Credits: ${formatNumber(PLAYER.credits)}</div>
                    <div>XP: ${Math.floor(PLAYER.xp)}/${PLAYER.level * 1000}</div>
                    <div style="margin-top: 10px;"><strong>${PLAYER.location.name}</strong></div>
                    <div style="font-size: 11px;">${PLAYER.location.starType} - ${PLAYER.location.faction}</div>
                `;
                overlay.appendChild(hudTR);

                // Bottom left - Controls
                const hudBL = document.createElement('div');
                hudBL.className = 'hud hud-bottom-left';
                hudBL.innerHTML = `
                    <div style="font-size: 12px;">
                        <div>W/S: Thrust/Brake</div>
                        <div>A/D: Turn</div>
                        <div>SPACE: Fire</div>
                        <div>M: Galaxy Map</div>
                        <div>T: Target</div>
                        <div>ESC: Menu</div>
                    </div>
                `;
                overlay.appendChild(hudBL);

                // Radar
                const radar = document.createElement('div');
                radar.className = 'radar';
                radar.innerHTML = '<canvas width="200" height="200"></canvas>';
                overlay.appendChild(radar);

                const radarCanvas = radar.querySelector('canvas');
                const radarCtx = radarCanvas.getContext('2d');
                radarCtx.fillStyle = 'rgba(0, 100, 0, 0.3)';
                radarCtx.fillRect(0, 0, 200, 200);

                // Draw radar grid
                radarCtx.strokeStyle = '#0f0';
                radarCtx.lineWidth = 1;
                radarCtx.beginPath();
                radarCtx.moveTo(100, 0);
                radarCtx.lineTo(100, 200);
                radarCtx.moveTo(0, 100);
                radarCtx.lineTo(200, 100);
                radarCtx.stroke();
                radarCtx.beginPath();
                radarCtx.arc(100, 100, 50, 0, Math.PI * 2);
                radarCtx.stroke();

                // Draw player (center)
                radarCtx.fillStyle = '#0ff';
                radarCtx.fillRect(98, 98, 4, 4);

                // Draw stations
                PLAYER.location.stations.forEach(station => {
                    const rx = 100 + (station.x - PLAYER.position.x) / 10;
                    const ry = 100 + (station.y - PLAYER.position.y) / 10;
                    if (rx >= 0 && rx <= 200 && ry >= 0 && ry <= 200) {
                        radarCtx.fillStyle = '#0f0';
                        radarCtx.fillRect(rx - 2, ry - 2, 4, 4);
                    }
                });

                // Draw NPCs
                NPC_SHIPS.forEach(ship => {
                    const rx = 100 + (ship.position.x - PLAYER.position.x) / 10;
                    const ry = 100 + (ship.position.y - PLAYER.position.y) / 10;
                    if (rx >= 0 && rx <= 200 && ry >= 0 && ry <= 200) {
                        radarCtx.fillStyle = ship.hostile ? '#f00' : '#ff0';
                        radarCtx.fillRect(rx - 2, ry - 2, 4, 4);
                    }
                });

                // Target info
                if (PLAYER.target) {
                    const targetInfo = document.createElement('div');
                    targetInfo.className = 'target-info';
                    targetInfo.innerHTML = `
                        <div style="color: #f90; font-size: 16px; margin-bottom: 10px;"><strong>TARGET LOCKED</strong></div>
                        <div><strong>${PLAYER.target.name}</strong></div>
                        <div>${PLAYER.target.class}</div>
                        <div style="margin-top: 10px;">
                            <div class="bar" style="width: 100%;">
                                <div class="bar-fill bar-shields" style="width: ${(PLAYER.target.shields / PLAYER.target.maxShields * 100)}%"></div>
                                <div class="bar-label">Shields</div>
                            </div>
                            <div class="bar" style="width: 100%;">
                                <div class="bar-fill bar-hull" style="width: ${(PLAYER.target.hull / PLAYER.target.maxHull * 100)}%"></div>
                                <div class="bar-label">Hull</div>
                            </div>
                        </div>
                        <div style="margin-top: 10px; font-size: 12px;">
                            Range: ${Math.floor(distance(PLAYER.position.x, PLAYER.position.y, PLAYER.target.position.x, PLAYER.target.position.y))}m
                        </div>
                    `;
                    overlay.appendChild(targetInfo);
                }
            }

            if (GAME.currentModal) {
                overlay.appendChild(GAME.currentModal);
            }

            // Notifications
            GAME.notifications.forEach((notif, idx) => {
                const elem = document.createElement('div');
                elem.className = 'notification';
                elem.style.top = `${50 + idx * 60}px`;
                elem.textContent = notif.message;
                overlay.appendChild(elem);
            });
        }

        // ===== STATION INTERFACE =====
        function dockAtStation(station) {
            GAME.state = 'station';

            const content = `
                <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                    <button class="btn btn-primary" onclick="stationMarket('${station.name}')">Market</button>
                    <button class="btn btn-primary" onclick="stationMissions('${station.name}')">Missions</button>
                    <button class="btn btn-primary" onclick="stationShipyard()">Shipyard</button>
                    <button class="btn btn-primary" onclick="stationRepairs()">Repairs & Refuel</button>
                    <button class="btn" onclick="undock()">Undock</button>
                </div>
                <div id="stationContent"></div>
            `;

            showModal(content, `${station.name} - ${station.type} Station`);
        }

        function stationMarket(stationName) {
            const station = PLAYER.location.stations.find(s => s.name === stationName);

            let rows = '';
            COMMODITIES.forEach(comm => {
                const market = station.market[comm.id];
                const owned = PLAYER.inventory[comm.id] || 0;
                rows += `
                    <tr>
                        <td>${comm.name}</td>
                        <td>${owned}</td>
                        <td>${market.stock}</td>
                        <td>${market.buyPrice}</td>
                        <td>${market.sellPrice}</td>
                        <td>
                            <input type="number" id="qty_${comm.id}" min="1" max="100" value="1" style="width: 60px;">
                            <button class="btn" onclick="buyCommodity('${comm.id}', '${stationName}')">Buy</button>
                            <button class="btn" onclick="sellCommodity('${comm.id}', '${stationName}')">Sell</button>
                        </td>
                    </tr>
                `;
            });

            document.getElementById('stationContent').innerHTML = `
                <h3>Market</h3>
                <p>Cargo: ${getCargoUsed()}/${PLAYER.ship.cargoCapacity}</p>
                <table>
                    <thead>
                        <tr>
                            <th>Commodity</th>
                            <th>Owned</th>
                            <th>Stock</th>
                            <th>Buy Price</th>
                            <th>Sell Price</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>${rows}</tbody>
                </table>
            `;
        }

        function buyCommodity(commId, stationName) {
            const station = PLAYER.location.stations.find(s => s.name === stationName);
            const qty = parseInt(document.getElementById(`qty_${commId}`).value) || 1;
            const market = station.market[commId];
            const cost = market.buyPrice * qty;

            if (PLAYER.credits < cost) {
                showNotification('Not enough credits!');
                return;
            }

            if (!canAddCargo(qty)) {
                showNotification('Not enough cargo space!');
                return;
            }

            if (market.stock < qty) {
                showNotification('Not enough stock!');
                return;
            }

            PLAYER.credits -= cost;
            PLAYER.inventory[commId] = (PLAYER.inventory[commId] || 0) + qty;
            market.stock -= qty;
            PLAYER.stats.tradesMade++;

            showNotification(`Bought ${qty}x ${COMMODITIES.find(c => c.id === commId).name} for ${cost} credits`);
            stationMarket(stationName);
        }

        function sellCommodity(commId, stationName) {
            const station = PLAYER.location.stations.find(s => s.name === stationName);
            const qty = parseInt(document.getElementById(`qty_${commId}`).value) || 1;
            const market = station.market[commId];
            const owned = PLAYER.inventory[commId] || 0;

            if (owned < qty) {
                showNotification('Not enough to sell!');
                return;
            }

            const revenue = market.sellPrice * qty;
            PLAYER.credits += revenue;
            PLAYER.inventory[commId] -= qty;
            market.stock += qty;
            PLAYER.stats.tradesMade++;

            showNotification(`Sold ${qty}x ${COMMODITIES.find(c => c.id === commId).name} for ${revenue} credits`);
            stationMarket(stationName);
        }

        function stationMissions(stationName) {
            const station = PLAYER.location.stations.find(s => s.name === stationName);
            const availableMissions = [];

            for (let i = 0; i < 5; i++) {
                availableMissions.push(generateMission(station));
            }

            let missionCards = '';
            availableMissions.forEach(mission => {
                missionCards += `
                    <div class="card">
                        <h4>${mission.type.toUpperCase()} <span class="mission-badge mission-${mission.difficulty}">${mission.difficulty}</span></h4>
                        <p>${mission.description}</p>
                        <p><strong>Reward:</strong> ${mission.reward} credits | +${mission.reputation} rep</p>
                        ${mission.timeLimit ? `<p><strong>Time Limit:</strong> ${Math.floor(mission.timeLimit)}s</p>` : ''}
                        <button class="btn btn-primary" onclick="acceptMission(${JSON.stringify(mission).replace(/"/g, '&quot;')})">Accept Mission</button>
                    </div>
                `;
            });

            let activeMissions = '';
            if (PLAYER.missions.length > 0) {
                activeMissions = '<h3>Active Missions</h3>';
                PLAYER.missions.forEach(mission => {
                    activeMissions += `
                        <div class="card">
                            <h4>${mission.type.toUpperCase()}</h4>
                            <p>${mission.description}</p>
                            ${mission.timeLimit ? `<p>Time Remaining: ${Math.floor(mission.timeLimit)}s</p>` : ''}
                            <button class="btn btn-danger" onclick="abandonMission('${mission.id}')">Abandon</button>
                        </div>
                    `;
                });
            }

            document.getElementById('stationContent').innerHTML = `
                <h3>Available Missions</h3>
                <div class="grid">${missionCards}</div>
                ${activeMissions}
            `;
        }

        function acceptMission(mission) {
            PLAYER.missions.push({...mission, active: true});
            showNotification('Mission accepted!');
            stationMissions(mission.station);
        }

        function abandonMission(missionId) {
            PLAYER.missions = PLAYER.missions.filter(m => m.id != missionId);
            showNotification('Mission abandoned');
            stationMissions(PLAYER.location.stations[0].name);
        }

        function stationShipyard() {
            let shipCards = '';
            Object.entries(SHIP_TEMPLATES).forEach(([key, template]) => {
                const canBuy = PLAYER.credits >= template.cost && key !== 'scout';
                shipCards += `
                    <div class="card ${PLAYER.ship.class === template.class ? 'selected' : ''}">
                        <h4>${template.name}</h4>
                        <p><strong>Class:</strong> ${template.class}</p>
                        <p><strong>Cost:</strong> ${formatNumber(template.cost)} credits</p>
                        <p>Hull: ${template.maxHull} | Shields: ${template.maxShields}</p>
                        <p>Cargo: ${template.cargoCapacity} | Speed: ${template.speed}</p>
                        <p>Weapons: ${template.weapons.length}</p>
                        <button class="btn btn-primary" ${!canBuy || PLAYER.ship.class === template.class ? 'disabled' : ''}
                                onclick="buyShip('${key}')">
                            ${PLAYER.ship.class === template.class ? 'Current Ship' : 'Purchase'}
                        </button>
                    </div>
                `;
            });

            document.getElementById('stationContent').innerHTML = `
                <h3>Shipyard</h3>
                <p>Current Ship: ${PLAYER.ship.name} (${PLAYER.ship.class})</p>
                <p>Your Credits: ${formatNumber(PLAYER.credits)}</p>
                <div class="grid">${shipCards}</div>
            `;
        }

        function buyShip(shipKey) {
            const template = SHIP_TEMPLATES[shipKey];

            if (PLAYER.credits < template.cost) {
                showNotification('Not enough credits!');
                return;
            }

            // Sell current ship for 50% value
            const currentValue = PLAYER.ship.cost * 0.5;
            PLAYER.credits -= template.cost;
            PLAYER.credits += currentValue;

            PLAYER.ship = createShip(template);
            showNotification(`Purchased ${template.name}!`);
            stationShipyard();
        }

        function stationRepairs() {
            const hullDamage = PLAYER.ship.maxHull - PLAYER.ship.hull;
            const repairCost = Math.floor(hullDamage * 10);
            const refuelCost = Math.floor((PLAYER.ship.maxFuel - PLAYER.ship.fuel) * 5);

            document.getElementById('stationContent').innerHTML = `
                <h3>Repairs & Refuel</h3>
                <p>Hull Damage: ${Math.floor(hullDamage)} (Repair Cost: ${repairCost} credits)</p>
                <p>Fuel Needed: ${Math.floor(PLAYER.ship.maxFuel - PLAYER.ship.fuel)} (Refuel Cost: ${refuelCost} credits)</p>
                <button class="btn btn-primary" ${PLAYER.credits < repairCost || hullDamage === 0 ? 'disabled' : ''}
                        onclick="repairShip()">Repair Hull</button>
                <button class="btn btn-primary" ${PLAYER.credits < refuelCost || PLAYER.ship.fuel === PLAYER.ship.maxFuel ? 'disabled' : ''}
                        onclick="refuelShip()">Refuel</button>
            `;
        }

        function repairShip() {
            const hullDamage = PLAYER.ship.maxHull - PLAYER.ship.hull;
            const repairCost = Math.floor(hullDamage * 10);

            if (PLAYER.credits >= repairCost) {
                PLAYER.credits -= repairCost;
                PLAYER.ship.hull = PLAYER.ship.maxHull;
                showNotification('Ship repaired!');
                stationRepairs();
            }
        }

        function refuelShip() {
            const refuelCost = Math.floor((PLAYER.ship.maxFuel - PLAYER.ship.fuel) * 5);

            if (PLAYER.credits >= refuelCost) {
                PLAYER.credits -= refuelCost;
                PLAYER.ship.fuel = PLAYER.ship.maxFuel;
                showNotification('Ship refueled!');
                stationRepairs();
            }
        }

        function undock() {
            GAME.state = 'system';
            clearModal();
        }

        // ===== GALAXY MAP =====
        function showGalaxyMap() {
            GAME.state = 'galaxy';
            GAME.camera = { x: -PLAYER.location.x + GAME.width / 2, y: -PLAYER.location.y + GAME.height / 2, zoom: 1 };
        }

        function closeGalaxyMap() {
            GAME.state = 'system';
            GAME.camera = { x: 0, y: 0, zoom: 1 };
        }

        function selectSystem(systemId) {
            const system = GALAXY.systems[systemId];

            if (!system.discovered) {
                showNotification('System not yet discovered!');
                return;
            }

            const canJump = PLAYER.location.connections.includes(systemId);

            const content = `
                <h3>${system.name}</h3>
                <p><strong>Type:</strong> ${system.starType}</p>
                <p><strong>Faction:</strong> ${system.faction}</p>
                <p><strong>Planets:</strong> ${system.planets.length}</p>
                <p><strong>Stations:</strong> ${system.stations.length}</p>
                <p><strong>Distance:</strong> ${Math.floor(distance(PLAYER.location.x, PLAYER.location.y, system.x, system.y))} ly</p>
                <div style="margin-top: 20px;">
                    <button class="btn btn-primary" ${!canJump ? 'disabled' : ''} onclick="jumpToSystem(${systemId})">
                        ${canJump ? 'Jump to System' : 'No Hyperspace Lane'}
                    </button>
                    <button class="btn" onclick="clearModal()">Cancel</button>
                </div>
            `;

            showModal(content, 'System Information');
        }

        function jumpToSystem(systemId) {
            const system = GALAXY.systems[systemId];
            const fuelCost = 20;

            if (PLAYER.ship.fuel < fuelCost) {
                showNotification('Not enough fuel!');
                return;
            }

            PLAYER.ship.fuel -= fuelCost;
            PLAYER.location = system;
            PLAYER.position = { x: 0, y: 0 };
            PLAYER.velocity = { x: 0, y: 0 };

            if (!system.discovered) {
                system.discovered = true;
                PLAYER.xp += 100;
                showNotification(`Discovered ${system.name}! +100 XP`);
                if (!PLAYER.stats.systemsVisited.includes(system.id)) {
                    PLAYER.stats.systemsVisited.push(system.id);
                }
            }

            // Spawn NPCs in new system
            NPC_SHIPS.length = 0;
            const pirateChance = PLAYER.location.faction === 'Pirate Clans' ? 0.7 : 0.3;
            if (Math.random() < pirateChance) {
                const pirateCount = randomInt(1, 3);
                for (let i = 0; i < pirateCount; i++) {
                    spawnNPCShip('pirate', random(-500, 500), random(-500, 500));
                }
            }

            if (Math.random() > 0.7) {
                spawnNPCShip('trader', random(-400, 400), random(-400, 400));
            }

            if (PLAYER.location.faction === 'Military Authority' && Math.random() > 0.5) {
                spawnNPCShip('military', random(-300, 300), random(-300, 300));
            }

            closeGalaxyMap();
            clearModal();

            // Hyperspace effect
            createHyperspaceEffect();
        }

        function createHyperspaceEffect() {
            for (let i = 0; i < 100; i++) {
                GAME.particles.push({
                    type: 'hyperspace',
                    x: PLAYER.position.x + (Math.random() - 0.5) * GAME.width,
                    y: PLAYER.position.y + (Math.random() - 0.5) * GAME.height,
                    vx: (Math.random() - 0.5) * 500,
                    vy: (Math.random() - 0.5) * 500,
                    life: 2,
                    maxLife: 2,
                    size: Math.random() * 3 + 1,
                    color: '#0ff'
                });
            }
        }

        // ===== MAIN MENU =====
        function showMainMenu() {
            GAME.state = 'menu';

            const hasSave = localStorage.getItem('starfield_save') !== null;

            const content = `
                <div style="text-align: center;">
                    <h1 style="font-size: 48px; color: #0ff; margin-bottom: 30px;">STARFIELD TRADERS</h1>
                    <p style="font-size: 18px; margin-bottom: 40px;">Elite Space Trading & Combat Simulation</p>
                    <button class="btn btn-primary" style="font-size: 20px; padding: 15px 40px;" onclick="newGame()">New Game</button>
                    <button class="btn btn-primary" style="font-size: 20px; padding: 15px 40px;" ${!hasSave ? 'disabled' : ''} onclick="loadGame()">Load Game</button>
                    <div style="margin-top: 60px; font-size: 14px; color: #0f0;">
                        <p>Controls:</p>
                        <p>W/S - Thrust/Brake | A/D - Turn | SPACE - Fire</p>
                        <p>M - Galaxy Map | T - Target | ESC - Menu</p>
                    </div>
                </div>
            `;

            showModal(content, '');
        }

        function newGame() {
            PLAYER.name = 'Commander';
            PLAYER.level = 1;
            PLAYER.xp = 0;
            PLAYER.credits = 1000;
            PLAYER.ship = createShip(SHIP_TEMPLATES.scout);
            PLAYER.inventory = {};
            PLAYER.missions = [];
            PLAYER.completedMissions = 0;
            PLAYER.reputation = {
                'Trade Federation': 0,
                'Military Authority': 0,
                'Pirate Clans': -50,
                'Free Systems': 10
            };
            PLAYER.stats = {
                systemsVisited: [0],
                killCount: 0,
                tradesMade: 0,
                distanceTraveled: 0,
                damageDealt: 0,
                damageTaken: 0
            };

            generateGalaxy();
            GAME.state = 'system';
            clearModal();

            // Spawn initial NPCs
            spawnNPCShip('trader', 300, 200);

            showNotification('Welcome to Starfield Traders, Commander!');
        }

        function loadGame() {
            const save = localStorage.getItem('starfield_save');
            if (save) {
                const data = JSON.parse(save);
                Object.assign(PLAYER, data.player);
                Object.assign(GALAXY, data.galaxy);
                GAME.state = 'system';
                clearModal();
                showNotification('Game loaded successfully!');
            }
        }

        function saveGame() {
            const data = {
                player: PLAYER,
                galaxy: GALAXY,
                timestamp: Date.now()
            };
            localStorage.setItem('starfield_save', JSON.stringify(data));
            showNotification('Game saved!');
        }

        function showPauseMenu() {
            const content = `
                <div style="text-align: center;">
                    <h2>PAUSED</h2>
                    <button class="btn btn-primary" onclick="resumeGame()">Resume</button>
                    <button class="btn btn-primary" onclick="showPlayerStats()">Statistics</button>
                    <button class="btn btn-primary" onclick="showReputation()">Reputation</button>
                    <button class="btn btn-primary" onclick="saveGame()">Save Game</button>
                    <button class="btn btn-danger" onclick="showMainMenu()">Main Menu</button>
                </div>
            `;
            showModal(content, 'Game Menu');
        }

        function resumeGame() {
            clearModal();
        }

        function showPlayerStats() {
            const content = `
                <h3>Player Statistics</h3>
                <table>
                    <tr><td>Level</td><td>${PLAYER.level}</td></tr>
                    <tr><td>Experience</td><td>${Math.floor(PLAYER.xp)} / ${PLAYER.level * 1000}</td></tr>
                    <tr><td>Credits</td><td>${formatNumber(PLAYER.credits)}</td></tr>
                    <tr><td>Systems Visited</td><td>${PLAYER.stats.systemsVisited.length}</td></tr>
                    <tr><td>Enemies Destroyed</td><td>${PLAYER.stats.killCount}</td></tr>
                    <tr><td>Trades Completed</td><td>${PLAYER.stats.tradesMade}</td></tr>
                    <tr><td>Missions Completed</td><td>${PLAYER.completedMissions}</td></tr>
                    <tr><td>Damage Dealt</td><td>${formatNumber(Math.floor(PLAYER.stats.damageDealt))}</td></tr>
                    <tr><td>Damage Taken</td><td>${formatNumber(Math.floor(PLAYER.stats.damageTaken))}</td></tr>
                </table>
                <button class="btn" onclick="showPauseMenu()">Back</button>
            `;
            showModal(content, 'Statistics');
        }

        function showReputation() {
            let factionRows = '';
            Object.entries(PLAYER.reputation).forEach(([faction, rep]) => {
                const status = getReputationStatus(faction);
                const percent = ((rep + 100) / 200) * 100;
                factionRows += `
                    <div class="faction-rep">
                        <div style="width: 150px;">${faction}</div>
                        <div class="faction-rep-bar">
                            <div class="faction-rep-fill" style="width: ${percent}%"></div>
                        </div>
                        <div style="width: 100px; text-align: right;">${status} (${rep})</div>
                    </div>
                `;
            });

            const content = `
                <h3>Faction Reputation</h3>
                <div>${factionRows}</div>
                <button class="btn" onclick="showPauseMenu()">Back</button>
            `;
            showModal(content, 'Reputation');
        }

        function gameOver() {
            const content = `
                <div style="text-align: center;">
                    <h1 style="color: #f00; font-size: 48px;">SHIP DESTROYED</h1>
                    <p style="font-size: 24px; margin: 30px 0;">You have been defeated in combat</p>
                    <div style="margin: 30px 0;">
                        <p>Final Level: ${PLAYER.level}</p>
                        <p>Credits Earned: ${formatNumber(PLAYER.credits)}</p>
                        <p>Enemies Destroyed: ${PLAYER.stats.killCount}</p>
                        <p>Systems Visited: ${PLAYER.stats.systemsVisited.length}</p>
                    </div>
                    <button class="btn btn-primary" onclick="showMainMenu()">Main Menu</button>
                </div>
            `;
            showModal(content, '');
        }

        // ===== RENDERING =====
        function render() {
            const ctx = GAME.ctx;
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, GAME.width, GAME.height);

            if (GAME.state === 'galaxy') {
                renderGalaxyMap();
            } else if (GAME.state === 'system') {
                renderSystemView();
            }

            updateHUD();
        }

        function renderGalaxyMap() {
            const ctx = GAME.ctx;

            // Draw starfield background
            ctx.fillStyle = '#fff';
            for (let i = 0; i < 200; i++) {
                const x = (i * 123.456) % GAME.width;
                const y = (i * 789.012) % GAME.height;
                ctx.fillRect(x, y, 1, 1);
            }

            ctx.save();
            ctx.translate(GAME.camera.x, GAME.camera.y);
            ctx.scale(GAME.camera.zoom, GAME.camera.zoom);

            // Draw connections
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.3)';
            ctx.lineWidth = 2;
            GALAXY.systems.forEach(system => {
                if (!system.discovered) return;
                system.connections.forEach(connId => {
                    const target = GALAXY.systems[connId];
                    if (!target.discovered) return;
                    ctx.beginPath();
                    ctx.moveTo(system.x, system.y);
                    ctx.lineTo(target.x, target.y);
                    ctx.stroke();
                });
            });

            // Draw systems
            GALAXY.systems.forEach(system => {
                if (!system.discovered) {
                    ctx.fillStyle = '#333';
                    ctx.beginPath();
                    ctx.arc(system.x, system.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                    return;
                }

                // Faction color ring
                const factionColors = {
                    'Trade Federation': '#0f0',
                    'Military Authority': '#00f',
                    'Pirate Clans': '#f00',
                    'Free Systems': '#ff0'
                };
                ctx.strokeStyle = factionColors[system.faction];
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(system.x, system.y, 15, 0, Math.PI * 2);
                ctx.stroke();

                // Star
                ctx.fillStyle = system.starColor;
                ctx.beginPath();
                ctx.arc(system.x, system.y, 10 * system.starSize, 0, Math.PI * 2);
                ctx.fill();

                // Name
                ctx.fillStyle = '#0f0';
                ctx.font = '14px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(system.name, system.x, system.y - 25);

                // Current location marker
                if (system.id === PLAYER.location.id) {
                    ctx.strokeStyle = '#0ff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(system.x, system.y, 20, 0, Math.PI * 2);
                    ctx.stroke();
                }
            });

            ctx.restore();

            // Instructions
            ctx.fillStyle = '#0f0';
            ctx.font = '16px Courier New';
            ctx.textAlign = 'left';
            ctx.fillText('Click system to view details | ESC to close', 10, 30);
            ctx.fillText('Drag to pan | Scroll to zoom', 10, 50);
        }

        function renderSystemView() {
            const ctx = GAME.ctx;

            // Draw parallax starfield
            ctx.fillStyle = '#fff';
            for (let i = 0; i < 300; i++) {
                const x = ((i * 123.456) % GAME.width - PLAYER.position.x * 0.1) % GAME.width;
                const y = ((i * 789.012) % GAME.height - PLAYER.position.y * 0.1) % GAME.height;
                const size = (i % 3) + 1;
                ctx.fillRect(x, y, size, size);
            }

            // Draw nebula effect
            const gradient = ctx.createRadialGradient(GAME.width / 2, GAME.height / 2, 100, GAME.width / 2, GAME.height / 2, 800);
            gradient.addColorStop(0, 'rgba(100, 0, 150, 0.1)');
            gradient.addColorStop(1, 'rgba(0, 0, 50, 0.3)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, GAME.width, GAME.height);

            ctx.save();
            ctx.translate(GAME.width / 2, GAME.height / 2);

            // Draw star at center
            ctx.fillStyle = PLAYER.location.starColor;
            ctx.shadowBlur = 30;
            ctx.shadowColor = PLAYER.location.starColor;
            ctx.beginPath();
            ctx.arc(-PLAYER.position.x, -PLAYER.position.y, 50 * PLAYER.location.starSize, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Draw planets
            PLAYER.location.planets.forEach(planet => {
                planet.angle += planet.rotationSpeed;
                const px = Math.cos(planet.angle) * planet.distance - PLAYER.position.x;
                const py = Math.sin(planet.angle) * planet.distance - PLAYER.position.y;

                // Orbit path
                ctx.strokeStyle = 'rgba(100, 100, 100, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(-PLAYER.position.x, -PLAYER.position.y, planet.distance, 0, Math.PI * 2);
                ctx.stroke();

                // Planet
                ctx.fillStyle = planet.color;
                ctx.beginPath();
                ctx.arc(px, py, planet.size, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw asteroid belts
            PLAYER.location.asteroidBelts.forEach(belt => {
                for (let i = 0; i < belt.count; i++) {
                    const angle = (i / belt.count) * Math.PI * 2;
                    const distance = belt.distance + (Math.sin(i) * 50);
                    const ax = Math.cos(angle) * distance - PLAYER.position.x;
                    const ay = Math.sin(angle) * distance - PLAYER.position.y;

                    ctx.fillStyle = '#888';
                    const size = Math.random() * 3 + 1;
                    ctx.fillRect(ax, ay, size, size);
                }
            });

            // Draw stations
            PLAYER.location.stations.forEach(station => {
                const sx = station.x - PLAYER.position.x;
                const sy = station.y - PLAYER.position.y;

                // Station structure
                ctx.strokeStyle = '#0f0';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(sx, sy, 20, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(sx - 25, sy);
                ctx.lineTo(sx + 25, sy);
                ctx.moveTo(sx, sy - 25);
                ctx.lineTo(sx, sy + 25);
                ctx.stroke();

                // Name
                ctx.fillStyle = '#0f0';
                ctx.font = '12px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(station.name, sx, sy - 30);

                // Docking range indicator if close
                const dist = distance(PLAYER.position.x, PLAYER.position.y, station.x, station.y);
                if (dist < 100) {
                    ctx.strokeStyle = '#0ff';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(sx, sy, 50, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    ctx.fillStyle = '#0ff';
                    ctx.font = '14px Courier New';
                    ctx.fillText('Press E to Dock', sx, sy + 70);
                }
            });

            // Draw NPCs
            NPC_SHIPS.forEach(ship => {
                const sx = ship.position.x - PLAYER.position.x;
                const sy = ship.position.y - PLAYER.position.y;

                ctx.save();
                ctx.translate(sx, sy);
                ctx.rotate(ship.rotation);

                // Ship body
                ctx.fillStyle = ship.hostile ? '#f00' : '#ff0';
                ctx.beginPath();
                ctx.moveTo(20, 0);
                ctx.lineTo(-15, -10);
                ctx.lineTo(-10, 0);
                ctx.lineTo(-15, 10);
                ctx.closePath();
                ctx.fill();

                // Shield indicator
                if (ship.shields > 0) {
                    ctx.strokeStyle = 'rgba(0, 150, 255, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, 25, 0, Math.PI * 2);
                    ctx.stroke();
                }

                ctx.restore();

                // Target indicator
                if (PLAYER.target === ship) {
                    ctx.strokeStyle = '#f90';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(sx, sy, 35, 0, Math.PI * 2);
                    ctx.stroke();

                    // Targeting brackets
                    ctx.beginPath();
                    ctx.moveTo(sx - 40, sy - 40);
                    ctx.lineTo(sx - 30, sy - 40);
                    ctx.lineTo(sx - 40, sy - 30);
                    ctx.moveTo(sx + 40, sy - 40);
                    ctx.lineTo(sx + 30, sy - 40);
                    ctx.lineTo(sx + 40, sy - 30);
                    ctx.moveTo(sx - 40, sy + 40);
                    ctx.lineTo(sx - 30, sy + 40);
                    ctx.lineTo(sx - 40, sy + 30);
                    ctx.moveTo(sx + 40, sy + 40);
                    ctx.lineTo(sx + 30, sy + 40);
                    ctx.lineTo(sx + 40, sy + 30);
                    ctx.stroke();
                }
            });

            // Draw particles
            GAME.particles.forEach(p => {
                if (p.type === 'projectile') {
                    const proj = p.data;
                    const px = proj.x - PLAYER.position.x;
                    const py = proj.y - PLAYER.position.y;

                    ctx.fillStyle = proj.type === 'laser' ? '#0ff' : proj.type === 'missile' ? '#f00' : '#f0f';
                    ctx.beginPath();
                    ctx.arc(px, py, 3, 0, Math.PI * 2);
                    ctx.fill();

                    // Trail
                    ctx.strokeStyle = ctx.fillStyle;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(px, py);
                    ctx.lineTo(px - Math.cos(proj.rotation) * 10, py - Math.sin(proj.rotation) * 10);
                    ctx.stroke();
                } else {
                    const px = p.x - PLAYER.position.x;
                    const py = p.y - PLAYER.position.y;
                    const alpha = p.life / p.maxLife;

                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = alpha;
                    ctx.beginPath();
                    ctx.arc(px, py, p.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
            });

            // Draw player ship
            ctx.save();
            ctx.rotate(PLAYER.rotation);

            // Thrust particles
            if (GAME.keys['w'] || GAME.keys['W']) {
                createThrustParticles(0, 0, PLAYER.rotation);
            }

            // Ship body
            ctx.fillStyle = '#0ff';
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(30, 0);
            ctx.lineTo(-20, -15);
            ctx.lineTo(-15, 0);
            ctx.lineTo(-20, 15);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Shield indicator
            if (PLAYER.ship.shields > 0) {
                ctx.strokeStyle = 'rgba(0, 150, 255, 0.7)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, 0, 30, 0, Math.PI * 2);
                ctx.stroke();
            }

            ctx.restore();
            ctx.restore();
        }

        // ===== INPUT HANDLING =====
        function handleInput(dt) {
            if (GAME.state === 'system') {
                // Movement
                if (GAME.keys['w'] || GAME.keys['W']) {
                    PLAYER.velocity.x += Math.cos(PLAYER.rotation) * PLAYER.ship.speed * dt;
                    PLAYER.velocity.y += Math.sin(PLAYER.rotation) * PLAYER.ship.speed * dt;
                }
                if (GAME.keys['s'] || GAME.keys['S']) {
                    PLAYER.velocity.x *= 0.95;
                    PLAYER.velocity.y *= 0.95;
                }
                if (GAME.keys['a'] || GAME.keys['A']) {
                    PLAYER.rotation -= PLAYER.ship.turnRate * dt;
                }
                if (GAME.keys['d'] || GAME.keys['D']) {
                    PLAYER.rotation += PLAYER.ship.turnRate * dt;
                }

                // Firing
                if (GAME.keys[' ']) {
                    PLAYER.ship.weaponCooldowns.forEach((cooldown, idx) => {
                        if (cooldown <= 0) {
                            fireWeapon(PLAYER.ship, idx, false);
                        }
                    });
                }

                // Targeting
                if (GAME.keys['t'] || GAME.keys['T']) {
                    if (!GAME.keys._tPressed) {
                        cycleTarget();
                        GAME.keys._tPressed = true;
                    }
                } else {
                    GAME.keys._tPressed = false;
                }

                // Docking
                if (GAME.keys['e'] || GAME.keys['E']) {
                    if (!GAME.keys._ePressed) {
                        PLAYER.location.stations.forEach(station => {
                            const dist = distance(PLAYER.position.x, PLAYER.position.y, station.x, station.y);
                            if (dist < 100) {
                                dockAtStation(station);
                            }
                        });
                        GAME.keys._ePressed = true;
                    }
                } else {
                    GAME.keys._ePressed = false;
                }

                // Galaxy map
                if (GAME.keys['m'] || GAME.keys['M']) {
                    if (!GAME.keys._mPressed) {
                        showGalaxyMap();
                        GAME.keys._mPressed = true;
                    }
                } else {
                    GAME.keys._mPressed = false;
                }
            }

            if (GAME.state === 'galaxy') {
                // Pan camera
                if (GAME.keys['ArrowLeft']) GAME.camera.x += 5;
                if (GAME.keys['ArrowRight']) GAME.camera.x -= 5;
                if (GAME.keys['ArrowUp']) GAME.camera.y += 5;
                if (GAME.keys['ArrowDown']) GAME.camera.y -= 5;

                // Close map
                if (GAME.keys['m'] || GAME.keys['M'] || GAME.keys['Escape']) {
                    if (!GAME.keys._mPressed) {
                        closeGalaxyMap();
                        GAME.keys._mPressed = true;
                    }
                } else {
                    GAME.keys._mPressed = false;
                }
            }

            // Pause menu
            if (GAME.keys['Escape']) {
                if (!GAME.keys._escPressed && GAME.state === 'system' && !GAME.currentModal) {
                    showPauseMenu();
                    GAME.keys._escPressed = true;
                } else if (!GAME.keys._escPressed && GAME.currentModal) {
                    clearModal();
                    GAME.keys._escPressed = true;
                }
            } else {
                GAME.keys._escPressed = false;
            }
        }

        function cycleTarget() {
            if (NPC_SHIPS.length === 0) {
                PLAYER.target = null;
                return;
            }

            const currentIdx = NPC_SHIPS.indexOf(PLAYER.target);
            const nextIdx = (currentIdx + 1) % NPC_SHIPS.length;
            PLAYER.target = NPC_SHIPS[nextIdx];
            showNotification(`Target: ${PLAYER.target.name}`);
        }

        // ===== GAME LOOP =====
        function update(dt) {
            GAME.time += dt;
            GAME.timePlayed += dt;

            if (GAME.state === 'system') {
                // Update player position
                PLAYER.position.x += PLAYER.velocity.x * dt;
                PLAYER.position.y += PLAYER.velocity.y * dt;

                // Update weapon cooldowns
                PLAYER.ship.weaponCooldowns = PLAYER.ship.weaponCooldowns.map(c => Math.max(0, c - dt));

                // Regenerate shields
                if (PLAYER.ship.shields < PLAYER.ship.maxShields) {
                    PLAYER.ship.shields = Math.min(PLAYER.ship.maxShields, PLAYER.ship.shields + 5 * dt);
                }

                // Update NPCs
                updateNPCShips(dt);

                // Update projectiles
                updateProjectiles(dt);

                // Update particles
                updateParticles(dt);

                // Check missions
                checkMissionProgress();

                // Level up check
                checkLevelUp();

                // Auto-save every 30 seconds
                if (Math.floor(GAME.time) % 30 === 0 && Math.floor(GAME.time) !== Math.floor(GAME.time - dt)) {
                    saveGame();
                }
            }

            // Update notifications
            GAME.notifications = GAME.notifications.filter(n => {
                n.life -= dt;
                return n.life > 0;
            });
        }

        function gameLoop(timestamp) {
            const dt = Math.min((timestamp - GAME.lastTime) / 1000, 0.1);
            GAME.lastTime = timestamp;

            handleInput(dt);
            update(dt);
            render();

            requestAnimationFrame(gameLoop);
        }

        // ===== INITIALIZATION =====
        function init() {
            GAME.canvas = document.getElementById('gameCanvas');
            GAME.ctx = GAME.canvas.getContext('2d');

            function resize() {
                GAME.canvas.width = window.innerWidth;
                GAME.canvas.height = window.innerHeight;
                GAME.width = GAME.canvas.width;
                GAME.height = GAME.canvas.height;
            }
            resize();
            window.addEventListener('resize', resize);

            // Input listeners
            window.addEventListener('keydown', e => {
                GAME.keys[e.key] = true;
            });

            window.addEventListener('keyup', e => {
                GAME.keys[e.key] = false;
            });

            GAME.canvas.addEventListener('click', e => {
                if (GAME.state === 'galaxy') {
                    const rect = GAME.canvas.getBoundingClientRect();
                    const x = (e.clientX - rect.left - GAME.camera.x) / GAME.camera.zoom;
                    const y = (e.clientY - rect.top - GAME.camera.y) / GAME.camera.zoom;

                    GALAXY.systems.forEach(system => {
                        const dist = distance(x, y, system.x, system.y);
                        if (dist < 20) {
                            selectSystem(system.id);
                        }
                    });
                }
            });

            GAME.canvas.addEventListener('wheel', e => {
                if (GAME.state === 'galaxy') {
                    e.preventDefault();
                    const zoomSpeed = 0.1;
                    GAME.camera.zoom = clamp(GAME.camera.zoom + (e.deltaY > 0 ? -zoomSpeed : zoomSpeed), 0.3, 3);
                }
            });

            // Start game
            showMainMenu();
            GAME.lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        window.addEventListener('load', init);
    </script>
</body>
</html>