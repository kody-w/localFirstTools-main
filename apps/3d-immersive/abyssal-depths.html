<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Abyssal Depths - Deep Sea Exploration</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            overflow: hidden;
            background: #000;
            color: #fff;
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
            cursor: none;
        }

        .hud {
            position: fixed;
            pointer-events: none;
            user-select: none;
        }

        #depthMeter {
            top: 20px;
            right: 20px;
            font-size: 48px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8), 0 0 20px rgba(0, 255, 255, 0.4);
            color: #00ffff;
        }

        .statusBar {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 300px;
        }

        .bar {
            margin-bottom: 10px;
            position: relative;
        }

        .barLabel {
            font-size: 12px;
            margin-bottom: 3px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .barContainer {
            width: 100%;
            height: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 3px;
            overflow: hidden;
        }

        .barFill {
            height: 100%;
            transition: width 0.3s, background-color 0.3s;
        }

        .hull .barFill {
            background: linear-gradient(90deg, #ff0000, #ff6600);
        }

        .oxygen .barFill {
            background: linear-gradient(90deg, #00ccff, #00ffff);
        }

        .battery .barFill {
            background: linear-gradient(90deg, #ffff00, #ffaa00);
        }

        .barValue {
            position: absolute;
            right: 5px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 11px;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
        }

        .bar.critical .barContainer {
            animation: pulse 0.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { border-color: rgba(255, 0, 0, 0.3); }
            50% { border-color: rgba(255, 0, 0, 1); }
        }

        #compass {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80px;
            height: 80px;
            border: 3px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.7);
        }

        #compassNeedle {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 2px;
            height: 30px;
            background: #ff0000;
            transform-origin: bottom center;
            transform: translate(-50%, -100%);
        }

        #minimap {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            border: 2px solid rgba(0, 255, 255, 0.5);
            background: rgba(0, 0, 0, 0.8);
            border-radius: 50%;
        }

        #minimapCanvas {
            width: 100%;
            height: 100%;
            border-radius: 50%;
        }

        #speedometer {
            position: fixed;
            bottom: 20px;
            left: 20px;
            font-size: 16px;
            color: #00ffff;
            text-shadow: 0 0 5px rgba(0, 255, 255, 0.5);
        }

        .notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 30px 50px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ffff;
            border-radius: 10px;
            font-size: 24px;
            text-align: center;
            animation: fadeInOut 3s forwards;
            pointer-events: none;
            z-index: 1000;
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        }

        .menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 20, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .menu h1 {
            font-size: 64px;
            margin-bottom: 20px;
            color: #00ffff;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
        }

        .menu h2 {
            font-size: 32px;
            margin-bottom: 40px;
            color: #0088ff;
        }

        .menuButtons {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .menuButton {
            padding: 15px 40px;
            font-size: 20px;
            background: rgba(0, 100, 150, 0.5);
            border: 2px solid #00ffff;
            color: #fff;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: all 0.3s;
            pointer-events: all;
        }

        .menuButton:hover {
            background: rgba(0, 150, 200, 0.8);
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        #upgradePanel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80vw;
            max-width: 900px;
            max-height: 80vh;
            background: rgba(0, 0, 30, 0.95);
            border: 3px solid #00ffff;
            border-radius: 10px;
            padding: 30px;
            overflow-y: auto;
            z-index: 2000;
            pointer-events: all;
        }

        #upgradePanel h2 {
            text-align: center;
            color: #00ffff;
            margin-bottom: 20px;
            font-size: 32px;
        }

        .upgradeGrid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .upgradeCard {
            background: rgba(0, 50, 100, 0.5);
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 8px;
            padding: 15px;
            transition: all 0.3s;
        }

        .upgradeCard:hover {
            border-color: #00ffff;
            transform: translateY(-5px);
        }

        .upgradeCard h3 {
            color: #00ffff;
            margin-bottom: 10px;
        }

        .upgradeCard .level {
            font-size: 14px;
            color: #ffaa00;
            margin-bottom: 5px;
        }

        .upgradeCard .description {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 10px;
            line-height: 1.4;
        }

        .upgradeCard .cost {
            font-size: 14px;
            color: #00ff00;
            margin-bottom: 10px;
        }

        .upgradeCard button {
            width: 100%;
            padding: 8px;
            background: rgba(0, 150, 200, 0.5);
            border: 1px solid #00ffff;
            color: #fff;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: all 0.3s;
        }

        .upgradeCard button:hover:not(:disabled) {
            background: rgba(0, 200, 255, 0.8);
        }

        .upgradeCard button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        #discoveryLog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80vw;
            max-width: 1000px;
            max-height: 80vh;
            background: rgba(0, 0, 30, 0.95);
            border: 3px solid #00ffff;
            border-radius: 10px;
            padding: 30px;
            overflow-y: auto;
            z-index: 2000;
            pointer-events: all;
        }

        .logSection {
            margin-bottom: 30px;
        }

        .logSection h3 {
            color: #00ffff;
            font-size: 24px;
            margin-bottom: 15px;
            border-bottom: 2px solid #00ffff;
            padding-bottom: 10px;
        }

        .logEntry {
            background: rgba(0, 50, 100, 0.3);
            border-left: 3px solid #00ffff;
            padding: 10px 15px;
            margin-bottom: 10px;
        }

        .logEntry h4 {
            color: #ffaa00;
            margin-bottom: 5px;
        }

        .logEntry p {
            font-size: 12px;
            color: #ccc;
            line-height: 1.4;
        }

        .closeButton {
            position: absolute;
            top: 15px;
            right: 15px;
            padding: 10px 20px;
            background: rgba(255, 0, 0, 0.5);
            border: 2px solid #ff0000;
            color: #fff;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            transition: all 0.3s;
        }

        .closeButton:hover {
            background: rgba(255, 0, 0, 0.8);
        }

        #inventory {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(0, 255, 255, 0.5);
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 14px;
        }

        .inventoryItem {
            display: inline-block;
            margin: 0 15px;
            color: #00ffff;
        }

        .inventoryItem .count {
            color: #ffaa00;
            font-weight: bold;
        }

        #controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.3);
            padding: 15px;
            border-radius: 5px;
            font-size: 11px;
            line-height: 1.6;
            max-width: 200px;
        }

        #controls h4 {
            color: #00ffff;
            margin-bottom: 5px;
        }

        .warning {
            position: fixed;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 30px;
            background: rgba(255, 0, 0, 0.8);
            border: 2px solid #ff0000;
            border-radius: 5px;
            font-size: 18px;
            font-weight: bold;
            animation: warningPulse 0.5s infinite;
        }

        @keyframes warningPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .hidden {
            display: none !important;
        }

        #mobileControls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            display: none;
            justify-content: space-between;
            align-items: flex-end;
            pointer-events: none;
            z-index: 100;
        }

        .joystick {
            width: 120px;
            height: 120px;
            background: rgba(0, 0, 0, 0.5);
            border: 3px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            position: relative;
            pointer-events: all;
        }

        .joystickKnob {
            width: 50px;
            height: 50px;
            background: rgba(0, 255, 255, 0.7);
            border: 2px solid #00ffff;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .mobileButtons {
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: all;
        }

        .mobileButton {
            width: 60px;
            height: 60px;
            background: rgba(0, 100, 150, 0.7);
            border: 2px solid #00ffff;
            border-radius: 50%;
            color: #fff;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
        }

        .mobileButton:active {
            background: rgba(0, 150, 200, 0.9);
        }

        @media (max-width: 768px) {
            #mobileControls {
                display: flex;
            }

            .statusBar {
                width: 200px;
            }

            #depthMeter {
                font-size: 32px;
            }

            #controls {
                display: none;
            }
        }

        .sonarPing {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            border: 3px solid rgba(0, 255, 255, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: sonarExpand 2s ease-out forwards;
            pointer-events: none;
        }

        @keyframes sonarExpand {
            0% {
                width: 50px;
                height: 50px;
                opacity: 1;
            }
            100% {
                width: 800px;
                height: 800px;
                opacity: 0;
            }
        }

        #storyText {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 800px;
            background: rgba(0, 0, 30, 0.9);
            border: 2px solid #00ffff;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            font-size: 16px;
            line-height: 1.6;
            color: #aaccff;
            animation: fadeIn 1s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateX(-50%) translateY(20px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <!-- HUD Elements -->
    <div id="depthMeter" class="hud">0m</div>

    <div class="statusBar hud">
        <div class="bar hull">
            <div class="barLabel">Hull Integrity</div>
            <div class="barContainer">
                <div class="barFill" style="width: 100%"></div>
                <div class="barValue">100%</div>
            </div>
        </div>
        <div class="bar oxygen">
            <div class="barLabel">Oxygen</div>
            <div class="barContainer">
                <div class="barFill" style="width: 100%"></div>
                <div class="barValue">100%</div>
            </div>
        </div>
        <div class="bar battery">
            <div class="barLabel">Battery</div>
            <div class="barContainer">
                <div class="barFill" style="width: 100%"></div>
                <div class="barValue">100%</div>
            </div>
        </div>
    </div>

    <div id="compass" class="hud">
        <div id="compassNeedle"></div>
        <div style="position: absolute; top: 5px; left: 50%; transform: translateX(-50%); font-size: 12px;">N</div>
    </div>

    <div id="minimap" class="hud">
        <canvas id="minimapCanvas" width="200" height="200"></canvas>
    </div>

    <div id="speedometer" class="hud">
        Speed: <span id="speedValue">0.0</span> m/s
    </div>

    <div id="inventory" class="hud">
        <span class="inventoryItem">Minerals: <span class="count" id="mineralCount">0</span></span>
        <span class="inventoryItem">Bio-Samples: <span class="count" id="bioCount">0</span></span>
        <span class="inventoryItem">Artifacts: <span class="count" id="artifactCount">0</span></span>
        <span class="inventoryItem">Data Cores: <span class="count" id="coreCount">0</span></span>
    </div>

    <div id="controls" class="hud">
        <h4>Controls</h4>
        WASD - Move<br>
        Mouse - Look<br>
        Space - Rise<br>
        Shift - Descend<br>
        E - Collect<br>
        Q - Sonar Ping<br>
        Tab - Upgrades<br>
        L - Discovery Log<br>
        ESC - Menu
    </div>

    <!-- Mobile Controls -->
    <div id="mobileControls">
        <div class="joystick" id="joystick">
            <div class="joystickKnob" id="joystickKnob"></div>
        </div>
        <div class="mobileButtons">
            <div class="mobileButton" id="mobileRise">▲</div>
            <div class="mobileButton" id="mobileCollect">E</div>
            <div class="mobileButton" id="mobileDescend">▼</div>
        </div>
    </div>

    <!-- Main Menu -->
    <div id="mainMenu" class="menu">
        <h1>ABYSSAL DEPTHS</h1>
        <h2>Deep Sea Exploration</h2>
        <div class="menuButtons">
            <button class="menuButton" id="newGameBtn">New Game</button>
            <button class="menuButton" id="continueBtn">Continue</button>
            <button class="menuButton" id="helpBtn">How to Play</button>
        </div>
    </div>

    <!-- Upgrade Panel -->
    <div id="upgradePanel" class="hidden">
        <button class="closeButton" id="closeUpgrades">Close</button>
        <h2>Research Station - Upgrades</h2>
        <div class="upgradeGrid" id="upgradeGrid"></div>
    </div>

    <!-- Discovery Log -->
    <div id="discoveryLog" class="hidden">
        <button class="closeButton" id="closeLog">Close</button>
        <h2>Discovery Log</h2>
        <div id="logContent"></div>
    </div>

    <script>
        // ============================================================================
        // GAME STATE & CONSTANTS
        // ============================================================================

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let width, height;

        function resizeCanvas() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Game state
        const game = {
            state: 'menu', // menu, playing, paused
            time: 0,
            deltaTime: 0,
            lastTime: 0,
            paused: false
        };

        // Player submarine
        const player = {
            x: 0,
            y: 0,
            z: 0,
            vx: 0,
            vy: 0,
            vz: 0,
            yaw: 0,
            pitch: 0,
            maxSpeed: 5,
            acceleration: 0.2,
            drag: 0.95,
            hull: 100,
            maxHull: 100,
            oxygen: 100,
            maxOxygen: 100,
            battery: 100,
            maxBattery: 100,
            lightsOn: true,
            sonarActive: false,
            sonarCooldown: 0,
            nearestCollectable: null
        };

        // Upgrades
        const upgrades = {
            hull: { level: 1, maxLevel: 5, cost: [50, 100, 200, 400], name: 'Hull Reinforcement', desc: 'Withstand deeper pressure' },
            engine: { level: 1, maxLevel: 5, cost: [40, 80, 160, 320], name: 'Engine Upgrade', desc: 'Increase maximum speed' },
            lights: { level: 1, maxLevel: 5, cost: [30, 60, 120, 240], name: 'Spotlight Range', desc: 'Illuminate further' },
            sonar: { level: 1, maxLevel: 5, cost: [60, 120, 240, 480], name: 'Sonar System', desc: 'Reveal hidden objects' },
            oxygen: { level: 1, maxLevel: 5, cost: [50, 100, 200, 400], name: 'Oxygen Tank', desc: 'Longer dive time' },
            grapple: { level: 1, maxLevel: 5, cost: [40, 80, 160, 320], name: 'Grappling Arm', desc: 'Collect resources faster' },
            shield: { level: 1, maxLevel: 5, cost: [80, 160, 320, 640], name: 'Shield Generator', desc: 'Protection from damage' }
        };

        // Inventory
        const inventory = {
            minerals: 0,
            bioSamples: 0,
            artifacts: 0,
            dataCores: 0
        };

        // Discovery log
        const discoveries = {
            creatures: new Set(),
            locations: new Set(),
            artifacts: new Set(),
            dataCores: new Set()
        };

        // Depth zones
        const depthZones = [
            { name: 'Surface', depth: 0, color: '#4499ff', light: 1.0, fog: 0.01 },
            { name: 'Sunlit Zone', depth: 50, color: '#3388dd', light: 0.8, fog: 0.015 },
            { name: 'Twilight Zone', depth: 200, color: '#2255aa', light: 0.4, fog: 0.025 },
            { name: 'Midnight Zone', depth: 1000, color: '#001144', light: 0.1, fog: 0.04 },
            { name: 'Abyssal Zone', depth: 4000, color: '#000022', light: 0.02, fog: 0.06 },
            { name: 'Hadal Zone', depth: 6000, color: '#000011', light: 0.005, fog: 0.08 }
        ];

        // Creature definitions
        const creatureTypes = [
            // Sunlit Zone
            { id: 'fish', name: 'Tropical Fish', behavior: 'school', speed: 2, size: 0.3, color: '#ff6600', minDepth: 0, maxDepth: 200, hostile: false, bio: 'Small, colorful fish that travel in schools for protection.' },
            { id: 'turtle', name: 'Sea Turtle', behavior: 'wander', speed: 1, size: 1.5, color: '#339933', minDepth: 0, maxDepth: 300, hostile: false, bio: 'Ancient reptiles that have roamed the oceans for millions of years.' },
            { id: 'manta', name: 'Manta Ray', behavior: 'glide', speed: 1.5, size: 3, color: '#444444', minDepth: 0, maxDepth: 500, hostile: false, bio: 'Graceful giants that filter feed on plankton.' },
            { id: 'dolphin', name: 'Dolphin', behavior: 'playful', speed: 4, size: 2, color: '#6699cc', minDepth: 0, maxDepth: 200, hostile: false, bio: 'Intelligent marine mammals known for their curiosity.' },

            // Twilight Zone
            { id: 'jellyfish', name: 'Jellyfish', behavior: 'drift', speed: 0.5, size: 1, color: '#ff00ff', minDepth: 100, maxDepth: 1000, hostile: false, glow: true, bio: 'Translucent creatures that pulse through the water.' },
            { id: 'shark', name: 'Reef Shark', behavior: 'hunt', speed: 3, size: 2.5, color: '#666666', minDepth: 50, maxDepth: 500, hostile: true, damage: 10, bio: 'Apex predators that patrol their territory.' },
            { id: 'whale', name: 'Humpback Whale', behavior: 'migrate', speed: 2, size: 12, color: '#334455', minDepth: 0, maxDepth: 600, hostile: false, bio: 'The largest creatures in the ocean, singing mysterious songs.' },

            // Midnight Zone
            { id: 'squid', name: 'Giant Squid', behavior: 'ambush', speed: 2.5, size: 6, color: '#aa3333', minDepth: 600, maxDepth: 2000, hostile: true, damage: 25, glow: true, bio: 'Mysterious giants of the deep, rarely seen by humans.' },
            { id: 'anglerfish', name: 'Anglerfish', behavior: 'lurk', speed: 1, size: 1.5, color: '#442222', minDepth: 1000, maxDepth: 4000, hostile: true, damage: 15, glow: true, bio: 'Uses a bioluminescent lure to attract prey in the darkness.' },
            { id: 'viperfish', name: 'Viperfish', behavior: 'hunt', speed: 3, size: 0.8, color: '#4444aa', minDepth: 800, maxDepth: 3000, hostile: true, damage: 8, glow: true, bio: 'Long fangs and photophores make it a fearsome predator.' },

            // Abyssal Zone
            { id: 'gulper', name: 'Gulper Eel', behavior: 'wander', speed: 1.5, size: 2, color: '#221144', minDepth: 2000, maxDepth: 6000, hostile: false, glow: true, bio: 'Enormous mouth allows it to swallow prey larger than itself.' },
            { id: 'vampire', name: 'Vampire Squid', behavior: 'drift', speed: 1, size: 1, color: '#aa0000', minDepth: 2000, maxDepth: 5000, hostile: false, glow: true, bio: 'Not actually a vampire - turns itself inside out when threatened.' },
            { id: 'chimera', name: 'Chimera', behavior: 'wander', speed: 1.5, size: 1.8, color: '#665544', minDepth: 3000, maxDepth: 6500, hostile: false, bio: 'Ancient fish with a venomous spine, virtually unchanged for millions of years.' },

            // Hadal Zone
            { id: 'snailfish', name: 'Hadal Snailfish', behavior: 'wander', speed: 0.8, size: 0.5, color: '#ccbbaa', minDepth: 6000, maxDepth: 8000, hostile: false, bio: 'The deepest living fish ever discovered, adapted to extreme pressure.' },
            { id: 'leviathan', name: 'The Leviathan', behavior: 'boss', speed: 1.5, size: 20, color: '#ff0044', minDepth: 7000, maxDepth: 8000, hostile: true, damage: 50, glow: true, bio: 'An ancient creature of legend, guardian of the abyss.' }
        ];

        // Collectables
        const collectableTypes = [
            { id: 'mineral', name: 'Mineral Deposit', color: '#ffaa00', size: 0.5, minDepth: 0, glow: false, type: 'minerals' },
            { id: 'bio', name: 'Bio-Sample', color: '#00ff88', size: 0.4, minDepth: 100, glow: true, type: 'bioSamples' },
            { id: 'artifact', name: 'Ancient Artifact', color: '#8800ff', size: 0.6, minDepth: 1000, glow: true, type: 'artifacts' },
            { id: 'core', name: 'Data Core', color: '#00ffff', size: 0.5, minDepth: 500, glow: true, type: 'dataCores' }
        ];

        // POIs (Points of Interest)
        const poiTypes = [
            { id: 'wreck', name: 'Shipwreck', size: 8, color: '#665544', minDepth: 50 },
            { id: 'cave', name: 'Cave System', size: 10, color: '#332211', minDepth: 100 },
            { id: 'ruins', name: 'Ancient Ruins', size: 15, color: '#4444aa', minDepth: 2000 },
            { id: 'vent', name: 'Hydrothermal Vent', size: 5, color: '#ff4400', minDepth: 3000, healing: true },
            { id: 'trench', name: 'Deep Trench', size: 20, color: '#000000', minDepth: 6000 }
        ];

        // Story data cores content
        const storyCores = [
            { depth: 500, text: 'Log Entry 1: We detected an anomalous signal from the deep. The readings are unlike anything we\'ve seen. Beginning descent to investigate.' },
            { depth: 1200, text: 'Log Entry 2: The pressure at this depth is incredible. We\'ve discovered ruins - impossibly ancient. Who built this?' },
            { depth: 2500, text: 'Log Entry 3: The structures go deeper. Symbols we cannot decipher. The signal grows stronger. Something calls from below.' },
            { depth: 4200, text: 'Log Entry 4: Systems failing. The creatures here... they guard something. The signal is not natural. We must know what lies at the bottom.' },
            { depth: 6500, text: 'Log Entry 5: Final entry. If you are reading this, turn back. The truth below is not meant for us. The Leviathan awakens. The abyss... looks back.' }
        ];

        // World objects
        let creatures = [];
        let collectables = [];
        let pois = [];
        let particles = [];
        let terrain = [];

        // Input state
        const keys = {};
        const mouse = { x: 0, y: 0, locked: false };

        // Mobile input
        const mobile = {
            joystickActive: false,
            joystickX: 0,
            joystickY: 0,
            joystickStartX: 0,
            joystickStartY: 0
        };

        // Audio context
        let audioContext;
        let masterGain;
        const sounds = {};

        // Camera
        const camera = {
            fov: 60,
            near: 0.1,
            far: 200
        };

        // ============================================================================
        // INITIALIZATION
        // ============================================================================

        function init() {
            initAudio();
            initInput();
            initMobile();
            checkSavedGame();

            // Start game loop
            game.lastTime = performance.now();
            gameLoop();
        }

        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                masterGain = audioContext.createGain();
                masterGain.connect(audioContext.destination);
                masterGain.gain.value = 0.3;
            } catch (e) {
                console.log('Audio not available');
            }
        }

        function playTone(freq, duration, type = 'sine', volume = 0.1) {
            if (!audioContext) return;

            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();

            osc.connect(gain);
            gain.connect(masterGain);

            osc.frequency.value = freq;
            osc.type = type;
            gain.gain.value = volume;

            osc.start();
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            osc.stop(audioContext.currentTime + duration);
        }

        function playSonarPing() {
            playTone(800, 0.1, 'sine', 0.2);
            setTimeout(() => playTone(600, 0.15, 'sine', 0.15), 100);
        }

        function playWarning() {
            playTone(400, 0.2, 'square', 0.15);
        }

        function playCollect() {
            playTone(1200, 0.1, 'sine', 0.1);
            setTimeout(() => playTone(1600, 0.1, 'sine', 0.1), 50);
        }

        // ============================================================================
        // INPUT HANDLING
        // ============================================================================

        function initInput() {
            document.addEventListener('keydown', (e) => {
                keys[e.key.toLowerCase()] = true;

                if (game.state !== 'playing') return;

                if (e.key === 'Escape') {
                    togglePause();
                }
                if (e.key === 'Tab') {
                    e.preventDefault();
                    toggleUpgradePanel();
                }
                if (e.key.toLowerCase() === 'l') {
                    toggleDiscoveryLog();
                }
                if (e.key.toLowerCase() === 'q') {
                    activateSonar();
                }
                if (e.key.toLowerCase() === 'e') {
                    collectNearby();
                }
            });

            document.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
            });

            canvas.addEventListener('click', () => {
                if (game.state === 'playing' && !mouse.locked) {
                    canvas.requestPointerLock();
                }
            });

            document.addEventListener('pointerlockchange', () => {
                mouse.locked = document.pointerLockElement === canvas;
            });

            document.addEventListener('mousemove', (e) => {
                if (mouse.locked) {
                    player.yaw -= e.movementX * 0.003;
                    player.pitch -= e.movementY * 0.003;
                    player.pitch = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, player.pitch));
                }
            });

            // Menu buttons
            document.getElementById('newGameBtn').addEventListener('click', startNewGame);
            document.getElementById('continueBtn').addEventListener('click', continueGame);
            document.getElementById('closeUpgrades').addEventListener('click', () => toggleUpgradePanel(false));
            document.getElementById('closeLog').addEventListener('click', () => toggleDiscoveryLog(false));
        }

        function initMobile() {
            const joystick = document.getElementById('joystick');
            const knob = document.getElementById('joystickKnob');

            joystick.addEventListener('touchstart', (e) => {
                e.preventDefault();
                mobile.joystickActive = true;
                const rect = joystick.getBoundingClientRect();
                mobile.joystickStartX = rect.left + rect.width / 2;
                mobile.joystickStartY = rect.top + rect.height / 2;
            });

            document.addEventListener('touchmove', (e) => {
                if (!mobile.joystickActive) return;
                e.preventDefault();

                const touch = e.touches[0];
                const dx = touch.clientX - mobile.joystickStartX;
                const dy = touch.clientY - mobile.joystickStartY;

                const distance = Math.sqrt(dx * dx + dy * dy);
                const maxDistance = 35;

                if (distance > maxDistance) {
                    const angle = Math.atan2(dy, dx);
                    mobile.joystickX = Math.cos(angle) * maxDistance;
                    mobile.joystickY = Math.sin(angle) * maxDistance;
                } else {
                    mobile.joystickX = dx;
                    mobile.joystickY = dy;
                }

                knob.style.transform = `translate(calc(-50% + ${mobile.joystickX}px), calc(-50% + ${mobile.joystickY}px))`;
            });

            document.addEventListener('touchend', (e) => {
                if (mobile.joystickActive) {
                    mobile.joystickActive = false;
                    mobile.joystickX = 0;
                    mobile.joystickY = 0;
                    knob.style.transform = 'translate(-50%, -50%)';
                }
            });

            document.getElementById('mobileRise').addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys[' '] = true;
            });
            document.getElementById('mobileRise').addEventListener('touchend', (e) => {
                e.preventDefault();
                keys[' '] = false;
            });

            document.getElementById('mobileDescend').addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys['shift'] = true;
            });
            document.getElementById('mobileDescend').addEventListener('touchend', (e) => {
                e.preventDefault();
                keys['shift'] = false;
            });

            document.getElementById('mobileCollect').addEventListener('touchstart', (e) => {
                e.preventDefault();
                collectNearby();
            });
        }

        // ============================================================================
        // GAME STATE MANAGEMENT
        // ============================================================================

        function startNewGame() {
            // Reset player
            player.x = 0;
            player.y = -10;
            player.z = 0;
            player.vx = player.vy = player.vz = 0;
            player.yaw = 0;
            player.pitch = 0;
            player.hull = 100;
            player.oxygen = 100;
            player.battery = 100;

            // Reset upgrades
            for (let key in upgrades) {
                upgrades[key].level = 1;
            }

            // Reset inventory
            inventory.minerals = 0;
            inventory.bioSamples = 0;
            inventory.artifacts = 0;
            inventory.dataCores = 0;

            // Clear discoveries
            discoveries.creatures.clear();
            discoveries.locations.clear();
            discoveries.artifacts.clear();
            discoveries.dataCores.clear();

            // Generate world
            generateWorld();

            // Start game
            document.getElementById('mainMenu').classList.add('hidden');
            game.state = 'playing';
            canvas.requestPointerLock();

            showNotification('Welcome to the Abyss');
        }

        function continueGame() {
            const saved = localStorage.getItem('abyssalDepthsSave');
            if (!saved) {
                startNewGame();
                return;
            }

            const data = JSON.parse(saved);

            // Restore player
            Object.assign(player, data.player);

            // Restore upgrades
            Object.assign(upgrades, data.upgrades);

            // Restore inventory
            Object.assign(inventory, data.inventory);

            // Restore discoveries
            discoveries.creatures = new Set(data.discoveries.creatures);
            discoveries.locations = new Set(data.discoveries.locations);
            discoveries.artifacts = new Set(data.discoveries.artifacts);
            discoveries.dataCores = new Set(data.discoveries.dataCores);

            // Generate world (will be different but same structure)
            generateWorld();

            document.getElementById('mainMenu').classList.add('hidden');
            game.state = 'playing';
            canvas.requestPointerLock();

            showNotification('Welcome Back');
        }

        function checkSavedGame() {
            const saved = localStorage.getItem('abyssalDepthsSave');
            const continueBtn = document.getElementById('continueBtn');
            if (!saved) {
                continueBtn.disabled = true;
                continueBtn.style.opacity = '0.3';
            }
        }

        function saveGame() {
            const data = {
                player: { ...player },
                upgrades: JSON.parse(JSON.stringify(upgrades)),
                inventory: { ...inventory },
                discoveries: {
                    creatures: Array.from(discoveries.creatures),
                    locations: Array.from(discoveries.locations),
                    artifacts: Array.from(discoveries.artifacts),
                    dataCores: Array.from(discoveries.dataCores)
                }
            };
            localStorage.setItem('abyssalDepthsSave', JSON.stringify(data));
        }

        function togglePause() {
            game.paused = !game.paused;
            if (game.paused) {
                document.getElementById('mainMenu').classList.remove('hidden');
                document.exitPointerLock();
            } else {
                document.getElementById('mainMenu').classList.add('hidden');
                canvas.requestPointerLock();
            }
        }

        // ============================================================================
        // WORLD GENERATION
        // ============================================================================

        function generateWorld() {
            creatures = [];
            collectables = [];
            pois = [];
            particles = [];
            terrain = [];

            // Generate creatures
            for (let i = 0; i < 200; i++) {
                const type = creatureTypes[Math.floor(Math.random() * creatureTypes.length)];
                const depth = type.minDepth + Math.random() * (type.maxDepth - type.minDepth);

                creatures.push({
                    ...type,
                    x: (Math.random() - 0.5) * 500,
                    y: -depth,
                    z: (Math.random() - 0.5) * 500,
                    vx: (Math.random() - 0.5) * type.speed,
                    vz: (Math.random() - 0.5) * type.speed,
                    angle: Math.random() * Math.PI * 2,
                    phase: Math.random() * Math.PI * 2,
                    discovered: false
                });
            }

            // Generate collectables
            for (let i = 0; i < 300; i++) {
                const type = collectableTypes[Math.floor(Math.random() * collectableTypes.length)];
                const maxDepth = type.id === 'core' ? 7000 : 6000;
                const depth = type.minDepth + Math.random() * (maxDepth - type.minDepth);

                collectables.push({
                    ...type,
                    x: (Math.random() - 0.5) * 500,
                    y: -depth,
                    z: (Math.random() - 0.5) * 500,
                    collected: false,
                    pulse: Math.random() * Math.PI * 2
                });
            }

            // Generate POIs
            for (let i = 0; i < 50; i++) {
                const type = poiTypes[Math.floor(Math.random() * poiTypes.length)];
                const depth = type.minDepth + Math.random() * (7000 - type.minDepth);

                pois.push({
                    ...type,
                    x: (Math.random() - 0.5) * 400,
                    y: -depth,
                    z: (Math.random() - 0.5) * 400,
                    discovered: false
                });
            }

            // Generate ambient particles
            for (let i = 0; i < 500; i++) {
                particles.push({
                    x: (Math.random() - 0.5) * 300,
                    y: Math.random() * -7000,
                    z: (Math.random() - 0.5) * 300,
                    vx: (Math.random() - 0.5) * 0.1,
                    vy: Math.random() * 0.05,
                    vz: (Math.random() - 0.5) * 0.1,
                    size: Math.random() * 2 + 1,
                    alpha: Math.random() * 0.5 + 0.3,
                    type: Math.random() < 0.7 ? 'plankton' : 'bubble'
                });
            }

            // Generate terrain features
            for (let i = 0; i < 100; i++) {
                const depth = Math.random() * 7000;
                terrain.push({
                    x: (Math.random() - 0.5) * 600,
                    y: -depth,
                    z: (Math.random() - 0.5) * 600,
                    size: Math.random() * 20 + 10,
                    type: depth < 200 ? 'coral' : depth < 1000 ? 'rock' : 'spire',
                    color: depth < 200 ? '#ff6633' : depth < 1000 ? '#665544' : '#222233'
                });
            }
        }

        // ============================================================================
        // GAME LOOP
        // ============================================================================

        function gameLoop(timestamp) {
            requestAnimationFrame(gameLoop);

            if (game.state !== 'playing' || game.paused) {
                return;
            }

            // Calculate delta time
            game.deltaTime = Math.min((timestamp - game.lastTime) / 1000, 0.1);
            game.lastTime = timestamp;
            game.time = timestamp / 1000;

            // Update
            updatePlayer();
            updateCreatures();
            updateParticles();
            updateSystems();

            // Render
            render();

            // Update HUD
            updateHUD();

            // Auto-save every 10 seconds
            if (Math.floor(game.time) % 10 === 0 && game.time % 1 < game.deltaTime) {
                saveGame();
            }
        }

        // ============================================================================
        // UPDATE FUNCTIONS
        // ============================================================================

        function updatePlayer() {
            const dt = game.deltaTime;
            const depth = -player.y;

            // Input handling
            let moveX = 0, moveZ = 0, moveY = 0;

            // Keyboard
            if (keys['w']) moveZ -= 1;
            if (keys['s']) moveZ += 1;
            if (keys['a']) moveX -= 1;
            if (keys['d']) moveX += 1;
            if (keys[' ']) moveY += 1;
            if (keys['shift']) moveY -= 1;

            // Mobile joystick
            if (mobile.joystickActive) {
                moveX += mobile.joystickX / 35;
                moveZ += mobile.joystickY / 35;
            }

            // Apply movement in local space
            const cos = Math.cos(player.yaw);
            const sin = Math.sin(player.yaw);

            const maxSpeed = player.maxSpeed * (1 + upgrades.engine.level * 0.3);
            const accel = player.acceleration;

            player.vx += (moveX * cos - moveZ * sin) * accel;
            player.vz += (moveX * sin + moveZ * cos) * accel;
            player.vy += moveY * accel * 0.5;

            // Apply drag
            player.vx *= player.drag;
            player.vz *= player.drag;
            player.vy *= 0.9;

            // Speed limit
            const speed = Math.sqrt(player.vx * player.vx + player.vz * player.vz);
            if (speed > maxSpeed) {
                player.vx = (player.vx / speed) * maxSpeed;
                player.vz = (player.vz / speed) * maxSpeed;
            }

            // Update position
            player.x += player.vx * dt * 60;
            player.y += player.vy * dt * 60;
            player.z += player.vz * dt * 60;

            // Surface limit
            if (player.y > -2) {
                player.y = -2;
                player.vy = 0;

                // Restore oxygen at surface
                player.oxygen = Math.min(player.maxOxygen, player.oxygen + dt * 20);
            }

            // Calculate pressure damage
            const maxDepth = 200 + upgrades.hull.level * 1000;
            if (depth > maxDepth) {
                const excess = depth - maxDepth;
                const damage = (excess / 100) * dt;
                player.hull = Math.max(0, player.hull - damage);

                if (Math.random() < 0.1) {
                    playWarning();
                }
            }

            // Oxygen depletion
            if (depth > 10) {
                const oxygenDrain = 0.5 * dt;
                player.oxygen = Math.max(0, player.oxygen - oxygenDrain);

                if (player.oxygen <= 0) {
                    player.hull = Math.max(0, player.hull - 5 * dt);
                }
            }

            // Battery drain (lights and movement)
            if (player.lightsOn) {
                player.battery = Math.max(0, player.battery - 0.5 * dt);
            }
            const movementDrain = speed / maxSpeed * 0.3 * dt;
            player.battery = Math.max(0, player.battery - movementDrain);

            // Battery recharge at surface
            if (depth < 10) {
                player.battery = Math.min(player.maxBattery, player.battery + dt * 10);
            }

            // Find nearest collectable
            let nearest = null;
            let nearestDist = 10;

            for (let c of collectables) {
                if (c.collected) continue;
                const dx = c.x - player.x;
                const dy = c.y - player.y;
                const dz = c.z - player.z;
                const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

                if (dist < nearestDist) {
                    nearest = c;
                    nearestDist = dist;
                }
            }
            player.nearestCollectable = nearest;

            // Sonar cooldown
            if (player.sonarCooldown > 0) {
                player.sonarCooldown -= dt;
            }

            // Check for death
            if (player.hull <= 0) {
                gameOver();
            }

            // Check for story triggers
            checkStoryTriggers();
        }

        function updateCreatures() {
            const dt = game.deltaTime;

            for (let creature of creatures) {
                // Update based on behavior
                switch (creature.behavior) {
                    case 'school':
                        // Flocking behavior - simplified
                        creature.angle += (Math.random() - 0.5) * 0.1;
                        creature.vx = Math.cos(creature.angle) * creature.speed;
                        creature.vz = Math.sin(creature.angle) * creature.speed;
                        break;

                    case 'wander':
                        if (Math.random() < 0.01) {
                            creature.angle = Math.random() * Math.PI * 2;
                        }
                        creature.vx = Math.cos(creature.angle) * creature.speed;
                        creature.vz = Math.sin(creature.angle) * creature.speed;
                        break;

                    case 'hunt':
                    case 'ambush':
                        // Move towards player if close
                        const dx = player.x - creature.x;
                        const dz = player.z - creature.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);

                        if (dist < 30 && creature.hostile) {
                            creature.angle = Math.atan2(dz, dx);
                            creature.vx = Math.cos(creature.angle) * creature.speed * 1.5;
                            creature.vz = Math.sin(creature.angle) * creature.speed * 1.5;

                            // Attack if very close
                            if (dist < 3) {
                                attackPlayer(creature);
                            }
                        } else {
                            if (Math.random() < 0.02) {
                                creature.angle = Math.random() * Math.PI * 2;
                            }
                            creature.vx = Math.cos(creature.angle) * creature.speed;
                            creature.vz = Math.sin(creature.angle) * creature.speed;
                        }
                        break;

                    case 'drift':
                        creature.vx = Math.sin(game.time + creature.phase) * 0.5;
                        creature.vz = Math.cos(game.time * 0.7 + creature.phase) * 0.5;
                        break;
                }

                // Update position
                creature.x += creature.vx * dt * 60;
                creature.z += creature.vz * dt * 60;

                // Keep in bounds
                const bound = 300;
                if (Math.abs(creature.x) > bound) creature.x = Math.sign(creature.x) * bound;
                if (Math.abs(creature.z) > bound) creature.z = Math.sign(creature.z) * bound;

                // Phase for animation
                creature.phase += dt;

                // Discovery check
                if (!creature.discovered) {
                    const dx = player.x - creature.x;
                    const dy = player.y - creature.y;
                    const dz = player.z - creature.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

                    if (dist < 15) {
                        discoverCreature(creature);
                    }
                }
            }
        }

        function updateParticles() {
            const dt = game.deltaTime;

            for (let p of particles) {
                p.x += p.vx * dt * 60;
                p.y += p.vy * dt * 60;
                p.z += p.vz * dt * 60;

                // Respawn particles that go out of range
                if (p.type === 'bubble' && p.y > 0) {
                    p.y = -100;
                    p.x = player.x + (Math.random() - 0.5) * 100;
                    p.z = player.z + (Math.random() - 0.5) * 100;
                }

                // Keep plankton near player
                const dx = p.x - player.x;
                const dz = p.z - player.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist > 200) {
                    p.x = player.x + (Math.random() - 0.5) * 200;
                    p.z = player.z + (Math.random() - 0.5) * 200;
                }
            }
        }

        function updateSystems() {
            const depth = -player.y;

            // Check for healing at vents
            for (let poi of pois) {
                if (!poi.healing) continue;

                const dx = player.x - poi.x;
                const dy = player.y - poi.y;
                const dz = player.z - poi.z;
                const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

                if (dist < poi.size * 2) {
                    player.oxygen = Math.min(player.maxOxygen, player.oxygen + game.deltaTime * 30);
                    player.hull = Math.min(player.maxHull, player.hull + game.deltaTime * 5);

                    if (!poi.discovered) {
                        discoverLocation(poi);
                    }
                }
            }

            // Check other POI discoveries
            for (let poi of pois) {
                if (poi.discovered) continue;

                const dx = player.x - poi.x;
                const dy = player.y - poi.y;
                const dz = player.z - poi.z;
                const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

                if (dist < poi.size * 2) {
                    discoverLocation(poi);
                }
            }
        }

        function attackPlayer(creature) {
            if (!creature.damage) return;
            if (Math.random() < 0.02) { // Attack every ~50 frames
                const shieldLevel = upgrades.shield.level;
                const damage = creature.damage * (1 - shieldLevel * 0.15);
                player.hull = Math.max(0, player.hull - damage);
                playWarning();
            }
        }

        // ============================================================================
        // INTERACTION FUNCTIONS
        // ============================================================================

        function activateSonar() {
            if (player.sonarCooldown > 0) return;
            if (player.battery < 10) return;

            player.battery -= 10;
            player.sonarCooldown = 5 - upgrades.sonar.level * 0.5;

            playSonarPing();

            // Visual effect
            const ping = document.createElement('div');
            ping.className = 'sonarPing';
            document.body.appendChild(ping);
            setTimeout(() => ping.remove(), 2000);

            // Reveal nearby collectables
            const range = 50 + upgrades.sonar.level * 20;
            for (let c of collectables) {
                if (c.collected) continue;
                const dx = c.x - player.x;
                const dy = c.y - player.y;
                const dz = c.z - player.z;
                const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

                if (dist < range) {
                    c.revealed = true;
                    setTimeout(() => c.revealed = false, 3000);
                }
            }
        }

        function collectNearby() {
            if (!player.nearestCollectable) return;

            const c = player.nearestCollectable;
            c.collected = true;

            inventory[c.type]++;
            playCollect();

            if (c.id === 'artifact') {
                discoverArtifact(c);
            }

            if (c.id === 'core') {
                discoverDataCore(c);
            }

            showNotification(`Collected ${c.name}`);
        }

        function discoverCreature(creature) {
            creature.discovered = true;
            discoveries.creatures.add(creature.id);
            showNotification(`New Creature: ${creature.name}`);
        }

        function discoverLocation(poi) {
            poi.discovered = true;
            discoveries.locations.add(poi.id);
            showNotification(`Discovered: ${poi.name}`);
        }

        function discoverArtifact(artifact) {
            const id = `artifact_${Math.floor(-artifact.y)}`;
            discoveries.artifacts.add(id);
        }

        function discoverDataCore(core) {
            const depth = -core.y;
            const storyCore = storyCores.find(s => Math.abs(s.depth - depth) < 500);

            if (storyCore && !discoveries.dataCores.has(storyCore.depth)) {
                discoveries.dataCores.add(storyCore.depth);
                showStoryText(storyCore.text);
            }
        }

        function checkStoryTriggers() {
            // Check if player has reached final depth
            if (-player.y > 7500 && !discoveries.dataCores.has('finale')) {
                discoveries.dataCores.add('finale');
                showStoryText('You have reached the bottom of the Hadal Zone. The signal source lies ahead. The Leviathan stirs...');
            }
        }

        // ============================================================================
        // UI FUNCTIONS
        // ============================================================================

        function updateHUD() {
            // Depth
            document.getElementById('depthMeter').textContent = Math.floor(-player.y) + 'm';

            // Status bars
            updateStatusBar('hull', player.hull, player.maxHull);
            updateStatusBar('oxygen', player.oxygen, player.maxOxygen);
            updateStatusBar('battery', player.battery, player.maxBattery);

            // Speed
            const speed = Math.sqrt(player.vx * player.vx + player.vz * player.vz);
            document.getElementById('speedValue').textContent = speed.toFixed(1);

            // Compass
            const needleRotation = player.yaw * (180 / Math.PI);
            document.getElementById('compassNeedle').style.transform =
                `translate(-50%, -100%) rotate(${needleRotation}deg)`;

            // Inventory
            document.getElementById('mineralCount').textContent = inventory.minerals;
            document.getElementById('bioCount').textContent = inventory.bioSamples;
            document.getElementById('artifactCount').textContent = inventory.artifacts;
            document.getElementById('coreCount').textContent = inventory.dataCores;

            // Warnings
            const existingWarning = document.querySelector('.warning');
            if (existingWarning) existingWarning.remove();

            if (player.hull < 30) {
                showWarning('HULL CRITICAL');
            } else if (player.oxygen < 20) {
                showWarning('OXYGEN LOW');
            } else if (player.battery < 10) {
                showWarning('BATTERY LOW');
            }

            // Minimap
            renderMinimap();
        }

        function updateStatusBar(type, value, max) {
            const bar = document.querySelector(`.${type}`);
            const fill = bar.querySelector('.barFill');
            const valueEl = bar.querySelector('.barValue');

            const percent = (value / max) * 100;
            fill.style.width = percent + '%';
            valueEl.textContent = Math.floor(percent) + '%';

            if (percent < 30) {
                bar.classList.add('critical');
            } else {
                bar.classList.remove('critical');
            }
        }

        function showNotification(text) {
            const notif = document.createElement('div');
            notif.className = 'notification';
            notif.textContent = text;
            document.body.appendChild(notif);
            setTimeout(() => notif.remove(), 3000);
        }

        function showWarning(text) {
            const warning = document.createElement('div');
            warning.className = 'warning hud';
            warning.textContent = text;
            document.body.appendChild(warning);
        }

        function showStoryText(text) {
            const story = document.createElement('div');
            story.id = 'storyText';
            story.textContent = text;
            document.body.appendChild(story);
            setTimeout(() => story.remove(), 8000);
        }

        function toggleUpgradePanel(show) {
            const panel = document.getElementById('upgradePanel');

            if (show === false || !panel.classList.contains('hidden')) {
                panel.classList.add('hidden');
                canvas.requestPointerLock();
                return;
            }

            // Build upgrade UI
            const grid = document.getElementById('upgradeGrid');
            grid.innerHTML = '';

            for (let key in upgrades) {
                const u = upgrades[key];
                const card = document.createElement('div');
                card.className = 'upgradeCard';

                const cost = u.level < u.maxLevel ? u.cost[u.level - 1] : 0;
                const canAfford = inventory.minerals >= cost;
                const maxed = u.level >= u.maxLevel;

                card.innerHTML = `
                    <h3>${u.name}</h3>
                    <div class="level">Level ${u.level}/${u.maxLevel}</div>
                    <div class="description">${u.desc}</div>
                    <div class="cost">${maxed ? 'MAX LEVEL' : `Cost: ${cost} Minerals`}</div>
                    <button ${!canAfford || maxed ? 'disabled' : ''} onclick="upgradeItem('${key}')">
                        ${maxed ? 'Maxed' : 'Upgrade'}
                    </button>
                `;

                grid.appendChild(card);
            }

            panel.classList.remove('hidden');
            document.exitPointerLock();
        }

        function upgradeItem(key) {
            const u = upgrades[key];
            if (u.level >= u.maxLevel) return;

            const cost = u.cost[u.level - 1];
            if (inventory.minerals < cost) return;

            inventory.minerals -= cost;
            u.level++;

            // Update player stats
            if (key === 'hull') {
                const increase = 50;
                player.maxHull += increase;
                player.hull += increase;
            }
            if (key === 'oxygen') {
                const increase = 30;
                player.maxOxygen += increase;
                player.oxygen += increase;
            }

            playCollect();
            toggleUpgradePanel(true); // Refresh
        }

        function toggleDiscoveryLog(show) {
            const panel = document.getElementById('discoveryLog');

            if (show === false || !panel.classList.contains('hidden')) {
                panel.classList.add('hidden');
                canvas.requestPointerLock();
                return;
            }

            // Build log UI
            const content = document.getElementById('logContent');
            content.innerHTML = '';

            // Creatures
            const creaturesSection = document.createElement('div');
            creaturesSection.className = 'logSection';
            creaturesSection.innerHTML = '<h3>Creatures Discovered</h3>';

            for (let id of discoveries.creatures) {
                const creature = creatureTypes.find(c => c.id === id);
                const entry = document.createElement('div');
                entry.className = 'logEntry';
                entry.innerHTML = `
                    <h4>${creature.name}</h4>
                    <p>${creature.bio}</p>
                `;
                creaturesSection.appendChild(entry);
            }
            content.appendChild(creaturesSection);

            // Locations
            const locationsSection = document.createElement('div');
            locationsSection.className = 'logSection';
            locationsSection.innerHTML = '<h3>Locations Discovered</h3>';

            for (let id of discoveries.locations) {
                const poi = poiTypes.find(p => p.id === id);
                const entry = document.createElement('div');
                entry.className = 'logEntry';
                entry.innerHTML = `<h4>${poi.name}</h4>`;
                locationsSection.appendChild(entry);
            }
            content.appendChild(locationsSection);

            // Data Cores
            const coresSection = document.createElement('div');
            coresSection.className = 'logSection';
            coresSection.innerHTML = '<h3>Data Cores</h3>';

            const sortedCores = Array.from(discoveries.dataCores).filter(d => typeof d === 'number').sort((a, b) => a - b);
            for (let depth of sortedCores) {
                const core = storyCores.find(s => s.depth === depth);
                if (core) {
                    const entry = document.createElement('div');
                    entry.className = 'logEntry';
                    entry.innerHTML = `
                        <h4>Depth: ${depth}m</h4>
                        <p>${core.text}</p>
                    `;
                    coresSection.appendChild(entry);
                }
            }
            content.appendChild(coresSection);

            panel.classList.remove('hidden');
            document.exitPointerLock();
        }

        function renderMinimap() {
            const canvas = document.getElementById('minimapCanvas');
            const ctx = canvas.getContext('2d');
            const size = 200;
            const scale = 0.5;

            ctx.clearRect(0, 0, size, size);

            // Background
            ctx.fillStyle = 'rgba(0, 20, 40, 0.8)';
            ctx.fillRect(0, 0, size, size);

            // Grid
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.2)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const pos = i * size / 4;
                ctx.beginPath();
                ctx.moveTo(pos, 0);
                ctx.lineTo(pos, size);
                ctx.moveTo(0, pos);
                ctx.lineTo(size, pos);
                ctx.stroke();
            }

            const centerX = size / 2;
            const centerY = size / 2;

            // Nearby creatures
            ctx.fillStyle = 'rgba(255, 100, 100, 0.6)';
            for (let c of creatures) {
                const dx = (c.x - player.x) * scale;
                const dz = (c.z - player.z) * scale;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < size / 2 && c.hostile) {
                    ctx.beginPath();
                    ctx.arc(centerX + dx, centerY + dz, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Nearby collectables
            ctx.fillStyle = 'rgba(0, 255, 100, 0.8)';
            for (let c of collectables) {
                if (c.collected) continue;
                const dx = (c.x - player.x) * scale;
                const dz = (c.z - player.z) * scale;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < size / 2) {
                    ctx.beginPath();
                    ctx.arc(centerX + dx, centerY + dz, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // POIs
            ctx.fillStyle = 'rgba(255, 200, 0, 0.8)';
            for (let p of pois) {
                const dx = (p.x - player.x) * scale;
                const dz = (p.z - player.z) * scale;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < size / 2) {
                    ctx.fillRect(centerX + dx - 2, centerY + dz - 2, 4, 4);
                }
            }

            // Player
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(player.yaw);
            ctx.fillStyle = '#00ffff';
            ctx.beginPath();
            ctx.moveTo(0, -6);
            ctx.lineTo(-4, 6);
            ctx.lineTo(4, 6);
            ctx.closePath();
            ctx.fill();
            ctx.restore();

            // Range circle
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY, size / 2 - 10, 0, Math.PI * 2);
            ctx.stroke();
        }

        function gameOver() {
            game.state = 'menu';
            document.getElementById('mainMenu').classList.remove('hidden');
            document.exitPointerLock();

            showNotification('SUBMARINE DESTROYED - Game Over');

            // Clear save
            localStorage.removeItem('abyssalDepthsSave');
        }

        // ============================================================================
        // RENDERING
        // ============================================================================

        function render() {
            const depth = -player.y;
            const zone = getCurrentZone(depth);

            // Background color based on depth
            const bgColor = interpolateColor(zone.color, depth);
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, width, height);

            // Lighting
            const lightLevel = zone.light * (player.lightsOn ? 1 : 0.3);

            // Draw volumetric light rays (only in shallow water)
            if (depth < 300) {
                drawLightRays(lightLevel);
            }

            // Draw terrain
            drawTerrain();

            // Draw POIs
            drawPOIs();

            // Draw particles
            drawParticles(lightLevel);

            // Draw creatures
            drawCreatures(lightLevel);

            // Draw collectables
            drawCollectables();

            // Screen effects
            applyScreenEffects(depth);

            // Nearest collectable indicator
            if (player.nearestCollectable) {
                drawCollectionPrompt();
            }
        }

        function getCurrentZone(depth) {
            for (let i = depthZones.length - 1; i >= 0; i--) {
                if (depth >= depthZones[i].depth) {
                    return depthZones[i];
                }
            }
            return depthZones[0];
        }

        function interpolateColor(hexColor, depth) {
            // Add depth-based darkening
            const r = parseInt(hexColor.slice(1, 3), 16);
            const g = parseInt(hexColor.slice(3, 5), 16);
            const b = parseInt(hexColor.slice(5, 7), 16);

            const darkFactor = Math.max(0, 1 - depth / 8000);

            return `rgb(${Math.floor(r * darkFactor)}, ${Math.floor(g * darkFactor)}, ${Math.floor(b * darkFactor)})`;
        }

        function drawLightRays(lightLevel) {
            if (lightLevel < 0.3) return;

            ctx.save();
            ctx.globalAlpha = lightLevel * 0.15;

            for (let i = 0; i < 8; i++) {
                const x = (i / 8) * width + (Math.sin(game.time * 0.5 + i) * 50);

                const gradient = ctx.createLinearGradient(x, 0, x, height);
                gradient.addColorStop(0, 'rgba(255, 255, 200, 0.3)');
                gradient.addColorStop(1, 'rgba(255, 255, 200, 0)');

                ctx.fillStyle = gradient;
                ctx.fillRect(x - 30, 0, 60, height);
            }

            ctx.restore();
        }

        function drawParticles(lightLevel) {
            ctx.save();

            for (let p of particles) {
                const dx = p.x - player.x;
                const dy = p.y - player.y;
                const dz = p.z - player.z;

                // Simple 3D projection
                const screenPos = project3D(dx, dy, dz);
                if (!screenPos) continue;

                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                const alpha = Math.max(0, 1 - distance / 100) * p.alpha * lightLevel;

                ctx.globalAlpha = alpha;

                if (p.type === 'bubble') {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.beginPath();
                    ctx.arc(screenPos.x, screenPos.y, p.size * screenPos.scale, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Plankton - with bioluminescence at depth
                    const isBio = -player.y > 1000 && Math.random() < 0.3;
                    ctx.fillStyle = isBio ? 'rgba(0, 255, 200, 0.8)' : 'rgba(200, 200, 200, 0.5)';
                    ctx.fillRect(screenPos.x, screenPos.y, p.size * screenPos.scale, p.size * screenPos.scale);
                }
            }

            ctx.restore();
        }

        function drawCreatures(lightLevel) {
            ctx.save();

            // Sort by distance for proper rendering
            const sorted = [...creatures].sort((a, b) => {
                const da = Math.sqrt((a.x - player.x) ** 2 + (a.z - player.z) ** 2);
                const db = Math.sqrt((b.x - player.x) ** 2 + (b.z - player.z) ** 2);
                return db - da;
            });

            for (let c of sorted) {
                const dx = c.x - player.x;
                const dy = c.y - player.y;
                const dz = c.z - player.z;

                const screenPos = project3D(dx, dy, dz);
                if (!screenPos) continue;

                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                const visible = distance < 50 + upgrades.lights.level * 10;

                if (!visible && !c.glow) continue;

                const alpha = c.glow ? 0.9 : Math.max(0, 1 - distance / 50) * lightLevel;
                ctx.globalAlpha = alpha;

                // Draw creature as ellipse
                const size = c.size * screenPos.scale * 10;

                if (c.glow) {
                    // Glow effect
                    const gradient = ctx.createRadialGradient(
                        screenPos.x, screenPos.y, 0,
                        screenPos.x, screenPos.y, size * 1.5
                    );
                    gradient.addColorStop(0, c.color);
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(screenPos.x, screenPos.y, size * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.fillStyle = c.color;
                ctx.beginPath();
                ctx.ellipse(screenPos.x, screenPos.y, size * 1.5, size, c.angle, 0, Math.PI * 2);
                ctx.fill();

                // Eye (for some creatures)
                if (size > 5) {
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(screenPos.x + size * 0.5, screenPos.y, size * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(screenPos.x + size * 0.5, screenPos.y, size * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            ctx.restore();
        }

        function drawCollectables() {
            ctx.save();

            for (let c of collectables) {
                if (c.collected) continue;

                const dx = c.x - player.x;
                const dy = c.y - player.y;
                const dz = c.z - player.z;

                const screenPos = project3D(dx, dy, dz);
                if (!screenPos) continue;

                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                const visible = distance < 30 || c.revealed;

                if (!visible && !c.glow) continue;

                c.pulse += game.deltaTime * 2;
                const pulseScale = 1 + Math.sin(c.pulse) * 0.2;
                const alpha = c.glow ? 0.8 + Math.sin(c.pulse) * 0.2 : 0.6;

                ctx.globalAlpha = alpha;

                const size = c.size * screenPos.scale * 8 * pulseScale;

                if (c.glow) {
                    // Glow effect
                    const gradient = ctx.createRadialGradient(
                        screenPos.x, screenPos.y, 0,
                        screenPos.x, screenPos.y, size * 2
                    );
                    gradient.addColorStop(0, c.color);
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(screenPos.x, screenPos.y, size * 2, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw collectable
                ctx.fillStyle = c.color;
                if (c.id === 'mineral') {
                    // Cube
                    ctx.fillRect(screenPos.x - size, screenPos.y - size, size * 2, size * 2);
                } else if (c.id === 'bio') {
                    // Triangle
                    ctx.beginPath();
                    ctx.moveTo(screenPos.x, screenPos.y - size);
                    ctx.lineTo(screenPos.x - size, screenPos.y + size);
                    ctx.lineTo(screenPos.x + size, screenPos.y + size);
                    ctx.closePath();
                    ctx.fill();
                } else if (c.id === 'artifact') {
                    // Diamond
                    ctx.beginPath();
                    ctx.moveTo(screenPos.x, screenPos.y - size);
                    ctx.lineTo(screenPos.x + size, screenPos.y);
                    ctx.lineTo(screenPos.x, screenPos.y + size);
                    ctx.lineTo(screenPos.x - size, screenPos.y);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    // Circle for data core
                    ctx.beginPath();
                    ctx.arc(screenPos.x, screenPos.y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            ctx.restore();
        }

        function drawPOIs() {
            ctx.save();

            for (let poi of pois) {
                const dx = poi.x - player.x;
                const dy = poi.y - player.y;
                const dz = poi.z - player.z;

                const screenPos = project3D(dx, dy, dz);
                if (!screenPos) continue;

                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                const alpha = Math.max(0, 1 - distance / 100);

                ctx.globalAlpha = alpha;

                const size = poi.size * screenPos.scale * 5;

                // Draw POI based on type
                ctx.fillStyle = poi.color;

                if (poi.id === 'wreck') {
                    // Rectangle for shipwreck
                    ctx.fillRect(screenPos.x - size, screenPos.y - size * 0.5, size * 2, size);
                } else if (poi.id === 'cave') {
                    // Arch shape
                    ctx.beginPath();
                    ctx.arc(screenPos.x, screenPos.y, size, 0, Math.PI, true);
                    ctx.fill();
                } else if (poi.id === 'vent') {
                    // Pulsing vent with particles
                    const pulse = 1 + Math.sin(game.time * 3) * 0.3;
                    ctx.fillStyle = '#ff4400';
                    ctx.beginPath();
                    ctx.arc(screenPos.x, screenPos.y, size * pulse, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Generic shape
                    ctx.fillRect(screenPos.x - size, screenPos.y - size, size * 2, size * 2);
                }
            }

            ctx.restore();
        }

        function drawTerrain() {
            ctx.save();

            for (let t of terrain) {
                const dx = t.x - player.x;
                const dy = t.y - player.y;
                const dz = t.z - player.z;

                const screenPos = project3D(dx, dy, dz);
                if (!screenPos) continue;

                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                const alpha = Math.max(0, 1 - distance / 80);

                ctx.globalAlpha = alpha;

                const size = t.size * screenPos.scale * 3;

                ctx.fillStyle = t.color;

                if (t.type === 'coral') {
                    // Organic coral shape
                    for (let i = 0; i < 5; i++) {
                        const angle = (i / 5) * Math.PI * 2;
                        const r = size * (0.5 + Math.random() * 0.5);
                        ctx.beginPath();
                        ctx.arc(
                            screenPos.x + Math.cos(angle) * r * 0.5,
                            screenPos.y + Math.sin(angle) * r * 0.5,
                            r * 0.4,
                            0, Math.PI * 2
                        );
                        ctx.fill();
                    }
                } else {
                    // Rock or spire
                    ctx.fillRect(screenPos.x - size, screenPos.y - size, size * 2, size * 2);
                }
            }

            ctx.restore();
        }

        function drawCollectionPrompt() {
            ctx.save();
            ctx.globalAlpha = 0.8 + Math.sin(game.time * 4) * 0.2;
            ctx.fillStyle = '#00ffff';
            ctx.font = '24px "Courier New"';
            ctx.textAlign = 'center';
            ctx.fillText('[E] Collect', width / 2, height - 100);
            ctx.restore();
        }

        function applyScreenEffects(depth) {
            // Vignette
            const gradient = ctx.createRadialGradient(
                width / 2, height / 2, 0,
                width / 2, height / 2, width * 0.7
            );
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
            gradient.addColorStop(1, `rgba(0, 0, 0, ${Math.min(0.6, depth / 8000)})`);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);

            // Pressure distortion at extreme depths
            if (depth > 5000) {
                ctx.save();
                ctx.globalAlpha = (depth - 5000) / 3000 * 0.2;
                const distortAmount = Math.sin(game.time * 2) * 5;
                ctx.fillStyle = '#000033';
                ctx.fillRect(0, 0, width, height);
                ctx.restore();
            }

            // Scan lines
            ctx.save();
            ctx.globalAlpha = 0.05;
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 1;
            for (let y = 0; y < height; y += 4) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
            ctx.restore();
        }

        function project3D(dx, dy, dz) {
            // Rotate by player yaw and pitch
            const cos = Math.cos(-player.yaw);
            const sin = Math.sin(-player.yaw);
            const rotX = dx * cos - dz * sin;
            const rotZ = dx * sin + dz * cos;

            const cosPitch = Math.cos(-player.pitch);
            const sinPitch = Math.sin(-player.pitch);
            const rotY = dy * cosPitch - rotZ * sinPitch;
            const finalZ = dy * sinPitch + rotZ * cosPitch;

            // Don't render behind camera
            if (finalZ < camera.near) return null;

            // Perspective projection
            const scale = (camera.fov * height) / (finalZ + camera.fov);
            const screenX = width / 2 + rotX * scale;
            const screenY = height / 2 + rotY * scale;

            // Cull off-screen
            if (screenX < -100 || screenX > width + 100 || screenY < -100 || screenY > height + 100) {
                return null;
            }

            return { x: screenX, y: screenY, scale: Math.max(0.1, scale / 100) };
        }

        // ============================================================================
        // MAKE UPGRADE FUNCTION GLOBAL
        // ============================================================================

        window.upgradeItem = upgradeItem;

        // ============================================================================
        // START GAME
        // ============================================================================

        init();
    </script>
</body>
</html>