<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Recursive fractal city builder using L-system fractals with infinite zoom, interdimensional citizens, and rippling day/night cycles">
    <!-- 3d, simulation, fractal, generative, threejs, webgl, procedural -->
    <title>Recursive Fractal City Builder</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: 'SF Mono', 'Consolas', monospace;
            color: #fff;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .ui-panel {
            position: fixed;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 16px;
            z-index: 100;
        }

        .top-panel {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 30px;
        }

        .title {
            font-size: 1.1rem;
            font-weight: 600;
            background: linear-gradient(90deg, #00d4ff, #7b2fff, #ff2d95);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .dimension-display {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .dimension-level {
            font-size: 2rem;
            font-weight: bold;
            color: #00d4ff;
            text-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
        }

        .dimension-label {
            font-size: 0.7rem;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .stats-row {
            display: flex;
            gap: 20px;
        }

        .stat {
            text-align: center;
        }

        .stat-value {
            font-size: 1.2rem;
            color: #7b2fff;
        }

        .stat-label {
            font-size: 0.6rem;
            color: #555;
            text-transform: uppercase;
        }

        .side-panel {
            top: 20px;
            right: 20px;
            width: 240px;
        }

        .section {
            margin-bottom: 16px;
        }

        .section:last-child {
            margin-bottom: 0;
        }

        .section-title {
            font-size: 0.7rem;
            color: #7b2fff;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        .time-bar {
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
            margin: 8px 0;
        }

        .time-progress {
            height: 100%;
            background: linear-gradient(90deg, #ff9500, #ffcc00, #00d4ff);
            border-radius: 2px;
            transition: width 0.1s;
        }

        .layer-stack {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .layer-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .layer-item:hover {
            background: rgba(123, 47, 255, 0.2);
        }

        .layer-item.active {
            background: rgba(0, 212, 255, 0.2);
            border: 1px solid rgba(0, 212, 255, 0.3);
        }

        .layer-time {
            font-size: 0.65rem;
            color: #666;
        }

        .btn {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.8rem;
            font-weight: 600;
            transition: all 0.2s;
            margin-top: 6px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #7b2fff, #00d4ff);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(123, 47, 255, 0.4);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #aaa;
        }

        .zoom-hint {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 12px 24px;
            border-radius: 20px;
            font-size: 0.75rem;
            color: #666;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .zoom-hint kbd {
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 8px;
            border-radius: 4px;
            margin: 0 4px;
        }

        .portal-indicator {
            position: fixed;
            pointer-events: none;
            border: 2px solid rgba(0, 212, 255, 0.5);
            border-radius: 4px;
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.3), inset 0 0 20px rgba(0, 212, 255, 0.1);
            transition: all 0.3s;
            display: none;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1rem;
            color: #7b2fff;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        .dimension-transition {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 0%, #000 100%);
            pointer-events: none;
            opacity: 0;
            z-index: 50;
            transition: opacity 0.5s;
        }

        .dimension-transition.active {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div class="dimension-transition" id="transition"></div>
    <div class="loading" id="loading">Generating Fractal City...</div>

    <div class="ui-panel top-panel">
        <div class="title">FRACTAL CITY</div>
        <div class="dimension-display">
            <div>
                <div class="dimension-level" id="dimensionLevel">0</div>
                <div class="dimension-label">Dimension</div>
            </div>
        </div>
        <div class="stats-row">
            <div class="stat">
                <div class="stat-value" id="buildingCount">0</div>
                <div class="stat-label">Buildings</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="citizenCount">0</div>
                <div class="stat-label">Citizens</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="trafficFlow">0</div>
                <div class="stat-label">Traffic</div>
            </div>
        </div>
    </div>

    <div class="ui-panel side-panel">
        <div class="section">
            <div class="section-title">Dimensional Time</div>
            <div class="time-bar">
                <div class="time-progress" id="timeProgress" style="width: 50%"></div>
            </div>
            <div style="display:flex;justify-content:space-between;font-size:0.7rem;color:#555;">
                <span id="timeOfDay">12:00</span>
                <span id="dayPhase">Day</span>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Dimension Stack</div>
            <div class="layer-stack" id="layerStack">
                <div class="layer-item active">
                    <span>Layer 0 - Root City</span>
                    <span class="layer-time">1x</span>
                </div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">L-System Seed</div>
            <div style="font-family:monospace;font-size:0.7rem;color:#00d4ff;word-break:break-all;" id="lsystemSeed">
                F→F[+F]F[-F]F
            </div>
        </div>

        <div class="section">
            <button class="btn btn-primary" id="regenerateBtn">Regenerate City</button>
            <button class="btn btn-secondary" id="resetViewBtn">Reset View</button>
        </div>
    </div>

    <div class="zoom-hint">
        <kbd>Scroll</kbd> to zoom · <kbd>Click Building</kbd> to enter dimension · <kbd>ESC</kbd> to ascend
    </div>

    <div class="portal-indicator" id="portalIndicator"></div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // ===== MATHEMATICAL CONSTANTS =====
        const PHI = (1 + Math.sqrt(5)) / 2;
        const GOLDEN_ANGLE = Math.PI * (3 - Math.sqrt(5));
        const FIBONACCI = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144];

        // ===== L-SYSTEM ENGINE =====
        class LSystem {
            constructor(axiom, rules, angle = 25) {
                this.axiom = axiom;
                this.rules = rules;
                this.angle = angle * Math.PI / 180;
            }

            generate(iterations) {
                let current = this.axiom;
                for (let i = 0; i < iterations; i++) {
                    let next = '';
                    for (const char of current) {
                        next += this.rules[char] || char;
                    }
                    current = next;
                }
                return current;
            }

            // Interpret L-system string into city layout
            interpret(str, scale = 1) {
                const buildings = [];
                const streets = [];
                const stack = [];

                let x = 0, z = 0;
                let angle = 0;
                let currentStreet = [{ x: 0, z: 0 }];

                for (const char of str) {
                    switch (char) {
                        case 'F': // Move forward, create street segment
                            const newX = x + Math.cos(angle) * scale;
                            const newZ = z + Math.sin(angle) * scale;
                            currentStreet.push({ x: newX, z: newZ });
                            x = newX;
                            z = newZ;
                            break;

                        case 'B': // Building
                            buildings.push({
                                x: x + (Math.random() - 0.5) * scale * 0.5,
                                z: z + (Math.random() - 0.5) * scale * 0.5,
                                height: (0.5 + Math.random() * 1.5) * scale,
                                width: (0.3 + Math.random() * 0.4) * scale,
                                depth: (0.3 + Math.random() * 0.4) * scale,
                                style: Math.floor(Math.random() * 4)
                            });
                            break;

                        case '+': // Turn right
                            angle += this.angle;
                            break;

                        case '-': // Turn left
                            angle -= this.angle;
                            break;

                        case '[': // Save state
                            stack.push({ x, z, angle, street: [...currentStreet] });
                            if (currentStreet.length > 1) {
                                streets.push([...currentStreet]);
                            }
                            currentStreet = [{ x, z }];
                            break;

                        case ']': // Restore state
                            if (currentStreet.length > 1) {
                                streets.push([...currentStreet]);
                            }
                            const state = stack.pop();
                            if (state) {
                                x = state.x;
                                z = state.z;
                                angle = state.angle;
                                currentStreet = [{ x, z }];
                            }
                            break;

                        case 'R': // Rotate by golden angle
                            angle += GOLDEN_ANGLE;
                            break;

                        case 'P': // Plaza (open space with buildings around)
                            for (let i = 0; i < 5; i++) {
                                const pAngle = i * GOLDEN_ANGLE;
                                const pDist = scale * (0.8 + Math.random() * 0.4);
                                buildings.push({
                                    x: x + Math.cos(pAngle) * pDist,
                                    z: z + Math.sin(pAngle) * pDist,
                                    height: (0.8 + Math.random() * 2) * scale,
                                    width: (0.4 + Math.random() * 0.3) * scale,
                                    depth: (0.4 + Math.random() * 0.3) * scale,
                                    style: Math.floor(Math.random() * 4),
                                    isLandmark: i === 0
                                });
                            }
                            break;
                    }
                }

                if (currentStreet.length > 1) {
                    streets.push(currentStreet);
                }

                return { buildings, streets };
            }
        }

        // City generation L-system rules (multiple styles)
        const CITY_GRAMMARS = [
            { // Grid city
                axiom: 'X',
                rules: {
                    'X': 'FB[+X][-X]FBX',
                    'F': 'FF'
                },
                angle: 90
            },
            { // Organic city
                axiom: 'X',
                rules: {
                    'X': 'FB[+X]FB[-X]+FBX',
                    'F': 'F'
                },
                angle: 25.7
            },
            { // Spiral city
                axiom: 'X',
                rules: {
                    'X': 'FBRX',
                    'F': 'F'
                },
                angle: 15
            },
            { // Plaza-based city
                axiom: 'P',
                rules: {
                    'P': 'F[+FBFBP][-FBFBP]FBP',
                    'F': 'F'
                },
                angle: 72
            },
            { // Fractal branching
                axiom: 'X',
                rules: {
                    'X': 'FB[-X][+X]FBX',
                    'F': 'FF'
                },
                angle: 30
            }
        ];

        // ===== FRACTAL DIMENSION SYSTEM =====
        class FractalDimension {
            constructor(level, parentBuilding = null, seed = Math.random()) {
                this.level = level;
                this.parentBuilding = parentBuilding;
                this.seed = seed;
                this.timeScale = Math.pow(PHI, level); // Time flows faster in deeper dimensions
                this.localTime = 0;

                // Generate city using L-system
                this.grammarIndex = Math.floor(seed * CITY_GRAMMARS.length);
                const grammar = CITY_GRAMMARS[this.grammarIndex];
                this.lsystem = new LSystem(grammar.axiom, grammar.rules, grammar.angle);

                // Fewer iterations for deeper levels (performance)
                const iterations = Math.max(2, 5 - level);
                const scale = 2 / Math.pow(PHI, level * 0.5);

                const lsystemStr = this.lsystem.generate(iterations);
                const layout = this.lsystem.interpret(lsystemStr, scale);

                this.buildings = layout.buildings;
                this.streets = layout.streets;
                this.citizens = [];
                this.trafficDensity = 0;

                // Each building can be a portal to a deeper dimension
                this.childDimensions = new Map();

                // 3D objects
                this.group = new THREE.Group();
                this.buildingMeshes = [];

                this.generateMeshes();
                this.spawnCitizens(Math.floor(20 / (level + 1)));
            }

            generateMeshes() {
                const buildingMaterial = (style, isLandmark) => {
                    const colors = [0x1a1a2e, 0x16213e, 0x0f3460, 0x1a1a3e];
                    const emissiveColors = [0x001133, 0x002244, 0x003355, 0x002233];

                    return new THREE.MeshStandardMaterial({
                        color: isLandmark ? 0x7b2fff : colors[style % colors.length],
                        emissive: isLandmark ? 0x3a1a7e : emissiveColors[style % emissiveColors.length],
                        emissiveIntensity: 0.3,
                        metalness: 0.3,
                        roughness: 0.7
                    });
                };

                // Generate buildings
                for (const b of this.buildings) {
                    const geometry = new THREE.BoxGeometry(b.width, b.height, b.depth);
                    const material = buildingMaterial(b.style, b.isLandmark);
                    const mesh = new THREE.Mesh(geometry, material);

                    mesh.position.set(b.x, b.height / 2, b.z);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;

                    // Store building data for portal detection
                    mesh.userData = {
                        isBuilding: true,
                        buildingData: b,
                        dimension: this
                    };

                    this.buildingMeshes.push(mesh);
                    this.group.add(mesh);

                    // Add window lights
                    this.addWindowLights(mesh, b);
                }

                // Generate streets
                const streetMaterial = new THREE.MeshStandardMaterial({
                    color: 0x222233,
                    roughness: 0.9,
                    metalness: 0.1
                });

                for (const street of this.streets) {
                    if (street.length < 2) continue;

                    for (let i = 0; i < street.length - 1; i++) {
                        const start = street[i];
                        const end = street[i + 1];
                        const length = Math.hypot(end.x - start.x, end.z - start.z);
                        const angle = Math.atan2(end.z - start.z, end.x - start.x);

                        const streetGeo = new THREE.BoxGeometry(length, 0.02, 0.3);
                        const streetMesh = new THREE.Mesh(streetGeo, streetMaterial);

                        streetMesh.position.set(
                            (start.x + end.x) / 2,
                            0.01,
                            (start.z + end.z) / 2
                        );
                        streetMesh.rotation.y = -angle;
                        streetMesh.receiveShadow = true;

                        this.group.add(streetMesh);
                    }
                }

                // Ground plane
                const groundGeo = new THREE.PlaneGeometry(50, 50);
                const groundMat = new THREE.MeshStandardMaterial({
                    color: 0x0a0a12,
                    roughness: 0.95
                });
                const ground = new THREE.Mesh(groundGeo, groundMat);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                this.group.add(ground);
            }

            addWindowLights(buildingMesh, buildingData) {
                const windowRows = Math.floor(buildingData.height * 3);
                const windowCols = Math.floor(buildingData.width * 4);

                const windowGeometry = new THREE.PlaneGeometry(0.05, 0.08);

                for (let row = 0; row < windowRows; row++) {
                    for (let col = 0; col < windowCols; col++) {
                        if (Math.random() > 0.6) continue; // Not all windows lit

                        const windowMaterial = new THREE.MeshBasicMaterial({
                            color: Math.random() > 0.3 ? 0xffdd88 : 0x88ddff,
                            transparent: true,
                            opacity: 0.8
                        });

                        const windowMesh = new THREE.Mesh(windowGeometry, windowMaterial);

                        // Position on building face
                        const face = Math.floor(Math.random() * 4);
                        const yPos = (row + 0.5) * (buildingData.height / windowRows) * 0.8 + 0.1;

                        switch (face) {
                            case 0: // Front
                                windowMesh.position.set(
                                    (col - windowCols / 2) * 0.1,
                                    yPos - buildingData.height / 2,
                                    buildingData.depth / 2 + 0.01
                                );
                                break;
                            case 1: // Back
                                windowMesh.position.set(
                                    (col - windowCols / 2) * 0.1,
                                    yPos - buildingData.height / 2,
                                    -buildingData.depth / 2 - 0.01
                                );
                                windowMesh.rotation.y = Math.PI;
                                break;
                            case 2: // Left
                                windowMesh.position.set(
                                    -buildingData.width / 2 - 0.01,
                                    yPos - buildingData.height / 2,
                                    (col - windowCols / 2) * 0.1
                                );
                                windowMesh.rotation.y = -Math.PI / 2;
                                break;
                            case 3: // Right
                                windowMesh.position.set(
                                    buildingData.width / 2 + 0.01,
                                    yPos - buildingData.height / 2,
                                    (col - windowCols / 2) * 0.1
                                );
                                windowMesh.rotation.y = Math.PI / 2;
                                break;
                        }

                        // Store for day/night updates
                        windowMesh.userData.isWindow = true;
                        windowMesh.userData.baseOpacity = windowMaterial.opacity;

                        buildingMesh.add(windowMesh);
                    }
                }
            }

            spawnCitizens(count) {
                for (let i = 0; i < count; i++) {
                    if (this.streets.length === 0) break;

                    const streetIdx = Math.floor(Math.random() * this.streets.length);
                    const street = this.streets[streetIdx];
                    if (street.length < 2) continue;

                    const segmentIdx = Math.floor(Math.random() * (street.length - 1));
                    const t = Math.random();
                    const start = street[segmentIdx];
                    const end = street[segmentIdx + 1];

                    this.citizens.push({
                        x: start.x + (end.x - start.x) * t,
                        z: start.z + (end.z - start.z) * t,
                        streetIdx,
                        segmentIdx,
                        t,
                        speed: 0.001 + Math.random() * 0.002,
                        direction: Math.random() > 0.5 ? 1 : -1,
                        dimension: this.level,
                        mesh: null,
                        commuting: false,
                        targetDimension: null
                    });
                }

                // Create instanced mesh for citizens
                if (this.citizens.length > 0) {
                    const citizenGeo = new THREE.SphereGeometry(0.03, 8, 6);
                    const citizenMat = new THREE.MeshBasicMaterial({ color: 0x00d4ff });

                    this.citizenMesh = new THREE.InstancedMesh(citizenGeo, citizenMat, this.citizens.length);
                    this.group.add(this.citizenMesh);
                }
            }

            updateCitizens(dt) {
                if (!this.citizenMesh || this.streets.length === 0) return;

                const dummy = new THREE.Object3D();
                let trafficCount = 0;

                for (let i = 0; i < this.citizens.length; i++) {
                    const citizen = this.citizens[i];

                    // Move along street
                    citizen.t += citizen.speed * citizen.direction * dt * 60;

                    // Handle segment transitions
                    const street = this.streets[citizen.streetIdx];
                    if (!street) continue;

                    if (citizen.t > 1) {
                        citizen.t = 0;
                        citizen.segmentIdx += 1;
                        if (citizen.segmentIdx >= street.length - 1) {
                            // End of street - turn around or switch streets
                            if (Math.random() > 0.3 && this.streets.length > 1) {
                                citizen.streetIdx = Math.floor(Math.random() * this.streets.length);
                                citizen.segmentIdx = 0;
                            } else {
                                citizen.segmentIdx = street.length - 2;
                                citizen.direction *= -1;
                            }
                        }
                    } else if (citizen.t < 0) {
                        citizen.t = 1;
                        citizen.segmentIdx -= 1;
                        if (citizen.segmentIdx < 0) {
                            if (Math.random() > 0.3 && this.streets.length > 1) {
                                citizen.streetIdx = Math.floor(Math.random() * this.streets.length);
                                citizen.segmentIdx = 0;
                            } else {
                                citizen.segmentIdx = 0;
                                citizen.direction *= -1;
                            }
                        }
                    }

                    // Interpolate position
                    const seg = this.streets[citizen.streetIdx];
                    if (seg && citizen.segmentIdx < seg.length - 1) {
                        const start = seg[citizen.segmentIdx];
                        const end = seg[citizen.segmentIdx + 1];
                        citizen.x = start.x + (end.x - start.x) * citizen.t;
                        citizen.z = start.z + (end.z - start.z) * citizen.t;
                    }

                    // Update instance matrix
                    dummy.position.set(citizen.x, 0.05, citizen.z);
                    dummy.updateMatrix();
                    this.citizenMesh.setMatrixAt(i, dummy.matrix);

                    trafficCount++;
                }

                this.citizenMesh.instanceMatrix.needsUpdate = true;
                this.trafficDensity = trafficCount;
            }

            updateDayNight(globalTime) {
                // Time flows at different rates per dimension level
                this.localTime = globalTime * this.timeScale;

                // Day/night cycle (full cycle = 60 seconds base)
                const cyclePosition = (this.localTime % 60000) / 60000;
                const daylight = Math.sin(cyclePosition * Math.PI * 2 - Math.PI / 2) * 0.5 + 0.5;

                // Update window lights based on time
                for (const building of this.buildingMeshes) {
                    building.traverse((child) => {
                        if (child.userData.isWindow) {
                            // Windows brighter at night
                            const nightIntensity = 1 - daylight;
                            child.material.opacity = child.userData.baseOpacity * (0.2 + nightIntensity * 0.8);
                        }
                    });

                    // Building emissive based on time
                    if (building.material.emissive) {
                        building.material.emissiveIntensity = 0.1 + (1 - daylight) * 0.4;
                    }
                }

                return { cyclePosition, daylight };
            }

            getChildDimension(building) {
                const key = `${building.x},${building.z}`;
                if (!this.childDimensions.has(key)) {
                    // Create new dimension inside this building
                    const childSeed = this.seed + building.x * 1000 + building.z;
                    const childDim = new FractalDimension(this.level + 1, building, childSeed);
                    this.childDimensions.set(key, childDim);
                }
                return this.childDimensions.get(key);
            }
        }

        // ===== THREE.JS SETUP =====
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000008);
        scene.fog = new THREE.FogExp2(0x000008, 0.05);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 1000);
        camera.position.set(0, 8, 12);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI * 0.45;
        controls.minDistance = 2;
        controls.maxDistance = 50;

        // ===== LIGHTING =====
        const ambientLight = new THREE.AmbientLight(0x111122, 0.4);
        scene.add(ambientLight);

        const moonLight = new THREE.DirectionalLight(0x4466aa, 0.3);
        moonLight.position.set(-10, 20, -10);
        scene.add(moonLight);

        const sunLight = new THREE.DirectionalLight(0xffffee, 0.8);
        sunLight.position.set(10, 30, 10);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 1;
        sunLight.shadow.camera.far = 100;
        sunLight.shadow.camera.left = -30;
        sunLight.shadow.camera.right = 30;
        sunLight.shadow.camera.top = 30;
        sunLight.shadow.camera.bottom = -30;
        scene.add(sunLight);

        // Atmospheric glow
        const glowLight = new THREE.PointLight(0x7b2fff, 0.5, 50);
        glowLight.position.set(0, 5, 0);
        scene.add(glowLight);

        // ===== DIMENSION MANAGEMENT =====
        let currentDimension = null;
        let dimensionStack = [];
        let globalTime = 0;
        let hoveredBuilding = null;

        function initCity() {
            currentDimension = new FractalDimension(0);
            dimensionStack = [currentDimension];
            scene.add(currentDimension.group);

            updateDimensionUI();
            document.getElementById('loading').style.display = 'none';
        }

        function descendIntoDimension(building) {
            if (!building || currentDimension.level >= 5) return; // Max depth

            const transition = document.getElementById('transition');
            transition.classList.add('active');

            setTimeout(() => {
                // Get or create child dimension
                const childDimension = currentDimension.getChildDimension(building);

                // Hide current, show child
                currentDimension.group.visible = false;
                scene.add(childDimension.group);

                dimensionStack.push(childDimension);
                currentDimension = childDimension;

                // Reset camera
                camera.position.set(0, 5 / Math.pow(PHI, currentDimension.level), 8 / Math.pow(PHI, currentDimension.level));
                controls.target.set(0, 0, 0);
                controls.update();

                updateDimensionUI();

                setTimeout(() => {
                    transition.classList.remove('active');
                }, 300);
            }, 300);
        }

        function ascendDimension() {
            if (dimensionStack.length <= 1) return;

            const transition = document.getElementById('transition');
            transition.classList.add('active');

            setTimeout(() => {
                // Hide current
                currentDimension.group.visible = false;

                // Pop and go to parent
                dimensionStack.pop();
                currentDimension = dimensionStack[dimensionStack.length - 1];
                currentDimension.group.visible = true;

                // Reset camera
                camera.position.set(0, 8, 12);
                controls.target.set(0, 0, 0);
                controls.update();

                updateDimensionUI();

                setTimeout(() => {
                    transition.classList.remove('active');
                }, 300);
            }, 300);
        }

        function updateDimensionUI() {
            document.getElementById('dimensionLevel').textContent = currentDimension.level;
            document.getElementById('buildingCount').textContent = currentDimension.buildings.length;
            document.getElementById('citizenCount').textContent = currentDimension.citizens.length;

            // Update L-system display
            const grammar = CITY_GRAMMARS[currentDimension.grammarIndex];
            let ruleStr = '';
            for (const [key, val] of Object.entries(grammar.rules)) {
                ruleStr += `${key}→${val} `;
            }
            document.getElementById('lsystemSeed').textContent = ruleStr.trim();

            // Update layer stack
            const stackEl = document.getElementById('layerStack');
            stackEl.innerHTML = '';
            for (let i = 0; i < dimensionStack.length; i++) {
                const dim = dimensionStack[i];
                const layerEl = document.createElement('div');
                layerEl.className = 'layer-item' + (i === dimensionStack.length - 1 ? ' active' : '');
                layerEl.innerHTML = `
                    <span>Layer ${dim.level}${dim.level === 0 ? ' - Root' : ''}</span>
                    <span class="layer-time">${dim.timeScale.toFixed(1)}x</span>
                `;
                layerEl.onclick = () => {
                    // Navigate to this layer
                    while (dimensionStack.length > i + 1) {
                        ascendDimension();
                    }
                };
                stackEl.appendChild(layerEl);
            }
        }

        // ===== RAYCASTING FOR BUILDING SELECTION =====
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const portalIndicator = document.getElementById('portalIndicator');

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(currentDimension.buildingMeshes);

            if (intersects.length > 0) {
                const building = intersects[0].object;
                hoveredBuilding = building.userData.buildingData;

                // Show portal indicator
                const screenPos = building.position.clone().project(camera);
                const x = (screenPos.x + 1) / 2 * window.innerWidth;
                const y = (-screenPos.y + 1) / 2 * window.innerHeight;

                portalIndicator.style.display = 'block';
                portalIndicator.style.left = (x - 30) + 'px';
                portalIndicator.style.top = (y - 40) + 'px';
                portalIndicator.style.width = '60px';
                portalIndicator.style.height = '80px';

                document.body.style.cursor = 'pointer';
            } else {
                hoveredBuilding = null;
                portalIndicator.style.display = 'none';
                document.body.style.cursor = 'default';
            }
        }

        function onClick(event) {
            if (hoveredBuilding && currentDimension.level < 5) {
                descendIntoDimension(hoveredBuilding);
            }
        }

        renderer.domElement.addEventListener('mousemove', onMouseMove);
        renderer.domElement.addEventListener('click', onClick);

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                ascendDimension();
            }
        });

        // ===== UI CONTROLS =====
        document.getElementById('regenerateBtn').addEventListener('click', () => {
            // Remove all dimensions
            for (const dim of dimensionStack) {
                scene.remove(dim.group);
            }

            // Create new city
            initCity();
        });

        document.getElementById('resetViewBtn').addEventListener('click', () => {
            camera.position.set(0, 8, 12);
            controls.target.set(0, 0, 0);
            controls.update();
        });

        // ===== WINDOW RESIZE =====
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ===== ANIMATION LOOP =====
        let lastTime = 0;

        function animate(time) {
            requestAnimationFrame(animate);

            const dt = Math.min((time - lastTime) / 1000, 0.1);
            lastTime = time;
            globalTime += dt * 1000;

            controls.update();

            if (currentDimension) {
                // Update all visible dimensions
                for (const dim of dimensionStack) {
                    if (dim.group.visible) {
                        dim.updateCitizens(dt);
                        const timeInfo = dim.updateDayNight(globalTime);

                        if (dim === currentDimension) {
                            // Update time display
                            const hours = Math.floor(timeInfo.cyclePosition * 24);
                            const mins = Math.floor((timeInfo.cyclePosition * 24 % 1) * 60);
                            document.getElementById('timeOfDay').textContent =
                                `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;
                            document.getElementById('dayPhase').textContent =
                                timeInfo.daylight > 0.5 ? 'Day' : 'Night';
                            document.getElementById('timeProgress').style.width =
                                (timeInfo.cyclePosition * 100) + '%';
                            document.getElementById('trafficFlow').textContent = dim.trafficDensity;

                            // Update lighting based on day/night
                            sunLight.intensity = timeInfo.daylight * 0.8;
                            moonLight.intensity = (1 - timeInfo.daylight) * 0.4;
                            ambientLight.intensity = 0.2 + timeInfo.daylight * 0.3;

                            scene.background.setHSL(0.65, 0.3, timeInfo.daylight * 0.02 + 0.01);
                        }
                    }
                }
            }

            renderer.render(scene, camera);
        }

        // Initialize
        initCity();
        animate(0);
    </script>
</body>
</html>
