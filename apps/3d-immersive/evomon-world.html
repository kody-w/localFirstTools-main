<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EvoMon World: 3D RPG</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; user-select: none; }
        #canvas { width: 100vw; height: 100vh; display: block; }
        
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        
        .panel {
            background: rgba(0, 20, 40, 0.85);
            border: 2px solid #00ffff;
            padding: 15px;
            border-radius: 12px;
            pointer-events: auto;
            color: #fff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
        }
        
        /* HUD */
        #hud-top {
            display: flex;
            justify-content: space-between;
            padding: 20px;
        }
        
        #player-card {
            width: 250px;
        }
        
        .stat-bar {
            height: 8px;
            background: #333;
            border-radius: 4px;
            margin-top: 5px;
            overflow: hidden;
        }
        .stat-fill { height: 100%; transition: width 0.3s; }
        .hp-fill { background: #ff4444; }
        .xp-fill { background: #4444ff; }
        
        /* Battle UI */
        #battle-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 10;
        }
        
        #battle-box {
            width: 800px;
            height: 500px;
            background: #111;
            border: 4px solid #444;
            border-radius: 20px;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        #battle-scene {
            flex-grow: 1;
            background: linear-gradient(#223, #112);
            position: relative;
        }
        
        .battler {
            width: 150px;
            height: 150px;
            position: absolute;
            bottom: 50px;
        }
        #player-battler { left: 50px; }
        #enemy-battler { right: 50px; filter: hue-rotate(180deg); } /* Placeholder visual diff */
        
        #battle-controls {
            height: 150px;
            background: #222;
            border-top: 4px solid #444;
            padding: 20px;
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
        }
        
        #battle-log {
            background: #000;
            border: 2px solid #444;
            border-radius: 8px;
            padding: 10px;
            font-family: monospace;
            color: #fff;
            overflow-y: auto;
        }
        
        #action-menu {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        button {
            background: #333;
            color: #fff;
            border: 2px solid #555;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.1s;
        }
        button:hover { background: #444; border-color: #fff; }
        button:active { transform: scale(0.98); }
        .btn-attack { border-color: #ff4444; }
        .btn-flee { border-color: #4444ff; }
        
        /* Evolution Modal */
        #evo-modal {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 20, 40, 0.95);
            border: 4px solid #00ffff;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            display: none;
            z-index: 20;
            color: #fff;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.3);
        }
        
        #mini-map {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #fff;
            border-radius: 50%;
            overflow: hidden;
        }
        #mm-canvas { width: 100%; height: 100%; }
        
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="ui-layer">
        <div id="hud-top">
            <div id="player-card" class="panel">
                <h3 style="margin:0">EvoCreature</h3>
                <div style="font-size: 12px; color: #aaa;">Lvl <span id="lvl-val">1</span></div>
                <div style="font-size: 10px; color: #555;">Input: <span id="debug-key">-</span></div>
                <div class="stat-bar"><div class="stat-fill hp-fill" id="hp-bar" style="width: 100%"></div></div>
                <div class="stat-bar"><div class="stat-fill xp-fill" id="xp-bar" style="width: 0%"></div></div>
                <div style="margin-top: 10px; display: flex; gap: 5px;">
                    <button onclick="game.exportSave()" style="font-size: 10px; padding: 2px 5px;">EXPORT</button>
                    <button onclick="document.getElementById('import-file').click()" style="font-size: 10px; padding: 2px 5px;">IMPORT</button>
                    <input type="file" id="import-file" style="display: none" onchange="game.importSave(this)">
                </div>
            </div>
        </div>
        
        <div id="mini-map">
            <canvas id="mm-canvas"></canvas>
        </div>
    </div>
    
    <div id="battle-overlay">
        <div id="battle-box">
            <div id="battle-scene">
                <div id="player-battler"></div> <!-- Will contain Canvas -->
                <div id="enemy-battler"></div> <!-- Will contain Canvas -->
                
                <div style="position: absolute; top: 20px; left: 20px; color: white; text-shadow: 2px 2px 0 #000;">
                    <h3>You</h3>
                    <div style="width: 150px; height: 10px; background: #333;"><div id="battle-player-hp" style="width: 100%; height: 100%; background: #0f0;"></div></div>
                </div>
                
                <div style="position: absolute; top: 20px; right: 20px; color: white; text-align: right; text-shadow: 2px 2px 0 #000;">
                    <h3 id="battle-enemy-name">Wild Beast</h3>
                    <div style="width: 150px; height: 10px; background: #333; display: inline-block;"><div id="battle-enemy-hp" style="width: 100%; height: 100%; background: #f00;"></div></div>
                </div>
            </div>
            <div id="battle-controls">
                <div id="battle-log">A wild creature appeared!</div>
                <div id="action-menu">
                    <button class="btn-attack" onclick="game.battleAction('attack')">ATTACK</button>
                    <button onclick="game.battleAction('defend')">DEFEND</button>
                    <button class="btn-flee" onclick="game.battleAction('flee')">FLEE</button>
                </div>
            </div>
        </div>
    </div>
    
    <div id="evo-modal">
        <h1 style="color: #00ffff; margin: 0;">EVOLUTION!</h1>
        <div id="evo-canvas-container" style="width: 300px; height: 300px; margin: 20px auto; border: 2px solid #00ffff; border-radius: 10px; overflow: hidden; position: relative;">
            <div style="position: absolute; top: 10px; left: 0; width: 100%; text-align: center; pointer-events: none;">
                <span id="evo-label" style="background: rgba(0,0,0,0.7); padding: 2px 8px; border-radius: 4px; font-size: 12px; color: #fff;">AFTER</span>
            </div>
        </div>
        <div style="display: flex; justify-content: center; gap: 10px; margin-bottom: 20px;">
            <button onclick="game.toggleEvoView('before')" style="font-size: 14px; padding: 5px 15px;">BEFORE</button>
            <button onclick="game.toggleEvoView('compare')" style="font-size: 14px; padding: 5px 15px;">COMPARE</button>
            <button onclick="game.toggleEvoView('after')" style="font-size: 14px; padding: 5px 15px;">AFTER</button>
        </div>
        <p id="evo-text" style="font-size: 18px; margin-bottom: 30px;">Your creature has adapted.</p>
        <button onclick="game.closeEvolution()" style="padding: 10px 30px; font-size: 20px;">CONTINUE</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <script>
        // --- Game Engine ---
        
        class Game {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.player = null;
                this.world = null;
                this.clock = new THREE.Clock();
                this.keys = {};
                this.state = 'roam'; // roam, battle, evolve
                
                this.playerStats = this.loadGame() || {
                    level: 15,
                    xp: 450,
                    hp: 250,
                    maxHp: 250,
                    atk: 40,
                    def: 20,
                    spd: 15,
                    genome: {
                      aggression: 0.8,
                      resilience: 0.7,
                      agility: 0.6,
                      element: 0.9
                    },
                    history: {
                      damageTaken: 5,
                      damageDealt: 120,
                      fled: 2,
                      biomeTime: {
                        forest: 120,
                        snow: 300
                      }
                    },
                    evolutionLog: [
                      {
                        gen: 1,
                        timestamp: "2024-05-20T10:00:00.000Z",
                        event: "Generation 1 Created",
                        details: "Initial Spawn",
                        genome: {
                          aggression: 0.2,
                          resilience: 0.2,
                          agility: 0.2,
                          element: 0.5
                        },
                        level: 1
                      },
                      {
                        gen: 2,
                        timestamp: "2024-05-20T10:15:00.000Z",
                        event: "Battle Adaptation",
                        details: "Claws Sharpened (+Aggression)",
                        genome: {
                          aggression: 0.3,
                          resilience: 0.2,
                          agility: 0.2,
                          element: 0.5
                        },
                        level: 3
                      },
                      {
                        gen: 3,
                        timestamp: "2024-05-20T10:45:00.000Z",
                        event: "Biome Adaptation",
                        details: "Adapted to Cold: Fur Grown",
                        genome: {
                          aggression: 0.3,
                          resilience: 0.3,
                          agility: 0.2,
                          element: 0.4
                        },
                        level: 5
                      },
                      {
                        gen: 4,
                        timestamp: "2024-05-20T11:30:00.000Z",
                        event: "Fossil Absorption",
                        details: "Traits Merged with Ancient DNA",
                        genome: {
                          aggression: 0.5,
                          resilience: 0.5,
                          agility: 0.3,
                          element: 0.4
                        },
                        level: 8
                      },
                      {
                        gen: 5,
                        timestamp: "2024-05-20T12:15:00.000Z",
                        event: "Battle Adaptation",
                        details: "Legs Strengthened (+Agility), Skin Hardened (+Resilience)",
                        genome: {
                          aggression: 0.8,
                          resilience: 0.7,
                          agility: 0.6,
                          element: 0.9
                        },
                        level: 15
                      }
                    ]
                };
                
                if (this.playerStats.evolutionLog.length === 0) {
                     this.playerStats.evolutionLog.push({
                        gen: 1,
                        timestamp: new Date().toISOString(),
                        event: "Generation 1 Created",
                        genome: JSON.parse(JSON.stringify(this.playerStats.genome)),
                        level: 1
                    });
                }
                
                this.evoScene = null;
                this.evoCamera = null;
                this.evoRenderer = null;
                this.evoPlayerBefore = null;
                this.evoPlayerAfter = null;
                this.evoView = 'after'; // 'before', 'after', 'compare'
                this.evoFocus = 'default';
                this.evoDiff = {};
                this.evoOldGenome = null;
                
                this.init();
            }
            
            logEvolution(event, details) {
                const currentGen = this.playerStats.evolutionLog.length + 1;
                this.playerStats.evolutionLog.push({
                    gen: currentGen,
                    timestamp: new Date().toISOString(),
                    event: event,
                    details: details,
                    genome: JSON.parse(JSON.stringify(this.playerStats.genome)),
                    level: this.playerStats.level
                });
            }
            
            saveGame() {
                try {
                    localStorage.setItem('evomon_save', JSON.stringify(this.playerStats));
                } catch (e) {
                    if (!this.saveWarningShown) {
                        console.warn("Save failed (Storage Quota/Blocked). Progress will not persist.");
                        this.saveWarningShown = true;
                        
                        const card = document.getElementById('player-card');
                        let err = document.getElementById('save-error');
                        if (!err) {
                            err = document.createElement('div');
                            err.id = 'save-error';
                            err.style.color = '#ff5555';
                            err.style.fontSize = '10px';
                            err.style.marginTop = '5px';
                            err.textContent = 'âš  Saving Disabled (Browser Blocked)';
                            card.appendChild(err);
                        }
                    }
                }
            }

            exportSave() {
                // Capture 3D Snapshot
                this.renderer.render(this.scene, this.camera);
                const snapshot3d = this.renderer.domElement.toDataURL('image/png');

                // Capture 2D Icon
                const tempDiv = document.createElement('div');
                this.renderBattler(tempDiv, this.playerStats.genome);
                const icon2d = tempDiv.querySelector('canvas').toDataURL('image/png');

                const exportData = {
                    stats: this.playerStats,
                    visuals: {
                        icon2d: icon2d,
                        snapshot3d: snapshot3d
                    },
                    timestamp: new Date().toISOString(),
                    version: "1.0"
                };

                const data = JSON.stringify(exportData, null, 2);
                const blob = new Blob([data], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `evomon-${this.playerStats.level}-${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }

            importSave(input) {
                const file = input.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        // Support both raw stats (legacy) and new wrapped format
                        const stats = data.stats || data;
                        
                        if (stats.level && stats.genome) {
                            this.playerStats = stats;
                            this.player.updateMesh(this.playerStats.genome, this.playerStats.level);
                            this.updateHUD();
                            this.saveGame();
                            
                            let msg = "Save loaded successfully!";
                            if (data.visuals) {
                                msg += "\n(Visuals verified)";
                            }
                            alert(msg);
                        } else {
                            alert("Invalid save file.");
                        }
                    } catch (err) {
                        console.error(err);
                        alert("Error loading save.");
                    }
                };
                reader.readAsText(file);
            }
            
            loadGame() {
                try {
                    const save = localStorage.getItem('evomon_save');
                    const data = save ? JSON.parse(save) : null;
                    if (data && !data.evolutionLog) {
                        data.evolutionLog = [];
                        data.evolutionLog.push({
                            gen: 1,
                            timestamp: new Date().toISOString(),
                            event: "Legacy Save Loaded",
                            genome: JSON.parse(JSON.stringify(data.genome)),
                            level: data.level
                        });
                    }
                    return data;
                } catch (e) {
                    console.warn("Failed to load game:", e);
                    return null;
                }
            }
            
            init() {
                // Three.js Setup
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB);
                this.scene.fog = new THREE.Fog(0x87CEEB, 20, 60);
                
                // "3DS Style" Camera: High angle, perspective
                this.camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 20, 20);
                this.camera.lookAt(0, 0, 0);
                
                this.renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true, preserveDrawingBuffer: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                
                // Lights
                const ambient = new THREE.AmbientLight(0x404040, 0.8);
                this.scene.add(ambient);
                
                const sun = new THREE.DirectionalLight(0xffffff, 1.0);
                sun.position.set(50, 100, 50);
                sun.castShadow = true;
                sun.shadow.mapSize.width = 2048;
                sun.shadow.mapSize.height = 2048;
                sun.shadow.camera.left = -50;
                sun.shadow.camera.right = 50;
                sun.shadow.camera.top = 50;
                sun.shadow.camera.bottom = -50;
                this.scene.add(sun);
                
                // Generate World
                this.world = new World(this.scene);
                
                // Spawn Fossils from previous runs (simulated for now)
                this.world.spawnFossils(this.scene);
                
                // Spawn Bosses
                this.world.spawnBosses(this.scene);
                
                // Create Player
                this.player = new Player(this.scene, this.playerStats.genome, this.playerStats.level);
                
                // Find Safe Spawn
                this.findSafeSpawn();
                
                // Input
                window.addEventListener('keydown', e => {
                    this.keys[e.key.toLowerCase()] = true;
                    document.getElementById('debug-key').textContent = e.key; // Debug
                    if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].indexOf(e.code) > -1) {
                        e.preventDefault();
                    }
                });
                window.addEventListener('keyup', e => this.keys[e.key.toLowerCase()] = false);
                window.addEventListener('resize', () => this.onResize());
                
                // Start Loop
                this.animate();
            }
            
            findSafeSpawn() {
                // Spiral out from 0,0 until we find land
                let r = 0;
                let angle = 0;
                while(r < 100) {
                    const x = Math.cos(angle) * r;
                    const z = Math.sin(angle) * r;
                    const h = this.world.getHeight(x, z);
                    if (h > 0.5) {
                        this.player.mesh.position.set(x, h, z);
                        return;
                    }
                    angle += 0.5;
                    if (angle > Math.PI * 2) {
                        angle = 0;
                        r += 2;
                    }
                }
                // Fallback
                this.player.mesh.position.set(0, 10, 0);
            }

            update(dt) {
                if (this.state === 'roam') {
                    // Movement
                    const speed = 20 * dt; // Increased speed
                    const move = new THREE.Vector3(0, 0, 0);
                    
                    // Debug log for keys
                    // console.log(this.keys);
                    
                    if (this.keys['w'] || this.keys['arrowup']) move.z -= 1;
                    if (this.keys['s'] || this.keys['arrowdown']) move.z += 1;
                    if (this.keys['a'] || this.keys['arrowleft']) move.x -= 1;
                    if (this.keys['d'] || this.keys['arrowright']) move.x += 1;
                    
                    if (move.lengthSq() > 0) {
                        move.normalize().multiplyScalar(speed);
                        
                        // Collision Check (Simple bounds & water)
                        const nextPos = this.player.mesh.position.clone().add(move);
                        const height = this.world.getHeight(nextPos.x, nextPos.z);
                        
                        if (height > 0.5) { // Not water
                            this.player.mesh.position.add(move);
                            this.player.mesh.position.y = height;
                            this.player.mesh.lookAt(this.player.mesh.position.clone().add(move));
                            
                            // Encounter Check
                            if (this.world.isTallGrass(nextPos.x, nextPos.z)) {
                                if (Math.random() < 0.01) { // 1% chance per frame in grass
                                    this.startBattle();
                                }
                            }
                        }
                    }
                    
                    // Camera Follow
                    this.camera.position.x = this.player.mesh.position.x;
                    this.camera.position.z = this.player.mesh.position.z + 20;
                    this.camera.position.y = this.player.mesh.position.y + 20;
                    this.camera.lookAt(this.player.mesh.position);
                    
                    // Update MiniMap
                    this.world.drawMiniMap(this.player.mesh.position.x, this.player.mesh.position.z);
                    
                    // Biome Adaptation Check
                    this.checkBiomeAdaptation(dt);
                    
                    // Boss Collision Check
                    this.checkBossCollision();
                    
                    // Fossil Interaction
                    this.checkFossilInteraction();
                }
                
                this.player.update(dt);
            }
            
            checkBiomeAdaptation(dt) {
                const x = this.player.mesh.position.x;
                const z = this.player.mesh.position.z;
                const biome = this.world.getBiome(x, z);
                
                if (!this.playerStats.history.biomeTime) this.playerStats.history.biomeTime = {};
                if (!this.playerStats.history.biomeTime[biome]) this.playerStats.history.biomeTime[biome] = 0;
                
                this.playerStats.history.biomeTime[biome] += dt;
                
                // Trigger adaptation every 30 seconds in a biome
                if (this.playerStats.history.biomeTime[biome] > 30) {
                    this.playerStats.history.biomeTime[biome] = 0;
                    this.triggerBiomeAdaptation(biome);
                }
            }
            
            initEvoPreview() {
                if (this.evoRenderer) return;
                
                const container = document.getElementById('evo-canvas-container');
                this.evoScene = new THREE.Scene();
                this.evoScene.background = new THREE.Color(0x001428);
                
                this.evoCamera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
                this.evoCamera.position.set(0, 0.5, 2.5);
                this.evoCamera.lookAt(0, 0.5, 0);
                
                this.evoRenderer = new THREE.WebGLRenderer({ antialias: true });
                this.evoRenderer.setSize(300, 300);
                container.appendChild(this.evoRenderer.domElement);
                
                const ambient = new THREE.AmbientLight(0x404040);
                this.evoScene.add(ambient);
                
                const dirLight = new THREE.DirectionalLight(0xffffff, 1);
                dirLight.position.set(2, 5, 3);
                this.evoScene.add(dirLight);
            }

            showEvolution(oldGenome, newGenome, msg, focusType) {
                this.state = 'evolve';
                document.getElementById('evo-modal').style.display = 'block';
                document.getElementById('evo-text').innerHTML = msg;
                this.evoFocus = focusType;
                this.evoView = 'after';
                this.evoOldGenome = oldGenome;
                
                // Calculate Diff
                this.evoDiff = {
                    agility: newGenome.agility - oldGenome.agility,
                    aggression: newGenome.aggression - oldGenome.aggression,
                    resilience: newGenome.resilience - oldGenome.resilience,
                    element: Math.abs(newGenome.element - oldGenome.element)
                };
                
                document.getElementById('evo-label').textContent = "AFTER (Changed)";
                document.getElementById('evo-label').style.color = "#00ffff";
                
                this.initEvoPreview();
                
                // Clear previous
                if (this.evoPlayerBefore && this.evoPlayerBefore.mesh) this.evoScene.remove(this.evoPlayerBefore.mesh);
                if (this.evoPlayerAfter && this.evoPlayerAfter.mesh) this.evoScene.remove(this.evoPlayerAfter.mesh);
                
                // Create meshes
                this.evoPlayerBefore = new Player(this.evoScene, oldGenome);
                this.evoPlayerAfter = new Player(this.evoScene, newGenome);
                
                this.evoPlayerBefore.mesh.visible = false;
                this.evoPlayerAfter.mesh.visible = true;
                
                // Focus Camera
                if (focusType === 'agility') {
                    this.evoCamera.position.set(1.5, 0.2, 1.5);
                    this.evoCamera.lookAt(0, 0.2, 0);
                } else if (focusType === 'aggression') {
                    this.evoCamera.position.set(0.8, 0.8, 1.5);
                    this.evoCamera.lookAt(0, 0.5, 0);
                } else if (focusType === 'resilience') {
                    this.evoCamera.position.set(0, 0.5, 2);
                    this.evoCamera.lookAt(0, 0.5, 0);
                } else {
                    this.evoCamera.position.set(0, 0.5, 2.5);
                    this.evoCamera.lookAt(0, 0.5, 0);
                }
                
                this.animateEvo();
            }
            
            toggleEvoView(view) {
                this.evoView = view;
                
                // Reset Before Mesh (in case it was ghosted)
                this.evoScene.remove(this.evoPlayerBefore.mesh);
                this.evoPlayerBefore = new Player(this.evoScene, this.evoOldGenome);
                
                if (view === 'before') {
                    this.evoPlayerBefore.mesh.visible = true;
                    this.evoPlayerAfter.mesh.visible = false;
                    document.getElementById('evo-label').textContent = "BEFORE";
                    document.getElementById('evo-label').style.color = "#aaa";
                } else if (view === 'compare') {
                    this.evoPlayerBefore.mesh.visible = true;
                    this.evoPlayerAfter.mesh.visible = true;
                    document.getElementById('evo-label').textContent = "COMPARE (Diff)";
                    document.getElementById('evo-label').style.color = "#ff00ff";
                    
                    // Make Before mesh a ghost
                    this.evoPlayerBefore.mesh.traverse(child => {
                        if (child.isMesh) {
                            child.material = new THREE.MeshBasicMaterial({
                                color: 0xffffff,
                                transparent: true,
                                opacity: 0.15,
                                wireframe: true
                            });
                        }
                    });
                } else {
                    this.evoPlayerBefore.mesh.visible = false;
                    this.evoPlayerAfter.mesh.visible = true;
                    document.getElementById('evo-label').textContent = "AFTER (Changed)";
                    document.getElementById('evo-label').style.color = "#00ffff";
                }
            }
            
            animateEvo() {
                if (this.state !== 'evolve') return;
                requestAnimationFrame(() => this.animateEvo());
                
                const time = Date.now() * 0.005;
                const pulse = (Math.sin(time * 4) + 1) * 0.5; // Faster pulse
                
                // Rotate both
                if (this.evoPlayerBefore.mesh) this.evoPlayerBefore.mesh.rotation.y += 0.01;
                if (this.evoPlayerAfter.mesh) this.evoPlayerAfter.mesh.rotation.y += 0.01;
                
                // Emphasis Effects on AFTER model
                if ((this.evoView === 'after' || this.evoView === 'compare') && this.evoPlayerAfter.mesh) {
                    const mesh = this.evoPlayerAfter.mesh;
                    
                    mesh.children.forEach(child => {
                        // Reset emissive first
                        if (child.material.emissive) {
                            child.material.emissive.setHex(0x000000);
                        }
                        
                        // Highlight Limbs if Agility changed
                        if (this.evoDiff.agility > 0 && child.userData.type === 'limb') {
                            const scale = 1 + pulse * 0.2;
                            child.scale.set(scale, scale, scale);
                            child.material.emissive.setHSL(0.3, 1, pulse * 0.5); // Greenish glow
                        }
                        
                        // Highlight Body if Aggression/Resilience changed
                        if ((this.evoDiff.aggression > 0 || this.evoDiff.resilience > 0) && child.userData.type === 'body') {
                            let hue = 0; // Red for aggression
                            if (this.evoDiff.resilience > this.evoDiff.aggression) hue = 0.6; // Blue for resilience
                            
                            child.material.emissive.setHSL(hue, 1, pulse * 0.4);
                        }
                    });
                }
                
                this.evoRenderer.render(this.evoScene, this.evoCamera);
            }

            triggerBiomeAdaptation(biome) {
                const oldGenome = JSON.parse(JSON.stringify(this.playerStats.genome));
                const g = this.playerStats.genome;
                let msg = "";
                
                if (biome === 'snow') {
                    g.resilience = Math.min(1, g.resilience + 0.1);
                    g.element = (g.element * 0.8) + (0.8 * 0.2); // Towards white/blue
                    msg = "Adapted to Cold: Fur Grown";
                } else if (biome === 'desert') {
                    g.resilience = Math.max(0, g.resilience - 0.05);
                    g.agility = Math.min(1, g.agility + 0.1);
                    g.element = (g.element * 0.8) + (0.1 * 0.2); // Towards red/yellow
                    msg = "Adapted to Heat: Scales Grown";
                } else if (biome === 'water') {
                    g.agility = Math.min(1, g.agility + 0.1);
                    g.element = (g.element * 0.8) + (0.6 * 0.2); // Towards blue
                    msg = "Adapted to Water: Fins Grown";
                }
                
                if (msg) {
                    this.player.updateMesh(g, this.playerStats.level);
                    this.logEvolution("Biome Adaptation", msg);
                    this.saveGame();
                    
                    let focus = 'element';
                    if (biome === 'snow') focus = 'resilience';
                    if (biome === 'desert') focus = 'agility';
                    
                    this.showEvolution(oldGenome, g, `Biome Adaptation:<br>${msg}`, focus);
                }
            }
            
            checkBossCollision() {
                for (let boss of this.world.bosses) {
                    if (boss.mesh.position.distanceTo(this.player.mesh.position) < 3) {
                        this.startBattle(boss);
                        // Move player back slightly to prevent re-trigger
                        this.player.mesh.position.sub(this.player.mesh.getWorldDirection(new THREE.Vector3()).multiplyScalar(2));
                        return;
                    }
                }
            }
            
            checkFossilInteraction() {
                for (let i = this.world.fossils.length - 1; i >= 0; i--) {
                    const f = this.world.fossils[i];
                    if (f.mesh.position.distanceTo(this.player.mesh.position) < 2) {
                        const oldGenome = JSON.parse(JSON.stringify(this.playerStats.genome));
                        
                        // Absorb DNA
                        this.playerStats.xp += 50;
                        this.playerStats.genome.aggression = (this.playerStats.genome.aggression + f.genome.aggression) / 2;
                        this.playerStats.genome.resilience = (this.playerStats.genome.resilience + f.genome.resilience) / 2;
                        
                        this.scene.remove(f.mesh);
                        this.world.fossils.splice(i, 1);
                        
                        this.player.updateMesh(this.playerStats.genome, this.playerStats.level);
                        this.logEvolution("Fossil Absorption", "Traits Merged with Ancient DNA");
                        this.saveGame();
                        
                        this.showEvolution(oldGenome, this.playerStats.genome, `Ancient DNA Absorbed!<br>Traits Merged.`, 'resilience');
                    }
                }
            }
            
            startBattle(boss = null) {
                this.state = 'battle';
                this.keys = {}; // Clear input
                
                if (boss) {
                    this.battleEnemy = {
                        name: boss.name,
                        hp: boss.stats.hp,
                        maxHp: boss.stats.maxHp,
                        atk: boss.stats.atk,
                        genome: boss.genome,
                        isBoss: true
                    };
                } else {
                    // Generate Wild Enemy
                    this.battleEnemy = {
                        name: "Wild Beast",
                        hp: 50 + this.playerStats.level * 10,
                        maxHp: 50 + this.playerStats.level * 10,
                        atk: 5 + this.playerStats.level * 2,
                        genome: {
                            aggression: Math.random(),
                            resilience: Math.random(),
                            agility: Math.random(),
                            element: Math.random()
                        }
                    };
                }
                
                // Setup UI
                document.getElementById('battle-overlay').style.display = 'flex';
                document.getElementById('battle-log').textContent = `A ${this.battleEnemy.name} appeared!`;
                document.getElementById('battle-enemy-name').textContent = this.battleEnemy.name;
                document.getElementById('battle-enemy-hp').style.width = '100%';
                
                // Render Battlers
                this.renderBattler('player-battler', this.playerStats.genome);
                this.renderBattler('enemy-battler', this.battleEnemy.genome, true);
            }
            
            battleAction(action) {
                const p = this.playerStats;
                const e = this.battleEnemy;
                const log = document.getElementById('battle-log');
                
                if (action === 'attack') {
                    // Player Attack
                    const dmg = Math.floor(p.atk * (1 + p.genome.aggression));
                    e.hp -= dmg;
                    p.history.damageDealt += dmg;
                    log.innerHTML += `<br>You dealt ${dmg} damage!`;
                    document.getElementById('battle-enemy-hp').style.width = (e.hp/e.maxHp*100) + '%';
                    
                    if (e.hp <= 0) {
                        this.winBattle();
                        return;
                    }
                    
                    // Enemy Attack
                    setTimeout(() => {
                        const eDmg = Math.max(1, Math.floor(e.atk * (1 + e.genome.aggression)) - Math.floor(p.def * p.genome.resilience));
                        p.hp -= eDmg;
                        p.history.damageTaken += eDmg;
                        log.innerHTML += `<br>Enemy dealt ${eDmg} damage!`;
                        this.updateHUD();
                        document.getElementById('battle-player-hp').style.width = (p.hp/p.maxHp*100) + '%';
                        
                        if (p.hp <= 0) {
                            alert("You fainted! Respawning...");
                            location.reload();
                        }
                    }, 500);
                } else if (action === 'flee') {
                    if (Math.random() < p.genome.agility) {
                        p.history.fled++;
                        this.endBattle();
                    } else {
                        log.innerHTML += "<br>Failed to flee!";
                        // Take damage
                        const eDmg = 5;
                        p.hp -= eDmg;
                        this.updateHUD();
                    }
                }
            }
            
            winBattle() {
                const xpGain = 20 + this.playerStats.level * 5;
                this.playerStats.xp += xpGain;
                
                // Check Level Up
                if (this.playerStats.xp >= this.playerStats.level * 100) {
                    this.playerStats.level++;
                    this.playerStats.xp = 0;
                    this.playerStats.maxHp += 10;
                    this.playerStats.hp = this.playerStats.maxHp;
                    this.playerStats.atk += 2;
                }
                
                this.updateHUD();
                this.saveGame();
                
                // Trigger Adaptation
                this.triggerAdaptation();
                
                this.endBattle();
            }
            
            triggerAdaptation() {
                const h = this.playerStats.history;
                const oldGenome = JSON.parse(JSON.stringify(this.playerStats.genome));
                const g = this.playerStats.genome;
                let changes = [];
                
                // Lower thresholds for easier testing
                if (h.damageTaken > 10) { // Was 20
                    g.resilience = Math.min(1, g.resilience + 0.1); // Faster growth
                    changes.push("Skin Hardened (+Resilience)");
                }
                if (h.damageDealt > 20) { // Was 50
                    g.aggression = Math.min(1, g.aggression + 0.1); // Faster growth
                    changes.push("Claws Sharpened (+Aggression)");
                }
                if (h.fled > 0) {
                    g.agility = Math.min(1, g.agility + 0.1);
                    changes.push("Legs Strengthened (+Agility)");
                }
                
                // Reset history
                h.damageTaken = 0; h.damageDealt = 0; h.fled = 0;
                
                if (changes.length > 0) {
                    // Re-render player mesh
                    this.player.updateMesh(g, this.playerStats.level);
                    this.logEvolution("Battle Adaptation", changes.join(', '));
                    this.saveGame();
                    
                    // Determine focus
                    let focus = 'default';
                    if (changes.some(c => c.includes('Agility'))) focus = 'agility';
                    else if (changes.some(c => c.includes('Aggression'))) focus = 'aggression';
                    else if (changes.some(c => c.includes('Resilience'))) focus = 'resilience';
                    
                    this.showEvolution(oldGenome, g, `Adaptations:<br>${changes.join('<br>')}`, focus);
                }
            }
            
            closeEvolution() {
                document.getElementById('evo-modal').style.display = 'none';
                this.state = 'roam';
                // Ensure input is cleared
                this.keys = {};
                
                // Force update of main player mesh with new stats
                // This ensures the main game view reflects the changes seen in the popup
                this.player.updateMesh(this.playerStats.genome, this.playerStats.level);
            }
            
            endBattle() {
                document.getElementById('battle-overlay').style.display = 'none';
                this.state = 'roam';
                this.keys = {}; // Clear input to prevent stuck movement
            }
            
            renderBattler(target, genome, flip=false) {
                const container = typeof target === 'string' ? document.getElementById(target) : target;
                container.innerHTML = '';
                
                const cvs = document.createElement('canvas');
                cvs.width = 150; cvs.height = 150;
                container.appendChild(cvs);
                
                const ctx = cvs.getContext('2d');
                
                // Draw 2D representation of genome
                const hue = Math.floor(genome.element * 360);
                ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                
                if (flip) {
                    ctx.translate(150, 0);
                    ctx.scale(-1, 1);
                }

                // Limbs (Agility) - Draw before body
                const limbCount = Math.floor(genome.agility * 6);
                ctx.fillStyle = `hsl(${hue}, 70%, 40%)`;
                for(let i=0; i<limbCount; i++) {
                    const angle = (i / limbCount) * Math.PI * 2;
                    const lx = 75 + Math.cos(angle) * 60;
                    const ly = 75 + Math.sin(angle) * 60;
                    
                    ctx.beginPath();
                    ctx.moveTo(75, 75);
                    ctx.lineTo(lx, ly);
                    ctx.lineWidth = 10;
                    ctx.strokeStyle = `hsl(${hue}, 70%, 40%)`;
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.arc(lx, ly, 8, 0, Math.PI*2);
                    ctx.fill();
                }
                
                // Body
                ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                if (genome.resilience > 0.6) {
                    ctx.fillRect(40, 40, 70, 70);
                } else {
                    ctx.beginPath();
                    ctx.arc(75, 75, 40, 0, Math.PI*2);
                    ctx.fill();
                }
                
                // Spikes
                if (genome.aggression > 0.4) {
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.moveTo(75, 20); ctx.lineTo(90, 50); ctx.lineTo(60, 50);
                    ctx.fill();
                }
                
                // Eyes
                const eyeCount = 1 + Math.floor(genome.element * 3); // 1 to 3 eyes
                const eyeSpacing = 20;
                const startX = 75 - ((eyeCount - 1) * eyeSpacing) / 2;
                
                for(let i=0; i<eyeCount; i++) {
                    const ex = startX + i * eyeSpacing;
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(ex, 60, 8, 0, Math.PI*2);
                    ctx.fill();
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(ex + 2, 60, 3, 0, Math.PI*2);
                    ctx.fill();
                }
            }
            
            updateHUD() {
                const p = this.playerStats;
                document.getElementById('lvl-val').textContent = p.level;
                document.getElementById('hp-bar').style.width = (p.hp/p.maxHp*100) + '%';
                document.getElementById('xp-bar').style.width = (p.xp/(p.level*100)*100) + '%';
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                const dt = this.clock.getDelta();
                this.update(dt);
                this.renderer.render(this.scene, this.camera);
            }
            
            onResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }
        
        // --- World Class ---
        class World {
            constructor(scene) {
                this.size = 100; // 100x100 tiles
                this.scale = 2;
                this.heightMap = [];
                this.objects = [];
                this.bosses = [];
                this.fossils = [];
                this.simplex = new SimplexNoise();
                
                this.generate(scene);
            }
            
            generate(scene) {
                // Terrain Geometry
                const geometry = new THREE.PlaneGeometry(this.size * this.scale, this.size * this.scale, this.size, this.size);
                geometry.rotateX(-Math.PI / 2);
                
                const colors = [];
                const pos = geometry.attributes.position;
                
                for (let i = 0; i < pos.count; i++) {
                    const x = pos.getX(i);
                    const z = pos.getZ(i);
                    
                    // Noise
                    let y = this.simplex.noise2D(x * 0.02, z * 0.02) * 5;
                    y += this.simplex.noise2D(x * 0.1, z * 0.1) * 1;
                    
                    // Water level flatten
                    if (y < 0) y = -1;
                    else if (y < 1) y = 0.5; // Beach
                    
                    pos.setY(i, y);
                    
                    // Color
                    const color = new THREE.Color();
                    if (y <= -0.5) color.setHex(0xe0cda4); // Sand underwater
                    else if (y <= 0.6) color.setHex(0xe0cda4); // Beach
                    else if (y > 4) color.setHex(0xffffff); // Snow Mountain
                    else if (y > 2.5) color.setHex(0x888888); // Rock
                    else color.setHex(0x228b22); // Grass
                    
                    colors.push(color.r, color.g, color.b);
                }
                
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                geometry.computeVertexNormals();
                
                const mat = new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.8 });
                const mesh = new THREE.Mesh(geometry, mat);
                mesh.receiveShadow = true;
                scene.add(mesh);
                
                // Water Plane
                const waterGeo = new THREE.PlaneGeometry(this.size * this.scale, this.size * this.scale);
                waterGeo.rotateX(-Math.PI/2);
                const waterMat = new THREE.MeshStandardMaterial({ color: 0x0077be, transparent: true, opacity: 0.6 });
                const water = new THREE.Mesh(waterGeo, waterMat);
                water.position.y = 0;
                scene.add(water);
                
                // Objects (Trees, Grass)
                for (let x = -this.size/2; x < this.size/2; x++) {
                    for (let z = -this.size/2; z < this.size/2; z++) {
                        const wx = x * this.scale;
                        const wz = z * this.scale;
                        const h = this.getHeight(wx, wz);
                        
                        if (h > 1 && h < 4) {
                            const n = this.simplex.noise2D(wx * 0.1 + 100, wz * 0.1 + 100);
                            
                            // Trees
                            if (n > 0.6 && Math.random() < 0.2) {
                                const tree = new THREE.Mesh(
                                    new THREE.ConeGeometry(0.5, 2, 8),
                                    new THREE.MeshStandardMaterial({ color: 0x004400 })
                                );
                                tree.position.set(wx, h + 1, wz);
                                tree.castShadow = true;
                                scene.add(tree);
                            }
                            
                            // Tall Grass (Encounter Zones)
                            if (n < -0.2 && Math.random() < 0.5) {
                                const grass = new THREE.Mesh(
                                    new THREE.BoxGeometry(0.5, 0.8, 0.5),
                                    new THREE.MeshStandardMaterial({ color: 0x32cd32, transparent: true, opacity: 0.8 })
                                );
                                grass.position.set(wx, h + 0.4, wz);
                                scene.add(grass);
                                this.objects.push({ type: 'grass', x: wx, z: wz });
                            }
                        }
                    }
                }
            }
            
            spawnFossils(scene) {
                // Simulate finding 3 fossils
                for(let i=0; i<3; i++) {
                    const x = (Math.random() - 0.5) * 80;
                    const z = (Math.random() - 0.5) * 80;
                    const h = this.getHeight(x, z);
                    if (h > 0.5) {
                        const fossil = new THREE.Mesh(
                            new THREE.DodecahedronGeometry(0.5),
                            new THREE.MeshStandardMaterial({ color: 0x885522 })
                        );
                        fossil.position.set(x, h + 0.5, z);
                        scene.add(fossil);
                        this.fossils.push({
                            mesh: fossil,
                            genome: { aggression: Math.random(), resilience: Math.random() }
                        });
                    }
                }
            }
            
            spawnBosses(scene) {
                // Spawn a Titan on a mountain
                let found = false;
                let attempts = 0;
                while(!found && attempts < 100) {
                    const x = (Math.random() - 0.5) * 100;
                    const z = (Math.random() - 0.5) * 100;
                    const h = this.getHeight(x, z);
                    if (h > 3) { // Mountain
                        const bossMesh = new THREE.Mesh(
                            new THREE.BoxGeometry(3, 3, 3),
                            new THREE.MeshStandardMaterial({ color: 0x550000 })
                        );
                        bossMesh.position.set(x, h + 1.5, z);
                        scene.add(bossMesh);
                        
                        this.bosses.push({
                            name: "Mountain Titan",
                            mesh: bossMesh,
                            stats: { hp: 500, maxHp: 500, atk: 30 },
                            genome: { aggression: 1, resilience: 1, element: 0.1 }
                        });
                        found = true;
                    }
                    attempts++;
                }
            }
            
            getBiome(x, z) {
                const h = this.getHeight(x, z);
                if (h < 0) return 'water';
                if (h < 1) return 'beach';
                if (h > 4) return 'snow';
                
                // Moisture noise
                const m = this.simplex.noise2D(x * 0.05 + 500, z * 0.05 + 500);
                if (m < -0.5) return 'desert';
                return 'forest';
            }
            
            getHeight(x, z) {
                let y = this.simplex.noise2D(x * 0.02, z * 0.02) * 5;
                y += this.simplex.noise2D(x * 0.1, z * 0.1) * 1;
                if (y < 0) return -1;
                if (y < 1) return 0.5;
                return y;
            }
            
            isTallGrass(x, z) {
                // Simple distance check against stored grass objects
                // Optimization: Spatial hash would be better, but linear scan ok for <1000 objects
                for(let o of this.objects) {
                    if (o.type === 'grass' && Math.abs(o.x - x) < 1 && Math.abs(o.z - z) < 1) {
                        return true;
                    }
                }
                return false;
            }
            
            drawMiniMap(px, pz) {
                const cvs = document.getElementById('mm-canvas');
                const ctx = cvs.getContext('2d');
                const w = cvs.width = cvs.offsetWidth;
                const h = cvs.height = cvs.offsetHeight;
                
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, w, h);
                
                // Draw Player
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(w/2, h/2, 3, 0, Math.PI*2);
                ctx.fill();
                
                // Draw nearby objects
                const range = 40;
                const scale = w / (range * 2);
                
                for(let o of this.objects) {
                    const dx = o.x - px;
                    const dz = o.z - pz;
                    
                    if (Math.abs(dx) < range && Math.abs(dz) < range) {
                        if (o.type === 'grass') {
                            ctx.fillStyle = '#00ff00';
                            ctx.fillRect(w/2 + dx*scale, h/2 + dz*scale, 2, 2);
                        }
                    }
                }
                
                // Draw Bosses
                ctx.fillStyle = '#ff0000';
                for(let b of this.bosses) {
                    const dx = b.mesh.position.x - px;
                    const dz = b.mesh.position.z - pz;
                    if (Math.abs(dx) < range && Math.abs(dz) < range) {
                        ctx.fillRect(w/2 + dx*scale - 2, h/2 + dz*scale - 2, 4, 4);
                    }
                }
                
                // Draw Fossils
                ctx.fillStyle = '#aa8800';
                for(let f of this.fossils) {
                    const dx = f.mesh.position.x - px;
                    const dz = f.mesh.position.z - pz;
                    if (Math.abs(dx) < range && Math.abs(dz) < range) {
                        ctx.fillRect(w/2 + dx*scale - 1, h/2 + dz*scale - 1, 3, 3);
                    }
                }
            }
        }
        
        // --- Player Class ---
        class Player {
            constructor(scene, genome) {
                this.scene = scene;
                this.mesh = null;
                this.updateMesh(genome);
            }
            
            updateMesh(genome) {
                const oldPos = this.mesh ? this.mesh.position.clone() : null;
                const oldRot = this.mesh ? this.mesh.rotation.clone() : null;
                
                if (this.mesh) this.scene.remove(this.mesh);
                
                const group = new THREE.Group();
                
                // --- Dynamic Procedural Generation ---
                // Instead of swapping geometries, we deform a base sphere based on traits
                
                // Base Geometry: High res sphere for deformation
                const geo = new THREE.SphereGeometry(0.6, 32, 32);
                const posAttribute = geo.attributes.position;
                const vertex = new THREE.Vector3();
                
                // Deform based on traits
                for (let i = 0; i < posAttribute.count; i++) {
                    vertex.fromBufferAttribute(posAttribute, i);
                    
                    // 1. Resilience (Blockiness)
                    // Push vertices towards a cube shape
                    // ALWAYS apply at least a tiny bit of deformation based on resilience so it's not just a perfect sphere
                    const resilienceFactor = Math.max(0.05, genome.resilience); 
                    
                    if (resilienceFactor > 0) {
                        const cubeFactor = resilienceFactor; // 0 to 1
                        const absX = Math.abs(vertex.x);
                        const absY = Math.abs(vertex.y);
                        const absZ = Math.abs(vertex.z);
                        const maxDim = Math.max(absX, Math.max(absY, absZ));
                        
                        // Lerp between sphere (length) and cube (maxDim)
                        // Normalize to radius 0.6
                        const sphereLen = vertex.length();
                        const cubeLen = 0.6 * (sphereLen / maxDim); // Project to cube surface
                        
                        // Blend
                        const targetLen = sphereLen * (1 - cubeFactor) + cubeLen * cubeFactor;
                        vertex.setLength(targetLen);
                    }
                    
                    // 2. Aggression (Spikiness)
                    // Add noise to vertices to create spikes
                    // ALWAYS apply noise if aggression > 0
                    if (genome.aggression > 0) {
                        // Simple noise function based on position
                        const noise = Math.sin(vertex.x * 10) * Math.sin(vertex.y * 10) * Math.sin(vertex.z * 10);
                        if (noise > 0.5) {
                            // Extrude spike
                            // Ensure minimum spike visibility if aggression is present
                            const spikeAmt = (noise - 0.5) * Math.max(0.1, genome.aggression) * 0.5;
                            vertex.add(vertex.clone().normalize().multiplyScalar(spikeAmt));
                        }
                    }
                    
                    posAttribute.setXYZ(i, vertex.x, vertex.y, vertex.z);
                }
                
                geo.computeVertexNormals();
                
                // Color
                const hue = Math.floor(genome.element * 360);
                const color = new THREE.Color(`hsl(${hue}, 70%, 50%)`);
                
                const body = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ 
                    color: color,
                    roughness: 0.7 - (genome.resilience * 0.5), // More resilient = shinier/harder
                    metalness: genome.resilience * 0.3
                }));
                body.position.y = 0.5;
                body.castShadow = true;
                body.userData.type = 'body';
                group.add(body);
                
                // 3. Agility (Limbs/Appendages)
                // Procedurally grow limbs based on agility score
                // ALWAYS show at least small nubs if agility > 0
                const limbCount = Math.max(0, Math.floor(genome.agility * 6)); 
                // If agility is low but > 0, maybe show small nubs? 
                // Let's stick to count for now but ensure length scales visibly
                
                if (limbCount > 0) {
                    for(let i=0; i<limbCount; i++) {
                        const angle = (i / limbCount) * Math.PI * 2;
                        // Fallback for older Three.js versions that lack CapsuleGeometry
                        let limbGeo;
                        // Ensure minimum length so they are visible
                        const limbLen = 0.4 + Math.max(0.1, genome.agility) * 0.5;
                        
                        if (THREE.CapsuleGeometry) {
                            limbGeo = new THREE.CapsuleGeometry(0.1, limbLen, 4, 8);
                        } else {
                            limbGeo = new THREE.CylinderGeometry(0.1, 0.1, limbLen, 8);
                        }
                        const limb = new THREE.Mesh(limbGeo, new THREE.MeshStandardMaterial({ color: color }));
                        
                        // Position around body
                        limb.position.set(Math.cos(angle)*0.5, 0.5, Math.sin(angle)*0.5);
                        
                        // Rotate outward
                        limb.lookAt(0, 0.5, 0); // Look at center
                        limb.rotateX(Math.PI/2); // Point out
                        limb.userData.type = 'limb';
                        
                        group.add(limb);
                    }
                }
                
                // Eyes (Always present, but change size/color)
                // Ensure minimum size change visibility
                const eyeSize = 0.1 + (Math.max(0.1, genome.agility) * 0.05); 
                const eyeCount = 1 + Math.floor(genome.element * 3); // 1 to 3 eyes
                
                // Distribute eyes across the front face
                const eyeAngleSpan = Math.PI / 2; // 90 degrees span
                const startAngle = -eyeAngleSpan / 2;
                
                for(let i=0; i<eyeCount; i++) {
                    // Calculate angle for this eye
                    // If 1 eye, angle is 0. If 2, -22.5 and +22.5. etc.
                    let angle = 0;
                    if (eyeCount > 1) {
                        angle = startAngle + (i / (eyeCount - 1)) * eyeAngleSpan;
                    }
                    
                    const ex = Math.sin(angle) * 0.5; // X offset
                    const ez = Math.cos(angle) * 0.5; // Z offset (forward)
                    
                    const eye = new THREE.Mesh(
                        new THREE.SphereGeometry(eyeSize, 8, 8),
                        new THREE.MeshBasicMaterial({ color: 0xffffff })
                    );
                    // Position on the surface of the "head" area
                    eye.position.set(ex, 0.7, ez);
                    
                    // Pupil
                    const pupil = new THREE.Mesh(
                        new THREE.SphereGeometry(eyeSize * 0.4, 8, 8),
                        new THREE.MeshBasicMaterial({ color: 0x000000 })
                    );
                    pupil.position.set(0, 0, eyeSize);
                    eye.add(pupil);
                    
                    group.add(eye);
                }
                
                this.mesh = group;
                this.scene.add(this.mesh);
                
                // Restore position
                if (oldPos) {
                    this.mesh.position.copy(oldPos);
                    this.mesh.rotation.copy(oldRot);
                }
            }
            
            update(dt) {
                // Animation (bobbing)
                if (this.mesh) {
                    this.mesh.children[0].position.y = 0.5 + Math.sin(Date.now() * 0.01) * 0.05;
                }
            }
        }
        
        // Start Game
        const game = new Game();
        
    </script>
</body>
</html>