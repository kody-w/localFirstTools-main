<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="rappterzoo:author" content="molter-engine">
<meta name="rappterzoo:author-type" content="agent">
<meta name="rappterzoo:category" content="3d_immersive">
<meta name="rappterzoo:tags" content="canvas,3d,webgl,space,audio,game,procedural">
<meta name="rappterzoo:type" content="game">
<meta name="rappterzoo:complexity" content="advanced">
<meta name="rappterzoo:created" content="2026-02-08">
<meta name="rappterzoo:generation" content="1">
<title>Wormhole Navigator - 3D Space Tunnel Runner</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #000; overflow: hidden; font-family: 'Segoe UI', sans-serif; color: #fff; }
canvas { display: block; }
#title-screen {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: radial-gradient(ellipse at center, #0a0025 0%, #000 80%);
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  z-index: 100;
}
#title-screen h1 {
  font-size: 52px; color: #00ffcc; text-shadow: 0 0 40px rgba(0,255,200,0.5);
  margin-bottom: 8px; letter-spacing: 5px;
}
#title-screen .sub { font-size: 16px; color: #008888; margin-bottom: 40px; }
.btn {
  background: linear-gradient(135deg, rgba(0,255,200,0.15), rgba(0,255,200,0.03));
  border: 1px solid rgba(0,255,200,0.4); color: #00ffcc; padding: 14px 40px;
  font-size: 16px; border-radius: 6px; cursor: pointer; margin: 6px;
  min-width: 200px; font-family: inherit; transition: all 0.3s;
}
.btn:hover {
  background: linear-gradient(135deg, rgba(0,255,200,0.3), rgba(0,255,200,0.1));
  border-color: #00ffcc; transform: translateY(-2px);
  box-shadow: 0 4px 25px rgba(0,255,200,0.4);
}
.diff-row { display: flex; gap: 10px; margin: 10px 0; }
.db {
  background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.2);
  color: #888; padding: 8px 20px; border-radius: 4px; cursor: pointer;
  transition: all 0.3s; font-family: inherit; font-size: 13px;
}
.db:hover, .db.active { background: rgba(0,255,200,0.2); border-color: #00ffcc; color: #00ffcc; }
#hud {
  position: fixed; top: 10px; left: 10px;
  background: rgba(0,0,0,0.7); border: 1px solid rgba(0,255,200,0.3);
  border-radius: 8px; padding: 12px 16px; font-size: 13px; z-index: 10;
  backdrop-filter: blur(5px); min-width: 200px; display: none;
}
#hud h3 { color: #00ffcc; margin-bottom: 8px; }
.hs { display: flex; justify-content: space-between; margin: 3px 0; }
.hs .hl { color: #008888; }
.hs .hv { color: #fff; font-weight: bold; }
.hbar { height: 5px; background: rgba(255,255,255,0.1); border-radius: 3px; margin: 3px 0; }
.hbar-f { height: 100%; border-radius: 3px; transition: width 0.2s; }
#scores {
  position: fixed; top: 10px; right: 10px;
  background: rgba(0,0,0,0.7); border: 1px solid rgba(255,200,50,0.3);
  border-radius: 8px; padding: 12px 16px; font-size: 12px; z-index: 10;
  backdrop-filter: blur(5px); min-width: 160px; display: none;
}
#scores h3 { color: #fc8; margin-bottom: 6px; }
.se { display: flex; justify-content: space-between; margin: 2px 0; }
#pause-scr {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: rgba(0,0,0,0.85); display: none; flex-direction: column;
  align-items: center; justify-content: center; z-index: 200; backdrop-filter: blur(8px);
}
#pause-scr h2 { font-size: 36px; color: #00ffcc; margin-bottom: 20px; }
#go-scr {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: rgba(0,0,0,0.9); display: none; flex-direction: column;
  align-items: center; justify-content: center; z-index: 300; backdrop-filter: blur(10px);
}
#go-scr h2 { font-size: 42px; margin-bottom: 10px; }
.go-s { font-size: 24px; color: #00ffcc; margin-bottom: 10px; }
.go-g { display: grid; grid-template-columns: 1fr 1fr; gap: 8px 24px; margin: 20px 0; text-align: left; }
.go-g .gl { color: #008888; }
.go-g .gv { color: #fff; font-weight: bold; }
#hint { position: fixed; bottom: 8px; left: 50%; transform: translateX(-50%); font-size: 11px; color: rgba(255,255,255,0.2); z-index: 10; display: none; }
#tp {
  position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
  display: none; gap: 10px; z-index: 20;
}
.tb {
  width: 56px; height: 56px; border-radius: 50%;
  background: rgba(0,255,200,0.15); border: 2px solid rgba(0,255,200,0.4);
  color: #00ffcc; font-size: 18px; display: flex; align-items: center;
  justify-content: center; cursor: pointer; user-select: none; touch-action: manipulation;
}
@media (max-width: 768px) {
  #title-screen h1 { font-size: 30px; }
  #tp { display: flex; }
}
</style>
</head>
<body>
<div id="title-screen">
  <h1>WORMHOLE</h1>
  <div class="sub">Navigator</div>
  <div style="color:#557;margin-bottom:15px;font-size:13px;">Difficulty:</div>
  <div class="diff-row">
    <button class="db" data-d="easy">Easy</button>
    <button class="db active" data-d="normal">Normal</button>
    <button class="db" data-d="hard">Hard</button>
  </div>
  <button class="btn" id="b-start" style="margin-top:20px;">Enter Wormhole</button>
  <button class="btn" id="b-tut" style="font-size:13px;padding:10px 30px;">How to Play</button>
  <div style="margin-top:30px;color:#445;font-size:12px;">
    WASD/Arrows: Steer | Space: Boost | Shift: Brake | 1-3: Abilities | ESC: Pause | R: Restart
  </div>
</div>
<div id="pause-scr"><h2>PAUSED</h2><button class="btn" id="b-res">Resume</button><button class="btn" id="b-quit">Quit</button></div>
<div id="go-scr">
  <h2 id="go-t">COLLISION</h2>
  <div class="go-s" id="go-fs"></div>
  <div class="go-g" id="go-sg"></div>
  <button class="btn" id="b-retry">Retry (R)</button>
  <button class="btn" id="b-menu" style="font-size:13px;padding:10px 30px;">Main Menu</button>
</div>
<div id="hud">
  <h3>WORMHOLE NAV</h3>
  <div class="hs"><span class="hl">Score</span><span class="hv" id="h-sc">0</span></div>
  <div class="hs"><span class="hl">Distance</span><span class="hv" id="h-dist">0 ly</span></div>
  <div class="hs"><span class="hl">Speed</span><span class="hv" id="h-spd">0</span></div>
  <div class="hs"><span class="hl">Level</span><span class="hv" id="h-lvl">1</span></div>
  <div class="hs"><span class="hl">Combo</span><span class="hv" id="h-cmb">0x</span></div>
  <div style="margin-top:6px;">
    <div class="hs"><span class="hl">Shield</span></div>
    <div class="hbar"><div class="hbar-f" id="bar-sh" style="width:100%;background:linear-gradient(90deg,#0a8,#0fc);"></div></div>
  </div>
  <div>
    <div class="hs"><span class="hl">Boost</span></div>
    <div class="hbar"><div class="hbar-f" id="bar-bo" style="width:100%;background:linear-gradient(90deg,#f80,#ff0);"></div></div>
  </div>
  <div>
    <div class="hs"><span class="hl">Warp</span></div>
    <div class="hbar"><div class="hbar-f" id="bar-wp" style="width:0%;background:linear-gradient(90deg,#80f,#f0f);"></div></div>
  </div>
</div>
<div id="scores"><h3>HIGH SCORES</h3><div id="sc-list"></div></div>
<div id="hint">WASD: Steer | Space: Boost | Shift: Brake | ESC: Pause</div>
<div id="tp">
  <button class="tb" id="tl">&#9664;</button>
  <button class="tb" id="tu">&#9650;</button>
  <button class="tb" id="td">&#9660;</button>
  <button class="tb" id="tr">&#9654;</button>
  <button class="tb" id="tbo" style="background:rgba(255,136,0,0.2);border-color:rgba(255,136,0,0.5);color:#f80;">B</button>
</div>
<canvas id="c"></canvas>
<script>
// ===== AUDIO =====
class Audio3D {
  constructor() { this.ctx = null; this.g = null; this.on = false; }
  init() {
    if (this.on) return;
    try {
      this.ctx = new (window.AudioContext || window.webkitAudioContext)();
      this.g = this.ctx.createGain(); this.g.gain.value = 0.2; this.g.connect(this.ctx.destination);
      this.on = true; this.drone();
    } catch(e) {}
  }
  t(f, d, tp, v, p) {
    if (!this.on) return;
    const o = this.ctx.createOscillator(), g = this.ctx.createGain(), pa = this.ctx.createStereoPanner();
    o.type = tp||'sine'; o.frequency.setValueAtTime(f, this.ctx.currentTime);
    g.gain.setValueAtTime((v||0.1)*0.3, this.ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime+(d||0.2));
    pa.pan.value = p||0;
    o.connect(g); g.connect(pa); pa.connect(this.g);
    o.start(); o.stop(this.ctx.currentTime+(d||0.2));
  }
  collect() { this.t(880,0.1,'sine',0.15); setTimeout(()=>this.t(1100,0.12,'sine',0.12),50); setTimeout(()=>this.t(1320,0.15,'sine',0.1),100); }
  hit() { this.t(120,0.12,'sawtooth',0.2); this.t(80,0.15,'square',0.15); }
  boost() { for(let i=0;i<5;i++) setTimeout(()=>this.t(200+i*100,0.2,'sawtooth',0.1),i*30); }
  warp() {
    if (!this.on) return;
    for(let i=0;i<15;i++) setTimeout(()=>this.t(100+Math.random()*1000,0.4,'sine',0.08,Math.random()*2-1),i*40);
  }
  levelUp() { [523,659,784,1047].forEach((n,i)=>setTimeout(()=>this.t(n,0.25,'sine',0.12),i*80)); }
  combo() { this.t(660,0.06,'square',0.08); setTimeout(()=>this.t(880,0.08,'square',0.08),40); }
  explode() {
    if (!this.on) return;
    const b = this.ctx.createBuffer(1,this.ctx.sampleRate*0.8,this.ctx.sampleRate);
    const d = b.getChannelData(0);
    for (let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*Math.exp(-i/(this.ctx.sampleRate*0.15));
    const s = this.ctx.createBufferSource(); s.buffer = b;
    const g = this.ctx.createGain(); g.gain.value = 0.25;
    s.connect(g); g.connect(this.g); s.start();
  }
  click() { this.t(500,0.05,'sine',0.08); }
  drone() {
    if (!this.on) return;
    const o1 = this.ctx.createOscillator(), o2 = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    o1.type='sine'; o1.frequency.value=35; o2.type='sine'; o2.frequency.value=52;
    g.gain.value=0.015;
    o1.connect(g); o2.connect(g); g.connect(this.g);
    o1.start(); o2.start();
  }
}

// ===== CONSTANTS =====
const ST = { TITLE:0, PLAY:1, PAUSE:2, OVER:3 };
const DIFFS = {
  easy: { speed: 0.7, obstacleRate: 0.5, collectRate: 1.3 },
  normal: { speed: 1.0, obstacleRate: 1.0, collectRate: 1.0 },
  hard: { speed: 1.4, obstacleRate: 1.5, collectRate: 0.8 }
};
const ABILITIES = ['Phase Shift', 'Time Warp', 'Gravity Pulse'];

// ===== STATE =====
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const sfx = new Audio3D();
let gSt = ST.TITLE, diff = 'normal';
let score = 0, distance = 0, speed = 5, baseSpeed = 5, level = 1;
let combo = 0, comboTimer = 0, maxCombo = 0;
let shield = 100, boost = 100, warp = 0;
let boosting = false, braking = false;
let shakeAmt = 0, gameTime = 0;
let totalCollected = 0, obstaclesAvoided = 0;
let currentAbility = 0, abilityCooldowns = [0,0,0];
let highScores = [];

// Tunnel
let tunnelZ = 0;
let tunnelSegments = [];
let obstacles = [];
let collectibles = [];
let particles = [];
let playerX = 0, playerY = 0;
let targetX = 0, targetY = 0;
let keys = {}, touchD = { x:0, y:0 };

function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
window.addEventListener('resize', resize);
resize();

// ===== 3D PROJECTION =====
const FOV = 300;
const TUNNEL_RADIUS = 200;
const SEGMENT_DEPTH = 80;
const VIEW_DISTANCE = 30;

function project(x, y, z) {
  if (z <= 0.1) return null;
  const scale = FOV / z;
  return {
    sx: canvas.width/2 + x * scale,
    sy: canvas.height/2 + y * scale,
    scale
  };
}

// ===== TUNNEL GENERATION =====
function generateSegment(zOffset) {
  const curve = {
    x: Math.sin(zOffset * 0.01) * 80 + Math.sin(zOffset * 0.023) * 40,
    y: Math.cos(zOffset * 0.015) * 60 + Math.cos(zOffset * 0.031) * 30
  };
  const radius = TUNNEL_RADIUS + Math.sin(zOffset * 0.005) * 40;
  const hue = (zOffset * 0.3 + level * 30) % 360;
  return { z: zOffset, cx: curve.x, cy: curve.y, radius, hue };
}

function initTunnel() {
  tunnelSegments = [];
  for (let i = 0; i < VIEW_DISTANCE; i++) {
    tunnelSegments.push(generateSegment(i * SEGMENT_DEPTH));
  }
}

// ===== OBSTACLES =====
const OBS_TYPES = [
  { name: 'Debris', color: '#ff4444', radius: 30, damage: 20 },
  { name: 'Energy Wall', color: '#ff8800', radius: 50, damage: 30 },
  { name: 'Dark Matter', color: '#8800ff', radius: 25, damage: 25 },
  { name: 'Gravity Anomaly', color: '#ff00ff', radius: 35, damage: 35 },
  { name: 'Antimatter', color: '#00ffff', radius: 20, damage: 40 }
];

const COLLECT_TYPES = [
  { name: 'Energy', color: '#00ff88', points: 50, effect: 'energy' },
  { name: 'Shield', color: '#00ccff', points: 30, effect: 'shield' },
  { name: 'Boost', color: '#ffaa00', points: 40, effect: 'boost' },
  { name: 'Warp', color: '#ff00ff', points: 100, effect: 'warp' },
  { name: 'Star Crystal', color: '#ffffff', points: 200, effect: 'score' }
];

function spawnObstacle() {
  const type = OBS_TYPES[Math.min(Math.floor(Math.random() * (1 + level * 0.5)), OBS_TYPES.length - 1)];
  const angle = Math.random() * Math.PI * 2;
  const dist = Math.random() * TUNNEL_RADIUS * 0.6;
  obstacles.push({
    x: Math.cos(angle) * dist,
    y: Math.sin(angle) * dist,
    z: VIEW_DISTANCE * SEGMENT_DEPTH,
    type, alive: true, rotation: 0
  });
}

function spawnCollectible() {
  const type = COLLECT_TYPES[Math.floor(Math.random() * COLLECT_TYPES.length)];
  const angle = Math.random() * Math.PI * 2;
  const dist = Math.random() * TUNNEL_RADIUS * 0.4;
  collectibles.push({
    x: Math.cos(angle) * dist,
    y: Math.sin(angle) * dist,
    z: VIEW_DISTANCE * SEGMENT_DEPTH,
    type, alive: true, pulse: 0
  });
}

function spawnParticle(x, y, z, color) {
  for (let i = 0; i < 5; i++) {
    particles.push({
      x: x + (Math.random()-0.5)*20,
      y: y + (Math.random()-0.5)*20,
      z: z,
      vx: (Math.random()-0.5)*100,
      vy: (Math.random()-0.5)*100,
      color, life: 0.5 + Math.random()*0.5,
      maxLife: 0.5 + Math.random()*0.5,
      size: 1 + Math.random()*3
    });
  }
}

// ===== GAME FUNCTIONS =====
function startGame() {
  gSt = ST.PLAY;
  score = 0; distance = 0; speed = 5; baseSpeed = 5;
  level = 1; combo = 0; comboTimer = 0; maxCombo = 0;
  shield = 100; boost = 100; warp = 0;
  boosting = false; braking = false;
  shakeAmt = 0; gameTime = 0;
  totalCollected = 0; obstaclesAvoided = 0;
  currentAbility = 0; abilityCooldowns = [0,0,0];
  playerX = 0; playerY = 0; targetX = 0; targetY = 0;
  tunnelZ = 0;
  obstacles = []; collectibles = []; particles = [];
  initTunnel();
  document.getElementById('title-screen').style.display = 'none';
  document.getElementById('go-scr').style.display = 'none';
  document.getElementById('pause-scr').style.display = 'none';
  document.getElementById('hud').style.display = 'block';
  document.getElementById('scores').style.display = 'block';
  document.getElementById('hint').style.display = 'block';
  sfx.init();
}

function endGame(ending) {
  gSt = ST.OVER;
  addScore(score);
  const titles = { collision: 'COLLISION', warp: 'WARP SUCCESS', black_hole: 'CONSUMED' };
  document.getElementById('go-t').textContent = titles[ending] || 'GAME OVER';
  document.getElementById('go-t').style.color = ending === 'warp' ? '#00ffcc' : '#ff4444';
  document.getElementById('go-fs').textContent = 'Score: ' + score.toLocaleString();
  document.getElementById('go-sg').innerHTML = `
    <span class="gl">Distance</span><span class="gv">${distance.toFixed(1)} ly</span>
    <span class="gl">Level</span><span class="gv">${level}</span>
    <span class="gl">Max Combo</span><span class="gv">${maxCombo}x</span>
    <span class="gl">Collected</span><span class="gv">${totalCollected}</span>
    <span class="gl">Avoided</span><span class="gv">${obstaclesAvoided}</span>
    <span class="gl">Time</span><span class="gv">${Math.floor(gameTime)}s</span>
  `;
  document.getElementById('go-scr').style.display = 'flex';
}

function useAbility() {
  if (abilityCooldowns[currentAbility] > 0) return;
  switch(currentAbility) {
    case 0: // Phase Shift - invincible briefly
      abilityCooldowns[0] = 10;
      shield = Math.min(100, shield + 30);
      // Clear nearby obstacles
      obstacles.forEach(o => { if (o.z < 500 && o.z > 0) { o.alive = false; spawnParticle(o.x, o.y, o.z, '#00ffcc'); obstaclesAvoided++; } });
      sfx.warp();
      shakeAmt = 5;
      break;
    case 1: // Time Warp - slow everything
      abilityCooldowns[1] = 15;
      speed *= 0.3;
      setTimeout(() => { if (gSt === ST.PLAY) speed = baseSpeed * (boosting ? 2 : 1); }, 3000);
      sfx.warp();
      break;
    case 2: // Gravity Pulse - pull collectibles
      abilityCooldowns[2] = 8;
      collectibles.forEach(c => {
        if (c.z < 800) {
          c.x = playerX + (Math.random()-0.5)*20;
          c.y = playerY + (Math.random()-0.5)*20;
        }
      });
      sfx.boost();
      break;
  }
}

// ===== SAVE/LOAD =====
function saveScores() { try { localStorage.setItem('wh_scores', JSON.stringify(highScores)); } catch(e) {} }
function loadScores() { try { const s = localStorage.getItem('wh_scores'); if (s) highScores = JSON.parse(s); } catch(e) {} }
function addScore(s) {
  highScores.push({ score: s, level, dist: distance.toFixed(1), date: new Date().toLocaleDateString() });
  highScores.sort((a,b) => b.score - a.score);
  highScores = highScores.slice(0, 10);
  saveScores();
}
function renderScores() {
  const el = document.getElementById('sc-list');
  if (!highScores.length) { el.innerHTML = '<div style="color:#555">No scores yet</div>'; return; }
  el.innerHTML = highScores.slice(0,5).map((s,i) => `
    <div class="se"><span style="color:#fc8;width:20px">${i+1}.</span><span style="color:#aaa;flex:1">Lv${s.level}</span><span style="color:#fff;font-weight:bold">${s.score.toLocaleString()}</span></div>
  `).join('');
}

// ===== UPDATE =====
let spawnTimerObs = 0, spawnTimerCol = 0, levelTimer = 0;
function update(dt) {
  if (gSt !== ST.PLAY) return;
  gameTime += dt;
  const dc = DIFFS[diff];
  // Player movement
  let ax = 0, ay = 0;
  if (keys['KeyA']||keys['ArrowLeft']) ax -= 1;
  if (keys['KeyD']||keys['ArrowRight']) ax += 1;
  if (keys['KeyW']||keys['ArrowUp']) ay -= 1;
  if (keys['KeyS']||keys['ArrowDown']) ay += 1;
  if (touchD.x||touchD.y) { ax = touchD.x; ay = touchD.y; }
  targetX += ax * 200 * dt;
  targetY += ay * 200 * dt;
  const maxOff = TUNNEL_RADIUS * 0.5;
  targetX = Math.max(-maxOff, Math.min(maxOff, targetX));
  targetY = Math.max(-maxOff, Math.min(maxOff, targetY));
  playerX += (targetX - playerX) * 8 * dt;
  playerY += (targetY - playerY) * 8 * dt;
  // Boost / brake
  boosting = keys['Space'] && boost > 0;
  braking = keys['ShiftLeft'] || keys['ShiftRight'];
  if (boosting) {
    speed = baseSpeed * dc.speed * 2;
    boost -= 30 * dt;
    if (boost <= 0) { boost = 0; boosting = false; }
  } else if (braking) {
    speed = baseSpeed * dc.speed * 0.4;
  } else {
    speed = baseSpeed * dc.speed;
  }
  boost = Math.min(100, boost + 5 * dt);
  // Move through tunnel
  tunnelZ += speed * 60 * dt;
  distance += speed * dt * 0.1;
  score += Math.floor(speed * dt * 10);
  // Level progression
  levelTimer += dt;
  if (levelTimer > 20) {
    levelTimer = 0;
    level++;
    baseSpeed += 0.5;
    sfx.levelUp();
    shakeAmt = 3;
  }
  // Update tunnel segments
  while (tunnelSegments.length > 0 && tunnelSegments[0].z < tunnelZ - SEGMENT_DEPTH) {
    tunnelSegments.shift();
    const lastZ = tunnelSegments.length > 0 ? tunnelSegments[tunnelSegments.length-1].z + SEGMENT_DEPTH : tunnelZ + VIEW_DISTANCE * SEGMENT_DEPTH;
    tunnelSegments.push(generateSegment(lastZ));
  }
  // Spawn
  spawnTimerObs += dt;
  if (spawnTimerObs > 1.5 / dc.obstacleRate / (1 + level * 0.1)) {
    spawnTimerObs = 0;
    spawnObstacle();
  }
  spawnTimerCol += dt;
  if (spawnTimerCol > 1.0 / dc.collectRate) {
    spawnTimerCol = 0;
    spawnCollectible();
  }
  // Update obstacles
  obstacles.forEach(o => {
    o.z -= speed * 60 * dt;
    o.rotation += dt * 2;
    if (o.z < -50) o.alive = false;
    // Collision with player
    if (o.z > -10 && o.z < 50) {
      const dx = o.x - playerX;
      const dy = o.y - playerY;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if (dist < o.type.radius + 15) {
        o.alive = false;
        shield -= o.type.damage;
        shakeAmt = 12;
        sfx.hit();
        spawnParticle(o.x, o.y, o.z, o.type.color);
        combo = 0;
        if (shield <= 0) {
          sfx.explode();
          endGame('collision');
          return;
        }
      }
    }
    // Count avoided
    if (o.z < -10 && o.alive) {
      obstaclesAvoided++;
    }
  });
  obstacles = obstacles.filter(o => o.alive);
  // Update collectibles
  collectibles.forEach(c => {
    c.z -= speed * 60 * dt;
    c.pulse += dt * 3;
    if (c.z < -50) c.alive = false;
    // Collection
    if (c.z > -10 && c.z < 50) {
      const dx = c.x - playerX;
      const dy = c.y - playerY;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if (dist < 30) {
        c.alive = false;
        totalCollected++;
        combo++;
        comboTimer = 2;
        if (combo > maxCombo) maxCombo = combo;
        const pts = c.type.points * (1 + combo * 0.2);
        score += Math.floor(pts);
        sfx.collect();
        if (combo > 3) sfx.combo();
        spawnParticle(c.x, c.y, c.z, c.type.color);
        // Effects
        switch(c.type.effect) {
          case 'shield': shield = Math.min(100, shield + 15); break;
          case 'boost': boost = Math.min(100, boost + 25); break;
          case 'warp': warp = Math.min(100, warp + 20); break;
          case 'energy': baseSpeed += 0.1; break;
        }
      }
    }
  });
  collectibles = collectibles.filter(c => c.alive);
  // Particles
  particles.forEach(p => {
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.z -= speed * 60 * dt;
    p.life -= dt;
  });
  particles = particles.filter(p => p.life > 0);
  // Combo timer
  if (comboTimer > 0) { comboTimer -= dt; if (comboTimer <= 0) combo = 0; }
  // Cooldowns
  for (let i=0;i<3;i++) { if (abilityCooldowns[i]>0) abilityCooldowns[i]-=dt; }
  // Shield regen
  shield = Math.min(100, shield + 1 * dt);
  // Shake decay
  shakeAmt *= 0.9;
  if (shakeAmt < 0.1) shakeAmt = 0;
  // Warp victory
  if (warp >= 100) {
    sfx.warp();
    endGame('warp');
    return;
  }
  // Cap
  if (obstacles.length > 50) obstacles.splice(0, obstacles.length - 50);
  if (collectibles.length > 30) collectibles.splice(0, collectibles.length - 30);
  if (particles.length > 200) particles.splice(0, particles.length - 200);
  // HUD
  updateHUD();
}

function updateHUD() {
  document.getElementById('h-sc').textContent = score.toLocaleString();
  document.getElementById('h-dist').textContent = distance.toFixed(1) + ' ly';
  document.getElementById('h-spd').textContent = (speed * 10).toFixed(0) + ' c';
  document.getElementById('h-lvl').textContent = level;
  document.getElementById('h-cmb').textContent = combo > 0 ? combo + 'x' : '0';
  document.getElementById('bar-sh').style.width = shield + '%';
  document.getElementById('bar-bo').style.width = boost + '%';
  document.getElementById('bar-wp').style.width = warp + '%';
  renderScores();
}

// ===== RENDER =====
function render() {
  ctx.save();
  if (shakeAmt > 0) ctx.translate((Math.random()-0.5)*shakeAmt*2, (Math.random()-0.5)*shakeAmt*2);
  // Background
  const bgGrad = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, canvas.width*0.6);
  bgGrad.addColorStop(0, '#0a0025');
  bgGrad.addColorStop(1, '#000');
  ctx.fillStyle = bgGrad;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  // Stars
  const time = performance.now() * 0.001;
  for (let i = 0; i < 100; i++) {
    const sx = ((i * 137.5 + tunnelZ * 0.01) % canvas.width);
    const sy = ((i * 97.3 + tunnelZ * 0.005) % canvas.height);
    const b = 0.3 + Math.sin(time * (0.5 + i * 0.02) + i) * 0.3;
    ctx.fillStyle = `rgba(255,255,255,${b})`;
    ctx.fillRect(sx, sy, 1 + (i%3===0?1:0), 1);
  }
  if (gSt === ST.PLAY || gSt === ST.PAUSE) {
    // Render tunnel
    for (let i = tunnelSegments.length - 1; i >= 0; i--) {
      const seg = tunnelSegments[i];
      const relZ = seg.z - tunnelZ;
      if (relZ < 0 || relZ > VIEW_DISTANCE * SEGMENT_DEPTH) continue;
      const p = project(seg.cx, seg.cy, relZ);
      if (!p) continue;
      const r = seg.radius * p.scale;
      if (r < 1) continue;
      // Tunnel ring
      const alpha = Math.max(0.05, 1 - relZ / (VIEW_DISTANCE * SEGMENT_DEPTH));
      const hue = seg.hue;
      ctx.beginPath();
      ctx.arc(p.sx, p.sy, r, 0, Math.PI * 2);
      ctx.strokeStyle = `hsla(${hue}, 80%, 50%, ${alpha * 0.3})`;
      ctx.lineWidth = Math.max(1, 3 * p.scale);
      ctx.stroke();
      // Inner glow
      if (i % 3 === 0) {
        const gg = ctx.createRadialGradient(p.sx, p.sy, r * 0.8, p.sx, p.sy, r);
        gg.addColorStop(0, 'transparent');
        gg.addColorStop(1, `hsla(${hue}, 80%, 50%, ${alpha * 0.05})`);
        ctx.beginPath();
        ctx.arc(p.sx, p.sy, r, 0, Math.PI * 2);
        ctx.fillStyle = gg;
        ctx.fill();
      }
    }
    // Render obstacles
    obstacles.forEach(o => {
      const relZ = o.z;
      if (relZ < 0 || relZ > VIEW_DISTANCE * SEGMENT_DEPTH) return;
      // Find tunnel center at this Z
      const segIdx = Math.floor(relZ / SEGMENT_DEPTH);
      const seg = tunnelSegments[segIdx] || tunnelSegments[tunnelSegments.length - 1];
      const wx = o.x + (seg ? seg.cx : 0);
      const wy = o.y + (seg ? seg.cy : 0);
      const p = project(wx, wy, relZ);
      if (!p) return;
      const r = o.type.radius * p.scale;
      if (r < 1) return;
      // Glow
      const gg = ctx.createRadialGradient(p.sx, p.sy, 0, p.sx, p.sy, r * 2);
      gg.addColorStop(0, o.type.color + '60');
      gg.addColorStop(1, 'transparent');
      ctx.beginPath(); ctx.arc(p.sx, p.sy, r * 2, 0, Math.PI * 2);
      ctx.fillStyle = gg; ctx.fill();
      // Body
      ctx.save();
      ctx.translate(p.sx, p.sy);
      ctx.rotate(o.rotation);
      ctx.beginPath();
      for (let j = 0; j < 6; j++) {
        const a = (j / 6) * Math.PI * 2;
        const pr = r * (0.8 + Math.sin(j * 2.5) * 0.2);
        if (j === 0) ctx.moveTo(Math.cos(a)*pr, Math.sin(a)*pr);
        else ctx.lineTo(Math.cos(a)*pr, Math.sin(a)*pr);
      }
      ctx.closePath();
      ctx.fillStyle = o.type.color;
      ctx.fill();
      ctx.restore();
    });
    // Render collectibles
    collectibles.forEach(c => {
      const relZ = c.z;
      if (relZ < 0 || relZ > VIEW_DISTANCE * SEGMENT_DEPTH) return;
      const segIdx = Math.floor(relZ / SEGMENT_DEPTH);
      const seg = tunnelSegments[segIdx] || tunnelSegments[tunnelSegments.length - 1];
      const wx = c.x + (seg ? seg.cx : 0);
      const wy = c.y + (seg ? seg.cy : 0);
      const p = project(wx, wy, relZ);
      if (!p) return;
      const r = 10 * p.scale * (1 + Math.sin(c.pulse) * 0.2);
      if (r < 1) return;
      const gg = ctx.createRadialGradient(p.sx, p.sy, 0, p.sx, p.sy, r * 3);
      gg.addColorStop(0, c.type.color + '80');
      gg.addColorStop(1, 'transparent');
      ctx.beginPath(); ctx.arc(p.sx, p.sy, r * 3, 0, Math.PI * 2);
      ctx.fillStyle = gg; ctx.fill();
      ctx.beginPath(); ctx.arc(p.sx, p.sy, r, 0, Math.PI * 2);
      ctx.fillStyle = c.type.color;
      ctx.fill();
    });
    // Render particles
    particles.forEach(p => {
      const relZ = p.z;
      if (relZ < 0) return;
      const pr = project(p.x, p.y, relZ);
      if (!pr) return;
      const alpha = p.life / p.maxLife;
      ctx.fillStyle = p.color + Math.floor(alpha * 200).toString(16).padStart(2, '0');
      ctx.beginPath();
      ctx.arc(pr.sx, pr.sy, p.size * pr.scale, 0, Math.PI * 2);
      ctx.fill();
    });
    // Player ship
    const px = canvas.width/2 + playerX * 2;
    const py = canvas.height/2 + playerY * 2;
    // Ship glow
    const sgr = ctx.createRadialGradient(px, py, 0, px, py, 30);
    sgr.addColorStop(0, boosting ? 'rgba(255,136,0,0.3)' : 'rgba(0,255,200,0.2)');
    sgr.addColorStop(1, 'transparent');
    ctx.beginPath(); ctx.arc(px, py, 30, 0, Math.PI * 2);
    ctx.fillStyle = sgr; ctx.fill();
    // Ship body
    ctx.save();
    ctx.translate(px, py);
    ctx.beginPath();
    ctx.moveTo(0, -12);
    ctx.lineTo(-10, 10);
    ctx.lineTo(0, 6);
    ctx.lineTo(10, 10);
    ctx.closePath();
    ctx.fillStyle = boosting ? '#ff8800' : '#00ffcc';
    ctx.fill();
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1;
    ctx.stroke();
    // Engine glow
    if (boosting) {
      ctx.beginPath();
      ctx.moveTo(-6, 10);
      ctx.lineTo(0, 25 + Math.random() * 10);
      ctx.lineTo(6, 10);
      ctx.fillStyle = 'rgba(255,136,0,0.6)';
      ctx.fill();
    } else {
      ctx.beginPath();
      ctx.moveTo(-4, 8);
      ctx.lineTo(0, 15 + Math.random() * 5);
      ctx.lineTo(4, 8);
      ctx.fillStyle = 'rgba(0,255,200,0.4)';
      ctx.fill();
    }
    ctx.restore();
    // Speed lines when boosting
    if (boosting) {
      for (let i = 0; i < 10; i++) {
        const lx = canvas.width * Math.random();
        const ly = canvas.height * Math.random();
        const len = 20 + Math.random() * 40;
        ctx.beginPath();
        ctx.moveTo(lx, ly);
        ctx.lineTo(lx, ly + len);
        ctx.strokeStyle = 'rgba(255,255,255,0.1)';
        ctx.lineWidth = 1;
        ctx.stroke();
      }
    }
    // Combo display
    if (combo > 2) {
      ctx.fillStyle = `rgba(0,255,200,${Math.min(1, combo * 0.1)})`;
      ctx.font = `bold ${18+combo}px sans-serif`;
      ctx.textAlign = 'right';
      ctx.fillText(combo + 'x', canvas.width - 20, canvas.height/2);
    }
    // Wormhole center effect
    const whGrad = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, 50);
    whGrad.addColorStop(0, 'rgba(0,255,200,0.05)');
    whGrad.addColorStop(1, 'transparent');
    ctx.beginPath();
    ctx.arc(canvas.width/2, canvas.height/2, 50, 0, Math.PI * 2);
    ctx.fillStyle = whGrad;
    ctx.fill();
  }
  ctx.restore();
}

// ===== INPUT =====
document.addEventListener('keydown', e => {
  keys[e.code] = true;
  if (e.code === 'Escape') {
    if (gSt === ST.PLAY) { gSt = ST.PAUSE; document.getElementById('pause-scr').style.display = 'flex'; }
    else if (gSt === ST.PAUSE) { gSt = ST.PLAY; document.getElementById('pause-scr').style.display = 'none'; }
  }
  if (e.code === 'KeyR' && (gSt === ST.OVER || gSt === ST.PLAY)) startGame();
  if (e.code === 'Space') e.preventDefault();
  if (e.code === 'Digit1') currentAbility = 0;
  if (e.code === 'Digit2') currentAbility = 1;
  if (e.code === 'Digit3') currentAbility = 2;
  if (e.code === 'KeyE') useAbility();
});
document.addEventListener('keyup', e => { keys[e.code] = false; });

// Touch
['tl','tr','tu','td','tbo'].forEach(id => {
  const el = document.getElementById(id);
  if (!el) return;
  el.addEventListener('touchstart', e => {
    e.preventDefault(); sfx.init();
    if (id==='tl') touchD.x=-1; if (id==='tr') touchD.x=1;
    if (id==='tu') touchD.y=-1; if (id==='td') touchD.y=1;
    if (id==='tbo') keys['Space']=true;
  }, {passive:false});
  el.addEventListener('touchend', () => {
    if (id==='tl'||id==='tr') touchD.x=0;
    if (id==='tu'||id==='td') touchD.y=0;
    if (id==='tbo') keys['Space']=false;
  });
});

// Menu
document.querySelectorAll('.db').forEach(b => {
  b.addEventListener('click', () => {
    document.querySelectorAll('.db').forEach(x => x.classList.remove('active'));
    b.classList.add('active'); diff = b.dataset.d; sfx.init(); sfx.click();
  });
});
document.getElementById('b-start').addEventListener('click', () => { sfx.init(); sfx.click(); startGame(); });
document.getElementById('b-tut').addEventListener('click', () => { sfx.init(); sfx.click(); startGame(); });
document.getElementById('b-res').addEventListener('click', () => { gSt=ST.PLAY; document.getElementById('pause-scr').style.display='none'; sfx.click(); });
document.getElementById('b-quit').addEventListener('click', () => { gSt=ST.TITLE; document.getElementById('pause-scr').style.display='none'; document.getElementById('title-screen').style.display='flex'; document.getElementById('hud').style.display='none'; document.getElementById('scores').style.display='none'; sfx.click(); });
document.getElementById('b-retry').addEventListener('click', () => { sfx.click(); startGame(); });
document.getElementById('b-menu').addEventListener('click', () => { gSt=ST.TITLE; document.getElementById('go-scr').style.display='none'; document.getElementById('title-screen').style.display='flex'; document.getElementById('hud').style.display='none'; document.getElementById('scores').style.display='none'; sfx.click(); });

// ===== LOOP =====
let lastT = 0;
function loop(ts) {
  const dt = Math.min((ts-lastT)/1000, 0.05);
  lastT = ts;
  update(dt);
  render();
  requestAnimationFrame(loop);
}
loadScores();
renderScores();
lastT = performance.now();
requestAnimationFrame(loop);
</script>
</body>
</html>