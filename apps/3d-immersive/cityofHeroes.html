<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hero City - Superhero RPG</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #0a0a0a;
            color: #fff;
            overflow: hidden;
        }

        #three-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        .game-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
            height: 100vh;
            pointer-events: none;
        }

        .game-container > * {
            pointer-events: auto;
        }

        /* Character Creation Screen */
        .character-creation {
            background: linear-gradient(180deg, #003366 0%, #001a33 100%);
            border: 2px solid #00ccff;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 0 20px rgba(0,204,255,0.5);
            max-width: 800px;
            margin: 50px auto;
        }

        .creation-header h1 {
            font-size: 3.5em;
            color: #00ffcc;
            text-shadow: 0 0 10px #00ffcc;
            font-family: 'Impact', sans-serif;
            letter-spacing: 2px;
        }

        .archetype-card {
            background: rgba(0, 51, 102, 0.6);
            border: 1px solid #00ccff;
            border-radius: 5px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .archetype-card:hover {
            background: rgba(0, 204, 255, 0.2);
            border-color: #00ffcc;
        }

        .archetype-card.selected {
            background: rgba(0, 255, 204, 0.2);
            border-color: #00ffcc;
            box-shadow: 0 0 15px #00ffcc;
        }

        /* Game HUD */
        .game-hud {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(180deg, rgba(0, 51, 102, 0.9) 0%, rgba(0, 26, 51, 0.7) 100%);
            border-bottom: 2px solid #00ccff;
            padding: 10px 20px;
            z-index: 1000;
            display: none;
        }

        .health-bar {
            background: #330000;
            border: 1px solid #ff0000;
            height: 25px;
            box-shadow: inset 0 0 5px #000;
        }

        .health-fill {
            background: linear-gradient(90deg, #cc0000 0%, #ff3333 100%);
        }

        .xp-bar {
            background: #001a00;
            border: 1px solid #00ff00;
            height: 15px;
        }

        .xp-fill {
            background: linear-gradient(90deg, #006600 0%, #00cc00 100%);
        }

        /* Power Bar */
        .power-bar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 26, 51, 0.8);
            border: 2px solid #00ccff;
            border-radius: 10px;
            padding: 10px;
            display: flex;
            gap: 10px;
            backdrop-filter: blur(5px);
        }

        .power-button {
            width: 60px;
            height: 60px;
            background: #003366;
            border: 2px solid #00ccff;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 0.8em;
            color: #fff;
            cursor: pointer;
        }

        .power-button:hover {
            background: #004d99;
            border-color: #00ffcc;
        }

        .power-button.on-cooldown {
            opacity: 0.5;
        }

        /* Controls Hint */
        .controls-hint {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #00ccff;
            font-size: 0.9em;
            color: #00ccff;
        }

        /* Game World */
        .game-world {
            display: none;
            min-height: 100vh;
            padding-top: 80px;
            background: transparent;
            pointer-events: none;
        }

        .game-world > * {
            pointer-events: auto;
        }

        .zone-header {
            position: fixed;
            top: 15%;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: none;
            animation: fadeOut 5s forwards;
        }

        @keyframes fadeOut {
            0% { opacity: 0; transform: translate(-50%, -20px); }
            10% { opacity: 1; transform: translate(-50%, 0); }
            80% { opacity: 1; }
            100% { opacity: 0; }
        }

        .zone-name {
            font-size: 2.5em;
            background: linear-gradient(45deg, #ff6b6b, #ffd93d);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .mission-board {
            background: rgba(0, 26, 51, 0.8);
            border: 2px solid #00ccff;
            border-radius: 10px;
            padding: 20px;
            margin: 20px;
            backdrop-filter: blur(5px);
            max-width: 300px;
            position: fixed;
            right: 20px;
            top: 100px;
        }

        .mission-card {
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .mission-card:hover {
            border-color: #ffd93d;
            transform: translateX(10px);
            background: rgba(255, 255, 255, 0.2);
        }

        .mission-title {
            font-size: 1.3em;
            color: #ffd93d;
            margin-bottom: 10px;
        }

        .mission-reward {
            color: #00ff88;
            font-weight: bold;
        }

        /* Combat System */
        .combat-arena {
            background: rgba(0, 26, 51, 0.8);
            border: 2px solid #00ccff;
            border-radius: 10px;
            padding: 30px;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 800px;
            display: none;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 30px rgba(0, 204, 255, 0.3);
        }

        .combat-participants {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
        }

        .combatant {
            text-align: center;
            flex: 1;
        }

        .combatant-sprite {
            width: 150px;
            height: 150px;
            background: rgba(255,255,255,0.1);
            border-radius: 50%;
            margin: 0 auto 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4em;
            position: relative;
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        .enemy-sprite {
            background: rgba(255,0,0,0.2);
            border: 3px solid #ff4444;
        }

        .hero-sprite {
            background: rgba(0,255,136,0.2);
            border: 3px solid #00ff88;
        }

        .damage-number {
            position: absolute;
            font-size: 2em;
            font-weight: bold;
            animation: damageFloat 1s ease-out forwards;
            pointer-events: none;
        }

        @keyframes damageFloat {
            0% {
                transform: translateY(0);
                opacity: 1;
            }
            100% {
                transform: translateY(-50px);
                opacity: 0;
            }
        }

        .power-bar {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .power-button {
            background: linear-gradient(45deg, #ff6b6b, #ff4444);
            border: none;
            padding: 15px 25px;
            border-radius: 10px;
            color: #fff;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .power-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 20px rgba(255,107,107,0.5);
        }

        .power-button:disabled {
            background: #444;
            cursor: not-allowed;
            transform: none;
        }

        .power-button.on-cooldown::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            animation: cooldown var(--cooldown-time) linear forwards;
        }

        @keyframes cooldown {
            from { transform: scaleX(1); transform-origin: left; }
            to { transform: scaleX(0); transform-origin: left; }
        }

        .combat-log {
            background: rgba(0,0,0,0.5);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 5px;
            border-left: 3px solid #00ccff;
            padding-left: 10px;
        }

        .victory-screen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(180deg, #003366 0%, #001a33 100%);
            border: 2px solid #00ffcc;
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 2000;
            box-shadow: 0 0 50px rgba(0,255,204,0.5);
        }

        .victory-title {
            font-size: 3em;
            color: #00ff88;
            margin-bottom: 20px;
        }

        .rewards {
            font-size: 1.2em;
            margin-bottom: 30px;
        }

        .continue-btn {
            background: linear-gradient(45deg, #00ff88, #00ccff);
            border: none;
            padding: 15px 30px;
            border-radius: 30px;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .continue-btn:hover {
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <div id="three-container"></div>
    <div class="game-container">
        <!-- Character Creation Screen -->
        <div class="character-creation" id="characterCreation">
            <div class="creation-header">
                <h1>Hero City</h1>
                <p>Create Your Superhero</p>
            </div>

            <div class="form-group">
                <label for="heroName">Hero Name</label>
                <input type="text" id="heroName" placeholder="Enter your hero's name">
            </div>

            <div class="form-group">
                <label>Choose Your Archetype</label>
                <div class="archetype-grid">
                    <div class="archetype-card" data-archetype="tank">
                        <div class="archetype-icon">üõ°Ô∏è</div>
                        <h3>Tank</h3>
                        <p>High defense, protects allies</p>
                    </div>
                    <div class="archetype-card" data-archetype="blaster">
                        <div class="archetype-icon">üí•</div>
                        <h3>Blaster</h3>
                        <p>High damage, ranged attacks</p>
                    </div>
                    <div class="archetype-card" data-archetype="scrapper">
                        <div class="archetype-icon">‚öîÔ∏è</div>
                        <h3>Scrapper</h3>
                        <p>Melee damage, critical hits</p>
                    </div>
                    <div class="archetype-card" data-archetype="controller">
                        <div class="archetype-icon">üîÆ</div>
                        <h3>Controller</h3>
                        <p>Crowd control, support</p>
                    </div>
                </div>
            </div>

            <div class="power-selection">
                <label>Select Your Primary Power Set</label>
                <div class="power-grid" id="powerGrid">
                    <!-- Powers will be populated based on archetype -->
                </div>
            </div>

            <button class="create-hero-btn" id="createHeroBtn">Create Hero</button>
        </div>

        <!-- Game HUD -->
        <div class="game-hud" id="gameHUD">
            <div class="hud-content">
                <div class="hero-info">
                    <div>
                        <strong id="heroNameDisplay"></strong>
                        <span id="heroLevel">Level 1</span>
                    </div>
                    <div>
                        <div class="health-bar">
                            <div class="health-fill" id="healthBar" style="width: 100%"></div>
                            <span class="bar-text" id="healthText">100/100</span>
                        </div>
                    </div>
                    <div>
                        <div class="xp-bar">
                            <div class="xp-fill" id="xpBar" style="width: 0%"></div>
                            <span class="bar-text" id="xpText">0/100</span>
                        </div>
                    </div>
                </div>
                <div>
                    <span>Zone: </span><span id="currentZone">Atlas Park</span>
                </div>
            </div>
        </div>

        <!-- Game World -->
        <div class="game-world" id="gameWorld">
            <div class="zone-header">
                <h2 class="zone-name">Atlas Park</h2>
                <p>The heart of Hero City - where every hero's journey begins</p>
            </div>

            <div class="controls-hint">
                <strong>Controls:</strong><br>
                WASD: Move Hero<br>
                Mouse Drag: Rotate Camera<br>
                Mouse Wheel: Zoom<br>
                1-3: Use Powers (in combat)
            </div>

            <div class="mission-board" id="missionBoard">
                <h3>Nearby Threats</h3>
                <p>Walk around the city to find enemies, or select a mission below:</p>
                <div class="mission-card" onclick="startMission('thugs')">
                    <div class="mission-title">Stop the Street Thugs</div>
                    <p>A gang of thugs is terrorizing citizens in the park.</p>
                    <p class="mission-reward">Reward: 50 XP</p>
                </div>
                <div class="mission-card" onclick="startMission('robots')">
                    <div class="mission-title">Clockwork Invasion</div>
                    <p>Clockwork robots are causing havoc downtown.</p>
                    <p class="mission-reward">Reward: 100 XP</p>
                </div>
                <div class="mission-card" onclick="startMission('boss')">
                    <div class="mission-title">Boss Battle: Dr. Vortex</div>
                    <p>The evil Dr. Vortex threatens the city!</p>
                    <p class="mission-reward">Reward: 200 XP</p>
                </div>
            </div>

            <!-- Combat Arena -->
            <div class="combat-arena" id="combatArena">
                <div class="combat-participants">
                    <div class="combatant">
                        <div class="combatant-sprite hero-sprite" id="heroSprite">ü¶∏</div>
                        <h3 id="combatHeroName">Hero</h3>
                        <div class="health-bar">
                            <div class="health-fill" id="heroHealthBar" style="width: 100%"></div>
                            <span class="bar-text" id="heroHealthText">100/100</span>
                        </div>
                    </div>
                    <div class="combatant">
                        <div class="combatant-sprite enemy-sprite" id="enemySprite">üëø</div>
                        <h3 id="enemyName">Enemy</h3>
                        <div class="health-bar">
                            <div class="health-fill" id="enemyHealthBar" style="width: 100%"></div>
                            <span class="bar-text" id="enemyHealthText">100/100</span>
                        </div>
                    </div>
                </div>

                <div class="power-bar" id="powerBar">
                    <!-- Powers will be populated here -->
                </div>

                <div class="combat-log" id="combatLog"></div>
            </div>
        </div>

        <!-- Victory Screen -->
        <div class="victory-screen" id="victoryScreen">
            <h2 class="victory-title">Victory!</h2>
            <div class="rewards" id="rewardText"></div>
            <button class="continue-btn" onclick="continueMission()">Continue</button>
        </div>
    </div>

    <script>
        // 3D Engine
        class ThreeEngine {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                document.getElementById('three-container').appendChild(this.renderer.domElement);

                this.buildings = [];
                this.heroMesh = null;
                this.enemyMesh = null;
                this.particles = [];
                this.keys = {};
                this.mouse = { x: 0, y: 0, down: false };
                this.cameraRotation = { x: -0.5, y: 0 };
                this.cameraDistance = 15;

                this.init();
                this.animate();
                this.setupControls();
            }

            setupControls() {
                window.addEventListener('keydown', (e) => this.keys[e.key.toLowerCase()] = true);
                window.addEventListener('keyup', (e) => this.keys[e.key.toLowerCase()] = false);
                
                window.addEventListener('mousedown', () => this.mouse.down = true);
                window.addEventListener('mouseup', () => this.mouse.down = false);
                window.addEventListener('mousemove', (e) => {
                    if (this.mouse.down) {
                        this.cameraRotation.y -= e.movementX * 0.005;
                        this.cameraRotation.x -= e.movementY * 0.005;
                        this.cameraRotation.x = Math.max(-Math.PI/2, Math.min(0, this.cameraRotation.x));
                    }
                });
                window.addEventListener('wheel', (e) => {
                    this.cameraDistance = Math.max(5, Math.min(50, this.cameraDistance + e.deltaY * 0.05));
                });
            }

            init() {
                // Scene background
                this.scene.background = new THREE.Color(0x050510);
                this.scene.fog = new THREE.FogExp2(0x050510, 0.01);

                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
                this.scene.add(ambientLight);

                const sunLight = new THREE.DirectionalLight(0x00ccff, 1);
                sunLight.position.set(50, 100, 50);
                sunLight.castShadow = true;
                this.scene.add(sunLight);

                // Ground
                const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
                const groundMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x111111,
                    side: THREE.DoubleSide
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = Math.PI / 2;
                ground.receiveShadow = true;
                this.scene.add(ground);

                // Grid helper
                const grid = new THREE.GridHelper(1000, 100, 0x00ccff, 0x222222);
                this.scene.add(grid);

                // Stars
                const starGeom = new THREE.BufferGeometry();
                const starCoords = [];
                for(let i=0; i<2000; i++) {
                    starCoords.push((Math.random()-0.5)*1000, Math.random()*500, (Math.random()-0.5)*1000);
                }
                starGeom.setAttribute('position', new THREE.Float32BufferAttribute(starCoords, 3));
                const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5 });
                const stars = new THREE.Points(starGeom, starMat);
                this.scene.add(stars);

                this.createCity();

                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            createCity() {
                // Atlas Statue Placeholder
                const statueBase = new THREE.Mesh(
                    new THREE.CylinderGeometry(5, 6, 4, 8),
                    new THREE.MeshPhongMaterial({ color: 0x444444 })
                );
                statueBase.position.set(0, 2, 0);
                this.scene.add(statueBase);

                const statue = new THREE.Mesh(
                    new THREE.SphereGeometry(3, 16, 16),
                    new THREE.MeshPhongMaterial({ color: 0x888844, emissive: 0x444422 })
                );
                statue.position.set(0, 8, 0);
                this.scene.add(statue);

                // City Hall Placeholder
                const hall = new THREE.Mesh(
                    new THREE.BoxGeometry(20, 15, 10),
                    new THREE.MeshPhongMaterial({ color: 0x333333 })
                );
                hall.position.set(0, 7.5, -30);
                this.scene.add(hall);

                const pillars = [];
                for(let i=-8; i<=8; i+=4) {
                    const p = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 15), new THREE.MeshPhongMaterial({color: 0x555555}));
                    p.position.set(i, 7.5, -24);
                    this.scene.add(p);
                }

                // Buildings
                const buildingGeom = new THREE.BoxGeometry(1, 1, 1);
                for (let i = 0; i < 200; i++) {
                    const h = 10 + Math.random() * 40;
                    const w = 5 + Math.random() * 10;
                    const d = 5 + Math.random() * 10;
                    
                    const material = new THREE.MeshPhongMaterial({ 
                        color: 0x1a1a2e,
                        emissive: 0x001133,
                    });
                    
                    const building = new THREE.Mesh(buildingGeom, material);
                    building.scale.set(w, h, d);
                    
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 40 + Math.random() * 200;
                    building.position.set(
                        Math.cos(angle) * radius,
                        h / 2,
                        Math.sin(angle) * radius
                    );
                    
                    if (Math.random() > 0.3) {
                        building.material.emissive.setHex(Math.random() > 0.5 ? 0x00ccff : 0xffd93d);
                        building.material.emissiveIntensity = 0.4;
                    }

                    building.castShadow = true;
                    building.receiveShadow = true;
                    this.scene.add(building);
                    this.buildings.push(building);
                }
            }

            createHeroMesh(archetype) {
                if (this.heroMesh) this.scene.remove(this.heroMesh);

                const group = new THREE.Group();
                
                let color = 0x00ff88;
                if (archetype === 'tank') color = 0x00ccff;
                if (archetype === 'blaster') color = 0xff6b6b;
                if (archetype === 'scrapper') color = 0xffd93d;

                const mat = new THREE.MeshPhongMaterial({ color: color });

                // Targeting Ring
                const ringGeom = new THREE.RingGeometry(0.8, 1, 32);
                const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide, transparent: true, opacity: 0.5 });
                const ring = new THREE.Mesh(ringGeom, ringMat);
                ring.rotation.x = Math.PI / 2;
                ring.position.y = 0.05;
                group.add(ring);

                // Torso
                const torso = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.2, 0.5), mat);
                torso.position.y = 1.6;
                group.add(torso);

                // Head
                const head = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), mat);
                head.position.y = 2.4;
                group.add(head);

                // Arms
                const armGeom = new THREE.BoxGeometry(0.25, 1, 0.25);
                const leftArm = new THREE.Mesh(armGeom, mat);
                leftArm.position.set(-0.55, 1.6, 0);
                group.add(leftArm);
                const rightArm = new THREE.Mesh(armGeom, mat);
                rightArm.position.set(0.55, 1.6, 0);
                group.add(rightArm);

                // Legs
                const legGeom = new THREE.BoxGeometry(0.3, 1, 0.3);
                const leftLeg = new THREE.Mesh(legGeom, mat);
                leftLeg.position.set(-0.25, 0.5, 0);
                group.add(leftLeg);
                const rightLeg = new THREE.Mesh(legGeom, mat);
                rightLeg.position.set(0.25, 0.5, 0);
                group.add(rightLeg);

                // Cape
                const capeGeom = new THREE.PlaneGeometry(0.8, 1.8);
                const capeMat = new THREE.MeshPhongMaterial({ color: 0xcc0000, side: THREE.DoubleSide });
                const cape = new THREE.Mesh(capeGeom, capeMat);
                cape.position.set(0, 1.5, -0.3);
                cape.rotation.x = 0.1;
                group.add(cape);

                group.position.set(0, 0, 20);
                group.rotation.y = Math.PI; // Face the statue
                this.scene.add(group);
                this.heroMesh = group;
            }

            createEnemyMesh(type) {
                if (this.enemyMesh) this.scene.remove(this.enemyMesh);

                const group = new THREE.Group();
                let color = 0x888888;
                if (type === 'robots') color = 0x00ccff;
                if (type === 'boss') color = 0xff00ff;

                const mat = new THREE.MeshPhongMaterial({ color: color });

                // Targeting Ring (Red for enemy)
                const ringGeom = new THREE.RingGeometry(1, 1.2, 32);
                const ringMat = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide, transparent: true, opacity: 0.5 });
                const ring = new THREE.Mesh(ringGeom, ringMat);
                ring.rotation.x = Math.PI / 2;
                ring.position.y = 0.05;
                group.add(ring);

                const body = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), mat);
                body.position.y = 1;
                group.add(body);

                const head = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), mat);
                head.position.y = 2.3;
                group.add(head);

                group.position.copy(this.heroMesh.position).add(new THREE.Vector3(0, 0, -10));
                this.scene.add(group);
                this.enemyMesh = group;
            }

            removeEnemyMesh() {
                if (this.enemyMesh) {
                    this.scene.remove(this.enemyMesh);
                    this.enemyMesh = null;
                }
            }

            spawnEffect(position, color) {
                for (let i = 0; i < 30; i++) {
                    const geom = new THREE.SphereGeometry(0.15, 8, 8);
                    const mat = new THREE.MeshBasicMaterial({ color: color, transparent: true });
                    const p = new THREE.Mesh(geom, mat);
                    p.position.copy(position).add(new THREE.Vector3(
                        (Math.random()-0.5)*2,
                        Math.random()*2,
                        (Math.random()-0.5)*2
                    ));
                    p.userData.velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 0.3,
                        Math.random() * 0.3,
                        (Math.random() - 0.5) * 0.3
                    );
                    p.userData.life = 1.0;
                    this.scene.add(p);
                    this.particles.push(p);
                }
            }

            updateMovement() {
                if (!this.heroMesh || gameState.inCombat) return;

                const speed = 0.4;
                const rotationSpeed = 0.06;
                let moving = false;

                if (this.keys['w']) {
                    this.heroMesh.translateZ(-speed);
                    moving = true;
                }
                if (this.keys['s']) {
                    this.heroMesh.translateZ(speed);
                    moving = true;
                }
                if (this.keys['a']) {
                    this.heroMesh.rotation.y += rotationSpeed;
                }
                if (this.keys['d']) {
                    this.heroMesh.rotation.y -= rotationSpeed;
                }

                // Update camera to follow hero
                const relativeCameraOffset = new THREE.Vector3(0, 6, this.cameraDistance);
                const cameraOffset = relativeCameraOffset.applyMatrix4(this.heroMesh.matrixWorld);
                
                this.camera.position.lerp(cameraOffset, 0.1);
                this.camera.lookAt(this.heroMesh.position.clone().add(new THREE.Vector3(0, 2, 0)));
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                const time = Date.now() * 0.001;

                this.updateMovement();

                // Animate hero idle
                if (this.heroMesh) {
                    this.heroMesh.children.forEach(child => {
                        if (child.geometry.type === 'PlaneGeometry') { // Cape
                            child.rotation.x = 0.1 + Math.sin(time * 5) * 0.1;
                        }
                    });
                }

                // Particles
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.position.add(p.userData.velocity);
                    p.userData.life -= 0.02;
                    p.material.opacity = p.userData.life;
                    p.scale.setScalar(p.userData.life);
                    if (p.userData.life <= 0) {
                        this.scene.remove(p);
                        this.particles.splice(i, 1);
                    }
                }

                this.renderer.render(this.scene, this.camera);
            }

            setCombatView(inCombat) {
                if (inCombat) {
                    // Fixed combat camera
                    const combatPos = this.heroMesh.position.clone().add(new THREE.Vector3(10, 5, 0));
                    this.camera.position.copy(combatPos);
                    this.camera.lookAt(this.heroMesh.position.clone().add(new THREE.Vector3(0, 1, -5)));
                }
            }
        }

        const engine = new ThreeEngine();

        // Game State
        let gameState = {
            hero: null,
            currentEnemy: null,
            inCombat: false,
            combatLog: []
        };

        // Archetype Data
        const archetypes = {
            tank: {
                baseHealth: 150,
                baseDamage: 20,
                defense: 30,
                powers: [
                    { name: "Shield Bash", damage: 25, cooldown: 2000, icon: "üõ°Ô∏è" },
                    { name: "Taunt", damage: 10, cooldown: 3000, icon: "üò§" },
                    { name: "Fortify", damage: 0, heal: 30, cooldown: 5000, icon: "üèõÔ∏è" }
                ]
            },
            blaster: {
                baseHealth: 80,
                baseDamage: 40,
                defense: 10,
                powers: [
                    { name: "Energy Blast", damage: 50, cooldown: 2000, icon: "‚ö°" },
                    { name: "Nova", damage: 80, cooldown: 5000, icon: "üí•" },
                    { name: "Snipe", damage: 100, cooldown: 7000, icon: "üéØ" }
                ]
            },
            scrapper: {
                baseHealth: 100,
                baseDamage: 35,
                defense: 20,
                powers: [
                    { name: "Slash", damage: 40, cooldown: 1500, icon: "‚öîÔ∏è" },
                    { name: "Critical Strike", damage: 70, cooldown: 4000, icon: "üí´" },
                    { name: "Whirlwind", damage: 30, cooldown: 3000, icon: "üå™Ô∏è" }
                ]
            },
            controller: {
                baseHealth: 90,
                baseDamage: 25,
                defense: 15,
                powers: [
                    { name: "Mind Control", damage: 20, cooldown: 2000, icon: "üß†" },
                    { name: "Freeze", damage: 30, cooldown: 3000, icon: "‚ùÑÔ∏è" },
                    { name: "Heal", damage: 0, heal: 50, cooldown: 4000, icon: "üíö" }
                ]
            }
        };

        // Enemy Types
        const enemies = {
            thugs: {
                name: "Street Thug",
                health: 50,
                damage: 15,
                xpReward: 50,
                sprite: "ü¶π‚Äç‚ôÇÔ∏è"
            },
            robots: {
                name: "Clockwork Robot",
                health: 80,
                damage: 25,
                xpReward: 100,
                sprite: "ü§ñ"
            },
            boss: {
                name: "Dr. Vortex",
                health: 200,
                damage: 40,
                xpReward: 200,
                sprite: "üëæ"
            }
        };

        // Character Creation
        document.querySelectorAll('.archetype-card').forEach(card => {
            card.addEventListener('click', function() {
                document.querySelectorAll('.archetype-card').forEach(c => c.classList.remove('selected'));
                this.classList.add('selected');
                
                const archetype = this.dataset.archetype;
                populatePowers(archetype);
            });
        });

        function populatePowers(archetype) {
            const powerGrid = document.getElementById('powerGrid');
            powerGrid.innerHTML = '';
            
            archetypes[archetype].powers.forEach((power, index) => {
                const powerCard = document.createElement('div');
                powerCard.className = 'power-card';
                powerCard.innerHTML = `
                    <div style="font-size: 2em">${power.icon}</div>
                    <h4>${power.name}</h4>
                    <p>Damage: ${power.damage || 'N/A'}</p>
                    ${power.heal ? `<p>Heal: ${power.heal}</p>` : ''}
                `;
                powerGrid.appendChild(powerCard);
            });
        }

        // Create Hero
        document.getElementById('createHeroBtn').addEventListener('click', function() {
            const heroName = document.getElementById('heroName').value.trim();
            const selectedArchetype = document.querySelector('.archetype-card.selected');
            
            if (!heroName) {
                alert('Please enter a hero name!');
                return;
            }
            
            if (!selectedArchetype) {
                alert('Please select an archetype!');
                return;
            }
            
            const archetype = selectedArchetype.dataset.archetype;
            createHero(heroName, archetype);
        });

        function createHero(name, archetype) {
            const archetypeData = archetypes[archetype];
            gameState.hero = {
                name: name,
                archetype: archetype,
                level: 1,
                xp: 0,
                xpToNext: 100,
                health: archetypeData.baseHealth,
                maxHealth: archetypeData.baseHealth,
                damage: archetypeData.baseDamage,
                defense: archetypeData.defense,
                powers: archetypeData.powers
            };
            
            // Hide character creation, show game
            document.getElementById('characterCreation').style.display = 'none';
            document.getElementById('gameHUD').style.display = 'block';
            document.getElementById('gameWorld').style.display = 'block';
            
            // Update HUD
            updateHUD();

            // Create 3D Hero
            engine.createHeroMesh(archetype);
        }

        function updateHUD() {
            document.getElementById('heroNameDisplay').textContent = gameState.hero.name;
            document.getElementById('heroLevel').textContent = `Level ${gameState.hero.level}`;
            
            const healthPercent = (gameState.hero.health / gameState.hero.maxHealth) * 100;
            document.getElementById('healthBar').style.width = healthPercent + '%';
            document.getElementById('healthText').textContent = `${gameState.hero.health}/${gameState.hero.maxHealth}`;
            
            const xpPercent = (gameState.hero.xp / gameState.hero.xpToNext) * 100;
            document.getElementById('xpBar').style.width = xpPercent + '%';
            document.getElementById('xpText').textContent = `${gameState.hero.xp}/${gameState.hero.xpToNext}`;
        }

        // Start Mission
        function startMission(enemyType) {
            if (gameState.inCombat) return;
            
            gameState.currentEnemy = {...enemies[enemyType]};
            gameState.currentEnemy.maxHealth = gameState.currentEnemy.health;
            gameState.inCombat = true;
            gameState.combatLog = [];
            
            // Hide mission board, show combat arena
            document.getElementById('missionBoard').style.display = 'none';
            document.getElementById('combatArena').style.display = 'block';
            
            // Setup combat UI
            document.getElementById('combatHeroName').textContent = gameState.hero.name;
            document.getElementById('enemyName').textContent = gameState.currentEnemy.name;
            document.getElementById('enemySprite').textContent = gameState.currentEnemy.sprite;
            
            // Setup power buttons
            const powerBar = document.getElementById('powerBar');
            powerBar.innerHTML = '';
            
            gameState.hero.powers.forEach((power, index) => {
                const button = document.createElement('button');
                button.className = 'power-button';
                button.innerHTML = `<span>${power.icon}</span><span>${power.name}</span>`;
                button.onclick = () => usePower(index);
                powerBar.appendChild(button);
            });
            
            updateCombatUI();
            addCombatLog(`Battle started against ${gameState.currentEnemy.name}!`);

            // 3D Combat Setup
            engine.createEnemyMesh(enemyType);
            engine.setCombatView(true);
        }

        function usePower(powerIndex) {
            if (!gameState.inCombat) return;
            
            const power = gameState.hero.powers[powerIndex];
            const button = document.querySelectorAll('.power-button')[powerIndex];
            
            if (button.disabled) return;
            
            // Disable button and add cooldown
            button.disabled = true;
            button.classList.add('on-cooldown');
            button.style.setProperty('--cooldown-time', power.cooldown + 'ms');
            
            // Apply power effects
            if (power.damage > 0) {
                const totalDamage = power.damage + gameState.hero.damage;
                dealDamage(gameState.currentEnemy, totalDamage, false);
                addCombatLog(`${gameState.hero.name} uses ${power.name} for ${totalDamage} damage!`);
                
                // 3D Effect
                if (engine.enemyMesh) {
                    engine.spawnEffect(engine.enemyMesh.position, 0xff6b6b);
                }
            }
            
            if (power.heal > 0) {
                healHero(power.heal);
                addCombatLog(`${gameState.hero.name} heals for ${power.heal} HP!`);
                
                // 3D Effect
                if (engine.heroMesh) {
                    engine.spawnEffect(engine.heroMesh.position, 0x00ff88);
                }
            }
            
            // Enemy counterattack
            setTimeout(() => {
                if (gameState.inCombat && gameState.currentEnemy.health > 0) {
                    enemyAttack();
                }
            }, 500);
            
            // Re-enable button after cooldown
            setTimeout(() => {
                button.disabled = false;
                button.classList.remove('on-cooldown');
            }, power.cooldown);
        }

        function dealDamage(target, damage, isHero) {
            const actualDamage = isHero ? Math.max(1, damage - gameState.hero.defense) : damage;
            
            if (isHero) {
                gameState.hero.health = Math.max(0, gameState.hero.health - actualDamage);
                if (engine.heroMesh) engine.spawnEffect(engine.heroMesh.position, 0xff4444);
            } else {
                target.health = Math.max(0, target.health - actualDamage);
                if (engine.enemyMesh) engine.spawnEffect(engine.enemyMesh.position, 0xff4444);
            }
            
            // Show damage number
            const sprite = isHero ? document.getElementById('heroSprite') : document.getElementById('enemySprite');
            const damageNumber = document.createElement('div');
            damageNumber.className = 'damage-number';
            damageNumber.style.color = '#ff4444';
            damageNumber.textContent = `-${actualDamage}`;
            sprite.appendChild(damageNumber);
            
            setTimeout(() => damageNumber.remove(), 1000);
            
            updateCombatUI();
            
            // Check for defeat
            if (!isHero && target.health <= 0) {
                victory();
            } else if (isHero && gameState.hero.health <= 0) {
                defeat();
            }
        }

        function healHero(amount) {
            gameState.hero.health = Math.min(gameState.hero.maxHealth, gameState.hero.health + amount);
            
            // Show heal number
            const sprite = document.getElementById('heroSprite');
            const healNumber = document.createElement('div');
            healNumber.className = 'damage-number';
            healNumber.style.color = '#00ff88';
            healNumber.textContent = `+${amount}`;
            sprite.appendChild(healNumber);
            
            setTimeout(() => healNumber.remove(), 1000);
            
            updateCombatUI();
        }

        function enemyAttack() {
            const damage = gameState.currentEnemy.damage + Math.floor(Math.random() * 10);
            dealDamage(null, damage, true);
            addCombatLog(`${gameState.currentEnemy.name} attacks for ${damage} damage!`);
        }

        function updateCombatUI() {
            // Update hero health
            const heroHealthPercent = (gameState.hero.health / gameState.hero.maxHealth) * 100;
            document.getElementById('heroHealthBar').style.width = heroHealthPercent + '%';
            document.getElementById('heroHealthText').textContent = `${gameState.hero.health}/${gameState.hero.maxHealth}`;
            
            // Update enemy health
            if (gameState.currentEnemy) {
                const enemyHealthPercent = (gameState.currentEnemy.health / gameState.currentEnemy.maxHealth) * 100;
                document.getElementById('enemyHealthBar').style.width = enemyHealthPercent + '%';
                document.getElementById('enemyHealthText').textContent = `${gameState.currentEnemy.health}/${gameState.currentEnemy.maxHealth}`;
            }
            
            // Update main HUD
            updateHUD();
        }

        function addCombatLog(message) {
            const log = document.getElementById('combatLog');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.textContent = message;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }

        function victory() {
            gameState.inCombat = false;
            
            // Award XP
            const xpGained = gameState.currentEnemy.xpReward;
            gameState.hero.xp += xpGained;
            
            // Check for level up
            if (gameState.hero.xp >= gameState.hero.xpToNext) {
                levelUp();
            }
            
            // Show victory screen
            document.getElementById('rewardText').innerHTML = `
                <p>You defeated ${gameState.currentEnemy.name}!</p>
                <p>XP Gained: ${xpGained}</p>
            `;
            document.getElementById('victoryScreen').style.display = 'block';
            
            updateHUD();
        }

        function defeat() {
            gameState.inCombat = false;
            addCombatLog("You have been defeated!");
            
            // Respawn with half health
            setTimeout(() => {
                gameState.hero.health = Math.floor(gameState.hero.maxHealth / 2);
                updateHUD();
                document.getElementById('combatArena').style.display = 'none';
                alert("You have been defeated! You respawn at the hospital with half health.");
            }, 1000);
        }

        function levelUp() {
            gameState.hero.level++;
            gameState.hero.xp -= gameState.hero.xpToNext;
            gameState.hero.xpToNext = Math.floor(gameState.hero.xpToNext * 1.5);
            
            // Increase stats
            const archetypeData = archetypes[gameState.hero.archetype];
            gameState.hero.maxHealth += Math.floor(archetypeData.baseHealth * 0.1);
            gameState.hero.health = gameState.hero.maxHealth;
            gameState.hero.damage += Math.floor(archetypeData.baseDamage * 0.1);
            gameState.hero.defense += Math.floor(archetypeData.defense * 0.05);
            
            // Enhance powers
            gameState.hero.powers.forEach(power => {
                if (power.damage) power.damage = Math.floor(power.damage * 1.1);
                if (power.heal) power.heal = Math.floor(power.heal * 1.1);
            });
            
            alert(`Level Up! You are now level ${gameState.hero.level}!`);
        }

        function continueMission() {
            document.getElementById('victoryScreen').style.display = 'none';
            document.getElementById('combatArena').style.display = 'none';
            document.getElementById('missionBoard').style.display = 'block';
            gameState.currentEnemy = null;
            
            // 3D Reset
            engine.removeEnemyMesh();
            engine.setCombatView(false);
        }

        // Auto-save functionality
        setInterval(() => {
            if (gameState.hero) {
                const saveData = {
                    hero: gameState.hero,
                    timestamp: new Date().toISOString()
                };
                console.log('Game auto-saved:', saveData);
            }
        }, 30000); // Auto-save every 30 seconds

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (!gameState.inCombat || !gameState.hero) return;
            
            const key = e.key;
            if (key >= '1' && key <= '9') {
                const powerIndex = parseInt(key) - 1;
                if (powerIndex < gameState.hero.powers.length) {
                    const button = document.querySelectorAll('.power-button')[powerIndex];
                    if (button && !button.disabled) {
                        usePower(powerIndex);
                    }
                }
            }
        });

        // Add some particle effects
        function createParticle(x, y, color) {
            const particle = document.createElement('div');
            particle.style.position = 'fixed';
            particle.style.left = x + 'px';
            particle.style.top = y + 'px';
            particle.style.width = '10px';
            particle.style.height = '10px';
            particle.style.backgroundColor = color;
            particle.style.borderRadius = '50%';
            particle.style.pointerEvents = 'none';
            particle.style.animation = 'particleFade 1s ease-out forwards';
            
            document.body.appendChild(particle);
            
            setTimeout(() => particle.remove(), 1000);
        }

        // Add particle effect animation
        const style = document.createElement('style');
        style.textContent = `
            @keyframes particleFade {
                0% {
                    opacity: 1;
                    transform: translate(0, 0) scale(1);
                }
                100% {
                    opacity: 0;
                    transform: translate(${Math.random() * 100 - 50}px, -50px) scale(0.5);
                }
            }
        `;
        document.head.appendChild(style);

        // Add click effects
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('power-button')) {
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        createParticle(
                            e.clientX + Math.random() * 20 - 10,
                            e.clientY + Math.random() * 20 - 10,
                            '#ff6b6b'
                        );
                    }, i * 50);
                }
            }
        });

        // Initialize game
        console.log('Hero City initialized! Create your hero to begin your adventure.');
    </script>
</body>
</html>