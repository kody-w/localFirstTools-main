<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cellular Automata Civilization</title>
    <meta name="description" content="Watch civilizations emerge from Conway's Game of Life. Stable patterns form cities, oscillators become religions, gliders are nomads. Experience millennia of history unfold.">
    <meta name="theme-color" content="#0a0a0f">
    <meta name="color-scheme" content="dark">
    <!-- Tags: 3d, simulation, game-of-life, cellular-automata, civilization, three.js, webgl, interactive -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #0a0a0f;
            color: #e0e0e0;
            overflow: hidden;
            height: 100vh;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        #ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .panel {
            background: rgba(15, 15, 25, 0.92);
            border: 1px solid rgba(100, 150, 255, 0.3);
            border-radius: 8px;
            padding: 12px;
            pointer-events: auto;
            backdrop-filter: blur(10px);
        }

        #controls-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 280px;
            max-height: calc(100vh - 20px);
            overflow-y: auto;
        }

        #stats-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 320px;
            max-height: calc(100vh - 20px);
            overflow-y: auto;
        }

        #event-log {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 400px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 11px;
        }

        #minimap-container {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 200px;
            height: 200px;
            border: 2px solid rgba(100, 150, 255, 0.5);
            border-radius: 8px;
            overflow: hidden;
            pointer-events: auto;
        }

        #minimap {
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }

        h2 {
            font-size: 14px;
            color: #8af;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(100, 150, 255, 0.3);
            padding-bottom: 5px;
        }

        h3 {
            font-size: 12px;
            color: #aaa;
            margin: 10px 0 5px 0;
        }

        .control-group {
            margin-bottom: 12px;
        }

        label {
            display: block;
            font-size: 11px;
            color: #888;
            margin-bottom: 3px;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: rgba(100, 150, 255, 0.2);
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #4af;
            border-radius: 50%;
            cursor: pointer;
        }

        button {
            background: rgba(70, 130, 220, 0.3);
            border: 1px solid rgba(100, 150, 255, 0.4);
            color: #cdf;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            margin: 2px;
            transition: all 0.2s;
        }

        button:hover {
            background: rgba(100, 160, 255, 0.5);
            border-color: rgba(130, 180, 255, 0.6);
        }

        button.active {
            background: rgba(100, 200, 150, 0.5);
            border-color: rgba(130, 230, 180, 0.6);
        }

        .btn-group {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .stat-label {
            color: #888;
        }

        .stat-value {
            color: #4af;
            font-weight: bold;
        }

        .stat-value.population {
            color: #4f8;
        }

        .stat-value.deaths {
            color: #f66;
        }

        .stat-value.cities {
            color: #fa4;
        }

        .stat-value.religions {
            color: #c6f;
        }

        #population-graph {
            width: 100%;
            height: 80px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            margin-top: 10px;
        }

        #faction-chart {
            width: 100%;
            height: 60px;
            display: flex;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }

        .faction-bar {
            height: 100%;
            transition: width 0.3s;
        }

        .event-entry {
            padding: 4px 8px;
            border-left: 3px solid #4af;
            margin-bottom: 4px;
            background: rgba(0, 0, 0, 0.2);
        }

        .event-entry.war {
            border-color: #f44;
        }

        .event-entry.religion {
            border-color: #c6f;
        }

        .event-entry.city {
            border-color: #fa4;
        }

        .event-entry.collapse {
            border-color: #666;
        }

        .event-year {
            color: #666;
            font-size: 10px;
        }

        .pattern-preset {
            display: inline-block;
            width: 32px;
            height: 32px;
            margin: 2px;
            border: 1px solid rgba(100, 150, 255, 0.3);
            border-radius: 4px;
            cursor: pointer;
            background: rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .pattern-preset:hover {
            border-color: rgba(100, 200, 255, 0.6);
        }

        .pattern-preset canvas {
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }

        #time-display {
            text-align: center;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            margin-bottom: 10px;
        }

        #year-counter {
            font-size: 24px;
            color: #4af;
            font-weight: bold;
        }

        #era-name {
            font-size: 11px;
            color: #888;
        }

        .legend-item {
            display: flex;
            align-items: center;
            font-size: 11px;
            margin: 3px 0;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            margin-right: 8px;
        }

        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a0a0f;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 1000;
        }

        #loading h1 {
            color: #4af;
            margin-bottom: 20px;
        }

        #loading-bar {
            width: 200px;
            height: 4px;
            background: rgba(100, 150, 255, 0.2);
            border-radius: 2px;
            overflow: hidden;
        }

        #loading-progress {
            height: 100%;
            background: #4af;
            width: 0%;
            transition: width 0.3s;
        }

        .hidden {
            display: none !important;
        }

        @media (max-width: 768px) {
            #controls-panel, #stats-panel {
                width: 200px;
                font-size: 10px;
            }
            #event-log {
                width: 250px;
            }
            #minimap-container {
                width: 120px;
                height: 120px;
            }
        }
    </style>
</head>
<body>
    <div id="loading">
        <h1>Cellular Civilization</h1>
        <p style="color: #888; margin-bottom: 20px;">Initializing the primordial soup...</p>
        <div id="loading-bar">
            <div id="loading-progress"></div>
        </div>
    </div>

    <div id="canvas-container"></div>

    <div id="ui-overlay">
        <div id="controls-panel" class="panel">
            <div id="time-display">
                <div id="year-counter">Year 0</div>
                <div id="era-name">The Dawn of Life</div>
            </div>

            <h2>Time Controls</h2>
            <div class="control-group">
                <div class="btn-group">
                    <button id="btn-pause" title="Pause">Pause</button>
                    <button id="btn-step" title="Single Step">Step</button>
                    <button id="btn-play" class="active" title="Play">Play</button>
                    <button id="btn-fast" title="Fast">Fast</button>
                    <button id="btn-hyper" title="Hyperspeed">Hyper</button>
                </div>
            </div>

            <h2>Tools</h2>
            <div class="control-group">
                <div class="btn-group">
                    <button id="tool-draw" class="active" title="Draw cells">Draw</button>
                    <button id="tool-erase" title="Erase cells">Erase</button>
                    <button id="tool-bless" title="Mass spawn">Bless</button>
                    <button id="tool-smite" title="Mass kill">Smite</button>
                    <button id="tool-nuke" title="Randomize area">Nuke</button>
                </div>
            </div>

            <h3>Pattern Library</h3>
            <div class="control-group" id="pattern-library">
                <!-- Patterns added dynamically -->
            </div>

            <h2>World Settings</h2>
            <div class="control-group">
                <label>Grid Size: <span id="grid-size-value">128</span></label>
                <input type="range" id="grid-size" min="64" max="256" value="128" step="32">
            </div>
            <div class="control-group">
                <label>Initial Density: <span id="density-value">15%</span></label>
                <input type="range" id="density" min="5" max="40" value="15">
            </div>
            <div class="control-group">
                <button id="btn-restart">New World</button>
                <button id="btn-clear">Clear All</button>
            </div>

            <h2>Visualization</h2>
            <div class="control-group">
                <label>Height Scale: <span id="height-value">1.5</span></label>
                <input type="range" id="height-scale" min="0.5" max="5" value="1.5" step="0.1">
            </div>
            <div class="control-group">
                <div class="btn-group">
                    <button id="btn-fog">Fog of War</button>
                    <button id="btn-trade">Trade Routes</button>
                    <button id="btn-auto-cam">Auto Camera</button>
                </div>
            </div>

            <h2>Camera</h2>
            <div class="control-group">
                <div class="btn-group">
                    <button id="btn-top-view">Top View</button>
                    <button id="btn-iso-view">Isometric</button>
                    <button id="btn-cinematic">Cinematic</button>
                </div>
            </div>

            <h3>Legend</h3>
            <div class="legend-item"><div class="legend-color" style="background: #ffaa44;"></div> Cities (Still Lifes)</div>
            <div class="legend-item"><div class="legend-color" style="background: #cc66ff;"></div> Religions (Oscillators)</div>
            <div class="legend-item"><div class="legend-color" style="background: #44ff88;"></div> Nomads (Spaceships)</div>
            <div class="legend-item"><div class="legend-color" style="background: #ff6666;"></div> War Zones</div>
            <div class="legend-item"><div class="legend-color" style="background: #4488ff;"></div> Unaligned Cells</div>
        </div>

        <div id="stats-panel" class="panel">
            <h2>Civilization Statistics</h2>
            
            <div class="stat-row">
                <span class="stat-label">Population</span>
                <span class="stat-value population" id="stat-population">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Historical Deaths</span>
                <span class="stat-value deaths" id="stat-deaths">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Active Cities</span>
                <span class="stat-value cities" id="stat-cities">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Religions</span>
                <span class="stat-value religions" id="stat-religions">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Nomad Tribes</span>
                <span class="stat-value" id="stat-nomads">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Oldest Pattern</span>
                <span class="stat-value" id="stat-oldest">None</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Largest City</span>
                <span class="stat-value" id="stat-largest">None</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Trade Volume</span>
                <span class="stat-value" id="stat-trade">0</span>
            </div>

            <h3>Population History</h3>
            <canvas id="population-graph"></canvas>

            <h3>Faction Distribution</h3>
            <div id="faction-chart"></div>

            <h3>Top Civilizations</h3>
            <div id="top-civs">
                <!-- Dynamically populated -->
            </div>
        </div>

        <div id="event-log" class="panel">
            <h2>Historical Chronicle</h2>
            <div id="events-container">
                <!-- Events added dynamically -->
            </div>
        </div>

        <div id="minimap-container" class="panel">
            <canvas id="minimap"></canvas>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // ==================== CONFIGURATION ====================
        const CONFIG = {
            gridSize: 128,
            cellSize: 1,
            initialDensity: 0.15,
            maxHeight: 20,
            heightGrowthRate: 0.3,
            baseHeight: 1.5,
            tradeParticleCount: 2000,
            warParticleCount: 1000,
            patternDetectionInterval: 10,
            eventLogMax: 50,
            populationHistoryMax: 200
        };

        // ==================== PATTERN PRESETS ====================
        const PATTERNS = {
            glider: {
                name: "Glider",
                cells: [[1,0],[2,1],[0,2],[1,2],[2,2]],
                type: "spaceship"
            },
            lwss: {
                name: "LWSS",
                cells: [[0,0],[3,0],[4,1],[0,2],[4,2],[1,3],[2,3],[3,3],[4,3]],
                type: "spaceship"
            },
            block: {
                name: "Block",
                cells: [[0,0],[1,0],[0,1],[1,1]],
                type: "still"
            },
            beehive: {
                name: "Beehive",
                cells: [[1,0],[2,0],[0,1],[3,1],[1,2],[2,2]],
                type: "still"
            },
            loaf: {
                name: "Loaf",
                cells: [[1,0],[2,0],[0,1],[3,1],[1,2],[3,2],[2,3]],
                type: "still"
            },
            blinker: {
                name: "Blinker",
                cells: [[0,0],[1,0],[2,0]],
                type: "oscillator"
            },
            toad: {
                name: "Toad",
                cells: [[1,0],[2,0],[3,0],[0,1],[1,1],[2,1]],
                type: "oscillator"
            },
            beacon: {
                name: "Beacon",
                cells: [[0,0],[1,0],[0,1],[3,2],[2,3],[3,3]],
                type: "oscillator"
            },
            pulsar: {
                name: "Pulsar",
                cells: [[2,0],[3,0],[4,0],[8,0],[9,0],[10,0],
                        [0,2],[5,2],[7,2],[12,2],[0,3],[5,3],[7,3],[12,3],[0,4],[5,4],[7,4],[12,4],
                        [2,5],[3,5],[4,5],[8,5],[9,5],[10,5],
                        [2,7],[3,7],[4,7],[8,7],[9,7],[10,7],
                        [0,8],[5,8],[7,8],[12,8],[0,9],[5,9],[7,9],[12,9],[0,10],[5,10],[7,10],[12,10],
                        [2,12],[3,12],[4,12],[8,12],[9,12],[10,12]],
                type: "oscillator"
            },
            gliderGun: {
                name: "Glider Gun",
                cells: [[0,4],[0,5],[1,4],[1,5],[10,4],[10,5],[10,6],[11,3],[11,7],[12,2],[12,8],
                        [13,2],[13,8],[14,5],[15,3],[15,7],[16,4],[16,5],[16,6],[17,5],
                        [20,2],[20,3],[20,4],[21,2],[21,3],[21,4],[22,1],[22,5],[24,0],[24,1],[24,5],[24,6],
                        [34,2],[34,3],[35,2],[35,3]],
                type: "gun"
            },
            rpentomino: {
                name: "R-Pentomino",
                cells: [[1,0],[2,0],[0,1],[1,1],[1,2]],
                type: "methuselah"
            },
            acorn: {
                name: "Acorn",
                cells: [[1,0],[3,1],[0,2],[1,2],[4,2],[5,2],[6,2]],
                type: "methuselah"
            },
            diehard: {
                name: "Diehard",
                cells: [[6,0],[0,1],[1,1],[1,2],[5,2],[6,2],[7,2]],
                type: "methuselah"
            }
        };

        // ==================== FACTION COLORS ====================
        const FACTION_COLORS = {
            city: new THREE.Color(0xffaa44),
            religion: new THREE.Color(0xcc66ff),
            nomad: new THREE.Color(0x44ff88),
            war: new THREE.Color(0xff4444),
            neutral: new THREE.Color(0x4488ff),
            ancient: new THREE.Color(0xffd700),
            prophet: new THREE.Color(0xffffff)
        };

        // ==================== SIMULATION STATE ====================
        class CellularCivilization {
            constructor() {
                this.gridSize = CONFIG.gridSize;
                this.grid = null;
                this.nextGrid = null;
                this.cellAge = null;
                this.cellFaction = null;
                this.cellStability = null;
                
                this.year = 0;
                this.population = 0;
                this.totalDeaths = 0;
                this.populationHistory = [];
                
                this.patterns = new Map();
                this.cities = new Map();
                this.religions = new Map();
                this.nomads = new Map();
                this.wars = [];
                this.tradeRoutes = [];
                
                this.events = [];
                this.isPaused = false;
                this.speed = 1;
                this.stepsPerFrame = 1;
                
                this.selectedTool = 'draw';
                this.selectedPattern = null;
                
                this.showFog = false;
                this.showTrade = true;
                this.autoCam = false;
                this.cinematicMode = false;

                this.heightScale = 1.5;
                
                this.gridHistory = [];
                this.historyLength = 16;
                
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                this.cellMesh = null;
                this.tradeParticles = null;
                this.warParticles = null;
                this.groundMesh = null;
                
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.isMouseDown = false;
            }

            init() {
                this.initGrids();
                this.initThree();
                this.initUI();
                this.initPatternLibrary();
                this.randomize(CONFIG.initialDensity);
                this.updateMesh();
                this.updateMinimap();
                this.updateStats();
                this.hideLoading();
                this.animate();
            }

            initGrids() {
                const size = this.gridSize;
                this.grid = new Uint8Array(size * size);
                this.nextGrid = new Uint8Array(size * size);
                this.cellAge = new Uint16Array(size * size);
                this.cellFaction = new Uint8Array(size * size);
                this.cellStability = new Uint8Array(size * size);
            }

            initThree() {
                const container = document.getElementById('canvas-container');
                
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0a0a15);
                this.scene.fog = new THREE.FogExp2(0x0a0a15, 0.008);

                const aspect = window.innerWidth / window.innerHeight;
                this.camera = new THREE.PerspectiveCamera(50, aspect, 0.1, 1000);
                // Lower angle to see the 3D towers better
                this.camera.position.set(this.gridSize * 0.8, this.gridSize * 0.35, this.gridSize * 0.8);

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                container.appendChild(this.renderer.domElement);

                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.target.set(this.gridSize / 2, 0, this.gridSize / 2);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.maxPolarAngle = Math.PI / 2.1;
                this.controls.update();

                const ambientLight = new THREE.AmbientLight(0x334466, 0.6);
                this.scene.add(ambientLight);

                const sunLight = new THREE.DirectionalLight(0xffeedd, 1.0);
                sunLight.position.set(50, 100, 50);
                this.scene.add(sunLight);

                const moonLight = new THREE.DirectionalLight(0x6688ff, 0.3);
                moonLight.position.set(-50, 50, -50);
                this.scene.add(moonLight);

                const groundGeo = new THREE.PlaneGeometry(this.gridSize * 2, this.gridSize * 2);
                const groundMat = new THREE.MeshStandardMaterial({
                    color: 0x111122,
                    roughness: 0.9,
                    metalness: 0.1
                });
                this.groundMesh = new THREE.Mesh(groundGeo, groundMat);
                this.groundMesh.rotation.x = -Math.PI / 2;
                this.groundMesh.position.set(this.gridSize / 2, -0.1, this.gridSize / 2);
                this.scene.add(this.groundMesh);

                const gridHelper = new THREE.GridHelper(this.gridSize, this.gridSize, 0x222244, 0x111133);
                gridHelper.position.set(this.gridSize / 2, 0, this.gridSize / 2);
                this.scene.add(gridHelper);

                this.createCellMesh();
                this.createTradeParticles();
                this.createWarParticles();

                window.addEventListener('resize', () => this.onWindowResize());
                this.renderer.domElement.addEventListener('mousedown', (e) => this.onMouseDown(e));
                this.renderer.domElement.addEventListener('mousemove', (e) => this.onMouseMove(e));
                this.renderer.domElement.addEventListener('mouseup', () => this.onMouseUp());
                this.renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
            }

            createCellMesh() {
                const maxCells = this.gridSize * this.gridSize;
                const geometry = new THREE.BoxGeometry(0.9, 1, 0.9);
                const material = new THREE.MeshStandardMaterial({
                    roughness: 0.7,
                    metalness: 0.3
                });

                this.cellMesh = new THREE.InstancedMesh(geometry, material, maxCells);
                this.cellMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
                this.cellMesh.instanceColor = new THREE.InstancedBufferAttribute(
                    new Float32Array(maxCells * 3), 3
                );
                this.cellMesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
                this.scene.add(this.cellMesh);
            }

            createTradeParticles() {
                const count = CONFIG.tradeParticleCount;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(count * 3);
                const colors = new Float32Array(count * 3);
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                const material = new THREE.PointsMaterial({
                    size: 0.3,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending
                });

                this.tradeParticles = new THREE.Points(geometry, material);
                this.tradeParticles.userData.velocities = new Float32Array(count * 3);
                this.tradeParticles.userData.lifetimes = new Float32Array(count);
                this.scene.add(this.tradeParticles);
            }

            createWarParticles() {
                const count = CONFIG.warParticleCount;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(count * 3);
                const colors = new Float32Array(count * 3);
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                const material = new THREE.PointsMaterial({
                    size: 0.4,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.9,
                    blending: THREE.AdditiveBlending
                });

                this.warParticles = new THREE.Points(geometry, material);
                this.warParticles.userData.velocities = new Float32Array(count * 3);
                this.warParticles.userData.lifetimes = new Float32Array(count);
                this.scene.add(this.warParticles);
            }

            randomize(density) {
                const size = this.gridSize;
                for (let i = 0; i < size * size; i++) {
                    this.grid[i] = Math.random() < density ? 1 : 0;
                    this.cellAge[i] = 0;
                    this.cellFaction[i] = 0;
                    this.cellStability[i] = 0;
                }
                this.year = 0;
                this.totalDeaths = 0;
                this.population = this.countPopulation(); // Initialize population immediately
                this.populationHistory = [this.population];
                this.events = [];
                this.patterns.clear();
                this.cities.clear();
                this.religions.clear();
                this.nomads.clear();
                this.wars = [];
                this.tradeRoutes = [];
                this.addEvent("The primordial soup stirs with the first sparks of life.", "neutral");
            }

            clear() {
                this.grid.fill(0);
                this.nextGrid.fill(0);
                this.cellAge.fill(0);
                this.cellFaction.fill(0);
                this.cellStability.fill(0);
                this.year = 0;
                this.totalDeaths = 0;
                this.populationHistory = [];
                this.patterns.clear();
                this.cities.clear();
                this.religions.clear();
                this.nomads.clear();
                this.wars = [];
                this.tradeRoutes = [];
                this.events = [];
                this.addEvent("The void awaits creation.", "neutral");
            }

            getIndex(x, y) {
                x = ((x % this.gridSize) + this.gridSize) % this.gridSize;
                y = ((y % this.gridSize) + this.gridSize) % this.gridSize;
                return y * this.gridSize + x;
            }

            getNeighborCount(x, y) {
                let count = 0;
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        const idx = this.getIndex(x + dx, y + dy);
                        count += this.grid[idx];
                    }
                }
                return count;
            }

            step() {
                const size = this.gridSize;
                let births = 0;
                let deaths = 0;
                
                for (let y = 0; y < size; y++) {
                    for (let x = 0; x < size; x++) {
                        const idx = y * size + x;
                        const alive = this.grid[idx];
                        const neighbors = this.getNeighborCount(x, y);
                        
                        if (alive) {
                            if (neighbors === 2 || neighbors === 3) {
                                this.nextGrid[idx] = 1;
                                this.cellAge[idx]++;
                                this.cellStability[idx] = Math.min(255, this.cellStability[idx] + 1);
                            } else {
                                this.nextGrid[idx] = 0;
                                deaths++;
                                this.cellStability[idx] = 0;
                            }
                        } else {
                            if (neighbors === 3) {
                                this.nextGrid[idx] = 1;
                                this.cellAge[idx] = 0;
                                births++;
                                this.inheritFaction(x, y);
                            } else {
                                this.nextGrid[idx] = 0;
                            }
                        }
                    }
                }

                [this.grid, this.nextGrid] = [this.nextGrid, this.grid];
                
                this.year++;
                this.totalDeaths += deaths;
                this.population = this.countPopulation();
                this.populationHistory.push(this.population);
                if (this.populationHistory.length > CONFIG.populationHistoryMax) {
                    this.populationHistory.shift();
                }

                if (this.year % CONFIG.patternDetectionInterval === 0) {
                    this.detectPatterns();
                    this.updateTradeRoutes();
                    this.detectWars();
                }

                this.checkEvents(births, deaths);
            }

            inheritFaction(x, y) {
                const factionCounts = [0, 0, 0, 0, 0];
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        const idx = this.getIndex(x + dx, y + dy);
                        if (this.grid[idx]) {
                            factionCounts[this.cellFaction[idx]]++;
                        }
                    }
                }
                
                let maxFaction = 0;
                let maxCount = factionCounts[0];
                for (let i = 1; i < 5; i++) {
                    if (factionCounts[i] > maxCount) {
                        maxCount = factionCounts[i];
                        maxFaction = i;
                    }
                }
                
                const idx = this.getIndex(x, y);
                this.cellFaction[idx] = maxFaction;
            }

            countPopulation() {
                let count = 0;
                for (let i = 0; i < this.grid.length; i++) {
                    count += this.grid[i];
                }
                return count;
            }

            detectPatterns() {
                const hash = this.hashGrid();
                this.gridHistory.push({ hash, year: this.year });
                if (this.gridHistory.length > this.historyLength) {
                    this.gridHistory.shift();
                }

                const visited = new Uint8Array(this.gridSize * this.gridSize);
                const components = [];

                for (let y = 0; y < this.gridSize; y++) {
                    for (let x = 0; x < this.gridSize; x++) {
                        const idx = y * this.gridSize + x;
                        if (this.grid[idx] && !visited[idx]) {
                            const component = this.floodFill(x, y, visited);
                            if (component.length > 0) {
                                components.push(component);
                            }
                        }
                    }
                }

                this.cities.clear();
                this.religions.clear();
                this.nomads.clear();

                components.forEach((cells, id) => {
                    if (cells.length < 3) return;
                    
                    const avgStability = cells.reduce((sum, [x, y]) => {
                        return sum + this.cellStability[y * this.gridSize + x];
                    }, 0) / cells.length;

                    const avgAge = cells.reduce((sum, [x, y]) => {
                        return sum + this.cellAge[y * this.gridSize + x];
                    }, 0) / cells.length;

                    const isOscillator = this.gridHistory.some(h => 
                        h.hash === hash && h.year !== this.year && h.year > this.year - 20
                    );

                    let patternType;
                    if (avgStability > 50 && cells.length >= 4) {
                        patternType = 'city';
                        this.cities.set(id, { cells, avgAge, avgStability });
                        cells.forEach(([x, y]) => {
                            this.cellFaction[y * this.gridSize + x] = 1;
                        });
                    } else if (isOscillator || (avgStability > 20 && avgStability < 50)) {
                        patternType = 'religion';
                        this.religions.set(id, { cells, avgAge, period: 2 });
                        cells.forEach(([x, y]) => {
                            this.cellFaction[y * this.gridSize + x] = 2;
                        });
                    } else if (avgStability < 10 && cells.length >= 3) {
                        patternType = 'nomad';
                        this.nomads.set(id, { cells, avgAge });
                        cells.forEach(([x, y]) => {
                            this.cellFaction[y * this.gridSize + x] = 3;
                        });
                    }
                });
            }

            floodFill(startX, startY, visited) {
                const cells = [];
                const stack = [[startX, startY]];
                
                while (stack.length > 0) {
                    const [x, y] = stack.pop();
                    const idx = y * this.gridSize + x;
                    
                    if (visited[idx] || !this.grid[idx]) continue;
                    
                    visited[idx] = 1;
                    cells.push([x, y]);
                    
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            const nx = (x + dx + this.gridSize) % this.gridSize;
                            const ny = (y + dy + this.gridSize) % this.gridSize;
                            const nidx = ny * this.gridSize + nx;
                            if (this.grid[nidx] && !visited[nidx]) {
                                stack.push([nx, ny]);
                            }
                        }
                    }
                }
                
                return cells;
            }

            hashGrid() {
                let hash = 0;
                for (let i = 0; i < this.grid.length; i += 17) {
                    hash = ((hash << 5) - hash + this.grid[i]) | 0;
                }
                return hash;
            }

            hashComponent(cells) {
                if (cells.length === 0) return 0;
                
                const minX = Math.min(...cells.map(c => c[0]));
                const minY = Math.min(...cells.map(c => c[1]));
                
                let hash = 0;
                cells.forEach(([x, y]) => {
                    const nx = x - minX;
                    const ny = y - minY;
                    hash ^= (nx * 31 + ny) * 37;
                });
                return hash;
            }

            updateTradeRoutes() {
                this.tradeRoutes = [];
                
                const cityList = Array.from(this.cities.values());
                for (let i = 0; i < cityList.length; i++) {
                    for (let j = i + 1; j < cityList.length; j++) {
                        const c1 = cityList[i];
                        const c2 = cityList[j];
                        
                        if (c1.cells.length > 3 && c2.cells.length > 3) {
                            const center1 = this.getCenter(c1.cells);
                            const center2 = this.getCenter(c2.cells);
                            const dist = Math.hypot(center2.x - center1.x, center2.y - center1.y);
                            
                            if (dist < this.gridSize / 3) {
                                this.tradeRoutes.push({
                                    from: center1,
                                    to: center2,
                                    volume: (c1.cells.length + c2.cells.length) / 10
                                });
                            }
                        }
                    }
                }
            }

            getCenter(cells) {
                const sum = cells.reduce((acc, [x, y]) => ({x: acc.x + x, y: acc.y + y}), {x: 0, y: 0});
                return { x: sum.x / cells.length, y: sum.y / cells.length };
            }

            detectWars() {
                this.wars = [];
                
                for (let y = 1; y < this.gridSize - 1; y++) {
                    for (let x = 1; x < this.gridSize - 1; x++) {
                        const idx = y * this.gridSize + x;
                        if (!this.grid[idx]) continue;
                        
                        const myFaction = this.cellFaction[idx];
                        if (myFaction === 0) continue;
                        
                        let hasConflict = false;
                        for (let dy = -1; dy <= 1 && !hasConflict; dy++) {
                            for (let dx = -1; dx <= 1 && !hasConflict; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                const nidx = this.getIndex(x + dx, y + dy);
                                if (this.grid[nidx] && this.cellFaction[nidx] !== 0 && 
                                    this.cellFaction[nidx] !== myFaction) {
                                    hasConflict = true;
                                }
                            }
                        }
                        
                        if (hasConflict) {
                            this.wars.push({ x, y });
                            this.cellFaction[idx] = 4;
                        }
                    }
                }
            }

            checkEvents(births, deaths) {
                if (this.population > 1000 && !this.events.some(e => e.message.includes("1,000 souls"))) {
                    this.addEvent("The world population exceeds 1,000 souls for the first time!", "city");
                }
                
                if (deaths > this.population * 0.3 && deaths > 100) {
                    this.addEvent("The Great Dying: " + deaths + " perish in a single generation.", "collapse");
                }
                
                if (births > deaths * 2 && births > 50) {
                    this.addEvent("A golden age of expansion begins!", "city");
                }
                
                if (this.religions.size > 0 && this.year % 100 === 0) {
                    const largestReligion = Array.from(this.religions.values())
                        .reduce((max, r) => r.cells.length > (max?.cells.length || 0) ? r : max, null);
                    if (largestReligion && largestReligion.cells.length > 5) {
                        this.addEvent("The " + this.getRandomName() + " faith spreads across the land.", "religion");
                    }
                }
                
                if (this.wars.length > 20 && this.year % 50 === 0) {
                    this.addEvent("Conflict zones have spread to " + this.wars.length + " regions.", "war");
                }
                
                if (this.cities.size > 0 && this.year % 200 === 0) {
                    const randomCity = Array.from(this.cities.values())[0];
                    if (randomCity && randomCity.cells.length > 8) {
                        this.addEvent("The city of " + this.getRandomName() + " flourishes.", "city");
                    }
                }

                if (this.population > this.gridSize * this.gridSize * 0.4) {
                    if (!this.events.some(e => e.message.includes("Singularity"))) {
                        this.addEvent("THE SINGULARITY: Population density reaches critical mass!", "religion");
                    }
                }
            }

            getRandomName() {
                const prefixes = ["Zar", "Kro", "Vel", "Tha", "Gor", "Mer", "Sal", "Bra", "Xen", "Lor"];
                const suffixes = ["oth", "im", "as", "ion", "ar", "is", "um", "en", "ax", "os"];
                return prefixes[Math.floor(Math.random() * prefixes.length)] + 
                       suffixes[Math.floor(Math.random() * suffixes.length)];
            }

            addEvent(message, type) {
                this.events.unshift({ year: this.year, message, type });
                if (this.events.length > CONFIG.eventLogMax) {
                    this.events.pop();
                }
                this.updateEventLog();
            }

            updateMesh() {
                const dummy = new THREE.Object3D();
                const color = new THREE.Color();
                let instanceIndex = 0;

                for (let y = 0; y < this.gridSize; y++) {
                    for (let x = 0; x < this.gridSize; x++) {
                        const idx = y * this.gridSize + x;
                        
                        if (this.grid[idx]) {
                            const age = this.cellAge[idx];
                            const faction = this.cellFaction[idx];
                            const stability = this.cellStability[idx];

                            // More dramatic 3D height based on age, stability, and faction
                            let height = CONFIG.baseHeight + (age * CONFIG.heightGrowthRate) + (stability * 0.05);

                            // Cities grow taller, religions pulse, nomads stay low
                            if (faction === 1) height *= 1.5; // Cities are tall
                            else if (faction === 2) height *= 1.0 + 0.3 * Math.sin(this.year * 0.3 + x + y); // Religions pulse
                            else if (faction === 3) height *= 0.6; // Nomads are low/mobile
                            else if (faction === 4) height *= 0.8; // War zones are medium

                            height = Math.min(CONFIG.maxHeight, height) * this.heightScale;
                            height = Math.max(0.5, height); // Minimum visible height

                            dummy.position.set(x, height / 2, y);
                            dummy.scale.set(1, height, 1);
                            dummy.updateMatrix();
                            
                            this.cellMesh.setMatrixAt(instanceIndex, dummy.matrix);
                            
                            switch (faction) {
                                case 1: color.copy(FACTION_COLORS.city); break;
                                case 2: 
                                    color.copy(FACTION_COLORS.religion);
                                    const pulse = 0.7 + 0.3 * Math.sin(this.year * 0.5 + x + y);
                                    color.multiplyScalar(pulse);
                                    break;
                                case 3: color.copy(FACTION_COLORS.nomad); break;
                                case 4: color.copy(FACTION_COLORS.war); break;
                                default: 
                                    color.copy(FACTION_COLORS.neutral);
                                    if (age > 100) {
                                        color.lerp(FACTION_COLORS.ancient, Math.min(1, age / 500));
                                    }
                            }
                            
                            this.cellMesh.instanceColor.setXYZ(instanceIndex, color.r, color.g, color.b);
                            instanceIndex++;
                        }
                    }
                }

                dummy.scale.set(0, 0, 0);
                dummy.updateMatrix();
                for (let i = instanceIndex; i < this.gridSize * this.gridSize; i++) {
                    this.cellMesh.setMatrixAt(i, dummy.matrix);
                    this.cellMesh.instanceColor.setXYZ(i, 0, 0, 0);
                }

                this.cellMesh.instanceMatrix.needsUpdate = true;
                this.cellMesh.instanceColor.needsUpdate = true;
                this.cellMesh.count = instanceIndex;

                this.updateTradeParticles();
                this.updateWarParticles();
            }

            updateTradeParticles() {
                if (!this.showTrade || this.tradeRoutes.length === 0) {
                    this.tradeParticles.visible = false;
                    return;
                }
                
                this.tradeParticles.visible = true;
                const positions = this.tradeParticles.geometry.attributes.position.array;
                const colors = this.tradeParticles.geometry.attributes.color.array;
                const velocities = this.tradeParticles.userData.velocities;
                const lifetimes = this.tradeParticles.userData.lifetimes;

                for (let i = 0; i < CONFIG.tradeParticleCount; i++) {
                    const i3 = i * 3;
                    
                    lifetimes[i] -= 0.02;
                    
                    if (lifetimes[i] <= 0 && this.tradeRoutes.length > 0) {
                        const route = this.tradeRoutes[Math.floor(Math.random() * this.tradeRoutes.length)];
                        const t = Math.random();
                        
                        positions[i3] = route.from.x + (route.to.x - route.from.x) * t;
                        positions[i3 + 1] = 1 + Math.random() * 2;
                        positions[i3 + 2] = route.from.y + (route.to.y - route.from.y) * t;
                        
                        const dx = route.to.x - route.from.x;
                        const dy = route.to.y - route.from.y;
                        const len = Math.sqrt(dx * dx + dy * dy) || 1;
                        
                        velocities[i3] = (dx / len) * 0.2;
                        velocities[i3 + 1] = (Math.random() - 0.5) * 0.05;
                        velocities[i3 + 2] = (dy / len) * 0.2;
                        
                        lifetimes[i] = 0.5 + Math.random() * 0.5;
                        
                        colors[i3] = 1.0;
                        colors[i3 + 1] = 0.8;
                        colors[i3 + 2] = 0.2;
                    } else {
                        positions[i3] += velocities[i3];
                        positions[i3 + 1] += velocities[i3 + 1];
                        positions[i3 + 2] += velocities[i3 + 2];
                    }
                }

                this.tradeParticles.geometry.attributes.position.needsUpdate = true;
                this.tradeParticles.geometry.attributes.color.needsUpdate = true;
            }

            updateWarParticles() {
                if (this.wars.length === 0) {
                    this.warParticles.visible = false;
                    return;
                }
                
                this.warParticles.visible = true;
                const positions = this.warParticles.geometry.attributes.position.array;
                const colors = this.warParticles.geometry.attributes.color.array;
                const velocities = this.warParticles.userData.velocities;
                const lifetimes = this.warParticles.userData.lifetimes;

                for (let i = 0; i < CONFIG.warParticleCount; i++) {
                    const i3 = i * 3;
                    
                    lifetimes[i] -= 0.03;
                    
                    if (lifetimes[i] <= 0 && this.wars.length > 0) {
                        const war = this.wars[Math.floor(Math.random() * this.wars.length)];
                        
                        positions[i3] = war.x + (Math.random() - 0.5) * 2;
                        positions[i3 + 1] = 0.5 + Math.random() * 3;
                        positions[i3 + 2] = war.y + (Math.random() - 0.5) * 2;
                        
                        velocities[i3] = (Math.random() - 0.5) * 0.3;
                        velocities[i3 + 1] = Math.random() * 0.2;
                        velocities[i3 + 2] = (Math.random() - 0.5) * 0.3;
                        
                        lifetimes[i] = 0.3 + Math.random() * 0.4;
                        
                        colors[i3] = 1.0;
                        colors[i3 + 1] = 0.2 + Math.random() * 0.3;
                        colors[i3 + 2] = 0.0;
                    } else {
                        positions[i3] += velocities[i3];
                        positions[i3 + 1] += velocities[i3 + 1];
                        velocities[i3 + 1] -= 0.01;
                        positions[i3 + 2] += velocities[i3 + 2];
                    }
                }

                this.warParticles.geometry.attributes.position.needsUpdate = true;
                this.warParticles.geometry.attributes.color.needsUpdate = true;
            }

            updateMinimap() {
                const canvas = document.getElementById('minimap');
                const ctx = canvas.getContext('2d');
                canvas.width = this.gridSize;
                canvas.height = this.gridSize;
                
                const imageData = ctx.createImageData(this.gridSize, this.gridSize);
                const data = imageData.data;

                for (let y = 0; y < this.gridSize; y++) {
                    for (let x = 0; x < this.gridSize; x++) {
                        const idx = y * this.gridSize + x;
                        const pIdx = idx * 4;
                        
                        if (this.grid[idx]) {
                            const faction = this.cellFaction[idx];
                            let color;
                            
                            switch (faction) {
                                case 1: color = FACTION_COLORS.city; break;
                                case 2: color = FACTION_COLORS.religion; break;
                                case 3: color = FACTION_COLORS.nomad; break;
                                case 4: color = FACTION_COLORS.war; break;
                                default: color = FACTION_COLORS.neutral;
                            }
                            
                            data[pIdx] = color.r * 255;
                            data[pIdx + 1] = color.g * 255;
                            data[pIdx + 2] = color.b * 255;
                            data[pIdx + 3] = 255;
                        } else {
                            data[pIdx] = 10;
                            data[pIdx + 1] = 10;
                            data[pIdx + 2] = 20;
                            data[pIdx + 3] = 255;
                        }
                    }
                }

                ctx.putImageData(imageData, 0, 0);
            }

            updateStats() {
                document.getElementById('stat-population').textContent = this.population.toLocaleString();
                document.getElementById('stat-deaths').textContent = this.totalDeaths.toLocaleString();
                document.getElementById('stat-cities').textContent = this.cities.size;
                document.getElementById('stat-religions').textContent = this.religions.size;
                document.getElementById('stat-nomads').textContent = this.nomads.size;
                document.getElementById('stat-trade').textContent = this.tradeRoutes.length;

                let maxAge = 0;
                let oldestType = 'None';
                this.cities.forEach(c => {
                    if (c.avgAge > maxAge) {
                        maxAge = c.avgAge;
                        oldestType = "City (" + Math.floor(c.avgAge) + " yrs)";
                    }
                });
                document.getElementById('stat-oldest').textContent = oldestType;

                let maxSize = 0;
                let largestName = 'None';
                this.cities.forEach(c => {
                    if (c.cells.length > maxSize) {
                        maxSize = c.cells.length;
                        largestName = maxSize + " cells";
                    }
                });
                document.getElementById('stat-largest').textContent = largestName;

                document.getElementById('year-counter').textContent = "Year " + this.year.toLocaleString();
                
                let era;
                if (this.year < 100) era = "The Dawn of Life";
                else if (this.year < 500) era = "The Age of Expansion";
                else if (this.population < 100) era = "The Dark Ages";
                else if (this.cities.size > 5) era = "The Age of Cities";
                else if (this.religions.size > 3) era = "The Age of Faith";
                else if (this.wars.length > 30) era = "The Age of Conflict";
                else if (this.year > 1000) era = "The Modern Era";
                else era = "The Age of Progress";
                document.getElementById('era-name').textContent = era;

                this.drawPopulationGraph();
                this.drawFactionChart();
                this.updateTopCivs();
            }

            drawPopulationGraph() {
                const canvas = document.getElementById('population-graph');
                const ctx = canvas.getContext('2d');
                canvas.width = canvas.offsetWidth * 2;
                canvas.height = canvas.offsetHeight * 2;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                if (this.populationHistory.length < 2) return;
                
                const maxPop = Math.max(...this.populationHistory, 1);
                const w = canvas.width;
                const h = canvas.height;
                
                ctx.strokeStyle = '#4488ff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                this.populationHistory.forEach((pop, i) => {
                    const x = (i / (this.populationHistory.length - 1)) * w;
                    const y = h - (pop / maxPop) * h * 0.9;
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                
                ctx.stroke();
                
                ctx.lineTo(w, h);
                ctx.lineTo(0, h);
                ctx.closePath();
                ctx.fillStyle = 'rgba(68, 136, 255, 0.2)';
                ctx.fill();
            }

            updateTopCivs() {
                const container = document.getElementById('top-civs');
                container.innerHTML = '';

                // Gather all civilizations with their data
                const allCivs = [];

                this.cities.forEach((city, id) => {
                    allCivs.push({
                        type: 'city',
                        name: this.getCivName(id, 'city'),
                        size: city.cells.length,
                        age: Math.floor(city.avgAge),
                        color: '#ffaa44',
                        icon: ''
                    });
                });

                this.religions.forEach((religion, id) => {
                    allCivs.push({
                        type: 'religion',
                        name: this.getCivName(id, 'religion'),
                        size: religion.cells.length,
                        age: Math.floor(religion.avgAge),
                        color: '#cc66ff',
                        icon: ''
                    });
                });

                this.nomads.forEach((nomad, id) => {
                    allCivs.push({
                        type: 'nomad',
                        name: this.getCivName(id, 'nomad'),
                        size: nomad.cells.length,
                        age: Math.floor(nomad.avgAge),
                        color: '#44ff88',
                        icon: ''
                    });
                });

                // Sort by size, take top 5
                allCivs.sort((a, b) => b.size - a.size);
                const topCivs = allCivs.slice(0, 5);

                if (topCivs.length === 0) {
                    container.innerHTML = '<div style="color: #666; font-size: 11px;">No civilizations yet...</div>';
                    return;
                }

                topCivs.forEach((civ, rank) => {
                    const div = document.createElement('div');
                    div.style.cssText = `
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        padding: 6px 8px;
                        margin: 4px 0;
                        background: rgba(0,0,0,0.3);
                        border-radius: 4px;
                        border-left: 3px solid ${civ.color};
                        font-size: 11px;
                    `;

                    div.innerHTML = `
                        <span style="color: #888;">#${rank + 1}</span>
                        <span style="flex: 1; margin-left: 8px; color: ${civ.color};">
                            ${civ.icon} ${civ.name}
                        </span>
                        <span style="color: #aaa; margin-right: 10px;" title="Population">
                             ${civ.size}
                        </span>
                        <span style="color: #666;" title="Age in years">
                            ${civ.age}y
                        </span>
                    `;

                    container.appendChild(div);
                });
            }

            getCivName(id, type) {
                // Generate consistent name from ID
                const prefixes = {
                    city: ["New", "Great", "Old", "Fort", "Port", "East", "West", "North", "South", "Upper"],
                    religion: ["Church of", "Order of", "Temple of", "Faith of", "Cult of", "Holy", "Sacred", "Divine", "Eternal", "Ancient"],
                    nomad: ["The", "Wild", "Free", "Wandering", "Roaming", "Drifting", "Nomadic", "Tribal", "Desert", "Forest"]
                };

                const roots = ["Zar", "Kron", "Vel", "Tha", "Gor", "Mer", "Sal", "Bra", "Xen", "Lor",
                              "Mal", "Dor", "Fen", "Gal", "Hal", "Jor", "Kel", "Nar", "Pol", "Ral"];
                const suffixes = ["oth", "im", "as", "ion", "ar", "is", "um", "en", "ax", "os",
                                 "ia", "an", "ur", "el", "ys", "or", "ix", "us", "ae", "on"];

                // Use ID to generate consistent but varied names
                const hash = Math.abs(id * 2654435761) % 1000000;
                const prefixIdx = hash % prefixes[type].length;
                const rootIdx = Math.floor(hash / 10) % roots.length;
                const suffixIdx = Math.floor(hash / 100) % suffixes.length;

                const prefix = prefixes[type][prefixIdx];
                const name = roots[rootIdx] + suffixes[suffixIdx];

                if (type === 'city') {
                    return `${prefix} ${name}`;
                } else if (type === 'religion') {
                    return `${prefix} ${name}`;
                } else {
                    return `${prefix} ${name} Tribe`;
                }
            }

            drawFactionChart() {
                const chart = document.getElementById('faction-chart');
                chart.innerHTML = '';
                
                let cityCount = 0, religionCount = 0, nomadCount = 0, warCount = 0, neutralCount = 0;
                
                for (let i = 0; i < this.grid.length; i++) {
                    if (this.grid[i]) {
                        switch (this.cellFaction[i]) {
                            case 1: cityCount++; break;
                            case 2: religionCount++; break;
                            case 3: nomadCount++; break;
                            case 4: warCount++; break;
                            default: neutralCount++;
                        }
                    }
                }
                
                const total = cityCount + religionCount + nomadCount + warCount + neutralCount;
                if (total === 0) return;
                
                const factions = [
                    { count: cityCount, color: '#ffaa44', name: 'Cities' },
                    { count: religionCount, color: '#cc66ff', name: 'Religions' },
                    { count: nomadCount, color: '#44ff88', name: 'Nomads' },
                    { count: warCount, color: '#ff4444', name: 'Wars' },
                    { count: neutralCount, color: '#4488ff', name: 'Neutral' }
                ];
                
                factions.forEach(f => {
                    if (f.count > 0) {
                        const bar = document.createElement('div');
                        bar.className = 'faction-bar';
                        bar.style.width = (f.count / total * 100) + '%';
                        bar.style.backgroundColor = f.color;
                        bar.title = f.name + ": " + f.count + " (" + (f.count / total * 100).toFixed(1) + "%)";
                        chart.appendChild(bar);
                    }
                });
            }

            updateEventLog() {
                const container = document.getElementById('events-container');
                container.innerHTML = '';
                
                this.events.slice(0, 20).forEach(event => {
                    const div = document.createElement('div');
                    div.className = "event-entry " + event.type;
                    div.innerHTML = '<span class="event-year">Year ' + event.year + ':</span> ' + event.message;
                    container.appendChild(div);
                });
            }

            initUI() {
                document.getElementById('btn-pause').addEventListener('click', () => {
                    this.isPaused = true;
                    this.updateSpeedButtons();
                });
                document.getElementById('btn-step').addEventListener('click', () => {
                    this.isPaused = true;
                    this.step();
                    this.updateMesh();
                    this.updateMinimap();
                    this.updateStats();
                    this.updateSpeedButtons();
                });
                document.getElementById('btn-play').addEventListener('click', () => {
                    this.isPaused = false;
                    this.speed = 1;
                    this.stepsPerFrame = 1;
                    this.updateSpeedButtons();
                });
                document.getElementById('btn-fast').addEventListener('click', () => {
                    this.isPaused = false;
                    this.speed = 3;
                    this.stepsPerFrame = 3;
                    this.updateSpeedButtons();
                });
                document.getElementById('btn-hyper').addEventListener('click', () => {
                    this.isPaused = false;
                    this.speed = 10;
                    this.stepsPerFrame = 10;
                    this.updateSpeedButtons();
                });

                ['draw', 'erase', 'bless', 'smite', 'nuke'].forEach(tool => {
                    document.getElementById('tool-' + tool).addEventListener('click', () => {
                        this.selectedTool = tool;
                        this.selectedPattern = null;
                        document.querySelectorAll('[id^="tool-"]').forEach(btn => btn.classList.remove('active'));
                        document.getElementById('tool-' + tool).classList.add('active');
                    });
                });

                document.getElementById('grid-size').addEventListener('input', (e) => {
                    document.getElementById('grid-size-value').textContent = e.target.value;
                });
                document.getElementById('density').addEventListener('input', (e) => {
                    document.getElementById('density-value').textContent = e.target.value + '%';
                });
                
                document.getElementById('btn-restart').addEventListener('click', () => {
                    const newSize = parseInt(document.getElementById('grid-size').value);
                    const density = parseInt(document.getElementById('density').value) / 100;
                    
                    if (newSize !== this.gridSize) {
                        this.gridSize = newSize;
                        CONFIG.gridSize = newSize;
                        this.initGrids();
                        this.scene.remove(this.cellMesh);
                        this.createCellMesh();
                        this.controls.target.set(newSize / 2, 0, newSize / 2);
                    }
                    
                    this.randomize(density);
                    this.updateMesh();
                    this.updateMinimap();
                    this.updateStats();
                });

                document.getElementById('btn-clear').addEventListener('click', () => {
                    this.clear();
                    this.updateMesh();
                    this.updateMinimap();
                    this.updateStats();
                });

                document.getElementById('height-scale').addEventListener('input', (e) => {
                    this.heightScale = parseFloat(e.target.value);
                    document.getElementById('height-value').textContent = this.heightScale.toFixed(1);
                    this.updateMesh();
                });

                document.getElementById('btn-fog').addEventListener('click', (e) => {
                    this.showFog = !this.showFog;
                    e.target.classList.toggle('active', this.showFog);
                    this.scene.fog = this.showFog ? 
                        new THREE.FogExp2(0x0a0a15, 0.02) : 
                        new THREE.FogExp2(0x0a0a15, 0.008);
                });

                document.getElementById('btn-trade').addEventListener('click', (e) => {
                    this.showTrade = !this.showTrade;
                    e.target.classList.toggle('active', this.showTrade);
                });

                document.getElementById('btn-auto-cam').addEventListener('click', (e) => {
                    this.autoCam = !this.autoCam;
                    e.target.classList.toggle('active', this.autoCam);
                });

                document.getElementById('btn-top-view').addEventListener('click', () => {
                    this.camera.position.set(this.gridSize / 2, this.gridSize * 0.8, this.gridSize / 2);
                    this.controls.update();
                });

                document.getElementById('btn-iso-view').addEventListener('click', () => {
                    // Lower angle to see towers as a cityscape
                    this.camera.position.set(this.gridSize * 0.6, this.gridSize * 0.25, this.gridSize * 0.6);
                    this.controls.update();
                });

                document.getElementById('btn-cinematic').addEventListener('click', () => {
                    this.cinematicMode = !this.cinematicMode;
                    document.getElementById('btn-cinematic').classList.toggle('active', this.cinematicMode);
                });
            }

            initPatternLibrary() {
                const library = document.getElementById('pattern-library');
                
                Object.entries(PATTERNS).forEach(([key, pattern]) => {
                    const container = document.createElement('div');
                    container.className = 'pattern-preset';
                    container.title = pattern.name;
                    
                    const canvas = document.createElement('canvas');
                    canvas.width = 16;
                    canvas.height = 16;
                    const ctx = canvas.getContext('2d');
                    
                    ctx.fillStyle = '#111';
                    ctx.fillRect(0, 0, 16, 16);
                    
                    ctx.fillStyle = '#4af';
                    pattern.cells.forEach(([x, y]) => {
                        ctx.fillRect(x, y, 1, 1);
                    });
                    
                    container.appendChild(canvas);
                    container.addEventListener('click', () => {
                        this.selectedPattern = key;
                        this.selectedTool = null;
                        document.querySelectorAll('[id^="tool-"]').forEach(btn => btn.classList.remove('active'));
                        document.querySelectorAll('.pattern-preset').forEach(p => p.style.borderColor = 'rgba(100, 150, 255, 0.3)');
                        container.style.borderColor = 'rgba(100, 255, 150, 0.8)';
                    });
                    
                    library.appendChild(container);
                });
            }

            updateSpeedButtons() {
                document.querySelectorAll('[id^="btn-"]').forEach(btn => {
                    if (['btn-pause', 'btn-step', 'btn-play', 'btn-fast', 'btn-hyper'].includes(btn.id)) {
                        btn.classList.remove('active');
                    }
                });
                
                if (this.isPaused) {
                    document.getElementById('btn-pause').classList.add('active');
                } else if (this.speed === 1) {
                    document.getElementById('btn-play').classList.add('active');
                } else if (this.speed === 3) {
                    document.getElementById('btn-fast').classList.add('active');
                } else {
                    document.getElementById('btn-hyper').classList.add('active');
                }
            }

            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            onMouseDown(event) {
                if (event.button === 0) {
                    this.isMouseDown = true;
                    this.handleInteraction(event);
                }
            }

            onMouseMove(event) {
                if (this.isMouseDown) {
                    this.handleInteraction(event);
                }
            }

            onMouseUp() {
                this.isMouseDown = false;
            }

            handleInteraction(event) {
                const rect = this.renderer.domElement.getBoundingClientRect();
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObject(this.groundMesh);

                if (intersects.length > 0) {
                    const point = intersects[0].point;
                    const gridX = Math.floor(point.x);
                    const gridY = Math.floor(point.z);

                    if (gridX >= 0 && gridX < this.gridSize && gridY >= 0 && gridY < this.gridSize) {
                        if (this.selectedPattern) {
                            this.placePattern(gridX, gridY, this.selectedPattern);
                        } else {
                            this.applyTool(gridX, gridY);
                        }
                        this.updateMesh();
                        this.updateMinimap();
                    }
                }
            }

            placePattern(x, y, patternKey) {
                const pattern = PATTERNS[patternKey];
                if (!pattern) return;

                pattern.cells.forEach(([dx, dy]) => {
                    const px = (x + dx + this.gridSize) % this.gridSize;
                    const py = (y + dy + this.gridSize) % this.gridSize;
                    const idx = py * this.gridSize + px;
                    this.grid[idx] = 1;
                    this.cellAge[idx] = 0;
                });
            }

            applyTool(x, y) {
                const radius = this.selectedTool === 'nuke' ? 8 : 
                              (this.selectedTool === 'bless' || this.selectedTool === 'smite') ? 5 : 1;

                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        if (dx * dx + dy * dy > radius * radius) continue;
                        
                        const px = (x + dx + this.gridSize) % this.gridSize;
                        const py = (y + dy + this.gridSize) % this.gridSize;
                        const idx = py * this.gridSize + px;

                        switch (this.selectedTool) {
                            case 'draw':
                                this.grid[idx] = 1;
                                this.cellAge[idx] = 0;
                                break;
                            case 'erase':
                                this.grid[idx] = 0;
                                this.cellAge[idx] = 0;
                                break;
                            case 'bless':
                                this.grid[idx] = 1;
                                this.cellAge[idx] = 0;
                                break;
                            case 'smite':
                                this.grid[idx] = 0;
                                this.cellAge[idx] = 0;
                                this.cellFaction[idx] = 0;
                                break;
                            case 'nuke':
                                this.grid[idx] = Math.random() < 0.3 ? 1 : 0;
                                this.cellAge[idx] = 0;
                                this.cellFaction[idx] = 0;
                                break;
                        }
                    }
                }
            }

            updateAutoCam() {
                if (!this.autoCam && !this.cinematicMode) return;

                let sumX = 0, sumY = 0, count = 0;
                
                if (this.wars.length > 10) {
                    this.wars.slice(0, 20).forEach(w => {
                        sumX += w.x;
                        sumY += w.y;
                        count++;
                    });
                }
                else if (this.cities.size > 0) {
                    this.cities.forEach(city => {
                        const center = this.getCenter(city.cells);
                        sumX += center.x;
                        sumY += center.y;
                        count++;
                    });
                }
                else {
                    for (let i = 0; i < this.grid.length; i++) {
                        if (this.grid[i]) {
                            sumX += i % this.gridSize;
                            sumY += Math.floor(i / this.gridSize);
                            count++;
                            if (count > 100) break;
                        }
                    }
                }

                if (count > 0) {
                    const targetX = sumX / count;
                    const targetY = sumY / count;
                    
                    this.controls.target.x += (targetX - this.controls.target.x) * 0.02;
                    this.controls.target.z += (targetY - this.controls.target.z) * 0.02;
                }

                if (this.cinematicMode) {
                    const time = Date.now() * 0.0001;
                    const radius = this.gridSize * 0.5;
                    this.camera.position.x = this.controls.target.x + Math.cos(time) * radius;
                    this.camera.position.z = this.controls.target.z + Math.sin(time) * radius;
                    // Lower camera to see buildings as a skyline
                    this.camera.position.y = 15 + Math.sin(time * 1.5) * 8;
                    this.camera.lookAt(this.controls.target.x, 5, this.controls.target.z);
                }
            }

            hideLoading() {
                const loading = document.getElementById('loading');
                loading.style.opacity = '0';
                loading.style.transition = 'opacity 0.5s';
                setTimeout(() => loading.classList.add('hidden'), 500);
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                if (!this.isPaused) {
                    for (let i = 0; i < this.stepsPerFrame; i++) {
                        this.step();
                    }
                    this.updateMesh();
                    this.updateMinimap();
                    this.updateStats();
                }

                this.updateAutoCam();
                this.controls.update();

                this.renderer.render(this.scene, this.camera);
            }
        }

        const sim = new CellularCivilization();
        
        const progress = document.getElementById('loading-progress');
        let loadProgress = 0;
        const loadInterval = setInterval(() => {
            loadProgress += 10;
            progress.style.width = loadProgress + '%';
            if (loadProgress >= 100) {
                clearInterval(loadInterval);
                sim.init();
            }
        }, 50);
    </script>
</body>
</html>
