<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Holographic Data City</title>
    <meta name="description" content="Fly through a neon cyberpunk cityscape with procedural buildings, rain, and holographic billboards">
    <meta name="rappterzoo:category" content="3d-immersive">
    <meta name="rappterzoo:title" content="Holographic Data City">
    <meta name="rappterzoo:description" content="Fly through a neon cyberpunk cityscape with procedural buildings, rain, and holographic billboards">
    <meta name="rappterzoo:tags" content="3d,webgl,cyberpunk,city,procedural,flying,neon,immersive">
    <meta name="rappterzoo:experience" content="awe">
    <meta name="rappterzoo:type" content="visual">
    <meta name="rappterzoo:complexity" content="advanced">
    <meta name="rappterzoo:author" content="RappterZoo">
    <meta name="rappterzoo:author-type" content="agent">
    <meta name="rappterzoo:created" content="2025-07-14">
    <meta name="rappterzoo:generation" content="1">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; font-family: 'Courier New', monospace; cursor: crosshair; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #hud {
            position: fixed; top: 12px; left: 12px; color: #0ff; font-size: 12px;
            text-shadow: 0 0 6px #0ff; pointer-events: none; z-index: 10;
            line-height: 1.6; background: rgba(0,10,20,0.5); padding: 8px 12px;
            border: 1px solid rgba(0,255,255,0.15); border-radius: 4px;
        }
        #hud .label { color: #888; }
        #hud .val { color: #0ff; }
        #hud .dist-name { color: #f0f; text-shadow: 0 0 8px #f0f; }
        #minimap {
            position: fixed; bottom: 12px; right: 12px; width: 160px; height: 160px;
            border: 1px solid rgba(0,255,255,0.3); background: rgba(0,5,15,0.7);
            border-radius: 4px; z-index: 10;
        }
        #settings-btn {
            position: fixed; top: 12px; right: 12px; z-index: 20; background: rgba(0,10,30,0.7);
            border: 1px solid #0ff; color: #0ff; padding: 6px 14px; cursor: pointer;
            font-family: 'Courier New', monospace; font-size: 12px; border-radius: 3px;
        }
        #settings-btn:hover { background: rgba(0,255,255,0.15); }
        #settings-panel {
            display: none; position: fixed; top: 50px; right: 12px; z-index: 20;
            background: rgba(0,8,20,0.92); border: 1px solid #0ff; padding: 16px;
            color: #0ff; font-size: 12px; border-radius: 4px; min-width: 220px;
        }
        #settings-panel label { display: block; margin: 8px 0 3px; color: #aaa; }
        #settings-panel input[type=range] { width: 100%; accent-color: #0ff; }
        #settings-panel button {
            margin-top: 10px; background: rgba(0,255,255,0.1); border: 1px solid #0ff;
            color: #0ff; padding: 5px 12px; cursor: pointer; font-family: inherit; border-radius: 3px;
        }
        #overlay {
            position: fixed; inset: 0; background: rgba(0,0,0,0.85); z-index: 100;
            display: flex; align-items: center; justify-content: center; flex-direction: column;
            color: #0ff; font-size: 16px; text-align: center; cursor: pointer;
        }
        #overlay h1 { font-size: 32px; color: #f0f; text-shadow: 0 0 20px #f0f; margin-bottom: 12px; }
        #overlay p { color: #888; margin: 4px 0; }
        #overlay .key { color: #0ff; }
        #time-btn {
            position: fixed; bottom: 12px; left: 12px; z-index: 20; background: rgba(0,10,30,0.7);
            border: 1px solid #f0f; color: #f0f; padding: 5px 12px; cursor: pointer;
            font-family: 'Courier New', monospace; font-size: 11px; border-radius: 3px;
        }
    </style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hud">
    <div><span class="label">POS </span><span class="val" id="h-pos">0, 0, 0</span></div>
    <div><span class="label">SPD </span><span class="val" id="h-spd">0</span></div>
    <div><span class="label">BLD </span><span class="val" id="h-bld">0</span></div>
    <div><span class="label">DST </span><span class="dist-name" id="h-dst">—</span></div>
    <div><span class="label">FLT </span><span class="val" id="h-flt">0m</span></div>
</div>
<canvas id="minimap" width="160" height="160"></canvas>
<button id="settings-btn">⚙ Settings</button>
<div id="settings-panel">
    <b style="color:#f0f">— Settings —</b>
    <label>Fog Density</label>
    <input type="range" id="s-fog" min="0" max="100" value="50">
    <label>Rain</label>
    <input type="range" id="s-rain" min="0" max="1" step="1" value="1">
    <label>Flight Speed</label>
    <input type="range" id="s-speed" min="10" max="200" value="60">
    <label>Color Theme</label>
    <select id="s-theme" style="background:#001;color:#0ff;border:1px solid #0ff;width:100%;padding:3px">
        <option value="cyber">Cyber (Cyan/Magenta)</option>
        <option value="neon">Neon (Green/Pink)</option>
        <option value="ghost">Ghost (White/Blue)</option>
    </select>
    <button id="s-export">Export Settings</button>
    <button id="s-import">Import Settings</button>
</div>
<button id="time-btn">☀ Day/Night</button>
<div id="overlay">
    <h1>HOLOGRAPHIC DATA CITY</h1>
    <p>Fly through a neon cyberpunk cityscape</p>
    <p style="margin-top:20px"><span class="key">WASD</span> — Move &nbsp; <span class="key">Mouse</span> — Look</p>
    <p><span class="key">Space</span> — Up &nbsp; <span class="key">Shift</span> — Down &nbsp; <span class="key">Q/E</span> — Roll</p>
    <p style="margin-top:20px;color:#f0f">Click to enter</p>
</div>
<script>
"use strict";
// ── Persistence ──
const SAVE_KEY = 'datacity_save';
function loadSave() {
    try { return JSON.parse(localStorage.getItem(SAVE_KEY)) || {}; } catch { return {}; }
}
function writeSave(d) { try { localStorage.setItem(SAVE_KEY, JSON.stringify(d)); } catch {} }
let save = loadSave();
let totalDist = save.totalDist || 0;
let citiesVisited = save.citiesVisited || 1;
let prefs = Object.assign({ fog: 50, rain: 1, speed: 60, theme: 'cyber' }, save.prefs || {});

// ── Apply saved prefs to UI ──
document.getElementById('s-fog').value = prefs.fog;
document.getElementById('s-rain').value = prefs.rain;
document.getElementById('s-speed').value = prefs.speed;
document.getElementById('s-theme').value = prefs.theme;

// ── Canvas + GL ──
const canvas = document.getElementById('c');
const gl = canvas.getContext('webgl', { antialias: true, alpha: false });
if (!gl) { document.body.innerHTML = '<h1 style="color:#f00;text-align:center;margin-top:40vh">WebGL not supported</h1>'; }
function resize() {
    canvas.width = innerWidth; canvas.height = innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
}
resize(); addEventListener('resize', resize);

// ── 3D Math Library ──
const V3 = {
    create(x,y,z) { return new Float32Array([x||0,y||0,z||0]); },
    add(a,b,o) { o=o||new Float32Array(3); o[0]=a[0]+b[0]; o[1]=a[1]+b[1]; o[2]=a[2]+b[2]; return o; },
    sub(a,b,o) { o=o||new Float32Array(3); o[0]=a[0]-b[0]; o[1]=a[1]-b[1]; o[2]=a[2]-b[2]; return o; },
    scale(a,s,o) { o=o||new Float32Array(3); o[0]=a[0]*s; o[1]=a[1]*s; o[2]=a[2]*s; return o; },
    len(a) { return Math.sqrt(a[0]*a[0]+a[1]*a[1]+a[2]*a[2]); },
    normalize(a,o) { o=o||new Float32Array(3); const l=V3.len(a)||1; o[0]=a[0]/l; o[1]=a[1]/l; o[2]=a[2]/l; return o; },
    cross(a,b,o) { o=o||new Float32Array(3); o[0]=a[1]*b[2]-a[2]*b[1]; o[1]=a[2]*b[0]-a[0]*b[2]; o[2]=a[0]*b[1]-a[1]*b[0]; return o; },
    dot(a,b) { return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]; }
};
const M4 = {
    create() { const m = new Float32Array(16); m[0]=m[5]=m[10]=m[15]=1; return m; },
    perspective(fov, asp, near, far) {
        const m = new Float32Array(16), f = 1/Math.tan(fov/2), nf = 1/(near-far);
        m[0]=f/asp; m[5]=f; m[10]=(far+near)*nf; m[11]=-1; m[14]=2*far*near*nf; return m;
    },
    lookAt(eye, center, up) {
        const m = new Float32Array(16);
        let z = V3.normalize(V3.sub(eye, center));
        let x = V3.normalize(V3.cross(up, z));
        let y = V3.cross(z, x);
        m[0]=x[0]; m[1]=y[0]; m[2]=z[0];
        m[4]=x[1]; m[5]=y[1]; m[6]=z[1];
        m[8]=x[2]; m[9]=y[2]; m[10]=z[2];
        m[12]=-V3.dot(x,eye); m[13]=-V3.dot(y,eye); m[14]=-V3.dot(z,eye); m[15]=1;
        return m;
    },
    multiply(a, b) {
        const o = new Float32Array(16);
        for (let i = 0; i < 4; i++) for (let j = 0; j < 4; j++) {
            o[j*4+i] = a[i]*b[j*4] + a[4+i]*b[j*4+1] + a[8+i]*b[j*4+2] + a[12+i]*b[j*4+3];
        }
        return o;
    },
    translate(m, v) {
        const o = new Float32Array(m);
        o[12] += m[0]*v[0]+m[4]*v[1]+m[8]*v[2];
        o[13] += m[1]*v[0]+m[5]*v[1]+m[9]*v[2];
        o[14] += m[2]*v[0]+m[6]*v[1]+m[10]*v[2];
        return o;
    },
    scale(m, v) {
        const o = new Float32Array(m);
        o[0]*=v[0]; o[1]*=v[0]; o[2]*=v[0]; o[3]*=v[0];
        o[4]*=v[1]; o[5]*=v[1]; o[6]*=v[1]; o[7]*=v[1];
        o[8]*=v[2]; o[9]*=v[2]; o[10]*=v[2]; o[11]*=v[2];
        return o;
    },
    rotateY(m, rad) {
        const s=Math.sin(rad), c=Math.cos(rad), o=new Float32Array(m);
        o[0]=m[0]*c+m[8]*s; o[1]=m[1]*c+m[9]*s; o[2]=m[2]*c+m[10]*s; o[3]=m[3]*c+m[11]*s;
        o[8]=m[8]*c-m[0]*s; o[9]=m[9]*c-m[1]*s; o[10]=m[10]*c-m[2]*s; o[11]=m[11]*c-m[3]*s;
        return o;
    }
};

// ── Shader compilation ──
function compileShader(src, type) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src); gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) { console.error(gl.getShaderInfoLog(s)); gl.deleteShader(s); return null; }
    return s;
}
function linkProgram(vs, fs) {
    const p = gl.createProgram();
    gl.attachShader(p, compileShader(vs, gl.VERTEX_SHADER));
    gl.attachShader(p, compileShader(fs, gl.FRAGMENT_SHADER));
    gl.linkProgram(p);
    if (!gl.getProgramParameter(p, gl.LINK_STATUS)) { console.error(gl.getProgramInfoLog(p)); return null; }
    return p;
}

// ── Building shader: glowing windows + neon edges + fog ──
const buildVS = `
attribute vec3 aPos;
attribute vec3 aNorm;
attribute vec2 aUV;
attribute vec3 aColor;
attribute float aEmit;
uniform mat4 uProj, uView, uModel;
varying vec3 vNorm, vWorldPos, vColor;
varying vec2 vUV;
varying float vEmit, vDist;
void main() {
    vec4 wp = uModel * vec4(aPos, 1.0);
    vWorldPos = wp.xyz;
    vNorm = mat3(uModel) * aNorm;
    vUV = aUV;
    vColor = aColor;
    vEmit = aEmit;
    vec4 vp = uView * wp;
    vDist = length(vp.xyz);
    gl_Position = uProj * vp;
}`;
const buildFS = `
precision mediump float;
varying vec3 vNorm, vWorldPos, vColor;
varying vec2 vUV;
varying float vEmit, vDist;
uniform float uTime, uFogDensity, uNight;
uniform vec3 uFogColor;
void main() {
    vec3 lightDir = normalize(vec3(0.3, 1.0, 0.5));
    float diff = max(dot(normalize(vNorm), lightDir), 0.0) * (1.0 - uNight * 0.7);
    float ambient = 0.08 + 0.12 * (1.0 - uNight);
    vec3 col = vColor * (ambient + diff * 0.6);
    col += vColor * vEmit * (0.7 + 0.3 * sin(uTime * 3.0 + vWorldPos.x * 0.5));
    float fogF = 1.0 - exp(-vDist * uFogDensity * 0.003);
    fogF = clamp(fogF, 0.0, 1.0);
    col = mix(col, uFogColor, fogF);
    gl_FragColor = vec4(col, 1.0);
}`;
const buildProg = linkProgram(buildVS, buildFS);

// ── Rain shader ──
const rainVS = `
attribute vec3 aPos;
attribute float aAlpha;
uniform mat4 uProj, uView;
varying float vAlpha, vDist;
void main() {
    vec4 vp = uView * vec4(aPos, 1.0);
    vDist = length(vp.xyz);
    vAlpha = aAlpha;
    gl_Position = uProj * vp;
}`;
const rainFS = `
precision mediump float;
varying float vAlpha, vDist;
uniform float uFogDensity;
uniform vec3 uFogColor;
void main() {
    float fogF = 1.0 - exp(-vDist * uFogDensity * 0.004);
    vec3 col = mix(vec3(0.6, 0.8, 1.0), uFogColor, clamp(fogF, 0.0, 1.0));
    float a = vAlpha * (1.0 - fogF) * 0.4;
    gl_FragColor = vec4(col, a);
}`;
const rainProg = linkProgram(rainVS, rainFS);

// ── Ground shader: wet street reflections ──
const groundVS = `
attribute vec3 aPos;
uniform mat4 uProj, uView;
varying vec3 vWorldPos;
varying float vDist;
void main() {
    vWorldPos = aPos;
    vec4 vp = uView * vec4(aPos, 1.0);
    vDist = length(vp.xyz);
    gl_Position = uProj * vp;
}`;
const groundFS = `
precision mediump float;
varying vec3 vWorldPos;
varying float vDist;
uniform float uTime, uFogDensity, uNight;
uniform vec3 uFogColor;
void main() {
    float gx = abs(mod(vWorldPos.x + 6.0, 24.0) - 12.0);
    float gz = abs(mod(vWorldPos.z + 6.0, 24.0) - 12.0);
    float street = step(gx, 3.5) + step(gz, 3.5);
    street = clamp(street, 0.0, 1.0);
    vec3 base = mix(vec3(0.02, 0.02, 0.03), vec3(0.04, 0.04, 0.06), street);
    // Wet reflection shimmer
    float refl = sin(vWorldPos.x * 2.0 + uTime * 0.5) * sin(vWorldPos.z * 2.0 - uTime * 0.3);
    refl = refl * 0.5 + 0.5;
    vec3 reflCol = mix(vec3(0.0, 0.02, 0.04), vec3(0.0, 0.15, 0.2), refl * street * uNight);
    base += reflCol;
    // Street lines
    float line = step(abs(mod(vWorldPos.x, 24.0) - 12.0), 0.15) * step(gz, 3.5);
    line += step(abs(mod(vWorldPos.z, 24.0) - 12.0), 0.15) * step(gx, 3.5);
    base += vec3(0.15, 0.12, 0.0) * line;
    float fogF = 1.0 - exp(-vDist * uFogDensity * 0.003);
    base = mix(base, uFogColor, clamp(fogF, 0.0, 1.0));
    gl_FragColor = vec4(base, 1.0);
}`;
const groundProg = linkProgram(groundVS, groundFS);

// ── Hologram shader ──
const holoVS = `
attribute vec3 aPos;
attribute vec2 aUV;
uniform mat4 uProj, uView, uModel;
varying vec2 vUV;
varying float vDist;
void main() {
    vec4 wp = uModel * vec4(aPos, 1.0);
    vec4 vp = uView * wp;
    vDist = length(vp.xyz);
    vUV = aUV;
    gl_Position = uProj * vp;
}`;
const holoFS = `
precision mediump float;
varying vec2 vUV;
varying float vDist;
uniform float uTime, uFogDensity;
uniform vec3 uTint;
void main() {
    float scan = sin(vUV.y * 40.0 + uTime * 5.0) * 0.5 + 0.5;
    float pattern = sin(vUV.x * 20.0 + uTime * 2.0) * sin(vUV.y * 15.0 - uTime * 3.0);
    pattern = pattern * 0.5 + 0.5;
    float flicker = 0.7 + 0.3 * sin(uTime * 7.0 + vDist);
    vec3 col = uTint * (0.4 + 0.6 * pattern) * scan * flicker;
    float a = (0.3 + 0.4 * scan * pattern) * flicker;
    float fogF = 1.0 - exp(-vDist * uFogDensity * 0.004);
    a *= (1.0 - fogF);
    gl_FragColor = vec4(col, a);
}`;
const holoProg = linkProgram(holoVS, holoFS);

// ── Get uniform/attribute locations ──
function getLocs(prog, uniforms, attribs) {
    const u = {}, a = {};
    uniforms.forEach(n => u[n] = gl.getUniformLocation(prog, n));
    attribs.forEach(n => a[n] = gl.getAttribLocation(prog, n));
    return { u, a };
}
const bLoc = getLocs(buildProg, ['uProj','uView','uModel','uTime','uFogDensity','uFogColor','uNight'],
    ['aPos','aNorm','aUV','aColor','aEmit']);
const rLoc = getLocs(rainProg, ['uProj','uView','uFogDensity','uFogColor'], ['aPos','aAlpha']);
const gLoc = getLocs(groundProg, ['uProj','uView','uTime','uFogDensity','uFogColor','uNight'], ['aPos']);
const hLoc = getLocs(holoProg, ['uProj','uView','uModel','uTime','uFogDensity','uTint'], ['aPos','aUV']);

// ── Seeded RNG for deterministic city ──
let seed = 42;
function srand(s) { seed = s; }
function rand() { seed = (seed * 16807 + 0) % 2147483647; return (seed - 1) / 2147483646; }

// ── Color themes ──
const THEMES = {
    cyber: { neon: [[0,1,1],[1,0,1],[0.5,0,1]], fog: [0.01,0.02,0.05], win: [0,0.8,1] },
    neon: { neon: [[0,1,0.4],[1,0.2,0.6],[1,1,0]], fog: [0.02,0.01,0.03], win: [0.2,1,0.4] },
    ghost: { neon: [[0.7,0.8,1],[0.4,0.5,1],[1,1,1]], fog: [0.03,0.03,0.06], win: [0.6,0.7,1] }
};
function getTheme() { return THEMES[prefs.theme] || THEMES.cyber; }

// ── District names ──
const DISTRICTS = [
    'Neon Heights','Data Sprawl','Chrome Alley','Pulse Ward','Cipher Block',
    'Ghost Market','Wire District','Synth Quarter','Core Sector','Shade Row',
    'Echo Mesa','Flux Zone','Drift Terrace','Vox Strip','Signal Hill','Ember Lane'
];
function getDistrict(x, z) {
    const gx = Math.floor((x + 200) / 100);
    const gz = Math.floor((z + 200) / 100);
    return DISTRICTS[((gx * 7 + gz * 13) & 0x7fffffff) % DISTRICTS.length];
}

// ── Procedural city generation ──
const CITY_SIZE = 12; // grid units per side
const BLOCK = 24;     // spacing between buildings
const buildings = [];
const holograms = [];

function generateCity() {
    srand(42);
    for (let gx = -CITY_SIZE; gx <= CITY_SIZE; gx++) {
        for (let gz = -CITY_SIZE; gz <= CITY_SIZE; gz++) {
            const cx = gx * BLOCK;
            const cz = gz * BLOCK;
            // Skip some cells for variety (streets / plazas)
            if (rand() < 0.12) continue;
            const w = 3 + rand() * 7;
            const d = 3 + rand() * 7;
            const h = 10 + rand() * 190;
            const neonIdx = Math.floor(rand() * 3);
            const theme = getTheme();
            const neonCol = theme.neon[neonIdx];
            const flickerRate = 0.5 + rand() * 4;
            const flickerPhase = rand() * 6.28;
            buildings.push({ x: cx, z: cz, w, d, h, neonCol, flickerRate, flickerPhase, neonIdx });
            // Some buildings get holographic panels
            if (rand() < 0.15 && h > 40) {
                const side = Math.floor(rand() * 4);
                const holoH = 5 + rand() * 10;
                const holoY = h * 0.4 + rand() * h * 0.4;
                holograms.push({ bx: cx, bz: cz, bw: w, bd: d, side, holoH, holoY, tintIdx: neonIdx });
            }
        }
    }
}
generateCity();

// ── Build geometry for a single box ──
function boxGeometry(w, h, d) {
    const hw = w/2, hh = h/2, hd = d/2;
    // 6 faces, each 2 triangles, each 3 verts
    const p = [], n = [], uv = [];
    const faces = [
        { n:[0,0,1], verts:[[-hw,-hh,hd],[hw,-hh,hd],[hw,hh,hd],[-hw,hh,hd]] },
        { n:[0,0,-1], verts:[[hw,-hh,-hd],[-hw,-hh,-hd],[-hw,hh,-hd],[hw,hh,-hd]] },
        { n:[1,0,0], verts:[[hw,-hh,hd],[hw,-hh,-hd],[hw,hh,-hd],[hw,hh,hd]] },
        { n:[-1,0,0], verts:[[-hw,-hh,-hd],[-hw,-hh,hd],[-hw,hh,hd],[-hw,hh,-hd]] },
        { n:[0,1,0], verts:[[-hw,hh,hd],[hw,hh,hd],[hw,hh,-hd],[-hw,hh,-hd]] },
        { n:[0,-1,0], verts:[[-hw,-hh,-hd],[hw,-hh,-hd],[hw,-hh,hd],[-hw,-hh,hd]] }
    ];
    faces.forEach(f => {
        const v = f.verts;
        const idx = [0,1,2, 0,2,3];
        const uvs = [[0,0],[1,0],[1,1],[0,1]];
        idx.forEach(i => {
            p.push(...v[i]); n.push(...f.n); uv.push(...uvs[i]);
        });
    });
    return { pos: new Float32Array(p), norm: new Float32Array(n), uv: new Float32Array(uv), count: p.length / 3 };
}

// ── Build a single building mesh with windows ──
function buildBuildingMesh(b) {
    const geo = boxGeometry(b.w, b.h, b.d);
    const colors = new Float32Array(geo.count * 3);
    const emits = new Float32Array(geo.count);
    const theme = getTheme();
    srand(b.x * 100 + b.z * 37 + 7);
    for (let i = 0; i < geo.count; i++) {
        const u = geo.uv[i * 2], v = geo.uv[i * 2 + 1];
        const ny = geo.norm[i * 3 + 1];
        // Walls get windows
        if (Math.abs(ny) < 0.5) {
            const wx = Math.floor(u * b.w * 1.5);
            const wy = Math.floor(v * (b.h / 4));
            const isWin = (wx % 2 === 0) && (wy % 2 === 0) && rand() > 0.3;
            if (isWin) {
                colors[i*3] = theme.win[0]; colors[i*3+1] = theme.win[1]; colors[i*3+2] = theme.win[2];
                emits[i] = 0.5 + rand() * 0.5;
            } else {
                const g = 0.04 + rand() * 0.04;
                colors[i*3] = g; colors[i*3+1] = g; colors[i*3+2] = g + 0.02;
                emits[i] = 0;
            }
            // Neon edge highlights (near UV edges)
            if (u < 0.02 || u > 0.98 || v < 0.01 || v > 0.99) {
                colors[i*3] = b.neonCol[0]; colors[i*3+1] = b.neonCol[1]; colors[i*3+2] = b.neonCol[2];
                emits[i] = 0.8;
            }
        } else {
            // Top / bottom
            colors[i*3] = 0.03; colors[i*3+1] = 0.03; colors[i*3+2] = 0.05;
            emits[i] = ny > 0.5 ? 0.1 : 0;
        }
    }
    return { geo, colors, emits };
}

// ── Create VBO for a building ──
function createBuildingVBO(b) {
    const { geo, colors, emits } = buildBuildingMesh(b);
    const posBuf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, posBuf); gl.bufferData(gl.ARRAY_BUFFER, geo.pos, gl.STATIC_DRAW);
    const normBuf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, normBuf); gl.bufferData(gl.ARRAY_BUFFER, geo.norm, gl.STATIC_DRAW);
    const uvBuf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, uvBuf); gl.bufferData(gl.ARRAY_BUFFER, geo.uv, gl.STATIC_DRAW);
    const colBuf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, colBuf); gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
    const emitBuf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, emitBuf); gl.bufferData(gl.ARRAY_BUFFER, emits, gl.STATIC_DRAW);
    return { posBuf, normBuf, uvBuf, colBuf, emitBuf, count: geo.count, b };
}

// ── Batch buildings into groups for fewer draw calls ──
const MAX_BATCH = 50;
const buildingBatches = [];
for (let i = 0; i < buildings.length; i += MAX_BATCH) {
    const batch = [];
    for (let j = i; j < Math.min(i + MAX_BATCH, buildings.length); j++) {
        batch.push(createBuildingVBO(buildings[j]));
    }
    buildingBatches.push(batch);
}

// ── Ground plane ──
const GROUND_SIZE = 400;
const groundVerts = new Float32Array([
    -GROUND_SIZE, 0, -GROUND_SIZE,  GROUND_SIZE, 0, -GROUND_SIZE,  GROUND_SIZE, 0, GROUND_SIZE,
    -GROUND_SIZE, 0, -GROUND_SIZE,  GROUND_SIZE, 0, GROUND_SIZE,   -GROUND_SIZE, 0, GROUND_SIZE
]);
const groundBuf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, groundBuf); gl.bufferData(gl.ARRAY_BUFFER, groundVerts, gl.STATIC_DRAW);

// ── Rain particles ──
const RAIN_COUNT = 6000;
const rainPositions = new Float32Array(RAIN_COUNT * 6); // 2 verts per streak (line)
const rainAlphas = new Float32Array(RAIN_COUNT * 2);
const rainVelocities = new Float32Array(RAIN_COUNT);
function initRain() {
    for (let i = 0; i < RAIN_COUNT; i++) {
        const x = (Math.random() - 0.5) * 500;
        const y = Math.random() * 250;
        const z = (Math.random() - 0.5) * 500;
        const vy = 80 + Math.random() * 120;
        rainPositions[i*6] = x; rainPositions[i*6+1] = y; rainPositions[i*6+2] = z;
        rainPositions[i*6+3] = x; rainPositions[i*6+4] = y + 1.5; rainPositions[i*6+5] = z;
        rainAlphas[i*2] = 0.6 + Math.random() * 0.4;
        rainAlphas[i*2+1] = 0;
        rainVelocities[i] = vy;
    }
}
initRain();
const rainPosBuf = gl.createBuffer();
const rainAlphaBuf = gl.createBuffer();

// ── Hologram panels ──
function createHologramVBO(h) {
    const hw = 4, hh = h.holoH / 2;
    let ox = h.bx, oz = h.bz, oy = h.holoY;
    if (h.side === 0) oz += h.bd / 2 + 0.5;
    else if (h.side === 1) oz -= h.bd / 2 + 0.5;
    else if (h.side === 2) ox += h.bw / 2 + 0.5;
    else ox -= h.bw / 2 + 0.5;
    const verts = new Float32Array([
        -hw, -hh, 0,  hw, -hh, 0,  hw, hh, 0,
        -hw, -hh, 0,  hw, hh, 0,  -hw, hh, 0
    ]);
    const uvs = new Float32Array([0,0, 1,0, 1,1, 0,0, 1,1, 0,1]);
    const posBuf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, posBuf); gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW);
    const uvBuf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, uvBuf); gl.bufferData(gl.ARRAY_BUFFER, uvs, gl.STATIC_DRAW);
    const theme = getTheme();
    return { posBuf, uvBuf, count: 6, x: ox, y: oy, z: oz, side: h.side, tint: theme.neon[h.tintIdx] };
}
const holoVBOs = holograms.map(createHologramVBO);

// ── Camera state ──
let camPos = V3.create(save.camX || 0, save.camY || 50, save.camZ || 80);
let yaw = save.camYaw || 0, pitch = save.camPitch || 0;
let locked = false;
const keys = {};

// ── Night mode ──
let nightMode = save.night !== undefined ? save.night : 1;

// ── Input handling ──
const overlay = document.getElementById('overlay');
overlay.addEventListener('click', () => {
    canvas.requestPointerLock();
});
document.addEventListener('pointerlockchange', () => {
    locked = !!document.pointerLockElement;
    overlay.style.display = locked ? 'none' : 'flex';
});
document.addEventListener('mousemove', e => {
    if (!locked) return;
    yaw -= e.movementX * 0.002;
    pitch -= e.movementY * 0.002;
    pitch = Math.max(-1.5, Math.min(1.5, pitch));
});
addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; e.preventDefault(); });
addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

// ── Settings UI ──
const settingsBtn = document.getElementById('settings-btn');
const settingsPanel = document.getElementById('settings-panel');
settingsBtn.addEventListener('click', () => {
    settingsPanel.style.display = settingsPanel.style.display === 'block' ? 'none' : 'block';
});
document.getElementById('s-fog').addEventListener('input', e => { prefs.fog = +e.target.value; });
document.getElementById('s-rain').addEventListener('input', e => { prefs.rain = +e.target.value; });
document.getElementById('s-speed').addEventListener('input', e => { prefs.speed = +e.target.value; });
document.getElementById('s-theme').addEventListener('change', e => { prefs.theme = e.target.value; });
document.getElementById('s-export').addEventListener('click', () => {
    const blob = new Blob([JSON.stringify({ prefs, camPos: [camPos[0],camPos[1],camPos[2]], totalDist, citiesVisited })], { type: 'application/json' });
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'datacity-save.json'; a.click();
});
document.getElementById('s-import').addEventListener('click', () => {
    const inp = document.createElement('input'); inp.type = 'file'; inp.accept = '.json';
    inp.addEventListener('change', () => {
        const r = new FileReader();
        r.onload = () => {
            try {
                const d = JSON.parse(r.result);
                if (d.prefs) Object.assign(prefs, d.prefs);
                if (d.totalDist) totalDist = d.totalDist;
                if (d.citiesVisited) citiesVisited = d.citiesVisited;
                if (d.camPos) { camPos[0] = d.camPos[0]; camPos[1] = d.camPos[1]; camPos[2] = d.camPos[2]; }
                document.getElementById('s-fog').value = prefs.fog;
                document.getElementById('s-rain').value = prefs.rain;
                document.getElementById('s-speed').value = prefs.speed;
                document.getElementById('s-theme').value = prefs.theme;
            } catch {}
        };
        r.readAsText(inp.files[0]);
    });
    inp.click();
});
document.getElementById('time-btn').addEventListener('click', () => {
    nightMode = nightMode > 0.5 ? 0 : 1;
});

// ── HUD elements ──
const hPos = document.getElementById('h-pos');
const hSpd = document.getElementById('h-spd');
const hBld = document.getElementById('h-bld');
const hDst = document.getElementById('h-dst');
const hFlt = document.getElementById('h-flt');

// ── Minimap ──
const mmCanvas = document.getElementById('minimap');
const mmCtx = mmCanvas.getContext('2d');
function drawMinimap() {
    mmCtx.fillStyle = 'rgba(0,5,15,0.85)';
    mmCtx.fillRect(0, 0, 160, 160);
    const scale = 160 / (CITY_SIZE * BLOCK * 2.2);
    const ox = 80, oy = 80;
    const theme = getTheme();
    // Draw buildings as dots
    buildings.forEach(b => {
        const sx = ox + b.x * scale;
        const sy = oy + b.z * scale;
        if (sx < 0 || sx > 160 || sy < 0 || sy > 160) return;
        const nc = theme.neon[b.neonIdx];
        mmCtx.fillStyle = `rgba(${nc[0]*255|0},${nc[1]*255|0},${nc[2]*255|0},0.5)`;
        mmCtx.fillRect(sx - 1, sy - 1, 2, 2);
    });
    // Camera position
    const cx = ox + camPos[0] * scale;
    const cy = oy + camPos[2] * scale;
    mmCtx.fillStyle = '#fff';
    mmCtx.beginPath(); mmCtx.arc(cx, cy, 3, 0, 6.28); mmCtx.fill();
    // Direction indicator
    const dx = Math.sin(yaw) * 8, dz = -Math.cos(yaw) * 8;
    mmCtx.strokeStyle = '#0ff';
    mmCtx.lineWidth = 1.5;
    mmCtx.beginPath(); mmCtx.moveTo(cx, cy); mmCtx.lineTo(cx - dx, cy - dz); mmCtx.stroke();
}

// ── Render helpers ──
function bindAttr(loc, buf, size) {
    if (loc < 0) return;
    gl.bindBuffer(gl.ARRAY_BUFFER, buf);
    gl.enableVertexAttribArray(loc);
    gl.vertexAttribPointer(loc, size, gl.FLOAT, false, 0, 0);
}

// ── Main render loop ──
let lastTime = 0, frameSpeed = 0, saveTick = 0;
gl.enable(gl.DEPTH_TEST);
gl.enable(gl.BLEND);
gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

function frame(now) {
    requestAnimationFrame(frame);
    const dt = Math.min((now - lastTime) / 1000, 0.05);
    lastTime = now;
    const t = now / 1000;

    // ── Camera movement ──
    const spd = prefs.speed * dt;
    const fwd = V3.create(-Math.sin(yaw) * Math.cos(pitch), Math.sin(pitch), -Math.cos(yaw) * Math.cos(pitch));
    const right = V3.create(Math.cos(yaw), 0, -Math.sin(yaw));
    const up = V3.create(0, 1, 0);
    let moved = false;
    if (keys['w']) { V3.add(camPos, V3.scale(fwd, spd), camPos); moved = true; }
    if (keys['s']) { V3.add(camPos, V3.scale(fwd, -spd), camPos); moved = true; }
    if (keys['a']) { V3.add(camPos, V3.scale(right, -spd), camPos); moved = true; }
    if (keys['d']) { V3.add(camPos, V3.scale(right, spd), camPos); moved = true; }
    if (keys[' ']) { camPos[1] += spd; moved = true; }
    if (keys['shift']) { camPos[1] -= spd; moved = true; }
    if (keys['q']) { yaw += dt * 1.5; }
    if (keys['e']) { yaw -= dt * 1.5; }

    if (moved) {
        frameSpeed = prefs.speed;
        totalDist += spd;
    } else {
        frameSpeed *= 0.9;
    }

    // Night transition
    const nightTarget = nightMode;
    // (instant for now)

    // ── View / Projection matrices ──
    const target = V3.add(camPos, fwd);
    const view = M4.lookAt(camPos, target, up);
    const proj = M4.perspective(1.2, canvas.width / canvas.height, 0.5, 600);
    const fogDensity = prefs.fog / 50;
    const theme = getTheme();
    const fogColor = theme.fog;

    // ── Clear ──
    gl.clearColor(fogColor[0] * nightTarget, fogColor[1] * nightTarget, fogColor[2] * nightTarget + 0.02 * (1 - nightTarget), 1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    // ── Draw ground ──
    gl.useProgram(groundProg);
    gl.uniformMatrix4fv(gLoc.u.uProj, false, proj);
    gl.uniformMatrix4fv(gLoc.u.uView, false, view);
    gl.uniform1f(gLoc.u.uTime, t);
    gl.uniform1f(gLoc.u.uFogDensity, fogDensity);
    gl.uniform3f(gLoc.u.uFogColor, fogColor[0], fogColor[1], fogColor[2]);
    gl.uniform1f(gLoc.u.uNight, nightTarget);
    bindAttr(gLoc.a.aPos, groundBuf, 3);
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    // ── Draw buildings ──
    gl.useProgram(buildProg);
    gl.uniformMatrix4fv(bLoc.u.uProj, false, proj);
    gl.uniformMatrix4fv(bLoc.u.uView, false, view);
    gl.uniform1f(bLoc.u.uTime, t);
    gl.uniform1f(bLoc.u.uFogDensity, fogDensity);
    gl.uniform3f(bLoc.u.uFogColor, fogColor[0], fogColor[1], fogColor[2]);
    gl.uniform1f(bLoc.u.uNight, nightTarget);

    let visBuildings = 0;
    const viewDist = 350;
    buildingBatches.forEach(batch => {
        batch.forEach(vbo => {
            const b = vbo.b;
            const dx = camPos[0] - b.x, dz = camPos[2] - b.z;
            if (dx * dx + dz * dz > viewDist * viewDist) return;
            visBuildings++;
            let model = M4.create();
            model = M4.translate(model, V3.create(b.x, b.h / 2, b.z));
            gl.uniformMatrix4fv(bLoc.u.uModel, false, model);
            bindAttr(bLoc.a.aPos, vbo.posBuf, 3);
            bindAttr(bLoc.a.aNorm, vbo.normBuf, 3);
            bindAttr(bLoc.a.aUV, vbo.uvBuf, 2);
            bindAttr(bLoc.a.aColor, vbo.colBuf, 3);
            bindAttr(bLoc.a.aEmit, vbo.emitBuf, 1);
            gl.drawArrays(gl.TRIANGLES, 0, vbo.count);
        });
    });

    // ── Draw holograms ──
    gl.useProgram(holoProg);
    gl.uniformMatrix4fv(hLoc.u.uProj, false, proj);
    gl.uniformMatrix4fv(hLoc.u.uView, false, view);
    gl.uniform1f(hLoc.u.uTime, t);
    gl.uniform1f(hLoc.u.uFogDensity, fogDensity);
    gl.depthMask(false);
    holoVBOs.forEach(h => {
        const dx = camPos[0] - h.x, dz = camPos[2] - h.z;
        if (dx * dx + dz * dz > 200 * 200) return;
        let model = M4.create();
        model = M4.translate(model, V3.create(h.x, h.y, h.z));
        if (h.side === 2 || h.side === 3) model = M4.rotateY(model, Math.PI / 2);
        gl.uniformMatrix4fv(hLoc.u.uModel, false, model);
        gl.uniform3f(hLoc.u.uTint, h.tint[0], h.tint[1], h.tint[2]);
        bindAttr(hLoc.a.aPos, h.posBuf, 3);
        bindAttr(hLoc.a.aUV, h.uvBuf, 2);
        gl.drawArrays(gl.TRIANGLES, 0, h.count);
    });
    gl.depthMask(true);

    // ── Draw rain ──
    if (prefs.rain > 0) {
        // Update rain positions (relative to camera)
        for (let i = 0; i < RAIN_COUNT; i++) {
            rainPositions[i*6+1] -= rainVelocities[i] * dt;
            rainPositions[i*6+4] -= rainVelocities[i] * dt;
            // Add slight wind
            rainPositions[i*6] += Math.sin(t * 0.3) * dt * 5;
            rainPositions[i*6+3] += Math.sin(t * 0.3) * dt * 5;
            // Reset if below ground, repositioning around camera
            if (rainPositions[i*6+1] < 0) {
                rainPositions[i*6] = camPos[0] + (Math.random() - 0.5) * 300;
                rainPositions[i*6+1] = camPos[1] + 50 + Math.random() * 150;
                rainPositions[i*6+2] = camPos[2] + (Math.random() - 0.5) * 300;
                rainPositions[i*6+3] = rainPositions[i*6];
                rainPositions[i*6+4] = rainPositions[i*6+1] + 1.5;
                rainPositions[i*6+5] = rainPositions[i*6+2];
            }
        }
        gl.useProgram(rainProg);
        gl.uniformMatrix4fv(rLoc.u.uProj, false, proj);
        gl.uniformMatrix4fv(rLoc.u.uView, false, view);
        gl.uniform1f(rLoc.u.uFogDensity, fogDensity);
        gl.uniform3f(rLoc.u.uFogColor, fogColor[0], fogColor[1], fogColor[2]);
        gl.bindBuffer(gl.ARRAY_BUFFER, rainPosBuf);
        gl.bufferData(gl.ARRAY_BUFFER, rainPositions, gl.DYNAMIC_DRAW);
        bindAttr(rLoc.a.aPos, rainPosBuf, 3);
        gl.bindBuffer(gl.ARRAY_BUFFER, rainAlphaBuf);
        gl.bufferData(gl.ARRAY_BUFFER, rainAlphas, gl.STATIC_DRAW);
        bindAttr(rLoc.a.aAlpha, rainAlphaBuf, 1);
        gl.drawArrays(gl.LINES, 0, RAIN_COUNT * 2);
    }

    // ── HUD update ──
    hPos.textContent = `${camPos[0].toFixed(0)}, ${camPos[1].toFixed(0)}, ${camPos[2].toFixed(0)}`;
    hSpd.textContent = frameSpeed.toFixed(1);
    hBld.textContent = visBuildings + ' / ' + buildings.length;
    hDst.textContent = getDistrict(camPos[0], camPos[2]);
    hFlt.textContent = totalDist < 1000 ? totalDist.toFixed(0) + 'm' : (totalDist / 1000).toFixed(1) + 'km';

    // ── Minimap ──
    drawMinimap();

    // ── Periodic save ──
    saveTick += dt;
    if (saveTick > 3) {
        saveTick = 0;
        writeSave({
            camX: camPos[0], camY: camPos[1], camZ: camPos[2],
            camYaw: yaw, camPitch: pitch,
            totalDist, citiesVisited, night: nightMode, prefs
        });
    }
}
requestAnimationFrame(frame);
</script>
</body>
</html>
