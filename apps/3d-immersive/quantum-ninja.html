<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Ninja: The Dual Nature</title>
    <meta name="description" content="A 2.5D action-platformer where you master wave-particle duality. Switch between solid matter and probability waves to solve puzzles and evade the Observer Effect.">
    <!-- 3d, game, platformer, quantum, physics, educational, action -->
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', system-ui, sans-serif;
            user-select: none;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }
        #hud-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }
        .status-bar {
            background: rgba(0, 20, 40, 0.8);
            border: 1px solid #00ffff;
            padding: 10px 20px;
            border-radius: 4px;
            color: #00ffff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
            backdrop-filter: blur(5px);
        }
        h1 {
            margin: 0 0 5px 0;
            font-size: 24px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px #00ffff;
        }
        .mode-indicator {
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .mode-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #fff;
        }
        .particle-mode .mode-icon {
            background: #ff0055;
            box-shadow: 0 0 10px #ff0055;
        }
        .wave-mode .mode-icon {
            background: #00ffff;
            box-shadow: 0 0 10px #00ffff;
            filter: blur(2px);
        }
        #controls-hint {
            text-align: right;
            font-size: 12px;
            color: #aaa;
        }
        .key {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 3px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            margin: 0 2px;
        }
        #message-area {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            width: 600px;
            pointer-events: none;
        }
        .tutorial-msg {
            background: rgba(0, 0, 0, 0.8);
            border-left: 4px solid #00ffff;
            padding: 15px;
            margin-bottom: 10px;
            color: #fff;
            font-size: 16px;
            line-height: 1.5;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.5s ease;
        }
        .tutorial-msg.visible {
            opacity: 1;
            transform: translateY(0);
        }
        .tutorial-msg strong {
            color: #00ffff;
        }
        #level-complete {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
        }
        #level-complete.visible {
            opacity: 1;
            pointer-events: auto;
        }
        #level-complete h2 {
            font-size: 48px;
            color: #00ffff;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 5px;
        }
        button {
            background: transparent;
            border: 2px solid #00ffff;
            color: #00ffff;
            padding: 15px 40px;
            font-size: 18px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s;
        }
        button:hover {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 20px #00ffff;
        }
        #observer-warning {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff0055;
            font-size: 24px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 0 0 10px #ff0055;
            opacity: 0;
            transition: opacity 0.2s;
        }
        #observer-warning.visible {
            opacity: 1;
            animation: pulse 0.5s infinite alternate;
        }
        @keyframes pulse {
            from { opacity: 0.5; }
            to { opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="ui-layer">
        <div id="hud-top">
            <div class="status-bar">
                <h1>Quantum Ninja</h1>
                <div class="mode-indicator particle-mode" id="mode-display">
                    <div class="mode-icon"></div>
                    <span id="mode-text">PARTICLE FORM</span>
                </div>
            </div>
            <div id="controls-hint">
                <p><span class="key">A</span> <span class="key">D</span> Move</p>
                <p><span class="key">SPACE</span> Jump</p>
                <p><span class="key">SHIFT</span> Toggle Wave Form</p>
                <p><span class="key">R</span> Restart Level</p>
            </div>
        </div>
        <div id="message-area"></div>
        <div id="observer-warning">OBSERVED! WAVE FUNCTION COLLAPSED</div>
    </div>

    <div id="level-complete">
        <h2>Level Complete</h2>
        <p style="color: #aaa; margin-bottom: 30px; max-width: 500px; text-align: center;">
            You have successfully navigated the quantum realm. The dual nature of reality is yours to command.
        </p>
        <button id="next-level-btn">Next Level</button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';

        // Game Constants
        const GRAVITY = 40;
        const MOVE_SPEED = 12;
        const JUMP_FORCE = 18;
        const WAVE_GRAVITY_SCALE = 0.3;
        const WAVE_SPEED_SCALE = 0.8;
        const WAVE_JUMP_SCALE = 1.2;
        
        // Game State
        const state = {
            mode: 'PARTICLE', // 'PARTICLE' or 'WAVE'
            isObserved: false,
            keys: { w: false, a: false, s: false, d: false, space: false, shift: false },
            player: {
                pos: new THREE.Vector3(0, 2, 0),
                vel: new THREE.Vector3(0, 0, 0),
                grounded: false,
                canJump: false
            },
            level: 0,
            checkpoints: [],
            lastCheckpoint: new THREE.Vector3(0, 2, 0)
        };

        // Three.js Globals
        let scene, camera, renderer, composer;
        let playerMesh, playerParticleSystem;
        let levelGroup, enemyGroup;
        let clock = new THREE.Clock();
        let particles = [];

        // Level Data
        const LEVELS = [
            // Level 1: The Basics
            {
                platforms: [
                    { x: 0, y: 0, w: 20, h: 1, type: 'solid' },
                    { x: 15, y: 2, w: 5, h: 1, type: 'solid' },
                    { x: 25, y: 4, w: 5, h: 1, type: 'solid' },
                    { x: 35, y: 6, w: 5, h: 1, type: 'solid' },
                    { x: 45, y: 6, w: 10, h: 1, type: 'solid' },
                    // The Wall (requires Wave mode to pass through slit)
                    { x: 55, y: 8, w: 1, h: 10, type: 'solid' }, // Tall wall
                    { x: 55, y: 2, w: 1, h: 2, type: 'solid' }, // Bottom part
                    // Slit is between y=4 and y=8? No, let's make a slit
                    { x: 55, y: 5, w: 1, h: 2, type: 'slit' }, // The slit
                    
                    { x: 65, y: 6, w: 10, h: 1, type: 'solid' },
                    { x: 80, y: 6, w: 5, h: 1, type: 'goal' }
                ],
                enemies: [],
                messages: [
                    { x: 0, text: "Welcome, Initiate. You exist in two states." },
                    { x: 5, text: "As a <strong>PARTICLE</strong> (Red), you are solid. You obey gravity and physics." },
                    { x: 15, text: "Press <strong>SPACE</strong> to jump." },
                    { x: 30, text: "Press <strong>SHIFT</strong> to become a <strong>WAVE</strong> (Blue)." },
                    { x: 40, text: "Waves are lighter. They float and jump higher." },
                    { x: 50, text: "Solid matter blocks Particles. But Waves can <strong>TUNNEL</strong> through narrow slits." }
                ],
                startPos: { x: 0, y: 2 }
            },
            // Level 2: The Observer
            {
                platforms: [
                    { x: 0, y: 0, w: 10, h: 1, type: 'solid' },
                    { x: 15, y: 0, w: 10, h: 1, type: 'solid' },
                    { x: 30, y: 4, w: 2, h: 1, type: 'solid' },
                    { x: 40, y: 8, w: 2, h: 1, type: 'solid' },
                    { x: 50, y: 4, w: 10, h: 1, type: 'solid' },
                    // Tunneling section
                    { x: 65, y: 4, w: 2, h: 8, type: 'solid' }, // Wall
                    { x: 65, y: 6, w: 2, h: 1, type: 'slit' }, // Slit
                    { x: 75, y: 4, w: 10, h: 1, type: 'solid' },
                    { x: 90, y: 4, w: 5, h: 1, type: 'goal' }
                ],
                enemies: [
                    { x: 15, y: 5, type: 'observer', range: 10, angle: 45, dir: -1 }, // Watches the gap
                    { x: 55, y: 8, type: 'observer', range: 12, angle: 60, dir: 1 }
                ],
                messages: [
                    { x: 0, text: "Beware the <strong>OBSERVER</strong>." },
                    { x: 8, text: "Measurement collapses the Wave Function." },
                    { x: 12, text: "If an Observer sees you, you are forced into <strong>PARTICLE</strong> mode." },
                    { x: 25, text: "You cannot be a Wave while being watched." }
                ],
                startPos: { x: 0, y: 2 }
            }
        ];

        function init() {
            // Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510);
            scene.fog = new THREE.FogExp2(0x050510, 0.02);

            // Camera
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.set(0, 5, 20);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Post Processing (Bloom)
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.1;
            bloomPass.strength = 1.5;
            bloomPass.radius = 0.5;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
            dirLight.position.set(10, 20, 10);
            scene.add(dirLight);

            // Player Setup
            createPlayer();

            // Level Setup
            loadLevel(0);

            // Input
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);
            window.addEventListener('resize', onWindowResize);
            document.getElementById('next-level-btn').addEventListener('click', nextLevel);

            // Start Loop
            animate();
        }

        function createPlayer() {
            // Particle Form (Solid Robot/Ninja)
            const geometry = new THREE.BoxGeometry(0.8, 1.6, 0.8);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0xff0055, 
                emissive: 0xff0055,
                emissiveIntensity: 0.5,
                roughness: 0.2,
                metalness: 0.8
            });
            playerMesh = new THREE.Mesh(geometry, material);
            scene.add(playerMesh);

            // Wave Form (Particle System)
            const particleGeo = new THREE.BufferGeometry();
            const particleCount = 100;
            const posArray = new Float32Array(particleCount * 3);
            for(let i=0; i<particleCount*3; i++) {
                posArray[i] = (Math.random() - 0.5) * 1.5;
            }
            particleGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            const particleMat = new THREE.PointsMaterial({
                color: 0x00ffff,
                size: 0.1,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            playerParticleSystem = new THREE.Points(particleGeo, particleMat);
            playerParticleSystem.visible = false;
            scene.add(playerParticleSystem);
        }

        function loadLevel(index) {
            if (levelGroup) scene.remove(levelGroup);
            if (enemyGroup) scene.remove(enemyGroup);
            
            levelGroup = new THREE.Group();
            enemyGroup = new THREE.Group();
            scene.add(levelGroup);
            scene.add(enemyGroup);

            const data = LEVELS[index];
            state.level = index;
            state.player.pos.set(data.startPos.x, data.startPos.y, 0);
            state.player.vel.set(0, 0, 0);
            state.lastCheckpoint.set(data.startPos.x, data.startPos.y, 0);

            // Build Platforms
            data.platforms.forEach(p => {
                const geo = new THREE.BoxGeometry(p.w, p.h, 4);
                let mat;
                
                if (p.type === 'solid') {
                    mat = new THREE.MeshStandardMaterial({ 
                        color: 0x222244, 
                        roughness: 0.1,
                        metalness: 0.5
                    });
                    // Add neon edges
                    const edges = new THREE.EdgesGeometry(geo);
                    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x00ffff }));
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.add(line);
                    mesh.position.set(p.x, p.y, 0);
                    mesh.userData = p;
                    levelGroup.add(mesh);
                } else if (p.type === 'slit') {
                    // Slit is a passable area for waves, but solid for particles?
                    // Actually, let's make it a "Polarizer" - a grate.
                    mat = new THREE.MeshStandardMaterial({
                        color: 0x00ffff,
                        emissive: 0x00ffff,
                        emissiveIntensity: 0.2,
                        transparent: true,
                        opacity: 0.3,
                        wireframe: true
                    });
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.set(p.x, p.y, 0);
                    mesh.userData = p;
                    levelGroup.add(mesh);
                } else if (p.type === 'goal') {
                    mat = new THREE.MeshStandardMaterial({
                        color: 0x00ff00,
                        emissive: 0x00ff00,
                        emissiveIntensity: 0.8,
                        transparent: true,
                        opacity: 0.5
                    });
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.set(p.x, p.y, 0);
                    mesh.userData = p;
                    levelGroup.add(mesh);
                    
                    // Goal particles
                    const goalLight = new THREE.PointLight(0x00ff00, 2, 10);
                    goalLight.position.set(p.x, p.y + 2, 0);
                    levelGroup.add(goalLight);
                }
            });

            // Build Enemies (Observers)
            data.enemies.forEach(e => {
                if (e.type === 'observer') {
                    // Eye mesh
                    const geo = new THREE.SphereGeometry(0.5, 16, 16);
                    const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xff0000, emissiveIntensity: 0.5 });
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.set(e.x, e.y, 0);
                    
                    // Cone of vision
                    const coneGeo = new THREE.ConeGeometry(2, e.range, 32, 1, true);
                    coneGeo.translate(0, -e.range/2, 0);
                    coneGeo.rotateZ(Math.PI / 2); // Point right
                    const coneMat = new THREE.MeshBasicMaterial({ 
                        color: 0xff0000, 
                        transparent: true, 
                        opacity: 0.1, 
                        side: THREE.DoubleSide,
                        blending: THREE.AdditiveBlending
                    });
                    const cone = new THREE.Mesh(coneGeo, coneMat);
                    cone.rotation.z = e.dir === 1 ? 0 : Math.PI; // Face direction
                    
                    mesh.add(cone);
                    mesh.userData = { ...e, cone: cone };
                    enemyGroup.add(mesh);
                }
            });

            // Reset UI
            document.getElementById('message-area').innerHTML = '';
            document.getElementById('level-complete').classList.remove('visible');
            
            // Show messages
            data.messages.forEach(msg => {
                const el = document.createElement('div');
                el.className = 'tutorial-msg';
                el.innerHTML = msg.text;
                el.dataset.x = msg.x;
                document.getElementById('message-area').appendChild(el);
            });
        }

        function nextLevel() {
            if (state.level + 1 < LEVELS.length) {
                loadLevel(state.level + 1);
            } else {
                alert("You have mastered the quantum realm! (More levels coming soon)");
                loadLevel(0);
            }
        }

        function onKeyDown(e) {
            switch(e.code) {
                case 'KeyW': state.keys.w = true; break;
                case 'KeyA': state.keys.a = true; break;
                case 'KeyS': state.keys.s = true; break;
                case 'KeyD': state.keys.d = true; break;
                case 'Space': 
                    if (!state.keys.space && state.player.grounded) {
                        jump();
                    }
                    state.keys.space = true; 
                    break;
                case 'ShiftLeft': 
                case 'ShiftRight':
                    if (!state.keys.shift) toggleMode();
                    state.keys.shift = true;
                    break;
                case 'KeyR': loadLevel(state.level); break;
            }
        }

        function onKeyUp(e) {
            switch(e.code) {
                case 'KeyW': state.keys.w = false; break;
                case 'KeyA': state.keys.a = false; break;
                case 'KeyS': state.keys.s = false; break;
                case 'KeyD': state.keys.d = false; break;
                case 'Space': state.keys.space = false; break;
                case 'ShiftLeft': 
                case 'ShiftRight':
                    state.keys.shift = false;
                    break;
            }
        }

        function toggleMode() {
            if (state.isObserved) return; // Cannot switch if observed
            
            state.mode = state.mode === 'PARTICLE' ? 'WAVE' : 'PARTICLE';
            updateModeUI();
        }

        function updateModeUI() {
            const display = document.getElementById('mode-display');
            const text = document.getElementById('mode-text');
            
            if (state.mode === 'PARTICLE') {
                display.className = 'mode-indicator particle-mode';
                text.textContent = 'PARTICLE FORM';
                playerMesh.visible = true;
                playerParticleSystem.visible = false;
            } else {
                display.className = 'mode-indicator wave-mode';
                text.textContent = 'WAVE FORM';
                playerMesh.visible = false;
                playerParticleSystem.visible = true;
            }
        }

        function jump() {
            const force = state.mode === 'WAVE' ? JUMP_FORCE * WAVE_JUMP_SCALE : JUMP_FORCE;
            state.player.vel.y = force;
            state.player.grounded = false;
        }

        function updatePhysics(dt) {
            const p = state.player;
            
            // Horizontal Movement
            let moveDir = 0;
            if (state.keys.a) moveDir -= 1;
            if (state.keys.d) moveDir += 1;

            const speed = state.mode === 'WAVE' ? MOVE_SPEED * WAVE_SPEED_SCALE : MOVE_SPEED;
            
            // Acceleration / Friction
            if (moveDir !== 0) {
                p.vel.x += moveDir * speed * 10 * dt;
                if (Math.abs(p.vel.x) > speed) p.vel.x = moveDir * speed;
            } else {
                p.vel.x *= 0.9; // Friction
            }

            // Gravity
            const gravity = state.mode === 'WAVE' ? GRAVITY * WAVE_GRAVITY_SCALE : GRAVITY;
            p.vel.y -= gravity * dt;

            // Apply Velocity
            p.pos.x += p.vel.x * dt;
            p.pos.y += p.vel.y * dt;

            // Collision Detection
            p.grounded = false;
            checkCollisions();

            // Death Plane
            if (p.pos.y < -10) {
                respawn();
            }

            // Update Mesh Position
            playerMesh.position.copy(p.pos);
            playerParticleSystem.position.copy(p.pos);
            
            // Rotate particle system for effect
            if (state.mode === 'WAVE') {
                playerParticleSystem.rotation.y += dt;
                playerParticleSystem.rotation.z += dt * 0.5;
            }
        }

        function checkCollisions() {
            const p = state.player;
            const playerBox = new THREE.Box3();
            const size = new THREE.Vector3(0.8, 1.6, 0.8);
            playerBox.setFromCenterAndSize(p.pos, size);

            levelGroup.children.forEach(mesh => {
                const platform = mesh.userData;
                if (!platform) return;

                const platformBox = new THREE.Box3().setFromObject(mesh);

                if (playerBox.intersectsBox(platformBox)) {
                    if (platform.type === 'goal') {
                        levelComplete();
                        return;
                    }

                    if (platform.type === 'slit') {
                        // If Wave, pass through. If Particle, collide.
                        if (state.mode === 'WAVE') return;
                    }

                    // Resolve Collision
                    // Simple AABB resolution
                    const overlapX = Math.min(playerBox.max.x, platformBox.max.x) - Math.max(playerBox.min.x, platformBox.min.x);
                    const overlapY = Math.min(playerBox.max.y, platformBox.max.y) - Math.max(playerBox.min.y, platformBox.min.y);

                    if (overlapX < overlapY) {
                        // Horizontal collision
                        if (p.pos.x < platform.x) {
                            p.pos.x -= overlapX;
                        } else {
                            p.pos.x += overlapX;
                        }
                        p.vel.x = 0;
                    } else {
                        // Vertical collision
                        if (p.pos.y < platform.y) {
                            p.pos.y -= overlapY;
                            p.vel.y = 0; // Hit head
                        } else {
                            p.pos.y += overlapY;
                            p.vel.y = 0;
                            p.grounded = true;
                        }
                    }
                    
                    // Update box for next check
                    playerBox.setFromCenterAndSize(p.pos, size);
                }
            });
        }

        function updateEnemies(dt) {
            state.isObserved = false;
            const pPos = state.player.pos;

            enemyGroup.children.forEach(enemy => {
                const data = enemy.userData;
                
                // Rotate observer
                // enemy.rotation.z = Math.sin(clock.getElapsedTime()) * 0.5;
                
                // Check vision
                const toPlayer = pPos.clone().sub(enemy.position);
                const dist = toPlayer.length();
                
                if (dist < data.range) {
                    // Check angle
                    // Assuming enemy faces X direction based on data.dir
                    const facing = new THREE.Vector3(data.dir, 0, 0);
                    // Apply rotation if we added animation
                    
                    const angle = facing.angleTo(toPlayer);
                    // data.angle is in degrees, convert to radians
                    const viewAngle = (data.angle * Math.PI / 180) / 2;
                    
                    if (angle < viewAngle) {
                        // Line of sight check (raycast)
                        const raycaster = new THREE.Raycaster(enemy.position, toPlayer.normalize(), 0, dist);
                        const intersects = raycaster.intersectObjects(levelGroup.children);
                        
                        // Filter out non-solid objects
                        const blocked = intersects.some(hit => hit.object.userData.type === 'solid');
                        
                        if (!blocked) {
                            state.isObserved = true;
                            
                            // Visual feedback
                            enemy.material.emissiveIntensity = 2.0;
                            enemy.children[0].material.opacity = 0.5;
                        } else {
                            enemy.material.emissiveIntensity = 0.5;
                            enemy.children[0].material.opacity = 0.1;
                        }
                    } else {
                        enemy.material.emissiveIntensity = 0.5;
                        enemy.children[0].material.opacity = 0.1;
                    }
                }
            });

            // Handle Observation Effect
            const warning = document.getElementById('observer-warning');
            if (state.isObserved) {
                warning.classList.add('visible');
                if (state.mode === 'WAVE') {
                    state.mode = 'PARTICLE';
                    updateModeUI();
                    // Add a "collapse" effect?
                }
            } else {
                warning.classList.remove('visible');
            }
        }

        function updateCamera() {
            // Smooth follow
            const targetX = state.player.pos.x;
            const targetY = Math.max(state.player.pos.y + 2, 5);
            
            camera.position.x += (targetX - camera.position.x) * 0.1;
            camera.position.y += (targetY - camera.position.y) * 0.1;
            camera.lookAt(camera.position.x, camera.position.y, 0);
        }

        function updateTutorial() {
            const msgs = document.querySelectorAll('.tutorial-msg');
            msgs.forEach(msg => {
                const x = parseFloat(msg.dataset.x);
                const dist = Math.abs(state.player.pos.x - x);
                if (dist < 8) {
                    msg.classList.add('visible');
                } else {
                    msg.classList.remove('visible');
                }
            });
        }

        function respawn() {
            state.player.pos.copy(state.lastCheckpoint);
            state.player.vel.set(0, 0, 0);
            state.mode = 'PARTICLE';
            updateModeUI();
        }

        function levelComplete() {
            document.getElementById('level-complete').classList.add('visible');
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const dt = Math.min(clock.getDelta(), 0.1);
            
            updatePhysics(dt);
            updateEnemies(dt);
            updateCamera(dt);
            updateTutorial();
            
            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>