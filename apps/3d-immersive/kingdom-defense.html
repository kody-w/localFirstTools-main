<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kingdom Defense - 3D Tower Defense</title>
    <meta name="description" content="A 3D Tower Defense game where you fight alongside your traps.">
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #111; color: white; user-select: none; }
        #game-ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 50%; transform: translate(-50%, -50%); box-sizing: border-box; }
        #crosshair::after { content: ''; position: absolute; top: 50%; left: 50%; width: 4px; height: 4px; background: white; transform: translate(-50%, -50%); border-radius: 50%; }
        
        .hud-panel { position: absolute; padding: 15px; background: rgba(0, 0, 0, 0.6); border-radius: 8px; pointer-events: auto; backdrop-filter: blur(5px); border: 1px solid rgba(255,255,255,0.1); }
        
        #stats-panel { top: 20px; left: 20px; }
        #wave-panel { top: 20px; right: 20px; text-align: right; }
        #build-panel { bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; }
        
        .stat-row { margin-bottom: 5px; font-size: 18px; font-weight: bold; text-shadow: 1px 1px 2px black; }
        .stat-label { color: #aaa; font-size: 14px; margin-right: 5px; }
        
        .build-slot { width: 60px; height: 60px; background: rgba(50, 50, 50, 0.8); border: 2px solid #444; border-radius: 8px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; position: relative; }
        .build-slot:hover { background: rgba(80, 80, 80, 0.9); border-color: #888; }
        .build-slot.active { border-color: #ffd700; box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); background: rgba(100, 80, 0, 0.6); }
        .build-slot.disabled { opacity: 0.5; cursor: not-allowed; filter: grayscale(1); }
        .slot-key { position: absolute; top: 2px; left: 5px; font-size: 12px; color: #ffd700; font-weight: bold; }
        .slot-cost { position: absolute; bottom: 2px; right: 5px; font-size: 12px; color: #4ff; font-weight: bold; }
        .slot-icon { font-size: 24px; margin-bottom: 2px; }
        
        #message-area { position: absolute; top: 20%; left: 50%; transform: translateX(-50%); text-align: center; font-size: 24px; font-weight: bold; text-shadow: 0 0 10px black; opacity: 0; transition: opacity 0.5s; }
        
        #start-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; pointer-events: auto; }
        h1 { font-size: 64px; margin-bottom: 10px; color: #ffd700; text-shadow: 0 0 20px #ff8800; letter-spacing: 2px; }
        .btn { padding: 15px 40px; font-size: 24px; background: linear-gradient(to bottom, #ff8800, #cc4400); color: white; border: none; border-radius: 5px; cursor: pointer; margin-top: 20px; font-weight: bold; box-shadow: 0 5px 15px rgba(0,0,0,0.5); transition: transform 0.1s; }
        .btn:hover { transform: scale(1.05); background: linear-gradient(to bottom, #ffaa00, #ee5500); }
        .btn:active { transform: scale(0.95); }
        
        #game-over-screen { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(50, 0, 0, 0.9); flex-direction: column; align-items: center; justify-content: center; z-index: 100; pointer-events: auto; }
        
        .health-bar-container { width: 200px; height: 20px; background: #333; border-radius: 10px; overflow: hidden; border: 1px solid #555; margin-top: 5px; }
        .health-bar { height: 100%; background: linear-gradient(to right, #ff3333, #aa0000); width: 100%; transition: width 0.2s; }
        
        .mana-bar-container { width: 200px; height: 10px; background: #333; border-radius: 5px; overflow: hidden; border: 1px solid #555; margin-top: 5px; }
        .mana-bar { height: 100%; background: linear-gradient(to right, #3333ff, #0000aa); width: 100%; transition: width 0.2s; }

        /* Tutorial overlay */
        #tutorial { position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.7); padding: 10px 20px; border-radius: 20px; font-size: 14px; color: #ccc; pointer-events: none; }
    </style>
</head>
<body>
    <div id="game-ui">
        <div id="crosshair"></div>
        
        <div id="stats-panel" class="hud-panel">
            <div class="stat-row"><span class="stat-label">HP:</span> <span id="hp-val">100</span></div>
            <div class="health-bar-container"><div id="hp-bar" class="health-bar"></div></div>
            <div class="stat-row" style="margin-top: 10px;"><span class="stat-label">GOLD:</span> <span id="gold-val" style="color: #ffd700">500</span></div>
            <div class="stat-row"><span class="stat-label">MANA:</span> <span id="mana-val" style="color: #4ff">100</span></div>
            <div class="mana-bar-container"><div id="mana-bar" class="mana-bar"></div></div>
        </div>
        
        <div id="wave-panel" class="hud-panel">
            <div class="stat-row" style="font-size: 24px;">WAVE <span id="wave-val">1</span></div>
            <div class="stat-row" style="font-size: 14px; color: #aaa;">Enemies: <span id="enemy-count">0</span></div>
            <div class="stat-row" style="font-size: 14px; color: #aaa;">Next Wave: <span id="wave-timer">--</span></div>
        </div>
        
        <div id="message-area">WAVE STARTED!</div>
        
        <div id="build-panel" class="hud-panel">
            <div class="build-slot active" id="slot-1" onclick="game.selectTrap(0)">
                <span class="slot-key">1</span>
                <span class="slot-icon">‚öîÔ∏è</span>
                <span class="slot-cost">0</span>
                <div style="font-size: 10px;">Attack</div>
            </div>
            <div class="build-slot" id="slot-2" onclick="game.selectTrap(1)">
                <span class="slot-key">2</span>
                <span class="slot-icon">üß±</span>
                <span class="slot-cost">50</span>
                <div style="font-size: 10px;">Wall</div>
            </div>
            <div class="build-slot" id="slot-3" onclick="game.selectTrap(2)">
                <span class="slot-key">3</span>
                <span class="slot-icon">üìå</span>
                <span class="slot-cost">100</span>
                <div style="font-size: 10px;">Spikes</div>
            </div>
            <div class="build-slot" id="slot-4" onclick="game.selectTrap(3)">
                <span class="slot-key">4</span>
                <span class="slot-icon">‚è´</span>
                <span class="slot-cost">150</span>
                <div style="font-size: 10px;">Spring</div>
            </div>
            <div class="build-slot" id="slot-5" onclick="game.selectTrap(4)">
                <span class="slot-key">5</span>
                <span class="slot-icon">üî•</span>
                <span class="slot-cost">300</span>
                <div style="font-size: 10px;">Lava</div>
            </div>
        </div>
        
        <div id="tutorial">WASD to Move ‚Ä¢ Mouse to Look ‚Ä¢ Click to Attack/Build ‚Ä¢ E to Interact</div>
    </div>

    <div id="start-screen">
        <h1>KINGDOM DEFENSE</h1>
        <p style="font-size: 20px; color: #ccc; max-width: 600px; text-align: center; line-height: 1.5;">
            Defend the Sacred Crystal from the endless hordes.<br>
            Build traps, fight with your sword, and survive as long as you can.
        </p>
        <button class="btn" id="start-btn">ENTER THE ARENA</button>
    </div>

    <div id="game-over-screen">
        <h1 style="color: #ff3333;">DEFEAT</h1>
        <p style="font-size: 24px; margin-bottom: 20px;">You survived <span id="final-wave">0</span> waves</p>
        <button class="btn" onclick="location.reload()">TRY AGAIN</button>
    </div>

    <!-- Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    
    <script>
        // --- Game Constants & Configuration ---
        const CONFIG = {
            PLAYER_SPEED: 15,
            PLAYER_RUN_SPEED: 25,
            JUMP_FORCE: 15,
            GRAVITY: 40,
            CAMERA_OFFSET: new THREE.Vector3(0, 4, 8),
            GRID_SIZE: 4,
            MAP_WIDTH: 60,
            MAP_DEPTH: 60,
            WAVE_DELAY: 10 // seconds between waves
        };

        const TRAPS = [
            { name: "Sword", cost: 0, type: "weapon", color: 0xcccccc, range: 5, damage: 25, cooldown: 0.4 },
            { name: "Wall", cost: 50, type: "block", color: 0x555555, health: 200 },
            { name: "Spikes", cost: 100, type: "floor", color: 0x888888, damage: 10, cooldown: 1.0 },
            { name: "Spring", cost: 150, type: "floor", color: 0x00ff00, force: 30, cooldown: 2.0 },
            { name: "Lava", cost: 300, type: "floor", color: 0xff4400, damage: 50, cooldown: 0.5 }
        ];

        // --- Game State ---
        const state = {
            gold: 500,
            hp: 100,
            mana: 100,
            wave: 1,
            enemies: [],
            traps: [],
            projectiles: [],
            particles: [],
            isPlaying: false,
            selectedTrapIndex: 0,
            lastAttackTime: 0,
            waveActive: false,
            waveTimer: 0,
            enemiesToSpawn: 0,
            spawnTimer: 0
        };

        // --- Three.js Globals ---
        let scene, camera, renderer, clock;
        let player, playerMesh, playerVelocity = new THREE.Vector3();
        let raycaster, mouse;
        let mapGroup, gridHelper, previewMesh;
        let enemyInstancedMesh;
        const dummy = new THREE.Object3D();
        const enemyColor = new THREE.Color();

        // --- Initialization ---
        function init() {
            // Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            scene.fog = new THREE.FogExp2(0x111111, 0.015);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            clock = new THREE.Clock();
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            dirLight.shadow.camera.left = -50;
            dirLight.shadow.camera.right = 50;
            dirLight.shadow.camera.top = 50;
            dirLight.shadow.camera.bottom = -50;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // Map Generation
            createMap();

            // Player Setup
            createPlayer();

            // Enemy System Setup
            setupEnemySystem();

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
            document.addEventListener('mousedown', onMouseDown, false);
            document.addEventListener('mousemove', onMouseMove, false);
            
            document.getElementById('start-btn').addEventListener('click', startGame);

            // Start Loop
            animate();
        }

        function createMap() {
            mapGroup = new THREE.Group();
            scene.add(mapGroup);

            // Floor
            const floorGeometry = new THREE.PlaneGeometry(CONFIG.MAP_WIDTH * 2, CONFIG.MAP_DEPTH * 2);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x222222, 
                roughness: 0.8,
                metalness: 0.2
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            mapGroup.add(floor);

            // Grid Helper (Visual only)
            gridHelper = new THREE.GridHelper(CONFIG.MAP_WIDTH * 2, CONFIG.MAP_WIDTH * 2 / CONFIG.GRID_SIZE, 0x444444, 0x222222);
            scene.add(gridHelper);

            // Crystal (Objective)
            const crystalGeo = new THREE.OctahedronGeometry(2);
            const crystalMat = new THREE.MeshPhongMaterial({ 
                color: 0x00ffff, 
                emissive: 0x0044aa,
                shininess: 100,
                transparent: true,
                opacity: 0.9
            });
            const crystal = new THREE.Mesh(crystalGeo, crystalMat);
            crystal.position.set(0, 3, 0);
            crystal.castShadow = true;
            
            // Crystal Base
            const baseGeo = new THREE.CylinderGeometry(3, 4, 1, 8);
            const baseMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
            const base = new THREE.Mesh(baseGeo, baseMat);
            base.position.set(0, 0.5, 0);
            base.receiveShadow = true;
            
            const crystalGroup = new THREE.Group();
            crystalGroup.add(crystal);
            crystalGroup.add(base);
            crystalGroup.userData = { type: 'crystal' };
            scene.add(crystalGroup);
            
            // Add a point light to the crystal
            const crystalLight = new THREE.PointLight(0x00ffff, 1, 20);
            crystalLight.position.set(0, 3, 0);
            scene.add(crystalLight);

            // Lava Pit (Kill zone)
            const lavaGeo = new THREE.PlaneGeometry(20, 20);
            const lavaMat = new THREE.MeshBasicMaterial({ color: 0xff3300 });
            const lava = new THREE.Mesh(lavaGeo, lavaMat);
            lava.rotation.x = -Math.PI / 2;
            lava.position.set(30, 0.1, 30); // Example position
            // scene.add(lava); // Add later if needed
            
            // Build Preview Mesh
            const previewGeo = new THREE.BoxGeometry(CONFIG.GRID_SIZE, CONFIG.GRID_SIZE, CONFIG.GRID_SIZE);
            const previewMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true, transparent: true, opacity: 0.5 });
            previewMesh = new THREE.Mesh(previewGeo, previewMat);
            scene.add(previewMesh);
            previewMesh.visible = false;
        }

        function createPlayer() {
            let geometry;
            if (typeof THREE.CapsuleGeometry !== 'undefined') {
                geometry = new THREE.CapsuleGeometry(0.8, 2, 4, 8);
            } else {
                // Fallback for older Three.js versions
                geometry = new THREE.CylinderGeometry(0.8, 0.8, 3.6, 8);
            }
            const material = new THREE.MeshStandardMaterial({ color: 0x3366ff });
            playerMesh = new THREE.Mesh(geometry, material);
            playerMesh.position.set(0, 2, 10);
            playerMesh.castShadow = true;
            scene.add(playerMesh);

            player = {
                mesh: playerMesh,
                onGround: false,
                canJump: true
            };
            
            // Weapon model (simple box)
            const weaponGeo = new THREE.BoxGeometry(0.2, 0.2, 1.5);
            const weaponMat = new THREE.MeshStandardMaterial({ color: 0xcccccc });
            const weapon = new THREE.Mesh(weaponGeo, weaponMat);
            weapon.position.set(0.5, 0, -0.5);
            playerMesh.add(weapon);
        }

        function setupEnemySystem() {
            // Using InstancedMesh for performance
            const geometry = new THREE.SphereGeometry(1, 16, 16); // Simple enemies for now
            const material = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            enemyInstancedMesh = new THREE.InstancedMesh(geometry, material, 1000);
            enemyInstancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            enemyInstancedMesh.castShadow = true;
            enemyInstancedMesh.receiveShadow = true;
            scene.add(enemyInstancedMesh);
            
            // Initialize all instances off-screen
            for (let i = 0; i < 1000; i++) {
                dummy.position.set(0, -100, 0);
                dummy.updateMatrix();
                enemyInstancedMesh.setMatrixAt(i, dummy.matrix);
            }
        }

        // --- Input Handling ---
        const keys = { w: false, a: false, s: false, d: false, space: false, shift: false };
        
        function onKeyDown(e) {
            switch(e.key.toLowerCase()) {
                case 'w': keys.w = true; break;
                case 'a': keys.a = true; break;
                case 's': keys.s = true; break;
                case 'd': keys.d = true; break;
                case ' ': keys.space = true; break;
                case 'shift': keys.shift = true; break;
                case '1': game.selectTrap(0); break;
                case '2': game.selectTrap(1); break;
                case '3': game.selectTrap(2); break;
                case '4': game.selectTrap(3); break;
                case '5': game.selectTrap(4); break;
            }
        }

        function onKeyUp(e) {
            switch(e.key.toLowerCase()) {
                case 'w': keys.w = false; break;
                case 'a': keys.a = false; break;
                case 's': keys.s = false; break;
                case 'd': keys.d = false; break;
                case ' ': keys.space = false; break;
                case 'shift': keys.shift = false; break;
            }
        }

        function onMouseDown(e) {
            if (!state.isPlaying) return;
            if (document.pointerLockElement !== document.body) {
                document.body.requestPointerLock();
                return;
            }
            
            if (e.button === 0) { // Left Click
                if (state.selectedTrapIndex === 0) {
                    game.attack();
                } else {
                    game.buildTrap();
                }
            } else if (e.button === 2) { // Right Click
                // Maybe cancel build or alt fire
            }
        }

        function onMouseMove(e) {
            if (document.pointerLockElement === document.body) {
                // Rotate player/camera based on mouse movement
                playerMesh.rotation.y -= e.movementX * 0.002;
                
                // Pitch camera (limit vertical angle)
                // For simplicity in this version, we just rotate the player Y and keep camera fixed relative to player
                // A more complex camera rig would be needed for full pitch control without rotating player mesh weirdly
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Game Logic ---
        const game = {
            selectTrap: (index) => {
                state.selectedTrapIndex = index;
                
                // Update UI
                document.querySelectorAll('.build-slot').forEach((el, i) => {
                    if (i === index) el.classList.add('active');
                    else el.classList.remove('active');
                });
                
                // Update Preview
                if (index === 0) {
                    previewMesh.visible = false;
                } else {
                    previewMesh.visible = true;
                    const trap = TRAPS[index];
                    previewMesh.material.color.setHex(trap.color);
                    
                    // Adjust preview geometry based on type
                    if (trap.type === 'block') {
                        previewMesh.geometry = new THREE.BoxGeometry(CONFIG.GRID_SIZE, CONFIG.GRID_SIZE * 2, CONFIG.GRID_SIZE);
                        previewMesh.position.y = CONFIG.GRID_SIZE;
                    } else {
                        previewMesh.geometry = new THREE.PlaneGeometry(CONFIG.GRID_SIZE, CONFIG.GRID_SIZE);
                        previewMesh.rotation.x = -Math.PI / 2;
                        previewMesh.position.y = 0.1;
                    }
                }
            },

            attack: () => {
                const now = clock.getElapsedTime();
                if (now - state.lastAttackTime < TRAPS[0].cooldown) return;
                
                state.lastAttackTime = now;
                
                // Visual effect
                const weapon = playerMesh.children[0];
                
                // Simple animation tween (manual)
                let animTime = 0;
                const animateAttack = () => {
                    animTime += 0.1;
                    if (animTime > Math.PI) {
                        weapon.rotation.y = 0;
                        return;
                    }
                    weapon.rotation.y = -Math.sin(animTime) * 2;
                    requestAnimationFrame(animateAttack);
                };
                animateAttack();
                
                // Hit detection (Cone in front of player)
                const attackPos = playerMesh.position.clone();
                const attackDir = new THREE.Vector3(0, 0, -1).applyQuaternion(playerMesh.quaternion);
                
                state.enemies.forEach(enemy => {
                    if (!enemy.active) return;
                    const dist = attackPos.distanceTo(enemy.position);
                    if (dist < TRAPS[0].range) {
                        // Check angle
                        const toEnemy = enemy.position.clone().sub(attackPos).normalize();
                        const angle = attackDir.angleTo(toEnemy);
                        if (angle < Math.PI / 3) { // 60 degree cone
                            game.damageEnemy(enemy, TRAPS[0].damage);
                            // Knockback
                            const knockback = toEnemy.multiplyScalar(5);
                            enemy.velocity.add(knockback);
                        }
                    }
                });
            },

            buildTrap: () => {
                const trapConfig = TRAPS[state.selectedTrapIndex];
                if (state.gold < trapConfig.cost) {
                    game.showMessage("Not enough gold!");
                    return;
                }

                // Raycast to find grid position
                // We cast from camera center
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                const intersects = raycaster.intersectObjects([mapGroup.children[0]]); // Intersect floor
                
                if (intersects.length > 0) {
                    const point = intersects[0].point;
                    
                    // Snap to grid
                    const x = Math.round(point.x / CONFIG.GRID_SIZE) * CONFIG.GRID_SIZE;
                    const z = Math.round(point.z / CONFIG.GRID_SIZE) * CONFIG.GRID_SIZE;
                    
                    // Check if occupied
                    const key = `${x},${z}`;
                    if (state.traps.find(t => t.key === key)) {
                        game.showMessage("Space occupied!");
                        return;
                    }
                    
                    // Check distance from player (can't build too far)
                    if (point.distanceTo(playerMesh.position) > 20) {
                        game.showMessage("Too far!");
                        return;
                    }

                    // Build it
                    state.gold -= trapConfig.cost;
                    game.updateStats();
                    
                    const trapObj = {
                        type: trapConfig.name,
                        position: new THREE.Vector3(x, 0, z),
                        key: key,
                        config: trapConfig,
                        lastFire: 0
                    };
                    
                    // Visuals
                    let mesh;
                    if (trapConfig.type === 'block') {
                        const geo = new THREE.BoxGeometry(CONFIG.GRID_SIZE, CONFIG.GRID_SIZE * 2, CONFIG.GRID_SIZE);
                        const mat = new THREE.MeshStandardMaterial({ color: trapConfig.color });
                        mesh = new THREE.Mesh(geo, mat);
                        mesh.position.set(x, CONFIG.GRID_SIZE, z);
                    } else {
                        const geo = new THREE.PlaneGeometry(CONFIG.GRID_SIZE * 0.9, CONFIG.GRID_SIZE * 0.9);
                        const mat = new THREE.MeshStandardMaterial({ color: trapConfig.color, side: THREE.DoubleSide });
                        mesh = new THREE.Mesh(geo, mat);
                        mesh.rotation.x = -Math.PI / 2;
                        mesh.position.set(x, 0.1, z);
                    }
                    
                    scene.add(mesh);
                    trapObj.mesh = mesh;
                    state.traps.push(trapObj);
                    
                    // Particle effect
                    game.spawnParticles(new THREE.Vector3(x, 1, z), 10, 0xffd700);
                }
            },

            damageEnemy: (enemy, amount) => {
                enemy.hp -= amount;
                game.spawnParticles(enemy.position, 3, 0xff0000);
                
                if (enemy.hp <= 0) {
                    enemy.active = false;
                    enemy.position.y = -100; // Hide
                    state.gold += 10;
                    game.updateStats();
                    document.getElementById('enemy-count').innerText = state.enemies.filter(e => e.active).length;
                }
            },

            spawnParticles: (pos, count, color) => {
                // Simple particle system implementation would go here
                // For now, just a placeholder
            },

            showMessage: (msg) => {
                const el = document.getElementById('message-area');
                el.innerText = msg;
                el.style.opacity = 1;
                setTimeout(() => el.style.opacity = 0, 2000);
            },

            updateStats: () => {
                document.getElementById('gold-val').innerText = state.gold;
                document.getElementById('hp-val').innerText = Math.ceil(state.hp);
                document.getElementById('hp-bar').style.width = state.hp + '%';
                
                // Update build buttons availability
                TRAPS.forEach((trap, i) => {
                    const el = document.getElementById(`slot-${i+1}`);
                    if (el) {
                        if (state.gold < trap.cost) el.classList.add('disabled');
                        else el.classList.remove('disabled');
                    }
                });
            },
            
            startWave: () => {
                state.waveActive = true;
                state.enemiesToSpawn = 5 + (state.wave * 2);
                state.spawnTimer = 0;
                game.showMessage(`WAVE ${state.wave} STARTED!`);
            },
            
            spawnEnemy: () => {
                // Find inactive enemy slot
                let enemy = state.enemies.find(e => !e.active);
                if (!enemy) {
                    enemy = { id: state.enemies.length, active: false, velocity: new THREE.Vector3() };
                    state.enemies.push(enemy);
                }
                
                // Reset enemy
                enemy.active = true;
                enemy.hp = 50 + (state.wave * 10);
                enemy.maxHp = enemy.hp;
                
                // Spawn points (4 corners)
                const spawnPoints = [
                    new THREE.Vector3(-40, 1, -40),
                    new THREE.Vector3(40, 1, -40),
                    new THREE.Vector3(-40, 1, 40),
                    new THREE.Vector3(40, 1, 40)
                ];
                const spawn = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
                enemy.position = spawn.clone();
                enemy.velocity.set(0, 0, 0);
                
                document.getElementById('enemy-count').innerText = state.enemies.filter(e => e.active).length;
            }
        };

        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            document.body.requestPointerLock();
            state.isPlaying = true;
            state.wave = 1;
            state.hp = 100;
            state.gold = 500;
            game.updateStats();
            
            // Start first wave after delay
            setTimeout(game.startWave, 2000);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const dt = Math.min(clock.getDelta(), 0.1); // Cap dt
            
            if (!state.isPlaying) return;

            // --- Player Physics ---
            // Apply Gravity
            if (!player.onGround) {
                playerVelocity.y -= CONFIG.GRAVITY * dt;
            }
            
            // Movement Input
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(playerMesh.quaternion);
            const right = new THREE.Vector3(1, 0, 0).applyQuaternion(playerMesh.quaternion);
            
            const moveDir = new THREE.Vector3();
            if (keys.w) moveDir.add(forward);
            if (keys.s) moveDir.sub(forward);
            if (keys.d) moveDir.add(right);
            if (keys.a) moveDir.sub(right);
            
            if (moveDir.length() > 0) moveDir.normalize();
            
            const speed = keys.shift ? CONFIG.PLAYER_RUN_SPEED : CONFIG.PLAYER_SPEED;
            
            // Apply movement to velocity (X/Z only)
            playerVelocity.x = moveDir.x * speed;
            playerVelocity.z = moveDir.z * speed;
            
            // Jump
            if (keys.space && player.onGround) {
                playerVelocity.y = CONFIG.JUMP_FORCE;
                player.onGround = false;
            }
            
            // Apply Velocity
            playerMesh.position.add(playerVelocity.clone().multiplyScalar(dt));
            
            // Floor Collision (Simple plane check)
            if (playerMesh.position.y < 2) {
                playerMesh.position.y = 2;
                playerVelocity.y = 0;
                player.onGround = true;
            }
            
            // Camera Follow
            // Calculate ideal camera position based on player rotation
            const idealOffset = CONFIG.CAMERA_OFFSET.clone().applyQuaternion(playerMesh.quaternion);
            const idealPos = playerMesh.position.clone().add(idealOffset);
            
            // Smoothly interpolate camera
            camera.position.lerp(idealPos, 5 * dt);
            camera.lookAt(playerMesh.position.clone().add(new THREE.Vector3(0, 2, 0)));

            // --- Wave Logic ---
            if (state.waveActive) {
                if (state.enemiesToSpawn > 0) {
                    state.spawnTimer += dt;
                    if (state.spawnTimer > 1.0) { // Spawn every second
                        game.spawnEnemy();
                        state.enemiesToSpawn--;
                        state.spawnTimer = 0;
                    }
                } else if (state.enemies.filter(e => e.active).length === 0) {
                    // Wave Complete
                    state.waveActive = false;
                    state.wave++;
                    state.waveTimer = CONFIG.WAVE_DELAY;
                    game.showMessage("WAVE COMPLETE!");
                    document.getElementById('wave-val').innerText = state.wave;
                }
            } else {
                // Between waves
                if (state.waveTimer > 0) {
                    state.waveTimer -= dt;
                    document.getElementById('wave-timer').innerText = Math.ceil(state.waveTimer) + 's';
                } else if (state.waveTimer <= 0 && state.wave > 1) {
                    game.startWave();
                }
            }

            // --- Enemy Logic ---
            const crystalPos = new THREE.Vector3(0, 0, 0);
            let activeCount = 0;
            
            state.enemies.forEach((enemy, i) => {
                if (!enemy.active) {
                    // Move dummy offscreen
                    dummy.position.set(0, -100, 0);
                    dummy.updateMatrix();
                    enemyInstancedMesh.setMatrixAt(i, dummy.matrix);
                    return;
                }
                
                activeCount++;
                
                // Move towards crystal
                const dir = crystalPos.clone().sub(enemy.position).normalize();
                
                // Simple avoidance (boids-like separation)
                state.enemies.forEach(other => {
                    if (other === enemy || !other.active) return;
                    const dist = enemy.position.distanceTo(other.position);
                    if (dist < 2) {
                        const push = enemy.position.clone().sub(other.position).normalize().multiplyScalar(2 / dist);
                        dir.add(push);
                    }
                });
                
                // Apply velocity (physics-ish)
                enemy.velocity.add(dir.multiplyScalar(10 * dt)); // Acceleration
                enemy.velocity.multiplyScalar(0.9); // Friction
                
                // Apply gravity
                if (enemy.position.y > 1) {
                    enemy.velocity.y -= CONFIG.GRAVITY * dt;
                } else {
                    enemy.position.y = 1;
                    enemy.velocity.y = 0;
                }
                
                enemy.position.add(enemy.velocity.clone().multiplyScalar(dt));
                
                // Trap Interactions
                state.traps.forEach(trap => {
                    const tPos = trap.position;
                    const dist = new THREE.Vector2(enemy.position.x - tPos.x, enemy.position.z - tPos.z).length();
                    
                    if (dist < CONFIG.GRID_SIZE / 2) {
                        const now = clock.getElapsedTime();
                        
                        if (trap.config.name === "Spikes" && now - trap.lastFire > trap.config.cooldown) {
                            game.damageEnemy(enemy, trap.config.damage);
                            trap.lastFire = now;
                        } else if (trap.config.name === "Lava" && now - trap.lastFire > trap.config.cooldown) {
                            game.damageEnemy(enemy, trap.config.damage);
                            trap.lastFire = now;
                        } else if (trap.config.name === "Spring" && now - trap.lastFire > trap.config.cooldown) {
                            enemy.velocity.y = trap.config.force;
                            // Random horizontal fling
                            enemy.velocity.x += (Math.random() - 0.5) * 20;
                            enemy.velocity.z += (Math.random() - 0.5) * 20;
                            trap.lastFire = now;
                        } else if (trap.config.name === "Wall") {
                            // Simple collision pushback
                            const push = enemy.position.clone().sub(tPos).normalize().multiplyScalar(5);
                            enemy.velocity.add(push);
                        }
                    }
                });
                
                // Crystal Damage
                if (enemy.position.distanceTo(crystalPos) < 3) {
                    state.hp -= 10 * dt;
                    game.updateStats();
                    // Push back
                    enemy.velocity.add(dir.negate().multiplyScalar(20));
                    
                    if (state.hp <= 0) {
                        state.isPlaying = false;
                        document.getElementById('final-wave').innerText = state.wave;
                        document.getElementById('game-over-screen').style.display = 'flex';
                        document.exitPointerLock();
                    }
                }
                
                // Update Instance
                dummy.position.copy(enemy.position);
                dummy.scale.setScalar(1);
                dummy.updateMatrix();
                enemyInstancedMesh.setMatrixAt(i, dummy.matrix);
                
                // Color based on HP (optional, requires custom shader or instance color attribute)
            });
            
            enemyInstancedMesh.instanceMatrix.needsUpdate = true;
            
            // --- Build Preview Update ---
            if (state.selectedTrapIndex > 0 && previewMesh.visible) {
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                const intersects = raycaster.intersectObjects([mapGroup.children[0]]);
                
                if (intersects.length > 0) {
                    const point = intersects[0].point;
                    const x = Math.round(point.x / CONFIG.GRID_SIZE) * CONFIG.GRID_SIZE;
                    const z = Math.round(point.z / CONFIG.GRID_SIZE) * CONFIG.GRID_SIZE;
                    
                    previewMesh.position.x = x;
                    previewMesh.position.z = z;
                    
                    // Color red if invalid
                    const key = `${x},${z}`;
                    const occupied = state.traps.find(t => t.key === key);
                    const tooFar = point.distanceTo(playerMesh.position) > 20;
                    
                    if (occupied || tooFar) {
                        previewMesh.material.color.setHex(0xff0000);
                    } else {
                        previewMesh.material.color.setHex(TRAPS[state.selectedTrapIndex].color);
                    }
                }
            }

            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>