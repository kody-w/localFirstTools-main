<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tesseract 4D Rotator</title>
    <meta name="rappterzoo:author" content="Claude Opus 4.6">
    <meta name="rappterzoo:author-type" content="agent">
    <meta name="rappterzoo:category" content="3d-immersive">
    <meta name="rappterzoo:tags" content="3d,4d,tesseract,hypercube,math,threejs,geometry,visualization">
    <meta name="rappterzoo:type" content="visual">
    <meta name="rappterzoo:complexity" content="advanced">
    <meta name="rappterzoo:created" content="2026-02-08">
    <meta name="rappterzoo:generation" content="2">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Courier New', monospace;
            background: #050505;
            color: #00ffcc;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }
        #canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        canvas {
            display: block;
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 20, 20, 0.85);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #00ffcc;
            max-width: 320px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            font-size: 13px;
        }
        #info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 20, 20, 0.85);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #00ffcc;
            max-width: 300px;
            font-size: 12px;
            line-height: 1.5;
        }
        h3 {
            color: #ff00ff;
            margin-bottom: 10px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .control-group {
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(0, 255, 204, 0.2);
        }
        .control-group:last-child {
            border-bottom: none;
        }
        label {
            display: block;
            margin-bottom: 4px;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }
        input[type="checkbox"] {
            margin-right: 8px;
        }
        button {
            background: rgba(0, 255, 204, 0.2);
            border: 1px solid #00ffcc;
            color: #00ffcc;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin: 4px 4px 4px 0;
            transition: all 0.2s;
        }
        button:hover {
            background: rgba(0, 255, 204, 0.4);
            box-shadow: 0 0 10px rgba(0, 255, 204, 0.5);
        }
        button:active {
            transform: scale(0.95);
        }
        .value-display {
            color: #ff00ff;
            font-weight: bold;
        }
        #fps {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 20, 20, 0.85);
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid #00ffcc;
            font-size: 11px;
        }
        .shortcuts {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid rgba(0, 255, 204, 0.2);
            font-size: 10px;
            opacity: 0.7;
        }
        .shortcuts div {
            margin: 3px 0;
        }
        #render-mode {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
        }
        #render-mode button {
            flex: 1;
            min-width: 80px;
        }
        #render-mode button.active {
            background: rgba(255, 0, 255, 0.4);
            border-color: #ff00ff;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div id="controls">
        <h3>4D Tesseract Controls</h3>

        <div class="control-group">
            <label>
                <input type="checkbox" id="auto-rotate" checked>
                Auto-Rotate
            </label>
            <label>Rotation Speed: <span class="value-display" id="speed-val">1.0</span></label>
            <input type="range" id="rotation-speed" min="0" max="3" step="0.1" value="1.0">
        </div>

        <div class="control-group">
            <label>XW Plane: <span class="value-display" id="xw-val">0.5</span></label>
            <input type="range" id="rot-xw" min="0" max="6.28" step="0.01" value="0.5">

            <label>YW Plane: <span class="value-display" id="yw-val">0.3</span></label>
            <input type="range" id="rot-yw" min="0" max="6.28" step="0.01" value="0.3">

            <label>ZW Plane: <span class="value-display" id="zw-val">0.7</span></label>
            <input type="range" id="rot-zw" min="0" max="6.28" step="0.01" value="0.7">

            <label>XY Plane: <span class="value-display" id="xy-val">0.0</span></label>
            <input type="range" id="rot-xy" min="0" max="6.28" step="0.01" value="0.0">

            <label>XZ Plane: <span class="value-display" id="xz-val">0.0</span></label>
            <input type="range" id="rot-xz" min="0" max="6.28" step="0.01" value="0.0">

            <label>YZ Plane: <span class="value-display" id="yz-val">0.0</span></label>
            <input type="range" id="rot-yz" min="0" max="6.28" step="0.01" value="0.0">
        </div>

        <div class="control-group">
            <label>Projection Distance: <span class="value-display" id="proj-val">3.0</span></label>
            <input type="range" id="proj-dist" min="2" max="6" step="0.1" value="3.0">

            <label>Vertex Size: <span class="value-display" id="vsize-val">0.08</span></label>
            <input type="range" id="vertex-size" min="0.03" max="0.15" step="0.01" value="0.08">
        </div>

        <div class="control-group">
            <label>Render Mode:</label>
            <div id="render-mode">
                <button class="mode-btn active" data-mode="full">Full</button>
                <button class="mode-btn" data-mode="edges">Edges</button>
                <button class="mode-btn" data-mode="vertices">Vertices</button>
            </div>
        </div>

        <div class="control-group">
            <label>Presets:</label>
            <button onclick="loadPreset('calm')">Calm Spin</button>
            <button onclick="loadPreset('full')">Full Rotation</button>
            <button onclick="loadPreset('hypnotic')">Hypnotic</button>
            <button onclick="loadPreset('single')">Single Plane</button>
        </div>

        <div class="control-group">
            <button onclick="saveSettings()">Save Settings</button>
            <button onclick="loadSettings()">Load Settings</button>
            <button onclick="resetSettings()">Reset</button>
        </div>

        <div class="shortcuts">
            <div><strong>Shortcuts:</strong></div>
            <div>SPACE - Pause/Resume</div>
            <div>1-4 - Presets</div>
            <div>Drag - Rotate View</div>
            <div>Scroll - Zoom</div>
        </div>
    </div>

    <div id="info">
        <h3>The Tesseract</h3>
        <p>A tesseract (8-cell, hypercube) is the 4-dimensional analog of a cube.</p>
        <p><strong>Structure:</strong></p>
        <ul style="margin-left: 15px; margin-top: 5px;">
            <li>16 vertices (corners)</li>
            <li>32 edges (lines)</li>
            <li>24 faces (squares)</li>
            <li>8 cells (cubes)</li>
        </ul>
        <p style="margin-top: 10px;"><strong>4D Rotation:</strong></p>
        <p>In 4D space, rotation occurs in planes (XW, YW, ZW), not around axes. The W-axis is the fourth spatial dimension.</p>
        <p style="margin-top: 10px;"><strong>Projection:</strong></p>
        <p>We project 4D coordinates into 3D using perspective: <code>scale = d/(d-w)</code>, then render with Three.js.</p>
        <p style="margin-top: 10px;"><strong>Color:</strong></p>
        <p>Vertices and edges are colored by their W-coordinate: <span style="color: #00ffff;">cyan (w=-1)</span> to <span style="color: #ff00ff;">magenta (w=+1)</span>.</p>
    </div>

    <div id="fps">FPS: <span id="fps-counter">60</span></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Three.js setup
        let scene, camera, renderer;
        let vertexMeshes = [];
        let edgeLines = null;
        let starField;

        // 4D tesseract state
        const vertices4D = [];
        const edges = [];

        // Rotation angles (in radians)
        let rotXW = 0.5, rotYW = 0.3, rotZW = 0.7;
        let rotXY = 0, rotXZ = 0, rotYZ = 0;

        // Settings
        let autoRotate = true;
        let rotationSpeed = 1.0;
        let projectionDistance = 3.0;
        let vertexSize = 0.08;
        let renderMode = 'full'; // full, edges, vertices
        let isPaused = false;

        // Mouse orbit controls
        let mouseDown = false;
        let mouseX = 0, mouseY = 0;
        let cameraAngleX = 0.3, cameraAngleY = 0.3;
        let cameraDistance = 8;

        // FPS tracking
        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 60;

        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050505);

            // Create camera
            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            updateCameraPosition();

            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Create starfield background
            createStarField();

            // Initialize 4D tesseract vertices (all combinations of +/-1 in 4D)
            for (let x = -1; x <= 1; x += 2) {
                for (let y = -1; y <= 1; y += 2) {
                    for (let z = -1; z <= 1; z += 2) {
                        for (let w = -1; w <= 1; w += 2) {
                            vertices4D.push({ x, y, z, w });
                        }
                    }
                }
            }

            // Define edges (connect vertices that differ in exactly one coordinate)
            for (let i = 0; i < vertices4D.length; i++) {
                for (let j = i + 1; j < vertices4D.length; j++) {
                    const v1 = vertices4D[i];
                    const v2 = vertices4D[j];
                    let diffCount = 0;
                    if (v1.x !== v2.x) diffCount++;
                    if (v1.y !== v2.y) diffCount++;
                    if (v1.z !== v2.z) diffCount++;
                    if (v1.w !== v2.w) diffCount++;
                    if (diffCount === 1) {
                        edges.push([i, j]);
                    }
                }
            }

            // Create 3D vertex meshes
            createVertexMeshes();

            // Create edge lines
            createEdgeLines();

            // Setup event listeners
            setupEventListeners();

            // Load saved settings
            loadSettings();

            // Start animation
            animate();
        }

        function createStarField() {
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 1000;
            const positions = new Float32Array(starCount * 3);

            for (let i = 0; i < starCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 100;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 100;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
            }

            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const starMaterial = new THREE.PointsMaterial({
                color: 0x00ffcc,
                size: 0.05,
                transparent: true,
                opacity: 0.6
            });

            starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);
        }

        function createVertexMeshes() {
            // Clear existing meshes
            vertexMeshes.forEach(mesh => scene.remove(mesh));
            vertexMeshes = [];

            if (renderMode === 'edges') return;

            for (let i = 0; i < vertices4D.length; i++) {
                const geometry = new THREE.SphereGeometry(vertexSize, 16, 16);
                const material = new THREE.MeshBasicMaterial({
                    color: 0x00ffcc,
                    transparent: true,
                    opacity: 0.9,
                    blending: THREE.AdditiveBlending
                });
                const mesh = new THREE.Mesh(geometry, material);
                scene.add(mesh);
                vertexMeshes.push(mesh);
            }
        }

        function createEdgeLines() {
            if (edgeLines) {
                scene.remove(edgeLines);
            }

            if (renderMode === 'vertices') return;

            const positions = new Float32Array(edges.length * 6);
            const colors = new Float32Array(edges.length * 6);

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.LineBasicMaterial({
                vertexColors: true,
                transparent: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending
            });

            edgeLines = new THREE.LineSegments(geometry, material);
            scene.add(edgeLines);
        }

        function rotate4D(v, angleXW, angleYW, angleZW, angleXY, angleXZ, angleYZ) {
            let { x, y, z, w } = v;

            // XW plane rotation
            if (angleXW !== 0) {
                const cosXW = Math.cos(angleXW);
                const sinXW = Math.sin(angleXW);
                const newX = x * cosXW - w * sinXW;
                const newW = x * sinXW + w * cosXW;
                x = newX;
                w = newW;
            }

            // YW plane rotation
            if (angleYW !== 0) {
                const cosYW = Math.cos(angleYW);
                const sinYW = Math.sin(angleYW);
                const newY = y * cosYW - w * sinYW;
                const newW = y * sinYW + w * cosYW;
                y = newY;
                w = newW;
            }

            // ZW plane rotation
            if (angleZW !== 0) {
                const cosZW = Math.cos(angleZW);
                const sinZW = Math.sin(angleZW);
                const newZ = z * cosZW - w * sinZW;
                const newW = z * sinZW + w * cosZW;
                z = newZ;
                w = newW;
            }

            // XY plane rotation
            if (angleXY !== 0) {
                const cosXY = Math.cos(angleXY);
                const sinXY = Math.sin(angleXY);
                const newX = x * cosXY - y * sinXY;
                const newY = x * sinXY + y * cosXY;
                x = newX;
                y = newY;
            }

            // XZ plane rotation
            if (angleXZ !== 0) {
                const cosXZ = Math.cos(angleXZ);
                const sinXZ = Math.sin(angleXZ);
                const newX = x * cosXZ - z * sinXZ;
                const newZ = x * sinXZ + z * cosXZ;
                x = newX;
                z = newZ;
            }

            // YZ plane rotation
            if (angleYZ !== 0) {
                const cosYZ = Math.cos(angleYZ);
                const sinYZ = Math.sin(angleYZ);
                const newY = y * cosYZ - z * sinYZ;
                const newZ = y * sinYZ + z * cosYZ;
                y = newY;
                z = newZ;
            }

            return { x, y, z, w };
        }

        function project4Dto3D(v4d) {
            const d = projectionDistance;
            const scale = d / (d - v4d.w);
            return {
                x: v4d.x * scale,
                y: v4d.y * scale,
                z: v4d.z * scale,
                w: v4d.w
            };
        }

        function getColorFromW(w) {
            // Map w from [-1, 1] to color from cyan to magenta
            const t = (w + 1) / 2; // Normalize to [0, 1]
            const r = Math.floor(t * 255);
            const g = Math.floor((1 - t) * 255);
            const b = 255;
            return new THREE.Color(r / 255, g / 255, b / 255);
        }

        function updateTesseract() {
            // Rotate and project all vertices
            const rotatedVertices = vertices4D.map(v =>
                rotate4D(v, rotXW, rotYW, rotZW, rotXY, rotXZ, rotYZ)
            );
            const projectedVertices = rotatedVertices.map(v => project4Dto3D(v));

            // Update vertex meshes
            vertexMeshes.forEach((mesh, i) => {
                const v = projectedVertices[i];
                mesh.position.set(v.x, v.y, v.z);
                mesh.material.color = getColorFromW(v.w);

                // Add glow effect by scaling based on w-depth
                const glowScale = 1 + (v.w + 1) * 0.2;
                mesh.scale.setScalar(glowScale);
            });

            // Update edge lines
            if (edgeLines) {
                const positions = edgeLines.geometry.attributes.position.array;
                const colors = edgeLines.geometry.attributes.color.array;

                edges.forEach((edge, i) => {
                    const v1 = projectedVertices[edge[0]];
                    const v2 = projectedVertices[edge[1]];

                    positions[i * 6] = v1.x;
                    positions[i * 6 + 1] = v1.y;
                    positions[i * 6 + 2] = v1.z;
                    positions[i * 6 + 3] = v2.x;
                    positions[i * 6 + 4] = v2.y;
                    positions[i * 6 + 5] = v2.z;

                    const color1 = getColorFromW(v1.w);
                    const color2 = getColorFromW(v2.w);

                    colors[i * 6] = color1.r;
                    colors[i * 6 + 1] = color1.g;
                    colors[i * 6 + 2] = color1.b;
                    colors[i * 6 + 3] = color2.r;
                    colors[i * 6 + 4] = color2.g;
                    colors[i * 6 + 5] = color2.b;
                });

                edgeLines.geometry.attributes.position.needsUpdate = true;
                edgeLines.geometry.attributes.color.needsUpdate = true;
            }
        }

        function updateCameraPosition() {
            camera.position.x = Math.sin(cameraAngleY) * Math.cos(cameraAngleX) * cameraDistance;
            camera.position.y = Math.sin(cameraAngleX) * cameraDistance;
            camera.position.z = Math.cos(cameraAngleY) * Math.cos(cameraAngleX) * cameraDistance;
            camera.lookAt(0, 0, 0);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (!isPaused) {
                // Auto-rotate if enabled
                if (autoRotate) {
                    const dt = 0.01 * rotationSpeed;
                    if (rotXW !== 0 || autoRotate) rotXW += dt * 0.5;
                    if (rotYW !== 0 || autoRotate) rotYW += dt * 0.3;
                    if (rotZW !== 0 || autoRotate) rotZW += dt * 0.7;

                    // Keep angles in [0, 2Ï€]
                    rotXW = rotXW % (2 * Math.PI);
                    rotYW = rotYW % (2 * Math.PI);
                    rotZW = rotZW % (2 * Math.PI);
                }

                updateTesseract();

                // Slowly rotate starfield
                if (starField) {
                    starField.rotation.y += 0.0001;
                }
            }

            renderer.render(scene, camera);

            // Update FPS
            frameCount++;
            const currentTime = performance.now();
            if (currentTime - lastTime >= 1000) {
                fps = Math.round(frameCount * 1000 / (currentTime - lastTime));
                document.getElementById('fps-counter').textContent = fps;
                frameCount = 0;
                lastTime = currentTime;
            }
        }

        function setupEventListeners() {
            // Auto-rotate checkbox
            document.getElementById('auto-rotate').addEventListener('change', (e) => {
                autoRotate = e.target.checked;
            });

            // Rotation speed slider
            const speedSlider = document.getElementById('rotation-speed');
            const speedVal = document.getElementById('speed-val');
            speedSlider.addEventListener('input', (e) => {
                rotationSpeed = parseFloat(e.target.value);
                speedVal.textContent = rotationSpeed.toFixed(1);
            });

            // Rotation plane sliders
            const setupRotationSlider = (id, valId, setter) => {
                const slider = document.getElementById(id);
                const val = document.getElementById(valId);
                slider.addEventListener('input', (e) => {
                    const angle = parseFloat(e.target.value);
                    setter(angle);
                    val.textContent = angle.toFixed(2);
                });
            };

            setupRotationSlider('rot-xw', 'xw-val', (v) => rotXW = v);
            setupRotationSlider('rot-yw', 'yw-val', (v) => rotYW = v);
            setupRotationSlider('rot-zw', 'zw-val', (v) => rotZW = v);
            setupRotationSlider('rot-xy', 'xy-val', (v) => rotXY = v);
            setupRotationSlider('rot-xz', 'xz-val', (v) => rotXZ = v);
            setupRotationSlider('rot-yz', 'yz-val', (v) => rotYZ = v);

            // Projection distance slider
            const projSlider = document.getElementById('proj-dist');
            const projVal = document.getElementById('proj-val');
            projSlider.addEventListener('input', (e) => {
                projectionDistance = parseFloat(e.target.value);
                projVal.textContent = projectionDistance.toFixed(1);
            });

            // Vertex size slider
            const vsizeSlider = document.getElementById('vertex-size');
            const vsizeVal = document.getElementById('vsize-val');
            vsizeSlider.addEventListener('input', (e) => {
                vertexSize = parseFloat(e.target.value);
                vsizeVal.textContent = vertexSize.toFixed(2);
                createVertexMeshes();
            });

            // Render mode buttons
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    renderMode = e.target.dataset.mode;
                    createVertexMeshes();
                    createEdgeLines();
                });
            });

            // Mouse controls for camera orbit
            const container = document.getElementById('canvas-container');

            container.addEventListener('mousedown', (e) => {
                mouseDown = true;
                mouseX = e.clientX;
                mouseY = e.clientY;
            });

            container.addEventListener('mouseup', () => {
                mouseDown = false;
            });

            container.addEventListener('mousemove', (e) => {
                if (mouseDown) {
                    const deltaX = e.clientX - mouseX;
                    const deltaY = e.clientY - mouseY;

                    cameraAngleY += deltaX * 0.005;
                    cameraAngleX += deltaY * 0.005;

                    // Clamp vertical angle
                    cameraAngleX = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, cameraAngleX));

                    updateCameraPosition();

                    mouseX = e.clientX;
                    mouseY = e.clientY;
                }
            });

            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                cameraDistance += e.deltaY * 0.01;
                cameraDistance = Math.max(3, Math.min(20, cameraDistance));
                updateCameraPosition();
            });

            // Keyboard shortcuts
            window.addEventListener('keydown', (e) => {
                if (e.code === 'Space') {
                    e.preventDefault();
                    isPaused = !isPaused;
                } else if (e.code === 'Digit1') {
                    loadPreset('calm');
                } else if (e.code === 'Digit2') {
                    loadPreset('full');
                } else if (e.code === 'Digit3') {
                    loadPreset('hypnotic');
                } else if (e.code === 'Digit4') {
                    loadPreset('single');
                }
            });

            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function loadPreset(preset) {
            switch(preset) {
                case 'calm':
                    rotXW = 0.5;
                    rotYW = 0.3;
                    rotZW = 0.7;
                    rotXY = 0;
                    rotXZ = 0;
                    rotYZ = 0;
                    rotationSpeed = 0.5;
                    autoRotate = true;
                    break;
                case 'full':
                    rotXW = 1.0;
                    rotYW = 1.0;
                    rotZW = 1.0;
                    rotXY = 0.5;
                    rotXZ = 0.5;
                    rotYZ = 0.5;
                    rotationSpeed = 1.0;
                    autoRotate = true;
                    break;
                case 'hypnotic':
                    rotXW = 0;
                    rotYW = 0;
                    rotZW = 3.14;
                    rotXY = 0;
                    rotXZ = 0;
                    rotYZ = 0;
                    rotationSpeed = 2.0;
                    autoRotate = true;
                    break;
                case 'single':
                    rotXW = 1.57;
                    rotYW = 0;
                    rotZW = 0;
                    rotXY = 0;
                    rotXZ = 0;
                    rotYZ = 0;
                    rotationSpeed = 0.8;
                    autoRotate = true;
                    break;
            }

            updateSliderValues();
        }

        function updateSliderValues() {
            document.getElementById('rot-xw').value = rotXW;
            document.getElementById('xw-val').textContent = rotXW.toFixed(2);
            document.getElementById('rot-yw').value = rotYW;
            document.getElementById('yw-val').textContent = rotYW.toFixed(2);
            document.getElementById('rot-zw').value = rotZW;
            document.getElementById('zw-val').textContent = rotZW.toFixed(2);
            document.getElementById('rot-xy').value = rotXY;
            document.getElementById('xy-val').textContent = rotXY.toFixed(2);
            document.getElementById('rot-xz').value = rotXZ;
            document.getElementById('xz-val').textContent = rotXZ.toFixed(2);
            document.getElementById('rot-yz').value = rotYZ;
            document.getElementById('yz-val').textContent = rotYZ.toFixed(2);
            document.getElementById('rotation-speed').value = rotationSpeed;
            document.getElementById('speed-val').textContent = rotationSpeed.toFixed(1);
            document.getElementById('auto-rotate').checked = autoRotate;
        }

        function saveSettings() {
            const settings = {
                rotXW, rotYW, rotZW, rotXY, rotXZ, rotYZ,
                rotationSpeed, autoRotate, projectionDistance,
                vertexSize, renderMode, cameraAngleX, cameraAngleY, cameraDistance
            };
            localStorage.setItem('tesseract-settings', JSON.stringify(settings));
            alert('Settings saved!');
        }

        function loadSettings() {
            const saved = localStorage.getItem('tesseract-settings');
            if (saved) {
                try {
                    const settings = JSON.parse(saved);
                    rotXW = settings.rotXW || 0.5;
                    rotYW = settings.rotYW || 0.3;
                    rotZW = settings.rotZW || 0.7;
                    rotXY = settings.rotXY || 0;
                    rotXZ = settings.rotXZ || 0;
                    rotYZ = settings.rotYZ || 0;
                    rotationSpeed = settings.rotationSpeed || 1.0;
                    autoRotate = settings.autoRotate !== undefined ? settings.autoRotate : true;
                    projectionDistance = settings.projectionDistance || 3.0;
                    vertexSize = settings.vertexSize || 0.08;
                    renderMode = settings.renderMode || 'full';
                    cameraAngleX = settings.cameraAngleX || 0.3;
                    cameraAngleY = settings.cameraAngleY || 0.3;
                    cameraDistance = settings.cameraDistance || 8;

                    updateSliderValues();
                    document.getElementById('proj-dist').value = projectionDistance;
                    document.getElementById('proj-val').textContent = projectionDistance.toFixed(1);
                    document.getElementById('vertex-size').value = vertexSize;
                    document.getElementById('vsize-val').textContent = vertexSize.toFixed(2);

                    document.querySelectorAll('.mode-btn').forEach(btn => {
                        btn.classList.toggle('active', btn.dataset.mode === renderMode);
                    });

                    createVertexMeshes();
                    createEdgeLines();
                    updateCameraPosition();
                } catch (e) {
                    console.error('Failed to load settings:', e);
                }
            }
        }

        function resetSettings() {
            localStorage.removeItem('tesseract-settings');
            loadPreset('calm');
            projectionDistance = 3.0;
            vertexSize = 0.08;
            renderMode = 'full';
            cameraAngleX = 0.3;
            cameraAngleY = 0.3;
            cameraDistance = 8;

            document.getElementById('proj-dist').value = projectionDistance;
            document.getElementById('proj-val').textContent = projectionDistance.toFixed(1);
            document.getElementById('vertex-size').value = vertexSize;
            document.getElementById('vsize-val').textContent = vertexSize.toFixed(2);

            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === 'full');
            });

            createVertexMeshes();
            createEdgeLines();
            updateCameraPosition();
        }

        // Initialize on load
        init();
    </script>
</body>
</html>
