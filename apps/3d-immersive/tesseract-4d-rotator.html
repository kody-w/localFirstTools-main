<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Interactive 4D Tesseract (Hypercube) visualizer. Rotate a 4-dimensional object on the W-axis and project it into 3D space.">
    <!-- 3d, math, 4d, tesseract, geometry, visualization, threejs, physics -->
    <title>4D Tesseract Rotator</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #00ffcc;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 20, 20, 0.8);
            border: 1px solid #00ffcc;
            padding: 20px;
            border-radius: 8px;
            pointer-events: none;
            max-width: 300px;
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.2);
        }
        #ui > * {
            pointer-events: auto;
        }
        h1 {
            font-size: 1.2rem;
            margin: 0 0 15px 0;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 5px #00ffcc;
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            margin-bottom: 5px;
            color: #aaffee;
        }
        input[type="range"] {
            width: 100%;
            accent-color: #00ffcc;
            background: rgba(0, 255, 204, 0.2);
        }
        .value-display {
            font-family: monospace;
        }
        .explanation {
            font-size: 0.8rem;
            color: #88ccbb;
            margin-top: 15px;
            line-height: 1.4;
            border-top: 1px solid #004433;
            padding-top: 10px;
        }
        button {
            background: transparent;
            border: 1px solid #00ffcc;
            color: #00ffcc;
            padding: 8px 16px;
            cursor: pointer;
            font-family: inherit;
            text-transform: uppercase;
            font-size: 0.8rem;
            transition: all 0.2s;
            width: 100%;
            margin-top: 5px;
        }
        button:hover {
            background: rgba(0, 255, 204, 0.2);
            box-shadow: 0 0 10px rgba(0, 255, 204, 0.4);
        }
        button.active {
            background: #00ffcc;
            color: #000;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="ui">
        <h1>4D Tesseract</h1>
        
        <div class="control-group">
            <label><span>XW Rotation (Inside/Out)</span> <span id="val-xw" class="value-display">0.00</span></label>
            <input type="range" id="rot-xw" min="0" max="6.28" step="0.01" value="0">
            <button id="anim-xw" class="active">Animate</button>
        </div>

        <div class="control-group">
            <label><span>YW Rotation</span> <span id="val-yw" class="value-display">0.00</span></label>
            <input type="range" id="rot-yw" min="0" max="6.28" step="0.01" value="0">
            <button id="anim-yw">Animate</button>
        </div>

        <div class="control-group">
            <label><span>ZW Rotation</span> <span id="val-zw" class="value-display">0.00</span></label>
            <input type="range" id="rot-zw" min="0" max="6.28" step="0.01" value="0">
            <button id="anim-zw">Animate</button>
        </div>

        <div class="control-group">
            <label><span>4D Distance (Perspective)</span> <span id="val-dist" class="value-display">3.0</span></label>
            <input type="range" id="dist-4d" min="1.5" max="5" step="0.1" value="3.0">
        </div>

        <div class="explanation">
            <p>You are viewing a 3D shadow of a 4D Hypercube.</p>
            <p>Rotation on the W-axis creates the illusion of the object turning "inside out" as 4D points move through our 3D slice of reality.</p>
        </div>
    </div>

    <!-- Import Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- 4D Math Setup ---
        
        // A point in 4D space
        class Point4D {
            constructor(x, y, z, w) {
                this.x = x;
                this.y = y;
                this.z = z;
                this.w = w;
            }
        }

        // Generate vertices of a Tesseract
        // 16 vertices: (+-1, +-1, +-1, +-1)
        const vertices4D = [];
        for (let i = 0; i < 16; i++) {
            const x = (i & 1) ? 1 : -1;
            const y = (i & 2) ? 1 : -1;
            const z = (i & 4) ? 1 : -1;
            const w = (i & 8) ? 1 : -1;
            vertices4D.push(new Point4D(x, y, z, w));
        }

        // Generate edges
        // Connect vertices that differ by exactly 1 coordinate
        const edges = [];
        for (let i = 0; i < 16; i++) {
            for (let j = i + 1; j < 16; j++) {
                let diff = 0;
                const v1 = vertices4D[i];
                const v2 = vertices4D[j];
                if (v1.x !== v2.x) diff++;
                if (v1.y !== v2.y) diff++;
                if (v1.z !== v2.z) diff++;
                if (v1.w !== v2.w) diff++;
                
                if (diff === 1) {
                    edges.push([i, j]);
                }
            }
        }

        // Matrix Multiplication Helper
        function matMul(v, m) {
            const x = v.x * m[0][0] + v.y * m[1][0] + v.z * m[2][0] + v.w * m[3][0];
            const y = v.x * m[0][1] + v.y * m[1][1] + v.z * m[2][1] + v.w * m[3][1];
            const z = v.x * m[0][2] + v.y * m[1][2] + v.z * m[2][2] + v.w * m[3][2];
            const w = v.x * m[0][3] + v.y * m[1][3] + v.z * m[2][3] + v.w * m[3][3];
            return new Point4D(x, y, z, w);
        }

        // --- Three.js Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        scene.fog = new THREE.FogExp2(0x050505, 0.05);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 6);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Post-processing (Bloom)
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0;
        bloomPass.strength = 2.0;
        bloomPass.radius = 0.5;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- Geometry Construction ---
        
        // We will use LineSegments for the edges
        // 32 edges * 2 vertices per edge = 64 points
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(edges.length * 2 * 3); // 3 coords per point
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const material = new THREE.LineBasicMaterial({ 
            color: 0x00ffcc,
            linewidth: 2,
            transparent: true,
            opacity: 0.8
        });

        const tesseractMesh = new THREE.LineSegments(geometry, material);
        scene.add(tesseractMesh);

        // Add vertices as glowing spheres
        const sphereGeo = new THREE.SphereGeometry(0.08, 16, 16);
        const sphereMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const spheres = [];
        
        for(let i=0; i<16; i++) {
            const mesh = new THREE.Mesh(sphereGeo, sphereMat);
            scene.add(mesh);
            spheres.push(mesh);
        }

        // Inner cube visualizer (optional, connects center to vertices)
        // Let's keep it clean with just edges for now.

        // --- Animation State ---
        const state = {
            angleXW: 0,
            angleYW: 0,
            angleZW: 0,
            animXW: true,
            animYW: false,
            animZW: false,
            distance4D: 3.0
        };

        // --- UI Handlers ---
        function setupUI() {
            const bind = (id, key) => {
                const el = document.getElementById(id);
                const valEl = document.getElementById('val-' + id.split('-')[1]);
                
                el.addEventListener('input', (e) => {
                    state[key] = parseFloat(e.target.value);
                    if(valEl) valEl.textContent = state[key].toFixed(2);
                    // Stop animation if user interacts manually
                    const animKey = 'anim' + key.substring(5); // angleXW -> animXW
                    if(state[animKey]) {
                        state[animKey] = false;
                        document.getElementById('anim-' + id.split('-')[1]).classList.remove('active');
                    }
                });
            };

            bind('rot-xw', 'angleXW');
            bind('rot-yw', 'angleYW');
            bind('rot-zw', 'angleZW');
            
            document.getElementById('dist-4d').addEventListener('input', (e) => {
                state.distance4D = parseFloat(e.target.value);
                document.getElementById('val-dist').textContent = state.distance4D.toFixed(1);
            });

            const bindAnim = (id, key) => {
                const btn = document.getElementById(id);
                btn.addEventListener('click', () => {
                    state[key] = !state[key];
                    btn.classList.toggle('active', state[key]);
                });
            };

            bindAnim('anim-xw', 'animXW');
            bindAnim('anim-yw', 'animYW');
            bindAnim('anim-zw', 'animZW');
        }

        setupUI();

        // --- Main Loop ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // Update angles if animating
            const speed = 0.01;
            if(state.animXW) {
                state.angleXW = (state.angleXW + speed) % (Math.PI * 2);
                document.getElementById('rot-xw').value = state.angleXW;
                document.getElementById('val-xw').textContent = state.angleXW.toFixed(2);
            }
            if(state.animYW) {
                state.angleYW = (state.angleYW + speed) % (Math.PI * 2);
                document.getElementById('rot-yw').value = state.angleYW;
                document.getElementById('val-yw').textContent = state.angleYW.toFixed(2);
            }
            if(state.animZW) {
                state.angleZW = (state.angleZW + speed) % (Math.PI * 2);
                document.getElementById('rot-zw').value = state.angleZW;
                document.getElementById('val-zw').textContent = state.angleZW.toFixed(2);
            }

            // 1. Calculate Rotation Matrices
            const axw = state.angleXW;
            const ayw = state.angleYW;
            const azw = state.angleZW;

            // Rotation XW
            // [ cos  0  0 -sin ]
            // [  0   1  0   0  ]
            // [  0   0  1   0  ]
            // [ sin  0  0  cos ]
            const rotXW = [
                [Math.cos(axw), 0, 0, -Math.sin(axw)],
                [0, 1, 0, 0],
                [0, 0, 1, 0],
                [Math.sin(axw), 0, 0, Math.cos(axw)]
            ];

            // Rotation YW
            const rotYW = [
                [1, 0, 0, 0],
                [0, Math.cos(ayw), 0, -Math.sin(ayw)],
                [0, 0, 1, 0],
                [0, Math.sin(ayw), 0, Math.cos(ayw)]
            ];

            // Rotation ZW
            const rotZW = [
                [1, 0, 0, 0],
                [0, 1, 0, 0],
                [0, 0, Math.cos(azw), -Math.sin(azw)],
                [0, 0, Math.sin(azw), Math.cos(azw)]
            ];

            // 2. Transform Vertices
            const projected3D = [];

            for (let v of vertices4D) {
                let p = v;
                
                // Apply rotations
                p = matMul(p, rotXW);
                p = matMul(p, rotYW);
                p = matMul(p, rotZW);

                // 3. Project 4D to 3D
                // Stereographic projection: w is the 4th dimension depth
                // distance is how far the "camera" is from the 4D object in W-space
                let w = 1 / (state.distance4D - p.w);
                
                const p3 = new THREE.Vector3(
                    p.x * w,
                    p.y * w,
                    p.z * w
                );
                
                // Scale up a bit for visibility
                p3.multiplyScalar(2);
                
                projected3D.push(p3);
            }

            // 4. Update Geometry
            const posAttr = geometry.attributes.position;
            let idx = 0;

            // Update lines
            for (let edge of edges) {
                const v1 = projected3D[edge[0]];
                const v2 = projected3D[edge[1]];

                posAttr.setXYZ(idx++, v1.x, v1.y, v1.z);
                posAttr.setXYZ(idx++, v2.x, v2.y, v2.z);
            }
            posAttr.needsUpdate = true;

            // Update spheres
            for(let i=0; i<16; i++) {
                spheres[i].position.copy(projected3D[i]);
                
                // Scale spheres based on W (depth) to enhance 4D effect
                // We can approximate W depth by distance from center in 3D after projection
                // Or better, use the original W before projection?
                // Let's use the projected scale factor 'w' we calculated earlier implicitly
                // Actually, let's just use distance from camera for simple depth cue
                const dist = spheres[i].position.distanceTo(camera.position);
                const scale = Math.max(0.05, 0.5 / dist);
                spheres[i].scale.setScalar(scale * 5);
            }

            // Rotate the whole 3D object slowly for better viewing
            tesseractMesh.rotation.y += 0.002;
            tesseractMesh.rotation.x += 0.001;
            
            // Rotate spheres group too? No, they are separate.
            // We need to apply the same rotation to spheres or put them in a group
            // Let's put them in a group
            // Actually, we are setting absolute positions from projection, so we shouldn't rotate the mesh container
            // unless we want double rotation.
            // Wait, the projection gives absolute 3D coordinates.
            // If we rotate tesseractMesh, the lines rotate.
            // But the spheres are set to absolute positions.
            // FIX: Add spheres to tesseractMesh or a common group.
        }
        
        // Fix for rotation sync
        const mainGroup = new THREE.Group();
        scene.add(mainGroup);
        mainGroup.add(tesseractMesh);
        spheres.forEach(s => {
            scene.remove(s); // Remove from scene root
            mainGroup.add(s); // Add to group
        });

        // Override animate to rotate group
        const _animate = animate;
        animate = function() {
            requestAnimationFrame(animate);
            controls.update();
            
            // ... (math logic same as above) ...
            // Copy-paste logic or refactor? 
            // Let's just rewrite the loop body here to be safe and clean.
            
             // Update angles if animating
            const speed = 0.01;
            if(state.animXW) {
                state.angleXW = (state.angleXW + speed) % (Math.PI * 2);
                document.getElementById('rot-xw').value = state.angleXW;
                document.getElementById('val-xw').textContent = state.angleXW.toFixed(2);
            }
            if(state.animYW) {
                state.angleYW = (state.angleYW + speed) % (Math.PI * 2);
                document.getElementById('rot-yw').value = state.angleYW;
                document.getElementById('val-yw').textContent = state.angleYW.toFixed(2);
            }
            if(state.animZW) {
                state.angleZW = (state.angleZW + speed) % (Math.PI * 2);
                document.getElementById('rot-zw').value = state.angleZW;
                document.getElementById('val-zw').textContent = state.angleZW.toFixed(2);
            }

            const axw = state.angleXW;
            const ayw = state.angleYW;
            const azw = state.angleZW;

            const rotXW = [
                [Math.cos(axw), 0, 0, -Math.sin(axw)],
                [0, 1, 0, 0],
                [0, 0, 1, 0],
                [Math.sin(axw), 0, 0, Math.cos(axw)]
            ];

            const rotYW = [
                [1, 0, 0, 0],
                [0, Math.cos(ayw), 0, -Math.sin(ayw)],
                [0, 0, 1, 0],
                [0, Math.sin(ayw), 0, Math.cos(ayw)]
            ];

            const rotZW = [
                [1, 0, 0, 0],
                [0, 1, 0, 0],
                [0, 0, Math.cos(azw), -Math.sin(azw)],
                [0, 0, Math.sin(azw), Math.cos(azw)]
            ];

            const projected3D = [];

            for (let v of vertices4D) {
                let p = v;
                p = matMul(p, rotXW);
                p = matMul(p, rotYW);
                p = matMul(p, rotZW);

                let w = 1 / (state.distance4D - p.w);
                const p3 = new THREE.Vector3(p.x * w, p.y * w, p.z * w);
                p3.multiplyScalar(2);
                projected3D.push(p3);
            }

            const posAttr = geometry.attributes.position;
            let idx = 0;
            for (let edge of edges) {
                const v1 = projected3D[edge[0]];
                const v2 = projected3D[edge[1]];
                posAttr.setXYZ(idx++, v1.x, v1.y, v1.z);
                posAttr.setXYZ(idx++, v2.x, v2.y, v2.z);
            }
            posAttr.needsUpdate = true;

            for(let i=0; i<16; i++) {
                spheres[i].position.copy(projected3D[i]);
                // Simple depth scaling
                // We can use the 'w' value from projection for size?
                // Let's recalculate w for size
                // Or just use distance from center (0,0,0)
                // The closer to center, the "further away" in 4D it might be?
                // Actually, in stereographic projection, things in center are further away in W.
                // Let's just keep constant size for now, or slight pulse.
                spheres[i].scale.setScalar(1);
            }

            mainGroup.rotation.y += 0.005;
            mainGroup.rotation.x += 0.002;

            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>