<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Academy 3D // Learn to Play</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a2e; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            max-width: 300px;
            border-left: 5px solid #4ecca3;
            backdrop-filter: blur(5px);
            user-select: none;
        }
        h1 { margin: 0 0 10px 0; font-size: 1.5rem; color: #4ecca3; }
        p { margin: 0 0 15px 0; line-height: 1.5; font-size: 0.95rem; }
        .btn {
            background: #4ecca3;
            color: #1a1a2e;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.1s;
            display: inline-block;
            margin-right: 10px;
        }
        .btn:hover { transform: scale(1.05); background: #45b08c; }
        .btn-secondary { background: #333; color: #ccc; }
        .btn-secondary:hover { background: #444; }
        
        #piece-label {
            position: absolute;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            pointer-events: none;
            display: none;
            font-size: 0.8rem;
            transform: translate(-50%, -150%);
        }

        #progress-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 5px;
            background: #333;
        }
        #progress-fill {
            height: 100%;
            background: #4ecca3;
            width: 0%;
            transition: width 0.5s;
        }
    </style>
    <!-- Import Three.js from CDN (No local build step required) -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="info-panel">
        <h1 id="lesson-title">Welcome to Chess</h1>
        <p id="lesson-text">Chess is a game of strategy played on an 8x8 grid. Your goal is to trap the enemy King. Let's start by learning how the pieces move.</p>
        <button id="next-btn" class="btn">Start Lesson</button>
    </div>
    <div id="piece-label">Pawn</div>
    <div id="progress-bar"><div id="progress-fill"></div></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Game State & Lessons ---
        const lessons = [
            {
                title: "The Board",
                text: "The board has 64 squares. Light squares and dark squares. We always set it up so the bottom-right square is Light (White). Try rotating the camera to see the board.",
                setup: "empty",
                action: "rotate"
            },
            {
                title: "The Pawn",
                text: "This is a Pawn. It's the foot soldier. Pawns move FORWARD one square at a time. But on their very first move, they can jump TWO squares forward. Click the highlighted Pawn to move it.",
                setup: "pawn_demo",
                highlight: {x: 4, y: 1}, // e2
                validMoves: [{x: 4, y: 2}, {x: 4, y: 3}]
            },
            {
                title: "Pawn Capturing",
                text: "Pawns are unique! They move forward, but they CAPTURE diagonally. There is an enemy pawn ahead. Capture it by moving diagonally!",
                setup: "pawn_capture",
                highlight: {x: 4, y: 3}, // e4
                validMoves: [{x: 3, y: 4}] // Capture d5
            },
            {
                title: "The Rook",
                text: "The Rook looks like a castle tower. It moves in straight lines: forward, backward, left, or right, as far as it wants. Move the Rook to the highlighted square.",
                setup: "rook_demo",
                highlight: {x: 3, y: 3}, // d4
                validMoves: [{x: 3, y: 7}, {x: 7, y: 3}, {x: 0, y: 3}] // Just some examples
            },
            {
                title: "The Bishop",
                text: "The Bishop moves diagonally. It stays on its own color forever! A light-square bishop can never move to a dark square. Try moving this Bishop.",
                setup: "bishop_demo",
                highlight: {x: 2, y: 0}, // c1
                validMoves: [{x: 5, y: 3}, {x: 0, y: 2}]
            },
            {
                title: "The Knight",
                text: "The Knight is tricky! It moves in an 'L' shape: 2 squares one way, then 1 square to the side. It is the ONLY piece that can jump over others. Hop the Knight over the pawns!",
                setup: "knight_demo",
                highlight: {x: 1, y: 0}, // b1
                validMoves: [{x: 2, y: 2}, {x: 0, y: 2}]
            },
            {
                title: "The Queen",
                text: "The Queen is the most powerful piece! She combines the Rook and Bishop. She can move straight OR diagonally, as far as she wants. She rules the board.",
                setup: "queen_demo",
                highlight: {x: 3, y: 0}, // d1
                validMoves: [{x: 3, y: 7}, {x: 7, y: 4}, {x: 0, y: 3}]
            },
            {
                title: "The King",
                text: "The King is the most important piece. If he is trapped (Checkmate), you lose. He can move one square in any direction. Keep him safe!",
                setup: "king_demo",
                highlight: {x: 4, y: 0}, // e1
                validMoves: [{x: 4, y: 1}, {x: 5, y: 1}, {x: 3, y: 1}]
            },
            {
                title: "Ready to Play",
                text: "You've learned all the pieces! Remember: White moves first. Good luck!",
                setup: "full_board",
                action: "freeplay"
            }
        ];

        let currentLesson = 0;
        let selectedPiece = null;
        let pieces = []; // Array of piece objects {mesh, type, color, x, y}
        let highlights = []; // Array of highlight meshes

        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);
        scene.fog = new THREE.Fog(0x1a1a2e, 10, 50);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 10, 10);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.maxPolarAngle = Math.PI / 2 - 0.1; // Don't go below board
        controls.minDistance = 5;
        controls.maxDistance = 20;

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 5);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // --- Board Generation ---
        const boardGroup = new THREE.Group();
        const squareSize = 1;
        const boardOffset = (squareSize * 8) / 2 - squareSize / 2;

        function createBoard() {
            const geometry = new THREE.BoxGeometry(squareSize, 0.2, squareSize);
            const whiteMat = new THREE.MeshStandardMaterial({ color: 0xe0e0e0, roughness: 0.2 });
            const blackMat = new THREE.MeshStandardMaterial({ color: 0x4a4e69, roughness: 0.2 });

            for (let x = 0; x < 8; x++) {
                for (let y = 0; y < 8; y++) {
                    const isWhite = (x + y) % 2 !== 0; // Chess board coloring
                    const square = new THREE.Mesh(geometry, isWhite ? whiteMat : blackMat);
                    square.position.set(x * squareSize - boardOffset, -0.1, y * squareSize - boardOffset);
                    square.receiveShadow = true;
                    square.userData = { isSquare: true, gridX: x, gridY: y }; // Store grid coords (0-7)
                    boardGroup.add(square);
                    
                    // Add coordinate labels (optional, maybe for advanced mode)
                }
            }
            
            // Board Border
            const borderGeo = new THREE.BoxGeometry(9, 0.2, 9);
            const borderMat = new THREE.MeshStandardMaterial({ color: 0x222233 });
            const border = new THREE.Mesh(borderGeo, borderMat);
            border.position.y = -0.2;
            border.receiveShadow = true;
            boardGroup.add(border);

            scene.add(boardGroup);
        }

        createBoard();

        // --- Piece Generation (Procedural Geometry) ---
        // Using simple geometries to represent pieces to avoid external asset loading
        
        function createPieceGeometry(type) {
            const group = new THREE.Group();
            let geo, mesh;
            const material = new THREE.MeshStandardMaterial({ color: 0xffffff }); // Placeholder

            // Base for all pieces
            const baseGeo = new THREE.CylinderGeometry(0.35, 0.4, 0.1, 32);
            const base = new THREE.Mesh(baseGeo, material);
            base.position.y = 0.05;
            group.add(base);

            switch (type) {
                case 'pawn':
                    geo = new THREE.SphereGeometry(0.25, 32, 32);
                    mesh = new THREE.Mesh(geo, material);
                    mesh.position.y = 0.4;
                    group.add(mesh);
                    // Body
                    const pBody = new THREE.CylinderGeometry(0.15, 0.25, 0.4, 16);
                    const pBodyMesh = new THREE.Mesh(pBody, material);
                    pBodyMesh.position.y = 0.25;
                    group.add(pBodyMesh);
                    break;
                case 'rook':
                    geo = new THREE.CylinderGeometry(0.3, 0.3, 0.6, 8);
                    mesh = new THREE.Mesh(geo, material);
                    mesh.position.y = 0.4;
                    group.add(mesh);
                    // Battlements
                    const battlement = new THREE.CylinderGeometry(0.35, 0.3, 0.2, 4);
                    const bMesh = new THREE.Mesh(battlement, material);
                    bMesh.position.y = 0.7;
                    group.add(bMesh);
                    break;
                case 'knight':
                    // Abstract horse head
                    const kBody = new THREE.CylinderGeometry(0.2, 0.3, 0.5, 16);
                    const kMesh = new THREE.Mesh(kBody, material);
                    kMesh.position.y = 0.35;
                    group.add(kMesh);
                    
                    const headGeo = new THREE.BoxGeometry(0.2, 0.3, 0.4);
                    const head = new THREE.Mesh(headGeo, material);
                    head.position.set(0, 0.7, -0.1);
                    head.rotation.x = Math.PI / 4;
                    group.add(head);
                    break;
                case 'bishop':
                    const bBody = new THREE.CylinderGeometry(0.15, 0.3, 0.6, 16);
                    const bBodyMesh = new THREE.Mesh(bBody, material);
                    bBodyMesh.position.y = 0.4;
                    group.add(bBodyMesh);
                    
                    const hat = new THREE.SphereGeometry(0.2, 16, 16);
                    const hatMesh = new THREE.Mesh(hat, material);
                    hatMesh.position.y = 0.8;
                    hatMesh.scale.y = 1.5;
                    group.add(hatMesh);
                    break;
                case 'queen':
                    const qBody = new THREE.CylinderGeometry(0.2, 0.35, 0.8, 16);
                    const qMesh = new THREE.Mesh(qBody, material);
                    qMesh.position.y = 0.5;
                    group.add(qMesh);
                    
                    const crown = new THREE.SphereGeometry(0.25, 16, 16);
                    const cMesh = new THREE.Mesh(crown, material);
                    cMesh.position.y = 1.0;
                    group.add(cMesh);
                    
                    const tinyBall = new THREE.SphereGeometry(0.1, 8, 8);
                    const tbMesh = new THREE.Mesh(tinyBall, material);
                    tbMesh.position.y = 1.25;
                    group.add(tbMesh);
                    break;
                case 'king':
                    const kBody2 = new THREE.CylinderGeometry(0.25, 0.35, 0.9, 16);
                    const kMesh2 = new THREE.Mesh(kBody2, material);
                    kMesh2.position.y = 0.55;
                    group.add(kMesh2);
                    
                    const crossV = new THREE.BoxGeometry(0.1, 0.3, 0.1);
                    const cvMesh = new THREE.Mesh(crossV, material);
                    cvMesh.position.y = 1.15;
                    group.add(cvMesh);
                    
                    const crossH = new THREE.BoxGeometry(0.3, 0.1, 0.1);
                    const chMesh = new THREE.Mesh(crossH, material);
                    chMesh.position.y = 1.15;
                    group.add(chMesh);
                    break;
            }
            
            // Merge geometries for performance (optional, keeping separate for simplicity of color assignment)
            return group;
        }

        function spawnPiece(type, color, gridX, gridY) {
            const pieceGroup = createPieceGeometry(type);
            
            // Apply Material
            const colorHex = color === 'white' ? 0xffffff : 0x222222;
            const emissive = color === 'white' ? 0x222222 : 0x000000;
            
            pieceGroup.traverse((child) => {
                if (child.isMesh) {
                    child.material = new THREE.MeshStandardMaterial({
                        color: colorHex,
                        roughness: 0.1,
                        metalness: 0.3,
                        emissive: emissive,
                        emissiveIntensity: 0.2
                    });
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            // Position
            // Grid 0,0 is bottom-left (a1)
            // Scene 0,0 is center
            // x: 0 -> -3.5, 7 -> 3.5
            const worldX = gridX * squareSize - boardOffset;
            const worldZ = (7 - gridY) * squareSize - boardOffset; // Flip Z so y=0 is bottom (rank 1)
            
            pieceGroup.position.set(worldX, 0, worldZ);
            pieceGroup.userData = { type, color, gridX, gridY, isPiece: true };
            
            scene.add(pieceGroup);
            pieces.push(pieceGroup);
            return pieceGroup;
        }

        function clearPieces() {
            pieces.forEach(p => scene.remove(p));
            pieces = [];
            clearHighlights();
        }

        function clearHighlights() {
            highlights.forEach(h => scene.remove(h));
            highlights = [];
        }

        function highlightSquare(gridX, gridY, color = 0x4ecca3) {
            const geometry = new THREE.PlaneGeometry(0.8, 0.8);
            const material = new THREE.MeshBasicMaterial({ 
                color: color, 
                transparent: true, 
                opacity: 0.5,
                side: THREE.DoubleSide
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.rotation.x = -Math.PI / 2;
            
            const worldX = gridX * squareSize - boardOffset;
            const worldZ = (7 - gridY) * squareSize - boardOffset;
            
            mesh.position.set(worldX, 0.01, worldZ);
            scene.add(mesh);
            highlights.push(mesh);
            
            // Animate highlight
            const animate = () => {
                if (!highlights.includes(mesh)) return;
                mesh.material.opacity = 0.3 + Math.sin(Date.now() * 0.005) * 0.2;
                requestAnimationFrame(animate);
            };
            animate();
        }

        // --- Interaction ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const label = document.getElementById('piece-label');

        window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Label positioning
            label.style.left = event.clientX + 'px';
            label.style.top = event.clientY + 'px';
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(pieces, true); // Recursive for groups
            
            if (intersects.length > 0) {
                // Find the root group of the piece
                let obj = intersects[0].object;
                while(obj.parent && !obj.userData.isPiece) {
                    obj = obj.parent;
                }
                
                if (obj.userData.isPiece) {
                    label.style.display = 'block';
                    label.textContent = `${obj.userData.color.toUpperCase()} ${obj.userData.type.toUpperCase()}`;
                    document.body.style.cursor = 'pointer';
                }
            } else {
                label.style.display = 'none';
                document.body.style.cursor = 'default';
            }
        });

        window.addEventListener('click', (event) => {
            if (currentLesson >= lessons.length) return; // End of lessons

            // Visual feedback for click
            const clickFeedback = document.createElement('div');
            clickFeedback.style.position = 'absolute';
            clickFeedback.style.left = (event.clientX - 10) + 'px';
            clickFeedback.style.top = (event.clientY - 10) + 'px';
            clickFeedback.style.width = '20px';
            clickFeedback.style.height = '20px';
            clickFeedback.style.border = '2px solid #4ecca3';
            clickFeedback.style.borderRadius = '50%';
            clickFeedback.style.pointerEvents = 'none';
            clickFeedback.style.animation = 'ping 0.5s ease-out forwards';
            document.body.appendChild(clickFeedback);
            
            // Add keyframes if not exists
            if (!document.getElementById('ping-style')) {
                const style = document.createElement('style');
                style.id = 'ping-style';
                style.textContent = `
                    @keyframes ping {
                        0% { transform: scale(0.5); opacity: 1; }
                        100% { transform: scale(2); opacity: 0; }
                    }
                `;
                document.head.appendChild(style);
            }
            
            setTimeout(() => clickFeedback.remove(), 500);

            raycaster.setFromCamera(mouse, camera);
            
            // Check for piece selection
            const pieceIntersects = raycaster.intersectObjects(pieces, true);
            let clickedPiece = null;
            
            if (pieceIntersects.length > 0) {
                let obj = pieceIntersects[0].object;
                while(obj.parent && !obj.userData.isPiece) {
                    obj = obj.parent;
                }
                clickedPiece = obj;
            }

            // Check for square selection (movement)
            const boardIntersects = raycaster.intersectObjects(boardGroup.children);
            let clickedSquare = null;
            if (boardIntersects.length > 0) {
                // Ensure we are clicking a square, not the border
                if (boardIntersects[0].object.userData.isSquare) {
                    clickedSquare = boardIntersects[0].object;
                }
            }

            // If we clicked a piece, but it's also a valid move target (capture), handle it as a move
            if (clickedPiece && selectedPiece && clickedPiece !== selectedPiece) {
                 const targetX = clickedPiece.userData.gridX;
                 const targetY = clickedPiece.userData.gridY;
                 const lesson = lessons[currentLesson];
                 
                 if (lesson.validMoves && lesson.validMoves.some(m => m.x === targetX && m.y === targetY)) {
                     // It's a capture! Treat the piece's square as the target
                     // Find the square under the piece
                     const square = boardGroup.children.find(c => c.userData.gridX === targetX && c.userData.gridY === targetY);
                     if (square) {
                         handleInteraction(null, square); // Pass null for piece so it treats it as a move to square
                         return;
                     }
                 }
            }

            handleInteraction(clickedPiece, clickedSquare);
        });

        function handleInteraction(piece, square) {
            const lesson = lessons[currentLesson];
            
            // If we are in a "move" lesson
            if (lesson.highlight && lesson.validMoves) {
                
                // 1. Select the correct piece
                // Allow re-selecting the piece if already selected
                if (piece && 
                    piece.userData.gridX === lesson.highlight.x && 
                    piece.userData.gridY === lesson.highlight.y) {
                    
                    selectedPiece = piece;
                    clearHighlights();
                    highlightSquare(piece.userData.gridX, piece.userData.gridY, 0xffff00); // Highlight selected
                    
                    // Highlight valid moves
                    lesson.validMoves.forEach(move => {
                        highlightSquare(move.x, move.y, 0x00ff00);
                    });
                    // Don't return here, allow fallthrough to check if we clicked the square UNDER the piece (unlikely but safe)
                    // Actually, we should return to prevent "moving to self" logic issues
                    return;
                }

                // 2. Move to a valid square
                if (selectedPiece && square && square.userData.isSquare) {
                    const targetX = square.userData.gridX;
                    const targetY = square.userData.gridY;
                    
                    const isValid = lesson.validMoves.some(m => m.x === targetX && m.y === targetY);
                    
                    if (isValid) {
                        movePiece(selectedPiece, targetX, targetY);
                        selectedPiece = null;
                        
                        // Success!
                        setTimeout(() => {
                            nextLesson();
                        }, 1000);
                    }
                }
            }
        }

        function movePiece(piece, gridX, gridY) {
            // Check for capture
            const captured = pieces.find(p => p.userData.gridX === gridX && p.userData.gridY === gridY && p !== piece);
            if (captured) {
                scene.remove(captured);
                pieces = pieces.filter(p => p !== captured);
                // Particle effect could go here
            }

            // Animate movement
            const startPos = piece.position.clone();
            const worldX = gridX * squareSize - boardOffset;
            const worldZ = (7 - gridY) * squareSize - boardOffset;
            const targetPos = new THREE.Vector3(worldX, 0, worldZ);
            
            // Simple lerp animation
            let alpha = 0;
            const animateMove = () => {
                alpha += 0.05;
                if (alpha > 1) alpha = 1;
                
                piece.position.lerpVectors(startPos, targetPos, alpha);
                // Add a little hop
                piece.position.y = Math.sin(alpha * Math.PI) * 0.5;
                
                if (alpha < 1) {
                    requestAnimationFrame(animateMove);
                } else {
                    piece.position.y = 0;
                    piece.userData.gridX = gridX;
                    piece.userData.gridY = gridY;
                }
            };
            animateMove();
        }

        // --- Lesson Management ---
        const titleEl = document.getElementById('lesson-title');
        const textEl = document.getElementById('lesson-text');
        const nextBtn = document.getElementById('next-btn');
        const progressBar = document.getElementById('progress-fill');

        function loadLesson(index) {
            if (index >= lessons.length) return;
            
            const lesson = lessons[index];
            titleEl.textContent = lesson.title;
            textEl.textContent = lesson.text;
            
            // Update progress
            const pct = ((index) / (lessons.length - 1)) * 100;
            progressBar.style.width = `${pct}%`;

            clearPieces();
            selectedPiece = null;

            // Setup Board based on lesson
            if (lesson.setup === "pawn_demo") {
                spawnPiece('pawn', 'white', 4, 1); // e2
            } else if (lesson.setup === "pawn_capture") {
                spawnPiece('pawn', 'white', 4, 3); // e4
                spawnPiece('pawn', 'black', 3, 4); // d5
            } else if (lesson.setup === "rook_demo") {
                spawnPiece('rook', 'white', 3, 3);
            } else if (lesson.setup === "bishop_demo") {
                spawnPiece('bishop', 'white', 2, 0);
            } else if (lesson.setup === "knight_demo") {
                spawnPiece('knight', 'white', 1, 0);
                spawnPiece('pawn', 'white', 1, 1); // Blockers
                spawnPiece('pawn', 'white', 2, 1);
                spawnPiece('pawn', 'white', 0, 1);
            } else if (lesson.setup === "queen_demo") {
                spawnPiece('queen', 'white', 3, 0);
            } else if (lesson.setup === "king_demo") {
                spawnPiece('king', 'white', 4, 0);
            } else if (lesson.setup === "full_board") {
                setupFullBoard();
                nextBtn.style.display = 'none';
            }

            // Highlight piece to move
            if (lesson.highlight) {
                highlightSquare(lesson.highlight.x, lesson.highlight.y, 0x4ecca3);
                nextBtn.style.display = 'none'; // Hide button, require action
            } else {
                nextBtn.style.display = 'inline-block';
                nextBtn.textContent = index === 0 ? "Start Lesson" : "Next";
            }
        }

        function setupFullBoard() {
            const layout = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];
            
            for (let i = 0; i < 8; i++) {
                spawnPiece('pawn', 'white', i, 1);
                spawnPiece('pawn', 'black', i, 6);
                spawnPiece(layout[i], 'white', i, 0);
                spawnPiece(layout[i], 'black', i, 7);
            }
        }

        function nextLesson() {
            currentLesson++;
            if (currentLesson < lessons.length) {
                loadLesson(currentLesson);
            }
        }

        nextBtn.addEventListener('click', nextLesson);

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // Start
        animate();
        
        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>