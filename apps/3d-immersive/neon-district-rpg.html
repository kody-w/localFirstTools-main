<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon District - Cyberpunk RPG</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #0ff;
            overflow: hidden;
            touch-action: none;
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(180deg, #0a0015 0%, #1a0030 50%, #0a0020 100%);
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        .hud {
            position: fixed;
            pointer-events: none;
        }

        .hud > * {
            pointer-events: auto;
        }

        #topHUD {
            top: 20px;
            left: 20px;
            right: 20px;
        }

        .stat-bar {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #0ff;
            padding: 8px 12px;
            margin-bottom: 8px;
            border-radius: 4px;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .bar-container {
            width: 200px;
            height: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #0ff;
            margin-top: 5px;
            position: relative;
            overflow: hidden;
        }

        .bar-fill {
            height: 100%;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px currentColor;
        }

        .hp-bar { background: linear-gradient(90deg, #ff0080, #ff0040); }
        .energy-bar { background: linear-gradient(90deg, #00ffff, #0080ff); }
        .xp-bar { background: linear-gradient(90deg, #ff00ff, #8000ff); }

        .bar-text {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            text-align: center;
            line-height: 20px;
            font-size: 11px;
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 2px #000;
        }

        #minimap {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #0ff;
            border-radius: 4px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        #questTracker {
            position: fixed;
            top: 20px;
            right: 20px;
            max-width: 300px;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #ff00ff;
            padding: 12px;
            border-radius: 4px;
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
        }

        .quest-title {
            color: #ff00ff;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 8px;
            text-shadow: 0 0 5px #ff00ff;
        }

        .quest-objective {
            color: #0ff;
            font-size: 11px;
            margin-left: 10px;
            margin-bottom: 4px;
        }

        .quest-objective.complete {
            color: #0f0;
            text-decoration: line-through;
        }

        #notifications {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 1000;
        }

        .notification {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #0ff;
            padding: 20px 40px;
            margin-bottom: 10px;
            border-radius: 8px;
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            animation: notifSlide 3s ease-out forwards;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
        }

        @keyframes notifSlide {
            0% { opacity: 0; transform: translateY(-50px); }
            10% { opacity: 1; transform: translateY(0); }
            90% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(50px); }
        }

        .damage-number {
            position: fixed;
            font-size: 24px;
            font-weight: bold;
            color: #ff0040;
            text-shadow: 0 0 10px #ff0040, 2px 2px 4px #000;
            pointer-events: none;
            animation: floatUp 1s ease-out forwards;
        }

        .damage-number.crit {
            font-size: 32px;
            color: #ffff00;
            text-shadow: 0 0 15px #ffff00, 2px 2px 4px #000;
        }

        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-100px); }
        }

        .panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #0ff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.8);
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
            display: none;
            z-index: 500;
        }

        .panel.active {
            display: block;
        }

        .panel h2 {
            color: #ff00ff;
            margin-bottom: 20px;
            font-size: 28px;
            text-shadow: 0 0 10px #ff00ff;
            border-bottom: 2px solid #ff00ff;
            padding-bottom: 10px;
        }

        .panel h3 {
            color: #0ff;
            margin-top: 20px;
            margin-bottom: 10px;
            font-size: 18px;
        }

        .stat-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-item {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #0ff;
            padding: 12px;
            border-radius: 4px;
        }

        .stat-name {
            color: #0ff;
            font-size: 12px;
            margin-bottom: 5px;
        }

        .stat-value {
            color: #fff;
            font-size: 20px;
            font-weight: bold;
        }

        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }

        .inventory-slot {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #0ff;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 4px;
        }

        .inventory-slot:hover {
            background: rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.6);
        }

        .inventory-slot.empty {
            border-style: dashed;
            opacity: 0.4;
        }

        .item-name {
            color: #ff00ff;
            font-size: 12px;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .item-stats {
            color: #0ff;
            font-size: 10px;
        }

        .skill-tree {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }

        .skill-category {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #ff00ff;
            padding: 15px;
            border-radius: 4px;
        }

        .skill-item {
            background: rgba(255, 0, 255, 0.1);
            border: 1px solid #ff00ff;
            padding: 10px;
            margin-bottom: 10px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.3s ease;
        }

        .skill-item:hover {
            background: rgba(255, 0, 255, 0.3);
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.6);
        }

        .skill-item.locked {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .skill-item.unlocked {
            background: rgba(0, 255, 0, 0.2);
            border-color: #0f0;
        }

        .dialogue-box {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 800px;
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #ff00ff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.8);
            display: none;
            z-index: 600;
        }

        .dialogue-box.active {
            display: block;
        }

        .dialogue-speaker {
            color: #ff00ff;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 0 0 5px #ff00ff;
        }

        .dialogue-text {
            color: #0ff;
            font-size: 14px;
            margin-bottom: 15px;
            line-height: 1.6;
        }

        .dialogue-choices {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .dialogue-choice {
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid #0ff;
            padding: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 4px;
            color: #0ff;
        }

        .dialogue-choice:hover {
            background: rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.6);
        }

        .btn {
            background: rgba(0, 255, 255, 0.2);
            border: 2px solid #0ff;
            color: #0ff;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            border-radius: 4px;
        }

        .btn:hover {
            background: rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.8);
        }

        .controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            display: none;
        }

        .controls.mobile {
            display: flex;
            gap: 10px;
        }

        .joystick {
            width: 120px;
            height: 120px;
            background: rgba(0, 255, 255, 0.2);
            border: 3px solid #0ff;
            border-radius: 50%;
            position: relative;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        .joystick-knob {
            width: 50px;
            height: 50px;
            background: rgba(255, 0, 255, 0.6);
            border: 2px solid #ff00ff;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.8);
        }

        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
            position: fixed;
            bottom: 20px;
            right: 20px;
        }

        .action-btn {
            width: 60px;
            height: 60px;
            background: rgba(255, 0, 0, 0.3);
            border: 3px solid #f00;
            border-radius: 50%;
            font-size: 12px;
            font-weight: bold;
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.6);
            touch-action: none;
        }

        .letterbox {
            position: fixed;
            width: 100%;
            height: 10%;
            background: #000;
            left: 0;
            z-index: 400;
            transition: all 0.5s ease;
        }

        .letterbox.top {
            top: -10%;
        }

        .letterbox.bottom {
            bottom: -10%;
        }

        .letterbox.active.top {
            top: 0;
        }

        .letterbox.active.bottom {
            bottom: 0;
        }

        .glitch {
            animation: glitch 0.3s ease;
        }

        @keyframes glitch {
            0%, 100% { transform: translate(0); }
            20% { transform: translate(-5px, 5px); }
            40% { transform: translate(-5px, -5px); }
            60% { transform: translate(5px, 5px); }
            80% { transform: translate(5px, -5px); }
        }

        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 10000;
        }

        .loading-text {
            font-size: 32px;
            color: #0ff;
            text-shadow: 0 0 20px #0ff;
            margin-bottom: 20px;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .loading-bar {
            width: 300px;
            height: 20px;
            background: rgba(0, 255, 255, 0.2);
            border: 2px solid #0ff;
            border-radius: 10px;
            overflow: hidden;
        }

        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #0ff, #ff00ff);
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: 0 0 20px #0ff;
        }

        @media (max-width: 768px) {
            .stat-bar {
                padding: 6px 8px;
            }
            .bar-container {
                width: 150px;
                height: 16px;
            }
            .bar-text {
                font-size: 9px;
                line-height: 16px;
            }
            #minimap {
                width: 120px;
                height: 120px;
            }
            #questTracker {
                max-width: 200px;
                padding: 8px;
                font-size: 10px;
            }
            .panel {
                padding: 15px;
            }
            .panel h2 {
                font-size: 20px;
            }
        }

        .credits-display {
            color: #ffff00;
            font-size: 14px;
            margin-top: 5px;
            text-shadow: 0 0 5px #ffff00;
        }

        .level-display {
            color: #ff00ff;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 5px;
            text-shadow: 0 0 5px #ff00ff;
        }

        .equipment-slot {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ff00ff;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 4px;
        }

        .equipment-slot.equipped {
            background: rgba(255, 0, 255, 0.2);
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
        }

        .faction-rep {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #0ff;
            border-radius: 4px;
        }

        .rep-bar-container {
            flex: 1;
            margin-left: 15px;
        }

        .rep-bar {
            height: 10px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #0ff;
            border-radius: 5px;
            overflow: hidden;
            margin-top: 5px;
        }

        .rep-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0080, #ff00ff);
            transition: width 0.3s ease;
        }

        .menu-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.98);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .menu-screen.hidden {
            display: none;
        }

        .menu-title {
            font-size: 64px;
            color: #ff00ff;
            text-shadow: 0 0 30px #ff00ff, 0 0 60px #0ff;
            margin-bottom: 50px;
            animation: pulse 2s ease-in-out infinite;
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .menu-btn {
            background: rgba(0, 255, 255, 0.2);
            border: 3px solid #0ff;
            color: #0ff;
            padding: 20px 60px;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
        }

        .menu-btn:hover {
            background: rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.9);
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <div id="loading" class="loading">
        <div class="loading-text">INITIALIZING NEON DISTRICT...</div>
        <div class="loading-bar">
            <div class="loading-progress" id="loadingProgress"></div>
        </div>
    </div>

    <div id="mainMenu" class="menu-screen">
        <div class="menu-title">NEON DISTRICT</div>
        <div class="menu-buttons">
            <button class="menu-btn" id="newGameBtn">NEW GAME</button>
            <button class="menu-btn" id="loadGameBtn">LOAD GAME</button>
            <button class="menu-btn" id="aboutBtn">ABOUT</button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div class="letterbox top"></div>
    <div class="letterbox bottom"></div>

    <div class="hud" id="topHUD">
        <div class="stat-bar">
            <div class="level-display">Level <span id="levelDisplay">1</span></div>
            <div class="stat-name">HP</div>
            <div class="bar-container">
                <div class="bar-fill hp-bar" id="hpBar" style="width: 100%"></div>
                <div class="bar-text" id="hpText">100 / 100</div>
            </div>
        </div>
        <div class="stat-bar">
            <div class="stat-name">ENERGY</div>
            <div class="bar-container">
                <div class="bar-fill energy-bar" id="energyBar" style="width: 100%"></div>
                <div class="bar-text" id="energyText">100 / 100</div>
            </div>
        </div>
        <div class="stat-bar">
            <div class="stat-name">XP</div>
            <div class="bar-container">
                <div class="bar-fill xp-bar" id="xpBar" style="width: 0%"></div>
                <div class="bar-text" id="xpText">0 / 100</div>
            </div>
            <div class="credits-display">CREDITS: <span id="creditsDisplay">500</span>¥</div>
        </div>
    </div>

    <div class="hud" id="questTracker">
        <div class="quest-title" id="currentQuestTitle">No Active Quest</div>
        <div id="questObjectives"></div>
    </div>

    <canvas id="minimap"></canvas>

    <div id="notifications"></div>

    <div class="panel" id="inventoryPanel">
        <h2>INVENTORY</h2>
        <div class="credits-display" style="font-size: 18px; margin-bottom: 20px;">
            CREDITS: <span id="invCredits">500</span>¥ | WEIGHT: <span id="invWeight">0</span> / <span id="invMaxWeight">100</span>
        </div>

        <h3>EQUIPMENT</h3>
        <div id="equipmentSlots"></div>

        <h3>INVENTORY</h3>
        <div class="inventory-grid" id="inventoryGrid"></div>

        <button class="btn" onclick="game.closePanel('inventoryPanel')">CLOSE [I]</button>
    </div>

    <div class="panel" id="characterPanel">
        <h2>CHARACTER</h2>

        <h3>STATS</h3>
        <div class="stat-grid">
            <div class="stat-item">
                <div class="stat-name">STRENGTH</div>
                <div class="stat-value" id="statSTR">5</div>
            </div>
            <div class="stat-item">
                <div class="stat-name">DEXTERITY</div>
                <div class="stat-value" id="statDEX">5</div>
            </div>
            <div class="stat-item">
                <div class="stat-name">INTELLIGENCE</div>
                <div class="stat-value" id="statINT">5</div>
            </div>
            <div class="stat-item">
                <div class="stat-name">CHARISMA</div>
                <div class="stat-value" id="statCHA">5</div>
            </div>
            <div class="stat-item">
                <div class="stat-name">ENDURANCE</div>
                <div class="stat-value" id="statEND">5</div>
            </div>
        </div>

        <div id="statPointsContainer" style="margin: 20px 0; display: none;">
            <div style="color: #ffff00; font-size: 18px; margin-bottom: 10px;">
                STAT POINTS AVAILABLE: <span id="statPointsAvailable">0</span>
            </div>
            <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                <button class="btn" onclick="game.addStat('str')">+STR</button>
                <button class="btn" onclick="game.addStat('dex')">+DEX</button>
                <button class="btn" onclick="game.addStat('int')">+INT</button>
                <button class="btn" onclick="game.addStat('cha')">+CHA</button>
                <button class="btn" onclick="game.addStat('end')">+END</button>
            </div>
        </div>

        <h3>REPUTATION</h3>
        <div id="reputationDisplay"></div>

        <button class="btn" onclick="game.closePanel('characterPanel')">CLOSE [C]</button>
    </div>

    <div class="panel" id="skillPanel">
        <h2>SKILL TREE</h2>
        <div style="color: #ffff00; font-size: 18px; margin-bottom: 20px;">
            SKILL POINTS: <span id="skillPointsDisplay">0</span>
        </div>
        <div class="skill-tree" id="skillTree"></div>
        <button class="btn" onclick="game.closePanel('skillPanel')">CLOSE [K]</button>
    </div>

    <div class="panel" id="questPanel">
        <h2>MISSION LOG</h2>
        <div id="questLog"></div>
        <button class="btn" onclick="game.closePanel('questPanel')">CLOSE [Q]</button>
    </div>

    <div class="dialogue-box" id="dialogueBox">
        <div class="dialogue-speaker" id="dialogueSpeaker"></div>
        <div class="dialogue-text" id="dialogueText"></div>
        <div class="dialogue-choices" id="dialogueChoices"></div>
    </div>

    <div class="controls mobile" id="mobileControls">
        <div class="joystick" id="joystick">
            <div class="joystick-knob" id="joystickKnob"></div>
        </div>
    </div>

    <div class="action-buttons" id="actionButtons" style="display: none;">
        <button class="action-btn" id="attackBtn">ATK</button>
        <button class="action-btn" id="dodgeBtn">DODGE</button>
        <button class="action-btn" id="interactBtn">USE</button>
    </div>

    <script>
        const game = {
            canvas: null,
            ctx: null,
            minimap: null,
            minimapCtx: null,
            width: 0,
            height: 0,

            // Player state
            player: {
                x: 0,
                y: 0,
                vx: 0,
                vy: 0,
                angle: 0,
                speed: 3,
                size: 16,
                hp: 100,
                maxHp: 100,
                energy: 100,
                maxEnergy: 100,
                xp: 0,
                level: 1,
                credits: 500,
                stats: {
                    str: 5,
                    dex: 5,
                    int: 5,
                    cha: 5,
                    end: 5
                },
                statPoints: 0,
                skillPoints: 0,
                inventory: [],
                maxWeight: 100,
                equipment: {
                    weapon: null,
                    armor: null,
                    implant: null,
                    accessory: null
                },
                skills: {},
                reputation: {
                    corpo: 0,
                    gang: 0,
                    hackers: 0
                },
                state: 'idle', // idle, attacking, dodging
                attackCooldown: 0,
                dodgeCooldown: 0,
                comboCount: 0,
                comboTimer: 0,
                isInvulnerable: false,
                buffs: []
            },

            // World state
            world: {
                time: 0,
                timeScale: 0.0001, // Day/night cycle speed
                buildings: [],
                npcs: [],
                enemies: [],
                items: [],
                particles: [],
                districts: [],
                camera: { x: 0, y: 0 }
            },

            // Quest system
            quests: {
                active: null,
                completed: [],
                available: []
            },

            // Input
            keys: {},
            mouse: { x: 0, y: 0, down: false },
            touch: { active: false, x: 0, y: 0 },

            // Game state
            paused: false,
            dialogue: null,
            cinematic: false,

            // Constants
            WORLD_SIZE: 4000,
            DISTRICT_SIZE: 800,

            init() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.minimap = document.getElementById('minimap');
                this.minimapCtx = this.minimap.getContext('2d');

                this.resize();
                window.addEventListener('resize', () => this.resize());

                this.setupInput();
                this.setupMobileControls();
                this.initWorld();
                this.initQuests();
                this.initSkills();

                // Simulate loading
                this.simulateLoading();
            },

            simulateLoading() {
                const progress = document.getElementById('loadingProgress');
                const loading = document.getElementById('loading');
                let pct = 0;

                const interval = setInterval(() => {
                    pct += Math.random() * 15;
                    if (pct >= 100) {
                        pct = 100;
                        progress.style.width = '100%';
                        clearInterval(interval);
                        setTimeout(() => {
                            loading.style.display = 'none';
                        }, 500);
                    } else {
                        progress.style.width = pct + '%';
                    }
                }, 100);
            },

            resize() {
                this.width = this.canvas.width = window.innerWidth;
                this.height = this.canvas.height = window.innerHeight;
            },

            setupInput() {
                window.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;

                    // Panel shortcuts
                    if (e.key.toLowerCase() === 'i') this.togglePanel('inventoryPanel');
                    if (e.key.toLowerCase() === 'c') this.togglePanel('characterPanel');
                    if (e.key.toLowerCase() === 'k') this.togglePanel('skillPanel');
                    if (e.key.toLowerCase() === 'q') this.togglePanel('questPanel');
                    if (e.key === 'Escape') this.closeAllPanels();

                    // Combat
                    if (e.key === ' ') this.playerAttack();
                    if (e.key.toLowerCase() === 'shift') this.playerDodge();
                });

                window.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });

                this.canvas.addEventListener('mousemove', (e) => {
                    this.mouse.x = e.clientX;
                    this.mouse.y = e.clientY;
                });

                this.canvas.addEventListener('mousedown', () => {
                    this.mouse.down = true;
                });

                this.canvas.addEventListener('mouseup', () => {
                    this.mouse.down = false;
                });

                // Menu buttons
                document.getElementById('newGameBtn').addEventListener('click', () => this.newGame());
                document.getElementById('loadGameBtn').addEventListener('click', () => this.loadGame());
                document.getElementById('aboutBtn').addEventListener('click', () => {
                    this.showNotification('Neon District RPG v1.0\nBy LocalFirstTools');
                });
            },

            setupMobileControls() {
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

                if (isMobile) {
                    document.getElementById('mobileControls').style.display = 'flex';
                    document.getElementById('actionButtons').style.display = 'flex';

                    const joystick = document.getElementById('joystick');
                    const knob = document.getElementById('joystickKnob');

                    joystick.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        this.touch.active = true;
                    });

                    joystick.addEventListener('touchmove', (e) => {
                        e.preventDefault();
                        if (!this.touch.active) return;

                        const rect = joystick.getBoundingClientRect();
                        const centerX = rect.width / 2;
                        const centerY = rect.height / 2;
                        const touch = e.touches[0];
                        const x = touch.clientX - rect.left - centerX;
                        const y = touch.clientY - rect.top - centerY;

                        const distance = Math.sqrt(x * x + y * y);
                        const maxDistance = 35;

                        if (distance > maxDistance) {
                            const angle = Math.atan2(y, x);
                            this.touch.x = Math.cos(angle) * maxDistance;
                            this.touch.y = Math.sin(angle) * maxDistance;
                        } else {
                            this.touch.x = x;
                            this.touch.y = y;
                        }

                        knob.style.transform = `translate(calc(-50% + ${this.touch.x}px), calc(-50% + ${this.touch.y}px))`;
                    });

                    joystick.addEventListener('touchend', () => {
                        this.touch.active = false;
                        this.touch.x = 0;
                        this.touch.y = 0;
                        knob.style.transform = 'translate(-50%, -50%)';
                    });

                    document.getElementById('attackBtn').addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        this.playerAttack();
                    });

                    document.getElementById('dodgeBtn').addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        this.playerDodge();
                    });

                    document.getElementById('interactBtn').addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        this.interact();
                    });
                }
            },

            initWorld() {
                // Generate districts
                const districts = [
                    { name: 'Downtown', x: 0, y: 0, color: '#0088ff' },
                    { name: 'Slums', x: this.DISTRICT_SIZE, y: 0, color: '#ff0040' },
                    { name: 'Market', x: 0, y: this.DISTRICT_SIZE, color: '#ffff00' },
                    { name: 'Industrial', x: this.DISTRICT_SIZE, y: this.DISTRICT_SIZE, color: '#ff8800' },
                    { name: 'Docks', x: this.DISTRICT_SIZE * 2, y: 0, color: '#00ffff' }
                ];

                this.world.districts = districts;

                // Generate buildings
                for (let i = 0; i < 200; i++) {
                    this.world.buildings.push({
                        x: Math.random() * this.WORLD_SIZE,
                        y: Math.random() * this.WORLD_SIZE,
                        width: 40 + Math.random() * 80,
                        height: 40 + Math.random() * 80,
                        floors: Math.floor(2 + Math.random() * 8),
                        color: this.randomNeonColor(),
                        hasNeon: Math.random() > 0.5
                    });
                }

                // Spawn NPCs
                for (let i = 0; i < 50; i++) {
                    this.spawnNPC();
                }

                // Spawn initial enemies
                for (let i = 0; i < 20; i++) {
                    this.spawnEnemy();
                }

                // Spawn items
                for (let i = 0; i < 30; i++) {
                    this.spawnItem();
                }

                // Player starts in downtown
                this.player.x = 200;
                this.player.y = 200;
            },

            spawnNPC() {
                const npc = {
                    x: Math.random() * this.WORLD_SIZE,
                    y: Math.random() * this.WORLD_SIZE,
                    vx: 0,
                    vy: 0,
                    size: 12,
                    color: '#00ffff',
                    state: 'patrol',
                    patrolPoints: [],
                    currentPatrol: 0,
                    hasQuest: Math.random() > 0.8,
                    dialogue: this.generateDialogue(),
                    faction: ['corpo', 'gang', 'civilian'][Math.floor(Math.random() * 3)]
                };

                // Generate patrol route
                for (let i = 0; i < 3; i++) {
                    npc.patrolPoints.push({
                        x: npc.x + (Math.random() - 0.5) * 200,
                        y: npc.y + (Math.random() - 0.5) * 200
                    });
                }

                this.world.npcs.push(npc);
            },

            spawnEnemy(type = null) {
                if (!type) {
                    type = ['thug', 'guard', 'drone', 'cyborg'][Math.floor(Math.random() * 4)];
                }

                const enemyData = {
                    thug: { hp: 50, damage: 10, speed: 2, xp: 25, color: '#ff0000' },
                    guard: { hp: 80, damage: 15, speed: 1.5, xp: 40, color: '#ff8800' },
                    drone: { hp: 30, damage: 8, speed: 3, xp: 30, color: '#00ff00' },
                    cyborg: { hp: 150, damage: 25, speed: 2.5, xp: 100, color: '#ff00ff' }
                };

                const data = enemyData[type];
                const enemy = {
                    x: Math.random() * this.WORLD_SIZE,
                    y: Math.random() * this.WORLD_SIZE,
                    vx: 0,
                    vy: 0,
                    size: 14,
                    type: type,
                    hp: data.hp,
                    maxHp: data.hp,
                    damage: data.damage,
                    speed: data.speed,
                    xp: data.xp,
                    color: data.color,
                    state: 'patrol',
                    alertRange: 200,
                    attackRange: 30,
                    attackCooldown: 0,
                    patrolPoints: [],
                    currentPatrol: 0
                };

                // Generate patrol route
                for (let i = 0; i < 3; i++) {
                    enemy.patrolPoints.push({
                        x: enemy.x + (Math.random() - 0.5) * 300,
                        y: enemy.y + (Math.random() - 0.5) * 300
                    });
                }

                this.world.enemies.push(enemy);
            },

            spawnItem() {
                const itemTypes = ['weapon', 'armor', 'implant', 'consumable', 'credits'];
                const type = itemTypes[Math.floor(Math.random() * itemTypes.length)];

                let item = {
                    x: Math.random() * this.WORLD_SIZE,
                    y: Math.random() * this.WORLD_SIZE,
                    size: 8,
                    type: type,
                    pickedUp: false
                };

                switch (type) {
                    case 'weapon':
                        item.name = ['Plasma Pistol', 'Katana', 'Energy Blade', 'SMG', 'Shotgun'][Math.floor(Math.random() * 5)];
                        item.damage = 10 + Math.floor(Math.random() * 30);
                        item.weight = 5;
                        item.value = item.damage * 10;
                        item.color = '#ff0000';
                        break;
                    case 'armor':
                        item.name = ['Kevlar Vest', 'Cyber Armor', 'Shield Gen', 'Stealth Cloak'][Math.floor(Math.random() * 4)];
                        item.defense = 5 + Math.floor(Math.random() * 20);
                        item.weight = 10;
                        item.value = item.defense * 15;
                        item.color = '#0088ff';
                        break;
                    case 'implant':
                        item.name = ['Reflex Boost', 'Strength Amp', 'Neural Link', 'Optic Enhancer'][Math.floor(Math.random() * 4)];
                        item.statBonus = { stat: ['str', 'dex', 'int'][Math.floor(Math.random() * 3)], amount: 2 + Math.floor(Math.random() * 3) };
                        item.weight = 2;
                        item.value = 500;
                        item.color = '#ff00ff';
                        break;
                    case 'consumable':
                        item.name = ['Medkit', 'Energy Drink', 'Stim Pack'][Math.floor(Math.random() * 3)];
                        item.effect = { hp: 50, energy: 30 };
                        item.weight = 1;
                        item.value = 50;
                        item.color = '#00ff00';
                        break;
                    case 'credits':
                        item.name = 'Credits';
                        item.amount = 50 + Math.floor(Math.random() * 200);
                        item.weight = 0;
                        item.value = item.amount;
                        item.color = '#ffff00';
                        break;
                }

                this.world.items.push(item);
            },

            randomNeonColor() {
                const colors = ['#ff0080', '#00ffff', '#ff00ff', '#ffff00', '#00ff00', '#ff8800'];
                return colors[Math.floor(Math.random() * colors.length)];
            },

            generateDialogue() {
                const dialogues = [
                    { speaker: 'Civilian', text: 'Stay safe out there. The streets are dangerous at night.', choices: [{ text: 'Thanks', response: 'No problem, choom.' }] },
                    { speaker: 'Corpo', text: 'Move along. This is private property.', choices: [{ text: 'Sorry', response: 'See that you do.' }] },
                    { speaker: 'Gang Member', text: 'You looking for trouble?', choices: [{ text: 'No trouble', response: 'Good. Keep it that way.' }] },
                    { speaker: 'Vendor', text: 'Need supplies? I got the best prices in the district.', choices: [{ text: 'Maybe later', response: 'Your loss, choom.' }] },
                    { speaker: 'Hacker', text: 'I can get you into places... for a price.', choices: [{ text: 'Interesting', response: 'Come find me when you need it.' }] }
                ];

                return dialogues[Math.floor(Math.random() * dialogues.length)];
            },

            initQuests() {
                this.quests.available = [
                    {
                        id: 'main_1',
                        title: 'Welcome to Neon District',
                        description: 'Explore the city and get your bearings.',
                        type: 'main',
                        objectives: [
                            { text: 'Visit Downtown', complete: false, location: { x: 200, y: 200 } },
                            { text: 'Talk to a civilian', complete: false, requireNPC: true }
                        ],
                        reward: { xp: 100, credits: 200 },
                        unlocks: 'main_2'
                    },
                    {
                        id: 'main_2',
                        title: 'First Blood',
                        description: 'Gang members have been causing trouble. Take them down.',
                        type: 'main',
                        objectives: [
                            { text: 'Defeat 5 enemies', complete: false, requireKills: 5, killCount: 0 }
                        ],
                        reward: { xp: 250, credits: 500 },
                        unlocks: 'main_3'
                    },
                    {
                        id: 'main_3',
                        title: 'The Hacker',
                        description: 'Find the legendary hacker in the Slums.',
                        type: 'main',
                        objectives: [
                            { text: 'Go to the Slums', complete: false, location: { x: 1000, y: 200 } },
                            { text: 'Find the hacker', complete: false, requireNPC: true }
                        ],
                        reward: { xp: 400, credits: 800, skillPoint: 1 },
                        unlocks: 'main_4'
                    },
                    {
                        id: 'main_4',
                        title: 'Corporate Espionage',
                        description: 'Infiltrate the corpo tower and steal data.',
                        type: 'main',
                        objectives: [
                            { text: 'Reach the Industrial District', complete: false, location: { x: 1000, y: 1000 } },
                            { text: 'Defeat the guards', complete: false, requireKills: 3, killCount: 0 }
                        ],
                        reward: { xp: 600, credits: 1500, skillPoint: 2 },
                        unlocks: 'main_5'
                    },
                    {
                        id: 'main_5',
                        title: 'Final Showdown',
                        description: 'Face the cyborg enforcer boss.',
                        type: 'main',
                        objectives: [
                            { text: 'Go to the Docks', complete: false, location: { x: 1600, y: 200 } },
                            { text: 'Defeat the boss', complete: false, requireBoss: true }
                        ],
                        reward: { xp: 1000, credits: 3000, skillPoint: 3 }
                    },
                    {
                        id: 'side_1',
                        title: 'Lost and Found',
                        description: 'A civilian lost their implant. Find it.',
                        type: 'side',
                        objectives: [
                            { text: 'Find the implant', complete: false, requireItem: 'implant' }
                        ],
                        reward: { xp: 100, credits: 300 }
                    },
                    {
                        id: 'side_2',
                        title: 'Gang War',
                        description: 'Help one gang defeat another.',
                        type: 'side',
                        objectives: [
                            { text: 'Defeat 10 enemies', complete: false, requireKills: 10, killCount: 0 }
                        ],
                        reward: { xp: 300, credits: 600, reputation: { gang: 20 } }
                    }
                ];

                this.startQuest('main_1');
            },

            initSkills() {
                this.player.skills = {
                    combat_combo: { unlocked: false, level: 0, maxLevel: 3, cost: 1 },
                    combat_crit: { unlocked: false, level: 0, maxLevel: 3, cost: 1 },
                    combat_berserk: { unlocked: false, level: 0, maxLevel: 1, cost: 2 },
                    hack_doors: { unlocked: false, level: 0, maxLevel: 1, cost: 1 },
                    hack_cameras: { unlocked: false, level: 0, maxLevel: 1, cost: 1 },
                    hack_emp: { unlocked: false, level: 0, maxLevel: 3, cost: 2 },
                    stealth_sneak: { unlocked: false, level: 0, maxLevel: 3, cost: 1 },
                    stealth_backstab: { unlocked: false, level: 0, maxLevel: 3, cost: 2 },
                    stealth_cloak: { unlocked: false, level: 0, maxLevel: 1, cost: 3 },
                    social_bribe: { unlocked: false, level: 0, maxLevel: 1, cost: 1 },
                    social_persuade: { unlocked: false, level: 0, maxLevel: 3, cost: 1 }
                };

                this.updateSkillPanel();
            },

            startQuest(questId) {
                const quest = this.quests.available.find(q => q.id === questId);
                if (!quest) return;

                this.quests.active = quest;
                this.showNotification(`NEW MISSION: ${quest.title}`);
                this.updateQuestTracker();
            },

            updateQuestTracker() {
                const quest = this.quests.active;
                if (!quest) {
                    document.getElementById('currentQuestTitle').textContent = 'No Active Quest';
                    document.getElementById('questObjectives').innerHTML = '';
                    return;
                }

                document.getElementById('currentQuestTitle').textContent = quest.title;
                const objDiv = document.getElementById('questObjectives');
                objDiv.innerHTML = '';

                quest.objectives.forEach(obj => {
                    const div = document.createElement('div');
                    div.className = 'quest-objective' + (obj.complete ? ' complete' : '');
                    let text = obj.text;
                    if (obj.requireKills) {
                        text += ` (${obj.killCount || 0}/${obj.requireKills})`;
                    }
                    div.textContent = '> ' + text;
                    objDiv.appendChild(div);
                });
            },

            checkQuestProgress() {
                const quest = this.quests.active;
                if (!quest) return;

                let allComplete = true;
                quest.objectives.forEach(obj => {
                    if (obj.complete) return;

                    if (obj.location) {
                        const dist = Math.hypot(this.player.x - obj.location.x, this.player.y - obj.location.y);
                        if (dist < 100) {
                            obj.complete = true;
                            this.showNotification('OBJECTIVE COMPLETE');
                        }
                    }

                    if (!obj.complete) allComplete = false;
                });

                if (allComplete) {
                    this.completeQuest();
                } else {
                    this.updateQuestTracker();
                }
            },

            completeQuest() {
                const quest = this.quests.active;
                if (!quest) return;

                this.showNotification(`MISSION COMPLETE: ${quest.title}`);

                // Rewards
                this.addXP(quest.reward.xp);
                this.player.credits += quest.reward.credits;
                if (quest.reward.skillPoint) {
                    this.player.skillPoints += quest.reward.skillPoint;
                }
                if (quest.reward.reputation) {
                    Object.keys(quest.reward.reputation).forEach(faction => {
                        this.player.reputation[faction] += quest.reward.reputation[faction];
                    });
                }

                this.quests.completed.push(quest);
                this.quests.active = null;

                // Unlock next quest
                if (quest.unlocks) {
                    setTimeout(() => {
                        this.startQuest(quest.unlocks);
                    }, 2000);
                }

                this.updateQuestTracker();
                this.updateHUD();
            },

            update() {
                if (this.paused) return;

                // Update world time
                this.world.time += this.world.timeScale;
                if (this.world.time > 1) this.world.time = 0;

                // Update player
                this.updatePlayer();

                // Update NPCs
                this.world.npcs.forEach(npc => this.updateNPC(npc));

                // Update enemies
                this.world.enemies.forEach(enemy => this.updateEnemy(enemy));

                // Update particles
                this.world.particles = this.world.particles.filter(p => {
                    p.life -= 0.016;
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.1; // Gravity for some particles
                    return p.life > 0;
                });

                // Update camera
                this.world.camera.x = this.player.x - this.width / 2;
                this.world.camera.y = this.player.y - this.height / 2;

                // Spawn rain particles
                if (Math.random() < 0.3) {
                    this.world.particles.push({
                        x: this.world.camera.x + Math.random() * this.width,
                        y: this.world.camera.y,
                        vx: -1,
                        vy: 10,
                        size: 1,
                        color: 'rgba(0, 255, 255, 0.3)',
                        life: 2
                    });
                }

                // Check quest progress
                this.checkQuestProgress();

                // Update cooldowns
                if (this.player.attackCooldown > 0) this.player.attackCooldown--;
                if (this.player.dodgeCooldown > 0) this.player.dodgeCooldown--;
                if (this.player.comboTimer > 0) {
                    this.player.comboTimer--;
                } else {
                    this.player.comboCount = 0;
                }

                // Auto-save every 10 seconds
                if (Math.random() < 0.001) {
                    this.saveGame();
                }
            },

            updatePlayer() {
                let dx = 0;
                let dy = 0;

                // Keyboard input
                if (this.keys['w'] || this.keys['arrowup']) dy -= 1;
                if (this.keys['s'] || this.keys['arrowdown']) dy += 1;
                if (this.keys['a'] || this.keys['arrowleft']) dx -= 1;
                if (this.keys['d'] || this.keys['arrowright']) dx += 1;

                // Touch input
                if (this.touch.active) {
                    dx = this.touch.x / 35;
                    dy = this.touch.y / 35;
                }

                // Normalize diagonal movement
                if (dx !== 0 || dy !== 0) {
                    const mag = Math.sqrt(dx * dx + dy * dy);
                    dx /= mag;
                    dy /= mag;

                    this.player.angle = Math.atan2(dy, dx);
                }

                // Apply movement
                const speed = this.player.state === 'dodging' ? this.player.speed * 2 : this.player.speed;
                this.player.vx = dx * speed;
                this.player.vy = dy * speed;

                this.player.x += this.player.vx;
                this.player.y += this.player.vy;

                // Boundary check
                this.player.x = Math.max(0, Math.min(this.WORLD_SIZE, this.player.x));
                this.player.y = Math.max(0, Math.min(this.WORLD_SIZE, this.player.y));

                // Building collision
                this.world.buildings.forEach(building => {
                    if (this.checkCollision(this.player, building)) {
                        this.player.x -= this.player.vx;
                        this.player.y -= this.player.vy;
                    }
                });

                // Energy regeneration
                if (this.player.energy < this.player.maxEnergy) {
                    this.player.energy = Math.min(this.player.maxEnergy, this.player.energy + 0.5);
                    this.updateHUD();
                }

                // State management
                if (this.player.state === 'dodging') {
                    if (this.player.dodgeCooldown <= 0) {
                        this.player.state = 'idle';
                        this.player.isInvulnerable = false;
                    }
                }

                // Check item pickup
                this.world.items.forEach(item => {
                    if (item.pickedUp) return;
                    const dist = Math.hypot(this.player.x - item.x, this.player.y - item.y);
                    if (dist < 30) {
                        this.pickupItem(item);
                    }
                });
            },

            updateNPC(npc) {
                if (npc.state === 'patrol') {
                    const target = npc.patrolPoints[npc.currentPatrol];
                    const dx = target.x - npc.x;
                    const dy = target.y - npc.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 5) {
                        npc.currentPatrol = (npc.currentPatrol + 1) % npc.patrolPoints.length;
                    } else {
                        npc.vx = (dx / dist) * 1;
                        npc.vy = (dy / dist) * 1;
                        npc.x += npc.vx;
                        npc.y += npc.vy;
                    }
                } else if (npc.state === 'flee') {
                    const dx = npc.x - this.player.x;
                    const dy = npc.y - this.player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > 200) {
                        npc.state = 'patrol';
                    } else {
                        npc.vx = (dx / dist) * 2;
                        npc.vy = (dy / dist) * 2;
                        npc.x += npc.vx;
                        npc.y += npc.vy;
                    }
                }

                // Check if player is attacking nearby - NPCs flee
                const distToPlayer = Math.hypot(this.player.x - npc.x, this.player.y - npc.y);
                if (distToPlayer < 100 && this.player.state === 'attacking') {
                    npc.state = 'flee';
                }
            },

            updateEnemy(enemy) {
                const distToPlayer = Math.hypot(this.player.x - enemy.x, this.player.y - enemy.y);

                if (enemy.state === 'patrol') {
                    if (distToPlayer < enemy.alertRange) {
                        enemy.state = 'chase';
                    } else {
                        const target = enemy.patrolPoints[enemy.currentPatrol];
                        const dx = target.x - enemy.x;
                        const dy = target.y - enemy.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < 5) {
                            enemy.currentPatrol = (enemy.currentPatrol + 1) % enemy.patrolPoints.length;
                        } else {
                            enemy.vx = (dx / dist) * enemy.speed * 0.5;
                            enemy.vy = (dy / dist) * enemy.speed * 0.5;
                            enemy.x += enemy.vx;
                            enemy.y += enemy.vy;
                        }
                    }
                } else if (enemy.state === 'chase') {
                    if (distToPlayer > enemy.alertRange * 1.5) {
                        enemy.state = 'patrol';
                    } else if (distToPlayer < enemy.attackRange) {
                        enemy.state = 'attack';
                    } else {
                        const dx = this.player.x - enemy.x;
                        const dy = this.player.y - enemy.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        enemy.vx = (dx / dist) * enemy.speed;
                        enemy.vy = (dy / dist) * enemy.speed;
                        enemy.x += enemy.vx;
                        enemy.y += enemy.vy;
                    }
                } else if (enemy.state === 'attack') {
                    if (distToPlayer > enemy.attackRange * 2) {
                        enemy.state = 'chase';
                    } else {
                        if (enemy.attackCooldown <= 0) {
                            this.enemyAttack(enemy);
                            enemy.attackCooldown = 60;
                        } else {
                            enemy.attackCooldown--;
                        }
                    }
                } else if (enemy.state === 'retreat') {
                    if (enemy.hp > enemy.maxHp * 0.5) {
                        enemy.state = 'chase';
                    } else {
                        const dx = enemy.x - this.player.x;
                        const dy = enemy.y - this.player.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        enemy.vx = (dx / dist) * enemy.speed * 1.5;
                        enemy.vy = (dy / dist) * enemy.speed * 1.5;
                        enemy.x += enemy.vx;
                        enemy.y += enemy.vy;
                    }
                }

                // Check health for retreat
                if (enemy.hp < enemy.maxHp * 0.3 && enemy.state !== 'retreat') {
                    enemy.state = 'retreat';
                }
            },

            playerAttack() {
                if (this.player.attackCooldown > 0) return;
                if (this.player.energy < 10) return;

                this.player.state = 'attacking';
                this.player.attackCooldown = 30;
                this.player.energy -= 10;

                // Combo system
                this.player.comboCount++;
                this.player.comboTimer = 60;

                // Screen shake
                this.screenShake();

                // Attack hitbox
                const attackRange = 50;
                const baseDamage = 20 + this.player.stats.str * 2;
                let damage = baseDamage * this.player.comboCount;

                // Crit chance
                const critChance = 0.1 + (this.player.skills.combat_crit.unlocked ? this.player.skills.combat_crit.level * 0.1 : 0);
                const isCrit = Math.random() < critChance;
                if (isCrit) damage *= 2;

                // Check for hits
                this.world.enemies.forEach(enemy => {
                    const dist = Math.hypot(this.player.x - enemy.x, this.player.y - enemy.y);
                    if (dist < attackRange) {
                        this.damageEnemy(enemy, damage, isCrit);
                    }
                });

                // Attack particles
                for (let i = 0; i < 10; i++) {
                    const angle = this.player.angle + (Math.random() - 0.5) * 0.5;
                    this.world.particles.push({
                        x: this.player.x,
                        y: this.player.y,
                        vx: Math.cos(angle) * (5 + Math.random() * 5),
                        vy: Math.sin(angle) * (5 + Math.random() * 5),
                        size: 2 + Math.random() * 3,
                        color: isCrit ? '#ffff00' : '#ff0080',
                        life: 0.5 + Math.random() * 0.5
                    });
                }

                setTimeout(() => {
                    if (this.player.state === 'attacking') {
                        this.player.state = 'idle';
                    }
                }, 200);

                this.updateHUD();
            },

            playerDodge() {
                if (this.player.dodgeCooldown > 0) return;
                if (this.player.energy < 20) return;

                this.player.state = 'dodging';
                this.player.dodgeCooldown = 60;
                this.player.energy -= 20;
                this.player.isInvulnerable = true;

                // Dodge particles
                for (let i = 0; i < 20; i++) {
                    this.world.particles.push({
                        x: this.player.x,
                        y: this.player.y,
                        vx: (Math.random() - 0.5) * 5,
                        vy: (Math.random() - 0.5) * 5,
                        size: 2,
                        color: '#00ffff',
                        life: 0.5
                    });
                }

                this.updateHUD();
            },

            damageEnemy(enemy, damage, isCrit = false) {
                enemy.hp -= damage;

                // Damage number
                this.showDamageNumber(enemy.x, enemy.y, damage, isCrit);

                // Hit particles
                for (let i = 0; i < 15; i++) {
                    this.world.particles.push({
                        x: enemy.x,
                        y: enemy.y,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8,
                        size: 2 + Math.random() * 2,
                        color: enemy.color,
                        life: 0.5 + Math.random() * 0.5
                    });
                }

                if (enemy.hp <= 0) {
                    this.killEnemy(enemy);
                }
            },

            killEnemy(enemy) {
                const index = this.world.enemies.indexOf(enemy);
                if (index > -1) {
                    this.world.enemies.splice(index, 1);
                }

                // Rewards
                this.addXP(enemy.xp);
                this.player.credits += Math.floor(10 + Math.random() * 30);

                // Quest progress
                if (this.quests.active) {
                    this.quests.active.objectives.forEach(obj => {
                        if (obj.requireKills && !obj.complete) {
                            obj.killCount = (obj.killCount || 0) + 1;
                            if (obj.killCount >= obj.requireKills) {
                                obj.complete = true;
                                this.showNotification('OBJECTIVE COMPLETE');
                            }
                        }
                    });
                }

                // Loot drop
                if (Math.random() > 0.5) {
                    this.world.items.push({
                        x: enemy.x,
                        y: enemy.y,
                        size: 8,
                        type: 'credits',
                        name: 'Credits',
                        amount: enemy.xp,
                        weight: 0,
                        value: enemy.xp,
                        color: '#ffff00',
                        pickedUp: false
                    });
                }

                // Death particles
                for (let i = 0; i < 30; i++) {
                    this.world.particles.push({
                        x: enemy.x,
                        y: enemy.y,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10,
                        size: 3 + Math.random() * 4,
                        color: enemy.color,
                        life: 1 + Math.random()
                    });
                }

                this.updateHUD();
            },

            enemyAttack(enemy) {
                if (this.player.isInvulnerable) return;

                let damage = enemy.damage;

                // Apply armor
                if (this.player.equipment.armor) {
                    damage = Math.max(1, damage - this.player.equipment.armor.defense);
                }

                this.player.hp -= damage;
                this.showDamageNumber(this.player.x, this.player.y, damage, false);

                // Screen glitch effect
                document.getElementById('gameCanvas').classList.add('glitch');
                setTimeout(() => {
                    document.getElementById('gameCanvas').classList.remove('glitch');
                }, 300);

                if (this.player.hp <= 0) {
                    this.gameOver();
                }

                this.updateHUD();
            },

            pickupItem(item) {
                item.pickedUp = true;

                if (item.type === 'credits') {
                    this.player.credits += item.amount;
                    this.showNotification(`+${item.amount}¥`);
                } else {
                    const currentWeight = this.calculateWeight();
                    if (currentWeight + item.weight <= this.player.maxWeight) {
                        this.player.inventory.push(item);
                        this.showNotification(`Picked up: ${item.name}`);

                        // Quest progress
                        if (this.quests.active) {
                            this.quests.active.objectives.forEach(obj => {
                                if (obj.requireItem === item.type && !obj.complete) {
                                    obj.complete = true;
                                    this.showNotification('OBJECTIVE COMPLETE');
                                }
                            });
                        }
                    } else {
                        this.showNotification('Inventory full!');
                        item.pickedUp = false;
                        return;
                    }
                }

                // Remove from world
                const index = this.world.items.indexOf(item);
                if (index > -1) {
                    this.world.items.splice(index, 1);
                }

                this.updateHUD();
            },

            calculateWeight() {
                return this.player.inventory.reduce((sum, item) => sum + (item.weight || 0), 0);
            },

            addXP(amount) {
                this.player.xp += amount;

                const xpNeeded = this.getXPForLevel(this.player.level + 1);
                if (this.player.xp >= xpNeeded) {
                    this.levelUp();
                }

                this.updateHUD();
            },

            getXPForLevel(level) {
                return Math.floor(100 * Math.pow(1.5, level - 1));
            },

            levelUp() {
                this.player.level++;
                this.player.xp = 0;
                this.player.statPoints += 3;
                this.player.skillPoints += 1;

                // Increase max HP and Energy
                this.player.maxHp += 10 + this.player.stats.end * 2;
                this.player.maxEnergy += 5 + this.player.stats.end;
                this.player.hp = this.player.maxHp;
                this.player.energy = this.player.maxEnergy;

                this.showNotification(`LEVEL UP! Now level ${this.player.level}`);
                this.setCinematic(true);

                setTimeout(() => {
                    this.setCinematic(false);
                }, 2000);

                this.updateHUD();
            },

            addStat(stat) {
                if (this.player.statPoints <= 0) return;

                this.player.stats[stat]++;
                this.player.statPoints--;

                // Update derived stats
                this.player.maxHp = 100 + this.player.stats.end * 10;
                this.player.maxEnergy = 100 + this.player.stats.end * 5;
                this.player.maxWeight = 100 + this.player.stats.str * 10;

                this.updateCharacterPanel();
                this.updateHUD();
            },

            unlockSkill(skillId) {
                const skill = this.player.skills[skillId];
                if (!skill) return;
                if (this.player.skillPoints < skill.cost) {
                    this.showNotification('Not enough skill points!');
                    return;
                }

                if (!skill.unlocked) {
                    skill.unlocked = true;
                    skill.level = 1;
                } else if (skill.level < skill.maxLevel) {
                    skill.level++;
                } else {
                    this.showNotification('Skill maxed out!');
                    return;
                }

                this.player.skillPoints -= skill.cost;
                this.showNotification(`Unlocked: ${skillId}`);
                this.updateSkillPanel();
            },

            interact() {
                // Check for nearby NPCs
                this.world.npcs.forEach(npc => {
                    const dist = Math.hypot(this.player.x - npc.x, this.player.y - npc.y);
                    if (dist < 50) {
                        this.showDialogue(npc.dialogue);
                    }
                });
            },

            showDialogue(dialogue) {
                this.dialogue = dialogue;
                this.paused = true;

                const box = document.getElementById('dialogueBox');
                box.classList.add('active');

                document.getElementById('dialogueSpeaker').textContent = dialogue.speaker;
                document.getElementById('dialogueText').textContent = dialogue.text;

                const choicesDiv = document.getElementById('dialogueChoices');
                choicesDiv.innerHTML = '';

                dialogue.choices.forEach(choice => {
                    const btn = document.createElement('div');
                    btn.className = 'dialogue-choice';
                    btn.textContent = choice.text;
                    btn.onclick = () => {
                        this.closeDialogue();
                        if (choice.response) {
                            setTimeout(() => {
                                this.showNotification(dialogue.speaker + ': ' + choice.response);
                            }, 500);
                        }

                        // Quest progress
                        if (this.quests.active) {
                            this.quests.active.objectives.forEach(obj => {
                                if (obj.requireNPC && !obj.complete) {
                                    obj.complete = true;
                                    this.showNotification('OBJECTIVE COMPLETE');
                                }
                            });
                        }
                    };
                    choicesDiv.appendChild(btn);
                });
            },

            closeDialogue() {
                document.getElementById('dialogueBox').classList.remove('active');
                this.dialogue = null;
                this.paused = false;
            },

            showDamageNumber(x, y, damage, isCrit) {
                const screenX = x - this.world.camera.x;
                const screenY = y - this.world.camera.y;

                const div = document.createElement('div');
                div.className = 'damage-number' + (isCrit ? ' crit' : '');
                div.textContent = Math.floor(damage);
                div.style.left = screenX + 'px';
                div.style.top = screenY + 'px';

                document.body.appendChild(div);

                setTimeout(() => {
                    div.remove();
                }, 1000);
            },

            showNotification(text) {
                const div = document.createElement('div');
                div.className = 'notification';
                div.textContent = text;

                document.getElementById('notifications').appendChild(div);

                setTimeout(() => {
                    div.remove();
                }, 3000);
            },

            screenShake() {
                const intensity = 5;
                const duration = 200;
                const startTime = Date.now();

                const shake = () => {
                    const elapsed = Date.now() - startTime;
                    if (elapsed > duration) {
                        this.canvas.style.transform = '';
                        return;
                    }

                    const x = (Math.random() - 0.5) * intensity;
                    const y = (Math.random() - 0.5) * intensity;
                    this.canvas.style.transform = `translate(${x}px, ${y}px)`;

                    requestAnimationFrame(shake);
                };

                shake();
            },

            setCinematic(active) {
                this.cinematic = active;
                const tops = document.querySelectorAll('.letterbox.top');
                const bottoms = document.querySelectorAll('.letterbox.bottom');

                tops.forEach(el => el.classList.toggle('active', active));
                bottoms.forEach(el => el.classList.toggle('active', active));
            },

            togglePanel(panelId) {
                const panel = document.getElementById(panelId);
                const isActive = panel.classList.contains('active');

                this.closeAllPanels();

                if (!isActive) {
                    panel.classList.add('active');
                    this.paused = true;

                    // Update panel content
                    if (panelId === 'inventoryPanel') this.updateInventoryPanel();
                    if (panelId === 'characterPanel') this.updateCharacterPanel();
                    if (panelId === 'skillPanel') this.updateSkillPanel();
                    if (panelId === 'questPanel') this.updateQuestPanel();
                }
            },

            closePanel(panelId) {
                document.getElementById(panelId).classList.remove('active');
                this.paused = false;
            },

            closeAllPanels() {
                document.querySelectorAll('.panel').forEach(panel => {
                    panel.classList.remove('active');
                });
                this.paused = false;
            },

            updateHUD() {
                // HP
                const hpPct = (this.player.hp / this.player.maxHp) * 100;
                document.getElementById('hpBar').style.width = hpPct + '%';
                document.getElementById('hpText').textContent = `${Math.floor(this.player.hp)} / ${this.player.maxHp}`;

                // Energy
                const energyPct = (this.player.energy / this.player.maxEnergy) * 100;
                document.getElementById('energyBar').style.width = energyPct + '%';
                document.getElementById('energyText').textContent = `${Math.floor(this.player.energy)} / ${this.player.maxEnergy}`;

                // XP
                const xpNeeded = this.getXPForLevel(this.player.level + 1);
                const xpPct = (this.player.xp / xpNeeded) * 100;
                document.getElementById('xpBar').style.width = xpPct + '%';
                document.getElementById('xpText').textContent = `${Math.floor(this.player.xp)} / ${xpNeeded}`;

                // Level and credits
                document.getElementById('levelDisplay').textContent = this.player.level;
                document.getElementById('creditsDisplay').textContent = this.player.credits;
            },

            updateInventoryPanel() {
                document.getElementById('invCredits').textContent = this.player.credits;
                document.getElementById('invWeight').textContent = Math.floor(this.calculateWeight());
                document.getElementById('invMaxWeight').textContent = this.player.maxWeight;

                // Equipment slots
                const equipDiv = document.getElementById('equipmentSlots');
                equipDiv.innerHTML = '';

                ['weapon', 'armor', 'implant', 'accessory'].forEach(slot => {
                    const slotDiv = document.createElement('div');
                    slotDiv.className = 'equipment-slot';

                    const item = this.player.equipment[slot];
                    if (item) {
                        slotDiv.classList.add('equipped');
                        slotDiv.innerHTML = `
                            <div style="color: #ff00ff; font-weight: bold;">${slot.toUpperCase()}</div>
                            <div style="color: #0ff; margin: 5px 0;">${item.name}</div>
                            <div style="color: #888; font-size: 11px;">${this.getItemStats(item)}</div>
                            <button class="btn" onclick="game.unequipItem('${slot}')">UNEQUIP</button>
                        `;
                    } else {
                        slotDiv.innerHTML = `
                            <div style="color: #666; font-weight: bold;">${slot.toUpperCase()}</div>
                            <div style="color: #444; margin: 5px 0;">Empty</div>
                        `;
                    }

                    equipDiv.appendChild(slotDiv);
                });

                // Inventory grid
                const gridDiv = document.getElementById('inventoryGrid');
                gridDiv.innerHTML = '';

                this.player.inventory.forEach((item, index) => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'inventory-slot';
                    itemDiv.innerHTML = `
                        <div class="item-name">${item.name}</div>
                        <div class="item-stats">${this.getItemStats(item)}</div>
                    `;
                    itemDiv.onclick = () => this.useItem(index);
                    gridDiv.appendChild(itemDiv);
                });

                // Add empty slots
                for (let i = this.player.inventory.length; i < 20; i++) {
                    const emptyDiv = document.createElement('div');
                    emptyDiv.className = 'inventory-slot empty';
                    emptyDiv.textContent = '---';
                    gridDiv.appendChild(emptyDiv);
                }
            },

            getItemStats(item) {
                if (item.damage) return `DMG: ${item.damage}`;
                if (item.defense) return `DEF: ${item.defense}`;
                if (item.statBonus) return `+${item.statBonus.amount} ${item.statBonus.stat.toUpperCase()}`;
                if (item.effect) return `HP: +${item.effect.hp || 0}, EN: +${item.effect.energy || 0}`;
                return `Value: ${item.value}¥`;
            },

            useItem(index) {
                const item = this.player.inventory[index];
                if (!item) return;

                if (item.type === 'weapon' || item.type === 'armor' || item.type === 'implant' || item.type === 'accessory') {
                    this.equipItem(index);
                } else if (item.type === 'consumable') {
                    this.consumeItem(index);
                }
            },

            equipItem(index) {
                const item = this.player.inventory[index];
                const slot = item.type === 'weapon' ? 'weapon' :
                           item.type === 'armor' ? 'armor' :
                           item.type === 'implant' ? 'implant' : 'accessory';

                // Unequip current
                if (this.player.equipment[slot]) {
                    this.player.inventory.push(this.player.equipment[slot]);
                }

                // Equip new
                this.player.equipment[slot] = item;
                this.player.inventory.splice(index, 1);

                this.showNotification(`Equipped: ${item.name}`);
                this.updateInventoryPanel();
            },

            unequipItem(slot) {
                const item = this.player.equipment[slot];
                if (!item) return;

                const weight = this.calculateWeight() + item.weight;
                if (weight > this.player.maxWeight) {
                    this.showNotification('Inventory full!');
                    return;
                }

                this.player.inventory.push(item);
                this.player.equipment[slot] = null;

                this.showNotification(`Unequipped: ${item.name}`);
                this.updateInventoryPanel();
            },

            consumeItem(index) {
                const item = this.player.inventory[index];
                if (!item || !item.effect) return;

                if (item.effect.hp) {
                    this.player.hp = Math.min(this.player.maxHp, this.player.hp + item.effect.hp);
                }
                if (item.effect.energy) {
                    this.player.energy = Math.min(this.player.maxEnergy, this.player.energy + item.effect.energy);
                }

                this.player.inventory.splice(index, 1);
                this.showNotification(`Used: ${item.name}`);
                this.updateInventoryPanel();
                this.updateHUD();
            },

            updateCharacterPanel() {
                document.getElementById('statSTR').textContent = this.player.stats.str;
                document.getElementById('statDEX').textContent = this.player.stats.dex;
                document.getElementById('statINT').textContent = this.player.stats.int;
                document.getElementById('statCHA').textContent = this.player.stats.cha;
                document.getElementById('statEND').textContent = this.player.stats.end;

                const pointsContainer = document.getElementById('statPointsContainer');
                if (this.player.statPoints > 0) {
                    pointsContainer.style.display = 'block';
                    document.getElementById('statPointsAvailable').textContent = this.player.statPoints;
                } else {
                    pointsContainer.style.display = 'none';
                }

                // Reputation
                const repDiv = document.getElementById('reputationDisplay');
                repDiv.innerHTML = '';

                Object.keys(this.player.reputation).forEach(faction => {
                    const rep = this.player.reputation[faction];
                    const div = document.createElement('div');
                    div.className = 'faction-rep';
                    div.innerHTML = `
                        <div style="color: #0ff;">${faction.toUpperCase()}</div>
                        <div class="rep-bar-container">
                            <div class="rep-bar">
                                <div class="rep-fill" style="width: ${Math.max(0, Math.min(100, rep))}%"></div>
                            </div>
                            <div style="color: #888; font-size: 11px; margin-top: 3px;">${rep} / 100</div>
                        </div>
                    `;
                    repDiv.appendChild(div);
                });
            },

            updateSkillPanel() {
                document.getElementById('skillPointsDisplay').textContent = this.player.skillPoints;

                const treeDiv = document.getElementById('skillTree');
                treeDiv.innerHTML = '';

                const categories = {
                    'COMBAT': ['combat_combo', 'combat_crit', 'combat_berserk'],
                    'HACKING': ['hack_doors', 'hack_cameras', 'hack_emp'],
                    'STEALTH': ['stealth_sneak', 'stealth_backstab', 'stealth_cloak'],
                    'SOCIAL': ['social_bribe', 'social_persuade']
                };

                Object.keys(categories).forEach(cat => {
                    const catDiv = document.createElement('div');
                    catDiv.className = 'skill-category';
                    catDiv.innerHTML = `<h3>${cat}</h3>`;

                    categories[cat].forEach(skillId => {
                        const skill = this.player.skills[skillId];
                        const skillDiv = document.createElement('div');
                        skillDiv.className = 'skill-item';

                        if (skill.unlocked) {
                            skillDiv.classList.add('unlocked');
                        } else if (this.player.skillPoints < skill.cost) {
                            skillDiv.classList.add('locked');
                        }

                        const name = skillId.replace(/_/g, ' ').toUpperCase();
                        const level = skill.unlocked ? ` (${skill.level}/${skill.maxLevel})` : '';

                        skillDiv.innerHTML = `
                            <div style="font-weight: bold; margin-bottom: 5px;">${name}${level}</div>
                            <div style="font-size: 11px; color: #888;">Cost: ${skill.cost} SP</div>
                        `;

                        if (this.player.skillPoints >= skill.cost && skill.level < skill.maxLevel) {
                            skillDiv.onclick = () => this.unlockSkill(skillId);
                        }

                        catDiv.appendChild(skillDiv);
                    });

                    treeDiv.appendChild(catDiv);
                });
            },

            updateQuestPanel() {
                const logDiv = document.getElementById('questLog');
                logDiv.innerHTML = '';

                // Active quest
                if (this.quests.active) {
                    const div = document.createElement('div');
                    div.style.cssText = 'background: rgba(0, 255, 255, 0.1); border: 2px solid #0ff; padding: 15px; margin-bottom: 15px; border-radius: 4px;';
                    div.innerHTML = `
                        <div style="color: #0ff; font-size: 18px; font-weight: bold; margin-bottom: 10px;">ACTIVE: ${this.quests.active.title}</div>
                        <div style="color: #888; margin-bottom: 10px;">${this.quests.active.description}</div>
                        <div style="color: #ffff00;">Reward: ${this.quests.active.reward.xp} XP, ${this.quests.active.reward.credits}¥</div>
                    `;
                    logDiv.appendChild(div);
                }

                // Completed quests
                if (this.quests.completed.length > 0) {
                    const header = document.createElement('h3');
                    header.textContent = 'COMPLETED';
                    header.style.color = '#0f0';
                    logDiv.appendChild(header);

                    this.quests.completed.forEach(quest => {
                        const div = document.createElement('div');
                        div.style.cssText = 'background: rgba(0, 255, 0, 0.1); border: 1px solid #0f0; padding: 10px; margin-bottom: 5px; border-radius: 4px;';
                        div.innerHTML = `
                            <div style="color: #0f0; font-weight: bold;">${quest.title}</div>
                            <div style="color: #666; font-size: 11px;">${quest.description}</div>
                        `;
                        logDiv.appendChild(div);
                    });
                }
            },

            render() {
                const ctx = this.ctx;
                const camera = this.world.camera;

                // Clear
                ctx.fillStyle = this.getSkyColor();
                ctx.fillRect(0, 0, this.width, this.height);

                // Render buildings
                this.world.buildings.forEach(building => {
                    const x = building.x - camera.x;
                    const y = building.y - camera.y;

                    // Only render if on screen
                    if (x + building.width < 0 || x > this.width || y + building.height < 0 || y > this.height) {
                        return;
                    }

                    // Building body
                    ctx.fillStyle = '#111';
                    ctx.fillRect(x, y, building.width, building.height);

                    // Windows
                    const windowSize = 4;
                    const windowSpacing = 8;
                    for (let floor = 0; floor < building.floors; floor++) {
                        for (let i = 0; i < building.width / windowSpacing; i++) {
                            const wx = x + i * windowSpacing + 2;
                            const wy = y + floor * (building.height / building.floors) + 5;

                            const lit = Math.random() > 0.3;
                            ctx.fillStyle = lit ? building.color : '#222';
                            ctx.fillRect(wx, wy, windowSize, windowSize);

                            if (lit && building.hasNeon) {
                                ctx.shadowBlur = 10;
                                ctx.shadowColor = building.color;
                                ctx.fillStyle = building.color;
                                ctx.fillRect(wx, wy, windowSize, windowSize);
                                ctx.shadowBlur = 0;
                            }
                        }
                    }

                    // Neon sign
                    if (building.hasNeon && this.isNight()) {
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = building.color;
                        ctx.strokeStyle = building.color;
                        ctx.lineWidth = 3;
                        ctx.strokeRect(x + 5, y + 5, building.width - 10, 15);
                        ctx.shadowBlur = 0;
                    }

                    // Outline
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x, y, building.width, building.height);
                });

                // Render items
                this.world.items.forEach(item => {
                    if (item.pickedUp) return;

                    const x = item.x - camera.x;
                    const y = item.y - camera.y;

                    ctx.shadowBlur = 10;
                    ctx.shadowColor = item.color;
                    ctx.fillStyle = item.color;
                    ctx.beginPath();
                    ctx.arc(x, y, item.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;

                    // Pulsing effect
                    const pulse = Math.sin(Date.now() * 0.005) * 0.3 + 0.7;
                    ctx.globalAlpha = pulse;
                    ctx.strokeStyle = item.color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(x, y, item.size + 5, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                });

                // Render NPCs
                this.world.npcs.forEach(npc => {
                    const x = npc.x - camera.x;
                    const y = npc.y - camera.y;

                    ctx.fillStyle = npc.color;
                    ctx.beginPath();
                    ctx.arc(x, y, npc.size, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Quest marker
                    if (npc.hasQuest) {
                        ctx.fillStyle = '#ffff00';
                        ctx.font = 'bold 20px monospace';
                        ctx.fillText('!', x - 5, y - 15);
                    }
                });

                // Render enemies
                this.world.enemies.forEach(enemy => {
                    const x = enemy.x - camera.x;
                    const y = enemy.y - camera.y;

                    // Enemy body
                    ctx.fillStyle = enemy.color;
                    ctx.beginPath();
                    ctx.arc(x, y, enemy.size, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // HP bar
                    const hpWidth = 30;
                    const hpHeight = 4;
                    const hpPct = enemy.hp / enemy.maxHp;

                    ctx.fillStyle = '#f00';
                    ctx.fillRect(x - hpWidth / 2, y - enemy.size - 10, hpWidth, hpHeight);

                    ctx.fillStyle = '#0f0';
                    ctx.fillRect(x - hpWidth / 2, y - enemy.size - 10, hpWidth * hpPct, hpHeight);

                    // State indicator
                    if (enemy.state === 'chase' || enemy.state === 'attack') {
                        ctx.strokeStyle = '#ff0000';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(x, y, enemy.size + 5, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                });

                // Render player
                const px = this.player.x - camera.x;
                const py = this.player.y - camera.y;

                ctx.save();
                ctx.translate(px, py);
                ctx.rotate(this.player.angle);

                // Player body
                if (this.player.state === 'dodging') {
                    ctx.globalAlpha = 0.5;
                }

                ctx.fillStyle = '#00ffff';
                ctx.fillRect(-this.player.size / 2, -this.player.size / 2, this.player.size, this.player.size);

                // Direction indicator
                ctx.fillStyle = '#ff00ff';
                ctx.beginPath();
                ctx.moveTo(this.player.size / 2, 0);
                ctx.lineTo(this.player.size, -5);
                ctx.lineTo(this.player.size, 5);
                ctx.fill();

                ctx.globalAlpha = 1;
                ctx.restore();

                // Attack visual
                if (this.player.state === 'attacking') {
                    ctx.strokeStyle = '#ff0080';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(px, py, 50, this.player.angle - 0.5, this.player.angle + 0.5);
                    ctx.stroke();
                }

                // Render particles
                this.world.particles.forEach(p => {
                    const x = p.x - camera.x;
                    const y = p.y - camera.y;

                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = p.color;
                    ctx.fillRect(x, y, p.size, p.size);
                });
                ctx.globalAlpha = 1;

                // Rain effect
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 50; i++) {
                    const x = Math.random() * this.width;
                    const y = Math.random() * this.height;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x - 2, y + 20);
                    ctx.stroke();
                }

                // Render minimap
                this.renderMinimap();
            },

            renderMinimap() {
                const ctx = this.minimapCtx;
                const size = this.minimap.width;
                const scale = size / this.WORLD_SIZE;

                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, size, size);

                // Districts
                this.world.districts.forEach(district => {
                    ctx.fillStyle = district.color + '22';
                    ctx.fillRect(district.x * scale, district.y * scale, this.DISTRICT_SIZE * scale, this.DISTRICT_SIZE * scale);
                });

                // Buildings
                ctx.fillStyle = '#333';
                this.world.buildings.forEach(building => {
                    ctx.fillRect(building.x * scale, building.y * scale, Math.max(2, building.width * scale), Math.max(2, building.height * scale));
                });

                // Enemies
                ctx.fillStyle = '#ff0000';
                this.world.enemies.forEach(enemy => {
                    ctx.fillRect(enemy.x * scale - 1, enemy.y * scale - 1, 3, 3);
                });

                // Quest objectives
                if (this.quests.active) {
                    this.quests.active.objectives.forEach(obj => {
                        if (obj.location && !obj.complete) {
                            ctx.fillStyle = '#ffff00';
                            ctx.beginPath();
                            ctx.arc(obj.location.x * scale, obj.location.y * scale, 4, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    });
                }

                // Player
                ctx.fillStyle = '#00ffff';
                ctx.beginPath();
                ctx.arc(this.player.x * scale, this.player.y * scale, 3, 0, Math.PI * 2);
                ctx.fill();

                // View cone
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.player.x * scale, this.player.y * scale);
                ctx.lineTo((this.player.x + Math.cos(this.player.angle - 0.5) * 100) * scale, (this.player.y + Math.sin(this.player.angle - 0.5) * 100) * scale);
                ctx.lineTo((this.player.x + Math.cos(this.player.angle + 0.5) * 100) * scale, (this.player.y + Math.sin(this.player.angle + 0.5) * 100) * scale);
                ctx.closePath();
                ctx.stroke();
            },

            getSkyColor() {
                const t = this.world.time;
                if (t < 0.25) {
                    // Night to dawn
                    return `rgb(${Math.floor(10 + t * 4 * 40)}, ${Math.floor(0 + t * 4 * 20)}, ${Math.floor(21 + t * 4 * 30)})`;
                } else if (t < 0.5) {
                    // Day
                    return '#1a1040';
                } else if (t < 0.75) {
                    // Dusk
                    const dt = (t - 0.5) * 4;
                    return `rgb(${Math.floor(50 - dt * 40)}, ${Math.floor(20 - dt * 20)}, ${Math.floor(51 - dt * 30)})`;
                } else {
                    // Night
                    return '#0a0015';
                }
            },

            isNight() {
                return this.world.time > 0.75 || this.world.time < 0.25;
            },

            checkCollision(a, b) {
                return a.x < b.x + b.width &&
                       a.x + a.size > b.x &&
                       a.y < b.y + b.height &&
                       a.y + a.size > b.y;
            },

            gameOver() {
                this.showNotification('GAME OVER');
                this.setCinematic(true);

                setTimeout(() => {
                    if (confirm('Game Over! Try again?')) {
                        this.loadGame();
                    } else {
                        document.getElementById('mainMenu').classList.remove('hidden');
                        this.setCinematic(false);
                    }
                }, 2000);
            },

            newGame() {
                document.getElementById('mainMenu').classList.add('hidden');
                this.player.x = 200;
                this.player.y = 200;
                this.player.hp = this.player.maxHp;
                this.player.energy = this.player.maxEnergy;
                this.updateHUD();
                this.gameLoop();
            },

            saveGame() {
                const saveData = {
                    player: this.player,
                    world: {
                        time: this.world.time,
                        buildings: this.world.buildings,
                        enemies: this.world.enemies.map(e => ({ ...e, patrolPoints: [] })), // Simplify
                        items: this.world.items
                    },
                    quests: this.quests
                };

                try {
                    localStorage.setItem('neonDistrictSave', JSON.stringify(saveData));
                } catch (e) {
                    console.error('Save failed:', e);
                }
            },

            loadGame() {
                try {
                    const saveData = localStorage.getItem('neonDistrictSave');
                    if (!saveData) {
                        this.newGame();
                        return;
                    }

                    const data = JSON.parse(saveData);
                    this.player = data.player;
                    this.world.time = data.world.time;
                    this.world.buildings = data.world.buildings;
                    this.world.enemies = data.world.enemies;
                    this.world.items = data.world.items;
                    this.quests = data.quests;

                    document.getElementById('mainMenu').classList.add('hidden');
                    this.updateHUD();
                    this.updateQuestTracker();
                    this.gameLoop();
                } catch (e) {
                    console.error('Load failed:', e);
                    this.newGame();
                }
            },

            gameLoop() {
                this.update();
                this.render();
                requestAnimationFrame(() => this.gameLoop());
            }
        };

        // Initialize when page loads
        window.addEventListener('load', () => {
            game.init();
        });
    </script>
</body>
</html>