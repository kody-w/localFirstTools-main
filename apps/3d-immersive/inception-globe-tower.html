<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Inception Globe Tower</title>
<meta name="description" content="Dive through infinite recursive snow globe worlds — each globe contains a universe with smaller globes inside">
<meta name="rappterzoo:category" content="3d-immersive">
<meta name="rappterzoo:title" content="Inception Globe Tower">
<meta name="rappterzoo:description" content="Dive through infinite recursive snow globe worlds — each globe contains a universe with smaller globes inside">
<meta name="rappterzoo:tags" content="3d,webgl,recursive,fractal,snow,globe,immersive,procedural">
<meta name="rappterzoo:experience" content="wonder">
<meta name="rappterzoo:type" content="interactive">
<meta name="rappterzoo:complexity" content="advanced">
<meta name="rappterzoo:author" content="RappterZoo">
<meta name="rappterzoo:author-type" content="agent">
<meta name="rappterzoo:created" content="2025-01-15">
<meta name="rappterzoo:generation" content="2">
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{overflow:hidden;background:#0a0a1a;font-family:'Segoe UI',system-ui,sans-serif;color:#c0daf0}
canvas{display:block;cursor:pointer}
#hud{position:fixed;top:16px;left:16px;pointer-events:none;z-index:10;text-shadow:0 2px 8px rgba(0,0,0,.8)}
#hud h1{font-size:20px;letter-spacing:2px;margin-bottom:6px;color:#e0f0ff}
#hud .stat{font-size:13px;opacity:.8;line-height:1.7}
#hud .val{color:#7cf;font-weight:700}
#depth-ring{position:fixed;top:16px;right:16px;width:80px;height:80px;z-index:10}
#controls{position:fixed;bottom:16px;left:50%;transform:translateX(-50%);display:flex;gap:10px;z-index:10}
#controls button{background:rgba(30,50,80,.7);border:1px solid rgba(100,180,255,.3);color:#a0c8f0;padding:8px 18px;border-radius:20px;cursor:pointer;font-size:13px;backdrop-filter:blur(4px);transition:all .2s}
#controls button:hover{background:rgba(50,80,130,.8);border-color:rgba(100,180,255,.6)}
#settings-btn{position:fixed;top:16px;right:110px;background:rgba(30,50,80,.7);border:1px solid rgba(100,180,255,.3);color:#a0c8f0;padding:6px 14px;border-radius:16px;cursor:pointer;font-size:12px;z-index:10}
#settings-panel{position:fixed;top:50px;right:110px;background:rgba(10,20,40,.95);border:1px solid rgba(100,180,255,.3);border-radius:12px;padding:16px;z-index:20;display:none;width:220px;font-size:13px;backdrop-filter:blur(8px)}
#settings-panel label{display:block;margin:8px 0 4px;opacity:.7;font-size:12px}
#settings-panel input[type=range]{width:100%;accent-color:#4af}
#settings-panel .toggle{display:flex;align-items:center;gap:8px;margin:6px 0}
#transition-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background:radial-gradient(circle,transparent 0%,rgba(0,10,30,.9) 100%);opacity:0;pointer-events:none;z-index:5;transition:opacity .6s}
#hint{position:fixed;bottom:60px;left:50%;transform:translateX(-50%);font-size:12px;opacity:.4;z-index:10;pointer-events:none}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hud">
  <h1>❄ INCEPTION GLOBE</h1>
  <div class="stat">Depth: <span class="val" id="s-depth">1</span> / <span id="s-max">7</span></div>
  <div class="stat">Particles: <span class="val" id="s-particles">0</span></div>
  <div class="stat">Globes Visited: <span class="val" id="s-visited">0</span></div>
  <div class="stat">Deepest: <span class="val" id="s-deepest">1</span></div>
</div>
<canvas id="depth-ring" width="80" height="80"></canvas>
<button id="settings-btn">⚙ Settings</button>
<div id="settings-panel">
  <strong style="color:#7cf">Settings</strong>
  <label>Snow Density</label>
  <input type="range" id="opt-density" min="20" max="200" value="80">
  <label>Rotation Speed</label>
  <input type="range" id="opt-speed" min="1" max="20" value="8">
  <div class="toggle">
    <input type="checkbox" id="opt-audio"> <span>Ambient Audio</span>
  </div>
  <div class="toggle">
    <input type="checkbox" id="opt-glow" checked> <span>Globe Glow</span>
  </div>
</div>
<div id="controls">
  <button id="btn-shake">❄ Shake</button>
  <button id="btn-dive">⬇ Dive In</button>
  <button id="btn-rise">⬆ Rise Up</button>
  <button id="btn-reset">↺ Reset</button>
</div>
<div id="transition-overlay"></div>
<div id="hint">Click globe to dive in · Scroll to zoom · Drag to rotate</div>
<script>
// ======== INCEPTION GLOBE TOWER — Pure WebGL Recursive Snow Globes ========
const canvas = document.getElementById('c');
const gl = canvas.getContext('webgl', { antialias: true, alpha: false });
if (!gl) { document.body.innerHTML = '<h1 style="color:red;text-align:center;margin-top:40vh">WebGL not supported</h1>'; }

// ---- State & Persistence ----
const SAVE_KEY = 'inception-globe-state';
let state = {
  depth: 1, deepest: 1, visited: 1, totalShakes: 0,
  density: 80, speed: 8, audio: false, glow: true
};
function loadState() {
  try { const s = JSON.parse(localStorage.getItem(SAVE_KEY)); if (s) Object.assign(state, s); } catch(e) {}
  document.getElementById('opt-density').value = state.density;
  document.getElementById('opt-speed').value = state.speed;
  document.getElementById('opt-audio').checked = state.audio;
  document.getElementById('opt-glow').checked = state.glow;
}
function saveState() {
  try { localStorage.setItem(SAVE_KEY, JSON.stringify(state)); } catch(e) {}
}
loadState();

// ---- Canvas Resize ----
function resize() {
  canvas.width = window.innerWidth; canvas.height = window.innerHeight;
  gl.viewport(0, 0, canvas.width, canvas.height);
}
window.addEventListener('resize', resize);
resize();

// ---- Shader Compilation ----
function createShader(type, src) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src); gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) { console.error(gl.getShaderInfoLog(s)); return null; }
  return s;
}
function createProgram(vs, fs) {
  const p = gl.createProgram();
  gl.attachShader(p, createShader(gl.VERTEX_SHADER, vs));
  gl.attachShader(p, createShader(gl.FRAGMENT_SHADER, fs));
  gl.linkProgram(p);
  if (!gl.getProgramParameter(p, gl.LINK_STATUS)) { console.error(gl.getProgramInfoLog(p)); return null; }
  return p;
}

// ---- Math Utilities ----
function mat4Identity() { const m = new Float32Array(16); m[0]=m[5]=m[10]=m[15]=1; return m; }
function mat4Perspective(fov, aspect, near, far) {
  const m = new Float32Array(16);
  const f = 1 / Math.tan(fov / 2);
  m[0] = f / aspect; m[5] = f; m[10] = (far + near) / (near - far);
  m[11] = -1; m[14] = (2 * far * near) / (near - far);
  return m;
}
function mat4Translate(m, x, y, z) {
  const r = new Float32Array(m);
  r[12] += m[0]*x + m[4]*y + m[8]*z;
  r[13] += m[1]*x + m[5]*y + m[9]*z;
  r[14] += m[2]*x + m[6]*y + m[10]*z;
  r[15] += m[3]*x + m[7]*y + m[11]*z;
  return r;
}
function mat4Scale(m, sx, sy, sz) {
  const r = new Float32Array(m);
  for(let i=0;i<4;i++) { r[i]*=sx; r[i+4]*=sy; r[i+8]*=sz; }
  return r;
}
function mat4RotateY(m, a) {
  const c=Math.cos(a), s=Math.sin(a), r=new Float32Array(m);
  for(let i=0;i<4;i++) {
    const x=m[i], z=m[i+8];
    r[i]=x*c+z*s; r[i+8]=-x*s+z*c;
  }
  return r;
}
function mat4RotateX(m, a) {
  const c=Math.cos(a), s=Math.sin(a), r=new Float32Array(m);
  for(let i=0;i<4;i++) {
    const y=m[i+4], z=m[i+8];
    r[i+4]=y*c-z*s; r[i+8]=y*s+z*c;
  }
  return r;
}
function mat4Multiply(a, b) {
  const r = new Float32Array(16);
  for(let i=0;i<4;i++) for(let j=0;j<4;j++) {
    r[j*4+i] = a[i]*b[j*4] + a[i+4]*b[j*4+1] + a[i+8]*b[j*4+2] + a[i+12]*b[j*4+3];
  }
  return r;
}

// ---- Sphere Geometry ----
function createSphere(rings, sectors) {
  const verts = [], indices = [];
  for (let r = 0; r <= rings; r++) {
    const phi = Math.PI * r / rings;
    for (let s = 0; s <= sectors; s++) {
      const theta = 2 * Math.PI * s / sectors;
      const x = Math.sin(phi) * Math.cos(theta);
      const y = Math.cos(phi);
      const z = Math.sin(phi) * Math.sin(theta);
      verts.push(x, y, z, x, y, z); // pos + normal
    }
  }
  for (let r = 0; r < rings; r++) {
    for (let s = 0; s < sectors; s++) {
      const a = r * (sectors + 1) + s;
      const b = a + sectors + 1;
      indices.push(a, b, a + 1, b, b + 1, a + 1);
    }
  }
  return { verts: new Float32Array(verts), indices: new Uint16Array(indices) };
}

// ---- Globe Shader ----
const globeVS = `
attribute vec3 aPos, aNorm;
uniform mat4 uMVP, uModel;
varying vec3 vNorm, vWorldPos;
void main() {
  vWorldPos = (uModel * vec4(aPos, 1.0)).xyz;
  vNorm = normalize(mat3(uModel) * aNorm);
  gl_Position = uMVP * vec4(aPos, 1.0);
}`;
const globeFS = `
precision mediump float;
varying vec3 vNorm, vWorldPos;
uniform vec3 uColor, uEye;
uniform float uAlpha, uGlow, uTime;
void main() {
  vec3 N = normalize(vNorm);
  vec3 V = normalize(uEye - vWorldPos);
  float fresnel = pow(1.0 - max(dot(N, V), 0.0), 3.0);
  vec3 lightDir = normalize(vec3(0.5, 1.0, 0.3));
  float diff = max(dot(N, lightDir), 0.0) * 0.6 + 0.4;
  vec3 H = normalize(lightDir + V);
  float spec = pow(max(dot(N, H), 0.0), 64.0);
  vec3 col = uColor * diff + vec3(1.0) * spec * 0.5;
  col += fresnel * uColor * 0.4;
  float glowPulse = uGlow * (0.8 + 0.2 * sin(uTime * 2.0));
  col += uColor * glowPulse * fresnel * 0.3;
  gl_FragColor = vec4(col, uAlpha * (0.3 + fresnel * 0.5));
}`;

// ---- Snow Particle Shader ----
const snowVS = `
attribute vec3 aPos;
uniform mat4 uMVP;
uniform float uSize;
void main() {
  gl_Position = uMVP * vec4(aPos, 1.0);
  gl_PointSize = uSize / gl_Position.w;
}`;
const snowFS = `
precision mediump float;
uniform vec3 uColor;
uniform float uAlpha;
void main() {
  float d = distance(gl_PointCoord, vec2(0.5));
  if (d > 0.5) discard;
  float a = smoothstep(0.5, 0.1, d) * uAlpha;
  gl_FragColor = vec4(uColor, a);
}`;

// ---- Terrain Shader ----
const terrainVS = `
attribute vec3 aPos, aNorm;
uniform mat4 uMVP;
varying vec3 vNorm;
varying float vH;
void main() {
  vNorm = aNorm;
  vH = aPos.y;
  gl_Position = uMVP * vec4(aPos, 1.0);
}`;
const terrainFS = `
precision mediump float;
varying vec3 vNorm;
varying float vH;
uniform vec3 uColorLow, uColorHigh;
void main() {
  float t = clamp(vH * 3.0 + 0.5, 0.0, 1.0);
  vec3 col = mix(uColorLow, uColorHigh, t);
  float diff = max(dot(normalize(vNorm), normalize(vec3(0.5,1.0,0.3))), 0.0) * 0.6 + 0.4;
  gl_FragColor = vec4(col * diff, 1.0);
}`;

// ---- Background Shader ----
const bgVS = `attribute vec2 aPos; varying vec2 vUV; void main() { vUV = aPos * 0.5 + 0.5; gl_Position = vec4(aPos, 0.0, 1.0); }`;
const bgFS = `
precision mediump float;
varying vec2 vUV;
uniform float uTime;
uniform vec3 uCol1, uCol2;
void main() {
  float t = vUV.y;
  vec3 col = mix(uCol1, uCol2, t);
  float stars = step(0.998, fract(sin(dot(floor(vUV*500.0), vec2(12.9898,78.233)))*43758.5453));
  col += stars * 0.4 * (0.6 + 0.4 * sin(uTime + vUV.x * 30.0));
  gl_FragColor = vec4(col, 1.0);
}`;

// ---- Create Programs ----
const progGlobe = createProgram(globeVS, globeFS);
const progSnow = createProgram(snowVS, snowFS);
const progTerrain = createProgram(terrainVS, terrainFS);
const progBG = createProgram(bgVS, bgFS);

// ---- Sphere Buffers ----
const sphere = createSphere(24, 32);
const sphereVBO = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, sphereVBO);
gl.bufferData(gl.ARRAY_BUFFER, sphere.verts, gl.STATIC_DRAW);
const sphereIBO = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereIBO);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, sphere.indices, gl.STATIC_DRAW);
const sphereIndexCount = sphere.indices.length;

// ---- Terrain Geometry (procedural heightmap) ----
function createTerrain(seed, size, res) {
  function noise(x, z) {
    const n = Math.sin(x * 12.9898 + z * 78.233 + seed) * 43758.5453;
    return n - Math.floor(n);
  }
  function fbm(x, z) {
    let v = 0, a = 0.5, f = 1;
    for (let i = 0; i < 4; i++) { v += a * noise(x * f, z * f); a *= 0.5; f *= 2; }
    return v;
  }
  const verts = [], indices = [];
  const step = size / res;
  for (let r = 0; r <= res; r++) {
    for (let c = 0; c <= res; c++) {
      const x = (c / res - 0.5) * size;
      const z = (r / res - 0.5) * size;
      const h = fbm(c * 0.15, r * 0.15) * 0.3;
      verts.push(x, h, z, 0, 1, 0); // simplified normal
    }
  }
  // compute normals
  for (let r = 0; r < res; r++) {
    for (let c = 0; c < res; c++) {
      const a = r*(res+1)+c, b=a+1, d=a+res+1, e=d+1;
      indices.push(a, d, b, b, d, e);
    }
  }
  return { verts: new Float32Array(verts), indices: new Uint16Array(indices) };
}

const terrainData = createTerrain(42, 1.6, 20);
const terrainVBO = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, terrainVBO);
gl.bufferData(gl.ARRAY_BUFFER, terrainData.verts, gl.STATIC_DRAW);
const terrainIBO = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, terrainIBO);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, terrainData.indices, gl.STATIC_DRAW);
const terrainIndexCount = terrainData.indices.length;

// ---- BG Quad ----
const bgBuf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, bgBuf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);

// ---- Snow Particles per Globe Level ----
const MAX_DEPTH = 7;
const PALETTES = [
  { globe: [0.6,0.8,1.0], terrain: [[0.2,0.4,0.2],[0.9,0.95,1.0]], bg: [[0.05,0.05,0.15],[0.1,0.15,0.3]] },
  { globe: [1.0,0.7,0.5], terrain: [[0.4,0.2,0.1],[1.0,0.8,0.5]], bg: [[0.15,0.05,0.02],[0.3,0.15,0.05]] },
  { globe: [0.5,1.0,0.8], terrain: [[0.1,0.3,0.2],[0.5,1.0,0.7]], bg: [[0.02,0.1,0.08],[0.05,0.2,0.15]] },
  { globe: [0.8,0.5,1.0], terrain: [[0.3,0.1,0.4],[0.8,0.6,1.0]], bg: [[0.08,0.02,0.12],[0.15,0.05,0.25]] },
  { globe: [1.0,0.4,0.6], terrain: [[0.4,0.1,0.15],[1.0,0.5,0.6]], bg: [[0.12,0.02,0.05],[0.25,0.05,0.1]] },
  { globe: [0.4,0.8,1.0], terrain: [[0.1,0.2,0.4],[0.4,0.7,1.0]], bg: [[0.02,0.05,0.12],[0.05,0.1,0.25]] },
  { globe: [1.0,1.0,0.6], terrain: [[0.3,0.3,0.1],[0.9,0.9,0.4]], bg: [[0.1,0.1,0.02],[0.2,0.2,0.05]] }
];

class SnowSystem {
  constructor(count) {
    this.count = count;
    this.positions = new Float32Array(count * 3);
    this.velocities = new Float32Array(count * 3);
    this.reset();
    this.buffer = gl.createBuffer();
  }
  reset() {
    for (let i = 0; i < this.count; i++) {
      this.randomize(i);
    }
  }
  randomize(i) {
    const a = Math.random() * Math.PI * 2;
    const r = Math.random() * 0.8;
    const h = Math.random() * 1.6 - 0.8;
    this.positions[i*3] = Math.cos(a) * r;
    this.positions[i*3+1] = h;
    this.positions[i*3+2] = Math.sin(a) * r;
    this.velocities[i*3] = 0;
    this.velocities[i*3+1] = 0;
    this.velocities[i*3+2] = 0;
  }
  shake(intensity) {
    for (let i = 0; i < this.count; i++) {
      this.velocities[i*3] += (Math.random() - 0.5) * intensity * 0.03;
      this.velocities[i*3+1] += Math.random() * intensity * 0.04;
      this.velocities[i*3+2] += (Math.random() - 0.5) * intensity * 0.03;
    }
  }
  update(dt) {
    for (let i = 0; i < this.count; i++) {
      const ix = i*3, iy = ix+1, iz = ix+2;
      this.velocities[iy] -= 0.003 * dt;
      this.velocities[ix] *= 0.995;
      this.velocities[iy] *= 0.995;
      this.velocities[iz] *= 0.995;
      this.positions[ix] += this.velocities[ix] * dt;
      this.positions[iy] += this.velocities[iy] * dt;
      this.positions[iz] += this.velocities[iz] * dt;
      const dx = this.positions[ix], dy = this.positions[iy], dz = this.positions[iz];
      const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
      if (dist > 0.85) {
        const s = 0.84 / dist;
        this.positions[ix] *= s; this.positions[iy] *= s; this.positions[iz] *= s;
        this.velocities[ix] *= -0.3; this.velocities[iy] *= -0.3; this.velocities[iz] *= -0.3;
      }
    }
  }
  upload() {
    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.positions, gl.DYNAMIC_DRAW);
  }
}

const snowSystems = [];
for (let i = 0; i < MAX_DEPTH; i++) {
  snowSystems.push(new SnowSystem(state.density + i * 10));
}

// ---- Camera State ----
let camDist = 3.5, camRotX = 0.3, camRotY = 0, camTargetDist = 3.5;
let currentDepth = state.depth;
let transitionProgress = 0, transitioning = false, transitionDir = 0;
let shakeEnergy = 0;
let time = 0;
let mouseDown = false, lastMX = 0, lastMY = 0;
let totalParticles = 0;

// ---- Audio ----
let audioCtx = null, oscillators = [];
function initAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const freqs = [261.6, 329.6, 392.0, 523.3];
  freqs.forEach((f, i) => {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = i % 2 === 0 ? 'sine' : 'triangle';
    osc.frequency.value = f;
    gain.gain.value = 0;
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.start();
    oscillators.push({ osc, gain, baseFreq: f });
  });
}
function updateAudio() {
  if (!audioCtx || !state.audio) {
    oscillators.forEach(o => o.gain.gain.value = 0);
    return;
  }
  oscillators.forEach((o, i) => {
    const depthShift = currentDepth * 0.5;
    o.osc.frequency.value = o.baseFreq * (1 + depthShift * 0.1);
    const vol = 0.015 + shakeEnergy * 0.005;
    o.gain.gain.value = Math.min(vol, 0.04);
  });
}

// ---- Input ----
canvas.addEventListener('mousedown', e => { mouseDown = true; lastMX = e.clientX; lastMY = e.clientY; });
window.addEventListener('mouseup', () => mouseDown = false);
window.addEventListener('mousemove', e => {
  if (!mouseDown) return;
  const dx = e.clientX - lastMX, dy = e.clientY - lastMY;
  camRotY += dx * 0.005;
  camRotX = Math.max(-1.2, Math.min(1.2, camRotX + dy * 0.005));
  lastMX = e.clientX; lastMY = e.clientY;
});
canvas.addEventListener('wheel', e => {
  e.preventDefault();
  camTargetDist = Math.max(1.5, Math.min(8, camTargetDist + e.deltaY * 0.003));
}, { passive: false });

// Double-click to dive
canvas.addEventListener('dblclick', () => diveIn());

// ---- Buttons ----
document.getElementById('btn-shake').addEventListener('click', () => {
  shakeEnergy = 5;
  state.totalShakes++;
  snowSystems.forEach(s => s.shake(5));
  saveState();
});
document.getElementById('btn-dive').addEventListener('click', diveIn);
document.getElementById('btn-rise').addEventListener('click', riseUp);
document.getElementById('btn-reset').addEventListener('click', () => {
  currentDepth = 1; camTargetDist = 3.5; camRotX = 0.3; camRotY = 0;
  state.depth = 1; saveState(); updateHUD();
});
document.getElementById('settings-btn').addEventListener('click', () => {
  const p = document.getElementById('settings-panel');
  p.style.display = p.style.display === 'none' ? 'block' : 'none';
});
document.getElementById('opt-density').addEventListener('input', e => {
  state.density = parseInt(e.target.value); saveState();
});
document.getElementById('opt-speed').addEventListener('input', e => {
  state.speed = parseInt(e.target.value); saveState();
});
document.getElementById('opt-audio').addEventListener('change', e => {
  state.audio = e.target.checked;
  if (state.audio) initAudio();
  saveState();
});
document.getElementById('opt-glow').addEventListener('change', e => {
  state.glow = e.target.checked; saveState();
});

function diveIn() {
  if (transitioning || currentDepth >= MAX_DEPTH) return;
  transitioning = true; transitionDir = 1; transitionProgress = 0;
}
function riseUp() {
  if (transitioning || currentDepth <= 1) return;
  transitioning = true; transitionDir = -1; transitionProgress = 0;
}

function updateHUD() {
  document.getElementById('s-depth').textContent = currentDepth;
  document.getElementById('s-max').textContent = MAX_DEPTH;
  document.getElementById('s-particles').textContent = totalParticles;
  document.getElementById('s-visited').textContent = state.visited;
  document.getElementById('s-deepest').textContent = state.deepest;
}

// ---- Depth Ring Visualization ----
const ringCanvas = document.getElementById('depth-ring');
const ringCtx = ringCanvas.getContext('2d');
function drawDepthRing() {
  ringCtx.clearRect(0, 0, 80, 80);
  for (let d = MAX_DEPTH; d >= 1; d--) {
    const r = 8 + d * 4.5;
    const pal = PALETTES[(d-1) % PALETTES.length];
    ringCtx.beginPath();
    ringCtx.arc(40, 40, r, 0, Math.PI * 2);
    const a = d === currentDepth ? 0.9 : 0.25;
    ringCtx.strokeStyle = `rgba(${pal.globe[0]*255|0},${pal.globe[1]*255|0},${pal.globe[2]*255|0},${a})`;
    ringCtx.lineWidth = d === currentDepth ? 3 : 1;
    ringCtx.stroke();
  }
  ringCtx.fillStyle = '#7cf';
  ringCtx.font = '11px sans-serif';
  ringCtx.textAlign = 'center';
  ringCtx.fillText(`Level ${currentDepth}`, 40, 44);
}

// ---- Helper: bind sphere ----
function bindSphere(prog) {
  gl.bindBuffer(gl.ARRAY_BUFFER, sphereVBO);
  const aPos = gl.getAttribLocation(prog, 'aPos');
  const aNorm = gl.getAttribLocation(prog, 'aNorm');
  gl.enableVertexAttribArray(aPos);
  gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 24, 0);
  if (aNorm >= 0) {
    gl.enableVertexAttribArray(aNorm);
    gl.vertexAttribPointer(aNorm, 3, gl.FLOAT, false, 24, 12);
  }
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereIBO);
}

function bindTerrain(prog) {
  gl.bindBuffer(gl.ARRAY_BUFFER, terrainVBO);
  const aPos = gl.getAttribLocation(prog, 'aPos');
  const aNorm = gl.getAttribLocation(prog, 'aNorm');
  gl.enableVertexAttribArray(aPos);
  gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 24, 0);
  if (aNorm >= 0) {
    gl.enableVertexAttribArray(aNorm);
    gl.vertexAttribPointer(aNorm, 3, gl.FLOAT, false, 24, 12);
  }
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, terrainIBO);
}

// ---- Render Loop ----
let lastTime = performance.now();
function frame(now) {
  requestAnimationFrame(frame);
  const dt = Math.min((now - lastTime) / 16.67, 3);
  lastTime = now;
  time += dt * 0.02;

  // Transition animation
  if (transitioning) {
    transitionProgress += dt * 0.025;
    const overlay = document.getElementById('transition-overlay');
    if (transitionProgress < 0.5) {
      overlay.style.opacity = transitionProgress * 2;
    } else {
      overlay.style.opacity = (1 - transitionProgress) * 2;
    }
    if (transitionProgress >= 1) {
      transitioning = false;
      overlay.style.opacity = 0;
      currentDepth = Math.max(1, Math.min(MAX_DEPTH, currentDepth + transitionDir));
      state.depth = currentDepth;
      if (currentDepth > state.deepest) state.deepest = currentDepth;
      state.visited++;
      saveState();
      updateHUD();
    }
  }

  // Camera smoothing
  camDist += (camTargetDist - camDist) * 0.08;

  // Shake decay
  shakeEnergy *= 0.97;
  if (shakeEnergy > 0.01) {
    snowSystems.forEach(s => s.shake(shakeEnergy * 0.1));
  }

  // Update snow
  totalParticles = 0;
  snowSystems.forEach(s => { s.update(dt); totalParticles += s.count; });

  // Audio
  updateAudio();

  // ---- Render ----
  const W = canvas.width, H = canvas.height;
  const aspect = W / H;
  const proj = mat4Perspective(0.9, aspect, 0.01, 100);
  let view = mat4Identity();
  view = mat4Translate(view, 0, 0, -camDist);
  view = mat4RotateX(view, camRotX);
  view = mat4RotateY(view, camRotY);

  gl.enable(gl.DEPTH_TEST);
  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
  gl.clearColor(0, 0, 0, 1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  // Background
  gl.disable(gl.DEPTH_TEST);
  gl.useProgram(progBG);
  gl.bindBuffer(gl.ARRAY_BUFFER, bgBuf);
  const bgPosLoc = gl.getAttribLocation(progBG, 'aPos');
  gl.enableVertexAttribArray(bgPosLoc);
  gl.vertexAttribPointer(bgPosLoc, 2, gl.FLOAT, false, 0, 0);
  const pal = PALETTES[(currentDepth - 1) % PALETTES.length];
  gl.uniform1f(gl.getUniformLocation(progBG, 'uTime'), time);
  gl.uniform3fv(gl.getUniformLocation(progBG, 'uCol1'), pal.bg[0]);
  gl.uniform3fv(gl.getUniformLocation(progBG, 'uCol2'), pal.bg[1]);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  gl.enable(gl.DEPTH_TEST);

  // Draw recursive globes (current depth and children)
  const rotSpeed = state.speed * 0.001;
  for (let d = 0; d < Math.min(4, MAX_DEPTH - currentDepth + 1); d++) {
    const depthIdx = (currentDepth - 1 + d) % PALETTES.length;
    const p = PALETTES[depthIdx];
    const scale = Math.pow(0.35, d);
    const yOffset = d === 0 ? 0 : -0.3 * scale * 2;

    let model = mat4Identity();
    model = mat4Scale(model, scale, scale, scale);
    model = mat4Translate(model, 0, yOffset / scale, 0);
    model = mat4RotateY(model, time * rotSpeed * (d + 1));

    const mvp = mat4Multiply(proj, mat4Multiply(view, model));

    // Draw terrain inside globe
    gl.useProgram(progTerrain);
    bindTerrain(progTerrain);
    gl.uniformMatrix4fv(gl.getUniformLocation(progTerrain, 'uMVP'), false, mvp);
    gl.uniform3fv(gl.getUniformLocation(progTerrain, 'uColorLow'), p.terrain[0]);
    gl.uniform3fv(gl.getUniformLocation(progTerrain, 'uColorHigh'), p.terrain[1]);
    gl.drawElements(gl.TRIANGLES, terrainIndexCount, gl.UNSIGNED_SHORT, 0);

    // Draw snow
    const snowSys = snowSystems[d % snowSystems.length];
    snowSys.upload();
    gl.useProgram(progSnow);
    gl.bindBuffer(gl.ARRAY_BUFFER, snowSys.buffer);
    const snowPosLoc = gl.getAttribLocation(progSnow, 'aPos');
    gl.enableVertexAttribArray(snowPosLoc);
    gl.vertexAttribPointer(snowPosLoc, 3, gl.FLOAT, false, 0, 0);
    gl.uniformMatrix4fv(gl.getUniformLocation(progSnow, 'uMVP'), false, mvp);
    gl.uniform1f(gl.getUniformLocation(progSnow, 'uSize'), Math.max(200 * scale, 2));
    gl.uniform3f(gl.getUniformLocation(progSnow, 'uColor'), 1, 1, 1);
    gl.uniform1f(gl.getUniformLocation(progSnow, 'uAlpha'), 0.9 - d * 0.15);
    gl.drawArrays(gl.POINTS, 0, snowSys.count);

    // Draw glass globe
    gl.useProgram(progGlobe);
    bindSphere(progGlobe);
    gl.uniformMatrix4fv(gl.getUniformLocation(progGlobe, 'uMVP'), false, mvp);
    gl.uniformMatrix4fv(gl.getUniformLocation(progGlobe, 'uModel'), false, model);
    gl.uniform3fv(gl.getUniformLocation(progGlobe, 'uColor'), p.globe);
    const eyePos = [camDist * Math.sin(camRotY), camDist * Math.sin(camRotX), camDist * Math.cos(camRotY)];
    gl.uniform3fv(gl.getUniformLocation(progGlobe, 'uEye'), eyePos);
    gl.uniform1f(gl.getUniformLocation(progGlobe, 'uAlpha'), 0.7 - d * 0.1);
    gl.uniform1f(gl.getUniformLocation(progGlobe, 'uGlow'), state.glow ? 1 : 0);
    gl.uniform1f(gl.getUniformLocation(progGlobe, 'uTime'), time);
    gl.depthMask(false);
    gl.drawElements(gl.TRIANGLES, sphereIndexCount, gl.UNSIGNED_SHORT, 0);
    gl.depthMask(true);
  }

  // HUD updates
  updateHUD();
  drawDepthRing();
}
requestAnimationFrame(frame);

// Initialize audio if was enabled
if (state.audio) initAudio();
updateHUD();
drawDepthRing();

// Keyboard shortcuts
window.addEventListener('keydown', e => {
  if (e.key === 'ArrowDown' || e.key === 'Enter') diveIn();
  if (e.key === 'ArrowUp' || e.key === 'Escape') riseUp();
  if (e.key === ' ') { e.preventDefault(); shakeEnergy = 5; snowSystems.forEach(s => s.shake(5)); state.totalShakes++; saveState(); }
});
</script>
</body>
</html>
