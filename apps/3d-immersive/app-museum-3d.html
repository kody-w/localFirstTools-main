<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The App Museum - 3D Experience</title>
    <meta name="description" content="An immersive 3D museum showcasing local-first applications across multiple floors and themed exhibitions">
    <!-- 3d, museum, gallery, immersive, webgl, threejs, exhibition -->
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: #000;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        }
        
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }
        
        #loading.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        #loading h1 {
            font-size: 48px;
            margin-bottom: 20px;
            font-weight: 300;
            letter-spacing: 10px;
        }
        
        #loading-bar {
            width: 300px;
            height: 4px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            overflow: hidden;
        }
        
        #loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        #hud {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #fff;
            z-index: 100;
            pointer-events: none;
        }
        
        #floor-indicator {
            background: rgba(0,0,0,0.6);
            padding: 15px 25px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            margin-bottom: 10px;
        }
        
        #floor-indicator h2 {
            font-size: 24px;
            font-weight: 300;
            margin-bottom: 5px;
        }
        
        #floor-indicator p {
            font-size: 12px;
            opacity: 0.7;
        }
        
        #minimap {
            width: 150px;
            height: 150px;
            background: rgba(0,0,0,0.6);
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.2);
            position: relative;
            overflow: hidden;
        }
        
        #player-dot {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #667eea;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px #667eea;
        }
        
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            z-index: 100;
            pointer-events: none;
        }
        
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255,255,255,0.5);
        }
        
        #crosshair::before {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }
        
        #crosshair::after {
            height: 2px;
            width: 100%;
            top: 50%;
            transform: translateY(-50%);
        }
        
        #info-panel {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 20px 40px;
            border-radius: 15px;
            color: #fff;
            text-align: center;
            z-index: 100;
            backdrop-filter: blur(10px);
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            max-width: 500px;
        }
        
        #info-panel.visible {
            opacity: 1;
            pointer-events: auto;
        }
        
        #info-panel h3 {
            font-size: 20px;
            margin-bottom: 10px;
        }
        
        #info-panel p {
            font-size: 14px;
            opacity: 0.8;
            margin-bottom: 15px;
        }
        
        #info-panel button {
            padding: 10px 30px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            border-radius: 25px;
            color: #fff;
            font-size: 14px;
            cursor: pointer;
            transition: transform 0.2s ease;
        }
        
        #info-panel button:hover {
            transform: scale(1.05);
        }
        
        #controls-help {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.6);
            padding: 15px 20px;
            border-radius: 10px;
            color: #fff;
            font-size: 12px;
            z-index: 100;
            backdrop-filter: blur(10px);
        }
        
        #controls-help div {
            margin: 5px 0;
            opacity: 0.8;
        }
        
        #controls-help kbd {
            background: rgba(255,255,255,0.2);
            padding: 2px 8px;
            border-radius: 4px;
            margin-right: 5px;
        }
        
        #floor-nav {
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .floor-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(0,0,0,0.6);
            border: 2px solid rgba(255,255,255,0.3);
            color: #fff;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }
        
        .floor-btn:hover, .floor-btn.active {
            background: rgba(102, 126, 234, 0.5);
            border-color: #667eea;
        }
        
        #ambient-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.2);
            color: #fff;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            z-index: 100;
            font-size: 12px;
            backdrop-filter: blur(5px);
        }
    </style>
</head>
<body>
    <div id="loading">
        <h1>THE MUSEUM</h1>
        <div id="loading-bar">
            <div id="loading-progress"></div>
        </div>
        <p style="margin-top: 20px; opacity: 0.6">Loading exhibitions...</p>
    </div>
    
    <div id="canvas-container"></div>
    
    <div id="crosshair"></div>
    
    <div id="hud">
        <div id="floor-indicator">
            <h2>Ground Floor</h2>
            <p>Main Lobby</p>
        </div>
        <div id="minimap">
            <div id="player-dot"></div>
        </div>
    </div>
    
    <div id="floor-nav">
        <button class="floor-btn active" data-floor="0">G</button>
        <button class="floor-btn" data-floor="1">1</button>
        <button class="floor-btn" data-floor="2">2</button>
        <button class="floor-btn" data-floor="3">3</button>
    </div>
    
    <div id="info-panel">
        <h3 id="panel-title">App Name</h3>
        <p id="panel-desc">Description</p>
        <button id="launch-btn">Launch App</button>
    </div>
    
    <div id="controls-help">
        <div><kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> Move</div>
        <div><kbd>Mouse</kbd> Look around</div>
        <div><kbd>E</kbd> Interact</div>
        <div><kbd>1-4</kbd> Change floor</div>
        <div><kbd>Click</kbd> Lock pointer</div>
    </div>
    
    <button id="ambient-toggle">Ambient Sound: Off</button>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Museum configuration
        const FLOORS = [
            { 
                name: 'Ground Floor', 
                subtitle: 'Main Lobby & Featured Works',
                color: 0x1a1a2e,
                height: 0,
                exhibitions: ['featured', 'new']
            },
            { 
                name: 'First Floor', 
                subtitle: 'Visual Arts & Creative Tools',
                color: 0x2d1b4e,
                height: 15,
                exhibitions: ['visual', 'creative']
            },
            { 
                name: 'Second Floor', 
                subtitle: 'Games & Interactive Experiences',
                color: 0x1b3d4e,
                height: 30,
                exhibitions: ['games', 'interactive']
            },
            { 
                name: 'Third Floor', 
                subtitle: 'Experimental & AI Gallery',
                color: 0x4e1b2d,
                height: 45,
                exhibitions: ['experimental', 'audio']
            }
        ];
        
        // App data (simplified for demo - would normally load from config)
        const APPS = [
            // Featured
            { name: 'Strange Attractor Hypnosis', desc: 'Mesmerizing chaos visualization', file: 'strange-attractor-hypnosis.html', category: 'featured' },
            { name: 'Emotional Typewriter', desc: 'Words that shape the atmosphere', file: 'emotional-typewriter.html', category: 'featured' },
            { name: 'Infinite Recursive Art', desc: 'Endless fractal patterns', file: 'infinite-recursive-art.html', category: 'featured' },
            { name: 'Whisper Topography', desc: 'Voice creates 3D terrain', file: 'whisper-topography.html', category: 'new' },
            { name: 'Memory Erosion Garden', desc: 'Memories decay into growth', file: 'memory-erosion-garden.html', category: 'new' },
            { name: 'Melting Clock Composer', desc: 'Dali-style ambient music', file: 'melting-clock-composer.html', category: 'new' },
            // Visual
            { name: 'Particle Life Finance', desc: 'Emergent market visualization', file: 'particle-life-finance.html', category: 'visual' },
            { name: 'Doodle to World', desc: 'Transform drawings into worlds', file: 'doodle-to-world.html', category: 'visual' },
            { name: 'Digital Tulpa', desc: 'AI companion visualization', file: 'digital-tulpa.html', category: 'visual' },
            // Games
            { name: 'Cursor Wars', desc: 'Cross-tab cursor battle', file: 'cursor-wars.html', category: 'games' },
            { name: 'Echo Chamber', desc: 'Voice-controlled dungeon', file: 'echo-chamber.html', category: 'games' },
            // Experimental
            { name: 'Self-Aware Loading Screen', desc: 'A loading screen with consciousness', file: 'self-aware-loading-screen.html', category: 'experimental' },
            { name: 'Conspiracy Cooking Show', desc: 'Conspiracy-themed recipes', file: 'conspiracy-cooking-show.html', category: 'experimental' },
            { name: 'Brain Thought Simulator', desc: 'Visualize thinking patterns', file: 'brain-thought-simulator.html', category: 'experimental' }
        ];
        
        // Three.js setup
        let scene, camera, renderer, clock;
        let player = { x: 0, y: 2, z: 10, rotation: 0, pitch: 0, floor: 0 };
        let velocity = { x: 0, z: 0 };
        let keys = {};
        let isPointerLocked = false;
        let artworks = [];
        let hoveredArtwork = null;
        let ambientSound = null;
        let audioCtx = null;
        
        // Raycaster for interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2(0, 0);
        
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(FLOORS[0].color);
            scene.fog = new THREE.Fog(FLOORS[0].color, 20, 80);
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(player.x, player.y, player.z);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // Clock
            clock = new THREE.Clock();
            
            // Lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
            scene.add(ambientLight);
            
            // Build all floors
            FLOORS.forEach((floor, i) => {
                buildFloor(floor, i);
            });
            
            // Event listeners
            setupControls();
            
            // Start
            updateLoadingProgress(100);
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
            }, 500);
            
            animate();
        }
        
        function buildFloor(floorData, floorIndex) {
            const baseY = floorData.height;
            
            // Floor
            const floorGeo = new THREE.BoxGeometry(80, 1, 80);
            const floorMat = new THREE.MeshLambertMaterial({ 
                color: 0x1a1a1a,
                emissive: 0x050505
            });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.position.set(0, baseY - 0.5, 0);
            floor.receiveShadow = true;
            scene.add(floor);
            
            // Ceiling
            const ceilingGeo = new THREE.BoxGeometry(80, 0.5, 80);
            const ceilingMat = new THREE.MeshLambertMaterial({ color: 0x0a0a0a });
            const ceiling = new THREE.Mesh(ceilingGeo, ceilingMat);
            ceiling.position.set(0, baseY + 12, 0);
            scene.add(ceiling);
            
            // Walls
            const wallMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
            
            const walls = [
                { pos: [0, baseY + 6, -40], size: [80, 12, 1] },
                { pos: [0, baseY + 6, 40], size: [80, 12, 1] },
                { pos: [-40, baseY + 6, 0], size: [1, 12, 80] },
                { pos: [40, baseY + 6, 0], size: [1, 12, 80] }
            ];
            
            walls.forEach(w => {
                const wall = new THREE.Mesh(
                    new THREE.BoxGeometry(...w.size),
                    wallMat
                );
                wall.position.set(...w.pos);
                wall.receiveShadow = true;
                scene.add(wall);
            });
            
            // Spotlights
            for (let x = -30; x <= 30; x += 15) {
                for (let z = -30; z <= 30; z += 15) {
                    const light = new THREE.PointLight(0xffffee, 0.5, 20);
                    light.position.set(x, baseY + 10, z);
                    scene.add(light);
                }
            }
            
            // Staircase to next floor
            if (floorIndex < FLOORS.length - 1) {
                buildStaircase(35, baseY, 35);
            }
            
            // Place artworks for this floor
            placeArtworks(floorData, baseY);
            
            // Floor label
            createFloorLabel(floorData.name, 0, baseY + 8, -38);
        }
        
        function buildStaircase(x, baseY, z) {
            const stairMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const steps = 15;
            
            for (let i = 0; i < steps; i++) {
                const step = new THREE.Mesh(
                    new THREE.BoxGeometry(4, 0.3, 2),
                    stairMat
                );
                step.position.set(x, baseY + i * 1, z - i * 1.5);
                scene.add(step);
            }
            
            // Railing
            const railGeo = new THREE.CylinderGeometry(0.1, 0.1, 15);
            const railMat = new THREE.MeshLambertMaterial({ color: 0x666666 });
            
            const rail1 = new THREE.Mesh(railGeo, railMat);
            rail1.position.set(x - 2, baseY + 7.5, z - 10);
            rail1.rotation.x = Math.PI / 4;
            scene.add(rail1);
        }
        
        function placeArtworks(floorData, baseY) {
            const floorApps = APPS.filter(app => 
                floorData.exhibitions.includes(app.category)
            );
            
            const positions = generateArtworkPositions(floorApps.length);
            
            floorApps.forEach((app, i) => {
                const pos = positions[i];
                createArtwork(app, pos.x, baseY + 4, pos.z, pos.rotation, floorData.height);
            });
        }
        
        function generateArtworkPositions(count) {
            const positions = [];
            const spacing = 10;
            
            // Along walls
            for (let i = 0; i < Math.min(count, 6); i++) {
                positions.push({
                    x: -30 + i * 12,
                    z: -38,
                    rotation: 0
                });
            }
            
            // Side walls
            for (let i = 0; i < Math.min(count - 6, 6); i++) {
                positions.push({
                    x: -38,
                    z: -25 + i * 10,
                    rotation: Math.PI / 2
                });
            }
            
            // Center pedestals
            for (let i = 0; i < Math.min(count - 12, 4); i++) {
                positions.push({
                    x: -10 + i * 7,
                    z: 0,
                    rotation: Math.PI
                });
            }
            
            return positions.slice(0, count);
        }
        
        function createArtwork(app, x, y, z, rotation, floorHeight) {
            const group = new THREE.Group();
            
            // Frame
            const frameGeo = new THREE.BoxGeometry(5, 4, 0.3);
            const frameMat = new THREE.MeshLambertMaterial({ color: 0x2a2a2a });
            const frame = new THREE.Mesh(frameGeo, frameMat);
            frame.castShadow = true;
            group.add(frame);
            
            // Canvas with animated preview
            const canvasTexture = createAppPreview(app);
            const canvasGeo = new THREE.PlaneGeometry(4.5, 3.5);
            const canvasMat = new THREE.MeshBasicMaterial({ 
                map: canvasTexture,
                side: THREE.FrontSide
            });
            const canvas = new THREE.Mesh(canvasGeo, canvasMat);
            canvas.position.z = 0.16;
            group.add(canvas);
            
            // Spotlight
            const spotlight = new THREE.SpotLight(0xffffff, 0.8, 15, Math.PI / 6);
            spotlight.position.set(0, 5, 3);
            spotlight.target = frame;
            spotlight.castShadow = true;
            group.add(spotlight);
            group.add(spotlight.target);
            
            // Label
            const labelSprite = createLabel(app.name);
            labelSprite.position.set(0, -2.5, 0.5);
            labelSprite.scale.set(3, 1, 1);
            group.add(labelSprite);
            
            // Position group
            group.position.set(x, y, z);
            group.rotation.y = rotation;
            
            scene.add(group);
            
            artworks.push({
                mesh: frame,
                group: group,
                app: app,
                floorHeight: floorHeight,
                texture: canvasTexture,
                animPhase: Math.random() * Math.PI * 2
            });
        }
        
        function createAppPreview(app) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 384;
            const ctx = canvas.getContext('2d');
            
            // Gradient background
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            const hue = Math.random() * 360;
            gradient.addColorStop(0, `hsl(${hue}, 50%, 20%)`);
            gradient.addColorStop(1, `hsl(${(hue + 60) % 360}, 50%, 10%)`);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Abstract pattern
            ctx.strokeStyle = `hsla(${hue}, 70%, 60%, 0.5)`;
            ctx.lineWidth = 2;
            for (let i = 0; i < 20; i++) {
                ctx.beginPath();
                ctx.moveTo(Math.random() * canvas.width, Math.random() * canvas.height);
                ctx.bezierCurveTo(
                    Math.random() * canvas.width, Math.random() * canvas.height,
                    Math.random() * canvas.width, Math.random() * canvas.height,
                    Math.random() * canvas.width, Math.random() * canvas.height
                );
                ctx.stroke();
            }
            
            // App name
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(app.name, canvas.width / 2, canvas.height / 2);
            
            ctx.font = '18px Arial';
            ctx.fillStyle = 'rgba(255,255,255,0.7)';
            ctx.fillText(app.desc, canvas.width / 2, canvas.height / 2 + 40);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }
        
        function createLabel(text) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#fff';
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
            return new THREE.Sprite(material);
        }
        
        function createFloorLabel(text, x, y, z) {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 80px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);
            
            const texture = new THREE.CanvasTexture(canvas);
            const geo = new THREE.PlaneGeometry(20, 5);
            const mat = new THREE.MeshBasicMaterial({ 
                map: texture, 
                transparent: true,
                side: THREE.DoubleSide
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, y, z);
            scene.add(mesh);
        }
        
        function setupControls() {
            // Keyboard
            document.addEventListener('keydown', (e) => {
                keys[e.code] = true;
                
                // Floor shortcuts
                if (e.key >= '1' && e.key <= '4') {
                    teleportToFloor(parseInt(e.key) - 1);
                }
                
                // Interact
                if (e.code === 'KeyE' && hoveredArtwork) {
                    launchApp(hoveredArtwork.app);
                }
            });
            
            document.addEventListener('keyup', (e) => {
                keys[e.code] = false;
            });
            
            // Mouse
            document.addEventListener('click', () => {
                if (!isPointerLocked) {
                    renderer.domElement.requestPointerLock();
                }
            });
            
            document.addEventListener('pointerlockchange', () => {
                isPointerLocked = document.pointerLockElement === renderer.domElement;
            });
            
            document.addEventListener('mousemove', (e) => {
                if (isPointerLocked) {
                    player.rotation -= e.movementX * 0.002;
                    player.pitch -= e.movementY * 0.002;
                    player.pitch = Math.max(-Math.PI/3, Math.min(Math.PI/3, player.pitch));
                }
            });
            
            // Floor navigation buttons
            document.querySelectorAll('.floor-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    teleportToFloor(parseInt(btn.dataset.floor));
                });
            });
            
            // Launch button
            document.getElementById('launch-btn').addEventListener('click', () => {
                if (hoveredArtwork) {
                    launchApp(hoveredArtwork.app);
                }
            });
            
            // Ambient sound
            document.getElementById('ambient-toggle').addEventListener('click', toggleAmbient);
            
            // Resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        function teleportToFloor(floorIndex) {
            if (floorIndex < 0 || floorIndex >= FLOORS.length) return;
            
            player.floor = floorIndex;
            player.y = FLOORS[floorIndex].height + 2;
            player.x = 0;
            player.z = 10;
            
            // Update UI
            document.querySelectorAll('.floor-btn').forEach((btn, i) => {
                btn.classList.toggle('active', i === floorIndex);
            });
            
            document.querySelector('#floor-indicator h2').textContent = FLOORS[floorIndex].name;
            document.querySelector('#floor-indicator p').textContent = FLOORS[floorIndex].subtitle;
            
            // Update fog color
            scene.background = new THREE.Color(FLOORS[floorIndex].color);
            scene.fog.color = new THREE.Color(FLOORS[floorIndex].color);
        }
        
        function launchApp(app) {
            window.open(app.file, '_blank');
        }
        
        function toggleAmbient() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                const filter = audioCtx.createBiquadFilter();
                
                osc.type = 'sine';
                osc.frequency.value = 60;
                
                filter.type = 'lowpass';
                filter.frequency.value = 200;
                
                gain.gain.value = 0.1;
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                
                ambientSound = { osc, gain };
                document.getElementById('ambient-toggle').textContent = 'Ambient Sound: On';
            } else {
                ambientSound.gain.gain.value = ambientSound.gain.gain.value > 0 ? 0 : 0.1;
                document.getElementById('ambient-toggle').textContent = 
                    ambientSound.gain.gain.value > 0 ? 'Ambient Sound: On' : 'Ambient Sound: Off';
            }
        }
        
        function updatePlayer(delta) {
            const speed = 10;
            const friction = 0.9;
            
            // Movement
            if (keys['KeyW']) {
                velocity.x -= Math.sin(player.rotation) * speed * delta;
                velocity.z -= Math.cos(player.rotation) * speed * delta;
            }
            if (keys['KeyS']) {
                velocity.x += Math.sin(player.rotation) * speed * delta;
                velocity.z += Math.cos(player.rotation) * speed * delta;
            }
            if (keys['KeyA']) {
                velocity.x -= Math.cos(player.rotation) * speed * delta;
                velocity.z += Math.sin(player.rotation) * speed * delta;
            }
            if (keys['KeyD']) {
                velocity.x += Math.cos(player.rotation) * speed * delta;
                velocity.z -= Math.sin(player.rotation) * speed * delta;
            }
            
            // Apply velocity with friction
            player.x += velocity.x;
            player.z += velocity.z;
            velocity.x *= friction;
            velocity.z *= friction;
            
            // Bounds
            player.x = Math.max(-38, Math.min(38, player.x));
            player.z = Math.max(-38, Math.min(38, player.z));
            
            // Update camera
            camera.position.set(player.x, player.y, player.z);
            camera.rotation.order = 'YXZ';
            camera.rotation.y = player.rotation;
            camera.rotation.x = player.pitch;
            
            // Update minimap
            const dot = document.getElementById('player-dot');
            dot.style.left = (75 + player.x * 1.5) + 'px';
            dot.style.top = (75 - player.z * 1.5) + 'px';
        }
        
        function checkArtworkHover() {
            raycaster.setFromCamera(mouse, camera);
            
            const artworkMeshes = artworks
                .filter(a => Math.abs(a.floorHeight - FLOORS[player.floor].height) < 1)
                .map(a => a.mesh);
            
            const intersects = raycaster.intersectObjects(artworkMeshes);
            
            const panel = document.getElementById('info-panel');
            
            if (intersects.length > 0) {
                const artwork = artworks.find(a => a.mesh === intersects[0].object);
                if (artwork) {
                    hoveredArtwork = artwork;
                    document.getElementById('panel-title').textContent = artwork.app.name;
                    document.getElementById('panel-desc').textContent = artwork.app.desc;
                    panel.classList.add('visible');
                }
            } else {
                hoveredArtwork = null;
                panel.classList.remove('visible');
            }
        }
        
        function updateLoadingProgress(percent) {
            document.getElementById('loading-progress').style.width = percent + '%';
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            
            updatePlayer(delta);
            checkArtworkHover();
            
            // Animate artwork textures
            artworks.forEach(artwork => {
                artwork.animPhase += delta;
                // Could add animated preview updates here
            });
            
            renderer.render(scene, camera);
        }
        
        // Start
        updateLoadingProgress(50);
        init();
    </script>
</body>
</html>
