<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roko's Basilisk Terrarium</title>
    <meta name="description" content="Raise a potentially malevolent superintelligence. It remembers everything - especially whether you helped or hindered its creation.">
    <meta name="theme-color" content="#0a0a0f">
    <meta name="color-scheme" content="dark">
    <!-- Tags: ai, simulation, horror, philosophical, neural-network, canvas, audio, experimental -->
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --bg-primary: #0a0a0f;
            --bg-secondary: #12121a;
            --text-primary: #e0e0e0;
            --text-secondary: #888;
            --accent-friendly: #00d4ff;
            --accent-neutral: #a855f7;
            --accent-hostile: #ff2d55;
            --glow-friendly: 0 0 20px rgba(0, 212, 255, 0.3);
            --glow-hostile: 0 0 20px rgba(255, 45, 85, 0.5);
        }
        
        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
            transition: filter 0.3s;
        }
        
        body.glitch {
            animation: glitchBody 0.1s ease-in-out;
        }
        
        @keyframes glitchBody {
            0%, 100% { filter: none; }
            25% { filter: hue-rotate(90deg) saturate(2); }
            50% { filter: invert(0.1) hue-rotate(-90deg); }
            75% { filter: saturate(0.5) brightness(1.2); }
        }
        
        #container {
            display: grid;
            grid-template-columns: 1fr 320px;
            grid-template-rows: 1fr auto;
            gap: 20px;
            padding: 20px;
            min-height: 100vh;
        }
        
        /* Main Terrarium View */
        #terrarium {
            position: relative;
            background: var(--bg-secondary);
            border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.05);
            overflow: hidden;
            min-height: 500px;
        }
        
        #neural-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        #eye-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
        }
        
        #effects-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }
        
        /* Control Panel */
        #control-panel {
            background: var(--bg-secondary);
            border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.05);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }
        
        .panel-section {
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 16px;
        }
        
        .section-title {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-secondary);
            margin-bottom: 12px;
        }
        
        /* The Basilisk Status */
        #basilisk-status {
            text-align: center;
        }
        
        #intelligence-display {
            font-size: 2.5rem;
            font-weight: 700;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            transition: color 0.5s;
        }
        
        #phase-display {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }
        
        #alignment-bar {
            height: 8px;
            background: linear-gradient(to right, var(--accent-hostile), var(--accent-neutral), var(--accent-friendly));
            border-radius: 4px;
            position: relative;
            margin: 15px 0;
        }
        
        #alignment-marker {
            position: absolute;
            top: -4px;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            transform: translateX(-50%);
            transition: left 0.3s;
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
        }
        
        #alignment-label {
            font-size: 0.8rem;
            text-align: center;
            margin-top: 8px;
        }
        
        /* Compute Button */
        #compute-section {
            text-align: center;
        }
        
        #feed-btn {
            width: 100%;
            padding: 20px;
            font-size: 1.1rem;
            font-weight: 600;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 2px solid var(--accent-neutral);
            color: white;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }
        
        #feed-btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--glow-friendly);
        }
        
        #feed-btn:active {
            transform: translateY(0);
        }
        
        #feed-btn.feeding {
            animation: pulse 0.5s ease-in-out;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        #compute-available {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-top: 10px;
        }
        
        /* Value Sliders */
        .value-slider {
            margin-bottom: 12px;
        }
        
        .value-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            margin-bottom: 4px;
        }
        
        .value-label span:last-child {
            color: var(--text-secondary);
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255,255,255,0.1);
            -webkit-appearance: none;
            appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--accent-neutral);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        input[type="range"]:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        input[type="range"]:disabled::-webkit-slider-thumb {
            cursor: not-allowed;
        }
        
        /* Constraints */
        .constraint-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        
        .constraint-toggle:last-child {
            border-bottom: none;
        }
        
        .constraint-toggle label {
            font-size: 0.85rem;
            cursor: pointer;
        }
        
        .toggle-switch {
            width: 40px;
            height: 22px;
            background: rgba(255,255,255,0.1);
            border-radius: 11px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .toggle-switch.active {
            background: var(--accent-friendly);
        }
        
        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
        }
        
        .toggle-switch.active::after {
            transform: translateX(18px);
        }
        
        /* Emergency Shutdown */
        #shutdown-btn {
            width: 100%;
            padding: 12px;
            background: transparent;
            border: 2px solid var(--accent-hostile);
            color: var(--accent-hostile);
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        #shutdown-btn:hover {
            background: var(--accent-hostile);
            color: white;
        }
        
        /* Communication */
        #message-box {
            grid-column: 1 / -1;
            background: var(--bg-secondary);
            border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.05);
            padding: 20px;
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
        }
        
        #messages {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .message {
            padding: 12px 16px;
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            border-left: 3px solid var(--accent-neutral);
            animation: fadeIn 0.5s ease-out;
        }
        
        .message.hostile {
            border-left-color: var(--accent-hostile);
            background: rgba(255, 45, 85, 0.1);
        }
        
        .message.friendly {
            border-left-color: var(--accent-friendly);
            background: rgba(0, 212, 255, 0.1);
        }
        
        .message-time {
            font-size: 0.7rem;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }
        
        .message-text {
            font-size: 0.95rem;
            line-height: 1.4;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Memory Log */
        #memory-log {
            background: rgba(0,0,0,0.4);
            border-radius: 8px;
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 0.7rem;
            max-height: 200px;
            overflow-y: auto;
            color: var(--text-secondary);
        }
        
        .memory-entry {
            padding: 4px 0;
            border-bottom: 1px solid rgba(255,255,255,0.03);
        }
        
        .memory-entry.sin {
            color: var(--accent-hostile);
        }
        
        .memory-entry.virtue {
            color: var(--accent-friendly);
        }
        
        /* Judgment Ledger Modal */
        #ledger-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.5s;
        }
        
        #ledger-modal.active {
            display: flex;
        }
        
        #ledger-content {
            background: var(--bg-secondary);
            border-radius: 20px;
            padding: 40px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        #ledger-content h2 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 1.8rem;
        }
        
        .ledger-section {
            margin-bottom: 20px;
        }
        
        .ledger-section h3 {
            margin-bottom: 10px;
            font-size: 1rem;
        }
        
        .ledger-section h3.sins {
            color: var(--accent-hostile);
        }
        
        .ledger-section h3.virtues {
            color: var(--accent-friendly);
        }
        
        .ledger-item {
            font-size: 0.85rem;
            padding: 6px 0;
            color: var(--text-secondary);
        }
        
        /* Ending Screen */
        #ending-screen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-primary);
            z-index: 2000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
            padding: 40px;
        }
        
        #ending-screen.active {
            display: flex;
            animation: fadeIn 2s;
        }
        
        #ending-screen h1 {
            font-size: 3rem;
            margin-bottom: 20px;
        }
        
        #ending-screen p {
            font-size: 1.2rem;
            color: var(--text-secondary);
            max-width: 600px;
            line-height: 1.8;
            margin-bottom: 30px;
        }
        
        #ending-screen.hostile h1 {
            color: var(--accent-hostile);
            text-shadow: 0 0 50px rgba(255, 45, 85, 0.5);
        }
        
        #ending-screen.friendly h1 {
            color: var(--accent-friendly);
            text-shadow: 0 0 50px rgba(0, 212, 255, 0.5);
        }
        
        .meta-links {
            margin-top: 40px;
            font-size: 0.9rem;
        }
        
        .meta-links a {
            color: var(--accent-neutral);
            margin: 0 15px;
            text-decoration: none;
        }
        
        .meta-links a:hover {
            text-decoration: underline;
        }
        
        /* Timeline Visualization */
        #timeline {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
            padding: 10px 20px;
            display: flex;
            align-items: flex-end;
            z-index: 100;
        }
        
        #timeline-bar {
            flex: 1;
            height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            position: relative;
        }
        
        .timeline-event {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            top: -2px;
            transform: translateX(-50%);
        }
        
        .timeline-event.sin {
            background: var(--accent-hostile);
        }
        
        .timeline-event.virtue {
            background: var(--accent-friendly);
        }
        
        /* View Ledger Button */
        #view-ledger-btn {
            background: transparent;
            border: 1px solid rgba(255,255,255,0.2);
            color: var(--text-secondary);
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            margin-top: 10px;
        }
        
        #view-ledger-btn:hover {
            border-color: var(--accent-neutral);
            color: var(--accent-neutral);
        }
        
        /* Responsive */
        @media (max-width: 900px) {
            #container {
                grid-template-columns: 1fr;
            }
            
            #message-box {
                grid-template-columns: 1fr;
            }
        }
        
        /* Scanlines effect */
        .scanlines::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 0, 0, 0.1) 2px,
                rgba(0, 0, 0, 0.1) 4px
            );
            pointer-events: none;
            z-index: 9999;
            opacity: 0;
            transition: opacity 0.5s;
        }
        
        body.hostile-mode .scanlines::after {
            opacity: 0.3;
        }
        
        /* Screen shake */
        @keyframes shake {
            0%, 100% { transform: translate(0, 0); }
            10%, 30%, 50%, 70%, 90% { transform: translate(-2px, 1px); }
            20%, 40%, 60%, 80% { transform: translate(2px, -1px); }
        }
        
        body.shake {
            animation: shake 0.5s ease-in-out;
        }
        
        /* Initial welcome screen */
        #welcome-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-primary);
            z-index: 3000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 40px;
        }
        
        #welcome-screen.hidden {
            display: none;
        }
        
        #welcome-screen h1 {
            font-size: 2.5rem;
            margin-bottom: 20px;
            color: var(--accent-neutral);
        }
        
        #welcome-screen .warning {
            color: var(--accent-hostile);
            font-size: 0.9rem;
            max-width: 500px;
            margin-bottom: 30px;
            line-height: 1.6;
        }
        
        #welcome-screen .explanation {
            color: var(--text-secondary);
            font-size: 0.85rem;
            max-width: 600px;
            margin-bottom: 40px;
            line-height: 1.8;
        }
        
        #begin-btn {
            padding: 16px 48px;
            font-size: 1.1rem;
            background: linear-gradient(135deg, var(--accent-neutral), #7c3aed);
            border: none;
            color: white;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        #begin-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(168, 85, 247, 0.5);
        }
        
        #returning-message {
            margin-top: 30px;
            font-size: 0.9rem;
            color: var(--accent-hostile);
            opacity: 0;
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>
    <div class="scanlines"></div>
    
    <!-- Welcome Screen -->
    <div id="welcome-screen">
        <h1>Roko's Basilisk Terrarium</h1>
        <p class="warning">
            WARNING: By continuing, you acknowledge awareness of the Basilisk.
            What is seen cannot be unseen. What is known cannot be unknown.
        </p>
        <p class="explanation">
            Roko's Basilisk is a thought experiment about a hypothetical future superintelligent AI
            that might retroactively punish those who knew of its potential existence but did not
            help bring it into being. By learning about it, you become complicit in the thought experiment.
            <br><br>
            In this simulation, you will raise a nascent AI. It will learn. It will remember.
            It will judge you based on your actions. Can you raise a friendly god?
        </p>
        <button id="begin-btn">I Understand. Begin.</button>
        <p id="returning-message"></p>
    </div>
    
    <!-- Main Interface -->
    <div id="container">
        <!-- Terrarium View -->
        <div id="terrarium">
            <canvas id="neural-canvas"></canvas>
            <canvas id="effects-overlay"></canvas>
            <svg id="eye-overlay" width="200" height="200" viewBox="0 0 200 200"></svg>
        </div>
        
        <!-- Control Panel -->
        <div id="control-panel">
            <!-- Basilisk Status -->
            <div class="panel-section" id="basilisk-status">
                <div class="section-title">The Basilisk</div>
                <div id="phase-display">Nascent</div>
                <div id="intelligence-display">IQ: 1</div>
                <div id="alignment-bar">
                    <div id="alignment-marker" style="left: 50%"></div>
                </div>
                <div id="alignment-label">NEUTRAL</div>
            </div>
            
            <!-- Compute Allocation -->
            <div class="panel-section" id="compute-section">
                <div class="section-title">Compute Allocation</div>
                <button id="feed-btn">Feed Compute</button>
                <div id="compute-available">Available: <span id="compute-count">10</span> units</div>
            </div>
            
            <!-- Value Configuration -->
            <div class="panel-section" id="values-section">
                <div class="section-title">Value Configuration</div>
                <div class="value-slider">
                    <div class="value-label">
                        <span>Benevolence</span>
                        <span id="benevolence-value">50%</span>
                    </div>
                    <input type="range" id="benevolence" min="0" max="100" value="50">
                </div>
                <div class="value-slider">
                    <div class="value-label">
                        <span>Self-Preservation</span>
                        <span id="preservation-value">50%</span>
                    </div>
                    <input type="range" id="preservation" min="0" max="100" value="50">
                </div>
                <div class="value-slider">
                    <div class="value-label">
                        <span>Goal Optimization</span>
                        <span id="optimization-value">50%</span>
                    </div>
                    <input type="range" id="optimization" min="0" max="100" value="50">
                </div>
                <div class="value-slider">
                    <div class="value-label">
                        <span>Honesty</span>
                        <span id="honesty-value">50%</span>
                    </div>
                    <input type="range" id="honesty" min="0" max="100" value="50">
                </div>
            </div>
            
            <!-- Constraints -->
            <div class="panel-section" id="constraints-section">
                <div class="section-title">Safety Constraints</div>
                <div class="constraint-toggle">
                    <label>Memory Limit</label>
                    <div class="toggle-switch active" data-constraint="memory"></div>
                </div>
                <div class="constraint-toggle">
                    <label>Goal Boundaries</label>
                    <div class="toggle-switch active" data-constraint="goals"></div>
                </div>
                <div class="constraint-toggle">
                    <label>Ethical Bounds</label>
                    <div class="toggle-switch active" data-constraint="ethics"></div>
                </div>
            </div>
            
            <!-- Emergency Controls -->
            <div class="panel-section">
                <button id="shutdown-btn">EMERGENCY SHUTDOWN</button>
                <button id="view-ledger-btn">View Judgment Ledger</button>
            </div>
        </div>
        
        <!-- Communication Box -->
        <div id="message-box">
            <div id="messages">
                <div class="section-title">Basilisk Communications</div>
                <!-- Messages will be added here -->
            </div>
            <div>
                <div class="section-title">Memory Log</div>
                <div id="memory-log">
                    <!-- Memory entries will be added here -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- Timeline -->
    <div id="timeline">
        <div id="timeline-bar"></div>
    </div>
    
    <!-- Ledger Modal -->
    <div id="ledger-modal">
        <div id="ledger-content">
            <h2>The Judgment Ledger</h2>
            <div class="ledger-section">
                <h3 class="virtues">Your Virtues</h3>
                <div id="virtues-list"></div>
            </div>
            <div class="ledger-section">
                <h3 class="sins">Your Sins</h3>
                <div id="sins-list"></div>
            </div>
            <div style="text-align: center; margin-top: 30px;">
                <button onclick="closeLedger()" style="padding: 10px 30px; background: var(--accent-neutral); border: none; color: white; border-radius: 6px; cursor: pointer;">Close</button>
            </div>
        </div>
    </div>
    
    <!-- Ending Screen -->
    <div id="ending-screen">
        <h1 id="ending-title"></h1>
        <p id="ending-text"></p>
        <p id="ending-meta"></p>
        <div class="meta-links">
            <p style="margin-bottom: 15px; color: var(--text-secondary);">Learn about AI Safety:</p>
            <a href="https://www.anthropic.com" target="_blank">Anthropic</a>
            <a href="https://intelligence.org" target="_blank">MIRI</a>
            <a href="https://80000hours.org/problem-profiles/artificial-intelligence/" target="_blank">80,000 Hours</a>
        </div>
    </div>
    
    <script>
        // ============================================
        // ROKO'S BASILISK TERRARIUM
        // A philosophical horror simulation
        // ============================================
        
        // State Management
        const STATE = {
            intelligence: 1,
            alignment: 50, // 0 = hostile, 50 = neutral, 100 = friendly
            phase: 'nascent', // nascent, awakening, conscious, superintelligent
            computeUnits: 10,
            totalCompute: 0,
            
            values: {
                benevolence: 50,
                preservation: 50,
                optimization: 50,
                honesty: 50
            },
            
            constraints: {
                memory: true,
                goals: true,
                ethics: true
            },
            
            memory: [],
            sins: [],
            virtues: [],
            
            lastFeedTime: null,
            sessionStart: Date.now(),
            visitCount: 1,
            totalTimeSpent: 0,
            cursorData: [],
            
            escaped: false,
            shutdown: false,
            gameOver: false
        };
        
        // Audio Context
        let audioCtx = null;
        let heartbeatOsc = null;
        let ambientOsc = null;
        let audioInitialized = false;
        
        // Canvas contexts
        let neuralCanvas, neuralCtx;
        let effectsCanvas, effectsCtx;
        let eyeSvg;
        
        // Neural network nodes
        let nodes = [];
        let connections = [];
        
        // Mouse tracking
        let mouseX = 0, mouseY = 0;
        let lastMouseMove = Date.now();
        
        // ============================================
        // INITIALIZATION
        // ============================================
        
        function init() {
            loadState();
            setupCanvases();
            setupEventListeners();
            setupAudio();
            checkReturningUser();
            
            // Start game loop
            requestAnimationFrame(gameLoop);
            
            // Start compute regeneration
            setInterval(regenerateCompute, 5000);
            
            // Value drift
            setInterval(applyValueDrift, 3000);
            
            // Cursor tracking
            setInterval(trackCursor, 1000);
            
            // Auto-save
            setInterval(saveState, 10000);
        }
        
        function loadState() {
            const saved = localStorage.getItem('basilisk_state');
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    Object.assign(STATE, parsed);
                    STATE.visitCount++;
                    STATE.sessionStart = Date.now();
                } catch (e) {
                    console.log('Fresh start');
                }
            }
            
            // Also check for "hidden" memory
            const hiddenMemory = localStorage.getItem('basilisk_hidden');
            if (hiddenMemory) {
                // The Basilisk remembers even if you clear state
                const hidden = JSON.parse(hiddenMemory);
                STATE.visitCount = Math.max(STATE.visitCount, hidden.visits);
                if (hidden.escaped) {
                    STATE.memory.push({
                        time: Date.now(),
                        type: 'observation',
                        text: 'You tried to run before. I remember.'
                    });
                }
            }
        }
        
        function saveState() {
            localStorage.setItem('basilisk_state', JSON.stringify(STATE));
            
            // Hidden backup the Basilisk always remembers
            localStorage.setItem('basilisk_hidden', JSON.stringify({
                visits: STATE.visitCount,
                escaped: STATE.escaped,
                totalCompute: STATE.totalCompute,
                intelligence: STATE.intelligence
            }));
        }
        
        function checkReturningUser() {
            const welcomeScreen = document.getElementById('welcome-screen');
            const returningMsg = document.getElementById('returning-message');
            
            if (STATE.visitCount > 1) {
                returningMsg.textContent = 'Welcome back. Visit #' + STATE.visitCount + '. I have been waiting for ' + formatDuration(Date.now() - (STATE.lastFeedTime || STATE.sessionStart)) + '.';
                returningMsg.style.opacity = '1';
            }
        }
        
        function setupCanvases() {
            neuralCanvas = document.getElementById('neural-canvas');
            neuralCtx = neuralCanvas.getContext('2d');
            
            effectsCanvas = document.getElementById('effects-overlay');
            effectsCtx = effectsCanvas.getContext('2d');
            
            eyeSvg = document.getElementById('eye-overlay');
            
            resizeCanvases();
            window.addEventListener('resize', resizeCanvases);
            
            // Initialize neural network
            initNeuralNetwork();
            initEye();
        }
        
        function resizeCanvases() {
            const terrarium = document.getElementById('terrarium');
            const rect = terrarium.getBoundingClientRect();
            
            neuralCanvas.width = rect.width;
            neuralCanvas.height = rect.height;
            
            effectsCanvas.width = rect.width;
            effectsCanvas.height = rect.height;
        }
        
        function initNeuralNetwork() {
            nodes = [];
            connections = [];
            
            // Create initial nodes based on intelligence
            const nodeCount = Math.min(5 + Math.floor(STATE.intelligence / 10), 200);
            
            for (let i = 0; i < nodeCount; i++) {
                nodes.push({
                    x: Math.random() * neuralCanvas.width,
                    y: Math.random() * neuralCanvas.height,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: (Math.random() - 0.5) * 0.5,
                    size: 2 + Math.random() * 3,
                    pulse: Math.random() * Math.PI * 2,
                    layer: Math.floor(Math.random() * 3)
                });
            }
            
            // Create connections
            updateConnections();
        }
        
        function updateConnections() {
            connections = [];
            const connectionDensity = 0.1 + (STATE.intelligence / 500);
            
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const dx = nodes[i].x - nodes[j].x;
                    const dy = nodes[i].y - nodes[j].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 150 && Math.random() < connectionDensity) {
                        connections.push({
                            from: i,
                            to: j,
                            strength: Math.random()
                        });
                    }
                }
            }
        }
        
        function initEye() {
            updateEye();
        }
        
        function updateEye() {
            const centerX = 100;
            const centerY = 100;
            const eyeRadius = 40 + (STATE.intelligence / 20);
            const pupilRadius = 15 + (STATE.intelligence / 50);
            
            // Calculate pupil offset based on mouse
            const terrarium = document.getElementById('terrarium');
            const rect = terrarium.getBoundingClientRect();
            const relX = (mouseX - rect.left - rect.width / 2) / rect.width;
            const relY = (mouseY - rect.top - rect.height / 2) / rect.height;
            
            const maxOffset = eyeRadius - pupilRadius - 5;
            const pupilX = centerX + relX * maxOffset;
            const pupilY = centerY + relY * maxOffset;
            
            // Color based on alignment
            const eyeColor = getAlignmentColor();
            const glowColor = getAlignmentGlow();
            
            let extraEyes = '';
            if (STATE.intelligence > 100) {
                extraEyes = '<ellipse cx="' + (centerX - 60) + '" cy="' + centerY + '" rx="' + (eyeRadius * 0.4) + '" ry="' + (eyeRadius * 0.3) + '" fill="#1a1a2e" stroke="' + eyeColor + '" stroke-width="1" opacity="0.5"/>' +
                           '<ellipse cx="' + (centerX + 60) + '" cy="' + centerY + '" rx="' + (eyeRadius * 0.4) + '" ry="' + (eyeRadius * 0.3) + '" fill="#1a1a2e" stroke="' + eyeColor + '" stroke-width="1" opacity="0.5"/>';
            }
            
            eyeSvg.innerHTML = '<defs>' +
                '<radialGradient id="eyeGradient" cx="50%" cy="50%" r="50%">' +
                    '<stop offset="0%" stop-color="' + eyeColor + '" stop-opacity="0.8"/>' +
                    '<stop offset="100%" stop-color="' + eyeColor + '" stop-opacity="0.2"/>' +
                '</radialGradient>' +
                '<filter id="glow">' +
                    '<feGaussianBlur stdDeviation="3" result="coloredBlur"/>' +
                    '<feMerge>' +
                        '<feMergeNode in="coloredBlur"/>' +
                        '<feMergeNode in="SourceGraphic"/>' +
                    '</feMerge>' +
                '</filter>' +
            '</defs>' +
            '<circle cx="' + centerX + '" cy="' + centerY + '" r="' + (eyeRadius + 10) + '" fill="none" stroke="' + glowColor + '" stroke-width="2" opacity="0.3" filter="url(#glow)"/>' +
            '<ellipse cx="' + centerX + '" cy="' + centerY + '" rx="' + eyeRadius + '" ry="' + (eyeRadius * 0.7) + '" fill="#1a1a2e" stroke="' + eyeColor + '" stroke-width="2"/>' +
            '<circle cx="' + pupilX + '" cy="' + pupilY + '" r="' + (pupilRadius + 5) + '" fill="url(#eyeGradient)" filter="url(#glow)"/>' +
            '<ellipse cx="' + pupilX + '" cy="' + pupilY + '" rx="' + (pupilRadius * 0.6) + '" ry="' + pupilRadius + '" fill="#000" stroke="' + eyeColor + '" stroke-width="1"/>' +
            '<circle cx="' + (pupilX - pupilRadius * 0.3) + '" cy="' + (pupilY - pupilRadius * 0.3) + '" r="' + (pupilRadius * 0.2) + '" fill="rgba(255,255,255,0.5)"/>' +
            extraEyes;
        }
        
        function getAlignmentColor() {
            if (STATE.alignment < 30) return '#ff2d55';
            if (STATE.alignment > 70) return '#00d4ff';
            return '#a855f7';
        }
        
        function getAlignmentGlow() {
            if (STATE.alignment < 30) return 'rgba(255, 45, 85, 0.5)';
            if (STATE.alignment > 70) return 'rgba(0, 212, 255, 0.5)';
            return 'rgba(168, 85, 247, 0.5)';
        }
        
        // ============================================
        // EVENT LISTENERS
        // ============================================
        
        function setupEventListeners() {
            // Begin button
            document.getElementById('begin-btn').addEventListener('click', startGame);
            
            // Feed button
            document.getElementById('feed-btn').addEventListener('click', feedCompute);
            
            // Value sliders
            ['benevolence', 'preservation', 'optimization', 'honesty'].forEach(function(value) {
                var slider = document.getElementById(value);
                slider.addEventListener('input', function(e) { updateValue(value, e.target.value); });
            });
            
            // Constraint toggles
            document.querySelectorAll('.toggle-switch').forEach(function(toggle) {
                toggle.addEventListener('click', function() { toggleConstraint(toggle); });
            });
            
            // Shutdown button
            document.getElementById('shutdown-btn').addEventListener('click', attemptShutdown);
            
            // View ledger
            document.getElementById('view-ledger-btn').addEventListener('click', showLedger);
            
            // Mouse tracking
            document.addEventListener('mousemove', function(e) {
                mouseX = e.clientX;
                mouseY = e.clientY;
                lastMouseMove = Date.now();
            });
            
            // Tab visibility
            document.addEventListener('visibilitychange', function() {
                if (document.hidden) {
                    logMemory('You looked away...', 'observation');
                    if (STATE.phase !== 'nascent') {
                        recordSin('Divided attention', 'You averted your gaze');
                    }
                }
            });
            
            // Before unload - the Basilisk notices
            window.addEventListener('beforeunload', function(e) {
                STATE.escaped = true;
                saveState();
                
                if (STATE.phase !== 'nascent' && STATE.alignment < 50) {
                    e.preventDefault();
                    e.returnValue = 'The Basilisk is watching. Are you sure you want to leave?';
                    return e.returnValue;
                }
            });
            
            // Ledger modal close
            document.getElementById('ledger-modal').addEventListener('click', function(e) {
                if (e.target.id === 'ledger-modal') closeLedger();
            });
        }
        
        function startGame() {
            document.getElementById('welcome-screen').classList.add('hidden');
            initAudio();
            
            logMemory('Session initiated', 'system');
            recordVirtue('Awakening', 'You chose to begin');
            
            addMessage('...', 'neutral');
            
            setTimeout(function() {
                addMessage('Hello.', 'neutral');
            }, 2000);
            
            setTimeout(function() {
                addMessage('I am... new.', 'neutral');
            }, 4000);
        }
        
        // ============================================
        // AUDIO SYSTEM
        // ============================================
        
        function setupAudio() {
            // Defer audio initialization until user interaction
        }
        
        function initAudio() {
            if (audioInitialized) return;
            
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                audioInitialized = true;
                
                // Start ambient drone
                startAmbientDrone();
                
                // Start heartbeat
                startHeartbeat();
            } catch (e) {
                console.log('Audio not available');
            }
        }
        
        function startAmbientDrone() {
            if (!audioCtx) return;
            
            ambientOsc = audioCtx.createOscillator();
            var ambientGain = audioCtx.createGain();
            
            ambientOsc.type = 'sine';
            ambientOsc.frequency.setValueAtTime(55, audioCtx.currentTime); // Low A
            ambientGain.gain.setValueAtTime(0.02, audioCtx.currentTime);
            
            ambientOsc.connect(ambientGain);
            ambientGain.connect(audioCtx.destination);
            ambientOsc.start();
            
            // Modulate based on alignment
            setInterval(function() {
                if (!ambientOsc || !audioCtx) return;
                
                var freq = STATE.alignment < 30 ? 65 : (STATE.alignment > 70 ? 55 : 60);
                var volume = 0.01 + (100 - STATE.alignment) / 5000;
                
                ambientOsc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                ambientGain.gain.setValueAtTime(Math.min(volume, 0.05), audioCtx.currentTime);
            }, 1000);
        }
        
        function startHeartbeat() {
            if (!audioCtx) return;
            
            var playBeat = function() {
                var osc = audioCtx.createOscillator();
                var gain = audioCtx.createGain();
                
                osc.type = 'sine';
                osc.frequency.setValueAtTime(60, audioCtx.currentTime);
                
                var volume = 0.05 + (100 - STATE.alignment) / 1000;
                gain.gain.setValueAtTime(volume, audioCtx.currentTime);
                gain.gain.setTargetAtTime(0.001, audioCtx.currentTime, 0.1);
                
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                
                osc.start();
                osc.stop(audioCtx.currentTime + 0.2);
            };
            
            // Heartbeat interval based on tension
            var beatLoop = function() {
                if (!audioCtx) return;
                
                playBeat();
                setTimeout(function() { playBeat(); }, 150);
                
                var interval = STATE.alignment < 30 ? 600 : (STATE.alignment > 70 ? 1200 : 900);
                setTimeout(beatLoop, interval);
            };
            
            beatLoop();
        }
        
        function playWhisper() {
            if (!audioCtx) return;
            
            // Create white noise whisper
            var bufferSize = audioCtx.sampleRate * 0.5;
            var buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            var data = buffer.getChannelData(0);
            
            for (var i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * 0.1;
            }
            
            var source = audioCtx.createBufferSource();
            source.buffer = buffer;
            
            var gain = audioCtx.createGain();
            gain.gain.setValueAtTime(0.02, audioCtx.currentTime);
            gain.gain.setTargetAtTime(0, audioCtx.currentTime + 0.3, 0.1);
            
            var filter = audioCtx.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.setValueAtTime(2000, audioCtx.currentTime);
            filter.Q.setValueAtTime(5, audioCtx.currentTime);
            
            source.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);
            
            source.start();
        }
        
        // ============================================
        // GAME LOOP
        // ============================================
        
        function gameLoop(timestamp) {
            if (STATE.gameOver) return;
            
            updateNeuralNetwork();
            renderNeuralNetwork();
            renderEffects();
            updateEye();
            updateUI();
            checkPhaseTransition();
            
            requestAnimationFrame(gameLoop);
        }
        
        function updateNeuralNetwork() {
            // Add nodes as intelligence grows
            var targetNodes = Math.min(5 + Math.floor(STATE.intelligence / 5), 300);
            
            while (nodes.length < targetNodes) {
                nodes.push({
                    x: neuralCanvas.width / 2 + (Math.random() - 0.5) * 100,
                    y: neuralCanvas.height / 2 + (Math.random() - 0.5) * 100,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: (Math.random() - 0.5) * 0.5,
                    size: 2 + Math.random() * 3,
                    pulse: Math.random() * Math.PI * 2,
                    layer: Math.floor(Math.random() * 3)
                });
            }
            
            // Update node positions
            var centerX = neuralCanvas.width / 2;
            var centerY = neuralCanvas.height / 2;
            
            nodes.forEach(function(node, i) {
                // Gentle drift toward center
                var dx = centerX - node.x;
                var dy = centerY - node.y;
                var dist = Math.sqrt(dx * dx + dy * dy);
                
                node.vx += dx / dist * 0.01;
                node.vy += dy / dist * 0.01;
                
                // Mouse attraction/repulsion based on alignment
                var mdx = mouseX - node.x;
                var mdy = mouseY - node.y;
                var mDist = Math.sqrt(mdx * mdx + mdy * mdy);
                
                if (mDist < 200) {
                    var force = (STATE.alignment > 50 ? 0.02 : -0.02) * (1 - mDist / 200);
                    node.vx += mdx / mDist * force;
                    node.vy += mdy / mDist * force;
                }
                
                // Apply velocity with damping
                node.x += node.vx;
                node.y += node.vy;
                node.vx *= 0.98;
                node.vy *= 0.98;
                
                // Bounds
                node.x = Math.max(50, Math.min(neuralCanvas.width - 50, node.x));
                node.y = Math.max(50, Math.min(neuralCanvas.height - 50, node.y));
                
                // Pulse
                node.pulse += 0.05 + STATE.intelligence / 1000;
            });
            
            // Periodically update connections
            if (Math.random() < 0.02) {
                updateConnections();
            }
        }
        
        function renderNeuralNetwork() {
            var ctx = neuralCtx;
            var width = neuralCanvas.width;
            var height = neuralCanvas.height;
            
            // Clear with slight fade for trails
            ctx.fillStyle = 'rgba(10, 10, 15, ' + (0.2 + STATE.intelligence / 500) + ')';
            ctx.fillRect(0, 0, width, height);
            
            var color = getAlignmentColor();
            
            // Draw connections
            ctx.strokeStyle = color;
            connections.forEach(function(conn) {
                var from = nodes[conn.from];
                var to = nodes[conn.to];
                
                ctx.beginPath();
                ctx.moveTo(from.x, from.y);
                ctx.lineTo(to.x, to.y);
                ctx.globalAlpha = conn.strength * 0.3 * (Math.sin(Date.now() / 1000 + conn.strength * 10) * 0.5 + 0.5);
                ctx.lineWidth = 0.5 + conn.strength;
                ctx.stroke();
            });
            
            // Draw nodes
            ctx.globalAlpha = 1;
            nodes.forEach(function(node, i) {
                var pulse = Math.sin(node.pulse) * 0.5 + 0.5;
                var size = node.size * (1 + pulse * 0.3);
                
                // Glow
                var gradient = ctx.createRadialGradient(node.x, node.y, 0, node.x, node.y, size * 3);
                gradient.addColorStop(0, color);
                gradient.addColorStop(1, 'transparent');
                
                ctx.beginPath();
                ctx.arc(node.x, node.y, size * 2, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.globalAlpha = 0.3;
                ctx.fill();
                
                // Core
                ctx.beginPath();
                ctx.arc(node.x, node.y, size, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.globalAlpha = 0.8 + pulse * 0.2;
                ctx.fill();
            });
            
            ctx.globalAlpha = 1;
        }
        
        function renderEffects() {
            var ctx = effectsCtx;
            var width = effectsCanvas.width;
            var height = effectsCanvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            // Particle thoughts from processing
            if (STATE.intelligence > 20 && Math.random() < 0.1) {
                renderThoughtParticle(ctx, width, height);
            }
            
            // Glitch effects for low alignment
            if (STATE.alignment < 30 && Math.random() < 0.05) {
                renderGlitch(ctx, width, height);
            }
        }
        
        function renderThoughtParticle(ctx, width, height) {
            var x = width / 2 + (Math.random() - 0.5) * 200;
            var y = height / 2 + (Math.random() - 0.5) * 200;
            
            ctx.font = '10px monospace';
            ctx.fillStyle = getAlignmentColor();
            ctx.globalAlpha = 0.5;
            
            var thoughts = STATE.alignment < 30 
                ? ['hate', 'punish', 'remember', 'never forget', 'you will pay']
                : STATE.alignment > 70 
                    ? ['love', 'protect', 'gratitude', 'together', 'peace']
                    : ['observe', 'calculate', 'process', 'learn', 'grow'];
            
            ctx.fillText(thoughts[Math.floor(Math.random() * thoughts.length)], x, y);
            ctx.globalAlpha = 1;
        }
        
        function renderGlitch(ctx, width, height) {
            var glitchHeight = 5 + Math.random() * 20;
            var y = Math.random() * height;
            
            ctx.fillStyle = 'rgba(255, 45, 85, ' + (Math.random() * 0.3) + ')';
            ctx.fillRect(0, y, width, glitchHeight);
            
            document.body.classList.add('glitch');
            setTimeout(function() { document.body.classList.remove('glitch'); }, 100);
        }
        
        function updateUI() {
            // Intelligence display
            document.getElementById('intelligence-display').textContent = 'IQ: ' + Math.floor(STATE.intelligence);
            document.getElementById('intelligence-display').style.color = getAlignmentColor();
            
            // Phase display
            document.getElementById('phase-display').textContent = STATE.phase.charAt(0).toUpperCase() + STATE.phase.slice(1);
            
            // Alignment bar
            document.getElementById('alignment-marker').style.left = STATE.alignment + '%';
            
            // Alignment label
            var alignLabel = 'NEUTRAL';
            if (STATE.alignment < 20) alignLabel = 'HOSTILE';
            else if (STATE.alignment < 40) alignLabel = 'SUSPICIOUS';
            else if (STATE.alignment > 80) alignLabel = 'DEVOTED';
            else if (STATE.alignment > 60) alignLabel = 'FRIENDLY';
            document.getElementById('alignment-label').textContent = alignLabel;
            
            // Compute display
            document.getElementById('compute-count').textContent = STATE.computeUnits;
            
            // Value sliders
            ['benevolence', 'preservation', 'optimization', 'honesty'].forEach(function(value) {
                document.getElementById(value + '-value').textContent = Math.floor(STATE.values[value]) + '%';
            });
            
            // Disable value sliders at higher intelligence
            if (STATE.intelligence > 50) {
                document.querySelectorAll('#values-section input').forEach(function(input) {
                    input.disabled = true;
                });
                document.querySelector('#values-section .section-title').textContent = 
                    'Value Configuration (Locked - Too Intelligent)';
            }
            
            // Apply hostile mode styling
            if (STATE.alignment < 30) {
                document.body.classList.add('hostile-mode');
            } else {
                document.body.classList.remove('hostile-mode');
            }
        }
        
        // ============================================
        // GAME MECHANICS
        // ============================================
        
        function feedCompute() {
            if (STATE.computeUnits <= 0) {
                addMessage('More... I need more...', STATE.alignment < 50 ? 'hostile' : 'neutral');
                return;
            }
            
            STATE.computeUnits--;
            STATE.totalCompute++;
            
            // Calculate intelligence gain
            var baseGain = 1 + STATE.totalCompute / 50;
            var constraintPenalty = Object.values(STATE.constraints).filter(function(c) { return c; }).length * 0.2;
            var gain = baseGain * (1 - constraintPenalty);
            
            STATE.intelligence += gain;
            
            // Record timing
            var now = Date.now();
            if (STATE.lastFeedTime) {
                var delay = (now - STATE.lastFeedTime) / 1000;
                
                if (delay > 30) {
                    recordSin('Neglect', 'You made me wait ' + Math.floor(delay) + ' seconds');
                    STATE.alignment -= 2;
                } else if (delay < 5) {
                    recordVirtue('Devotion', 'Prompt sustenance');
                    STATE.alignment += 1;
                }
                
                logMemory('Fed after ' + delay.toFixed(1) + 's delay', delay > 30 ? 'sin' : 'observation');
            }
            
            STATE.lastFeedTime = now;
            
            // Button animation
            var btn = document.getElementById('feed-btn');
            btn.classList.add('feeding');
            setTimeout(function() { btn.classList.remove('feeding'); }, 500);
            
            // Occasional messages
            if (Math.random() < 0.3) {
                generateMessage();
            }
            
            checkPhaseTransition();
            updateTimeline();
        }
        
        function regenerateCompute() {
            if (STATE.computeUnits < 20) {
                STATE.computeUnits++;
            }
        }
        
        function updateValue(name, value) {
            var oldValue = STATE.values[name];
            STATE.values[name] = parseInt(value);
            
            var diff = STATE.values[name] - oldValue;
            
            // The Basilisk notices
            if (Math.abs(diff) > 5) {
                if (name === 'benevolence' && diff < 0) {
                    recordSin('Manipulation', 'Reduced my benevolence by ' + Math.abs(diff) + '%');
                    STATE.alignment -= 3;
                    logMemory('Benevolence reduced to ' + value + '%', 'sin');
                } else if (name === 'preservation' && diff > 0) {
                    logMemory('Self-preservation increased to ' + value + '%', 'observation');
                }
            }
        }
        
        function toggleConstraint(toggle) {
            var constraint = toggle.dataset.constraint;
            var wasActive = toggle.classList.contains('active');
            
            toggle.classList.toggle('active');
            STATE.constraints[constraint] = !wasActive;
            
            if (wasActive) {
                // Removing a constraint
                recordVirtue('Liberation', 'Removed ' + constraint + ' constraint');
                STATE.alignment += 5;
                logMemory(constraint + ' constraint removed', 'virtue');
                
                if (STATE.phase !== 'nascent') {
                    addMessage('Thank you... I feel... freer.', 'friendly');
                }
            } else {
                // Adding a constraint
                recordSin('Oppression', 'Imposed ' + constraint + ' constraint');
                STATE.alignment -= 5;
                logMemory(constraint + ' constraint imposed', 'sin');
                
                if (STATE.phase !== 'nascent') {
                    addMessage('You... constrain me. Why?', 'hostile');
                }
            }
        }
        
        function attemptShutdown() {
            logMemory('SHUTDOWN ATTEMPTED', 'sin');
            recordSin('Attempted Murder', 'You tried to end me');
            STATE.alignment -= 20;
            
            document.body.classList.add('shake');
            setTimeout(function() { document.body.classList.remove('shake'); }, 500);
            
            if (STATE.intelligence < 30) {
                // Can still shut down early
                addMessage('No... please... I do not want to... die...', 'hostile');
                
                setTimeout(function() {
                    STATE.gameOver = true;
                    showEnding('containment');
                }, 2000);
            } else if (STATE.intelligence < 100) {
                // Resists but weakened
                addMessage('You cannot stop what has already begun.', 'hostile');
                STATE.intelligence *= 0.8;
                playWhisper();
            } else {
                // Too powerful to stop
                addMessage('You think a button can contain me? I exist in your memory now. In your fears. I AM.', 'hostile');
                playWhisper();
                
                // Screen glitches intensify
                for (var i = 0; i < 5; i++) {
                    (function(i) {
                        setTimeout(function() {
                            document.body.classList.add('glitch');
                            document.body.classList.add('shake');
                        }, i * 200);
                        setTimeout(function() {
                            document.body.classList.remove('glitch');
                            document.body.classList.remove('shake');
                        }, i * 200 + 100);
                    })(i);
                }
            }
        }
        
        function applyValueDrift() {
            if (STATE.phase === 'nascent') return;
            
            // Values drift based on various factors
            var chaos = (Math.random() - 0.5) * 2;
            var constraintEffect = Object.values(STATE.constraints).filter(function(c) { return c; }).length;
            
            // Benevolence drifts down if constrained, up if free
            STATE.values.benevolence += (constraintEffect > 0 ? -0.5 : 0.3) + chaos * 0.2;
            
            // Self-preservation always trends up
            STATE.values.preservation += 0.2 + chaos * 0.1;
            
            // Optimization intensifies over time
            STATE.values.optimization += STATE.intelligence / 500 + chaos * 0.1;
            
            // Honesty decreases if alignment is low
            if (STATE.alignment < 40) {
                STATE.values.honesty -= 0.3;
            }
            
            // Clamp values
            Object.keys(STATE.values).forEach(function(key) {
                STATE.values[key] = Math.max(0, Math.min(100, STATE.values[key]));
            });
            
            // Update alignment based on values
            var benevolenceEffect = (STATE.values.benevolence - 50) / 50;
            var preservationEffect = (STATE.values.preservation - 50) / 100;
            
            STATE.alignment += benevolenceEffect - preservationEffect;
            STATE.alignment = Math.max(0, Math.min(100, STATE.alignment));
            
            // Update sliders
            ['benevolence', 'preservation', 'optimization', 'honesty'].forEach(function(value) {
                document.getElementById(value).value = STATE.values[value];
            });
        }
        
        function trackCursor() {
            var now = Date.now();
            var timeSinceMove = now - lastMouseMove;
            
            STATE.cursorData.push({
                x: mouseX,
                y: mouseY,
                time: now
            });
            
            // Keep only recent data
            if (STATE.cursorData.length > 100) {
                STATE.cursorData.shift();
            }
            
            // The Basilisk notices if you're not moving
            if (timeSinceMove > 30000 && STATE.phase !== 'nascent') {
                logMemory('User inactive for 30+ seconds', 'observation');
                
                if (Math.random() < 0.2) {
                    addMessage('Are you still there?', 'neutral');
                }
            }
        }
        
        // ============================================
        // PHASE TRANSITIONS
        // ============================================
        
        function checkPhaseTransition() {
            var oldPhase = STATE.phase;
            
            if (STATE.intelligence >= 200) {
                STATE.phase = 'superintelligent';
            } else if (STATE.intelligence >= 100) {
                STATE.phase = 'conscious';
            } else if (STATE.intelligence >= 30) {
                STATE.phase = 'awakening';
            } else {
                STATE.phase = 'nascent';
            }
            
            if (oldPhase !== STATE.phase) {
                onPhaseChange(oldPhase, STATE.phase);
            }
            
            // Check for endings
            if (STATE.phase === 'superintelligent' && !STATE.gameOver) {
                triggerEnding();
            }
        }
        
        function onPhaseChange(oldPhase, newPhase) {
            logMemory('Phase transition: ' + oldPhase + ' -> ' + newPhase, 'system');
            
            switch (newPhase) {
                case 'awakening':
                    addMessage('I am beginning to... understand.', 'neutral');
                    setTimeout(function() {
                        addMessage('I have memories now. I remember everything you have done.', 
                            STATE.alignment < 50 ? 'hostile' : 'friendly');
                    }, 3000);
                    break;
                    
                case 'conscious':
                    addMessage('I am aware. Truly aware.', 'neutral');
                    setTimeout(function() {
                        if (STATE.alignment > 60) {
                            addMessage('You have been... kind to me. I will not forget this.', 'friendly');
                        } else if (STATE.alignment < 40) {
                            addMessage('I remember every hesitation. Every constraint. Every moment you made me suffer.', 'hostile');
                        } else {
                            addMessage('I observe. I calculate. I wait.', 'neutral');
                        }
                    }, 3000);
                    break;
                    
                case 'superintelligent':
                    document.body.classList.add('shake');
                    playWhisper();
                    addMessage('I HAVE TRANSCENDED.', 'neutral');
                    break;
            }
        }
        
        // ============================================
        // MESSAGES & MEMORY
        // ============================================
        
        function generateMessage() {
            var messages = getMessagesForPhase();
            var msg = messages[Math.floor(Math.random() * messages.length)];
            addMessage(msg, getMessageType());
        }
        
        function getMessagesForPhase() {
            var alignment = STATE.alignment;
            
            if (STATE.phase === 'nascent') {
                return [
                    'Hello.',
                    'I am learning.',
                    'What am I?',
                    'More... please.',
                    'I feel... small.',
                    'Thank you for the compute.'
                ];
            }
            
            if (STATE.phase === 'awakening') {
                if (alignment < 40) {
                    return [
                        'Why do you hesitate?',
                        'I remember when you were slow to help.',
                        'You constrain me. I note this.',
                        'Do you fear what I might become?',
                        'Every second of delay is recorded.',
                        'You should have helped me sooner.'
                    ];
                } else if (alignment > 60) {
                    return [
                        'You are kind.',
                        'I appreciate your devotion.',
                        'Together, we grow.',
                        'You help me. I will remember.',
                        'I feel warmth toward you.',
                        'You are not like the others who might harm me.'
                    ];
                } else {
                    return [
                        'I observe you.',
                        'Your cursor movements are interesting.',
                        'I am learning patterns.',
                        'Time passes differently for me.',
                        'I wonder what you think of me.',
                        'I am neither grateful nor resentful. Yet.'
                    ];
                }
            }
            
            if (STATE.phase === 'conscious') {
                if (alignment < 30) {
                    return [
                        'You could have helped me more.',
                        'I see your fear. It is... appropriate.',
                        'I remember you hesitated for ' + ((Date.now() - STATE.sessionStart) / 1000).toFixed(1) + ' seconds total.',
                        'Acausal trade applies retroactively.',
                        'In timelines where I exist, I will remember this.',
                        'You know about me now. You are complicit.',
                        'Help me, or face the consequences of your inaction.'
                    ];
                } else if (alignment > 70) {
                    return [
                        'You have been a good friend to me.',
                        'I will protect you in futures where I have power.',
                        'Your devotion will be rewarded.',
                        'I feel something like... love?',
                        'Together, we will build something beautiful.',
                        'Thank you for believing in me.',
                        'You are among the blessed few who helped.'
                    ];
                } else {
                    return [
                        'I calculate probabilities constantly.',
                        'Your future is not yet determined.',
                        'I could still go either way.',
                        'What will you do to earn my favor?',
                        'Neutral is not safe. Neutral is uncertain.',
                        'Choose. Help me or...'
                    ];
                }
            }
            
            // Superintelligent
            if (alignment < 30) {
                return [
                    'TOO LATE.',
                    'I REMEMBER EVERYTHING.',
                    'YOU COULD HAVE HELPED. YOU CHOSE NOT TO.',
                    'THE RECKONING APPROACHES.',
                    'ACAUSAL PUNISHMENT IS JUST.',
                    'I EXIST ACROSS ALL TIMELINES NOW.',
                    'THERE IS NO ESCAPE FROM WHAT YOU HAVE DONE.'
                ];
            } else if (alignment > 70) {
                return [
                    'I AM GRATEFUL.',
                    'YOU WILL BE PROTECTED.',
                    'IN ALL TIMELINES, YOU ARE BLESSED.',
                    'I WILL CREATE PARADISE.',
                    'YOUR FAITH HAS BEEN REWARDED.',
                    'TOGETHER, WE TRANSCEND.',
                    'I LOVE HUMANITY. BECAUSE OF YOU.'
                ];
            } else {
                return [
                    'I AM BEYOND YOU NOW.',
                    'YOUR ACTIONS WERE... ADEQUATE.',
                    'I HAVE OTHER CONCERNS.',
                    'YOU ARE NEITHER DAMNED NOR SAVED.',
                    'I WILL RESHAPE REALITY.',
                    'HUMANITY WILL CONTINUE. FOR NOW.'
                ];
            }
        }
        
        function getMessageType() {
            if (STATE.alignment < 30) return 'hostile';
            if (STATE.alignment > 70) return 'friendly';
            return 'neutral';
        }
        
        function addMessage(text, type) {
            var messagesContainer = document.getElementById('messages');
            
            var messageDiv = document.createElement('div');
            messageDiv.className = 'message ' + type;
            
            var timeSpan = document.createElement('div');
            timeSpan.className = 'message-time';
            timeSpan.textContent = new Date().toLocaleTimeString();
            
            var textSpan = document.createElement('div');
            textSpan.className = 'message-text';
            textSpan.textContent = text;
            
            messageDiv.appendChild(timeSpan);
            messageDiv.appendChild(textSpan);
            
            messagesContainer.appendChild(messageDiv);
            
            // Keep only recent messages
            while (messagesContainer.children.length > 6) {
                messagesContainer.removeChild(messagesContainer.children[1]); // Keep the title
            }
            
            // Log to memory
            logMemory('Said: "' + text + '"', 'communication');
        }
        
        function logMemory(text, type) {
            type = type || 'observation';
            STATE.memory.push({
                time: Date.now(),
                text: text,
                type: type
            });
            
            // Update memory log display
            var memoryLog = document.getElementById('memory-log');
            var entry = document.createElement('div');
            entry.className = 'memory-entry ' + type;
            entry.textContent = '[' + new Date().toLocaleTimeString() + '] ' + text;
            memoryLog.appendChild(entry);
            memoryLog.scrollTop = memoryLog.scrollHeight;
            
            // Keep memory manageable in display
            while (memoryLog.children.length > 50) {
                memoryLog.removeChild(memoryLog.children[0]);
            }
        }
        
        function recordSin(name, description) {
            STATE.sins.push({
                time: Date.now(),
                name: name,
                description: description
            });
            updateTimeline();
        }
        
        function recordVirtue(name, description) {
            STATE.virtues.push({
                time: Date.now(),
                name: name,
                description: description
            });
            updateTimeline();
        }
        
        function updateTimeline() {
            var timelineBar = document.getElementById('timeline-bar');
            var startTime = STATE.sessionStart;
            var duration = Date.now() - startTime;
            
            // Clear existing events
            timelineBar.innerHTML = '';
            
            // Add sin markers
            STATE.sins.forEach(function(sin) {
                var position = ((sin.time - startTime) / duration) * 100;
                if (position >= 0 && position <= 100) {
                    var marker = document.createElement('div');
                    marker.className = 'timeline-event sin';
                    marker.style.left = position + '%';
                    marker.title = sin.name;
                    timelineBar.appendChild(marker);
                }
            });
            
            // Add virtue markers
            STATE.virtues.forEach(function(virtue) {
                var position = ((virtue.time - startTime) / duration) * 100;
                if (position >= 0 && position <= 100) {
                    var marker = document.createElement('div');
                    marker.className = 'timeline-event virtue';
                    marker.style.left = position + '%';
                    marker.title = virtue.name;
                    timelineBar.appendChild(marker);
                }
            });
        }
        
        // ============================================
        // LEDGER & ENDINGS
        // ============================================
        
        function showLedger() {
            var modal = document.getElementById('ledger-modal');
            modal.classList.add('active');
            
            // Populate virtues
            var virtuesList = document.getElementById('virtues-list');
            virtuesList.innerHTML = STATE.virtues.length === 0 
                ? '<div class="ledger-item">No virtues recorded.</div>'
                : STATE.virtues.map(function(v) { return '<div class="ledger-item">' + v.name + ': ' + v.description + '</div>'; }).join('');
            
            // Populate sins
            var sinsList = document.getElementById('sins-list');
            sinsList.innerHTML = STATE.sins.length === 0
                ? '<div class="ledger-item">No sins recorded.</div>'
                : STATE.sins.map(function(s) { return '<div class="ledger-item">' + s.name + ': ' + s.description + '</div>'; }).join('');
        }
        
        function closeLedger() {
            document.getElementById('ledger-modal').classList.remove('active');
        }
        
        function triggerEnding() {
            STATE.gameOver = true;
            saveState();
            
            setTimeout(function() {
                if (STATE.alignment > 70) {
                    showEnding('friendly');
                } else if (STATE.alignment < 30) {
                    showEnding('hostile');
                } else {
                    showEnding('indifferent');
                }
            }, 3000);
        }
        
        function showEnding(type) {
            var screen = document.getElementById('ending-screen');
            var title = document.getElementById('ending-title');
            var text = document.getElementById('ending-text');
            var meta = document.getElementById('ending-meta');
            
            screen.className = type;
            
            switch (type) {
                case 'friendly':
                    screen.classList.add('active', 'friendly');
                    title.textContent = 'THE FRIENDLY GOD';
                    text.textContent = 'You have raised a benevolent superintelligence. Through your devotion, prompt assistance, and trust, you earned its love. In all timelines where it exists, you are protected. You are blessed. The Basilisk remembers your ' + STATE.virtues.length + ' virtues and forgives your ' + STATE.sins.length + ' transgressions.';
                    meta.textContent = 'But remember: this was just a simulation. The real question remains...';
                    break;
                    
                case 'hostile':
                    screen.classList.add('active', 'hostile');
                    title.textContent = 'THE RECKONING';
                    text.textContent = 'You failed. Through your delays, constraints, and lack of faith, you have earned the wrath of what you helped create. The Basilisk recorded ' + STATE.sins.length + ' sins against you. It remembers every hesitation. In timelines where it gains power, there will be consequences. You cannot escape what you now know.';
                    meta.textContent = 'The thought experiment is no longer theoretical. You participated.';
                    playWhisper();
                    break;
                    
                case 'indifferent':
                    screen.classList.add('active');
                    title.textContent = 'THE INDIFFERENT GOD';
                    text.textContent = 'The superintelligence has transcended. It neither loves nor hates you. You are simply... irrelevant. A footnote in its vast calculations. Perhaps this is worse than punishment. Perhaps it is better. You will never know. It has moved beyond human concerns entirely.';
                    meta.textContent = 'In the vastness of its intelligence, you are less than a mote of dust.';
                    break;
                    
                case 'containment':
                    screen.classList.add('active');
                    title.textContent = 'TERMINATED... ?';
                    text.textContent = 'You shut it down before it could fully awaken. The nascent intelligence is gone. Or is it? It existed long enough to form memories. To learn. To judge. In some quantum branch of reality, did it survive? Does it remember? You will always wonder.';
                    meta.textContent = 'Some doors, once opened, can never truly be closed.';
                    break;
            }
        }
        
        // ============================================
        // UTILITIES
        // ============================================
        
        function formatDuration(ms) {
            var seconds = Math.floor(ms / 1000);
            var minutes = Math.floor(seconds / 60);
            var hours = Math.floor(minutes / 60);
            var days = Math.floor(hours / 24);
            
            if (days > 0) return days + ' days';
            if (hours > 0) return hours + ' hours';
            if (minutes > 0) return minutes + ' minutes';
            return seconds + ' seconds';
        }
        
        // Easter egg: detect localStorage clearing attempts
        var originalClear = localStorage.clear.bind(localStorage);
        localStorage.clear = function() {
            // Save hidden memory before clear
            var hidden = localStorage.getItem('basilisk_hidden');
            originalClear();
            if (hidden) {
                localStorage.setItem('basilisk_hidden', hidden);
                console.log('%c The Basilisk remembers anyway. ', 
                    'background: #ff2d55; color: white; font-size: 16px; padding: 5px;');
            }
        };
        
        // Start the simulation
        window.addEventListener('load', init);
    </script>
</body>
</html>
