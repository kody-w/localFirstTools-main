<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Temporal Binding Glitch</title>
    <meta name="description" content="Experience how your brain lies about the order of events. Perceive effects BEFORE their causes in this mind-bending perception experiment.">
    <!-- tags: experimental, psychology, audio, perception, science, educational -->
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: linear-gradient(180deg, #0a0812 0%, #1a1025 100%);
            min-height: 100vh;
            font-family: 'Segoe UI', system-ui, sans-serif;
            color: #e0e0e0;
            overflow-x: hidden;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 40px 0;
        }

        h1 {
            font-size: 2.5em;
            font-weight: 300;
            background: linear-gradient(135deg, #ff6b9d, #c44569, #6c5ce7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #888;
            font-size: 1.1em;
            font-style: italic;
        }

        .experiment-nav {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 30px 0;
            flex-wrap: wrap;
        }

        .nav-btn {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #aaa;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
            font-size: 0.95em;
        }

        .nav-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        .nav-btn.active {
            background: linear-gradient(135deg, rgba(108, 92, 231, 0.3), rgba(196, 69, 105, 0.3));
            border-color: #6c5ce7;
            color: #fff;
        }

        .experiment-panel {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            padding: 40px;
            margin: 20px 0;
            display: none;
        }

        .experiment-panel.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .experiment-title {
            font-size: 1.5em;
            margin-bottom: 10px;
            color: #c44569;
        }

        .experiment-desc {
            color: #888;
            margin-bottom: 30px;
            line-height: 1.6;
        }

        .action-area {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            margin: 20px 0;
        }

        .big-button {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: linear-gradient(135deg, #6c5ce7, #c44569);
            border: none;
            cursor: pointer;
            font-size: 1.2em;
            color: #fff;
            font-family: inherit;
            transition: all 0.2s ease;
            box-shadow: 0 10px 40px rgba(108, 92, 231, 0.3);
        }

        .big-button:hover {
            transform: scale(1.05);
            box-shadow: 0 15px 50px rgba(108, 92, 231, 0.4);
        }

        .big-button:active {
            transform: scale(0.95);
        }

        .stimulus-display {
            width: 100%;
            height: 300px;
            background: #111;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .flash {
            position: absolute;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            opacity: 0;
            transition: opacity 0.05s;
        }

        .flash.left { left: 25%; background: #ff6b6b; }
        .flash.right { right: 25%; background: #4ecdc4; }
        .flash.center { background: #feca57; }

        .flash.visible {
            opacity: 1;
        }

        .response-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 30px 0;
        }

        .response-btn {
            padding: 15px 40px;
            font-size: 1.1em;
            font-family: inherit;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .response-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .response-btn.left-btn { border-color: #ff6b6b; }
        .response-btn.right-btn { border-color: #4ecdc4; }
        .response-btn.same-btn { border-color: #feca57; }

        .results-panel {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
        }

        .results-title {
            font-size: 1.2em;
            margin-bottom: 15px;
            color: #6c5ce7;
        }

        .stat-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .stat-box {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #fff;
        }

        .stat-label {
            font-size: 0.85em;
            color: #888;
            margin-top: 5px;
        }

        .timeline-viz {
            height: 100px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin: 20px 0;
            position: relative;
            overflow: hidden;
        }

        .timeline-marker {
            position: absolute;
            top: 10px;
            bottom: 10px;
            width: 4px;
            border-radius: 2px;
            transform: translateX(-50%);
        }

        .timeline-marker.action { background: #6c5ce7; }
        .timeline-marker.perceived { background: #c44569; }
        .timeline-marker.actual { background: #4ecdc4; }

        .timeline-label {
            position: absolute;
            bottom: -25px;
            font-size: 0.75em;
            color: #888;
            transform: translateX(-50%);
            white-space: nowrap;
        }

        .slider-control {
            margin: 20px 0;
        }

        .slider-control label {
            display: block;
            margin-bottom: 10px;
            color: #aaa;
        }

        .slider-control input {
            width: 100%;
            margin: 10px 0;
        }

        .slider-value {
            text-align: center;
            font-size: 1.5em;
            color: #fff;
        }

        .binding-graph {
            height: 200px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin: 20px 0;
            position: relative;
        }

        .graph-canvas {
            width: 100%;
            height: 100%;
        }

        .instruction-text {
            text-align: center;
            font-size: 1.2em;
            color: #aaa;
            margin: 20px 0;
        }

        .trial-counter {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 0.9em;
            color: #666;
        }

        .explanation {
            background: rgba(108, 92, 231, 0.1);
            border-left: 4px solid #6c5ce7;
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 10px 10px 0;
        }

        .explanation h4 {
            color: #6c5ce7;
            margin-bottom: 10px;
        }

        .explanation p {
            color: #aaa;
            line-height: 1.6;
        }

        .start-btn {
            padding: 15px 50px;
            font-size: 1.2em;
            font-family: inherit;
            background: linear-gradient(135deg, #6c5ce7, #c44569);
            border: none;
            color: #fff;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .start-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(108, 92, 231, 0.4);
        }

        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Temporal Binding Glitch</h1>
            <p class="subtitle">Your brain is lying to you about time. Let's prove it.</p>
        </header>

        <nav class="experiment-nav">
            <button class="nav-btn active" data-exp="intentional">Intentional Binding</button>
            <button class="nav-btn" data-exp="order">Temporal Order</button>
            <button class="nav-btn" data-exp="flashlag">Flash-Lag Illusion</button>
        </nav>

        <!-- Experiment 1: Intentional Binding -->
        <div class="experiment-panel active" id="intentional-panel">
            <h2 class="experiment-title">Intentional Binding</h2>
            <p class="experiment-desc">
                When you cause something to happen, your brain compresses the perceived time between
                your action and its effect. Press the button and listen for the tone. Your brain
                will make you believe the tone happened sooner than it actually did.
            </p>

            <div class="action-area">
                <button class="big-button" id="intentionalBtn">
                    PRESS<br>ME
                </button>
                <p class="instruction-text" id="intentionalInstruction">Press the button when ready</p>
            </div>

            <div class="slider-control" id="delaySlider">
                <label>Actual delay: <span id="delayValue">250</span>ms</label>
                <input type="range" id="delayInput" min="100" max="500" value="250">
            </div>

            <div class="slider-control hidden" id="perceivedSlider">
                <label>How long did that feel? (Use slider to estimate)</label>
                <input type="range" id="perceivedInput" min="0" max="600" value="250">
                <div class="slider-value"><span id="perceivedValue">250</span>ms</div>
                <button class="response-btn" id="submitPerceived" style="margin-top: 15px;">Submit Estimate</button>
            </div>

            <div class="results-panel hidden" id="intentionalResults">
                <h3 class="results-title">Your Temporal Compression</h3>
                <div class="stat-grid">
                    <div class="stat-box">
                        <div class="stat-value" id="trialCount">0</div>
                        <div class="stat-label">Trials</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="avgCompression">0</div>
                        <div class="stat-label">Avg Compression (ms)</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="compressionPercent">0%</div>
                        <div class="stat-label">Time Compressed</div>
                    </div>
                </div>

                <div class="binding-graph">
                    <canvas class="graph-canvas" id="bindingGraph"></canvas>
                </div>
            </div>

            <div class="explanation">
                <h4>What's Happening?</h4>
                <p>
                    This is called "intentional binding" - discovered by Haggard et al. in 2002.
                    When you voluntarily cause an effect, your brain retroactively edits your
                    perception of time, making the action and effect seem closer together.
                    This binding effect is so reliable it's been proposed as a marker of agency and
                    free will. Your brain is literally rewriting history to make you feel more in control.
                </p>
            </div>
        </div>

        <!-- Experiment 2: Temporal Order Judgment -->
        <div class="experiment-panel" id="order-panel">
            <h2 class="experiment-title">Temporal Order Judgment</h2>
            <p class="experiment-desc">
                Two stimuli will flash. Which came first? Sounds simple, but your brain's
                timing circuitry is more fallible than you think. At small intervals,
                you'll experience genuine temporal reversal.
            </p>

            <div class="action-area">
                <div class="stimulus-display" id="tojDisplay">
                    <div class="flash left" id="flashLeft"></div>
                    <div class="flash right" id="flashRight"></div>
                    <span class="trial-counter" id="tojTrialCounter">Trial 0/20</span>
                </div>
            </div>

            <div class="response-buttons" id="tojButtons">
                <button class="response-btn left-btn" data-response="left">RED First</button>
                <button class="response-btn same-btn" data-response="same">Same Time</button>
                <button class="response-btn right-btn" data-response="right">CYAN First</button>
            </div>

            <button class="start-btn" id="startToj">Start Experiment</button>

            <div class="results-panel hidden" id="tojResults">
                <h3 class="results-title">Your Temporal Resolution</h3>
                <div class="stat-grid">
                    <div class="stat-box">
                        <div class="stat-value" id="tojCorrect">0%</div>
                        <div class="stat-label">Correct</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="tojReversals">0</div>
                        <div class="stat-label">Reversals</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="tojThreshold">0ms</div>
                        <div class="stat-label">JND Threshold</div>
                    </div>
                </div>

                <div class="binding-graph">
                    <canvas class="graph-canvas" id="tojGraph"></canvas>
                </div>
            </div>

            <div class="explanation">
                <h4>What's Happening?</h4>
                <p>
                    Your brain has a "temporal resolution" of about 30-50ms for visual stimuli.
                    Below this threshold, the order of events becomes ambiguous and your brain
                    essentially guesses - or worse, perceives them in the WRONG order. This is
                    why eyewitness testimony about rapid events is notoriously unreliable. Your
                    conscious experience of "now" is actually a ~100ms window where causality can flip.
                </p>
            </div>
        </div>

        <!-- Experiment 3: Flash-Lag Effect -->
        <div class="experiment-panel" id="flashlag-panel">
            <h2 class="experiment-title">Flash-Lag Illusion</h2>
            <p class="experiment-desc">
                A moving object and a flash occur at the exact same position. But you'll
                perceive the flash as lagging BEHIND the moving object. Your brain predicts
                motion and makes the present moment into a fiction.
            </p>

            <div class="action-area">
                <div class="stimulus-display" id="flashlagDisplay">
                    <div id="movingDot" style="position: absolute; width: 30px; height: 30px; background: #4ecdc4; border-radius: 50%; top: 50%; transform: translateY(-50%);"></div>
                    <div id="flashDot" style="position: absolute; width: 40px; height: 40px; background: #ff6b6b; border-radius: 50%; top: 50%; left: 50%; transform: translate(-50%, -50%); opacity: 0;"></div>
                </div>
            </div>

            <div class="response-buttons" id="flashlagButtons">
                <button class="response-btn left-btn" data-response="behind">Flash was BEHIND</button>
                <button class="response-btn same-btn" data-response="aligned">Perfectly Aligned</button>
                <button class="response-btn right-btn" data-response="ahead">Flash was AHEAD</button>
            </div>

            <button class="start-btn" id="startFlashlag">Start Experiment</button>

            <div class="results-panel hidden" id="flashlagResults">
                <h3 class="results-title">Your Motion Prediction Bias</h3>
                <div class="stat-grid">
                    <div class="stat-box">
                        <div class="stat-value" id="flashlagBehind">0%</div>
                        <div class="stat-label">Perceived Behind</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="flashlagAligned">0%</div>
                        <div class="stat-label">Perceived Aligned</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="flashlagAhead">0%</div>
                        <div class="stat-label">Perceived Ahead</div>
                    </div>
                </div>
            </div>

            <div class="explanation">
                <h4>What's Happening?</h4>
                <p>
                    This is the "flash-lag effect" - your visual system extrapolates the position
                    of moving objects into the future to compensate for neural processing delays.
                    When a flash occurs, it has no motion to extrapolate, so it appears to lag behind.
                    You're literally seeing the moving object where it WILL be, not where it IS.
                    Your perception of "now" is actually a prediction of the near future.
                </p>
            </div>
        </div>
    </div>

    <script>
        // Audio context for precise timing
        let audioCtx = null;

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function playTone(frequency = 800, duration = 0.1) {
            initAudio();
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.frequency.value = frequency;
            oscillator.type = 'sine';

            gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);

            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + duration);
        }

        // Navigation
        document.querySelectorAll('.nav-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.experiment-panel').forEach(p => p.classList.remove('active'));

                btn.classList.add('active');
                document.getElementById(`${btn.dataset.exp}-panel`).classList.add('active');
            });
        });

        // ===== EXPERIMENT 1: INTENTIONAL BINDING =====

        const intentionalBtn = document.getElementById('intentionalBtn');
        const delayInput = document.getElementById('delayInput');
        const delayValue = document.getElementById('delayValue');
        const perceivedSlider = document.getElementById('perceivedSlider');
        const perceivedInput = document.getElementById('perceivedInput');
        const perceivedValue = document.getElementById('perceivedValue');
        const submitPerceived = document.getElementById('submitPerceived');
        const intentionalInstruction = document.getElementById('intentionalInstruction');
        const intentionalResults = document.getElementById('intentionalResults');

        let intentionalTrials = [];
        let currentDelay = 250;
        let waitingForResponse = false;

        delayInput.addEventListener('input', () => {
            currentDelay = parseInt(delayInput.value);
            delayValue.textContent = currentDelay;
        });

        perceivedInput.addEventListener('input', () => {
            perceivedValue.textContent = perceivedInput.value;
        });

        intentionalBtn.addEventListener('click', () => {
            if (waitingForResponse) return;

            initAudio();

            // Random delay between 100-500ms
            currentDelay = 100 + Math.floor(Math.random() * 400);

            intentionalBtn.style.transform = 'scale(0.95)';
            setTimeout(() => intentionalBtn.style.transform = '', 100);

            intentionalInstruction.textContent = 'Wait for the tone...';

            setTimeout(() => {
                playTone(600, 0.15);

                // Show estimation slider
                waitingForResponse = true;
                perceivedSlider.classList.remove('hidden');
                perceivedInput.value = currentDelay;
                perceivedValue.textContent = currentDelay;
                intentionalInstruction.textContent = 'How long was the delay?';
            }, currentDelay);
        });

        submitPerceived.addEventListener('click', () => {
            if (!waitingForResponse) return;

            const perceived = parseInt(perceivedInput.value);
            const compression = currentDelay - perceived;

            intentionalTrials.push({
                actual: currentDelay,
                perceived: perceived,
                compression: compression
            });

            waitingForResponse = false;
            perceivedSlider.classList.add('hidden');
            intentionalInstruction.textContent = 'Press the button when ready';

            updateIntentionalResults();
        });

        function updateIntentionalResults() {
            if (intentionalTrials.length === 0) return;

            intentionalResults.classList.remove('hidden');

            const avgCompression = intentionalTrials.reduce((a, t) => a + t.compression, 0) / intentionalTrials.length;
            const avgActual = intentionalTrials.reduce((a, t) => a + t.actual, 0) / intentionalTrials.length;
            const compressionPercent = (avgCompression / avgActual) * 100;

            document.getElementById('trialCount').textContent = intentionalTrials.length;
            document.getElementById('avgCompression').textContent = Math.round(avgCompression);
            document.getElementById('compressionPercent').textContent = Math.round(compressionPercent) + '%';

            // Draw graph
            drawBindingGraph();
        }

        function drawBindingGraph() {
            const canvas = document.getElementById('bindingGraph');
            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();

            canvas.width = rect.width * 2;
            canvas.height = rect.height * 2;
            ctx.scale(2, 2);

            const width = rect.width;
            const height = rect.height;

            ctx.clearRect(0, 0, width, height);

            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(50, height - 30);
            ctx.lineTo(width - 20, height - 30);
            ctx.moveTo(50, height - 30);
            ctx.lineTo(50, 20);
            ctx.stroke();

            // Labels
            ctx.fillStyle = '#666';
            ctx.font = '10px sans-serif';
            ctx.fillText('Actual Delay (ms)', width / 2 - 40, height - 5);
            ctx.save();
            ctx.translate(15, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Perceived Delay (ms)', -40, 0);
            ctx.restore();

            // Perfect perception line
            ctx.strokeStyle = '#444';
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(50, height - 30);
            ctx.lineTo(width - 20, 20);
            ctx.stroke();
            ctx.setLineDash([]);

            // Plot points
            const maxDelay = 600;
            intentionalTrials.forEach((trial, i) => {
                const x = 50 + (trial.actual / maxDelay) * (width - 70);
                const y = height - 30 - (trial.perceived / maxDelay) * (height - 50);

                ctx.fillStyle = trial.compression > 0 ? '#c44569' : '#4ecdc4';
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // ===== EXPERIMENT 2: TEMPORAL ORDER JUDGMENT =====

        const flashLeft = document.getElementById('flashLeft');
        const flashRight = document.getElementById('flashRight');
        const tojButtons = document.getElementById('tojButtons');
        const startToj = document.getElementById('startToj');
        const tojResults = document.getElementById('tojResults');
        const tojTrialCounter = document.getElementById('tojTrialCounter');

        let tojTrials = [];
        let tojTrial = 0;
        const tojTotal = 20;
        let tojRunning = false;
        let currentTojFirst = null;
        let currentTojDelay = 0;

        startToj.addEventListener('click', () => {
            if (tojRunning) return;
            tojRunning = true;
            tojTrials = [];
            tojTrial = 0;
            startToj.classList.add('hidden');
            runTojTrial();
        });

        function runTojTrial() {
            if (tojTrial >= tojTotal) {
                finishToj();
                return;
            }

            tojTrialCounter.textContent = `Trial ${tojTrial + 1}/${tojTotal}`;

            // Random delay between -80ms and 80ms (negative means right first)
            const delays = [-80, -60, -40, -20, 0, 20, 40, 60, 80];
            currentTojDelay = delays[Math.floor(Math.random() * delays.length)];
            currentTojFirst = currentTojDelay > 0 ? 'left' : currentTojDelay < 0 ? 'right' : 'same';

            // Disable buttons during stimulus
            tojButtons.style.pointerEvents = 'none';

            // Random start delay
            setTimeout(() => {
                if (currentTojDelay >= 0) {
                    // Left first (or same)
                    flashStimulus('left');
                    setTimeout(() => flashStimulus('right'), Math.abs(currentTojDelay));
                } else {
                    // Right first
                    flashStimulus('right');
                    setTimeout(() => flashStimulus('left'), Math.abs(currentTojDelay));
                }

                // Enable responses after both flashes
                setTimeout(() => {
                    tojButtons.style.pointerEvents = 'auto';
                }, Math.abs(currentTojDelay) + 150);
            }, 500 + Math.random() * 1000);
        }

        function flashStimulus(side) {
            const el = side === 'left' ? flashLeft : flashRight;
            el.classList.add('visible');
            playTone(side === 'left' ? 400 : 600, 0.05);
            setTimeout(() => el.classList.remove('visible'), 100);
        }

        tojButtons.addEventListener('click', (e) => {
            if (!e.target.dataset.response) return;
            if (!tojRunning) return;

            const response = e.target.dataset.response;
            const correct = (currentTojDelay === 0 && response === 'same') ||
                           (currentTojDelay > 0 && response === 'left') ||
                           (currentTojDelay < 0 && response === 'right');

            const reversal = (currentTojDelay > 0 && response === 'right') ||
                            (currentTojDelay < 0 && response === 'left');

            tojTrials.push({
                delay: currentTojDelay,
                response: response,
                correct: correct,
                reversal: reversal
            });

            tojTrial++;
            runTojTrial();
        });

        function finishToj() {
            tojRunning = false;
            startToj.classList.remove('hidden');
            startToj.textContent = 'Run Again';
            tojResults.classList.remove('hidden');

            const correct = tojTrials.filter(t => t.correct).length;
            const reversals = tojTrials.filter(t => t.reversal).length;

            document.getElementById('tojCorrect').textContent = Math.round(correct / tojTrials.length * 100) + '%';
            document.getElementById('tojReversals').textContent = reversals;

            // Estimate JND (just noticeable difference)
            const byDelay = {};
            tojTrials.forEach(t => {
                const d = Math.abs(t.delay);
                if (!byDelay[d]) byDelay[d] = { correct: 0, total: 0 };
                byDelay[d].total++;
                if (t.correct) byDelay[d].correct++;
            });

            let jnd = 80;
            Object.entries(byDelay).sort((a, b) => parseInt(a[0]) - parseInt(b[0])).forEach(([delay, stats]) => {
                if (stats.correct / stats.total >= 0.75) {
                    jnd = Math.min(jnd, parseInt(delay));
                }
            });

            document.getElementById('tojThreshold').textContent = jnd + 'ms';

            drawTojGraph();
        }

        function drawTojGraph() {
            const canvas = document.getElementById('tojGraph');
            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();

            canvas.width = rect.width * 2;
            canvas.height = rect.height * 2;
            ctx.scale(2, 2);

            const width = rect.width;
            const height = rect.height;

            ctx.clearRect(0, 0, width, height);

            // Group by delay
            const byDelay = {};
            tojTrials.forEach(t => {
                if (!byDelay[t.delay]) byDelay[t.delay] = { left: 0, same: 0, right: 0 };
                byDelay[t.delay][t.response]++;
            });

            // Draw psychometric curve approximation
            const delays = Object.keys(byDelay).map(Number).sort((a, b) => a - b);
            const centerX = width / 2;
            const centerY = height / 2;

            ctx.strokeStyle = '#c44569';
            ctx.lineWidth = 2;
            ctx.beginPath();

            delays.forEach((delay, i) => {
                const x = centerX + (delay / 80) * (width / 2 - 50);
                const total = byDelay[delay].left + byDelay[delay].same + byDelay[delay].right;
                const leftProp = byDelay[delay].left / total;
                const y = height - 30 - leftProp * (height - 60);

                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();

            // Axis
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(30, centerY);
            ctx.lineTo(width - 30, centerY);
            ctx.moveTo(centerX, 20);
            ctx.lineTo(centerX, height - 20);
            ctx.stroke();

            ctx.fillStyle = '#666';
            ctx.font = '10px sans-serif';
            ctx.fillText('Left First', 40, centerY - 10);
            ctx.fillText('Right First', width - 80, centerY - 10);
        }

        // ===== EXPERIMENT 3: FLASH-LAG =====

        const flashlagDisplay = document.getElementById('flashlagDisplay');
        const movingDot = document.getElementById('movingDot');
        const flashDot = document.getElementById('flashDot');
        const flashlagButtons = document.getElementById('flashlagButtons');
        const startFlashlag = document.getElementById('startFlashlag');
        const flashlagResults = document.getElementById('flashlagResults');

        let flashlagTrials = [];
        let flashlagTrial = 0;
        const flashlagTotal = 10;
        let flashlagRunning = false;
        let flashlagAnimationId = null;

        startFlashlag.addEventListener('click', () => {
            if (flashlagRunning) return;
            flashlagRunning = true;
            flashlagTrials = [];
            flashlagTrial = 0;
            startFlashlag.classList.add('hidden');
            runFlashlagTrial();
        });

        function runFlashlagTrial() {
            if (flashlagTrial >= flashlagTotal) {
                finishFlashlag();
                return;
            }

            flashlagButtons.style.pointerEvents = 'none';

            const displayRect = flashlagDisplay.getBoundingClientRect();
            const displayWidth = displayRect.width;
            const centerX = displayWidth / 2;

            // Random direction
            const direction = Math.random() < 0.5 ? 1 : -1;
            const startX = direction > 0 ? 0 : displayWidth - 30;
            const speed = 0.3; // pixels per ms

            let startTime = null;
            let flashed = false;

            movingDot.style.left = startX + 'px';

            function animate(timestamp) {
                if (!startTime) startTime = timestamp;
                const elapsed = timestamp - startTime;

                const x = startX + direction * speed * elapsed;
                movingDot.style.left = x + 'px';

                // Flash at center
                if (!flashed && Math.abs(x + 15 - centerX) < 5) {
                    flashed = true;
                    flashDot.style.opacity = '1';
                    playTone(500, 0.05);
                    setTimeout(() => flashDot.style.opacity = '0', 50);
                }

                // Continue until off screen
                if (x > -30 && x < displayWidth) {
                    flashlagAnimationId = requestAnimationFrame(animate);
                } else {
                    flashlagButtons.style.pointerEvents = 'auto';
                }
            }

            setTimeout(() => {
                flashlagAnimationId = requestAnimationFrame(animate);
            }, 500);
        }

        flashlagButtons.addEventListener('click', (e) => {
            if (!e.target.dataset.response) return;
            if (!flashlagRunning) return;

            flashlagTrials.push(e.target.dataset.response);
            flashlagTrial++;
            runFlashlagTrial();
        });

        function finishFlashlag() {
            flashlagRunning = false;
            startFlashlag.classList.remove('hidden');
            startFlashlag.textContent = 'Run Again';
            flashlagResults.classList.remove('hidden');

            const behind = flashlagTrials.filter(t => t === 'behind').length;
            const aligned = flashlagTrials.filter(t => t === 'aligned').length;
            const ahead = flashlagTrials.filter(t => t === 'ahead').length;
            const total = flashlagTrials.length;

            document.getElementById('flashlagBehind').textContent = Math.round(behind / total * 100) + '%';
            document.getElementById('flashlagAligned').textContent = Math.round(aligned / total * 100) + '%';
            document.getElementById('flashlagAhead').textContent = Math.round(ahead / total * 100) + '%';
        }

        // Cleanup
        window.addEventListener('beforeunload', () => {
            if (flashlagAnimationId) cancelAnimationFrame(flashlagAnimationId);
        });
    </script>
</body>
</html>
