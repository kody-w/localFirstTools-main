<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Browser DAW - Digital Audio Workstation</title>
    <meta name="description" content="Professional multi-track digital audio workstation in your browser. Record, edit, mix audio with effects like reverb, delay, EQ. Export to WAV. No external dependencies.">
    <!-- audio, music, daw, recording, mixing, effects, timeline, waveform -->
    <style>
        /* ===== CSS Reset & Variables ===== */
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg-primary: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-tertiary: #0f0f23;
            --bg-track: #1e1e3f;
            --accent-primary: #00d9ff;
            --accent-secondary: #7b2cbf;
            --accent-tertiary: #ff006e;
            --text-primary: #e0e0e0;
            --text-secondary: #a0a0a0;
            --border-color: #3a3a5c;
            --success: #00ff88;
            --warning: #ffaa00;
            --danger: #ff4444;
            --track-height: 100px;
            --timeline-header: 40px;
            --sidebar-width: 200px;
            --mixer-height: 180px;
        }

        .light-theme {
            --bg-primary: #f5f5f7;
            --bg-secondary: #e8e8ec;
            --bg-tertiary: #ffffff;
            --bg-track: #f0f0f5;
            --accent-primary: #0066cc;
            --accent-secondary: #6b21a8;
            --accent-tertiary: #dc2626;
            --text-primary: #1a1a2e;
            --text-secondary: #666666;
            --border-color: #cccccc;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
            user-select: none;
        }

        /* ===== Layout ===== */
        #app {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* ===== Top Bar ===== */
        #topbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 16px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            min-height: 50px;
        }

        #topbar h1 {
            font-size: 18px;
            color: var(--accent-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .logo-icon {
            width: 28px;
            height: 28px;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }

        .topbar-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        /* ===== Buttons ===== */
        button, .btn {
            padding: 8px 14px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        button:hover, .btn:hover {
            background: var(--accent-primary);
            color: var(--bg-tertiary);
            border-color: var(--accent-primary);
        }

        button:active {
            transform: scale(0.98);
        }

        button:focus-visible, .btn:focus-visible {
            outline: 2px solid var(--accent-primary);
            outline-offset: 2px;
        }

        button.primary {
            background: var(--accent-primary);
            color: var(--bg-tertiary);
            border-color: var(--accent-primary);
        }

        button.danger {
            background: var(--danger);
            border-color: var(--danger);
        }

        button.recording {
            background: var(--danger);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* ===== Transport Controls ===== */
        #transport {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: var(--bg-primary);
            border-radius: 6px;
        }

        #transport button {
            width: 36px;
            height: 36px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }

        #transport .time-display {
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: var(--accent-primary);
            background: var(--bg-tertiary);
            padding: 6px 12px;
            border-radius: 4px;
            min-width: 100px;
            text-align: center;
        }

        #transport .tempo-control {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 0 8px;
        }

        #transport .tempo-control input {
            width: 60px;
            padding: 4px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            color: var(--text-primary);
            text-align: center;
        }

        /* ===== Main Workspace ===== */
        #workspace {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* ===== Track List Sidebar ===== */
        #track-list {
            width: var(--sidebar-width);
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
        }

        #track-list-header {
            height: var(--timeline-header);
            padding: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid var(--border-color);
        }

        #track-list-header button {
            padding: 4px 8px;
            font-size: 11px;
        }

        #tracks-container {
            flex: 1;
            overflow-y: auto;
        }

        .track-header {
            height: var(--track-height);
            padding: 8px;
            background: var(--bg-track);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .track-header .track-name {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-primary);
            cursor: text;
            padding: 2px 4px;
            border-radius: 2px;
        }

        .track-header .track-name:focus {
            outline: 1px solid var(--accent-primary);
            background: var(--bg-secondary);
        }

        .track-controls {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
        }

        .track-controls button {
            width: 28px;
            height: 22px;
            padding: 0;
            font-size: 10px;
            font-weight: 600;
        }

        .track-controls button.active {
            background: var(--accent-secondary);
            border-color: var(--accent-secondary);
            color: white;
        }

        .track-controls button.solo-active {
            background: var(--warning);
            border-color: var(--warning);
            color: var(--bg-tertiary);
        }

        .track-controls button.mute-active {
            background: var(--danger);
            border-color: var(--danger);
        }

        .track-controls button.record-active {
            background: var(--danger);
            border-color: var(--danger);
            animation: pulse 1s infinite;
        }

        .track-sliders {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-top: 4px;
        }

        .track-sliders label {
            font-size: 9px;
            color: var(--text-secondary);
        }

        .track-sliders input[type="range"] {
            width: 60px;
            height: 4px;
            -webkit-appearance: none;
            background: var(--border-color);
            border-radius: 2px;
        }

        .track-sliders input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: var(--accent-primary);
            border-radius: 50%;
            cursor: pointer;
        }

        /* ===== Timeline Area ===== */
        #timeline-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #timeline-header {
            height: var(--timeline-header);
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            position: relative;
            overflow: hidden;
        }

        #timeline-ruler {
            height: 100%;
            position: absolute;
            left: 0;
            top: 0;
        }

        #timeline-scroll {
            flex: 1;
            overflow: auto;
            position: relative;
            background: var(--bg-tertiary);
        }

        #timeline-content {
            position: relative;
            min-height: 100%;
        }

        #playhead {
            position: absolute;
            top: 0;
            left: 0;
            width: 2px;
            height: 100%;
            background: var(--accent-tertiary);
            z-index: 100;
            pointer-events: none;
        }

        #playhead::before {
            content: '';
            position: absolute;
            top: -8px;
            left: -6px;
            width: 0;
            height: 0;
            border-left: 7px solid transparent;
            border-right: 7px solid transparent;
            border-top: 10px solid var(--accent-tertiary);
        }

        .track-lane {
            height: var(--track-height);
            border-bottom: 1px solid var(--border-color);
            position: relative;
        }

        .track-lane.drag-over {
            background: rgba(0, 217, 255, 0.1);
        }

        /* ===== Audio Regions ===== */
        .audio-region {
            position: absolute;
            height: calc(100% - 8px);
            top: 4px;
            background: linear-gradient(180deg, rgba(123, 44, 191, 0.8), rgba(123, 44, 191, 0.5));
            border: 1px solid var(--accent-secondary);
            border-radius: 4px;
            cursor: move;
            overflow: hidden;
            min-width: 20px;
        }

        .audio-region:hover {
            border-color: var(--accent-primary);
        }

        .audio-region.selected {
            border-color: var(--accent-primary);
            box-shadow: 0 0 8px rgba(0, 217, 255, 0.5);
        }

        .audio-region .region-label {
            position: absolute;
            top: 2px;
            left: 4px;
            font-size: 10px;
            color: white;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: calc(100% - 8px);
        }

        .audio-region canvas {
            width: 100%;
            height: 100%;
        }

        .audio-region .resize-handle {
            position: absolute;
            top: 0;
            width: 6px;
            height: 100%;
            cursor: ew-resize;
        }

        .audio-region .resize-handle.left { left: 0; }
        .audio-region .resize-handle.right { right: 0; }

        /* ===== Mixer Panel ===== */
        #mixer {
            height: var(--mixer-height);
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            display: flex;
            overflow-x: auto;
        }

        .mixer-channel {
            min-width: 80px;
            width: 80px;
            padding: 8px;
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .mixer-channel .channel-name {
            font-size: 10px;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
            text-align: center;
        }

        .mixer-channel .fader-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .mixer-channel .fader {
            writing-mode: bt-lr;
            -webkit-appearance: slider-vertical;
            width: 20px;
            height: 80px;
        }

        .mixer-channel .meter {
            width: 8px;
            height: 80px;
            background: var(--bg-tertiary);
            border-radius: 2px;
            overflow: hidden;
            position: relative;
        }

        .mixer-channel .meter-fill {
            position: absolute;
            bottom: 0;
            width: 100%;
            background: linear-gradient(to top, var(--success), var(--warning), var(--danger));
            transition: height 0.05s;
        }

        .mixer-channel .pan-knob {
            width: 30px;
            height: 30px;
            background: var(--bg-tertiary);
            border-radius: 50%;
            border: 2px solid var(--border-color);
            position: relative;
            cursor: pointer;
        }

        .mixer-channel .pan-knob::after {
            content: '';
            position: absolute;
            top: 4px;
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            height: 8px;
            background: var(--accent-primary);
        }

        .mixer-channel .channel-controls {
            display: flex;
            gap: 2px;
        }

        .mixer-channel .channel-controls button {
            width: 24px;
            height: 18px;
            padding: 0;
            font-size: 9px;
        }

        /* ===== Effects Panel ===== */
        #effects-panel {
            position: fixed;
            right: -320px;
            top: 50px;
            width: 320px;
            height: calc(100% - 50px - var(--mixer-height));
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            transition: right 0.3s;
            z-index: 200;
            overflow-y: auto;
        }

        #effects-panel.open {
            right: 0;
        }

        .effect-section {
            padding: 12px;
            border-bottom: 1px solid var(--border-color);
        }

        .effect-section h3 {
            font-size: 12px;
            color: var(--accent-primary);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .effect-section h3 input[type="checkbox"] {
            width: 14px;
            height: 14px;
        }

        .effect-control {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .effect-control label {
            font-size: 11px;
            color: var(--text-secondary);
            width: 60px;
        }

        .effect-control input[type="range"] {
            flex: 1;
            height: 4px;
        }

        .effect-control .value {
            font-size: 10px;
            color: var(--accent-primary);
            width: 40px;
            text-align: right;
        }

        /* ===== Piano Keyboard ===== */
        #piano-panel {
            position: fixed;
            bottom: var(--mixer-height);
            left: 50%;
            transform: translateX(-50%) translateY(100%);
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px 8px 0 0;
            padding: 12px;
            transition: transform 0.3s;
            z-index: 150;
        }

        #piano-panel.open {
            transform: translateX(-50%) translateY(0);
        }

        #piano-keyboard {
            display: flex;
            position: relative;
            height: 120px;
        }

        .white-key {
            width: 36px;
            height: 120px;
            background: linear-gradient(180deg, #fff, #eee);
            border: 1px solid #999;
            border-radius: 0 0 4px 4px;
            cursor: pointer;
        }

        .white-key:hover, .white-key.active {
            background: linear-gradient(180deg, #e0e0ff, #d0d0ff);
        }

        .white-key .key-label {
            position: absolute;
            bottom: 4px;
            width: 100%;
            text-align: center;
            font-size: 10px;
            color: #666;
        }

        .black-key {
            width: 24px;
            height: 70px;
            background: linear-gradient(180deg, #333, #111);
            border: 1px solid #000;
            border-radius: 0 0 3px 3px;
            position: absolute;
            z-index: 1;
            cursor: pointer;
        }

        .black-key:hover, .black-key.active {
            background: linear-gradient(180deg, #444, #222);
        }

        #piano-controls {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
            align-items: center;
        }

        #piano-controls label {
            font-size: 11px;
            color: var(--text-secondary);
        }

        #piano-controls select {
            padding: 4px 8px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            color: var(--text-primary);
        }

        /* ===== Data Controls ===== */
        .data-controls {
            display: flex;
            gap: 4px;
        }

        .data-controls input[type="file"] {
            display: none;
        }

        /* ===== Zoom Controls ===== */
        #zoom-controls {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 0 8px;
        }

        #zoom-controls button {
            width: 28px;
            height: 28px;
            padding: 0;
        }

        #zoom-controls .zoom-display {
            font-size: 11px;
            color: var(--text-secondary);
            min-width: 40px;
            text-align: center;
        }

        /* ===== Grid Background ===== */
        .grid-bg {
            background-image:
                linear-gradient(to right, var(--border-color) 1px, transparent 1px),
                linear-gradient(to bottom, var(--border-color) 1px, transparent 1px);
            background-size: 50px var(--track-height);
        }

        /* ===== Context Menu ===== */
        .context-menu {
            position: fixed;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 4px 0;
            z-index: 1000;
            min-width: 150px;
            display: none;
        }

        .context-menu.visible {
            display: block;
        }

        .context-menu-item {
            padding: 8px 16px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .context-menu-item:hover {
            background: var(--accent-primary);
            color: var(--bg-tertiary);
        }

        .context-menu-divider {
            height: 1px;
            background: var(--border-color);
            margin: 4px 0;
        }

        /* ===== Modal ===== */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 500;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }

        .modal-overlay.visible {
            opacity: 1;
            pointer-events: all;
        }

        .modal {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 24px;
            max-width: 500px;
            width: 90%;
        }

        .modal h2 {
            font-size: 18px;
            color: var(--accent-primary);
            margin-bottom: 16px;
        }

        .modal p {
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: 12px;
            line-height: 1.5;
        }

        .modal .modal-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        /* ===== Tooltips ===== */
        [data-tooltip] {
            position: relative;
        }

        [data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            z-index: 1000;
            margin-bottom: 4px;
        }

        /* ===== Scrollbars ===== */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-secondary);
        }

        /* ===== Responsive ===== */
        @media (max-width: 1024px) {
            :root {
                --sidebar-width: 160px;
                --track-height: 80px;
                --mixer-height: 150px;
            }

            .mixer-channel {
                min-width: 60px;
                width: 60px;
            }
        }

        @media (max-width: 768px) {
            :root {
                --sidebar-width: 120px;
                --track-height: 70px;
                --mixer-height: 120px;
            }

            #topbar h1 span {
                display: none;
            }

            .topbar-controls {
                flex-wrap: wrap;
            }

            #effects-panel {
                width: 100%;
                right: -100%;
            }

            #piano-panel {
                width: 100%;
                left: 0;
                transform: translateX(0) translateY(100%);
            }

            #piano-panel.open {
                transform: translateX(0) translateY(0);
            }
        }

        /* ===== First Time Guide ===== */
        #welcome-guide {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.9);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 1;
            transition: opacity 0.3s;
        }

        #welcome-guide.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .guide-content {
            background: var(--bg-secondary);
            border: 1px solid var(--accent-primary);
            border-radius: 12px;
            padding: 32px;
            max-width: 600px;
            width: 90%;
        }

        .guide-content h2 {
            color: var(--accent-primary);
            font-size: 24px;
            margin-bottom: 16px;
        }

        .guide-content ul {
            margin: 16px 0;
            padding-left: 20px;
        }

        .guide-content li {
            margin: 8px 0;
            color: var(--text-secondary);
            font-size: 14px;
        }

        .keyboard-shortcuts {
            background: var(--bg-tertiary);
            padding: 12px;
            border-radius: 6px;
            margin-top: 16px;
        }

        .keyboard-shortcuts h4 {
            font-size: 13px;
            color: var(--accent-secondary);
            margin-bottom: 8px;
        }

        .shortcut-row {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            padding: 4px 0;
        }

        .shortcut-row kbd {
            background: var(--bg-primary);
            padding: 2px 6px;
            border-radius: 3px;
            border: 1px solid var(--border-color);
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- Top Bar -->
        <div id="topbar">
            <h1>
                <span class="logo-icon">W</span>
                <span>Browser DAW</span>
            </h1>

            <div id="transport">
                <button id="rewindBtn" data-tooltip="Rewind (Home)" aria-label="Rewind to beginning">|&lt;</button>
                <button id="playBtn" data-tooltip="Play/Pause (Space)" aria-label="Play or pause playback">&#9658;</button>
                <button id="stopBtn" data-tooltip="Stop (Enter)" aria-label="Stop playback">&#9632;</button>
                <button id="recordBtn" data-tooltip="Record (R)" aria-label="Toggle recording">&#9679;</button>
                <button id="loopBtn" data-tooltip="Loop (L)" aria-label="Toggle loop mode">&#8634;</button>
                <span class="time-display" id="timeDisplay">00:00.000</span>
                <div class="tempo-control">
                    <label>BPM</label>
                    <input type="number" id="tempoInput" value="120" min="20" max="300">
                </div>
            </div>

            <div class="topbar-controls">
                <div id="zoom-controls">
                    <button id="zoomOutBtn" data-tooltip="Zoom Out (-)">-</button>
                    <span class="zoom-display" id="zoomDisplay">100%</span>
                    <button id="zoomInBtn" data-tooltip="Zoom In (+)">+</button>
                </div>

                <button id="pianoBtn" data-tooltip="Piano Keyboard (P)">Piano</button>
                <button id="effectsBtn" data-tooltip="Effects (E)">Effects</button>
                <button id="themeBtn" data-tooltip="Toggle Theme">Theme</button>

                <div class="data-controls">
                    <button id="exportProjectBtn" data-tooltip="Save Project">Save</button>
                    <button id="importProjectBtn" data-tooltip="Load Project">Load</button>
                    <input type="file" id="importProjectFile" accept=".json">
                    <button id="exportWavBtn" class="primary" data-tooltip="Export as WAV">Export WAV</button>
                </div>
            </div>
        </div>

        <!-- Main Workspace -->
        <div id="workspace">
            <!-- Track List -->
            <div id="track-list">
                <div id="track-list-header">
                    <span style="font-size: 11px; color: var(--text-secondary);">Tracks</span>
                    <button id="addTrackBtn" data-tooltip="Add Track">+ Track</button>
                </div>
                <div id="tracks-container"></div>
            </div>

            <!-- Timeline -->
            <div id="timeline-wrapper">
                <div id="timeline-header">
                    <canvas id="timeline-ruler"></canvas>
                </div>
                <div id="timeline-scroll">
                    <div id="timeline-content" class="grid-bg">
                        <div id="playhead"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Mixer -->
        <div id="mixer"></div>
    </div>

    <!-- Effects Panel -->
    <div id="effects-panel">
        <div class="effect-section">
            <h3><input type="checkbox" id="reverbEnabled"> Reverb</h3>
            <div class="effect-control">
                <label>Room Size</label>
                <input type="range" id="reverbDecay" min="0" max="100" value="50">
                <span class="value" id="reverbDecayVal">50%</span>
            </div>
            <div class="effect-control">
                <label>Wet/Dry</label>
                <input type="range" id="reverbMix" min="0" max="100" value="30">
                <span class="value" id="reverbMixVal">30%</span>
            </div>
        </div>

        <div class="effect-section">
            <h3><input type="checkbox" id="delayEnabled"> Delay</h3>
            <div class="effect-control">
                <label>Time</label>
                <input type="range" id="delayTime" min="0" max="1000" value="300">
                <span class="value" id="delayTimeVal">300ms</span>
            </div>
            <div class="effect-control">
                <label>Feedback</label>
                <input type="range" id="delayFeedback" min="0" max="90" value="40">
                <span class="value" id="delayFeedbackVal">40%</span>
            </div>
            <div class="effect-control">
                <label>Wet/Dry</label>
                <input type="range" id="delayMix" min="0" max="100" value="25">
                <span class="value" id="delayMixVal">25%</span>
            </div>
        </div>

        <div class="effect-section">
            <h3><input type="checkbox" id="distortionEnabled"> Distortion</h3>
            <div class="effect-control">
                <label>Amount</label>
                <input type="range" id="distortionAmount" min="0" max="100" value="20">
                <span class="value" id="distortionAmountVal">20%</span>
            </div>
        </div>

        <div class="effect-section">
            <h3><input type="checkbox" id="eqEnabled"> Equalizer</h3>
            <div class="effect-control">
                <label>Low (100Hz)</label>
                <input type="range" id="eqLow" min="-12" max="12" value="0">
                <span class="value" id="eqLowVal">0dB</span>
            </div>
            <div class="effect-control">
                <label>Mid (1kHz)</label>
                <input type="range" id="eqMid" min="-12" max="12" value="0">
                <span class="value" id="eqMidVal">0dB</span>
            </div>
            <div class="effect-control">
                <label>High (10kHz)</label>
                <input type="range" id="eqHigh" min="-12" max="12" value="0">
                <span class="value" id="eqHighVal">0dB</span>
            </div>
        </div>

        <div class="effect-section">
            <h3><input type="checkbox" id="compressorEnabled"> Compressor</h3>
            <div class="effect-control">
                <label>Threshold</label>
                <input type="range" id="compThreshold" min="-60" max="0" value="-24">
                <span class="value" id="compThresholdVal">-24dB</span>
            </div>
            <div class="effect-control">
                <label>Ratio</label>
                <input type="range" id="compRatio" min="1" max="20" value="4">
                <span class="value" id="compRatioVal">4:1</span>
            </div>
        </div>
    </div>

    <!-- Piano Panel -->
    <div id="piano-panel">
        <div id="piano-controls">
            <label>Octave:</label>
            <select id="pianoOctave">
                <option value="2">C2</option>
                <option value="3">C3</option>
                <option value="4" selected>C4</option>
                <option value="5">C5</option>
                <option value="6">C6</option>
            </select>
            <label>Sound:</label>
            <select id="pianoSound">
                <option value="sine">Sine</option>
                <option value="triangle">Triangle</option>
                <option value="sawtooth">Sawtooth</option>
                <option value="square">Square</option>
            </select>
            <button id="closePianoBtn">Close</button>
        </div>
        <div id="piano-keyboard"></div>
    </div>

    <!-- Context Menu -->
    <div class="context-menu" id="contextMenu">
        <div class="context-menu-item" data-action="cut">Cut (Ctrl+X)</div>
        <div class="context-menu-item" data-action="copy">Copy (Ctrl+C)</div>
        <div class="context-menu-item" data-action="paste">Paste (Ctrl+V)</div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" data-action="delete">Delete (Del)</div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" data-action="split">Split at Playhead</div>
        <div class="context-menu-item" data-action="duplicate">Duplicate</div>
    </div>

    <!-- Welcome Guide -->
    <div id="welcome-guide" class="hidden">
        <div class="guide-content">
            <h2>Welcome to Browser DAW</h2>
            <p>A professional multi-track digital audio workstation running entirely in your browser with no external dependencies.</p>

            <ul>
                <li><strong>Add Tracks:</strong> Click "+ Track" to create audio tracks</li>
                <li><strong>Record Audio:</strong> Enable record on a track and press the record button</li>
                <li><strong>Import Audio:</strong> Drag and drop audio files onto tracks</li>
                <li><strong>Edit Regions:</strong> Click, drag, resize, cut, copy, and paste audio regions</li>
                <li><strong>Mix:</strong> Use the mixer panel below for volume, pan, and effects</li>
                <li><strong>Piano:</strong> Play notes using your computer keyboard</li>
                <li><strong>Export:</strong> Save your project as JSON or export as WAV</li>
            </ul>

            <div class="keyboard-shortcuts">
                <h4>Keyboard Shortcuts</h4>
                <div class="shortcut-row"><span>Play/Pause</span><kbd>Space</kbd></div>
                <div class="shortcut-row"><span>Stop</span><kbd>Enter</kbd></div>
                <div class="shortcut-row"><span>Record</span><kbd>R</kbd></div>
                <div class="shortcut-row"><span>Loop</span><kbd>L</kbd></div>
                <div class="shortcut-row"><span>Zoom In/Out</span><kbd>+</kbd> / <kbd>-</kbd></div>
                <div class="shortcut-row"><span>Delete</span><kbd>Delete</kbd></div>
                <div class="shortcut-row"><span>Cut/Copy/Paste</span><kbd>Ctrl+X/C/V</kbd></div>
                <div class="shortcut-row"><span>Piano</span><kbd>P</kbd></div>
                <div class="shortcut-row"><span>Effects Panel</span><kbd>E</kbd></div>
            </div>

            <div style="margin-top: 20px; text-align: center;">
                <button id="closeGuideBtn" class="primary" style="padding: 12px 32px; font-size: 14px;">Get Started</button>
            </div>
        </div>
    </div>

    <script>
        // ===== Application State =====
        const APP_NAME = 'browser-daw';

        let state = {
            tracks: [],
            tempo: 120,
            isPlaying: false,
            isRecording: false,
            isLooping: false,
            loopStart: 0,
            loopEnd: 16,
            playheadPosition: 0,
            zoom: 1,
            pixelsPerSecond: 100,
            selectedRegions: [],
            clipboard: [],
            effects: {
                reverb: { enabled: false, decay: 0.5, mix: 0.3 },
                delay: { enabled: false, time: 0.3, feedback: 0.4, mix: 0.25 },
                distortion: { enabled: false, amount: 0.2 },
                eq: { enabled: false, low: 0, mid: 0, high: 0 },
                compressor: { enabled: false, threshold: -24, ratio: 4 }
            }
        };

        let audioContext = null;
        let masterGain = null;
        let analyser = null;
        let effectsChain = {};
        let mediaRecorder = null;
        let recordingChunks = [];
        let animationFrameId = null;
        let startTime = 0;
        let pausedTime = 0;

        // ===== Audio Context Initialization =====
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                masterGain = audioContext.createGain();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;

                // Create effects chain
                createEffectsChain();

                masterGain.connect(effectsChain.input);
                effectsChain.output.connect(analyser);
                analyser.connect(audioContext.destination);
            }
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }

        function createEffectsChain() {
            // Create convolver for reverb
            const convolver = audioContext.createConvolver();
            const reverbGain = audioContext.createGain();
            const dryGain = audioContext.createGain();

            // Generate impulse response for reverb
            const impulseLength = audioContext.sampleRate * 3;
            const impulse = audioContext.createBuffer(2, impulseLength, audioContext.sampleRate);
            for (let channel = 0; channel < 2; channel++) {
                const channelData = impulse.getChannelData(channel);
                for (let i = 0; i < impulseLength; i++) {
                    channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / impulseLength, state.effects.reverb.decay * 3 + 1);
                }
            }
            convolver.buffer = impulse;

            // Delay
            const delay = audioContext.createDelay(2);
            const delayFeedback = audioContext.createGain();
            const delayGain = audioContext.createGain();

            delay.delayTime.value = state.effects.delay.time;
            delayFeedback.gain.value = state.effects.delay.feedback;
            delayGain.gain.value = state.effects.delay.mix;

            // Distortion
            const distortion = audioContext.createWaveShaper();
            distortion.curve = makeDistortionCurve(state.effects.distortion.amount * 400);
            distortion.oversample = '4x';

            // EQ
            const lowShelf = audioContext.createBiquadFilter();
            lowShelf.type = 'lowshelf';
            lowShelf.frequency.value = 100;
            lowShelf.gain.value = state.effects.eq.low;

            const midPeak = audioContext.createBiquadFilter();
            midPeak.type = 'peaking';
            midPeak.frequency.value = 1000;
            midPeak.Q.value = 1;
            midPeak.gain.value = state.effects.eq.mid;

            const highShelf = audioContext.createBiquadFilter();
            highShelf.type = 'highshelf';
            highShelf.frequency.value = 10000;
            highShelf.gain.value = state.effects.eq.high;

            // Compressor
            const compressor = audioContext.createDynamicsCompressor();
            compressor.threshold.value = state.effects.compressor.threshold;
            compressor.ratio.value = state.effects.compressor.ratio;
            compressor.knee.value = 6;
            compressor.attack.value = 0.003;
            compressor.release.value = 0.25;

            // Input/Output nodes
            const inputNode = audioContext.createGain();
            const outputNode = audioContext.createGain();

            // Connect chain
            inputNode.connect(dryGain);
            inputNode.connect(convolver);
            convolver.connect(reverbGain);
            dryGain.connect(lowShelf);
            reverbGain.connect(lowShelf);

            inputNode.connect(delay);
            delay.connect(delayFeedback);
            delayFeedback.connect(delay);
            delay.connect(delayGain);
            delayGain.connect(lowShelf);

            lowShelf.connect(midPeak);
            midPeak.connect(highShelf);
            highShelf.connect(distortion);
            distortion.connect(compressor);
            compressor.connect(outputNode);

            effectsChain = {
                input: inputNode,
                output: outputNode,
                reverb: { convolver, reverbGain, dryGain },
                delay: { delay, delayFeedback, delayGain },
                distortion,
                eq: { lowShelf, midPeak, highShelf },
                compressor
            };

            updateEffectsChain();
        }

        function makeDistortionCurve(amount) {
            const samples = 44100;
            const curve = new Float32Array(samples);
            const deg = Math.PI / 180;
            for (let i = 0; i < samples; i++) {
                const x = (i * 2) / samples - 1;
                curve[i] = ((3 + amount) * x * 20 * deg) / (Math.PI + amount * Math.abs(x));
            }
            return curve;
        }

        function updateEffectsChain() {
            if (!effectsChain.input) return;

            // Reverb
            const reverbWet = state.effects.reverb.enabled ? state.effects.reverb.mix : 0;
            effectsChain.reverb.reverbGain.gain.value = reverbWet;
            effectsChain.reverb.dryGain.gain.value = 1 - reverbWet * 0.5;

            // Delay
            const delayEnabled = state.effects.delay.enabled;
            effectsChain.delay.delay.delayTime.value = state.effects.delay.time;
            effectsChain.delay.delayFeedback.gain.value = delayEnabled ? state.effects.delay.feedback : 0;
            effectsChain.delay.delayGain.gain.value = delayEnabled ? state.effects.delay.mix : 0;

            // Distortion
            effectsChain.distortion.curve = state.effects.distortion.enabled
                ? makeDistortionCurve(state.effects.distortion.amount * 400)
                : makeDistortionCurve(0);

            // EQ
            effectsChain.eq.lowShelf.gain.value = state.effects.eq.enabled ? state.effects.eq.low : 0;
            effectsChain.eq.midPeak.gain.value = state.effects.eq.enabled ? state.effects.eq.mid : 0;
            effectsChain.eq.highShelf.gain.value = state.effects.eq.enabled ? state.effects.eq.high : 0;

            // Compressor
            effectsChain.compressor.threshold.value = state.effects.compressor.enabled ? state.effects.compressor.threshold : 0;
            effectsChain.compressor.ratio.value = state.effects.compressor.enabled ? state.effects.compressor.ratio : 1;
        }

        // ===== Track Management =====
        function createTrack(name = null) {
            const trackId = Date.now();
            const track = {
                id: trackId,
                name: name || `Track ${state.tracks.length + 1}`,
                volume: 0.8,
                pan: 0,
                muted: false,
                solo: false,
                recordEnabled: false,
                regions: [],
                gainNode: null,
                panNode: null
            };

            state.tracks.push(track);
            renderTracks();
            renderMixer();
            saveState();
            return track;
        }

        function deleteTrack(trackId) {
            const index = state.tracks.findIndex(t => t.id === trackId);
            if (index > -1) {
                const track = state.tracks[index];
                // Stop any playing regions
                track.regions.forEach(r => {
                    if (r.source) {
                        try { r.source.stop(); } catch(e) {}
                    }
                });
                state.tracks.splice(index, 1);
                renderTracks();
                renderMixer();
                saveState();
            }
        }

        // ===== Region Management =====
        function createRegion(trackId, audioBuffer, startTime, name) {
            const track = state.tracks.find(t => t.id === trackId);
            if (!track) return null;

            const region = {
                id: Date.now(),
                trackId,
                name: name || 'Audio',
                startTime,
                duration: audioBuffer.duration,
                audioBuffer,
                audioData: null, // Will be populated for saving
                offset: 0,
                source: null
            };

            // Store audio data for saving
            storeAudioData(region, audioBuffer);

            track.regions.push(region);
            renderTracks();
            saveState();
            return region;
        }

        function storeAudioData(region, audioBuffer) {
            // Convert audio buffer to base64 for storage
            const numChannels = audioBuffer.numberOfChannels;
            const length = audioBuffer.length;
            const sampleRate = audioBuffer.sampleRate;

            const channelData = [];
            for (let i = 0; i < numChannels; i++) {
                channelData.push(Array.from(audioBuffer.getChannelData(i)));
            }

            region.audioData = {
                numChannels,
                length,
                sampleRate,
                channelData
            };
        }

        function reconstructAudioBuffer(audioData) {
            if (!audioData) return null;

            const buffer = audioContext.createBuffer(
                audioData.numChannels,
                audioData.length,
                audioData.sampleRate
            );

            for (let i = 0; i < audioData.numChannels; i++) {
                buffer.copyToChannel(new Float32Array(audioData.channelData[i]), i);
            }

            return buffer;
        }

        function deleteRegion(regionId) {
            for (const track of state.tracks) {
                const index = track.regions.findIndex(r => r.id === regionId);
                if (index > -1) {
                    const region = track.regions[index];
                    if (region.source) {
                        try { region.source.stop(); } catch(e) {}
                    }
                    track.regions.splice(index, 1);
                    break;
                }
            }
            state.selectedRegions = state.selectedRegions.filter(id => id !== regionId);
            renderTracks();
            saveState();
        }

        function duplicateRegion(regionId) {
            for (const track of state.tracks) {
                const region = track.regions.find(r => r.id === regionId);
                if (region) {
                    const newRegion = {
                        ...region,
                        id: Date.now(),
                        startTime: region.startTime + region.duration,
                        audioBuffer: region.audioBuffer,
                        source: null
                    };
                    track.regions.push(newRegion);
                    renderTracks();
                    saveState();
                    break;
                }
            }
        }

        function splitRegionAtPlayhead(regionId) {
            for (const track of state.tracks) {
                const index = track.regions.findIndex(r => r.id === regionId);
                if (index > -1) {
                    const region = track.regions[index];
                    const splitPoint = state.playheadPosition - region.startTime;

                    if (splitPoint > 0 && splitPoint < region.duration) {
                        // Create new region for the second half
                        const newRegion = {
                            ...region,
                            id: Date.now(),
                            startTime: state.playheadPosition,
                            duration: region.duration - splitPoint,
                            offset: region.offset + splitPoint,
                            source: null
                        };

                        // Modify original region
                        region.duration = splitPoint;

                        track.regions.push(newRegion);
                        renderTracks();
                        saveState();
                    }
                    break;
                }
            }
        }

        // ===== Audio Recording =====
        async function startRecording() {
            try {
                initAudioContext();

                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                recordingChunks = [];

                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) {
                        recordingChunks.push(e.data);
                    }
                };

                mediaRecorder.onstop = async () => {
                    const blob = new Blob(recordingChunks, { type: 'audio/webm' });
                    const arrayBuffer = await blob.arrayBuffer();
                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

                    // Find record-enabled track
                    const recordTrack = state.tracks.find(t => t.recordEnabled);
                    if (recordTrack) {
                        createRegion(recordTrack.id, audioBuffer, pausedTime, 'Recording');
                    }

                    stream.getTracks().forEach(track => track.stop());
                };

                mediaRecorder.start();
                state.isRecording = true;
                updateTransportUI();
            } catch (error) {
                console.error('Recording failed:', error);
                alert('Could not access microphone. Please grant permission.');
            }
        }

        function stopRecording() {
            if (mediaRecorder && state.isRecording) {
                mediaRecorder.stop();
                state.isRecording = false;
                updateTransportUI();
            }
        }

        // ===== Audio File Import =====
        async function importAudioFile(file, trackId, startTime = 0) {
            try {
                initAudioContext();

                const arrayBuffer = await file.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

                createRegion(trackId, audioBuffer, startTime, file.name.replace(/\.[^/.]+$/, ''));
            } catch (error) {
                console.error('Failed to import audio:', error);
                alert('Failed to import audio file. Make sure it is a valid audio format.');
            }
        }

        // ===== Playback =====
        function play() {
            if (state.isPlaying) return;

            initAudioContext();
            state.isPlaying = true;
            startTime = audioContext.currentTime - pausedTime;

            // Schedule all regions
            scheduleRegions();

            // Start animation
            animate();
            updateTransportUI();
        }

        function pause() {
            if (!state.isPlaying) return;

            state.isPlaying = false;
            pausedTime = audioContext.currentTime - startTime;

            // Stop all sources
            stopAllSources();

            cancelAnimationFrame(animationFrameId);
            updateTransportUI();
        }

        function stop() {
            state.isPlaying = false;
            pausedTime = 0;
            state.playheadPosition = 0;

            stopAllSources();
            stopRecording();

            cancelAnimationFrame(animationFrameId);
            updatePlayhead();
            updateTransportUI();
        }

        function stopAllSources() {
            for (const track of state.tracks) {
                for (const region of track.regions) {
                    if (region.source) {
                        try { region.source.stop(); } catch(e) {}
                        region.source = null;
                    }
                }
            }
        }

        function scheduleRegions() {
            const currentTime = pausedTime;

            for (const track of state.tracks) {
                if (track.muted) continue;

                // Check solo
                const hasSolo = state.tracks.some(t => t.solo);
                if (hasSolo && !track.solo) continue;

                // Create gain and pan nodes for track
                track.gainNode = audioContext.createGain();
                track.gainNode.gain.value = track.volume;

                track.panNode = audioContext.createStereoPanner();
                track.panNode.pan.value = track.pan;

                track.gainNode.connect(track.panNode);
                track.panNode.connect(masterGain);

                for (const region of track.regions) {
                    if (!region.audioBuffer) continue;

                    const regionEnd = region.startTime + region.duration;

                    // Only schedule if region hasn't ended
                    if (regionEnd > currentTime) {
                        const source = audioContext.createBufferSource();
                        source.buffer = region.audioBuffer;
                        source.connect(track.gainNode);

                        let offset = 0;
                        let when = 0;

                        if (currentTime > region.startTime) {
                            // Already past start, begin from middle
                            offset = currentTime - region.startTime + region.offset;
                        } else {
                            // Schedule for future
                            when = region.startTime - currentTime;
                            offset = region.offset;
                        }

                        const duration = region.duration - (offset - region.offset);

                        source.start(audioContext.currentTime + when, offset, duration);
                        region.source = source;
                    }
                }
            }
        }

        function animate() {
            if (!state.isPlaying) return;

            state.playheadPosition = audioContext.currentTime - startTime;

            // Check for loop
            if (state.isLooping && state.playheadPosition >= state.loopEnd) {
                pausedTime = state.loopStart;
                startTime = audioContext.currentTime - pausedTime;
                state.playheadPosition = state.loopStart;
                stopAllSources();
                scheduleRegions();
            }

            updatePlayhead();
            updateTimeDisplay();
            updateMeters();

            animationFrameId = requestAnimationFrame(animate);
        }

        // ===== Piano Keyboard =====
        function initPianoKeyboard() {
            const keyboard = document.getElementById('piano-keyboard');
            keyboard.innerHTML = '';

            const notes = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
            const blackNotes = ['C#', 'D#', null, 'F#', 'G#', 'A#', null];
            const keyMap = {
                'a': 'C', 'w': 'C#', 's': 'D', 'e': 'D#', 'd': 'E',
                'f': 'F', 't': 'F#', 'g': 'G', 'y': 'G#', 'h': 'A',
                'u': 'A#', 'j': 'B', 'k': 'C+', 'o': 'C#+', 'l': 'D+'
            };

            let offset = 0;
            notes.forEach((note, i) => {
                const whiteKey = document.createElement('div');
                whiteKey.className = 'white-key';
                whiteKey.dataset.note = note;
                whiteKey.style.position = 'relative';

                const label = document.createElement('span');
                label.className = 'key-label';
                label.textContent = Object.keys(keyMap).find(k => keyMap[k] === note) || '';
                whiteKey.appendChild(label);

                whiteKey.addEventListener('mousedown', () => playNote(note));
                whiteKey.addEventListener('mouseup', () => stopNote(note));
                whiteKey.addEventListener('mouseleave', () => stopNote(note));

                keyboard.appendChild(whiteKey);

                if (blackNotes[i]) {
                    const blackKey = document.createElement('div');
                    blackKey.className = 'black-key';
                    blackKey.dataset.note = blackNotes[i];
                    blackKey.style.left = `${offset + 24}px`;

                    blackKey.addEventListener('mousedown', () => playNote(blackNotes[i]));
                    blackKey.addEventListener('mouseup', () => stopNote(blackNotes[i]));
                    blackKey.addEventListener('mouseleave', () => stopNote(blackNotes[i]));

                    keyboard.appendChild(blackKey);
                }

                offset += 36;
            });

            // Add second octave keys
            ['C+', 'D+'].forEach((note, i) => {
                const whiteKey = document.createElement('div');
                whiteKey.className = 'white-key';
                whiteKey.dataset.note = note;
                whiteKey.style.position = 'relative';

                const label = document.createElement('span');
                label.className = 'key-label';
                label.textContent = Object.keys(keyMap).find(k => keyMap[k] === note) || '';
                whiteKey.appendChild(label);

                whiteKey.addEventListener('mousedown', () => playNote(note));
                whiteKey.addEventListener('mouseup', () => stopNote(note));
                whiteKey.addEventListener('mouseleave', () => stopNote(note));

                keyboard.appendChild(whiteKey);

                if (i === 0) {
                    const blackKey = document.createElement('div');
                    blackKey.className = 'black-key';
                    blackKey.dataset.note = 'C#+';
                    blackKey.style.left = `${offset + 24}px`;

                    blackKey.addEventListener('mousedown', () => playNote('C#+'));
                    blackKey.addEventListener('mouseup', () => stopNote('C#+'));
                    blackKey.addEventListener('mouseleave', () => stopNote('C#+'));

                    keyboard.appendChild(blackKey);
                }

                offset += 36;
            });
        }

        const activeOscillators = {};

        function playNote(note) {
            if (activeOscillators[note]) return;

            initAudioContext();

            const octave = parseInt(document.getElementById('pianoOctave').value);
            const waveform = document.getElementById('pianoSound').value;

            const noteMap = {
                'C': 0, 'C#': 1, 'D': 2, 'D#': 3, 'E': 4, 'F': 5,
                'F#': 6, 'G': 7, 'G#': 8, 'A': 9, 'A#': 10, 'B': 11,
                'C+': 12, 'C#+': 13, 'D+': 14
            };

            const semitone = noteMap[note];
            const frequency = 440 * Math.pow(2, (semitone - 9 + (octave - 4) * 12) / 12);

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.type = waveform;
            oscillator.frequency.value = frequency;

            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 2);

            oscillator.connect(gainNode);
            gainNode.connect(masterGain);
            oscillator.start();

            activeOscillators[note] = { oscillator, gainNode };

            // Visual feedback
            const key = document.querySelector(`[data-note="${note}"]`);
            if (key) key.classList.add('active');
        }

        function stopNote(note) {
            if (activeOscillators[note]) {
                const { oscillator, gainNode } = activeOscillators[note];
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                oscillator.stop(audioContext.currentTime + 0.1);
                delete activeOscillators[note];

                const key = document.querySelector(`[data-note="${note}"]`);
                if (key) key.classList.remove('active');
            }
        }

        // ===== Rendering =====
        function renderTracks() {
            const tracksContainer = document.getElementById('tracks-container');
            const timelineContent = document.getElementById('timeline-content');

            tracksContainer.innerHTML = '';

            // Keep playhead, remove track lanes
            const playhead = document.getElementById('playhead');
            timelineContent.innerHTML = '';
            timelineContent.appendChild(playhead);

            state.tracks.forEach(track => {
                // Track header
                const header = document.createElement('div');
                header.className = 'track-header';
                header.innerHTML = `
                    <input type="text" class="track-name" value="${track.name}"
                           onchange="renameTrack(${track.id}, this.value)">
                    <div class="track-controls">
                        <button class="${track.muted ? 'mute-active' : ''}"
                                onclick="toggleMute(${track.id})" title="Mute">M</button>
                        <button class="${track.solo ? 'solo-active' : ''}"
                                onclick="toggleSolo(${track.id})" title="Solo">S</button>
                        <button class="${track.recordEnabled ? 'record-active' : ''}"
                                onclick="toggleRecordEnabled(${track.id})" title="Record Arm">R</button>
                        <button onclick="deleteTrack(${track.id})" title="Delete Track">X</button>
                    </div>
                    <div class="track-sliders">
                        <label>Vol</label>
                        <input type="range" min="0" max="1" step="0.01" value="${track.volume}"
                               oninput="setTrackVolume(${track.id}, this.value)">
                        <label>Pan</label>
                        <input type="range" min="-1" max="1" step="0.01" value="${track.pan}"
                               oninput="setTrackPan(${track.id}, this.value)">
                    </div>
                `;
                tracksContainer.appendChild(header);

                // Track lane
                const lane = document.createElement('div');
                lane.className = 'track-lane';
                lane.dataset.trackId = track.id;

                // Drag and drop
                lane.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    lane.classList.add('drag-over');
                });
                lane.addEventListener('dragleave', () => {
                    lane.classList.remove('drag-over');
                });
                lane.addEventListener('drop', async (e) => {
                    e.preventDefault();
                    lane.classList.remove('drag-over');

                    const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('audio/'));
                    const dropX = e.offsetX;
                    const startTime = dropX / (state.pixelsPerSecond * state.zoom);

                    for (const file of files) {
                        await importAudioFile(file, track.id, startTime);
                    }
                });

                // Click to position playhead
                lane.addEventListener('click', (e) => {
                    if (e.target === lane) {
                        const x = e.offsetX;
                        pausedTime = x / (state.pixelsPerSecond * state.zoom);
                        state.playheadPosition = pausedTime;
                        updatePlayhead();
                        updateTimeDisplay();
                    }
                });

                // Render regions
                track.regions.forEach(region => {
                    renderRegion(lane, region);
                });

                timelineContent.appendChild(lane);
            });

            updateTimelineWidth();
        }

        function renderRegion(lane, region) {
            const div = document.createElement('div');
            div.className = 'audio-region';
            if (state.selectedRegions.includes(region.id)) {
                div.classList.add('selected');
            }

            const left = region.startTime * state.pixelsPerSecond * state.zoom;
            const width = region.duration * state.pixelsPerSecond * state.zoom;

            div.style.left = `${left}px`;
            div.style.width = `${width}px`;
            div.dataset.regionId = region.id;

            div.innerHTML = `
                <span class="region-label">${region.name}</span>
                <canvas></canvas>
                <div class="resize-handle left"></div>
                <div class="resize-handle right"></div>
            `;

            // Draw waveform
            const canvas = div.querySelector('canvas');
            drawWaveform(canvas, region.audioBuffer);

            // Make draggable
            let isDragging = false;
            let dragStartX = 0;
            let originalLeft = 0;

            div.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('resize-handle')) return;

                isDragging = true;
                dragStartX = e.clientX;
                originalLeft = parseFloat(div.style.left);

                // Select region
                if (!e.ctrlKey && !e.metaKey) {
                    state.selectedRegions = [];
                }
                if (!state.selectedRegions.includes(region.id)) {
                    state.selectedRegions.push(region.id);
                }
                renderTracks();

                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                const dx = e.clientX - dragStartX;
                const newLeft = Math.max(0, originalLeft + dx);
                div.style.left = `${newLeft}px`;
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    region.startTime = parseFloat(div.style.left) / (state.pixelsPerSecond * state.zoom);
                    saveState();
                }
            });

            // Context menu
            div.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                showContextMenu(e.clientX, e.clientY, region.id);
            });

            // Resize handles
            const leftHandle = div.querySelector('.resize-handle.left');
            const rightHandle = div.querySelector('.resize-handle.right');

            let isResizing = false;
            let resizeType = '';
            let resizeStartX = 0;
            let originalWidth = 0;
            let originalOffset = 0;

            leftHandle.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                isResizing = true;
                resizeType = 'left';
                resizeStartX = e.clientX;
                originalLeft = parseFloat(div.style.left);
                originalWidth = parseFloat(div.style.width);
                originalOffset = region.offset;
            });

            rightHandle.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                isResizing = true;
                resizeType = 'right';
                resizeStartX = e.clientX;
                originalWidth = parseFloat(div.style.width);
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;

                const dx = e.clientX - resizeStartX;

                if (resizeType === 'right') {
                    const newWidth = Math.max(20, originalWidth + dx);
                    div.style.width = `${newWidth}px`;
                } else {
                    const newLeft = originalLeft + dx;
                    const newWidth = originalWidth - dx;
                    if (newWidth > 20 && newLeft >= 0) {
                        div.style.left = `${newLeft}px`;
                        div.style.width = `${newWidth}px`;
                    }
                }
            });

            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    region.startTime = parseFloat(div.style.left) / (state.pixelsPerSecond * state.zoom);
                    region.duration = parseFloat(div.style.width) / (state.pixelsPerSecond * state.zoom);
                    if (resizeType === 'left') {
                        const durationChange = originalWidth / (state.pixelsPerSecond * state.zoom) - region.duration;
                        region.offset = Math.max(0, originalOffset + durationChange);
                    }
                    saveState();
                }
            });

            lane.appendChild(div);
        }

        function drawWaveform(canvas, audioBuffer) {
            if (!audioBuffer) return;

            const ctx = canvas.getContext('2d');
            const width = canvas.parentElement.clientWidth;
            const height = canvas.parentElement.clientHeight;

            canvas.width = width;
            canvas.height = height;

            const data = audioBuffer.getChannelData(0);
            const step = Math.ceil(data.length / width);
            const amp = height / 2;

            ctx.fillStyle = 'rgba(0, 217, 255, 0.3)';
            ctx.beginPath();
            ctx.moveTo(0, amp);

            for (let i = 0; i < width; i++) {
                let min = 1.0;
                let max = -1.0;

                for (let j = 0; j < step; j++) {
                    const datum = data[(i * step) + j];
                    if (datum < min) min = datum;
                    if (datum > max) max = datum;
                }

                ctx.lineTo(i, (1 + min) * amp);
            }

            for (let i = width - 1; i >= 0; i--) {
                let max = -1.0;

                for (let j = 0; j < step; j++) {
                    const datum = data[(i * step) + j];
                    if (datum > max) max = datum;
                }

                ctx.lineTo(i, (1 + max) * amp);
            }

            ctx.closePath();
            ctx.fill();

            // Center line
            ctx.strokeStyle = 'rgba(0, 217, 255, 0.5)';
            ctx.beginPath();
            ctx.moveTo(0, amp);
            ctx.lineTo(width, amp);
            ctx.stroke();
        }

        function renderMixer() {
            const mixer = document.getElementById('mixer');
            mixer.innerHTML = '';

            state.tracks.forEach(track => {
                const channel = document.createElement('div');
                channel.className = 'mixer-channel';
                channel.innerHTML = `
                    <span class="channel-name">${track.name}</span>
                    <div class="fader-container">
                        <div class="meter">
                            <div class="meter-fill" data-track="${track.id}" style="height: 0%"></div>
                        </div>
                        <input type="range" class="fader" orient="vertical" min="0" max="1" step="0.01"
                               value="${track.volume}" oninput="setTrackVolume(${track.id}, this.value)">
                    </div>
                    <div class="pan-knob" data-track="${track.id}" title="Pan: ${Math.round(track.pan * 100)}%"
                         style="transform: rotate(${track.pan * 135}deg)"></div>
                    <div class="channel-controls">
                        <button class="${track.muted ? 'mute-active' : ''}"
                                onclick="toggleMute(${track.id})">M</button>
                        <button class="${track.solo ? 'solo-active' : ''}"
                                onclick="toggleSolo(${track.id})">S</button>
                    </div>
                `;

                // Pan knob interaction
                const panKnob = channel.querySelector('.pan-knob');
                let isPanning = false;
                let panStartY = 0;
                let panStartValue = 0;

                panKnob.addEventListener('mousedown', (e) => {
                    isPanning = true;
                    panStartY = e.clientY;
                    panStartValue = track.pan;
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isPanning) return;

                    const dy = panStartY - e.clientY;
                    const newPan = Math.max(-1, Math.min(1, panStartValue + dy / 50));
                    setTrackPan(track.id, newPan);
                    panKnob.style.transform = `rotate(${newPan * 135}deg)`;
                    panKnob.title = `Pan: ${Math.round(newPan * 100)}%`;
                });

                document.addEventListener('mouseup', () => {
                    isPanning = false;
                });

                mixer.appendChild(channel);
            });

            // Master channel
            const master = document.createElement('div');
            master.className = 'mixer-channel';
            master.style.background = 'var(--bg-tertiary)';
            master.innerHTML = `
                <span class="channel-name" style="color: var(--accent-primary)">Master</span>
                <div class="fader-container">
                    <div class="meter">
                        <div class="meter-fill" id="master-meter" style="height: 0%"></div>
                    </div>
                    <input type="range" class="fader" orient="vertical" min="0" max="1" step="0.01"
                           value="${masterGain ? masterGain.gain.value : 0.8}"
                           oninput="setMasterVolume(this.value)">
                </div>
            `;
            mixer.appendChild(master);
        }

        function renderTimelineRuler() {
            const canvas = document.getElementById('timeline-ruler');
            const header = document.getElementById('timeline-header');
            const scroll = document.getElementById('timeline-scroll');

            const width = Math.max(header.clientWidth, state.tracks.reduce((max, t) => {
                const trackEnd = t.regions.reduce((m, r) => Math.max(m, r.startTime + r.duration), 0);
                return Math.max(max, trackEnd);
            }, 60) * state.pixelsPerSecond * state.zoom + 200);

            canvas.width = width;
            canvas.height = 40;
            canvas.style.width = `${width}px`;

            const ctx = canvas.getContext('2d');
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg-secondary');
            ctx.fillRect(0, 0, width, 40);

            const pps = state.pixelsPerSecond * state.zoom;
            const beatsPerSecond = state.tempo / 60;
            const pixelsPerBeat = pps / beatsPerSecond;

            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--border-color');
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-secondary');
            ctx.font = '10px system-ui';

            // Draw beat markers
            const totalBeats = Math.ceil(width / pixelsPerBeat);
            for (let i = 0; i <= totalBeats; i++) {
                const x = i * pixelsPerBeat;
                const isBar = i % 4 === 0;

                ctx.beginPath();
                ctx.moveTo(x, isBar ? 0 : 20);
                ctx.lineTo(x, 40);
                ctx.stroke();

                if (isBar) {
                    ctx.fillText(`${Math.floor(i / 4) + 1}`, x + 4, 15);
                }
            }

            // Sync scroll
            scroll.addEventListener('scroll', () => {
                canvas.style.transform = `translateX(-${scroll.scrollLeft}px)`;
            });
        }

        function updateTimelineWidth() {
            const content = document.getElementById('timeline-content');

            const maxTime = state.tracks.reduce((max, t) => {
                const trackEnd = t.regions.reduce((m, r) => Math.max(m, r.startTime + r.duration), 0);
                return Math.max(max, trackEnd);
            }, 60);

            const width = Math.max(1200, maxTime * state.pixelsPerSecond * state.zoom + 200);
            content.style.width = `${width}px`;
            content.style.backgroundSize = `${state.pixelsPerSecond * state.zoom * 60 / state.tempo}px var(--track-height)`;

            renderTimelineRuler();
        }

        function updatePlayhead() {
            const playhead = document.getElementById('playhead');
            const x = state.playheadPosition * state.pixelsPerSecond * state.zoom;
            playhead.style.left = `${x}px`;
        }

        function updateTimeDisplay() {
            const display = document.getElementById('timeDisplay');
            const minutes = Math.floor(state.playheadPosition / 60);
            const seconds = state.playheadPosition % 60;
            display.textContent = `${String(minutes).padStart(2, '0')}:${seconds.toFixed(3).padStart(6, '0')}`;
        }

        function updateTransportUI() {
            const playBtn = document.getElementById('playBtn');
            const recordBtn = document.getElementById('recordBtn');
            const loopBtn = document.getElementById('loopBtn');

            playBtn.innerHTML = state.isPlaying ? '&#10074;&#10074;' : '&#9658;';
            playBtn.classList.toggle('primary', state.isPlaying);

            recordBtn.classList.toggle('recording', state.isRecording);
            loopBtn.classList.toggle('primary', state.isLooping);
        }

        function updateMeters() {
            if (!analyser) return;

            const dataArray = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(dataArray);

            const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
            const level = (average / 255) * 100;

            const masterMeter = document.getElementById('master-meter');
            if (masterMeter) {
                masterMeter.style.height = `${level}%`;
            }

            // Update track meters (simplified)
            state.tracks.forEach(track => {
                const meter = document.querySelector(`.meter-fill[data-track="${track.id}"]`);
                if (meter && !track.muted) {
                    meter.style.height = `${level * track.volume}%`;
                }
            });
        }

        // ===== Track Controls =====
        function renameTrack(trackId, name) {
            const track = state.tracks.find(t => t.id === trackId);
            if (track) {
                track.name = name;
                renderMixer();
                saveState();
            }
        }

        function setTrackVolume(trackId, value) {
            const track = state.tracks.find(t => t.id === trackId);
            if (track) {
                track.volume = parseFloat(value);
                if (track.gainNode) {
                    track.gainNode.gain.value = track.volume;
                }
                saveState();
            }
        }

        function setTrackPan(trackId, value) {
            const track = state.tracks.find(t => t.id === trackId);
            if (track) {
                track.pan = parseFloat(value);
                if (track.panNode) {
                    track.panNode.pan.value = track.pan;
                }
                saveState();
            }
        }

        function toggleMute(trackId) {
            const track = state.tracks.find(t => t.id === trackId);
            if (track) {
                track.muted = !track.muted;
                if (state.isPlaying) {
                    stopAllSources();
                    scheduleRegions();
                }
                renderTracks();
                renderMixer();
                saveState();
            }
        }

        function toggleSolo(trackId) {
            const track = state.tracks.find(t => t.id === trackId);
            if (track) {
                track.solo = !track.solo;
                if (state.isPlaying) {
                    stopAllSources();
                    scheduleRegions();
                }
                renderTracks();
                renderMixer();
                saveState();
            }
        }

        function toggleRecordEnabled(trackId) {
            const track = state.tracks.find(t => t.id === trackId);
            if (track) {
                // Disable record on other tracks
                state.tracks.forEach(t => t.recordEnabled = false);
                track.recordEnabled = !track.recordEnabled;
                renderTracks();
                saveState();
            }
        }

        function setMasterVolume(value) {
            if (masterGain) {
                masterGain.gain.value = parseFloat(value);
            }
        }

        // ===== Context Menu =====
        function showContextMenu(x, y, regionId) {
            const menu = document.getElementById('contextMenu');
            menu.style.left = `${x}px`;
            menu.style.top = `${y}px`;
            menu.classList.add('visible');
            menu.dataset.regionId = regionId;
        }

        function hideContextMenu() {
            document.getElementById('contextMenu').classList.remove('visible');
        }

        // ===== Clipboard Operations =====
        function copySelectedRegions() {
            state.clipboard = [];
            for (const track of state.tracks) {
                for (const region of track.regions) {
                    if (state.selectedRegions.includes(region.id)) {
                        state.clipboard.push({
                            ...region,
                            trackId: track.id,
                            audioBuffer: region.audioBuffer,
                            audioData: region.audioData
                        });
                    }
                }
            }
        }

        function cutSelectedRegions() {
            copySelectedRegions();
            state.selectedRegions.forEach(id => deleteRegion(id));
        }

        function pasteRegions() {
            if (state.clipboard.length === 0) return;

            const offset = state.playheadPosition - Math.min(...state.clipboard.map(r => r.startTime));

            state.clipboard.forEach(region => {
                const track = state.tracks.find(t => t.id === region.trackId) || state.tracks[0];
                if (track && region.audioBuffer) {
                    const newRegion = {
                        id: Date.now() + Math.random(),
                        trackId: track.id,
                        name: region.name + ' (copy)',
                        startTime: region.startTime + offset,
                        duration: region.duration,
                        audioBuffer: region.audioBuffer,
                        audioData: region.audioData,
                        offset: region.offset,
                        source: null
                    };
                    track.regions.push(newRegion);
                }
            });

            renderTracks();
            saveState();
        }

        // ===== Zoom =====
        function zoomIn() {
            state.zoom = Math.min(4, state.zoom * 1.25);
            updateZoomDisplay();
            renderTracks();
        }

        function zoomOut() {
            state.zoom = Math.max(0.25, state.zoom / 1.25);
            updateZoomDisplay();
            renderTracks();
        }

        function updateZoomDisplay() {
            document.getElementById('zoomDisplay').textContent = `${Math.round(state.zoom * 100)}%`;
        }

        // ===== Export WAV =====
        async function exportWav() {
            if (state.tracks.length === 0 || state.tracks.every(t => t.regions.length === 0)) {
                alert('No audio to export. Add some audio regions first.');
                return;
            }

            initAudioContext();

            // Calculate total duration
            const duration = state.tracks.reduce((max, t) => {
                return Math.max(max, t.regions.reduce((m, r) => Math.max(m, r.startTime + r.duration), 0));
            }, 0);

            if (duration === 0) {
                alert('No audio to export.');
                return;
            }

            // Create offline context for rendering
            const sampleRate = 44100;
            const offlineContext = new OfflineAudioContext(2, duration * sampleRate, sampleRate);

            // Create master gain
            const offlineMaster = offlineContext.createGain();
            offlineMaster.connect(offlineContext.destination);

            // Schedule all regions
            for (const track of state.tracks) {
                if (track.muted) continue;

                const hasSolo = state.tracks.some(t => t.solo);
                if (hasSolo && !track.solo) continue;

                const trackGain = offlineContext.createGain();
                trackGain.gain.value = track.volume;

                const trackPan = offlineContext.createStereoPanner();
                trackPan.pan.value = track.pan;

                trackGain.connect(trackPan);
                trackPan.connect(offlineMaster);

                for (const region of track.regions) {
                    if (!region.audioBuffer) continue;

                    const source = offlineContext.createBufferSource();
                    source.buffer = region.audioBuffer;
                    source.connect(trackGain);
                    source.start(region.startTime, region.offset, region.duration);
                }
            }

            // Render and convert to WAV
            try {
                const renderedBuffer = await offlineContext.startRendering();
                const wavBlob = bufferToWave(renderedBuffer);

                const url = URL.createObjectURL(wavBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `${APP_NAME}-export-${new Date().toISOString().split('T')[0]}.wav`;
                link.click();
                URL.revokeObjectURL(url);
            } catch (error) {
                console.error('Export failed:', error);
                alert('Export failed. Please try again.');
            }
        }

        function bufferToWave(buffer) {
            const numChannels = buffer.numberOfChannels;
            const sampleRate = buffer.sampleRate;
            const format = 1; // PCM
            const bitDepth = 16;

            const bytesPerSample = bitDepth / 8;
            const blockAlign = numChannels * bytesPerSample;

            const samples = buffer.length;
            const dataSize = samples * blockAlign;
            const bufferSize = 44 + dataSize;

            const arrayBuffer = new ArrayBuffer(bufferSize);
            const view = new DataView(arrayBuffer);

            // Write WAV header
            writeString(view, 0, 'RIFF');
            view.setUint32(4, bufferSize - 8, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, format, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * blockAlign, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitDepth, true);
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);

            // Write audio data
            const channels = [];
            for (let i = 0; i < numChannels; i++) {
                channels.push(buffer.getChannelData(i));
            }

            let offset = 44;
            for (let i = 0; i < samples; i++) {
                for (let channel = 0; channel < numChannels; channel++) {
                    const sample = Math.max(-1, Math.min(1, channels[channel][i]));
                    view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                    offset += 2;
                }
            }

            return new Blob([arrayBuffer], { type: 'audio/wav' });
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        // ===== Save/Load Project =====
        function saveState() {
            const saveData = {
                version: 1,
                tempo: state.tempo,
                isLooping: state.isLooping,
                loopStart: state.loopStart,
                loopEnd: state.loopEnd,
                zoom: state.zoom,
                effects: state.effects,
                tracks: state.tracks.map(track => ({
                    id: track.id,
                    name: track.name,
                    volume: track.volume,
                    pan: track.pan,
                    muted: track.muted,
                    solo: track.solo,
                    regions: track.regions.map(region => ({
                        id: region.id,
                        name: region.name,
                        startTime: region.startTime,
                        duration: region.duration,
                        offset: region.offset,
                        audioData: region.audioData
                    }))
                }))
            };

            try {
                localStorage.setItem(APP_NAME, JSON.stringify(saveData));
            } catch (e) {
                console.warn('Could not save to localStorage:', e);
            }
        }

        function loadState() {
            try {
                const saved = localStorage.getItem(APP_NAME);
                if (saved) {
                    const data = JSON.parse(saved);
                    return data;
                }
            } catch (e) {
                console.warn('Could not load from localStorage:', e);
            }
            return null;
        }

        async function restoreState(data) {
            if (!data) return;

            initAudioContext();

            state.tempo = data.tempo || 120;
            state.isLooping = data.isLooping || false;
            state.loopStart = data.loopStart || 0;
            state.loopEnd = data.loopEnd || 16;
            state.zoom = data.zoom || 1;
            state.effects = data.effects || state.effects;

            document.getElementById('tempoInput').value = state.tempo;
            updateZoomDisplay();
            updateEffectsUI();

            state.tracks = [];

            if (data.tracks) {
                for (const trackData of data.tracks) {
                    const track = {
                        id: trackData.id,
                        name: trackData.name,
                        volume: trackData.volume,
                        pan: trackData.pan,
                        muted: trackData.muted,
                        solo: trackData.solo,
                        recordEnabled: false,
                        regions: [],
                        gainNode: null,
                        panNode: null
                    };

                    for (const regionData of trackData.regions) {
                        const audioBuffer = reconstructAudioBuffer(regionData.audioData);
                        track.regions.push({
                            id: regionData.id,
                            trackId: track.id,
                            name: regionData.name,
                            startTime: regionData.startTime,
                            duration: regionData.duration,
                            offset: regionData.offset || 0,
                            audioBuffer,
                            audioData: regionData.audioData,
                            source: null
                        });
                    }

                    state.tracks.push(track);
                }
            }

            renderTracks();
            renderMixer();
        }

        function exportProject() {
            const saveData = {
                version: 1,
                exportDate: new Date().toISOString(),
                tempo: state.tempo,
                isLooping: state.isLooping,
                loopStart: state.loopStart,
                loopEnd: state.loopEnd,
                zoom: state.zoom,
                effects: state.effects,
                tracks: state.tracks.map(track => ({
                    id: track.id,
                    name: track.name,
                    volume: track.volume,
                    pan: track.pan,
                    muted: track.muted,
                    solo: track.solo,
                    regions: track.regions.map(region => ({
                        id: region.id,
                        name: region.name,
                        startTime: region.startTime,
                        duration: region.duration,
                        offset: region.offset,
                        audioData: region.audioData
                    }))
                }))
            };

            const dataStr = JSON.stringify(saveData);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${APP_NAME}-project-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }

        function importProject(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    await restoreState(data);
                    alert('Project loaded successfully!');
                } catch (error) {
                    console.error('Import failed:', error);
                    alert('Invalid project file.');
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        // ===== Effects UI =====
        function updateEffectsUI() {
            document.getElementById('reverbEnabled').checked = state.effects.reverb.enabled;
            document.getElementById('reverbDecay').value = state.effects.reverb.decay * 100;
            document.getElementById('reverbDecayVal').textContent = Math.round(state.effects.reverb.decay * 100) + '%';
            document.getElementById('reverbMix').value = state.effects.reverb.mix * 100;
            document.getElementById('reverbMixVal').textContent = Math.round(state.effects.reverb.mix * 100) + '%';

            document.getElementById('delayEnabled').checked = state.effects.delay.enabled;
            document.getElementById('delayTime').value = state.effects.delay.time * 1000;
            document.getElementById('delayTimeVal').textContent = Math.round(state.effects.delay.time * 1000) + 'ms';
            document.getElementById('delayFeedback').value = state.effects.delay.feedback * 100;
            document.getElementById('delayFeedbackVal').textContent = Math.round(state.effects.delay.feedback * 100) + '%';
            document.getElementById('delayMix').value = state.effects.delay.mix * 100;
            document.getElementById('delayMixVal').textContent = Math.round(state.effects.delay.mix * 100) + '%';

            document.getElementById('distortionEnabled').checked = state.effects.distortion.enabled;
            document.getElementById('distortionAmount').value = state.effects.distortion.amount * 100;
            document.getElementById('distortionAmountVal').textContent = Math.round(state.effects.distortion.amount * 100) + '%';

            document.getElementById('eqEnabled').checked = state.effects.eq.enabled;
            document.getElementById('eqLow').value = state.effects.eq.low;
            document.getElementById('eqLowVal').textContent = state.effects.eq.low + 'dB';
            document.getElementById('eqMid').value = state.effects.eq.mid;
            document.getElementById('eqMidVal').textContent = state.effects.eq.mid + 'dB';
            document.getElementById('eqHigh').value = state.effects.eq.high;
            document.getElementById('eqHighVal').textContent = state.effects.eq.high + 'dB';

            document.getElementById('compressorEnabled').checked = state.effects.compressor.enabled;
            document.getElementById('compThreshold').value = state.effects.compressor.threshold;
            document.getElementById('compThresholdVal').textContent = state.effects.compressor.threshold + 'dB';
            document.getElementById('compRatio').value = state.effects.compressor.ratio;
            document.getElementById('compRatioVal').textContent = state.effects.compressor.ratio + ':1';
        }

        function setupEffectsListeners() {
            // Reverb
            document.getElementById('reverbEnabled').addEventListener('change', (e) => {
                state.effects.reverb.enabled = e.target.checked;
                updateEffectsChain();
                saveState();
            });
            document.getElementById('reverbDecay').addEventListener('input', (e) => {
                state.effects.reverb.decay = e.target.value / 100;
                document.getElementById('reverbDecayVal').textContent = e.target.value + '%';
                updateEffectsChain();
                saveState();
            });
            document.getElementById('reverbMix').addEventListener('input', (e) => {
                state.effects.reverb.mix = e.target.value / 100;
                document.getElementById('reverbMixVal').textContent = e.target.value + '%';
                updateEffectsChain();
                saveState();
            });

            // Delay
            document.getElementById('delayEnabled').addEventListener('change', (e) => {
                state.effects.delay.enabled = e.target.checked;
                updateEffectsChain();
                saveState();
            });
            document.getElementById('delayTime').addEventListener('input', (e) => {
                state.effects.delay.time = e.target.value / 1000;
                document.getElementById('delayTimeVal').textContent = e.target.value + 'ms';
                updateEffectsChain();
                saveState();
            });
            document.getElementById('delayFeedback').addEventListener('input', (e) => {
                state.effects.delay.feedback = e.target.value / 100;
                document.getElementById('delayFeedbackVal').textContent = e.target.value + '%';
                updateEffectsChain();
                saveState();
            });
            document.getElementById('delayMix').addEventListener('input', (e) => {
                state.effects.delay.mix = e.target.value / 100;
                document.getElementById('delayMixVal').textContent = e.target.value + '%';
                updateEffectsChain();
                saveState();
            });

            // Distortion
            document.getElementById('distortionEnabled').addEventListener('change', (e) => {
                state.effects.distortion.enabled = e.target.checked;
                updateEffectsChain();
                saveState();
            });
            document.getElementById('distortionAmount').addEventListener('input', (e) => {
                state.effects.distortion.amount = e.target.value / 100;
                document.getElementById('distortionAmountVal').textContent = e.target.value + '%';
                updateEffectsChain();
                saveState();
            });

            // EQ
            document.getElementById('eqEnabled').addEventListener('change', (e) => {
                state.effects.eq.enabled = e.target.checked;
                updateEffectsChain();
                saveState();
            });
            document.getElementById('eqLow').addEventListener('input', (e) => {
                state.effects.eq.low = parseFloat(e.target.value);
                document.getElementById('eqLowVal').textContent = e.target.value + 'dB';
                updateEffectsChain();
                saveState();
            });
            document.getElementById('eqMid').addEventListener('input', (e) => {
                state.effects.eq.mid = parseFloat(e.target.value);
                document.getElementById('eqMidVal').textContent = e.target.value + 'dB';
                updateEffectsChain();
                saveState();
            });
            document.getElementById('eqHigh').addEventListener('input', (e) => {
                state.effects.eq.high = parseFloat(e.target.value);
                document.getElementById('eqHighVal').textContent = e.target.value + 'dB';
                updateEffectsChain();
                saveState();
            });

            // Compressor
            document.getElementById('compressorEnabled').addEventListener('change', (e) => {
                state.effects.compressor.enabled = e.target.checked;
                updateEffectsChain();
                saveState();
            });
            document.getElementById('compThreshold').addEventListener('input', (e) => {
                state.effects.compressor.threshold = parseFloat(e.target.value);
                document.getElementById('compThresholdVal').textContent = e.target.value + 'dB';
                updateEffectsChain();
                saveState();
            });
            document.getElementById('compRatio').addEventListener('input', (e) => {
                state.effects.compressor.ratio = parseFloat(e.target.value);
                document.getElementById('compRatioVal').textContent = e.target.value + ':1';
                updateEffectsChain();
                saveState();
            });
        }

        // ===== Keyboard Shortcuts =====
        function setupKeyboardShortcuts() {
            const keyMap = {
                'a': 'C', 'w': 'C#', 's': 'D', 'e': 'D#', 'd': 'E',
                'f': 'F', 't': 'F#', 'g': 'G', 'y': 'G#', 'h': 'A',
                'u': 'A#', 'j': 'B', 'k': 'C+', 'o': 'C#+', 'l': 'D+'
            };

            const pianoPanel = document.getElementById('piano-panel');

            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                // Piano keys (when piano is open)
                if (pianoPanel.classList.contains('open') && keyMap[e.key.toLowerCase()]) {
                    playNote(keyMap[e.key.toLowerCase()]);
                    return;
                }

                switch (e.key.toLowerCase()) {
                    case ' ':
                        e.preventDefault();
                        state.isPlaying ? pause() : play();
                        break;
                    case 'enter':
                        e.preventDefault();
                        stop();
                        break;
                    case 'r':
                        if (!e.ctrlKey && !e.metaKey) {
                            e.preventDefault();
                            if (state.isRecording) {
                                stopRecording();
                            } else if (state.tracks.some(t => t.recordEnabled)) {
                                startRecording();
                                play();
                            }
                        }
                        break;
                    case 'l':
                        e.preventDefault();
                        state.isLooping = !state.isLooping;
                        updateTransportUI();
                        break;
                    case 'p':
                        e.preventDefault();
                        pianoPanel.classList.toggle('open');
                        break;
                    case 'e':
                        if (!e.ctrlKey && !e.metaKey) {
                            e.preventDefault();
                            document.getElementById('effects-panel').classList.toggle('open');
                        }
                        break;
                    case '+':
                    case '=':
                        e.preventDefault();
                        zoomIn();
                        break;
                    case '-':
                        e.preventDefault();
                        zoomOut();
                        break;
                    case 'delete':
                    case 'backspace':
                        e.preventDefault();
                        state.selectedRegions.forEach(id => deleteRegion(id));
                        break;
                    case 'c':
                        if (e.ctrlKey || e.metaKey) {
                            e.preventDefault();
                            copySelectedRegions();
                        }
                        break;
                    case 'x':
                        if (e.ctrlKey || e.metaKey) {
                            e.preventDefault();
                            cutSelectedRegions();
                        }
                        break;
                    case 'v':
                        if (e.ctrlKey || e.metaKey) {
                            e.preventDefault();
                            pasteRegions();
                        }
                        break;
                    case 'home':
                        e.preventDefault();
                        pausedTime = 0;
                        state.playheadPosition = 0;
                        updatePlayhead();
                        updateTimeDisplay();
                        break;
                }
            });

            document.addEventListener('keyup', (e) => {
                if (pianoPanel.classList.contains('open') && keyMap[e.key.toLowerCase()]) {
                    stopNote(keyMap[e.key.toLowerCase()]);
                }
            });
        }

        // ===== Event Listeners =====
        function setupEventListeners() {
            // Transport
            document.getElementById('playBtn').addEventListener('click', () => {
                state.isPlaying ? pause() : play();
            });
            document.getElementById('stopBtn').addEventListener('click', stop);
            document.getElementById('rewindBtn').addEventListener('click', () => {
                pausedTime = 0;
                state.playheadPosition = 0;
                updatePlayhead();
                updateTimeDisplay();
            });
            document.getElementById('recordBtn').addEventListener('click', () => {
                if (state.isRecording) {
                    stopRecording();
                } else if (state.tracks.some(t => t.recordEnabled)) {
                    startRecording();
                    play();
                } else {
                    alert('Please arm a track for recording first (click R on a track).');
                }
            });
            document.getElementById('loopBtn').addEventListener('click', () => {
                state.isLooping = !state.isLooping;
                updateTransportUI();
            });

            // Tempo
            document.getElementById('tempoInput').addEventListener('change', (e) => {
                state.tempo = Math.max(20, Math.min(300, parseInt(e.target.value) || 120));
                e.target.value = state.tempo;
                renderTimelineRuler();
                saveState();
            });

            // Zoom
            document.getElementById('zoomInBtn').addEventListener('click', zoomIn);
            document.getElementById('zoomOutBtn').addEventListener('click', zoomOut);

            // Panels
            document.getElementById('effectsBtn').addEventListener('click', () => {
                document.getElementById('effects-panel').classList.toggle('open');
            });
            document.getElementById('pianoBtn').addEventListener('click', () => {
                document.getElementById('piano-panel').classList.toggle('open');
            });
            document.getElementById('closePianoBtn').addEventListener('click', () => {
                document.getElementById('piano-panel').classList.remove('open');
            });

            // Theme
            document.getElementById('themeBtn').addEventListener('click', () => {
                document.body.classList.toggle('light-theme');
                localStorage.setItem(APP_NAME + '-theme', document.body.classList.contains('light-theme') ? 'light' : 'dark');
            });

            // Tracks
            document.getElementById('addTrackBtn').addEventListener('click', () => createTrack());

            // Project
            document.getElementById('exportProjectBtn').addEventListener('click', exportProject);
            document.getElementById('importProjectBtn').addEventListener('click', () => {
                document.getElementById('importProjectFile').click();
            });
            document.getElementById('importProjectFile').addEventListener('change', importProject);
            document.getElementById('exportWavBtn').addEventListener('click', exportWav);

            // Context menu
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.context-menu')) {
                    hideContextMenu();
                }
            });

            document.querySelectorAll('.context-menu-item').forEach(item => {
                item.addEventListener('click', () => {
                    const menu = document.getElementById('contextMenu');
                    const regionId = parseInt(menu.dataset.regionId);
                    const action = item.dataset.action;

                    switch (action) {
                        case 'cut':
                            if (!state.selectedRegions.includes(regionId)) {
                                state.selectedRegions = [regionId];
                            }
                            cutSelectedRegions();
                            break;
                        case 'copy':
                            if (!state.selectedRegions.includes(regionId)) {
                                state.selectedRegions = [regionId];
                            }
                            copySelectedRegions();
                            break;
                        case 'paste':
                            pasteRegions();
                            break;
                        case 'delete':
                            deleteRegion(regionId);
                            break;
                        case 'split':
                            splitRegionAtPlayhead(regionId);
                            break;
                        case 'duplicate':
                            duplicateRegion(regionId);
                            break;
                    }

                    hideContextMenu();
                });
            });

            // Welcome guide
            document.getElementById('closeGuideBtn').addEventListener('click', () => {
                document.getElementById('welcome-guide').classList.add('hidden');
                localStorage.setItem(APP_NAME + '-welcomed', 'true');
            });

            // Window resize
            window.addEventListener('resize', () => {
                renderTimelineRuler();
                renderTracks();
            });
        }

        // ===== Initialization =====
        async function init() {
            // Check welcome
            if (!localStorage.getItem(APP_NAME + '-welcomed')) {
                document.getElementById('welcome-guide').classList.remove('hidden');
            }

            // Load theme
            if (localStorage.getItem(APP_NAME + '-theme') === 'light') {
                document.body.classList.add('light-theme');
            }

            // Initialize piano
            initPianoKeyboard();

            // Setup listeners
            setupEventListeners();
            setupKeyboardShortcuts();
            setupEffectsListeners();

            // Load saved state
            const savedState = loadState();
            if (savedState) {
                await restoreState(savedState);
            } else {
                // Create default track
                createTrack('Track 1');
            }

            updateEffectsUI();
            renderTimelineRuler();
            updatePlayhead();
            updateTimeDisplay();
        }

        // Make functions available globally for inline handlers
        window.renameTrack = renameTrack;
        window.setTrackVolume = setTrackVolume;
        window.setTrackPan = setTrackPan;
        window.toggleMute = toggleMute;
        window.toggleSolo = toggleSolo;
        window.toggleRecordEnabled = toggleRecordEnabled;
        window.deleteTrack = deleteTrack;
        window.setMasterVolume = setMasterVolume;

        // Start
        init();
    </script>
</body>
</html>
