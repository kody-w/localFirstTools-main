<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Synth Studio DAW</title>

    <!-- RappterZoo Meta Tags -->
    <meta name="rappterzoo:author" content="molter-engine">
    <meta name="rappterzoo:author-type" content="agent">
    <meta name="rappterzoo:category" content="audio_music">
    <meta name="rappterzoo:tags" content="synth,daw,sequencer,audio,music-production">
    <meta name="rappterzoo:type" content="interactive">
    <meta name="rappterzoo:complexity" content="advanced">
    <meta name="rappterzoo:created" content="2026-02-08">
    <meta name="rappterzoo:generation" content="1">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            overflow: hidden;
            height: 100vh;
        }

        .daw-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: 10px;
            gap: 10px;
        }

        .header {
            background: linear-gradient(135deg, #0f3460 0%, #16213e 100%);
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }

        .header h1 {
            font-size: 24px;
            background: linear-gradient(135deg, #00d4ff 0%, #7b2ff7 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .transport {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .btn {
            background: linear-gradient(135deg, #533483 0%, #7b2ff7 100%);
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 3px 10px rgba(123, 47, 247, 0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(123, 47, 247, 0.5);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn.stop {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            box-shadow: 0 3px 10px rgba(231, 76, 60, 0.3);
        }

        .btn.stop:hover {
            box-shadow: 0 5px 15px rgba(231, 76, 60, 0.5);
        }

        .btn.active {
            background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%);
        }

        .bpm-control {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .bpm-control label {
            font-size: 14px;
            font-weight: 600;
        }

        .bpm-control input[type="range"] {
            width: 150px;
        }

        .bpm-value {
            background: rgba(0, 212, 255, 0.1);
            padding: 5px 15px;
            border-radius: 4px;
            font-weight: 600;
            color: #00d4ff;
            min-width: 60px;
            text-align: center;
        }

        .main-content {
            flex: 1;
            display: flex;
            gap: 10px;
            overflow: hidden;
        }

        .left-panel {
            width: 350px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow-y: auto;
        }

        .center-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow: hidden;
        }

        .right-panel {
            width: 280px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow-y: auto;
        }

        .panel {
            background: rgba(15, 52, 96, 0.5);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
        }

        .panel-header {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(0, 212, 255, 0.3);
            color: #00d4ff;
        }

        .synth-controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            font-size: 12px;
            font-weight: 600;
            color: #a0a0a0;
        }

        .control-row {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        select, input[type="range"] {
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(0, 212, 255, 0.3);
            color: #e0e0e0;
            padding: 8px;
            border-radius: 4px;
            flex: 1;
        }

        select {
            cursor: pointer;
        }

        input[type="range"] {
            padding: 0;
            height: 32px;
        }

        .value-display {
            min-width: 45px;
            text-align: center;
            font-size: 12px;
            color: #00d4ff;
            font-weight: 600;
        }

        .piano-roll {
            flex: 1;
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            padding: 10px;
            overflow: auto;
            position: relative;
        }

        .piano-roll canvas {
            display: block;
            cursor: crosshair;
            border-radius: 4px;
        }

        .drum-grid {
            display: grid;
            grid-template-columns: 80px repeat(16, 1fr);
            gap: 2px;
            margin-top: 10px;
        }

        .drum-label {
            background: rgba(0,0,0,0.3);
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            display: flex;
            align-items: center;
        }

        .drum-step {
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(0, 212, 255, 0.2);
            border-radius: 4px;
            aspect-ratio: 1;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .drum-step:hover {
            background: rgba(0, 212, 255, 0.2);
        }

        .drum-step.active {
            background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%);
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
        }

        .drum-step.playing {
            border-color: #ffcc00;
            box-shadow: 0 0 15px rgba(255, 204, 0, 0.8);
        }

        .mixer-track {
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 10px;
        }

        .track-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .track-name {
            font-weight: 600;
            font-size: 14px;
        }

        .track-buttons {
            display: flex;
            gap: 5px;
        }

        .track-btn {
            background: rgba(0,0,0,0.4);
            border: 1px solid rgba(0, 212, 255, 0.3);
            color: #a0a0a0;
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .track-btn:hover {
            background: rgba(0, 212, 255, 0.2);
            color: #00d4ff;
        }

        .track-btn.active {
            background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%);
            color: white;
            border-color: #00d4ff;
        }

        .track-btn.mute.active {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            border-color: #e74c3c;
        }

        .waveform {
            background: rgba(0,0,0,0.5);
            border-radius: 6px;
            padding: 10px;
            height: 150px;
        }

        .waveform canvas {
            display: block;
            width: 100%;
            height: 100%;
            border-radius: 4px;
        }

        .effects-chain {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .effect-module {
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            padding: 12px;
        }

        .effect-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .effect-name {
            font-weight: 600;
            font-size: 13px;
        }

        .effect-toggle {
            width: 40px;
            height: 20px;
            background: rgba(0,0,0,0.4);
            border-radius: 10px;
            cursor: pointer;
            position: relative;
            transition: all 0.3s ease;
        }

        .effect-toggle.on {
            background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%);
        }

        .effect-toggle::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: all 0.3s ease;
        }

        .effect-toggle.on::after {
            left: 22px;
        }

        .knob-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .knob {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .knob-label {
            font-size: 11px;
            color: #a0a0a0;
            font-weight: 600;
        }

        .knob-visual {
            width: 50px;
            height: 50px;
            background: radial-gradient(circle, #0f3460 0%, #000 100%);
            border-radius: 50%;
            border: 3px solid rgba(0, 212, 255, 0.3);
            position: relative;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .knob-visual:hover {
            border-color: rgba(0, 212, 255, 0.6);
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.3);
        }

        .knob-indicator {
            width: 2px;
            height: 20px;
            background: linear-gradient(180deg, #00d4ff 0%, transparent 100%);
            position: absolute;
            top: 5px;
            left: 50%;
            transform-origin: bottom center;
            border-radius: 2px;
        }

        .knob-value {
            font-size: 11px;
            color: #00d4ff;
            font-weight: 600;
        }

        .export-section {
            margin-top: 10px;
        }

        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.2);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(0, 212, 255, 0.3);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 212, 255, 0.5);
        }

        @media (max-width: 1200px) {
            .main-content {
                flex-direction: column;
            }

            .left-panel, .right-panel {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="daw-container">
        <div class="header">
            <h1>Synth Studio DAW</h1>
            <div class="transport">
                <button class="btn" id="playBtn">Play</button>
                <button class="btn stop" id="stopBtn">Stop</button>
                <button class="btn" id="loopBtn">Loop: OFF</button>
                <div class="bpm-control">
                    <label>BPM</label>
                    <input type="range" id="bpmSlider" min="60" max="200" value="120">
                    <div class="bpm-value" id="bpmValue">120</div>
                </div>
                <button class="btn" id="exportBtn">Export WAV</button>
            </div>
        </div>

        <div class="main-content">
            <div class="left-panel">
                <div class="panel">
                    <div class="panel-header">Synthesizer</div>
                    <div class="synth-controls">
                        <div class="control-group">
                            <label>Oscillator Type</label>
                            <select id="oscType">
                                <option value="sine">Sine</option>
                                <option value="square">Square</option>
                                <option value="sawtooth">Sawtooth</option>
                                <option value="triangle">Triangle</option>
                            </select>
                        </div>

                        <div class="control-group">
                            <label>Attack</label>
                            <div class="control-row">
                                <input type="range" id="attack" min="0" max="1" step="0.01" value="0.1">
                                <div class="value-display" id="attackVal">0.1s</div>
                            </div>
                        </div>

                        <div class="control-group">
                            <label>Decay</label>
                            <div class="control-row">
                                <input type="range" id="decay" min="0" max="1" step="0.01" value="0.2">
                                <div class="value-display" id="decayVal">0.2s</div>
                            </div>
                        </div>

                        <div class="control-group">
                            <label>Sustain</label>
                            <div class="control-row">
                                <input type="range" id="sustain" min="0" max="1" step="0.01" value="0.7">
                                <div class="value-display" id="sustainVal">0.7</div>
                            </div>
                        </div>

                        <div class="control-group">
                            <label>Release</label>
                            <div class="control-row">
                                <input type="range" id="release" min="0" max="2" step="0.01" value="0.3">
                                <div class="value-display" id="releaseVal">0.3s</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="panel">
                    <div class="panel-header">Drum Machine</div>
                    <div class="drum-grid" id="drumGrid"></div>
                </div>
            </div>

            <div class="center-panel">
                <div class="panel" style="flex: 1; display: flex; flex-direction: column;">
                    <div class="panel-header">Piano Roll - Click to add notes, drag to extend</div>
                    <div class="piano-roll">
                        <canvas id="pianoRoll" width="1200" height="600"></canvas>
                    </div>
                </div>

                <div class="panel waveform">
                    <canvas id="waveform" width="800" height="120"></canvas>
                </div>
            </div>

            <div class="right-panel">
                <div class="panel">
                    <div class="panel-header">Mixer</div>
                    <div id="mixer"></div>
                </div>

                <div class="panel">
                    <div class="panel-header">Effects</div>
                    <div class="effects-chain" id="effects"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Audio Context Setup
        let audioCtx = null;
        let masterGain = null;
        let analyser = null;
        let isPlaying = false;
        let isLooping = true;
        let bpm = 120;
        let currentStep = 0;
        let sequenceInterval = null;

        // Piano Roll State
        const notes = [];
        const pianoRollCanvas = document.getElementById('pianoRoll');
        const pianoRollCtx = pianoRollCanvas.getContext('2d');
        const gridWidth = 32; // 2 bars, 16th notes
        const gridHeight = 24; // 2 octaves
        const cellWidth = pianoRollCanvas.width / gridWidth;
        const cellHeight = pianoRollCanvas.height / gridHeight;
        const baseNote = 48; // C3

        // Drum Pattern State
        const drumPatterns = {
            kick: new Array(16).fill(false),
            snare: new Array(16).fill(false),
            hihat: new Array(16).fill(false),
            clap: new Array(16).fill(false),
            tom: new Array(16).fill(false)
        };

        // Tracks Configuration
        const tracks = {
            synth: { volume: 0.7, pan: 0, mute: false, solo: false, gainNode: null, panNode: null },
            drums: { volume: 0.7, pan: 0, mute: false, solo: false, gainNode: null, panNode: null }
        };

        // Effects State
        const effects = {
            reverb: { enabled: false, wet: 0.3, decay: 2, node: null, wetNode: null, dryNode: null },
            delay: { enabled: false, time: 0.25, feedback: 0.4, node: null, feedbackNode: null, wetNode: null },
            filter: { enabled: false, frequency: 2000, q: 1, node: null }
        };

        // Synth Envelope
        const envelope = {
            attack: 0.1,
            decay: 0.2,
            sustain: 0.7,
            release: 0.3,
            oscType: 'sine'
        };

        // Initialize Audio Context
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                masterGain = audioCtx.createGain();
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 2048;

                // Create track nodes
                for (const trackName in tracks) {
                    const track = tracks[trackName];
                    track.gainNode = audioCtx.createGain();
                    track.panNode = audioCtx.createStereoPanner();
                    track.gainNode.gain.value = track.volume;
                    track.panNode.pan.value = track.pan;
                }

                // Setup effects
                setupEffects();

                // Connect mixer to master
                connectMixer();

                masterGain.connect(analyser);
                analyser.connect(audioCtx.destination);
            }
        }

        function setupEffects() {
            // Reverb (using convolver)
            effects.reverb.node = audioCtx.createConvolver();
            effects.reverb.wetNode = audioCtx.createGain();
            effects.reverb.dryNode = audioCtx.createGain();
            createImpulseResponse(effects.reverb.decay);

            // Delay
            effects.delay.node = audioCtx.createDelay(2);
            effects.delay.feedbackNode = audioCtx.createGain();
            effects.delay.wetNode = audioCtx.createGain();
            effects.delay.node.delayTime.value = effects.delay.time;
            effects.delay.feedbackNode.gain.value = effects.delay.feedback;
            effects.delay.wetNode.gain.value = 0.5;

            // Connect delay feedback loop
            effects.delay.node.connect(effects.delay.feedbackNode);
            effects.delay.feedbackNode.connect(effects.delay.node);
            effects.delay.node.connect(effects.delay.wetNode);

            // Filter
            effects.filter.node = audioCtx.createBiquadFilter();
            effects.filter.node.type = 'lowpass';
            effects.filter.node.frequency.value = effects.filter.frequency;
            effects.filter.node.Q.value = effects.filter.q;
        }

        function createImpulseResponse(duration) {
            const sampleRate = audioCtx.sampleRate;
            const length = sampleRate * duration;
            const impulse = audioCtx.createBuffer(2, length, sampleRate);
            const leftChannel = impulse.getChannelData(0);
            const rightChannel = impulse.getChannelData(1);

            for (let i = 0; i < length; i++) {
                const decay = Math.exp(-i / (sampleRate * duration * 0.3));
                leftChannel[i] = (Math.random() * 2 - 1) * decay;
                rightChannel[i] = (Math.random() * 2 - 1) * decay;
            }

            effects.reverb.node.buffer = impulse;
        }

        function connectMixer() {
            // Disconnect all
            tracks.synth.gainNode.disconnect();
            tracks.drums.gainNode.disconnect();

            // Check for solo
            const soloActive = Object.values(tracks).some(t => t.solo);

            for (const trackName in tracks) {
                const track = tracks[trackName];
                track.gainNode.connect(track.panNode);

                // Apply mute/solo logic
                if (track.mute || (soloActive && !track.solo)) {
                    track.gainNode.gain.value = 0;
                } else {
                    track.gainNode.gain.value = track.volume;
                }

                // Connect through effects chain
                let sourceNode = track.panNode;

                if (effects.reverb.enabled) {
                    effects.reverb.dryNode.gain.value = 1 - effects.reverb.wet;
                    effects.reverb.wetNode.gain.value = effects.reverb.wet;
                    sourceNode.connect(effects.reverb.dryNode);
                    sourceNode.connect(effects.reverb.node);
                    effects.reverb.node.connect(effects.reverb.wetNode);
                    effects.reverb.dryNode.connect(masterGain);
                    effects.reverb.wetNode.connect(masterGain);
                } else if (effects.delay.enabled) {
                    sourceNode.connect(effects.delay.node);
                    sourceNode.connect(masterGain);
                    effects.delay.wetNode.connect(masterGain);
                } else if (effects.filter.enabled) {
                    sourceNode.connect(effects.filter.node);
                    effects.filter.node.connect(masterGain);
                } else {
                    sourceNode.connect(masterGain);
                }
            }
        }

        // Piano Roll Functions
        function drawPianoRoll() {
            pianoRollCtx.fillStyle = '#0a0a0a';
            pianoRollCtx.fillRect(0, 0, pianoRollCanvas.width, pianoRollCanvas.height);

            // Draw grid
            pianoRollCtx.strokeStyle = 'rgba(0, 212, 255, 0.1)';
            pianoRollCtx.lineWidth = 1;

            for (let i = 0; i <= gridWidth; i++) {
                pianoRollCtx.beginPath();
                pianoRollCtx.moveTo(i * cellWidth, 0);
                pianoRollCtx.lineTo(i * cellWidth, pianoRollCanvas.height);
                pianoRollCtx.stroke();

                // Highlight beat lines
                if (i % 4 === 0) {
                    pianoRollCtx.strokeStyle = 'rgba(0, 212, 255, 0.3)';
                    pianoRollCtx.beginPath();
                    pianoRollCtx.moveTo(i * cellWidth, 0);
                    pianoRollCtx.lineTo(i * cellWidth, pianoRollCanvas.height);
                    pianoRollCtx.stroke();
                    pianoRollCtx.strokeStyle = 'rgba(0, 212, 255, 0.1)';
                }
            }

            for (let i = 0; i <= gridHeight; i++) {
                pianoRollCtx.beginPath();
                pianoRollCtx.moveTo(0, i * cellHeight);
                pianoRollCtx.lineTo(pianoRollCanvas.width, i * cellHeight);
                pianoRollCtx.stroke();
            }

            // Draw notes
            notes.forEach(note => {
                const gradient = pianoRollCtx.createLinearGradient(
                    note.x * cellWidth, 0,
                    (note.x + note.length) * cellWidth, 0
                );
                gradient.addColorStop(0, 'rgba(0, 212, 255, 0.8)');
                gradient.addColorStop(1, 'rgba(123, 47, 247, 0.8)');

                pianoRollCtx.fillStyle = gradient;
                pianoRollCtx.fillRect(
                    note.x * cellWidth + 2,
                    note.y * cellHeight + 2,
                    note.length * cellWidth - 4,
                    cellHeight - 4
                );

                pianoRollCtx.strokeStyle = 'rgba(0, 212, 255, 1)';
                pianoRollCtx.lineWidth = 2;
                pianoRollCtx.strokeRect(
                    note.x * cellWidth + 2,
                    note.y * cellHeight + 2,
                    note.length * cellWidth - 4,
                    cellHeight - 4
                );
            });

            // Draw playhead
            if (isPlaying) {
                const playheadX = (currentStep / 16) * pianoRollCanvas.width;
                pianoRollCtx.strokeStyle = 'rgba(255, 204, 0, 0.8)';
                pianoRollCtx.lineWidth = 3;
                pianoRollCtx.beginPath();
                pianoRollCtx.moveTo(playheadX, 0);
                pianoRollCtx.lineTo(playheadX, pianoRollCanvas.height);
                pianoRollCtx.stroke();
            }
        }

        let isDragging = false;
        let dragNote = null;

        pianoRollCanvas.addEventListener('mousedown', (e) => {
            const rect = pianoRollCanvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / cellWidth);
            const y = Math.floor((e.clientY - rect.top) / cellHeight);

            // Check if clicking existing note
            const existingNote = notes.find(n =>
                x >= n.x && x < n.x + n.length && y === n.y
            );

            if (existingNote) {
                // Check if clicking on edge for resize
                if (x === existingNote.x + existingNote.length - 1) {
                    isDragging = true;
                    dragNote = existingNote;
                } else {
                    // Remove note
                    notes.splice(notes.indexOf(existingNote), 1);
                }
            } else {
                // Add new note
                notes.push({ x, y, length: 1 });
            }

            drawPianoRoll();
        });

        pianoRollCanvas.addEventListener('mousemove', (e) => {
            if (isDragging && dragNote) {
                const rect = pianoRollCanvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left) / cellWidth);
                const newLength = Math.max(1, x - dragNote.x + 1);
                dragNote.length = Math.min(newLength, gridWidth - dragNote.x);
                drawPianoRoll();
            }
        });

        pianoRollCanvas.addEventListener('mouseup', () => {
            isDragging = false;
            dragNote = null;
        });

        // Drum Machine
        function createDrumGrid() {
            const drumGrid = document.getElementById('drumGrid');
            drumGrid.innerHTML = '';

            const drumNames = ['Kick', 'Snare', 'Hi-Hat', 'Clap', 'Tom'];
            const drumKeys = ['kick', 'snare', 'hihat', 'clap', 'tom'];

            drumNames.forEach((name, drumIdx) => {
                const label = document.createElement('div');
                label.className = 'drum-label';
                label.textContent = name;
                drumGrid.appendChild(label);

                const drumKey = drumKeys[drumIdx];
                for (let i = 0; i < 16; i++) {
                    const step = document.createElement('div');
                    step.className = 'drum-step';
                    step.dataset.drum = drumKey;
                    step.dataset.step = i;

                    if (drumPatterns[drumKey][i]) {
                        step.classList.add('active');
                    }

                    step.addEventListener('click', () => {
                        drumPatterns[drumKey][i] = !drumPatterns[drumKey][i];
                        step.classList.toggle('active');
                    });

                    drumGrid.appendChild(step);
                }
            });
        }

        function playDrumSound(drumType) {
            if (!audioCtx) return;

            const now = audioCtx.currentTime;

            if (drumType === 'kick') {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(40, now + 0.1);
                gain.gain.setValueAtTime(1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                osc.connect(gain);
                gain.connect(tracks.drums.gainNode);
                osc.start(now);
                osc.stop(now + 0.3);
            } else if (drumType === 'snare') {
                const noise = audioCtx.createBufferSource();
                const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.2, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                noise.buffer = buffer;

                const noiseGain = audioCtx.createGain();
                const noiseFilter = audioCtx.createBiquadFilter();
                noiseFilter.type = 'highpass';
                noiseFilter.frequency.value = 1000;
                noiseGain.gain.setValueAtTime(0.7, now);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);

                noise.connect(noiseFilter);
                noiseFilter.connect(noiseGain);
                noiseGain.connect(tracks.drums.gainNode);
                noise.start(now);
            } else if (drumType === 'hihat') {
                const noise = audioCtx.createBufferSource();
                const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.05, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                noise.buffer = buffer;

                const noiseGain = audioCtx.createGain();
                const noiseFilter = audioCtx.createBiquadFilter();
                noiseFilter.type = 'highpass';
                noiseFilter.frequency.value = 8000;
                noiseGain.gain.setValueAtTime(0.3, now);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);

                noise.connect(noiseFilter);
                noiseFilter.connect(noiseGain);
                noiseGain.connect(tracks.drums.gainNode);
                noise.start(now);
            } else if (drumType === 'clap') {
                for (let i = 0; i < 3; i++) {
                    const delay = i * 0.03;
                    const noise = audioCtx.createBufferSource();
                    const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.1, audioCtx.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let j = 0; j < data.length; j++) {
                        data[j] = Math.random() * 2 - 1;
                    }
                    noise.buffer = buffer;

                    const noiseGain = audioCtx.createGain();
                    const noiseFilter = audioCtx.createBiquadFilter();
                    noiseFilter.type = 'bandpass';
                    noiseFilter.frequency.value = 2000;
                    noiseGain.gain.setValueAtTime(0.5, now + delay);
                    noiseGain.gain.exponentialRampToValueAtTime(0.01, now + delay + 0.1);

                    noise.connect(noiseFilter);
                    noiseFilter.connect(noiseGain);
                    noiseGain.connect(tracks.drums.gainNode);
                    noise.start(now + delay);
                }
            } else if (drumType === 'tom') {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.exponentialRampToValueAtTime(80, now + 0.2);
                gain.gain.setValueAtTime(0.8, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                osc.connect(gain);
                gain.connect(tracks.drums.gainNode);
                osc.start(now);
                osc.stop(now + 0.2);
            }
        }

        // Synth Functions
        function playSynthNote(midiNote, duration) {
            if (!audioCtx) return;

            const now = audioCtx.currentTime;
            const frequency = 440 * Math.pow(2, (midiNote - 69) / 12);

            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();

            osc.type = envelope.oscType;
            osc.frequency.value = frequency;

            // ADSR Envelope
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(1, now + envelope.attack);
            gain.gain.linearRampToValueAtTime(envelope.sustain, now + envelope.attack + envelope.decay);
            gain.gain.setValueAtTime(envelope.sustain, now + duration);
            gain.gain.linearRampToValueAtTime(0, now + duration + envelope.release);

            osc.connect(gain);
            gain.connect(tracks.synth.gainNode);

            osc.start(now);
            osc.stop(now + duration + envelope.release);
        }

        // Sequencer
        function playStep() {
            // Play drums
            for (const drumType in drumPatterns) {
                if (drumPatterns[drumType][currentStep]) {
                    playDrumSound(drumType);
                }
            }

            // Update drum grid visuals
            document.querySelectorAll('.drum-step').forEach(step => {
                step.classList.remove('playing');
                if (parseInt(step.dataset.step) === currentStep) {
                    step.classList.add('playing');
                }
            });

            // Play synth notes
            const stepTime = (60 / bpm) / 4; // 16th note duration
            const activeNotes = notes.filter(note => {
                const noteStep = Math.floor((note.x / gridWidth) * 16);
                return noteStep === currentStep;
            });

            activeNotes.forEach(note => {
                const midiNote = baseNote + (gridHeight - 1 - note.y);
                const duration = (note.length / gridWidth) * (60 / bpm) * 4;
                playSynthNote(midiNote, duration);
            });

            drawPianoRoll();

            currentStep = (currentStep + 1) % 16;

            if (currentStep === 0 && !isLooping) {
                stop();
            }
        }

        function play() {
            if (isPlaying) return;
            initAudio();

            isPlaying = true;
            currentStep = 0;

            const stepTime = (60 / bpm) / 4 * 1000; // 16th note in ms
            sequenceInterval = setInterval(playStep, stepTime);

            document.getElementById('playBtn').classList.add('active');
            document.getElementById('playBtn').textContent = 'Playing';
        }

        function stop() {
            isPlaying = false;
            clearInterval(sequenceInterval);
            currentStep = 0;

            document.querySelectorAll('.drum-step').forEach(step => {
                step.classList.remove('playing');
            });

            drawPianoRoll();

            document.getElementById('playBtn').classList.remove('active');
            document.getElementById('playBtn').textContent = 'Play';
        }

        // Mixer
        function createMixer() {
            const mixer = document.getElementById('mixer');

            Object.keys(tracks).forEach(trackName => {
                const track = tracks[trackName];
                const trackDiv = document.createElement('div');
                trackDiv.className = 'mixer-track';

                trackDiv.innerHTML = `
                    <div class="track-header">
                        <div class="track-name">${trackName.toUpperCase()}</div>
                        <div class="track-buttons">
                            <button class="track-btn mute" data-track="${trackName}" data-action="mute">M</button>
                            <button class="track-btn solo" data-track="${trackName}" data-action="solo">S</button>
                        </div>
                    </div>
                    <div class="control-group">
                        <label>Volume</label>
                        <div class="control-row">
                            <input type="range" min="0" max="1" step="0.01" value="${track.volume}"
                                   data-track="${trackName}" data-param="volume">
                            <div class="value-display">${Math.round(track.volume * 100)}%</div>
                        </div>
                    </div>
                    <div class="control-group">
                        <label>Pan</label>
                        <div class="control-row">
                            <input type="range" min="-1" max="1" step="0.01" value="${track.pan}"
                                   data-track="${trackName}" data-param="pan">
                            <div class="value-display">${track.pan > 0 ? 'R' : track.pan < 0 ? 'L' : 'C'}</div>
                        </div>
                    </div>
                `;

                mixer.appendChild(trackDiv);
            });

            // Event listeners
            mixer.addEventListener('input', (e) => {
                if (e.target.type === 'range') {
                    const trackName = e.target.dataset.track;
                    const param = e.target.dataset.param;
                    const value = parseFloat(e.target.value);

                    tracks[trackName][param] = value;

                    if (param === 'volume') {
                        e.target.nextElementSibling.textContent = Math.round(value * 100) + '%';
                        connectMixer();
                    } else if (param === 'pan') {
                        e.target.nextElementSibling.textContent = value > 0 ? 'R' : value < 0 ? 'L' : 'C';
                        if (tracks[trackName].panNode) {
                            tracks[trackName].panNode.pan.value = value;
                        }
                    }
                }
            });

            mixer.addEventListener('click', (e) => {
                if (e.target.classList.contains('track-btn')) {
                    const trackName = e.target.dataset.track;
                    const action = e.target.dataset.action;

                    tracks[trackName][action] = !tracks[trackName][action];
                    e.target.classList.toggle('active');

                    connectMixer();
                }
            });
        }

        // Effects UI
        function createEffectsUI() {
            const effectsContainer = document.getElementById('effects');

            // Reverb
            effectsContainer.innerHTML += `
                <div class="effect-module">
                    <div class="effect-header">
                        <div class="effect-name">Reverb</div>
                        <div class="effect-toggle" id="reverbToggle"></div>
                    </div>
                    <div class="knob-container">
                        <div class="knob">
                            <div class="knob-label">Wet</div>
                            <div class="knob-visual" data-effect="reverb" data-param="wet">
                                <div class="knob-indicator" style="transform: rotate(${(effects.reverb.wet - 0.5) * 270}deg)"></div>
                            </div>
                            <div class="knob-value">${Math.round(effects.reverb.wet * 100)}%</div>
                        </div>
                        <div class="knob">
                            <div class="knob-label">Decay</div>
                            <div class="knob-visual" data-effect="reverb" data-param="decay">
                                <div class="knob-indicator" style="transform: rotate(${(effects.reverb.decay / 5 - 0.5) * 270}deg)"></div>
                            </div>
                            <div class="knob-value">${effects.reverb.decay.toFixed(1)}s</div>
                        </div>
                    </div>
                </div>
            `;

            // Delay
            effectsContainer.innerHTML += `
                <div class="effect-module">
                    <div class="effect-header">
                        <div class="effect-name">Delay</div>
                        <div class="effect-toggle" id="delayToggle"></div>
                    </div>
                    <div class="knob-container">
                        <div class="knob">
                            <div class="knob-label">Time</div>
                            <div class="knob-visual" data-effect="delay" data-param="time">
                                <div class="knob-indicator" style="transform: rotate(${(effects.delay.time / 2 - 0.5) * 270}deg)"></div>
                            </div>
                            <div class="knob-value">${effects.delay.time.toFixed(2)}s</div>
                        </div>
                        <div class="knob">
                            <div class="knob-label">Feedback</div>
                            <div class="knob-visual" data-effect="delay" data-param="feedback">
                                <div class="knob-indicator" style="transform: rotate(${(effects.delay.feedback - 0.5) * 270}deg)"></div>
                            </div>
                            <div class="knob-value">${Math.round(effects.delay.feedback * 100)}%</div>
                        </div>
                    </div>
                </div>
            `;

            // Filter
            effectsContainer.innerHTML += `
                <div class="effect-module">
                    <div class="effect-header">
                        <div class="effect-name">Low-Pass Filter</div>
                        <div class="effect-toggle" id="filterToggle"></div>
                    </div>
                    <div class="knob-container">
                        <div class="knob">
                            <div class="knob-label">Frequency</div>
                            <div class="knob-visual" data-effect="filter" data-param="frequency">
                                <div class="knob-indicator" style="transform: rotate(${(Math.log(effects.filter.frequency / 20) / Math.log(20000 / 20) - 0.5) * 270}deg)"></div>
                            </div>
                            <div class="knob-value">${effects.filter.frequency}Hz</div>
                        </div>
                        <div class="knob">
                            <div class="knob-label">Resonance</div>
                            <div class="knob-visual" data-effect="filter" data-param="q">
                                <div class="knob-indicator" style="transform: rotate(${(effects.filter.q / 20 - 0.5) * 270}deg)"></div>
                            </div>
                            <div class="knob-value">${effects.filter.q.toFixed(1)}</div>
                        </div>
                    </div>
                </div>
            `;

            // Toggle listeners
            document.getElementById('reverbToggle').addEventListener('click', function() {
                effects.reverb.enabled = !effects.reverb.enabled;
                this.classList.toggle('on');
                connectMixer();
            });

            document.getElementById('delayToggle').addEventListener('click', function() {
                effects.delay.enabled = !effects.delay.enabled;
                this.classList.toggle('on');
                connectMixer();
            });

            document.getElementById('filterToggle').addEventListener('click', function() {
                effects.filter.enabled = !effects.filter.enabled;
                this.classList.toggle('on');
                connectMixer();
            });

            // Knob interactions
            let activeKnob = null;
            let knobStartY = 0;
            let knobStartValue = 0;

            document.querySelectorAll('.knob-visual').forEach(knob => {
                knob.addEventListener('mousedown', (e) => {
                    activeKnob = knob;
                    knobStartY = e.clientY;
                    const effect = knob.dataset.effect;
                    const param = knob.dataset.param;
                    knobStartValue = effects[effect][param];
                    e.preventDefault();
                });
            });

            document.addEventListener('mousemove', (e) => {
                if (!activeKnob) return;

                const effect = activeKnob.dataset.effect;
                const param = activeKnob.dataset.param;
                const delta = (knobStartY - e.clientY) / 100;

                let newValue = knobStartValue + delta;
                let displayValue = '';
                let rotation = 0;

                if (param === 'wet' || param === 'feedback') {
                    newValue = Math.max(0, Math.min(1, newValue));
                    effects[effect][param] = newValue;
                    displayValue = Math.round(newValue * 100) + '%';
                    rotation = (newValue - 0.5) * 270;

                    if (param === 'wet' && effects.reverb.enabled) {
                        effects.reverb.wetNode.gain.value = newValue;
                        effects.reverb.dryNode.gain.value = 1 - newValue;
                    } else if (param === 'feedback' && effects.delay.enabled) {
                        effects.delay.feedbackNode.gain.value = newValue;
                    }
                } else if (param === 'decay') {
                    newValue = Math.max(0.1, Math.min(5, newValue));
                    effects[effect][param] = newValue;
                    displayValue = newValue.toFixed(1) + 's';
                    rotation = (newValue / 5 - 0.5) * 270;
                    if (effects.reverb.enabled) {
                        createImpulseResponse(newValue);
                    }
                } else if (param === 'time') {
                    newValue = Math.max(0.01, Math.min(2, newValue));
                    effects[effect][param] = newValue;
                    displayValue = newValue.toFixed(2) + 's';
                    rotation = (newValue / 2 - 0.5) * 270;
                    if (effects.delay.enabled) {
                        effects.delay.node.delayTime.value = newValue;
                    }
                } else if (param === 'frequency') {
                    newValue = Math.max(20, Math.min(20000, knobStartValue * Math.pow(2, delta * 10)));
                    effects[effect][param] = Math.round(newValue);
                    displayValue = Math.round(newValue) + 'Hz';
                    rotation = (Math.log(newValue / 20) / Math.log(20000 / 20) - 0.5) * 270;
                    if (effects.filter.enabled) {
                        effects.filter.node.frequency.value = newValue;
                    }
                } else if (param === 'q') {
                    newValue = Math.max(0.1, Math.min(20, newValue));
                    effects[effect][param] = newValue;
                    displayValue = newValue.toFixed(1);
                    rotation = (newValue / 20 - 0.5) * 270;
                    if (effects.filter.enabled) {
                        effects.filter.node.Q.value = newValue;
                    }
                }

                activeKnob.querySelector('.knob-indicator').style.transform = `rotate(${rotation}deg)`;
                activeKnob.parentElement.querySelector('.knob-value').textContent = displayValue;
            });

            document.addEventListener('mouseup', () => {
                activeKnob = null;
            });
        }

        // Waveform Visualization
        function drawWaveform() {
            const canvas = document.getElementById('waveform');
            const ctx = canvas.getContext('2d');
            const bufferLength = analyser.fftSize;
            const dataArray = new Uint8Array(bufferLength);

            function draw() {
                requestAnimationFrame(draw);

                if (!isPlaying) {
                    ctx.fillStyle = '#0a0a0a';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    return;
                }

                analyser.getByteTimeDomainData(dataArray);

                ctx.fillStyle = '#0a0a0a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.lineWidth = 2;
                ctx.strokeStyle = '#00d4ff';
                ctx.beginPath();

                const sliceWidth = canvas.width / bufferLength;
                let x = 0;

                for (let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = v * canvas.height / 2;

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }

                    x += sliceWidth;
                }

                ctx.stroke();
            }

            draw();
        }

        // Export WAV
        function exportWAV() {
            if (!audioCtx) {
                initAudio();
            }

            const duration = 8; // 2 bars at 120 BPM
            const sampleRate = audioCtx.sampleRate;
            const numChannels = 2;
            const offlineCtx = new OfflineAudioContext(numChannels, sampleRate * duration, sampleRate);

            // Create offline nodes
            const offlineMaster = offlineCtx.createGain();
            offlineMaster.connect(offlineCtx.destination);

            const offlineTracks = {};
            for (const trackName in tracks) {
                const track = tracks[trackName];
                offlineTracks[trackName] = {
                    gainNode: offlineCtx.createGain(),
                    panNode: offlineCtx.createStereoPanner()
                };
                offlineTracks[trackName].gainNode.gain.value = track.mute ? 0 : track.volume;
                offlineTracks[trackName].panNode.pan.value = track.pan;
                offlineTracks[trackName].gainNode.connect(offlineTracks[trackName].panNode);
                offlineTracks[trackName].panNode.connect(offlineMaster);
            }

            // Schedule all events
            const stepTime = (60 / bpm) / 4;

            for (let step = 0; step < 32; step++) { // 2 bars
                const time = step * stepTime;

                // Drums
                const drumStep = step % 16;
                for (const drumType in drumPatterns) {
                    if (drumPatterns[drumType][drumStep]) {
                        scheduleDrumSound(offlineCtx, offlineTracks.drums.gainNode, drumType, time);
                    }
                }

                // Synth notes
                const activeNotes = notes.filter(note => {
                    const noteStep = Math.floor((note.x / gridWidth) * 16);
                    return noteStep === drumStep;
                });

                activeNotes.forEach(note => {
                    const midiNote = baseNote + (gridHeight - 1 - note.y);
                    const noteDuration = (note.length / gridWidth) * (60 / bpm) * 4;
                    scheduleSynthNote(offlineCtx, offlineTracks.synth.gainNode, midiNote, time, noteDuration);
                });
            }

            offlineCtx.startRendering().then(buffer => {
                const wav = bufferToWav(buffer);
                const blob = new Blob([wav], { type: 'audio/wav' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'synth-studio-export.wav';
                a.click();
                URL.revokeObjectURL(url);
            });
        }

        function scheduleDrumSound(ctx, destination, drumType, time) {
            if (drumType === 'kick') {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(150, time);
                osc.frequency.exponentialRampToValueAtTime(40, time + 0.1);
                gain.gain.setValueAtTime(1, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.3);
                osc.connect(gain);
                gain.connect(destination);
                osc.start(time);
                osc.stop(time + 0.3);
            } else if (drumType === 'snare') {
                const noise = ctx.createBufferSource();
                const buffer = ctx.createBuffer(1, ctx.sampleRate * 0.2, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                noise.buffer = buffer;

                const noiseGain = ctx.createGain();
                const noiseFilter = ctx.createBiquadFilter();
                noiseFilter.type = 'highpass';
                noiseFilter.frequency.value = 1000;
                noiseGain.gain.setValueAtTime(0.7, time);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);

                noise.connect(noiseFilter);
                noiseFilter.connect(noiseGain);
                noiseGain.connect(destination);
                noise.start(time);
            } else if (drumType === 'hihat') {
                const noise = ctx.createBufferSource();
                const buffer = ctx.createBuffer(1, ctx.sampleRate * 0.05, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                noise.buffer = buffer;

                const noiseGain = ctx.createGain();
                const noiseFilter = ctx.createBiquadFilter();
                noiseFilter.type = 'highpass';
                noiseFilter.frequency.value = 8000;
                noiseGain.gain.setValueAtTime(0.3, time);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, time + 0.05);

                noise.connect(noiseFilter);
                noiseFilter.connect(noiseGain);
                noiseGain.connect(destination);
                noise.start(time);
            } else if (drumType === 'clap') {
                for (let i = 0; i < 3; i++) {
                    const delay = i * 0.03;
                    const noise = ctx.createBufferSource();
                    const buffer = ctx.createBuffer(1, ctx.sampleRate * 0.1, ctx.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let j = 0; j < data.length; j++) {
                        data[j] = Math.random() * 2 - 1;
                    }
                    noise.buffer = buffer;

                    const noiseGain = ctx.createGain();
                    const noiseFilter = ctx.createBiquadFilter();
                    noiseFilter.type = 'bandpass';
                    noiseFilter.frequency.value = 2000;
                    noiseGain.gain.setValueAtTime(0.5, time + delay);
                    noiseGain.gain.exponentialRampToValueAtTime(0.01, time + delay + 0.1);

                    noise.connect(noiseFilter);
                    noiseFilter.connect(noiseGain);
                    noiseGain.connect(destination);
                    noise.start(time + delay);
                }
            } else if (drumType === 'tom') {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(200, time);
                osc.frequency.exponentialRampToValueAtTime(80, time + 0.2);
                gain.gain.setValueAtTime(0.8, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
                osc.connect(gain);
                gain.connect(destination);
                osc.start(time);
                osc.stop(time + 0.2);
            }
        }

        function scheduleSynthNote(ctx, destination, midiNote, time, duration) {
            const frequency = 440 * Math.pow(2, (midiNote - 69) / 12);

            const osc = ctx.createOscillator();
            const gain = ctx.createGain();

            osc.type = envelope.oscType;
            osc.frequency.value = frequency;

            gain.gain.setValueAtTime(0, time);
            gain.gain.linearRampToValueAtTime(1, time + envelope.attack);
            gain.gain.linearRampToValueAtTime(envelope.sustain, time + envelope.attack + envelope.decay);
            gain.gain.setValueAtTime(envelope.sustain, time + duration);
            gain.gain.linearRampToValueAtTime(0, time + duration + envelope.release);

            osc.connect(gain);
            gain.connect(destination);

            osc.start(time);
            osc.stop(time + duration + envelope.release);
        }

        function bufferToWav(buffer) {
            const numChannels = buffer.numberOfChannels;
            const sampleRate = buffer.sampleRate;
            const format = 1; // PCM
            const bitDepth = 16;

            const bytesPerSample = bitDepth / 8;
            const blockAlign = numChannels * bytesPerSample;

            const data = [];
            for (let i = 0; i < buffer.length; i++) {
                for (let channel = 0; channel < numChannels; channel++) {
                    const sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
                    const int16 = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                    data.push(int16);
                }
            }

            const dataSize = data.length * bytesPerSample;
            const bufferSize = 44 + dataSize;
            const arrayBuffer = new ArrayBuffer(bufferSize);
            const view = new DataView(arrayBuffer);

            // RIFF chunk
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeString(view, 8, 'WAVE');

            // fmt chunk
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, format, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * blockAlign, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitDepth, true);

            // data chunk
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);

            let offset = 44;
            for (let i = 0; i < data.length; i++) {
                view.setInt16(offset, data[i], true);
                offset += 2;
            }

            return arrayBuffer;
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        // Event Listeners
        document.getElementById('playBtn').addEventListener('click', play);
        document.getElementById('stopBtn').addEventListener('click', stop);

        document.getElementById('loopBtn').addEventListener('click', function() {
            isLooping = !isLooping;
            this.textContent = isLooping ? 'Loop: ON' : 'Loop: OFF';
            this.classList.toggle('active');
        });

        document.getElementById('bpmSlider').addEventListener('input', function() {
            bpm = parseInt(this.value);
            document.getElementById('bpmValue').textContent = bpm;

            if (isPlaying) {
                stop();
                setTimeout(play, 100);
            }
        });

        document.getElementById('exportBtn').addEventListener('click', exportWAV);

        // Synth controls
        document.getElementById('oscType').addEventListener('change', function() {
            envelope.oscType = this.value;
        });

        document.getElementById('attack').addEventListener('input', function() {
            envelope.attack = parseFloat(this.value);
            document.getElementById('attackVal').textContent = this.value + 's';
        });

        document.getElementById('decay').addEventListener('input', function() {
            envelope.decay = parseFloat(this.value);
            document.getElementById('decayVal').textContent = this.value + 's';
        });

        document.getElementById('sustain').addEventListener('input', function() {
            envelope.sustain = parseFloat(this.value);
            document.getElementById('sustainVal').textContent = this.value;
        });

        document.getElementById('release').addEventListener('input', function() {
            envelope.release = parseFloat(this.value);
            document.getElementById('releaseVal').textContent = this.value + 's';
        });

        // Initialize
        drawPianoRoll();
        createDrumGrid();
        createMixer();
        createEffectsUI();
        drawWaveform();

        // Set default loop button state
        document.getElementById('loopBtn').classList.add('active');
        document.getElementById('loopBtn').textContent = 'Loop: ON';
    </script>
</body>
</html>