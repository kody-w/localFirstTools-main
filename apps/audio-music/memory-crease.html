<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memory Crease</title>
    <meta name="description" content="Unfold origami backwards through time, revealing the memory traces embedded in each crease">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #f8f5f0; min-height: 100vh; font-family: 'Georgia', serif; color: #5a5040; overflow: hidden; }
        #canvas { position: fixed; top: 0; left: 0; cursor: pointer; }
        #controls {
            position: fixed; top: 20px; left: 20px; background: rgba(248,245,240,0.95);
            padding: 20px; border-radius: 10px; border: 1px solid rgba(180,160,140,0.5);
            z-index: 100;
        }
        h3 { margin-bottom: 15px; color: #6a5a48; font-weight: normal; }
        .control-row { margin: 10px 0; }
        label { display: block; font-size: 11px; margin-bottom: 5px; opacity: 0.8; }
        input[type="range"] { width: 140px; }
        .value { float: right; color: #8a7a68; font-size: 12px; }
        button {
            display: block; width: 100%; padding: 10px; margin: 6px 0;
            background: rgba(180,160,140,0.3); border: 1px solid rgba(180,160,140,0.5);
            color: #6a5a48; cursor: pointer; border-radius: 6px; font-family: inherit;
        }
        #stats { position: fixed; top: 20px; right: 20px; font-size: 12px; color: #8a7a68; z-index: 100; text-align: right; }
        #info { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); font-size: 12px; opacity: 0.5; z-index: 100; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="controls">
        <h3>Memory Crease</h3>
        <div class="control-row">
            <label>Unfold Speed <span class="value" id="speed-val">50</span></label>
            <input type="range" id="speed" min="10" max="100" value="50">
        </div>
        <div class="control-row">
            <label>Memory Intensity <span class="value" id="memory-val">60</span></label>
            <input type="range" id="memory" min="20" max="100" value="60">
        </div>
        <button id="unfold-btn">Unfold One Step</button>
        <button id="refold-btn">Refold</button>
        <button id="new-btn">New Origami</button>
    </div>
    <div id="stats">
        <div>Folds: <span id="fold-count">0</span></div>
        <div>State: <span id="current-state">Folded</span></div>
    </div>
    <div id="info">Click Unfold to reveal the memory traces in each crease</div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let W, H;
        function resize() { W = canvas.width = innerWidth; H = canvas.height = innerHeight; initOrigami(); }
        
        let unfoldSpeed = 0.5;
        let memoryIntensity = 0.6;
        let time = 0;
        
        let creases = [];
        let currentFold = 0;
        let isUnfolding = false;
        let unfoldProgress = 0;
        
        const FOLD_MEMORIES = [
            'The first careful crease, anticipation in fingertips',
            'Sunlight through the window during this fold',
            'A moment of hesitation before committing',
            'The paper resisted slightly here',
            'Confidence growing with each precise line',
            'Background music fading into focus',
            'The smell of fresh paper',
            'A breath held during the delicate work',
            'Satisfaction at the symmetry achieved',
            'Almost done, the form emerging'
        ];
        
        function initOrigami() {
            creases = [];
            currentFold = 0;
            unfoldProgress = 0;
            
            const centerX = W / 2;
            const centerY = H / 2;
            const size = Math.min(W, H) * 0.35;
            
            const foldCount = 8 + Math.floor(Math.random() * 5);
            
            for (let i = 0; i < foldCount; i++) {
                const angle = Math.random() * Math.PI;
                const offset = (Math.random() - 0.5) * size * 0.5;
                const isMountain = Math.random() > 0.5;
                
                creases.push({
                    x1: centerX + Math.cos(angle) * size + Math.sin(angle) * offset,
                    y1: centerY + Math.sin(angle) * size - Math.cos(angle) * offset,
                    x2: centerX - Math.cos(angle) * size + Math.sin(angle) * offset,
                    y2: centerY - Math.sin(angle) * size - Math.cos(angle) * offset,
                    isMountain: isMountain,
                    order: i,
                    revealed: false,
                    revealProgress: 0,
                    memory: FOLD_MEMORIES[i % FOLD_MEMORIES.length],
                    hue: isMountain ? 200 : 30
                });
            }
            
            creases.sort((a, b) => b.order - a.order);
        }
        
        resize(); window.onresize = resize;
        
        function drawPaper() {
            const centerX = W / 2;
            const centerY = H / 2;
            const size = Math.min(W, H) * 0.35;
            
            ctx.save();
            ctx.shadowColor = 'rgba(0,0,0,0.1)';
            ctx.shadowBlur = 20;
            ctx.shadowOffsetY = 10;
            
            ctx.beginPath();
            ctx.rect(centerX - size, centerY - size, size * 2, size * 2);
            ctx.fillStyle = '#fffef8';
            ctx.fill();
            
            ctx.restore();
            
            ctx.strokeStyle = 'rgba(180, 160, 140, 0.3)';
            ctx.lineWidth = 1;
            ctx.strokeRect(centerX - size, centerY - size, size * 2, size * 2);
        }
        
        function drawCreases() {
            creases.forEach((crease, index) => {
                if (!crease.revealed && index !== currentFold) return;
                
                let progress = crease.revealProgress;
                if (index === currentFold && isUnfolding) {
                    progress = unfoldProgress;
                }
                
                if (progress <= 0) return;
                
                const midX = (crease.x1 + crease.x2) / 2;
                const midY = (crease.y1 + crease.y2) / 2;
                const length = Math.hypot(crease.x2 - crease.x1, crease.y2 - crease.y1);
                const angle = Math.atan2(crease.y2 - crease.y1, crease.x2 - crease.x1);
                
                const drawLength = length * progress;
                const startX = midX - Math.cos(angle) * drawLength / 2;
                const startY = midY - Math.sin(angle) * drawLength / 2;
                const endX = midX + Math.cos(angle) * drawLength / 2;
                const endY = midY + Math.sin(angle) * drawLength / 2;
                
                if (crease.isMountain) {
                    ctx.setLineDash([]);
                } else {
                    ctx.setLineDash([8, 4]);
                }
                
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                
                const alpha = progress * memoryIntensity;
                const lightness = crease.isMountain ? 40 : 50;
                ctx.strokeStyle = "hsla(" + crease.hue + ", 40%, " + lightness + "%, " + alpha + ")";
                ctx.lineWidth = 2 + (crease.order / creases.length) * 2;
                ctx.stroke();
                ctx.setLineDash([]);
                
                if (progress > 0.5) {
                    const glowAlpha = (progress - 0.5) * 2 * memoryIntensity * 0.3;
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.strokeStyle = "hsla(" + crease.hue + ", 60%, 70%, " + glowAlpha + ")";
                    ctx.lineWidth = 6;
                    ctx.stroke();
                }
                
                if (progress > 0.8 && index === currentFold) {
                    ctx.font = '12px Georgia';
                    ctx.fillStyle = "rgba(100, 90, 70, " + ((progress - 0.8) * 5 * 0.6) + ")";
                    ctx.textAlign = 'center';
                    ctx.fillText(crease.memory, midX, midY - 15);
                }
            });
        }
        
        function drawBackground() {
            const gradient = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, Math.max(W, H) * 0.7);
            gradient.addColorStop(0, '#f8f5f0');
            gradient.addColorStop(1, '#e8e5e0');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, W, H);
        }
        
        function unfoldStep() {
            if (currentFold >= creases.length) return;
            
            isUnfolding = true;
            unfoldProgress = 0;
        }
        
        function updateStats() {
            const revealedCount = creases.filter(c => c.revealed).length;
            document.getElementById('fold-count').textContent = revealedCount + ' / ' + creases.length;
            
            if (revealedCount === 0) {
                document.getElementById('current-state').textContent = 'Folded';
            } else if (revealedCount === creases.length) {
                document.getElementById('current-state').textContent = 'Fully Unfolded';
            } else {
                document.getElementById('current-state').textContent = 'Unfolding...';
            }
        }
        
        function animate() {
            time += 0.016;
            
            if (isUnfolding) {
                unfoldProgress += 0.02 * unfoldSpeed;
                
                if (unfoldProgress >= 1) {
                    creases[currentFold].revealed = true;
                    creases[currentFold].revealProgress = 1;
                    currentFold++;
                    isUnfolding = false;
                    unfoldProgress = 0;
                }
            }
            
            drawBackground();
            drawPaper();
            drawCreases();
            updateStats();
            
            requestAnimationFrame(animate);
        }
        
        document.getElementById('speed').oninput = e => {
            unfoldSpeed = e.target.value / 100;
            document.getElementById('speed-val').textContent = e.target.value;
        };
        
        document.getElementById('memory').oninput = e => {
            memoryIntensity = e.target.value / 100;
            document.getElementById('memory-val').textContent = e.target.value;
        };
        
        document.getElementById('unfold-btn').onclick = () => {
            unfoldStep();
        };
        
        document.getElementById('refold-btn').onclick = () => {
            creases.forEach(c => {
                c.revealed = false;
                c.revealProgress = 0;
            });
            currentFold = 0;
            isUnfolding = false;
            unfoldProgress = 0;
        };
        
        document.getElementById('new-btn').onclick = () => {
            initOrigami();
        };
        
        canvas.onclick = e => {
            if (e.clientX < 200 && e.clientY < 280) return;
            unfoldStep();
        };
        
        animate();
    </script>
</body>
</html>