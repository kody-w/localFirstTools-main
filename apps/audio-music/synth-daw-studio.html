<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Synth DAW Studio - Multi-Track Synthesizer & Sequencer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            overflow-x: hidden;
            user-select: none;
        }

        .container {
            max-width: 100%;
            padding: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 10px;
            border: 1px solid #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        h1 {
            font-size: 2.5em;
            background: linear-gradient(90deg, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .transport {
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
            margin-bottom: 30px;
            padding: 20px;
            background: #1a1a1a;
            border-radius: 10px;
            border: 1px solid #333;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            font-size: 1em;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-play {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            color: #000;
        }

        .btn-stop {
            background: linear-gradient(135deg, #ff4444, #cc0000);
            color: #fff;
        }

        .btn-record {
            background: linear-gradient(135deg, #ff0066, #cc0044);
            color: #fff;
        }

        .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px currentColor;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn.active {
            box-shadow: 0 0 20px currentColor;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-group label {
            font-weight: bold;
            color: #00ffff;
            min-width: 60px;
        }

        input[type="range"] {
            width: 150px;
            height: 5px;
            background: #333;
            outline: none;
            border-radius: 5px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 15px;
            height: 15px;
            background: #00ffff;
            cursor: pointer;
            border-radius: 50%;
        }

        input[type="number"] {
            width: 80px;
            padding: 8px;
            background: #222;
            border: 1px solid #444;
            color: #fff;
            border-radius: 5px;
        }

        .sequencer-container {
            margin-bottom: 30px;
        }

        .track {
            margin-bottom: 20px;
            background: #1a1a1a;
            border-radius: 10px;
            padding: 15px;
            border: 1px solid #333;
        }

        .track-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .track-title {
            font-size: 1.2em;
            font-weight: bold;
            color: #ff00ff;
        }

        .track-controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .track-control {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .track-control label {
            font-size: 0.8em;
            color: #888;
        }

        .track-control select,
        .track-control input {
            padding: 5px;
            background: #222;
            border: 1px solid #444;
            color: #fff;
            border-radius: 3px;
        }

        .sequencer-grid {
            display: grid;
            grid-template-columns: repeat(16, 1fr);
            gap: 5px;
            margin-bottom: 15px;
        }

        .step {
            aspect-ratio: 1;
            background: #222;
            border: 1px solid #333;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.1s;
            position: relative;
        }

        .step:hover {
            background: #333;
            border-color: #00ffff;
        }

        .step.active {
            background: linear-gradient(135deg, #00ffff, #ff00ff);
            border-color: #00ffff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .step.playing {
            box-shadow: 0 0 20px #00ff88;
            border-color: #00ff88;
        }

        .piano-roll {
            display: grid;
            grid-template-columns: 60px repeat(16, 1fr);
            gap: 2px;
            margin-top: 15px;
        }

        .note-label {
            display: flex;
            align-items: center;
            justify-content: center;
            background: #222;
            border-radius: 3px;
            font-size: 0.8em;
            color: #888;
        }

        .note-row {
            display: contents;
        }

        .note-cell {
            aspect-ratio: 1;
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 2px;
            cursor: pointer;
            transition: all 0.1s;
        }

        .note-cell:hover {
            background: #333;
            border-color: #00ffff;
        }

        .note-cell.active {
            background: linear-gradient(135deg, #ff00ff, #00ffff);
            box-shadow: 0 0 8px rgba(255, 0, 255, 0.5);
        }

        .master-effects {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #333;
            margin-bottom: 30px;
        }

        .master-effects h3 {
            color: #00ffff;
            margin-bottom: 15px;
        }

        .effects-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }

        .effect-section {
            background: #222;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #444;
        }

        .effect-section h4 {
            color: #ff00ff;
            margin-bottom: 10px;
        }

        .keyboard {
            display: flex;
            gap: 2px;
            justify-content: center;
            margin: 30px 0;
            padding: 20px;
            background: #1a1a1a;
            border-radius: 10px;
            flex-wrap: wrap;
        }

        .key {
            width: 50px;
            height: 200px;
            background: white;
            border: 1px solid #000;
            border-radius: 0 0 5px 5px;
            cursor: pointer;
            position: relative;
            transition: all 0.05s;
        }

        .key:hover {
            background: #f0f0f0;
        }

        .key:active,
        .key.playing {
            background: #00ffff;
            transform: translateY(2px);
        }

        .key.black {
            width: 35px;
            height: 130px;
            background: #000;
            border: 1px solid #333;
            margin-left: -19px;
            margin-right: -18px;
            z-index: 2;
        }

        .key.black:hover {
            background: #222;
        }

        .key.black:active,
        .key.black.playing {
            background: #00ffff;
        }

        .key-label {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.8em;
            font-weight: bold;
            color: #000;
        }

        .key.black .key-label {
            color: #fff;
        }

        .pattern-manager {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #333;
            margin-bottom: 30px;
        }

        .pattern-manager h3 {
            color: #00ffff;
            margin-bottom: 15px;
        }

        .pattern-list {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .pattern-item {
            padding: 10px 15px;
            background: #222;
            border: 2px solid #444;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .pattern-item:hover {
            border-color: #00ffff;
        }

        .pattern-item.selected {
            border-color: #ff00ff;
            background: #2a1a2a;
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.3);
        }

        .visualizer {
            width: 100%;
            height: 100px;
            background: #0a0a0a;
            border: 1px solid #333;
            border-radius: 5px;
            margin-top: 10px;
        }

        .storage-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .info-panel {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #333;
            margin-top: 20px;
            text-align: center;
            color: #888;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8em;
            }

            .transport {
                flex-direction: column;
            }

            .track-controls {
                flex-direction: column;
                width: 100%;
            }

            .keyboard {
                overflow-x: auto;
            }

            .key {
                width: 40px;
                height: 150px;
            }

            .key.black {
                width: 28px;
                height: 100px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Synth DAW Studio</h1>
            <p>Multi-Track Synthesizer & Step Sequencer</p>
        </header>

        <div class="transport">
            <button class="btn btn-play" id="playBtn">Play</button>
            <button class="btn btn-stop" id="stopBtn">Stop</button>
            <button class="btn" id="loopBtn">Loop: OFF</button>

            <div class="control-group">
                <label for="bpmInput">BPM:</label>
                <input type="number" id="bpmInput" min="60" max="200" value="120">
                <button class="btn" id="tapBtn">Tap</button>
            </div>

            <div class="control-group">
                <label for="swingSlider">Swing:</label>
                <input type="range" id="swingSlider" min="0" max="100" value="0">
                <span id="swingValue">0%</span>
            </div>
        </div>

        <div class="pattern-manager">
            <h3>Pattern Manager</h3>
            <div class="pattern-list" id="patternList"></div>
            <div class="storage-controls">
                <button class="btn" id="newPatternBtn">New Pattern</button>
                <button class="btn" id="saveBtn">Save to Storage</button>
                <button class="btn" id="loadBtn">Load from Storage</button>
                <button class="btn" id="exportBtn">Export JSON</button>
                <button class="btn" id="importBtn">Import JSON</button>
                <input type="file" id="importFile" accept=".json" style="display: none;">
            </div>
        </div>

        <div class="master-effects">
            <h3>Master Effects</h3>
            <div class="effects-grid">
                <div class="effect-section">
                    <h4>Reverb</h4>
                    <div class="control-group">
                        <label>Mix:</label>
                        <input type="range" id="reverbMix" min="0" max="100" value="0">
                        <span id="reverbMixValue">0%</span>
                    </div>
                </div>
                <div class="effect-section">
                    <h4>Delay</h4>
                    <div class="control-group">
                        <label>Time:</label>
                        <input type="range" id="delayTime" min="0" max="1000" value="250">
                        <span id="delayTimeValue">250ms</span>
                    </div>
                    <div class="control-group">
                        <label>Feedback:</label>
                        <input type="range" id="delayFeedback" min="0" max="100" value="30">
                        <span id="delayFeedbackValue">30%</span>
                    </div>
                    <div class="control-group">
                        <label>Mix:</label>
                        <input type="range" id="delayMix" min="0" max="100" value="0">
                        <span id="delayMixValue">0%</span>
                    </div>
                </div>
                <div class="effect-section">
                    <h4>Compressor</h4>
                    <div class="control-group">
                        <label>Threshold:</label>
                        <input type="range" id="compThreshold" min="-60" max="0" value="-24">
                        <span id="compThresholdValue">-24dB</span>
                    </div>
                    <div class="control-group">
                        <label>Ratio:</label>
                        <input type="range" id="compRatio" min="1" max="20" value="4">
                        <span id="compRatioValue">4:1</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="sequencer-container" id="sequencerContainer"></div>

        <div class="keyboard" id="keyboard"></div>

        <div class="info-panel">
            <p>Click sequencer steps to create patterns | Use keyboard to play notes | All data saves to localStorage</p>
        </div>
    </div>

    <script>
        // Audio Engine
        let audioContext;
        let masterGain;
        let masterCompressor;
        let masterReverb;
        let masterDelay;
        let delayFeedback;
        let dryGain;
        let wetGain;

        // Sequencer State
        let isPlaying = false;
        let currentStep = 0;
        let bpm = 120;
        let swing = 0;
        let loopEnabled = false;
        let nextNoteTime = 0;
        let scheduleAheadTime = 0.1;
        let lookahead = 25.0;
        let timerID;
        let currentPattern = 0;
        let patterns = [];
        let selectedTrack = 0;

        // Tap tempo
        let tapTimes = [];

        // Track definitions
        const tracks = [
            { name: 'Synth 1', type: 'synth', color: '#ff00ff' },
            { name: 'Synth 2', type: 'synth', color: '#00ffff' },
            { name: 'Synth 3', type: 'synth', color: '#ffff00' },
            { name: 'Synth 4', type: 'synth', color: '#00ff88' },
            { name: 'Bass', type: 'synth', color: '#ff8800' },
            { name: 'Lead', type: 'synth', color: '#ff0088' },
            { name: 'Pad', type: 'synth', color: '#8800ff' },
            { name: 'Drums', type: 'drums', color: '#ff4444' }
        ];

        // Note frequencies (C2 to C6)
        const notes = [
            'C2', 'D2', 'E2', 'F2', 'G2', 'A2', 'B2',
            'C3', 'D3', 'E3', 'F3', 'G3', 'A3', 'B3',
            'C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'B4',
            'C5', 'D5', 'E5', 'F5', 'G5', 'A5', 'B5',
            'C6'
        ];

        const noteFrequencies = {
            'C2': 65.41, 'D2': 73.42, 'E2': 82.41, 'F2': 87.31, 'G2': 98.00, 'A2': 110.00, 'B2': 123.47,
            'C3': 130.81, 'D3': 146.83, 'E3': 164.81, 'F3': 174.61, 'G3': 196.00, 'A3': 220.00, 'B3': 246.94,
            'C4': 261.63, 'D4': 293.66, 'E4': 329.63, 'F4': 349.23, 'G4': 392.00, 'A4': 440.00, 'B4': 493.88,
            'C5': 523.25, 'D5': 587.33, 'E5': 659.25, 'F5': 698.46, 'G5': 783.99, 'A5': 880.00, 'B5': 987.77,
            'C6': 1046.50
        };

        // Drum sounds
        const drumTypes = ['kick', 'snare', 'hihat', 'clap', 'tom'];

        // Initialize
        function init() {
            initAudio();
            createPattern();
            renderPatternList();
            renderSequencer();
            renderKeyboard();
            setupEventListeners();
            loadFromStorage();
        }

        function initAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();

            // Master chain
            masterGain = audioContext.createGain();
            masterGain.gain.value = 0.7;

            // Compressor
            masterCompressor = audioContext.createDynamicsCompressor();
            masterCompressor.threshold.value = -24;
            masterCompressor.knee.value = 30;
            masterCompressor.ratio.value = 4;
            masterCompressor.attack.value = 0.003;
            masterCompressor.release.value = 0.25;

            // Delay
            masterDelay = audioContext.createDelay();
            masterDelay.delayTime.value = 0.25;

            delayFeedback = audioContext.createGain();
            delayFeedback.gain.value = 0.3;

            masterDelay.connect(delayFeedback);
            delayFeedback.connect(masterDelay);

            // Reverb (simple with delay network)
            masterReverb = audioContext.createConvolver();
            createReverbImpulse();

            // Dry/Wet mixing
            dryGain = audioContext.createGain();
            wetGain = audioContext.createGain();
            wetGain.gain.value = 0;

            // Connect chain
            dryGain.connect(masterCompressor);

            wetGain.connect(masterReverb);
            masterReverb.connect(masterCompressor);

            wetGain.connect(masterDelay);
            masterDelay.connect(masterCompressor);

            masterCompressor.connect(masterGain);
            masterGain.connect(audioContext.destination);
        }

        function createReverbImpulse() {
            const length = audioContext.sampleRate * 2;
            const impulse = audioContext.createBuffer(2, length, audioContext.sampleRate);
            const leftChannel = impulse.getChannelData(0);
            const rightChannel = impulse.getChannelData(1);

            for (let i = 0; i < length; i++) {
                const decay = Math.pow(1 - i / length, 2);
                leftChannel[i] = (Math.random() * 2 - 1) * decay;
                rightChannel[i] = (Math.random() * 2 - 1) * decay;
            }

            masterReverb.buffer = impulse;
        }

        function createPattern() {
            const pattern = {
                name: `Pattern ${patterns.length + 1}`,
                bpm: 120,
                swing: 0,
                tracks: tracks.map(track => ({
                    ...track,
                    steps: Array(16).fill(false),
                    notes: Array(16).fill(null).map(() => Array(notes.length).fill(false)),
                    settings: {
                        oscType: 'sine',
                        attack: 0.01,
                        decay: 0.1,
                        sustain: 0.7,
                        release: 0.2,
                        filterType: 'lowpass',
                        filterFreq: 2000,
                        filterQ: 1,
                        volume: 0.5,
                        pan: 0,
                        detune: 0
                    },
                    drumType: 'kick',
                    visualizer: null
                }))
            };
            patterns.push(pattern);
        }

        function renderPatternList() {
            const list = document.getElementById('patternList');
            list.innerHTML = '';
            patterns.forEach((pattern, index) => {
                const item = document.createElement('div');
                item.className = 'pattern-item' + (index === currentPattern ? ' selected' : '');
                item.textContent = pattern.name;
                item.onclick = () => {
                    currentPattern = index;
                    renderPatternList();
                    renderSequencer();
                };
                list.appendChild(item);
            });
        }

        function renderSequencer() {
            const container = document.getElementById('sequencerContainer');
            container.innerHTML = '';

            const pattern = patterns[currentPattern];

            pattern.tracks.forEach((track, trackIndex) => {
                const trackDiv = document.createElement('div');
                trackDiv.className = 'track';

                // Track header
                const header = document.createElement('div');
                header.className = 'track-header';

                const title = document.createElement('div');
                title.className = 'track-title';
                title.textContent = track.name;
                title.style.color = track.color;
                header.appendChild(title);

                // Track controls
                const controls = document.createElement('div');
                controls.className = 'track-controls';

                if (track.type === 'synth') {
                    controls.innerHTML = `
                        <div class="track-control">
                            <label>Osc</label>
                            <select onchange="updateTrackSetting(${trackIndex}, 'oscType', this.value)">
                                <option value="sine" ${track.settings.oscType === 'sine' ? 'selected' : ''}>Sine</option>
                                <option value="square" ${track.settings.oscType === 'square' ? 'selected' : ''}>Square</option>
                                <option value="sawtooth" ${track.settings.oscType === 'sawtooth' ? 'selected' : ''}>Saw</option>
                                <option value="triangle" ${track.settings.oscType === 'triangle' ? 'selected' : ''}>Triangle</option>
                            </select>
                        </div>
                        <div class="track-control">
                            <label>Attack</label>
                            <input type="range" min="0" max="1" step="0.01" value="${track.settings.attack}"
                                onchange="updateTrackSetting(${trackIndex}, 'attack', parseFloat(this.value))">
                        </div>
                        <div class="track-control">
                            <label>Release</label>
                            <input type="range" min="0" max="2" step="0.01" value="${track.settings.release}"
                                onchange="updateTrackSetting(${trackIndex}, 'release', parseFloat(this.value))">
                        </div>
                        <div class="track-control">
                            <label>Filter</label>
                            <select onchange="updateTrackSetting(${trackIndex}, 'filterType', this.value)">
                                <option value="lowpass" ${track.settings.filterType === 'lowpass' ? 'selected' : ''}>LP</option>
                                <option value="highpass" ${track.settings.filterType === 'highpass' ? 'selected' : ''}>HP</option>
                                <option value="bandpass" ${track.settings.filterType === 'bandpass' ? 'selected' : ''}>BP</option>
                            </select>
                        </div>
                        <div class="track-control">
                            <label>Cutoff</label>
                            <input type="range" min="100" max="10000" value="${track.settings.filterFreq}"
                                onchange="updateTrackSetting(${trackIndex}, 'filterFreq', parseFloat(this.value))">
                        </div>
                        <div class="track-control">
                            <label>Volume</label>
                            <input type="range" min="0" max="1" step="0.01" value="${track.settings.volume}"
                                onchange="updateTrackSetting(${trackIndex}, 'volume', parseFloat(this.value))">
                        </div>
                        <div class="track-control">
                            <label>Pan</label>
                            <input type="range" min="-1" max="1" step="0.01" value="${track.settings.pan}"
                                onchange="updateTrackSetting(${trackIndex}, 'pan', parseFloat(this.value))">
                        </div>
                    `;
                } else {
                    controls.innerHTML = `
                        <div class="track-control">
                            <label>Type</label>
                            <select onchange="updateTrackSetting(${trackIndex}, 'drumType', this.value)">
                                <option value="kick" ${track.drumType === 'kick' ? 'selected' : ''}>Kick</option>
                                <option value="snare" ${track.drumType === 'snare' ? 'selected' : ''}>Snare</option>
                                <option value="hihat" ${track.drumType === 'hihat' ? 'selected' : ''}>Hi-hat</option>
                                <option value="clap" ${track.drumType === 'clap' ? 'selected' : ''}>Clap</option>
                                <option value="tom" ${track.drumType === 'tom' ? 'selected' : ''}>Tom</option>
                            </select>
                        </div>
                        <div class="track-control">
                            <label>Volume</label>
                            <input type="range" min="0" max="1" step="0.01" value="${track.settings.volume}"
                                onchange="updateTrackSetting(${trackIndex}, 'volume', parseFloat(this.value))">
                        </div>
                    `;
                }

                header.appendChild(controls);
                trackDiv.appendChild(header);

                // Sequencer grid
                const grid = document.createElement('div');
                grid.className = 'sequencer-grid';

                for (let i = 0; i < 16; i++) {
                    const step = document.createElement('div');
                    step.className = 'step' + (track.steps[i] ? ' active' : '');
                    step.dataset.track = trackIndex;
                    step.dataset.step = i;
                    step.onclick = () => toggleStep(trackIndex, i);
                    grid.appendChild(step);
                }

                trackDiv.appendChild(grid);

                // Piano roll for synth tracks
                if (track.type === 'synth') {
                    const pianoRoll = document.createElement('div');
                    pianoRoll.className = 'piano-roll';

                    notes.slice().reverse().forEach((note, noteIndex) => {
                        const actualNoteIndex = notes.length - 1 - noteIndex;

                        const label = document.createElement('div');
                        label.className = 'note-label';
                        label.textContent = note;
                        pianoRoll.appendChild(label);

                        for (let i = 0; i < 16; i++) {
                            const cell = document.createElement('div');
                            cell.className = 'note-cell' + (track.notes[i][actualNoteIndex] ? ' active' : '');
                            cell.dataset.track = trackIndex;
                            cell.dataset.step = i;
                            cell.dataset.note = actualNoteIndex;
                            cell.onclick = () => toggleNote(trackIndex, i, actualNoteIndex);
                            pianoRoll.appendChild(cell);
                        }
                    });

                    trackDiv.appendChild(pianoRoll);
                }

                // Visualizer
                const canvas = document.createElement('canvas');
                canvas.className = 'visualizer';
                canvas.width = canvas.offsetWidth || 800;
                canvas.height = 100;
                track.visualizer = canvas;
                trackDiv.appendChild(canvas);

                container.appendChild(trackDiv);
            });
        }

        function renderKeyboard() {
            const keyboard = document.getElementById('keyboard');
            keyboard.innerHTML = '';

            const keyboardNotes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const octaves = [3, 4, 5];

            octaves.forEach(octave => {
                keyboardNotes.forEach(note => {
                    const noteName = note + octave;
                    const key = document.createElement('div');
                    key.className = 'key' + (note.includes('#') ? ' black' : '');
                    key.dataset.note = noteName;

                    const label = document.createElement('div');
                    label.className = 'key-label';
                    label.textContent = noteName;
                    key.appendChild(label);

                    key.onmousedown = () => playNote(selectedTrack, noteName);
                    key.onmouseup = () => stopNote(selectedTrack);
                    key.onmouseleave = () => stopNote(selectedTrack);

                    keyboard.appendChild(key);
                });
            });
        }

        function toggleStep(trackIndex, step) {
            const pattern = patterns[currentPattern];
            pattern.tracks[trackIndex].steps[step] = !pattern.tracks[trackIndex].steps[step];
            renderSequencer();
        }

        function toggleNote(trackIndex, step, noteIndex) {
            const pattern = patterns[currentPattern];
            const track = pattern.tracks[trackIndex];
            track.notes[step][noteIndex] = !track.notes[step][noteIndex];

            // If enabling a note, also enable the step
            if (track.notes[step][noteIndex]) {
                track.steps[step] = true;
            }

            renderSequencer();
        }

        function updateTrackSetting(trackIndex, setting, value) {
            const pattern = patterns[currentPattern];
            if (setting === 'drumType') {
                pattern.tracks[trackIndex].drumType = value;
            } else {
                pattern.tracks[trackIndex].settings[setting] = value;
            }
        }

        function playNote(trackIndex, noteName) {
            const pattern = patterns[currentPattern];
            const track = pattern.tracks[trackIndex];

            if (track.type === 'drums') {
                playDrum(track.drumType, audioContext.currentTime);
            } else {
                const freq = noteFrequencies[noteName];
                if (freq) {
                    playSynth(track, freq, audioContext.currentTime, 0.5);
                }
            }

            // Visual feedback
            const key = document.querySelector(`.key[data-note="${noteName}"]`);
            if (key) {
                key.classList.add('playing');
                setTimeout(() => key.classList.remove('playing'), 200);
            }
        }

        function stopNote(trackIndex) {
            // Notes use ADSR envelope, so they stop automatically
        }

        function playSynth(track, frequency, time, duration) {
            const osc = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            const panner = audioContext.createStereoPanner();

            osc.type = track.settings.oscType;
            osc.frequency.value = frequency;
            osc.detune.value = track.settings.detune;

            filter.type = track.settings.filterType;
            filter.frequency.value = track.settings.filterFreq;
            filter.Q.value = track.settings.filterQ;

            panner.pan.value = track.settings.pan;

            // ADSR envelope
            const attack = track.settings.attack;
            const decay = track.settings.decay;
            const sustain = track.settings.sustain;
            const release = track.settings.release;
            const volume = track.settings.volume;

            gainNode.gain.setValueAtTime(0, time);
            gainNode.gain.linearRampToValueAtTime(volume, time + attack);
            gainNode.gain.linearRampToValueAtTime(volume * sustain, time + attack + decay);
            gainNode.gain.setValueAtTime(volume * sustain, time + duration - release);
            gainNode.gain.linearRampToValueAtTime(0, time + duration);

            osc.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(panner);
            panner.connect(dryGain);
            panner.connect(wetGain);

            osc.start(time);
            osc.stop(time + duration);
        }

        function playDrum(drumType, time) {
            switch (drumType) {
                case 'kick':
                    playKick(time);
                    break;
                case 'snare':
                    playSnare(time);
                    break;
                case 'hihat':
                    playHihat(time);
                    break;
                case 'clap':
                    playClap(time);
                    break;
                case 'tom':
                    playTom(time);
                    break;
            }
        }

        function playKick(time) {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();

            osc.frequency.setValueAtTime(150, time);
            osc.frequency.exponentialRampToValueAtTime(30, time + 0.05);

            gain.gain.setValueAtTime(1, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);

            osc.connect(gain);
            gain.connect(dryGain);
            gain.connect(wetGain);

            osc.start(time);
            osc.stop(time + 0.5);
        }

        function playSnare(time) {
            // Tone component
            const osc = audioContext.createOscillator();
            const oscGain = audioContext.createGain();

            osc.type = 'triangle';
            osc.frequency.value = 200;

            oscGain.gain.setValueAtTime(0.3, time);
            oscGain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);

            osc.connect(oscGain);

            // Noise component
            const noise = audioContext.createBufferSource();
            const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.2, audioContext.sampleRate);
            const noiseData = noiseBuffer.getChannelData(0);
            for (let i = 0; i < noiseData.length; i++) {
                noiseData[i] = Math.random() * 2 - 1;
            }
            noise.buffer = noiseBuffer;

            const noiseFilter = audioContext.createBiquadFilter();
            noiseFilter.type = 'highpass';
            noiseFilter.frequency.value = 1000;

            const noiseGain = audioContext.createGain();
            noiseGain.gain.setValueAtTime(0.5, time);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);

            noise.connect(noiseFilter);
            noiseFilter.connect(noiseGain);

            const merger = audioContext.createGain();
            oscGain.connect(merger);
            noiseGain.connect(merger);
            merger.connect(dryGain);
            merger.connect(wetGain);

            osc.start(time);
            osc.stop(time + 0.2);
            noise.start(time);
        }

        function playHihat(time) {
            const noise = audioContext.createBufferSource();
            const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.05, audioContext.sampleRate);
            const noiseData = noiseBuffer.getChannelData(0);
            for (let i = 0; i < noiseData.length; i++) {
                noiseData[i] = Math.random() * 2 - 1;
            }
            noise.buffer = noiseBuffer;

            const filter = audioContext.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.value = 7000;

            const gain = audioContext.createGain();
            gain.gain.setValueAtTime(0.3, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.05);

            noise.connect(filter);
            filter.connect(gain);
            gain.connect(dryGain);
            gain.connect(wetGain);

            noise.start(time);
        }

        function playClap(time) {
            for (let i = 0; i < 3; i++) {
                const delay = i * 0.01;
                const noise = audioContext.createBufferSource();
                const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.1, audioContext.sampleRate);
                const noiseData = noiseBuffer.getChannelData(0);
                for (let j = 0; j < noiseData.length; j++) {
                    noiseData[j] = Math.random() * 2 - 1;
                }
                noise.buffer = noiseBuffer;

                const filter = audioContext.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.value = 1500;

                const gain = audioContext.createGain();
                gain.gain.setValueAtTime(0.3, time + delay);
                gain.gain.exponentialRampToValueAtTime(0.01, time + delay + 0.1);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(dryGain);
                gain.connect(wetGain);

                noise.start(time + delay);
            }
        }

        function playTom(time) {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();

            osc.frequency.setValueAtTime(120, time);
            osc.frequency.exponentialRampToValueAtTime(60, time + 0.1);

            gain.gain.setValueAtTime(0.7, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.3);

            osc.connect(gain);
            gain.connect(dryGain);
            gain.connect(wetGain);

            osc.start(time);
            osc.stop(time + 0.3);
        }

        function scheduleNote(trackIndex, step, time) {
            const pattern = patterns[currentPattern];
            const track = pattern.tracks[trackIndex];

            if (!track.steps[step]) return;

            if (track.type === 'drums') {
                playDrum(track.drumType, time);
            } else {
                // Play all active notes in this step
                track.notes[step].forEach((active, noteIndex) => {
                    if (active) {
                        const freq = noteFrequencies[notes[noteIndex]];
                        if (freq) {
                            const noteDuration = (60 / bpm) * 0.8; // 80% of step duration
                            playSynth(track, freq, time, noteDuration);
                        }
                    }
                });
            }

            // Visual feedback (on main thread)
            setTimeout(() => {
                const stepElements = document.querySelectorAll(`.step[data-track="${trackIndex}"][data-step="${step}"]`);
                stepElements.forEach(el => {
                    el.classList.add('playing');
                    setTimeout(() => el.classList.remove('playing'), 100);
                });
            }, (time - audioContext.currentTime) * 1000);
        }

        function scheduler() {
            while (nextNoteTime < audioContext.currentTime + scheduleAheadTime) {
                scheduleStep(currentStep, nextNoteTime);
                nextStep();
            }
            timerID = setTimeout(scheduler, lookahead);
        }

        function scheduleStep(step, time) {
            const pattern = patterns[currentPattern];
            pattern.tracks.forEach((track, trackIndex) => {
                scheduleNote(trackIndex, step, time);
            });
        }

        function nextStep() {
            const secondsPerBeat = 60.0 / bpm;
            const secondsPerStep = secondsPerBeat / 4; // 16th notes

            // Apply swing to odd steps
            let stepDuration = secondsPerStep;
            if (currentStep % 2 === 1 && swing > 0) {
                stepDuration *= 1 + (swing / 100);
            }

            nextNoteTime += stepDuration;
            currentStep++;

            if (currentStep >= 16) {
                if (loopEnabled) {
                    currentStep = 0;
                } else {
                    stop();
                    return;
                }
            }
        }

        function play() {
            if (isPlaying) return;

            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }

            isPlaying = true;
            currentStep = 0;
            nextNoteTime = audioContext.currentTime;
            scheduler();

            document.getElementById('playBtn').classList.add('active');
        }

        function stop() {
            isPlaying = false;
            currentStep = 0;

            if (timerID) {
                clearTimeout(timerID);
            }

            document.getElementById('playBtn').classList.remove('active');
        }

        function setupEventListeners() {
            // Transport controls
            document.getElementById('playBtn').onclick = play;
            document.getElementById('stopBtn').onclick = stop;

            const loopBtn = document.getElementById('loopBtn');
            loopBtn.onclick = () => {
                loopEnabled = !loopEnabled;
                loopBtn.textContent = `Loop: ${loopEnabled ? 'ON' : 'OFF'}`;
                loopBtn.classList.toggle('active', loopEnabled);
            };

            // BPM control
            const bpmInput = document.getElementById('bpmInput');
            bpmInput.onchange = () => {
                bpm = parseInt(bpmInput.value);
                patterns[currentPattern].bpm = bpm;
            };

            // Tap tempo
            document.getElementById('tapBtn').onclick = () => {
                const now = Date.now();
                tapTimes.push(now);

                // Keep only last 4 taps
                if (tapTimes.length > 4) {
                    tapTimes.shift();
                }

                if (tapTimes.length >= 2) {
                    const intervals = [];
                    for (let i = 1; i < tapTimes.length; i++) {
                        intervals.push(tapTimes[i] - tapTimes[i - 1]);
                    }
                    const avgInterval = intervals.reduce((a, b) => a + b) / intervals.length;
                    const newBpm = Math.round(60000 / avgInterval);

                    if (newBpm >= 60 && newBpm <= 200) {
                        bpm = newBpm;
                        bpmInput.value = bpm;
                        patterns[currentPattern].bpm = bpm;
                    }
                }

                // Clear taps after 2 seconds
                setTimeout(() => {
                    tapTimes = tapTimes.filter(t => Date.now() - t < 2000);
                }, 2000);
            };

            // Swing control
            const swingSlider = document.getElementById('swingSlider');
            const swingValue = document.getElementById('swingValue');
            swingSlider.oninput = () => {
                swing = parseInt(swingSlider.value);
                swingValue.textContent = swing + '%';
                patterns[currentPattern].swing = swing;
            };

            // Master effects
            const reverbMix = document.getElementById('reverbMix');
            const reverbMixValue = document.getElementById('reverbMixValue');
            reverbMix.oninput = () => {
                const mix = parseInt(reverbMix.value) / 100;
                reverbMixValue.textContent = reverbMix.value + '%';
                wetGain.gain.setValueAtTime(mix, audioContext.currentTime);
                dryGain.gain.setValueAtTime(1 - mix * 0.5, audioContext.currentTime);
            };

            const delayTime = document.getElementById('delayTime');
            const delayTimeValue = document.getElementById('delayTimeValue');
            delayTime.oninput = () => {
                const time = parseInt(delayTime.value) / 1000;
                delayTimeValue.textContent = delayTime.value + 'ms';
                masterDelay.delayTime.setValueAtTime(time, audioContext.currentTime);
            };

            const delayFeedbackCtrl = document.getElementById('delayFeedback');
            const delayFeedbackValue = document.getElementById('delayFeedbackValue');
            delayFeedbackCtrl.oninput = () => {
                const fb = parseInt(delayFeedbackCtrl.value) / 100;
                delayFeedbackValue.textContent = delayFeedbackCtrl.value + '%';
                delayFeedback.gain.setValueAtTime(fb, audioContext.currentTime);
            };

            const delayMix = document.getElementById('delayMix');
            const delayMixValue = document.getElementById('delayMixValue');
            delayMix.oninput = () => {
                delayMixValue.textContent = delayMix.value + '%';
                // Delay mix is handled through wetGain
            };

            const compThreshold = document.getElementById('compThreshold');
            const compThresholdValue = document.getElementById('compThresholdValue');
            compThreshold.oninput = () => {
                const thresh = parseInt(compThreshold.value);
                compThresholdValue.textContent = thresh + 'dB';
                masterCompressor.threshold.setValueAtTime(thresh, audioContext.currentTime);
            };

            const compRatio = document.getElementById('compRatio');
            const compRatioValue = document.getElementById('compRatioValue');
            compRatio.oninput = () => {
                const ratio = parseInt(compRatio.value);
                compRatioValue.textContent = ratio + ':1';
                masterCompressor.ratio.setValueAtTime(ratio, audioContext.currentTime);
            };

            // Pattern management
            document.getElementById('newPatternBtn').onclick = () => {
                createPattern();
                currentPattern = patterns.length - 1;
                renderPatternList();
                renderSequencer();
            };

            document.getElementById('saveBtn').onclick = saveToStorage;
            document.getElementById('loadBtn').onclick = loadFromStorage;
            document.getElementById('exportBtn').onclick = exportJSON;
            document.getElementById('importBtn').onclick = () => {
                document.getElementById('importFile').click();
            };

            document.getElementById('importFile').onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const data = JSON.parse(event.target.result);
                            patterns = data.patterns;
                            currentPattern = 0;
                            renderPatternList();
                            renderSequencer();
                            alert('Patterns imported successfully!');
                        } catch (err) {
                            alert('Error importing patterns: ' + err.message);
                        }
                    };
                    reader.readAsText(file);
                }
            };
        }

        function saveToStorage() {
            try {
                const data = {
                    patterns: patterns,
                    currentPattern: currentPattern
                };
                localStorage.setItem('synthDAWStudio', JSON.stringify(data));
                alert('Patterns saved to localStorage!');
            } catch (err) {
                alert('Error saving: ' + err.message);
            }
        }

        function loadFromStorage() {
            try {
                const data = localStorage.getItem('synthDAWStudio');
                if (data) {
                    const parsed = JSON.parse(data);
                    patterns = parsed.patterns;
                    currentPattern = parsed.currentPattern || 0;

                    // Restore UI state
                    const pattern = patterns[currentPattern];
                    document.getElementById('bpmInput').value = pattern.bpm;
                    bpm = pattern.bpm;
                    document.getElementById('swingSlider').value = pattern.swing;
                    swing = pattern.swing;
                    document.getElementById('swingValue').textContent = swing + '%';

                    renderPatternList();
                    renderSequencer();
                    alert('Patterns loaded from localStorage!');
                } else {
                    alert('No saved data found.');
                }
            } catch (err) {
                alert('Error loading: ' + err.message);
            }
        }

        function exportJSON() {
            const data = {
                patterns: patterns,
                currentPattern: currentPattern,
                exportDate: new Date().toISOString()
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'synth-daw-patterns.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && e.target.tagName !== 'INPUT') {
                e.preventDefault();
                if (isPlaying) {
                    stop();
                } else {
                    play();
                }
            }
        });

        // Click anywhere to ensure audio context starts
        document.addEventListener('click', () => {
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }, { once: true });

        // Initialize on load
        window.addEventListener('load', init);
    </script>
</body>
</html>