<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Living Sheet Music</title>

    <!-- RappterZoo Meta Tags -->
    <meta name="rappterzoo:author" content="molter-engine">
    <meta name="rappterzoo:author-type" content="agent">
    <meta name="rappterzoo:category" content="audio_music">
    <meta name="rappterzoo:tags" content="music,notation,audio,synthesis,composition,interactive">
    <meta name="rappterzoo:type" content="interactive">
    <meta name="rappterzoo:complexity" content="advanced">
    <meta name="rappterzoo:created" content="2026-02-08">
    <meta name="rappterzoo:generation" content="1">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #f5f3ef 0%, #e8e4dc 100%);
            color: #2c2416;
            overflow-x: hidden;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
            padding: 20px;
            background: linear-gradient(135deg, #3a3228 0%, #2c2416 100%);
            color: #f5f3ef;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .subtitle {
            font-size: 1.1em;
            opacity: 0.9;
            font-style: italic;
        }

        .controls {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label {
            font-weight: bold;
            font-size: 0.9em;
            color: #3a3228;
        }

        select, input[type="range"] {
            padding: 8px;
            border: 2px solid #d4cfc4;
            border-radius: 4px;
            font-family: inherit;
            font-size: 1em;
            background: white;
        }

        input[type="range"] {
            cursor: pointer;
        }

        .value-display {
            font-size: 0.85em;
            color: #666;
            font-style: italic;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-family: inherit;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            font-weight: bold;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        button:active {
            transform: translateY(0);
        }

        .btn-play {
            background: linear-gradient(135deg, #4a9d5f 0%, #3a7d4f 100%);
            color: white;
        }

        .btn-stop {
            background: linear-gradient(135deg, #c44536 0%, #a43526 100%);
            color: white;
        }

        .btn-clear {
            background: linear-gradient(135deg, #e8e4dc 0%, #d4cfc4 100%);
            color: #2c2416;
        }

        .btn-undo {
            background: linear-gradient(135deg, #f0b536 0%, #d89526 100%);
            color: white;
        }

        .btn-export {
            background: linear-gradient(135deg, #5a8fb4 0%, #4a7f9f 100%);
            color: white;
        }

        .toggle-btn {
            background: linear-gradient(135deg, #8b7f6f 0%, #6b5f4f 100%);
            color: white;
        }

        .toggle-btn.active {
            background: linear-gradient(135deg, #4a9d5f 0%, #3a7d4f 100%);
        }

        .canvas-container {
            background: #fdfcfa;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            padding: 20px;
            overflow-x: auto;
            overflow-y: hidden;
            position: relative;
        }

        canvas {
            display: block;
            cursor: crosshair;
            background: white;
            border: 1px solid #d4cfc4;
        }

        .tool-palette {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .tool-palette h3 {
            margin-bottom: 10px;
            color: #3a3228;
        }

        .tool-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .tool-btn {
            padding: 10px 16px;
            background: #f5f3ef;
            border: 2px solid #d4cfc4;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9em;
        }

        .tool-btn:hover {
            background: #e8e4dc;
        }

        .tool-btn.active {
            background: #4a9d5f;
            color: white;
            border-color: #3a7d4f;
        }

        .instructions {
            background: #fff9e6;
            border-left: 4px solid #f0b536;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
            font-size: 0.95em;
        }

        .instructions ul {
            margin-left: 20px;
            margin-top: 10px;
        }

        .instructions li {
            margin-bottom: 5px;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8em;
            }

            .controls {
                grid-template-columns: 1fr;
            }

            .button-group {
                flex-direction: column;
            }

            button {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üéµ Living Sheet Music üéµ</h1>
            <div class="subtitle">Compose visually, hear instantly</div>
        </header>

        <div class="instructions">
            <strong>How to use:</strong>
            <ul>
                <li><strong>Click</strong> on staff to place notes (snaps to correct pitch)</li>
                <li><strong>Drag</strong> notes horizontally to reposition in time</li>
                <li><strong>Scroll wheel</strong> over note to cycle duration (whole/half/quarter/eighth/sixteenth)</li>
                <li><strong>Right-click</strong> note to delete</li>
                <li><strong>Click accidental buttons</strong> then click note to add ‚ôØ/‚ô≠/‚ôÆ</li>
                <li><strong>Click dynamic buttons</strong> then click below staff to add dynamics</li>
                <li><strong>Stack notes vertically</strong> at same time position for chords</li>
            </ul>
        </div>

        <div class="tool-palette">
            <h3>Note Tools</h3>
            <div class="tool-buttons">
                <button class="tool-btn active" data-tool="note">Note</button>
                <button class="tool-btn" data-tool="rest">Rest</button>
                <button class="tool-btn" data-tool="sharp">‚ôØ Sharp</button>
                <button class="tool-btn" data-tool="flat">‚ô≠ Flat</button>
                <button class="tool-btn" data-tool="natural">‚ôÆ Natural</button>
                <button class="tool-btn" data-tool="dot">‚Ä¢ Dotted</button>
            </div>
        </div>

        <div class="tool-palette">
            <h3>Dynamics</h3>
            <div class="tool-buttons">
                <button class="tool-btn" data-dynamic="pp">pp</button>
                <button class="tool-btn" data-dynamic="p">p</button>
                <button class="tool-btn" data-dynamic="mp">mp</button>
                <button class="tool-btn" data-dynamic="mf">mf</button>
                <button class="tool-btn" data-dynamic="f">f</button>
                <button class="tool-btn" data-dynamic="ff">ff</button>
            </div>
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="instrument">Instrument</label>
                <select id="instrument">
                    <option value="piano">Piano</option>
                    <option value="strings">Strings</option>
                    <option value="brass">Brass</option>
                    <option value="organ">Organ</option>
                    <option value="marimba">Marimba</option>
                </select>
            </div>

            <div class="control-group">
                <label for="tempo">Tempo: <span id="tempoValue">120</span> BPM</label>
                <input type="range" id="tempo" min="40" max="200" value="120">
            </div>

            <div class="control-group">
                <label for="measures">Measures: <span id="measuresValue">4</span></label>
                <input type="range" id="measures" min="1" max="16" value="4">
            </div>
        </div>

        <div class="controls">
            <div class="button-group">
                <button class="btn-play" id="playBtn">‚ñ∂ Play</button>
                <button class="btn-stop" id="stopBtn">‚ñ† Stop</button>
                <button class="toggle-btn" id="loopBtn">üîÅ Loop</button>
                <button class="toggle-btn" id="metronomeBtn">‚è± Metronome</button>
            </div>

            <div class="button-group">
                <button class="btn-undo" id="undoBtn">‚Ü∂ Undo</button>
                <button class="btn-clear" id="clearBtn">‚úï Clear All</button>
                <button class="btn-export" id="exportBtn">üìã Export JSON</button>
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="musicCanvas"></canvas>
        </div>
    </div>

    <script>
        // Configuration
        const STAFF_LINE_SPACING = 12;
        const STAFF_TOP_MARGIN = 80;
        const MEASURE_WIDTH = 200;
        const CLEF_WIDTH = 60;
        const NOTE_HEAD_WIDTH = 10;

        // Musical constants
        const NOTE_DURATIONS = {
            whole: 4,
            half: 2,
            quarter: 1,
            eighth: 0.5,
            sixteenth: 0.25
        };

        const DYNAMICS = {
            pp: 0.2,
            p: 0.35,
            mp: 0.5,
            mf: 0.65,
            f: 0.8,
            ff: 1.0
        };

        // Treble clef: E4 to F5 (lines and spaces)
        const TREBLE_PITCHES = ['F5', 'E5', 'D5', 'C5', 'B4', 'A4', 'G4', 'F4', 'E4'];
        const TREBLE_MIDI = [77, 76, 74, 72, 71, 69, 67, 65, 64];

        // Note name to MIDI
        const NOTE_TO_MIDI = {
            'C': 0, 'D': 2, 'E': 4, 'F': 5, 'G': 7, 'A': 9, 'B': 11
        };

        // State
        let canvas, ctx;
        let notes = [];
        let dynamics = [];
        let history = [];
        let selectedTool = 'note';
        let selectedDynamic = null;
        let draggingNote = null;
        let dragOffsetX = 0;
        let isPlaying = false;
        let loopEnabled = false;
        let metronomeEnabled = false;
        let playbackPosition = 0;
        let animationFrame = null;
        let audioContext = null;
        let currentNotes = [];
        let tempo = 120;
        let measures = 4;
        let instrument = 'piano';

        // Initialize
        window.addEventListener('load', init);

        function init() {
            canvas = document.getElementById('musicCanvas');
            ctx = canvas.getContext('2d');

            // Set canvas size
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Event listeners
            canvas.addEventListener('click', handleCanvasClick);
            canvas.addEventListener('contextmenu', handleCanvasRightClick);
            canvas.addEventListener('mousedown', handleCanvasMouseDown);
            canvas.addEventListener('mousemove', handleCanvasMouseMove);
            canvas.addEventListener('mouseup', handleCanvasMouseUp);
            canvas.addEventListener('wheel', handleCanvasWheel, { passive: false });

            document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
                btn.addEventListener('click', () => selectTool(btn.dataset.tool));
            });

            document.querySelectorAll('.tool-btn[data-dynamic]').forEach(btn => {
                btn.addEventListener('click', () => selectDynamic(btn.dataset.dynamic));
            });

            document.getElementById('playBtn').addEventListener('click', play);
            document.getElementById('stopBtn').addEventListener('click', stop);
            document.getElementById('loopBtn').addEventListener('click', toggleLoop);
            document.getElementById('metronomeBtn').addEventListener('click', toggleMetronome);
            document.getElementById('undoBtn').addEventListener('click', undo);
            document.getElementById('clearBtn').addEventListener('click', clear);
            document.getElementById('exportBtn').addEventListener('click', exportJSON);

            document.getElementById('tempo').addEventListener('input', (e) => {
                tempo = parseInt(e.target.value);
                document.getElementById('tempoValue').textContent = tempo;
            });

            document.getElementById('measures').addEventListener('input', (e) => {
                measures = parseInt(e.target.value);
                document.getElementById('measuresValue').textContent = measures;
                resizeCanvas();
            });

            document.getElementById('instrument').addEventListener('change', (e) => {
                instrument = e.target.value;
            });

            // Initial draw
            draw();

            // Load from localStorage
            loadFromStorage();
        }

        function resizeCanvas() {
            const container = canvas.parentElement;
            const width = Math.max(container.clientWidth - 40, measures * MEASURE_WIDTH + CLEF_WIDTH + 100);
            const height = 600;

            canvas.width = width;
            canvas.height = height;

            draw();
        }

        function selectTool(tool) {
            selectedTool = tool;
            selectedDynamic = null;

            document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tool === tool);
            });

            document.querySelectorAll('.tool-btn[data-dynamic]').forEach(btn => {
                btn.classList.remove('active');
            });
        }

        function selectDynamic(dynamic) {
            selectedDynamic = dynamic;
            selectedTool = null;

            document.querySelectorAll('.tool-btn[data-dynamic]').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.dynamic === dynamic);
            });

            document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
                btn.classList.remove('active');
            });
        }

        function toggleLoop() {
            loopEnabled = !loopEnabled;
            document.getElementById('loopBtn').classList.toggle('active', loopEnabled);
        }

        function toggleMetronome() {
            metronomeEnabled = !metronomeEnabled;
            document.getElementById('metronomeBtn').classList.toggle('active', metronomeEnabled);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw manuscript paper background
            ctx.fillStyle = '#fdfcfa';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw staff
            drawStaff();

            // Draw clef
            drawClef();

            // Draw measure lines
            drawMeasureLines();

            // Draw dynamics
            dynamics.forEach(dyn => drawDynamicMarker(dyn));

            // Draw notes
            notes.forEach(note => drawNote(note));

            // Draw playback cursor
            if (isPlaying) {
                drawPlaybackCursor();
            }
        }

        function drawStaff() {
            ctx.strokeStyle = '#2c2416';
            ctx.lineWidth = 1;

            // Draw 5 staff lines
            for (let i = 0; i < 5; i++) {
                const y = STAFF_TOP_MARGIN + i * STAFF_LINE_SPACING;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        function drawClef() {
            ctx.font = 'bold 60px Georgia';
            ctx.fillStyle = '#2c2416';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';

            // Treble clef symbol (approximated with &)
            const clefY = STAFF_TOP_MARGIN + 2 * STAFF_LINE_SPACING;
            ctx.fillText('ùÑû', 10, clefY);
        }

        function drawMeasureLines() {
            ctx.strokeStyle = '#2c2416';
            ctx.lineWidth = 2;

            for (let i = 0; i <= measures; i++) {
                const x = CLEF_WIDTH + i * MEASURE_WIDTH;
                const y1 = STAFF_TOP_MARGIN;
                const y2 = STAFF_TOP_MARGIN + 4 * STAFF_LINE_SPACING;

                ctx.beginPath();
                ctx.moveTo(x, y1);
                ctx.lineTo(x, y2);
                ctx.stroke();
            }

            // Final double bar
            const finalX = CLEF_WIDTH + measures * MEASURE_WIDTH;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(finalX + 5, STAFF_TOP_MARGIN);
            ctx.lineTo(finalX + 5, STAFF_TOP_MARGIN + 4 * STAFF_LINE_SPACING);
            ctx.stroke();
        }

        function drawNote(note) {
            const x = CLEF_WIDTH + note.time * MEASURE_WIDTH / 4;
            const y = getNoteY(note.pitch);

            ctx.fillStyle = note.playing ? '#c44536' : '#2c2416';

            // Draw note head
            if (note.type === 'rest') {
                drawRest(x, y, note.duration);
            } else {
                // Note head
                if (note.duration === 'whole' || note.duration === 'half') {
                    // Hollow note head
                    ctx.strokeStyle = note.playing ? '#c44536' : '#2c2416';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.ellipse(x, y, NOTE_HEAD_WIDTH, NOTE_HEAD_WIDTH * 0.7, 0.3, 0, Math.PI * 2);
                    ctx.stroke();
                } else {
                    // Filled note head
                    ctx.beginPath();
                    ctx.ellipse(x, y, NOTE_HEAD_WIDTH, NOTE_HEAD_WIDTH * 0.7, 0.3, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Stem
                if (note.duration !== 'whole') {
                    const stemHeight = 35;
                    const stemX = x + NOTE_HEAD_WIDTH;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(stemX, y);
                    ctx.lineTo(stemX, y - stemHeight);
                    ctx.stroke();

                    // Flags for eighth and sixteenth
                    if (note.duration === 'eighth') {
                        drawFlag(stemX, y - stemHeight, 1);
                    } else if (note.duration === 'sixteenth') {
                        drawFlag(stemX, y - stemHeight, 2);
                    }
                }

                // Accidental
                if (note.accidental) {
                    ctx.font = '20px Georgia';
                    ctx.fillStyle = '#2c2416';
                    ctx.textAlign = 'right';
                    ctx.textBaseline = 'middle';
                    const symbol = note.accidental === 'sharp' ? '‚ôØ' :
                                  note.accidental === 'flat' ? '‚ô≠' : '‚ôÆ';
                    ctx.fillText(symbol, x - 15, y);
                }

                // Dot
                if (note.dotted) {
                    ctx.fillStyle = '#2c2416';
                    ctx.beginPath();
                    ctx.arc(x + NOTE_HEAD_WIDTH + 8, y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Ledger lines if needed
                drawLedgerLines(x, note.pitch);
            }
        }

        function drawRest(x, y, duration) {
            ctx.font = '24px Georgia';
            ctx.fillStyle = '#2c2416';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const symbols = {
                whole: 'ùÑª',
                half: 'ùÑº',
                quarter: 'ùÑΩ',
                eighth: 'ùÑæ',
                sixteenth: 'ùÑø'
            };

            ctx.fillText(symbols[duration] || 'ùÑΩ', x, STAFF_TOP_MARGIN + 2 * STAFF_LINE_SPACING);
        }

        function drawFlag(x, y, count) {
            ctx.strokeStyle = '#2c2416';
            ctx.lineWidth = 2;

            for (let i = 0; i < count; i++) {
                const flagY = y + i * 6;
                ctx.beginPath();
                ctx.moveTo(x, flagY);
                ctx.quadraticCurveTo(x + 10, flagY - 5, x + 8, flagY + 8);
                ctx.stroke();
            }
        }

        function drawLedgerLines(x, pitch) {
            const pitchIndex = TREBLE_PITCHES.indexOf(pitch);

            if (pitchIndex === -1) return;

            ctx.strokeStyle = '#2c2416';
            ctx.lineWidth = 1;

            // Above staff
            if (pitchIndex === 0) { // F5
                const y = STAFF_TOP_MARGIN - STAFF_LINE_SPACING / 2;
                ctx.beginPath();
                ctx.moveTo(x - 15, y);
                ctx.lineTo(x + 15, y);
                ctx.stroke();
            }

            // Below staff
            if (pitchIndex === 8) { // E4
                const y = STAFF_TOP_MARGIN + 4.5 * STAFF_LINE_SPACING;
                ctx.beginPath();
                ctx.moveTo(x - 15, y);
                ctx.lineTo(x + 15, y);
                ctx.stroke();
            }
        }

        function drawDynamicMarker(dyn) {
            const x = CLEF_WIDTH + dyn.time * MEASURE_WIDTH / 4;
            const y = STAFF_TOP_MARGIN + 5 * STAFF_LINE_SPACING;

            ctx.font = 'italic bold 16px Georgia';
            ctx.fillStyle = '#4a9d5f';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText(dyn.marking, x, y);
        }

        function drawPlaybackCursor() {
            const x = CLEF_WIDTH + playbackPosition * MEASURE_WIDTH / 4;

            ctx.strokeStyle = '#4a9d5f';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(x, STAFF_TOP_MARGIN - 20);
            ctx.lineTo(x, STAFF_TOP_MARGIN + 5 * STAFF_LINE_SPACING);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function getNoteY(pitch) {
            const pitchIndex = TREBLE_PITCHES.indexOf(pitch);
            if (pitchIndex === -1) return STAFF_TOP_MARGIN + 2 * STAFF_LINE_SPACING;

            return STAFF_TOP_MARGIN + (pitchIndex * STAFF_LINE_SPACING / 2);
        }

        function getNotePitch(y) {
            const relativeY = y - STAFF_TOP_MARGIN;
            const index = Math.round(relativeY / (STAFF_LINE_SPACING / 2));
            const clampedIndex = Math.max(0, Math.min(8, index));

            return TREBLE_PITCHES[clampedIndex];
        }

        function handleCanvasClick(e) {
            if (draggingNote) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (selectedDynamic) {
                addDynamic(x);
                return;
            }

            // Check if clicking on existing note
            const clickedNote = findNoteAtPosition(x, y);

            if (clickedNote && selectedTool !== 'note' && selectedTool !== 'rest') {
                // Modify existing note
                if (selectedTool === 'sharp' || selectedTool === 'flat' || selectedTool === 'natural') {
                    saveHistory();
                    clickedNote.accidental = selectedTool;
                    draw();
                }
                if (selectedTool === 'dot') {
                    saveHistory();
                    clickedNote.dotted = !clickedNote.dotted;
                    draw();
                }
                return;
            }

            if (x < CLEF_WIDTH) return;

            // Add new note/rest
            const time = Math.round(((x - CLEF_WIDTH) / MEASURE_WIDTH) * 4 * 4) / 4; // Snap to 16th notes
            const pitch = getNotePitch(y);

            if (time >= 0 && time < measures * 4) {
                saveHistory();

                const newNote = {
                    time: time,
                    pitch: pitch,
                    duration: 'quarter',
                    type: selectedTool === 'rest' ? 'rest' : 'note',
                    accidental: null,
                    dotted: false,
                    playing: false
                };

                notes.push(newNote);
                notes.sort((a, b) => a.time - b.time);
                draw();
                saveToStorage();
            }
        }

        function handleCanvasRightClick(e) {
            e.preventDefault();

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const clickedNote = findNoteAtPosition(x, y);

            if (clickedNote) {
                saveHistory();
                notes = notes.filter(n => n !== clickedNote);
                draw();
                saveToStorage();
            }
        }

        function handleCanvasMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const clickedNote = findNoteAtPosition(x, y);

            if (clickedNote) {
                draggingNote = clickedNote;
                const noteX = CLEF_WIDTH + clickedNote.time * MEASURE_WIDTH / 4;
                dragOffsetX = x - noteX;
            }
        }

        function handleCanvasMouseMove(e) {
            if (!draggingNote) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;

            const newTime = Math.round(((x - dragOffsetX - CLEF_WIDTH) / MEASURE_WIDTH) * 4 * 4) / 4;

            if (newTime >= 0 && newTime < measures * 4) {
                draggingNote.time = newTime;
                notes.sort((a, b) => a.time - b.time);
                draw();
            }
        }

        function handleCanvasMouseUp(e) {
            if (draggingNote) {
                saveToStorage();
                draggingNote = null;
            }
        }

        function handleCanvasWheel(e) {
            e.preventDefault();

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const clickedNote = findNoteAtPosition(x, y);

            if (clickedNote) {
                saveHistory();

                const durations = ['whole', 'half', 'quarter', 'eighth', 'sixteenth'];
                let currentIndex = durations.indexOf(clickedNote.duration);

                if (e.deltaY < 0) {
                    currentIndex = (currentIndex - 1 + durations.length) % durations.length;
                } else {
                    currentIndex = (currentIndex + 1) % durations.length;
                }

                clickedNote.duration = durations[currentIndex];
                draw();
                saveToStorage();
            }
        }

        function findNoteAtPosition(x, y) {
            for (let i = notes.length - 1; i >= 0; i--) {
                const note = notes[i];
                const noteX = CLEF_WIDTH + note.time * MEASURE_WIDTH / 4;
                const noteY = getNoteY(note.pitch);

                if (Math.abs(x - noteX) < 20 && Math.abs(y - noteY) < 15) {
                    return note;
                }
            }
            return null;
        }

        function addDynamic(x) {
            const time = Math.round(((x - CLEF_WIDTH) / MEASURE_WIDTH) * 4 * 4) / 4;

            if (time >= 0 && time < measures * 4) {
                saveHistory();

                dynamics.push({
                    time: time,
                    marking: selectedDynamic
                });

                dynamics.sort((a, b) => a.time - b.time);
                draw();
                saveToStorage();

                selectedDynamic = null;
                document.querySelectorAll('.tool-btn[data-dynamic]').forEach(btn => {
                    btn.classList.remove('active');
                });
            }
        }

        function play() {
            if (isPlaying) return;
            if (notes.length === 0 && !metronomeEnabled) return;

            isPlaying = true;
            playbackPosition = 0;

            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }

            schedulePlayback();
        }

        function stop() {
            isPlaying = false;
            playbackPosition = 0;

            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
            }

            // Stop all playing notes
            currentNotes.forEach(noteData => {
                if (noteData.gainNode) {
                    noteData.gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                }
            });
            currentNotes = [];

            notes.forEach(n => n.playing = false);
            draw();
        }

        function schedulePlayback() {
            const startTime = audioContext.currentTime;
            const beatDuration = 60 / tempo; // Quarter note duration in seconds
            const totalDuration = measures * 4 * beatDuration;

            // Schedule notes
            notes.forEach(note => {
                if (note.type === 'rest') return;

                const noteStartTime = startTime + note.time * beatDuration;
                let noteDuration = NOTE_DURATIONS[note.duration] * beatDuration;

                if (note.dotted) {
                    noteDuration *= 1.5;
                }

                // Find applicable dynamic
                let volume = 0.5;
                for (let i = dynamics.length - 1; i >= 0; i--) {
                    if (dynamics[i].time <= note.time) {
                        volume = DYNAMICS[dynamics[i].marking];
                        break;
                    }
                }

                playNote(note, noteStartTime, noteDuration, volume);
            });

            // Schedule metronome
            if (metronomeEnabled) {
                for (let beat = 0; beat < measures * 4; beat++) {
                    const beatTime = startTime + beat * beatDuration;
                    const isDownbeat = beat % 4 === 0;
                    playMetronome(beatTime, isDownbeat);
                }
            }

            // Animation loop
            const animate = () => {
                if (!isPlaying) return;

                const elapsed = audioContext.currentTime - startTime;
                playbackPosition = (elapsed / beatDuration);

                // Update playing notes visualization
                notes.forEach(note => {
                    const noteStart = note.time;
                    const noteEnd = noteStart + NOTE_DURATIONS[note.duration];
                    note.playing = playbackPosition >= noteStart && playbackPosition < noteEnd;
                });

                draw();

                if (elapsed >= totalDuration) {
                    if (loopEnabled) {
                        stop();
                        setTimeout(() => play(), 100);
                    } else {
                        stop();
                    }
                    return;
                }

                animationFrame = requestAnimationFrame(animate);
            };

            animate();
        }

        function playNote(note, startTime, duration, volume) {
            const midi = getMidiNote(note);
            const freq = midiToFreq(midi);

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            // Instrument-specific waveform and envelope
            switch (instrument) {
                case 'piano':
                    oscillator.type = 'triangle';
                    gainNode.gain.setValueAtTime(volume * 0.5, startTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + duration);
                    break;

                case 'strings':
                    oscillator.type = 'sawtooth';
                    gainNode.gain.setValueAtTime(0, startTime);
                    gainNode.gain.linearRampToValueAtTime(volume * 0.3, startTime + 0.1);
                    gainNode.gain.setValueAtTime(volume * 0.3, startTime + duration - 0.1);
                    gainNode.gain.linearRampToValueAtTime(0, startTime + duration);
                    break;

                case 'brass':
                    oscillator.type = 'sawtooth';
                    gainNode.gain.setValueAtTime(0, startTime);
                    gainNode.gain.linearRampToValueAtTime(volume * 0.4, startTime + 0.05);
                    gainNode.gain.setValueAtTime(volume * 0.35, startTime + duration - 0.05);
                    gainNode.gain.linearRampToValueAtTime(0, startTime + duration);
                    break;

                case 'organ':
                    oscillator.type = 'square';
                    gainNode.gain.setValueAtTime(volume * 0.3, startTime);
                    gainNode.gain.setValueAtTime(volume * 0.3, startTime + duration - 0.05);
                    gainNode.gain.linearRampToValueAtTime(0, startTime + duration);
                    break;

                case 'marimba':
                    oscillator.type = 'sine';
                    gainNode.gain.setValueAtTime(volume * 0.6, startTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + Math.min(duration, 0.5));
                    break;
            }

            oscillator.frequency.setValueAtTime(freq, startTime);

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.start(startTime);
            oscillator.stop(startTime + duration);

            currentNotes.push({ oscillator, gainNode });
        }

        function playMetronome(time, isDownbeat) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(isDownbeat ? 1200 : 800, time);

            gainNode.gain.setValueAtTime(0.3, time);
            gainNode.gain.exponentialRampToValueAtTime(0.01, time + 0.05);

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.start(time);
            oscillator.stop(time + 0.05);
        }

        function getMidiNote(note) {
            const pitchIndex = TREBLE_PITCHES.indexOf(note.pitch);
            let midi = TREBLE_MIDI[pitchIndex];

            if (note.accidental === 'sharp') {
                midi += 1;
            } else if (note.accidental === 'flat') {
                midi -= 1;
            }

            return midi;
        }

        function midiToFreq(midi) {
            return 440 * Math.pow(2, (midi - 69) / 12);
        }

        function saveHistory() {
            history.push({
                notes: JSON.parse(JSON.stringify(notes)),
                dynamics: JSON.parse(JSON.stringify(dynamics))
            });

            if (history.length > 50) {
                history.shift();
            }
        }

        function undo() {
            if (history.length === 0) return;

            const previous = history.pop();
            notes = previous.notes;
            dynamics = previous.dynamics;

            draw();
            saveToStorage();
        }

        function clear() {
            if (confirm('Clear all notes and dynamics?')) {
                saveHistory();
                notes = [];
                dynamics = [];
                draw();
                saveToStorage();
            }
        }

        function exportJSON() {
            const data = {
                tempo: tempo,
                measures: measures,
                instrument: instrument,
                notes: notes,
                dynamics: dynamics
            };

            const json = JSON.stringify(data, null, 2);

            navigator.clipboard.writeText(json).then(() => {
                alert('Score exported to clipboard as JSON!');
            }).catch(() => {
                // Fallback
                const textarea = document.createElement('textarea');
                textarea.value = json;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                alert('Score exported to clipboard as JSON!');
            });
        }

        function saveToStorage() {
            const data = {
                notes: notes,
                dynamics: dynamics,
                tempo: tempo,
                measures: measures,
                instrument: instrument
            };

            localStorage.setItem('livingSheetMusic', JSON.stringify(data));
        }

        function loadFromStorage() {
            const saved = localStorage.getItem('livingSheetMusic');

            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    notes = data.notes || [];
                    dynamics = data.dynamics || [];
                    tempo = data.tempo || 120;
                    measures = data.measures || 4;
                    instrument = data.instrument || 'piano';

                    document.getElementById('tempo').value = tempo;
                    document.getElementById('tempoValue').textContent = tempo;
                    document.getElementById('measures').value = measures;
                    document.getElementById('measuresValue').textContent = measures;
                    document.getElementById('instrument').value = instrument;

                    resizeCanvas();
                } catch (e) {
                    console.error('Failed to load saved data:', e);
                }
            }
        }
    </script>
</body>
</html>