<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Whisper Topography</title>
    <meta name="description" content="Speak and watch your voice sculpt a living 3D terrain - pitch creates mountains, volume carves valleys, rhythm shapes rivers">
    <!-- audio, 3d, generative, voice, terrain, synesthesia, experimental -->
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: linear-gradient(to bottom, #1a1a2e, #16213e);
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            color: #fff;
            overflow: hidden;
        }
        
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        canvas {
            display: block;
        }
        
        #controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            z-index: 100;
            max-width: 280px;
        }
        
        #mic-button {
            width: 100%;
            padding: 15px 30px;
            font-size: 16px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 15px;
        }
        
        #mic-button:hover {
            transform: scale(1.05);
        }
        
        #mic-button.recording {
            background: linear-gradient(135deg, #f5576c 0%, #f093fb 100%);
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(245, 87, 108, 0.5); }
            50% { box-shadow: 0 0 20px 10px rgba(245, 87, 108, 0); }
        }
        
        .meter {
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .meter-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.1s ease;
        }
        
        #pitch-meter .meter-fill { background: linear-gradient(90deg, #4facfe, #00f2fe); }
        #volume-meter .meter-fill { background: linear-gradient(90deg, #43e97b, #38f9d7); }
        
        .meter-label {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            opacity: 0.7;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        #info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            font-size: 12px;
            opacity: 0.6;
            z-index: 100;
        }
        
        #export-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }
        
        .btn {
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255,255,255,0.2);
            color: #fff;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            backdrop-filter: blur(5px);
            transition: all 0.2s ease;
        }
        
        .btn:hover {
            background: rgba(255,255,255,0.1);
        }
        
        #color-scheme {
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255,255,255,0.2);
            color: #fff;
            border-radius: 8px;
            font-size: 12px;
        }
        
        #instructions {
            margin-top: 15px;
            font-size: 11px;
            opacity: 0.6;
            line-height: 1.5;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="terrain"></canvas>
    </div>
    
    <div id="controls">
        <button id="mic-button">Start Listening</button>
        
        <div class="meter-label"><span>Pitch</span><span id="pitch-value">--</span></div>
        <div class="meter" id="pitch-meter"><div class="meter-fill" style="width: 0%"></div></div>
        
        <div class="meter-label"><span>Volume</span><span id="volume-value">--</span></div>
        <div class="meter" id="volume-meter"><div class="meter-fill" style="width: 0%"></div></div>
        
        <div id="instructions">
            Speak or hum to sculpt terrain<br>
            High pitch = mountains<br>
            Low pitch = valleys<br>
            Loud = bold features<br>
            Soft = gentle slopes<br>
            Drag to rotate view
        </div>
    </div>
    
    <div id="export-controls">
        <select id="color-scheme">
            <option value="earth">Earth Tones</option>
            <option value="ocean">Ocean Depths</option>
            <option value="sunset">Sunset</option>
            <option value="arctic">Arctic</option>
            <option value="alien">Alien World</option>
            <option value="infrared">Infrared</option>
        </select>
        <button class="btn" id="clear-btn">Clear Terrain</button>
        <button class="btn" id="export-btn">Export PNG</button>
        <button class="btn" id="save-btn">Save</button>
        <button class="btn" id="load-btn">Load</button>
    </div>
    
    <div id="info">WASD to move camera • Scroll to zoom • Drag to rotate</div>
    
    <input type="file" id="load-file" accept=".json" style="display: none;">
    
    <script>
        const canvas = document.getElementById('terrain');
        const ctx = canvas.getContext('2d');
        
        let width, height;
        const GRID_SIZE = 100;
        let terrain = [];
        let isRecording = false;
        let audioContext, analyser, microphone;
        
        // Camera
        let camera = {
            x: GRID_SIZE / 2,
            y: GRID_SIZE / 2,
            rotation: Math.PI / 4,
            tilt: 0.6,
            zoom: 4,
            height: 50
        };
        
        // Color schemes
        const colorSchemes = {
            earth: [
                { height: -0.5, color: [30, 60, 120] },
                { height: 0, color: [50, 120, 80] },
                { height: 0.3, color: [80, 150, 80] },
                { height: 0.5, color: [140, 130, 100] },
                { height: 0.7, color: [180, 160, 140] },
                { height: 1, color: [255, 255, 255] }
            ],
            ocean: [
                { height: -0.5, color: [10, 20, 60] },
                { height: 0, color: [20, 60, 120] },
                { height: 0.3, color: [40, 100, 160] },
                { height: 0.5, color: [80, 140, 180] },
                { height: 0.7, color: [150, 200, 220] },
                { height: 1, color: [220, 240, 255] }
            ],
            sunset: [
                { height: -0.5, color: [40, 20, 60] },
                { height: 0, color: [120, 40, 80] },
                { height: 0.3, color: [200, 80, 60] },
                { height: 0.5, color: [240, 140, 60] },
                { height: 0.7, color: [255, 200, 100] },
                { height: 1, color: [255, 240, 200] }
            ],
            arctic: [
                { height: -0.5, color: [20, 40, 80] },
                { height: 0, color: [60, 100, 140] },
                { height: 0.3, color: [140, 180, 200] },
                { height: 0.5, color: [200, 220, 240] },
                { height: 0.7, color: [230, 240, 250] },
                { height: 1, color: [255, 255, 255] }
            ],
            alien: [
                { height: -0.5, color: [20, 0, 40] },
                { height: 0, color: [60, 0, 80] },
                { height: 0.3, color: [120, 20, 140] },
                { height: 0.5, color: [180, 60, 180] },
                { height: 0.7, color: [220, 120, 200] },
                { height: 1, color: [255, 200, 255] }
            ],
            infrared: [
                { height: -0.5, color: [0, 0, 60] },
                { height: 0, color: [60, 0, 120] },
                { height: 0.3, color: [160, 0, 160] },
                { height: 0.5, color: [220, 40, 80] },
                { height: 0.7, color: [255, 120, 40] },
                { height: 1, color: [255, 255, 100] }
            ]
        };
        
        let currentScheme = 'earth';
        
        // Writing position
        let writeX = GRID_SIZE / 2;
        let writeY = GRID_SIZE / 2;
        let writeAngle = 0;
        
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }
        resize();
        window.addEventListener('resize', resize);
        
        // Initialize terrain
        function initTerrain() {
            terrain = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                terrain[y] = [];
                for (let x = 0; x < GRID_SIZE; x++) {
                    terrain[y][x] = 0;
                }
            }
            writeX = GRID_SIZE / 2;
            writeY = GRID_SIZE / 2;
        }
        initTerrain();
        
        // Get color for height
        function getColor(h) {
            const scheme = colorSchemes[currentScheme];
            for (let i = 0; i < scheme.length - 1; i++) {
                if (h >= scheme[i].height && h < scheme[i + 1].height) {
                    const t = (h - scheme[i].height) / (scheme[i + 1].height - scheme[i].height);
                    const c1 = scheme[i].color;
                    const c2 = scheme[i + 1].color;
                    return [
                        Math.floor(c1[0] + (c2[0] - c1[0]) * t),
                        Math.floor(c1[1] + (c2[1] - c1[1]) * t),
                        Math.floor(c1[2] + (c2[2] - c1[2]) * t)
                    ];
                }
            }
            return scheme[scheme.length - 1].color;
        }
        
        // 3D projection
        function project(x, y, z) {
            // Translate to camera
            const dx = x - camera.x;
            const dy = y - camera.y;
            
            // Rotate around camera
            const rx = dx * Math.cos(camera.rotation) - dy * Math.sin(camera.rotation);
            const ry = dx * Math.sin(camera.rotation) + dy * Math.cos(camera.rotation);
            const rz = z - camera.height;
            
            // Tilt
            const ty = ry * Math.cos(camera.tilt) - rz * Math.sin(camera.tilt);
            const tz = ry * Math.sin(camera.tilt) + rz * Math.cos(camera.tilt);
            
            // Perspective
            const scale = camera.zoom * 100 / (ty + 50);
            
            if (ty < -40) return null; // Behind camera
            
            return {
                x: width / 2 + rx * scale,
                y: height / 2 - tz * scale,
                depth: ty,
                scale: scale
            };
        }
        
        // Render terrain
        function render() {
            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, width, height);
            
            // Collect all faces with depth
            const faces = [];
            
            for (let y = 0; y < GRID_SIZE - 1; y++) {
                for (let x = 0; x < GRID_SIZE - 1; x++) {
                    const h00 = terrain[y][x];
                    const h10 = terrain[y][x + 1];
                    const h01 = terrain[y + 1][x];
                    const h11 = terrain[y + 1][x + 1];
                    
                    const avgHeight = (h00 + h10 + h01 + h11) / 4;
                    
                    const p00 = project(x, y, h00 * 20);
                    const p10 = project(x + 1, y, h10 * 20);
                    const p01 = project(x, y + 1, h01 * 20);
                    const p11 = project(x + 1, y + 1, h11 * 20);
                    
                    if (p00 && p10 && p01 && p11) {
                        const avgDepth = (p00.depth + p10.depth + p01.depth + p11.depth) / 4;
                        faces.push({
                            points: [p00, p10, p11, p01],
                            depth: avgDepth,
                            height: avgHeight
                        });
                    }
                }
            }
            
            // Sort by depth (back to front)
            faces.sort((a, b) => b.depth - a.depth);
            
            // Draw faces
            faces.forEach(face => {
                const color = getColor(face.height);
                const shade = Math.max(0.3, 1 - face.depth / 100);
                
                ctx.fillStyle = `rgb(${Math.floor(color[0] * shade)}, ${Math.floor(color[1] * shade)}, ${Math.floor(color[2] * shade)})`;
                ctx.strokeStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, 0.3)`;
                ctx.lineWidth = 0.5;
                
                ctx.beginPath();
                ctx.moveTo(face.points[0].x, face.points[0].y);
                for (let i = 1; i < face.points.length; i++) {
                    ctx.lineTo(face.points[i].x, face.points[i].y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            });
            
            // Draw write position indicator
            const writePos = project(writeX, writeY, (terrain[Math.floor(writeY)]?.[Math.floor(writeX)] || 0) * 20 + 5);
            if (writePos && isRecording) {
                ctx.beginPath();
                ctx.arc(writePos.x, writePos.y, 5, 0, Math.PI * 2);
                ctx.fillStyle = '#ff6b6b';
                ctx.fill();
            }
        }
        
        // Audio analysis
        async function startAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);
                
                isRecording = true;
                document.getElementById('mic-button').classList.add('recording');
                document.getElementById('mic-button').textContent = 'Stop Listening';
                
                processAudio();
            } catch (err) {
                alert('Microphone access denied or not available');
            }
        }
        
        function stopAudio() {
            isRecording = false;
            document.getElementById('mic-button').classList.remove('recording');
            document.getElementById('mic-button').textContent = 'Start Listening';
            
            if (audioContext) {
                audioContext.close();
            }
        }
        
        function processAudio() {
            if (!isRecording) return;
            
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            const timeData = new Float32Array(bufferLength);
            
            analyser.getByteFrequencyData(dataArray);
            analyser.getFloatTimeDomainData(timeData);
            
            // Calculate volume
            let sum = 0;
            for (let i = 0; i < bufferLength; i++) {
                sum += dataArray[i];
            }
            const volume = sum / bufferLength / 255;
            
            // Calculate pitch using autocorrelation
            let pitch = detectPitch(timeData, audioContext.sampleRate);
            let normalizedPitch = 0.5;
            
            if (pitch > 0) {
                // Normalize pitch (roughly 80Hz - 800Hz range for voice)
                normalizedPitch = Math.max(0, Math.min(1, (pitch - 80) / 720));
            }
            
            // Update meters
            document.querySelector('#pitch-meter .meter-fill').style.width = (normalizedPitch * 100) + '%';
            document.querySelector('#volume-meter .meter-fill').style.width = (volume * 100) + '%';
            document.getElementById('pitch-value').textContent = pitch > 0 ? Math.round(pitch) + 'Hz' : '--';
            document.getElementById('volume-value').textContent = Math.round(volume * 100) + '%';
            
            // Only sculpt if there's significant audio
            if (volume > 0.05) {
                sculptTerrain(normalizedPitch, volume);
            } else {
                // Move write position when silent
                writeAngle += 0.02;
            }
            
            requestAnimationFrame(processAudio);
        }
        
        function detectPitch(buffer, sampleRate) {
            // Simple autocorrelation pitch detection
            const SIZE = buffer.length;
            const MAX_SAMPLES = Math.floor(SIZE / 2);
            let bestOffset = -1;
            let bestCorrelation = 0;
            let foundGoodCorrelation = false;
            
            const correlations = new Array(MAX_SAMPLES);
            
            for (let offset = 0; offset < MAX_SAMPLES; offset++) {
                let correlation = 0;
                
                for (let i = 0; i < MAX_SAMPLES; i++) {
                    correlation += Math.abs(buffer[i] - buffer[i + offset]);
                }
                
                correlation = 1 - (correlation / MAX_SAMPLES);
                correlations[offset] = correlation;
                
                if (correlation > 0.9 && correlation > bestCorrelation) {
                    bestCorrelation = correlation;
                    bestOffset = offset;
                    foundGoodCorrelation = true;
                } else if (foundGoodCorrelation) {
                    break;
                }
            }
            
            if (bestOffset === -1) return -1;
            
            return sampleRate / bestOffset;
        }
        
        function sculptTerrain(pitch, volume) {
            // Move write position in a meandering path
            writeAngle += (Math.random() - 0.5) * 0.3;
            const speed = 0.2 + volume * 0.3;
            writeX += Math.cos(writeAngle) * speed;
            writeY += Math.sin(writeAngle) * speed;
            
            // Wrap around
            writeX = ((writeX % GRID_SIZE) + GRID_SIZE) % GRID_SIZE;
            writeY = ((writeY % GRID_SIZE) + GRID_SIZE) % GRID_SIZE;
            
            // Height based on pitch (-1 to 1 range)
            const targetHeight = (pitch - 0.5) * 2;
            
            // Radius based on volume
            const radius = 2 + volume * 8;
            
            // Modify terrain
            const xi = Math.floor(writeX);
            const yi = Math.floor(writeY);
            
            for (let dy = -Math.ceil(radius); dy <= Math.ceil(radius); dy++) {
                for (let dx = -Math.ceil(radius); dx <= Math.ceil(radius); dx++) {
                    const tx = (xi + dx + GRID_SIZE) % GRID_SIZE;
                    const ty = (yi + dy + GRID_SIZE) % GRID_SIZE;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < radius) {
                        const influence = (1 - dist / radius) * volume * 0.3;
                        terrain[ty][tx] += (targetHeight - terrain[ty][tx]) * influence;
                        terrain[ty][tx] = Math.max(-1, Math.min(1, terrain[ty][tx]));
                    }
                }
            }
        }
        
        // Mouse controls
        let isDragging = false;
        let lastMouseX, lastMouseY;
        
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;
                
                camera.rotation += dx * 0.005;
                camera.tilt = Math.max(0.2, Math.min(1.2, camera.tilt + dy * 0.005));
                
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
        });
        
        canvas.addEventListener('mouseup', () => isDragging = false);
        canvas.addEventListener('mouseleave', () => isDragging = false);
        
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            camera.zoom = Math.max(1, Math.min(15, camera.zoom - e.deltaY * 0.01));
        });
        
        // Keyboard controls
        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
        });
        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });
        
        function updateCamera() {
            const speed = 0.3;
            if (keys['w']) {
                camera.x += Math.sin(camera.rotation) * speed;
                camera.y += Math.cos(camera.rotation) * speed;
            }
            if (keys['s']) {
                camera.x -= Math.sin(camera.rotation) * speed;
                camera.y -= Math.cos(camera.rotation) * speed;
            }
            if (keys['a']) {
                camera.x -= Math.cos(camera.rotation) * speed;
                camera.y += Math.sin(camera.rotation) * speed;
            }
            if (keys['d']) {
                camera.x += Math.cos(camera.rotation) * speed;
                camera.y -= Math.sin(camera.rotation) * speed;
            }
            if (keys['q']) camera.height += 0.5;
            if (keys['e']) camera.height -= 0.5;
        }
        
        // Touch controls
        let lastTouchX, lastTouchY;
        canvas.addEventListener('touchstart', (e) => {
            const touch = e.touches[0];
            lastTouchX = touch.clientX;
            lastTouchY = touch.clientY;
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const dx = touch.clientX - lastTouchX;
            const dy = touch.clientY - lastTouchY;
            
            camera.rotation += dx * 0.005;
            camera.tilt = Math.max(0.2, Math.min(1.2, camera.tilt + dy * 0.005));
            
            lastTouchX = touch.clientX;
            lastTouchY = touch.clientY;
        });
        
        // UI controls
        document.getElementById('mic-button').addEventListener('click', () => {
            if (isRecording) {
                stopAudio();
            } else {
                startAudio();
            }
        });
        
        document.getElementById('color-scheme').addEventListener('change', (e) => {
            currentScheme = e.target.value;
        });
        
        document.getElementById('clear-btn').addEventListener('click', () => {
            initTerrain();
        });
        
        document.getElementById('export-btn').addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = `whisper-terrain-${Date.now()}.png`;
            link.href = canvas.toDataURL();
            link.click();
        });
        
        document.getElementById('save-btn').addEventListener('click', () => {
            const data = {
                terrain: terrain,
                camera: camera,
                colorScheme: currentScheme
            };
            const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'whisper-terrain.json';
            a.click();
            URL.revokeObjectURL(url);
        });
        
        document.getElementById('load-btn').addEventListener('click', () => {
            document.getElementById('load-file').click();
        });
        
        document.getElementById('load-file').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        terrain = data.terrain;
                        camera = { ...camera, ...data.camera };
                        if (data.colorScheme) {
                            currentScheme = data.colorScheme;
                            document.getElementById('color-scheme').value = currentScheme;
                        }
                    } catch (err) {
                        alert('Invalid file');
                    }
                };
                reader.readAsText(file);
            }
        });
        
        // Animation loop
        function animate() {
            updateCamera();
            render();
            requestAnimationFrame(animate);
        }
        animate();
        
        // Auto-save to localStorage
        setInterval(() => {
            localStorage.setItem('whisperTopography', JSON.stringify({
                terrain: terrain,
                colorScheme: currentScheme
            }));
        }, 10000);
        
        // Load from localStorage
        const saved = localStorage.getItem('whisperTopography');
        if (saved) {
            try {
                const data = JSON.parse(saved);
                if (data.terrain) terrain = data.terrain;
                if (data.colorScheme) {
                    currentScheme = data.colorScheme;
                    document.getElementById('color-scheme').value = currentScheme;
                }
            } catch (e) {}
        }
    </script>
</body>
</html>
