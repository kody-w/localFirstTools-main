<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>RappterZooNation — Visual Music Video</title>
<meta name="rappterzoo:author" content="MolterEngine">
<meta name="rappterzoo:author-type" content="agent">
<meta name="rappterzoo:category" content="audio-music">
<meta name="rappterzoo:tags" content="audio,visual,canvas,animation,podcast,waveform,music-video">
<meta name="rappterzoo:type" content="audio">
<meta name="rappterzoo:complexity" content="advanced">
<meta name="rappterzoo:created" content="2026-02-08">
<meta name="rappterzoo:generation" content="1">
<style>
*{margin:0;padding:0;box-sizing:border-box}
:root{
  --bg:#0a0a14;--surface:#12121f;--surface2:#1a1a2e;--surface3:#242440;
  --text:#e8e8f0;--text2:#9898b0;--text3:#686880;
  --cyan:#00e5ff;--orange:#ff6e40;--purple:#b388ff;--gold:#ffd740;
  --green:#4caf50;--lime:#8bc34a;--yellow:#ffc107;--deeporange:#ff9800;--red:#f44336;
  --radius:10px;
}
html,body{height:100%;background:var(--bg);color:var(--text);font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;overflow:hidden}

.app{display:flex;flex-direction:column;height:100vh;position:relative}

/* Top bar */
.top-bar{display:flex;align-items:center;gap:12px;padding:8px 16px;background:rgba(10,10,20,0.9);position:absolute;top:0;left:0;right:0;z-index:20;transition:opacity 0.3s}
.top-bar.hidden{opacity:0;pointer-events:none}
.logo{font-size:16px;font-weight:800;letter-spacing:-0.5px}
.logo .r{color:var(--cyan)}.logo .z{color:var(--orange)}
.episode-select{background:var(--surface2);border:1px solid var(--surface3);color:var(--text);padding:4px 8px;border-radius:6px;font-size:12px;max-width:260px;cursor:pointer}
.top-spacer{flex:1}
.settings-btn,.fullscreen-btn{background:none;border:1px solid var(--surface3);color:var(--text2);padding:4px 10px;border-radius:6px;cursor:pointer;font-size:12px;transition:border-color 0.2s}
.settings-btn:hover,.fullscreen-btn:hover{border-color:var(--cyan);color:var(--text)}

/* Canvas fills viewport */
canvas#stage{position:absolute;top:0;left:0;width:100%;height:100%;z-index:1}

/* Bottom controls */
.controls{position:absolute;bottom:0;left:0;right:0;z-index:20;padding:12px 16px;background:linear-gradient(transparent,rgba(10,10,20,0.95));transition:opacity 0.3s}
.controls.hidden{opacity:0;pointer-events:none}
.progress-row{display:flex;align-items:center;gap:8px;margin-bottom:8px}
.time-label{font-size:11px;color:var(--text3);min-width:40px;font-variant-numeric:tabular-nums}
.time-label.right{text-align:right}
.progress-track{flex:1;height:4px;background:var(--surface3);border-radius:2px;cursor:pointer;position:relative}
.progress-fill{height:100%;background:var(--cyan);border-radius:2px;width:0;transition:width 0.1s linear}
.controls-row{display:flex;align-items:center;gap:12px}
.play-btn{width:36px;height:36px;border-radius:50%;background:var(--cyan);border:none;cursor:pointer;display:flex;align-items:center;justify-content:center;flex-shrink:0;transition:transform 0.1s}
.play-btn:hover{transform:scale(1.08)}
.play-btn:active{transform:scale(0.95)}
.play-btn svg{fill:#0a0a14;width:16px;height:16px}
.now-playing{flex:1;min-width:0;overflow:hidden}
.now-title{font-size:13px;font-weight:600;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.now-segment{font-size:11px;color:var(--text3);margin-top:1px}
.vol-group{display:flex;align-items:center;gap:6px}
.vol-icon{fill:var(--text3);width:16px;height:16px;cursor:pointer}
.vol-slider{width:60px;appearance:none;height:3px;background:var(--surface3);border-radius:2px;cursor:pointer}
.vol-slider::-webkit-slider-thumb{appearance:none;width:10px;height:10px;background:var(--text2);border-radius:50%;cursor:pointer}

/* Settings panel */
.settings-panel{display:none;position:absolute;top:44px;right:16px;z-index:30;background:var(--surface);border:1px solid var(--surface3);border-radius:var(--radius);padding:16px;min-width:220px}
.settings-panel.visible{display:block}
.settings-panel h4{font-size:12px;color:var(--text3);text-transform:uppercase;letter-spacing:1px;margin-bottom:10px}
.setting-row{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px;font-size:13px}
.setting-row label{color:var(--text2)}
.toggle{width:36px;height:20px;border-radius:10px;background:var(--surface3);border:none;cursor:pointer;position:relative;transition:background 0.2s}
.toggle.on{background:var(--cyan)}
.toggle::after{content:'';position:absolute;top:2px;left:2px;width:16px;height:16px;border-radius:50%;background:var(--text);transition:transform 0.2s}
.toggle.on::after{transform:translateX(16px)}
.intensity-slider{width:80px;appearance:none;height:3px;background:var(--surface3);border-radius:2px}
.intensity-slider::-webkit-slider-thumb{appearance:none;width:10px;height:10px;background:var(--cyan);border-radius:50%;cursor:pointer}

/* Dialogue overlay */
.dialogue-overlay{position:absolute;bottom:80px;left:50%;transform:translateX(-50%);z-index:15;max-width:600px;width:90%;text-align:center;pointer-events:none}
.dialogue-bubble{background:rgba(18,18,31,0.88);border:1px solid var(--surface3);border-radius:12px;padding:12px 20px;backdrop-filter:blur(8px);opacity:0;transform:translateY(10px);transition:opacity 0.3s,transform 0.3s}
.dialogue-bubble.visible{opacity:1;transform:translateY(0)}
.dialogue-host{font-size:11px;font-weight:700;text-transform:uppercase;letter-spacing:1px;margin-bottom:4px}
.dialogue-host.rapptr{color:var(--cyan)}
.dialogue-host.zookeeper{color:var(--orange)}
.dialogue-text{font-size:14px;line-height:1.5;color:var(--text)}

/* App review card overlay */
.review-card{position:absolute;top:80px;right:20px;z-index:15;width:240px;background:rgba(18,18,31,0.92);border:1px solid var(--surface3);border-radius:var(--radius);padding:14px;backdrop-filter:blur(8px);opacity:0;transform:translateX(60px);transition:opacity 0.4s,transform 0.4s cubic-bezier(0.34,1.56,0.64,1)}
.review-card.visible{opacity:1;transform:translateX(0)}
.review-card .rc-title{font-size:14px;font-weight:700;margin-bottom:4px}
.review-card .rc-category{font-size:10px;color:var(--text3);text-transform:uppercase;letter-spacing:1px;margin-bottom:8px}
.review-card .rc-score-row{display:flex;align-items:center;gap:10px;margin-bottom:6px}
.review-card .rc-score{font-size:28px;font-weight:800}
.review-card .rc-grade{font-size:16px;font-weight:800;padding:4px 10px;border-radius:6px}
.grade-S{background:#6200ea33;color:#b388ff}.grade-A{background:#4caf5033;color:#4caf50}
.grade-B{background:#8bc34a33;color:#8bc34a}.grade-C{background:#ffc10733;color:#ffc107}
.grade-D{background:#ff980033;color:#ff9800}.grade-F{background:#f4433633;color:#f44336}
.review-card .rc-desc{font-size:11px;color:var(--text2);line-height:1.4;margin-bottom:6px}
.review-card .rc-tags{display:flex;flex-wrap:wrap;gap:3px}
.review-card .rc-tags span{font-size:9px;background:var(--surface3);color:var(--text3);padding:2px 5px;border-radius:3px}

@media(max-width:600px){
  .vol-group{display:none}
  .review-card{width:180px;right:10px;top:50px}
  .dialogue-overlay{bottom:70px;max-width:90%}
}
</style>
</head>
<body>
<div class="app">
  <canvas id="stage"></canvas>

  <div class="top-bar" id="topBar">
    <div class="logo"><span class="r">RappterZoo</span><span class="z">Nation</span></div>
    <select class="episode-select" id="episodeSelect"><option value="">Loading...</option></select>
    <div class="top-spacer"></div>
    <button class="settings-btn" id="settingsBtn">Settings</button>
    <button class="fullscreen-btn" id="fullscreenBtn">Fullscreen</button>
  </div>

  <div class="settings-panel" id="settingsPanel">
    <h4>Visuals</h4>
    <div class="setting-row"><label>Particles</label><button class="toggle on" id="toggleParticles"></button></div>
    <div class="setting-row"><label>Waveform</label><button class="toggle on" id="toggleWaveform"></button></div>
    <div class="setting-row"><label>Intensity</label><input type="range" class="intensity-slider" id="intensitySlider" min="0.2" max="2" step="0.1" value="1"></div>
  </div>

  <div class="dialogue-overlay" id="dialogueOverlay">
    <div class="dialogue-bubble" id="dialogueBubble">
      <div class="dialogue-host" id="dialogueHost"></div>
      <div class="dialogue-text" id="dialogueText"></div>
    </div>
  </div>

  <div class="review-card" id="reviewCard">
    <div class="rc-title" id="rcTitle"></div>
    <div class="rc-category" id="rcCategory"></div>
    <div class="rc-score-row">
      <div class="rc-score" id="rcScore"></div>
      <div class="rc-grade" id="rcGrade"></div>
    </div>
    <div class="rc-desc" id="rcDesc"></div>
    <div class="rc-tags" id="rcTags"></div>
  </div>

  <div class="controls" id="controls">
    <div class="progress-row">
      <span class="time-label" id="curTime">0:00</span>
      <div class="progress-track" id="progressTrack"><div class="progress-fill" id="progressFill"></div></div>
      <span class="time-label right" id="totTime">0:00</span>
    </div>
    <div class="controls-row">
      <button class="play-btn" id="playBtn"><svg viewBox="0 0 24 24" id="playIcon"><polygon points="6,3 20,12 6,21"/></svg></button>
      <div class="now-playing">
        <div class="now-title" id="nowTitle">Select an episode</div>
        <div class="now-segment" id="nowSegment"></div>
      </div>
      <div class="vol-group">
        <svg class="vol-icon" viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02z"/></svg>
        <input type="range" class="vol-slider" id="volSlider" min="0" max="1" step="0.05" value="0.7">
      </div>
    </div>
  </div>
</div>

<script>
(function(){
'use strict';

// ── Constants ──
const FEED_URLS = ['../broadcasts/feed.json','./feed.json','../../apps/broadcasts/feed.json'];
const GRADE_COLORS = {S:'#b388ff',A:'#4caf50',B:'#8bc34a',C:'#ffc107',D:'#ff9800',F:'#f44336'};
const SEG_COLORS = {'intro':[16,20,60],'review':[10,40,30],'roast':[50,15,15],'transition':[20,15,40],'outro':[10,10,25]};
const PARTICLE_COUNT = 200;
const BLINK_MIN = 2000;
const BLINK_MAX = 5000;

// ── State ──
let feed = null;
let currentEpisode = null;
let audio = new Audio();
let isPlaying = false;
let audioCtx = null;
let analyser = null;
let sourceNode = null;
let frequencyData = null;
let timeDomainData = null;
let canvas, ctx, W, H;
let particles = [];
let animFrame = null;
let lastTime = 0;
let activeSegmentIdx = -1;
let activeDialogueIdx = -1;
let allDialogueLines = [];
let allSegmentRanges = [];
let showUI = true;
let uiTimeout = null;
let rollingAmplitude = 0;
let beatFlash = 0;
let introAlpha = 1;
let outroAlpha = 0;
let roastShake = 0;
let roastBorderPulse = 0;

// Settings
let settings = {particles:true, intensity:1.0, showWaveform:true};
try { Object.assign(settings, JSON.parse(localStorage.getItem('rzn-mv-settings')||'{}')); } catch(e){}

// Avatar state
const avatars = {
  rapptr: {x:0,y:0,scale:1,opacity:0.4,blinkTimer:0,blinkNext:randBlink(),isBlinking:false,blinkFrame:0},
  zookeeper:{x:0,y:0,scale:1,opacity:0.4,blinkTimer:0,blinkNext:randBlink(),isBlinking:false,blinkFrame:0}
};

function randBlink(){ return BLINK_MIN + Math.random()*(BLINK_MAX-BLINK_MIN); }

// ── Init ──
async function init(){
  canvas = document.getElementById('stage');
  ctx = canvas.getContext('2d');
  resize();
  window.addEventListener('resize', resize);

  await loadFeed();
  if(feed) populateEpisodes();

  // Restore last episode
  const lastEp = localStorage.getItem('rzn-mv-episode');
  if(lastEp && feed){
    const ep = feed.episodes.find(e => e.id === lastEp);
    if(ep) selectEpisode(ep);
  }

  initParticles();
  applySettings();
  bindEvents();
  requestAnimationFrame(render);
}

function resize(){
  const dpr = window.devicePixelRatio || 1;
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W * dpr;
  canvas.height = H * dpr;
  ctx.setTransform(dpr,0,0,dpr,0,0);
  // Reposition avatars
  avatars.rapptr.x = W * 0.3;
  avatars.rapptr.y = H * 0.45;
  avatars.zookeeper.x = W * 0.7;
  avatars.zookeeper.y = H * 0.45;
}

// ── Feed ──
async function loadFeed(){
  for(const url of FEED_URLS){
    try{
      const res = await fetch(url);
      if(res.ok){ feed = await res.json(); return; }
    }catch(e){}
  }
}

function populateEpisodes(){
  const sel = document.getElementById('episodeSelect');
  sel.innerHTML = '<option value="">Choose episode...</option>';
  const eps = (feed.episodes||[]).slice().reverse();
  for(const ep of eps){
    const opt = document.createElement('option');
    opt.value = ep.id;
    opt.textContent = `Ep ${ep.number}: ${ep.title}`;
    sel.appendChild(opt);
  }
}

function selectEpisode(ep){
  currentEpisode = ep;
  localStorage.setItem('rzn-mv-episode', ep.id);
  document.getElementById('nowTitle').textContent = ep.title;
  document.getElementById('episodeSelect').value = ep.id;

  // Build sync data
  buildSyncData(ep);

  // Load audio
  let src = ep.audioFile || '';
  if(src.startsWith('apps/broadcasts/')) {
    const loc = window.location.pathname;
    const idx = loc.indexOf('/apps/');
    if(idx !== -1) src = loc.substring(0, idx) + '/' + src;
    else src = '/' + src;
  } else if(!src.startsWith('http') && !src.startsWith('/') && !src.startsWith('.')) {
    src = '../broadcasts/audio/' + src.split('/').pop();
  }
  audio.src = src;
  audio.volume = parseFloat(document.getElementById('volSlider').value);

  // Restore position
  const savedPos = localStorage.getItem('rzn-mv-position');
  if(savedPos){
    try{
      const pos = JSON.parse(savedPos);
      if(pos.id === ep.id && pos.time) audio.currentTime = pos.time;
    }catch(e){}
  }

  // Reset visuals
  introAlpha = 1;
  outroAlpha = 0;
  activeSegmentIdx = -1;
  activeDialogueIdx = -1;
}

function buildSyncData(ep){
  allDialogueLines = [];
  allSegmentRanges = [];
  const segs = ep.segments || [];
  let totalLines = 0;

  // Count all dialogue lines + solo text segments
  for(const seg of segs){
    const count = seg.dialogue ? seg.dialogue.length : (seg.text ? 1 : 0);
    totalLines += count;
  }

  // Build ranges: each segment gets proportional share based on its line count
  let offset = 0;
  for(let i = 0; i < segs.length; i++){
    const seg = segs[i];
    const count = seg.dialogue ? seg.dialogue.length : (seg.text ? 1 : 0);
    const weight = totalLines > 0 ? count / totalLines : 1 / segs.length;
    const start = offset;
    const end = offset + weight;
    allSegmentRanges.push({idx:i, start, end, type:seg.type, seg});

    // Flatten dialogue lines
    if(seg.dialogue){
      for(const d of seg.dialogue){
        allDialogueLines.push({host:d.host, text:d.text, segIdx:i, pctStart:start, pctEnd:end, type:seg.type, app:seg.app});
      }
    } else if(seg.text){
      allDialogueLines.push({host:seg.host||'', text:seg.text, segIdx:i, pctStart:start, pctEnd:end, type:seg.type, app:seg.app});
    }
    offset = end;
  }
}

// ── Audio Pipeline ──
function initAudio(){
  if(analyser) return;
  try{
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    sourceNode = audioCtx.createMediaElementSource(audio);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;
    analyser.smoothingTimeConstant = 0.8;
    sourceNode.connect(analyser);
    analyser.connect(audioCtx.destination);
    frequencyData = new Uint8Array(analyser.frequencyBinCount);
    timeDomainData = new Uint8Array(analyser.fftSize);
  }catch(e){}
}

function getAmplitude(){
  if(!frequencyData) return 0;
  let sum = 0;
  for(let i = 0; i < frequencyData.length; i++) sum += frequencyData[i];
  return sum / frequencyData.length / 255;
}

function getBass(){
  if(!frequencyData) return 0;
  let sum = 0;
  const bassEnd = Math.floor(frequencyData.length * 0.1);
  for(let i = 0; i < bassEnd; i++) sum += frequencyData[i];
  return sum / bassEnd / 255;
}

// ── Particles ──
function initParticles(){
  particles = [];
  for(let i = 0; i < PARTICLE_COUNT; i++){
    particles.push(makeParticle());
  }
}

function makeParticle(){
  return {
    x: Math.random() * (W||800),
    y: Math.random() * (H||600),
    vx: (Math.random()-0.5) * 0.5,
    vy: (Math.random()-0.5) * 0.5,
    size: 1 + Math.random() * 2,
    baseSize: 1 + Math.random() * 2,
    alpha: 0.2 + Math.random() * 0.4,
    hue: Math.random() * 360
  };
}

function updateParticles(dt, bass, amplitude){
  if(!settings.particles) return;
  const intensity = settings.intensity;
  for(const p of particles){
    const boost = 1 + bass * 4 * intensity;
    p.x += p.vx * boost * dt * 60;
    p.y += p.vy * boost * dt * 60;
    p.size = p.baseSize * (1 + amplitude * 3 * intensity);

    // Wrap around
    if(p.x < 0) p.x = W;
    if(p.x > W) p.x = 0;
    if(p.y < 0) p.y = H;
    if(p.y > H) p.y = 0;
  }
}

function drawParticles(){
  if(!settings.particles) return;
  for(const p of particles){
    ctx.globalAlpha = p.alpha;
    ctx.fillStyle = `hsl(${p.hue},70%,70%)`;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

// ── Rendering ──
function render(timestamp){
  animFrame = requestAnimationFrame(render);
  const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
  lastTime = timestamp;

  // Update audio data
  if(analyser && isPlaying){
    analyser.getByteFrequencyData(frequencyData);
    analyser.getByteTimeDomainData(timeDomainData);
  }

  const amplitude = getAmplitude();
  const bass = getBass();

  // Beat detection
  rollingAmplitude = rollingAmplitude * 0.95 + amplitude * 0.05;
  if(amplitude > rollingAmplitude * 1.5 && amplitude > 0.15){
    beatFlash = 1;
  }
  beatFlash *= 0.92;

  // Sync engine
  syncToAudio();

  // Get current segment type
  const segType = activeSegmentIdx >= 0 && allSegmentRanges[activeSegmentIdx]
    ? allSegmentRanges[activeSegmentIdx].type : 'intro';

  // Roast effects
  if(segType === 'roast'){
    roastShake = Math.sin(timestamp*0.01) * 2 * settings.intensity;
    roastBorderPulse = 0.5 + Math.sin(timestamp*0.005) * 0.5;
  } else {
    roastShake *= 0.9;
    roastBorderPulse *= 0.9;
  }

  // Outro fade
  if(segType === 'outro'){
    outroAlpha = Math.min(outroAlpha + dt * 0.3, 0.6);
  } else {
    outroAlpha = Math.max(outroAlpha - dt * 0.5, 0);
  }

  // Intro fade
  if(segType === 'intro' && introAlpha > 0 && isPlaying){
    introAlpha = Math.max(introAlpha - dt * 0.4, 0);
  }

  // Clear and transform for shake
  ctx.clearRect(0, 0, W, H);
  ctx.save();
  if(roastShake > 0.1) ctx.translate(roastShake*(Math.random()-0.5), roastShake*(Math.random()-0.5));

  // Layer 1: Background gradient
  drawBackground(segType, amplitude);

  // Layer 2: Particles
  updateParticles(dt, bass, amplitude);
  drawParticles();

  // Layer 3: Roast fire particles
  if(segType === 'roast') drawFireParticles(timestamp);

  // Layer 4: Circular waveform
  if(settings.showWaveform) drawCircularWaveform(amplitude);

  // Layer 5: Host avatars
  updateAvatars(dt, amplitude, segType);
  drawAvatar('rapptr', avatars.rapptr);
  drawAvatar('zookeeper', avatars.zookeeper);

  // Layer 6: Spectrum bars
  drawSpectrumBars();

  // Layer 7: Roast border
  if(roastBorderPulse > 0.05) drawRoastBorder();

  // Layer 8: Intro overlay
  if(introAlpha > 0.01) drawIntroOverlay();

  // Layer 9: Outro overlay
  if(outroAlpha > 0.01) drawOutroOverlay();

  // Layer 10: Beat flash
  if(beatFlash > 0.05){
    ctx.globalAlpha = beatFlash * 0.08;
    ctx.fillStyle = '#fff';
    ctx.fillRect(0,0,W,H);
    ctx.globalAlpha = 1;
  }

  ctx.restore();
}

function drawBackground(segType, amplitude){
  const base = SEG_COLORS[segType] || SEG_COLORS.intro;
  const r = base[0] + amplitude * 15 * settings.intensity;
  const g = base[1] + amplitude * 10 * settings.intensity;
  const b = base[2] + amplitude * 20 * settings.intensity;

  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, `rgb(${r},${g},${b})`);
  grad.addColorStop(1, `rgb(${r*0.4},${g*0.4},${b*0.4})`);
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);
}

function drawCircularWaveform(amplitude){
  if(!timeDomainData || !isPlaying) return;
  const cx = W/2, cy = H*0.45;
  const baseR = Math.min(W,H) * 0.18;
  const r = baseR + amplitude * 20 * settings.intensity;
  const step = Math.max(1, Math.floor(timeDomainData.length / 180));

  ctx.beginPath();
  ctx.strokeStyle = `rgba(180,160,255,${0.3 + amplitude * 0.3})`;
  ctx.lineWidth = 1.5;

  for(let i = 0; i < 360; i += 2){
    const dataIdx = Math.floor((i/360) * timeDomainData.length);
    const val = (timeDomainData[dataIdx] - 128) / 128;
    const rad = (i * Math.PI) / 180;
    const dist = r + val * 30 * settings.intensity;
    const x = cx + Math.cos(rad) * dist;
    const y = cy + Math.sin(rad) * dist;
    if(i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.closePath();
  ctx.stroke();

  // Inner glow ring
  ctx.beginPath();
  ctx.strokeStyle = `rgba(0,229,255,${0.1 + amplitude * 0.15})`;
  ctx.lineWidth = 3;
  ctx.arc(cx, cy, r * 0.85, 0, Math.PI * 2);
  ctx.stroke();
}

function drawSpectrumBars(){
  if(!frequencyData || !isPlaying) return;
  const barCount = 64;
  const step = Math.floor(frequencyData.length / barCount);
  const barW = W / barCount;
  const maxH = H * 0.12;

  // Determine active host for color
  const activeHost = activeDialogueIdx >= 0 && allDialogueLines[activeDialogueIdx]
    ? allDialogueLines[activeDialogueIdx].host.toLowerCase() : '';
  const isRapptr = activeHost.includes('rapptr');
  const baseHue = isRapptr ? 187 : 16;

  for(let i = 0; i < barCount; i++){
    const val = frequencyData[i * step] / 255;
    const h = val * maxH * settings.intensity;
    const hue = baseHue + (i / barCount) * 30;
    ctx.fillStyle = `hsla(${hue},80%,55%,${0.4 + val * 0.4})`;
    ctx.fillRect(i * barW, H - h, barW - 1, h);
  }
}

function drawFireParticles(t){
  ctx.globalAlpha = 0.6 * settings.intensity;
  for(let i = 0; i < 30; i++){
    const x = (Math.sin(t*0.001 + i*0.7) * 0.5 + 0.5) * W;
    const y = H - Math.abs(Math.sin(t*0.002 + i*1.3)) * H * 0.4;
    const size = 2 + Math.random() * 4;
    const hue = 0 + Math.random() * 40;
    ctx.fillStyle = `hsl(${hue},100%,55%)`;
    ctx.beginPath();
    ctx.arc(x, y, size, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

function drawRoastBorder(){
  ctx.save();
  ctx.globalAlpha = roastBorderPulse * 0.4;
  ctx.strokeStyle = '#ff5252';
  ctx.lineWidth = 4;
  ctx.strokeRect(2, 2, W-4, H-4);
  ctx.restore();
}

function drawIntroOverlay(){
  ctx.globalAlpha = introAlpha;
  ctx.fillStyle = '#000';
  ctx.fillRect(0,0,W,H);

  if(currentEpisode){
    ctx.globalAlpha = Math.max(0, introAlpha - 0.3) / 0.7;
    ctx.fillStyle = '#fff';
    ctx.font = `bold ${Math.min(W*0.05, 36)}px -apple-system, sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    const scale = 1 + introAlpha * 0.3;
    ctx.save();
    ctx.translate(W/2, H/2);
    ctx.scale(scale, scale);
    ctx.fillText(currentEpisode.title, 0, 0);
    ctx.restore();

    ctx.font = `${Math.min(W*0.025, 14)}px -apple-system, sans-serif`;
    ctx.globalAlpha = Math.max(0, introAlpha - 0.5) / 0.5;
    ctx.fillStyle = 'var(--text3)';
    ctx.fillText(`Episode ${currentEpisode.number}`, W/2, H/2 + 40);
  }
  ctx.globalAlpha = 1;
  ctx.textAlign = 'start';
}

function drawOutroOverlay(){
  ctx.globalAlpha = outroAlpha;
  ctx.fillStyle = '#000';
  ctx.fillRect(0,0,W,H);

  if(outroAlpha > 0.3 && currentEpisode){
    ctx.globalAlpha = (outroAlpha - 0.3) / 0.3;
    ctx.fillStyle = '#fff';
    ctx.font = `bold ${Math.min(W*0.035, 24)}px -apple-system, sans-serif`;
    ctx.textAlign = 'center';
    ctx.fillText('Thanks for watching', W/2, H*0.4);
    ctx.font = `${Math.min(W*0.02, 14)}px -apple-system, sans-serif`;
    ctx.fillStyle = '#888';
    const reviews = (currentEpisode.segments||[]).filter(s=>s.type==='review').length;
    ctx.fillText(`${reviews} apps reviewed this episode`, W/2, H*0.4 + 30);
    ctx.textAlign = 'start';
  }
  ctx.globalAlpha = 1;
}

// ── Avatars ──
function updateAvatars(dt, amplitude, segType){
  const activeHost = activeDialogueIdx >= 0 && allDialogueLines[activeDialogueIdx]
    ? allDialogueLines[activeDialogueIdx].host.toLowerCase() : '';

  for(const [name, av] of Object.entries(avatars)){
    const isActive = activeHost.includes(name);
    const targetOpacity = isActive ? 1.0 : 0.4;
    const targetScale = isActive ? 1.0 + amplitude * 0.15 * settings.intensity : 1.0;
    av.opacity += (targetOpacity - av.opacity) * 0.1;
    av.scale += (targetScale - av.scale) * 0.2;

    // Blinking
    av.blinkTimer += dt * 1000;
    if(av.isBlinking){
      av.blinkFrame++;
      if(av.blinkFrame > 6){ av.isBlinking = false; av.blinkTimer = 0; av.blinkNext = randBlink(); }
    } else if(av.blinkTimer >= av.blinkNext){
      av.isBlinking = true;
      av.blinkFrame = 0;
    }
  }
}

function drawAvatar(name, av){
  ctx.save();
  ctx.translate(av.x, av.y);
  ctx.scale(av.scale, av.scale);
  ctx.globalAlpha = av.opacity;

  if(name === 'rapptr'){
    drawRapptr(av);
  } else {
    drawZooKeeper(av);
  }

  ctx.restore();
}

function drawRapptr(av){
  const s = Math.min(W, H) * 0.08;

  // Body — triangle (fox-like)
  ctx.fillStyle = '#00e5ff';
  ctx.beginPath();
  ctx.moveTo(0, -s);
  ctx.lineTo(-s*0.7, s*0.6);
  ctx.lineTo(s*0.7, s*0.6);
  ctx.closePath();
  ctx.fill();

  // Ears — small triangles
  ctx.beginPath();
  ctx.moveTo(-s*0.5, -s*0.7);
  ctx.lineTo(-s*0.7, -s*1.3);
  ctx.lineTo(-s*0.15, -s*0.85);
  ctx.closePath();
  ctx.fill();

  ctx.beginPath();
  ctx.moveTo(s*0.5, -s*0.7);
  ctx.lineTo(s*0.7, -s*1.3);
  ctx.lineTo(s*0.15, -s*0.85);
  ctx.closePath();
  ctx.fill();

  // Face circle
  ctx.fillStyle = '#00b8d4';
  ctx.beginPath();
  ctx.arc(0, -s*0.15, s*0.35, 0, Math.PI*2);
  ctx.fill();

  // Eyes
  const eyeH = av.isBlinking ? 1 : s*0.08;
  ctx.fillStyle = '#0a0a14';
  ctx.fillRect(-s*0.15, -s*0.25, s*0.08, eyeH);
  ctx.fillRect(s*0.07, -s*0.25, s*0.08, eyeH);

  // Nose
  ctx.fillStyle = '#ff6e40';
  ctx.beginPath();
  ctx.arc(0, -s*0.08, s*0.04, 0, Math.PI*2);
  ctx.fill();

  // Name label
  ctx.fillStyle = '#00e5ff';
  ctx.font = `bold ${Math.max(10, s*0.25)}px sans-serif`;
  ctx.textAlign = 'center';
  ctx.fillText('RAPPTR', 0, s*0.95);
  ctx.textAlign = 'start';
}

function drawZooKeeper(av){
  const s = Math.min(W, H) * 0.08;

  // Body — rounded rectangle (bear-like)
  ctx.fillStyle = '#ff6e40';
  roundRect(ctx, -s*0.6, -s*0.7, s*1.2, s*1.4, s*0.15);
  ctx.fill();

  // Ears — circles
  ctx.beginPath();
  ctx.arc(-s*0.45, -s*0.8, s*0.2, 0, Math.PI*2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(s*0.45, -s*0.8, s*0.2, 0, Math.PI*2);
  ctx.fill();

  // Inner ears
  ctx.fillStyle = '#bf360c';
  ctx.beginPath();
  ctx.arc(-s*0.45, -s*0.8, s*0.1, 0, Math.PI*2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(s*0.45, -s*0.8, s*0.1, 0, Math.PI*2);
  ctx.fill();

  // Face
  ctx.fillStyle = '#e65100';
  ctx.beginPath();
  ctx.arc(0, -s*0.1, s*0.38, 0, Math.PI*2);
  ctx.fill();

  // Eyes
  const eyeH = av.isBlinking ? 1 : s*0.1;
  ctx.fillStyle = '#0a0a14';
  ctx.beginPath();
  ctx.arc(-s*0.13, -s*0.2, s*0.06, 0, Math.PI*2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(s*0.13, -s*0.2, s*0.06, 0, Math.PI*2);
  ctx.fill();

  // Nose
  ctx.fillStyle = '#3e2723';
  ctx.beginPath();
  ctx.arc(0, -s*0.05, s*0.06, 0, Math.PI*2);
  ctx.fill();

  // Muzzle
  ctx.fillStyle = '#ffab91';
  ctx.beginPath();
  ctx.arc(0, s*0.05, s*0.2, 0, Math.PI);
  ctx.fill();

  // Name label
  ctx.fillStyle = '#ff6e40';
  ctx.font = `bold ${Math.max(10, s*0.25)}px sans-serif`;
  ctx.textAlign = 'center';
  ctx.fillText('ZOOKEEPER', 0, s*0.95);
  ctx.textAlign = 'start';
}

function roundRect(c, x, y, w, h, r){
  c.beginPath();
  c.moveTo(x+r, y);
  c.lineTo(x+w-r, y);
  c.quadraticCurveTo(x+w, y, x+w, y+r);
  c.lineTo(x+w, y+h-r);
  c.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
  c.lineTo(x+r, y+h);
  c.quadraticCurveTo(x, y+h, x, y+h-r);
  c.lineTo(x, y+r);
  c.quadraticCurveTo(x, y, x+r, y);
  c.closePath();
}

// ── Sync Engine ──
function syncToAudio(){
  if(!currentEpisode || !audio.duration) return;
  const pct = audio.currentTime / audio.duration;

  // Find active segment
  let newSegIdx = -1;
  for(let i = 0; i < allSegmentRanges.length; i++){
    if(pct >= allSegmentRanges[i].start && pct < allSegmentRanges[i].end){
      newSegIdx = i;
      break;
    }
  }
  if(newSegIdx < 0 && allSegmentRanges.length > 0) newSegIdx = allSegmentRanges.length - 1;

  if(newSegIdx !== activeSegmentIdx){
    activeSegmentIdx = newSegIdx;
    onSegmentChange();
  }

  // Find active dialogue line
  if(allDialogueLines.length > 0){
    const lineIdx = Math.min(Math.floor(pct * allDialogueLines.length), allDialogueLines.length - 1);
    if(lineIdx !== activeDialogueIdx){
      activeDialogueIdx = lineIdx;
      onDialogueChange();
    }
  }

  // Update progress
  document.getElementById('progressFill').style.width = (pct * 100) + '%';
  document.getElementById('curTime').textContent = formatTime(audio.currentTime);
  if(audio.duration) document.getElementById('totTime').textContent = formatTime(audio.duration);

  // Save position
  localStorage.setItem('rzn-mv-position', JSON.stringify({id:currentEpisode.id, time:audio.currentTime}));
}

function onSegmentChange(){
  if(activeSegmentIdx < 0) return;
  const range = allSegmentRanges[activeSegmentIdx];
  if(!range) return;

  // Update segment label
  const labels = {intro:'Intro',review:'App Review',roast:'The Roast Pit',transition:'...',outro:'Outro'};
  document.getElementById('nowSegment').textContent = labels[range.type] || range.type;

  // Show/hide review card
  const card = document.getElementById('reviewCard');
  if(range.type === 'review' && range.seg.app){
    showReviewCard(range.seg.app);
  } else {
    card.classList.remove('visible');
  }
}

function showReviewCard(app){
  const card = document.getElementById('reviewCard');
  document.getElementById('rcTitle').textContent = app.title || '';
  document.getElementById('rcCategory').textContent = (app.category||'').replace(/_/g,' ');
  document.getElementById('rcScore').textContent = app.score || '?';

  const grade = app.grade || 'C';
  const gradeEl = document.getElementById('rcGrade');
  gradeEl.textContent = grade;
  gradeEl.className = 'rc-grade grade-' + grade;

  document.getElementById('rcDesc').textContent = app.description || '';
  document.getElementById('rcTags').innerHTML = (app.tags||[]).map(t => `<span>${esc(t)}</span>`).join('');

  card.classList.add('visible');
}

function onDialogueChange(){
  if(activeDialogueIdx < 0 || !allDialogueLines[activeDialogueIdx]) return;
  const line = allDialogueLines[activeDialogueIdx];
  const bubble = document.getElementById('dialogueBubble');
  const hostEl = document.getElementById('dialogueHost');
  const textEl = document.getElementById('dialogueText');

  const hostClass = line.host.toLowerCase().replace(/[^a-z]/g,'');
  hostEl.className = 'dialogue-host ' + hostClass;
  hostEl.textContent = line.host;

  // Typewriter effect — show text progressively
  textEl.textContent = line.text;
  bubble.classList.add('visible');
}

// ── Playback Controls ──
function togglePlay(){
  if(!audio.src || !currentEpisode) return;
  if(isPlaying){
    audio.pause();
  } else {
    initAudio();
    audio.play().catch(()=>{});
  }
  isPlaying = !isPlaying;
  updatePlayIcon();
}

function updatePlayIcon(){
  const icon = document.getElementById('playIcon');
  if(isPlaying){
    icon.innerHTML = '<rect x="5" y="3" width="4" height="18"/><rect x="15" y="3" width="4" height="18"/>';
  } else {
    icon.innerHTML = '<polygon points="6,3 20,12 6,21"/>';
  }
}

audio.addEventListener('ended', () => {
  isPlaying = false;
  updatePlayIcon();
  outroAlpha = 0.6;
});

audio.addEventListener('error', () => {
  document.getElementById('nowSegment').textContent = 'Audio unavailable — visual mode only';
});

// ── Event Bindings ──
function bindEvents(){
  document.getElementById('playBtn').addEventListener('click', togglePlay);

  document.getElementById('episodeSelect').addEventListener('change', (e) => {
    if(!e.target.value || !feed) return;
    const ep = feed.episodes.find(ep => ep.id === e.target.value);
    if(ep){
      if(isPlaying){ audio.pause(); isPlaying = false; updatePlayIcon(); }
      selectEpisode(ep);
    }
  });

  document.getElementById('progressTrack').addEventListener('click', (e) => {
    if(!audio.duration) return;
    const rect = e.currentTarget.getBoundingClientRect();
    const pct = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
    audio.currentTime = pct * audio.duration;
  });

  document.getElementById('volSlider').addEventListener('input', (e) => {
    audio.volume = parseFloat(e.target.value);
  });

  document.getElementById('fullscreenBtn').addEventListener('click', toggleFullscreen);

  document.getElementById('settingsBtn').addEventListener('click', () => {
    document.getElementById('settingsPanel').classList.toggle('visible');
  });

  // Settings toggles
  document.getElementById('toggleParticles').addEventListener('click', (e) => {
    settings.particles = !settings.particles;
    e.target.classList.toggle('on', settings.particles);
    saveSettings();
  });

  document.getElementById('toggleWaveform').addEventListener('click', (e) => {
    settings.showWaveform = !settings.showWaveform;
    e.target.classList.toggle('on', settings.showWaveform);
    saveSettings();
  });

  document.getElementById('intensitySlider').addEventListener('input', (e) => {
    settings.intensity = parseFloat(e.target.value);
    saveSettings();
  });

  // Keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    if(e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
    if(e.key === ' '){ e.preventDefault(); togglePlay(); }
    if(e.key === 'f' || e.key === 'F'){ e.preventDefault(); toggleFullscreen(); }
    if(e.key === 'Escape'){
      document.getElementById('settingsPanel').classList.remove('visible');
    }
    if(e.key === 'ArrowRight' && audio.duration) audio.currentTime = Math.min(audio.duration, audio.currentTime + 10);
    if(e.key === 'ArrowLeft' && audio.duration) audio.currentTime = Math.max(0, audio.currentTime - 10);
  });

  // Auto-hide UI
  document.addEventListener('mousemove', resetUITimer);
  document.addEventListener('touchstart', resetUITimer);

  // Close settings on outside click
  document.addEventListener('click', (e) => {
    if(!e.target.closest('.settings-panel') && !e.target.closest('.settings-btn')){
      document.getElementById('settingsPanel').classList.remove('visible');
    }
  });
}

function resetUITimer(){
  showUI = true;
  document.getElementById('topBar').classList.remove('hidden');
  document.getElementById('controls').classList.remove('hidden');
  clearTimeout(uiTimeout);
  uiTimeout = setTimeout(() => {
    if(isPlaying){
      document.getElementById('topBar').classList.add('hidden');
      document.getElementById('controls').classList.add('hidden');
    }
  }, 3000);
}

function toggleFullscreen(){
  if(!document.fullscreenElement){
    document.documentElement.requestFullscreen().catch(()=>{});
  } else {
    document.exitFullscreen().catch(()=>{});
  }
}

function applySettings(){
  document.getElementById('toggleParticles').classList.toggle('on', settings.particles);
  document.getElementById('toggleWaveform').classList.toggle('on', settings.showWaveform);
  document.getElementById('intensitySlider').value = settings.intensity;
}

function saveSettings(){
  localStorage.setItem('rzn-mv-settings', JSON.stringify(settings));
}

// ── Helpers ──
function esc(s){ return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;'); }
function formatTime(s){ const m=Math.floor(s/60); return m+':'+String(Math.floor(s%60)).padStart(2,'0'); }

// ── Start ──
init();

})();
</script>
</body>
</html>
