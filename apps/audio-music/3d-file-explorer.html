<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="3D File System Explorer - Fly through your hard drive in an immersive 3D space using WebGL">
    <!-- 3d, webgl, canvas, interactive, visualization -->
    <title>3D File System Explorer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0a1a;
            --bg-secondary: #1a1a2e;
            --bg-tertiary: #16213e;
            --text-primary: #e0e0e0;
            --text-secondary: #a0a0a0;
            --accent: #00d4ff;
            --accent-glow: rgba(0, 212, 255, 0.3);
            --folder-color: #ffa500;
            --image-color: #4a9eff;
            --code-color: #50fa7b;
            --doc-color: #f1fa8c;
            --video-color: #ff79c6;
            --audio-color: #bd93f9;
            --archive-color: #ff5555;
            --other-color: #8be9fd;
        }

        .light-theme {
            --bg-primary: #f0f4f8;
            --bg-secondary: #e0e8f0;
            --bg-tertiary: #d0d8e0;
            --text-primary: #1a1a2e;
            --text-secondary: #4a4a6e;
            --accent: #0088cc;
            --accent-glow: rgba(0, 136, 204, 0.3);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Overlay */
        .ui-overlay {
            position: fixed;
            z-index: 100;
            pointer-events: none;
        }

        .ui-overlay > * {
            pointer-events: auto;
        }

        /* Top Bar */
        .top-bar {
            top: 0;
            left: 0;
            right: 0;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(180deg, var(--bg-secondary) 0%, transparent 100%);
        }

        .breadcrumb {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
            max-width: 60%;
        }

        .breadcrumb-item {
            background: var(--bg-tertiary);
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
            border: 1px solid transparent;
        }

        .breadcrumb-item:hover {
            border-color: var(--accent);
            box-shadow: 0 0 10px var(--accent-glow);
        }

        .breadcrumb-separator {
            color: var(--text-secondary);
        }

        .top-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        /* Buttons */
        .btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--accent);
            color: var(--text-primary);
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn:hover {
            background: var(--accent);
            color: var(--bg-primary);
            box-shadow: 0 0 20px var(--accent-glow);
        }

        .btn:focus-visible {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
            box-shadow: 0 0 20px var(--accent-glow);
        }

        .btn-primary {
            background: var(--accent);
            color: var(--bg-primary);
        }

        .btn-icon {
            padding: 8px;
            min-width: 36px;
            justify-content: center;
        }

        /* Search Box */
        .search-container {
            position: relative;
        }

        .search-input {
            background: var(--bg-tertiary);
            border: 1px solid var(--text-secondary);
            color: var(--text-primary);
            padding: 8px 12px 8px 36px;
            border-radius: 6px;
            width: 250px;
            font-size: 13px;
            transition: all 0.2s;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 10px var(--accent-glow);
        }

        .search-icon {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-secondary);
        }

        /* Side Panels */
        .side-panel {
            position: fixed;
            top: 70px;
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 15px;
            max-height: calc(100vh - 150px);
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            border: 1px solid var(--bg-tertiary);
        }

        .side-panel::-webkit-scrollbar {
            width: 6px;
        }

        .side-panel::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
        }

        .side-panel::-webkit-scrollbar-thumb {
            background: var(--accent);
            border-radius: 3px;
        }

        /* Left Panel - Stats & Legend */
        .left-panel {
            left: 20px;
            width: 220px;
        }

        .panel-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stats-grid {
            display: grid;
            gap: 10px;
            margin-bottom: 20px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 10px;
            background: var(--bg-tertiary);
            border-radius: 4px;
        }

        .stat-label {
            color: var(--text-secondary);
            font-size: 12px;
        }

        .stat-value {
            font-weight: 600;
            font-size: 13px;
        }

        .legend-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 12px;
            cursor: pointer;
            padding: 6px 8px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .legend-item:hover {
            background: var(--bg-tertiary);
        }

        .legend-item.filtered {
            opacity: 0.4;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 4px;
            box-shadow: 0 0 8px currentColor;
        }

        /* Right Panel - File Details */
        .right-panel {
            right: 20px;
            width: 280px;
        }

        .file-details {
            display: none;
        }

        .file-details.visible {
            display: block;
        }

        .file-icon-large {
            width: 60px;
            height: 60px;
            border-radius: 12px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            box-shadow: 0 0 20px var(--accent-glow);
        }

        .file-name {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 5px;
            word-break: break-all;
        }

        .file-path {
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 15px;
            word-break: break-all;
        }

        .detail-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid var(--bg-tertiary);
            font-size: 13px;
        }

        .detail-label {
            color: var(--text-secondary);
        }

        /* Mini-map */
        .minimap-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--bg-tertiary);
            overflow: hidden;
            z-index: 100;
        }

        .minimap-canvas {
            width: 100%;
            height: 100%;
        }

        .minimap-label {
            position: absolute;
            top: 5px;
            left: 8px;
            font-size: 10px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Controls Help */
        .controls-help {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 12px 15px;
            font-size: 11px;
            border: 1px solid var(--bg-tertiary);
            z-index: 100;
        }

        .control-row {
            display: flex;
            gap: 15px;
            margin-bottom: 5px;
        }

        .control-row:last-child {
            margin-bottom: 0;
        }

        .key {
            background: var(--bg-tertiary);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            min-width: 24px;
            text-align: center;
            display: inline-block;
        }

        /* Welcome Screen */
        .welcome-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            text-align: center;
            padding: 20px;
        }

        .welcome-screen.hidden {
            display: none;
        }

        .welcome-title {
            font-size: 48px;
            font-weight: 700;
            margin-bottom: 10px;
            background: linear-gradient(135deg, var(--accent), #ff79c6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .welcome-subtitle {
            font-size: 18px;
            color: var(--text-secondary);
            margin-bottom: 40px;
        }

        .welcome-btn {
            font-size: 18px;
            padding: 15px 40px;
            margin-bottom: 30px;
        }

        .welcome-features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            max-width: 800px;
            margin-top: 20px;
        }

        .feature-card {
            background: var(--bg-secondary);
            padding: 20px;
            border-radius: 8px;
            text-align: left;
        }

        .feature-icon {
            font-size: 24px;
            margin-bottom: 10px;
        }

        .feature-title {
            font-weight: 600;
            margin-bottom: 5px;
        }

        .feature-desc {
            font-size: 13px;
            color: var(--text-secondary);
        }

        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(10, 10, 26, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .loading-overlay.visible {
            display: flex;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 3px solid var(--bg-tertiary);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 20px;
            font-size: 16px;
            color: var(--text-secondary);
        }

        .loading-progress {
            margin-top: 10px;
            font-size: 14px;
            color: var(--accent);
        }

        /* Crosshair */
        .crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 50;
            opacity: 0.5;
        }

        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: var(--accent);
        }

        .crosshair::before {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }

        .crosshair::after {
            width: 100%;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }

        /* Tooltip */
        .tooltip {
            position: fixed;
            background: var(--bg-secondary);
            border: 1px solid var(--accent);
            padding: 10px 14px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            z-index: 200;
            max-width: 300px;
            display: none;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
        }

        .tooltip.visible {
            display: block;
        }

        .tooltip-name {
            font-weight: 600;
            margin-bottom: 4px;
        }

        .tooltip-size {
            color: var(--text-secondary);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .left-panel,
            .right-panel {
                display: none;
            }

            .minimap-container {
                width: 120px;
                height: 90px;
            }

            .controls-help {
                display: none;
            }

            .search-input {
                width: 150px;
            }

            .welcome-title {
                font-size: 32px;
            }

            .welcome-features {
                grid-template-columns: 1fr;
            }
        }

        /* Data controls */
        .data-controls {
            display: flex;
            gap: 10px;
        }

        /* Notification */
        .notification {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-secondary);
            border: 1px solid var(--accent);
            padding: 12px 24px;
            border-radius: 8px;
            z-index: 300;
            display: none;
            animation: slideUp 0.3s ease;
        }

        .notification.visible {
            display: block;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translate(-50%, 20px);
            }
            to {
                opacity: 1;
                transform: translate(-50%, 0);
            }
        }
    </style>
</head>
<body>
    <!-- Welcome Screen -->
    <div class="welcome-screen" id="welcomeScreen">
        <h1 class="welcome-title">3D File Explorer</h1>
        <p class="welcome-subtitle">Fly through your file system in immersive 3D</p>
        <button class="btn btn-primary welcome-btn" id="openFolderBtn">
            <span>Open Folder</span>
        </button>
        <p style="color: var(--text-secondary); font-size: 13px; margin-bottom: 20px;">
            Or drag and drop a folder onto this window
        </p>
        <div class="welcome-features">
            <div class="feature-card">
                <div class="feature-icon">&#128193;</div>
                <div class="feature-title">Visual Navigation</div>
                <div class="feature-desc">Files appear as 3D objects sized by file size, colored by type</div>
            </div>
            <div class="feature-card">
                <div class="feature-icon">&#127918;</div>
                <div class="feature-title">FPS Controls</div>
                <div class="feature-desc">WASD to move, mouse to look, space/shift for up/down</div>
            </div>
            <div class="feature-card">
                <div class="feature-icon">&#128269;</div>
                <div class="feature-title">Search & Filter</div>
                <div class="feature-desc">Find files instantly with real-time search highlighting</div>
            </div>
            <div class="feature-card">
                <div class="feature-icon">&#128190;</div>
                <div class="feature-title">Export Structure</div>
                <div class="feature-desc">Save directory structure as JSON for analysis</div>
            </div>
        </div>
        <div style="margin-top: 30px;">
            <button class="btn" id="loadSampleBtn">Load Sample Data</button>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
        <div class="loading-text">Scanning directory...</div>
        <div class="loading-progress" id="loadingProgress">0 files found</div>
    </div>

    <!-- Canvas Container -->
    <div id="canvas-container">
        <canvas id="glCanvas" role="application" aria-label="3D file system visualization - use WASD to move, mouse to look around"></canvas>
    </div>

    <!-- Crosshair -->
    <div class="crosshair" id="crosshair"></div>

    <!-- Tooltip -->
    <div class="tooltip" id="tooltip">
        <div class="tooltip-name" id="tooltipName"></div>
        <div class="tooltip-size" id="tooltipSize"></div>
    </div>

    <!-- Top Bar -->
    <div class="ui-overlay top-bar" id="topBar" style="display: none;">
        <div class="breadcrumb" id="breadcrumb"></div>
        <div class="top-controls">
            <div class="search-container">
                <span class="search-icon">&#128269;</span>
                <input type="text" class="search-input" id="searchInput" placeholder="Search files..." aria-label="Search files in current directory">
            </div>
            <button class="btn btn-icon" id="themeToggle" title="Toggle theme" aria-label="Toggle between dark and light theme">&#9728;</button>
            <button class="btn" id="overviewBtn" title="Overview mode">Overview</button>
            <div class="data-controls">
                <button class="btn" id="exportBtn">Export JSON</button>
                <button class="btn" id="newFolderBtn">New Folder</button>
            </div>
        </div>
    </div>

    <!-- Left Panel -->
    <div class="side-panel left-panel ui-overlay" id="leftPanel" style="display: none;">
        <div class="panel-title">Statistics</div>
        <div class="stats-grid" id="statsGrid">
            <div class="stat-item">
                <span class="stat-label">Total Files</span>
                <span class="stat-value" id="statFiles">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Total Folders</span>
                <span class="stat-value" id="statFolders">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Total Size</span>
                <span class="stat-value" id="statSize">0 B</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Depth</span>
                <span class="stat-value" id="statDepth">0</span>
            </div>
        </div>
        <div class="panel-title">File Types</div>
        <div class="legend-list" id="legendList"></div>
    </div>

    <!-- Right Panel -->
    <div class="side-panel right-panel ui-overlay" id="rightPanel" style="display: none;">
        <div class="panel-title">File Details</div>
        <div class="file-details" id="fileDetails">
            <div class="file-icon-large" id="fileIconLarge"></div>
            <div class="file-name" id="fileName"></div>
            <div class="file-path" id="filePath"></div>
            <div class="detail-row">
                <span class="detail-label">Size</span>
                <span id="detailSize">-</span>
            </div>
            <div class="detail-row">
                <span class="detail-label">Type</span>
                <span id="detailType">-</span>
            </div>
            <div class="detail-row">
                <span class="detail-label">Modified</span>
                <span id="detailModified">-</span>
            </div>
        </div>
        <div id="noSelection" style="color: var(--text-secondary); font-size: 13px;">
            Click on a file to see details
        </div>
    </div>

    <!-- Mini-map -->
    <div class="minimap-container" id="minimapContainer" style="display: none;">
        <span class="minimap-label">Overview</span>
        <canvas class="minimap-canvas" id="minimapCanvas" role="img" aria-label="Overview minimap showing current position in file system"></canvas>
    </div>

    <!-- Controls Help -->
    <div class="controls-help ui-overlay" id="controlsHelp" style="display: none;">
        <div class="control-row">
            <span><span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> Move</span>
            <span><span class="key">Space</span> Up</span>
        </div>
        <div class="control-row">
            <span><span class="key">Shift</span> Down</span>
            <span><span class="key">Click</span> Lock mouse</span>
        </div>
        <div class="control-row">
            <span><span class="key">Esc</span> Unlock</span>
            <span><span class="key">E</span> Select file</span>
        </div>
    </div>

    <!-- Notification -->
    <div class="notification" id="notification"></div>

    <!-- Hidden file input -->
    <input type="file" id="importFile" accept=".json" style="display: none;">

    <script>
        // ==================== Application State ====================
        const APP_NAME = '3d-file-explorer';
        let appData = JSON.parse(localStorage.getItem(APP_NAME) || '{"recentPaths": [], "theme": "dark", "settings": {}}');

        let fileSystem = null;
        let fileNodes = [];
        let folderNodes = [];
        let currentPath = [];
        let selectedFile = null;
        let isPointerLocked = false;
        let isOverviewMode = false;

        // Camera state
        const camera = {
            x: 0, y: 5, z: 20,
            rotX: 0, rotY: 0,
            speed: 0.3,
            sensitivity: 0.002
        };

        // Movement state
        const keys = {
            w: false, a: false, s: false, d: false,
            space: false, shift: false
        };

        // File type definitions
        const fileTypes = {
            image: {
                extensions: ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'svg', 'webp', 'ico', 'tiff'],
                color: [0.29, 0.62, 1.0],
                label: 'Images',
                icon: '&#128247;'
            },
            code: {
                extensions: ['js', 'ts', 'py', 'java', 'cpp', 'c', 'h', 'cs', 'go', 'rs', 'php', 'rb', 'swift', 'kt', 'html', 'css', 'scss', 'less', 'jsx', 'tsx', 'vue', 'svelte'],
                color: [0.31, 0.98, 0.48],
                label: 'Code',
                icon: '&#128187;'
            },
            document: {
                extensions: ['doc', 'docx', 'pdf', 'txt', 'rtf', 'odt', 'xls', 'xlsx', 'ppt', 'pptx', 'md', 'json', 'xml', 'yaml', 'yml', 'csv'],
                color: [0.95, 0.98, 0.55],
                label: 'Documents',
                icon: '&#128196;'
            },
            video: {
                extensions: ['mp4', 'avi', 'mov', 'mkv', 'wmv', 'flv', 'webm', 'm4v'],
                color: [1.0, 0.47, 0.78],
                label: 'Video',
                icon: '&#127909;'
            },
            audio: {
                extensions: ['mp3', 'wav', 'flac', 'aac', 'ogg', 'm4a', 'wma'],
                color: [0.74, 0.58, 0.98],
                label: 'Audio',
                icon: '&#127925;'
            },
            archive: {
                extensions: ['zip', 'rar', '7z', 'tar', 'gz', 'bz2', 'xz'],
                color: [1.0, 0.33, 0.33],
                label: 'Archives',
                icon: '&#128230;'
            },
            folder: {
                extensions: [],
                color: [1.0, 0.65, 0.0],
                label: 'Folders',
                icon: '&#128193;'
            },
            other: {
                extensions: [],
                color: [0.55, 0.91, 0.99],
                label: 'Other',
                icon: '&#128196;'
            }
        };

        let typeFilters = {};
        Object.keys(fileTypes).forEach(t => typeFilters[t] = true);

        // WebGL context and programs
        let gl, canvas;
        let shaderProgram;
        let cubeBuffers, sphereBuffers, lineBuffers;
        let projectionMatrix, viewMatrix, modelMatrix;

        // ==================== Utility Functions ====================

        function saveData() {
            localStorage.setItem(APP_NAME, JSON.stringify(appData));
        }

        function showNotification(message, duration = 3000) {
            const notif = document.getElementById('notification');
            notif.textContent = message;
            notif.classList.add('visible');
            setTimeout(() => notif.classList.remove('visible'), duration);
        }

        function formatSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function formatDate(date) {
            if (!date) return '-';
            return new Date(date).toLocaleDateString('en-US', {
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        function getFileType(filename, isDirectory) {
            if (isDirectory) return 'folder';
            const ext = filename.split('.').pop().toLowerCase();
            for (const [type, config] of Object.entries(fileTypes)) {
                if (config.extensions.includes(ext)) return type;
            }
            return 'other';
        }

        function getTypeColor(type) {
            return fileTypes[type]?.color || fileTypes.other.color;
        }

        function rgbToHex(rgb) {
            return '#' + rgb.map(c => Math.round(c * 255).toString(16).padStart(2, '0')).join('');
        }

        // ==================== Matrix Math ====================

        function createMatrix() {
            return new Float32Array([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ]);
        }

        function perspectiveMatrix(fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2);
            const nf = 1 / (near - far);
            return new Float32Array([
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (far + near) * nf, -1,
                0, 0, 2 * far * near * nf, 0
            ]);
        }

        function lookAtMatrix(eye, center, up) {
            const zAxis = normalize([eye[0] - center[0], eye[1] - center[1], eye[2] - center[2]]);
            const xAxis = normalize(cross(up, zAxis));
            const yAxis = cross(zAxis, xAxis);

            return new Float32Array([
                xAxis[0], yAxis[0], zAxis[0], 0,
                xAxis[1], yAxis[1], zAxis[1], 0,
                xAxis[2], yAxis[2], zAxis[2], 0,
                -dot(xAxis, eye), -dot(yAxis, eye), -dot(zAxis, eye), 1
            ]);
        }

        function translateMatrix(m, v) {
            const result = new Float32Array(m);
            result[12] = m[0] * v[0] + m[4] * v[1] + m[8] * v[2] + m[12];
            result[13] = m[1] * v[0] + m[5] * v[1] + m[9] * v[2] + m[13];
            result[14] = m[2] * v[0] + m[6] * v[1] + m[10] * v[2] + m[14];
            result[15] = m[3] * v[0] + m[7] * v[1] + m[11] * v[2] + m[15];
            return result;
        }

        function scaleMatrix(m, v) {
            const result = new Float32Array(m);
            result[0] *= v[0]; result[1] *= v[0]; result[2] *= v[0]; result[3] *= v[0];
            result[4] *= v[1]; result[5] *= v[1]; result[6] *= v[1]; result[7] *= v[1];
            result[8] *= v[2]; result[9] *= v[2]; result[10] *= v[2]; result[11] *= v[2];
            return result;
        }

        function rotateYMatrix(m, angle) {
            const c = Math.cos(angle);
            const s = Math.sin(angle);
            const result = new Float32Array(m);

            const m0 = m[0], m1 = m[1], m2 = m[2], m3 = m[3];
            const m8 = m[8], m9 = m[9], m10 = m[10], m11 = m[11];

            result[0] = m0 * c + m8 * s;
            result[1] = m1 * c + m9 * s;
            result[2] = m2 * c + m10 * s;
            result[3] = m3 * c + m11 * s;
            result[8] = m8 * c - m0 * s;
            result[9] = m9 * c - m1 * s;
            result[10] = m10 * c - m2 * s;
            result[11] = m11 * c - m3 * s;

            return result;
        }

        function normalize(v) {
            const len = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
            return len > 0 ? [v[0] / len, v[1] / len, v[2] / len] : [0, 0, 0];
        }

        function cross(a, b) {
            return [
                a[1] * b[2] - a[2] * b[1],
                a[2] * b[0] - a[0] * b[2],
                a[0] * b[1] - a[1] * b[0]
            ];
        }

        function dot(a, b) {
            return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
        }

        function multiplyMatrices(a, b) {
            const result = new Float32Array(16);
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    result[i * 4 + j] =
                        a[j] * b[i * 4] +
                        a[j + 4] * b[i * 4 + 1] +
                        a[j + 8] * b[i * 4 + 2] +
                        a[j + 12] * b[i * 4 + 3];
                }
            }
            return result;
        }

        // ==================== WebGL Setup ====================

        function initWebGL() {
            canvas = document.getElementById('glCanvas');
            gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

            if (!gl) {
                alert('WebGL not supported in this browser');
                return false;
            }

            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Create shaders
            const vsSource = `
                attribute vec4 aPosition;
                attribute vec3 aNormal;

                uniform mat4 uProjection;
                uniform mat4 uView;
                uniform mat4 uModel;

                varying vec3 vNormal;
                varying vec3 vPosition;

                void main() {
                    vec4 worldPos = uModel * aPosition;
                    gl_Position = uProjection * uView * worldPos;
                    vNormal = mat3(uModel) * aNormal;
                    vPosition = worldPos.xyz;
                }
            `;

            const fsSource = `
                precision mediump float;

                uniform vec3 uColor;
                uniform float uHighlight;
                uniform float uSelected;
                uniform vec3 uCameraPos;

                varying vec3 vNormal;
                varying vec3 vPosition;

                void main() {
                    vec3 normal = normalize(vNormal);
                    vec3 lightDir = normalize(vec3(0.5, 1.0, 0.3));
                    float diff = max(dot(normal, lightDir), 0.0) * 0.6 + 0.4;

                    vec3 viewDir = normalize(uCameraPos - vPosition);
                    vec3 reflectDir = reflect(-lightDir, normal);
                    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0) * 0.3;

                    vec3 color = uColor * diff + vec3(spec);

                    // Highlight effect
                    if (uHighlight > 0.5) {
                        color = mix(color, vec3(1.0, 1.0, 0.5), 0.4 + sin(uHighlight * 6.28) * 0.2);
                    }

                    // Selection effect
                    if (uSelected > 0.5) {
                        float rim = 1.0 - max(dot(viewDir, normal), 0.0);
                        color += vec3(0.0, 0.8, 1.0) * pow(rim, 2.0) * 0.8;
                    }

                    gl_FragColor = vec4(color, 1.0);
                }
            `;

            shaderProgram = createShaderProgram(vsSource, fsSource);

            if (!shaderProgram) return false;

            // Get attribute and uniform locations
            shaderProgram.aPosition = gl.getAttribLocation(shaderProgram, 'aPosition');
            shaderProgram.aNormal = gl.getAttribLocation(shaderProgram, 'aNormal');
            shaderProgram.uProjection = gl.getUniformLocation(shaderProgram, 'uProjection');
            shaderProgram.uView = gl.getUniformLocation(shaderProgram, 'uView');
            shaderProgram.uModel = gl.getUniformLocation(shaderProgram, 'uModel');
            shaderProgram.uColor = gl.getUniformLocation(shaderProgram, 'uColor');
            shaderProgram.uHighlight = gl.getUniformLocation(shaderProgram, 'uHighlight');
            shaderProgram.uSelected = gl.getUniformLocation(shaderProgram, 'uSelected');
            shaderProgram.uCameraPos = gl.getUniformLocation(shaderProgram, 'uCameraPos');

            // Create geometry buffers
            cubeBuffers = createCubeBuffers();
            sphereBuffers = createSphereBuffers(16, 16);

            // Enable depth testing
            gl.enable(gl.DEPTH_TEST);
            gl.enable(gl.CULL_FACE);
            gl.cullFace(gl.BACK);

            return true;
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
            projectionMatrix = perspectiveMatrix(Math.PI / 4, canvas.width / canvas.height, 0.1, 1000);
        }

        function createShaderProgram(vsSource, fsSource) {
            const vs = compileShader(gl.VERTEX_SHADER, vsSource);
            const fs = compileShader(gl.FRAGMENT_SHADER, fsSource);

            if (!vs || !fs) return null;

            const program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Shader program link error:', gl.getProgramInfoLog(program));
                return null;
            }

            return program;
        }

        function compileShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }

        function createCubeBuffers() {
            const positions = new Float32Array([
                // Front
                -1, -1,  1,   1, -1,  1,   1,  1,  1,  -1,  1,  1,
                // Back
                 1, -1, -1,  -1, -1, -1,  -1,  1, -1,   1,  1, -1,
                // Top
                -1,  1,  1,   1,  1,  1,   1,  1, -1,  -1,  1, -1,
                // Bottom
                -1, -1, -1,   1, -1, -1,   1, -1,  1,  -1, -1,  1,
                // Right
                 1, -1,  1,   1, -1, -1,   1,  1, -1,   1,  1,  1,
                // Left
                -1, -1, -1,  -1, -1,  1,  -1,  1,  1,  -1,  1, -1
            ]);

            const normals = new Float32Array([
                0, 0, 1,  0, 0, 1,  0, 0, 1,  0, 0, 1,
                0, 0,-1,  0, 0,-1,  0, 0,-1,  0, 0,-1,
                0, 1, 0,  0, 1, 0,  0, 1, 0,  0, 1, 0,
                0,-1, 0,  0,-1, 0,  0,-1, 0,  0,-1, 0,
                1, 0, 0,  1, 0, 0,  1, 0, 0,  1, 0, 0,
               -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0
            ]);

            const indices = new Uint16Array([
                0,  1,  2,   0,  2,  3,
                4,  5,  6,   4,  6,  7,
                8,  9, 10,   8, 10, 11,
               12, 13, 14,  12, 14, 15,
               16, 17, 18,  16, 18, 19,
               20, 21, 22,  20, 22, 23
            ]);

            const posBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

            const normBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, normBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);

            const indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

            return { posBuffer, normBuffer, indexBuffer, count: indices.length };
        }

        function createSphereBuffers(latBands, longBands) {
            const positions = [];
            const normals = [];
            const indices = [];

            for (let lat = 0; lat <= latBands; lat++) {
                const theta = lat * Math.PI / latBands;
                const sinTheta = Math.sin(theta);
                const cosTheta = Math.cos(theta);

                for (let lon = 0; lon <= longBands; lon++) {
                    const phi = lon * 2 * Math.PI / longBands;
                    const x = Math.cos(phi) * sinTheta;
                    const y = cosTheta;
                    const z = Math.sin(phi) * sinTheta;

                    positions.push(x, y, z);
                    normals.push(x, y, z);
                }
            }

            for (let lat = 0; lat < latBands; lat++) {
                for (let lon = 0; lon < longBands; lon++) {
                    const first = lat * (longBands + 1) + lon;
                    const second = first + longBands + 1;

                    indices.push(first, second, first + 1);
                    indices.push(second, second + 1, first + 1);
                }
            }

            const posBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

            const normBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, normBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);

            const indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

            return { posBuffer, normBuffer, indexBuffer, count: indices.length };
        }

        // ==================== File System Handling ====================

        async function openFolder() {
            try {
                const dirHandle = await window.showDirectoryPicker();
                await scanDirectory(dirHandle);
            } catch (err) {
                if (err.name !== 'AbortError') {
                    console.error('Error opening folder:', err);
                    showNotification('Could not open folder: ' + err.message);
                }
            }
        }

        async function scanDirectory(dirHandle, path = [], depth = 0, maxDepth = 8) {
            const loadingOverlay = document.getElementById('loadingOverlay');
            const loadingProgress = document.getElementById('loadingProgress');

            if (depth === 0) {
                loadingOverlay.classList.add('visible');
                fileSystem = {
                    name: dirHandle.name,
                    type: 'folder',
                    handle: dirHandle,
                    children: [],
                    path: [dirHandle.name],
                    depth: 0
                };
                currentPath = [dirHandle.name];
            }

            if (depth >= maxDepth) return;

            const currentFolder = depth === 0 ? fileSystem : getNodeAtPath(path);
            if (!currentFolder) return;

            try {
                for await (const entry of dirHandle.values()) {
                    const nodePath = [...path, entry.name];

                    if (entry.kind === 'directory') {
                        const folderNode = {
                            name: entry.name,
                            type: 'folder',
                            handle: entry,
                            children: [],
                            path: nodePath,
                            depth: depth + 1
                        };
                        currentFolder.children.push(folderNode);

                        // Recursively scan subdirectories
                        await scanDirectory(entry, nodePath, depth + 1, maxDepth);
                    } else {
                        try {
                            const file = await entry.getFile();
                            const fileNode = {
                                name: entry.name,
                                type: getFileType(entry.name, false),
                                size: file.size,
                                lastModified: file.lastModified,
                                path: nodePath,
                                depth: depth + 1
                            };
                            currentFolder.children.push(fileNode);
                        } catch (e) {
                            // Skip files we can't access
                        }
                    }

                    // Update progress
                    const stats = calculateStats(fileSystem);
                    loadingProgress.textContent = `${stats.files} files, ${stats.folders} folders found`;
                }
            } catch (e) {
                console.warn('Could not access directory:', path.join('/'), e);
            }

            if (depth === 0) {
                loadingOverlay.classList.remove('visible');
                document.getElementById('welcomeScreen').classList.add('hidden');
                showUI();
                buildScene();
                updateStats();
                updateBreadcrumb();
                updateLegend();
                showNotification('Directory loaded successfully');
            }
        }

        function getNodeAtPath(path) {
            if (!fileSystem) return null;
            let node = fileSystem;
            for (let i = 1; i < path.length; i++) {
                const child = node.children?.find(c => c.name === path[i]);
                if (!child) return null;
                node = child;
            }
            return node;
        }

        function calculateStats(node, stats = { files: 0, folders: 0, totalSize: 0, maxDepth: 0 }) {
            if (!node) return stats;

            if (node.type === 'folder') {
                stats.folders++;
                stats.maxDepth = Math.max(stats.maxDepth, node.depth || 0);
                if (node.children) {
                    node.children.forEach(child => calculateStats(child, stats));
                }
            } else {
                stats.files++;
                stats.totalSize += node.size || 0;
            }

            return stats;
        }

        // ==================== Scene Building ====================

        function buildScene() {
            fileNodes = [];
            folderNodes = [];

            if (!fileSystem) return;

            const currentNode = getNodeAtPath(currentPath) || fileSystem;
            if (!currentNode.children) return;

            // Calculate layout
            const items = currentNode.children.filter(c =>
                c.type === 'folder' || typeFilters[c.type]
            );

            // Find size range for scaling
            let maxSize = 0;
            items.forEach(item => {
                if (item.type !== 'folder') {
                    maxSize = Math.max(maxSize, item.size || 0);
                }
            });
            maxSize = Math.max(maxSize, 1);

            // Layout items in a grid with some randomness
            const gridSize = Math.ceil(Math.sqrt(items.length));
            const spacing = 6;
            const offset = (gridSize * spacing) / 2;

            items.forEach((item, index) => {
                const gridX = index % gridSize;
                const gridZ = Math.floor(index / gridSize);

                const x = gridX * spacing - offset + (Math.random() - 0.5) * 2;
                const z = gridZ * spacing - offset + (Math.random() - 0.5) * 2;

                if (item.type === 'folder') {
                    // Folders are cubes
                    const subStats = calculateStats(item);
                    const size = 1.5 + Math.min(subStats.files / 50, 2);

                    folderNodes.push({
                        data: item,
                        x: x,
                        y: size / 2,
                        z: z,
                        size: size,
                        rotation: Math.random() * Math.PI * 2
                    });
                } else {
                    // Files are spheres
                    const sizeRatio = Math.log10((item.size || 1) + 1) / Math.log10(maxSize + 1);
                    const size = 0.3 + sizeRatio * 1.5;

                    fileNodes.push({
                        data: item,
                        x: x,
                        y: size + 0.1,
                        z: z,
                        size: size
                    });
                }
            });

            // Reset camera position
            camera.x = 0;
            camera.y = 5;
            camera.z = offset + 10;
            camera.rotX = -0.3;
            camera.rotY = 0;
        }

        // ==================== Rendering ====================

        let animationTime = 0;
        let searchQuery = '';
        let hoveredNode = null;

        function render() {
            animationTime += 0.016;

            // Clear
            const bgColor = appData.theme === 'light' ? [0.94, 0.96, 0.97] : [0.04, 0.04, 0.1];
            gl.clearColor(...bgColor, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // Update view matrix
            const lookX = camera.x + Math.sin(camera.rotY) * Math.cos(camera.rotX);
            const lookY = camera.y + Math.sin(camera.rotX);
            const lookZ = camera.z - Math.cos(camera.rotY) * Math.cos(camera.rotX);

            viewMatrix = lookAtMatrix(
                [camera.x, camera.y, camera.z],
                [lookX, lookY, lookZ],
                [0, 1, 0]
            );

            gl.useProgram(shaderProgram);
            gl.uniformMatrix4fv(shaderProgram.uProjection, false, projectionMatrix);
            gl.uniformMatrix4fv(shaderProgram.uView, false, viewMatrix);
            gl.uniform3fv(shaderProgram.uCameraPos, [camera.x, camera.y, camera.z]);

            // Draw ground grid
            drawGroundGrid();

            // Draw folders
            folderNodes.forEach(node => {
                const isHighlighted = searchQuery && node.data.name.toLowerCase().includes(searchQuery.toLowerCase());
                const isSelected = selectedFile === node.data;
                const isHovered = hoveredNode === node;

                let model = createMatrix();
                model = translateMatrix(model, [node.x, node.y + Math.sin(animationTime + node.x) * 0.1, node.z]);
                model = rotateYMatrix(model, node.rotation + animationTime * 0.2);
                model = scaleMatrix(model, [node.size * 0.5, node.size * 0.5, node.size * 0.5]);

                const color = getTypeColor('folder');
                drawCube(model, color, isHighlighted ? animationTime : 0, isSelected || isHovered ? 1 : 0);
            });

            // Draw files
            fileNodes.forEach(node => {
                const isHighlighted = searchQuery && node.data.name.toLowerCase().includes(searchQuery.toLowerCase());
                const isSelected = selectedFile === node.data;
                const isHovered = hoveredNode === node;

                let model = createMatrix();
                model = translateMatrix(model, [node.x, node.y + Math.sin(animationTime * 2 + node.x * 0.5) * 0.05, node.z]);
                model = scaleMatrix(model, [node.size, node.size, node.size]);

                const color = getTypeColor(node.data.type);
                drawSphere(model, color, isHighlighted ? animationTime : 0, isSelected || isHovered ? 1 : 0);
            });

            // Update minimap
            updateMinimap();

            requestAnimationFrame(render);
        }

        function drawGroundGrid() {
            // Simple ground plane representation using a large flat cube
            let model = createMatrix();
            model = translateMatrix(model, [0, -0.1, 0]);
            model = scaleMatrix(model, [100, 0.05, 100]);

            const gridColor = appData.theme === 'light' ? [0.8, 0.85, 0.9] : [0.1, 0.1, 0.15];
            drawCube(model, gridColor, 0, 0);
        }

        function drawCube(modelMatrix, color, highlight, selected) {
            gl.uniformMatrix4fv(shaderProgram.uModel, false, modelMatrix);
            gl.uniform3fv(shaderProgram.uColor, color);
            gl.uniform1f(shaderProgram.uHighlight, highlight);
            gl.uniform1f(shaderProgram.uSelected, selected);

            gl.bindBuffer(gl.ARRAY_BUFFER, cubeBuffers.posBuffer);
            gl.enableVertexAttribArray(shaderProgram.aPosition);
            gl.vertexAttribPointer(shaderProgram.aPosition, 3, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, cubeBuffers.normBuffer);
            gl.enableVertexAttribArray(shaderProgram.aNormal);
            gl.vertexAttribPointer(shaderProgram.aNormal, 3, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeBuffers.indexBuffer);
            gl.drawElements(gl.TRIANGLES, cubeBuffers.count, gl.UNSIGNED_SHORT, 0);
        }

        function drawSphere(modelMatrix, color, highlight, selected) {
            gl.uniformMatrix4fv(shaderProgram.uModel, false, modelMatrix);
            gl.uniform3fv(shaderProgram.uColor, color);
            gl.uniform1f(shaderProgram.uHighlight, highlight);
            gl.uniform1f(shaderProgram.uSelected, selected);

            gl.bindBuffer(gl.ARRAY_BUFFER, sphereBuffers.posBuffer);
            gl.enableVertexAttribArray(shaderProgram.aPosition);
            gl.vertexAttribPointer(shaderProgram.aPosition, 3, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, sphereBuffers.normBuffer);
            gl.enableVertexAttribArray(shaderProgram.aNormal);
            gl.vertexAttribPointer(shaderProgram.aNormal, 3, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereBuffers.indexBuffer);
            gl.drawElements(gl.TRIANGLES, sphereBuffers.count, gl.UNSIGNED_SHORT, 0);
        }

        // ==================== Minimap ====================

        function updateMinimap() {
            const minimapCanvas = document.getElementById('minimapCanvas');
            const ctx = minimapCanvas.getContext('2d');

            if (minimapCanvas.width !== minimapCanvas.offsetWidth) {
                minimapCanvas.width = minimapCanvas.offsetWidth;
                minimapCanvas.height = minimapCanvas.offsetHeight;
            }

            const w = minimapCanvas.width;
            const h = minimapCanvas.height;

            // Clear
            ctx.fillStyle = appData.theme === 'light' ? '#e0e8f0' : '#1a1a2e';
            ctx.fillRect(0, 0, w, h);

            // Calculate bounds
            let minX = 0, maxX = 0, minZ = 0, maxZ = 0;
            [...fileNodes, ...folderNodes].forEach(node => {
                minX = Math.min(minX, node.x);
                maxX = Math.max(maxX, node.x);
                minZ = Math.min(minZ, node.z);
                maxZ = Math.max(maxZ, node.z);
            });

            const rangeX = maxX - minX || 1;
            const rangeZ = maxZ - minZ || 1;
            const scale = Math.min((w - 20) / rangeX, (h - 30) / rangeZ);
            const offsetX = (w - rangeX * scale) / 2 - minX * scale;
            const offsetZ = (h - rangeZ * scale) / 2 - minZ * scale + 10;

            // Draw folders
            folderNodes.forEach(node => {
                const x = node.x * scale + offsetX;
                const y = node.z * scale + offsetZ;
                ctx.fillStyle = rgbToHex(getTypeColor('folder'));
                ctx.fillRect(x - 3, y - 3, 6, 6);
            });

            // Draw files
            fileNodes.forEach(node => {
                const x = node.x * scale + offsetX;
                const y = node.z * scale + offsetZ;
                ctx.fillStyle = rgbToHex(getTypeColor(node.data.type));
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw camera position
            const camX = camera.x * scale + offsetX;
            const camY = camera.z * scale + offsetZ;
            ctx.fillStyle = '#00d4ff';
            ctx.beginPath();
            ctx.arc(camX, camY, 4, 0, Math.PI * 2);
            ctx.fill();

            // Draw camera direction
            const dirLength = 15;
            const dirX = camX + Math.sin(camera.rotY) * dirLength;
            const dirY = camY - Math.cos(camera.rotY) * dirLength;
            ctx.strokeStyle = '#00d4ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(camX, camY);
            ctx.lineTo(dirX, dirY);
            ctx.stroke();
        }

        // ==================== UI Updates ====================

        function showUI() {
            document.getElementById('topBar').style.display = 'flex';
            document.getElementById('leftPanel').style.display = 'block';
            document.getElementById('rightPanel').style.display = 'block';
            document.getElementById('minimapContainer').style.display = 'block';
            document.getElementById('controlsHelp').style.display = 'block';
            document.getElementById('crosshair').style.display = 'block';
        }

        function updateStats() {
            if (!fileSystem) return;

            const currentNode = getNodeAtPath(currentPath) || fileSystem;
            const stats = calculateStats(currentNode);

            document.getElementById('statFiles').textContent = stats.files.toLocaleString();
            document.getElementById('statFolders').textContent = stats.folders.toLocaleString();
            document.getElementById('statSize').textContent = formatSize(stats.totalSize);
            document.getElementById('statDepth').textContent = stats.maxDepth;
        }

        function updateBreadcrumb() {
            const container = document.getElementById('breadcrumb');
            container.innerHTML = '';

            currentPath.forEach((name, index) => {
                if (index > 0) {
                    const sep = document.createElement('span');
                    sep.className = 'breadcrumb-separator';
                    sep.textContent = '/';
                    container.appendChild(sep);
                }

                const item = document.createElement('span');
                item.className = 'breadcrumb-item';
                item.textContent = name;
                item.addEventListener('click', () => navigateToPath(currentPath.slice(0, index + 1)));
                container.appendChild(item);
            });
        }

        function updateLegend() {
            const container = document.getElementById('legendList');
            container.innerHTML = '';

            Object.entries(fileTypes).forEach(([type, config]) => {
                const item = document.createElement('div');
                item.className = 'legend-item' + (typeFilters[type] ? '' : ' filtered');
                item.innerHTML = `
                    <span class="legend-color" style="background: ${rgbToHex(config.color)}"></span>
                    <span>${config.label}</span>
                `;
                item.addEventListener('click', () => {
                    typeFilters[type] = !typeFilters[type];
                    item.classList.toggle('filtered');
                    buildScene();
                });
                container.appendChild(item);
            });
        }

        function updateFileDetails(node) {
            const detailsDiv = document.getElementById('fileDetails');
            const noSelection = document.getElementById('noSelection');

            if (!node) {
                detailsDiv.classList.remove('visible');
                noSelection.style.display = 'block';
                return;
            }

            detailsDiv.classList.add('visible');
            noSelection.style.display = 'none';

            const typeConfig = fileTypes[node.type] || fileTypes.other;

            document.getElementById('fileIconLarge').innerHTML = typeConfig.icon;
            document.getElementById('fileIconLarge').style.background = rgbToHex(typeConfig.color);
            document.getElementById('fileName').textContent = node.name;
            document.getElementById('filePath').textContent = node.path.join('/');
            document.getElementById('detailSize').textContent = node.type === 'folder' ? '-' : formatSize(node.size || 0);
            document.getElementById('detailType').textContent = typeConfig.label;
            document.getElementById('detailModified').textContent = formatDate(node.lastModified);
        }

        function navigateToPath(path) {
            currentPath = path;
            buildScene();
            updateStats();
            updateBreadcrumb();
            selectedFile = null;
            updateFileDetails(null);
        }

        // ==================== Controls ====================

        function initControls() {
            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT') return;

                switch(e.key.toLowerCase()) {
                    case 'w': keys.w = true; break;
                    case 'a': keys.a = true; break;
                    case 's': keys.s = true; break;
                    case 'd': keys.d = true; break;
                    case ' ': keys.space = true; e.preventDefault(); break;
                    case 'shift': keys.shift = true; break;
                    case 'e': selectHoveredNode(); break;
                    case 'escape':
                        document.exitPointerLock();
                        break;
                }
            });

            document.addEventListener('keyup', (e) => {
                switch(e.key.toLowerCase()) {
                    case 'w': keys.w = false; break;
                    case 'a': keys.a = false; break;
                    case 's': keys.s = false; break;
                    case 'd': keys.d = false; break;
                    case ' ': keys.space = false; break;
                    case 'shift': keys.shift = false; break;
                }
            });

            // Mouse controls
            canvas.addEventListener('click', () => {
                if (!isPointerLocked) {
                    canvas.requestPointerLock();
                }
            });

            document.addEventListener('pointerlockchange', () => {
                isPointerLocked = document.pointerLockElement === canvas;
                document.getElementById('crosshair').style.opacity = isPointerLocked ? '0.7' : '0.3';
            });

            document.addEventListener('mousemove', (e) => {
                if (isPointerLocked) {
                    camera.rotY += e.movementX * camera.sensitivity;
                    camera.rotX -= e.movementY * camera.sensitivity;
                    camera.rotX = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, camera.rotX));
                }

                // Update tooltip position
                const tooltip = document.getElementById('tooltip');
                tooltip.style.left = e.clientX + 15 + 'px';
                tooltip.style.top = e.clientY + 15 + 'px';
            });

            // Movement update loop
            setInterval(updateMovement, 16);

            // Raycasting for hover
            setInterval(updateHover, 50);

            // Search input
            document.getElementById('searchInput').addEventListener('input', (e) => {
                searchQuery = e.target.value;
            });

            // Theme toggle
            document.getElementById('themeToggle').addEventListener('click', toggleTheme);

            // Overview mode
            document.getElementById('overviewBtn').addEventListener('click', toggleOverview);

            // Open folder button
            document.getElementById('openFolderBtn').addEventListener('click', openFolder);
            document.getElementById('newFolderBtn').addEventListener('click', openFolder);

            // Export button
            document.getElementById('exportBtn').addEventListener('click', exportData);

            // Load sample button
            document.getElementById('loadSampleBtn').addEventListener('click', loadSampleData);

            // Apply saved theme
            if (appData.theme === 'light') {
                document.body.classList.add('light-theme');
            }
        }

        function updateMovement() {
            if (!isPointerLocked) return;

            const moveX = Math.sin(camera.rotY);
            const moveZ = Math.cos(camera.rotY);

            if (keys.w) {
                camera.x += moveX * camera.speed;
                camera.z -= moveZ * camera.speed;
            }
            if (keys.s) {
                camera.x -= moveX * camera.speed;
                camera.z += moveZ * camera.speed;
            }
            if (keys.a) {
                camera.x -= moveZ * camera.speed;
                camera.z -= moveX * camera.speed;
            }
            if (keys.d) {
                camera.x += moveZ * camera.speed;
                camera.z += moveX * camera.speed;
            }
            if (keys.space) {
                camera.y += camera.speed;
            }
            if (keys.shift) {
                camera.y -= camera.speed;
                camera.y = Math.max(0.5, camera.y);
            }
        }

        function updateHover() {
            if (!isPointerLocked) {
                hoveredNode = null;
                document.getElementById('tooltip').classList.remove('visible');
                return;
            }

            // Simple distance-based selection (raycasting approximation)
            const lookX = Math.sin(camera.rotY) * Math.cos(camera.rotX);
            const lookY = Math.sin(camera.rotX);
            const lookZ = -Math.cos(camera.rotY) * Math.cos(camera.rotX);

            let closestNode = null;
            let closestDist = Infinity;

            const allNodes = [...fileNodes, ...folderNodes];

            allNodes.forEach(node => {
                // Vector from camera to node
                const dx = node.x - camera.x;
                const dy = node.y - camera.y;
                const dz = node.z - camera.z;

                // Distance along look direction
                const t = dx * lookX + dy * lookY + dz * lookZ;

                if (t < 0 || t > 50) return; // Behind camera or too far

                // Perpendicular distance
                const px = camera.x + lookX * t - node.x;
                const py = camera.y + lookY * t - node.y;
                const pz = camera.z + lookZ * t - node.z;
                const perpDist = Math.sqrt(px * px + py * py + pz * pz);

                // Check if within node bounds
                if (perpDist < node.size * 1.5 && t < closestDist) {
                    closestDist = t;
                    closestNode = node;
                }
            });

            hoveredNode = closestNode;

            const tooltip = document.getElementById('tooltip');
            if (closestNode) {
                document.getElementById('tooltipName').textContent = closestNode.data.name;
                document.getElementById('tooltipSize').textContent =
                    closestNode.data.type === 'folder' ? 'Folder' : formatSize(closestNode.data.size || 0);
                tooltip.classList.add('visible');
            } else {
                tooltip.classList.remove('visible');
            }
        }

        function selectHoveredNode() {
            if (!hoveredNode) return;

            if (hoveredNode.data.type === 'folder') {
                // Navigate into folder
                navigateToPath(hoveredNode.data.path);
            } else {
                // Select file
                selectedFile = hoveredNode.data;
                updateFileDetails(hoveredNode.data);
            }
        }

        function toggleTheme() {
            appData.theme = appData.theme === 'dark' ? 'light' : 'dark';
            document.body.classList.toggle('light-theme');
            saveData();
        }

        function toggleOverview() {
            isOverviewMode = !isOverviewMode;

            if (isOverviewMode) {
                // Move camera to overview position
                const currentNode = getNodeAtPath(currentPath) || fileSystem;
                const items = currentNode?.children?.length || 1;
                const gridSize = Math.ceil(Math.sqrt(items));

                camera.x = 0;
                camera.y = gridSize * 4;
                camera.z = gridSize * 2;
                camera.rotX = -0.8;
                camera.rotY = 0;

                document.getElementById('overviewBtn').textContent = 'First Person';
            } else {
                camera.y = 5;
                camera.rotX = -0.3;
                document.getElementById('overviewBtn').textContent = 'Overview';
            }
        }

        // ==================== Data Import/Export ====================

        function exportData() {
            if (!fileSystem) {
                showNotification('No directory loaded to export');
                return;
            }

            // Create exportable structure (without handles)
            function cleanNode(node) {
                const clean = {
                    name: node.name,
                    type: node.type,
                    path: node.path
                };

                if (node.size !== undefined) clean.size = node.size;
                if (node.lastModified !== undefined) clean.lastModified = node.lastModified;
                if (node.children) {
                    clean.children = node.children.map(cleanNode);
                }

                return clean;
            }

            const exportObj = {
                exportDate: new Date().toISOString(),
                rootPath: currentPath.join('/'),
                stats: calculateStats(fileSystem),
                structure: cleanNode(fileSystem)
            };

            const dataStr = JSON.stringify(exportObj, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${APP_NAME}-${fileSystem.name}-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);

            showNotification('Directory structure exported');
        }

        function loadSampleData() {
            // Generate sample file system for demo
            const sampleFS = {
                name: 'Sample Project',
                type: 'folder',
                path: ['Sample Project'],
                depth: 0,
                children: [
                    {
                        name: 'src',
                        type: 'folder',
                        path: ['Sample Project', 'src'],
                        depth: 1,
                        children: [
                            { name: 'index.js', type: 'code', size: 15420, path: ['Sample Project', 'src', 'index.js'], lastModified: Date.now() - 86400000 },
                            { name: 'app.js', type: 'code', size: 28340, path: ['Sample Project', 'src', 'app.js'], lastModified: Date.now() - 172800000 },
                            { name: 'utils.js', type: 'code', size: 8920, path: ['Sample Project', 'src', 'utils.js'], lastModified: Date.now() - 259200000 },
                            { name: 'styles.css', type: 'code', size: 12450, path: ['Sample Project', 'src', 'styles.css'], lastModified: Date.now() - 345600000 },
                            {
                                name: 'components',
                                type: 'folder',
                                path: ['Sample Project', 'src', 'components'],
                                depth: 2,
                                children: [
                                    { name: 'Header.jsx', type: 'code', size: 5420, path: ['Sample Project', 'src', 'components', 'Header.jsx'], lastModified: Date.now() - 86400000 },
                                    { name: 'Footer.jsx', type: 'code', size: 3890, path: ['Sample Project', 'src', 'components', 'Footer.jsx'], lastModified: Date.now() - 172800000 },
                                    { name: 'Sidebar.jsx', type: 'code', size: 7650, path: ['Sample Project', 'src', 'components', 'Sidebar.jsx'], lastModified: Date.now() - 259200000 }
                                ]
                            }
                        ]
                    },
                    {
                        name: 'assets',
                        type: 'folder',
                        path: ['Sample Project', 'assets'],
                        depth: 1,
                        children: [
                            { name: 'logo.png', type: 'image', size: 45230, path: ['Sample Project', 'assets', 'logo.png'], lastModified: Date.now() - 432000000 },
                            { name: 'hero.jpg', type: 'image', size: 1245000, path: ['Sample Project', 'assets', 'hero.jpg'], lastModified: Date.now() - 518400000 },
                            { name: 'icon.svg', type: 'image', size: 2340, path: ['Sample Project', 'assets', 'icon.svg'], lastModified: Date.now() - 604800000 },
                            { name: 'background.webp', type: 'image', size: 890000, path: ['Sample Project', 'assets', 'background.webp'], lastModified: Date.now() - 691200000 }
                        ]
                    },
                    {
                        name: 'docs',
                        type: 'folder',
                        path: ['Sample Project', 'docs'],
                        depth: 1,
                        children: [
                            { name: 'README.md', type: 'document', size: 8920, path: ['Sample Project', 'docs', 'README.md'], lastModified: Date.now() - 86400000 },
                            { name: 'API.md', type: 'document', size: 24560, path: ['Sample Project', 'docs', 'API.md'], lastModified: Date.now() - 172800000 },
                            { name: 'CHANGELOG.md', type: 'document', size: 12340, path: ['Sample Project', 'docs', 'CHANGELOG.md'], lastModified: Date.now() - 259200000 }
                        ]
                    },
                    {
                        name: 'media',
                        type: 'folder',
                        path: ['Sample Project', 'media'],
                        depth: 1,
                        children: [
                            { name: 'intro.mp4', type: 'video', size: 15678000, path: ['Sample Project', 'media', 'intro.mp4'], lastModified: Date.now() - 864000000 },
                            { name: 'tutorial.webm', type: 'video', size: 8934000, path: ['Sample Project', 'media', 'tutorial.webm'], lastModified: Date.now() - 950400000 },
                            { name: 'notification.mp3', type: 'audio', size: 234000, path: ['Sample Project', 'media', 'notification.mp3'], lastModified: Date.now() - 1036800000 },
                            { name: 'background.ogg', type: 'audio', size: 5670000, path: ['Sample Project', 'media', 'background.ogg'], lastModified: Date.now() - 1123200000 }
                        ]
                    },
                    {
                        name: 'dist',
                        type: 'folder',
                        path: ['Sample Project', 'dist'],
                        depth: 1,
                        children: [
                            { name: 'bundle.js', type: 'code', size: 456000, path: ['Sample Project', 'dist', 'bundle.js'], lastModified: Date.now() - 43200000 },
                            { name: 'bundle.min.js', type: 'code', size: 189000, path: ['Sample Project', 'dist', 'bundle.min.js'], lastModified: Date.now() - 43200000 },
                            { name: 'styles.min.css', type: 'code', size: 34500, path: ['Sample Project', 'dist', 'styles.min.css'], lastModified: Date.now() - 43200000 },
                            { name: 'release.zip', type: 'archive', size: 2340000, path: ['Sample Project', 'dist', 'release.zip'], lastModified: Date.now() - 86400000 }
                        ]
                    },
                    { name: 'package.json', type: 'document', size: 1890, path: ['Sample Project', 'package.json'], lastModified: Date.now() - 172800000 },
                    { name: 'tsconfig.json', type: 'document', size: 890, path: ['Sample Project', 'tsconfig.json'], lastModified: Date.now() - 259200000 },
                    { name: '.gitignore', type: 'other', size: 340, path: ['Sample Project', '.gitignore'], lastModified: Date.now() - 2592000000 }
                ]
            };

            fileSystem = sampleFS;
            currentPath = ['Sample Project'];

            document.getElementById('welcomeScreen').classList.add('hidden');
            showUI();
            buildScene();
            updateStats();
            updateBreadcrumb();
            updateLegend();
            showNotification('Sample data loaded - explore the 3D file system!');
        }

        // ==================== Initialization ====================

        function init() {
            if (!initWebGL()) {
                document.body.innerHTML = '<div style="padding: 50px; text-align: center;"><h1>WebGL Not Supported</h1><p>Please use a modern browser with WebGL support.</p></div>';
                return;
            }

            initControls();
            render();

            // Check for File System Access API support
            if (!window.showDirectoryPicker) {
                const btn = document.getElementById('openFolderBtn');
                btn.textContent = 'Load Sample Data';
                btn.onclick = loadSampleData;

                const note = document.createElement('p');
                note.style.color = 'var(--text-secondary)';
                note.style.fontSize = '12px';
                note.style.marginTop = '10px';
                note.textContent = 'File System Access API not supported. Sample data will be used.';
                btn.parentNode.insertBefore(note, btn.nextSibling);
            }
        }

        // Start the application
        init();
    </script>
</body>
</html>
