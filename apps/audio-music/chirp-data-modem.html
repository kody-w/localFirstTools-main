<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chirp: Air-Gapped Data Modem</title>
    <meta name="description" content="Transfer text data between devices using sound. Encodes data into R2D2-style chirps and decodes via microphone.">
    <style>
        :root {
            --bg: #0d1117;
            --panel: #161b22;
            --border: #30363d;
            --text: #c9d1d9;
            --accent: #58a6ff;
            --success: #2ea043;
            --danger: #f85149;
            --wave: #7ee787;
        }

        body {
            margin: 0;
            padding: 20px;
            background-color: var(--bg);
            color: var(--text);
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        .container {
            width: 100%;
            max-width: 800px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        header {
            text-align: center;
            border-bottom: 1px solid var(--border);
            padding-bottom: 20px;
        }

        h1 {
            margin: 0;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            color: #8b949e;
            font-size: 0.9em;
            margin-top: 5px;
        }

        .panel {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .panel-header {
            font-weight: bold;
            color: var(--text);
            border-bottom: 1px solid var(--border);
            padding-bottom: 10px;
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        textarea {
            background: #0d1117;
            border: 1px solid var(--border);
            color: var(--text);
            padding: 10px;
            border-radius: 4px;
            resize: vertical;
            min-height: 80px;
            font-family: inherit;
        }

        textarea:focus {
            outline: 1px solid var(--accent);
            border-color: var(--accent);
        }

        button {
            padding: 10px 20px;
            border-radius: 6px;
            border: 1px solid rgba(27, 31, 35, 0.15);
            font-family: inherit;
            font-weight: bold;
            cursor: pointer;
            transition: 0.2s;
        }

        .btn-primary {
            background-color: var(--success);
            color: white;
        }
        .btn-primary:hover { background-color: #2c974b; }
        .btn-primary:disabled { background-color: #238636; opacity: 0.5; cursor: not-allowed; }

        .btn-secondary {
            background-color: var(--accent);
            color: white;
        }
        .btn-secondary:hover { background-color: #4a9eff; }

        .btn-danger {
            background-color: var(--danger);
            color: white;
        }

        canvas {
            background: #000;
            border-radius: 4px;
            width: 100%;
            height: 150px;
            border: 1px solid var(--border);
        }

        .status-bar {
            font-size: 0.8em;
            color: #8b949e;
            display: flex;
            justify-content: space-between;
        }

        .mode-switch {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .mode-btn {
            flex: 1;
            background: var(--panel);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 10px;
            text-align: center;
            cursor: pointer;
            border-radius: 6px;
        }

        .mode-btn.active {
            background: var(--border);
            border-color: var(--accent);
            color: var(--accent);
        }

        #log {
            font-size: 12px;
            color: #8b949e;
            max-height: 100px;
            overflow-y: auto;
            background: #000;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
        }

        .hidden { display: none; }
    </style>
</head>
<body>

<div class="container">
    <header>
        <h1>Chirp Modem</h1>
        <div class="subtitle">Air-Gapped Audio Data Transfer Protocol</div>
    </header>

    <div class="mode-switch">
        <div class="mode-btn active" onclick="setMode('tx')">TRANSMITTER (TX)</div>
        <div class="mode-btn" onclick="setMode('rx')">RECEIVER (RX)</div>
    </div>

    <!-- TRANSMITTER UI -->
    <div id="tx-panel" class="panel">
        <div class="panel-header">
            <span>DATA ENCODER</span>
            <span id="tx-status" style="font-size: 0.8em; color: var(--success)">READY</span>
        </div>
        <textarea id="tx-input" placeholder="Enter text to transmit... (Keep it short for faster transfer)"></textarea>
        
        <div style="display: flex; gap: 10px; align-items: center;">
            <button class="btn-primary" id="btn-transmit" onclick="transmitData()">TRANSMIT AUDIO</button>
            <div style="font-size: 0.8em; color: #8b949e;">
                Speed: <select id="tx-speed" style="background: #000; color: #fff; border: 1px solid #333;">
                    <option value="150">Slow (Reliable)</option>
                    <option value="100" selected>Normal</option>
                    <option value="60">Fast (Experimental)</option>
                </select>
            </div>
        </div>
    </div>

    <!-- RECEIVER UI -->
    <div id="rx-panel" class="panel hidden">
        <div class="panel-header">
            <span>DATA DECODER</span>
            <span id="rx-status" style="font-size: 0.8em; color: var(--danger)">OFFLINE</span>
        </div>
        
        <canvas id="visualizer"></canvas>
        
        <div style="display: flex; gap: 10px;">
            <button class="btn-secondary" id="btn-listen" onclick="toggleListening()">START LISTENING</button>
            <button class="btn-danger" onclick="clearRx()">CLEAR</button>
        </div>

        <div class="panel-header" style="margin-top: 10px; border: none; padding: 0;">Received Data:</div>
        <textarea id="rx-output" readonly placeholder="Waiting for signal..."></textarea>
    </div>

    <div id="log">System initialized. Select a mode.</div>
</div>

<script>
    // --- CONFIGURATION ---
    const BASE_FREQ = 1500; // Starting frequency for 0x0
    const STEP_FREQ = 100;  // Hz between tones
    const START_TOKEN = 4000; // High pitch start
    const END_TOKEN = 1000;   // Low pitch end
    
    // Hex to Frequency Map (0-F)
    // 0=1500, 1=1600, ... F=3000
    
    // --- STATE ---
    let audioCtx;
    let analyser;
    let microphone;
    let isListening = false;
    let animationId;
    let rxBuffer = "";
    let lastDetectedChar = null;
    let lastDetectedTime = 0;
    let detectionHistory = []; // For debouncing
    
    // --- UI FUNCTIONS ---
    function setMode(mode) {
        document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
        event.target.classList.add('active');
        
        if (mode === 'tx') {
            document.getElementById('tx-panel').classList.remove('hidden');
            document.getElementById('rx-panel').classList.add('hidden');
            stopListening();
        } else {
            document.getElementById('tx-panel').classList.add('hidden');
            document.getElementById('rx-panel').classList.remove('hidden');
        }
    }

    function log(msg) {
        const el = document.getElementById('log');
        el.innerText = `> ${msg}\n` + el.innerText;
    }

    // --- AUDIO CONTEXT ---
    function initAudio() {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (audioCtx.state === 'suspended') {
            audioCtx.resume();
        }
    }

    // --- TRANSMITTER (TX) ---
    async function transmitData() {
        initAudio();
        const text = document.getElementById('tx-input').value;
        if (!text) return;

        const speed = parseInt(document.getElementById('tx-speed').value);
        const btn = document.getElementById('btn-transmit');
        btn.disabled = true;
        btn.innerText = "TRANSMITTING...";
        log(`Transmitting: "${text}"`);

        // 1. Encode Text to Nibbles
        // "A" -> 0x41 -> [4, 1]
        const nibbles = [];
        for (let i = 0; i < text.length; i++) {
            const code = text.charCodeAt(i);
            nibbles.push((code >> 4) & 0xF); // High nibble
            nibbles.push(code & 0xF);        // Low nibble
        }

        // 2. Play Tones
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        
        osc.type = 'sine';
        gain.gain.value = 0.5;
        
        const now = audioCtx.currentTime;
        let t = now + 0.5; // Start delay

        // Start Token
        osc.frequency.setValueAtTime(START_TOKEN, t);
        t += (speed / 1000) * 2; // Longer start token
        
        // Gap
        osc.frequency.setValueAtTime(0, t); 
        // Actually, to do silence we need gain envelope, but for simplicity let's just slide freq to 0 (inaudible) or use gain
        // Better: use gain for silence
        gain.gain.setValueAtTime(0.5, t);
        
        // Data Tones
        for (let n of nibbles) {
            // Silence gap between tones to help separation
            gain.gain.setValueAtTime(0, t);
            t += 0.02; // 20ms gap
            
            const freq = BASE_FREQ + (n * STEP_FREQ);
            osc.frequency.setValueAtTime(freq, t);
            gain.gain.setValueAtTime(0.5, t);
            
            t += (speed / 1000);
        }

        // End Token
        gain.gain.setValueAtTime(0, t);
        t += 0.02;
        osc.frequency.setValueAtTime(END_TOKEN, t);
        gain.gain.setValueAtTime(0.5, t);
        t += (speed / 1000) * 2;

        // Stop
        osc.start(now);
        osc.stop(t);

        // Cleanup UI
        setTimeout(() => {
            btn.disabled = false;
            btn.innerText = "TRANSMIT AUDIO";
            log("Transmission complete.");
        }, (t - now) * 1000);
    }

    // --- RECEIVER (RX) ---
    async function toggleListening() {
        if (isListening) {
            stopListening();
        } else {
            await startListening();
        }
    }

    async function startListening() {
        try {
            initAudio();
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            microphone = audioCtx.createMediaStreamSource(stream);
            analyser = audioCtx.createAnalyser();
            analyser.fftSize = 2048; // High resolution
            analyser.smoothingTimeConstant = 0.5;
            microphone.connect(analyser);

            isListening = true;
            document.getElementById('btn-listen').innerText = "STOP LISTENING";
            document.getElementById('btn-listen').classList.replace('btn-secondary', 'btn-danger');
            document.getElementById('rx-status').innerText = "LISTENING...";
            document.getElementById('rx-status').style.color = "var(--success)";
            
            log("Microphone connected. Listening for chirps...");
            drawVisualizer();
            processAudio();
        } catch (e) {
            log("Error accessing microphone: " + e.message);
            alert("Microphone access required for receiver mode.");
        }
    }

    function stopListening() {
        isListening = false;
        if (microphone) microphone.disconnect();
        if (animationId) cancelAnimationFrame(animationId);
        
        document.getElementById('btn-listen').innerText = "START LISTENING";
        document.getElementById('btn-listen').classList.replace('btn-danger', 'btn-secondary');
        document.getElementById('rx-status').innerText = "OFFLINE";
        document.getElementById('rx-status').style.color = "var(--danger)";
    }

    function clearRx() {
        document.getElementById('rx-output').value = "";
        rxBuffer = "";
        log("Buffer cleared.");
    }

    // --- SIGNAL PROCESSING ---
    let nibbleBuffer = [];
    let isReceiving = false;
    let silenceCounter = 0;

    function processAudio() {
        if (!isListening) return;

        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        analyser.getByteFrequencyData(dataArray);

        // Find Peak Frequency
        let maxVal = 0;
        let maxIndex = 0;
        for (let i = 0; i < bufferLength; i++) {
            if (dataArray[i] > maxVal) {
                maxVal = dataArray[i];
                maxIndex = i;
            }
        }

        // Threshold for noise
        if (maxVal > 150) { // Adjustable threshold
            const nyquist = audioCtx.sampleRate / 2;
            const freq = maxIndex * (nyquist / bufferLength);
            
            // Analyze Frequency
            detectTone(freq);
        } else {
            // Silence / Noise
            resetDetection();
        }

        setTimeout(processAudio, 50); // Poll every 50ms
    }

    let currentStableTone = null;
    let stableCount = 0;

    function detectTone(freq) {
        // Check for Start/End Tokens
        if (Math.abs(freq - START_TOKEN) < 50) {
            if (!isReceiving) {
                isReceiving = true;
                nibbleBuffer = [];
                log("Start sequence detected! Receiving data...");
                document.getElementById('rx-status').innerText = "RECEIVING...";
            }
            return;
        }
        
        if (Math.abs(freq - END_TOKEN) < 50) {
            if (isReceiving) {
                isReceiving = false;
                log("End sequence detected.");
                document.getElementById('rx-status').innerText = "LISTENING...";
                decodeBuffer();
            }
            return;
        }

        if (!isReceiving) return;

        // Match to Hex Nibble Frequencies
        // 0=1500, 1=1600 ...
        let bestNibble = -1;
        let minDiff = 9999;

        for (let i = 0; i < 16; i++) {
            const target = BASE_FREQ + (i * STEP_FREQ);
            const diff = Math.abs(freq - target);
            if (diff < 40) { // Tolerance +/- 40Hz
                if (diff < minDiff) {
                    minDiff = diff;
                    bestNibble = i;
                }
            }
        }

        if (bestNibble !== -1) {
            // Debounce: Only accept if we see the same tone multiple times in a row
            if (currentStableTone === bestNibble) {
                stableCount++;
            } else {
                currentStableTone = bestNibble;
                stableCount = 1;
            }

            // If stable for ~3 frames (150ms) and not already added recently
            if (stableCount === 3) {
                // Avoid duplicates from same tone duration
                // Simple logic: just push. We rely on the "Silence gap" in TX to separate tones.
                // But since we poll every 50ms and tone is 100ms, we might double count.
                // We need a "cooldown" or state "tone_registered".
                if (!toneRegistered) {
                    nibbleBuffer.push(bestNibble);
                    toneRegistered = true;
                    log(`Rx Nibble: ${bestNibble.toString(16).toUpperCase()}`);
                    updatePreview();
                }
            }
        }
    }

    let toneRegistered = false;
    function resetDetection() {
        stableCount = 0;
        currentStableTone = null;
        toneRegistered = false; // Reset so we can accept next tone
    }

    function updatePreview() {
        // Try to decode what we have so far
        let tempStr = "";
        for (let i = 0; i < nibbleBuffer.length - 1; i += 2) {
            const high = nibbleBuffer[i];
            const low = nibbleBuffer[i+1];
            const charCode = (high << 4) | low;
            tempStr += String.fromCharCode(charCode);
        }
        document.getElementById('rx-output').value = tempStr;
    }

    function decodeBuffer() {
        updatePreview();
        log("Data decoded.");
    }

    // --- VISUALIZER ---
    function drawVisualizer() {
        if (!isListening) return;
        
        animationId = requestAnimationFrame(drawVisualizer);
        
        const canvas = document.getElementById('visualizer');
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        
        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        analyser.getByteFrequencyData(dataArray);
        
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, width, height);
        
        const barWidth = (width / bufferLength) * 2.5;
        let barHeight;
        let x = 0;
        
        for(let i = 0; i < bufferLength; i++) {
            barHeight = dataArray[i] / 2;
            
            // Color based on height
            ctx.fillStyle = `rgb(${barHeight + 100}, 50, 50)`;
            if (barHeight > 100) ctx.fillStyle = `var(--accent)`;
            
            ctx.fillRect(x, height - barHeight, barWidth, barHeight);
            x += barWidth + 1;
        }
    }

    // Resize canvas
    window.addEventListener('resize', () => {
        const c = document.getElementById('visualizer');
        c.width = c.parentElement.clientWidth;
    });
    // Init canvas size
    setTimeout(() => {
        const c = document.getElementById('visualizer');
        c.width = c.parentElement.clientWidth;
        c.height = 150;
    }, 100);

</script>
</body>
</html>