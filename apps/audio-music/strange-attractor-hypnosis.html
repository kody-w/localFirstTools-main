<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strange Attractor Hypnosis - Chaos Made Beautiful</title>
    <meta name="description" content="A mesmerizing visualization of Lorenz, Rossler, and other strange attractors with ambient generative music. Watch chaos dance.">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: #000;
            color: #fff;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            overflow: hidden;
            height: 100vh;
        }
        
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .ui-overlay {
            position: fixed;
            z-index: 100;
            pointer-events: none;
        }
        
        .ui-overlay > * { pointer-events: auto; }
        
        .panel {
            background: rgba(10, 10, 20, 0.85);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
        }
        
        .top-left {
            top: 20px;
            left: 20px;
        }
        
        h1 {
            font-size: 20px;
            font-weight: 300;
            margin-bottom: 8px;
            background: linear-gradient(90deg, #667eea, #f093fb, #00d9a5);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .subtitle {
            font-size: 12px;
            color: #666;
            margin-bottom: 15px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            font-size: 11px;
            color: #888;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        select, input[type="range"] {
            width: 100%;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: #fff;
            font-size: 13px;
        }
        
        select:focus, input:focus {
            outline: none;
            border-color: #667eea;
        }
        
        input[type="range"] {
            -webkit-appearance: none;
            padding: 0;
            height: 8px;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #667eea;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .btn {
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.3s;
            width: 100%;
            margin-top: 10px;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }
        
        .btn.playing {
            background: linear-gradient(135deg, #00d9a5, #00b894);
        }
        
        .stats {
            position: fixed;
            bottom: 20px;
            left: 20px;
            font-size: 11px;
            color: #555;
        }
        
        .hint {
            position: fixed;
            bottom: 20px;
            right: 20px;
            font-size: 11px;
            color: #444;
            text-align: right;
        }
        
        .attractor-info {
            position: fixed;
            top: 20px;
            right: 20px;
            max-width: 250px;
        }
        
        .equation {
            font-family: 'Times New Roman', serif;
            font-style: italic;
            font-size: 12px;
            color: #888;
            line-height: 1.8;
            margin-top: 10px;
        }
        
        .hidden { display: none !important; }
        
        .fullscreen-btn {
            position: fixed;
            top: 20px;
            right: 300px;
            background: rgba(10, 10, 20, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            z-index: 100;
        }
        
        .zen-mode .panel,
        .zen-mode .fullscreen-btn,
        .zen-mode .stats,
        .zen-mode .hint { opacity: 0; transition: opacity 0.5s; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="ui-overlay top-left panel">
        <h1>Strange Attractor Hypnosis</h1>
        <p class="subtitle">Chaos made beautiful</p>
        
        <div class="control-group">
            <label>Attractor Type</label>
            <select id="attractorType">
                <option value="lorenz">Lorenz System</option>
                <option value="rossler">Rossler Attractor</option>
                <option value="aizawa">Aizawa Attractor</option>
                <option value="thomas">Thomas Attractor</option>
                <option value="halvorsen">Halvorsen Attractor</option>
                <option value="dadras">Dadras Attractor</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>Color Mode</label>
            <select id="colorMode">
                <option value="velocity">Velocity-Based</option>
                <option value="position">Position-Based</option>
                <option value="time">Time Gradient</option>
                <option value="rainbow">Rainbow Cycle</option>
                <option value="monochrome">Monochrome</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>Trail Length: <span id="trailValue">500</span></label>
            <input type="range" id="trailLength" min="100" max="2000" value="500">
        </div>
        
        <div class="control-group">
            <label>Speed: <span id="speedValue">1.0</span>x</label>
            <input type="range" id="speed" min="0.1" max="3" step="0.1" value="1">
        </div>
        
        <div class="control-group">
            <label>Rotation Speed: <span id="rotateValue">0.5</span></label>
            <input type="range" id="rotateSpeed" min="0" max="2" step="0.1" value="0.5">
        </div>
        
        <button class="btn" id="audioBtn" onclick="toggleAudio()">Enable Ambient Sound</button>
    </div>
    
    <div class="ui-overlay panel attractor-info" id="attractorInfo">
        <h3 style="font-size: 14px; margin-bottom: 10px;">Lorenz System</h3>
        <p style="font-size: 11px; color: #888; line-height: 1.6;" id="attractorDesc">
            Discovered by Edward Lorenz in 1963 while modeling atmospheric convection. This system demonstrates sensitive dependence on initial conditions - the "butterfly effect."
        </p>
        <div class="equation" id="attractorEq">
            dx/dt = σ(y - x)<br>
            dy/dt = x(ρ - z) - y<br>
            dz/dt = xy - βz
        </div>
    </div>
    
    <button class="fullscreen-btn" onclick="toggleZen()">Zen Mode (Z)</button>
    
    <div class="stats" id="stats">
        Points: <span id="pointCount">0</span> | FPS: <span id="fps">0</span>
    </div>
    
    <div class="hint">
        Press Z for zen mode | Scroll to zoom | Drag to rotate
    </div>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let width, height;
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);
        
        // Attractor definitions
        const attractors = {
            lorenz: {
                name: 'Lorenz System',
                desc: 'Discovered by Edward Lorenz in 1963 while modeling atmospheric convection. This system demonstrates sensitive dependence on initial conditions - the "butterfly effect."',
                eq: 'dx/dt = σ(y - x)<br>dy/dt = x(ρ - z) - y<br>dz/dt = xy - βz',
                params: { sigma: 10, rho: 28, beta: 8/3 },
                step: (x, y, z, p, dt) => ({
                    dx: p.sigma * (y - x) * dt,
                    dy: (x * (p.rho - z) - y) * dt,
                    dz: (x * y - p.beta * z) * dt
                }),
                scale: 12,
                center: { x: 0, y: 0, z: 25 }
            },
            rossler: {
                name: 'Rossler Attractor',
                desc: 'Proposed by Otto Rossler in 1976, this attractor was designed to behave similarly to the Lorenz attractor but with a simpler structure.',
                eq: 'dx/dt = -y - z<br>dy/dt = x + ay<br>dz/dt = b + z(x - c)',
                params: { a: 0.2, b: 0.2, c: 5.7 },
                step: (x, y, z, p, dt) => ({
                    dx: (-y - z) * dt,
                    dy: (x + p.a * y) * dt,
                    dz: (p.b + z * (x - p.c)) * dt
                }),
                scale: 20,
                center: { x: 0, y: 0, z: 0 }
            },
            aizawa: {
                name: 'Aizawa Attractor',
                desc: 'A beautiful 3D chaotic attractor that creates intricate spiral patterns reminiscent of DNA helixes.',
                eq: 'dx/dt = (z-b)x - dy<br>dy/dt = dx + (z-b)y<br>dz/dt = c + az - z³/3 - (x²+y²)(1+ez) + fzx³',
                params: { a: 0.95, b: 0.7, c: 0.6, d: 3.5, e: 0.25, f: 0.1 },
                step: (x, y, z, p, dt) => ({
                    dx: ((z - p.b) * x - p.d * y) * dt,
                    dy: (p.d * x + (z - p.b) * y) * dt,
                    dz: (p.c + p.a * z - Math.pow(z, 3) / 3 - (x*x + y*y) * (1 + p.e * z) + p.f * z * Math.pow(x, 3)) * dt
                }),
                scale: 150,
                center: { x: 0, y: 0, z: 0 }
            },
            thomas: {
                name: 'Thomas Attractor',
                desc: 'Discovered by René Thomas, this attractor is notable for its cyclic symmetry and slower dynamics.',
                eq: 'dx/dt = sin(y) - bx<br>dy/dt = sin(z) - by<br>dz/dt = sin(x) - bz',
                params: { b: 0.208186 },
                step: (x, y, z, p, dt) => ({
                    dx: (Math.sin(y) - p.b * x) * dt,
                    dy: (Math.sin(z) - p.b * y) * dt,
                    dz: (Math.sin(x) - p.b * z) * dt
                }),
                scale: 60,
                center: { x: 0, y: 0, z: 0 }
            },
            halvorsen: {
                name: 'Halvorsen Attractor',
                desc: 'A chaotic system that produces a distinctive three-winged pattern with elegant rotational symmetry.',
                eq: 'dx/dt = -ax - 4y - 4z - y²<br>dy/dt = -ay - 4z - 4x - z²<br>dz/dt = -az - 4x - 4y - x²',
                params: { a: 1.89 },
                step: (x, y, z, p, dt) => ({
                    dx: (-p.a * x - 4 * y - 4 * z - y * y) * dt,
                    dy: (-p.a * y - 4 * z - 4 * x - z * z) * dt,
                    dz: (-p.a * z - 4 * x - 4 * y - x * x) * dt
                }),
                scale: 15,
                center: { x: 0, y: 0, z: 0 }
            },
            dadras: {
                name: 'Dadras Attractor',
                desc: 'A relatively recent discovery showing complex multi-scroll behavior with distinctive interconnected loops.',
                eq: 'dx/dt = y - ax + byz<br>dy/dt = cy - xz + z<br>dz/dt = dxy - ez',
                params: { a: 3, b: 2.7, c: 1.7, d: 2, e: 9 },
                step: (x, y, z, p, dt) => ({
                    dx: (y - p.a * x + p.b * y * z) * dt,
                    dy: (p.c * y - x * z + z) * dt,
                    dz: (p.d * x * y - p.e * z) * dt
                }),
                scale: 18,
                center: { x: 0, y: 0, z: 0 }
            }
        };
        
        // State
        let currentAttractor = 'lorenz';
        let colorMode = 'velocity';
        let trailLength = 500;
        let speedMult = 1;
        let rotateSpeed = 0.5;
        let rotation = { x: 0.3, y: 0, z: 0 };
        let zoom = 1;
        let isDragging = false;
        let lastMouse = { x: 0, y: 0 };
        let zenMode = false;
        
        // Attractor point and trail
        let point = { x: 0.1, y: 0, z: 0 };
        let trail = [];
        let time = 0;
        
        // FPS tracking
        let frameCount = 0;
        let lastFpsTime = Date.now();
        let fps = 0;
        
        // Audio
        let audioCtx = null;
        let isPlaying = false;
        let oscillators = [];
        let masterGain = null;
        
        function initAudio() {
            if (audioCtx) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            masterGain = audioCtx.createGain();
            masterGain.gain.value = 0.15;
            masterGain.connect(audioCtx.destination);
            
            // Create ambient drone
            const frequencies = [55, 82.5, 110, 165];
            frequencies.forEach((freq, i) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                const filter = audioCtx.createBiquadFilter();
                
                osc.type = 'sine';
                osc.frequency.value = freq;
                
                filter.type = 'lowpass';
                filter.frequency.value = 500;
                filter.Q.value = 2;
                
                gain.gain.value = 0.3 / (i + 1);
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(masterGain);
                
                oscillators.push({ osc, gain, filter, baseFreq: freq });
                osc.start();
            });
        }
        
        function toggleAudio() {
            if (!audioCtx) initAudio();
            
            isPlaying = !isPlaying;
            const btn = document.getElementById('audioBtn');
            
            if (isPlaying) {
                masterGain.gain.linearRampToValueAtTime(0.15, audioCtx.currentTime + 0.5);
                btn.textContent = 'Disable Ambient Sound';
                btn.classList.add('playing');
            } else {
                masterGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.5);
                btn.textContent = 'Enable Ambient Sound';
                btn.classList.remove('playing');
            }
        }
        
        function updateAudio() {
            if (!isPlaying || !oscillators.length) return;
            
            // Modulate audio based on attractor state
            const att = attractors[currentAttractor];
            const velocity = Math.sqrt(
                Math.pow(trail[trail.length-1]?.dx || 0, 2) +
                Math.pow(trail[trail.length-1]?.dy || 0, 2) +
                Math.pow(trail[trail.length-1]?.dz || 0, 2)
            );
            
            oscillators.forEach((o, i) => {
                // Subtle frequency modulation based on position
                const modulation = 1 + (point.x + point.y) * 0.01;
                o.osc.frequency.setTargetAtTime(o.baseFreq * modulation, audioCtx.currentTime, 0.1);
                
                // Filter modulation based on velocity
                const filterFreq = 300 + velocity * 50;
                o.filter.frequency.setTargetAtTime(Math.min(2000, filterFreq), audioCtx.currentTime, 0.1);
            });
        }
        
        function updateAttractor() {
            const att = attractors[currentAttractor];
            const dt = 0.005 * speedMult;
            
            const delta = att.step(point.x, point.y, point.z, att.params, dt);
            point.x += delta.dx;
            point.y += delta.dy;
            point.z += delta.dz;
            
            trail.push({
                x: point.x, y: point.y, z: point.z,
                dx: delta.dx, dy: delta.dy, dz: delta.dz,
                time: time++
            });
            
            if (trail.length > trailLength) {
                trail.shift();
            }
        }
        
        function project(x, y, z) {
            const att = attractors[currentAttractor];
            
            // Center the attractor
            x -= att.center.x;
            y -= att.center.y;
            z -= att.center.z;
            
            // Apply rotation
            let rx = rotation.x;
            let ry = rotation.y + time * 0.0001 * rotateSpeed;
            
            // Rotate around Y
            let tx = x * Math.cos(ry) - z * Math.sin(ry);
            let tz = x * Math.sin(ry) + z * Math.cos(ry);
            x = tx; z = tz;
            
            // Rotate around X
            let ty = y * Math.cos(rx) - z * Math.sin(rx);
            tz = y * Math.sin(rx) + z * Math.cos(rx);
            y = ty; z = tz;
            
            // Perspective projection
            const fov = 400;
            const scale = att.scale * zoom;
            const perspective = fov / (fov + z * 0.1);
            
            return {
                x: width / 2 + x * scale * perspective,
                y: height / 2 - y * scale * perspective,
                z: z,
                alpha: 0.3 + perspective * 0.7
            };
        }
        
        function getColor(index, p) {
            const t = index / trail.length;
            const velocity = Math.sqrt(p.dx*p.dx + p.dy*p.dy + p.dz*p.dz);
            
            switch (colorMode) {
                case 'velocity':
                    const hue = 220 - velocity * 5000;
                    return `hsla(${Math.max(0, hue)}, 80%, 60%, ${t * 0.8})`;
                    
                case 'position':
                    const h = ((p.x + p.y + p.z) * 10 + 180) % 360;
                    return `hsla(${h}, 70%, 55%, ${t * 0.8})`;
                    
                case 'time':
                    return `hsla(${(p.time * 0.5) % 360}, 70%, 55%, ${t * 0.8})`;
                    
                case 'rainbow':
                    return `hsla(${(t * 360 + time * 0.1) % 360}, 80%, 55%, ${t * 0.8})`;
                    
                case 'monochrome':
                    const brightness = 40 + t * 40;
                    return `hsla(220, 10%, ${brightness}%, ${t * 0.9})`;
                    
                default:
                    return `hsla(260, 70%, 60%, ${t * 0.8})`;
            }
        }
        
        function render() {
            // Clear with fade for trails effect
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.fillRect(0, 0, width, height);
            
            if (trail.length < 2) return;
            
            // Draw trail
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            for (let i = 1; i < trail.length; i++) {
                const p1 = project(trail[i-1].x, trail[i-1].y, trail[i-1].z);
                const p2 = project(trail[i].x, trail[i].y, trail[i].z);
                
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                
                ctx.strokeStyle = getColor(i, trail[i]);
                ctx.globalAlpha = p2.alpha * (i / trail.length);
                ctx.stroke();
            }
            
            // Draw current point
            const current = project(point.x, point.y, point.z);
            ctx.globalAlpha = 1;
            ctx.beginPath();
            ctx.arc(current.x, current.y, 4, 0, Math.PI * 2);
            ctx.fillStyle = '#fff';
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = 15;
            ctx.fill();
            ctx.shadowBlur = 0;
        }
        
        function updateStats() {
            frameCount++;
            const now = Date.now();
            if (now - lastFpsTime > 1000) {
                fps = frameCount;
                frameCount = 0;
                lastFpsTime = now;
                document.getElementById('fps').textContent = fps;
            }
            document.getElementById('pointCount').textContent = trail.length;
        }
        
        function animate() {
            updateAttractor();
            updateAudio();
            render();
            updateStats();
            requestAnimationFrame(animate);
        }
        
        function resetAttractor() {
            point = { x: 0.1 + Math.random() * 0.01, y: Math.random() * 0.01, z: Math.random() * 0.01 };
            trail = [];
            time = 0;
            
            const att = attractors[currentAttractor];
            document.querySelector('.attractor-info h3').textContent = att.name;
            document.getElementById('attractorDesc').textContent = att.desc;
            document.getElementById('attractorEq').innerHTML = att.eq;
        }
        
        // Event listeners
        document.getElementById('attractorType').addEventListener('change', (e) => {
            currentAttractor = e.target.value;
            resetAttractor();
        });
        
        document.getElementById('colorMode').addEventListener('change', (e) => {
            colorMode = e.target.value;
        });
        
        document.getElementById('trailLength').addEventListener('input', (e) => {
            trailLength = parseInt(e.target.value);
            document.getElementById('trailValue').textContent = trailLength;
        });
        
        document.getElementById('speed').addEventListener('input', (e) => {
            speedMult = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = speedMult.toFixed(1);
        });
        
        document.getElementById('rotateSpeed').addEventListener('input', (e) => {
            rotateSpeed = parseFloat(e.target.value);
            document.getElementById('rotateValue').textContent = rotateSpeed.toFixed(1);
        });
        
        // Mouse controls
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouse = { x: e.clientX, y: e.clientY };
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const dx = e.clientX - lastMouse.x;
            const dy = e.clientY - lastMouse.y;
            rotation.y += dx * 0.005;
            rotation.x += dy * 0.005;
            lastMouse = { x: e.clientX, y: e.clientY };
        });
        
        canvas.addEventListener('mouseup', () => isDragging = false);
        canvas.addEventListener('mouseleave', () => isDragging = false);
        
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            zoom *= e.deltaY > 0 ? 0.95 : 1.05;
            zoom = Math.max(0.1, Math.min(5, zoom));
        });
        
        // Keyboard
        document.addEventListener('keydown', (e) => {
            if (e.key === 'z' || e.key === 'Z') {
                toggleZen();
            }
        });
        
        function toggleZen() {
            zenMode = !zenMode;
            document.body.classList.toggle('zen-mode', zenMode);
        }
        
        // Initialize
        resetAttractor();
        animate();
    </script>
</body>
</html>
