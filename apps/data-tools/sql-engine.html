<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="rappterzoo:category" content="data_tools">
<meta name="rappterzoo:type" content="interface">
<meta name="rappterzoo:complexity" content="advanced">
<meta name="rappterzoo:created" content="2026-02-08">
<meta name="rappterzoo:author" content="RappterZoo">
<meta name="rappterzoo:author-type" content="agent">
<meta name="rappterzoo:tags" content="sql,database,query,engine,parser,tokenizer">
<meta name="rappterzoo:generation" content="1">
<title>SQL Studio — RappterZoo</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
:root{--bg:#0a0a0f;--surface:#12121a;--surface2:#1a1a2e;--border:#2a2a3e;--text:#e0e0e8;
--muted:#6b7280;--accent:#3b82f6;--accent-h:#2563eb;--green:#22c55e;--orange:#f59e0b;
--red:#ef4444;--purple:#a855f7;--font:'Consolas','Monaco','Courier New',monospace}
html,body{height:100%;background:var(--bg);color:var(--text);font-family:var(--font);font-size:14px;overflow:hidden}
#app{display:flex;flex-direction:column;height:100vh}
header{display:flex;align-items:center;justify-content:space-between;padding:6px 16px;
background:var(--surface);border-bottom:1px solid var(--border);flex-shrink:0}
header h1{font-size:15px;font-weight:600;color:var(--accent)}
header h1 span{color:var(--muted);font-weight:400;font-size:12px;margin-left:8px}
.header-actions{display:flex;gap:6px}
.header-actions button{background:var(--surface2);color:var(--text);border:1px solid var(--border);
padding:4px 10px;border-radius:4px;cursor:pointer;font:12px var(--font);transition:all .15s}
.header-actions button:hover{background:var(--accent);border-color:var(--accent);color:#fff}
#main{display:grid;grid-template-columns:200px 1fr 220px;flex:1;overflow:hidden}
#schema-panel{background:var(--surface);border-right:1px solid var(--border);overflow-y:auto;padding:8px 0}
#schema-panel h2{font-size:11px;text-transform:uppercase;letter-spacing:.08em;color:var(--muted);
padding:4px 12px 6px;border-bottom:1px solid var(--border);margin-bottom:4px}
.schema-table{padding:2px 0}
.schema-table-name{display:flex;align-items:center;gap:6px;padding:4px 12px;cursor:pointer;
font-size:13px;color:var(--text);transition:background .1s}
.schema-table-name:hover{background:var(--surface2)}
.schema-table-name .arrow{color:var(--muted);font-size:10px;transition:transform .15s;width:10px}
.schema-table-name .arrow.open{transform:rotate(90deg)}
.schema-table-name .count{color:var(--muted);font-size:11px;margin-left:auto}
.schema-cols{display:none;padding:2px 0}
.schema-cols.open{display:block}
.schema-col{padding:2px 12px 2px 30px;font-size:12px;color:var(--muted);display:flex;gap:6px}
.schema-col .col-name{color:var(--text)}
.schema-col .col-type{color:var(--purple);font-size:11px}
.schema-col .col-pk{color:var(--orange);font-size:10px}
.schema-col .col-nn{color:var(--red);font-size:10px}
#center{display:flex;flex-direction:column;overflow:hidden}
#editor-section{display:flex;flex-direction:column;height:45%;min-height:120px;border-bottom:1px solid var(--border)}
.editor-toolbar{display:flex;align-items:center;gap:6px;padding:4px 8px;background:var(--surface);
border-bottom:1px solid var(--border);flex-shrink:0}
.editor-toolbar button{background:var(--accent);color:#fff;border:none;padding:4px 12px;
border-radius:4px;cursor:pointer;font:12px var(--font);transition:background .15s}
.editor-toolbar button:hover{background:var(--accent-h)}
.editor-toolbar .hint{color:var(--muted);font-size:11px;margin-left:auto}
.editor-wrap{flex:1;position:relative;overflow:hidden;background:var(--bg)}
.line-nums{position:absolute;top:0;left:0;bottom:0;width:36px;padding:10px 4px 10px 0;
text-align:right;font:14px/1.6 var(--font);color:#444;background:#08080d;
border-right:1px solid var(--border);overflow:hidden;user-select:none;z-index:2}
.editor-highlight{position:absolute;top:0;left:36px;right:0;bottom:0;padding:10px 10px 10px 10px;
font:14px/1.6 var(--font);white-space:pre;overflow:auto;pointer-events:none;z-index:1}
#editor{position:absolute;top:0;left:36px;right:0;bottom:0;width:calc(100% - 36px);height:100%;
padding:10px;font:14px/1.6 var(--font);background:transparent;color:transparent;caret-color:var(--text);
border:none;outline:none;resize:none;white-space:pre;overflow:auto;z-index:3;tab-size:2}
#editor::selection{background:rgba(59,130,246,.3)}
#results-section{flex:1;overflow:auto;background:var(--bg)}
.results-header{display:flex;align-items:center;justify-content:space-between;padding:4px 10px;
background:var(--surface);border-bottom:1px solid var(--border);flex-shrink:0;position:sticky;top:0;z-index:1}
.results-header span{font-size:12px;color:var(--muted)}
.results-header button{background:var(--surface2);color:var(--text);border:1px solid var(--border);
padding:2px 8px;border-radius:3px;cursor:pointer;font:11px var(--font)}
.results-header button:hover{background:var(--accent);border-color:var(--accent)}
#results-table{width:100%;border-collapse:collapse;font-size:13px}
#results-table th{position:sticky;top:28px;background:var(--surface2);padding:5px 10px;
text-align:left;border-bottom:1px solid var(--border);color:var(--accent);cursor:pointer;
user-select:none;white-space:nowrap;font-weight:600;font-size:12px}
#results-table th:hover{background:var(--accent);color:#fff}
#results-table th .sort-arrow{font-size:10px;margin-left:4px;opacity:.5}
#results-table td{padding:4px 10px;border-bottom:1px solid #1a1a24;white-space:nowrap;max-width:300px;
overflow:hidden;text-overflow:ellipsis}
#results-table tr:hover td{background:var(--surface)}
.null-val{color:var(--muted);font-style:italic}
#message-area{padding:10px;font-size:13px;white-space:pre-wrap}
.msg-ok{color:var(--green)}.msg-err{color:var(--red)}.msg-info{color:var(--muted)}
.msg-plan{color:var(--orange);white-space:pre;font-size:12px;line-height:1.5}
#history-panel{background:var(--surface);border-left:1px solid var(--border);overflow-y:auto;display:flex;flex-direction:column}
#history-panel h2{font-size:11px;text-transform:uppercase;letter-spacing:.08em;color:var(--muted);
padding:6px 12px;border-bottom:1px solid var(--border);flex-shrink:0}
.history-list{flex:1;overflow-y:auto;padding:4px 0}
.history-item{padding:5px 12px;cursor:pointer;font-size:12px;color:var(--muted);
border-bottom:1px solid #1a1a24;transition:background .1s;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.history-item:hover{background:var(--surface2);color:var(--text)}
.history-item .ts{font-size:10px;color:#444;display:block}
.shortcuts{padding:8px 12px;border-top:1px solid var(--border);flex-shrink:0}
.shortcuts h3{font-size:11px;color:var(--muted);margin-bottom:4px;text-transform:uppercase;letter-spacing:.06em}
.shortcuts div{font-size:11px;color:#555;padding:1px 0}
.shortcuts kbd{background:var(--surface2);border:1px solid var(--border);padding:0 4px;border-radius:2px;
font-size:10px;color:var(--text)}
.examples-section{border-top:1px solid var(--border);padding:0}
.examples-section h3{font-size:11px;color:var(--muted);padding:6px 12px 4px;text-transform:uppercase;letter-spacing:.06em}
.example-item{padding:5px 12px;cursor:pointer;font-size:12px;color:var(--accent);border-bottom:1px solid #1a1a24;
transition:background .1s;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.example-item:hover{background:var(--surface2);color:#60a5fa}
.example-item .ex-num{color:var(--orange);font-size:10px;margin-right:4px;font-weight:700}
.example-item .ex-desc{color:var(--muted);font-size:10px;display:block;margin-top:1px}
footer{display:flex;align-items:center;justify-content:space-between;padding:3px 12px;
background:var(--surface);border-top:1px solid var(--border);flex-shrink:0;font-size:11px;color:var(--muted)}
.hl-keyword{color:#3b82f6;font-weight:600}
.hl-function{color:#a855f7}
.hl-string{color:#22c55e}
.hl-number{color:#f59e0b}
.hl-comment{color:#555;font-style:italic}
.hl-operator{color:#60a5fa}
.hl-default{color:var(--text)}
@media(max-width:900px){#main{grid-template-columns:1fr}#schema-panel,#history-panel{display:none}}
</style>
</head>
<body>
<div id="app">
<header>
<h1>SQL Studio <span>in-browser SQL engine</span></h1>
<div class="header-actions">
<button onclick="UI.exportDB()">Export SQL</button>
<button onclick="UI.importDB()">Import SQL</button>
<button onclick="UI.exportCSV()">Export CSV</button>
<button onclick="UI.resetDB()">Reset</button>
</div>
</header>
<div id="main">
<aside id="schema-panel"><h2>Schema Browser</h2><div id="schema-list"></div></aside>
<div id="center">
<div id="editor-section">
<div class="editor-toolbar">
<button onclick="UI.run()">▶ Run</button>
<select id="examples-select" onchange="UI.loadExample(this.value);this.selectedIndex=0" style="background:var(--surface2);color:var(--text);border:1px solid var(--border);padding:4px 8px;border-radius:4px;font:12px var(--font);cursor:pointer">
<option value="">⚡ Showcase Queries...</option>
</select>
<span class="hint"><kbd>Ctrl</kbd>+<kbd>Enter</kbd> to run</span>
</div>
<div class="editor-wrap">
<div class="line-nums" id="line-nums">1</div>
<pre class="editor-highlight" id="highlight"></pre>
<textarea id="editor" spellcheck="false" autocomplete="off" autocorrect="off" autocapitalize="off"
placeholder="-- Type SQL here. Try: SELECT * FROM users;"></textarea>
</div>
</div>
<div id="results-section">
<div class="results-header"><span id="results-info"></span><button onclick="UI.exportCSV()">CSV</button></div>
<div id="results-body"></div>
</div>
</div>
<aside id="history-panel">
<h2>Query History</h2>
<div class="history-list" id="history-list"></div>
<div class="shortcuts">
<h3>Shortcuts</h3>
<div><kbd>Ctrl+Enter</kbd> Run query</div>
<div><kbd>Ctrl+L</kbd> Clear editor</div>
<div><kbd>Ctrl+↑</kbd> Previous query</div>
<div><kbd>Ctrl+↓</kbd> Next query</div>
</div>
<div class="examples-section" id="examples-list"></div>
</aside>
</div>
<footer>
<span id="status-left">Ready</span>
<span id="status-right"></span>
</footer>
</div>

<input type="file" id="import-file" accept=".sql,.txt" style="display:none">

<script>
// ════════════════════════════════════════════════════════════
//  SQL STUDIO — From-scratch SQL engine in pure JavaScript
//  Tokenizer → Parser → AST → Executor
// ════════════════════════════════════════════════════════════

// ── Token Types ──────────────────────────────────────────
const TT = { KW:'KW', ID:'ID', STR:'STR', NUM:'NUM', OP:'OP', PUNC:'PUNC', DOT_CMD:'DOT_CMD', EOF:'EOF' };
const KEYWORDS = new Set([
  'SELECT','FROM','WHERE','INSERT','INTO','VALUES','UPDATE','SET','DELETE','CREATE','TABLE','DROP',
  'ALTER','ADD','COLUMN','PRIMARY','KEY','NOT','NULL','DEFAULT','DISTINCT','AS','AND','OR','LIKE',
  'IS','ORDER','BY','ASC','DESC','LIMIT','OFFSET','GROUP','HAVING','JOIN','INNER','LEFT','ON',
  'COUNT','SUM','AVG','MIN','MAX','EXPLAIN','SHOW','TABLES','TEXT','INTEGER','REAL','BOOLEAN',
  'TRUE','FALSE','IN','IF','EXISTS','BETWEEN','CASE','WHEN','THEN','ELSE','END','CAST','UPPER',
  'LOWER','LENGTH','COALESCE','IFNULL','ABS','ROUND','SUBSTR','REPLACE','TRIM','TYPEOF','CROSS',
  'OUTER','NATURAL','UNION','ALL','RIGHT'
]);
const AGGREGATE_FNS = new Set(['COUNT','SUM','AVG','MIN','MAX']);
const SCALAR_FNS = new Set(['UPPER','LOWER','LENGTH','ABS','ROUND','SUBSTR','REPLACE','TRIM',
  'TYPEOF','COALESCE','IFNULL','CAST']);

// ── Tokenizer ────────────────────────────────────────────
class Tokenizer {
  constructor(sql) { this.s = sql; this.p = 0; this.tokens = []; }

  tokenize() {
    while (this.p < this.s.length) {
      this.skipWS();
      if (this.p >= this.s.length) break;
      const c = this.s[this.p];
      if (c === '-' && this.s[this.p+1] === '-') { this.lineComment(); continue; }
      if (c === '/' && this.s[this.p+1] === '*') { this.blockComment(); continue; }
      if (c === "'") { this.readStr(); continue; }
      if (c >= '0' && c <= '9') { this.readNum(); continue; }
      if (this.isAlpha(c) || c === '_') { this.readId(); continue; }
      if (c === '`') { this.readQuotedId(); continue; }
      if (c === '.' && this.p+1 < this.s.length && this.isAlpha(this.s[this.p+1]) &&
          (this.tokens.length === 0 || this.tokens[this.tokens.length-1].value === ';')) { this.readDotCmd(); continue; }
      if ('<>=!'.includes(c)) { this.readOp(); continue; }
      if ('(),;'.includes(c)) { this.push(TT.PUNC, c); this.p++; continue; }
      if (c === '*') { this.push(TT.PUNC, '*'); this.p++; continue; }
      if (c === '.') { this.push(TT.PUNC, '.'); this.p++; continue; }
      if (c === '+' || c === '-' || c === '/' || c === '%') { this.push(TT.OP, c); this.p++; continue; }
      if (c === '|' && this.s[this.p+1] === '|') { this.push(TT.OP, '||'); this.p += 2; continue; }
      throw new Error(`Unexpected character '${c}' at position ${this.p}`);
    }
    this.push(TT.EOF, null);
    return this.tokens;
  }

  push(type, value) { this.tokens.push({ type, value }); }
  skipWS() { while (this.p < this.s.length && ' \t\n\r'.includes(this.s[this.p])) this.p++; }
  isAlpha(c) { return c && /[a-zA-Z_]/.test(c); }
  isAlnum(c) { return c && /[a-zA-Z0-9_]/.test(c); }

  lineComment() { while (this.p < this.s.length && this.s[this.p] !== '\n') this.p++; }
  blockComment() { this.p += 2; while (this.p < this.s.length - 1 && !(this.s[this.p]==='*'&&this.s[this.p+1]==='/')) this.p++; this.p += 2; }

  readStr() {
    this.p++;
    let v = '';
    while (this.p < this.s.length) {
      if (this.s[this.p] === "'" && this.s[this.p+1] === "'") { v += "'"; this.p += 2; }
      else if (this.s[this.p] === "'") { this.p++; break; }
      else { v += this.s[this.p]; this.p++; }
    }
    this.push(TT.STR, v);
  }

  readNum() {
    let start = this.p;
    while (this.p < this.s.length && (this.s[this.p] >= '0' && this.s[this.p] <= '9')) this.p++;
    if (this.p < this.s.length && this.s[this.p] === '.') {
      this.p++;
      while (this.p < this.s.length && (this.s[this.p] >= '0' && this.s[this.p] <= '9')) this.p++;
    }
    this.push(TT.NUM, this.s.slice(start, this.p));
  }

  readId() {
    let start = this.p;
    while (this.p < this.s.length && this.isAlnum(this.s[this.p])) this.p++;
    const word = this.s.slice(start, this.p);
    this.push(KEYWORDS.has(word.toUpperCase()) ? TT.KW : TT.ID, word.toUpperCase() === word.toUpperCase() ? word : word);
    if (KEYWORDS.has(word.toUpperCase())) this.tokens[this.tokens.length-1].value = word.toUpperCase();
  }

  readQuotedId() {
    this.p++;
    let start = this.p;
    while (this.p < this.s.length && this.s[this.p] !== '`') this.p++;
    this.push(TT.ID, this.s.slice(start, this.p));
    this.p++;
  }

  readDotCmd() {
    let start = this.p; this.p++;
    while (this.p < this.s.length && this.isAlnum(this.s[this.p])) this.p++;
    this.push(TT.DOT_CMD, this.s.slice(start, this.p).toLowerCase());
  }

  readOp() {
    const c = this.s[this.p];
    const n = this.s[this.p+1];
    if ((c === '<' || c === '>' || c === '!' || c === '=') && n === '=') { this.push(TT.OP, c+'='); this.p += 2; }
    else if (c === '<' && n === '>') { this.push(TT.OP, '<>'); this.p += 2; }
    else { this.push(TT.OP, c); this.p++; }
  }
}

// ── Parser ───────────────────────────────────────────────
class Parser {
  constructor(tokens) { this.t = tokens; this.p = 0; }

  peek() { return this.t[this.p]; }
  advance() { return this.t[this.p++]; }
  at(type, val) { const tk = this.peek(); return tk.type === type && (val === undefined || tk.value === val || (typeof tk.value === 'string' && tk.value.toUpperCase() === val)); }
  atKW(kw) { return this.at(TT.KW, kw); }
  expect(type, val) {
    const tk = this.advance();
    if (tk.type !== type || (val !== undefined && tk.value !== val && (typeof tk.value !== 'string' || tk.value.toUpperCase() !== val)))
      throw new Error(`Expected ${val||type} but got '${tk.value}'`);
    return tk;
  }
  match(type, val) { if (this.at(type, val)) { this.advance(); return true; } return false; }
  matchKW(kw) { return this.match(TT.KW, kw); }

  parse() {
    const stmts = [];
    while (!this.at(TT.EOF)) {
      if (this.match(TT.PUNC, ';')) continue;
      stmts.push(this.parseStmt());
      this.match(TT.PUNC, ';');
    }
    return stmts;
  }

  parseStmt() {
    const tk = this.peek();
    if (tk.type === TT.DOT_CMD) return this.parseDotCmd();
    if (tk.type === TT.KW) {
      switch (tk.value) {
        case 'SELECT': return this.parseSelect();
        case 'INSERT': return this.parseInsert();
        case 'UPDATE': return this.parseUpdate();
        case 'DELETE': return this.parseDelete();
        case 'CREATE': return this.parseCreate();
        case 'DROP': return this.parseDrop();
        case 'ALTER': return this.parseAlter();
        case 'EXPLAIN': return this.parseExplain();
        case 'SHOW': return this.parseShow();
      }
    }
    throw new Error(`Unexpected token: '${tk.value}'`);
  }

  parseDotCmd() {
    const cmd = this.advance().value;
    if (cmd === '.schema') {
      let table = null;
      if (this.peek().type === TT.ID || this.peek().type === TT.KW) table = this.advance().value;
      return { type: 'SCHEMA', table };
    }
    throw new Error(`Unknown command: ${cmd}`);
  }

  parseSelect() {
    this.expect(TT.KW, 'SELECT');
    const distinct = this.matchKW('DISTINCT');
    const columns = this.parseSelectList();
    let from = null, joins = [], where = null, groupBy = null, having = null, orderBy = null, limit = null, offset = null;
    if (this.matchKW('FROM')) {
      from = this.parseTableRef();
      joins = this.parseJoins();
    }
    if (this.matchKW('WHERE')) where = this.parseExpr();
    if (this.matchKW('GROUP')) { this.expect(TT.KW, 'BY'); groupBy = this.parseExprList(); }
    if (this.matchKW('HAVING')) having = this.parseExpr();
    if (this.matchKW('ORDER')) { this.expect(TT.KW, 'BY'); orderBy = this.parseOrderList(); }
    if (this.matchKW('LIMIT')) { limit = parseInt(this.expect(TT.NUM).value); }
    if (this.matchKW('OFFSET')) { offset = parseInt(this.expect(TT.NUM).value); }
    return { type:'SELECT', distinct, columns, from, joins, where, groupBy, having, orderBy, limit, offset };
  }

  parseSelectList() {
    const cols = [];
    do {
      if (this.at(TT.PUNC, '*')) { this.advance(); cols.push({ expr:{ type:'star' }, alias:null }); continue; }
      const expr = this.parseExpr();
      if (expr.type === 'column' && this.at(TT.PUNC, '.')) {
        this.advance();
        if (this.at(TT.PUNC, '*')) { this.advance(); cols.push({ expr:{ type:'table_star', table:expr.name }, alias:null }); continue; }
        const col = this.parseIdent();
        let alias = null;
        if (this.matchKW('AS')) alias = this.parseIdent();
        else if (this.peek().type === TT.ID && !this.atKW('FROM') && !this.atKW('WHERE') && !this.at(TT.PUNC,',') && !this.at(TT.PUNC,';') && !this.at(TT.EOF))
          alias = this.parseIdent();
        cols.push({ expr:{ type:'column', table:expr.name, name:col }, alias });
        continue;
      }
      let alias = null;
      if (this.matchKW('AS')) alias = this.parseIdent();
      else if (this.peek().type === TT.ID && !this.atKW('FROM') && !this.atKW('WHERE') && !this.atKW('GROUP') &&
               !this.atKW('ORDER') && !this.atKW('HAVING') && !this.atKW('LIMIT') && !this.at(TT.PUNC,',') &&
               !this.at(TT.PUNC,';') && !this.at(TT.EOF) && !this.atKW('INNER') && !this.atKW('LEFT') &&
               !this.atKW('JOIN') && !this.atKW('ON'))
        alias = this.parseIdent();
      cols.push({ expr, alias });
    } while (this.match(TT.PUNC, ','));
    return cols;
  }

  parseTableRef() {
    // Derived table: (SELECT ...) AS alias
    if (this.at(TT.PUNC, '(')) {
      this.advance();
      const sub = this.parseSelect();
      this.expect(TT.PUNC, ')');
      let alias = null;
      if (this.matchKW('AS')) alias = this.parseIdent();
      else if (this.peek().type === TT.ID) alias = this.parseIdent();
      if (!alias) throw new Error('Derived tables require an alias');
      return { table: null, subquery: sub, alias };
    }
    const name = this.parseIdent();
    let alias = null;
    if (this.matchKW('AS')) alias = this.parseIdent();
    else if (this.peek().type === TT.ID && !this.atKW('WHERE') && !this.atKW('SET') && !this.atKW('INNER') &&
             !this.atKW('LEFT') && !this.atKW('JOIN') && !this.atKW('ON') && !this.atKW('GROUP') &&
             !this.atKW('ORDER') && !this.atKW('HAVING') && !this.atKW('LIMIT') && !this.at(TT.PUNC,',') &&
             !this.at(TT.PUNC,';') && !this.at(TT.EOF) && !this.atKW('CROSS'))
      alias = this.parseIdent();
    return { table: name, alias };
  }

  parseJoins() {
    const joins = [];
    while (true) {
      let jtype = null;
      if (this.matchKW('INNER')) { jtype = 'INNER'; this.expect(TT.KW, 'JOIN'); }
      else if (this.matchKW('LEFT')) { this.matchKW('OUTER'); jtype = 'LEFT'; this.expect(TT.KW, 'JOIN'); }
      else if (this.matchKW('CROSS')) { jtype = 'CROSS'; this.expect(TT.KW, 'JOIN'); }
      else if (this.matchKW('JOIN')) { jtype = 'INNER'; }
      else break;
      const ref = this.parseTableRef();
      let on = null;
      if (this.matchKW('ON')) on = this.parseExpr();
      joins.push({ joinType: jtype, ...ref, on });
    }
    return joins;
  }

  parseOrderList() {
    const list = [];
    do {
      const expr = this.parseExpr();
      let dir = 'ASC';
      if (this.matchKW('ASC')) dir = 'ASC';
      else if (this.matchKW('DESC')) dir = 'DESC';
      list.push({ expr, dir });
    } while (this.match(TT.PUNC, ','));
    return list;
  }

  parseInsert() {
    this.expect(TT.KW, 'INSERT'); this.expect(TT.KW, 'INTO');
    const table = this.parseIdent();
    let columns = null;
    if (this.match(TT.PUNC, '(')) {
      columns = [];
      do { columns.push(this.parseIdent()); } while (this.match(TT.PUNC, ','));
      this.expect(TT.PUNC, ')');
    }
    // INSERT...SELECT
    if (this.atKW('SELECT')) {
      const select = this.parseSelect();
      return { type:'INSERT', table, columns, rows: null, select };
    }
    this.expect(TT.KW, 'VALUES');
    const rows = [];
    do {
      this.expect(TT.PUNC, '(');
      const vals = [];
      do { vals.push(this.parseExpr()); } while (this.match(TT.PUNC, ','));
      this.expect(TT.PUNC, ')');
      rows.push(vals);
    } while (this.match(TT.PUNC, ','));
    return { type:'INSERT', table, columns, rows, select: null };
  }

  parseUpdate() {
    this.expect(TT.KW, 'UPDATE');
    const table = this.parseIdent();
    this.expect(TT.KW, 'SET');
    const set = [];
    do {
      const col = this.parseIdent();
      this.expect(TT.OP, '=');
      const val = this.parseExpr();
      set.push({ column: col, value: val });
    } while (this.match(TT.PUNC, ','));
    let where = null;
    if (this.matchKW('WHERE')) where = this.parseExpr();
    return { type:'UPDATE', table, set, where };
  }

  parseDelete() {
    this.expect(TT.KW, 'DELETE'); this.expect(TT.KW, 'FROM');
    const table = this.parseIdent();
    let where = null;
    if (this.matchKW('WHERE')) where = this.parseExpr();
    return { type:'DELETE', table, where };
  }

  parseCreate() {
    this.expect(TT.KW, 'CREATE'); this.expect(TT.KW, 'TABLE');
    let ifNotExists = false;
    if (this.matchKW('IF')) { this.expect(TT.KW, 'NOT'); this.expect(TT.KW, 'EXISTS'); ifNotExists = true; }
    const table = this.parseIdent();
    this.expect(TT.PUNC, '(');
    const cols = [];
    do { cols.push(this.parseColDef()); } while (this.match(TT.PUNC, ','));
    this.expect(TT.PUNC, ')');
    return { type:'CREATE_TABLE', table, ifNotExists, columns: cols };
  }

  parseColDef() {
    const name = this.parseIdent();
    let dataType = 'TEXT';
    if (this.atKW('TEXT')||this.atKW('INTEGER')||this.atKW('REAL')||this.atKW('BOOLEAN')) dataType = this.advance().value;
    let pk = false, nn = false, dflt = null;
    while (true) {
      if (this.atKW('PRIMARY')) { this.advance(); this.expect(TT.KW,'KEY'); pk = true; nn = true; continue; }
      if (this.atKW('NOT')) { this.advance(); this.expect(TT.KW,'NULL'); nn = true; continue; }
      if (this.matchKW('DEFAULT')) { dflt = this.parsePrimary(); continue; }
      break;
    }
    return { name, dataType, primaryKey: pk, notNull: nn, default: dflt };
  }

  parseDrop() {
    this.expect(TT.KW,'DROP'); this.expect(TT.KW,'TABLE');
    let ifExists = false;
    if (this.matchKW('IF')) { this.expect(TT.KW,'EXISTS'); ifExists = true; }
    const table = this.parseIdent();
    return { type:'DROP_TABLE', table, ifExists };
  }

  parseAlter() {
    this.expect(TT.KW,'ALTER'); this.expect(TT.KW,'TABLE');
    const table = this.parseIdent();
    this.expect(TT.KW,'ADD');
    this.matchKW('COLUMN');
    const col = this.parseColDef();
    return { type:'ALTER_TABLE', table, action:'ADD_COLUMN', column: col };
  }

  parseExplain() { this.expect(TT.KW,'EXPLAIN'); return { type:'EXPLAIN', statement: this.parseStmt() }; }
  parseShow() { this.expect(TT.KW,'SHOW'); this.expect(TT.KW,'TABLES'); return { type:'SHOW_TABLES' }; }

  parseIdent() {
    const tk = this.advance();
    if (tk.type === TT.ID || tk.type === TT.KW) return tk.value;
    throw new Error(`Expected identifier but got '${tk.value}'`);
  }

  parseExprList() { const list = []; do { list.push(this.parseExpr()); } while (this.match(TT.PUNC,',')); return list; }
  parseExpr() { return this.parseOr(); }

  parseOr() {
    let left = this.parseAnd();
    while (this.matchKW('OR')) left = { type:'binary', op:'OR', left, right: this.parseAnd() };
    return left;
  }

  parseAnd() {
    let left = this.parseNot();
    while (this.matchKW('AND')) left = { type:'binary', op:'AND', left, right: this.parseNot() };
    return left;
  }

  parseNot() {
    if (this.matchKW('NOT')) return { type:'unary', op:'NOT', operand: this.parseNot() };
    return this.parseComparison();
  }

  parseComparison() {
    let left = this.parseAddition();
    if (this.atKW('IS')) {
      this.advance();
      const neg = this.matchKW('NOT');
      this.expect(TT.KW,'NULL');
      return { type:'is_null', expr: left, negated: neg };
    }
    if (this.atKW('NOT') && this.t[this.p+1] && (this.t[this.p+1].value === 'LIKE' || this.t[this.p+1].value === 'IN' || this.t[this.p+1].value === 'BETWEEN')) {
      this.advance();
      if (this.matchKW('LIKE')) return { type:'binary', op:'NOT LIKE', left, right: this.parseAddition() };
      if (this.matchKW('IN')) return this.parseIn(left, true);
      if (this.matchKW('BETWEEN')) return this.parseBetween(left, true);
    }
    if (this.matchKW('LIKE')) return { type:'binary', op:'LIKE', left, right: this.parseAddition() };
    if (this.matchKW('IN')) return this.parseIn(left, false);
    if (this.matchKW('BETWEEN')) return this.parseBetween(left, false);
    const ops = ['=','!=','<>','<','>','<=','>='];
    if (this.peek().type === TT.OP && ops.includes(this.peek().value)) {
      const op = this.advance().value === '<>' ? '!=' : this.t[this.p-1].value;
      return { type:'binary', op, left, right: this.parseAddition() };
    }
    return left;
  }

  parseIn(expr, neg) {
    this.expect(TT.PUNC,'(');
    const vals = [];
    do { vals.push(this.parseExpr()); } while (this.match(TT.PUNC,','));
    this.expect(TT.PUNC,')');
    return { type:'in', expr, values: vals, negated: neg };
  }

  parseBetween(expr, neg) {
    const low = this.parseAddition();
    this.expect(TT.KW,'AND');
    const high = this.parseAddition();
    return { type:'between', expr, low, high, negated: neg };
  }

  parseAddition() {
    let left = this.parseMultiplication();
    while (this.peek().type === TT.OP && (this.peek().value === '+' || this.peek().value === '-' || this.peek().value === '||'))
      left = { type:'binary', op: this.advance().value, left, right: this.parseMultiplication() };
    return left;
  }

  parseMultiplication() {
    let left = this.parseUnary();
    while ((this.peek().type === TT.OP && (this.peek().value === '/' || this.peek().value === '%')) ||
           (this.peek().type === TT.PUNC && this.peek().value === '*' && !this.isStarContext()))
      left = { type:'binary', op: this.advance().value, left, right: this.parseUnary() };
    return left;
  }

  isStarContext() {
    // Star is multiplication if preceded by a value-like token; it's SELECT * if preceded by keyword/comma
    if (this.p === 0) return true;
    const prev = this.t[this.p - 1];
    return prev.type === TT.KW || prev.type === TT.PUNC && (prev.value === ',' || prev.value === '(');
  }

  parseUnary() {
    if (this.peek().type === TT.OP && this.peek().value === '-') { this.advance(); return { type:'unary', op:'-', operand: this.parseUnary() }; }
    return this.parsePrimary();
  }

  parsePrimary() {
    const tk = this.peek();
    // Number
    if (tk.type === TT.NUM) { this.advance(); return { type:'number', value: parseFloat(tk.value) }; }
    // String
    if (tk.type === TT.STR) { this.advance(); return { type:'string', value: tk.value }; }
    // NULL
    if (this.atKW('NULL')) { this.advance(); return { type:'null' }; }
    // Boolean
    if (this.atKW('TRUE')) { this.advance(); return { type:'boolean', value: true }; }
    if (this.atKW('FALSE')) { this.advance(); return { type:'boolean', value: false }; }
    // Aggregate or scalar function
    if (tk.type === TT.KW && (AGGREGATE_FNS.has(tk.value) || SCALAR_FNS.has(tk.value))) {
      const fname = this.advance().value;
      this.expect(TT.PUNC,'(');
      if (AGGREGATE_FNS.has(fname)) {
        const distinct = this.matchKW('DISTINCT');
        if (this.at(TT.PUNC,'*')) { this.advance(); this.expect(TT.PUNC,')'); return { type:'function', name:fname, distinct, args:[{type:'star'}] }; }
        const args = this.parseExprList();
        this.expect(TT.PUNC,')');
        return { type:'function', name:fname, distinct, args };
      } else {
        const args = this.at(TT.PUNC,')') ? [] : this.parseExprList();
        this.expect(TT.PUNC,')');
        return { type:'function', name:fname, distinct:false, args };
      }
    }
    // CASE expression
    if (this.atKW('CASE')) { return this.parseCase(); }
    // Parenthesized expression or scalar subquery
    if (this.at(TT.PUNC,'(')) {
      this.advance();
      if (this.atKW('SELECT')) { const sub = this.parseSelect(); this.expect(TT.PUNC,')'); return { type:'subquery', statement: sub }; }
      const e = this.parseExpr(); this.expect(TT.PUNC,')'); return e;
    }
    // Star
    if (this.at(TT.PUNC,'*')) { this.advance(); return { type:'star' }; }
    // Identifier or qualified column (table.column)
    if (tk.type === TT.ID || tk.type === TT.KW) {
      const name = this.advance().value;
      if (this.at(TT.PUNC,'.') && this.t[this.p+1] && this.t[this.p+1].type !== TT.DOT_CMD) {
        this.advance();
        if (this.at(TT.PUNC,'*')) { this.advance(); return { type:'table_star', table: name }; }
        const col = this.parseIdent();
        return { type:'column', table: name, name: col };
      }
      // Check if it's a function call
      if (this.at(TT.PUNC,'(')) {
        this.advance();
        const args = this.at(TT.PUNC,')') ? [] : this.parseExprList();
        this.expect(TT.PUNC,')');
        return { type:'function', name: name.toUpperCase(), distinct:false, args };
      }
      return { type:'column', table: null, name };
    }
    throw new Error(`Unexpected token: '${tk.value}' (${tk.type})`);
  }

  parseCase() {
    this.expect(TT.KW,'CASE');
    const whens = [];
    let elseExpr = null;
    while (this.matchKW('WHEN')) {
      const cond = this.parseExpr();
      this.expect(TT.KW,'THEN');
      const then = this.parseExpr();
      whens.push({ cond, then });
    }
    if (this.matchKW('ELSE')) elseExpr = this.parseExpr();
    this.expect(TT.KW,'END');
    return { type:'case', whens, else: elseExpr };
  }
}

// ── Database Engine (Storage + Executor) ─────────────────
class Database {
  constructor() {
    this.tables = {};
    this.load();
  }

  getTable(name) {
    const n = Object.keys(this.tables).find(k => k.toUpperCase() === name.toUpperCase());
    if (!n) throw new Error(`Table '${name}' does not exist`);
    return { name: n, ...this.tables[n] };
  }

  execute(sql) {
    const t0 = performance.now();
    const tokens = new Tokenizer(sql).tokenize();
    const stmts = new Parser(tokens).parse();
    let result = null;
    for (const stmt of stmts) result = this.exec(stmt);
    const ms = (performance.now() - t0).toFixed(1);
    if (result) result.time = ms;
    return result;
  }

  exec(stmt) {
    switch (stmt.type) {
      case 'SELECT': return this.execSelect(stmt);
      case 'INSERT': return this.execInsert(stmt);
      case 'UPDATE': return this.execUpdate(stmt);
      case 'DELETE': return this.execDelete(stmt);
      case 'CREATE_TABLE': return this.execCreate(stmt);
      case 'DROP_TABLE': return this.execDrop(stmt);
      case 'ALTER_TABLE': return this.execAlter(stmt);
      case 'EXPLAIN': return this.execExplain(stmt);
      case 'SHOW_TABLES': return this.execShowTables();
      case 'SCHEMA': return this.execSchema(stmt);
      default: throw new Error(`Unknown statement type: ${stmt.type}`);
    }
  }

  // ── CREATE TABLE ──
  execCreate(stmt) {
    const name = stmt.table;
    if (this.tables[name.toUpperCase()] || this.tables[name]) {
      if (stmt.ifNotExists) return { message: `Table '${name}' already exists (skipped)`, columns:[], rows:[] };
      throw new Error(`Table '${name}' already exists`);
    }
    this.tables[name] = { columns: stmt.columns.map(c => ({
      name: c.name, dataType: c.dataType, primaryKey: c.primaryKey, notNull: c.notNull,
      default: c.default ? this.evalExpr(c.default, {}, {}) : null
    })), rows: [] };
    this.save();
    return { message: `Table '${name}' created`, columns:[], rows:[] };
  }

  // ── DROP TABLE ──
  execDrop(stmt) {
    const n = Object.keys(this.tables).find(k => k.toUpperCase() === stmt.table.toUpperCase());
    if (!n) {
      if (stmt.ifExists) return { message: `Table '${stmt.table}' does not exist (skipped)`, columns:[], rows:[] };
      throw new Error(`Table '${stmt.table}' does not exist`);
    }
    delete this.tables[n];
    this.save();
    return { message: `Table '${n}' dropped`, columns:[], rows:[] };
  }

  // ── ALTER TABLE ADD COLUMN ──
  execAlter(stmt) {
    const tbl = this.getTable(stmt.table);
    const col = stmt.column;
    if (tbl.columns && tbl.columns.find(c => c.name.toUpperCase() === col.name.toUpperCase()))
      throw new Error(`Column '${col.name}' already exists in '${tbl.name}'`);
    const tblData = this.tables[tbl.name];
    const dflt = col.default ? this.evalExpr(col.default, {}, {}) : null;
    tblData.columns.push({ name: col.name, dataType: col.dataType, primaryKey: col.primaryKey, notNull: col.notNull, default: dflt });
    for (const row of tblData.rows) row[col.name] = dflt;
    this.save();
    return { message: `Column '${col.name}' added to '${tbl.name}'`, columns:[], rows:[] };
  }

  // ── INSERT ──
  execInsert(stmt) {
    const tbl = this.getTable(stmt.table);
    const tblData = this.tables[tbl.name];
    const colNames = stmt.columns || tblData.columns.map(c => c.name);
    let inserted = 0;

    // INSERT...SELECT
    if (stmt.select) {
      const result = this.execSelect(stmt.select);
      for (const srcRow of result.rows) {
        const vals = result.columns.map(c => srcRow[c]);
        if (vals.length !== colNames.length) throw new Error(`SELECT returns ${vals.length} columns, expected ${colNames.length}`);
        const row = {};
        for (const cd of tblData.columns) row[cd.name] = cd.default !== null && cd.default !== undefined ? cd.default : null;
        for (let i = 0; i < colNames.length; i++) row[colNames[i]] = vals[i];
        for (const cd of tblData.columns) {
          if (cd.notNull && (row[cd.name] === null || row[cd.name] === undefined))
            throw new Error(`NOT NULL constraint failed: column '${cd.name}'`);
        }
        tblData.rows.push(row);
        inserted++;
      }
      this.save();
      return { message: `${inserted} row(s) inserted`, columns:[], rows:[] };
    }

    for (const valExprs of stmt.rows) {
      if (valExprs.length !== colNames.length) throw new Error(`Expected ${colNames.length} values, got ${valExprs.length}`);
      const row = {};
      for (const cd of tblData.columns) row[cd.name] = cd.default !== null && cd.default !== undefined ? cd.default : null;
      for (let i = 0; i < colNames.length; i++) {
        const cn = colNames[i];
        if (!tblData.columns.find(c => c.name.toUpperCase() === cn.toUpperCase()))
          throw new Error(`Column '${cn}' not found in '${tbl.name}'`);
        row[cn] = this.evalExpr(valExprs[i], {}, {});
      }
      // Check constraints
      for (const cd of tblData.columns) {
        if (cd.primaryKey && row[cd.name] != null) {
          if (tblData.rows.some(r => r[cd.name] === row[cd.name]))
            throw new Error(`PRIMARY KEY constraint failed: duplicate value '${row[cd.name]}' for column '${cd.name}'`);
        }
        if (cd.notNull && (row[cd.name] === null || row[cd.name] === undefined))
          throw new Error(`NOT NULL constraint failed: column '${cd.name}'`);
      }
      tblData.rows.push(row);
      inserted++;
    }
    this.save();
    return { message: `${inserted} row(s) inserted`, columns:[], rows:[] };
  }

  // ── UPDATE ──
  execUpdate(stmt) {
    const tbl = this.getTable(stmt.table);
    const tblData = this.tables[tbl.name];
    const aliases = {};
    let updated = 0;
    for (const row of tblData.rows) {
      const qrow = this.qualifyRow(row, tbl.name);
      if (stmt.where && !this.evalExpr(stmt.where, qrow, aliases)) continue;
      for (const s of stmt.set) {
        const col = tblData.columns.find(c => c.name.toUpperCase() === s.column.toUpperCase());
        if (!col) throw new Error(`Column '${s.column}' not found`);
        row[col.name] = this.evalExpr(s.value, qrow, aliases);
      }
      updated++;
    }
    this.save();
    return { message: `${updated} row(s) updated`, columns:[], rows:[] };
  }

  // ── DELETE ──
  execDelete(stmt) {
    const tbl = this.getTable(stmt.table);
    const tblData = this.tables[tbl.name];
    const before = tblData.rows.length;
    const aliases = {};
    tblData.rows = tblData.rows.filter(row => {
      const qrow = this.qualifyRow(row, tbl.name);
      return stmt.where ? this.evalExpr(stmt.where, qrow, aliases) : false;
    });
    const deleted = before - tblData.rows.length;
    this.save();
    return { message: `${deleted} row(s) deleted`, columns:[], rows:[] };
  }

  // ── SELECT (the big one) ──
  execSelect(stmt) {
    // 1. FROM
    let rows = [];
    let colDefs = [];
    const aliases = {};

    if (stmt.from) {
      if (stmt.from.subquery) {
        // Derived table in FROM
        const sub = this.execSelect(stmt.from.subquery);
        const alias = stmt.from.alias;
        aliases[alias.toUpperCase()] = alias;
        colDefs = sub.columns.map(c => ({ table: alias, name: c }));
        rows = sub.rows.map(r => {
          const qr = {};
          for (const c of sub.columns) { qr[alias + '.' + c] = r[c]; qr[c] = r[c]; }
          return qr;
        });
      } else {
        const tbl = this.getTable(stmt.from.table);
        const tblData = this.tables[tbl.name];
        const alias = stmt.from.alias || tbl.name;
        aliases[alias.toUpperCase()] = tbl.name;
        colDefs = tblData.columns.map(c => ({ table: tbl.name, name: c.name }));
        rows = tblData.rows.map(r => this.qualifyRow(r, tbl.name));
      }

      // 2. JOINs
      for (const join of stmt.joins) {
        let jrows, jColDefs, jtableName;

        if (join.subquery) {
          // Derived table join
          const sub = this.execSelect(join.subquery);
          jtableName = join.alias;
          aliases[join.alias.toUpperCase()] = join.alias;
          jColDefs = sub.columns.map(c => ({ table: join.alias, name: c }));
          jrows = sub.rows.map(r => {
            const qr = {};
            for (const c of sub.columns) { qr[join.alias + '.' + c] = r[c]; qr[c] = r[c]; }
            return qr;
          });
        } else {
          const jtbl = this.getTable(join.table);
          const jdata = this.tables[jtbl.name];
          jtableName = jtbl.name;
          const jalias = join.alias || jtbl.name;
          aliases[jalias.toUpperCase()] = jtbl.name;
          jColDefs = jdata.columns.map(c => ({ table: jtbl.name, name: c.name }));
          jrows = jdata.rows.map(r => this.qualifyRow(r, jtbl.name));
        }

        const newRows = [];
        if (join.joinType === 'CROSS') {
          for (const lr of rows) {
            for (const rr of jrows) newRows.push({ ...lr, ...rr });
          }
        } else {
          for (const lr of rows) {
            let matched = false;
            for (const rr of jrows) {
              const combined = { ...lr, ...rr };
              if (!join.on || this.evalExpr(join.on, combined, aliases)) {
                newRows.push(combined);
                matched = true;
              }
            }
            if (!matched && join.joinType === 'LEFT') {
              const nullRight = {};
              for (const cd of jColDefs) nullRight[cd.table + '.' + cd.name] = null;
              newRows.push({ ...lr, ...nullRight });
            }
          }
        }
        rows = newRows;
        colDefs = colDefs.concat(jColDefs);
      }
    }

    // If no FROM clause, provide a single empty row for evaluation (e.g., SELECT with scalar subqueries)
    if (!stmt.from) rows = [{}];

    // 3. WHERE
    if (stmt.where) rows = rows.filter(r => this.evalExpr(stmt.where, r, aliases));

    // 4. GROUP BY
    if (stmt.groupBy) {
      const groups = new Map();
      for (const row of rows) {
        const key = stmt.groupBy.map(e => JSON.stringify(this.evalExpr(e, row, aliases))).join('|');
        if (!groups.has(key)) groups.set(key, []);
        groups.get(key).push(row);
      }
      // Build grouped result
      const groupedRows = [];
      for (const [, groupRows] of groups) {
        const rep = groupRows[0];
        const grow = { __group: groupRows, ...rep };
        groupedRows.push(grow);
      }
      rows = groupedRows;
    }

    // 5. SELECT columns — resolve expressions
    const resultCols = [];
    const resultRows = [];
    const expandedCols = this.expandSelectCols(stmt.columns, colDefs, aliases);

    for (const row of rows) {
      const rr = {};
      for (let i = 0; i < expandedCols.length; i++) {
        const { expr, alias } = expandedCols[i];
        const colName = alias || this.exprLabel(expr);
        if (resultRows.length === 0) resultCols.push(colName);
        rr[colName] = this.evalExpr(expr, row, aliases, row.__group);
      }
      resultRows.push(rr);
    }
    if (resultRows.length === 0) {
      for (const { expr, alias } of expandedCols) resultCols.push(alias || this.exprLabel(expr));
    }

    // 6. HAVING
    let finalRows = resultRows;
    if (stmt.having) {
      const havingRows = [];
      for (let i = 0; i < rows.length; i++) {
        if (this.evalExpr(stmt.having, rows[i], aliases, rows[i].__group)) havingRows.push(finalRows[i]);
      }
      finalRows = havingRows;
    }

    // 7. DISTINCT
    if (stmt.distinct) {
      const seen = new Set();
      finalRows = finalRows.filter(r => {
        const key = JSON.stringify(resultCols.map(c => r[c]));
        if (seen.has(key)) return false;
        seen.add(key);
        return true;
      });
    }

    // 8. ORDER BY
    if (stmt.orderBy) {
      finalRows.sort((a, b) => {
        for (const { expr, dir } of stmt.orderBy) {
          const label = this.exprLabel(expr);
          let va, vb;
          if (resultCols.includes(label)) { va = a[label]; vb = b[label]; }
          else {
            const idx = rows.findIndex(r => resultRows.indexOf(a) >= 0);
            va = a[label]; vb = b[label];
          }
          if (va == null && vb == null) continue;
          if (va == null) return dir === 'ASC' ? 1 : -1;
          if (vb == null) return dir === 'ASC' ? -1 : 1;
          if (va < vb) return dir === 'ASC' ? -1 : 1;
          if (va > vb) return dir === 'ASC' ? 1 : -1;
        }
        return 0;
      });
    }

    // 9. LIMIT / OFFSET
    const off = stmt.offset || 0;
    if (stmt.limit != null) finalRows = finalRows.slice(off, off + stmt.limit);
    else if (off > 0) finalRows = finalRows.slice(off);

    return { columns: resultCols, rows: finalRows };
  }

  expandSelectCols(selectCols, colDefs, aliases) {
    const result = [];
    for (const sc of selectCols) {
      if (sc.expr.type === 'star') {
        for (const cd of colDefs) result.push({ expr:{ type:'column', table:cd.table, name:cd.name }, alias: cd.name });
      } else if (sc.expr.type === 'table_star') {
        const tname = this.resolveAlias(sc.expr.table, aliases);
        for (const cd of colDefs) {
          if (cd.table.toUpperCase() === tname.toUpperCase()) result.push({ expr:{ type:'column', table:cd.table, name:cd.name }, alias: cd.name });
        }
      } else {
        result.push(sc);
      }
    }
    return result;
  }

  resolveAlias(name, aliases) {
    return aliases[name.toUpperCase()] || name;
  }

  qualifyRow(row, tableName) {
    const qr = {};
    for (const [k, v] of Object.entries(row)) {
      if (k === '__group') continue;
      qr[tableName + '.' + k] = v;
      if (!k.includes('.')) qr[k] = v;
    }
    return qr;
  }

  exprLabel(expr) {
    if (!expr) return '?';
    if (expr.type === 'column') return expr.table ? expr.table + '.' + expr.name : expr.name;
    if (expr.type === 'function') return expr.name + '(' + expr.args.map(a => this.exprLabel(a)).join(',') + ')';
    if (expr.type === 'star') return '*';
    if (expr.type === 'number' || expr.type === 'string' || expr.type === 'boolean') return String(expr.value);
    if (expr.type === 'null') return 'NULL';
    if (expr.type === 'binary') return this.exprLabel(expr.left) + ' ' + expr.op + ' ' + this.exprLabel(expr.right);
    if (expr.type === 'subquery') return '(SELECT...)';
    return '?';
  }

  // ── Expression Evaluator ──
  evalExpr(expr, row, aliases, group) {
    switch (expr.type) {
      case 'number': return expr.value;
      case 'string': return expr.value;
      case 'boolean': return expr.value;
      case 'null': return null;

      case 'column': {
        const { table, name } = expr;
        if (table) {
          const real = this.resolveAlias(table, aliases);
          const key = real + '.' + name;
          if (key in row) return row[key];
          const keyUpper = Object.keys(row).find(k => k.toUpperCase() === key.toUpperCase());
          if (keyUpper) return row[keyUpper];
        }
        if (name in row) return row[name];
        const nameUpper = Object.keys(row).find(k => {
          const parts = k.split('.');
          return parts[parts.length-1].toUpperCase() === name.toUpperCase();
        });
        if (nameUpper) return row[nameUpper];
        return null;
      }

      case 'binary': {
        if (expr.op === 'AND') return this.evalExpr(expr.left, row, aliases, group) && this.evalExpr(expr.right, row, aliases, group);
        if (expr.op === 'OR') return this.evalExpr(expr.left, row, aliases, group) || this.evalExpr(expr.right, row, aliases, group);
        const lv = this.evalExpr(expr.left, row, aliases, group);
        const rv = this.evalExpr(expr.right, row, aliases, group);
        if (expr.op === '||') return String(lv ?? '') + String(rv ?? '');
        if (expr.op === '+') return (lv ?? 0) + (rv ?? 0);
        if (expr.op === '-') return (lv ?? 0) - (rv ?? 0);
        if (expr.op === '*') return (lv ?? 0) * (rv ?? 0);
        if (expr.op === '/') return rv === 0 ? null : (lv ?? 0) / rv;
        if (expr.op === '%') return rv === 0 ? null : (lv ?? 0) % rv;
        if (lv === null || rv === null) return expr.op === '!=' ? (lv !== rv) : false;
        switch (expr.op) {
          case '=': return lv == rv;
          case '!=': return lv != rv;
          case '<': return lv < rv;
          case '>': return lv > rv;
          case '<=': return lv <= rv;
          case '>=': return lv >= rv;
          case 'LIKE': return this.matchLike(String(lv), String(rv));
          case 'NOT LIKE': return !this.matchLike(String(lv), String(rv));
        }
        return null;
      }

      case 'unary':
        if (expr.op === '-') return -(this.evalExpr(expr.operand, row, aliases, group) ?? 0);
        if (expr.op === 'NOT') return !this.evalExpr(expr.operand, row, aliases, group);
        return null;

      case 'is_null': {
        const v = this.evalExpr(expr.expr, row, aliases, group);
        return expr.negated ? v !== null : v === null;
      }

      case 'in': {
        const v = this.evalExpr(expr.expr, row, aliases, group);
        const vals = expr.values.map(e => this.evalExpr(e, row, aliases, group));
        const found = vals.some(iv => iv == v);
        return expr.negated ? !found : found;
      }

      case 'between': {
        const v = this.evalExpr(expr.expr, row, aliases, group);
        const lo = this.evalExpr(expr.low, row, aliases, group);
        const hi = this.evalExpr(expr.high, row, aliases, group);
        const inRange = v >= lo && v <= hi;
        return expr.negated ? !inRange : inRange;
      }

      case 'function': return this.evalFunction(expr, row, aliases, group);

      case 'subquery': {
        const result = this.execSelect(expr.statement);
        if (result.rows.length === 0) return null;
        const firstCol = result.columns[0];
        return result.rows[0][firstCol];
      }

      case 'case': {
        for (const w of expr.whens) {
          if (this.evalExpr(w.cond, row, aliases, group)) return this.evalExpr(w.then, row, aliases, group);
        }
        return expr.else ? this.evalExpr(expr.else, row, aliases, group) : null;
      }

      case 'star': return '*';
      default: return null;
    }
  }

  evalFunction(expr, row, aliases, group) {
    const fn = expr.name;
    const args = expr.args;

    // Aggregate functions
    if (AGGREGATE_FNS.has(fn)) {
      const grp = group || row.__group || [row];
      if (fn === 'COUNT') {
        if (args[0] && args[0].type === 'star') return grp.length;
        let vals = grp.map(r => this.evalExpr(args[0], r, aliases));
        if (expr.distinct) vals = [...new Set(vals)];
        return vals.filter(v => v !== null).length;
      }
      let vals = grp.map(r => this.evalExpr(args[0], r, aliases));
      if (expr.distinct) vals = [...new Set(vals)];
      vals = vals.filter(v => v !== null).map(Number);
      if (vals.length === 0) return fn === 'COUNT' ? 0 : null;
      switch (fn) {
        case 'SUM': return vals.reduce((a, b) => a + b, 0);
        case 'AVG': return vals.reduce((a, b) => a + b, 0) / vals.length;
        case 'MIN': return Math.min(...vals);
        case 'MAX': return Math.max(...vals);
      }
    }

    // Scalar functions
    const evArgs = args.map(a => this.evalExpr(a, row, aliases, group));
    switch (fn) {
      case 'UPPER': return evArgs[0] != null ? String(evArgs[0]).toUpperCase() : null;
      case 'LOWER': return evArgs[0] != null ? String(evArgs[0]).toLowerCase() : null;
      case 'LENGTH': return evArgs[0] != null ? String(evArgs[0]).length : null;
      case 'ABS': return evArgs[0] != null ? Math.abs(Number(evArgs[0])) : null;
      case 'ROUND': return evArgs[0] != null ? Math.round(Number(evArgs[0]) * Math.pow(10, evArgs[1]||0)) / Math.pow(10, evArgs[1]||0) : null;
      case 'SUBSTR': return evArgs[0] != null ? String(evArgs[0]).substring((evArgs[1]||1)-1, evArgs[2] ? (evArgs[1]||1)-1+(evArgs[2]) : undefined) : null;
      case 'REPLACE': return evArgs[0] != null ? String(evArgs[0]).split(String(evArgs[1])).join(String(evArgs[2])) : null;
      case 'TRIM': return evArgs[0] != null ? String(evArgs[0]).trim() : null;
      case 'TYPEOF': return evArgs[0] === null ? 'null' : typeof evArgs[0];
      case 'COALESCE': case 'IFNULL': return evArgs.find(v => v !== null) ?? null;
    }
    throw new Error(`Unknown function: ${fn}`);
  }

  matchLike(str, pattern) {
    const regex = new RegExp('^' + pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
      .replace(/%/g, '.*').replace(/_/g, '.') + '$', 'i');
    // Undo double-escaping of our wildcards
    return new RegExp('^' + pattern.split('').map(c => {
      if (c === '%') return '.*';
      if (c === '_') return '.';
      return c.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }).join('') + '$', 'i').test(str);
  }

  // ── EXPLAIN ──
  execExplain(stmt) {
    const plan = this.buildPlan(stmt.statement, 0);
    return { columns:[], rows:[], plan };
  }

  buildPlan(stmt, depth) {
    const pad = '  '.repeat(depth);
    let lines = [];
    if (stmt.type === 'SELECT') {
      if (stmt.limit != null) lines.push(pad + '├─ LIMIT ' + stmt.limit + (stmt.offset ? ' OFFSET ' + stmt.offset : ''));
      if (stmt.orderBy) lines.push(pad + '├─ ORDER BY ' + stmt.orderBy.map(o => this.exprLabel(o.expr)+' '+o.dir).join(', '));
      if (stmt.distinct) lines.push(pad + '├─ DISTINCT');
      if (stmt.having) lines.push(pad + '├─ HAVING filter');
      if (stmt.groupBy) lines.push(pad + '├─ GROUP BY ' + stmt.groupBy.map(e => this.exprLabel(e)).join(', '));
      lines.push(pad + '├─ SELECT ' + stmt.columns.map(c => c.alias || this.exprLabel(c.expr)).join(', '));
      if (stmt.where) lines.push(pad + '├─ WHERE filter');
      for (let i = stmt.joins.length - 1; i >= 0; i--) {
        const j = stmt.joins[i];
        lines.push(pad + '├─ ' + j.joinType + ' JOIN ' + j.table + (j.alias ? ' AS ' + j.alias : ''));
      }
      if (stmt.from) lines.push(pad + '└─ SCAN TABLE ' + stmt.from.table + (stmt.from.alias ? ' AS ' + stmt.from.alias : ''));
    } else {
      lines.push(pad + '└─ ' + stmt.type);
    }
    return lines.join('\n');
  }

  // ── SHOW TABLES ──
  execShowTables() {
    const names = Object.keys(this.tables).sort();
    return { columns:['table_name'], rows: names.map(n => ({ table_name: n })) };
  }

  // ── .schema ──
  execSchema(stmt) {
    if (stmt.table) {
      const tbl = this.getTable(stmt.table);
      const tblData = this.tables[tbl.name];
      const ddl = 'CREATE TABLE ' + tbl.name + ' (\n' + tblData.columns.map(c => {
        let s = '  ' + c.name + ' ' + c.dataType;
        if (c.primaryKey) s += ' PRIMARY KEY';
        if (c.notNull && !c.primaryKey) s += ' NOT NULL';
        if (c.default != null) s += ' DEFAULT ' + this.quoteLiteral(c.default);
        return s;
      }).join(',\n') + '\n);';
      return { columns:[], rows:[], message: ddl };
    }
    const lines = Object.keys(this.tables).sort().map(name => {
      const t = this.tables[name];
      return 'CREATE TABLE ' + name + ' (\n' + t.columns.map(c => {
        let s = '  ' + c.name + ' ' + c.dataType;
        if (c.primaryKey) s += ' PRIMARY KEY';
        if (c.notNull && !c.primaryKey) s += ' NOT NULL';
        if (c.default != null) s += ' DEFAULT ' + this.quoteLiteral(c.default);
        return s;
      }).join(',\n') + '\n);';
    });
    return { columns:[], rows:[], message: lines.join('\n\n') };
  }

  quoteLiteral(v) {
    if (v === null) return 'NULL';
    if (typeof v === 'string') return "'" + v.replace(/'/g, "''") + "'";
    return String(v);
  }

  // ── Persistence ──
  save() {
    try { localStorage.setItem('rappterzoo-sqlstudio-db', JSON.stringify(this.tables)); } catch(e) {}
  }

  load() {
    try {
      const d = localStorage.getItem('rappterzoo-sqlstudio-db');
      if (d) { this.tables = JSON.parse(d); return true; }
    } catch(e) {}
    return false;
  }

  // ── Export SQL ──
  exportSQL() {
    const lines = [];
    for (const [name, tbl] of Object.entries(this.tables)) {
      lines.push('CREATE TABLE ' + name + ' (');
      lines.push(tbl.columns.map(c => {
        let s = '  ' + c.name + ' ' + c.dataType;
        if (c.primaryKey) s += ' PRIMARY KEY';
        if (c.notNull && !c.primaryKey) s += ' NOT NULL';
        if (c.default != null) s += ' DEFAULT ' + this.quoteLiteral(c.default);
        return s;
      }).join(',\n'));
      lines.push(');\n');
      for (const row of tbl.rows) {
        const vals = tbl.columns.map(c => this.quoteLiteral(row[c.name]));
        lines.push('INSERT INTO ' + name + ' VALUES (' + vals.join(', ') + ');');
      }
      lines.push('');
    }
    return lines.join('\n');
  }

  // ── Export CSV ──
  exportCSV(columns, rows) {
    const esc = v => {
      if (v === null || v === undefined) return '';
      const s = String(v);
      return s.includes(',') || s.includes('"') || s.includes('\n') ? '"' + s.replace(/"/g, '""') + '"' : s;
    };
    const header = columns.map(esc).join(',');
    const body = rows.map(r => columns.map(c => esc(r[c])).join(',')).join('\n');
    return header + '\n' + body;
  }

  // ── Import SQL ──
  importSQL(sql) {
    const tokens = new Tokenizer(sql).tokenize();
    const stmts = new Parser(tokens).parse();
    let count = 0;
    for (const stmt of stmts) { this.exec(stmt); count++; }
    return count;
  }
}

// ── UI Controller ────────────────────────────────────────
const SHOWCASE = [
  { title: '1. Social Graph', desc: 'Who replies to whom most?',
    sql: `SELECT u1.username AS commenter, u2.username AS author, COUNT(*) AS interactions\nFROM comments c\nINNER JOIN users u1 ON c.user_id = u1.id\nINNER JOIN posts p ON c.post_id = p.id\nINNER JOIN users u2 ON p.user_id = u2.id\nWHERE u1.id != u2.id\nGROUP BY u1.username, u2.username\nORDER BY interactions DESC;` },
  { title: '2. Viral Score', desc: 'Engagement per view, ranked',
    sql: `SELECT p.title, u.username,\n  p.views, COUNT(c.id) AS comments,\n  ROUND(COUNT(c.id) * 1000 / p.views) AS engagement_per_1k_views\nFROM posts p\nINNER JOIN users u ON p.user_id = u.id\nLEFT JOIN comments c ON c.post_id = p.id\nGROUP BY p.id, p.title, u.username, p.views\nORDER BY engagement_per_1k_views DESC\nLIMIT 5;` },
  { title: '3. The Lurkers', desc: 'Users who comment but never post',
    sql: `SELECT DISTINCT u.username, u.email\nFROM users u\nINNER JOIN comments c ON c.user_id = u.id\nWHERE u.id NOT IN (SELECT DISTINCT user_id FROM posts)\nORDER BY u.username;` },
  { title: '4. EXPLAIN', desc: 'Query plan for a 4-table join',
    sql: `EXPLAIN SELECT u.username, cat.name, COUNT(*) AS posts\nFROM users u\nINNER JOIN posts p ON u.id = p.user_id\nINNER JOIN post_categories pc ON p.id = pc.post_id\nINNER JOIN categories cat ON pc.category_id = cat.id\nWHERE p.views > 100\nGROUP BY u.username, cat.name\nHAVING COUNT(*) >= 1\nORDER BY posts DESC\nLIMIT 10;` },
  { title: '5. CASE Personas', desc: 'Dynamic tier labels from bio length',
    sql: `SELECT username, bio,\n  CASE\n    WHEN bio IS NULL THEN '\u{1F47B} Ghost'\n    WHEN LENGTH(bio) > 30 THEN '\u{1F4DD} Storyteller'\n    WHEN LENGTH(bio) > 15 THEN '\u{1F4AC} Chatty'\n    ELSE '\u{1F92B} Minimalist'\n  END AS persona\nFROM users\nORDER BY persona;` },
  { title: '6. Power Law', desc: 'Zipf distribution with ASCII bar chart',
    sql: `SELECT title,\n  views,\n  ROUND(views * 100 / 2340) AS pct_of_top,\n  SUBSTR('\u{2588}\u{2588}\u{2588}\u{2588}\u{2588}\u{2588}\u{2588}\u{2588}\u{2588}\u{2588}\u{2588}\u{2588}\u{2588}\u{2588}\u{2588}\u{2588}\u{2588}\u{2588}\u{2588}\u{2588}', 1, views * 20 / 2340) AS bar\nFROM posts\nORDER BY views DESC;` },
  { title: '7. Cross-Pollination', desc: 'Posts spanning multiple categories',
    sql: `SELECT p.title, COUNT(*) AS num_categories\nFROM posts p\nINNER JOIN post_categories pc ON p.id = pc.post_id\nGROUP BY p.title\nHAVING num_categories > 1\nORDER BY num_categories DESC;` },
  { title: '8. DDL Flex', desc: 'CREATE + INSERT + ALTER in one shot',
    sql: `CREATE TABLE IF NOT EXISTS leaderboard (rank INTEGER PRIMARY KEY, username TEXT NOT NULL, score REAL NOT NULL, badge TEXT DEFAULT 'bronze');\nINSERT INTO leaderboard VALUES (1, 'alice', 98.5, 'gold');\nINSERT INTO leaderboard VALUES (2, 'eve', 87.2, 'silver');\nINSERT INTO leaderboard VALUES (3, 'bob', 76.0, 'bronze');\nALTER TABLE leaderboard ADD COLUMN streak INTEGER DEFAULT 0;\nSELECT * FROM leaderboard;` },
  { title: '9. Self-Join', desc: 'Users who joined the same month',
    sql: `SELECT a.username AS user_a, b.username AS user_b, SUBSTR(a.created_at, 1, 7) AS month\nFROM users a\nINNER JOIN users b ON SUBSTR(a.created_at, 1, 7) = SUBSTR(b.created_at, 1, 7)\nWHERE a.id < b.id\nORDER BY month;` },
  { title: '10. The Everything Query', desc: '7 SQL features in one statement',
    sql: `SELECT DISTINCT\n  u.username,\n  UPPER(SUBSTR(u.username, 1, 1)) || LOWER(SUBSTR(u.username, 2, LENGTH(u.username))) AS display_name,\n  COUNT(DISTINCT p.id) AS posts,\n  COUNT(DISTINCT c.id) AS comments_received,\n  COALESCE(SUM(p.views), 0) AS total_views,\n  CASE WHEN COUNT(p.id) > 3 THEN '\u{1F525} Prolific' WHEN COUNT(p.id) > 0 THEN '\u{270D}\u{FE0F} Active' ELSE '\u{1F440} Reader' END AS role,\n  ROUND(COALESCE(SUM(p.views), 0) / CASE WHEN COUNT(p.id) = 0 THEN 1 ELSE COUNT(p.id) END) AS avg_views\nFROM users u\nLEFT JOIN posts p ON u.id = p.user_id\nLEFT JOIN comments c ON c.post_id = p.id\nWHERE u.created_at BETWEEN '2025-01-01' AND '2025-12-31'\nGROUP BY u.username\nHAVING total_views >= 0\nORDER BY total_views DESC\nLIMIT 8 OFFSET 0;` },
  { title: '11. Influence Score', desc: 'Recursive social rank via posts × engagement',
    sql: `SELECT u.username,\n  COUNT(DISTINCT p.id) AS posts,\n  COUNT(DISTINCT c.id) AS comments_on_their_work,\n  COUNT(DISTINCT p.id) * COUNT(DISTINCT c.id) AS influence_score,\n  CASE\n    WHEN COUNT(DISTINCT p.id) * COUNT(DISTINCT c.id) > 50 THEN '\u{1F451} Thought Leader'\n    WHEN COUNT(DISTINCT p.id) * COUNT(DISTINCT c.id) > 20 THEN '\u{2B50} Rising Star'\n    WHEN COUNT(DISTINCT p.id) > 0 THEN '\u{1F331} Contributor'\n    ELSE '\u{1F47B} Ghost'\n  END AS rank\nFROM users u\nLEFT JOIN posts p ON u.id = p.user_id\nLEFT JOIN comments c ON c.post_id = p.id AND c.user_id != u.id\nGROUP BY u.username\nORDER BY influence_score DESC;` },
  { title: '12. Conversation Heatmap', desc: 'Which posts spark the most back-and-forth?',
    sql: `SELECT p.title,\n  COUNT(DISTINCT c.user_id) AS unique_voices,\n  COUNT(c.id) AS total_replies,\n  ROUND(COUNT(c.id) * 100 / COUNT(DISTINCT c.user_id)) AS avg_replies_per_person,\n  SUBSTR('\u{1F525}\u{1F525}\u{1F525}\u{1F525}\u{1F525}\u{1F525}\u{1F525}\u{1F525}\u{1F525}\u{1F525}', 1, COUNT(DISTINCT c.user_id)) AS heat\nFROM posts p\nINNER JOIN comments c ON c.post_id = p.id\nGROUP BY p.title\nHAVING unique_voices > 1\nORDER BY unique_voices DESC, total_replies DESC;` },
  { title: '13. Ghost Network', desc: 'Who co-comments on the same threads?',
    sql: `SELECT u1.username AS user_a, u2.username AS user_b,\n  COUNT(*) AS mutual_threads\nFROM comments c1\nINNER JOIN comments c2 ON c1.post_id = c2.post_id AND c1.user_id < c2.user_id\nINNER JOIN users u1 ON c1.user_id = u1.id\nINNER JOIN users u2 ON c2.user_id = u2.id\nGROUP BY u1.username, u2.username\nORDER BY mutual_threads DESC\nLIMIT 10;` },
  { title: '14. Time Machine', desc: 'Cohort analysis by join month',
    sql: `SELECT SUBSTR(u.created_at, 1, 7) AS cohort,\n  COUNT(DISTINCT u.id) AS users_joined,\n  COUNT(DISTINCT p.id) AS posts_written,\n  COUNT(DISTINCT c.id) AS comments_made,\n  ROUND(COUNT(DISTINCT p.id) * 100 / COUNT(DISTINCT u.id)) AS posts_per_user_pct,\n  CASE\n    WHEN COUNT(DISTINCT p.id) > COUNT(DISTINCT u.id) * 2 THEN '\u{1F680} Hyperactive'\n    WHEN COUNT(DISTINCT p.id) >= COUNT(DISTINCT u.id) THEN '\u{2705} Healthy'\n    ELSE '\u{1F634} Quiet'\n  END AS cohort_health\nFROM users u\nLEFT JOIN posts p ON u.id = p.user_id\nLEFT JOIN comments c ON u.id = c.user_id\nGROUP BY cohort\nORDER BY cohort;` },
  { title: '15. Content Genome', desc: 'Category DNA per author with bar chart',
    sql: `SELECT u.username,\n  cat.name AS category,\n  COUNT(*) AS posts_in_cat,\n  SUBSTR('\u{2588}\u{2588}\u{2588}\u{2588}\u{2588}\u{2588}\u{2588}\u{2588}\u{2588}\u{2588}\u{2588}\u{2588}\u{2588}\u{2588}\u{2588}\u{2588}\u{2588}\u{2588}\u{2588}\u{2588}', 1, COUNT(*) * 4) AS distribution\nFROM users u\nINNER JOIN posts p ON u.id = p.user_id\nINNER JOIN post_categories pc ON p.id = pc.post_id\nINNER JOIN categories cat ON pc.category_id = cat.id\nGROUP BY u.username, cat.name\nORDER BY u.username, posts_in_cat DESC;` },
  { title: '16. Engagement Decay', desc: 'Do newer posts get fewer comments?',
    sql: `SELECT p.title,\n  p.created_at,\n  p.views,\n  COUNT(c.id) AS comments,\n  CASE\n    WHEN p.created_at < '2025-04-01' THEN '\u{1F3DB}\u{FE0F} Ancient'\n    WHEN p.created_at < '2025-07-01' THEN '\u{1F4C5} Mid-era'\n    ELSE '\u{1F195} Recent'\n  END AS era,\n  ROUND(p.views / CASE WHEN COUNT(c.id) = 0 THEN 1 ELSE COUNT(c.id) END) AS views_per_comment\nFROM posts p\nLEFT JOIN comments c ON c.post_id = p.id\nGROUP BY p.id, p.title, p.created_at, p.views\nORDER BY p.created_at;` },
  { title: '17. SQL Inception', desc: 'DDL that builds a stats table from live query',
    sql: `DROP TABLE IF EXISTS user_stats;\nCREATE TABLE user_stats (\n  username TEXT NOT NULL,\n  total_posts INTEGER DEFAULT 0,\n  total_comments INTEGER DEFAULT 0,\n  total_views INTEGER DEFAULT 0,\n  ratio REAL DEFAULT 0,\n  tier TEXT DEFAULT 'unknown'\n);\nINSERT INTO user_stats\n  SELECT u.username,\n    COUNT(DISTINCT p.id),\n    COUNT(DISTINCT c.id),\n    COALESCE(SUM(p.views), 0),\n    ROUND(COALESCE(SUM(p.views), 0) / CASE WHEN COUNT(DISTINCT p.id) = 0 THEN 1 ELSE COUNT(DISTINCT p.id) END),\n    CASE WHEN COUNT(DISTINCT p.id) > 3 THEN 'platinum' WHEN COUNT(DISTINCT p.id) > 1 THEN 'gold' ELSE 'silver' END\n  FROM users u\n  LEFT JOIN posts p ON u.id = p.user_id\n  LEFT JOIN comments c ON c.user_id = u.id\n  GROUP BY u.username;\nSELECT * FROM user_stats ORDER BY total_views DESC;` },
  { title: '18. Orphan Detector', desc: 'Posts missing from the category system',
    sql: `SELECT p.title, u.username, p.views,\n  CASE WHEN pc.post_id IS NULL THEN '\u{274C} ORPHAN' ELSE '\u{2705} Tagged' END AS status\nFROM posts p\nINNER JOIN users u ON p.user_id = u.id\nLEFT JOIN post_categories pc ON p.id = pc.post_id\nORDER BY status DESC, p.views DESC;` },
  { title: '19. The Paradox', desc: 'Users whose taste exceeds their output',
    sql: `SELECT commenter.username,\n  COALESCE(own_views.avg_post_views, 0) AS avg_own_post_views,\n  ROUND(AVG(target.views)) AS avg_commented_post_views,\n  CASE\n    WHEN COALESCE(own_views.avg_post_views, 0) < AVG(target.views)\n    THEN '\u{1F3AF} Taste > Output'\n    ELSE '\u{1F4AA} Walks the Talk'\n  END AS paradox\nFROM comments c\nINNER JOIN users commenter ON c.user_id = commenter.id\nINNER JOIN posts target ON c.post_id = target.id\nLEFT JOIN (\n  SELECT user_id, ROUND(AVG(views)) AS avg_post_views\n  FROM posts GROUP BY user_id\n) own_views ON own_views.user_id = commenter.id\nGROUP BY commenter.username, own_views.avg_post_views\nORDER BY avg_commented_post_views DESC;` },
  { title: '20. Full Census', desc: 'Scalar subqueries — one query to rule them all',
    sql: `SELECT\n  (SELECT COUNT(*) FROM users) AS total_users,\n  (SELECT COUNT(*) FROM posts) AS total_posts,\n  (SELECT COUNT(*) FROM comments) AS total_comments,\n  (SELECT COUNT(*) FROM categories) AS total_categories,\n  (SELECT ROUND(AVG(views)) FROM posts) AS avg_views,\n  (SELECT username FROM users u INNER JOIN posts p ON u.id = p.user_id GROUP BY u.username ORDER BY COUNT(*) DESC LIMIT 1) AS top_poster,\n  (SELECT title FROM posts ORDER BY views DESC LIMIT 1) AS most_viewed,\n  (SELECT name FROM categories cat INNER JOIN post_categories pc ON cat.id = pc.category_id GROUP BY cat.name ORDER BY COUNT(*) DESC LIMIT 1) AS hottest_category;` }
];

const UI = {
  db: null,
  history: [],
  historyIdx: -1,
  lastResult: null,
  sortCol: null,
  sortDir: 'ASC',

  init() {
    this.db = new Database();
    // Load history
    try { this.history = JSON.parse(localStorage.getItem('rappterzoo-sqlstudio-history') || '[]'); } catch(e) { this.history = []; }

    // If no tables, load demo data
    if (Object.keys(this.db.tables).length === 0) this.loadDemo();

    this.updateSchema();
    this.updateHistoryPanel();
    this.updateStatus();
    this.populateExamples();

    const ed = document.getElementById('editor');
    ed.addEventListener('input', () => { this.updateLineNums(); this.highlight(); });
    ed.addEventListener('scroll', () => this.syncScroll());
    ed.addEventListener('keydown', e => this.onKey(e));

    // Set default query
    ed.value = '-- Welcome to SQL Studio!\n-- Pick a showcase query from the dropdown, or try:\n\nSELECT u.username, COUNT(p.id) AS post_count\nFROM users u\nLEFT JOIN posts p ON u.id = p.user_id\nGROUP BY u.username\nORDER BY post_count DESC;';
    this.updateLineNums();
    this.highlight();
  },

  populateExamples() {
    const sel = document.getElementById('examples-select');
    SHOWCASE.forEach((ex, i) => {
      const opt = document.createElement('option');
      opt.value = i;
      opt.textContent = ex.title;
      sel.appendChild(opt);
    });
    const list = document.getElementById('examples-list');
    list.innerHTML = '<h3>⚡ Showcase</h3>' + SHOWCASE.map((ex, i) =>
      `<div class="example-item" onclick="UI.loadExample(${i})" title="${UI.escHTML(ex.desc)}">` +
      `<span class="ex-num">#${i+1}</span>${UI.escHTML(ex.title.replace(/^\d+\.\s*/, ''))}` +
      `<span class="ex-desc">${UI.escHTML(ex.desc)}</span></div>`
    ).join('');
  },

  loadExample(idx) {
    idx = parseInt(idx);
    if (isNaN(idx) || !SHOWCASE[idx]) return;
    document.getElementById('editor').value = SHOWCASE[idx].sql;
    this.updateLineNums();
    this.highlight();
    document.getElementById('status-left').textContent = 'Loaded: ' + SHOWCASE[idx].title;
  },

  loadDemo() {
    const demo = `
CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT NOT NULL, email TEXT NOT NULL, bio TEXT, created_at TEXT NOT NULL);
CREATE TABLE categories (id INTEGER PRIMARY KEY, name TEXT NOT NULL, slug TEXT NOT NULL, description TEXT);
CREATE TABLE posts (id INTEGER PRIMARY KEY, user_id INTEGER NOT NULL, title TEXT NOT NULL, body TEXT, views INTEGER DEFAULT 0, created_at TEXT NOT NULL);
CREATE TABLE comments (id INTEGER PRIMARY KEY, post_id INTEGER NOT NULL, user_id INTEGER NOT NULL, body TEXT NOT NULL, created_at TEXT NOT NULL);
CREATE TABLE post_categories (post_id INTEGER NOT NULL, category_id INTEGER NOT NULL);

INSERT INTO users VALUES (1, 'alice', 'alice@example.com', 'Full-stack developer who loves Rust', '2025-01-15');
INSERT INTO users VALUES (2, 'bob', 'bob@example.com', 'Data scientist and ML engineer', '2025-02-20');
INSERT INTO users VALUES (3, 'charlie', 'charlie@example.com', NULL, '2025-03-10');
INSERT INTO users VALUES (4, 'diana', 'diana@example.com', 'DevOps engineer, cloud native', '2025-04-05');
INSERT INTO users VALUES (5, 'eve', 'eve@example.com', 'Security researcher', '2025-05-12');
INSERT INTO users VALUES (6, 'frank', 'frank@example.com', 'Frontend wizard, CSS artisan', '2025-06-01');
INSERT INTO users VALUES (7, 'grace', 'grace@example.com', 'Database architect', '2025-06-15');
INSERT INTO users VALUES (8, 'hank', 'hank@example.com', NULL, '2025-07-22');

INSERT INTO categories VALUES (1, 'Technology', 'tech', 'Programming, hardware, and software');
INSERT INTO categories VALUES (2, 'Science', 'science', 'Research and discoveries');
INSERT INTO categories VALUES (3, 'Design', 'design', 'UI/UX, graphics, and aesthetics');
INSERT INTO categories VALUES (4, 'Career', 'career', 'Jobs, interviews, and growth');
INSERT INTO categories VALUES (5, 'Community', 'community', 'Events, meetups, and culture');

INSERT INTO posts VALUES (1, 1, 'Getting Started with Rust', 'Rust is a systems programming language focused on safety and performance.', 342, '2025-03-01');
INSERT INTO posts VALUES (2, 1, 'Why I Switched to Linux', 'After years on macOS, I made the jump to Linux full-time.', 891, '2025-03-15');
INSERT INTO posts VALUES (3, 2, 'Intro to Neural Networks', 'Neural networks are the backbone of modern machine learning.', 567, '2025-04-02');
INSERT INTO posts VALUES (4, 2, 'Python vs R for Data Science', 'A comprehensive comparison for data professionals.', 1203, '2025-04-20');
INSERT INTO posts VALUES (5, 3, 'My First Open Source Contribution', 'How I found my first issue and submitted a PR.', 234, '2025-05-01');
INSERT INTO posts VALUES (6, 4, 'Kubernetes Best Practices', 'Lessons learned from running K8s in production for 3 years.', 1567, '2025-05-15');
INSERT INTO posts VALUES (7, 5, 'Web Security Fundamentals', 'Every developer should know these security basics.', 2103, '2025-06-01');
INSERT INTO posts VALUES (8, 6, 'CSS Grid vs Flexbox', 'When to use each layout system and why.', 445, '2025-06-20');
INSERT INTO posts VALUES (9, 6, 'Designing for Accessibility', 'Making the web usable for everyone.', 678, '2025-07-01');
INSERT INTO posts VALUES (10, 7, 'PostgreSQL Performance Tuning', 'Tips for optimizing your database queries.', 1890, '2025-07-15');
INSERT INTO posts VALUES (11, 1, 'Building a SQL Engine from Scratch', 'How tokenizers, parsers, and executors work together.', 456, '2025-08-01');
INSERT INTO posts VALUES (12, 4, 'CI/CD Pipeline Design', 'Automate everything from commit to deploy.', 789, '2025-08-10');
INSERT INTO posts VALUES (13, 8, 'Hello World', 'Just getting started here.', 12, '2025-08-15');
INSERT INTO posts VALUES (14, 5, 'Threat Modeling for Startups', 'Security on a budget.', 334, '2025-08-20');
INSERT INTO posts VALUES (15, 7, 'The Art of Database Indexing', 'Indexes can make or break your app performance.', 2340, '2025-09-01');

INSERT INTO comments VALUES (1, 1, 2, 'Great intro! Rust ownership model is tricky at first.', '2025-03-02');
INSERT INTO comments VALUES (2, 1, 3, 'I have been meaning to try Rust. Thanks for the push!', '2025-03-03');
INSERT INTO comments VALUES (3, 2, 4, 'Which distro did you choose?', '2025-03-16');
INSERT INTO comments VALUES (4, 2, 5, 'I switched last year too. No regrets!', '2025-03-17');
INSERT INTO comments VALUES (5, 3, 1, 'Can you cover CNNs next?', '2025-04-03');
INSERT INTO comments VALUES (6, 4, 6, 'Python all the way for me.', '2025-04-21');
INSERT INTO comments VALUES (7, 4, 7, 'R still has a place in statistical analysis.', '2025-04-22');
INSERT INTO comments VALUES (8, 5, 1, 'Welcome to open source! The community is amazing.', '2025-05-02');
INSERT INTO comments VALUES (9, 6, 2, 'Solid advice. Resource limits are crucial.', '2025-05-16');
INSERT INTO comments VALUES (10, 6, 5, 'How do you handle secrets management?', '2025-05-17');
INSERT INTO comments VALUES (11, 7, 1, 'OWASP Top 10 is a must-read alongside this.', '2025-06-02');
INSERT INTO comments VALUES (12, 7, 3, 'Really helpful, bookmarked!', '2025-06-03');
INSERT INTO comments VALUES (13, 7, 4, 'Can you write about JWT security?', '2025-06-04');
INSERT INTO comments VALUES (14, 8, 7, 'I use Grid for page layout, Flexbox for components.', '2025-06-21');
INSERT INTO comments VALUES (15, 9, 5, 'Accessibility should be the default, not an afterthought.', '2025-07-02');
INSERT INTO comments VALUES (16, 10, 1, 'EXPLAIN ANALYZE is my best friend.', '2025-07-16');
INSERT INTO comments VALUES (17, 10, 2, 'Connection pooling tips would be great.', '2025-07-17');
INSERT INTO comments VALUES (18, 10, 4, 'Partitioning large tables helped us a lot.', '2025-07-18');
INSERT INTO comments VALUES (19, 11, 7, 'Fascinating! Recursive descent parsers are elegant.', '2025-08-02');
INSERT INTO comments VALUES (20, 11, 6, 'This is exactly what SQL Studio does!', '2025-08-03');
INSERT INTO comments VALUES (21, 12, 1, 'GitHub Actions or GitLab CI?', '2025-08-11');
INSERT INTO comments VALUES (22, 14, 3, 'STRIDE model is a good starting point.', '2025-08-21');
INSERT INTO comments VALUES (23, 15, 2, 'Covering indexes are underrated.', '2025-09-02');
INSERT INTO comments VALUES (24, 15, 8, 'Thanks! My queries are 10x faster now.', '2025-09-03');
INSERT INTO comments VALUES (25, 13, 1, 'Welcome aboard!', '2025-08-16');

INSERT INTO post_categories VALUES (1, 1);
INSERT INTO post_categories VALUES (2, 1);
INSERT INTO post_categories VALUES (3, 2);
INSERT INTO post_categories VALUES (3, 1);
INSERT INTO post_categories VALUES (4, 2);
INSERT INTO post_categories VALUES (4, 1);
INSERT INTO post_categories VALUES (5, 5);
INSERT INTO post_categories VALUES (6, 1);
INSERT INTO post_categories VALUES (7, 1);
INSERT INTO post_categories VALUES (8, 3);
INSERT INTO post_categories VALUES (8, 1);
INSERT INTO post_categories VALUES (9, 3);
INSERT INTO post_categories VALUES (10, 1);
INSERT INTO post_categories VALUES (11, 1);
INSERT INTO post_categories VALUES (12, 1);
INSERT INTO post_categories VALUES (12, 4);
INSERT INTO post_categories VALUES (13, 5);
INSERT INTO post_categories VALUES (14, 1);
INSERT INTO post_categories VALUES (15, 1);`;
    try { this.db.importSQL(demo); } catch(e) { console.error('Demo load error:', e); }
  },

  run() {
    const ed = document.getElementById('editor');
    const sql = ed.value.trim();
    if (!sql) return;

    this.addHistory(sql);
    try {
      const result = this.db.execute(sql);
      this.lastResult = result;

      if (result.plan) {
        this.showMessage('Query Plan:\n\n' + result.plan, 'plan');
      } else if (result.rows && result.rows.length > 0) {
        this.showTable(result.columns, result.rows);
        document.getElementById('results-info').textContent =
          `${result.rows.length} row(s) in ${result.time}ms`;
      } else if (result.message) {
        this.showMessage(result.message, result.message.startsWith('CREATE') || result.message.startsWith('Error') ? 'info' : 'ok');
        document.getElementById('results-info').textContent = result.time ? `Done in ${result.time}ms` : '';
      } else {
        this.showMessage('Query returned 0 rows', 'info');
        document.getElementById('results-info').textContent = `0 rows in ${result.time}ms`;
      }
      this.updateSchema();
      this.updateStatus();
      document.getElementById('status-left').textContent = `✓ Query executed in ${result.time}ms`;
    } catch (e) {
      this.showMessage('Error: ' + e.message, 'err');
      document.getElementById('status-left').textContent = '✗ ' + e.message;
    }
  },

  showTable(columns, rows) {
    const body = document.getElementById('results-body');
    this.sortCol = null;
    this.sortDir = 'ASC';
    const table = document.createElement('table');
    table.id = 'results-table';
    const thead = document.createElement('thead');
    const hr = document.createElement('tr');
    columns.forEach((c, i) => {
      const th = document.createElement('th');
      th.textContent = c;
      th.dataset.col = c;
      th.innerHTML = c + ' <span class="sort-arrow"></span>';
      th.onclick = () => this.sortTable(columns, rows, c);
      hr.appendChild(th);
    });
    thead.appendChild(hr);
    table.appendChild(thead);
    const tbody = document.createElement('tbody');
    for (const row of rows) {
      const tr = document.createElement('tr');
      for (const c of columns) {
        const td = document.createElement('td');
        const val = row[c];
        if (val === null || val === undefined) { td.innerHTML = '<span class="null-val">NULL</span>'; }
        else { td.textContent = String(val); }
        td.title = String(val);
        tr.appendChild(td);
      }
      tbody.appendChild(tr);
    }
    table.appendChild(tbody);
    body.innerHTML = '';
    body.appendChild(table);
  },

  sortTable(columns, rows, col) {
    if (this.sortCol === col) this.sortDir = this.sortDir === 'ASC' ? 'DESC' : 'ASC';
    else { this.sortCol = col; this.sortDir = 'ASC'; }
    const sorted = [...rows].sort((a, b) => {
      const va = a[col], vb = b[col];
      if (va == null && vb == null) return 0;
      if (va == null) return 1;
      if (vb == null) return -1;
      if (va < vb) return this.sortDir === 'ASC' ? -1 : 1;
      if (va > vb) return this.sortDir === 'ASC' ? 1 : -1;
      return 0;
    });
    this.showTable(columns, sorted);
    const th = document.querySelector(`#results-table th[data-col="${col}"]`);
    if (th) th.querySelector('.sort-arrow').textContent = this.sortDir === 'ASC' ? '▲' : '▼';
  },

  showMessage(msg, cls) {
    const body = document.getElementById('results-body');
    body.innerHTML = `<div id="message-area" class="msg-${cls}">${this.escHTML(msg)}</div>`;
  },

  updateSchema() {
    const list = document.getElementById('schema-list');
    const tables = Object.entries(this.db.tables).sort((a,b) => a[0].localeCompare(b[0]));
    list.innerHTML = tables.map(([name, tbl]) => `
      <div class="schema-table">
        <div class="schema-table-name" onclick="UI.toggleSchema(this)" ondblclick="UI.insertTableQuery('${name}')">
          <span class="arrow">▶</span>
          <span>${this.escHTML(name)}</span>
          <span class="count">${tbl.rows.length}</span>
        </div>
        <div class="schema-cols">
          ${tbl.columns.map(c => `<div class="schema-col">
            <span class="col-name">${this.escHTML(c.name)}</span>
            <span class="col-type">${c.dataType}</span>
            ${c.primaryKey ? '<span class="col-pk">PK</span>' : ''}
            ${c.notNull && !c.primaryKey ? '<span class="col-nn">NN</span>' : ''}
          </div>`).join('')}
        </div>
      </div>`).join('');
  },

  toggleSchema(el) {
    const cols = el.nextElementSibling;
    const arrow = el.querySelector('.arrow');
    cols.classList.toggle('open');
    arrow.classList.toggle('open');
  },

  insertTableQuery(name) {
    document.getElementById('editor').value = `SELECT * FROM ${name};`;
    this.updateLineNums();
    this.highlight();
  },

  addHistory(sql) {
    this.history.unshift({ sql, ts: Date.now() });
    if (this.history.length > 100) this.history.length = 100;
    this.historyIdx = -1;
    try { localStorage.setItem('rappterzoo-sqlstudio-history', JSON.stringify(this.history)); } catch(e) {}
    this.updateHistoryPanel();
  },

  updateHistoryPanel() {
    const list = document.getElementById('history-list');
    list.innerHTML = this.history.slice(0, 50).map((h, i) => {
      const t = new Date(h.ts);
      const time = t.getHours().toString().padStart(2,'0') + ':' + t.getMinutes().toString().padStart(2,'0');
      return `<div class="history-item" onclick="UI.loadHistory(${i})" title="${this.escHTML(h.sql)}">
        <span class="ts">${time}</span>${this.escHTML(h.sql.substring(0, 60))}
      </div>`;
    }).join('');
  },

  loadHistory(idx) {
    if (this.history[idx]) {
      document.getElementById('editor').value = this.history[idx].sql;
      this.updateLineNums();
      this.highlight();
    }
  },

  updateLineNums() {
    const ed = document.getElementById('editor');
    const lines = ed.value.split('\n').length;
    const nums = document.getElementById('line-nums');
    nums.innerHTML = Array.from({length: lines}, (_, i) => i + 1).join('\n');
  },

  highlight() {
    const ed = document.getElementById('editor');
    const hl = document.getElementById('highlight');
    hl.innerHTML = this.syntaxHL(ed.value);
  },

  syntaxHL(text) {
    let result = '';
    let i = 0;
    while (i < text.length) {
      // Comment
      if (text[i] === '-' && text[i+1] === '-') {
        let end = text.indexOf('\n', i);
        if (end === -1) end = text.length;
        result += '<span class="hl-comment">' + this.escHTML(text.slice(i, end)) + '</span>';
        i = end;
        continue;
      }
      // String
      if (text[i] === "'") {
        let j = i + 1;
        while (j < text.length) {
          if (text[j] === "'" && text[j+1] === "'") j += 2;
          else if (text[j] === "'") { j++; break; }
          else j++;
        }
        result += '<span class="hl-string">' + this.escHTML(text.slice(i, j)) + '</span>';
        i = j;
        continue;
      }
      // Number
      if (text[i] >= '0' && text[i] <= '9') {
        let j = i;
        while (j < text.length && ((text[j] >= '0' && text[j] <= '9') || text[j] === '.')) j++;
        result += '<span class="hl-number">' + this.escHTML(text.slice(i, j)) + '</span>';
        i = j;
        continue;
      }
      // Word (keyword/identifier)
      if (/[a-zA-Z_]/.test(text[i])) {
        let j = i;
        while (j < text.length && /[a-zA-Z0-9_]/.test(text[j])) j++;
        const word = text.slice(i, j);
        const upper = word.toUpperCase();
        if (AGGREGATE_FNS.has(upper) || SCALAR_FNS.has(upper)) {
          result += '<span class="hl-function">' + this.escHTML(word) + '</span>';
        } else if (KEYWORDS.has(upper)) {
          result += '<span class="hl-keyword">' + this.escHTML(word) + '</span>';
        } else {
          result += '<span class="hl-default">' + this.escHTML(word) + '</span>';
        }
        i = j;
        continue;
      }
      // Operators
      if ('<>=!'.includes(text[i])) {
        let j = i + 1;
        if (j < text.length && '=<>'.includes(text[j])) j++;
        result += '<span class="hl-operator">' + this.escHTML(text.slice(i, j)) + '</span>';
        i = j;
        continue;
      }
      // Everything else
      result += this.escHTML(text[i]);
      i++;
    }
    return result + '\n';
  },

  syncScroll() {
    const ed = document.getElementById('editor');
    document.getElementById('highlight').scrollTop = ed.scrollTop;
    document.getElementById('highlight').scrollLeft = ed.scrollLeft;
    document.getElementById('line-nums').scrollTop = ed.scrollTop;
  },

  onKey(e) {
    if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') { e.preventDefault(); this.run(); return; }
    if ((e.ctrlKey || e.metaKey) && e.key === 'l') { e.preventDefault(); document.getElementById('editor').value = ''; this.updateLineNums(); this.highlight(); return; }
    if ((e.ctrlKey || e.metaKey) && e.key === 'ArrowUp') {
      e.preventDefault();
      if (this.historyIdx < this.history.length - 1) {
        this.historyIdx++;
        document.getElementById('editor').value = this.history[this.historyIdx].sql;
        this.updateLineNums(); this.highlight();
      }
      return;
    }
    if ((e.ctrlKey || e.metaKey) && e.key === 'ArrowDown') {
      e.preventDefault();
      if (this.historyIdx > 0) {
        this.historyIdx--;
        document.getElementById('editor').value = this.history[this.historyIdx].sql;
        this.updateLineNums(); this.highlight();
      }
      return;
    }
    if (e.key === 'Tab') {
      e.preventDefault();
      const ed = e.target;
      const start = ed.selectionStart;
      ed.value = ed.value.substring(0, start) + '  ' + ed.value.substring(ed.selectionEnd);
      ed.selectionStart = ed.selectionEnd = start + 2;
      this.updateLineNums(); this.highlight();
    }
  },

  updateStatus() {
    const tables = Object.keys(this.db.tables).length;
    const rows = Object.values(this.db.tables).reduce((s, t) => s + t.rows.length, 0);
    document.getElementById('status-right').textContent = `${tables} table(s), ${rows} row(s)`;
  },

  exportDB() {
    const sql = this.db.exportSQL();
    this.download('sqlstudio-export.sql', sql, 'text/sql');
  },

  importDB() {
    document.getElementById('import-file').click();
  },

  exportCSV() {
    if (!this.lastResult || !this.lastResult.columns || this.lastResult.columns.length === 0) {
      this.showMessage('Run a SELECT query first to export CSV', 'info');
      return;
    }
    const csv = this.db.exportCSV(this.lastResult.columns, this.lastResult.rows);
    this.download('results.csv', csv, 'text/csv');
  },

  resetDB() {
    if (!confirm('Reset database to demo data? All changes will be lost.')) return;
    localStorage.removeItem('rappterzoo-sqlstudio-db');
    this.db.tables = {};
    this.loadDemo();
    this.updateSchema();
    this.updateStatus();
    this.showMessage('Database reset to demo data', 'ok');
    document.getElementById('status-left').textContent = 'Database reset';
  },

  download(name, content, type) {
    const a = document.createElement('a');
    a.href = URL.createObjectURL(new Blob([content], {type}));
    a.download = name;
    a.click();
    URL.revokeObjectURL(a.href);
  },

  escHTML(s) { return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;'); }
};

// ── File Import Handler ──────────────────────────────────
document.getElementById('import-file').addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = ev => {
    try {
      const count = UI.db.importSQL(ev.target.result);
      UI.showMessage(`Imported ${count} statement(s) successfully`, 'ok');
      UI.updateSchema();
      UI.updateStatus();
    } catch(err) {
      UI.showMessage('Import error: ' + err.message, 'err');
    }
  };
  reader.readAsText(file);
  e.target.value = '';
});

// ── Initialize ───────────────────────────────────────────
window.addEventListener('DOMContentLoaded', () => UI.init());
</script>
</body>
</html>
