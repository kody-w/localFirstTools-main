<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Slosh Test Suite</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            color: #4fc3f7;
            margin-bottom: 20px;
            font-size: 2em;
        }

        .summary {
            background: #2a2a2a;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
        }

        .summary h2 {
            color: #4fc3f7;
            font-size: 1.5em;
        }

        .stats {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
        }

        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-value.passed {
            color: #4caf50;
        }

        .stat-value.failed {
            color: #f44336;
        }

        .stat-label {
            color: #999;
            font-size: 0.9em;
        }

        .controls {
            margin-bottom: 20px;
        }

        button {
            background: #4fc3f7;
            color: #000;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover {
            background: #29b6f6;
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        .test-group {
            background: #2a2a2a;
            border-radius: 8px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .group-header {
            background: #333;
            padding: 15px 20px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
        }

        .group-header:hover {
            background: #3a3a3a;
        }

        .group-title {
            font-size: 1.2em;
            font-weight: bold;
            color: #4fc3f7;
        }

        .group-stats {
            color: #999;
            font-size: 0.9em;
        }

        .group-stats .pass {
            color: #4caf50;
        }

        .group-stats .fail {
            color: #f44336;
        }

        .test-list {
            padding: 10px;
        }

        .test-list.collapsed {
            display: none;
        }

        .test-item {
            padding: 12px 15px;
            margin: 5px 0;
            background: #1e1e1e;
            border-radius: 6px;
            border-left: 4px solid transparent;
        }

        .test-item.passed {
            border-left-color: #4caf50;
        }

        .test-item.failed {
            border-left-color: #f44336;
        }

        .test-name {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 5px;
        }

        .test-icon {
            font-size: 1.2em;
        }

        .test-icon.passed {
            color: #4caf50;
        }

        .test-icon.failed {
            color: #f44336;
        }

        .test-error {
            margin-top: 8px;
            padding: 10px;
            background: #3a1f1f;
            border-radius: 4px;
            color: #ff6b6b;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .progress {
            width: 100%;
            height: 6px;
            background: #333;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #8bc34a);
            transition: width 0.3s ease;
        }

        .running {
            opacity: 0.6;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .spinner {
            display: inline-block;
            animation: spin 1s linear infinite;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Data Slosh Test Suite</h1>

        <div class="summary">
            <h2 id="summary-title">Ready to run tests</h2>
            <div class="stats">
                <div class="stat">
                    <div class="stat-value passed" id="stat-passed">0</div>
                    <div class="stat-label">Passed</div>
                </div>
                <div class="stat">
                    <div class="stat-value failed" id="stat-failed">0</div>
                    <div class="stat-label">Failed</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="stat-total" style="color: #4fc3f7;">0</div>
                    <div class="stat-label">Total</div>
                </div>
            </div>
        </div>

        <div class="controls">
            <button id="run-btn" onclick="runAllTests()">Run Tests</button>
        </div>

        <div id="test-results"></div>
    </div>

    <script>
        // ============================================================================
        // CORE MODULES (IDENTICAL TO data-slosh.html)
        // ============================================================================

        const Parser = {
            parse(html) {
                const result = {
                    hasDoctype: false,
                    doctype: null,
                    hasHead: false,
                    headContent: '',
                    hasBody: false,
                    bodyContent: '',
                    title: null,
                    htmlLang: null,
                    metas: [],
                    hasCharset: false,
                    hasViewport: false,
                    hasDescription: false,
                    scripts: [],
                    styles: [],
                    externalUrls: [],
                    hasLocalStorage: false,
                    hasJsonExport: false,
                    hasErrorHandling: false,
                    consoleLogs: { count: 0, lines: [] },
                    hasMediaQueries: false,
                    hasAriaLabels: false,
                    hasNoscript: false,
                    inlineHandlers: [],
                    inputs: [],
                    hasInputLabels: false
                };

                // Detect DOCTYPE (case-insensitive)
                const doctypeMatch = html.match(/<!DOCTYPE[^>]*>/i);
                if (doctypeMatch) {
                    result.hasDoctype = true;
                    result.doctype = doctypeMatch[0];
                }

                // Extract head content
                const headMatch = html.match(/<head[^>]*>([\s\S]*?)<\/head>/i);
                if (headMatch) {
                    result.hasHead = true;
                    result.headContent = headMatch[1];
                }

                // Extract body content
                const bodyMatch = html.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
                if (bodyMatch) {
                    result.hasBody = true;
                    result.bodyContent = bodyMatch[1];
                }

                // Extract title
                const titleMatch = html.match(/<title[^>]*>([\s\S]*?)<\/title>/i);
                if (titleMatch) {
                    result.title = titleMatch[1].trim();
                }

                // Extract html lang
                const htmlLangMatch = html.match(/<html[^>]*lang=["']([^"']+)["']/i);
                if (htmlLangMatch) {
                    result.htmlLang = htmlLangMatch[1];
                }

                // Extract meta tags
                const metaRegex = /<meta([^>]*)>/gi;
                let metaMatch;
                while ((metaMatch = metaRegex.exec(html)) !== null) {
                    const attrs = metaMatch[1];
                    const meta = {};

                    const nameMatch = attrs.match(/name=["']([^"']+)["']/i);
                    if (nameMatch) meta.name = nameMatch[1];

                    const contentMatch = attrs.match(/content=["']([^"']+)["']/i);
                    if (contentMatch) meta.content = contentMatch[1];

                    const charsetMatch = attrs.match(/charset=["']?([^"'\s>]+)["']?/i);
                    if (charsetMatch) meta.charset = charsetMatch[1];

                    const httpEquivMatch = attrs.match(/http-equiv=["']([^"']+)["']/i);
                    if (httpEquivMatch) meta.httpEquiv = httpEquivMatch[1];

                    result.metas.push(meta);

                    // Check for charset
                    if (meta.charset || (meta.httpEquiv && meta.httpEquiv.toLowerCase() === 'content-type' && meta.content && meta.content.toLowerCase().includes('charset'))) {
                        result.hasCharset = true;
                    }

                    // Check for viewport
                    if (meta.name && meta.name.toLowerCase() === 'viewport') {
                        result.hasViewport = true;
                    }

                    // Check for description
                    if (meta.name && meta.name.toLowerCase() === 'description') {
                        result.hasDescription = true;
                    }
                }

                // Extract scripts
                const scriptRegex = /<script([^>]*)>([\s\S]*?)<\/script>/gi;
                let scriptMatch;
                while ((scriptMatch = scriptRegex.exec(html)) !== null) {
                    const attrs = scriptMatch[1];
                    const content = scriptMatch[2];
                    const script = {};

                    const srcMatch = attrs.match(/src=["']([^"']+)["']/i);
                    if (srcMatch) {
                        script.src = srcMatch[1];
                        script.inline = false;
                        if (script.src.match(/^https?:\/\//)) {
                            result.externalUrls.push(script.src);
                        }
                    } else {
                        script.inline = true;
                        script.content = content;
                    }

                    result.scripts.push(script);
                }

                // Extract styles
                const styleRegex = /<style([^>]*)>([\s\S]*?)<\/style>/gi;
                let styleMatch;
                while ((styleMatch = styleRegex.exec(html)) !== null) {
                    result.styles.push({
                        inline: true,
                        content: styleMatch[2]
                    });
                }

                const linkRegex = /<link([^>]*)>/gi;
                let linkMatch;
                while ((linkMatch = linkRegex.exec(html)) !== null) {
                    const attrs = linkMatch[1];
                    const relMatch = attrs.match(/rel=["']([^"']+)["']/i);
                    if (relMatch && relMatch[1].toLowerCase() === 'stylesheet') {
                        const hrefMatch = attrs.match(/href=["']([^"']+)["']/i);
                        if (hrefMatch) {
                            const href = hrefMatch[1];
                            result.styles.push({ href, inline: false });
                            if (href.match(/^https?:\/\//)) {
                                result.externalUrls.push(href);
                            }
                        }
                    }
                }

                // Check inline scripts for features
                result.scripts.forEach(script => {
                    if (script.inline && script.content) {
                        const content = script.content;

                        // localStorage usage
                        if (content.match(/localStorage\.(getItem|setItem|removeItem)/)) {
                            result.hasLocalStorage = true;
                        }

                        // JSON export pattern
                        if (content.includes('JSON.stringify') &&
                            (content.match(/download|export|blob|a\.href/))) {
                            result.hasJsonExport = true;
                        }

                        // Error handling
                        if (content.match(/try\s*{|catch\s*\(|window\.onerror|addEventListener\s*\(\s*['"]error['"]/)) {
                            result.hasErrorHandling = true;
                        }

                        // Console logs
                        const consoleRegex = /console\.(log|debug|info|warn)\(/g;
                        let consoleMatch;
                        const lines = content.split('\n');
                        while ((consoleMatch = consoleRegex.exec(content)) !== null) {
                            result.consoleLogs.count++;
                            // Find line number
                            const pos = consoleMatch.index;
                            const beforeMatch = content.substring(0, pos);
                            const lineNum = beforeMatch.split('\n').length;
                            result.consoleLogs.lines.push(lineNum);
                        }
                    }
                });

                // Check inline styles for media queries
                result.styles.forEach(style => {
                    if (style.inline && style.content && style.content.includes('@media')) {
                        result.hasMediaQueries = true;
                    }
                });

                // Check for ARIA labels
                if (html.match(/aria-label|role=/i)) {
                    result.hasAriaLabels = true;
                }

                // Check for noscript
                if (html.match(/<noscript/i)) {
                    result.hasNoscript = true;
                }

                // Check for inline handlers
                const handlerRegex = /\s(on\w+)=["'][^"']*["']/gi;
                let handlerMatch;
                while ((handlerMatch = handlerRegex.exec(html)) !== null) {
                    result.inlineHandlers.push(handlerMatch[1]);
                }

                // Check for inputs and labels
                const inputRegex = /<(input|select|textarea)([^>]*)>/gi;
                let inputMatch;
                while ((inputMatch = inputRegex.exec(html)) !== null) {
                    const attrs = inputMatch[2];
                    const typeMatch = attrs.match(/type=["']([^"']+)["']/i);
                    const idMatch = attrs.match(/id=["']([^"']+)["']/i);

                    const input = {
                        type: typeMatch ? typeMatch[1] : 'text',
                        hasLabel: false
                    };

                    // Check if there's a label for this input
                    if (idMatch) {
                        const labelRegex = new RegExp(`<label[^>]*for=["']${idMatch[1]}["']`, 'i');
                        if (html.match(labelRegex)) {
                            input.hasLabel = true;
                        }
                    }

                    result.inputs.push(input);
                }

                // Check if all inputs have labels
                if (result.inputs.length > 0) {
                    result.hasInputLabels = result.inputs.every(input => input.hasLabel);
                } else {
                    result.hasInputLabels = true; // No inputs = passing
                }

                return result;
            }
        };

        const Analyzer = {
            rules: [
                // ERRORS (weight: 15 each)
                { id: 'missing-doctype', severity: 'error', weight: 15, check: (p) => p.hasDoctype, message: 'Missing <!DOCTYPE html>' },
                { id: 'missing-charset', severity: 'error', weight: 15, check: (p) => p.hasCharset, message: 'Missing <meta charset="UTF-8">' },
                { id: 'missing-viewport', severity: 'error', weight: 15, check: (p) => p.hasViewport, message: 'Missing viewport meta tag' },
                { id: 'external-scripts', severity: 'error', weight: 15, check: (p) => p.scripts.every(s => !s.src || !s.src.match(/^https?:\/\//)), message: 'External script dependencies detected' },
                { id: 'external-styles', severity: 'error', weight: 15, check: (p) => p.styles.every(s => !s.href || !s.href.match(/^https?:\/\//)), message: 'External stylesheet dependencies detected' },
                { id: 'cdn-dependencies', severity: 'error', weight: 15, check: (p) => p.externalUrls.length === 0, message: 'CDN/external URL dependencies found' },

                // WARNINGS (weight: 5 each)
                { id: 'missing-title', severity: 'warning', weight: 5, check: (p) => !!p.title, message: 'Missing <title> tag' },
                { id: 'missing-html-lang', severity: 'warning', weight: 5, check: (p) => !!p.htmlLang, message: 'Missing lang attribute on <html>' },
                { id: 'missing-description', severity: 'warning', weight: 5, check: (p) => p.hasDescription, message: 'Missing meta description' },
                { id: 'no-localstorage', severity: 'warning', weight: 5, check: (p) => p.hasLocalStorage, message: 'No localStorage usage detected' },
                { id: 'no-json-export', severity: 'warning', weight: 5, check: (p) => p.hasJsonExport || !p.hasLocalStorage, message: 'Uses localStorage but no JSON export found' },
                { id: 'no-error-handling', severity: 'warning', weight: 5, check: (p) => p.hasErrorHandling, message: 'No error handling (try/catch or onerror)' },
                { id: 'console-log-pollution', severity: 'warning', weight: 5, check: (p) => p.consoleLogs.count === 0, message: (p) => `Console statements found (${p.consoleLogs.count} occurrences)` },
                { id: 'hardcoded-api-keys', severity: 'warning', weight: 5, check: (p) => !Analyzer.detectApiKeys(p), message: 'Possible hardcoded API keys detected' },

                // INFO (weight: 2 each)
                { id: 'no-media-queries', severity: 'info', weight: 2, check: (p) => p.hasMediaQueries, message: 'No CSS media queries for responsive design' },
                { id: 'no-aria-labels', severity: 'info', weight: 2, check: (p) => p.hasAriaLabels, message: 'No ARIA labels for accessibility' },
                { id: 'no-noscript', severity: 'info', weight: 2, check: (p) => p.hasNoscript, message: 'No <noscript> fallback' },
                { id: 'inline-onclick', severity: 'info', weight: 2, check: (p) => p.inlineHandlers.length === 0, message: 'Inline event handlers found (use addEventListener)' },
                { id: 'missing-input-labels', severity: 'info', weight: 2, check: (p) => p.hasInputLabels, message: 'Input elements missing associated labels' }
            ],

            analyze(parsed) {
                let score = 100;
                const results = [];
                const summary = { errors: 0, warnings: 0, info: 0 };

                this.rules.forEach(rule => {
                    const passed = rule.check(parsed);
                    const message = typeof rule.message === 'function' ? rule.message(parsed) : rule.message;

                    results.push({
                        rule: rule.id,
                        passed,
                        severity: rule.severity,
                        message
                    });

                    if (!passed) {
                        score -= rule.weight;
                        summary[rule.severity === 'error' ? 'errors' : rule.severity === 'warning' ? 'warnings' : 'info']++;
                    }
                });

                score = Math.max(0, score);

                return { score, results, summary };
            },

            detectApiKeys(parsed) {
                // Check for patterns like key/token/secret/api followed by = or : and a long alphanumeric string
                const keyPattern = /(api[-_]?key|token|secret|password)\s*[=:]\s*['"]([a-zA-Z0-9]{20,})['"]|['"]([a-zA-Z0-9]{32,})['"](?=\s*[;,)])/i;

                for (const script of parsed.scripts) {
                    if (script.inline && script.content) {
                        if (keyPattern.test(script.content)) {
                            return true;
                        }
                    }
                }

                return false;
            }
        };

        const Improver = {
            improve(html) {
                let improved = html;
                const changes = [];
                const linesBefore = html.split('\n').length;

                // 1. Add DOCTYPE if missing
                if (!html.match(/<!DOCTYPE/i)) {
                    improved = '<!DOCTYPE html>\n' + improved;
                    changes.push({
                        rule: 'missing-doctype',
                        description: 'Added <!DOCTYPE html>',
                        linesBefore,
                        linesAfter: improved.split('\n').length
                    });
                }

                // 2. Add charset meta if missing
                if (!html.match(/<meta[^>]*charset/i)) {
                    const headMatch = improved.match(/(<head[^>]*>)/i);
                    if (headMatch) {
                        const insertPos = headMatch.index + headMatch[0].length;
                        improved = improved.slice(0, insertPos) + '\n    <meta charset="UTF-8">' + improved.slice(insertPos);
                        changes.push({
                            rule: 'missing-charset',
                            description: 'Added <meta charset="UTF-8">',
                            linesBefore: improved.split('\n').length - 1,
                            linesAfter: improved.split('\n').length
                        });
                    } else {
                        // Create head if missing
                        const htmlMatch = improved.match(/(<html[^>]*>)/i);
                        if (htmlMatch) {
                            const insertPos = htmlMatch.index + htmlMatch[0].length;
                            improved = improved.slice(0, insertPos) + '\n<head>\n    <meta charset="UTF-8">\n</head>' + improved.slice(insertPos);
                            changes.push({
                                rule: 'missing-charset',
                                description: 'Added <head> with charset meta',
                                linesBefore: improved.split('\n').length - 4,
                                linesAfter: improved.split('\n').length
                            });
                        }
                    }
                }

                // 3. Add viewport meta if missing
                if (!html.match(/<meta[^>]*name=["']viewport["']/i)) {
                    const charsetMatch = improved.match(/<meta[^>]*charset[^>]*>/i);
                    if (charsetMatch) {
                        const insertPos = charsetMatch.index + charsetMatch[0].length;
                        improved = improved.slice(0, insertPos) + '\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">' + improved.slice(insertPos);
                        changes.push({
                            rule: 'missing-viewport',
                            description: 'Added viewport meta tag',
                            linesBefore: improved.split('\n').length - 1,
                            linesAfter: improved.split('\n').length
                        });
                    } else {
                        const headMatch = improved.match(/(<head[^>]*>)/i);
                        if (headMatch) {
                            const insertPos = headMatch.index + headMatch[0].length;
                            improved = improved.slice(0, insertPos) + '\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">' + improved.slice(insertPos);
                            changes.push({
                                rule: 'missing-viewport',
                                description: 'Added viewport meta tag',
                                linesBefore: improved.split('\n').length - 1,
                                linesAfter: improved.split('\n').length
                            });
                        }
                    }
                }

                // 4. Add lang="en" to <html> if missing
                if (html.match(/<html(?![^>]*lang=)/i)) {
                    improved = improved.replace(/<html/i, '<html lang="en"');
                    changes.push({
                        rule: 'missing-html-lang',
                        description: 'Added lang="en" to <html>',
                        linesBefore: improved.split('\n').length,
                        linesAfter: improved.split('\n').length
                    });
                }

                // 5. Comment out console.log/debug/info (but not error/warn)
                const consolePattern = /(\s*)(console\.(log|debug|info)\([^)]*\);?)/g;
                let consoleMatch;
                let commentedCount = 0;
                while ((consoleMatch = consolePattern.exec(html)) !== null) {
                    const indent = consoleMatch[1];
                    const statement = consoleMatch[2];
                    improved = improved.replace(consoleMatch[0], `${indent}// [DataSlosh] ${statement}`);
                    commentedCount++;
                }
                if (commentedCount > 0) {
                    changes.push({
                        rule: 'console-log-pollution',
                        description: `Commented out ${commentedCount} console statements`,
                        linesBefore: improved.split('\n').length,
                        linesAfter: improved.split('\n').length
                    });
                }

                // 6. Add <noscript> after <body> if missing
                if (!html.match(/<noscript/i) && html.match(/<body[^>]*>/i)) {
                    const bodyMatch = improved.match(/(<body[^>]*>)/i);
                    if (bodyMatch) {
                        const insertPos = bodyMatch.index + bodyMatch[0].length;
                        improved = improved.slice(0, insertPos) + '\n    <noscript>This application requires JavaScript to be enabled.</noscript>' + improved.slice(insertPos);
                        changes.push({
                            rule: 'no-noscript',
                            description: 'Added <noscript> fallback',
                            linesBefore: improved.split('\n').length - 1,
                            linesAfter: improved.split('\n').length
                        });
                    }
                }

                return { html: improved, changes };
            }
        };

        const Differ = {
            diff(original, improved) {
                const origLines = original.split('\n');
                const impLines = improved.split('\n');

                // For large files, use simplified comparison
                if (origLines.length > 5000 || impLines.length > 5000) {
                    return this._simpleDiff(origLines, impLines);
                }

                // Use LCS for smaller files
                return this._lcsDiff(origLines, impLines);
            },

            _simpleDiff(origLines, impLines) {
                const lines = [];
                const maxLen = Math.max(origLines.length, impLines.length);
                let added = 0, removed = 0, unchanged = 0;

                for (let i = 0; i < maxLen; i++) {
                    if (i >= origLines.length) {
                        lines.push({ type: 'added', content: impLines[i], lineNum: i + 1 });
                        added++;
                    } else if (i >= impLines.length) {
                        lines.push({ type: 'removed', content: origLines[i], lineNum: i + 1 });
                        removed++;
                    } else if (origLines[i] === impLines[i]) {
                        lines.push({ type: 'same', content: origLines[i], lineNum: i + 1 });
                        unchanged++;
                    } else {
                        lines.push({ type: 'removed', content: origLines[i], lineNum: i + 1 });
                        lines.push({ type: 'added', content: impLines[i], lineNum: i + 1 });
                        added++;
                        removed++;
                    }
                }

                return { lines, stats: { added, removed, unchanged } };
            },

            _lcsDiff(origLines, impLines) {
                const lcs = this._computeLCS(origLines, impLines);
                const lines = [];
                let i = 0, j = 0, lineNum = 1;
                let added = 0, removed = 0, unchanged = 0;

                lcs.forEach(commonLine => {
                    // Add removed lines before this common line
                    while (i < origLines.length && origLines[i] !== commonLine) {
                        lines.push({ type: 'removed', content: origLines[i], lineNum });
                        i++;
                        removed++;
                        lineNum++;
                    }

                    // Add added lines before this common line
                    while (j < impLines.length && impLines[j] !== commonLine) {
                        lines.push({ type: 'added', content: impLines[j], lineNum });
                        j++;
                        added++;
                        lineNum++;
                    }

                    // Add the common line
                    lines.push({ type: 'same', content: commonLine, lineNum });
                    i++;
                    j++;
                    unchanged++;
                    lineNum++;
                });

                // Add remaining removed lines
                while (i < origLines.length) {
                    lines.push({ type: 'removed', content: origLines[i], lineNum });
                    i++;
                    removed++;
                    lineNum++;
                }

                // Add remaining added lines
                while (j < impLines.length) {
                    lines.push({ type: 'added', content: impLines[j], lineNum });
                    j++;
                    added++;
                    lineNum++;
                }

                return { lines, stats: { added, removed, unchanged } };
            },

            _computeLCS(arr1, arr2) {
                const m = arr1.length;
                const n = arr2.length;
                const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));

                for (let i = 1; i <= m; i++) {
                    for (let j = 1; j <= n; j++) {
                        if (arr1[i - 1] === arr2[j - 1]) {
                            dp[i][j] = dp[i - 1][j - 1] + 1;
                        } else {
                            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                        }
                    }
                }

                // Backtrack to find LCS
                const lcs = [];
                let i = m, j = n;
                while (i > 0 && j > 0) {
                    if (arr1[i - 1] === arr2[j - 1]) {
                        lcs.unshift(arr1[i - 1]);
                        i--;
                        j--;
                    } else if (dp[i - 1][j] > dp[i][j - 1]) {
                        i--;
                    } else {
                        j--;
                    }
                }

                return lcs;
            },

            toHTML(diffResult) {
                const escape = (str) => {
                    return str.replace(/&/g, '&amp;')
                              .replace(/</g, '&lt;')
                              .replace(/>/g, '&gt;')
                              .replace(/"/g, '&quot;')
                              .replace(/'/g, '&#039;');
                };

                let html = '<div class="diff-output">';

                diffResult.lines.forEach(line => {
                    const className = line.type === 'added' ? 'diff-added' :
                                     line.type === 'removed' ? 'diff-removed' : 'diff-same';
                    const prefix = line.type === 'added' ? '+ ' :
                                  line.type === 'removed' ? '- ' : '  ';
                    html += `<div class="${className}">${escape(prefix + line.content)}</div>`;
                });

                html += '</div>';
                return html;
            }
        };

        const History = {
            STORAGE_KEY: 'dataslosh-history',
            MAX_ENTRIES: 200,

            load() {
                try {
                    const stored = localStorage.getItem(this.STORAGE_KEY);
                    return stored ? JSON.parse(stored) : [];
                } catch (e) {
                    return [];
                }
            },

            save(entries) {
                try {
                    const trimmed = entries.slice(-this.MAX_ENTRIES);
                    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(trimmed));
                } catch (e) {
                    // Silently fail if localStorage is full
                }
            },

            record(result) {
                const entries = this.load();
                entries.push({
                    filename: result.filename,
                    score: result.score,
                    failedRules: result.failedRules,
                    timestamp: result.timestamp || Date.now()
                });
                this.save(entries);
            },

            getStats() {
                const entries = this.load();

                if (entries.length === 0) {
                    return {
                        totalRuns: 0,
                        avgScore: 0,
                        ruleFrequency: {},
                        scoreTrend: []
                    };
                }

                const totalRuns = entries.length;
                const avgScore = entries.reduce((sum, e) => sum + e.score, 0) / totalRuns;
                const ruleFrequency = {};

                entries.forEach(entry => {
                    entry.failedRules.forEach(rule => {
                        ruleFrequency[rule] = (ruleFrequency[rule] || 0) + 1;
                    });
                });

                const scoreTrend = entries.slice(-20).map(e => e.score);

                return { totalRuns, avgScore, ruleFrequency, scoreTrend };
            },

            getInsights() {
                const entries = this.load();
                const insights = [];

                if (entries.length === 0) {
                    return insights;
                }

                const stats = this.getStats();

                // Most common issue
                const sortedRules = Object.entries(stats.ruleFrequency)
                    .sort((a, b) => b[1] - a[1]);

                if (sortedRules.length > 0) {
                    const [rule, count] = sortedRules[0];
                    const percentage = Math.round((count / stats.totalRuns) * 100);
                    insights.push(`Your most common issue is ${rule} (found in ${percentage}% of scans)`);
                }

                // Score trend
                if (stats.scoreTrend.length >= 10) {
                    const firstHalf = stats.scoreTrend.slice(0, Math.floor(stats.scoreTrend.length / 2));
                    const secondHalf = stats.scoreTrend.slice(Math.floor(stats.scoreTrend.length / 2));
                    const firstAvg = firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length;
                    const secondAvg = secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length;

                    if (secondAvg > firstAvg + 5) {
                        insights.push(`Average score has improved from ${Math.round(firstAvg)} to ${Math.round(secondAvg)} over last ${stats.scoreTrend.length} runs`);
                    } else if (firstAvg > secondAvg + 5) {
                        insights.push(`Average score has declined from ${Math.round(firstAvg)} to ${Math.round(secondAvg)} over last ${stats.scoreTrend.length} runs`);
                    }
                }

                return insights;
            },

            exportJSON() {
                return JSON.stringify(this.load(), null, 2);
            },

            importJSON(json) {
                const data = JSON.parse(json); // Will throw if invalid JSON

                if (!Array.isArray(data)) {
                    throw new Error('Import data must be an array');
                }

                // Validate structure
                for (const entry of data) {
                    if (typeof entry.score !== 'number' || !Array.isArray(entry.failedRules)) {
                        throw new Error('Invalid entry structure: must have score (number) and failedRules (array)');
                    }
                }

                this.save(data);
            },

            clear() {
                localStorage.removeItem(this.STORAGE_KEY);
            }
        };

        // ============================================================================
        // TEST FRAMEWORK
        // ============================================================================

        class TestRunner {
            constructor() {
                this.tests = [];
                this.results = [];
                this.currentGroup = null;
            }

            group(name, fn) {
                this.currentGroup = name;
                fn();
                this.currentGroup = null;
            }

            test(name, fn) {
                this.tests.push({ name, fn, group: this.currentGroup });
            }

            assertEqual(actual, expected, msg) {
                if (actual !== expected) {
                    throw new Error(`${msg || 'assertEqual'}: expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`);
                }
            }

            assertTrue(val, msg) {
                if (!val) {
                    throw new Error(`${msg || 'assertTrue'}: expected truthy, got ${JSON.stringify(val)}`);
                }
            }

            assertFalse(val, msg) {
                if (val) {
                    throw new Error(`${msg || 'assertFalse'}: expected falsy, got ${JSON.stringify(val)}`);
                }
            }

            assertContains(str, substr, msg) {
                if (typeof str !== 'string' || !str.includes(substr)) {
                    throw new Error(`${msg || 'assertContains'}: "${substr}" not found in "${str}"`);
                }
            }

            assertNotContains(str, substr, msg) {
                if (typeof str === 'string' && str.includes(substr)) {
                    throw new Error(`${msg || 'assertNotContains'}: "${substr}" was found in "${str}"`);
                }
            }

            async run() {
                this.results = [];
                for (const t of this.tests) {
                    try {
                        await t.fn();
                        this.results.push({ ...t, passed: true });
                    } catch (e) {
                        this.results.push({ ...t, passed: false, error: e.message });
                    }
                }
                return this.results;
            }
        }

        // ============================================================================
        // TEST SUITE
        // ============================================================================

        const runner = new TestRunner();

        // Parser Tests
        runner.group('Parser Tests', () => {
            runner.test('detects DOCTYPE present', () => {
                const html = '<!DOCTYPE html><html><body></body></html>';
                const result = Parser.parse(html);
                runner.assertTrue(result.hasDoctype, 'Should detect DOCTYPE');
            });

            runner.test('detects DOCTYPE missing', () => {
                const html = '<html><body></body></html>';
                const result = Parser.parse(html);
                runner.assertFalse(result.hasDoctype, 'Should not detect DOCTYPE');
            });

            runner.test('detects DOCTYPE case-insensitive', () => {
                const html = '<!doctype html><html><body></body></html>';
                const result = Parser.parse(html);
                runner.assertTrue(result.hasDoctype, 'Should detect lowercase DOCTYPE');
            });

            runner.test('extracts head content', () => {
                const html = '<html><head><title>Test</title></head><body></body></html>';
                const result = Parser.parse(html);
                runner.assertContains(result.headContent, '<title>Test</title>', 'Should extract head content');
            });

            runner.test('handles missing head', () => {
                const html = '<html><body></body></html>';
                const result = Parser.parse(html);
                runner.assertFalse(result.hasHead, 'Should detect missing head');
            });

            runner.test('extracts inline scripts', () => {
                const html = '<html><body><script>var x=1;</script></body></html>';
                const result = Parser.parse(html);
                runner.assertTrue(result.scripts[0].inline, 'Should detect inline script');
                runner.assertContains(result.scripts[0].content, 'var x=1;', 'Should extract script content');
            });

            runner.test('detects external scripts', () => {
                const html = '<html><body><script src="https://cdn.example.com/lib.js"></script></body></html>';
                const result = Parser.parse(html);
                runner.assertFalse(result.scripts[0].inline, 'Should detect external script');
                runner.assertContains(result.scripts[0].src, 'https://cdn.example.com/lib.js', 'Should extract src');
            });

            runner.test('extracts charset meta', () => {
                const html = '<html><head><meta charset="UTF-8"></head><body></body></html>';
                const result = Parser.parse(html);
                runner.assertTrue(result.hasCharset, 'Should detect charset');
            });

            runner.test('extracts viewport meta', () => {
                const html = '<html><head><meta name="viewport" content="width=device-width"></head><body></body></html>';
                const result = Parser.parse(html);
                runner.assertTrue(result.hasViewport, 'Should detect viewport');
            });

            runner.test('extracts title', () => {
                const html = '<html><head><title>My App</title></head><body></body></html>';
                const result = Parser.parse(html);
                runner.assertEqual(result.title, 'My App', 'Should extract title');
            });

            runner.test('detects html lang', () => {
                const html = '<html lang="en"><body></body></html>';
                const result = Parser.parse(html);
                runner.assertEqual(result.htmlLang, 'en', 'Should extract lang attribute');
            });

            runner.test('detects localStorage usage', () => {
                const html = '<html><body><script>localStorage.setItem("key", "value");</script></body></html>';
                const result = Parser.parse(html);
                runner.assertTrue(result.hasLocalStorage, 'Should detect localStorage');
            });

            runner.test('detects external URLs', () => {
                const html = '<html><head><script src="https://example.com/x.js"></script></head><body></body></html>';
                const result = Parser.parse(html);
                runner.assertTrue(result.externalUrls.length > 0, 'Should detect external URLs');
                runner.assertContains(result.externalUrls[0], 'https://example.com/x.js', 'Should include URL');
            });

            runner.test('detects console.log', () => {
                const html = '<html><body><script>console.log("test");</script></body></html>';
                const result = Parser.parse(html);
                runner.assertTrue(result.consoleLogs.count >= 1, 'Should detect console.log');
            });

            runner.test('detects inline handlers', () => {
                const html = '<html><body><button onclick="foo()">Click</button></body></html>';
                const result = Parser.parse(html);
                runner.assertTrue(result.inlineHandlers.length > 0, 'Should detect inline handlers');
                runner.assertEqual(result.inlineHandlers[0], 'onclick', 'Should extract onclick');
            });
        });

        // Analyzer Tests
        runner.group('Analyzer Tests', () => {
            runner.test('flags missing DOCTYPE', () => {
                const html = '<html><body></body></html>';
                const parsed = Parser.parse(html);
                const analysis = Analyzer.analyze(parsed);
                const doctypeRule = analysis.results.find(r => r.rule === 'missing-doctype');
                runner.assertFalse(doctypeRule.passed, 'Should flag missing DOCTYPE');
            });

            runner.test('passes present DOCTYPE', () => {
                const html = '<!DOCTYPE html><html><body></body></html>';
                const parsed = Parser.parse(html);
                const analysis = Analyzer.analyze(parsed);
                const doctypeRule = analysis.results.find(r => r.rule === 'missing-doctype');
                runner.assertTrue(doctypeRule.passed, 'Should pass with DOCTYPE');
            });

            runner.test('flags missing charset', () => {
                const html = '<!DOCTYPE html><html><head></head><body></body></html>';
                const parsed = Parser.parse(html);
                const analysis = Analyzer.analyze(parsed);
                const charsetRule = analysis.results.find(r => r.rule === 'missing-charset');
                runner.assertFalse(charsetRule.passed, 'Should flag missing charset');
            });

            runner.test('flags missing viewport', () => {
                const html = '<!DOCTYPE html><html><head><meta charset="UTF-8"></head><body></body></html>';
                const parsed = Parser.parse(html);
                const analysis = Analyzer.analyze(parsed);
                const viewportRule = analysis.results.find(r => r.rule === 'missing-viewport');
                runner.assertFalse(viewportRule.passed, 'Should flag missing viewport');
            });

            runner.test('flags external scripts', () => {
                const html = '<!DOCTYPE html><html><head><script src="https://cdn.example.com/lib.js"></script></head><body></body></html>';
                const parsed = Parser.parse(html);
                const analysis = Analyzer.analyze(parsed);
                const scriptRule = analysis.results.find(r => r.rule === 'external-scripts');
                runner.assertFalse(scriptRule.passed, 'Should flag external scripts');
            });

            runner.test('flags external styles', () => {
                const html = '<!DOCTYPE html><html><head><link rel="stylesheet" href="https://cdn.example.com/style.css"></head><body></body></html>';
                const parsed = Parser.parse(html);
                const analysis = Analyzer.analyze(parsed);
                const styleRule = analysis.results.find(r => r.rule === 'external-styles');
                runner.assertFalse(styleRule.passed, 'Should flag external styles');
            });

            runner.test('perfect score for complete HTML', () => {
                const html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Test app">
    <title>Test</title>
    <style>
        @media (max-width: 768px) { body { font-size: 14px; } }
    </style>
</head>
<body>
    <noscript>Enable JS</noscript>
    <label for="input1">Name</label>
    <input id="input1" type="text" aria-label="Name">
    <script>
        try {
            const data = localStorage.getItem('test');
            const json = JSON.stringify({ test: true });
            const blob = new Blob([json], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'export.json';
        } catch (e) {
            console.error(e);
        }
    </script>
</body>
</html>`;
                const parsed = Parser.parse(html);
                const analysis = Analyzer.analyze(parsed);
                runner.assertEqual(analysis.score, 100, 'Should have perfect score');
            });

            runner.test('score deducts for errors', () => {
                const html = '<html><body></body></html>';
                const parsed = Parser.parse(html);
                const analysis = Analyzer.analyze(parsed);
                runner.assertTrue(analysis.score <= 55, 'Should deduct at least 45 points for missing doctype, charset, viewport');
            });

            runner.test('flags console.log', () => {
                const html = '<!DOCTYPE html><html><body><script>console.log("test");</script></body></html>';
                const parsed = Parser.parse(html);
                const analysis = Analyzer.analyze(parsed);
                const consoleRule = analysis.results.find(r => r.rule === 'console-log-pollution');
                runner.assertFalse(consoleRule.passed, 'Should flag console.log');
            });

            runner.test('flags no-localstorage', () => {
                const html = '<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"></head><body></body></html>';
                const parsed = Parser.parse(html);
                const analysis = Analyzer.analyze(parsed);
                const localStorageRule = analysis.results.find(r => r.rule === 'no-localstorage');
                runner.assertFalse(localStorageRule.passed, 'Should flag no localStorage');
            });

            runner.test('skips json-export when no localStorage', () => {
                const html = '<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"></head><body></body></html>';
                const parsed = Parser.parse(html);
                const analysis = Analyzer.analyze(parsed);
                const jsonExportRule = analysis.results.find(r => r.rule === 'no-json-export');
                runner.assertTrue(jsonExportRule.passed, 'Should skip json-export check when no localStorage');
            });

            runner.test('flags no-json-export when localStorage but no export', () => {
                const html = '<!DOCTYPE html><html><body><script>localStorage.setItem("test", "value");</script></body></html>';
                const parsed = Parser.parse(html);
                const analysis = Analyzer.analyze(parsed);
                const jsonExportRule = analysis.results.find(r => r.rule === 'no-json-export');
                runner.assertFalse(jsonExportRule.passed, 'Should flag missing JSON export when localStorage is used');
            });

            runner.test('detects hardcoded API keys', () => {
                const html = '<!DOCTYPE html><html><body><script>const API_KEY = "abc123def456ghi789jkl012";</script></body></html>';
                const parsed = Parser.parse(html);
                const analysis = Analyzer.analyze(parsed);
                const apiKeyRule = analysis.results.find(r => r.rule === 'hardcoded-api-keys');
                runner.assertFalse(apiKeyRule.passed, 'Should detect hardcoded API keys');
            });

            runner.test('flags inline onclick', () => {
                const html = '<!DOCTYPE html><html><body><button onclick="alert()">Click</button></body></html>';
                const parsed = Parser.parse(html);
                const analysis = Analyzer.analyze(parsed);
                const onclickRule = analysis.results.find(r => r.rule === 'inline-onclick');
                runner.assertFalse(onclickRule.passed, 'Should flag inline onclick');
            });

            runner.test('passes inline onclick when none present', () => {
                const html = '<!DOCTYPE html><html><body><button>Click</button></body></html>';
                const parsed = Parser.parse(html);
                const analysis = Analyzer.analyze(parsed);
                const onclickRule = analysis.results.find(r => r.rule === 'inline-onclick');
                runner.assertTrue(onclickRule.passed, 'Should pass when no inline handlers');
            });
        });

        // Improver Tests
        runner.group('Improver Tests', () => {
            runner.test('adds DOCTYPE when missing', () => {
                const html = '<html><body></body></html>';
                const result = Improver.improve(html);
                runner.assertContains(result.html, '<!DOCTYPE html>', 'Should add DOCTYPE');
                runner.assertTrue(result.html.indexOf('<!DOCTYPE html>') === 0, 'DOCTYPE should be at start');
            });

            runner.test('adds charset when missing', () => {
                const html = '<!DOCTYPE html><html><head></head><body></body></html>';
                const result = Improver.improve(html);
                runner.assertContains(result.html, '<meta charset="UTF-8">', 'Should add charset');
            });

            runner.test('adds viewport when missing', () => {
                const html = '<!DOCTYPE html><html><head><meta charset="UTF-8"></head><body></body></html>';
                const result = Improver.improve(html);
                runner.assertContains(result.html, 'viewport', 'Should add viewport');
            });

            runner.test('adds lang when missing', () => {
                const html = '<!DOCTYPE html><html><head></head><body></body></html>';
                const result = Improver.improve(html);
                runner.assertContains(result.html, '<html lang="en">', 'Should add lang attribute');
            });

            runner.test('comments out console.log', () => {
                const html = '<!DOCTYPE html><html><body><script>console.log("test");</script></body></html>';
                const result = Improver.improve(html);
                runner.assertContains(result.html, '// [DataSlosh]', 'Should comment out console.log');
            });

            runner.test('adds noscript when missing', () => {
                const html = '<!DOCTYPE html><html><head></head><body></body></html>';
                const result = Improver.improve(html);
                runner.assertContains(result.html, '<noscript>', 'Should add noscript');
            });

            runner.test('does not double DOCTYPE', () => {
                const html = '<!DOCTYPE html><html><body></body></html>';
                const result = Improver.improve(html);
                const doctypeCount = (result.html.match(/<!DOCTYPE/gi) || []).length;
                runner.assertEqual(doctypeCount, 1, 'Should have exactly one DOCTYPE');
            });

            runner.test('no changes on correct file', () => {
                const html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test</title>
</head>
<body>
    <noscript>Enable JS</noscript>
</body>
</html>`;
                const result = Improver.improve(html);
                runner.assertEqual(result.changes.length, 0, 'Should have no changes for correct HTML');
            });

            runner.test('score improves after fixes', () => {
                const html = '<html><body></body></html>';
                const originalParsed = Parser.parse(html);
                const originalAnalysis = Analyzer.analyze(originalParsed);

                const improved = Improver.improve(html);
                const improvedParsed = Parser.parse(improved.html);
                const improvedAnalysis = Analyzer.analyze(improvedParsed);

                runner.assertTrue(improvedAnalysis.score >= originalAnalysis.score, 'Improved score should be >= original');
            });

            runner.test('content preserved', () => {
                const html = '<!DOCTYPE html><html><body><h1>Hello World</h1><p>Test content</p></body></html>';
                const result = Improver.improve(html);
                runner.assertContains(result.html, 'Hello World', 'Should preserve body content');
                runner.assertContains(result.html, 'Test content', 'Should preserve all content');
            });
        });

        // Differ Tests
        runner.group('Differ Tests', () => {
            runner.test('identical = no changes', () => {
                const result = Differ.diff('abc', 'abc');
                runner.assertEqual(result.stats.added, 0, 'Should have no added lines');
                runner.assertEqual(result.stats.removed, 0, 'Should have no removed lines');
            });

            runner.test('detects added lines', () => {
                const result = Differ.diff('a', 'a\nb');
                runner.assertEqual(result.stats.added, 1, 'Should detect 1 added line');
            });

            runner.test('detects removed lines', () => {
                const result = Differ.diff('a\nb', 'a');
                runner.assertEqual(result.stats.removed, 1, 'Should detect 1 removed line');
            });

            runner.test('HTML output is valid', () => {
                const diffResult = Differ.diff('line1', 'line2');
                const html = Differ.toHTML(diffResult);
                runner.assertContains(html, '<div', 'Should contain div elements');
            });

            runner.test('XSS escaped', () => {
                const diffResult = Differ.diff('<script>alert("xss")</script>', 'safe');
                const html = Differ.toHTML(diffResult);
                runner.assertContains(html, '&lt;script&gt;', 'Should escape script tags');
                runner.assertNotContains(html, '<script>', 'Should not contain raw script tags');
            });
        });

        // History Tests
        runner.group('History Tests', () => {
            let originalStorage;

            // Save and mock localStorage for tests
            runner.test('starts empty', () => {
                originalStorage = History.load();
                History.clear();
                const loaded = History.load();
                runner.assertEqual(loaded.length, 0, 'Should start empty');
            });

            runner.test('records a run', () => {
                History.clear();
                History.record({
                    filename: 'test.html',
                    score: 80,
                    failedRules: ['x'],
                    timestamp: Date.now()
                });
                const loaded = History.load();
                runner.assertEqual(loaded.length, 1, 'Should have 1 entry');
            });

            runner.test('updates rule stats', () => {
                History.clear();
                History.record({
                    filename: 'test.html',
                    score: 80,
                    failedRules: ['x'],
                    timestamp: Date.now()
                });
                const stats = History.getStats();
                runner.assertEqual(stats.ruleFrequency.x, 1, 'Should count rule x once');
            });

            runner.test('computes avg score', () => {
                History.clear();
                History.record({ filename: 'test1.html', score: 80, failedRules: [], timestamp: Date.now() });
                History.record({ filename: 'test2.html', score: 60, failedRules: [], timestamp: Date.now() });
                const stats = History.getStats();
                runner.assertEqual(stats.avgScore, 70, 'Should compute average score');
            });

            runner.test('respects MAX_ENTRIES', () => {
                History.clear();
                for (let i = 0; i < 201; i++) {
                    History.record({ filename: `test${i}.html`, score: 50, failedRules: [], timestamp: Date.now() });
                }
                const loaded = History.load();
                runner.assertEqual(loaded.length, 200, 'Should trim to MAX_ENTRIES');
            });

            runner.test('getInsights returns array', () => {
                History.clear();
                const insights = History.getInsights();
                runner.assertTrue(Array.isArray(insights), 'Should return array');
            });

            runner.test('exportJSON round-trips', () => {
                History.clear();
                History.record({ filename: 'test.html', score: 75, failedRules: ['a', 'b'], timestamp: 1234567890 });
                const exported = History.exportJSON();
                History.clear();
                History.importJSON(exported);
                const loaded = History.load();
                runner.assertEqual(loaded.length, 1, 'Should have 1 entry after import');
                runner.assertEqual(loaded[0].score, 75, 'Should preserve score');
            });

            runner.test('importJSON rejects invalid', () => {
                let errorThrown = false;
                try {
                    History.importJSON('not json');
                } catch (e) {
                    errorThrown = true;
                }
                runner.assertTrue(errorThrown, 'Should throw error for invalid JSON');
            });

            // Cleanup: restore original storage
            if (originalStorage) {
                History.save(originalStorage);
            }
        });

        // Integration Tests
        runner.group('Integration Tests', () => {
            runner.test('full pipeline on minimal HTML', () => {
                const html = '<html><body>Hi</body></html>';
                const parsed = Parser.parse(html);
                const analysis = Analyzer.analyze(parsed);
                const improved = Improver.improve(html);
                const diff = Differ.diff(html, improved.html);

                runner.assertTrue(parsed !== null, 'Parser should return result');
                runner.assertTrue(typeof analysis.score === 'number', 'Analyzer should return score');
                runner.assertTrue(improved.html.length > 0, 'Improver should return HTML');
                runner.assertTrue(diff.lines.length > 0, 'Differ should return lines');
            });

            runner.test('handles empty string', () => {
                const parsed = Parser.parse('');
                runner.assertTrue(parsed !== null, 'Parser should handle empty string');
                runner.assertFalse(parsed.hasDoctype, 'Should not have DOCTYPE');
            });

            runner.test('handles well-formed HTML', () => {
                const html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Test">
    <title>Test</title>
</head>
<body>
    <noscript>Enable JS</noscript>
    <h1>Test</h1>
</body>
</html>`;
                const parsed = Parser.parse(html);
                const analysis = Analyzer.analyze(parsed);
                runner.assertTrue(analysis.score >= 85, 'Should have high score for well-formed HTML');
            });

            runner.test('handles headless HTML', () => {
                const html = '<!DOCTYPE html><html><body>Content</body></html>';
                const improved = Improver.improve(html);
                runner.assertContains(improved.html, '<meta charset="UTF-8">', 'Should add head with charset');
                runner.assertContains(improved.html, 'viewport', 'Should add viewport');
            });

            runner.test('handles large input', () => {
                let largeHtml = '<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"></head><body>\n';
                for (let i = 0; i < 1000; i++) {
                    largeHtml += `<div>Line ${i}</div>\n`;
                }
                largeHtml += '</body></html>';

                const parsed = Parser.parse(largeHtml);
                const analysis = Analyzer.analyze(parsed);
                const improved = Improver.improve(largeHtml);
                const diff = Differ.diff(largeHtml, improved.html);

                runner.assertTrue(parsed !== null, 'Should parse large HTML');
                runner.assertTrue(typeof analysis.score === 'number', 'Should analyze large HTML');
                runner.assertTrue(improved.html.length > 0, 'Should improve large HTML');
                runner.assertTrue(diff.lines.length > 0, 'Should diff large HTML');
            });
        });

        // ============================================================================
        // UI RENDERING
        // ============================================================================

        async function runAllTests() {
            const runBtn = document.getElementById('run-btn');
            const summaryTitle = document.getElementById('summary-title');
            const resultsContainer = document.getElementById('test-results');

            runBtn.disabled = true;
            runBtn.textContent = 'Running tests...';
            runBtn.classList.add('running');
            summaryTitle.innerHTML = '<span class="spinner"></span> Running tests...';
            resultsContainer.innerHTML = '';

            // Run tests
            const results = await runner.run();

            // Compute stats
            const passed = results.filter(r => r.passed).length;
            const failed = results.filter(r => !r.passed).length;
            const total = results.length;

            // Update summary
            document.getElementById('stat-passed').textContent = passed;
            document.getElementById('stat-failed').textContent = failed;
            document.getElementById('stat-total').textContent = total;

            if (failed === 0) {
                summaryTitle.textContent = 'All tests passed!';
                summaryTitle.style.color = '#4caf50';
            } else {
                summaryTitle.textContent = `${failed} test${failed === 1 ? '' : 's'} failed`;
                summaryTitle.style.color = '#f44336';
            }

            // Group results
            const groups = {};
            results.forEach(result => {
                const groupName = result.group || 'Other';
                if (!groups[groupName]) {
                    groups[groupName] = [];
                }
                groups[groupName].push(result);
            });

            // Render groups
            Object.entries(groups).forEach(([groupName, tests]) => {
                const groupPassed = tests.filter(t => t.passed).length;
                const groupFailed = tests.filter(t => !t.passed).length;

                const groupDiv = document.createElement('div');
                groupDiv.className = 'test-group';

                const headerDiv = document.createElement('div');
                headerDiv.className = 'group-header';
                headerDiv.innerHTML = `
                    <div class="group-title">${groupName}</div>
                    <div class="group-stats">
                        <span class="pass">${groupPassed} passed</span> /
                        <span class="fail">${groupFailed} failed</span>
                    </div>
                `;

                const testList = document.createElement('div');
                testList.className = 'test-list';

                tests.forEach(test => {
                    const testDiv = document.createElement('div');
                    testDiv.className = `test-item ${test.passed ? 'passed' : 'failed'}`;

                    let html = `
                        <div class="test-name">
                            <span class="test-icon ${test.passed ? 'passed' : 'failed'}">
                                ${test.passed ? '' : ''}
                            </span>
                            <span>${test.name}</span>
                        </div>
                    `;

                    if (!test.passed && test.error) {
                        html += `<div class="test-error">${test.error}</div>`;
                    }

                    testDiv.innerHTML = html;
                    testList.appendChild(testDiv);
                });

                headerDiv.onclick = () => {
                    testList.classList.toggle('collapsed');
                };

                groupDiv.appendChild(headerDiv);
                groupDiv.appendChild(testList);
                resultsContainer.appendChild(groupDiv);
            });

            runBtn.disabled = false;
            runBtn.textContent = 'Run Tests Again';
            runBtn.classList.remove('running');
        }

        // Auto-run on load
        window.addEventListener('load', runAllTests);
    </script>
</body>
</html>