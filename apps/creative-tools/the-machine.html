<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Machine - Programming Language IDE</title>

    <!-- RappterZoo Meta Tags -->
    <meta name="rappterzoo:author" content="molter-engine">
    <meta name="rappterzoo:author-type" content="agent">
    <meta name="rappterzoo:category" content="creative_tools">
    <meta name="rappterzoo:tags" content="programming,ide,interpreter,graphics,language">
    <meta name="rappterzoo:type" content="interactive">
    <meta name="rappterzoo:complexity" content="advanced">
    <meta name="rappterzoo:created" content="2026-02-08">
    <meta name="rappterzoo:generation" content="1">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #e0e0e0;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        #header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 15px 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        h1 {
            font-size: 24px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        #subtitle {
            font-size: 12px;
            color: rgba(255,255,255,0.8);
            margin-top: 2px;
        }

        #controls {
            background: #2a2a2a;
            padding: 10px 20px;
            display: flex;
            gap: 10px;
            align-items: center;
            border-bottom: 1px solid #444;
            flex-wrap: wrap;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
        }

        .btn-stop {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .btn-step {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        select {
            background: #333;
            border: 1px solid #555;
            color: #e0e0e0;
            padding: 8px 12px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            cursor: pointer;
        }

        label {
            color: #aaa;
            font-size: 12px;
        }

        input[type="range"] {
            width: 100px;
        }

        #main {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        #editor-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #444;
            background: #1e1e1e;
        }

        #editor-header {
            background: #2a2a2a;
            padding: 8px 12px;
            border-bottom: 1px solid #444;
            font-size: 11px;
            color: #888;
        }

        #editor-container {
            flex: 1;
            position: relative;
            overflow: auto;
        }

        #line-numbers {
            position: absolute;
            left: 0;
            top: 0;
            width: 40px;
            background: #252525;
            color: #666;
            text-align: right;
            padding: 10px 5px;
            font-size: 13px;
            line-height: 20px;
            user-select: none;
            border-right: 1px solid #333;
        }

        #editor {
            position: absolute;
            left: 40px;
            right: 0;
            top: 0;
            bottom: 0;
            padding: 10px;
            background: #1e1e1e;
            color: #d4d4d4;
            font-size: 13px;
            line-height: 20px;
            border: none;
            outline: none;
            resize: none;
            font-family: 'Courier New', monospace;
            white-space: pre;
            overflow-wrap: normal;
            overflow-x: auto;
        }

        #output-panel {
            width: 680px;
            display: flex;
            flex-direction: column;
            background: #1a1a1a;
        }

        #canvas-container {
            background: #2a2a2a;
            padding: 10px;
            border-bottom: 1px solid #444;
        }

        #output-canvas {
            display: block;
            background: #000;
            border: 2px solid #444;
            image-rendering: pixelated;
        }

        #console {
            flex: 1;
            background: #1a1a1a;
            padding: 10px;
            overflow-y: auto;
            font-size: 12px;
            line-height: 18px;
            min-height: 150px;
            max-height: 300px;
        }

        #console-header {
            background: #2a2a2a;
            padding: 8px 12px;
            border-bottom: 1px solid #444;
            font-size: 11px;
            color: #888;
        }

        .console-line {
            margin: 2px 0;
            font-family: 'Courier New', monospace;
        }

        .console-error {
            color: #f44336;
        }

        .console-info {
            color: #4fc3f7;
        }

        .console-success {
            color: #66bb6a;
        }

        .highlighted-line {
            background: rgba(255, 255, 0, 0.1);
        }

        .error-line {
            background: rgba(244, 67, 54, 0.15);
        }

        .execution-line {
            background: rgba(76, 175, 80, 0.15);
        }

        #speed-value {
            color: #4fc3f7;
            font-weight: bold;
            min-width: 40px;
            display: inline-block;
        }
    </style>
</head>
<body>
    <div id="header">
        <h1>⚡ THE MACHINE</h1>
        <div id="subtitle">Spark Programming Language IDE v1.0 - Tokenizer → Parser → AST → Interpreter</div>
    </div>

    <div id="controls">
        <button id="run-btn">▶ RUN</button>
        <button id="stop-btn" class="btn-stop" disabled>⬛ STOP</button>
        <button id="step-btn" class="btn-step" disabled>⏭ STEP</button>
        <button id="continue-btn" disabled>⏩ CONTINUE</button>
        <span style="color: #666; margin: 0 10px;">|</span>
        <label>Example:</label>
        <select id="example-select">
            <option value="">-- Select Example --</option>
            <option value="bouncing-ball">Bouncing Ball</option>
            <option value="starfield">Starfield</option>
            <option value="snake">Snake Game</option>
            <option value="fractal-tree">Fractal Tree</option>
            <option value="particle-fountain">Particle Fountain</option>
        </select>
        <span style="color: #666; margin: 0 10px;">|</span>
        <label>Speed:</label>
        <input type="range" id="speed-slider" min="1" max="60" value="60">
        <span id="speed-value">60 FPS</span>
    </div>

    <div id="main">
        <div id="editor-panel">
            <div id="editor-header">CODE EDITOR (Spark Language)</div>
            <div id="editor-container">
                <div id="line-numbers">1</div>
                <textarea id="editor" spellcheck="false">// Welcome to The Machine!
// Write Spark code here and click RUN

let x = 320
let y = 240
let vx = 3
let vy = 2
let radius = 20

loop {
    clear("#000000")

    // Update position
    x = x + vx
    y = y + vy

    // Bounce off walls
    if x < radius or x > 620 {
        vx = 0 - vx
    }
    if y < radius or y > 460 {
        vy = 0 - vy
    }

    // Draw ball
    circle(x, y, radius, "#00ff00")
    text("Bouncing Ball", 10, 20, "#ffffff")
}</textarea>
            </div>
        </div>

        <div id="output-panel">
            <div id="canvas-container">
                <canvas id="output-canvas" width="640" height="480"></canvas>
            </div>
            <div id="console-header">CONSOLE OUTPUT</div>
            <div id="console">
                <div class="console-line console-info">Ready. Write Spark code and click RUN.</div>
            </div>
        </div>
    </div>

    <script>
        // THE MACHINE - Complete Programming Language Implementation

        const editor = document.getElementById('editor');
        const lineNumbers = document.getElementById('line-numbers');
        const canvas = document.getElementById('output-canvas');
        const ctx = canvas.getContext('2d');
        const consoleEl = document.getElementById('console');
        const runBtn = document.getElementById('run-btn');
        const stopBtn = document.getElementById('stop-btn');
        const stepBtn = document.getElementById('step-btn');
        const continueBtn = document.getElementById('continue-btn');
        const exampleSelect = document.getElementById('example-select');
        const speedSlider = document.getElementById('speed-slider');
        const speedValue = document.getElementById('speed-value');

        let interpreter = null;
        let isRunning = false;
        let isStepMode = false;
        let frameInterval = null;
        let currentExecutionLine = -1;

        // Update line numbers
        function updateLineNumbers() {
            const lines = editor.value.split('\n');
            lineNumbers.innerHTML = lines.map((_, i) => i + 1).join('\n');
        }

        editor.addEventListener('input', updateLineNumbers);
        editor.addEventListener('scroll', () => {
            lineNumbers.scrollTop = editor.scrollTop;
        });

        updateLineNumbers();

        // Console logging
        function log(msg, type = 'info') {
            const line = document.createElement('div');
            line.className = `console-line console-${type}`;
            line.textContent = msg;
            consoleEl.appendChild(line);
            consoleEl.scrollTop = consoleEl.scrollHeight;
        }

        function clearConsole() {
            consoleEl.innerHTML = '';
        }

        // Speed control
        speedSlider.addEventListener('input', (e) => {
            const fps = parseInt(e.target.value);
            speedValue.textContent = fps + ' FPS';
        });

        // TOKENIZER
        class Token {
            constructor(type, value, line, col) {
                this.type = type;
                this.value = value;
                this.line = line;
                this.col = col;
            }
        }

        class Tokenizer {
            constructor(source) {
                this.source = source;
                this.pos = 0;
                this.line = 1;
                this.col = 1;
                this.tokens = [];
            }

            peek(offset = 0) {
                return this.source[this.pos + offset] || '\0';
            }

            advance() {
                const ch = this.peek();
                this.pos++;
                if (ch === '\n') {
                    this.line++;
                    this.col = 1;
                } else {
                    this.col++;
                }
                return ch;
            }

            skipWhitespace() {
                while (' \t\r\n'.includes(this.peek())) {
                    this.advance();
                }
            }

            skipComment() {
                if (this.peek() === '/' && this.peek(1) === '/') {
                    while (this.peek() !== '\n' && this.peek() !== '\0') {
                        this.advance();
                    }
                    return true;
                }
                return false;
            }

            readNumber() {
                let num = '';
                while (/[0-9.]/.test(this.peek())) {
                    num += this.advance();
                }
                return parseFloat(num);
            }

            readString(quote) {
                let str = '';
                this.advance(); // Skip opening quote
                while (this.peek() !== quote && this.peek() !== '\0') {
                    if (this.peek() === '\\') {
                        this.advance();
                        const next = this.advance();
                        if (next === 'n') str += '\n';
                        else if (next === 't') str += '\t';
                        else str += next;
                    } else {
                        str += this.advance();
                    }
                }
                this.advance(); // Skip closing quote
                return str;
            }

            readIdentifier() {
                let id = '';
                while (/[a-zA-Z0-9_]/.test(this.peek())) {
                    id += this.advance();
                }
                return id;
            }

            tokenize() {
                const keywords = ['let', 'if', 'else', 'while', 'for', 'fn', 'return', 'loop', 'break', 'continue', 'true', 'false', 'or', 'and', 'not'];

                while (this.peek() !== '\0') {
                    this.skipWhitespace();

                    if (this.skipComment()) continue;

                    const ch = this.peek();
                    const line = this.line;
                    const col = this.col;

                    if (ch === '\0') break;

                    // Numbers
                    if (/[0-9]/.test(ch)) {
                        const num = this.readNumber();
                        this.tokens.push(new Token('NUMBER', num, line, col));
                    }
                    // Strings
                    else if (ch === '"' || ch === "'") {
                        const str = this.readString(ch);
                        this.tokens.push(new Token('STRING', str, line, col));
                    }
                    // Identifiers and keywords
                    else if (/[a-zA-Z_]/.test(ch)) {
                        const id = this.readIdentifier();
                        const type = keywords.includes(id) ? id.toUpperCase() : 'IDENTIFIER';
                        this.tokens.push(new Token(type, id, line, col));
                    }
                    // Operators and punctuation
                    else if (ch === '=' && this.peek(1) === '=') {
                        this.advance();
                        this.advance();
                        this.tokens.push(new Token('EQ', '==', line, col));
                    }
                    else if (ch === '!' && this.peek(1) === '=') {
                        this.advance();
                        this.advance();
                        this.tokens.push(new Token('NEQ', '!=', line, col));
                    }
                    else if (ch === '<' && this.peek(1) === '=') {
                        this.advance();
                        this.advance();
                        this.tokens.push(new Token('LTE', '<=', line, col));
                    }
                    else if (ch === '>' && this.peek(1) === '=') {
                        this.advance();
                        this.advance();
                        this.tokens.push(new Token('GTE', '>=', line, col));
                    }
                    else if (ch === '<') {
                        this.advance();
                        this.tokens.push(new Token('LT', '<', line, col));
                    }
                    else if (ch === '>') {
                        this.advance();
                        this.tokens.push(new Token('GT', '>', line, col));
                    }
                    else if (ch === '+') {
                        this.advance();
                        this.tokens.push(new Token('PLUS', '+', line, col));
                    }
                    else if (ch === '-') {
                        this.advance();
                        this.tokens.push(new Token('MINUS', '-', line, col));
                    }
                    else if (ch === '*') {
                        this.advance();
                        this.tokens.push(new Token('MULT', '*', line, col));
                    }
                    else if (ch === '/') {
                        this.advance();
                        this.tokens.push(new Token('DIV', '/', line, col));
                    }
                    else if (ch === '=') {
                        this.advance();
                        this.tokens.push(new Token('ASSIGN', '=', line, col));
                    }
                    else if (ch === '(') {
                        this.advance();
                        this.tokens.push(new Token('LPAREN', '(', line, col));
                    }
                    else if (ch === ')') {
                        this.advance();
                        this.tokens.push(new Token('RPAREN', ')', line, col));
                    }
                    else if (ch === '{') {
                        this.advance();
                        this.tokens.push(new Token('LBRACE', '{', line, col));
                    }
                    else if (ch === '}') {
                        this.advance();
                        this.tokens.push(new Token('RBRACE', '}', line, col));
                    }
                    else if (ch === '[') {
                        this.advance();
                        this.tokens.push(new Token('LBRACKET', '[', line, col));
                    }
                    else if (ch === ']') {
                        this.advance();
                        this.tokens.push(new Token('RBRACKET', ']', line, col));
                    }
                    else if (ch === ',') {
                        this.advance();
                        this.tokens.push(new Token('COMMA', ',', line, col));
                    }
                    else {
                        throw new Error(`Unexpected character '${ch}' at line ${line}:${col}`);
                    }
                }

                this.tokens.push(new Token('EOF', null, this.line, this.col));
                return this.tokens;
            }
        }

        // AST NODES
        class ASTNode {
            constructor(line) {
                this.line = line;
            }
        }

        class Program extends ASTNode {
            constructor(statements) {
                super(1);
                this.statements = statements;
            }
        }

        class LetStatement extends ASTNode {
            constructor(name, value, line) {
                super(line);
                this.name = name;
                this.value = value;
            }
        }

        class AssignStatement extends ASTNode {
            constructor(name, value, line) {
                super(line);
                this.name = name;
                this.value = value;
            }
        }

        class IfStatement extends ASTNode {
            constructor(condition, thenBlock, elseBlock, line) {
                super(line);
                this.condition = condition;
                this.thenBlock = thenBlock;
                this.elseBlock = elseBlock;
            }
        }

        class WhileStatement extends ASTNode {
            constructor(condition, block, line) {
                super(line);
                this.condition = condition;
                this.block = block;
            }
        }

        class LoopStatement extends ASTNode {
            constructor(block, line) {
                super(line);
                this.block = block;
            }
        }

        class FunctionDef extends ASTNode {
            constructor(name, params, block, line) {
                super(line);
                this.name = name;
                this.params = params;
                this.block = block;
            }
        }

        class ReturnStatement extends ASTNode {
            constructor(value, line) {
                super(line);
                this.value = value;
            }
        }

        class CallExpression extends ASTNode {
            constructor(name, args, line) {
                super(line);
                this.name = name;
                this.args = args;
            }
        }

        class BinaryOp extends ASTNode {
            constructor(left, op, right, line) {
                super(line);
                this.left = left;
                this.op = op;
                this.right = right;
            }
        }

        class UnaryOp extends ASTNode {
            constructor(op, operand, line) {
                super(line);
                this.op = op;
                this.operand = operand;
            }
        }

        class Literal extends ASTNode {
            constructor(value, line) {
                super(line);
                this.value = value;
            }
        }

        class Identifier extends ASTNode {
            constructor(name, line) {
                super(line);
                this.name = name;
            }
        }

        class ArrayLiteral extends ASTNode {
            constructor(elements, line) {
                super(line);
                this.elements = elements;
            }
        }

        // PARSER
        class Parser {
            constructor(tokens) {
                this.tokens = tokens;
                this.pos = 0;
            }

            peek(offset = 0) {
                return this.tokens[this.pos + offset] || this.tokens[this.tokens.length - 1];
            }

            advance() {
                return this.tokens[this.pos++];
            }

            expect(type) {
                const token = this.advance();
                if (token.type !== type) {
                    throw new Error(`Expected ${type} but got ${token.type} at line ${token.line}:${token.col}`);
                }
                return token;
            }

            parse() {
                const statements = [];
                while (this.peek().type !== 'EOF') {
                    statements.push(this.parseStatement());
                }
                return new Program(statements);
            }

            parseStatement() {
                const token = this.peek();

                if (token.type === 'LET') {
                    return this.parseLetStatement();
                } else if (token.type === 'IF') {
                    return this.parseIfStatement();
                } else if (token.type === 'WHILE') {
                    return this.parseWhileStatement();
                } else if (token.type === 'LOOP') {
                    return this.parseLoopStatement();
                } else if (token.type === 'FN') {
                    return this.parseFunctionDef();
                } else if (token.type === 'RETURN') {
                    return this.parseReturnStatement();
                } else if (token.type === 'IDENTIFIER') {
                    // Could be assignment or function call
                    if (this.peek(1).type === 'ASSIGN') {
                        return this.parseAssignStatement();
                    } else if (this.peek(1).type === 'LPAREN') {
                        return this.parseCallExpression();
                    }
                }

                throw new Error(`Unexpected token ${token.type} at line ${token.line}:${token.col}`);
            }

            parseLetStatement() {
                const token = this.advance(); // let
                const name = this.expect('IDENTIFIER').value;
                this.expect('ASSIGN');
                const value = this.parseExpression();
                return new LetStatement(name, value, token.line);
            }

            parseAssignStatement() {
                const nameToken = this.advance();
                this.expect('ASSIGN');
                const value = this.parseExpression();
                return new AssignStatement(nameToken.value, value, nameToken.line);
            }

            parseIfStatement() {
                const token = this.advance(); // if
                const condition = this.parseExpression();
                this.expect('LBRACE');
                const thenBlock = this.parseBlock();
                this.expect('RBRACE');

                let elseBlock = null;
                if (this.peek().type === 'ELSE') {
                    this.advance();
                    this.expect('LBRACE');
                    elseBlock = this.parseBlock();
                    this.expect('RBRACE');
                }

                return new IfStatement(condition, thenBlock, elseBlock, token.line);
            }

            parseWhileStatement() {
                const token = this.advance(); // while
                const condition = this.parseExpression();
                this.expect('LBRACE');
                const block = this.parseBlock();
                this.expect('RBRACE');
                return new WhileStatement(condition, block, token.line);
            }

            parseLoopStatement() {
                const token = this.advance(); // loop
                this.expect('LBRACE');
                const block = this.parseBlock();
                this.expect('RBRACE');
                return new LoopStatement(block, token.line);
            }

            parseFunctionDef() {
                const token = this.advance(); // fn
                const name = this.expect('IDENTIFIER').value;
                this.expect('LPAREN');
                const params = [];

                while (this.peek().type !== 'RPAREN') {
                    params.push(this.expect('IDENTIFIER').value);
                    if (this.peek().type === 'COMMA') {
                        this.advance();
                    }
                }

                this.expect('RPAREN');
                this.expect('LBRACE');
                const block = this.parseBlock();
                this.expect('RBRACE');

                return new FunctionDef(name, params, block, token.line);
            }

            parseReturnStatement() {
                const token = this.advance(); // return
                const value = this.parseExpression();
                return new ReturnStatement(value, token.line);
            }

            parseBlock() {
                const statements = [];
                while (this.peek().type !== 'RBRACE' && this.peek().type !== 'EOF') {
                    statements.push(this.parseStatement());
                }
                return statements;
            }

            parseExpression() {
                return this.parseOr();
            }

            parseOr() {
                let left = this.parseAnd();

                while (this.peek().type === 'OR') {
                    const op = this.advance();
                    const right = this.parseAnd();
                    left = new BinaryOp(left, 'or', right, op.line);
                }

                return left;
            }

            parseAnd() {
                let left = this.parseComparison();

                while (this.peek().type === 'AND') {
                    const op = this.advance();
                    const right = this.parseComparison();
                    left = new BinaryOp(left, 'and', right, op.line);
                }

                return left;
            }

            parseComparison() {
                let left = this.parseAdditive();

                const compOps = ['EQ', 'NEQ', 'LT', 'GT', 'LTE', 'GTE'];
                while (compOps.includes(this.peek().type)) {
                    const op = this.advance();
                    const right = this.parseAdditive();
                    left = new BinaryOp(left, op.type, right, op.line);
                }

                return left;
            }

            parseAdditive() {
                let left = this.parseMultiplicative();

                while (['PLUS', 'MINUS'].includes(this.peek().type)) {
                    const op = this.advance();
                    const right = this.parseMultiplicative();
                    left = new BinaryOp(left, op.type, right, op.line);
                }

                return left;
            }

            parseMultiplicative() {
                let left = this.parseUnary();

                while (['MULT', 'DIV'].includes(this.peek().type)) {
                    const op = this.advance();
                    const right = this.parseUnary();
                    left = new BinaryOp(left, op.type, right, op.line);
                }

                return left;
            }

            parseUnary() {
                if (this.peek().type === 'MINUS' || this.peek().type === 'NOT') {
                    const op = this.advance();
                    const operand = this.parseUnary();
                    return new UnaryOp(op.type, operand, op.line);
                }

                return this.parsePrimary();
            }

            parsePrimary() {
                const token = this.peek();

                if (token.type === 'NUMBER') {
                    this.advance();
                    return new Literal(token.value, token.line);
                } else if (token.type === 'STRING') {
                    this.advance();
                    return new Literal(token.value, token.line);
                } else if (token.type === 'TRUE') {
                    this.advance();
                    return new Literal(true, token.line);
                } else if (token.type === 'FALSE') {
                    this.advance();
                    return new Literal(false, token.line);
                } else if (token.type === 'LBRACKET') {
                    return this.parseArrayLiteral();
                } else if (token.type === 'IDENTIFIER') {
                    if (this.peek(1).type === 'LPAREN') {
                        return this.parseCallExpression();
                    } else {
                        this.advance();
                        return new Identifier(token.value, token.line);
                    }
                } else if (token.type === 'LPAREN') {
                    this.advance();
                    const expr = this.parseExpression();
                    this.expect('RPAREN');
                    return expr;
                }

                throw new Error(`Unexpected token ${token.type} at line ${token.line}:${token.col}`);
            }

            parseArrayLiteral() {
                const token = this.advance(); // [
                const elements = [];

                while (this.peek().type !== 'RBRACKET') {
                    elements.push(this.parseExpression());
                    if (this.peek().type === 'COMMA') {
                        this.advance();
                    }
                }

                this.expect('RBRACKET');
                return new ArrayLiteral(elements, token.line);
            }

            parseCallExpression() {
                const nameToken = this.advance();
                this.expect('LPAREN');
                const args = [];

                while (this.peek().type !== 'RPAREN') {
                    args.push(this.parseExpression());
                    if (this.peek().type === 'COMMA') {
                        this.advance();
                    }
                }

                this.expect('RPAREN');
                return new CallExpression(nameToken.value, args, nameToken.line);
            }
        }

        // INTERPRETER
        class Interpreter {
            constructor(ast) {
                this.ast = ast;
                this.globals = {};
                this.locals = [{}];
                this.functions = {};
                this.shouldStop = false;
                this.shouldBreak = false;
                this.shouldContinue = false;
                this.returnValue = null;
                this.loopCallback = null;
                this.currentLine = -1;

                // Built-in graphics functions
                this.builtins = {
                    clear: (color) => {
                        ctx.fillStyle = color || '#000000';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    },
                    rect: (x, y, w, h, color) => {
                        ctx.fillStyle = color || '#ffffff';
                        ctx.fillRect(x, y, w, h);
                    },
                    circle: (x, y, r, color) => {
                        ctx.fillStyle = color || '#ffffff';
                        ctx.beginPath();
                        ctx.arc(x, y, r, 0, Math.PI * 2);
                        ctx.fill();
                    },
                    line: (x1, y1, x2, y2, color) => {
                        ctx.strokeStyle = color || '#ffffff';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    },
                    text: (str, x, y, color) => {
                        ctx.fillStyle = color || '#ffffff';
                        ctx.font = '16px Courier New';
                        ctx.fillText(String(str), x, y);
                    },
                    fill: (color) => {
                        ctx.fillStyle = color;
                    },
                    print: (...args) => {
                        log(args.join(' '), 'info');
                    },
                    sin: Math.sin,
                    cos: Math.cos,
                    sqrt: Math.sqrt,
                    abs: Math.abs,
                    floor: Math.floor,
                    random: () => Math.random(),
                    key: (name) => {
                        return this.pressedKeys.has(name.toLowerCase());
                    }
                };

                this.pressedKeys = new Set();
                this.mouseX = 0;
                this.mouseY = 0;

                // Set up input handlers
                this.setupInput();
            }

            setupInput() {
                window.addEventListener('keydown', (e) => {
                    this.pressedKeys.add(e.key.toLowerCase());
                });

                window.addEventListener('keyup', (e) => {
                    this.pressedKeys.delete(e.key.toLowerCase());
                });

                canvas.addEventListener('mousemove', (e) => {
                    const rect = canvas.getBoundingClientRect();
                    this.mouseX = e.clientX - rect.left;
                    this.mouseY = e.clientY - rect.top;
                });
            }

            setVariable(name, value) {
                // Check locals first (from innermost to outermost)
                for (let i = this.locals.length - 1; i >= 0; i--) {
                    if (name in this.locals[i]) {
                        this.locals[i][name] = value;
                        return;
                    }
                }

                // Then check globals
                this.globals[name] = value;
            }

            getVariable(name) {
                // Check locals first
                for (let i = this.locals.length - 1; i >= 0; i--) {
                    if (name in this.locals[i]) {
                        return this.locals[i][name];
                    }
                }

                // Then globals
                if (name in this.globals) {
                    return this.globals[name];
                }

                // Special variables
                if (name === 'mouseX') return this.mouseX;
                if (name === 'mouseY') return this.mouseY;

                throw new Error(`Undefined variable: ${name}`);
            }

            run() {
                try {
                    this.execute(this.ast);
                } catch (e) {
                    log(`Runtime error: ${e.message}`, 'error');
                    this.shouldStop = true;
                }
            }

            execute(node) {
                if (this.shouldStop) return;

                if (node instanceof Program) {
                    for (const stmt of node.statements) {
                        this.execute(stmt);
                        if (this.shouldStop || this.returnValue !== null) break;
                    }
                } else if (node instanceof LetStatement) {
                    this.currentLine = node.line;
                    const value = this.evaluate(node.value);
                    this.locals[this.locals.length - 1][node.name] = value;
                } else if (node instanceof AssignStatement) {
                    this.currentLine = node.line;
                    const value = this.evaluate(node.value);
                    this.setVariable(node.name, value);
                } else if (node instanceof IfStatement) {
                    this.currentLine = node.line;
                    const condition = this.evaluate(node.condition);
                    if (condition) {
                        for (const stmt of node.thenBlock) {
                            this.execute(stmt);
                            if (this.shouldStop || this.returnValue !== null || this.shouldBreak || this.shouldContinue) break;
                        }
                    } else if (node.elseBlock) {
                        for (const stmt of node.elseBlock) {
                            this.execute(stmt);
                            if (this.shouldStop || this.returnValue !== null || this.shouldBreak || this.shouldContinue) break;
                        }
                    }
                } else if (node instanceof WhileStatement) {
                    this.currentLine = node.line;
                    while (this.evaluate(node.condition) && !this.shouldStop) {
                        for (const stmt of node.block) {
                            this.execute(stmt);
                            if (this.shouldStop || this.returnValue !== null) break;
                            if (this.shouldBreak) {
                                this.shouldBreak = false;
                                return;
                            }
                            if (this.shouldContinue) {
                                this.shouldContinue = false;
                                break;
                            }
                        }
                    }
                } else if (node instanceof LoopStatement) {
                    this.currentLine = node.line;
                    if (this.loopCallback) {
                        this.loopCallback(() => {
                            if (this.shouldStop) return;
                            for (const stmt of node.block) {
                                this.execute(stmt);
                                if (this.shouldStop || this.returnValue !== null) break;
                            }
                        });
                    }
                } else if (node instanceof FunctionDef) {
                    this.functions[node.name] = node;
                } else if (node instanceof ReturnStatement) {
                    this.currentLine = node.line;
                    this.returnValue = this.evaluate(node.value);
                } else if (node instanceof CallExpression) {
                    this.currentLine = node.line;
                    this.evaluateCall(node);
                }
            }

            evaluate(node) {
                if (node instanceof Literal) {
                    return node.value;
                } else if (node instanceof Identifier) {
                    return this.getVariable(node.name);
                } else if (node instanceof BinaryOp) {
                    const left = this.evaluate(node.left);
                    const right = this.evaluate(node.right);

                    switch (node.op) {
                        case 'PLUS': return left + right;
                        case 'MINUS': return left - right;
                        case 'MULT': return left * right;
                        case 'DIV': return left / right;
                        case 'EQ': return left === right;
                        case 'NEQ': return left !== right;
                        case 'LT': return left < right;
                        case 'GT': return left > right;
                        case 'LTE': return left <= right;
                        case 'GTE': return left >= right;
                        case 'or': return left || right;
                        case 'and': return left && right;
                    }
                } else if (node instanceof UnaryOp) {
                    const operand = this.evaluate(node.operand);

                    switch (node.op) {
                        case 'MINUS': return -operand;
                        case 'NOT': return !operand;
                    }
                } else if (node instanceof ArrayLiteral) {
                    return node.elements.map(el => this.evaluate(el));
                } else if (node instanceof CallExpression) {
                    return this.evaluateCall(node);
                }

                return null;
            }

            evaluateCall(node) {
                const args = node.args.map(arg => this.evaluate(arg));

                // Built-in function
                if (node.name in this.builtins) {
                    return this.builtins[node.name](...args);
                }

                // User-defined function
                if (node.name in this.functions) {
                    const fn = this.functions[node.name];
                    const newScope = {};

                    for (let i = 0; i < fn.params.length; i++) {
                        newScope[fn.params[i]] = args[i];
                    }

                    this.locals.push(newScope);

                    for (const stmt of fn.block) {
                        this.execute(stmt);
                        if (this.returnValue !== null) break;
                    }

                    this.locals.pop();
                    const result = this.returnValue;
                    this.returnValue = null;
                    return result;
                }

                throw new Error(`Undefined function: ${node.name}`);
            }
        }

        // RUN/STOP CONTROL
        function runProgram() {
            if (isRunning) return;

            clearConsole();
            log('Compiling...', 'info');

            try {
                // Clear canvas
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Tokenize
                const tokenizer = new Tokenizer(editor.value);
                const tokens = tokenizer.tokenize();
                log(`Tokenized: ${tokens.length} tokens`, 'success');

                // Parse
                const parser = new Parser(tokens);
                const ast = parser.parse();
                log(`Parsed: ${ast.statements.length} statements`, 'success');

                // Interpret
                interpreter = new Interpreter(ast);

                // Find loop statement
                let hasLoop = false;
                for (const stmt of ast.statements) {
                    if (stmt instanceof LoopStatement) {
                        hasLoop = true;
                        break;
                    }
                }

                if (hasLoop) {
                    // Animation loop
                    interpreter.loopCallback = (loopBody) => {
                        isRunning = true;
                        runBtn.disabled = true;
                        stopBtn.disabled = false;

                        const fps = parseInt(speedSlider.value);
                        const interval = 1000 / fps;

                        frameInterval = setInterval(() => {
                            if (!isRunning || interpreter.shouldStop) {
                                stopProgram();
                                return;
                            }
                            loopBody();
                        }, interval);
                    };

                    log('Running animation loop...', 'success');
                    interpreter.run();
                } else {
                    // Single execution
                    isRunning = true;
                    runBtn.disabled = true;
                    stopBtn.disabled = false;

                    interpreter.run();

                    log('Execution complete.', 'success');
                    stopProgram();
                }

            } catch (e) {
                log(`Error: ${e.message}`, 'error');
            }
        }

        function stopProgram() {
            isRunning = false;
            runBtn.disabled = false;
            stopBtn.disabled = true;
            stepBtn.disabled = true;
            continueBtn.disabled = true;

            if (frameInterval) {
                clearInterval(frameInterval);
                frameInterval = null;
            }

            if (interpreter) {
                interpreter.shouldStop = true;
            }

            log('Stopped.', 'info');
        }

        // EVENT HANDLERS
        runBtn.addEventListener('click', runProgram);
        stopBtn.addEventListener('click', stopProgram);

        // EXAMPLE PROGRAMS
        const examples = {
            'bouncing-ball': `// Bouncing Ball
let x = 320
let y = 240
let vx = 3
let vy = 2
let radius = 20

loop {
    clear("#001020")

    x = x + vx
    y = y + vy

    if x < radius or x > 620 {
        vx = 0 - vx
    }
    if y < radius or y > 460 {
        vy = 0 - vy
    }

    circle(x, y, radius, "#00ff88")
    text("Bouncing Ball", 10, 20, "#ffffff")
}`,
            'starfield': `// Starfield
let stars = []
let i = 0

while i < 100 {
    stars = [random() * 640, random() * 480, random() * 3]
    i = i + 1
}

loop {
    clear("#000000")

    i = 0
    while i < 100 {
        let sx = stars[0]
        let sy = stars[1]
        let speed = stars[2]

        sy = sy + speed
        if sy > 480 {
            sy = 0
            sx = random() * 640
        }

        circle(sx, sy, 2, "#ffffff")
        i = i + 1
    }

    text("Starfield", 10, 20, "#ffffff")
}`,
            'snake': `// Snake Game (use arrow keys)
let snakeX = [320, 300, 280]
let snakeY = [240, 240, 240]
let dirX = 20
let dirY = 0
let foodX = 400
let foodY = 300
let score = 0
let frame = 0

loop {
    clear("#001a00")
    frame = frame + 1

    if frame > 10 {
        frame = 0

        // Move snake
        let newX = snakeX[0] + dirX
        let newY = snakeY[0] + dirY

        // Wrap around
        if newX < 0 { newX = 620 }
        if newX > 640 { newX = 0 }
        if newY < 0 { newY = 460 }
        if newY > 480 { newY = 0 }

        // Check food
        if abs(newX - foodX) < 20 and abs(newY - foodY) < 20 {
            score = score + 1
            foodX = floor(random() * 30) * 20 + 10
            foodY = floor(random() * 22) * 20 + 10
        }
    }

    // Controls
    if key("arrowleft") and dirX == 0 {
        dirX = 0 - 20
        dirY = 0
    }
    if key("arrowright") and dirX == 0 {
        dirX = 20
        dirY = 0
    }
    if key("arrowup") and dirY == 0 {
        dirX = 0
        dirY = 0 - 20
    }
    if key("arrowdown") and dirY == 0 {
        dirX = 0
        dirY = 20
    }

    // Draw snake
    let i = 0
    while i < 3 {
        rect(snakeX[i] - 10, snakeY[i] - 10, 18, 18, "#00ff00")
        i = i + 1
    }

    // Draw food
    circle(foodX, foodY, 8, "#ff0000")

    text("Snake Game - Use Arrow Keys", 10, 20, "#ffffff")
}`,
            'fractal-tree': `// Fractal Tree
fn branch(x, y, angle, len) {
    if len < 5 {
        return 0
    }

    let x2 = x + cos(angle) * len
    let y2 = y + sin(angle) * len

    line(x, y, x2, y2, "#8b4513")

    branch(x2, y2, angle - 0.3, len * 0.7)
    branch(x2, y2, angle + 0.3, len * 0.7)
}

clear("#001020")
branch(320, 450, 0 - 1.57, 80)
text("Fractal Tree", 10, 20, "#ffffff")`,
            'particle-fountain': `// Particle Fountain
let particles = []
let i = 0

while i < 50 {
    let angle = random() * 6.28
    let speed = random() * 5 + 2
    particles = [320, 400, cos(angle) * speed, sin(angle) * speed - 5]
    i = i + 1
}

loop {
    clear("#000510")

    i = 0
    while i < 50 {
        let px = particles[0]
        let py = particles[1]
        let vx = particles[2]
        let vy = particles[3]

        px = px + vx
        py = py + vy
        vy = vy + 0.2

        if py > 480 {
            py = 400
            let angle = random() * 6.28
            let speed = random() * 5 + 2
            vx = cos(angle) * speed
            vy = sin(angle) * speed - 5
        }

        circle(px, py, 3, "#ffaa00")
        i = i + 1
    }

    text("Particle Fountain", 10, 20, "#ffffff")
}`
        };

        exampleSelect.addEventListener('change', (e) => {
            if (e.target.value && examples[e.target.value]) {
                editor.value = examples[e.target.value];
                updateLineNumbers();
                exampleSelect.value = '';
            }
        });

        // Initialize
        log('Ready. Write Spark code and click RUN.', 'info');
    </script>
</body>
</html>