<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Data Slosh - HTML Quality Pipeline tool for analyzing and improving single-file HTML applications">
  <title>Data Slosh - HTML Quality Pipeline</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #1a1a2e;
      color: #e8e8e8;
      line-height: 1.6;
      padding: 20px;
      min-height: 100vh;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    header {
      text-align: center;
      margin-bottom: 30px;
      padding-bottom: 20px;
      border-bottom: 2px solid #0f3460;
    }

    h1 {
      font-size: 2.5rem;
      margin-bottom: 10px;
      color: #74b9ff;
    }

    .subtitle {
      color: #a8a8a8;
      font-size: 1.1rem;
    }

    .tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    .tab-button {
      background: #16213e;
      border: 2px solid #0f3460;
      color: #e8e8e8;
      padding: 12px 24px;
      border-radius: 25px;
      cursor: pointer;
      font-size: 1rem;
      transition: all 0.3s ease;
      flex: 1;
      min-width: 120px;
    }

    .tab-button:hover {
      background: #0f3460;
      transform: translateY(-2px);
    }

    .tab-button.active {
      background: #0f3460;
      border-color: #74b9ff;
      color: #74b9ff;
      font-weight: bold;
    }

    .tab-content {
      display: none;
      background: #16213e;
      padding: 30px;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }

    .tab-content.active {
      display: block;
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .form-group {
      margin-bottom: 20px;
    }

    label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
      color: #74b9ff;
    }

    input[type="text"],
    input[type="file"],
    textarea {
      width: 100%;
      padding: 12px;
      background: #1a1a2e;
      border: 2px solid #0f3460;
      border-radius: 5px;
      color: #e8e8e8;
      font-family: inherit;
      font-size: 1rem;
      transition: border-color 0.3s ease;
    }

    textarea {
      font-family: 'Courier New', monospace;
      resize: vertical;
      min-height: 400px;
    }

    input:focus,
    textarea:focus {
      outline: none;
      border-color: #74b9ff;
    }

    button {
      background: #0f3460;
      color: #e8e8e8;
      border: none;
      padding: 12px 30px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 500;
      transition: all 0.3s ease;
      margin-right: 10px;
      margin-bottom: 10px;
    }

    button:hover {
      background: #74b9ff;
      color: #1a1a2e;
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(116, 185, 255, 0.3);
    }

    button.primary {
      background: #74b9ff;
      color: #1a1a2e;
      font-size: 1.2rem;
      padding: 15px 40px;
    }

    button.primary:hover {
      background: #a8d5ff;
    }

    button.danger {
      background: #e17055;
    }

    button.danger:hover {
      background: #ff8b6d;
      color: #1a1a2e;
    }

    .score-display {
      text-align: center;
      margin-bottom: 30px;
    }

    .score-number {
      font-size: 5rem;
      font-weight: bold;
      margin: 20px 0;
    }

    .score-number.high { color: #00b894; }
    .score-number.medium { color: #fdcb6e; }
    .score-number.low { color: #e17055; }

    .score-label {
      font-size: 1.2rem;
      color: #a8a8a8;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .summary {
      display: flex;
      gap: 20px;
      justify-content: center;
      margin-bottom: 30px;
      flex-wrap: wrap;
    }

    .summary-item {
      background: #1a1a2e;
      padding: 15px 25px;
      border-radius: 8px;
      text-align: center;
    }

    .summary-item .count {
      font-size: 2rem;
      font-weight: bold;
      margin-bottom: 5px;
    }

    .summary-item.errors .count { color: #e17055; }
    .summary-item.warnings .count { color: #fdcb6e; }
    .summary-item.info .count { color: #74b9ff; }

    .summary-item .label {
      color: #a8a8a8;
      text-transform: uppercase;
      font-size: 0.9rem;
    }

    .rule-group {
      margin-bottom: 25px;
    }

    .rule-group-title {
      font-size: 1.3rem;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 2px solid #0f3460;
    }

    .rule-item {
      background: #1a1a2e;
      padding: 15px;
      margin-bottom: 10px;
      border-radius: 5px;
      display: flex;
      align-items: center;
      gap: 15px;
      border-left: 4px solid transparent;
    }

    .rule-item.passed {
      border-left-color: #00b894;
    }

    .rule-item.failed {
      border-left-color: #e17055;
    }

    .rule-icon {
      font-size: 1.5rem;
      min-width: 30px;
      text-align: center;
    }

    .rule-content {
      flex: 1;
    }

    .rule-id {
      font-family: 'Courier New', monospace;
      font-size: 0.9rem;
      color: #a8a8a8;
      margin-bottom: 5px;
    }

    .rule-message {
      font-size: 1rem;
    }

    .severity-badge {
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 0.85rem;
      font-weight: 500;
      text-transform: uppercase;
      white-space: nowrap;
    }

    .severity-badge.error {
      background: #e17055;
      color: #1a1a2e;
    }

    .severity-badge.warning {
      background: #fdcb6e;
      color: #1a1a2e;
    }

    .severity-badge.info {
      background: #74b9ff;
      color: #1a1a2e;
    }

    .diff-container {
      background: #1a1a2e;
      border-radius: 5px;
      overflow: auto;
      max-height: 600px;
      margin-bottom: 20px;
      font-family: 'Courier New', monospace;
      font-size: 0.9rem;
      padding: 15px;
    }

    .diff-line {
      display: flex;
      line-height: 1.5;
    }

    .diff-prefix {
      min-width: 20px;
      text-align: center;
      margin-right: 10px;
      font-weight: bold;
    }

    .diff-added {
      background: rgba(0, 184, 148, 0.2);
      color: #00b894;
    }

    .diff-removed {
      background: rgba(225, 112, 85, 0.2);
      color: #e17055;
    }

    .diff-same {
      color: #a8a8a8;
    }

    .change-log {
      background: #1a1a2e;
      border-radius: 5px;
      padding: 20px;
      margin-bottom: 20px;
    }

    .change-log h3 {
      color: #74b9ff;
      margin-bottom: 15px;
    }

    .change-item {
      padding: 10px;
      margin-bottom: 8px;
      background: #16213e;
      border-radius: 4px;
      border-left: 3px solid #00b894;
    }

    .change-item .rule {
      font-family: 'Courier New', monospace;
      color: #74b9ff;
      font-size: 0.9rem;
    }

    .change-item .description {
      margin-top: 5px;
      color: #e8e8e8;
    }

    .stats-box {
      background: #1a1a2e;
      padding: 15px;
      border-radius: 5px;
      margin-bottom: 20px;
      display: inline-block;
    }

    .stats-box strong {
      color: #74b9ff;
    }

    .history-table {
      width: 100%;
      background: #1a1a2e;
      border-radius: 5px;
      overflow: hidden;
      margin-bottom: 20px;
    }

    .history-table table {
      width: 100%;
      border-collapse: collapse;
    }

    .history-table th {
      background: #0f3460;
      padding: 12px;
      text-align: left;
      color: #74b9ff;
      font-weight: 600;
    }

    .history-table td {
      padding: 12px;
      border-top: 1px solid #0f3460;
    }

    .history-table tr:hover {
      background: #16213e;
    }

    .insights-panel {
      background: #1a1a2e;
      padding: 20px;
      border-radius: 5px;
      margin-bottom: 20px;
    }

    .insights-panel h3 {
      color: #74b9ff;
      margin-bottom: 15px;
    }

    .insight-item {
      padding: 10px;
      margin-bottom: 8px;
      background: #16213e;
      border-radius: 4px;
      border-left: 3px solid #74b9ff;
    }

    .sparkline {
      display: flex;
      gap: 3px;
      height: 60px;
      align-items: flex-end;
      margin: 20px 0;
      padding: 10px;
      background: #1a1a2e;
      border-radius: 5px;
    }

    .sparkline-bar {
      flex: 1;
      background: #74b9ff;
      min-width: 4px;
      border-radius: 2px 2px 0 0;
      transition: all 0.3s ease;
    }

    .sparkline-bar:hover {
      background: #a8d5ff;
    }

    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: #a8a8a8;
    }

    .empty-state .icon {
      font-size: 4rem;
      margin-bottom: 20px;
      opacity: 0.5;
    }

    .keyboard-hint {
      font-size: 0.85rem;
      color: #a8a8a8;
      margin-top: 10px;
    }

    .keyboard-hint kbd {
      background: #1a1a2e;
      padding: 2px 6px;
      border-radius: 3px;
      border: 1px solid #0f3460;
      font-family: monospace;
    }

    @media (max-width: 768px) {
      h1 {
        font-size: 2rem;
      }

      .score-number {
        font-size: 3.5rem;
      }

      .tabs {
        flex-direction: column;
      }

      .tab-button {
        min-width: auto;
      }

      .summary {
        flex-direction: column;
      }

      .tab-content {
        padding: 20px;
      }
    }

    .hidden {
      display: none !important;
    }

    /* API status */
    .api-status {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 12px;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 500;
      margin-top: 8px;
    }

    .api-status.offline {
      background: rgba(225, 112, 85, 0.15);
      color: #e17055;
      border: 1px solid rgba(225, 112, 85, 0.3);
    }

    .api-status.online {
      background: rgba(0, 184, 148, 0.15);
      color: #00b894;
      border: 1px solid rgba(0, 184, 148, 0.3);
    }

    .api-status.checking {
      background: rgba(253, 203, 110, 0.15);
      color: #fdcb6e;
      border: 1px solid rgba(253, 203, 110, 0.3);
    }

    .api-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      display: inline-block;
    }

    .api-status.offline .api-dot { background: #e17055; }
    .api-status.online .api-dot { background: #00b894; }
    .api-status.checking .api-dot { background: #fdcb6e; animation: pulse 1s infinite; }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }

    .ai-badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      background: linear-gradient(135deg, #a29bfe, #6c5ce7);
      color: white;
      padding: 3px 10px;
      border-radius: 12px;
      font-size: 0.75rem;
      font-weight: 600;
      letter-spacing: 0.5px;
    }

    .ai-spinner {
      display: inline-block;
      width: 14px;
      height: 14px;
      border: 2px solid rgba(255,255,255,0.3);
      border-top-color: white;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Rewriter styles */
    .rewriter-section {
      background: #1a1a2e;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
    }

    .rewriter-section h3 {
      color: #74b9ff;
      margin-bottom: 15px;
      border-bottom: 1px solid #0f3460;
      padding-bottom: 8px;
    }

    .suggestion-card {
      background: #16213e;
      border-radius: 6px;
      padding: 15px;
      margin-bottom: 12px;
      border-left: 4px solid #74b9ff;
    }

    .suggestion-card.category {
      border-left-color: #a29bfe;
    }

    .suggestion-card.filename {
      border-left-color: #00b894;
    }

    .suggestion-card.manifest {
      border-left-color: #fdcb6e;
    }

    .suggestion-card .suggestion-label {
      font-size: 0.85rem;
      color: #a8a8a8;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 6px;
    }

    .suggestion-card .suggestion-value {
      font-size: 1.2rem;
      font-weight: 600;
      font-family: 'Courier New', monospace;
    }

    .suggestion-card .suggestion-reason {
      font-size: 0.9rem;
      color: #a8a8a8;
      margin-top: 6px;
    }

    .tag-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 8px;
    }

    .tag-chip {
      background: #0f3460;
      color: #74b9ff;
      padding: 3px 10px;
      border-radius: 12px;
      font-size: 0.85rem;
    }

    .manifest-preview {
      background: #0d0d1a;
      border-radius: 6px;
      padding: 15px;
      font-family: 'Courier New', monospace;
      font-size: 0.9rem;
      white-space: pre-wrap;
      overflow-x: auto;
      color: #00b894;
      margin-top: 10px;
      border: 1px solid #0f3460;
    }

    .rewriter-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 20px;
    }

    .category-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 8px;
      margin-top: 10px;
    }

    .category-option {
      background: #1a1a2e;
      border: 2px solid #0f3460;
      border-radius: 6px;
      padding: 10px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .category-option:hover {
      border-color: #74b9ff;
    }

    .category-option.selected {
      border-color: #a29bfe;
      background: rgba(162, 155, 254, 0.1);
    }

    .category-option .cat-name {
      font-weight: 600;
      font-size: 0.95rem;
    }

    .category-option .cat-desc {
      font-size: 0.8rem;
      color: #a8a8a8;
      margin-top: 2px;
    }

    .complexity-select {
      display: flex;
      gap: 8px;
      margin-top: 8px;
    }

    .complexity-btn {
      padding: 6px 16px;
      border: 2px solid #0f3460;
      background: #1a1a2e;
      color: #e8e8e8;
      border-radius: 20px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.2s;
    }

    .complexity-btn:hover {
      border-color: #74b9ff;
    }

    .complexity-btn.selected {
      border-color: #00b894;
      background: rgba(0, 184, 148, 0.15);
      color: #00b894;
    }
  </style>
</head>
<body>
  <noscript><p style="text-align: center; padding: 40px; background: #e17055; color: #1a1a2e; font-weight: bold; border-radius: 5px;">This application requires JavaScript to run.</p></noscript>

  <div class="container">
    <header>
      <h1>Data Slosh</h1>
      <p class="subtitle">HTML Quality Pipeline - Analyze, Improve, Perfect</p>
      <div id="api-status" class="api-status offline" title="Local API status">
        <span class="api-dot"></span>
        <span class="api-label">API Offline</span>
      </div>
    </header>

    <div class="tabs" role="tablist">
      <button class="tab-button active" data-tab="input" role="tab" aria-selected="true">1. Input</button>
      <button class="tab-button" data-tab="analysis" role="tab" aria-selected="false">2. Analysis</button>
      <button class="tab-button" data-tab="improved" role="tab" aria-selected="false">3. Improved</button>
      <button class="tab-button" data-tab="history" role="tab" aria-selected="false">4. History</button>
      <button class="tab-button" data-tab="rewrite" role="tab" aria-selected="false">5. Rewrite</button>
    </div>

    <div id="tab-input" class="tab-content active" role="tabpanel">
      <div class="form-group">
        <label for="html-input">Paste HTML Code</label>
        <textarea id="html-input" placeholder="Paste your HTML file contents here..."></textarea>
        <p class="keyboard-hint"><kbd>Ctrl</kbd> + <kbd>Enter</kbd> to analyze</p>
      </div>

      <div class="form-group">
        <label for="file-upload">Or Upload HTML File</label>
        <input type="file" id="file-upload" accept=".html,.htm">
      </div>

      <div class="form-group">
        <label for="filename-input">Filename (optional)</label>
        <input type="text" id="filename-input" placeholder="my-app.html">
      </div>

      <button class="primary" id="analyze-btn">Analyze HTML</button>
    </div>

    <div id="tab-analysis" class="tab-content" role="tabpanel">
      <div id="analysis-results"></div>
    </div>

    <div id="tab-improved" class="tab-content" role="tabpanel">
      <div id="improved-results"></div>
    </div>

    <div id="tab-history" class="tab-content" role="tabpanel">
      <h2 style="margin-bottom: 20px; color: #74b9ff;">Analysis History</h2>

      <div id="history-insights"></div>

      <div id="history-sparkline"></div>

      <div id="history-table"></div>

      <div style="margin-top: 20px;">
        <button id="export-history-btn">Export History (JSON)</button>
        <button id="import-history-btn">Import History</button>
        <input type="file" id="import-history-file" accept=".json" class="hidden">
        <button class="danger" id="clear-history-btn">Clear History</button>
      </div>
    </div>

    <div id="tab-rewrite" class="tab-content" role="tabpanel">
      <div id="rewrite-results">
        <div class="empty-state">
          <div class="icon">&#9998;</div>
          <p>Analyze HTML first, then use "Rewrite" to generate filename, category, and manifest entry suggestions.</p>
        </div>
      </div>
    </div>
  </div>

  <script>
    'use strict';

    // ==================== Module 1: Parser ====================
    const Parser = {
      parse(html) {
        const lines = html.split('\n');

        const result = {
          hasDoctype: /<!DOCTYPE\s+html>/i.test(html),
          doctype: (html.match(/<!DOCTYPE[^>]*>/i) || [null])[0],
          hasHead: /<head[\s>]/i.test(html) && /<\/head>/i.test(html),
          headContent: (html.match(/<head[^>]*>([\s\S]*?)<\/head>/i) || ['', ''])[1],
          hasBody: /<body[\s>]/i.test(html) && /<\/body>/i.test(html),
          bodyContent: (html.match(/<body[^>]*>([\s\S]*?)<\/body>/i) || ['', ''])[1],
          title: (html.match(/<title[^>]*>([\s\S]*?)<\/title>/i) || [null, null])[1],
          htmlLang: (html.match(/<html[^>]*\slang=["']([^"']*)["']/i) || [null, null])[1],
          metas: [...html.matchAll(/<meta\s([^>]*)>/gi)].map(m => {
            const attrs = m[1];
            return {
              name: (attrs.match(/name=["']([^"']*)["']/i) || [null, null])[1],
              content: (attrs.match(/content=["']([^"']*)["']/i) || [null, null])[1],
              charset: (attrs.match(/charset=["']?([^"'\s>]*)["']?/i) || [null, null])[1],
              httpEquiv: (attrs.match(/http-equiv=["']([^"']*)["']/i) || [null, null])[1],
            };
          }),
          hasCharset: false,
          hasViewport: false,
          hasDescription: false,
          scripts: [],
          styles: [],
          externalUrls: [],
          hasLocalStorage: false,
          hasJsonExport: false,
          hasErrorHandling: false,
          consoleLogs: { count: 0, lines: [] },
          hasMediaQueries: false,
          hasAriaLabels: false,
          hasNoscript: /<noscript[\s>]/i.test(html),
          inlineHandlers: [],
          inputs: [],
          hasInputLabels: true,
        };

        // Check charset
        result.hasCharset = result.metas.some(m =>
          m.charset ||
          (m.httpEquiv && /content-type/i.test(m.httpEquiv) && m.content && /charset/i.test(m.content))
        );

        // Check viewport
        result.hasViewport = result.metas.some(m => m.name && /viewport/i.test(m.name));

        // Check description
        result.hasDescription = result.metas.some(m => m.name && /description/i.test(m.name));

        // Parse scripts
        const scriptMatches = [...html.matchAll(/<script([^>]*)>([\s\S]*?)<\/script>/gi)];
        for (const match of scriptMatches) {
          const attrs = match[1];
          const content = match[2];
          const srcMatch = attrs.match(/src=["']([^"']*)["']/i);

          if (srcMatch) {
            result.scripts.push({ inline: false, src: srcMatch[1], content: '' });
          } else {
            result.scripts.push({ inline: true, src: null, content });
          }
        }

        // Parse styles
        const styleMatches = [...html.matchAll(/<style([^>]*)>([\s\S]*?)<\/style>/gi)];
        for (const match of styleMatches) {
          result.styles.push({ inline: true, href: null, content: match[2] });
        }

        const linkMatches = [...html.matchAll(/<link\s([^>]*)>/gi)];
        for (const match of linkMatches) {
          const attrs = match[1];
          if (/rel=["']stylesheet["']/i.test(attrs)) {
            const hrefMatch = attrs.match(/href=["']([^"']*)["']/i);
            if (hrefMatch) {
              result.styles.push({ inline: false, href: hrefMatch[1], content: '' });
            }
          }
        }

        // Find external URLs
        const urlMatches = [...html.matchAll(/(?:src|href)=["'](https?:\/\/[^"']*)["']/gi)];
        result.externalUrls = urlMatches.map(m => m[1]);

        // Check localStorage usage
        const inlineScriptContent = result.scripts.filter(s => s.inline).map(s => s.content).join('\n');
        result.hasLocalStorage = /localStorage\.(getItem|setItem|removeItem|clear)/i.test(inlineScriptContent);

        // Check JSON export
        result.hasJsonExport = /JSON\.stringify/i.test(inlineScriptContent) &&
          (/download|export|Blob|\.href\s*=|createElement\s*\(\s*['"]a['"]\s*\)/i.test(inlineScriptContent));

        // Check error handling
        result.hasErrorHandling = /try\s*\{[\s\S]*?\}\s*catch/i.test(inlineScriptContent) ||
          /window\.onerror/i.test(inlineScriptContent) ||
          /addEventListener\s*\(\s*['"]error['"]/i.test(inlineScriptContent);

        // Count console logs
        const consoleMatches = [...inlineScriptContent.matchAll(/console\.(log|debug|info)\s*\(/gi)];
        result.consoleLogs.count = consoleMatches.length;

        // Find line numbers for console logs
        const scriptLines = inlineScriptContent.split('\n');
        for (let i = 0; i < scriptLines.length; i++) {
          if (/console\.(log|debug|info)\s*\(/i.test(scriptLines[i])) {
            result.consoleLogs.lines.push(i + 1);
          }
        }

        // Check media queries
        const inlineStyleContent = result.styles.filter(s => s.inline).map(s => s.content).join('\n');
        result.hasMediaQueries = /@media/i.test(inlineStyleContent);

        // Check ARIA labels
        result.hasAriaLabels = /aria-label|role=/i.test(html);

        // Find inline handlers
        const handlerMatches = [...html.matchAll(/\s(on\w+)=["']([^"']*)["']/gi)];
        result.inlineHandlers = handlerMatches.map(m => ({ event: m[1], handler: m[2] }));

        // Find inputs and check for labels
        const inputMatches = [...html.matchAll(/<(input|select|textarea)([^>]*)>/gi)];
        for (const match of inputMatches) {
          const tag = match[1].toLowerCase();
          const attrs = match[2];
          const idMatch = attrs.match(/id=["']([^"']*)["']/i);
          const id = idMatch ? idMatch[1] : null;

          result.inputs.push({ tag, id, hasLabel: false });
        }

        // Check for labels
        for (const input of result.inputs) {
          if (input.id) {
            const labelRegex = new RegExp(`<label[^>]*\\sfor=["']${input.id}["'][^>]*>`, 'i');
            if (labelRegex.test(html)) {
              input.hasLabel = true;
            }
          }

          // Check for wrapping label
          const wrapRegex = new RegExp(`<label[^>]*>[\\s\\S]*?<${input.tag}[^>]*>[\\s\\S]*?<\\/label>`, 'i');
          if (wrapRegex.test(html)) {
            input.hasLabel = true;
          }
        }

        result.hasInputLabels = result.inputs.length === 0 || result.inputs.every(i => i.hasLabel);

        return result;
      }
    };

    // ==================== Module 2: Analyzer ====================
    const Analyzer = {
      rules: [
        // ERRORS (weight: 15)
        {
          id: 'missing-doctype',
          severity: 'error',
          weight: 15,
          check: (p) => p.hasDoctype,
          message: 'Missing <!DOCTYPE html> declaration'
        },
        {
          id: 'missing-charset',
          severity: 'error',
          weight: 15,
          check: (p) => p.hasCharset,
          message: 'Missing <meta charset="UTF-8">'
        },
        {
          id: 'missing-viewport',
          severity: 'error',
          weight: 15,
          check: (p) => p.hasViewport,
          message: 'Missing viewport meta tag'
        },
        {
          id: 'external-scripts',
          severity: 'error',
          weight: 15,
          check: (p) => p.scripts.every(s => !s.src || !/^https?:\/\//i.test(s.src)),
          message: 'External script dependencies detected'
        },
        {
          id: 'external-styles',
          severity: 'error',
          weight: 15,
          check: (p) => p.styles.every(s => !s.href || !/^https?:\/\//i.test(s.href)),
          message: 'External stylesheet dependencies detected'
        },
        {
          id: 'cdn-dependencies',
          severity: 'error',
          weight: 15,
          check: (p) => p.externalUrls.length === 0,
          message: 'CDN/external URL dependencies found'
        },

        // WARNINGS (weight: 5)
        {
          id: 'missing-title',
          severity: 'warning',
          weight: 5,
          check: (p) => !!p.title,
          message: 'Missing <title> tag'
        },
        {
          id: 'missing-html-lang',
          severity: 'warning',
          weight: 5,
          check: (p) => !!p.htmlLang,
          message: 'Missing lang attribute on <html> tag'
        },
        {
          id: 'missing-description',
          severity: 'warning',
          weight: 5,
          check: (p) => p.hasDescription,
          message: 'Missing meta description'
        },
        {
          id: 'no-localstorage',
          severity: 'warning',
          weight: 5,
          check: (p) => p.hasLocalStorage,
          message: 'No localStorage usage for state persistence'
        },
        {
          id: 'no-json-export',
          severity: 'warning',
          weight: 5,
          check: (p) => p.hasJsonExport || !p.hasLocalStorage,
          message: 'Uses localStorage but no JSON export functionality'
        },
        {
          id: 'no-error-handling',
          severity: 'warning',
          weight: 5,
          check: (p) => p.hasErrorHandling,
          message: 'No error handling (try/catch or onerror)'
        },
        {
          id: 'console-log-pollution',
          severity: 'warning',
          weight: 5,
          check: (p) => p.consoleLogs.count === 0,
          message: 'Console log statements found'
        },
        {
          id: 'hardcoded-api-keys',
          severity: 'warning',
          weight: 5,
          check: (p) => !Analyzer.detectApiKeys(p),
          message: 'Possible hardcoded API keys or secrets detected'
        },

        // INFO (weight: 2)
        {
          id: 'no-media-queries',
          severity: 'info',
          weight: 2,
          check: (p) => p.hasMediaQueries,
          message: 'No CSS media queries for responsive design'
        },
        {
          id: 'no-aria-labels',
          severity: 'info',
          weight: 2,
          check: (p) => p.hasAriaLabels,
          message: 'No ARIA labels for accessibility'
        },
        {
          id: 'no-noscript',
          severity: 'info',
          weight: 2,
          check: (p) => p.hasNoscript,
          message: 'No <noscript> fallback for non-JS browsers'
        },
        {
          id: 'inline-onclick',
          severity: 'info',
          weight: 2,
          check: (p) => p.inlineHandlers.length === 0,
          message: 'Inline event handlers detected (prefer addEventListener)'
        },
        {
          id: 'missing-input-labels',
          severity: 'info',
          weight: 2,
          check: (p) => p.hasInputLabels,
          message: 'Input elements missing associated <label> tags'
        },
      ],

      analyze(parsed) {
        const results = this.rules.map(rule => {
          const passed = rule.check(parsed);
          return {
            id: rule.id,
            passed,
            severity: rule.severity,
            weight: rule.weight,
            message: rule.message
          };
        });

        let score = 100;
        for (const r of results) {
          if (!r.passed) score -= r.weight;
        }
        score = Math.max(0, score);

        const summary = { errors: 0, warnings: 0, info: 0 };
        for (const r of results) {
          if (!r.passed) summary[r.severity]++;
        }

        return { score, results, summary };
      },

      detectApiKeys(parsed) {
        const scriptContent = parsed.scripts.filter(s => s.inline).map(s => s.content).join('\n');
        return /(?:api[_-]?key|api[_-]?token|api[_-]?secret|secret[_-]?key|auth[_-]?token|access[_-]?token|private[_-]?key)\s*[:=]\s*['"`][a-zA-Z0-9_\-]{16,}['"`]/i.test(scriptContent);
      }
    };

    // ==================== Module 3: Improver ====================
    const Improver = {
      improve(html) {
        let improved = html;
        const changes = [];
        const parsed = Parser.parse(html);

        // 1. Add DOCTYPE if missing
        if (!parsed.hasDoctype) {
          improved = '<!DOCTYPE html>\n' + improved;
          changes.push({ rule: 'missing-doctype', description: 'Added <!DOCTYPE html> declaration' });
        }

        // 2. Add charset if missing
        if (!parsed.hasCharset) {
          if (/<head[^>]*>/i.test(improved)) {
            improved = improved.replace(/(<head[^>]*>)/i, '$1\n  <meta charset="UTF-8">');
          } else if (/<html[^>]*>/i.test(improved)) {
            improved = improved.replace(/(<html[^>]*>)/i, '$1\n<head>\n  <meta charset="UTF-8">\n</head>');
          } else {
            improved = improved.replace(/(<body[^>]*>)/i, '<head>\n  <meta charset="UTF-8">\n</head>\n$1');
          }
          changes.push({ rule: 'missing-charset', description: 'Added <meta charset="UTF-8">' });
        }

        // 3. Add viewport if missing
        if (!parsed.hasViewport) {
          if (/<head[^>]*>/i.test(improved)) {
            const headMatch = improved.match(/<head[^>]*>[\s\S]*?<\/head>/i);
            if (headMatch) {
              const headContent = headMatch[0];
              const metaMatches = [...headContent.matchAll(/<meta[^>]*>/gi)];

              if (metaMatches.length > 0) {
                const lastMeta = metaMatches[metaMatches.length - 1];
                const lastMetaEnd = headMatch.index + lastMeta.index + lastMeta[0].length;
                improved = improved.slice(0, lastMetaEnd) + '\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">' + improved.slice(lastMetaEnd);
              } else {
                improved = improved.replace(/(<head[^>]*>)/i, '$1\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">');
              }
            }
          }
          changes.push({ rule: 'missing-viewport', description: 'Added viewport meta tag' });
        }

        // 4. Add lang="en" if missing
        if (!parsed.htmlLang) {
          if (/<html(?:\s[^>]*)?>/i.test(improved)) {
            improved = improved.replace(/<html(\s[^>]*)?>/i, (match, attrs) => {
              if (attrs && !/^\s*$/.test(attrs)) {
                return `<html lang="en"${attrs}>`;
              }
              return '<html lang="en">';
            });
          } else {
            improved = improved.replace(/^/, '<html lang="en">\n');
            improved += '\n</html>';
          }
          changes.push({ rule: 'missing-html-lang', description: 'Added lang="en" to <html> tag' });
        }

        // 5. Comment out console.log/debug/info
        if (parsed.consoleLogs.count > 0) {
          const lines = improved.split('\n');
          let modified = false;

          for (let i = 0; i < lines.length; i++) {
            if (/^\s*console\.(log|debug|info)\s*\(/i.test(lines[i])) {
              const leadingSpace = lines[i].match(/^(\s*)/)[1];
              lines[i] = leadingSpace + '// [DataSlosh] ' + lines[i].trim();
              modified = true;
            }
          }

          if (modified) {
            improved = lines.join('\n');
            changes.push({ rule: 'console-log-pollution', description: `Commented out ${parsed.consoleLogs.count} console statements` });
          }
        }

        // 6. Add noscript if missing
        if (!parsed.hasNoscript) {
          if (/<body[^>]*>/i.test(improved)) {
            improved = improved.replace(/(<body[^>]*>)/i, '$1\n  <noscript><p>This application requires JavaScript to run.</p></noscript>');
            changes.push({ rule: 'no-noscript', description: 'Added <noscript> fallback message' });
          }
        }

        return { html: improved, changes };
      }
    };

    // ==================== Module 4: Differ ====================
    const Differ = {
      diff(original, improved) {
        const origLines = original.split('\n');
        const impLines = improved.split('\n');

        if (origLines.length > 5000 || impLines.length > 5000) {
          return this._simpleDiff(origLines, impLines);
        }

        return this._lcsDiff(origLines, impLines);
      },

      _simpleDiff(origLines, impLines) {
        const lines = [];
        const maxLen = Math.max(origLines.length, impLines.length);
        let added = 0, removed = 0, unchanged = 0;

        for (let i = 0; i < maxLen; i++) {
          if (i < origLines.length && i < impLines.length) {
            if (origLines[i] === impLines[i]) {
              lines.push({ type: 'same', content: origLines[i], lineNum: i + 1 });
              unchanged++;
            } else {
              lines.push({ type: 'removed', content: origLines[i], lineNum: i + 1 });
              lines.push({ type: 'added', content: impLines[i], lineNum: i + 1 });
              added++;
              removed++;
            }
          } else if (i < origLines.length) {
            lines.push({ type: 'removed', content: origLines[i], lineNum: i + 1 });
            removed++;
          } else {
            lines.push({ type: 'added', content: impLines[i], lineNum: i + 1 });
            added++;
          }
        }

        return { lines, stats: { added, removed, unchanged } };
      },

      _lcsDiff(origLines, impLines) {
        const m = origLines.length;
        const n = impLines.length;

        const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));
        for (let i = 1; i <= m; i++) {
          for (let j = 1; j <= n; j++) {
            if (origLines[i - 1] === impLines[j - 1]) {
              dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
              dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
          }
        }

        const lines = [];
        let i = m, j = n;
        const temp = [];

        while (i > 0 || j > 0) {
          if (i > 0 && j > 0 && origLines[i - 1] === impLines[j - 1]) {
            temp.push({ type: 'same', content: origLines[i - 1], lineNum: i });
            i--;
            j--;
          } else if (j > 0 && (i === 0 || dp[i][j - 1] >= dp[i - 1][j])) {
            temp.push({ type: 'added', content: impLines[j - 1], lineNum: j });
            j--;
          } else {
            temp.push({ type: 'removed', content: origLines[i - 1], lineNum: i });
            i--;
          }
        }
        temp.reverse();

        let added = 0, removed = 0, unchanged = 0;
        for (const line of temp) {
          if (line.type === 'added') added++;
          else if (line.type === 'removed') removed++;
          else unchanged++;
        }

        return { lines: temp, stats: { added, removed, unchanged } };
      },

      toHTML(diffResult) {
        const esc = (s) => s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');

        return diffResult.lines.map(line => {
          const cls = line.type === 'added' ? 'diff-added' : line.type === 'removed' ? 'diff-removed' : 'diff-same';
          const prefix = line.type === 'added' ? '+' : line.type === 'removed' ? '-' : ' ';
          return `<div class="diff-line ${cls}"><span class="diff-prefix">${prefix}</span><span class="diff-content">${esc(line.content)}</span></div>`;
        }).join('\n');
      }
    };

    // ==================== Module 5: History ====================
    const History = {
      STORAGE_KEY: 'dataslosh-history',
      MAX_ENTRIES: 200,

      load() {
        try {
          const data = localStorage.getItem(this.STORAGE_KEY);
          return data ? JSON.parse(data) : [];
        } catch {
          return [];
        }
      },

      save(entries) {
        const trimmed = entries.slice(-this.MAX_ENTRIES);
        localStorage.setItem(this.STORAGE_KEY, JSON.stringify(trimmed));
      },

      record(result) {
        const entries = this.load();
        entries.push({
          filename: result.filename || 'untitled.html',
          score: result.score,
          failedRules: result.failedRules || [],
          timestamp: result.timestamp || Date.now()
        });
        this.save(entries);
      },

      getStats() {
        const entries = this.load();
        if (entries.length === 0) {
          return { totalRuns: 0, avgScore: 0, ruleFrequency: {}, scoreTrend: [] };
        }

        const totalRuns = entries.length;
        const avgScore = Math.round(entries.reduce((sum, e) => sum + e.score, 0) / totalRuns);

        const ruleFrequency = {};
        for (const entry of entries) {
          for (const rule of (entry.failedRules || [])) {
            ruleFrequency[rule] = (ruleFrequency[rule] || 0) + 1;
          }
        }

        const scoreTrend = entries.slice(-20).map(e => e.score);

        return { totalRuns, avgScore, ruleFrequency, scoreTrend };
      },

      getInsights() {
        const stats = this.getStats();
        const insights = [];

        if (stats.totalRuns === 0) return insights;

        const sorted = Object.entries(stats.ruleFrequency).sort((a, b) => b[1] - a[1]);
        if (sorted.length > 0) {
          const pct = Math.round((sorted[0][1] / stats.totalRuns) * 100);
          insights.push(`Most common issue: ${sorted[0][0]} (found in ${pct}% of scans)`);
        }

        if (stats.scoreTrend.length >= 4) {
          const firstHalf = stats.scoreTrend.slice(0, Math.floor(stats.scoreTrend.length / 2));
          const secondHalf = stats.scoreTrend.slice(Math.floor(stats.scoreTrend.length / 2));
          const avgFirst = firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length;
          const avgSecond = secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length;

          if (avgSecond > avgFirst + 5) {
            insights.push(`Quality improving: average score went from ${Math.round(avgFirst)} to ${Math.round(avgSecond)}`);
          } else if (avgFirst > avgSecond + 5) {
            insights.push(`Quality declining: average score went from ${Math.round(avgFirst)} to ${Math.round(avgSecond)}`);
          }
        }

        insights.push(`${stats.totalRuns} total scans with average score of ${stats.avgScore}/100`);

        return insights;
      },

      exportJSON() {
        return JSON.stringify(this.load(), null, 2);
      },

      importJSON(json) {
        let data;
        try {
          data = JSON.parse(json);
        } catch {
          throw new Error('Invalid JSON');
        }

        if (!Array.isArray(data)) {
          throw new Error('Expected an array');
        }

        for (const entry of data) {
          if (typeof entry.score !== 'number' || !Array.isArray(entry.failedRules)) {
            throw new Error('Invalid entry: must have numeric score and failedRules array');
          }
        }

        this.save(data);
      },

      clear() {
        localStorage.removeItem(this.STORAGE_KEY);
      }
    };

    // ==================== Module 6: API ====================
    const API = {
      baseURL: 'http://localhost:5000',
      available: false,
      backend: null,

      async checkHealth() {
        const statusEl = document.getElementById('api-status');
        if (statusEl) {
          statusEl.className = 'api-status checking';
          statusEl.querySelector('.api-label').textContent = 'Checking...';
        }

        try {
          const controller = new AbortController();
          const timeout = setTimeout(() => controller.abort(), 3000);
          const resp = await fetch(`${this.baseURL}/api/health`, { signal: controller.signal });
          clearTimeout(timeout);

          if (resp.ok) {
            const data = await resp.json();
            this.available = true;
            this.backend = data.backend;

            if (statusEl) {
              if (data.backend === 'copilot-cli') {
                statusEl.className = 'api-status online';
                statusEl.querySelector('.api-label').textContent = `API Online (${data.model || 'Claude'})`;
              } else {
                statusEl.className = 'api-status online';
                statusEl.querySelector('.api-label').textContent = 'API Online (no LLM)';
              }
            }
            return true;
          }
        } catch {
          // Server not running — that's fine, we work offline
        }

        this.available = false;
        this.backend = null;
        if (statusEl) {
          statusEl.className = 'api-status offline';
          statusEl.querySelector('.api-label').textContent = 'API Offline';
        }
        return false;
      },

      async analyze(html, filename, analysisContext) {
        if (!this.available) return null;

        try {
          const resp = await fetch(`${this.baseURL}/api/analyze`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ html, filename, analysis: analysisContext }),
          });

          if (resp.ok) return await resp.json();
        } catch {
          // API call failed — fall back to local
        }
        return null;
      },

      async rewrite(html, filename, analysisContext) {
        if (!this.available) return null;

        try {
          const resp = await fetch(`${this.baseURL}/api/rewrite`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ html, filename, analysis: analysisContext }),
          });

          if (resp.ok) return await resp.json();
        } catch {
          // API call failed — fall back to local
        }
        return null;
      }
    };

    // ==================== Module 7: Rewriter (local regex) ========
    const Rewriter = {
      // Category definitions matching CLAUDE.md
      CATEGORIES: {
        visual_art:       { folder: 'visual-art',       title: 'Visual Art & Design',   keywords: ['draw', 'paint', 'sketch', 'design', 'color', 'palette', 'gradient', 'svg', 'pixel', 'css art', 'illustration', 'pattern', 'brush', 'canvas art'] },
        '3d_immersive':   { folder: '3d-immersive',     title: '3D & Immersive',        keywords: ['three.js', 'threejs', 'webgl', '3d', 'scene', 'mesh', 'camera', 'orbit', 'raycast', 'vr', 'ar', 'immersive', 'quaternion', 'matrix4'] },
        audio_music:      { folder: 'audio-music',      title: 'Audio & Music',         keywords: ['audio', 'music', 'synth', 'oscillator', 'frequency', 'wav', 'midi', 'daw', 'beat', 'drum', 'piano', 'chord', 'note', 'tempo', 'bpm', 'audiocontext', 'webaudio'] },
        generative_art:   { folder: 'generative-art',   title: 'Generative Art',        keywords: ['generative', 'procedural', 'fractal', 'mandelbrot', 'perlin', 'noise', 'cellular automata', 'l-system', 'algorithm', 'recursive', 'random art', 'emergent'] },
        games_puzzles:    { folder: 'games-puzzles',     title: 'Games & Puzzles',       keywords: ['game', 'puzzle', 'score', 'level', 'player', 'enemy', 'collision', 'sprite', 'highscore', 'lives', 'timer', 'board', 'card', 'dice', 'chess', 'maze', 'tetris', 'snake'] },
        particle_physics: { folder: 'particle-physics',  title: 'Particle & Physics',    keywords: ['particle', 'physics', 'gravity', 'velocity', 'acceleration', 'force', 'mass', 'spring', 'collision detect', 'vector', 'simulation', 'fluid', 'pendulum', 'wave'] },
        creative_tools:   { folder: 'creative-tools',    title: 'Creative Tools',        keywords: ['editor', 'tracker', 'converter', 'calculator', 'tool', 'utility', 'productivity', 'dashboard', 'planner', 'manager', 'timer', 'clock', 'markdown', 'notes'] },
        experimental_ai:  { folder: 'experimental-ai',   title: 'Experimental & AI',     keywords: ['ai', 'neural', 'model', 'simulate', 'experiment', 'prototype', 'chat', 'llm', 'api', 'interface', 'virtual', 'digital twin', 'pipeline', 'algorithm'] },
      },

      // Complexity heuristics
      COMPLEXITY_THRESHOLDS: {
        simple: 500,       // < 500 lines
        intermediate: 1500, // 500-1500 lines
        advanced: Infinity  // > 1500 lines
      },

      // Type detection keywords
      TYPE_KEYWORDS: {
        game:        ['game', 'score', 'lives', 'level', 'player', 'enemy'],
        visual:      ['canvas', 'draw', 'render', 'animate', 'gradient', 'svg', 'webgl'],
        audio:       ['audio', 'sound', 'music', 'synth', 'oscillator', 'frequency'],
        interactive: ['click', 'drag', 'input', 'form', 'slider', 'button', 'interactive'],
        interface:   ['dashboard', 'editor', 'manager', 'tracker', 'tool', 'viewer', 'crud', 'table'],
      },

      rewrite(html, parsed, analysis) {
        const result = {
          suggestedFilename: '',
          suggestedCategory: '',
          categoryKey: '',
          categoryFolder: '',
          categoryScores: {},
          suggestedTitle: '',
          suggestedDescription: '',
          suggestedTags: [],
          suggestedComplexity: 'simple',
          suggestedType: 'interactive',
          manifestEntry: null,
          rewrittenHTML: '',
        };

        const inlineScriptContent = parsed.scripts.filter(s => s.inline).map(s => s.content).join('\n').toLowerCase();
        const inlineStyleContent = parsed.styles.filter(s => s.inline).map(s => s.content).join('\n').toLowerCase();
        const fullTextLower = html.toLowerCase();
        const lineCount = html.split('\n').length;

        // === TITLE ===
        result.suggestedTitle = this._inferTitle(parsed, html);

        // === DESCRIPTION ===
        result.suggestedDescription = this._inferDescription(parsed, html, inlineScriptContent);

        // === CATEGORY ===
        const catResult = this._classifyCategory(inlineScriptContent, inlineStyleContent, fullTextLower, parsed);
        result.categoryKey = catResult.key;
        result.suggestedCategory = catResult.title;
        result.categoryFolder = catResult.folder;
        result.categoryScores = catResult.scores;

        // === FILENAME ===
        result.suggestedFilename = this._generateFilename(result.suggestedTitle);

        // === TAGS ===
        result.suggestedTags = this._inferTags(inlineScriptContent, fullTextLower, parsed);

        // === COMPLEXITY ===
        if (lineCount < this.COMPLEXITY_THRESHOLDS.simple) {
          result.suggestedComplexity = 'simple';
        } else if (lineCount < this.COMPLEXITY_THRESHOLDS.intermediate) {
          result.suggestedComplexity = 'intermediate';
        } else {
          result.suggestedComplexity = 'advanced';
        }

        // === TYPE ===
        result.suggestedType = this._inferType(inlineScriptContent, fullTextLower);

        // === MANIFEST ENTRY ===
        result.manifestEntry = {
          title: result.suggestedTitle,
          file: result.suggestedFilename,
          description: result.suggestedDescription,
          tags: result.suggestedTags,
          complexity: result.suggestedComplexity,
          type: result.suggestedType,
          featured: analysis.score >= 70,
          created: new Date().toISOString().split('T')[0]
        };

        // === REWRITTEN HTML ===
        result.rewrittenHTML = this._rewriteHTML(html, parsed, analysis, result);

        return result;
      },

      _inferTitle(parsed, html) {
        // Priority: <title> tag > <h1> > first heading > filename heuristic
        if (parsed.title && parsed.title.trim()) {
          return parsed.title.trim();
        }

        const h1Match = html.match(/<h1[^>]*>([\s\S]*?)<\/h1>/i);
        if (h1Match) {
          const stripped = h1Match[1].replace(/<[^>]*>/g, '').trim();
          if (stripped.length > 2 && stripped.length < 100) return stripped;
        }

        const hMatch = html.match(/<h[1-3][^>]*>([\s\S]*?)<\/h[1-3]>/i);
        if (hMatch) {
          const stripped = hMatch[1].replace(/<[^>]*>/g, '').trim();
          if (stripped.length > 2 && stripped.length < 100) return stripped;
        }

        return 'Untitled App';
      },

      _inferDescription(parsed, html, scriptContent) {
        // Priority: meta description > infer from content
        const metaDesc = parsed.metas.find(m => m.name && /description/i.test(m.name));
        if (metaDesc && metaDesc.content && metaDesc.content.trim().length > 10) {
          return metaDesc.content.trim();
        }

        // Build from detected features
        const features = [];
        if (/canvas/i.test(html)) features.push('canvas-based');
        if (/webgl|three/i.test(scriptContent)) features.push('3D');
        if (/audiocontext|oscillator/i.test(scriptContent)) features.push('audio');
        if (parsed.hasLocalStorage) features.push('with persistent state');
        if (parsed.hasJsonExport) features.push('JSON import/export');
        if (/drag|resize|sortable/i.test(scriptContent)) features.push('interactive');

        const title = this._inferTitle(parsed, html);
        if (features.length > 0) {
          return `${title} - ${features.slice(0, 4).join(', ')} application`;
        }
        return `Self-contained ${title.toLowerCase()} application`;
      },

      _classifyCategory(scriptContent, styleContent, fullText, parsed) {
        const scores = {};

        for (const [key, cat] of Object.entries(this.CATEGORIES)) {
          let score = 0;
          for (const kw of cat.keywords) {
            const kwLower = kw.toLowerCase();
            // Check script content (highest weight)
            const scriptHits = (scriptContent.match(new RegExp(kwLower.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi')) || []).length;
            score += scriptHits * 3;
            // Check full text (medium weight)
            const fullHits = (fullText.match(new RegExp(kwLower.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi')) || []).length;
            score += fullHits * 1;
          }
          scores[key] = score;
        }

        // Find winner
        let bestKey = 'experimental_ai'; // default fallback
        let bestScore = 0;
        for (const [key, score] of Object.entries(scores)) {
          if (score > bestScore) {
            bestScore = score;
            bestKey = key;
          }
        }

        return {
          key: bestKey,
          title: this.CATEGORIES[bestKey].title,
          folder: this.CATEGORIES[bestKey].folder,
          scores
        };
      },

      _generateFilename(title) {
        return title
          .toLowerCase()
          .replace(/[^a-z0-9\s-]/g, '')  // strip special chars
          .replace(/\s+/g, '-')            // spaces to hyphens
          .replace(/-+/g, '-')             // collapse multiple hyphens
          .replace(/^-|-$/g, '')           // trim leading/trailing hyphens
          .slice(0, 60)                    // max 60 chars
          + '.html';
      },

      _inferTags(scriptContent, fullText, parsed) {
        const tagCandidates = {
          'canvas':       /\bcanvas\b|getContext\s*\(\s*['"]2d['"]\)/i,
          '3d':           /three\.?js|webgl|3d/i,
          'svg':          /<svg|createElementNS.*svg/i,
          'animation':    /requestAnimationFrame|@keyframes|transition|animate/i,
          'physics':      /gravity|velocity|acceleration|collision/i,
          'audio':        /audiocontext|oscillator|webaudio/i,
          'game':         /score|lives|level|gameloop|gameover/i,
          'interactive':  /addEventListener|onclick|drag|click/i,
          'generative':   /random|noise|procedural|fractal/i,
          'visualization':/chart|graph|plot|histogram|data.*vis/i,
          'creative':     /draw|paint|brush|palette|color.*pick/i,
          'terminal':     /terminal|console|command|cli|shell/i,
          'drawing':      /draw|stroke|lineTo|bezier|path/i,
        };

        const tags = [];
        for (const [tag, regex] of Object.entries(tagCandidates)) {
          if (regex.test(scriptContent) || regex.test(fullText)) {
            tags.push(tag);
          }
        }

        // Cap at 6 most relevant
        return tags.slice(0, 6);
      },

      _inferType(scriptContent, fullText) {
        const scores = {};
        for (const [type, keywords] of Object.entries(this.TYPE_KEYWORDS)) {
          scores[type] = 0;
          for (const kw of keywords) {
            const regex = new RegExp(kw.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
            scores[type] += (scriptContent.match(regex) || []).length;
            scores[type] += (fullText.match(regex) || []).length * 0.5;
          }
        }

        let best = 'interactive';
        let bestScore = 0;
        for (const [type, score] of Object.entries(scores)) {
          if (score > bestScore) {
            bestScore = score;
            best = type;
          }
        }
        return best;
      },

      _rewriteHTML(html, parsed, analysis, rewriteResult) {
        // Start with the improved HTML (all auto-fixes applied)
        let output = Improver.improve(html).html;

        // Ensure the title matches our suggested title
        if (parsed.title !== rewriteResult.suggestedTitle) {
          if (/<title[^>]*>[\s\S]*?<\/title>/i.test(output)) {
            output = output.replace(/<title[^>]*>[\s\S]*?<\/title>/i,
              `<title>${this._escHTML(rewriteResult.suggestedTitle)}</title>`);
          } else if (/<head[^>]*>/i.test(output)) {
            output = output.replace(/(<head[^>]*>)/i,
              `$1\n  <title>${this._escHTML(rewriteResult.suggestedTitle)}</title>`);
          }
        }

        // Ensure meta description exists and matches
        if (!parsed.hasDescription || parsed.metas.find(m => m.name === 'description')?.content !== rewriteResult.suggestedDescription) {
          const descContent = this._escAttr(rewriteResult.suggestedDescription);
          if (/<meta\s+name=["']description["'][^>]*>/i.test(output)) {
            output = output.replace(/<meta\s+name=["']description["'][^>]*>/i,
              `<meta name="description" content="${descContent}">`);
          } else if (/<head[^>]*>/i.test(output)) {
            // Insert after title or after last meta
            if (/<\/title>/i.test(output)) {
              output = output.replace(/(<\/title>)/i,
                `$1\n  <meta name="description" content="${descContent}">`);
            } else {
              output = output.replace(/(<head[^>]*>)/i,
                `$1\n  <meta name="description" content="${descContent}">`);
            }
          }
        }

        return output;
      },

      _escHTML(str) {
        return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
      },

      _escAttr(str) {
        return str.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
      }
    };

    // ==================== Module 8: UI ====================
    const UI = {
      currentTab: 'input',
      currentHTML: '',
      currentFilename: '',
      currentAnalysis: null,
      currentImproved: null,
      currentRewrite: null,

      init() {
        this.setupTabs();
        this.setupInput();
        this.setupHistory();
        this.setupKeyboardShortcuts();
        this.renderHistory();
        API.checkHealth();
        // Re-check every 30s in case server starts/stops
        setInterval(() => API.checkHealth(), 30000);
      },

      setupTabs() {
        const buttons = document.querySelectorAll('.tab-button');
        buttons.forEach(btn => {
          btn.addEventListener('click', () => {
            const tab = btn.dataset.tab;
            this.switchTab(tab);
          });
        });
      },

      switchTab(tab) {
        document.querySelectorAll('.tab-button').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.tab === tab);
          btn.setAttribute('aria-selected', btn.dataset.tab === tab);
        });

        document.querySelectorAll('.tab-content').forEach(content => {
          content.classList.toggle('active', content.id === `tab-${tab}`);
        });

        this.currentTab = tab;

        if (tab === 'history') {
          this.renderHistory();
        }
      },

      setupInput() {
        const textarea = document.getElementById('html-input');
        const fileUpload = document.getElementById('file-upload');
        const filenameInput = document.getElementById('filename-input');
        const analyzeBtn = document.getElementById('analyze-btn');

        fileUpload.addEventListener('change', (e) => {
          const file = e.target.files[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = (event) => {
            textarea.value = event.target.result;
            filenameInput.value = file.name;
          };
          reader.readAsText(file);
        });

        analyzeBtn.addEventListener('click', () => {
          this.analyze();
        });
      },

      setupHistory() {
        document.getElementById('export-history-btn').addEventListener('click', () => {
          this.exportHistory();
        });

        document.getElementById('import-history-btn').addEventListener('click', () => {
          document.getElementById('import-history-file').click();
        });

        document.getElementById('import-history-file').addEventListener('change', (e) => {
          const file = e.target.files[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = (event) => {
            try {
              History.importJSON(event.target.result);
              alert('History imported successfully!');
              this.renderHistory();
            } catch (err) {
              alert('Error importing history: ' + err.message);
            }
          };
          reader.readAsText(file);
        });

        document.getElementById('clear-history-btn').addEventListener('click', () => {
          if (confirm('Are you sure you want to clear all history? This cannot be undone.')) {
            History.clear();
            this.renderHistory();
          }
        });
      },

      setupKeyboardShortcuts() {
        document.addEventListener('keydown', (e) => {
          if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT') {
            if (e.ctrlKey && e.key === 'Enter') {
              e.preventDefault();
              this.analyze();
            }
            return;
          }

          if (e.key >= '1' && e.key <= '5') {
            const tabs = ['input', 'analysis', 'improved', 'history', 'rewrite'];
            this.switchTab(tabs[parseInt(e.key) - 1]);
          }

          if (this.currentTab === 'improved') {
            if (e.ctrlKey && e.key === 'd') {
              e.preventDefault();
              this.downloadImproved();
            }

            if (e.ctrlKey && e.shiftKey && e.key === 'C') {
              e.preventDefault();
              this.copyImproved();
            }
          }
        });
      },

      analyze() {
        const html = document.getElementById('html-input').value.trim();
        const filename = document.getElementById('filename-input').value.trim() || 'untitled.html';

        if (!html) {
          alert('Please paste HTML code or upload a file.');
          return;
        }

        this.currentHTML = html;
        this.currentFilename = filename;

        const parsed = Parser.parse(html);
        const analysis = Analyzer.analyze(parsed);

        this.currentAnalysis = analysis;

        const failedRules = analysis.results.filter(r => !r.passed).map(r => r.id);
        History.record({
          filename,
          score: analysis.score,
          failedRules,
          timestamp: Date.now()
        });

        this.renderAnalysis(analysis);
        this.switchTab('analysis');
      },

      renderAnalysis(analysis) {
        const container = document.getElementById('analysis-results');

        const scoreClass = analysis.score >= 70 ? 'high' : analysis.score >= 40 ? 'medium' : 'low';

        let html = `
          <div class="score-display">
            <div class="score-label">Quality Score</div>
            <div class="score-number ${scoreClass}">${analysis.score}</div>
            <div class="score-label">out of 100</div>
          </div>

          <div class="summary">
            <div class="summary-item errors">
              <div class="count">${analysis.summary.errors}</div>
              <div class="label">Errors</div>
            </div>
            <div class="summary-item warnings">
              <div class="count">${analysis.summary.warnings}</div>
              <div class="label">Warnings</div>
            </div>
            <div class="summary-item info">
              <div class="count">${analysis.summary.info}</div>
              <div class="label">Info</div>
            </div>
          </div>

          <div style="text-align: center; margin-bottom: 30px;">
            <button class="primary" onclick="UI.improveHTML()">Improve HTML</button>
            <button onclick="UI.rewriteHTML()" style="background: #a29bfe;">Rewrite &amp; Classify</button>
          </div>
        `;

        const groups = { error: [], warning: [], info: [] };
        for (const result of analysis.results) {
          groups[result.severity].push(result);
        }

        for (const [severity, results] of Object.entries(groups)) {
          if (results.length === 0) continue;

          const severityTitle = severity.charAt(0).toUpperCase() + severity.slice(1) + 's';
          html += `<div class="rule-group">`;
          html += `<h3 class="rule-group-title">${severityTitle}</h3>`;

          for (const result of results) {
            const icon = result.passed ? '✓' : '✗';
            const passedClass = result.passed ? 'passed' : 'failed';

            html += `
              <div class="rule-item ${passedClass}">
                <div class="rule-icon">${icon}</div>
                <div class="rule-content">
                  <div class="rule-id">${result.id}</div>
                  <div class="rule-message">${result.message}</div>
                </div>
                <span class="severity-badge ${result.severity}">${result.severity}</span>
              </div>
            `;
          }

          html += `</div>`;
        }

        container.innerHTML = html;
      },

      improveHTML() {
        if (!this.currentHTML) return;

        const improved = Improver.improve(this.currentHTML);
        this.currentImproved = improved;

        const diff = Differ.diff(this.currentHTML, improved.html);
        this.renderImproved(improved, diff);
        this.switchTab('improved');
      },

      renderImproved(improved, diff) {
        const container = document.getElementById('improved-results');

        let html = `
          <h2 style="margin-bottom: 20px; color: #74b9ff;">Improved HTML</h2>

          <div class="change-log">
            <h3>Changes Applied</h3>
        `;

        if (improved.changes.length === 0) {
          html += `<p style="color: #a8a8a8;">No automatic improvements available.</p>`;
        } else {
          for (const change of improved.changes) {
            html += `
              <div class="change-item">
                <div class="rule">${change.rule}</div>
                <div class="description">${change.description}</div>
              </div>
            `;
          }
        }

        html += `</div>`;

        html += `
          <div class="stats-box">
            <strong>Lines added:</strong> ${diff.stats.added} |
            <strong>Lines removed:</strong> ${diff.stats.removed} |
            <strong>Lines unchanged:</strong> ${diff.stats.unchanged}
          </div>
        `;

        html += `
          <div style="margin-bottom: 20px;">
            <button class="primary" onclick="UI.downloadImproved()">Download Improved HTML</button>
            <button onclick="UI.copyImproved()">Copy to Clipboard</button>
          </div>
        `;

        html += `
          <h3 style="margin-bottom: 15px; color: #74b9ff;">Diff View</h3>
          <div class="diff-container">
            ${Differ.toHTML(diff)}
          </div>
        `;

        container.innerHTML = html;
      },

      downloadImproved() {
        if (!this.currentImproved) return;

        const blob = new Blob([this.currentImproved.html], { type: 'text/html' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = this.currentFilename.replace('.html', '-improved.html');
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      },

      copyImproved() {
        if (!this.currentImproved) return;

        navigator.clipboard.writeText(this.currentImproved.html).then(() => {
          alert('Improved HTML copied to clipboard!');
        }).catch(() => {
          alert('Failed to copy to clipboard. Please try again.');
        });
      },

      renderHistory() {
        const stats = History.getStats();
        const insights = History.getInsights();
        const entries = History.load();

        const insightsContainer = document.getElementById('history-insights');
        if (insights.length === 0) {
          insightsContainer.innerHTML = `
            <div class="empty-state">
              <div class="icon">📊</div>
              <p>No analysis history yet. Run your first scan to see insights!</p>
            </div>
          `;
        } else {
          let html = `<div class="insights-panel"><h3>Insights</h3>`;
          for (const insight of insights) {
            html += `<div class="insight-item">${insight}</div>`;
          }
          html += `</div>`;
          insightsContainer.innerHTML = html;
        }

        const sparklineContainer = document.getElementById('history-sparkline');
        if (stats.scoreTrend.length > 0) {
          const max = Math.max(...stats.scoreTrend, 1);
          let sparkHTML = `
            <h3 style="margin-bottom: 10px; color: #74b9ff;">Score Trend (Last 20 Scans)</h3>
            <div class="sparkline">
          `;

          for (const score of stats.scoreTrend) {
            const height = Math.max((score / max) * 100, 5);
            sparkHTML += `<div class="sparkline-bar" style="height: ${height}%" title="Score: ${score}"></div>`;
          }

          sparkHTML += `</div>`;
          sparklineContainer.innerHTML = sparkHTML;
        } else {
          sparklineContainer.innerHTML = '';
        }

        const tableContainer = document.getElementById('history-table');
        if (entries.length === 0) {
          tableContainer.innerHTML = '';
        } else {
          let tableHTML = `
            <div class="history-table">
              <table>
                <thead>
                  <tr>
                    <th>Date</th>
                    <th>Filename</th>
                    <th>Score</th>
                    <th>Issues</th>
                  </tr>
                </thead>
                <tbody>
          `;

          const reversed = [...entries].reverse();
          for (const entry of reversed) {
            const date = new Date(entry.timestamp).toLocaleString();
            const scoreClass = entry.score >= 70 ? 'high' : entry.score >= 40 ? 'medium' : 'low';

            tableHTML += `
              <tr>
                <td>${date}</td>
                <td>${entry.filename}</td>
                <td><span class="score-number ${scoreClass}" style="font-size: 1.2rem;">${entry.score}</span></td>
                <td>${entry.failedRules.length}</td>
              </tr>
            `;
          }

          tableHTML += `
                </tbody>
              </table>
            </div>
          `;

          tableContainer.innerHTML = tableHTML;
        }
      },

      async rewriteHTML() {
        if (!this.currentHTML) return;

        const parsed = Parser.parse(this.currentHTML);
        const analysis = this.currentAnalysis || Analyzer.analyze(parsed);

        // Always compute local rewrite first (instant)
        const localRewrite = Rewriter.rewrite(this.currentHTML, parsed, analysis);

        // If API is available, try AI-powered rewrite
        if (API.available && API.backend === 'copilot-cli') {
          this.switchTab('rewrite');
          const container = document.getElementById('rewrite-results');
          container.innerHTML = `
            <div style="text-align: center; padding: 60px 20px;">
              <div class="ai-spinner" style="width: 40px; height: 40px; border-width: 3px; margin: 0 auto 20px;"></div>
              <h2 style="color: #a29bfe; margin-bottom: 10px;">AI Rewrite in Progress</h2>
              <p style="color: #a8a8a8;">Calling Claude via Copilot CLI... This may take 30-60 seconds.</p>
              <p style="color: #a8a8a8; margin-top: 10px; font-size: 0.9rem;">Local regex rewrite is ready as fallback.</p>
            </div>
          `;

          const failedRules = analysis.results.filter(r => !r.passed).map(r => r.id);
          const analysisContext = {
            score: analysis.score,
            errors: analysis.summary.errors,
            warnings: analysis.summary.warnings,
            failedRules,
          };

          const aiResult = await API.rewrite(this.currentHTML, this.currentFilename, analysisContext);

          if (aiResult && aiResult.suggestedTitle) {
            // Merge AI metadata into local rewrite (local Improver handles the HTML)
            const mergedRewrite = { ...localRewrite };
            mergedRewrite.aiPowered = true;
            mergedRewrite.improvements = aiResult.improvements || [];
            mergedRewrite.externalDepsFound = aiResult.externalDepsFound || [];
            mergedRewrite.securityIssues = aiResult.securityIssues || [];
            mergedRewrite.accessibilityNotes = aiResult.accessibilityNotes || '';

            if (aiResult.suggestedFilename) mergedRewrite.suggestedFilename = aiResult.suggestedFilename;
            if (aiResult.suggestedTitle) mergedRewrite.suggestedTitle = aiResult.suggestedTitle;
            if (aiResult.suggestedDescription) mergedRewrite.suggestedDescription = aiResult.suggestedDescription;
            if (aiResult.suggestedCategory) {
              mergedRewrite.categoryKey = aiResult.suggestedCategory;
              mergedRewrite.suggestedCategory = Rewriter.CATEGORIES[aiResult.suggestedCategory]?.title || aiResult.suggestedCategory;
              mergedRewrite.categoryFolder = aiResult.categoryFolder || Rewriter.CATEGORIES[aiResult.suggestedCategory]?.folder || aiResult.suggestedCategory;
            }
            if (aiResult.suggestedTags) mergedRewrite.suggestedTags = aiResult.suggestedTags;
            if (aiResult.suggestedType) mergedRewrite.suggestedType = aiResult.suggestedType;
            if (aiResult.suggestedComplexity) mergedRewrite.suggestedComplexity = aiResult.suggestedComplexity;

            // Rebuild manifest entry with AI data
            mergedRewrite.manifestEntry = {
              title: mergedRewrite.suggestedTitle,
              file: mergedRewrite.suggestedFilename,
              description: mergedRewrite.suggestedDescription,
              tags: mergedRewrite.suggestedTags,
              complexity: mergedRewrite.suggestedComplexity,
              type: mergedRewrite.suggestedType,
              featured: analysis.score >= 70,
              created: new Date().toISOString().split('T')[0]
            };

            this.currentRewrite = mergedRewrite;
            this.renderRewrite(mergedRewrite, analysis);
            return;
          }
          // AI failed — fall through to local
        }

        this.currentRewrite = localRewrite;
        this.renderRewrite(localRewrite, analysis);
        this.switchTab('rewrite');
      },

      renderRewrite(rewrite, analysis) {
        const container = document.getElementById('rewrite-results');
        const esc = (s) => s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');

        // Build category scores for display (top 3)
        const sortedCats = Object.entries(rewrite.categoryScores)
          .sort((a, b) => b[1] - a[1])
          .filter(([, score]) => score > 0)
          .slice(0, 4);

        let catScoresHTML = '';
        if (sortedCats.length > 0) {
          const maxScore = sortedCats[0][1] || 1;
          catScoresHTML = sortedCats.map(([key, score]) => {
            const cat = Rewriter.CATEGORIES[key];
            const pct = Math.round((score / maxScore) * 100);
            const isWinner = key === rewrite.categoryKey;
            return `
              <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 6px;">
                <span style="min-width: 140px; font-size: 0.9rem; ${isWinner ? 'color: #a29bfe; font-weight: 600;' : 'color: #a8a8a8;'}">${cat.title}</span>
                <div style="flex: 1; background: #0f3460; height: 8px; border-radius: 4px; overflow: hidden;">
                  <div style="width: ${pct}%; height: 100%; background: ${isWinner ? '#a29bfe' : '#74b9ff'}; border-radius: 4px;"></div>
                </div>
                <span style="min-width: 30px; text-align: right; font-size: 0.85rem; color: #a8a8a8;">${score}</span>
              </div>
            `;
          }).join('');
        }

        const manifestJSON = JSON.stringify(rewrite.manifestEntry, null, 2);

        let html = `
          <h2 style="margin-bottom: 20px; color: #a29bfe;">
            Rewrite Suggestions
            ${rewrite.aiPowered ? '<span class="ai-badge" style="margin-left: 10px; vertical-align: middle;">AI Powered</span>' : '<span style="font-size: 0.8rem; color: #a8a8a8; margin-left: 10px; vertical-align: middle;">(Local Regex)</span>'}
          </h2>

          <div class="rewriter-section">
            <h3>Suggested Title</h3>
            <div class="suggestion-card">
              <div class="suggestion-label">Title</div>
              <div class="suggestion-value">${esc(rewrite.suggestedTitle)}</div>
            </div>
          </div>

          <div class="rewriter-section">
            <h3>Suggested Filename</h3>
            <div class="suggestion-card filename">
              <div class="suggestion-label">Filename</div>
              <div class="suggestion-value">${esc(rewrite.suggestedFilename)}</div>
              <div class="suggestion-reason">Generated from title, kebab-case, max 60 chars</div>
            </div>
          </div>

          <div class="rewriter-section">
            <h3>Category Classification</h3>
            <div class="suggestion-card category">
              <div class="suggestion-label">Best Match</div>
              <div class="suggestion-value">${esc(rewrite.suggestedCategory)}</div>
              <div class="suggestion-reason">Folder: apps/${esc(rewrite.categoryFolder)}/</div>
            </div>
            <div style="margin-top: 15px;">
              <div class="suggestion-label" style="font-size: 0.85rem; color: #a8a8a8; margin-bottom: 8px;">CATEGORY SCORES</div>
              ${catScoresHTML}
            </div>
          </div>

          <div class="rewriter-section">
            <h3>Detected Tags</h3>
            <div class="tag-list">
              ${rewrite.suggestedTags.map(t => `<span class="tag-chip">${esc(t)}</span>`).join('')}
            </div>
          </div>

          <div class="rewriter-section">
            <h3>Classification</h3>
            <div style="display: flex; gap: 20px; flex-wrap: wrap;">
              <div class="suggestion-card" style="flex: 1; min-width: 150px;">
                <div class="suggestion-label">Complexity</div>
                <div class="suggestion-value">${esc(rewrite.suggestedComplexity)}</div>
                <div class="suggestion-reason">${this.currentHTML.split('\n').length} lines</div>
              </div>
              <div class="suggestion-card" style="flex: 1; min-width: 150px;">
                <div class="suggestion-label">Type</div>
                <div class="suggestion-value">${esc(rewrite.suggestedType)}</div>
              </div>
              <div class="suggestion-card" style="flex: 1; min-width: 150px;">
                <div class="suggestion-label">Quality Score</div>
                <div class="suggestion-value">${analysis.score}/100</div>
                <div class="suggestion-reason">Featured: ${rewrite.manifestEntry.featured ? 'Yes' : 'No'}</div>
              </div>
            </div>
          </div>

          <div class="rewriter-section">
            <h3>Description</h3>
            <div class="suggestion-card">
              <div class="suggestion-value" style="font-size: 1rem; font-family: inherit; font-weight: normal;">${esc(rewrite.suggestedDescription)}</div>
            </div>
          </div>

          <div class="rewriter-section">
            <h3>Manifest Entry (JSON)</h3>
            <div class="manifest-preview">${esc(manifestJSON)}</div>
          </div>

          <div class="rewriter-actions">
            <button class="primary" onclick="UI.downloadRewritten()">Download Rewritten HTML</button>
            <button onclick="UI.copyRewritten()">Copy Rewritten HTML</button>
            <button onclick="UI.copyManifest()">Copy Manifest JSON</button>
          </div>

          <div class="rewriter-section" style="margin-top: 20px;">
            <h3>Rewritten HTML Diff</h3>
            <div id="rewrite-diff"></div>
          </div>
        `;

        container.innerHTML = html;

        // Render the diff between original and rewritten
        const diff = Differ.diff(this.currentHTML, rewrite.rewrittenHTML);
        const diffContainer = document.getElementById('rewrite-diff');
        diffContainer.innerHTML = `
          <div class="stats-box" style="margin-bottom: 15px;">
            <strong>Lines added:</strong> ${diff.stats.added} |
            <strong>Lines removed:</strong> ${diff.stats.removed} |
            <strong>Lines unchanged:</strong> ${diff.stats.unchanged}
          </div>
          <div class="diff-container">${Differ.toHTML(diff)}</div>
        `;
      },

      downloadRewritten() {
        if (!this.currentRewrite) return;
        const blob = new Blob([this.currentRewrite.rewrittenHTML], { type: 'text/html' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = this.currentRewrite.suggestedFilename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      },

      copyRewritten() {
        if (!this.currentRewrite) return;
        navigator.clipboard.writeText(this.currentRewrite.rewrittenHTML).then(() => {
          alert('Rewritten HTML copied to clipboard!');
        }).catch(() => {
          alert('Failed to copy. Please try again.');
        });
      },

      copyManifest() {
        if (!this.currentRewrite) return;
        const json = JSON.stringify(this.currentRewrite.manifestEntry, null, 2);
        navigator.clipboard.writeText(json).then(() => {
          alert('Manifest JSON copied to clipboard!');
        }).catch(() => {
          alert('Failed to copy. Please try again.');
        });
      },

      exportHistory() {
        const json = History.exportJSON();
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'dataslosh-history.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
    };

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', () => {
      UI.init();
    });
  </script>
</body>
</html>
