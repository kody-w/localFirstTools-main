<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Local-first database with SQL-like queries, IndexedDB persistence, and CRDT-based conflict resolution">
    <meta name="theme-color" content="#0a0a0f">
    <meta name="color-scheme" content="dark">
    <title>Local-First CRDT Database</title>
    <!-- database, crdt, sync, indexeddb, sql, offline-first -->
    <style>
        :root {
            --bg-primary: #0a0a0f;
            --bg-secondary: #12121a;
            --bg-tertiary: #1a1a25;
            --text-primary: #e8e8f0;
            --text-secondary: #a0a0b0;
            --accent-primary: #6366f1;
            --accent-secondary: #818cf8;
            --success: #22c55e;
            --warning: #f59e0b;
            --error: #ef4444;
            --border: #2a2a3a;
            --device-a: #3b82f6;
            --device-b: #8b5cf6;
            --conflict: #f59e0b;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Mono', 'Consolas', 'Monaco', monospace;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .app-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto 1fr auto;
            height: 100vh;
            gap: 1px;
            background: var(--border);
        }

        header {
            grid-column: 1 / -1;
            background: var(--bg-secondary);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .logo h1 {
            font-size: 1.25rem;
            background: linear-gradient(135deg, var(--device-a), var(--device-b));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .sync-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: var(--bg-tertiary);
            border-radius: 9999px;
            font-size: 0.75rem;
        }

        .sync-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--success);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .device-panel {
            background: var(--bg-secondary);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .device-header {
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border);
        }

        .device-header.device-a {
            border-top: 3px solid var(--device-a);
        }

        .device-header.device-b {
            border-top: 3px solid var(--device-b);
        }

        .device-name {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
        }

        .device-name .icon {
            width: 24px;
            height: 24px;
        }

        .offline-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .toggle-switch {
            position: relative;
            width: 40px;
            height: 20px;
            background: var(--bg-tertiary);
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .toggle-switch.active {
            background: var(--error);
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.3s;
        }

        .toggle-switch.active::after {
            transform: translateX(20px);
        }

        .query-section {
            padding: 1rem;
            border-bottom: 1px solid var(--border);
        }

        .query-input {
            width: 100%;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 0.75rem;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 0.875rem;
            resize: vertical;
            min-height: 80px;
        }

        .query-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .query-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.75rem;
            font-weight: 600;
            transition: all 0.2s;
        }

        .btn-primary {
            background: var(--accent-primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--accent-secondary);
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--border);
        }

        .btn-sync {
            background: linear-gradient(135deg, var(--device-a), var(--device-b));
            color: white;
        }

        .data-view {
            flex: 1;
            overflow: auto;
            padding: 1rem;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.75rem;
        }

        .data-table th {
            background: var(--bg-tertiary);
            padding: 0.5rem;
            text-align: left;
            font-weight: 600;
            color: var(--text-secondary);
            position: sticky;
            top: 0;
        }

        .data-table td {
            padding: 0.5rem;
            border-bottom: 1px solid var(--border);
        }

        .data-table tr:hover td {
            background: var(--bg-tertiary);
        }

        .crdt-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.125rem 0.375rem;
            border-radius: 4px;
            font-size: 0.625rem;
            font-weight: 600;
        }

        .crdt-badge.lww {
            background: rgba(99, 102, 241, 0.2);
            color: var(--accent-secondary);
        }

        .crdt-badge.counter {
            background: rgba(34, 197, 94, 0.2);
            color: var(--success);
        }

        .crdt-badge.conflict {
            background: rgba(245, 158, 11, 0.2);
            color: var(--warning);
        }

        .operation-log {
            padding: 1rem;
            background: var(--bg-tertiary);
            border-top: 1px solid var(--border);
            max-height: 150px;
            overflow-y: auto;
            font-size: 0.7rem;
        }

        .log-entry {
            padding: 0.25rem 0;
            display: flex;
            gap: 0.5rem;
            color: var(--text-secondary);
        }

        .log-entry .timestamp {
            color: var(--text-secondary);
            opacity: 0.5;
        }

        .log-entry.insert { color: var(--success); }
        .log-entry.update { color: var(--warning); }
        .log-entry.delete { color: var(--error); }
        .log-entry.sync { color: var(--accent-secondary); }

        footer {
            grid-column: 1 / -1;
            background: var(--bg-secondary);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top: 1px solid var(--border);
        }

        .stats {
            display: flex;
            gap: 2rem;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .stat-value {
            color: var(--text-primary);
            font-weight: 600;
        }

        .test-controls {
            display: flex;
            gap: 0.5rem;
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 2rem;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal h2 {
            margin-bottom: 1rem;
            font-size: 1.25rem;
        }

        .test-results {
            font-size: 0.8rem;
        }

        .test-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            border-bottom: 1px solid var(--border);
        }

        .test-item.pass .status { color: var(--success); }
        .test-item.fail .status { color: var(--error); }

        .test-summary {
            margin-top: 1rem;
            padding: 1rem;
            background: var(--bg-tertiary);
            border-radius: 8px;
        }

        /* Vector Clock Display */
        .vector-clock {
            display: inline-flex;
            gap: 0.25rem;
            font-size: 0.625rem;
            background: var(--bg-primary);
            padding: 0.125rem 0.375rem;
            border-radius: 4px;
        }

        .vc-entry {
            color: var(--text-secondary);
        }

        .vc-entry.device-a { color: var(--device-a); }
        .vc-entry.device-b { color: var(--device-b); }

        /* Import/Export */
        .import-export-section {
            display: flex;
            gap: 0.5rem;
        }

        .hidden-input {
            display: none;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <header>
            <div class="logo">
                <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 2L2 7l10 5 10-5-10-5z"/>
                    <path d="M2 17l10 5 10-5"/>
                    <path d="M2 12l10 5 10-5"/>
                </svg>
                <h1>Local-First CRDT Database</h1>
            </div>
            <div class="sync-status">
                <div class="sync-indicator"></div>
                <span id="syncStatusText">All devices synced</span>
            </div>
        </header>

        <!-- Device A Panel -->
        <div class="device-panel">
            <div class="device-header device-a">
                <div class="device-name">
                    <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="var(--device-a)" stroke-width="2">
                        <rect x="2" y="3" width="20" height="14" rx="2" ry="2"/>
                        <line x1="8" y1="21" x2="16" y2="21"/>
                        <line x1="12" y1="17" x2="12" y2="21"/>
                    </svg>
                    Device A
                </div>
                <div class="offline-toggle">
                    <span>Offline</span>
                    <div class="toggle-switch" id="offlineToggleA" onclick="toggleOffline('A')"></div>
                </div>
            </div>

            <div class="query-section">
                <textarea class="query-input" id="queryInputA" placeholder="Enter SQL-like query...
Examples:
  SELECT * FROM users
  INSERT INTO users (name, age) VALUES ('Alice', 30)
  UPDATE users SET age = 31 WHERE name = 'Alice'
  DELETE FROM users WHERE id = 1"></textarea>
                <div class="query-actions">
                    <button class="btn btn-primary" onclick="executeQuery('A')">Execute</button>
                    <button class="btn btn-secondary" onclick="loadSampleData('A')">Load Sample</button>
                    <button class="btn btn-secondary" onclick="clearData('A')">Clear</button>
                </div>
            </div>

            <div class="data-view" id="dataViewA">
                <table class="data-table" id="tableA">
                    <thead></thead>
                    <tbody></tbody>
                </table>
            </div>

            <div class="operation-log" id="logA"></div>
        </div>

        <!-- Device B Panel -->
        <div class="device-panel">
            <div class="device-header device-b">
                <div class="device-name">
                    <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="var(--device-b)" stroke-width="2">
                        <rect x="5" y="2" width="14" height="20" rx="2" ry="2"/>
                        <line x1="12" y1="18" x2="12.01" y2="18"/>
                    </svg>
                    Device B
                </div>
                <div class="offline-toggle">
                    <span>Offline</span>
                    <div class="toggle-switch" id="offlineToggleB" onclick="toggleOffline('B')"></div>
                </div>
            </div>

            <div class="query-section">
                <textarea class="query-input" id="queryInputB" placeholder="Enter SQL-like query..."></textarea>
                <div class="query-actions">
                    <button class="btn btn-primary" onclick="executeQuery('B')">Execute</button>
                    <button class="btn btn-secondary" onclick="loadSampleData('B')">Load Sample</button>
                    <button class="btn btn-secondary" onclick="clearData('B')">Clear</button>
                </div>
            </div>

            <div class="data-view" id="dataViewB">
                <table class="data-table" id="tableB">
                    <thead></thead>
                    <tbody></tbody>
                </table>
            </div>

            <div class="operation-log" id="logB"></div>
        </div>

        <footer>
            <div class="stats">
                <div class="stat-item">
                    <span>Rows (A):</span>
                    <span class="stat-value" id="rowCountA">0</span>
                </div>
                <div class="stat-item">
                    <span>Rows (B):</span>
                    <span class="stat-value" id="rowCountB">0</span>
                </div>
                <div class="stat-item">
                    <span>Pending Ops:</span>
                    <span class="stat-value" id="pendingOps">0</span>
                </div>
                <div class="stat-item">
                    <span>Query Time:</span>
                    <span class="stat-value" id="queryTime">0ms</span>
                </div>
            </div>
            <div class="test-controls">
                <button class="btn btn-sync" onclick="syncDevices()">Sync Devices</button>
                <button class="btn btn-secondary" onclick="generate100kRows()">Generate 100K Rows</button>
                <button class="btn btn-secondary" onclick="runTests()">Run Tests</button>
                <div class="import-export-section">
                    <button class="btn btn-secondary" onclick="exportData()">Export</button>
                    <button class="btn btn-secondary" onclick="document.getElementById('importInput').click()">Import</button>
                    <input type="file" id="importInput" class="hidden-input" accept=".json" onchange="importData(event)">
                </div>
            </div>
        </footer>
    </div>

    <!-- Test Results Modal -->
    <div class="modal-overlay" id="testModal">
        <div class="modal">
            <h2>Test Results</h2>
            <div class="test-results" id="testResults"></div>
            <div class="test-summary" id="testSummary"></div>
            <button class="btn btn-primary" style="margin-top: 1rem;" onclick="closeModal()">Close</button>
        </div>
    </div>

    <script>
        // ============================================
        // CRDT Implementation
        // ============================================

        class VectorClock {
            constructor(nodeId) {
                this.nodeId = nodeId;
                this.clock = {};
            }

            increment() {
                this.clock[this.nodeId] = (this.clock[this.nodeId] || 0) + 1;
                return this.clone();
            }

            merge(other) {
                const otherClock = other.clock || other;
                for (const node in otherClock) {
                    this.clock[node] = Math.max(this.clock[node] || 0, otherClock[node]);
                }
                return this;
            }

            compare(other) {
                const otherClock = other.clock || other;
                let thisGreater = false;
                let otherGreater = false;

                const allNodes = new Set([...Object.keys(this.clock), ...Object.keys(otherClock)]);

                for (const node of allNodes) {
                    const thisVal = this.clock[node] || 0;
                    const otherVal = otherClock[node] || 0;

                    if (thisVal > otherVal) thisGreater = true;
                    if (otherVal > thisVal) otherGreater = true;
                }

                if (thisGreater && !otherGreater) return 1;
                if (otherGreater && !thisGreater) return -1;
                if (thisGreater && otherGreater) return 0; // Concurrent
                return 0; // Equal
            }

            clone() {
                const newClock = new VectorClock(this.nodeId);
                newClock.clock = { ...this.clock };
                return newClock;
            }

            toJSON() {
                return { nodeId: this.nodeId, clock: this.clock };
            }

            static fromJSON(json) {
                const vc = new VectorClock(json.nodeId);
                vc.clock = json.clock;
                return vc;
            }
        }

        // LWW Register (Last-Writer-Wins)
        class LWWRegister {
            constructor(value, timestamp, nodeId) {
                this.value = value;
                this.timestamp = timestamp || Date.now();
                this.nodeId = nodeId;
            }

            update(value, timestamp, nodeId) {
                if (timestamp > this.timestamp ||
                    (timestamp === this.timestamp && nodeId > this.nodeId)) {
                    this.value = value;
                    this.timestamp = timestamp;
                    this.nodeId = nodeId;
                    return true;
                }
                return false;
            }

            merge(other) {
                return this.update(other.value, other.timestamp, other.nodeId);
            }

            toJSON() {
                return {
                    value: this.value,
                    timestamp: this.timestamp,
                    nodeId: this.nodeId
                };
            }

            static fromJSON(json) {
                return new LWWRegister(json.value, json.timestamp, json.nodeId);
            }
        }

        // G-Counter (Grow-only Counter)
        class GCounter {
            constructor(nodeId) {
                this.nodeId = nodeId;
                this.counts = {};
            }

            increment(amount = 1) {
                this.counts[this.nodeId] = (this.counts[this.nodeId] || 0) + amount;
            }

            value() {
                return Object.values(this.counts).reduce((a, b) => a + b, 0);
            }

            merge(other) {
                const otherCounts = other.counts || other;
                for (const node in otherCounts) {
                    this.counts[node] = Math.max(this.counts[node] || 0, otherCounts[node]);
                }
            }

            toJSON() {
                return { nodeId: this.nodeId, counts: this.counts };
            }

            static fromJSON(json) {
                const counter = new GCounter(json.nodeId);
                counter.counts = json.counts;
                return counter;
            }
        }

        // PN-Counter (Positive-Negative Counter)
        class PNCounter {
            constructor(nodeId) {
                this.nodeId = nodeId;
                this.p = new GCounter(nodeId);
                this.n = new GCounter(nodeId);
            }

            increment(amount = 1) {
                this.p.increment(amount);
            }

            decrement(amount = 1) {
                this.n.increment(amount);
            }

            value() {
                return this.p.value() - this.n.value();
            }

            merge(other) {
                this.p.merge(other.p);
                this.n.merge(other.n);
            }

            toJSON() {
                return { nodeId: this.nodeId, p: this.p.toJSON(), n: this.n.toJSON() };
            }

            static fromJSON(json) {
                const counter = new PNCounter(json.nodeId);
                counter.p = GCounter.fromJSON(json.p);
                counter.n = GCounter.fromJSON(json.n);
                return counter;
            }
        }

        // LWW-Element-Set (Last-Writer-Wins Element Set)
        class LWWElementSet {
            constructor(nodeId) {
                this.nodeId = nodeId;
                this.addSet = new Map(); // element -> { timestamp, nodeId }
                this.removeSet = new Map();
            }

            add(element, timestamp = Date.now()) {
                const key = JSON.stringify(element);
                const existing = this.addSet.get(key);
                if (!existing || timestamp > existing.timestamp ||
                    (timestamp === existing.timestamp && this.nodeId > existing.nodeId)) {
                    this.addSet.set(key, { timestamp, nodeId: this.nodeId });
                }
            }

            remove(element, timestamp = Date.now()) {
                const key = JSON.stringify(element);
                const existing = this.removeSet.get(key);
                if (!existing || timestamp > existing.timestamp ||
                    (timestamp === existing.timestamp && this.nodeId > existing.nodeId)) {
                    this.removeSet.set(key, { timestamp, nodeId: this.nodeId });
                }
            }

            has(element) {
                const key = JSON.stringify(element);
                const addEntry = this.addSet.get(key);
                const removeEntry = this.removeSet.get(key);

                if (!addEntry) return false;
                if (!removeEntry) return true;

                if (addEntry.timestamp > removeEntry.timestamp) return true;
                if (removeEntry.timestamp > addEntry.timestamp) return false;
                return addEntry.nodeId >= removeEntry.nodeId;
            }

            values() {
                const result = [];
                for (const [key, _] of this.addSet) {
                    const element = JSON.parse(key);
                    if (this.has(element)) {
                        result.push(element);
                    }
                }
                return result;
            }

            merge(other) {
                for (const [key, entry] of other.addSet) {
                    const existing = this.addSet.get(key);
                    if (!existing || entry.timestamp > existing.timestamp ||
                        (entry.timestamp === existing.timestamp && entry.nodeId > existing.nodeId)) {
                        this.addSet.set(key, entry);
                    }
                }
                for (const [key, entry] of other.removeSet) {
                    const existing = this.removeSet.get(key);
                    if (!existing || entry.timestamp > existing.timestamp ||
                        (entry.timestamp === existing.timestamp && entry.nodeId > existing.nodeId)) {
                        this.removeSet.set(key, entry);
                    }
                }
            }

            toJSON() {
                return {
                    nodeId: this.nodeId,
                    addSet: Array.from(this.addSet.entries()),
                    removeSet: Array.from(this.removeSet.entries())
                };
            }

            static fromJSON(json) {
                const set = new LWWElementSet(json.nodeId);
                set.addSet = new Map(json.addSet);
                set.removeSet = new Map(json.removeSet);
                return set;
            }
        }

        // ============================================
        // CRDT Document/Row
        // ============================================

        class CRDTRow {
            constructor(id, nodeId, fields = {}) {
                this.id = id;
                this.nodeId = nodeId;
                this.fields = {};
                this.vectorClock = new VectorClock(nodeId);
                this.deleted = new LWWRegister(false, Date.now(), nodeId);

                for (const [key, value] of Object.entries(fields)) {
                    this.fields[key] = new LWWRegister(value, Date.now(), nodeId);
                }
            }

            set(key, value, timestamp = Date.now()) {
                if (!this.fields[key]) {
                    this.fields[key] = new LWWRegister(value, timestamp, this.nodeId);
                } else {
                    this.fields[key].update(value, timestamp, this.nodeId);
                }
                this.vectorClock.increment();
            }

            get(key) {
                return this.fields[key]?.value;
            }

            getAll() {
                const result = { id: this.id };
                for (const [key, register] of Object.entries(this.fields)) {
                    result[key] = register.value;
                }
                return result;
            }

            markDeleted(timestamp = Date.now()) {
                this.deleted.update(true, timestamp, this.nodeId);
                this.vectorClock.increment();
            }

            isDeleted() {
                return this.deleted.value;
            }

            merge(other) {
                // Merge deletion status
                this.deleted.merge(other.deleted);

                // Merge all fields
                for (const [key, register] of Object.entries(other.fields)) {
                    if (!this.fields[key]) {
                        this.fields[key] = LWWRegister.fromJSON(register.toJSON());
                    } else {
                        this.fields[key].merge(register);
                    }
                }

                // Merge vector clocks
                this.vectorClock.merge(other.vectorClock);
            }

            toJSON() {
                const fieldsJSON = {};
                for (const [key, register] of Object.entries(this.fields)) {
                    fieldsJSON[key] = register.toJSON();
                }
                return {
                    id: this.id,
                    nodeId: this.nodeId,
                    fields: fieldsJSON,
                    vectorClock: this.vectorClock.toJSON(),
                    deleted: this.deleted.toJSON()
                };
            }

            static fromJSON(json) {
                const row = new CRDTRow(json.id, json.nodeId);
                row.vectorClock = VectorClock.fromJSON(json.vectorClock);
                row.deleted = LWWRegister.fromJSON(json.deleted);
                for (const [key, registerJSON] of Object.entries(json.fields)) {
                    row.fields[key] = LWWRegister.fromJSON(registerJSON);
                }
                return row;
            }
        }

        // ============================================
        // CRDT Table
        // ============================================

        class CRDTTable {
            constructor(name, nodeId) {
                this.name = name;
                this.nodeId = nodeId;
                this.rows = new Map();
                this.idCounter = new GCounter(nodeId);
                this.schema = new Set();
            }

            nextId() {
                this.idCounter.increment();
                return `${this.nodeId}-${this.idCounter.value()}`;
            }

            insert(fields, timestamp = Date.now()) {
                const id = this.nextId();
                const row = new CRDTRow(id, this.nodeId, fields);
                this.rows.set(id, row);

                // Update schema
                for (const key of Object.keys(fields)) {
                    this.schema.add(key);
                }

                return row;
            }

            update(id, fields, timestamp = Date.now()) {
                const row = this.rows.get(id);
                if (!row || row.isDeleted()) return null;

                for (const [key, value] of Object.entries(fields)) {
                    row.set(key, value, timestamp);
                    this.schema.add(key);
                }

                return row;
            }

            delete(id, timestamp = Date.now()) {
                const row = this.rows.get(id);
                if (!row) return false;
                row.markDeleted(timestamp);
                return true;
            }

            get(id) {
                const row = this.rows.get(id);
                if (!row || row.isDeleted()) return null;
                return row.getAll();
            }

            getAll() {
                const result = [];
                for (const row of this.rows.values()) {
                    if (!row.isDeleted()) {
                        result.push(row.getAll());
                    }
                }
                return result;
            }

            query(predicate) {
                return this.getAll().filter(predicate);
            }

            count() {
                let count = 0;
                for (const row of this.rows.values()) {
                    if (!row.isDeleted()) count++;
                }
                return count;
            }

            merge(other) {
                // Merge ID counter
                this.idCounter.merge(other.idCounter);

                // Merge schema
                for (const field of other.schema) {
                    this.schema.add(field);
                }

                // Merge rows
                for (const [id, otherRow] of other.rows) {
                    if (this.rows.has(id)) {
                        this.rows.get(id).merge(otherRow);
                    } else {
                        this.rows.set(id, CRDTRow.fromJSON(otherRow.toJSON()));
                    }
                }
            }

            toJSON() {
                const rowsJSON = {};
                for (const [id, row] of this.rows) {
                    rowsJSON[id] = row.toJSON();
                }
                return {
                    name: this.name,
                    nodeId: this.nodeId,
                    rows: rowsJSON,
                    idCounter: this.idCounter.toJSON(),
                    schema: Array.from(this.schema)
                };
            }

            static fromJSON(json) {
                const table = new CRDTTable(json.name, json.nodeId);
                table.idCounter = GCounter.fromJSON(json.idCounter);
                table.schema = new Set(json.schema);
                for (const [id, rowJSON] of Object.entries(json.rows)) {
                    table.rows.set(id, CRDTRow.fromJSON(rowJSON));
                }
                return table;
            }
        }

        // ============================================
        // CRDT Database
        // ============================================

        class CRDTDatabase {
            constructor(nodeId) {
                this.nodeId = nodeId;
                this.tables = new Map();
                this.operationLog = [];
                this.pendingOps = [];
            }

            createTable(name) {
                if (!this.tables.has(name)) {
                    this.tables.set(name, new CRDTTable(name, this.nodeId));
                }
                return this.tables.get(name);
            }

            getTable(name) {
                return this.tables.get(name);
            }

            dropTable(name) {
                return this.tables.delete(name);
            }

            logOperation(type, table, data) {
                const op = {
                    type,
                    table,
                    data,
                    timestamp: Date.now(),
                    nodeId: this.nodeId
                };
                this.operationLog.push(op);
                this.pendingOps.push(op);
                return op;
            }

            getPendingOps() {
                return [...this.pendingOps];
            }

            clearPendingOps() {
                this.pendingOps = [];
            }

            merge(other) {
                // Merge all tables
                for (const [name, otherTable] of other.tables) {
                    if (!this.tables.has(name)) {
                        this.tables.set(name, CRDTTable.fromJSON(otherTable.toJSON()));
                    } else {
                        this.tables.get(name).merge(otherTable);
                    }
                }
            }

            toJSON() {
                const tablesJSON = {};
                for (const [name, table] of this.tables) {
                    tablesJSON[name] = table.toJSON();
                }
                return {
                    nodeId: this.nodeId,
                    tables: tablesJSON,
                    operationLog: this.operationLog
                };
            }

            static fromJSON(json) {
                const db = new CRDTDatabase(json.nodeId);
                for (const [name, tableJSON] of Object.entries(json.tables)) {
                    db.tables.set(name, CRDTTable.fromJSON(tableJSON));
                }
                db.operationLog = json.operationLog || [];
                return db;
            }
        }

        // ============================================
        // SQL Parser and Executor
        // ============================================

        class SQLParser {
            static parse(sql) {
                sql = sql.trim();

                // SELECT
                const selectMatch = sql.match(/^SELECT\s+(.+?)\s+FROM\s+(\w+)(?:\s+WHERE\s+(.+?))?(?:\s+ORDER\s+BY\s+(\w+)(?:\s+(ASC|DESC))?)?(?:\s+LIMIT\s+(\d+))?$/i);
                if (selectMatch) {
                    return {
                        type: 'SELECT',
                        columns: selectMatch[1].trim() === '*' ? '*' : selectMatch[1].split(',').map(c => c.trim()),
                        table: selectMatch[2],
                        where: selectMatch[3] ? this.parseWhere(selectMatch[3]) : null,
                        orderBy: selectMatch[4] || null,
                        orderDir: selectMatch[5]?.toUpperCase() || 'ASC',
                        limit: selectMatch[6] ? parseInt(selectMatch[6]) : null
                    };
                }

                // INSERT
                const insertMatch = sql.match(/^INSERT\s+INTO\s+(\w+)\s*\((.+?)\)\s*VALUES\s*\((.+?)\)$/i);
                if (insertMatch) {
                    const columns = insertMatch[2].split(',').map(c => c.trim());
                    const values = this.parseValues(insertMatch[3]);
                    const fields = {};
                    columns.forEach((col, i) => fields[col] = values[i]);
                    return {
                        type: 'INSERT',
                        table: insertMatch[1],
                        fields
                    };
                }

                // UPDATE
                const updateMatch = sql.match(/^UPDATE\s+(\w+)\s+SET\s+(.+?)(?:\s+WHERE\s+(.+))?$/i);
                if (updateMatch) {
                    const sets = this.parseSets(updateMatch[2]);
                    return {
                        type: 'UPDATE',
                        table: updateMatch[1],
                        sets,
                        where: updateMatch[3] ? this.parseWhere(updateMatch[3]) : null
                    };
                }

                // DELETE
                const deleteMatch = sql.match(/^DELETE\s+FROM\s+(\w+)(?:\s+WHERE\s+(.+))?$/i);
                if (deleteMatch) {
                    return {
                        type: 'DELETE',
                        table: deleteMatch[1],
                        where: deleteMatch[2] ? this.parseWhere(deleteMatch[2]) : null
                    };
                }

                // CREATE TABLE
                const createMatch = sql.match(/^CREATE\s+TABLE\s+(?:IF\s+NOT\s+EXISTS\s+)?(\w+)/i);
                if (createMatch) {
                    return {
                        type: 'CREATE_TABLE',
                        table: createMatch[1]
                    };
                }

                // DROP TABLE
                const dropMatch = sql.match(/^DROP\s+TABLE\s+(?:IF\s+EXISTS\s+)?(\w+)/i);
                if (dropMatch) {
                    return {
                        type: 'DROP_TABLE',
                        table: dropMatch[1]
                    };
                }

                throw new Error(`Unable to parse SQL: ${sql}`);
            }

            static parseWhere(whereClause) {
                // Support: column = value, column > value, column < value, AND/OR
                const conditions = [];
                const parts = whereClause.split(/\s+(AND|OR)\s+/i);

                for (let i = 0; i < parts.length; i += 2) {
                    const part = parts[i].trim();
                    const opMatch = part.match(/^(\w+)\s*(=|!=|<>|>|<|>=|<=|LIKE)\s*(.+)$/i);
                    if (opMatch) {
                        conditions.push({
                            column: opMatch[1],
                            operator: opMatch[2].toUpperCase(),
                            value: this.parseValue(opMatch[3].trim())
                        });
                        if (parts[i + 1]) {
                            conditions.push({ connector: parts[i + 1].toUpperCase() });
                        }
                    }
                }

                return conditions;
            }

            static parseSets(setsClause) {
                const sets = {};
                const parts = setsClause.split(',');
                for (const part of parts) {
                    const match = part.trim().match(/^(\w+)\s*=\s*(.+)$/);
                    if (match) {
                        sets[match[1]] = this.parseValue(match[2].trim());
                    }
                }
                return sets;
            }

            static parseValues(valuesStr) {
                const values = [];
                let current = '';
                let inQuote = false;
                let quoteChar = '';

                for (let i = 0; i < valuesStr.length; i++) {
                    const char = valuesStr[i];
                    if ((char === '"' || char === "'") && !inQuote) {
                        inQuote = true;
                        quoteChar = char;
                    } else if (char === quoteChar && inQuote) {
                        inQuote = false;
                        quoteChar = '';
                    } else if (char === ',' && !inQuote) {
                        values.push(this.parseValue(current.trim()));
                        current = '';
                        continue;
                    }
                    current += char;
                }
                if (current.trim()) {
                    values.push(this.parseValue(current.trim()));
                }

                return values;
            }

            static parseValue(value) {
                // Remove quotes
                if ((value.startsWith('"') && value.endsWith('"')) ||
                    (value.startsWith("'") && value.endsWith("'"))) {
                    return value.slice(1, -1);
                }
                // Check for NULL
                if (value.toUpperCase() === 'NULL') return null;
                // Check for boolean
                if (value.toUpperCase() === 'TRUE') return true;
                if (value.toUpperCase() === 'FALSE') return false;
                // Check for number
                const num = Number(value);
                if (!isNaN(num)) return num;
                return value;
            }
        }

        class SQLExecutor {
            constructor(db) {
                this.db = db;
            }

            execute(sql) {
                const parsed = SQLParser.parse(sql);

                switch (parsed.type) {
                    case 'SELECT':
                        return this.executeSelect(parsed);
                    case 'INSERT':
                        return this.executeInsert(parsed);
                    case 'UPDATE':
                        return this.executeUpdate(parsed);
                    case 'DELETE':
                        return this.executeDelete(parsed);
                    case 'CREATE_TABLE':
                        return this.executeCreateTable(parsed);
                    case 'DROP_TABLE':
                        return this.executeDropTable(parsed);
                    default:
                        throw new Error(`Unknown SQL type: ${parsed.type}`);
                }
            }

            executeSelect(parsed) {
                const table = this.db.getTable(parsed.table);
                if (!table) {
                    return { rows: [], columns: [], count: 0 };
                }

                let rows = table.getAll();

                // Apply WHERE
                if (parsed.where) {
                    rows = rows.filter(row => this.evaluateWhere(row, parsed.where));
                }

                // Apply ORDER BY
                if (parsed.orderBy) {
                    rows.sort((a, b) => {
                        const aVal = a[parsed.orderBy];
                        const bVal = b[parsed.orderBy];
                        const cmp = aVal < bVal ? -1 : aVal > bVal ? 1 : 0;
                        return parsed.orderDir === 'DESC' ? -cmp : cmp;
                    });
                }

                // Apply LIMIT
                if (parsed.limit) {
                    rows = rows.slice(0, parsed.limit);
                }

                // Select columns
                let columns = parsed.columns === '*' ? Array.from(table.schema) : parsed.columns;
                columns = ['id', ...columns.filter(c => c !== 'id')];

                if (parsed.columns !== '*') {
                    rows = rows.map(row => {
                        const selected = {};
                        for (const col of parsed.columns) {
                            selected[col] = row[col];
                        }
                        selected.id = row.id;
                        return selected;
                    });
                }

                return { rows, columns, count: rows.length };
            }

            executeInsert(parsed) {
                let table = this.db.getTable(parsed.table);
                if (!table) {
                    table = this.db.createTable(parsed.table);
                }

                const row = table.insert(parsed.fields);
                this.db.logOperation('INSERT', parsed.table, row.getAll());

                return { inserted: 1, row: row.getAll() };
            }

            executeUpdate(parsed) {
                const table = this.db.getTable(parsed.table);
                if (!table) throw new Error(`Table ${parsed.table} not found`);

                let updated = 0;
                for (const row of table.rows.values()) {
                    if (row.isDeleted()) continue;

                    const rowData = row.getAll();
                    if (!parsed.where || this.evaluateWhere(rowData, parsed.where)) {
                        table.update(row.id, parsed.sets);
                        this.db.logOperation('UPDATE', parsed.table, { id: row.id, ...parsed.sets });
                        updated++;
                    }
                }

                return { updated };
            }

            executeDelete(parsed) {
                const table = this.db.getTable(parsed.table);
                if (!table) throw new Error(`Table ${parsed.table} not found`);

                let deleted = 0;
                for (const row of table.rows.values()) {
                    if (row.isDeleted()) continue;

                    const rowData = row.getAll();
                    if (!parsed.where || this.evaluateWhere(rowData, parsed.where)) {
                        table.delete(row.id);
                        this.db.logOperation('DELETE', parsed.table, { id: row.id });
                        deleted++;
                    }
                }

                return { deleted };
            }

            executeCreateTable(parsed) {
                this.db.createTable(parsed.table);
                return { created: parsed.table };
            }

            executeDropTable(parsed) {
                const dropped = this.db.dropTable(parsed.table);
                return { dropped: dropped ? parsed.table : null };
            }

            evaluateWhere(row, conditions) {
                let result = true;
                let connector = 'AND';

                for (const cond of conditions) {
                    if (cond.connector) {
                        connector = cond.connector;
                        continue;
                    }

                    const rowValue = row[cond.column];
                    const condValue = cond.value;
                    let match = false;

                    switch (cond.operator) {
                        case '=':
                            match = rowValue == condValue;
                            break;
                        case '!=':
                        case '<>':
                            match = rowValue != condValue;
                            break;
                        case '>':
                            match = rowValue > condValue;
                            break;
                        case '<':
                            match = rowValue < condValue;
                            break;
                        case '>=':
                            match = rowValue >= condValue;
                            break;
                        case '<=':
                            match = rowValue <= condValue;
                            break;
                        case 'LIKE':
                            const pattern = condValue.replace(/%/g, '.*').replace(/_/g, '.');
                            match = new RegExp(`^${pattern}$`, 'i').test(String(rowValue));
                            break;
                    }

                    if (connector === 'AND') {
                        result = result && match;
                    } else {
                        result = result || match;
                    }
                }

                return result;
            }
        }

        // ============================================
        // IndexedDB Persistence
        // ============================================

        class IndexedDBPersistence {
            constructor(dbName = 'CRDTDatabase') {
                this.dbName = dbName;
                this.db = null;
            }

            async init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, 1);

                    request.onerror = () => reject(request.error);

                    request.onsuccess = () => {
                        this.db = request.result;
                        resolve();
                    };

                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('databases')) {
                            db.createObjectStore('databases', { keyPath: 'nodeId' });
                        }
                    };
                });
            }

            async save(crdtDb) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['databases'], 'readwrite');
                    const store = transaction.objectStore('databases');
                    const request = store.put(crdtDb.toJSON());

                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            }

            async load(nodeId) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['databases'], 'readonly');
                    const store = transaction.objectStore('databases');
                    const request = store.get(nodeId);

                    request.onsuccess = () => {
                        if (request.result) {
                            resolve(CRDTDatabase.fromJSON(request.result));
                        } else {
                            resolve(null);
                        }
                    };
                    request.onerror = () => reject(request.error);
                });
            }

            async clear() {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['databases'], 'readwrite');
                    const store = transaction.objectStore('databases');
                    const request = store.clear();

                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            }
        }

        // ============================================
        // Device State Management
        // ============================================

        const deviceState = {
            A: {
                db: null,
                executor: null,
                offline: false,
                persistence: null
            },
            B: {
                db: null,
                executor: null,
                offline: false,
                persistence: null
            }
        };

        async function initDevices() {
            // Initialize Device A
            deviceState.A.persistence = new IndexedDBPersistence('CRDTDatabase-A');
            await deviceState.A.persistence.init();

            let dbA = await deviceState.A.persistence.load('DeviceA');
            if (!dbA) {
                dbA = new CRDTDatabase('DeviceA');
            }
            deviceState.A.db = dbA;
            deviceState.A.executor = new SQLExecutor(dbA);

            // Initialize Device B
            deviceState.B.persistence = new IndexedDBPersistence('CRDTDatabase-B');
            await deviceState.B.persistence.init();

            let dbB = await deviceState.B.persistence.load('DeviceB');
            if (!dbB) {
                dbB = new CRDTDatabase('DeviceB');
            }
            deviceState.B.db = dbB;
            deviceState.B.executor = new SQLExecutor(dbB);

            // Initial sync if both have data
            if (!deviceState.A.offline && !deviceState.B.offline) {
                syncDevices();
            }

            refreshViews();
        }

        function toggleOffline(device) {
            const state = deviceState[device];
            state.offline = !state.offline;

            const toggle = document.getElementById(`offlineToggle${device}`);
            toggle.classList.toggle('active', state.offline);

            updateSyncStatus();
            addLog(device, state.offline ? 'Went offline' : 'Came online', 'sync');

            // If coming back online, sync
            if (!state.offline && !deviceState[device === 'A' ? 'B' : 'A'].offline) {
                syncDevices();
            }
        }

        function executeQuery(device) {
            const input = document.getElementById(`queryInput${device}`);
            const sql = input.value.trim();

            if (!sql) return;

            const state = deviceState[device];
            const startTime = performance.now();

            try {
                const result = state.executor.execute(sql);
                const endTime = performance.now();

                document.getElementById('queryTime').textContent = `${(endTime - startTime).toFixed(2)}ms`;

                // Log the operation
                if (result.inserted) {
                    addLog(device, `INSERT: ${JSON.stringify(result.row)}`, 'insert');
                } else if (result.updated !== undefined) {
                    addLog(device, `UPDATE: ${result.updated} row(s)`, 'update');
                } else if (result.deleted !== undefined) {
                    addLog(device, `DELETE: ${result.deleted} row(s)`, 'delete');
                } else if (result.rows) {
                    addLog(device, `SELECT: ${result.count} row(s) returned`, 'sync');
                }

                // Save to IndexedDB
                state.persistence.save(state.db);

                // Sync if both online
                if (!deviceState.A.offline && !deviceState.B.offline) {
                    syncDevices();
                }

                refreshViews();
            } catch (error) {
                addLog(device, `ERROR: ${error.message}`, 'delete');
            }
        }

        function syncDevices() {
            if (deviceState.A.offline || deviceState.B.offline) {
                updateSyncStatus('Devices offline - sync pending');
                return;
            }

            const startTime = performance.now();

            // Bidirectional merge
            deviceState.A.db.merge(deviceState.B.db);
            deviceState.B.db.merge(deviceState.A.db);

            // Clear pending ops
            deviceState.A.db.clearPendingOps();
            deviceState.B.db.clearPendingOps();

            // Save both
            deviceState.A.persistence.save(deviceState.A.db);
            deviceState.B.persistence.save(deviceState.B.db);

            const endTime = performance.now();

            addLog('A', `Synced with Device B (${(endTime - startTime).toFixed(2)}ms)`, 'sync');
            addLog('B', `Synced with Device A (${(endTime - startTime).toFixed(2)}ms)`, 'sync');

            updateSyncStatus('All devices synced');
            refreshViews();
        }

        function refreshViews() {
            refreshTable('A');
            refreshTable('B');
            updateStats();
        }

        function refreshTable(device) {
            const state = deviceState[device];
            const tableEl = document.getElementById(`table${device}`);
            const thead = tableEl.querySelector('thead');
            const tbody = tableEl.querySelector('tbody');

            thead.innerHTML = '';
            tbody.innerHTML = '';

            // Get all tables and their data
            let allData = [];
            let columns = new Set(['id']);

            for (const [tableName, table] of state.db.tables) {
                const rows = table.getAll();
                for (const row of rows) {
                    allData.push({ ...row, _table: tableName });
                    Object.keys(row).forEach(k => columns.add(k));
                }
            }

            if (allData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="100" style="text-align:center;color:var(--text-secondary);padding:2rem;">No data. Run a query to add data.</td></tr>';
                return;
            }

            // Build header
            const headerRow = document.createElement('tr');
            columns = ['id', ...Array.from(columns).filter(c => c !== 'id' && c !== '_table')];
            for (const col of columns) {
                const th = document.createElement('th');
                th.textContent = col;
                headerRow.appendChild(th);
            }
            thead.appendChild(headerRow);

            // Build body
            for (const row of allData) {
                const tr = document.createElement('tr');
                for (const col of columns) {
                    const td = document.createElement('td');
                    td.textContent = row[col] !== undefined ? row[col] : '';
                    tr.appendChild(td);
                }
                tbody.appendChild(tr);
            }
        }

        function updateStats() {
            let countA = 0, countB = 0;

            for (const table of deviceState.A.db.tables.values()) {
                countA += table.count();
            }
            for (const table of deviceState.B.db.tables.values()) {
                countB += table.count();
            }

            document.getElementById('rowCountA').textContent = countA.toLocaleString();
            document.getElementById('rowCountB').textContent = countB.toLocaleString();

            const pendingA = deviceState.A.db.getPendingOps().length;
            const pendingB = deviceState.B.db.getPendingOps().length;
            document.getElementById('pendingOps').textContent = pendingA + pendingB;
        }

        function updateSyncStatus(message) {
            const statusText = document.getElementById('syncStatusText');
            const indicator = document.querySelector('.sync-indicator');

            if (message) {
                statusText.textContent = message;
            }

            const anyOffline = deviceState.A.offline || deviceState.B.offline;
            indicator.style.background = anyOffline ? 'var(--warning)' : 'var(--success)';
        }

        function addLog(device, message, type = '') {
            const log = document.getElementById(`log${device}`);
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.innerHTML = `<span class="timestamp">${new Date().toLocaleTimeString()}</span> ${message}`;
            log.insertBefore(entry, log.firstChild);

            // Keep only last 50 entries
            while (log.children.length > 50) {
                log.removeChild(log.lastChild);
            }
        }

        function loadSampleData(device) {
            const state = deviceState[device];
            const executor = state.executor;

            // Create users table and add sample data
            const queries = [
                "INSERT INTO users (name, age, email, city) VALUES ('Alice', 30, 'alice@example.com', 'New York')",
                "INSERT INTO users (name, age, email, city) VALUES ('Bob', 25, 'bob@example.com', 'San Francisco')",
                "INSERT INTO users (name, age, email, city) VALUES ('Charlie', 35, 'charlie@example.com', 'Chicago')",
                "INSERT INTO users (name, age, email, city) VALUES ('Diana', 28, 'diana@example.com', 'Boston')",
                "INSERT INTO users (name, age, email, city) VALUES ('Eve', 32, 'eve@example.com', 'Seattle')"
            ];

            for (const sql of queries) {
                try {
                    executor.execute(sql);
                } catch (e) {
                    console.error(e);
                }
            }

            addLog(device, 'Loaded 5 sample users', 'insert');
            state.persistence.save(state.db);

            if (!deviceState.A.offline && !deviceState.B.offline) {
                syncDevices();
            }

            refreshViews();
        }

        function clearData(device) {
            const state = deviceState[device];
            state.db = new CRDTDatabase(device === 'A' ? 'DeviceA' : 'DeviceB');
            state.executor = new SQLExecutor(state.db);
            state.persistence.save(state.db);

            addLog(device, 'Cleared all data', 'delete');
            refreshViews();
        }

        async function generate100kRows() {
            const state = deviceState.A;
            const table = state.db.createTable('benchmark');

            addLog('A', 'Generating 100,000 rows...', 'sync');

            const startTime = performance.now();

            // Generate in batches
            const batchSize = 10000;
            for (let batch = 0; batch < 10; batch++) {
                for (let i = 0; i < batchSize; i++) {
                    const idx = batch * batchSize + i;
                    table.insert({
                        name: `User_${idx}`,
                        age: 18 + (idx % 60),
                        email: `user${idx}@example.com`,
                        score: Math.random() * 100,
                        active: idx % 2 === 0
                    });
                }
                // Yield to UI
                await new Promise(r => setTimeout(r, 0));
            }

            const genTime = performance.now() - startTime;
            addLog('A', `Generated 100K rows in ${genTime.toFixed(0)}ms`, 'insert');

            // Test query performance
            const queryStart = performance.now();
            const result = state.executor.execute('SELECT * FROM benchmark WHERE age > 50');
            const queryTime = performance.now() - queryStart;

            document.getElementById('queryTime').textContent = `${queryTime.toFixed(2)}ms`;
            addLog('A', `Query returned ${result.count} rows in ${queryTime.toFixed(2)}ms`, 'sync');

            state.persistence.save(state.db);
            refreshViews();
        }

        function exportData() {
            const data = {
                deviceA: deviceState.A.db.toJSON(),
                deviceB: deviceState.B.db.toJSON(),
                exportedAt: new Date().toISOString()
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `crdt-database-export-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);

            addLog('A', 'Exported database', 'sync');
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);

                    if (data.deviceA) {
                        deviceState.A.db = CRDTDatabase.fromJSON(data.deviceA);
                        deviceState.A.executor = new SQLExecutor(deviceState.A.db);
                        deviceState.A.persistence.save(deviceState.A.db);
                    }

                    if (data.deviceB) {
                        deviceState.B.db = CRDTDatabase.fromJSON(data.deviceB);
                        deviceState.B.executor = new SQLExecutor(deviceState.B.db);
                        deviceState.B.persistence.save(deviceState.B.db);
                    }

                    addLog('A', 'Imported database', 'sync');
                    refreshViews();
                } catch (err) {
                    addLog('A', `Import failed: ${err.message}`, 'delete');
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        // ============================================
        // Test Suite
        // ============================================

        async function runTests() {
            const results = [];
            const modal = document.getElementById('testModal');
            const resultsDiv = document.getElementById('testResults');
            const summaryDiv = document.getElementById('testSummary');

            modal.classList.add('active');
            resultsDiv.innerHTML = '<p>Running tests...</p>';

            await new Promise(r => setTimeout(r, 100));

            // Test 1: Basic CRUD
            results.push(await testBasicCRUD());

            // Test 2: Concurrent inserts merge correctly
            results.push(await testConcurrentInserts());

            // Test 3: Offline edits sync correctly
            results.push(await testOfflineSync());

            // Test 4: LWW conflict resolution
            results.push(await testLWWConflict());

            // Test 5: Delete wins if after update
            results.push(await testDeleteWins());

            // Test 6: SQL parser
            results.push(testSQLParser());

            // Test 7: WHERE clause evaluation
            results.push(testWhereClause());

            // Test 8: 100k query performance
            results.push(await test100kPerformance());

            // Test 9: Vector clock comparison
            results.push(testVectorClock());

            // Test 10: CRDT merge idempotency
            results.push(await testMergeIdempotency());

            // Display results
            const passed = results.filter(r => r.pass).length;
            const failed = results.length - passed;

            resultsDiv.innerHTML = results.map(r => `
                <div class="test-item ${r.pass ? 'pass' : 'fail'}">
                    <span class="status">${r.pass ? '' : ''}</span>
                    <span class="name">${r.name}</span>
                    <span class="message">${r.message || ''}</span>
                </div>
            `).join('');

            summaryDiv.innerHTML = `
                <strong>Results:</strong> ${passed}/${results.length} passed
                ${failed === 0 ? '<br><br><strong style="color:var(--success)">SYNC CONFLICT RESOLUTION WORKS</strong>' : ''}
            `;
        }

        async function testBasicCRUD() {
            try {
                const db = new CRDTDatabase('test');
                const executor = new SQLExecutor(db);

                // Insert
                executor.execute("INSERT INTO test (name, value) VALUES ('foo', 42)");
                let result = executor.execute("SELECT * FROM test");
                if (result.count !== 1) throw new Error('Insert failed');

                // Update
                const id = result.rows[0].id;
                executor.execute(`UPDATE test SET value = 100 WHERE id = '${id}'`);
                result = executor.execute("SELECT * FROM test");
                if (result.rows[0].value !== 100) throw new Error('Update failed');

                // Delete
                executor.execute(`DELETE FROM test WHERE id = '${id}'`);
                result = executor.execute("SELECT * FROM test");
                if (result.count !== 0) throw new Error('Delete failed');

                return { name: 'Basic CRUD', pass: true };
            } catch (e) {
                return { name: 'Basic CRUD', pass: false, message: e.message };
            }
        }

        async function testConcurrentInserts() {
            try {
                const dbA = new CRDTDatabase('DeviceA');
                const dbB = new CRDTDatabase('DeviceB');
                const execA = new SQLExecutor(dbA);
                const execB = new SQLExecutor(dbB);

                // Both devices insert different data
                execA.execute("INSERT INTO users (name) VALUES ('Alice')");
                execB.execute("INSERT INTO users (name) VALUES ('Bob')");

                // Merge
                dbA.merge(dbB);
                dbB.merge(dbA);

                // Both should have both records
                const resultA = execA.execute("SELECT * FROM users");
                const resultB = execB.execute("SELECT * FROM users");

                if (resultA.count !== 2 || resultB.count !== 2) {
                    throw new Error(`Expected 2 rows each, got A:${resultA.count}, B:${resultB.count}`);
                }

                return { name: 'Concurrent Inserts', pass: true };
            } catch (e) {
                return { name: 'Concurrent Inserts', pass: false, message: e.message };
            }
        }

        async function testOfflineSync() {
            try {
                const dbA = new CRDTDatabase('DeviceA');
                const dbB = new CRDTDatabase('DeviceB');
                const execA = new SQLExecutor(dbA);
                const execB = new SQLExecutor(dbB);

                // Initial sync
                execA.execute("INSERT INTO data (key, value) VALUES ('shared', 'initial')");
                dbB.merge(dbA);

                // Device A goes offline and makes changes
                execA.execute("UPDATE data SET value = 'offline_A' WHERE key = 'shared'");

                // Device B makes changes too (concurrent)
                await new Promise(r => setTimeout(r, 10)); // Ensure different timestamp
                execB.execute("UPDATE data SET value = 'offline_B' WHERE key = 'shared'");

                // Sync - LWW should pick B's value (later timestamp)
                dbA.merge(dbB);
                dbB.merge(dbA);

                const resultA = execA.execute("SELECT * FROM data WHERE key = 'shared'");
                const resultB = execB.execute("SELECT * FROM data WHERE key = 'shared'");

                // Both should have the same value after merge
                if (resultA.rows[0].value !== resultB.rows[0].value) {
                    throw new Error('Values diverged after sync');
                }

                return { name: 'Offline Sync', pass: true };
            } catch (e) {
                return { name: 'Offline Sync', pass: false, message: e.message };
            }
        }

        async function testLWWConflict() {
            try {
                const dbA = new CRDTDatabase('DeviceA');
                const dbB = new CRDTDatabase('DeviceB');

                // Create same-id row in both
                const tableA = dbA.createTable('conflict');
                const tableB = dbB.createTable('conflict');

                // A inserts first
                const rowA = tableA.insert({ name: 'Alice' }, Date.now());

                // B gets the row via merge
                tableB.rows.set(rowA.id, CRDTRow.fromJSON(rowA.toJSON()));

                // Both update the same field at different times
                const time1 = Date.now();
                tableA.update(rowA.id, { name: 'Alice Updated A' }, time1);

                await new Promise(r => setTimeout(r, 10));
                const time2 = Date.now();
                tableB.update(rowA.id, { name: 'Alice Updated B' }, time2);

                // Merge
                tableA.merge(tableB);
                tableB.merge(tableA);

                // LWW: later timestamp wins (B)
                const valueA = tableA.rows.get(rowA.id).get('name');
                const valueB = tableB.rows.get(rowA.id).get('name');

                if (valueA !== valueB || valueA !== 'Alice Updated B') {
                    throw new Error(`LWW failed: A=${valueA}, B=${valueB}`);
                }

                return { name: 'LWW Conflict Resolution', pass: true };
            } catch (e) {
                return { name: 'LWW Conflict Resolution', pass: false, message: e.message };
            }
        }

        async function testDeleteWins() {
            try {
                const dbA = new CRDTDatabase('DeviceA');
                const dbB = new CRDTDatabase('DeviceB');
                const execA = new SQLExecutor(dbA);
                const execB = new SQLExecutor(dbB);

                // Insert on A
                execA.execute("INSERT INTO items (name) VALUES ('ToDelete')");

                // Sync
                dbB.merge(dbA);

                // Get the ID
                const result = execA.execute("SELECT * FROM items");
                const id = result.rows[0].id;

                // A updates, B deletes (later)
                execA.execute(`UPDATE items SET name = 'Updated' WHERE id = '${id}'`);
                await new Promise(r => setTimeout(r, 10));
                execB.execute(`DELETE FROM items WHERE id = '${id}'`);

                // Sync
                dbA.merge(dbB);
                dbB.merge(dbA);

                // Item should be deleted (delete was later)
                const finalA = execA.execute("SELECT * FROM items");
                const finalB = execB.execute("SELECT * FROM items");

                if (finalA.count !== 0 || finalB.count !== 0) {
                    throw new Error('Delete should win over earlier update');
                }

                return { name: 'Delete Wins Over Earlier Update', pass: true };
            } catch (e) {
                return { name: 'Delete Wins Over Earlier Update', pass: false, message: e.message };
            }
        }

        function testSQLParser() {
            try {
                // Test SELECT
                let parsed = SQLParser.parse("SELECT name, age FROM users WHERE age > 25 ORDER BY name DESC LIMIT 10");
                if (parsed.type !== 'SELECT' || parsed.table !== 'users') throw new Error('SELECT parse failed');

                // Test INSERT
                parsed = SQLParser.parse("INSERT INTO users (name, age) VALUES ('Test', 30)");
                if (parsed.type !== 'INSERT' || parsed.fields.name !== 'Test') throw new Error('INSERT parse failed');

                // Test UPDATE
                parsed = SQLParser.parse("UPDATE users SET age = 31 WHERE name = 'Test'");
                if (parsed.type !== 'UPDATE' || parsed.sets.age !== 31) throw new Error('UPDATE parse failed');

                // Test DELETE
                parsed = SQLParser.parse("DELETE FROM users WHERE id = 1");
                if (parsed.type !== 'DELETE') throw new Error('DELETE parse failed');

                return { name: 'SQL Parser', pass: true };
            } catch (e) {
                return { name: 'SQL Parser', pass: false, message: e.message };
            }
        }

        function testWhereClause() {
            try {
                const db = new CRDTDatabase('test');
                const executor = new SQLExecutor(db);

                executor.execute("INSERT INTO test (name, age, active) VALUES ('Alice', 30, true)");
                executor.execute("INSERT INTO test (name, age, active) VALUES ('Bob', 25, false)");
                executor.execute("INSERT INTO test (name, age, active) VALUES ('Charlie', 35, true)");

                // Test >
                let result = executor.execute("SELECT * FROM test WHERE age > 28");
                if (result.count !== 2) throw new Error('> operator failed');

                // Test LIKE
                result = executor.execute("SELECT * FROM test WHERE name LIKE 'A%'");
                if (result.count !== 1) throw new Error('LIKE operator failed');

                // Test AND
                result = executor.execute("SELECT * FROM test WHERE age > 28 AND active = true");
                if (result.count !== 2) throw new Error('AND operator failed');

                return { name: 'WHERE Clause', pass: true };
            } catch (e) {
                return { name: 'WHERE Clause', pass: false, message: e.message };
            }
        }

        async function test100kPerformance() {
            try {
                const db = new CRDTDatabase('perf');
                const table = db.createTable('perf');

                // Generate 100k rows
                for (let i = 0; i < 100000; i++) {
                    table.insert({
                        name: `User_${i}`,
                        age: 18 + (i % 60),
                        score: i * 1.5
                    });
                }

                const executor = new SQLExecutor(db);

                // Time query
                const start = performance.now();
                const result = executor.execute("SELECT * FROM perf WHERE age > 50");
                const elapsed = performance.now() - start;

                if (elapsed > 100) {
                    throw new Error(`Query took ${elapsed.toFixed(0)}ms, expected <100ms`);
                }

                return { name: '100K Query <100ms', pass: true, message: `${elapsed.toFixed(0)}ms` };
            } catch (e) {
                return { name: '100K Query <100ms', pass: false, message: e.message };
            }
        }

        function testVectorClock() {
            try {
                const vcA = new VectorClock('A');
                const vcB = new VectorClock('B');

                // A increments
                vcA.increment();
                vcA.increment();

                // B increments
                vcB.increment();

                // A > B (A has more of its own events)
                // But they're concurrent because neither dominates

                // After merge, both should reflect all events
                vcA.merge(vcB);
                vcB.merge(vcA);

                if (vcA.clock['A'] !== 2 || vcA.clock['B'] !== 1) {
                    throw new Error('Merge failed');
                }

                if (vcA.compare(vcB) !== 0) {
                    throw new Error('Should be equal after merge');
                }

                return { name: 'Vector Clock', pass: true };
            } catch (e) {
                return { name: 'Vector Clock', pass: false, message: e.message };
            }
        }

        async function testMergeIdempotency() {
            try {
                const dbA = new CRDTDatabase('DeviceA');
                const dbB = new CRDTDatabase('DeviceB');
                const execA = new SQLExecutor(dbA);

                execA.execute("INSERT INTO idempotent (value) VALUES ('test')");

                // Multiple merges should not duplicate data
                dbB.merge(dbA);
                dbB.merge(dbA);
                dbB.merge(dbA);

                const execB = new SQLExecutor(dbB);
                const result = execB.execute("SELECT * FROM idempotent");

                if (result.count !== 1) {
                    throw new Error(`Expected 1 row, got ${result.count}`);
                }

                return { name: 'Merge Idempotency', pass: true };
            } catch (e) {
                return { name: 'Merge Idempotency', pass: false, message: e.message };
            }
        }

        function closeModal() {
            document.getElementById('testModal').classList.remove('active');
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', initDevices);

        // Handle Enter key in query input
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && e.ctrlKey) {
                const activeElement = document.activeElement;
                if (activeElement.id === 'queryInputA') {
                    executeQuery('A');
                } else if (activeElement.id === 'queryInputB') {
                    executeQuery('B');
                }
            }
        });
    </script>
</body>
</html>