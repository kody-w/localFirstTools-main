<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Architect - Level Editor & Platformer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        #mainMenu {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%);
        }

        .title {
            font-size: 4rem;
            font-weight: bold;
            text-shadow: 4px 4px 0 rgba(0,0,0,0.5);
            margin-bottom: 2rem;
            letter-spacing: 0.1em;
        }

        .subtitle {
            font-size: 1.2rem;
            opacity: 0.8;
            margin-bottom: 3rem;
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .btn {
            padding: 1rem 3rem;
            font-size: 1.2rem;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .btn-success {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        .screen {
            display: none;
            width: 100vw;
            height: 100vh;
        }

        .screen.active {
            display: flex;
        }

        #editorScreen {
            flex-direction: row;
        }

        #playScreen {
            flex-direction: column;
        }

        .palette {
            width: 250px;
            background: rgba(0,0,0,0.7);
            padding: 1rem;
            overflow-y: auto;
            border-right: 2px solid #667eea;
        }

        .palette-category {
            margin-bottom: 1.5rem;
        }

        .palette-title {
            font-size: 1rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
            color: #667eea;
        }

        .palette-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
        }

        .tile-btn {
            width: 60px;
            height: 60px;
            border: 2px solid #555;
            background: #222;
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
        }

        .tile-btn:hover {
            border-color: #667eea;
            transform: scale(1.1);
        }

        .tile-btn.selected {
            border-color: #f5576c;
            box-shadow: 0 0 10px #f5576c;
        }

        .editor-main {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .toolbar {
            background: rgba(0,0,0,0.7);
            padding: 0.75rem;
            display: flex;
            gap: 0.5rem;
            align-items: center;
            border-bottom: 2px solid #667eea;
            flex-wrap: wrap;
        }

        .toolbar-btn {
            padding: 0.5rem 1rem;
            background: #667eea;
            border: none;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }

        .toolbar-btn:hover {
            background: #764ba2;
        }

        .toolbar-input {
            padding: 0.5rem;
            background: #222;
            border: 1px solid #555;
            color: white;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
        }

        #editorCanvas, #gameCanvas {
            background: #87ceeb;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        .canvas-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
        }

        .hud {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background: rgba(0,0,0,0.7);
            padding: 1rem;
            border-radius: 8px;
            font-size: 1.2rem;
            z-index: 100;
        }

        .hud-item {
            margin-bottom: 0.5rem;
        }

        #levelSelect {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 1rem;
            padding: 2rem;
            overflow-y: auto;
        }

        .level-card {
            background: rgba(0,0,0,0.5);
            border: 2px solid #667eea;
            border-radius: 8px;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .level-card:hover {
            transform: scale(1.05);
            border-color: #f5576c;
        }

        .level-card-title {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .level-card-info {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .stars {
            color: #ffd700;
            margin-top: 0.5rem;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0,0,0,0.8);
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: #1a1a2e;
            padding: 2rem;
            border-radius: 8px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            border: 2px solid #667eea;
        }

        .modal-title {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: #667eea;
        }

        textarea {
            width: 100%;
            height: 200px;
            background: #222;
            border: 1px solid #555;
            color: white;
            padding: 0.5rem;
            font-family: 'Courier New', monospace;
            border-radius: 4px;
        }

        .back-btn {
            position: fixed;
            top: 1rem;
            left: 1rem;
            z-index: 200;
        }

        .controls-hint {
            position: absolute;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-size: 0.9rem;
        }

        .complete-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 3rem;
            border-radius: 12px;
            text-align: center;
            border: 3px solid #ffd700;
        }

        .complete-title {
            font-size: 3rem;
            color: #ffd700;
            margin-bottom: 1rem;
        }

        .stats {
            font-size: 1.2rem;
            margin: 1rem 0;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .pulse {
            animation: pulse 0.5s ease-in-out;
        }
    </style>
</head>
<body>
    <!-- Main Menu -->
    <div id="mainMenu" class="screen active">
        <div class="title">THE ARCHITECT</div>
        <div class="subtitle">Build. Play. Create.</div>
        <div class="menu-buttons">
            <button class="btn" onclick="showCampaign()">üéÆ Play Campaign</button>
            <button class="btn btn-secondary" onclick="showCustomLevels()">üìÅ My Levels</button>
            <button class="btn btn-success" onclick="startEditor()">üî® Build New Level</button>
            <button class="btn" onclick="showImport()">üì• Import Level</button>
        </div>
    </div>

    <!-- Level Select -->
    <div id="levelSelectScreen" class="screen">
        <button class="btn back-btn" onclick="showMainMenu()">‚Üê Back</button>
        <div id="levelSelect"></div>
    </div>

    <!-- Editor Screen -->
    <div id="editorScreen" class="screen">
        <div class="palette" id="palette"></div>
        <div class="editor-main">
            <div class="toolbar">
                <input type="text" id="levelName" class="toolbar-input" placeholder="Level Name" value="Untitled Level">
                <select id="bgSelect" class="toolbar-input">
                    <option value="sky">Sky</option>
                    <option value="cave">Cave</option>
                    <option value="night">Night</option>
                    <option value="underwater">Underwater</option>
                    <option value="castle">Castle</option>
                </select>
                <select id="musicSelect" class="toolbar-input">
                    <option value="adventure">Adventure</option>
                    <option value="tense">Tense</option>
                    <option value="peaceful">Peaceful</option>
                    <option value="boss">Boss</option>
                </select>
                <button class="toolbar-btn" onclick="editor.undo()">‚Ü∂ Undo</button>
                <button class="toolbar-btn" onclick="editor.redo()">‚Ü∑ Redo</button>
                <button class="toolbar-btn" onclick="editor.toggleGrid()">Grid</button>
                <button class="toolbar-btn" onclick="editor.zoomIn()">üîç+</button>
                <button class="toolbar-btn" onclick="editor.zoomOut()">üîç-</button>
                <button class="toolbar-btn" onclick="editor.clear()">üóëÔ∏è Clear</button>
                <button class="toolbar-btn" onclick="testLevel()" style="background: #4facfe;">‚ñ∂Ô∏è Test</button>
                <button class="toolbar-btn" onclick="saveLevel()" style="background: #00f2fe;">üíæ Save</button>
                <button class="toolbar-btn" onclick="exportLevel()">üì§ Export</button>
                <button class="toolbar-btn" onclick="showMainMenu()">‚Üê Menu</button>
            </div>
            <div class="canvas-container">
                <canvas id="editorCanvas" width="1600" height="900"></canvas>
            </div>
        </div>
    </div>

    <!-- Play Screen -->
    <div id="playScreen" class="screen">
        <div class="canvas-container">
            <canvas id="gameCanvas" width="1280" height="720"></canvas>
            <div class="hud" id="hud">
                <div class="hud-item">‚ù§Ô∏è Lives: <span id="lives">3</span></div>
                <div class="hud-item">ü™ô Coins: <span id="coins">0</span>/<span id="totalCoins">0</span></div>
                <div class="hud-item">‚è±Ô∏è Time: <span id="time">0:00</span></div>
            </div>
            <div class="controls-hint">
                Arrow Keys / WASD: Move | Space: Jump | ESC: Pause
            </div>
        </div>
    </div>

    <!-- Import Modal -->
    <div id="importModal" class="modal">
        <div class="modal-content">
            <div class="modal-title">Import Level</div>
            <textarea id="importText" placeholder="Paste level JSON here..."></textarea>
            <div style="margin-top: 1rem; display: flex; gap: 1rem;">
                <button class="btn" onclick="doImport()">Import</button>
                <button class="btn btn-secondary" onclick="closeImport()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Export Modal -->
    <div id="exportModal" class="modal">
        <div class="modal-content">
            <div class="modal-title">Export Level</div>
            <textarea id="exportText" readonly></textarea>
            <div style="margin-top: 1rem; display: flex; gap: 1rem;">
                <button class="btn" onclick="copyExport()">üìã Copy</button>
                <button class="btn btn-secondary" onclick="closeExport()">Close</button>
            </div>
        </div>
    </div>

    <script>
        // ============= CONSTANTS =============
        const TILE_SIZE = 32;
        const DEFAULT_WIDTH = 50;
        const DEFAULT_HEIGHT = 15;

        const TILES = {
            EMPTY: 0,
            GROUND: 1,
            BRICK: 2,
            ICE: 3,
            SAND: 4,
            BOUNCY: 5,
            SPIKE: 6,
            LAVA: 7,
            WATER: 8,
            LADDER: 9,
            PLATFORM: 10,
            SWITCH: 11,
            DOOR: 12,
            KEY: 13,
            MOVING_PLATFORM: 14,
            CONVEYOR: 15,
            TELEPORTER: 16,
            CHECKPOINT: 17,
            SPRING: 18,
            WALKER: 19,
            JUMPER: 20,
            FLYER: 21,
            SHOOTER: 22,
            BOSS: 23,
            COIN: 24,
            HEART: 25,
            SPEED: 26,
            DOUBLE_JUMP: 27,
            SHIELD: 28,
            STAR: 29,
            PLAYER_START: 30,
            EXIT: 31
        };

        const TILE_COLORS = {
            [TILES.GROUND]: '#8B4513',
            [TILES.BRICK]: '#CD853F',
            [TILES.ICE]: '#B0E0E6',
            [TILES.SAND]: '#F4A460',
            [TILES.BOUNCY]: '#FFB6C1',
            [TILES.SPIKE]: '#696969',
            [TILES.LAVA]: '#FF4500',
            [TILES.WATER]: '#4682B4',
            [TILES.LADDER]: '#A0522D',
            [TILES.PLATFORM]: '#9370DB',
            [TILES.SWITCH]: '#FFD700',
            [TILES.DOOR]: '#8B0000',
            [TILES.KEY]: '#FFD700',
            [TILES.MOVING_PLATFORM]: '#9370DB',
            [TILES.CONVEYOR]: '#708090',
            [TILES.TELEPORTER]: '#9400D3',
            [TILES.CHECKPOINT]: '#32CD32',
            [TILES.SPRING]: '#FF69B4',
            [TILES.WALKER]: '#FF6347',
            [TILES.JUMPER]: '#FF8C00',
            [TILES.FLYER]: '#DDA0DD',
            [TILES.SHOOTER]: '#DC143C',
            [TILES.BOSS]: '#8B0000',
            [TILES.COIN]: '#FFD700',
            [TILES.HEART]: '#FF1493',
            [TILES.SPEED]: '#00CED1',
            [TILES.DOUBLE_JUMP]: '#7FFF00',
            [TILES.SHIELD]: '#4169E1',
            [TILES.STAR]: '#FFD700',
            [TILES.PLAYER_START]: '#00FF00',
            [TILES.EXIT]: '#FF00FF'
        };

        const TILE_ICONS = {
            [TILES.GROUND]: '‚ñà',
            [TILES.BRICK]: '‚ñ¶',
            [TILES.ICE]: '‚ùÑ',
            [TILES.SAND]: '‚ñí',
            [TILES.BOUNCY]: '‚¨Ü',
            [TILES.SPIKE]: '‚ñ≤',
            [TILES.LAVA]: 'üî•',
            [TILES.WATER]: 'üíß',
            [TILES.LADDER]: '‚â°',
            [TILES.PLATFORM]: '‚îÄ',
            [TILES.SWITCH]: '‚ö°',
            [TILES.DOOR]: 'üö™',
            [TILES.KEY]: 'üîë',
            [TILES.MOVING_PLATFORM]: '‚Üî',
            [TILES.CONVEYOR]: '‚Üí',
            [TILES.TELEPORTER]: '‚äõ',
            [TILES.CHECKPOINT]: 'üö©',
            [TILES.SPRING]: '‚Üü',
            [TILES.WALKER]: 'üëæ',
            [TILES.JUMPER]: 'ü¶ò',
            [TILES.FLYER]: 'ü¶á',
            [TILES.SHOOTER]: 'üî´',
            [TILES.BOSS]: 'üëπ',
            [TILES.COIN]: 'ü™ô',
            [TILES.HEART]: '‚ù§',
            [TILES.SPEED]: '‚ö°',
            [TILES.DOUBLE_JUMP]: '‚áà',
            [TILES.SHIELD]: 'üõ°',
            [TILES.STAR]: '‚≠ê',
            [TILES.PLAYER_START]: 'üéÆ',
            [TILES.EXIT]: 'üèÅ'
        };

        const PALETTE_CATEGORIES = [
            {
                name: 'Terrain',
                tiles: [TILES.GROUND, TILES.BRICK, TILES.ICE, TILES.SAND, TILES.BOUNCY, TILES.SPIKE, TILES.LAVA, TILES.WATER, TILES.LADDER]
            },
            {
                name: 'Platforms',
                tiles: [TILES.PLATFORM, TILES.MOVING_PLATFORM, TILES.CONVEYOR, TILES.SPRING]
            },
            {
                name: 'Interactive',
                tiles: [TILES.SWITCH, TILES.DOOR, TILES.KEY, TILES.TELEPORTER, TILES.CHECKPOINT]
            },
            {
                name: 'Enemies',
                tiles: [TILES.WALKER, TILES.JUMPER, TILES.FLYER, TILES.SHOOTER, TILES.BOSS]
            },
            {
                name: 'Items',
                tiles: [TILES.COIN, TILES.HEART, TILES.SPEED, TILES.DOUBLE_JUMP, TILES.SHIELD, TILES.STAR]
            },
            {
                name: 'Special',
                tiles: [TILES.PLAYER_START, TILES.EXIT]
            }
        ];

        // ============= SAVE/LOAD SYSTEM =============
        class SaveSystem {
            constructor() {
                this.loadProgress();
            }

            loadProgress() {
                const saved = localStorage.getItem('architect_progress');
                if (saved) {
                    this.progress = JSON.parse(saved);
                } else {
                    this.progress = {
                        completedLevels: [],
                        levelStats: {},
                        customLevels: []
                    };
                }
            }

            saveProgress() {
                localStorage.setItem('architect_progress', JSON.stringify(this.progress));
            }

            completeLevel(levelId, stats) {
                if (!this.progress.completedLevels.includes(levelId)) {
                    this.progress.completedLevels.push(levelId);
                }

                if (!this.progress.levelStats[levelId] || stats.time < this.progress.levelStats[levelId].time) {
                    this.progress.levelStats[levelId] = stats;
                }

                this.saveProgress();
            }

            saveCustomLevel(level) {
                const existing = this.progress.customLevels.findIndex(l => l.id === level.id);
                if (existing >= 0) {
                    this.progress.customLevels[existing] = level;
                } else {
                    this.progress.customLevels.push(level);
                }
                this.saveProgress();
            }

            getCustomLevels() {
                return this.progress.customLevels;
            }

            deleteCustomLevel(id) {
                this.progress.customLevels = this.progress.customLevels.filter(l => l.id !== id);
                this.saveProgress();
            }
        }

        const saveSystem = new SaveSystem();

        // ============= LEVEL EDITOR =============
        class LevelEditor {
            constructor() {
                this.canvas = document.getElementById('editorCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.width = DEFAULT_WIDTH;
                this.height = DEFAULT_HEIGHT;
                this.grid = [];
                this.selectedTile = TILES.GROUND;
                this.showGrid = true;
                this.zoom = 1;
                this.cameraX = 0;
                this.cameraY = 0;
                this.isDragging = false;
                this.history = [];
                this.historyIndex = -1;

                this.initGrid();
                this.initPalette();
                this.setupEvents();
                this.render();
            }

            initGrid() {
                this.grid = Array(this.height).fill(null).map(() => Array(this.width).fill(TILES.EMPTY));
                this.saveState();
            }

            initPalette() {
                const palette = document.getElementById('palette');
                palette.innerHTML = '';

                PALETTE_CATEGORIES.forEach(category => {
                    const div = document.createElement('div');
                    div.className = 'palette-category';

                    const title = document.createElement('div');
                    title.className = 'palette-title';
                    title.textContent = category.name;
                    div.appendChild(title);

                    const grid = document.createElement('div');
                    grid.className = 'palette-grid';

                    category.tiles.forEach(tile => {
                        const btn = document.createElement('div');
                        btn.className = 'tile-btn';
                        btn.style.background = TILE_COLORS[tile];
                        btn.textContent = TILE_ICONS[tile];
                        btn.onclick = () => this.selectTile(tile, btn);
                        if (tile === this.selectedTile) btn.classList.add('selected');
                        grid.appendChild(btn);
                    });

                    div.appendChild(grid);
                    palette.appendChild(div);
                });
            }

            selectTile(tile, btn) {
                document.querySelectorAll('.tile-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                this.selectedTile = tile;
            }

            setupEvents() {
                this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
                this.canvas.addEventListener('mouseup', () => this.isDragging = false);
                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());

                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey && e.key === 'z') this.undo();
                    if (e.ctrlKey && e.key === 'y') this.redo();
                });
            }

            getTilePos(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left + this.cameraX) / (TILE_SIZE * this.zoom));
                const y = Math.floor((e.clientY - rect.top + this.cameraY) / (TILE_SIZE * this.zoom));
                return { x, y };
            }

            onMouseDown(e) {
                const pos = this.getTilePos(e);
                if (pos.x >= 0 && pos.x < this.width && pos.y >= 0 && pos.y < this.height) {
                    this.isDragging = true;
                    this.placeTile(pos.x, pos.y, e.button === 2 ? TILES.EMPTY : this.selectedTile);
                }
            }

            onMouseMove(e) {
                if (!this.isDragging) return;
                const pos = this.getTilePos(e);
                if (pos.x >= 0 && pos.x < this.width && pos.y >= 0 && pos.y < this.height) {
                    this.placeTile(pos.x, pos.y, e.button === 2 ? TILES.EMPTY : this.selectedTile);
                }
            }

            placeTile(x, y, tile) {
                if (this.grid[y][x] !== tile) {
                    this.grid[y][x] = tile;
                    this.render();
                    this.saveState();
                }
            }

            saveState() {
                this.history = this.history.slice(0, this.historyIndex + 1);
                this.history.push(JSON.parse(JSON.stringify(this.grid)));
                this.historyIndex++;
                if (this.history.length > 50) {
                    this.history.shift();
                    this.historyIndex--;
                }
            }

            undo() {
                if (this.historyIndex > 0) {
                    this.historyIndex--;
                    this.grid = JSON.parse(JSON.stringify(this.history[this.historyIndex]));
                    this.render();
                }
            }

            redo() {
                if (this.historyIndex < this.history.length - 1) {
                    this.historyIndex++;
                    this.grid = JSON.parse(JSON.stringify(this.history[this.historyIndex]));
                    this.render();
                }
            }

            toggleGrid() {
                this.showGrid = !this.showGrid;
                this.render();
            }

            zoomIn() {
                this.zoom = Math.min(2, this.zoom + 0.25);
                this.render();
            }

            zoomOut() {
                this.zoom = Math.max(0.5, this.zoom - 0.25);
                this.render();
            }

            clear() {
                if (confirm('Clear entire level?')) {
                    this.initGrid();
                    this.render();
                }
            }

            render() {
                this.ctx.fillStyle = '#87ceeb';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const tile = this.grid[y][x];
                        if (tile === TILES.EMPTY) continue;

                        const screenX = x * TILE_SIZE * this.zoom - this.cameraX;
                        const screenY = y * TILE_SIZE * this.zoom - this.cameraY;
                        const size = TILE_SIZE * this.zoom;

                        this.ctx.fillStyle = TILE_COLORS[tile];
                        this.ctx.fillRect(screenX, screenY, size, size);

                        this.ctx.fillStyle = '#000';
                        this.ctx.font = `${size * 0.6}px Arial`;
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'middle';
                        this.ctx.fillText(TILE_ICONS[tile], screenX + size / 2, screenY + size / 2);
                    }
                }

                if (this.showGrid) {
                    this.ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                    this.ctx.lineWidth = 1;
                    for (let x = 0; x <= this.width; x++) {
                        const screenX = x * TILE_SIZE * this.zoom - this.cameraX;
                        this.ctx.beginPath();
                        this.ctx.moveTo(screenX, 0);
                        this.ctx.lineTo(screenX, this.height * TILE_SIZE * this.zoom);
                        this.ctx.stroke();
                    }
                    for (let y = 0; y <= this.height; y++) {
                        const screenY = y * TILE_SIZE * this.zoom - this.cameraY;
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, screenY);
                        this.ctx.lineTo(this.width * TILE_SIZE * this.zoom, screenY);
                        this.ctx.stroke();
                    }
                }
            }

            getLevel() {
                return {
                    id: Date.now().toString(),
                    name: document.getElementById('levelName').value,
                    width: this.width,
                    height: this.height,
                    grid: this.grid,
                    background: document.getElementById('bgSelect').value,
                    music: document.getElementById('musicSelect').value
                };
            }

            loadLevel(level) {
                this.width = level.width;
                this.height = level.height;
                this.grid = JSON.parse(JSON.stringify(level.grid));
                document.getElementById('levelName').value = level.name;
                document.getElementById('bgSelect').value = level.background;
                document.getElementById('musicSelect').value = level.music;
                this.history = [JSON.parse(JSON.stringify(this.grid))];
                this.historyIndex = 0;
                this.render();
            }
        }

        let editor = null;

        // ============= GAME ENGINE =============
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.level = null;
                this.player = null;
                this.entities = [];
                this.particles = [];
                this.camera = { x: 0, y: 0 };
                this.keys = {};
                this.time = 0;
                this.paused = false;
                this.gameOver = false;
                this.levelComplete = false;

                this.setupInput();
            }

            setupInput() {
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    if (e.key === 'Escape') this.togglePause();
                    if (e.key === ' ') e.preventDefault();
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });
            }

            loadLevel(level) {
                this.level = level;
                this.entities = [];
                this.particles = [];
                this.time = 0;
                this.gameOver = false;
                this.levelComplete = false;

                let startX = 2, startY = 12;
                let totalCoins = 0;

                for (let y = 0; y < level.height; y++) {
                    for (let x = 0; x < level.width; x++) {
                        const tile = level.grid[y][x];

                        if (tile === TILES.PLAYER_START) {
                            startX = x;
                            startY = y;
                        } else if (tile === TILES.COIN) {
                            totalCoins++;
                        } else if (tile === TILES.WALKER) {
                            this.entities.push(new Walker(x * TILE_SIZE, y * TILE_SIZE));
                        } else if (tile === TILES.JUMPER) {
                            this.entities.push(new Jumper(x * TILE_SIZE, y * TILE_SIZE));
                        } else if (tile === TILES.FLYER) {
                            this.entities.push(new Flyer(x * TILE_SIZE, y * TILE_SIZE));
                        } else if (tile === TILES.SHOOTER) {
                            this.entities.push(new Shooter(x * TILE_SIZE, y * TILE_SIZE));
                        } else if (tile === TILES.BOSS) {
                            this.entities.push(new Boss(x * TILE_SIZE, y * TILE_SIZE));
                        }
                    }
                }

                this.player = new Player(startX * TILE_SIZE, startY * TILE_SIZE);

                document.getElementById('lives').textContent = this.player.lives;
                document.getElementById('coins').textContent = 0;
                document.getElementById('totalCoins').textContent = totalCoins;
                document.getElementById('time').textContent = '0:00';
            }

            start() {
                this.running = true;
                this.lastTime = performance.now();
                this.gameLoop();
            }

            stop() {
                this.running = false;
            }

            togglePause() {
                this.paused = !this.paused;
            }

            gameLoop() {
                if (!this.running) return;

                const now = performance.now();
                const dt = Math.min((now - this.lastTime) / 1000, 0.1);
                this.lastTime = now;

                if (!this.paused && !this.gameOver && !this.levelComplete) {
                    this.update(dt);
                }

                this.render();
                requestAnimationFrame(() => this.gameLoop());
            }

            update(dt) {
                this.time += dt;
                const minutes = Math.floor(this.time / 60);
                const seconds = Math.floor(this.time % 60);
                document.getElementById('time').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;

                this.player.update(dt, this);

                this.entities = this.entities.filter(e => e.alive);
                this.entities.forEach(e => e.update(dt, this));

                this.particles = this.particles.filter(p => p.life > 0);
                this.particles.forEach(p => p.update(dt));

                this.updateCamera();

                if (this.player.checkExit(this)) {
                    this.completeLevel();
                }

                if (this.player.lives <= 0) {
                    this.gameOver = true;
                    setTimeout(() => showMainMenu(), 2000);
                }
            }

            updateCamera() {
                const targetX = this.player.x - this.canvas.width / 2;
                const targetY = this.player.y - this.canvas.height / 2;

                this.camera.x += (targetX - this.camera.x) * 0.1;
                this.camera.y += (targetY - this.camera.y) * 0.1;

                this.camera.x = Math.max(0, Math.min(this.camera.x, this.level.width * TILE_SIZE - this.canvas.width));
                this.camera.y = Math.max(0, Math.min(this.camera.y, this.level.height * TILE_SIZE - this.canvas.height));
            }

            render() {
                const bg = {
                    sky: '#87ceeb',
                    cave: '#1a1a1a',
                    night: '#191970',
                    underwater: '#006994',
                    castle: '#4a4a4a'
                };

                this.ctx.fillStyle = bg[this.level.background] || '#87ceeb';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                this.ctx.save();
                this.ctx.translate(-this.camera.x, -this.camera.y);

                for (let y = 0; y < this.level.height; y++) {
                    for (let x = 0; x < this.level.width; x++) {
                        const tile = this.level.grid[y][x];
                        if (tile === TILES.EMPTY || tile === TILES.PLAYER_START) continue;

                        const px = x * TILE_SIZE;
                        const py = y * TILE_SIZE;

                        this.ctx.fillStyle = TILE_COLORS[tile];
                        this.ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);

                        if ([TILES.COIN, TILES.HEART, TILES.SPEED, TILES.DOUBLE_JUMP, TILES.SHIELD, TILES.STAR, TILES.EXIT, TILES.KEY, TILES.CHECKPOINT].includes(tile)) {
                            this.ctx.fillStyle = '#000';
                            this.ctx.font = '20px Arial';
                            this.ctx.textAlign = 'center';
                            this.ctx.textBaseline = 'middle';
                            this.ctx.fillText(TILE_ICONS[tile], px + TILE_SIZE / 2, py + TILE_SIZE / 2);
                        }
                    }
                }

                this.entities.forEach(e => e.render(this.ctx));
                this.particles.forEach(p => p.render(this.ctx));
                this.player.render(this.ctx);

                this.ctx.restore();

                if (this.paused) {
                    this.ctx.fillStyle = 'rgba(0,0,0,0.7)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = '48px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('PAUSED', this.canvas.width / 2, this.canvas.height / 2);
                }

                if (this.gameOver) {
                    this.ctx.fillStyle = 'rgba(0,0,0,0.7)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    this.ctx.fillStyle = '#f00';
                    this.ctx.font = '48px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('GAME OVER', this.canvas.width / 2, this.canvas.height / 2);
                }
            }

            completeLevel() {
                this.levelComplete = true;

                const stats = {
                    time: Math.floor(this.time),
                    coins: this.player.coins,
                    deaths: this.player.deaths
                };

                if (this.level.id) {
                    saveSystem.completeLevel(this.level.id, stats);
                }

                const complete = document.createElement('div');
                complete.className = 'complete-screen';
                complete.innerHTML = `
                    <div class="complete-title">LEVEL COMPLETE!</div>
                    <div class="stats">
                        Time: ${Math.floor(stats.time / 60)}:${(stats.time % 60).toString().padStart(2, '0')}<br>
                        Coins: ${stats.coins}/${document.getElementById('totalCoins').textContent}<br>
                        Deaths: ${stats.deaths}
                    </div>
                    <button class="btn" onclick="showMainMenu()">Continue</button>
                `;
                document.getElementById('playScreen').querySelector('.canvas-container').appendChild(complete);
            }

            getTileAt(x, y) {
                const tx = Math.floor(x / TILE_SIZE);
                const ty = Math.floor(y / TILE_SIZE);
                if (tx < 0 || tx >= this.level.width || ty < 0 || ty >= this.level.height) return TILES.EMPTY;
                return this.level.grid[ty][tx];
            }

            setTileAt(x, y, tile) {
                const tx = Math.floor(x / TILE_SIZE);
                const ty = Math.floor(y / TILE_SIZE);
                if (tx >= 0 && tx < this.level.width && ty >= 0 && ty < this.level.height) {
                    this.level.grid[ty][tx] = tile;
                }
            }

            isSolid(x, y) {
                const tile = this.getTileAt(x, y);
                return [TILES.GROUND, TILES.BRICK, TILES.ICE, TILES.SAND, TILES.DOOR].includes(tile);
            }

            addParticle(x, y, color) {
                this.particles.push(new Particle(x, y, color));
            }
        }

        let game = null;

        // ============= PLAYER =============
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.width = 24;
                this.height = 30;
                this.onGround = false;
                this.lives = 3;
                this.coins = 0;
                this.deaths = 0;
                this.hasDoubleJump = false;
                this.jumpsLeft = 1;
                this.hasShield = false;
                this.invincible = false;
                this.speedBoost = 0;
                this.checkpointX = x;
                this.checkpointY = y;
            }

            update(dt, game) {
                const speed = 200 + this.speedBoost;
                const jumpPower = 400;

                if (game.keys['arrowleft'] || game.keys['a']) {
                    this.vx = -speed;
                } else if (game.keys['arrowright'] || game.keys['d']) {
                    this.vx = speed;
                } else {
                    this.vx *= 0.8;
                }

                if ((game.keys[' '] || game.keys['arrowup'] || game.keys['w']) && this.jumpsLeft > 0) {
                    this.vy = -jumpPower;
                    this.jumpsLeft--;
                    game.keys[' '] = false;
                }

                this.vy += 1200 * dt;
                this.vy = Math.min(this.vy, 600);

                this.x += this.vx * dt;
                this.y += this.vy * dt;

                this.handleCollisions(game);

                if (this.speedBoost > 0) this.speedBoost -= dt * 100;

                if (this.y > game.level.height * TILE_SIZE) {
                    this.die(game);
                }
            }

            handleCollisions(game) {
                this.onGround = false;

                const corners = [
                    { x: this.x, y: this.y },
                    { x: this.x + this.width, y: this.y },
                    { x: this.x, y: this.y + this.height },
                    { x: this.x + this.width, y: this.y + this.height }
                ];

                corners.forEach(corner => {
                    const tile = game.getTileAt(corner.x, corner.y);

                    if (tile === TILES.COIN) {
                        this.coins++;
                        document.getElementById('coins').textContent = this.coins;
                        game.setTileAt(corner.x, corner.y, TILES.EMPTY);
                        game.addParticle(corner.x, corner.y, '#ffd700');
                    } else if (tile === TILES.HEART) {
                        this.lives = Math.min(3, this.lives + 1);
                        document.getElementById('lives').textContent = this.lives;
                        game.setTileAt(corner.x, corner.y, TILES.EMPTY);
                    } else if (tile === TILES.SPEED) {
                        this.speedBoost = 300;
                        game.setTileAt(corner.x, corner.y, TILES.EMPTY);
                    } else if (tile === TILES.DOUBLE_JUMP) {
                        this.hasDoubleJump = true;
                        game.setTileAt(corner.x, corner.y, TILES.EMPTY);
                    } else if (tile === TILES.SHIELD) {
                        this.hasShield = true;
                        game.setTileAt(corner.x, corner.y, TILES.EMPTY);
                    } else if (tile === TILES.STAR) {
                        this.invincible = true;
                        setTimeout(() => this.invincible = false, 5000);
                        game.setTileAt(corner.x, corner.y, TILES.EMPTY);
                    } else if (tile === TILES.CHECKPOINT) {
                        this.checkpointX = corner.x;
                        this.checkpointY = corner.y;
                    } else if ([TILES.SPIKE, TILES.LAVA].includes(tile)) {
                        if (!this.invincible) this.die(game);
                    } else if (tile === TILES.BOUNCY) {
                        this.vy = -500;
                    } else if (tile === TILES.SPRING) {
                        this.vy = -600;
                    }
                });

                if (this.vy > 0) {
                    const bottomLeft = game.getTileAt(this.x, this.y + this.height);
                    const bottomRight = game.getTileAt(this.x + this.width, this.y + this.height);

                    if (game.isSolid(this.x, this.y + this.height) || game.isSolid(this.x + this.width, this.y + this.height)) {
                        this.y = Math.floor((this.y + this.height) / TILE_SIZE) * TILE_SIZE - this.height;
                        this.vy = 0;
                        this.onGround = true;
                        this.jumpsLeft = this.hasDoubleJump ? 2 : 1;
                    }
                }

                if (this.vy < 0) {
                    if (game.isSolid(this.x, this.y) || game.isSolid(this.x + this.width, this.y)) {
                        this.y = Math.ceil(this.y / TILE_SIZE) * TILE_SIZE;
                        this.vy = 0;
                    }
                }

                if (this.vx > 0) {
                    if (game.isSolid(this.x + this.width, this.y) || game.isSolid(this.x + this.width, this.y + this.height - 1)) {
                        this.x = Math.floor((this.x + this.width) / TILE_SIZE) * TILE_SIZE - this.width;
                        this.vx = 0;
                    }
                }

                if (this.vx < 0) {
                    if (game.isSolid(this.x, this.y) || game.isSolid(this.x, this.y + this.height - 1)) {
                        this.x = Math.ceil(this.x / TILE_SIZE) * TILE_SIZE;
                        this.vx = 0;
                    }
                }
            }

            die(game) {
                if (this.hasShield) {
                    this.hasShield = false;
                    return;
                }

                this.lives--;
                this.deaths++;
                document.getElementById('lives').textContent = this.lives;

                if (this.lives > 0) {
                    this.x = this.checkpointX;
                    this.y = this.checkpointY;
                    this.vx = 0;
                    this.vy = 0;
                }
            }

            checkExit(game) {
                const tile = game.getTileAt(this.x + this.width / 2, this.y + this.height / 2);
                return tile === TILES.EXIT;
            }

            render(ctx) {
                ctx.fillStyle = this.invincible ? '#ffd700' : (this.hasShield ? '#4169e1' : '#00ff00');
                ctx.fillRect(this.x, this.y, this.width, this.height);

                ctx.fillStyle = '#000';
                ctx.fillRect(this.x + 5, this.y + 5, 4, 4);
                ctx.fillRect(this.x + 15, this.y + 5, 4, 4);

                ctx.fillRect(this.x + 8, this.y + 20, 8, 3);
            }
        }

        // ============= ENTITIES =============
        class Walker {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = 50;
                this.width = 24;
                this.height = 24;
                this.alive = true;
            }

            update(dt, game) {
                this.x += this.vx * dt;

                const nextTile = game.getTileAt(this.x + (this.vx > 0 ? this.width : 0), this.y + this.height + 5);
                const wallTile = game.getTileAt(this.x + (this.vx > 0 ? this.width : 0), this.y);

                if (nextTile === TILES.EMPTY || game.isSolid(wallTile)) {
                    this.vx *= -1;
                }

                if (this.checkPlayerCollision(game.player, game)) {
                    if (game.player.vy > 0 && game.player.y < this.y) {
                        this.alive = false;
                        game.player.vy = -300;
                    } else if (!game.player.invincible) {
                        game.player.die(game);
                    }
                }
            }

            checkPlayerCollision(player, game) {
                return this.x < player.x + player.width &&
                       this.x + this.width > player.x &&
                       this.y < player.y + player.height &&
                       this.y + this.height > player.y;
            }

            render(ctx) {
                ctx.fillStyle = '#ff6347';
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.fillStyle = '#000';
                ctx.fillRect(this.x + 5, this.y + 5, 4, 4);
                ctx.fillRect(this.x + 15, this.y + 5, 4, 4);
            }
        }

        class Jumper {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vy = 0;
                this.width = 24;
                this.height = 24;
                this.alive = true;
                this.jumpTimer = 0;
            }

            update(dt, game) {
                this.jumpTimer += dt;

                if (this.jumpTimer > 2 && this.vy === 0) {
                    this.vy = -400;
                    this.jumpTimer = 0;
                }

                this.vy += 1200 * dt;
                this.y += this.vy * dt;

                if (game.isSolid(this.x, this.y + this.height)) {
                    this.y = Math.floor((this.y + this.height) / TILE_SIZE) * TILE_SIZE - this.height;
                    this.vy = 0;
                }

                if (this.checkPlayerCollision(game.player, game)) {
                    if (game.player.vy > 0 && game.player.y < this.y) {
                        this.alive = false;
                        game.player.vy = -300;
                    } else if (!game.player.invincible) {
                        game.player.die(game);
                    }
                }
            }

            checkPlayerCollision(player, game) {
                return this.x < player.x + player.width &&
                       this.x + this.width > player.x &&
                       this.y < player.y + player.height &&
                       this.y + this.height > player.y;
            }

            render(ctx) {
                ctx.fillStyle = '#ff8c00';
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.fillStyle = '#000';
                ctx.fillRect(this.x + 5, this.y + 5, 4, 4);
                ctx.fillRect(this.x + 15, this.y + 5, 4, 4);
            }
        }

        class Flyer {
            constructor(x, y) {
                this.startX = x;
                this.x = x;
                this.y = y;
                this.width = 24;
                this.height = 24;
                this.alive = true;
                this.time = 0;
            }

            update(dt, game) {
                this.time += dt;
                this.x = this.startX + Math.sin(this.time * 2) * 100;
                this.y += Math.sin(this.time * 3) * 2;

                if (this.checkPlayerCollision(game.player, game)) {
                    if (!game.player.invincible) {
                        game.player.die(game);
                    }
                }
            }

            checkPlayerCollision(player, game) {
                return this.x < player.x + player.width &&
                       this.x + this.width > player.x &&
                       this.y < player.y + player.height &&
                       this.y + this.height > player.y;
            }

            render(ctx) {
                ctx.fillStyle = '#dda0dd';
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.fillStyle = '#000';
                ctx.fillRect(this.x + 5, this.y + 5, 4, 4);
                ctx.fillRect(this.x + 15, this.y + 5, 4, 4);
            }
        }

        class Shooter {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 24;
                this.height = 24;
                this.alive = true;
                this.shootTimer = 0;
            }

            update(dt, game) {
                this.shootTimer += dt;

                if (this.shootTimer > 3) {
                    this.shootTimer = 0;
                }

                if (this.checkPlayerCollision(game.player, game)) {
                    if (!game.player.invincible) {
                        game.player.die(game);
                    }
                }
            }

            checkPlayerCollision(player, game) {
                return this.x < player.x + player.width &&
                       this.x + this.width > player.x &&
                       this.y < player.y + player.height &&
                       this.y + this.height > player.y;
            }

            render(ctx) {
                ctx.fillStyle = '#dc143c';
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.fillStyle = '#000';
                ctx.fillRect(this.x + 5, this.y + 5, 4, 4);
                ctx.fillRect(this.x + 15, this.y + 5, 4, 4);
            }
        }

        class Boss {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 48;
                this.height = 48;
                this.alive = true;
                this.health = 3;
            }

            update(dt, game) {
                if (this.checkPlayerCollision(game.player, game)) {
                    if (game.player.vy > 0 && game.player.y < this.y) {
                        this.health--;
                        game.player.vy = -400;
                        if (this.health <= 0) {
                            this.alive = false;
                        }
                    } else if (!game.player.invincible) {
                        game.player.die(game);
                    }
                }
            }

            checkPlayerCollision(player, game) {
                return this.x < player.x + player.width &&
                       this.x + this.width > player.x &&
                       this.y < player.y + player.height &&
                       this.y + this.height > player.y;
            }

            render(ctx) {
                ctx.fillStyle = '#8b0000';
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.fillStyle = '#fff';
                ctx.font = '16px Arial';
                ctx.fillText(`HP:${this.health}`, this.x + 10, this.y + 30);
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 100;
                this.vy = (Math.random() - 0.5) * 100 - 50;
                this.life = 1;
                this.color = color;
            }

            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.vy += 200 * dt;
                this.life -= dt * 2;
            }

            render(ctx) {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, 4, 4);
                ctx.globalAlpha = 1;
            }
        }

        // ============= CAMPAIGN LEVELS =============
        const CAMPAIGN_LEVELS = [
            {
                id: 'w1-1',
                name: 'First Steps',
                world: 1,
                width: 30,
                height: 15,
                background: 'sky',
                music: 'adventure',
                grid: (() => {
                    const grid = Array(15).fill(null).map(() => Array(30).fill(TILES.EMPTY));
                    for (let x = 0; x < 30; x++) grid[14][x] = TILES.GROUND;
                    grid[13][2] = TILES.PLAYER_START;
                    for (let x = 10; x < 15; x++) grid[13][x] = TILES.COIN;
                    grid[12][20] = TILES.WALKER;
                    grid[13][28] = TILES.EXIT;
                    return grid;
                })()
            },
            {
                id: 'w1-2',
                name: 'Jump Training',
                world: 1,
                width: 35,
                height: 15,
                background: 'sky',
                music: 'adventure',
                grid: (() => {
                    const grid = Array(15).fill(null).map(() => Array(35).fill(TILES.EMPTY));
                    for (let x = 0; x < 35; x++) grid[14][x] = TILES.GROUND;
                    grid[13][2] = TILES.PLAYER_START;
                    for (let x = 5; x < 10; x++) grid[11][x] = TILES.BRICK;
                    grid[10][7] = TILES.COIN;
                    for (let x = 15; x < 18; x++) grid[13][x] = TILES.COIN;
                    grid[12][25] = TILES.JUMPER;
                    grid[13][33] = TILES.EXIT;
                    return grid;
                })()
            },
            {
                id: 'w1-3',
                name: 'Coin Collection',
                world: 1,
                width: 40,
                height: 15,
                background: 'sky',
                music: 'adventure',
                grid: (() => {
                    const grid = Array(15).fill(null).map(() => Array(40).fill(TILES.EMPTY));
                    for (let x = 0; x < 40; x++) grid[14][x] = TILES.GROUND;
                    grid[13][2] = TILES.PLAYER_START;
                    for (let x = 8; x < 15; x++) grid[10][x] = TILES.BRICK;
                    for (let x = 9; x < 14; x++) grid[9][x] = TILES.COIN;
                    for (let x = 20; x < 28; x++) grid[12][x] = TILES.PLATFORM;
                    grid[11][24] = TILES.COIN;
                    grid[12][30] = TILES.WALKER;
                    grid[13][38] = TILES.EXIT;
                    return grid;
                })()
            },
            {
                id: 'w1-4',
                name: 'Danger Zone',
                world: 1,
                width: 45,
                height: 15,
                background: 'sky',
                music: 'tense',
                grid: (() => {
                    const grid = Array(15).fill(null).map(() => Array(45).fill(TILES.EMPTY));
                    for (let x = 0; x < 45; x++) grid[14][x] = TILES.GROUND;
                    grid[13][2] = TILES.PLAYER_START;
                    for (let x = 10; x < 14; x++) grid[13][x] = TILES.SPIKE;
                    grid[12][20] = TILES.WALKER;
                    grid[12][25] = TILES.WALKER;
                    grid[13][30] = TILES.HEART;
                    for (let x = 35; x < 40; x++) grid[11][x] = TILES.BRICK;
                    grid[10][37] = TILES.COIN;
                    grid[13][43] = TILES.EXIT;
                    return grid;
                })()
            },
            {
                id: 'w1-5',
                name: 'Boss Arena',
                world: 1,
                width: 50,
                height: 15,
                background: 'sky',
                music: 'boss',
                grid: (() => {
                    const grid = Array(15).fill(null).map(() => Array(50).fill(TILES.EMPTY));
                    for (let x = 0; x < 50; x++) grid[14][x] = TILES.GROUND;
                    grid[13][2] = TILES.PLAYER_START;
                    grid[13][10] = TILES.SHIELD;
                    for (let x = 20; x < 30; x++) grid[10][x] = TILES.PLATFORM;
                    grid[12][40] = TILES.BOSS;
                    grid[13][48] = TILES.EXIT;
                    return grid;
                })()
            },
            {
                id: 'w2-1',
                name: 'Cave Entry',
                world: 2,
                width: 40,
                height: 15,
                background: 'cave',
                music: 'tense',
                grid: (() => {
                    const grid = Array(15).fill(null).map(() => Array(40).fill(TILES.EMPTY));
                    for (let x = 0; x < 40; x++) grid[14][x] = TILES.GROUND;
                    grid[13][2] = TILES.PLAYER_START;
                    for (let x = 10; x < 15; x++) grid[11][x] = TILES.BRICK;
                    grid[13][20] = TILES.CHECKPOINT;
                    grid[12][25] = TILES.WALKER;
                    for (let x = 30; x < 35; x++) grid[13][x] = TILES.COIN;
                    grid[13][38] = TILES.EXIT;
                    return grid;
                })()
            },
            {
                id: 'w2-2',
                name: 'Switch Puzzle',
                world: 2,
                width: 45,
                height: 15,
                background: 'cave',
                music: 'tense',
                grid: (() => {
                    const grid = Array(15).fill(null).map(() => Array(45).fill(TILES.EMPTY));
                    for (let x = 0; x < 45; x++) grid[14][x] = TILES.GROUND;
                    grid[13][2] = TILES.PLAYER_START;
                    grid[13][15] = TILES.SWITCH;
                    for (let y = 10; y < 14; y++) grid[y][25] = TILES.DOOR;
                    grid[13][30] = TILES.COIN;
                    grid[13][43] = TILES.EXIT;
                    return grid;
                })()
            },
            {
                id: 'w2-3',
                name: 'Key Hunt',
                world: 2,
                width: 50,
                height: 15,
                background: 'cave',
                music: 'adventure',
                grid: (() => {
                    const grid = Array(15).fill(null).map(() => Array(50).fill(TILES.EMPTY));
                    for (let x = 0; x < 50; x++) grid[14][x] = TILES.GROUND;
                    grid[13][2] = TILES.PLAYER_START;
                    for (let x = 10; x < 20; x++) grid[10][x] = TILES.BRICK;
                    grid[9][15] = TILES.KEY;
                    for (let y = 10; y < 14; y++) grid[y][30] = TILES.DOOR;
                    grid[12][35] = TILES.WALKER;
                    grid[13][48] = TILES.EXIT;
                    return grid;
                })()
            },
            {
                id: 'w2-4',
                name: 'Dark Path',
                world: 2,
                width: 55,
                height: 15,
                background: 'cave',
                music: 'tense',
                grid: (() => {
                    const grid = Array(15).fill(null).map(() => Array(55).fill(TILES.EMPTY));
                    for (let x = 0; x < 55; x++) grid[14][x] = TILES.GROUND;
                    grid[13][2] = TILES.PLAYER_START;
                    for (let x = 10; x < 15; x++) grid[13][x] = TILES.SPIKE;
                    grid[12][20] = TILES.JUMPER;
                    grid[13][25] = TILES.CHECKPOINT;
                    for (let x = 30; x < 35; x++) grid[13][x] = TILES.LAVA;
                    grid[13][40] = TILES.HEART;
                    grid[12][45] = TILES.WALKER;
                    grid[13][53] = TILES.EXIT;
                    return grid;
                })()
            },
            {
                id: 'w2-5',
                name: 'Cave Boss',
                world: 2,
                width: 50,
                height: 15,
                background: 'cave',
                music: 'boss',
                grid: (() => {
                    const grid = Array(15).fill(null).map(() => Array(50).fill(TILES.EMPTY));
                    for (let x = 0; x < 50; x++) grid[14][x] = TILES.GROUND;
                    grid[13][2] = TILES.PLAYER_START;
                    grid[13][10] = TILES.DOUBLE_JUMP;
                    for (let x = 20; x < 30; x++) grid[11][x] = TILES.PLATFORM;
                    grid[12][40] = TILES.BOSS;
                    grid[13][48] = TILES.EXIT;
                    return grid;
                })()
            },
            {
                id: 'w3-1',
                name: 'Sky High',
                world: 3,
                width: 45,
                height: 20,
                background: 'sky',
                music: 'peaceful',
                grid: (() => {
                    const grid = Array(20).fill(null).map(() => Array(45).fill(TILES.EMPTY));
                    for (let x = 0; x < 45; x++) grid[19][x] = TILES.GROUND;
                    grid[18][2] = TILES.PLAYER_START;
                    for (let x = 10; x < 15; x++) grid[15][x] = TILES.PLATFORM;
                    for (let x = 20; x < 25; x++) grid[12][x] = TILES.PLATFORM;
                    grid[11][22] = TILES.COIN;
                    grid[17][30] = TILES.FLYER;
                    grid[18][43] = TILES.EXIT;
                    return grid;
                })()
            },
            {
                id: 'w3-2',
                name: 'Cloud Hopping',
                world: 3,
                width: 50,
                height: 20,
                background: 'sky',
                music: 'peaceful',
                grid: (() => {
                    const grid = Array(20).fill(null).map(() => Array(50).fill(TILES.EMPTY));
                    for (let x = 0; x < 50; x++) grid[19][x] = TILES.GROUND;
                    grid[18][2] = TILES.PLAYER_START;
                    for (let x = 8; x < 12; x++) grid[16][x] = TILES.PLATFORM;
                    for (let x = 15; x < 19; x++) grid[13][x] = TILES.PLATFORM;
                    for (let x = 22; x < 26; x++) grid[10][x] = TILES.PLATFORM;
                    grid[9][24] = TILES.COIN;
                    grid[18][35] = TILES.BOUNCY;
                    grid[18][48] = TILES.EXIT;
                    return grid;
                })()
            },
            {
                id: 'w3-3',
                name: 'Moving Platforms',
                world: 3,
                width: 55,
                height: 20,
                background: 'sky',
                music: 'adventure',
                grid: (() => {
                    const grid = Array(20).fill(null).map(() => Array(55).fill(TILES.EMPTY));
                    for (let x = 0; x < 55; x++) grid[19][x] = TILES.GROUND;
                    grid[18][2] = TILES.PLAYER_START;
                    for (let x = 10; x < 14; x++) grid[15][x] = TILES.MOVING_PLATFORM;
                    for (let x = 20; x < 24; x++) grid[12][x] = TILES.MOVING_PLATFORM;
                    grid[17][30] = TILES.FLYER;
                    grid[18][40] = TILES.CHECKPOINT;
                    grid[18][53] = TILES.EXIT;
                    return grid;
                })()
            },
            {
                id: 'w3-4',
                name: 'Precision Jumps',
                world: 3,
                width: 60,
                height: 20,
                background: 'sky',
                music: 'tense',
                grid: (() => {
                    const grid = Array(20).fill(null).map(() => Array(60).fill(TILES.EMPTY));
                    for (let x = 0; x < 60; x++) grid[19][x] = TILES.GROUND;
                    grid[18][2] = TILES.PLAYER_START;
                    grid[18][10] = TILES.DOUBLE_JUMP;
                    for (let x = 15; x < 18; x++) grid[15][x] = TILES.PLATFORM;
                    for (let x = 25; x < 28; x++) grid[12][x] = TILES.PLATFORM;
                    for (let x = 35; x < 38; x++) grid[9][x] = TILES.PLATFORM;
                    grid[8][36] = TILES.COIN;
                    grid[17][45] = TILES.FLYER;
                    grid[18][58] = TILES.EXIT;
                    return grid;
                })()
            },
            {
                id: 'w3-5',
                name: 'Sky Boss',
                world: 3,
                width: 60,
                height: 20,
                background: 'sky',
                music: 'boss',
                grid: (() => {
                    const grid = Array(20).fill(null).map(() => Array(60).fill(TILES.EMPTY));
                    for (let x = 0; x < 60; x++) grid[19][x] = TILES.GROUND;
                    grid[18][2] = TILES.PLAYER_START;
                    grid[18][15] = TILES.STAR;
                    for (let x = 25; x < 35; x++) grid[15][x] = TILES.PLATFORM;
                    grid[17][45] = TILES.BOSS;
                    grid[18][58] = TILES.EXIT;
                    return grid;
                })()
            },
            {
                id: 'w4-1',
                name: 'Castle Gates',
                world: 4,
                width: 50,
                height: 15,
                background: 'castle',
                music: 'tense',
                grid: (() => {
                    const grid = Array(15).fill(null).map(() => Array(50).fill(TILES.EMPTY));
                    for (let x = 0; x < 50; x++) grid[14][x] = TILES.GROUND;
                    grid[13][2] = TILES.PLAYER_START;
                    for (let x = 10; x < 15; x++) grid[13][x] = TILES.SPIKE;
                    grid[12][20] = TILES.WALKER;
                    grid[12][25] = TILES.JUMPER;
                    grid[13][30] = TILES.CHECKPOINT;
                    for (let x = 35; x < 40; x++) grid[13][x] = TILES.LAVA;
                    grid[13][48] = TILES.EXIT;
                    return grid;
                })()
            },
            {
                id: 'w4-2',
                name: 'Trap Corridor',
                world: 4,
                width: 55,
                height: 15,
                background: 'castle',
                music: 'tense',
                grid: (() => {
                    const grid = Array(15).fill(null).map(() => Array(55).fill(TILES.EMPTY));
                    for (let x = 0; x < 55; x++) grid[14][x] = TILES.GROUND;
                    grid[13][2] = TILES.PLAYER_START;
                    for (let x = 10; x < 13; x++) grid[13][x] = TILES.SPIKE;
                    grid[13][15] = TILES.SPRING;
                    for (let x = 20; x < 23; x++) grid[13][x] = TILES.LAVA;
                    grid[12][30] = TILES.SHOOTER;
                    grid[13][35] = TILES.SHIELD;
                    grid[12][40] = TILES.WALKER;
                    grid[12][45] = TILES.JUMPER;
                    grid[13][53] = TILES.EXIT;
                    return grid;
                })()
            },
            {
                id: 'w4-3',
                name: 'Tower Ascent',
                world: 4,
                width: 40,
                height: 25,
                background: 'castle',
                music: 'adventure',
                grid: (() => {
                    const grid = Array(25).fill(null).map(() => Array(40).fill(TILES.EMPTY));
                    for (let x = 0; x < 40; x++) grid[24][x] = TILES.GROUND;
                    grid[23][2] = TILES.PLAYER_START;
                    for (let y = 15; y < 24; y++) {
                        grid[y][10] = TILES.LADDER;
                    }
                    for (let x = 11; x < 20; x++) grid[15][x] = TILES.PLATFORM;
                    grid[14][15] = TILES.COIN;
                    grid[22][25] = TILES.WALKER;
                    grid[23][38] = TILES.EXIT;
                    return grid;
                })()
            },
            {
                id: 'w4-4',
                name: 'Final Challenge',
                world: 4,
                width: 65,
                height: 20,
                background: 'castle',
                music: 'tense',
                grid: (() => {
                    const grid = Array(20).fill(null).map(() => Array(65).fill(TILES.EMPTY));
                    for (let x = 0; x < 65; x++) grid[19][x] = TILES.GROUND;
                    grid[18][2] = TILES.PLAYER_START;
                    for (let x = 10; x < 15; x++) grid[18][x] = TILES.SPIKE;
                    grid[18][20] = TILES.SPRING;
                    for (let x = 25; x < 30; x++) grid[15][x] = TILES.PLATFORM;
                    grid[17][35] = TILES.FLYER;
                    grid[18][40] = TILES.CHECKPOINT;
                    for (let x = 45; x < 50; x++) grid[18][x] = TILES.LAVA;
                    grid[17][55] = TILES.SHOOTER;
                    grid[18][60] = TILES.HEART;
                    grid[18][63] = TILES.EXIT;
                    return grid;
                })()
            },
            {
                id: 'w4-5',
                name: 'Final Boss',
                world: 4,
                width: 70,
                height: 20,
                background: 'castle',
                music: 'boss',
                grid: (() => {
                    const grid = Array(20).fill(null).map(() => Array(70).fill(TILES.EMPTY));
                    for (let x = 0; x < 70; x++) grid[19][x] = TILES.GROUND;
                    grid[18][2] = TILES.PLAYER_START;
                    grid[18][15] = TILES.STAR;
                    grid[18][20] = TILES.SHIELD;
                    for (let x = 30; x < 40; x++) grid[16][x] = TILES.PLATFORM;
                    grid[17][50] = TILES.BOSS;
                    grid[17][55] = TILES.BOSS;
                    grid[18][68] = TILES.EXIT;
                    return grid;
                })()
            }
        ];

        // ============= UI FUNCTIONS =============
        function showMainMenu() {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById('mainMenu').classList.add('active');
            if (game) game.stop();
        }

        function showCampaign() {
            const screen = document.getElementById('levelSelectScreen');
            const select = document.getElementById('levelSelect');
            select.innerHTML = '<h2 style="grid-column: 1/-1; color: #667eea;">Campaign Levels</h2>';

            CAMPAIGN_LEVELS.forEach(level => {
                const card = document.createElement('div');
                card.className = 'level-card';

                const completed = saveSystem.progress.completedLevels.includes(level.id);
                const stats = saveSystem.progress.levelStats[level.id];

                card.innerHTML = `
                    <div class="level-card-title">${level.name}</div>
                    <div class="level-card-info">World ${level.world}</div>
                    ${completed ? '<div class="stars">‚òÖ Complete</div>' : ''}
                    ${stats ? `<div class="level-card-info">Best: ${Math.floor(stats.time / 60)}:${(stats.time % 60).toString().padStart(2, '0')}</div>` : ''}
                `;

                card.onclick = () => playLevel(level);
                select.appendChild(card);
            });

            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            screen.classList.add('active');
        }

        function showCustomLevels() {
            const screen = document.getElementById('levelSelectScreen');
            const select = document.getElementById('levelSelect');
            select.innerHTML = '<h2 style="grid-column: 1/-1; color: #667eea;">My Levels</h2>';

            const levels = saveSystem.getCustomLevels();

            if (levels.length === 0) {
                select.innerHTML += '<p style="grid-column: 1/-1;">No custom levels yet. Build one!</p>';
            }

            levels.forEach(level => {
                const card = document.createElement('div');
                card.className = 'level-card';

                card.innerHTML = `
                    <div class="level-card-title">${level.name}</div>
                    <div class="level-card-info">${level.width}x${level.height}</div>
                    <div style="margin-top: 1rem;">
                        <button class="btn" style="padding: 0.5rem 1rem; margin-right: 0.5rem;" onclick="event.stopPropagation(); playLevel(${JSON.stringify(level).replace(/"/g, '&quot;')})">Play</button>
                        <button class="btn btn-secondary" style="padding: 0.5rem 1rem; margin-right: 0.5rem;" onclick="event.stopPropagation(); editLevel(${JSON.stringify(level).replace(/"/g, '&quot;')})">Edit</button>
                        <button class="btn" style="padding: 0.5rem 1rem; background: #f5576c;" onclick="event.stopPropagation(); deleteLevel('${level.id}')">Delete</button>
                    </div>
                `;

                select.appendChild(card);
            });

            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            screen.classList.add('active');
        }

        function startEditor(level = null) {
            const screen = document.getElementById('editorScreen');
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            screen.classList.add('active');

            if (!editor) {
                editor = new LevelEditor();
            }

            if (level) {
                editor.loadLevel(level);
            }
        }

        function editLevel(level) {
            startEditor(level);
        }

        function deleteLevel(id) {
            if (confirm('Delete this level?')) {
                saveSystem.deleteCustomLevel(id);
                showCustomLevels();
            }
        }

        function playLevel(level) {
            const screen = document.getElementById('playScreen');
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            screen.classList.add('active');

            if (!game) {
                game = new Game();
            }

            game.loadLevel(level);
            game.start();
        }

        function testLevel() {
            const level = editor.getLevel();
            playLevel(level);
        }

        function saveLevel() {
            const level = editor.getLevel();
            saveSystem.saveCustomLevel(level);
            alert('Level saved!');
        }

        function exportLevel() {
            const level = editor.getLevel();
            const json = JSON.stringify(level);
            document.getElementById('exportText').value = json;
            document.getElementById('exportModal').classList.add('active');
        }

        function closeExport() {
            document.getElementById('exportModal').classList.remove('active');
        }

        function copyExport() {
            const text = document.getElementById('exportText');
            text.select();
            document.execCommand('copy');
            alert('Copied to clipboard!');
        }

        function showImport() {
            document.getElementById('importText').value = '';
            document.getElementById('importModal').classList.add('active');
        }

        function closeImport() {
            document.getElementById('importModal').classList.remove('active');
        }

        function doImport() {
            try {
                const json = document.getElementById('importText').value;
                const level = JSON.parse(json);

                if (!level.grid || !level.width || !level.height) {
                    throw new Error('Invalid level format');
                }

                saveSystem.saveCustomLevel(level);
                closeImport();
                alert('Level imported successfully!');
                showCustomLevels();
            } catch (e) {
                alert('Error importing level: ' + e.message);
            }
        }

        // Initialize
        showMainMenu();
    </script>
</body>
</html>