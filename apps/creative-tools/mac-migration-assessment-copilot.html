<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <meta name="description" content="MAC (Migration Assessment Copilot)" />
    <meta name="theme-color" content="#742774" />
    <title>MAC (Migration Assessment Copilot)</title>

    <link
      rel="preload"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css"
      as="style"
    />
    <link
      rel="preload"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/github.min.css"
      as="style"
    />

    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css"
      rel="stylesheet"
    />
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/github.min.css"
      rel="stylesheet"
    />

    <style>
      :root {
        --power-purple: #742774;
        --power-purple-light: #9168b6;
        --power-purple-dark: #4f1c4f;
        --ms-gray-10: #faf9f8;
        --ms-gray-20: #f3f2f1;
        --ms-gray-30: #edebe9;
        --ms-gray-40: #e1dfdd;
        --ms-gray-100: #323130;
        --ms-gray-130: #242424;
        --power-apps-color: #742774;
        --power-automate-color: #0066ff;
        --power-bi-color: #f2c811;
        --power-pages-color: #008272;
        --space-xs: 4px;
        --space-s: 8px;
        --space-m: 16px;
        --space-l: 24px;
        --space-xl: 32px;
        --border-radius: 4px;
        --shadow-small: 0 2px 4px rgba(0, 0, 0, 0.1);
        --shadow-medium: 0 4px 8px rgba(0, 0, 0, 0.1);
        --header-height: 48px;
        --footer-height: 68px;
      }

      @font-face {
        font-family: "Segoe UI Web";
        src: local("Segoe UI");
        font-weight: normal;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        font-family: "Segoe UI Web", -apple-system, BlinkMacSystemFont,
          "Segoe UI", Roboto, sans-serif;
      }

      body {
        background-color: var(--ms-gray-10);
        color: var(--ms-gray-100);
        line-height: 1.5;
        height: 100vh;
        overflow: hidden;
      }

      .app-container {
        display: grid;
        grid-template-rows: var(--header-height) 1fr var(--footer-height);
        height: 100vh;
        max-width: 1200px;
        margin: 0 auto;
        background: white;
        box-shadow: var(--shadow-medium);
      }

      .header {
        background: var(--power-purple);
        color: white;
        padding: 0 var(--space-m);
        display: flex;
        align-items: center;
        justify-content: space-between;
        box-shadow: var(--shadow-small);
        z-index: 100;
      }

      .header h1 {
        font-size: 16px;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: var(--space-s);
      }

      .header h1::before {
        content: "";
        display: inline-block;
        width: 24px;
        height: 24px;
        background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 3c.83 0 1.5.67 1.5 1.5S12.83 8 12 8s-1.5-.67-1.5-1.5S11.17 5 12 5zm4 11.5c0 .83-.67 1.5-1.5 1.5h-5c-.83 0-1.5-.67-1.5-1.5V16h1.5v.5h5v-.5H16v.5zm-3-4h-2V9h2v3.5z"/></svg>')
          center/contain no-repeat;
        opacity: 0.9;
      }

      .chat-container {
        overflow: hidden;
        position: relative;
        display: flex;
        flex-direction: column;
        background: white;
      }

      .chat-messages {
        flex: 1;
        overflow-y: auto;
        padding: var(--space-m) var(--space-m) var(--space-xl) var(--space-m);
        scroll-behavior: smooth;
        margin-top: 40px;
      }

      .utility-buttons-container {
        position: fixed;
        top: calc(var(--header-height) + 8px);
        right: 16px;
        z-index: 100;
        display: flex;
        gap: 8px;
      }

      .utility-button {
        background: var(--power-purple);
        border: none;
        color: white;
        width: 32px;
        height: 32px;
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background-color 0.2s ease;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .utility-button:hover {
        background: var(--power-purple-dark);
      }

      .guid-dropdown {
        position: absolute;
        top: 100%;
        right: 0;
        background: white;
        border: 1px solid var(--ms-gray-30);
        border-radius: var(--border-radius);
        box-shadow: var(--shadow-small);
        min-width: 300px;
        max-height: 300px;
        overflow-y: auto;
        display: none;
        z-index: 1000;
      }

      .guid-dropdown.show {
        display: block;
      }

      .guid-dropdown-item {
        padding: 8px 12px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: space-between;
        border-bottom: 1px solid var(--ms-gray-30);
      }

      .guid-dropdown-item .guid-info {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .guid-dropdown-item .guid {
        font-family: monospace;
        font-size: 12px;
        color: var(--ms-gray-100);
      }

      .guid-dropdown-item .guid-name {
        font-size: 14px;
        font-weight: 500;
        color: var(--power-purple);
      }

      .guid-dropdown-item .timestamp {
        font-size: 11px;
        color: var(--ms-gray-100);
        opacity: 0.7;
      }

      .guid-dropdown-item .actions {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      .guid-dropdown-item .edit-name {
        background: none;
        border: none;
        color: var(--power-purple);
        opacity: 0.7;
        transition: opacity 0.2s ease;
        cursor: pointer;
        padding: 4px;
      }

      .guid-dropdown-item .delete-guid {
        background: none;
        border: none;
        color: #d32f2f;
        opacity: 0.7;
        transition: opacity 0.2s ease;
        cursor: pointer;
        padding: 4px;
      }

      .guid-dropdown-item .edit-name:hover,
      .guid-dropdown-item .delete-guid:hover {
        opacity: 1;
      }

      .guid-dropdown-item:last-child {
        border-bottom: none;
      }

      .guid-dropdown-item:hover {
        background: var(--ms-gray-20);
      }

      body.dark .guid-dropdown {
        background: var(--ms-gray-130);
        border-color: var(--ms-gray-100);
      }

      body.dark .guid-dropdown-item {
        border-color: var(--ms-gray-100);
      }

      body.dark .guid-dropdown-item:hover {
        background: var(--ms-gray-100);
      }

      body.dark .guid-dropdown-item .timestamp {
        color: white;
      }

      .message {
        max-width: 80%;
        margin: var(--space-s) 0;
        padding: var(--space-m);
        border-radius: var(--border-radius);
        position: relative;
        word-wrap: break-word;
        overflow-wrap: break-word;
      }

      .user-message {
        background: var(--power-purple);
        color: white;
        margin-left: auto;
        border-top-left-radius: var(--border-radius);
        border-top-right-radius: var(--border-radius);
        border-bottom-left-radius: var(--border-radius);
        border-bottom-right-radius: 0;
      }

      .assistant-message {
        background: var(--ms-gray-20);
        margin-right: auto;
        border-top-left-radius: var(--border-radius);
        border-top-right-radius: var(--border-radius);
        border-bottom-left-radius: 0;
        border-bottom-right-radius: var(--border-radius);
      }

      .system-message {
        background: rgba(255, 255, 255, 0.1);
        margin: var(--space-m) auto;
        width: 90%;
        font-family: monospace;
        white-space: pre-wrap;
        padding: var(--space-m);
        border-radius: var(--border-radius);
        position: relative;
      }

      .system-message .agent-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: var(--space-m);
        cursor: pointer;
      }

      .system-message .message-content {
        display: none;
        margin-top: var(--space-m);
        padding-top: var(--space-m);
        border-top: 1px solid rgba(255, 255, 255, 0.1);
      }

      .system-message.expanded .message-content {
        display: block;
      }

      .system-message .agent-name {
        font-weight: bold;
        color: var(--power-purple-light);
      }

      .system-message .expand-button {
        background: none;
        border: none;
        color: inherit;
        cursor: pointer;
        opacity: 0.7;
        padding: 4px;
        transition: all 0.2s ease;
      }

      .system-message .expand-button:hover {
        opacity: 1;
      }

      .system-message .expand-button i {
        transition: transform 0.2s ease;
      }

      .system-message.expanded .expand-button i {
        transform: rotate(180deg);
      }

      /* New styles for multiple agent calls */
      .agent-section {
        margin-bottom: 15px;
      }

      .agent-subheader {
        font-weight: 500;
        margin-bottom: 8px;
        padding-left: 10px;
        border-left: 3px solid var(--power-purple-light);
      }

      .agent-content {
        padding-left: 15px;
      }

      .message a {
        color: #0078d4;
        text-decoration: none;
        border-bottom: 1px solid transparent;
        transition: border-color 0.2s ease;
      }

      .message a:hover {
        border-bottom-color: #0078d4;
      }

      .user-message a {
        color: white;
        border-bottom: 1px solid rgba(255, 255, 255, 0.3);
      }

      .user-message a:hover {
        border-bottom-color: white;
      }

      body.dark .message a {
        color: #4cc9ff;
      }

      body.dark .message a:hover {
        border-bottom-color: #4cc9ff;
      }

      .message pre {
        background: var(--ms-gray-10);
        padding: var(--space-m);
        border-radius: var(--border-radius);
        overflow-x: auto;
        margin: var(--space-s) 0;
      }

      .message code {
        font-family: "Consolas", "Monaco", monospace;
        font-size: 14px;
      }

      .user-message pre,
      .user-message code {
        background: rgba(255, 255, 255, 0.1);
        color: white;
      }

      .input-container {
        background: white;
        border-top: 1px solid var(--ms-gray-30);
        padding: var(--space-m);
        display: grid;
        grid-template-columns: 1fr auto;
        gap: var(--space-m);
        align-items: center;
      }

      .input-field {
        padding: var(--space-m);
        border: 1px solid var(--ms-gray-40);
        border-radius: var(--border-radius);
        font-size: 14px;
        resize: none;
        min-height: 40px;
        max-height: 120px;
        transition: all 0.2s ease;
      }

      .input-field:focus {
        outline: none;
        border-color: var(--power-purple);
        box-shadow: 0 0 0 2px rgba(116, 39, 116, 0.1);
      }

      .button {
        background: var(--power-purple);
        color: white;
        border: none;
        border-radius: var(--border-radius);
        padding: var(--space-m);
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: var(--space-s);
        height: 40px;
        min-width: 40px;
      }

      .button:hover {
        background: var(--power-purple-dark);
      }

      .button:active {
        transform: scale(0.98);
      }

      .loading {
        display: none;
        padding: var(--space-m);
        align-items: center;
        justify-content: center;
        gap: var(--space-s);
      }

      .loading span {
        width: 8px;
        height: 8px;
        background: var(--power-purple);
        border-radius: 50%;
        display: inline-block;
        animation: bounce 0.8s infinite;
      }

      .loading span:nth-child(2) {
        animation-delay: 0.2s;
      }

      .loading span:nth-child(3) {
        animation-delay: 0.4s;
      }

      @keyframes bounce {
        0%,
        100% {
          transform: translateY(0);
        }
        50% {
          transform: translateY(-6px);
        }
      }

      /* Modal styles for GUID creation */
      .modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1000;
      }

      .modal-content {
        background: white;
        padding: 24px;
        border-radius: 8px;
        min-width: 300px;
        max-width: 90%;
      }

      .modal h2 {
        margin: 0;
        color: var(--power-purple);
        font-size: 18px;
      }

      .input-group {
        margin: 16px 0;
      }

      .input-group label {
        display: block;
        margin-bottom: 8px;
        color: var(--ms-gray-100);
      }

      .input-group input {
        width: 100%;
        padding: 8px;
        border: 1px solid var(--ms-gray-40);
        border-radius: 4px;
        font-size: 14px;
      }

      .modal-actions {
        display: flex;
        justify-content: flex-end;
        gap: 8px;
        margin-top: 16px;
      }

      .button.secondary {
        background: var(--ms-gray-20);
        color: var(--ms-gray-100);
      }

      /* Dark mode styles */
      body.dark {
        background: var(--ms-gray-130);
        color: white;
      }

      body.dark .app-container {
        background: var(--ms-gray-100);
      }

      body.dark .chat-container {
        background: var(--ms-gray-100);
      }

      body.dark .input-container {
        background: var(--ms-gray-100);
        border-top-color: var(--ms-gray-40);
      }

      body.dark .input-field {
        background: var(--ms-gray-130);
        color: white;
        border-color: var(--ms-gray-40);
      }

      body.dark .assistant-message {
        background: var(--ms-gray-130);
        color: white;
      }

      body.dark .modal-content {
        background: var(--ms-gray-100);
        color: white;
      }

      body.dark .modal h2 {
        color: white;
      }

      body.dark .input-group label {
        color: white;
      }

      body.dark .input-group input {
        background: var(--ms-gray-130);
        color: white;
        border-color: var(--ms-gray-40);
      }

      body.dark .button.secondary {
        background: var(--ms-gray-130);
        color: white;
      }

      @media (max-width: 768px) {
        .app-container {
          height: 100vh;
          width: 100vw;
        }

        .message {
          max-width: 90%;
        }

        .utility-buttons-container {
          top: auto;
          bottom: calc(var(--footer-height) + var(--space-m));
        }

        .input-field {
          font-size: 16px;
        }

        .modal-content {
          width: 90%;
          margin: 20px;
        }
      }

      @supports (-webkit-touch-callout: none) {
        .app-container {
          height: -webkit-fill-available;
        }
      }

      /* Time Machine Styles */
      .time-machine-controls {
        position: fixed;
        bottom: calc(var(--footer-height) + 20px);
        left: 50%;
        transform: translate(-50%, 150%);
        background: var(--power-purple);
        padding: 10px 20px;
        border-radius: 20px;
        display: flex;
        gap: 15px;
        align-items: center;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        z-index: 1000;
        transition: all 0.3s ease;
        opacity: 0;
        pointer-events: none;
      }

      .time-machine-controls.visible {
        transform: translate(-50%, 0);
        opacity: 1;
        pointer-events: all;
      }

      .time-machine-button {
        background: transparent;
        border: none;
        color: white;
        font-size: 20px;
        cursor: pointer;
        padding: 5px;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0.8;
        transition: all 0.2s ease;
      }

      .time-machine-button:hover {
        opacity: 1;
        transform: scale(1.1);
      }

      .time-machine-button:disabled {
        opacity: 0.3;
        cursor: not-allowed;
        transform: none;
      }

      .time-machine-progress {
        color: white;
        font-size: 14px;
        min-width: 80px;
        text-align: center;
      }

      .time-machine-toggle {
        position: fixed;
        bottom: var(--footer-height);
        right: 20px;
        background: var(--power-purple);
        color: white;
        border: none;
        padding: 8px 15px;
        border-radius: 20px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 14px;
        z-index: 1000;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        transition: all 0.2s ease;
      }

      .time-machine-toggle:hover {
        background: var(--power-purple-dark);
        transform: translateY(-2px);
      }

      .replay-mode .input-container {
        opacity: 0.5;
        pointer-events: none;
      }

      .replay-mode .input-field {
        background: var(--ms-gray-30);
      }

      @keyframes messageAppear {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .message.replay-animation {
        animation: messageAppear 0.5s ease forwards;
      }

      /* Dark mode adjustments */
      body.dark .time-machine-button:disabled {
        opacity: 0.3;
      }

      body.dark .time-machine-toggle:hover {
        background: var(--power-purple-dark);
      }

      /* Add this CSS to align the Time Machine button with other buttons on small screens */
      @media (max-width: 768px) {
        .time-machine-toggle {
          position: static;
          display: inline-flex;
          margin: 0;
          padding: 0;
          width: 48px;
          height: 48px;
          justify-content: center;
          align-items: center;
          border-radius: 4px;
          box-shadow: none;
        }

        .time-machine-toggle i {
          margin-right: 0;
        }

        .time-machine-toggle span,
        .time-machine-toggle::after {
          display: none;
        }
      }

      .drop-zone {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(116, 39, 116, 0.1);
        border: 3px dashed var(--power-purple);
        z-index: 1000;
        display: flex;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
      }

      .drop-zone.active {
        opacity: 1;
        pointer-events: all;
      }

      .drop-zone-content {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        color: var(--power-purple);
      }

      .drop-zone-content i {
        font-size: 48px;
        margin-bottom: 16px;
      }

      .drop-zone-content p {
        font-size: 18px;
        font-weight: 500;
      }

      body.dark .drop-zone {
        background: rgba(255, 255, 255, 0.1);
      }

      body.dark .drop-zone-content {
        color: white;
      }

      /* Branch button styling */
      #branch-button {
        color: #fff;
        opacity: 0.8;
      }

      #branch-button:hover:not(:disabled) {
        opacity: 1;
        transform: scale(1.1);
      }

      #branch-button:disabled {
        opacity: 0.3;
        cursor: not-allowed;
      }

      /* Branch switcher button */
      #branch-switcher {
        margin-left: 5px;
        color: #fff;
        opacity: 0.8;
      }

      #branch-switcher:hover {
        opacity: 1;
        transform: scale(1.1);
      }

      /* Branch dropdown styling */
      .branch-dropdown {
        position: absolute;
        top: 100px;
        right: 20px;
        background: white;
        border: 1px solid var(--ms-gray-30);
        border-radius: var(--border-radius);
        box-shadow: var(--shadow-small);
        min-width: 280px;
        max-height: 300px;
        overflow-y: auto;
        display: none;
        z-index: 1000;
      }

      .branch-dropdown.show {
        display: block;
      }

      .branch-dropdown-item {
        padding: 12px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: space-between;
        border-bottom: 1px solid var(--ms-gray-30);
      }

      .branch-dropdown-item:hover {
        background: var(--ms-gray-20);
      }

      .branch-dropdown-item.active {
        background: rgba(116, 39, 116, 0.1);
      }

      .branch-info {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .branch-name {
        font-weight: 500;
        color: var(--power-purple);
      }

      .branch-details {
        font-size: 11px;
        color: var(--ms-gray-100);
        opacity: 0.7;
      }

      .branch-actions {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      .delete-branch {
        background: none;
        border: none;
        color: #d32f2f;
        opacity: 0.7;
        transition: opacity 0.2s ease;
        cursor: pointer;
        padding: 4px;
      }

      .delete-branch:hover {
        opacity: 1;
      }

      /* Branch indicator in chat */
      .branch-indicator {
        background: rgba(116, 39, 116, 0.1);
        border-radius: 4px;
        padding: 2px 6px;
        font-size: 10px;
        margin-left: 8px;
        color: var(--power-purple);
      }

      /* Dark mode adjustments */
      body.dark .branch-dropdown {
        background: var(--ms-gray-130);
        border-color: var(--ms-gray-100);
      }

      body.dark .branch-dropdown-item {
        border-color: var(--ms-gray-100);
      }

      body.dark .branch-dropdown-item:hover {
        background: var(--ms-gray-100);
      }

      body.dark .branch-dropdown-item.active {
        background: rgba(255, 255, 255, 0.1);
      }

      body.dark .branch-name {
        color: var(--power-purple-light);
      }

      body.dark .branch-details {
        color: white;
      }

      body.dark .branch-indicator {
        background: rgba(255, 255, 255, 0.1);
        color: var(--power-purple-light);
      }

      /* Command Queue Panel Styles */
      .queue-panel {
        position: fixed;
        top: calc(var(--header-height) + 10px);
        right: 10px;
        width: 400px;
        max-width: 90vw;
        background: white;
        border-radius: var(--border-radius);
        box-shadow: var(--shadow-medium);
        display: flex;
        flex-direction: column;
        max-height: calc(100vh - var(--header-height) - var(--footer-height) - 20px);
        transform: translateX(110%);
        transition: transform 0.3s ease;
        z-index: 200;
      }

      .queue-panel.show {
        transform: translateX(0);
      }

      .queue-header {
        padding: 12px 16px;
        border-bottom: 1px solid var(--ms-gray-30);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .queue-header h3 {
        margin: 0;
        font-size: 16px;
        color: var(--power-purple);
      }

      .queue-close {
        background: none;
        border: none;
        color: var(--ms-gray-100);
        cursor: pointer;
        padding: 4px;
        opacity: 0.7;
        transition: opacity 0.2s ease;
      }

      .queue-close:hover {
        opacity: 1;
      }

      .queue-content {
        padding: 16px;
        overflow-y: auto;
        flex: 1;
      }

      .queue-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
        min-height: 120px;
        overflow-y: auto;
        border: 1px solid var(--ms-gray-30);
        border-radius: var(--border-radius);
        padding: 8px;
        background: var(--ms-gray-10);
      }

      .queue-empty {
        padding: 20px;
        text-align: center;
        color: var(--ms-gray-100);
        opacity: 0.7;
        font-style: italic;
      }

      .queue-item {
        display: flex;
        align-items: center;
        background: white;
        border: 1px solid var(--ms-gray-30);
        border-radius: var(--border-radius);
        overflow: hidden;
        cursor: grab;
      }

      .queue-item.dragging {
        opacity: 0.5;
        cursor: grabbing;
      }

      .queue-item-content {
        flex: 1;
        padding: 8px 12px;
        display: flex;
        flex-direction: column;
        gap: 4px;
        position: relative;
      }

      .queue-item-number {
        position: absolute;
        top: 8px;
        left: 8px;
        width: 20px;
        height: 20px;
        background: var(--power-purple-light);
        color: white;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
      }

      .queue-item-command {
        padding-left: 28px;
        word-break: break-word;
      }

      .queue-item-skill {
        font-size: 12px;
        color: var(--power-purple);
        font-style: italic;
        padding-left: 28px;
      }

      .queue-item-actions {
        display: flex;
        align-items: center;
        padding: 0 8px;
      }

      .queue-item-remove {
        background: none;
        border: none;
        color: #d32f2f;
        opacity: 0.7;
        transition: opacity 0.2s ease;
        cursor: pointer;
        padding: 4px;
      }

      .queue-item-remove:hover {
        opacity: 1;
      }

      .queue-input-group {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .queue-input {
        padding: 8px 12px;
        border: 1px solid var(--ms-gray-40);
        border-radius: var(--border-radius);
        font-size: 14px;
      }

      .queue-input:focus {
        outline: none;
        border-color: var(--power-purple);
        box-shadow: 0 0 0 2px rgba(116, 39, 116, 0.1);
      }

      .queue-actions {
        display: flex;
        justify-content: space-between;
        margin-top: 12px;
        gap: 8px;
      }

      .queue-button {
        padding: 8px 12px;
        border-radius: var(--border-radius);
        border: none;
        cursor: pointer;
        transition: all 0.2s ease;
        font-size: 14px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
      }

      .queue-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .queue-button.primary {
        background: var(--power-purple);
        color: white;
        flex: 1;
      }

      .queue-button.primary:hover:not(:disabled) {
        background: var(--power-purple-dark);
      }

      .queue-button.secondary {
        background: var(--ms-gray-20);
        color: var(--ms-gray-100);
      }

      .queue-button.secondary:hover:not(:disabled) {
        background: var(--ms-gray-30);
      }

      .queue-button {
        background: white;
        border: 1px solid var(--ms-gray-40);
        color: var(--ms-gray-100);
      }

      .queue-button:hover:not(:disabled) {
        background: var(--ms-gray-10);
      }

      .queue-status {
        padding: 12px 16px;
        border-top: 1px solid var(--ms-gray-30);
        font-size: 14px;
        color: var(--ms-gray-100);
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .queue-status.processing {
        color: var(--power-purple);
        background-color: rgba(116, 39, 116, 0.1);
      }

      .queue-status.success {
        color: #2e7d32;
        background-color: rgba(46, 125, 50, 0.1);
      }

      .queue-status.failed {
        color: #d32f2f;
        background-color: rgba(211, 47, 47, 0.1);
      }

      /* Queue item status styling */
      .queue-item-completed {
        border-left: 4px solid #2e7d32;
      }

      .queue-item-failed {
        border-left: 4px solid #d32f2f;
      }

      .queue-item-processing {
        border-left: 4px solid var(--power-purple);
        background-color: rgba(116, 39, 116, 0.05);
      }

      /* Dark mode styling */
      body.dark .queue-panel {
        background: var(--ms-gray-100);
        border-color: var(--ms-gray-40);
      }

      body.dark .queue-header {
        border-color: var(--ms-gray-40);
      }

      body.dark .queue-header h3 {
        color: var(--power-purple-light);
      }

      body.dark .queue-close {
        color: white;
      }

      body.dark .queue-list {
        background: var(--ms-gray-130);
        border-color: var(--ms-gray-40);
      }

      body.dark .queue-item {
        background: var(--ms-gray-100);
        border-color: var(--ms-gray-40);
      }

      body.dark .queue-input {
        background: var(--ms-gray-130);
        color: white;
        border-color: var(--ms-gray-40);
      }

      body.dark .queue-button.secondary {
        background: var(--ms-gray-130);
        color: white;
      }

      body.dark .queue-button {
        background: var(--ms-gray-100);
        color: white;
        border-color: var(--ms-gray-40);
      }

      body.dark .queue-empty {
        color: white;
      }

      body.dark .queue-status {
        border-color: var(--ms-gray-40);
        color: white;
      }

      /* Responsive adjustments */
      @media (max-width: 768px) {
        .queue-panel {
          width: 90vw;
          max-height: 80vh;
          top: 60px;
        }
        
        .queue-actions {
          flex-wrap: wrap;
        }
        
        .queue-button.primary {
          order: -1;
          width: 100%;
          margin-bottom: 8px;
        }
      }

      /* Workflow Modal Styling */
      #workflow-modal .modal-content {
        max-width: 800px;
        width: 90%;
        max-height: 90vh;
        overflow-y: auto;
      }

      .workflow-tabs {
        display: flex;
        margin-bottom: 16px;
        border-bottom: 1px solid var(--ms-gray-30);
      }

      .workflow-tab {
        padding: 8px 16px;
        background: none;
        border: none;
        border-bottom: 2px solid transparent;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
        color: var(--ms-gray-100);
        transition: all 0.2s ease;
      }

      .workflow-tab.active {
        color: var(--power-purple);
        border-bottom-color: var(--power-purple);
      }

      .workflow-panel {
        display: none;
      }

      .workflow-panel.active {
        display: block;
      }

      .workflow-field {
        margin-bottom: 16px;
      }

      .workflow-field label {
        display: block;
        margin-bottom: 6px;
        font-weight: 500;
        font-size: 14px;
      }

      .workflow-field input,
      .workflow-field textarea {
        width: 100%;
        padding: 8px 12px;
        border: 1px solid var(--ms-gray-40);
        border-radius: var(--border-radius);
        font-size: 14px;
      }

      .workflow-field textarea {
        min-height: 80px;
        resize: vertical;
      }

      .agent-list {
        margin-top: 20px;
      }

      .agent-item {
        border: 1px solid var(--ms-gray-30);
        border-radius: var(--border-radius);
        padding: 12px;
        margin-bottom: 12px;
        position: relative;
      }

      .agent-item-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
      }

      .agent-item-title {
        font-weight: 500;
        font-size: 16px;
        color: var(--power-purple);
      }

      .agent-item-type {
        font-size: 12px;
        background: var(--ms-gray-20);
        color: var(--ms-gray-100);
        padding: 2px 6px;
        border-radius: 4px;
      }

      .agent-item-command {
        font-family: monospace;
        font-size: 13px;
        background: var(--ms-gray-10);
        padding: 8px;
        border-radius: 4px;
        margin-top: 8px;
        white-space: pre-wrap;
        word-break: break-word;
      }

      .connection-line {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 8px 0;
        color: var(--ms-gray-100);
        font-size: 12px;
      }

      .connection-line::before,
      .connection-line::after {
        content: "";
        flex: 1;
        height: 1px;
        background: var(--ms-gray-30);
        margin: 0 8px;
      }

      .json-preview {
        background: var(--ms-gray-100);
        color: white;
        padding: 16px;
        border-radius: var(--border-radius);
        font-family: monospace;
        font-size: 12px;
        white-space: pre-wrap;
        overflow-x: auto;
        max-height: 400px;
        overflow-y: auto;
      }

      .workflow-actions {
        display: flex;
        justify-content: space-between;
        margin-top: 24px;
      }

      /* Dark mode adjustments */
      body.dark .workflow-tab {
        color: white;
      }

      body.dark .workflow-tab.active {
        color: var(--power-purple-light);
      }

      body.dark .workflow-field input,
      body.dark .workflow-field textarea {
        background: var(--ms-gray-130);
        color: white;
        border-color: var(--ms-gray-40);
      }

      body.dark .agent-item {
        border-color: var(--ms-gray-40);
        background: var(--ms-gray-130);
      }

      body.dark .agent-item-title {
        color: var(--power-purple-light);
      }

      body.dark .agent-item-type {
        background: var(--ms-gray-100);
        color: white;
      }

      body.dark .agent-item-command {
        background: var(--ms-gray-100);
        color: white;
      }

      body.dark .connection-line {
        color: white;
      }

      body.dark .connection-line::before,
      body.dark .connection-line::after {
        background: var(--ms-gray-40);
      }

      body.dark .json-preview {
        background: var(--ms-gray-130);
      }
    </style>
  </head>
  <body data-assistant-name="MAC (Migration Assessment Copilot)">
    <div class="app-container">
      <header class="header">
        <h1>MAC (Migration Assessment Copilot)</h1>
      </header>

      <main class="chat-container">
        <div class="chat-messages" id="chat-messages"></div>

        <div class="loading" id="loading">
          <span></span>
          <span></span>
          <span></span>
        </div>

        <div class="utility-buttons-container">
          <!-- Reordered buttons for better UX -->
          <button
            class="utility-button"
            id="reset-guid"
            aria-label="Manage user IDs"
            title="Manage user IDs"
            style="display: none"
          >
            <i class="fas fa-fingerprint"></i>
          </button>
          <button
            class="utility-button"
            id="create-guid"
            aria-label="Create new GUID"
            title="Create new GUID"
          >
            <i class="fas fa-plus"></i>
          </button>
          <button
            class="utility-button"
            id="workflow-button"
            aria-label="Generate Workflow"
            title="Generate Agent Workflow from Conversation"
          >
            <i class="fas fa-cogs"></i>
          </button>
          <button
            class="utility-button"
            id="clear-chat"
            aria-label="Clear chat"
            title="Clear chat"
          >
            <i class="fas fa-trash-alt"></i>
          </button>
          <button
            class="utility-button"
            id="theme-toggle"
            aria-label="Toggle theme"
            title="Toggle theme"
          >
            <i class="fas fa-moon"></i>
          </button>
          <button
            class="utility-button"
            id="sound-toggle"
            aria-label="Toggle sounds"
            title="Toggle sounds"
          >
            <i class="fas fa-volume-mute"></i>
          </button>
          <button
            class="utility-button"
            id="export-chat"
            aria-label="Export chat"
            title="Export chat"
          >
            <i class="fas fa-file-export"></i>
          </button>
          <button
            class="utility-button"
            id="import-chat"
            aria-label="Import chat"
            title="Import chat"
          >
            <i class="fas fa-file-import"></i>
          </button>
          <button
            class="utility-button"
            id="export-guids"
            aria-label="Export GUIDs"
            title="Export GUIDs"
          >
            <i class="fas fa-download"></i>
          </button>
          <button
            class="utility-button"
            id="import-guids"
            aria-label="Import GUIDs"
            title="Import GUIDs"
          >
            <i class="fas fa-upload"></i>
          </button>
          <div class="guid-dropdown" id="guid-dropdown"></div>
        </div>

        <input
          type="file"
          id="chat-file-input"
          accept=".json"
          style="display: none"
        />

        <input
          type="file"
          id="guid-file-input"
          accept=".json"
          style="display: none"
        />

        <div id="drop-zone" class="drop-zone">
          <div class="drop-zone-content">
            <i class="fas fa-cloud-upload-alt"></i>
            <p>Drop conversation file here</p>
          </div>
        </div>

        <button class="time-machine-toggle" id="time-machine-toggle">
          <i class="fas fa-clock"></i>
          <span>Time Machine</span>
        </button>

        <div class="time-machine-controls" id="time-machine-controls">
          <button
            class="time-machine-button"
            id="step-backward"
            title="Previous message"
          >
            <i class="fas fa-step-backward"></i>
          </button>
          <button
            class="time-machine-button"
            id="play-pause"
            title="Play/Pause"
          >
            <i class="fas fa-play"></i>
          </button>
          <button
            class="time-machine-button"
            id="step-forward"
            title="Next message"
          >
            <i class="fas fa-step-forward"></i>
          </button>
          <button
            class="time-machine-button"
            id="branch-button"
            title="Create branch from this point"
          >
            <i class="fas fa-code-branch"></i>
          </button>
          <button
            class="time-machine-button"
            id="branch-switcher"
            title="View branches"
          >
            <i class="fas fa-sitemap"></i>
          </button>
          <div class="time-machine-progress" id="progress">0 / 0</div>
        </div>

        <!-- Branch dropdown menu -->
        <div id="branch-dropdown" class="branch-dropdown"></div>
      </main>

      <div class="input-container">
        <input
          type="text"
          class="input-field"
          id="user-input"
          placeholder="Type your message..."
          aria-label="Message input"
          autocomplete="off"
          autocapitalize="sentences"
        />
        <button class="button" id="send-button" aria-label="Send message">
          <i class="fas fa-paper-plane"></i>
        </button>
      </div>
    </div>

    <!-- Modal for creating new GUID -->
    <div id="create-guid-modal" class="modal">
      <div class="modal-content">
        <h2>Create New GUID</h2>
        <div class="input-group">
          <label for="guid-name">Name (optional):</label>
          <input
            type="text"
            id="guid-name"
            placeholder="Enter a name for this GUID"
          />
        </div>
        <div class="modal-actions">
          <button id="modal-cancel" class="button secondary">Cancel</button>
          <button id="modal-create" class="button">Create</button>
        </div>
      </div>
    </div>

    <!-- Modal for generating workflow -->
    <div id="workflow-modal" class="modal">
      <div class="modal-content">
        <h2>Generate Agent Workflow</h2>
        
        <div class="workflow-tabs">
          <button class="workflow-tab active" data-tab="config">Configure</button>
          <button class="workflow-tab" data-tab="preview">Preview</button>
          <button class="workflow-tab" data-tab="json">JSON</button>
        </div>
        
        <div class="workflow-panel active" data-panel="config">
          <div class="workflow-field">
            <label for="workflow-name">Workflow Name</label>
            <input type="text" id="workflow-name" placeholder="Enter workflow name">
          </div>
          
          <div class="workflow-field">
            <label for="workflow-description">Description</label>
            <textarea id="workflow-description" placeholder="Describe what this workflow does"></textarea>
          </div>
          
          <div class="workflow-field">
            <label for="workflow-nl-description">Natural Language Description</label>
            <textarea id="workflow-nl-description" placeholder="Describe the workflow in natural language"></textarea>
          </div>
          
          <div id="agent-detected-message" style="display: none; margin-bottom: 16px; padding: 12px; background: #e6f7ff; border-radius: 4px; color: #0078d4;">
            <i class="fas fa-info-circle" style="margin-right: 8px;"></i>
            <span id="detected-agents-count">0</span> agent calls detected in this conversation.
          </div>
          
          <div id="no-agents-message" style="display: none; margin-bottom: 16px; padding: 12px; background: #fff4e5; border-radius: 4px; color: #d83b01;">
            <i class="fas fa-exclamation-triangle" style="margin-right: 8px;"></i>
            No agent calls were detected in this conversation. Try having a conversation that uses agents like Dynamics365CRUD or EmailDrafting before generating a workflow.
          </div>
        </div>
        
        <div class="workflow-panel" data-panel="preview">
          <div class="agent-list" id="workflow-agent-list">
            <!-- Agent items will be added here dynamically -->
          </div>
        </div>
        
        <div class="workflow-panel" data-panel="json">
          <pre class="json-preview" id="workflow-json-preview"></pre>
        </div>
        
        <div class="workflow-actions">
          <button id="workflow-cancel" class="button secondary">Cancel</button>
          <button id="workflow-export" class="button">Export Workflow</button>
        </div>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>

    <script>
      document.addEventListener("DOMContentLoaded", function () {
        const assistantName = document.body.dataset.assistantName;
        const azureFunctionUrl =
          "http://localhost:7071/api/businessinsightbot_function";
        let functionKey = localStorage.getItem("functionKey");

        // Agent Workflow Generator Class
        class AgentWorkflowGenerator {
          constructor() {
            this.availableAgents = {
              'Dynamics365CRUD': {
                description: "Performs CRUD operations with Dynamics 365 Web API.",
                parameters: ["operation", "entity", "data", "record_id", "fetchxml", "select"]
              },
              'ContextMemory': {
                description: "Recalls and provides context based on stored memories of past interactions.",
                parameters: ["user_guid"]
              },
              'ManageMemory': {
                description: "Manages memories in a JSON-based storage system.",
                parameters: ["data", "conversation_id", "session_id", "user_guid", "conversation_context", "companion_id", "mood", "theme"]
              },
              'EmailDrafting': {
                description: "Drafts an email with proper formatting and sends it via Microsoft Power Automate.",
                parameters: ["subject", "to", "cc", "bcc", "body", "attachments", "importance"]
              }
            };
          }

          /**
           * Extract agent calls from a conversation
           * @param {Array} conversation - Array of message objects with role and content
           * @return {Array} - Array of agent call objects
           */
          extractAgentCalls(conversation) {
            const agentCalls = [];
            const systemMessages = conversation.filter(msg => msg.role === 'system');
            
            systemMessages.forEach(message => {
              const content = message.content;
              if (!content.startsWith('Performed ')) return;
              
              const agentNameMatch = content.match(/^Performed (\w+)/);
              if (!agentNameMatch) return;
              
              const agentName = agentNameMatch[1];
              if (!this.availableAgents[agentName]) return;

              let resultData = {};
              try {
                // Extract the JSON part after "got result: "
                const jsonMatch = content.match(/and got result: ({.*})/s);
                if (jsonMatch && jsonMatch[1]) {
                  resultData = JSON.parse(jsonMatch[1]);
                }
              } catch (error) {
                console.warn(`Failed to parse result data for ${agentName}:`, error);
              }

              // Find the user message that preceded this agent call
              const agentIndex = conversation.findIndex(msg => 
                msg.role === 'system' && msg.content === content
              );
              
              let command = "";
              if (agentIndex > 0) {
                // Look for the nearest user message before this agent call
                for (let i = agentIndex - 1; i >= 0; i--) {
                  if (conversation[i].role === 'user') {
                    command = conversation[i].content;
                    break;
                  }
                }
              }

              agentCalls.push({
                agentName,
                command,
                resultData,
                description: this.availableAgents[agentName]?.description || "",
                agentIndex
              });
            });

            return agentCalls;
          }

          /**
           * Generate a workflow from extracted agent calls
           * @param {Array} agentCalls - Array of agent call objects
           * @param {String} name - Name for the workflow
           * @param {String} description - Description for the workflow
           * @param {String} nlDescription - Natural language description for the workflow
           * @return {Object} - Workflow object
           */
          generateWorkflow(agentCalls, name, description, nlDescription) {
            if (!agentCalls || agentCalls.length === 0) {
              throw new Error("No agent calls found to create a workflow");
            }

            const workflow = {
              id: this.generateId(name),
              name: name || "Untitled Workflow",
              description: description || "Workflow generated from conversation",
              created: new Date().toISOString(),
              lastRun: null,
              nlDescription: nlDescription || description || "Execute a sequence of agent tasks",
              agents: [],
              connections: []
            };

            // Generate agents
            agentCalls.forEach((call, index) => {
              const agentId = `agent${index + 1}`;
              workflow.agents.push({
                id: agentId,
                type: call.agentName,
                agentId: this.generateId(call.agentName + index),
                name: this.generateAgentName(call.agentName, call.command),
                description: this.generateAgentDescription(call.agentName, call.command),
                position: {
                  x: 100 + (index * 200),
                  y: 100
                },
                command: call.command
              });
            });

            // Generate connections (connecting each agent to the next one)
            for (let i = 0; i < workflow.agents.length - 1; i++) {
              workflow.connections.push({
                fromId: workflow.agents[i].id,
                toId: workflow.agents[i + 1].id,
                connectionPrompt: `Pass the results from ${workflow.agents[i].name} to ${workflow.agents[i + 1].name}`
              });
            }

            return workflow;
          }

          /**
           * Generate a friendly name for an agent in the workflow
           * @param {String} agentType - The type of the agent
           * @param {String} command - The command used with the agent
           * @return {String} - A readable name for the agent
           */
          generateAgentName(agentType, command) {
            // Try to extract a meaningful name from the command
            let name = '';
            
            if (agentType === 'Dynamics365CRUD') {
              if (command.toLowerCase().includes('get') || command.toLowerCase().includes('read')) {
                name = 'Get Dynamics Data';
              } else if (command.toLowerCase().includes('create')) {
                name = 'Create Dynamics Record';
              } else if (command.toLowerCase().includes('update')) {
                name = 'Update Dynamics Record';
              } else if (command.toLowerCase().includes('delete')) {
                name = 'Delete Dynamics Record';
              } else {
                name = 'Work with Dynamics 365';
              }
            } else if (agentType === 'EmailDrafting') {
              name = 'Send Email';
            } else if (agentType === 'ContextMemory') {
              name = 'Retrieve Context';
            } else if (agentType === 'ManageMemory') {
              name = 'Save to Memory';
            } else {
              name = `Use ${agentType}`;
            }
            
            return name;
          }

          /**
           * Generate a description for an agent in the workflow
           * @param {String} agentType - The type of the agent
           * @param {String} command - The command used with the agent
           * @return {String} - A readable description for the agent
           */
          generateAgentDescription(agentType, command) {
            // For brevity, use the first 60 chars of the command
            const shortCommand = command.length > 60 ? command.substring(0, 57) + '...' : command;
            return `${this.availableAgents[agentType]?.description || agentType}: "${shortCommand}"`;
          }

          /**
           * Generate an ID from a string
           * @param {String} str - String to generate ID from
           * @return {String} - ID string
           */
          generateId(str) {
            const normalized = (str || 'default').toLowerCase().replace(/[^a-z0-9]/g, '-');
            return `${normalized}-${Date.now().toString(36)}`;
          }

          /**
           * Export a workflow as JSON
           * @param {Object} workflow - Workflow object
           * @return {String} - JSON string
           */
          exportWorkflow(workflow) {
            return JSON.stringify(workflow, null, 2);
          }
        }

        class SoundManager {
          constructor() {
            this.audioContext = null;
            this.bellBuffer = null;
            this.responseBuffer = null;
            this.loopTimeout = null;
            this.isPlaying = false;

            // Get sound preference from localStorage, default to 'off'
            const savedSoundPreference = localStorage.getItem("soundEnabled");
            this.volume = savedSoundPreference === "on" ? 0.3 : 0;
            this.isInitialized = false;

            this.initializeAudio();
          }

          async initializeAudio() {
            if (this.isInitialized) return;

            try {
              this.audioContext = new (window.AudioContext ||
                window.webkitAudioContext)();

              const bellBuffer = this.audioContext.createBuffer(
                1,
                this.audioContext.sampleRate * 1,
                this.audioContext.sampleRate
              );
              const bellData = bellBuffer.getChannelData(0);
              for (let i = 0; i < bellBuffer.length; i++) {
                bellData[i] =
                  Math.sin(
                    (440 * Math.PI * 2 * i) / this.audioContext.sampleRate
                  ) * Math.exp((-3 * i) / bellBuffer.length);
              }
              this.bellBuffer = bellBuffer;

              const responseBuffer = this.audioContext.createBuffer(
                1,
                this.audioContext.sampleRate * 0.5,
                this.audioContext.sampleRate
              );
              const responseData = responseBuffer.getChannelData(0);
              for (let i = 0; i < responseBuffer.length; i++) {
                responseData[i] =
                  Math.sin(
                    (880 * Math.PI * 2 * i) / this.audioContext.sampleRate
                  ) * Math.exp((-5 * i) / responseBuffer.length);
              }
              this.responseBuffer = responseBuffer;

              this.isInitialized = true;
            } catch (error) {
              console.warn("Error initializing audio:", error);
            }
          }

          async playSound(buffer, volume = 0.3) {
            if (!this.isInitialized || !this.audioContext || !buffer) return;

            try {
              const source = this.audioContext.createBufferSource();
              const gainNode = this.audioContext.createGain();

              source.buffer = buffer;
              gainNode.gain.value = volume * this.volume;

              source.connect(gainNode);
              gainNode.connect(this.audioContext.destination);

              source.start(0);
              gainNode.gain.exponentialRampToValueAtTime(
                0.001,
                this.audioContext.currentTime + 2.0
              );
            } catch (error) {
              console.warn("Error playing sound:", error);
            }
          }

          async startBellSequence() {
            if (this.isPlaying) return;

            if (this.audioContext?.state === "suspended") {
              await this.audioContext.resume();
            }

            this.isPlaying = true;
            await this.playSound(this.bellBuffer);
            this.scheduleNextBell();
          }

          async scheduleNextBell() {
            if (!this.isPlaying) return;

            this.loopTimeout = setTimeout(async () => {
              if (this.isPlaying) {
                await this.playSound(this.bellBuffer, 0.15);
                this.scheduleNextBell();
              }
            }, 3000);
          }

          stopBellSequence() {
            this.isPlaying = false;
            if (this.loopTimeout) {
              clearTimeout(this.loopTimeout);
              this.loopTimeout = null;
            }
          }

          async playResponseSound() {
            await this.playSound(this.responseBuffer, 0.2);
          }

          setVolume(volume) {
            this.volume = volume;
          }

          mute() {
            this.volume = 0;
            localStorage.setItem("soundEnabled", "off");
          }

          unmute() {
            this.volume = 0.3;
            localStorage.setItem("soundEnabled", "on");
          }
        }

        const soundManager = new SoundManager();

        class ConversationManager {
          constructor() {
            this.conversationHistory = [];
            this.cachedGuid = localStorage.getItem("userGuid");
            this.guidHistory = JSON.parse(
              localStorage.getItem("guidHistory") || "[]"
            );
            this.loadHistory();
            this.initializeGuidHandling();
            
            // Add property to track current branch
            this.currentBranch = 'main';
          }

          initializeGuidHandling() {
            const resetButton = document.getElementById("reset-guid");
            const dropdown = document.getElementById("guid-dropdown");
            const createGuidButton = document.getElementById("create-guid");
            const createGuidModal =
              document.getElementById("create-guid-modal");
            const modalCancel = document.getElementById("modal-cancel");
            const modalCreate = document.getElementById("modal-create");
            const guidNameInput = document.getElementById("guid-name");

            if (this.cachedGuid) {
              resetButton.style.display = "flex";
              if (this.conversationHistory.length === 0) {
                this.addMessage("user", this.cachedGuid);
              }
            }

            this.updateGuidDropdown();

            // Event listeners for GUID creation
            createGuidButton.addEventListener("click", () => {
              createGuidModal.style.display = "flex";
              guidNameInput.focus();
            });

            modalCancel.addEventListener("click", () => {
              createGuidModal.style.display = "none";
              guidNameInput.value = "";
            });

            modalCreate.addEventListener("click", () => {
              const name = guidNameInput.value.trim();
              const newGuid = this.generateGuid();

              // Add to history
              this.guidHistory.unshift({
                guid: newGuid,
                name: name,
                timestamp: new Date().toISOString(),
              });

              // Switch to the new GUID
              this.switchToGuid(newGuid);

              // Update localStorage
              localStorage.setItem(
                "guidHistory",
                JSON.stringify(this.guidHistory)
              );

              // Close modal and reset
              createGuidModal.style.display = "none";
              guidNameInput.value = "";
            });

            // Close modal if clicking outside
            createGuidModal.addEventListener("click", (e) => {
              if (e.target === createGuidModal) {
                createGuidModal.style.display = "none";
                guidNameInput.value = "";
              }
            });

            resetButton.addEventListener("click", (e) => {
              e.stopPropagation();
              dropdown.classList.toggle("show");
            });

            document.addEventListener("click", (e) => {
              if (
                !dropdown.contains(e.target) &&
                !resetButton.contains(e.target)
              ) {
                dropdown.classList.remove("show");
              }
            });

            // Set up GUID import/export handlers
            document
              .getElementById("export-guids")
              .addEventListener("click", () => this.exportGuids());
            document
              .getElementById("import-guids")
              .addEventListener("click", () => this.importGuids());
            document
              .getElementById("guid-file-input")
              .addEventListener("change", (event) => {
                const file = event.target.files[0];
                if (file) {
                  this.handleGuidFileImport(file);
                }
                event.target.value = "";
              });
          }

          generateGuid() {
            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(
              /[xy]/g,
              function (c) {
                const r = (Math.random() * 16) | 0;
                const v = c === "x" ? r : (r & 0x3) | 0x8;
                return v.toString(16);
              }
            );
          }

          exportGuids() {
            const exportData = {
              cachedGuid: this.cachedGuid,
              guidHistory: this.guidHistory,
              timestamp: new Date().toISOString(),
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], {
              type: "application/json",
            });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `guid-export-${new Date().toISOString()}.json`;
            document.body.appendChild(a);
            a.click();
            URL.revokeObjectURL(url);
            document.body.removeChild(a);
          }

          importGuids() {
            document.getElementById("guid-file-input").click();
          }

          handleGuidFileImport(file) {
            if (!file || file.type !== "application/json") {
              alert("Please select a valid JSON file");
              return;
            }

            const reader = new FileReader();
            reader.onload = (event) => {
              try {
                const importedData = JSON.parse(event.target.result);

                if (
                  !importedData.guidHistory ||
                  !Array.isArray(importedData.guidHistory)
                ) {
                  throw new Error("Invalid GUID history format");
                }

                this.guidHistory = importedData.guidHistory;
                localStorage.setItem(
                  "guidHistory",
                  JSON.stringify(this.guidHistory)
                );

                if (importedData.cachedGuid) {
                  this.cachedGuid = importedData.cachedGuid;
                  localStorage.setItem("userGuid", importedData.cachedGuid);
                  document.getElementById("reset-guid").style.display = "flex";
                }

                this.updateGuidDropdown();
                alert("GUIDs imported successfully!");
              } catch (error) {
                alert(`Error importing GUIDs: ${error.message}`);
              }
            };

            reader.readAsText(file);
          }

          loadHistory() {
            try {
              const saved = localStorage.getItem("chatHistory");
              if (saved) {
                this.conversationHistory = JSON.parse(saved);
                this.displayLoadedHistory();
              }
            } catch (e) {
              console.warn("Failed to load chat history:", e);
              localStorage.removeItem("chatHistory");
            }
          }

          displayLoadedHistory() {
            document.getElementById("chat-messages").innerHTML = "";
            this.conversationHistory.forEach((msg) => {
              this.addMessage(msg.role, msg.content, false, msg.branch);
            });
          }

          saveHistory() {
            try {
              localStorage.setItem(
                "chatHistory",
                JSON.stringify(this.conversationHistory)
              );
            } catch (e) {
              console.warn("Failed to save chat history:", e);
            }
          }

          updateGuidDropdown() {
            const dropdown = document.getElementById("guid-dropdown");
            dropdown.innerHTML = "";

            this.guidHistory.forEach((guidInfo, index) => {
              const item = document.createElement("div");
              item.className = "guid-dropdown-item";
              item.innerHTML = `
                <div class="guid-info">
                  ${
                    guidInfo.name
                      ? `<div class="guid-name">${guidInfo.name}</div>`
                      : ""
                  }
                  <div class="guid">${guidInfo.guid}</div>
                  <div class="timestamp">${new Date(
                    guidInfo.timestamp
                  ).toLocaleString()}</div>
                </div>
                <div class="actions">
                  <button class="edit-name" title="Edit name">
                    <i class="fas fa-edit"></i>
                  </button>
                  <button class="delete-guid" title="Remove from history">
                    <i class="fas fa-times"></i>
                  </button>
                </div>
              `;

              item.addEventListener("click", (e) => {
                if (
                  !e.target.closest(".edit-name") &&
                  !e.target.closest(".delete-guid")
                ) {
                  this.switchToGuid(guidInfo.guid);
                  dropdown.classList.remove("show");
                }
              });

              item
                .querySelector(".edit-name")
                .addEventListener("click", (e) => {
                  e.stopPropagation();
                  const newName = prompt(
                    "Enter a name for this GUID:",
                    guidInfo.name || ""
                  );
                  if (newName !== null) {
                    this.updateGuidName(index, newName);
                  }
                });

              item
                .querySelector(".delete-guid")
                .addEventListener("click", (e) => {
                  e.stopPropagation();
                  this.removeGuidFromHistory(index);
                });

              dropdown.appendChild(item);
            });

            if (this.cachedGuid) {
              const clearItem = document.createElement("div");
              clearItem.className = "guid-dropdown-item";
              clearItem.innerHTML = `
                <div class="guid-info">
                  <div class="guid">Clear current GUID</div>
                </div>
              `;
              clearItem.addEventListener("click", () => {
                this.clearCurrentGuid();
                dropdown.classList.remove("show");
              });
              dropdown.appendChild(clearItem);
            }
          }

          updateGuidName(index, newName) {
            this.guidHistory[index].name = newName.trim();
            localStorage.setItem(
              "guidHistory",
              JSON.stringify(this.guidHistory)
            );
            this.updateGuidDropdown();
          }

          removeGuidFromHistory(index) {
            const guidToRemove = this.guidHistory[index].guid;
            this.guidHistory.splice(index, 1);
            localStorage.setItem(
              "guidHistory",
              JSON.stringify(this.guidHistory)
            );

            if (this.cachedGuid === guidToRemove) {
              this.clearCurrentGuid();
            }

            this.updateGuidDropdown();
          }

          switchToGuid(guid) {
            this.cachedGuid = guid;
            localStorage.setItem("userGuid", guid);
            document.getElementById("reset-guid").style.display = "flex";

            this.clear();
            this.addMessage("user", guid);
            this.addGuidToHistory(guid);
          }

          clearCurrentGuid() {
            if (
              confirm(
                "Are you sure you want to clear the current GUID? This will clear your conversation history."
              )
            ) {
              localStorage.removeItem("userGuid");
              this.cachedGuid = null;
              this.clear();

              this.updateGuidDropdown();
            }
          }

          addGuidToHistory(guid) {
            const existingIndex = this.guidHistory.findIndex(
              (item) => item.guid === guid
            );
            if (existingIndex !== -1) {
              this.guidHistory[existingIndex].timestamp =
                new Date().toISOString();

              if (!this.guidHistory[existingIndex].name) {
                const name = prompt(
                  "Would you like to give this GUID a name for easier identification?"
                );
                if (name) {
                  this.guidHistory[existingIndex].name = name.trim();
                }
              }
            } else {
              const name = prompt(
                "Would you like to give this GUID a name for easier identification?"
              );
              this.guidHistory.push({
                guid: guid,
                name: name ? name.trim() : "",
                timestamp: new Date().toISOString(),
              });
            }

            this.guidHistory.sort(
              (a, b) => new Date(b.timestamp) - new Date(a.timestamp)
            );
            localStorage.setItem(
              "guidHistory",
              JSON.stringify(this.guidHistory)
            );
            this.updateGuidDropdown();
          }

          addMessage(role, content, shouldSave = true, branch = null) {
            const guidPattern =
              /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
            if (role === "user" && guidPattern.test(content)) {
              this.cachedGuid = content;
              localStorage.setItem("userGuid", content);
              document.getElementById("reset-guid").style.display = "flex";
              this.addGuidToHistory(content);
            }

            const messageDiv = document.createElement("div");
            messageDiv.className = `message ${role}-message`;

            // Save the branch info if we're on a branch
            const actualBranch = branch || this.currentBranch;
            
            if (role === "system") {
              this.formatSystemMessage(messageDiv, content);
            } else {
              this.formatUserOrAssistantMessage(messageDiv, role, content, actualBranch);
            }

            document.getElementById("chat-messages").appendChild(messageDiv);

            if (shouldSave) {
              // Store message with branch info
              this.conversationHistory.push({ 
                role, 
                content,
                branch: actualBranch !== 'main' ? actualBranch : undefined
              });
              this.saveHistory();
            }

            this.scrollToBottom();

            if (role === "assistant" || role === "system") {
              messageDiv.querySelectorAll("pre code").forEach((block) => {
                hljs.highlightBlock(block);
              });
            }
          }

          formatSystemMessage(messageDiv, content) {
            // Check if there are multiple agent calls in the content
            const multipleAgentCalls =
              content.includes("Performed ") &&
              content.indexOf("Performed ", content.indexOf("Performed ") + 1) >
                0;

            if (multipleAgentCalls) {
              // Split content at each "Performed" occurrence, but keep "Performed" with each part
              const parts = content.split(/(?=Performed )/);

              // Create a header div to explain multiple agent calls
              const headerDiv = document.createElement("div");
              headerDiv.className = "agent-header";
              headerDiv.innerHTML = `
                <span>Multiple agents were called</span>
                <button class="expand-button" title="Show details">
                  <i class="fas fa-chevron-down"></i>
                </button>
              `;

              const contentDiv = document.createElement("div");
              contentDiv.className = "message-content";

              // Process each agent call separately
              parts.forEach((part, index) => {
                if (part.trim()) {
                  const agentMatch = part.match(/^Performed (\w+)/);
                  if (agentMatch) {
                    const agentName = agentMatch[1];
                    const agentSection = document.createElement("div");
                    agentSection.className = "agent-section";
                    agentSection.innerHTML = `
                      <div class="agent-subheader">
                        <span>Agent #${
                          index + 1
                        }: <span class="agent-name">${agentName}</span></span>
                      </div>
                      <div class="agent-content">
                        ${formatResponse(
                          part.replace(/^Performed \w+ and got result: /, "")
                        )}
                      </div>
                    `;
                    contentDiv.appendChild(agentSection);

                    // Add separation between agent calls
                    if (index < parts.length - 1) {
                      const separator = document.createElement("hr");
                      separator.style.margin = "15px 0";
                      separator.style.opacity = "0.3";
                      contentDiv.appendChild(separator);
                    }
                  }
                }
              });

              messageDiv.appendChild(headerDiv);
              messageDiv.appendChild(contentDiv);

              headerDiv.addEventListener(
                "click",
                this.handleSystemMessageExpand
              );
            } else {
              // Original single agent handling
              const agentMatch = content.match(/^Performed (\w+)/);
              if (agentMatch) {
                const agentName = agentMatch[1];
                const headerDiv = document.createElement("div");
                headerDiv.className = "agent-header";
                headerDiv.innerHTML = `
                  <span>Performed <span class="agent-name">${agentName}</span></span>
                  <button class="expand-button" title="Show details">
                    <i class="fas fa-chevron-down"></i>
                  </button>
                `;

                const contentDiv = document.createElement("div");
                contentDiv.className = "message-content";
                contentDiv.innerHTML = formatResponse(
                  content.replace(/^Performed \w+ and got result: /, "")
                );

                messageDiv.appendChild(headerDiv);
                messageDiv.appendChild(contentDiv);

                headerDiv.addEventListener(
                  "click",
                  this.handleSystemMessageExpand
                );
              } else {
                messageDiv.innerHTML = formatResponse(content);
              }
            }
          }

          formatUserOrAssistantMessage(messageDiv, role, content, branch) {
            const senderName = role === "user" ? "You" : assistantName;
            const senderLabel = document.createElement("div");
            senderLabel.className = "sender-label";
            senderLabel.style.cssText =
              "font-size: 12px; margin-bottom: 4px; opacity: 0.7;";
            
            // Add branch indicator if not on main branch
            if (branch && branch !== 'main') {
              senderLabel.innerHTML = `
                ${senderName}
                <span class="branch-indicator">${branch}</span>
              `;
            } else {
              senderLabel.textContent = senderName;
            }

            const contentDiv = document.createElement("div");
            contentDiv.className = "message-content";
            contentDiv.innerHTML =
              role === "user" ? content : formatResponse(content);

            messageDiv.appendChild(senderLabel);
            messageDiv.appendChild(contentDiv);
          }

          handleSystemMessageExpand(e) {
            if (e.target.closest(".expand-button") || e.target === this) {
              const messageDiv = this.closest(".message");
              messageDiv.classList.toggle("expanded");
              const icon = this.querySelector(".expand-button i");
              icon.classList.toggle("fa-chevron-down");
              icon.classList.toggle("fa-chevron-up");
              e.stopPropagation();
            }
          }

          scrollToBottom(immediate = false) {
            const chatMessages = document.getElementById("chat-messages");
            chatMessages.scrollTo({
              top: chatMessages.scrollHeight,
              behavior: immediate ? "auto" : "smooth",
            });
          }

          clear() {
            document.getElementById("chat-messages").innerHTML = "";
            this.conversationHistory = [];
            localStorage.removeItem("chatHistory");
          }
          
          // New method to set the current branch
          setCurrentBranch(branchId) {
            this.currentBranch = branchId;
          }
        }

        function formatResponse(text) {
          if (text.trim().startsWith("{") || text.trim().startsWith("[")) {
            try {
              const json = JSON.parse(text);
              return `<pre><code class="json">${JSON.stringify(
                json,
                null,
                2
              )}</code></pre>`;
            } catch (e) {
              console.warn("JSON parsing failed:", e);
            }
          }

          const codeBlocks = [];
          text = text.replace(
            /```(\w+)?\n([\s\S]+?)```/g,
            (match, language, code) => {
              codeBlocks.push({
                language: language || "",
                code: code.trim(),
              });
              return `__CODE_BLOCK_${codeBlocks.length - 1}__`;
            }
          );

          text = text.replace(/\(URL: ([^)]+)\)/g, (match, url) => {
            return `<a href="../${url.trim()}" target="_blank" rel="noopener noreferrer">${url.trim()}</a>`;
          });

          text = text.replace(
            /\[([^\]]+)\]\(([^)]+)\)/g,
            (match, text, url) => {
              const decodedUrl = url.replace(/&amp;/g, "&");
              return `<a href="../${decodedUrl}" target="_blank" rel="noopener noreferrer">${text}</a>`;
            }
          );

          text = text.replace(
            /(?<!["\'])(https?:\/\/[^\s<>]+)(?![^<]*>|[^<>]*<\/)/g,
            '<a href="../$1" target="_blank" rel="noopener noreferrer">$1</a>'
          );

          text = text
            .replace(/`([^`]+)`/g, "<code>$1</code>")
            .replace(/\*\*([^*]+)\*\*/g, "<strong>$1</strong>")
            .replace(/\*([^*]+)\*/g, "<em>$1</em>")
            .replace(/\n/g, "<br>");

          text = text.replace(/__CODE_BLOCK_(\d+)__/g, (match, index) => {
            const block = codeBlocks[parseInt(index)];
            const highlightedCode = hljs.highlightAuto(
              block.code,
              block.language ? [block.language] : undefined
            ).value;
            return `<pre><code class="${block.language}">${highlightedCode}</code></pre>`;
          });

          return text;
        }

        const conversationManager = new ConversationManager();

        class TimeMachine {
          constructor(conversationManager) {
            this.conversationManager = conversationManager;
            this.currentIndex = 0;
            this.isPlaying = false;
            this.playbackSpeed = 1000; // milliseconds between messages
            this.playbackTimeout = null;
            this.originalHistory = []; // New properties for branching
            this.branches = {}; // Stores all conversation branches
            this.activeBranchId = 'main'; // Default main branch
            this.branchPoints = []; // Points where branches were created
            this.inReplayMode = false;

            this.initializeControls();
            this.loadBranches();
          }

          initializeControls() {
            const timeMachineToggle = document.getElementById("time-machine-toggle");
            const controls = document.getElementById("time-machine-controls");
            const stepBackward = document.getElementById("step-backward");
            const stepForward = document.getElementById("step-forward");
            const playPause = document.getElementById("play-pause");
            const progress = document.getElementById("progress");
            const branchButton = document.getElementById("branch-button");
            const branchSwitcher = document.getElementById("branch-switcher");

            timeMachineToggle.addEventListener("click", () => {
              controls.classList.toggle("visible");
              if (!controls.classList.contains("visible")) {
                this.stopPlayback();
                document.body.classList.remove("replay-mode");
                this.inReplayMode = false;
                this.exitReplayMode();
              } else {
                document.body.classList.add("replay-mode");
                this.inReplayMode = true;
                this.startReplay();
              }
            });

            stepBackward.addEventListener("click", () => this.stepBackward());
            stepForward.addEventListener("click", () => this.stepForward());
            playPause.addEventListener("click", () => this.togglePlayback());
            branchButton.addEventListener("click", () => this.createBranchFromCurrentPoint());
            branchSwitcher.addEventListener("click", () => this.toggleBranchDropdown());
          }

          // Toggle branch dropdown visibility
          toggleBranchDropdown() {
            const dropdown = document.getElementById("branch-dropdown");
            const isVisible = dropdown.classList.contains("show");
            
            if (isVisible) {
              dropdown.classList.remove("show");
            } else {
              this.updateBranchDropdown();
              dropdown.classList.add("show");
            }
          }

          // Update branch dropdown content
          updateBranchDropdown() {
            const dropdown = document.getElementById("branch-dropdown");
            dropdown.innerHTML = "";
            
            const branchIds = Object.keys(this.branches);
            
            if (branchIds.length === 0) {
              const emptyItem = document.createElement("div");
              emptyItem.className = "branch-dropdown-item";
              emptyItem.textContent = "No branches created yet";
              dropdown.appendChild(emptyItem);
              return;
            }
            
            branchIds.forEach(branchId => {
              const branch = this.branches[branchId];
              const item = document.createElement("div");
              item.className = "branch-dropdown-item";
              
              if (branchId === this.activeBranchId) {
                item.classList.add("active");
              }
              
              // Show branch info
              item.innerHTML = `
                <div class="branch-info">
                  <div class="branch-name">${branch.name || branchId}</div>
                  <div class="branch-details">
                    ${branch.timestamp ? new Date(branch.timestamp).toLocaleString() : ''}
                    (${branch.messages.length} messages)
                  </div>
                </div>
                <div class="branch-actions">
                  <button class="delete-branch" title="Delete branch">
                    <i class="fas fa-trash"></i>
                  </button>
                </div>
              `;
              
              // Switch to branch on click
              item.addEventListener("click", (e) => {
                if (!e.target.closest(".delete-branch")) {
                  this.switchToBranch(branchId);
                  dropdown.classList.remove("show");
                }
              });
              
              // Delete branch
              item.querySelector(".delete-branch").addEventListener("click", (e) => {
                e.stopPropagation();
                this.deleteBranch(branchId);
              });
              
              dropdown.appendChild(item);
            });
          }

          // Switch to a different branch
          switchToBranch(branchId) {
            if (!this.branches[branchId]) return;
            
            this.activeBranchId = branchId;
            
            // Load branch messages and display them
            if (this.inReplayMode) {
              // In replay mode, just show the messages up to current index
              this.originalHistory = [...this.branches[branchId].messages];
              document.getElementById("chat-messages").innerHTML = "";
              
              // Reset current index and replay
              this.currentIndex = 0;
              this.updateControls();
              
              // Show messages up to current index
              for (let i = 0; i < this.currentIndex; i++) {
                const message = this.originalHistory[i];
                this.addMessageWithAnimation(message.role, message.content, message.branch);
              }
            } else {
              // Not in replay mode, load the branch into the conversation manager
              this.conversationManager.conversationHistory = [...this.branches[branchId].messages];
              this.conversationManager.setCurrentBranch(branchId);
              this.conversationManager.saveHistory();
              this.conversationManager.displayLoadedHistory();
            }
            
            // Update branch dropdown if visible
            if (document.getElementById("branch-dropdown").classList.contains("show")) {
              this.updateBranchDropdown();
            }
          }

          // Delete a branch
          deleteBranch(branchId) {
            if (branchId === 'main') {
              alert("Cannot delete the main branch");
              return;
            }
            
            if (!confirm(`Are you sure you want to delete branch "${this.branches[branchId].name || branchId}"?`)) {return;
            }
            
            delete this.branches[branchId];
            
            // If we deleted the active branch, switch to main
            if (branchId === this.activeBranchId) {
              this.switchToBranch('main');
            }
            
            // Update branch dropdown if visible
            if (document.getElementById("branch-dropdown").classList.contains("show")) {
              this.updateBranchDropdown();
            }
            
            // Save branches to localStorage
            this.saveBranches();
          }

          // Create a new branch from the current point in the conversation
          createBranchFromCurrentPoint() {
            if (this.currentIndex === 0) {
              alert("Cannot branch from the beginning of the conversation");
              return;
            }

            const branchName = prompt("Enter a name for this branch:", 
              `Branch at message ${this.currentIndex}`);
            
            if (branchName === null) return; // User cancelled
            
            // Generate unique branch ID
            const branchId = 'branch_' + Date.now();
            
            // Store branch point information
            this.branchPoints.push({
              sourceIndex: this.currentIndex,
              sourceBranch: this.activeBranchId,
              newBranchId: branchId
            });
            
            // Create a new branch with messages up to current index
            this.branches[branchId] = {
              name: branchName,
              parentBranch: this.activeBranchId,
              parentIndex: this.currentIndex,
              timestamp: new Date().toISOString(),
              messages: this.originalHistory.slice(0, this.currentIndex)
            };
            
            // Switch to the new branch
            this.activeBranchId = branchId;
            
            // Exit replay mode to allow typing a new message
            this.exitReplayMode();
            
            // Update branch dropdown if visible
            if (document.getElementById("branch-dropdown").classList.contains("show")) {
              this.updateBranchDropdown();
            }
            
            // Save branches to localStorage
            this.saveBranches();
            
            // Show confirmation to user
            alert(`Created new branch: ${branchName}\nYou can now continue the conversation from this point.`);
          }

          // Save branches to localStorage
          saveBranches() {
            try {
              localStorage.setItem('conversation_branches', JSON.stringify({
                branches: this.branches,
                activeBranchId: this.activeBranchId,
                branchPoints: this.branchPoints
              }));
            } catch (error) {
              console.warn("Failed to save branches:", error);
            }
          }

          // Load branches from localStorage
          loadBranches() {
            try {
              const savedData = localStorage.getItem('conversation_branches');
              if (savedData) {
                const parsed = JSON.parse(savedData);
                this.branches = parsed.branches || {};
                this.activeBranchId = parsed.activeBranchId || 'main';
                this.branchPoints = parsed.branchPoints || [];
                
                // Make sure main branch exists
                if (!this.branches.main) {
                  this.initializeMainBranch();
                }
                
                // Set the current branch in the conversation manager
                this.conversationManager.setCurrentBranch(this.activeBranchId);
              } else {
                this.initializeMainBranch();
              }
            } catch (error) {
              console.warn("Failed to load branches:", error);
              this.initializeMainBranch();
            }
          }

          // Initialize the main branch with current conversation
          initializeMainBranch() {
            this.branches = {
              main: {
                name: "Main Timeline",
                timestamp: new Date().toISOString(),
                messages: [...this.conversationManager.conversationHistory]
              }
            };
            this.activeBranchId = 'main';
            this.branchPoints = [];
            this.conversationManager.setCurrentBranch('main');
          }

          // Exit replay mode and set up for continuing from current point
          exitReplayMode() {
            // Only exit if in replay mode
            if (!this.inReplayMode) return;
            
            // Stop playback
            this.stopPlayback();
            document.body.classList.remove("replay-mode");
            this.inReplayMode = false;
            
            // Hide controls
            document.getElementById("time-machine-controls").classList.remove("visible");
            
            // Set conversation history to current branch up to current index
            this.conversationManager.conversationHistory = this.originalHistory.slice(0, this.currentIndex);
            this.conversationManager.setCurrentBranch(this.activeBranchId);
            this.conversationManager.saveHistory();
            
            // Update branch with current state
            this.branches[this.activeBranchId].messages = [...this.conversationManager.conversationHistory];
            this.saveBranches();
            
            // Display current messages
            this.conversationManager.displayLoadedHistory();
          }

          startReplay() {
            // Load branches if not already done
            if (Object.keys(this.branches).length === 0) {
              this.loadBranches();
            }
            
            // Store current branch messages (or initialize main branch if needed)
            if (!this.branches[this.activeBranchId]) {
              this.initializeMainBranch();
            } else {
              // Update active branch with current conversation if that's needed
              if (this.activeBranchId === 'main') {
                this.branches.main.messages = [...this.conversationManager.conversationHistory];
                this.branches.main.timestamp = new Date().toISOString();
              }
            }
            
            // Store original history from current branch
            this.originalHistory = [...this.branches[this.activeBranchId].messages];
            
            // Clear display
            document.getElementById("chat-messages").innerHTML = "";
            this.currentIndex = 0;
            this.updateControls();
          }

          stepForward() {
            if (this.currentIndex < this.originalHistory.length) {
              const message = this.originalHistory[this.currentIndex];
              this.addMessageWithAnimation(message.role, message.content, message.branch);
              this.currentIndex++;
              this.updateControls();
            }
          }

          stepBackward() {
            if (this.currentIndex > 0) {
              this.currentIndex--;
              const messages = document.getElementById("chat-messages");
              if (messages.lastChild) {
                messages.removeChild(messages.lastChild);
              }
              this.updateControls();
            }
          }

          togglePlayback() {
            const playPauseButton = document.getElementById("play-pause");
            const playIcon = playPauseButton.querySelector("i");

            if (this.isPlaying) {
              this.stopPlayback();
              playIcon.classList.replace("fa-pause", "fa-play");
            } else {
              this.startPlayback();
              playIcon.classList.replace("fa-play", "fa-pause");
            }
          }

          startPlayback() {
            this.isPlaying = true;
            this.playMessage();
          }

          stopPlayback() {
            this.isPlaying = false;
            if (this.playbackTimeout) {
              clearTimeout(this.playbackTimeout);
              this.playbackTimeout = null;
            }
          }

          playMessage() {
            if (!this.isPlaying) return;

            if (this.currentIndex < this.originalHistory.length) {
              const message = this.originalHistory[this.currentIndex];
              this.addMessageWithAnimation(message.role, message.content, message.branch);
              this.currentIndex++;
              this.updateControls();

              this.playbackTimeout = setTimeout(() => {
                this.playMessage();
              }, this.playbackSpeed);
            } else {
              this.stopPlayback();
              const playPauseButton = document.getElementById("play-pause");
              playPauseButton
                .querySelector("i")
                .classList.replace("fa-pause", "fa-play");
            }
          }

          addMessageWithAnimation(role, content, branch) {
            const messageDiv = document.createElement("div");
            messageDiv.className = `message ${role}-message replay-animation`;

            if (role === "system") {
              this.conversationManager.formatSystemMessage(messageDiv, content);
            } else {
              this.conversationManager.formatUserOrAssistantMessage(
                messageDiv,
                role,
                content,
                branch
              );
            }

            document.getElementById("chat-messages").appendChild(messageDiv);

            if (role === "assistant" || role === "system") {
              messageDiv.querySelectorAll("pre code").forEach((block) => {
                hljs.highlightBlock(block);
              });
            }

            this.conversationManager.scrollToBottom();
            return messageDiv;
          }

          updateControls() {
            const stepBackward = document.getElementById("step-backward");
            const stepForward = document.getElementById("step-forward");
            const progress = document.getElementById("progress");
            const branchButton = document.getElementById("branch-button");

            stepBackward.disabled = this.currentIndex === 0;
            stepForward.disabled = this.currentIndex >= this.originalHistory.length;
            progress.textContent = `${this.currentIndex} / ${this.originalHistory.length}`;
            
            // Enable branch button only if we're at a valid branch point (not at beginning)
            branchButton.disabled = this.currentIndex === 0;
          }
        }

        const timeMachine = new TimeMachine(conversationManager);

        class WorkflowManager {
          constructor(conversationManager) {
            this.conversationManager = conversationManager;
            this.workflowGenerator = new AgentWorkflowGenerator();
            this.currentWorkflow = null;
            this.workflowModal = document.getElementById('workflow-modal');
            
            this.initializeEvents();
          }
          
          initializeEvents() {
            // Button to open workflow modal
            document.getElementById('workflow-button').addEventListener('click', () => this.openWorkflowModal());
            
            // Tab switching in modal
            document.querySelectorAll('.workflow-tab').forEach(tab => {
              tab.addEventListener('click', () => {
                // Set active tab
                document.querySelectorAll('.workflow-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                // Show corresponding panel
                const panelId = tab.dataset.tab;
                document.querySelectorAll('.workflow-panel').forEach(p => p.classList.remove('active'));
                document.querySelector(`.workflow-panel[data-panel="${panelId}"]`).classList.add('active');
                
                // Update preview or JSON if needed
                if (panelId === 'preview') {
                  this.updatePreviewPanel();
                } else if (panelId === 'json') {
                  this.updateJsonPanel();
                }
              });
            });
            
            // Modal buttons
            document.getElementById('workflow-cancel').addEventListener('click', () => {
              this.workflowModal.style.display = 'none';
            });
            
            document.getElementById('workflow-export').addEventListener('click', () => {
              this.exportWorkflow();
            });
            
            // Close modal when clicking outside
            this.workflowModal.addEventListener('click', (event) => {
              if (event.target === this.workflowModal) {
                this.workflowModal.style.display = 'none';
              }
            });
            
            // Form field change events
            document.getElementById('workflow-name').addEventListener('input', () => {
              if (this.currentWorkflow) {
                this.currentWorkflow.name = document.getElementById('workflow-name').value;
              }
            });
            
            document.getElementById('workflow-description').addEventListener('input', () => {
              if (this.currentWorkflow) {
                this.currentWorkflow.description = document.getElementById('workflow-description').value;
              }
            });
            
            document.getElementById('workflow-nl-description').addEventListener('input', () => {
              if (this.currentWorkflow) {
                this.currentWorkflow.nlDescription = document.getElementById('workflow-nl-description').value;
              }
            });
          }
          
          openWorkflowModal() {
            // Reset modal state
            this.resetModal();
            
            // Extract agent calls and generate workflow
            const agentCalls = this.workflowGenerator.extractAgentCalls(this.conversationManager.conversationHistory);
            
            if (agentCalls.length === 0) {
              // Show message when no agents found
              document.getElementById('no-agents-message').style.display = 'block';
              document.getElementById('agent-detected-message').style.display = 'none';
              document.getElementById('workflow-export').disabled = true;
            } else {
              // Show message with agent count
              document.getElementById('no-agents-message').style.display = 'none';
              document.getElementById('agent-detected-message').style.display = 'block';
              document.getElementById('detected-agents-count').textContent = agentCalls.length;
              document.getElementById('workflow-export').disabled = false;
              
              // Generate workflow name from first user message
              let workflowName = `Workflow ${new Date().toLocaleDateString()}`;
              const firstUserMessage = this.conversationManager.conversationHistory.find(msg => msg.role === 'user');
              if (firstUserMessage && firstUserMessage.content) {
                const content = firstUserMessage.content.trim();
                if (content.length > 5 && content.length <= 50) {
                  workflowName = content;
                } else if (content.length > 50) {
                  workflowName = content.substring(0, 47) + '...';
                }
              }
              
              // Generate workflow
              this.currentWorkflow = this.workflowGenerator.generateWorkflow(
                agentCalls, 
                workflowName, 
                "Workflow generated from conversation"
              );
              
              // Update form fields
              document.getElementById('workflow-name').value = this.currentWorkflow.name;
              document.getElementById('workflow-description').value = this.currentWorkflow.description;
              document.getElementById('workflow-nl-description').value = this.currentWorkflow.nlDescription;
              
              // Update preview
              this.updatePreviewPanel();
              this.updateJsonPanel();
            }
            
            // Show modal
            this.workflowModal.style.display = 'flex';
          }
          
          resetModal() {
            // Reset tab selection
            document.querySelectorAll('.workflow-tab').forEach(t => t.classList.remove('active'));
            document.querySelector('.workflow-tab[data-tab="config"]').classList.add('active');
            
            // Reset panel visibility
            document.querySelectorAll('.workflow-panel').forEach(p => p.classList.remove('active'));
            document.querySelector('.workflow-panel[data-panel="config"]').classList.add('active');
            
            // Clear form fields
            document.getElementById('workflow-name').value = '';
            document.getElementById('workflow-description').value = '';
            document.getElementById('workflow-nl-description').value = '';
            
            // Clear preview and JSON
            document.getElementById('workflow-agent-list').innerHTML = '';
            document.getElementById('workflow-json-preview').textContent = '';
            
            // Reset current workflow
            this.currentWorkflow = null;
          }
          
          updatePreviewPanel() {
            if (!this.currentWorkflow) return;
            
            const agentList = document.getElementById('workflow-agent-list');
            agentList.innerHTML = '';
            
            this.currentWorkflow.agents.forEach((agent, index) => {
              const agentItem = document.createElement('div');
              agentItem.className = 'agent-item';
              
              // Agent header with name and type
              agentItem.innerHTML = `
                <div class="agent-item-header">
                  <div class="agent-item-title">${agent.name}</div>
                  <div class="agent-item-type">${agent.type}</div>
                </div>
                <div>${agent.description}</div>
                <div class="agent-item-command">${agent.command}</div>
              `;
              
              agentList.appendChild(agentItem);
              
              // Add connection line if not the last agent
              if (index < this.currentWorkflow.agents.length - 1) {
                const connection = document.createElement('div');
                connection.className = 'connection-line';
                connection.textContent = this.currentWorkflow.connections[index].connectionPrompt;
                agentList.appendChild(connection);
              }
            });
          }
          
          updateJsonPanel() {
            if (!this.currentWorkflow) return;
            
            // Update workflow with latest form values
            this.currentWorkflow.name = document.getElementById('workflow-name').value;
            this.currentWorkflow.description = document.getElementById('workflow-description').value;
            this.currentWorkflow.nlDescription = document.getElementById('workflow-nl-description').value;
            
            // Format and display JSON
            const jsonStr = this.workflowGenerator.exportWorkflow(this.currentWorkflow);
            document.getElementById('workflow-json-preview').textContent = jsonStr;
          }
          
          exportWorkflow() {
            if (!this.currentWorkflow) return;
            
            // Update workflow with latest form values before export
            this.currentWorkflow.name = document.getElementById('workflow-name').value;
            this.currentWorkflow.description = document.getElementById('workflow-description').value;
            this.currentWorkflow.nlDescription = document.getElementById('workflow-nl-description').value;
            
            // Generate JSON
            const jsonStr = this.workflowGenerator.exportWorkflow(this.currentWorkflow);
            
            // Create and download file
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${this.currentWorkflow.name.toLowerCase().replace(/\s+/g, '-')}-workflow.json`;
            document.body.appendChild(a);
            a.click();
            URL.revokeObjectURL(url);
            document.body.removeChild(a);
            
            // Close modal
            this.workflowModal.style.display = 'none';
          }
        }

        async function sendMessage(userInput) {
          if (!userInput.trim()) return;

          // Get the current branch ID before adding the message
          const currentBranch = timeMachine.activeBranchId;

          conversationManager.addMessage("user", userInput);
          document.getElementById("user-input").value = "";
          document.getElementById("loading").style.display = "flex";

          await soundManager.startBellSequence();

          if (!functionKey) {
            await promptForFunctionKey();
            soundManager.stopBellSequence();
            return;
          }

          try {
            const response = await fetch(azureFunctionUrl, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "x-functions-key": functionKey,
              },
              body: JSON.stringify({
                user_input: userInput,
                conversation_history: conversationManager.conversationHistory,
                user_guid: conversationManager.cachedGuid,
              }),
            });

            if (!response.ok) {
              if (response.status === 401) {
                localStorage.removeItem("functionKey");
                await promptForFunctionKey();
                soundManager.stopBellSequence();
                return;
              }
              throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            handleResponse(data, currentBranch);

            soundManager.stopBellSequence();
            await soundManager.playResponseSound();
          } catch (error) {
            handleError(error);
            soundManager.stopBellSequence();
          } finally {
            document.getElementById("loading").style.display = "none";
          }
        }

        function handleResponse(response, currentBranch) {
          const assistantResponse =
            response.assistant_response || response.text;
          conversationManager.addMessage("assistant", assistantResponse);

          // Update the branch with the new messages
          if (timeMachine.branches[currentBranch]) {
            timeMachine.branches[currentBranch].messages = [...conversationManager.conversationHistory];
            timeMachine.saveBranches();
          }

          if (response.agent_logs) {
            conversationManager.addMessage("system", response.agent_logs);
          }

          if (
            response.user_guid &&
            response.user_guid !== conversationManager.cachedGuid
          ) {
            conversationManager.cachedGuid = response.user_guid;
            localStorage.setItem("userGuid", response.user_guid);
            document.getElementById("reset-guid").style.display = "flex";
            conversationManager.addGuidToHistory(response.user_guid);
          }
        }

        function handleError(error) {
          const errorMessage = `Error: ${
            error.message || "Something went wrong. Please try again."
          }`;
          conversationManager.addMessage("system", errorMessage);
        }

        async function promptForFunctionKey() {
          const key = prompt("Please enter your function key:");
          if (key) {
            functionKey = key;
            localStorage.setItem("functionKey", key);
          }
          document.getElementById("loading").style.display = "none";
        }

        // Initialize Workflow Manager
        const workflowManager = new WorkflowManager(conversationManager);

        // Event Listeners
        document.getElementById("send-button").addEventListener("click", () => {
          const input = document.getElementById("user-input");
          sendMessage(input.value.trim());
        });

        document
          .getElementById("user-input")
          .addEventListener("keypress", (e) => {
            if (e.key === "Enter" && !e.shiftKey) {
              e.preventDefault();
              const input = e.target;
              sendMessage(input.value.trim());
            }
          });

        document.getElementById("clear-chat").addEventListener("click", () => {
          if (confirm("Are you sure you want to clear the chat history?")) {
            conversationManager.clear();
            
            // Also reset the time machine branches
            timeMachine.initializeMainBranch();
            timeMachine.saveBranches();
          }
        });

        document
          .getElementById("theme-toggle")
          .addEventListener("click", () => {
            document.body.classList.toggle("dark");

            const isDark = document.body.classList.contains("dark");
            localStorage.setItem("theme", isDark ? "dark" : "light");
            const icon = document.querySelector("#theme-toggle i");
            icon.classList.toggle("fa-sun");
            icon.classList.toggle("fa-moon");
          });

        document
          .getElementById("sound-toggle")
          .addEventListener("click", function () {
            const icon = this.querySelector("i");
            if (icon.classList.contains("fa-volume-up")) {
              icon.classList.replace("fa-volume-up", "fa-volume-mute");
              soundManager.mute();
            } else {
              icon.classList.replace("fa-volume-mute", "fa-volume-up");
              soundManager.unmute();
            }
          });

        // Mobile viewport handling
        if (/iPad|iPhone|iPod/.test(navigator.userAgent)) {
          window.visualViewport.addEventListener("resize", () => {
            document.body.style.height = `${window.visualViewport.height}px`;
            document.body.style.width = `${window.visualViewport.width}px`;
          });
        }

        // Initialize theme if previously set
        if (localStorage.getItem("theme") === "dark") {
          document.body.classList.add("dark");
          const icon = document.querySelector("#theme-toggle i");
          icon.classList.replace("fa-moon", "fa-sun");
        }

        // Initialize sound toggle state based on localStorage
        const soundToggleButton = document.getElementById("sound-toggle");
        const soundToggleIcon = soundToggleButton.querySelector("i");
        if (localStorage.getItem("soundEnabled") === "on") {
          soundToggleIcon.classList.replace("fa-volume-mute", "fa-volume-up");
        } else {
          // Sound is muted by default (already set in the HTML)
        }

        // Drop zone handling for importing conversations
        const dropZone = document.getElementById("drop-zone");
        const importChatButton = document.getElementById("import-chat");
        const chatFileInput = document.getElementById("chat-file-input");

        // Setup file import handling
        importChatButton.addEventListener("click", () => {
          chatFileInput.click();
        });

        chatFileInput.addEventListener("change", (event) => {
          const file = event.target.files[0];
          if (file) {
            handleChatFileImport(file);
          }
          event.target.value = "";
        });

        // Drop zone event handlers
        ["dragenter", "dragover", "dragleave", "drop"].forEach((eventName) => {
          document.body.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
          e.preventDefault();
          e.stopPropagation();
        }

        ["dragenter", "dragover"].forEach((eventName) => {
          document.body.addEventListener(eventName, highlight, false);
        });

        ["dragleave", "drop"].forEach((eventName) => {
          document.body.addEventListener(eventName, unhighlight, false);
        });

        function highlight() {
          dropZone.classList.add("active");
        }

        function unhighlight() {
          dropZone.classList.remove("active");
        }

        // Handle file drop
        document.body.addEventListener("drop", handleDrop, false);

        function handleDrop(e) {
          const dt = e.dataTransfer;
          const files = dt.files;

          if (files.length) {
            handleChatFileImport(files[0]);
          }
        }

        function handleChatFileImport(file) {
          if (!file || file.type !== "application/json") {
            alert("Please select a valid JSON file");
            return;
          }

          const reader = new FileReader();
          reader.onload = (event) => {
            try {
              const importedData = JSON.parse(event.target.result);
              console.log("Imported data:", importedData); // Debug log

              // Check if the file contains branch information
              if (importedData.branches && importedData.activeBranchId) {
                // Import branches data
                timeMachine.branches = importedData.branches || {};
                timeMachine.activeBranchId = importedData.activeBranchId || 'main';
                timeMachine.branchPoints = importedData.branchPoints || [];
                timeMachine.saveBranches();
                
                // Set current branch and load its conversation
                conversationManager.setCurrentBranch(timeMachine.activeBranchId);
                conversationManager.conversationHistory = [...timeMachine.branches[timeMachine.activeBranchId].messages];
                conversationManager.saveHistory();
                conversationManager.displayLoadedHistory();
                
                alert("Conversation with branches imported successfully!");
                return;
              }

              // Handle legacy format without branches
              let validConversation = null;

              // Format 1: messages array format
              if (
                importedData.messages &&
                Array.isArray(importedData.messages)
              ) {
                validConversation = importedData.messages;
              }
              // Format 2: conversation array format
              else if (
                importedData.conversation &&
                Array.isArray(importedData.conversation)
              ) {
                validConversation = importedData.conversation;
              }
              // Format 3: Direct array of messages
              else if (
                Array.isArray(importedData) &&
                importedData.length > 0 &&
                importedData[0] &&
                typeof importedData[0] === "object" &&
                (importedData[0].role || importedData[0].content)
              ) {
                validConversation = importedData;
              }

              if (!validConversation) {
                throw new Error(
                  'Could not find a valid conversation structure in the imported file. Expected "messages" or "conversation" array.'
                );
              }

              // Format validation - ensure each item has role and content
              validConversation = validConversation.filter((item) => {
                return (
                  item &&
                  typeof item === "object" &&
                  (item.role || item.sender || item.type) &&
                  (item.content || item.message || item.text)
                );
              });

              // Normalize format
              validConversation = validConversation.map((item) => ({
                role:
                  item.role ||
                  item.sender ||
                  (item.type === "human"
                    ? "user"
                    : item.type === "ai"
                    ? "assistant"
                    : item.type || "user"),
                content: item.content || item.message || item.text || "",
                branch: item.branch
              }));

              if (validConversation.length === 0) {
                throw new Error(
                  "No valid messages found in the imported conversation"
                );
              }

              // Confirm before replacing current conversation
              if (conversationManager.conversationHistory.length > 0) {
                if (
                  !confirm(
                    "This will replace your current conversation. Continue?"
                  )
                ) {
                  return;
                }
              }

              // Replace conversation history
              conversationManager.conversationHistory = validConversation;
              conversationManager.saveHistory();

              // Display the imported conversation
              conversationManager.displayLoadedHistory();

              // Extract and set GUID if available
              let guid = null;

              // Look for GUID in importedData properties
              if (importedData.guid) {
                guid = importedData.guid;
              }
              // Look for GUID in first user message
              else if (validConversation.length > 0) {
                const firstUserMessage = validConversation.find(
                  (msg) => msg.role === "user"
                );
                if (firstUserMessage) {
                  const guidPattern =
                    /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
                  if (guidPattern.test(firstUserMessage.content.trim())) {
                    guid = firstUserMessage.content.trim();
                  }
                }
              }

              if (guid) {
                conversationManager.cachedGuid = guid;
                localStorage.setItem("userGuid", guid);
                document.getElementById("reset-guid").style.display = "flex";
                conversationManager.addGuidToHistory(guid);
              }
              
              // Update main branch with imported conversation
              timeMachine.branches.main = {
                name: "Main Timeline",
                timestamp: new Date().toISOString(),
                messages: [...conversationManager.conversationHistory]
              };
              timeMachine.activeBranchId = 'main';
              timeMachine.saveBranches();

              alert("Conversation imported successfully!");
            } catch (error) {
              console.error("Import error:", error);
              alert(
                `Error importing conversation: ${error.message}\n\nMake sure the file contains a valid conversation format.`
              );
            }
          };

          reader.readAsText(file);
        }

        // Add export chat functionality
        document.getElementById("export-chat").addEventListener("click", () =>{
          if (conversationManager.conversationHistory.length === 0) {
            alert("No conversation to export");
            return;
          }

          const exportData = {
            conversation: conversationManager.conversationHistory,
            guid: conversationManager.cachedGuid,
            timestamp: new Date().toISOString(),
            appName: assistantName,
            // Include branch information
            branches: timeMachine.branches,
            activeBranchId: timeMachine.activeBranchId,
            branchPoints: timeMachine.branchPoints
          };

          const blob = new Blob([JSON.stringify(exportData, null, 2)], {
            type: "application/json",
          });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `conversation-${new Date().toISOString()}.json`;
          document.body.appendChild(a);
          a.click();
          URL.revokeObjectURL(url);
          document.body.removeChild(a);
        });

        // Make sendMessage function globally accessible for the queue system to use
        window.sendMessage = sendMessage;
        window.handleResponse = handleResponse;
        window.handleError = handleError;
      });
    </script>
  </body>
</html>