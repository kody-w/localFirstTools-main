<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BUZZSAW v3 Production Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-dark: #0a0a0f;
            --bg-panel: #1a1a24;
            --border-color: #2a2a3a;
            --text-primary: #ffffff;
            --text-secondary: #a0a0b0;
            --accent-claude: #6366f1;
            --accent-copilot: #10b981;
            --accent-gold: #fbbf24;
            --quality-high: #10b981;
            --quality-medium: #fbbf24;
            --quality-low: #ef4444;
            --shadow-glow: rgba(99, 102, 241, 0.2);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            padding: 20px;
            line-height: 1.6;
            min-height: 100vh;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px;
            background: linear-gradient(135deg, var(--bg-panel), #252538);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        .header h1 {
            font-size: 3em;
            font-weight: 900;
            letter-spacing: 3px;
            background: linear-gradient(135deg, var(--accent-claude), var(--accent-copilot));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .header-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .last-updated {
            color: var(--text-secondary);
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        button {
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        button:hover {
            background: var(--accent-claude);
            border-color: var(--accent-claude);
            box-shadow: 0 0 20px var(--shadow-glow);
        }

        button.active {
            background: var(--accent-copilot);
            border-color: var(--accent-copilot);
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }

        .metric-card {
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 24px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .metric-card:hover {
            border-color: var(--accent-claude);
            box-shadow: 0 0 24px var(--shadow-glow);
            transform: translateY(-2px);
        }

        .metric-label {
            color: var(--text-secondary);
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        .metric-value {
            font-size: 2.5em;
            font-weight: 900;
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, var(--accent-claude), var(--accent-copilot));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .metric-value.quality-high {
            color: var(--quality-high);
            -webkit-text-fill-color: var(--quality-high);
        }

        .metric-value.quality-medium {
            color: var(--quality-medium);
            -webkit-text-fill-color: var(--quality-medium);
        }

        .metric-value.quality-low {
            color: var(--quality-low);
            -webkit-text-fill-color: var(--quality-low);
        }

        .panel {
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
        }

        .panel h2 {
            margin-bottom: 20px;
            color: var(--accent-claude);
            font-size: 1.5em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        canvas {
            display: block;
            max-width: 100%;
            height: auto;
        }

        .charts-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        @media (max-width: 1024px) {
            .charts-row {
                grid-template-columns: 1fr;
            }
        }

        .game-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 16px;
            margin-top: 20px;
        }

        .game-card {
            background: linear-gradient(135deg, #1a1a24, #252538);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 16px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .game-card:hover {
            border-color: var(--accent-copilot);
            box-shadow: 0 0 16px rgba(16, 185, 129, 0.3);
            transform: translateY(-2px);
        }

        .game-title {
            font-weight: 700;
            margin-bottom: 8px;
            font-size: 1.1em;
        }

        .game-stats {
            display: flex;
            justify-content: space-between;
            font-size: 0.85em;
            color: var(--text-secondary);
            margin-bottom: 8px;
            font-family: 'Courier New', monospace;
        }

        .quality-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-weight: 700;
            font-size: 0.9em;
            font-family: 'Courier New', monospace;
        }

        .quality-badge.high {
            background: rgba(16, 185, 129, 0.2);
            color: var(--quality-high);
        }

        .quality-badge.medium {
            background: rgba(251, 191, 36, 0.2);
            color: var(--quality-medium);
        }

        .quality-badge.low {
            background: rgba(239, 68, 68, 0.2);
            color: var(--quality-low);
        }

        .checks-dots {
            display: flex;
            gap: 6px;
            margin-top: 8px;
        }

        .check-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .check-dot.pass {
            background: var(--quality-high);
            box-shadow: 0 0 8px var(--quality-high);
        }

        .check-dot.fail {
            background: var(--quality-low);
        }

        .filters {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        select {
            background: var(--bg-dark);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.9em;
        }

        .loading {
            text-align: center;
            padding: 60px;
            color: var(--text-secondary);
            font-size: 1.2em;
        }

        .error {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid var(--quality-low);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            color: var(--quality-low);
        }

        input[type="file"] {
            display: none;
        }

        .file-upload-label {
            display: inline-block;
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        .file-upload-label:hover {
            background: var(--accent-claude);
            border-color: var(--accent-claude);
            box-shadow: 0 0 20px var(--shadow-glow);
        }

        .legend {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 4px;
        }

        .tooltip {
            position: absolute;
            background: rgba(26, 26, 36, 0.95);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 1000;
            font-size: 0.85em;
            max-width: 250px;
        }

        .tooltip.show {
            opacity: 1;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .pulse {
            animation: pulse 2s ease-in-out infinite;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>BUZZSAW v3 PRODUCTION DASHBOARD</h1>
        <div class="header-controls">
            <div class="last-updated" id="lastUpdated">No data loaded</div>
            <button id="loadBtn">Load Stats</button>
            <label for="fileInput" class="file-upload-label">Upload JSON</label>
            <input type="file" id="fileInput" accept=".json">
            <button id="autoRefreshBtn">Auto-Refresh: OFF</button>
            <button id="clearCacheBtn">Clear Cache</button>
        </div>
    </div>

    <div id="metricsContainer"></div>
    <div id="chartsContainer"></div>
    <div id="gameGridContainer"></div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        // Global state
        let statsData = null;
        let autoRefreshInterval = null;
        let autoRefreshEnabled = false;

        // Canvas chart utilities
        class ChartRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.width = canvas.width;
                this.height = canvas.height;
            }

            clear() {
                this.ctx.clearRect(0, 0, this.width, this.height);
            }

            drawPieChart(data, colors, labels, title) {
                this.clear();
                const centerX = this.width / 2;
                const centerY = this.height / 2 - 20;
                const radius = Math.min(this.width, this.height) / 2 - 60;

                let total = data.reduce((sum, val) => sum + val, 0);
                let startAngle = -Math.PI / 2;

                // Draw title
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = 'bold 18px sans-serif';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(title, centerX, 30);

                // Draw slices
                data.forEach((value, i) => {
                    const sliceAngle = (value / total) * 2 * Math.PI;
                    const endAngle = startAngle + sliceAngle;

                    this.ctx.fillStyle = colors[i];
                    this.ctx.beginPath();
                    this.ctx.moveTo(centerX, centerY);
                    this.ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                    this.ctx.closePath();
                    this.ctx.fill();

                    // Draw percentage label
                    const midAngle = startAngle + sliceAngle / 2;
                    const labelX = centerX + Math.cos(midAngle) * (radius * 0.6);
                    const labelY = centerY + Math.sin(midAngle) * (radius * 0.6);
                    const percentage = ((value / total) * 100).toFixed(1);

                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = 'bold 14px monospace';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(`${percentage}%`, labelX, labelY);

                    startAngle = endAngle;
                });

                // Draw legend
                const legendY = this.height - 40;
                const legendSpacing = this.width / labels.length;
                labels.forEach((label, i) => {
                    const x = legendSpacing * i + legendSpacing / 2;

                    this.ctx.fillStyle = colors[i];
                    this.ctx.fillRect(x - 30, legendY, 20, 12);

                    this.ctx.fillStyle = '#a0a0b0';
                    this.ctx.font = '12px sans-serif';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(label, x + 20, legendY + 10);
                });
            }

            drawBarChart(data, labels, colors, title, yAxisLabel) {
                this.clear();
                const padding = 60;
                const barWidth = (this.width - padding * 2) / data.length - 10;
                const maxValue = Math.max(...data);
                const chartHeight = this.height - padding * 2;

                // Draw title
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = 'bold 18px sans-serif';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(title, this.width / 2, 30);

                // Draw Y-axis label
                this.ctx.save();
                this.ctx.translate(20, this.height / 2);
                this.ctx.rotate(-Math.PI / 2);
                this.ctx.fillStyle = '#a0a0b0';
                this.ctx.font = '12px sans-serif';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(yAxisLabel, 0, 0);
                this.ctx.restore();

                // Draw bars
                data.forEach((value, i) => {
                    const barHeight = (value / maxValue) * chartHeight;
                    const x = padding + i * (barWidth + 10);
                    const y = this.height - padding - barHeight;

                    // Bar with gradient
                    const gradient = this.ctx.createLinearGradient(x, y, x, y + barHeight);
                    gradient.addColorStop(0, colors[i % colors.length]);
                    gradient.addColorStop(1, colors[i % colors.length] + '80');
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(x, y, barWidth, barHeight);

                    // Value label
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = 'bold 12px monospace';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(this.formatNumber(value), x + barWidth / 2, y - 5);

                    // X-axis label
                    this.ctx.fillStyle = '#a0a0b0';
                    this.ctx.font = '11px sans-serif';
                    this.ctx.fillText(labels[i], x + barWidth / 2, this.height - padding + 20);
                });

                // Draw axes
                this.ctx.strokeStyle = '#2a2a3a';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(padding, this.height - padding);
                this.ctx.lineTo(this.width - padding, this.height - padding);
                this.ctx.stroke();
            }

            drawLineChart(xLabels, datasets, title, yLabel) {
                this.clear();
                const padding = 60;
                const chartWidth = this.width - padding * 2;
                const chartHeight = this.height - padding * 2;
                const maxY = Math.max(...datasets.flatMap(d => d.data));
                const stepX = chartWidth / (xLabels.length - 1);

                // Draw title
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = 'bold 18px sans-serif';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(title, this.width / 2, 30);

                // Draw axes
                this.ctx.strokeStyle = '#2a2a3a';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(padding, padding);
                this.ctx.lineTo(padding, this.height - padding);
                this.ctx.lineTo(this.width - padding, this.height - padding);
                this.ctx.stroke();

                // Draw Y-axis label
                this.ctx.save();
                this.ctx.translate(20, this.height / 2);
                this.ctx.rotate(-Math.PI / 2);
                this.ctx.fillStyle = '#a0a0b0';
                this.ctx.font = '12px sans-serif';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(yLabel, 0, 0);
                this.ctx.restore();

                // Draw datasets
                datasets.forEach((dataset, idx) => {
                    this.ctx.strokeStyle = dataset.color;
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();

                    dataset.data.forEach((value, i) => {
                        const x = padding + i * stepX;
                        const y = this.height - padding - (value / maxY) * chartHeight;

                        if (i === 0) {
                            this.ctx.moveTo(x, y);
                        } else {
                            this.ctx.lineTo(x, y);
                        }

                        // Draw point
                        this.ctx.fillStyle = dataset.color;
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, 4, 0, Math.PI * 2);
                        this.ctx.fill();
                    });

                    this.ctx.stroke();
                });

                // Draw X-axis labels
                this.ctx.fillStyle = '#a0a0b0';
                this.ctx.font = '11px sans-serif';
                this.ctx.textAlign = 'center';
                xLabels.forEach((label, i) => {
                    const x = padding + i * stepX;
                    this.ctx.fillText(label, x, this.height - padding + 20);
                });

                // Draw legend
                const legendY = 50;
                datasets.forEach((dataset, i) => {
                    const x = this.width - 150;
                    const y = legendY + i * 25;

                    this.ctx.fillStyle = dataset.color;
                    this.ctx.fillRect(x, y, 20, 12);

                    this.ctx.fillStyle = '#a0a0b0';
                    this.ctx.font = '12px sans-serif';
                    this.ctx.textAlign = 'left';
                    this.ctx.fillText(dataset.label, x + 30, y + 10);
                });
            }

            drawHistogram(buckets, counts, colors, title, xLabel, yLabel) {
                this.clear();
                const padding = 60;
                const barWidth = (this.width - padding * 2) / buckets.length - 5;
                const maxCount = Math.max(...counts);
                const chartHeight = this.height - padding * 2;

                // Draw title
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = 'bold 18px sans-serif';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(title, this.width / 2, 30);

                // Draw bars
                buckets.forEach((bucket, i) => {
                    const barHeight = (counts[i] / maxCount) * chartHeight;
                    const x = padding + i * (barWidth + 5);
                    const y = this.height - padding - barHeight;

                    this.ctx.fillStyle = colors[i];
                    this.ctx.fillRect(x, y, barWidth, barHeight);

                    // Count label
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = 'bold 12px monospace';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(counts[i], x + barWidth / 2, y - 5);

                    // Bucket label
                    this.ctx.fillStyle = '#a0a0b0';
                    this.ctx.font = '11px sans-serif';
                    this.ctx.fillText(bucket, x + barWidth / 2, this.height - padding + 20);
                });

                // Target line at 80 score
                const targetY = this.height - padding - (16 / maxCount) * chartHeight; // Assuming bucket 80-100 is index 4
                this.ctx.strokeStyle = '#fbbf24';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.moveTo(padding, targetY);
                this.ctx.lineTo(this.width - padding, targetY);
                this.ctx.stroke();
                this.ctx.setLineDash([]);

                this.ctx.fillStyle = '#fbbf24';
                this.ctx.font = '11px sans-serif';
                this.ctx.textAlign = 'right';
                this.ctx.fillText('Target', this.width - padding - 5, targetY - 5);
            }

            drawScatterPlot(points, title, xLabel, yLabel, targetZone) {
                this.clear();
                const padding = 60;
                const chartWidth = this.width - padding * 2;
                const chartHeight = this.height - padding * 2;

                const maxX = Math.max(...points.map(p => p.x));
                const maxY = Math.max(...points.map(p => p.y));

                // Draw title
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = 'bold 18px sans-serif';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(title, this.width / 2, 30);

                // Draw axes
                this.ctx.strokeStyle = '#2a2a3a';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(padding, padding);
                this.ctx.lineTo(padding, this.height - padding);
                this.ctx.lineTo(this.width - padding, this.height - padding);
                this.ctx.stroke();

                // Draw target zone
                if (targetZone) {
                    const zoneX = padding + (targetZone.minX / maxX) * chartWidth;
                    const zoneY = this.height - padding - (targetZone.maxY / maxY) * chartHeight;
                    const zoneWidth = ((targetZone.maxX - targetZone.minX) / maxX) * chartWidth;
                    const zoneHeight = ((targetZone.maxY - targetZone.minY) / maxY) * chartHeight;

                    this.ctx.fillStyle = 'rgba(16, 185, 129, 0.1)';
                    this.ctx.strokeStyle = 'rgba(16, 185, 129, 0.4)';
                    this.ctx.lineWidth = 2;
                    this.ctx.fillRect(zoneX, zoneY, zoneWidth, zoneHeight);
                    this.ctx.strokeRect(zoneX, zoneY, zoneWidth, zoneHeight);
                }

                // Draw points
                points.forEach(point => {
                    const x = padding + (point.x / maxX) * chartWidth;
                    const y = this.height - padding - (point.y / maxY) * chartHeight;

                    this.ctx.fillStyle = point.color || '#6366f1';
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 5, 0, Math.PI * 2);
                    this.ctx.fill();

                    // Highlight outliers
                    const isOutlier = targetZone && (
                        point.x < targetZone.minX || point.x > targetZone.maxX ||
                        point.y < targetZone.minY || point.y > targetZone.maxY
                    );

                    if (isOutlier) {
                        this.ctx.strokeStyle = '#ef4444';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, 8, 0, Math.PI * 2);
                        this.ctx.stroke();
                    }
                });

                // Draw axis labels
                this.ctx.fillStyle = '#a0a0b0';
                this.ctx.font = '12px sans-serif';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(xLabel, this.width / 2, this.height - 20);

                this.ctx.save();
                this.ctx.translate(20, this.height / 2);
                this.ctx.rotate(-Math.PI / 2);
                this.ctx.fillText(yLabel, 0, 0);
                this.ctx.restore();
            }

            formatNumber(num) {
                if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
                if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
                return num.toString();
            }
        }

        // Data loading functions
        async function loadStatsFromURL() {
            try {
                const response = await fetch('buzzsaw-stats.json');
                if (!response.ok) throw new Error('Failed to fetch');
                const data = await response.json();
                return data;
            } catch (error) {
                console.log('Could not fetch stats.json:', error.message);
                return null;
            }
        }

        function loadStatsFromLocalStorage() {
            try {
                const cached = localStorage.getItem('buzzsaw-stats');
                if (cached) {
                    return JSON.parse(cached);
                }
            } catch (error) {
                console.error('Error loading from localStorage:', error);
            }
            return null;
        }

        function saveStatsToLocalStorage(data) {
            try {
                localStorage.setItem('buzzsaw-stats', JSON.stringify(data));
            } catch (error) {
                console.error('Error saving to localStorage:', error);
            }
        }

        function clearCache() {
            localStorage.removeItem('buzzsaw-stats');
            alert('Cache cleared!');
        }

        // Rendering functions
        function renderMetrics(data) {
            const container = document.getElementById('metricsContainer');
            const summary = data.summary;

            const qualityClass = summary.avg_quality_score >= 80 ? 'quality-high' :
                                summary.avg_quality_score >= 60 ? 'quality-medium' : 'quality-low';

            container.innerHTML = `
                <div class="metrics-grid">
                    <div class="metric-card">
                        <div class="metric-label">Total Games</div>
                        <div class="metric-value">${summary.total_games}</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Total Lines</div>
                        <div class="metric-value">${summary.total_lines.toLocaleString()}</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Total Size</div>
                        <div class="metric-value">${summary.total_size_mb} MB</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Avg Quality</div>
                        <div class="metric-value ${qualityClass}">${summary.avg_quality_score}</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Copilot Delegation</div>
                        <div class="metric-value">${(summary.delegation_ratio * 100).toFixed(1)}%</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Waves</div>
                        <div class="metric-value">${summary.waves_completed}</div>
                    </div>
                </div>
            `;
        }

        function renderCharts(data) {
            const container = document.getElementById('chartsContainer');

            container.innerHTML = `
                <div class="charts-row">
                    <div class="panel">
                        <h2>Token Usage Breakdown</h2>
                        <canvas id="tokenPieChart" width="500" height="400"></canvas>
                    </div>
                    <div class="panel">
                        <h2>Tokens per Wave</h2>
                        <canvas id="tokenBarChart" width="500" height="400"></canvas>
                    </div>
                </div>
                <div class="panel">
                    <h2>Production Timeline</h2>
                    <canvas id="timelineChart" width="1000" height="400"></canvas>
                </div>
                <div class="charts-row">
                    <div class="panel">
                        <h2>Quality Distribution</h2>
                        <canvas id="qualityHistogram" width="500" height="400"></canvas>
                    </div>
                    <div class="panel">
                        <h2>Size Analysis</h2>
                        <canvas id="sizeScatter" width="500" height="400"></canvas>
                    </div>
                </div>
            `;

            // Token pie chart
            const pieCanvas = document.getElementById('tokenPieChart');
            const pieChart = new ChartRenderer(pieCanvas);
            pieChart.drawPieChart(
                [data.token_breakdown.claude_code_orchestration, data.token_breakdown.copilot_cli_generation],
                ['#6366f1', '#10b981'],
                ['Claude Code', 'Copilot CLI'],
                'Token Distribution'
            );

            // Tokens per wave bar chart
            const barCanvas = document.getElementById('tokenBarChart');
            const barChart = new ChartRenderer(barCanvas);
            const waveTokens = data.waves.map(w => w.total_size * 4); // Rough estimate
            const waveLabels = data.waves.map(w => w.name);
            barChart.drawBarChart(
                waveTokens,
                waveLabels,
                ['#6366f1', '#10b981', '#fbbf24', '#ef4444'],
                'Tokens per Wave',
                'Tokens'
            );

            // Timeline chart
            const timelineCanvas = document.getElementById('timelineChart');
            const timelineChart = new ChartRenderer(timelineCanvas);

            let cumulative = 0;
            const cumulativeGames = data.waves.map(w => {
                cumulative += w.games;
                return cumulative;
            });

            const avgQualityPerWave = data.waves.map((w, idx) => {
                const waveGames = data.games.slice(idx * 3, (idx + 1) * 3); // Rough distribution
                const avgQ = waveGames.reduce((sum, g) => sum + g.quality_score, 0) / waveGames.length || 0;
                return avgQ;
            });

            timelineChart.drawLineChart(
                waveLabels,
                [
                    { label: 'Cumulative Games', data: cumulativeGames, color: '#6366f1' },
                    { label: 'Avg Quality', data: avgQualityPerWave, color: '#10b981' }
                ],
                'Production Timeline',
                'Count / Score'
            );

            // Quality histogram
            const histCanvas = document.getElementById('qualityHistogram');
            const histChart = new ChartRenderer(histCanvas);

            const buckets = ['0-20', '20-40', '40-60', '60-80', '80-100'];
            const counts = [0, 0, 0, 0, 0];
            data.games.forEach(g => {
                const score = g.quality_score;
                if (score < 20) counts[0]++;
                else if (score < 40) counts[1]++;
                else if (score < 60) counts[2]++;
                else if (score < 80) counts[3]++;
                else counts[4]++;
            });

            histChart.drawHistogram(
                buckets,
                counts,
                ['#ef4444', '#f97316', '#fbbf24', '#10b981', '#059669'],
                'Quality Score Distribution',
                'Score Range',
                'Game Count'
            );

            // Size scatter plot
            const scatterCanvas = document.getElementById('sizeScatter');
            const scatterChart = new ChartRenderer(scatterCanvas);

            const points = data.games.map(g => ({
                x: g.size_bytes / 1024, // KB
                y: g.lines,
                color: g.quality_score >= 80 ? '#10b981' : g.quality_score >= 60 ? '#fbbf24' : '#ef4444'
            }));

            scatterChart.drawScatterPlot(
                points,
                'File Size vs Line Count',
                'Size (KB)',
                'Lines',
                { minX: 50, maxX: 120, minY: 1500, maxY: 3000 }
            );
        }

        function renderGameGrid(data) {
            const container = document.getElementById('gameGridContainer');

            container.innerHTML = `
                <div class="panel">
                    <h2>Game Quality Grid</h2>
                    <div class="filters">
                        <select id="sortSelect">
                            <option value="name">Sort by Name</option>
                            <option value="score">Sort by Quality</option>
                            <option value="size">Sort by Size</option>
                            <option value="date">Sort by Date</option>
                        </select>
                        <select id="filterSelect">
                            <option value="all">All Games</option>
                            <option value="high">Quality 80+</option>
                            <option value="medium">Quality 60-79</option>
                            <option value="low">Quality <60</option>
                        </select>
                    </div>
                    <div class="game-grid" id="gameGrid"></div>
                </div>
            `;

            renderGameCards(data.games);

            document.getElementById('sortSelect').addEventListener('change', (e) => {
                const sorted = sortGames(data.games, e.target.value);
                renderGameCards(sorted);
            });

            document.getElementById('filterSelect').addEventListener('change', (e) => {
                const filtered = filterGames(data.games, e.target.value);
                renderGameCards(filtered);
            });
        }

        function renderGameCards(games) {
            const grid = document.getElementById('gameGrid');

            grid.innerHTML = games.map(game => {
                const qualityClass = game.quality_score >= 80 ? 'high' :
                                    game.quality_score >= 60 ? 'medium' : 'low';

                const checks = Object.values(game.checks);
                const checkDots = checks.map(pass =>
                    `<div class="check-dot ${pass ? 'pass' : 'fail'}"></div>`
                ).join('');

                return `
                    <div class="game-card">
                        <div class="game-title">${game.title}</div>
                        <div class="game-stats">
                            <span>${(game.size_bytes / 1024).toFixed(1)} KB</span>
                            <span>${game.lines.toLocaleString()} lines</span>
                        </div>
                        <div class="game-stats">
                            <span class="quality-badge ${qualityClass}">${game.quality_score}</span>
                            <span>${game.created}</span>
                        </div>
                        <div class="checks-dots">${checkDots}</div>
                    </div>
                `;
            }).join('');
        }

        function sortGames(games, sortBy) {
            const sorted = [...games];
            switch (sortBy) {
                case 'name':
                    return sorted.sort((a, b) => a.title.localeCompare(b.title));
                case 'score':
                    return sorted.sort((a, b) => b.quality_score - a.quality_score);
                case 'size':
                    return sorted.sort((a, b) => b.size_bytes - a.size_bytes);
                case 'date':
                    return sorted.sort((a, b) => b.created.localeCompare(a.created));
                default:
                    return sorted;
            }
        }

        function filterGames(games, filter) {
            switch (filter) {
                case 'high':
                    return games.filter(g => g.quality_score >= 80);
                case 'medium':
                    return games.filter(g => g.quality_score >= 60 && g.quality_score < 80);
                case 'low':
                    return games.filter(g => g.quality_score < 60);
                default:
                    return games;
            }
        }

        function updateLastUpdated(timestamp) {
            const elem = document.getElementById('lastUpdated');
            const date = new Date(timestamp);
            elem.textContent = `Last updated: ${date.toLocaleString()}`;
        }

        async function loadAndRenderStats() {
            let data = await loadStatsFromURL();

            if (!data) {
                data = loadStatsFromLocalStorage();
            }

            if (!data) {
                document.getElementById('metricsContainer').innerHTML = `
                    <div class="error">
                        <h3>No data loaded</h3>
                        <p>Click "Load Stats" to fetch buzzsaw-stats.json or "Upload JSON" to load a file.</p>
                    </div>
                `;
                return;
            }

            statsData = data;
            saveStatsToLocalStorage(data);

            updateLastUpdated(data.generated);
            renderMetrics(data);
            renderCharts(data);
            renderGameGrid(data);
        }

        function toggleAutoRefresh() {
            autoRefreshEnabled = !autoRefreshEnabled;
            const btn = document.getElementById('autoRefreshBtn');

            if (autoRefreshEnabled) {
                btn.textContent = 'Auto-Refresh: ON';
                btn.classList.add('active');
                autoRefreshInterval = setInterval(loadAndRenderStats, 10000);
            } else {
                btn.textContent = 'Auto-Refresh: OFF';
                btn.classList.remove('active');
                if (autoRefreshInterval) {
                    clearInterval(autoRefreshInterval);
                    autoRefreshInterval = null;
                }
            }
        }

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    statsData = data;
                    saveStatsToLocalStorage(data);
                    updateLastUpdated(data.generated);
                    renderMetrics(data);
                    renderCharts(data);
                    renderGameGrid(data);
                } catch (error) {
                    alert('Error parsing JSON file: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        // Event listeners
        document.getElementById('loadBtn').addEventListener('click', loadAndRenderStats);
        document.getElementById('autoRefreshBtn').addEventListener('click', toggleAutoRefresh);
        document.getElementById('clearCacheBtn').addEventListener('click', clearCache);
        document.getElementById('fileInput').addEventListener('change', handleFileUpload);

        // Initialize
        loadAndRenderStats();
    </script>
</body>
</html>
