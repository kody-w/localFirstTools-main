<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="P2P AirDrop Killer - Peer-to-peer file transfer with no server, WebRTC powered, end-to-end encrypted">
    <meta name="theme-color" content="#0a0a0f">
    <meta name="color-scheme" content="dark light">
    <title>P2P Drop - Serverless File Transfer</title>
    <style>
        :root {
            --bg-primary: #0a0a0f;
            --bg-secondary: #12121a;
            --bg-tertiary: #1a1a25;
            --text-primary: #ffffff;
            --text-secondary: #a0a0b0;
            --accent: #6366f1;
            --accent-hover: #818cf8;
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
            --border: #2a2a3a;
        }

        [data-theme="light"] {
            --bg-primary: #f8fafc;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f1f5f9;
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --accent: #4f46e5;
            --accent-hover: #6366f1;
            --border: #e2e8f0;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.6;
        }

        .app-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 0;
            border-bottom: 1px solid var(--border);
            margin-bottom: 30px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo-icon {
            width: 48px;
            height: 48px;
            background: linear-gradient(135deg, var(--accent), #a855f7);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }

        .logo h1 {
            font-size: 24px;
            font-weight: 700;
        }

        .logo span {
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 400;
        }

        .header-controls {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .theme-toggle, .data-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .theme-toggle:hover, .data-btn:hover {
            background: var(--accent);
            border-color: var(--accent);
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: var(--bg-tertiary);
            border-radius: 20px;
            font-size: 14px;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--text-secondary);
            animation: pulse 2s infinite;
        }

        .status-dot.connected {
            background: var(--success);
        }

        .status-dot.connecting {
            background: var(--warning);
        }

        .status-dot.error {
            background: var(--error);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }

        @media (max-width: 900px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 24px;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .panel-title {
            font-size: 18px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .panel-title-icon {
            width: 32px;
            height: 32px;
            background: var(--accent);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .mode-tabs {
            display: flex;
            background: var(--bg-tertiary);
            border-radius: 8px;
            padding: 4px;
            margin-bottom: 20px;
        }

        .mode-tab {
            flex: 1;
            padding: 10px 20px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .mode-tab.active {
            background: var(--accent);
            color: white;
        }

        .room-section {
            text-align: center;
            padding: 20px 0;
        }

        .room-code {
            font-size: 32px;
            font-weight: 700;
            letter-spacing: 8px;
            color: var(--accent);
            margin: 20px 0;
            font-family: 'Monaco', 'Menlo', monospace;
        }

        .qr-container {
            background: white;
            padding: 20px;
            border-radius: 12px;
            display: inline-block;
            margin: 20px 0;
        }

        #qrCanvas {
            display: block;
        }

        .btn {
            background: var(--accent);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn:hover {
            background: var(--accent-hover);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--border);
        }

        .btn-success {
            background: var(--success);
        }

        .drop-zone {
            border: 2px dashed var(--border);
            border-radius: 12px;
            padding: 60px 40px;
            text-align: center;
            transition: all 0.3s;
            cursor: pointer;
            margin: 20px 0;
        }

        .drop-zone:hover, .drop-zone.dragover {
            border-color: var(--accent);
            background: rgba(99, 102, 241, 0.1);
        }

        .drop-zone-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }

        .drop-zone h3 {
            font-size: 18px;
            margin-bottom: 8px;
        }

        .drop-zone p {
            color: var(--text-secondary);
            font-size: 14px;
        }

        .file-input {
            display: none;
        }

        .file-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .file-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            margin-bottom: 8px;
        }

        .file-icon {
            width: 40px;
            height: 40px;
            background: var(--accent);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .file-info {
            flex: 1;
            min-width: 0;
        }

        .file-name {
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .file-size {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .file-progress {
            width: 100%;
            height: 4px;
            background: var(--border);
            border-radius: 2px;
            margin-top: 6px;
            overflow: hidden;
        }

        .file-progress-bar {
            height: 100%;
            background: var(--accent);
            border-radius: 2px;
            transition: width 0.3s;
        }

        .file-progress-bar.complete {
            background: var(--success);
        }

        .file-status {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .file-actions {
            display: flex;
            gap: 8px;
        }

        .file-action-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 4px;
            font-size: 16px;
        }

        .file-action-btn:hover {
            color: var(--accent);
        }

        .signaling-section {
            margin-top: 20px;
        }

        .signal-textarea {
            width: 100%;
            min-height: 120px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            color: var(--text-primary);
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
            resize: vertical;
            margin: 10px 0;
        }

        .signal-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .message-section {
            margin-top: 20px;
        }

        .message-input-container {
            display: flex;
            gap: 10px;
        }

        .message-input {
            flex: 1;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            color: var(--text-primary);
            font-size: 14px;
        }

        .messages-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .message-item {
            padding: 10px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            margin-bottom: 8px;
        }

        .message-item.sent {
            background: rgba(99, 102, 241, 0.2);
            margin-left: 20%;
        }

        .message-item.received {
            margin-right: 20%;
        }

        .message-time {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 4px;
        }

        .instructions {
            background: var(--bg-tertiary);
            border-radius: 8px;
            padding: 16px;
            margin-top: 20px;
        }

        .instructions h4 {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .instructions ol {
            padding-left: 20px;
            color: var(--text-secondary);
            font-size: 14px;
        }

        .instructions li {
            margin-bottom: 6px;
        }

        .history-section {
            margin-top: 30px;
        }

        .history-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            margin-bottom: 8px;
        }

        .history-direction {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        .history-direction.sent {
            background: rgba(99, 102, 241, 0.2);
            color: var(--accent);
        }

        .history-direction.received {
            background: rgba(16, 185, 129, 0.2);
            color: var(--success);
        }

        .history-info {
            flex: 1;
        }

        .history-name {
            font-weight: 500;
        }

        .history-meta {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .encryption-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            background: rgba(16, 185, 129, 0.2);
            color: var(--success);
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-top: 20px;
        }

        .stat-item {
            background: var(--bg-tertiary);
            padding: 16px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--accent);
        }

        .stat-label {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 4px;
        }

        .speed-indicator {
            font-size: 14px;
            color: var(--success);
            margin-left: 8px;
        }

        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            padding: 16px 24px;
            border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s;
            z-index: 1000;
        }

        .toast.show {
            transform: translateY(0);
            opacity: 1;
        }

        .toast.success {
            border-left: 4px solid var(--success);
        }

        .toast.error {
            border-left: 4px solid var(--error);
        }

        .hidden {
            display: none !important;
        }

        /* Mobile responsiveness */
        @media (max-width: 600px) {
            .app-container {
                padding: 12px;
            }

            header {
                flex-direction: column;
                gap: 16px;
                text-align: center;
            }

            .header-controls {
                flex-wrap: wrap;
                justify-content: center;
            }

            .panel {
                padding: 16px;
            }

            .room-code {
                font-size: 24px;
                letter-spacing: 4px;
            }

            .drop-zone {
                padding: 40px 20px;
            }

            .stats {
                grid-template-columns: 1fr;
            }

            .signal-actions {
                flex-direction: column;
            }

            .signal-actions .btn {
                width: 100%;
                justify-content: center;
            }
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }
    </style>
</head>
<body>
    <div class="app-container">
        <header>
            <div class="logo">
                <div class="logo-icon">P</div>
                <div>
                    <h1>P2P Drop</h1>
                    <span>Serverless File Transfer</span>
                </div>
            </div>
            <div class="header-controls">
                <div class="connection-status">
                    <div class="status-dot" id="statusDot"></div>
                    <span id="statusText">Disconnected</span>
                </div>
                <span class="encryption-badge">
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                        <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
                    </svg>
                    E2E Encrypted
                </span>
                <button class="theme-toggle" onclick="toggleTheme()">
                    <span id="themeIcon">Light</span>
                </button>
                <button class="data-btn" onclick="exportData()">Export</button>
                <button class="data-btn" onclick="document.getElementById('importFile').click()">Import</button>
                <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importData(event)">
            </div>
        </header>

        <div class="main-grid">
            <!-- Sender Panel -->
            <div class="panel">
                <div class="panel-header">
                    <div class="panel-title">
                        <div class="panel-title-icon">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
                                <path d="M22 2L11 13"></path>
                                <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                            </svg>
                        </div>
                        Send Files
                    </div>
                </div>

                <div class="mode-tabs">
                    <button class="mode-tab active" onclick="setMode('sender')">Create Room</button>
                    <button class="mode-tab" onclick="setMode('joiner')">Join Room</button>
                </div>

                <!-- Sender Mode -->
                <div id="senderMode">
                    <div class="room-section">
                        <p style="color: var(--text-secondary); margin-bottom: 10px;">Share this room code or QR</p>
                        <div class="room-code" id="roomCode">------</div>
                        <div class="qr-container">
                            <canvas id="qrCanvas" width="150" height="150"></canvas>
                        </div>
                        <div style="margin-top: 10px;">
                            <button class="btn" onclick="generateNewRoom()">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M23 4v6h-6"></path>
                                    <path d="M1 20v-6h6"></path>
                                    <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
                                </svg>
                                New Room
                            </button>
                        </div>
                    </div>

                    <div class="signaling-section">
                        <h4 style="margin-bottom: 10px; color: var(--text-secondary); font-size: 14px;">Your Offer (copy and send to peer)</h4>
                        <textarea class="signal-textarea" id="localOffer" readonly placeholder="Generating offer..."></textarea>
                        <div class="signal-actions">
                            <button class="btn btn-secondary" onclick="copyOffer()">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                                </svg>
                                Copy Offer
                            </button>
                        </div>
                        <h4 style="margin: 20px 0 10px; color: var(--text-secondary); font-size: 14px;">Paste Answer (from peer)</h4>
                        <textarea class="signal-textarea" id="remoteAnswer" placeholder="Paste the answer from your peer here..."></textarea>
                        <button class="btn btn-success" onclick="handleAnswer()">Connect</button>
                    </div>
                </div>

                <!-- Joiner Mode -->
                <div id="joinerMode" class="hidden">
                    <div class="signaling-section">
                        <h4 style="margin-bottom: 10px; color: var(--text-secondary); font-size: 14px;">Paste Offer (from sender)</h4>
                        <textarea class="signal-textarea" id="remoteOffer" placeholder="Paste the offer from the sender here..."></textarea>
                        <button class="btn" onclick="handleOffer()">Generate Answer</button>

                        <h4 style="margin: 20px 0 10px; color: var(--text-secondary); font-size: 14px;">Your Answer (copy and send back)</h4>
                        <textarea class="signal-textarea" id="localAnswer" readonly placeholder="Answer will appear here..."></textarea>
                        <div class="signal-actions">
                            <button class="btn btn-secondary" onclick="copyAnswer()">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                                </svg>
                                Copy Answer
                            </button>
                        </div>
                    </div>
                </div>

                <div class="instructions">
                    <h4>
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="10"></circle>
                            <line x1="12" y1="16" x2="12" y2="12"></line>
                            <line x1="12" y1="8" x2="12.01" y2="8"></line>
                        </svg>
                        How it works
                    </h4>
                    <ol>
                        <li>Sender creates a room and copies the offer</li>
                        <li>Send the offer to the receiver (via any messaging app)</li>
                        <li>Receiver pastes offer and generates an answer</li>
                        <li>Send the answer back to the sender</li>
                        <li>Sender pastes answer and connects</li>
                        <li>Transfer files directly - no server involved!</li>
                    </ol>
                </div>
            </div>

            <!-- Receiver Panel -->
            <div class="panel">
                <div class="panel-header">
                    <div class="panel-title">
                        <div class="panel-title-icon" style="background: var(--success);">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                <polyline points="7 10 12 15 17 10"></polyline>
                                <line x1="12" y1="15" x2="12" y2="3"></line>
                            </svg>
                        </div>
                        File Transfer
                    </div>
                </div>

                <div class="drop-zone" id="dropZone" onclick="document.getElementById('fileInput').click()">
                    <div class="drop-zone-icon">
                        <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="var(--accent)" stroke-width="2">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                            <polyline points="17 8 12 3 7 8"></polyline>
                            <line x1="12" y1="3" x2="12" y2="15"></line>
                        </svg>
                    </div>
                    <h3>Drop files here</h3>
                    <p>or click to browse</p>
                </div>
                <input type="file" id="fileInput" class="file-input" multiple onchange="handleFileSelect(event)">

                <div class="file-list" id="fileList"></div>

                <div id="transferActions" class="hidden" style="margin-top: 15px; text-align: center;">
                    <button class="btn btn-success" onclick="sendFiles()">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M22 2L11 13"></path>
                            <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                        </svg>
                        Send Files
                    </button>
                </div>

                <div class="message-section">
                    <h4 style="margin-bottom: 10px; font-size: 14px;">Send Message</h4>
                    <div class="message-input-container">
                        <input type="text" class="message-input" id="messageInput" placeholder="Type a message..." onkeypress="if(event.key==='Enter')sendMessage()">
                        <button class="btn" onclick="sendMessage()">Send</button>
                    </div>
                    <div class="messages-list" id="messagesList"></div>
                </div>

                <div class="stats">
                    <div class="stat-item">
                        <div class="stat-value" id="statFilesSent">0</div>
                        <div class="stat-label">Files Sent</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="statFilesReceived">0</div>
                        <div class="stat-label">Files Received</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="statTotalData">0 MB</div>
                        <div class="stat-label">Data Transferred</div>
                    </div>
                </div>

                <div class="history-section">
                    <h4 style="margin-bottom: 15px; display: flex; align-items: center; gap: 8px;">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="10"></circle>
                            <polyline points="12 6 12 12 16 14"></polyline>
                        </svg>
                        Transfer History
                        <button class="btn btn-secondary" style="margin-left: auto; padding: 6px 12px; font-size: 12px;" onclick="clearHistory()">Clear</button>
                    </h4>
                    <div id="historyList"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="toast" id="toast"></div>

    <script>
        // Application State
        const APP_NAME = 'p2p-drop';
        let appData = JSON.parse(localStorage.getItem(APP_NAME) || '{"history":[],"stats":{"sent":0,"received":0,"totalBytes":0},"theme":"dark"}');

        // WebRTC State
        let peerConnection = null;
        let dataChannel = null;
        let encryptionKey = null;
        let selectedFiles = [];
        let currentMode = 'sender';
        let isConnected = false;

        // Transfer State
        let incomingFiles = {};
        let resumableTransfers = {};

        // Constants
        const CHUNK_SIZE = 16384; // 16KB chunks
        const ICE_SERVERS = [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' },
            { urls: 'stun:stun2.l.google.com:19302' }
        ];

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            applyTheme();
            updateStats();
            renderHistory();
            generateNewRoom();
            setupDropZone();
        });

        // Theme Management
        function toggleTheme() {
            appData.theme = appData.theme === 'dark' ? 'light' : 'dark';
            applyTheme();
            saveData();
        }

        function applyTheme() {
            document.documentElement.setAttribute('data-theme', appData.theme);
            document.getElementById('themeIcon').textContent = appData.theme === 'dark' ? 'Light' : 'Dark';
        }

        // Data Persistence
        function saveData() {
            localStorage.setItem(APP_NAME, JSON.stringify(appData));
        }

        function exportData() {
            const dataStr = JSON.stringify(appData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${APP_NAME}-data-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
            showToast('Data exported successfully', 'success');
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const imported = JSON.parse(e.target.result);
                    appData = { ...appData, ...imported };
                    saveData();
                    updateStats();
                    renderHistory();
                    applyTheme();
                    showToast('Data imported successfully', 'success');
                } catch (error) {
                    showToast('Invalid JSON file', 'error');
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        // Room Code Generation
        function generateRoomCode() {
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
            let code = '';
            for (let i = 0; i < 6; i++) {
                code += chars[Math.floor(Math.random() * chars.length)];
            }
            return code;
        }

        // QR Code Generation (Simple Canvas-based)
        function generateQRCode(data) {
            const canvas = document.getElementById('qrCanvas');
            const ctx = canvas.getContext('2d');
            const size = 150;
            const moduleCount = 25;
            const moduleSize = size / moduleCount;

            // Simple hash-based pattern (visual representation only)
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, size, size);

            // Generate a deterministic pattern based on data
            const hash = simpleHash(data);
            ctx.fillStyle = 'black';

            // Position patterns (corners)
            drawFinderPattern(ctx, 0, 0, moduleSize * 7);
            drawFinderPattern(ctx, size - moduleSize * 7, 0, moduleSize * 7);
            drawFinderPattern(ctx, 0, size - moduleSize * 7, moduleSize * 7);

            // Data modules based on hash
            for (let y = 0; y < moduleCount; y++) {
                for (let x = 0; x < moduleCount; x++) {
                    if (isInFinderPattern(x, y, moduleCount)) continue;

                    const idx = y * moduleCount + x;
                    if ((hash[idx % hash.length].charCodeAt(0) + idx) % 3 === 0) {
                        ctx.fillRect(x * moduleSize, y * moduleSize, moduleSize - 1, moduleSize - 1);
                    }
                }
            }

            // Add text in center
            ctx.fillStyle = 'white';
            ctx.fillRect(size/2 - 30, size/2 - 10, 60, 20);
            ctx.fillStyle = 'black';
            ctx.font = 'bold 12px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(data.substring(0, 6), size/2, size/2 + 4);
        }

        function drawFinderPattern(ctx, x, y, size) {
            ctx.fillStyle = 'black';
            ctx.fillRect(x, y, size, size);
            ctx.fillStyle = 'white';
            ctx.fillRect(x + size/7, y + size/7, size * 5/7, size * 5/7);
            ctx.fillStyle = 'black';
            ctx.fillRect(x + size * 2/7, y + size * 2/7, size * 3/7, size * 3/7);
        }

        function isInFinderPattern(x, y, count) {
            return (x < 8 && y < 8) ||
                   (x >= count - 8 && y < 8) ||
                   (x < 8 && y >= count - 8);
        }

        function simpleHash(str) {
            let hash = '';
            for (let i = 0; i < 100; i++) {
                let val = 0;
                for (let j = 0; j < str.length; j++) {
                    val = ((val << 5) - val + str.charCodeAt(j) + i) | 0;
                }
                hash += Math.abs(val).toString(36);
            }
            return hash;
        }

        // WebRTC Setup
        async function generateNewRoom() {
            const roomCode = generateRoomCode();
            document.getElementById('roomCode').textContent = roomCode;
            generateQRCode(roomCode);

            // Generate encryption key from room code
            encryptionKey = await generateEncryptionKey(roomCode);

            // Create new peer connection
            await createPeerConnection();

            // Create offer
            await createOffer();
        }

        async function generateEncryptionKey(seed) {
            const encoder = new TextEncoder();
            const data = encoder.encode(seed + 'p2p-drop-salt');
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            return await crypto.subtle.importKey(
                'raw',
                hashBuffer,
                { name: 'AES-GCM' },
                false,
                ['encrypt', 'decrypt']
            );
        }

        async function createPeerConnection() {
            if (peerConnection) {
                peerConnection.close();
            }

            peerConnection = new RTCPeerConnection({ iceServers: ICE_SERVERS });

            peerConnection.onicecandidate = (event) => {
                if (!event.candidate) {
                    // ICE gathering complete
                    const offer = document.getElementById('localOffer');
                    const answer = document.getElementById('localAnswer');

                    if (currentMode === 'sender' && peerConnection.localDescription) {
                        offer.value = btoa(JSON.stringify(peerConnection.localDescription));
                    } else if (currentMode === 'joiner' && peerConnection.localDescription) {
                        answer.value = btoa(JSON.stringify(peerConnection.localDescription));
                    }
                }
            };

            peerConnection.onconnectionstatechange = () => {
                updateConnectionStatus(peerConnection.connectionState);
            };

            peerConnection.ondatachannel = (event) => {
                setupDataChannel(event.channel);
            };
        }

        function setupDataChannel(channel) {
            dataChannel = channel;
            dataChannel.binaryType = 'arraybuffer';

            dataChannel.onopen = () => {
                isConnected = true;
                updateConnectionStatus('connected');
                showToast('Connected! You can now transfer files.', 'success');
            };

            dataChannel.onclose = () => {
                isConnected = false;
                updateConnectionStatus('disconnected');
            };

            dataChannel.onerror = (error) => {
                console.error('Data channel error:', error);
                updateConnectionStatus('error');
            };

            dataChannel.onmessage = handleDataChannelMessage;
        }

        async function createOffer() {
            // Create data channel (only initiator creates it)
            const channel = peerConnection.createDataChannel('fileTransfer', {
                ordered: true
            });
            setupDataChannel(channel);

            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);

            updateConnectionStatus('waiting');
        }

        async function handleOffer() {
            const offerText = document.getElementById('remoteOffer').value.trim();
            if (!offerText) {
                showToast('Please paste an offer first', 'error');
                return;
            }

            try {
                const offer = JSON.parse(atob(offerText));

                // Extract room code from offer for encryption
                const roomCode = document.getElementById('roomCode').textContent;
                encryptionKey = await generateEncryptionKey(roomCode);

                await createPeerConnection();
                await peerConnection.setRemoteDescription(offer);

                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);

                updateConnectionStatus('connecting');
                showToast('Answer generated! Copy and send it back.', 'success');
            } catch (error) {
                console.error('Error handling offer:', error);
                showToast('Invalid offer format', 'error');
            }
        }

        async function handleAnswer() {
            const answerText = document.getElementById('remoteAnswer').value.trim();
            if (!answerText) {
                showToast('Please paste an answer first', 'error');
                return;
            }

            try {
                const answer = JSON.parse(atob(answerText));
                await peerConnection.setRemoteDescription(answer);
                updateConnectionStatus('connecting');
            } catch (error) {
                console.error('Error handling answer:', error);
                showToast('Invalid answer format', 'error');
            }
        }

        function updateConnectionStatus(state) {
            const dot = document.getElementById('statusDot');
            const text = document.getElementById('statusText');

            dot.className = 'status-dot';

            switch (state) {
                case 'connected':
                    dot.classList.add('connected');
                    text.textContent = 'Connected';
                    break;
                case 'connecting':
                    dot.classList.add('connecting');
                    text.textContent = 'Connecting...';
                    break;
                case 'waiting':
                    dot.classList.add('connecting');
                    text.textContent = 'Waiting for peer...';
                    break;
                case 'error':
                case 'failed':
                    dot.classList.add('error');
                    text.textContent = 'Connection failed';
                    break;
                default:
                    text.textContent = 'Disconnected';
            }
        }

        // Mode Switching
        function setMode(mode) {
            currentMode = mode;
            document.querySelectorAll('.mode-tab').forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');

            document.getElementById('senderMode').classList.toggle('hidden', mode !== 'sender');
            document.getElementById('joinerMode').classList.toggle('hidden', mode !== 'joiner');
        }

        // Clipboard Functions
        function copyOffer() {
            const offer = document.getElementById('localOffer').value;
            if (offer) {
                navigator.clipboard.writeText(offer);
                showToast('Offer copied to clipboard!', 'success');
            }
        }

        function copyAnswer() {
            const answer = document.getElementById('localAnswer').value;
            if (answer) {
                navigator.clipboard.writeText(answer);
                showToast('Answer copied to clipboard!', 'success');
            }
        }

        // File Handling
        function setupDropZone() {
            const dropZone = document.getElementById('dropZone');

            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('dragover');
            });

            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('dragover');
            });

            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('dragover');
                handleFiles(e.dataTransfer.files);
            });
        }

        function handleFileSelect(event) {
            handleFiles(event.target.files);
        }

        function handleFiles(fileList) {
            for (const file of fileList) {
                if (!selectedFiles.find(f => f.name === file.name && f.size === file.size)) {
                    selectedFiles.push(file);
                }
            }
            renderFileList();
            document.getElementById('transferActions').classList.toggle('hidden', selectedFiles.length === 0);
        }

        function renderFileList() {
            const container = document.getElementById('fileList');
            container.innerHTML = selectedFiles.map((file, index) => `
                <div class="file-item" id="file-${index}">
                    <div class="file-icon">
                        ${getFileIcon(file.type)}
                    </div>
                    <div class="file-info">
                        <div class="file-name">${file.name}</div>
                        <div class="file-size">${formatFileSize(file.size)}</div>
                        <div class="file-progress">
                            <div class="file-progress-bar" id="progress-${index}" style="width: 0%"></div>
                        </div>
                        <div class="file-status" id="status-${index}">Ready to send</div>
                    </div>
                    <div class="file-actions">
                        <button class="file-action-btn" onclick="removeFile(${index})" title="Remove">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <line x1="18" y1="6" x2="6" y2="18"></line>
                                <line x1="6" y1="6" x2="18" y2="18"></line>
                            </svg>
                        </button>
                    </div>
                </div>
            `).join('');
        }

        function removeFile(index) {
            selectedFiles.splice(index, 1);
            renderFileList();
            document.getElementById('transferActions').classList.toggle('hidden', selectedFiles.length === 0);
        }

        function getFileIcon(type) {
            if (type.startsWith('image/')) return '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>';
            if (type.startsWith('video/')) return '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"><polygon points="23 7 16 12 23 17 23 7"></polygon><rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect></svg>';
            if (type.startsWith('audio/')) return '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"><path d="M9 18V5l12-2v13"></path><circle cx="6" cy="18" r="3"></circle><circle cx="18" cy="16" r="3"></circle></svg>';
            return '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline></svg>';
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // File Transfer
        async function sendFiles() {
            if (!isConnected) {
                showToast('Not connected! Complete the handshake first.', 'error');
                return;
            }

            if (selectedFiles.length === 0) {
                showToast('No files selected', 'error');
                return;
            }

            for (let i = 0; i < selectedFiles.length; i++) {
                await sendFile(selectedFiles[i], i);
            }
        }

        async function sendFile(file, index) {
            const fileId = `${Date.now()}-${index}`;
            const totalChunks = Math.ceil(file.size / CHUNK_SIZE);

            // Send file metadata
            const metadata = {
                type: 'file-start',
                id: fileId,
                name: file.name,
                size: file.size,
                mimeType: file.type,
                totalChunks: totalChunks
            };

            sendData(metadata);

            const progressBar = document.getElementById(`progress-${index}`);
            const statusEl = document.getElementById(`status-${index}`);

            const startTime = Date.now();
            let sentBytes = 0;

            // Read and send file in chunks
            for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {
                const start = chunkIndex * CHUNK_SIZE;
                const end = Math.min(start + CHUNK_SIZE, file.size);
                const chunk = file.slice(start, end);

                const arrayBuffer = await chunk.arrayBuffer();
                const encryptedChunk = await encryptData(arrayBuffer);

                // Send chunk
                const chunkData = {
                    type: 'file-chunk',
                    id: fileId,
                    index: chunkIndex,
                    data: Array.from(new Uint8Array(encryptedChunk.encrypted)),
                    iv: Array.from(encryptedChunk.iv)
                };

                sendData(chunkData);

                sentBytes += end - start;
                const progress = (sentBytes / file.size) * 100;
                progressBar.style.width = `${progress}%`;

                const elapsedSeconds = (Date.now() - startTime) / 1000;
                const speed = sentBytes / elapsedSeconds;
                statusEl.textContent = `Sending... ${progress.toFixed(1)}% (${formatFileSize(speed)}/s)`;

                // Small delay to prevent overwhelming the channel
                await new Promise(resolve => setTimeout(resolve, 10));
            }

            // Send completion message
            sendData({ type: 'file-end', id: fileId });

            progressBar.classList.add('complete');
            statusEl.textContent = 'Sent successfully!';

            // Update stats
            appData.stats.sent++;
            appData.stats.totalBytes += file.size;
            addToHistory(file.name, file.size, 'sent');
            updateStats();
            saveData();
        }

        async function encryptData(data) {
            const iv = crypto.getRandomValues(new Uint8Array(12));
            const encrypted = await crypto.subtle.encrypt(
                { name: 'AES-GCM', iv: iv },
                encryptionKey,
                data
            );
            return { encrypted, iv };
        }

        async function decryptData(encrypted, iv) {
            return await crypto.subtle.decrypt(
                { name: 'AES-GCM', iv: new Uint8Array(iv) },
                encryptionKey,
                new Uint8Array(encrypted)
            );
        }

        function sendData(data) {
            if (dataChannel && dataChannel.readyState === 'open') {
                dataChannel.send(JSON.stringify(data));
            }
        }

        async function handleDataChannelMessage(event) {
            const data = JSON.parse(event.data);

            switch (data.type) {
                case 'file-start':
                    incomingFiles[data.id] = {
                        name: data.name,
                        size: data.size,
                        mimeType: data.mimeType,
                        totalChunks: data.totalChunks,
                        chunks: [],
                        receivedBytes: 0,
                        startTime: Date.now()
                    };
                    addReceivingFileUI(data);
                    break;

                case 'file-chunk':
                    await handleFileChunk(data);
                    break;

                case 'file-end':
                    await completeFileReceive(data.id);
                    break;

                case 'message':
                    displayMessage(data.text, false);
                    break;
            }
        }

        function addReceivingFileUI(data) {
            const container = document.getElementById('fileList');
            const html = `
                <div class="file-item" id="recv-${data.id}">
                    <div class="file-icon" style="background: var(--success);">
                        ${getFileIcon(data.mimeType)}
                    </div>
                    <div class="file-info">
                        <div class="file-name">${data.name}</div>
                        <div class="file-size">${formatFileSize(data.size)}</div>
                        <div class="file-progress">
                            <div class="file-progress-bar" id="recv-progress-${data.id}" style="width: 0%"></div>
                        </div>
                        <div class="file-status" id="recv-status-${data.id}">Receiving...</div>
                    </div>
                </div>
            `;
            container.insertAdjacentHTML('beforeend', html);
        }

        async function handleFileChunk(data) {
            const file = incomingFiles[data.id];
            if (!file) return;

            // Decrypt chunk
            const decrypted = await decryptData(data.data, data.iv);
            file.chunks[data.index] = decrypted;
            file.receivedBytes += decrypted.byteLength;

            // Update progress
            const progress = (file.receivedBytes / file.size) * 100;
            const progressBar = document.getElementById(`recv-progress-${data.id}`);
            const statusEl = document.getElementById(`recv-status-${data.id}`);

            if (progressBar) {
                progressBar.style.width = `${progress}%`;

                const elapsedSeconds = (Date.now() - file.startTime) / 1000;
                const speed = file.receivedBytes / elapsedSeconds;
                statusEl.textContent = `Receiving... ${progress.toFixed(1)}% (${formatFileSize(speed)}/s)`;
            }
        }

        async function completeFileReceive(fileId) {
            const file = incomingFiles[fileId];
            if (!file) return;

            // Combine chunks
            const combined = new Uint8Array(file.size);
            let offset = 0;
            for (const chunk of file.chunks) {
                combined.set(new Uint8Array(chunk), offset);
                offset += chunk.byteLength;
            }

            // Create download link
            const blob = new Blob([combined], { type: file.mimeType });
            const url = URL.createObjectURL(blob);

            const progressBar = document.getElementById(`recv-progress-${fileId}`);
            const statusEl = document.getElementById(`recv-status-${fileId}`);

            if (progressBar) {
                progressBar.classList.add('complete');
                statusEl.innerHTML = `<a href="${url}" download="${file.name}" style="color: var(--success);">Download ${file.name}</a>`;
            }

            // Auto-download
            const link = document.createElement('a');
            link.href = url;
            link.download = file.name;
            link.click();

            // Update stats
            appData.stats.received++;
            appData.stats.totalBytes += file.size;
            addToHistory(file.name, file.size, 'received');
            updateStats();
            saveData();

            showToast(`Received: ${file.name}`, 'success');

            delete incomingFiles[fileId];
        }

        // Messaging
        function sendMessage() {
            const input = document.getElementById('messageInput');
            const text = input.value.trim();

            if (!text) return;

            if (!isConnected) {
                showToast('Not connected!', 'error');
                return;
            }

            sendData({ type: 'message', text: text });
            displayMessage(text, true);
            input.value = '';
        }

        function displayMessage(text, isSent) {
            const container = document.getElementById('messagesList');
            const time = new Date().toLocaleTimeString();
            const html = `
                <div class="message-item ${isSent ? 'sent' : 'received'}">
                    ${text}
                    <div class="message-time">${time}</div>
                </div>
            `;
            container.insertAdjacentHTML('afterbegin', html);
        }

        // History & Stats
        function addToHistory(name, size, direction) {
            appData.history.unshift({
                name,
                size,
                direction,
                timestamp: new Date().toISOString()
            });

            // Keep only last 50 items
            if (appData.history.length > 50) {
                appData.history = appData.history.slice(0, 50);
            }

            renderHistory();
        }

        function renderHistory() {
            const container = document.getElementById('historyList');
            if (!appData.history || appData.history.length === 0) {
                container.innerHTML = '<p style="color: var(--text-secondary); text-align: center; padding: 20px;">No transfer history yet</p>';
                return;
            }

            container.innerHTML = appData.history.slice(0, 10).map(item => `
                <div class="history-item">
                    <div class="history-direction ${item.direction}">
                        ${item.direction === 'sent' ?
                            '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="17 1 21 5 17 9"></polyline><path d="M3 11V9a4 4 0 0 1 4-4h14"></path><polyline points="7 23 3 19 7 15"></polyline><path d="M21 13v2a4 4 0 0 1-4 4H3"></path></svg>' :
                            '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>'}
                    </div>
                    <div class="history-info">
                        <div class="history-name">${item.name}</div>
                        <div class="history-meta">${formatFileSize(item.size)} - ${new Date(item.timestamp).toLocaleString()}</div>
                    </div>
                </div>
            `).join('');
        }

        function clearHistory() {
            appData.history = [];
            saveData();
            renderHistory();
            showToast('History cleared', 'success');
        }

        function updateStats() {
            document.getElementById('statFilesSent').textContent = appData.stats.sent || 0;
            document.getElementById('statFilesReceived').textContent = appData.stats.received || 0;
            document.getElementById('statTotalData').textContent = formatFileSize(appData.stats.totalBytes || 0);
        }

        // Toast Notifications
        function showToast(message, type = 'info') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = `toast ${type} show`;

            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }
    </script>
</body>
</html>
