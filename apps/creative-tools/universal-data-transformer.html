<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Universal Data Transformer</title>
    <meta name="description" content="Transform data between CSV, JSON, XML, Excel formats with visual pipeline builder. Privacy-first: data never leaves your browser.">
    <meta name="theme-color" content="#0f172a">
    <meta name="color-scheme" content="dark">
    <!-- data, transform, etl, csv, json, xml, excel, pipeline, privacy -->
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }

        :root {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-tertiary: #334155;
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --accent: #3b82f6;
            --accent-hover: #2563eb;
            --success: #22c55e;
            --warning: #f59e0b;
            --error: #ef4444;
            --border: #475569;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .header {
            background: var(--bg-secondary);
            padding: 1rem 2rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .header-actions {
            display: flex;
            gap: 1rem;
        }

        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-primary {
            background: var(--accent);
            color: white;
        }

        .btn-primary:hover {
            background: var(--accent-hover);
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .btn-secondary:hover {
            background: var(--border);
        }

        .btn-success {
            background: var(--success);
            color: white;
        }

        .main-container {
            display: grid;
            grid-template-columns: 280px 1fr 320px;
            height: calc(100vh - 60px);
        }

        .sidebar {
            background: var(--bg-secondary);
            border-right: 1px solid var(--border);
            padding: 1rem;
            overflow-y: auto;
        }

        .sidebar h3 {
            font-size: 0.75rem;
            text-transform: uppercase;
            color: var(--text-secondary);
            margin-bottom: 0.75rem;
            letter-spacing: 0.05em;
        }

        .node-palette {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
        }

        .palette-node {
            background: var(--bg-tertiary);
            padding: 0.75rem 1rem;
            border-radius: 8px;
            cursor: grab;
            border: 1px solid var(--border);
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .palette-node:hover {
            border-color: var(--accent);
            transform: translateX(4px);
        }

        .palette-node.dragging {
            opacity: 0.5;
        }

        .node-icon {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
        }

        .node-icon.input { background: #3b82f620; color: #3b82f6; }
        .node-icon.transform { background: #8b5cf620; color: #8b5cf6; }
        .node-icon.output { background: #22c55e20; color: #22c55e; }
        .node-icon.join { background: #f59e0b20; color: #f59e0b; }

        .canvas-container {
            position: relative;
            overflow: hidden;
            background:
                radial-gradient(circle at center, var(--bg-tertiary) 1px, transparent 1px);
            background-size: 24px 24px;
        }

        .pipeline-canvas {
            width: 100%;
            height: 100%;
            position: relative;
        }

        .pipeline-node {
            position: absolute;
            background: var(--bg-secondary);
            border: 2px solid var(--border);
            border-radius: 12px;
            min-width: 180px;
            cursor: move;
            user-select: none;
        }

        .pipeline-node.selected {
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3);
        }

        .pipeline-node-header {
            padding: 0.75rem 1rem;
            background: var(--bg-tertiary);
            border-radius: 10px 10px 0 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 500;
        }

        .pipeline-node-body {
            padding: 0.75rem 1rem;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .node-port {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--border);
            border: 2px solid var(--bg-secondary);
            position: absolute;
            cursor: crosshair;
        }

        .node-port.input-port {
            left: -6px;
            top: 50%;
            transform: translateY(-50%);
        }

        .node-port.output-port {
            right: -6px;
            top: 50%;
            transform: translateY(-50%);
        }

        .node-port:hover {
            background: var(--accent);
        }

        .connection-line {
            stroke: var(--accent);
            stroke-width: 2;
            fill: none;
        }

        .properties-panel {
            background: var(--bg-secondary);
            border-left: 1px solid var(--border);
            padding: 1rem;
            overflow-y: auto;
        }

        .properties-panel h3 {
            font-size: 1rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }

        .property-group {
            margin-bottom: 1rem;
        }

        .property-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
            display: block;
        }

        .property-input {
            width: 100%;
            padding: 0.5rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.875rem;
        }

        .property-input:focus {
            outline: none;
            border-color: var(--accent);
        }

        select.property-input {
            cursor: pointer;
        }

        textarea.property-input {
            min-height: 100px;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 0.8rem;
        }

        .drop-zone {
            border: 2px dashed var(--border);
            border-radius: 12px;
            padding: 2rem;
            text-align: center;
            margin-bottom: 1rem;
            transition: all 0.2s;
        }

        .drop-zone.drag-over {
            border-color: var(--accent);
            background: rgba(59, 130, 246, 0.1);
        }

        .drop-zone-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .stats-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border);
            padding: 0.5rem 2rem;
            display: flex;
            gap: 2rem;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .stat-value {
            color: var(--text-primary);
            font-weight: 500;
        }

        .data-preview {
            background: var(--bg-primary);
            border-radius: 8px;
            overflow: hidden;
            margin-top: 1rem;
        }

        .data-preview-header {
            background: var(--bg-tertiary);
            padding: 0.5rem 1rem;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.75rem;
        }

        .data-table th, .data-table td {
            padding: 0.5rem;
            text-align: left;
            border-bottom: 1px solid var(--border);
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .data-table th {
            background: var(--bg-secondary);
            font-weight: 500;
            position: sticky;
            top: 0;
        }

        .preview-scroll {
            max-height: 200px;
            overflow: auto;
        }

        .progress-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .progress-card {
            background: var(--bg-secondary);
            padding: 2rem;
            border-radius: 12px;
            text-align: center;
            min-width: 300px;
        }

        .progress-bar {
            height: 8px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            overflow: hidden;
            margin: 1rem 0;
        }

        .progress-fill {
            height: 100%;
            background: var(--accent);
            transition: width 0.3s;
        }

        .hidden { display: none !important; }

        .toast {
            position: fixed;
            bottom: 80px;
            right: 20px;
            background: var(--bg-secondary);
            padding: 1rem 1.5rem;
            border-radius: 8px;
            border-left: 4px solid var(--success);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            animation: slideIn 0.3s ease;
        }

        .toast.error { border-left-color: var(--error); }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .test-results {
            margin-top: 1rem;
            max-height: 300px;
            overflow-y: auto;
        }

        .test-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            margin-bottom: 0.25rem;
        }

        .test-item.pass { background: rgba(34, 197, 94, 0.1); }
        .test-item.fail { background: rgba(239, 68, 68, 0.1); }
    </style>
</head>
<body>
    <header class="header">
        <h1>üîÑ Universal Data Transformer</h1>
        <div class="header-actions">
            <button class="btn btn-secondary" onclick="importPipeline()">üìÇ Import Pipeline</button>
            <button class="btn btn-secondary" onclick="exportPipeline()">üíæ Export Pipeline</button>
            <button class="btn btn-primary" onclick="runPipeline()">‚ñ∂Ô∏è Run Pipeline</button>
            <button class="btn btn-success" onclick="runTests()">üß™ Run Tests</button>
        </div>
    </header>

    <div class="main-container">
        <aside class="sidebar">
            <h3>üì• Input Sources</h3>
            <div class="node-palette">
                <div class="palette-node" draggable="true" data-type="input-file">
                    <div class="node-icon input">üìÑ</div>
                    <div>
                        <div>File Input</div>
                        <small style="color: var(--text-secondary)">CSV, JSON, XML, Excel</small>
                    </div>
                </div>
                <div class="palette-node" draggable="true" data-type="input-paste">
                    <div class="node-icon input">üìã</div>
                    <div>
                        <div>Paste Data</div>
                        <small style="color: var(--text-secondary)">Text or JSON</small>
                    </div>
                </div>
            </div>

            <h3>üîß Transforms</h3>
            <div class="node-palette">
                <div class="palette-node" draggable="true" data-type="filter">
                    <div class="node-icon transform">üîç</div>
                    <div>Filter</div>
                </div>
                <div class="palette-node" draggable="true" data-type="map">
                    <div class="node-icon transform">üîÄ</div>
                    <div>Map/Transform</div>
                </div>
                <div class="palette-node" draggable="true" data-type="select">
                    <div class="node-icon transform">‚úÇÔ∏è</div>
                    <div>Select Columns</div>
                </div>
                <div class="palette-node" draggable="true" data-type="sort">
                    <div class="node-icon transform">üìä</div>
                    <div>Sort</div>
                </div>
                <div class="palette-node" draggable="true" data-type="aggregate">
                    <div class="node-icon transform">üìà</div>
                    <div>Aggregate</div>
                </div>
                <div class="palette-node" draggable="true" data-type="custom">
                    <div class="node-icon transform">‚ö°</div>
                    <div>Custom JS</div>
                </div>
            </div>

            <h3>üîó Combine</h3>
            <div class="node-palette">
                <div class="palette-node" draggable="true" data-type="join">
                    <div class="node-icon join">üîó</div>
                    <div>Join</div>
                </div>
                <div class="palette-node" draggable="true" data-type="union">
                    <div class="node-icon join">‚ûï</div>
                    <div>Union</div>
                </div>
            </div>

            <h3>üì§ Output</h3>
            <div class="node-palette">
                <div class="palette-node" draggable="true" data-type="output">
                    <div class="node-icon output">üíæ</div>
                    <div>Export</div>
                </div>
            </div>
        </aside>

        <main class="canvas-container" id="canvasContainer">
            <svg id="connectionsSvg" style="position: absolute; inset: 0; width: 100%; height: 100%; pointer-events: none;"></svg>
            <div class="pipeline-canvas" id="pipelineCanvas"></div>
        </main>

        <aside class="properties-panel" id="propertiesPanel">
            <h3>Properties</h3>
            <div id="propertiesContent">
                <p style="color: var(--text-secondary); font-size: 0.875rem;">
                    Select a node to view and edit its properties.
                </p>

                <div class="drop-zone" id="quickDropZone">
                    <div class="drop-zone-icon">üìÅ</div>
                    <div>Drop file here to start</div>
                    <small style="color: var(--text-secondary)">CSV, JSON, XML, XLSX</small>
                </div>

                <input type="file" id="fileInput" class="hidden" accept=".csv,.json,.xml,.xlsx,.xls,.parquet" multiple>
            </div>
        </aside>
    </div>

    <div class="stats-bar">
        <div class="stat-item">
            <span>Rows:</span>
            <span class="stat-value" id="statRows">0</span>
        </div>
        <div class="stat-item">
            <span>Columns:</span>
            <span class="stat-value" id="statCols">0</span>
        </div>
        <div class="stat-item">
            <span>Processing:</span>
            <span class="stat-value" id="statTime">-</span>
        </div>
        <div class="stat-item">
            <span>Memory:</span>
            <span class="stat-value" id="statMemory">-</span>
        </div>
    </div>

    <div class="progress-overlay hidden" id="progressOverlay">
        <div class="progress-card">
            <h3 id="progressTitle">Processing...</h3>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill" style="width: 0%"></div>
            </div>
            <div id="progressText">Initializing...</div>
        </div>
    </div>

    <script>
        // ============================================
        // CORE DATA ENGINE
        // ============================================

        class DataEngine {
            constructor() {
                this.datasets = new Map();
                this.workers = [];
                this.initWorkers();
            }

            initWorkers() {
                // Create worker pool for parallel processing
                const workerCode = `
                    self.onmessage = function(e) {
                        const { type, data, options, chunkId } = e.data;
                        let result;

                        try {
                            switch(type) {
                                case 'filter':
                                    result = filterData(data, options);
                                    break;
                                case 'map':
                                    result = mapData(data, options);
                                    break;
                                case 'aggregate':
                                    result = aggregateData(data, options);
                                    break;
                                case 'sort':
                                    result = sortData(data, options);
                                    break;
                                case 'parse-csv':
                                    result = parseCSV(data);
                                    break;
                            }
                            self.postMessage({ success: true, result, chunkId });
                        } catch(err) {
                            self.postMessage({ success: false, error: err.message, chunkId });
                        }
                    };

                    function filterData(data, { expression }) {
                        const fn = new Function('row', 'index', 'return ' + expression);
                        return data.filter((row, i) => fn(row, i));
                    }

                    function mapData(data, { expression }) {
                        const fn = new Function('row', 'index', expression);
                        return data.map((row, i) => {
                            const newRow = {...row};
                            fn(newRow, i);
                            return newRow;
                        });
                    }

                    function aggregateData(data, { groupBy, aggregations }) {
                        const groups = new Map();

                        for (const row of data) {
                            const key = groupBy.map(col => row[col]).join('|');
                            if (!groups.has(key)) {
                                groups.set(key, { rows: [], key: {} });
                                groupBy.forEach(col => groups.get(key).key[col] = row[col]);
                            }
                            groups.get(key).rows.push(row);
                        }

                        return Array.from(groups.values()).map(group => {
                            const result = {...group.key};
                            for (const agg of aggregations) {
                                const values = group.rows.map(r => parseFloat(r[agg.column]) || 0);
                                switch(agg.function) {
                                    case 'sum': result[agg.alias] = values.reduce((a,b) => a+b, 0); break;
                                    case 'avg': result[agg.alias] = values.reduce((a,b) => a+b, 0) / values.length; break;
                                    case 'count': result[agg.alias] = values.length; break;
                                    case 'min': result[agg.alias] = Math.min(...values); break;
                                    case 'max': result[agg.alias] = Math.max(...values); break;
                                }
                            }
                            return result;
                        });
                    }

                    function sortData(data, { column, direction }) {
                        return [...data].sort((a, b) => {
                            const aVal = a[column], bVal = b[column];
                            const cmp = typeof aVal === 'string' ? aVal.localeCompare(bVal) : aVal - bVal;
                            return direction === 'desc' ? -cmp : cmp;
                        });
                    }

                    function parseCSV(text) {
                        const lines = text.split(/\\r?\\n/);
                        const headers = parseCSVLine(lines[0]);
                        const data = [];

                        for (let i = 1; i < lines.length; i++) {
                            if (!lines[i].trim()) continue;
                            const values = parseCSVLine(lines[i]);
                            const row = {};
                            headers.forEach((h, idx) => row[h] = values[idx] || '');
                            data.push(row);
                        }
                        return { headers, data };
                    }

                    function parseCSVLine(line) {
                        const result = [];
                        let current = '';
                        let inQuotes = false;

                        for (let i = 0; i < line.length; i++) {
                            const char = line[i];
                            if (char === '"') {
                                inQuotes = !inQuotes;
                            } else if (char === ',' && !inQuotes) {
                                result.push(current.trim());
                                current = '';
                            } else {
                                current += char;
                            }
                        }
                        result.push(current.trim());
                        return result;
                    }
                `;

                const blob = new Blob([workerCode], { type: 'application/javascript' });
                const workerUrl = URL.createObjectURL(blob);

                const numWorkers = navigator.hardwareConcurrency || 4;
                for (let i = 0; i < numWorkers; i++) {
                    this.workers.push(new Worker(workerUrl));
                }
            }

            async processInParallel(type, data, options) {
                const chunkSize = Math.ceil(data.length / this.workers.length);
                const chunks = [];

                for (let i = 0; i < data.length; i += chunkSize) {
                    chunks.push(data.slice(i, i + chunkSize));
                }

                const promises = chunks.map((chunk, i) => {
                    return new Promise((resolve, reject) => {
                        const worker = this.workers[i % this.workers.length];
                        const handler = (e) => {
                            worker.removeEventListener('message', handler);
                            if (e.data.success) {
                                resolve(e.data.result);
                            } else {
                                reject(new Error(e.data.error));
                            }
                        };
                        worker.addEventListener('message', handler);
                        worker.postMessage({ type, data: chunk, options, chunkId: i });
                    });
                });

                const results = await Promise.all(promises);
                return results.flat();
            }
        }

        // ============================================
        // FORMAT PARSERS
        // ============================================

        const Parsers = {
            async parseCSV(text) {
                const lines = text.split(/\r?\n/);
                const headers = this.parseCSVLine(lines[0]);
                const data = [];

                for (let i = 1; i < lines.length; i++) {
                    if (!lines[i].trim()) continue;
                    const values = this.parseCSVLine(lines[i]);
                    const row = {};
                    headers.forEach((h, idx) => row[h] = values[idx] || '');
                    data.push(row);
                }

                return { headers, data };
            },

            parseCSVLine(line) {
                const result = [];
                let current = '';
                let inQuotes = false;

                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        result.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                result.push(current.trim());
                return result;
            },

            async parseJSON(text) {
                const parsed = JSON.parse(text);
                const data = Array.isArray(parsed) ? parsed : [parsed];
                const headers = data.length > 0 ? Object.keys(data[0]) : [];
                return { headers, data };
            },

            async parseXML(text) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(text, 'text/xml');
                const data = [];
                const headers = new Set();

                // Find repeated elements (likely data rows)
                const children = doc.documentElement.children;
                for (const child of children) {
                    const row = {};
                    for (const prop of child.children) {
                        headers.add(prop.tagName);
                        row[prop.tagName] = prop.textContent;
                    }
                    data.push(row);
                }

                return { headers: Array.from(headers), data };
            },

            async parseExcel(arrayBuffer) {
                // Simple XLSX parser - reads first sheet
                const zip = await this.unzip(arrayBuffer);
                const sheetXml = zip['xl/worksheets/sheet1.xml'];
                const stringsXml = zip['xl/sharedStrings.xml'];

                // Parse shared strings
                const strings = [];
                if (stringsXml) {
                    const matches = stringsXml.match(/<t[^>]*>([^<]*)<\/t>/g) || [];
                    for (const match of matches) {
                        strings.push(match.replace(/<\/?t[^>]*>/g, ''));
                    }
                }

                // Parse sheet data
                const rows = [];
                const rowMatches = sheetXml.match(/<row[^>]*>[\s\S]*?<\/row>/g) || [];

                for (const rowXml of rowMatches) {
                    const cells = [];
                    const cellMatches = rowXml.match(/<c[^>]*>[\s\S]*?<\/c>|<c[^\/]*\/>/g) || [];

                    for (const cellXml of cellMatches) {
                        const typeMatch = cellXml.match(/t="([^"]*)"/);
                        const valueMatch = cellXml.match(/<v>([^<]*)<\/v>/);

                        let value = valueMatch ? valueMatch[1] : '';
                        if (typeMatch && typeMatch[1] === 's' && strings[parseInt(value)]) {
                            value = strings[parseInt(value)];
                        }
                        cells.push(value);
                    }
                    rows.push(cells);
                }

                if (rows.length === 0) return { headers: [], data: [] };

                const headers = rows[0];
                const data = rows.slice(1).map(row => {
                    const obj = {};
                    headers.forEach((h, i) => obj[h] = row[i] || '');
                    return obj;
                });

                return { headers, data };
            },

            async unzip(arrayBuffer) {
                // Minimal ZIP parser for XLSX
                const view = new DataView(arrayBuffer);
                const files = {};
                let offset = 0;

                while (offset < arrayBuffer.byteLength - 4) {
                    const sig = view.getUint32(offset, true);
                    if (sig !== 0x04034b50) break; // Local file header

                    const compMethod = view.getUint16(offset + 8, true);
                    const compSize = view.getUint32(offset + 18, true);
                    const uncompSize = view.getUint32(offset + 22, true);
                    const nameLen = view.getUint16(offset + 26, true);
                    const extraLen = view.getUint16(offset + 28, true);

                    const nameBytes = new Uint8Array(arrayBuffer, offset + 30, nameLen);
                    const fileName = new TextDecoder().decode(nameBytes);

                    const dataStart = offset + 30 + nameLen + extraLen;
                    const dataBytes = new Uint8Array(arrayBuffer, dataStart, compSize);

                    if (compMethod === 0) {
                        files[fileName] = new TextDecoder().decode(dataBytes);
                    } else if (compMethod === 8) {
                        // Deflate - use DecompressionStream
                        try {
                            const ds = new DecompressionStream('deflate-raw');
                            const writer = ds.writable.getWriter();
                            writer.write(dataBytes);
                            writer.close();
                            const reader = ds.readable.getReader();
                            const chunks = [];
                            while (true) {
                                const { done, value } = await reader.read();
                                if (done) break;
                                chunks.push(value);
                            }
                            const result = new Uint8Array(chunks.reduce((a, c) => a + c.length, 0));
                            let pos = 0;
                            for (const chunk of chunks) {
                                result.set(chunk, pos);
                                pos += chunk.length;
                            }
                            files[fileName] = new TextDecoder().decode(result);
                        } catch (e) {
                            // Skip files that fail to decompress
                        }
                    }

                    offset = dataStart + compSize;
                }

                return files;
            }
        };

        // ============================================
        // FORMAT EXPORTERS
        // ============================================

        const Exporters = {
            toCSV(headers, data) {
                const escape = (val) => {
                    const str = String(val ?? '');
                    if (str.includes(',') || str.includes('"') || str.includes('\n')) {
                        return '"' + str.replace(/"/g, '""') + '"';
                    }
                    return str;
                };

                let csv = headers.map(escape).join(',') + '\n';
                for (const row of data) {
                    csv += headers.map(h => escape(row[h])).join(',') + '\n';
                }
                return csv;
            },

            toJSON(data, pretty = true) {
                return JSON.stringify(data, null, pretty ? 2 : 0);
            },

            toXML(data, rootName = 'data', rowName = 'row') {
                let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
                xml += `<${rootName}>\n`;

                for (const row of data) {
                    xml += `  <${rowName}>\n`;
                    for (const [key, value] of Object.entries(row)) {
                        const escaped = String(value ?? '')
                            .replace(/&/g, '&amp;')
                            .replace(/</g, '&lt;')
                            .replace(/>/g, '&gt;');
                        xml += `    <${key}>${escaped}</${key}>\n`;
                    }
                    xml += `  </${rowName}>\n`;
                }

                xml += `</${rootName}>`;
                return xml;
            }
        };

        // ============================================
        // TRANSFORMATION OPERATIONS
        // ============================================

        const Transforms = {
            filter(data, expression) {
                try {
                    const fn = new Function('row', 'index', 'return ' + expression);
                    return data.filter((row, i) => fn(row, i));
                } catch (e) {
                    console.error('Filter error:', e);
                    return data;
                }
            },

            map(data, expression) {
                try {
                    const fn = new Function('row', 'index', expression);
                    return data.map((row, i) => {
                        const newRow = {...row};
                        fn(newRow, i);
                        return newRow;
                    });
                } catch (e) {
                    console.error('Map error:', e);
                    return data;
                }
            },

            select(data, columns) {
                return data.map(row => {
                    const newRow = {};
                    columns.forEach(col => {
                        if (col in row) newRow[col] = row[col];
                    });
                    return newRow;
                });
            },

            sort(data, column, direction = 'asc') {
                return [...data].sort((a, b) => {
                    const aVal = a[column], bVal = b[column];
                    let cmp = 0;
                    if (typeof aVal === 'number' && typeof bVal === 'number') {
                        cmp = aVal - bVal;
                    } else {
                        cmp = String(aVal).localeCompare(String(bVal));
                    }
                    return direction === 'desc' ? -cmp : cmp;
                });
            },

            aggregate(data, groupBy, aggregations) {
                const groups = new Map();

                for (const row of data) {
                    const key = groupBy.map(col => row[col]).join('|||');
                    if (!groups.has(key)) {
                        groups.set(key, { rows: [], keyValues: {} });
                        groupBy.forEach(col => groups.get(key).keyValues[col] = row[col]);
                    }
                    groups.get(key).rows.push(row);
                }

                return Array.from(groups.values()).map(group => {
                    const result = {...group.keyValues};

                    for (const agg of aggregations) {
                        const values = group.rows.map(r => {
                            const v = r[agg.column];
                            return typeof v === 'number' ? v : parseFloat(v) || 0;
                        });

                        switch(agg.function) {
                            case 'sum':
                                result[agg.alias || `${agg.function}_${agg.column}`] = values.reduce((a, b) => a + b, 0);
                                break;
                            case 'avg':
                                result[agg.alias || `${agg.function}_${agg.column}`] = values.reduce((a, b) => a + b, 0) / values.length;
                                break;
                            case 'count':
                                result[agg.alias || `${agg.function}_${agg.column}`] = values.length;
                                break;
                            case 'min':
                                result[agg.alias || `${agg.function}_${agg.column}`] = Math.min(...values);
                                break;
                            case 'max':
                                result[agg.alias || `${agg.function}_${agg.column}`] = Math.max(...values);
                                break;
                        }
                    }

                    return result;
                });
            },

            join(leftData, rightData, leftKey, rightKey, type = 'inner') {
                const rightIndex = new Map();
                for (const row of rightData) {
                    const key = row[rightKey];
                    if (!rightIndex.has(key)) rightIndex.set(key, []);
                    rightIndex.get(key).push(row);
                }

                const result = [];
                const usedRight = new Set();

                for (const leftRow of leftData) {
                    const key = leftRow[leftKey];
                    const matches = rightIndex.get(key) || [];

                    if (matches.length > 0) {
                        for (const rightRow of matches) {
                            const merged = {...leftRow};
                            for (const [k, v] of Object.entries(rightRow)) {
                                if (k !== rightKey || leftKey !== rightKey) {
                                    merged[k === leftKey ? k : (k in merged ? `right_${k}` : k)] = v;
                                }
                            }
                            result.push(merged);
                            usedRight.add(rightRow);
                        }
                    } else if (type === 'left' || type === 'full') {
                        result.push({...leftRow});
                    }
                }

                if (type === 'right' || type === 'full') {
                    for (const rightRow of rightData) {
                        if (!usedRight.has(rightRow)) {
                            result.push({...rightRow});
                        }
                    }
                }

                return result;
            },

            union(data1, data2) {
                return [...data1, ...data2];
            },

            custom(data, code) {
                try {
                    const fn = new Function('data', code);
                    return fn(data) || data;
                } catch (e) {
                    console.error('Custom transform error:', e);
                    return data;
                }
            }
        };

        // ============================================
        // PIPELINE MANAGER
        // ============================================

        class PipelineManager {
            constructor() {
                this.nodes = new Map();
                this.connections = [];
                this.selectedNode = null;
                this.nodeCounter = 0;
                this.datasets = new Map();
                this.engine = new DataEngine();
            }

            addNode(type, x, y) {
                const id = `node_${++this.nodeCounter}`;
                const node = {
                    id,
                    type,
                    x,
                    y,
                    config: this.getDefaultConfig(type),
                    data: null
                };
                this.nodes.set(id, node);
                return node;
            }

            getDefaultConfig(type) {
                switch(type) {
                    case 'input-file':
                        return { fileName: '', format: 'auto' };
                    case 'input-paste':
                        return { content: '', format: 'auto' };
                    case 'filter':
                        return { expression: 'row.column > 0' };
                    case 'map':
                        return { expression: 'row.newCol = row.col1 + row.col2;' };
                    case 'select':
                        return { columns: [] };
                    case 'sort':
                        return { column: '', direction: 'asc' };
                    case 'aggregate':
                        return { groupBy: [], aggregations: [] };
                    case 'join':
                        return { leftKey: '', rightKey: '', type: 'inner' };
                    case 'union':
                        return {};
                    case 'custom':
                        return { code: 'return data.map(row => ({...row}));' };
                    case 'output':
                        return { format: 'csv', fileName: 'output' };
                    default:
                        return {};
                }
            }

            connect(fromId, toId) {
                // Check if connection already exists
                const exists = this.connections.find(c => c.from === fromId && c.to === toId);
                if (exists) return;

                this.connections.push({ from: fromId, to: toId });
            }

            disconnect(fromId, toId) {
                this.connections = this.connections.filter(c => !(c.from === fromId && c.to === toId));
            }

            getInputNodes(nodeId) {
                return this.connections
                    .filter(c => c.to === nodeId)
                    .map(c => this.nodes.get(c.from));
            }

            async execute(progressCallback) {
                const startTime = performance.now();
                const executionOrder = this.getExecutionOrder();

                let step = 0;
                for (const nodeId of executionOrder) {
                    const node = this.nodes.get(nodeId);
                    const inputs = this.getInputNodes(nodeId);

                    progressCallback?.({
                        progress: (step / executionOrder.length) * 100,
                        message: `Processing ${node.type}...`
                    });

                    await this.executeNode(node, inputs);
                    step++;
                }

                const endTime = performance.now();
                return {
                    duration: endTime - startTime,
                    nodesProcessed: executionOrder.length
                };
            }

            async executeNode(node, inputs) {
                const inputData = inputs.length > 0 ? inputs.map(n => n.data) : [];

                switch(node.type) {
                    case 'input-file':
                    case 'input-paste':
                        // Data already loaded
                        break;

                    case 'filter':
                        if (inputData[0]) {
                            node.data = {
                                headers: inputData[0].headers,
                                data: Transforms.filter(inputData[0].data, node.config.expression)
                            };
                        }
                        break;

                    case 'map':
                        if (inputData[0]) {
                            const transformed = Transforms.map(inputData[0].data, node.config.expression);
                            node.data = {
                                headers: transformed.length > 0 ? Object.keys(transformed[0]) : inputData[0].headers,
                                data: transformed
                            };
                        }
                        break;

                    case 'select':
                        if (inputData[0]) {
                            node.data = {
                                headers: node.config.columns,
                                data: Transforms.select(inputData[0].data, node.config.columns)
                            };
                        }
                        break;

                    case 'sort':
                        if (inputData[0]) {
                            node.data = {
                                headers: inputData[0].headers,
                                data: Transforms.sort(inputData[0].data, node.config.column, node.config.direction)
                            };
                        }
                        break;

                    case 'aggregate':
                        if (inputData[0]) {
                            const aggregated = Transforms.aggregate(
                                inputData[0].data,
                                node.config.groupBy,
                                node.config.aggregations
                            );
                            node.data = {
                                headers: aggregated.length > 0 ? Object.keys(aggregated[0]) : [],
                                data: aggregated
                            };
                        }
                        break;

                    case 'join':
                        if (inputData[0] && inputData[1]) {
                            const joined = Transforms.join(
                                inputData[0].data,
                                inputData[1].data,
                                node.config.leftKey,
                                node.config.rightKey,
                                node.config.type
                            );
                            node.data = {
                                headers: joined.length > 0 ? Object.keys(joined[0]) : [],
                                data: joined
                            };
                        }
                        break;

                    case 'union':
                        if (inputData[0] && inputData[1]) {
                            const unioned = Transforms.union(inputData[0].data, inputData[1].data);
                            node.data = {
                                headers: inputData[0].headers,
                                data: unioned
                            };
                        }
                        break;

                    case 'custom':
                        if (inputData[0]) {
                            const customResult = Transforms.custom(inputData[0].data, node.config.code);
                            node.data = {
                                headers: customResult.length > 0 ? Object.keys(customResult[0]) : [],
                                data: customResult
                            };
                        }
                        break;

                    case 'output':
                        if (inputData[0]) {
                            node.data = inputData[0];
                        }
                        break;
                }
            }

            getExecutionOrder() {
                // Topological sort
                const order = [];
                const visited = new Set();
                const visiting = new Set();

                const visit = (nodeId) => {
                    if (visited.has(nodeId)) return;
                    if (visiting.has(nodeId)) throw new Error('Circular dependency detected');

                    visiting.add(nodeId);

                    for (const conn of this.connections) {
                        if (conn.to === nodeId) {
                            visit(conn.from);
                        }
                    }

                    visiting.delete(nodeId);
                    visited.add(nodeId);
                    order.push(nodeId);
                };

                for (const nodeId of this.nodes.keys()) {
                    visit(nodeId);
                }

                return order;
            }

            exportPipeline() {
                return {
                    nodes: Array.from(this.nodes.entries()).map(([id, node]) => ({
                        id,
                        type: node.type,
                        x: node.x,
                        y: node.y,
                        config: node.config
                    })),
                    connections: this.connections
                };
            }

            importPipeline(data) {
                this.nodes.clear();
                this.connections = [];

                for (const nodeData of data.nodes) {
                    this.nodes.set(nodeData.id, {
                        ...nodeData,
                        data: null
                    });
                    const num = parseInt(nodeData.id.split('_')[1]);
                    if (num > this.nodeCounter) this.nodeCounter = num;
                }

                this.connections = data.connections;
            }
        }

        // ============================================
        // UI CONTROLLER
        // ============================================

        const pipeline = new PipelineManager();
        let draggedNode = null;
        let connectingFrom = null;
        let tempLine = null;

        function init() {
            setupDragAndDrop();
            setupCanvasEvents();
            setupFileDropZone();
        }

        function setupDragAndDrop() {
            document.querySelectorAll('.palette-node').forEach(el => {
                el.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('nodeType', e.target.dataset.type);
                    e.target.classList.add('dragging');
                });

                el.addEventListener('dragend', (e) => {
                    e.target.classList.remove('dragging');
                });
            });

            const canvas = document.getElementById('canvasContainer');
            canvas.addEventListener('dragover', (e) => {
                e.preventDefault();
            });

            canvas.addEventListener('drop', (e) => {
                e.preventDefault();
                const type = e.dataTransfer.getData('nodeType');
                if (type) {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    const node = pipeline.addNode(type, x, y);
                    renderNode(node);
                }
            });
        }

        function setupCanvasEvents() {
            const canvas = document.getElementById('pipelineCanvas');

            canvas.addEventListener('click', (e) => {
                if (e.target === canvas) {
                    selectNode(null);
                }
            });
        }

        function setupFileDropZone() {
            const dropZone = document.getElementById('quickDropZone');
            const fileInput = document.getElementById('fileInput');

            dropZone.addEventListener('click', () => fileInput.click());

            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('drag-over');
            });

            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('drag-over');
            });

            dropZone.addEventListener('drop', async (e) => {
                e.preventDefault();
                dropZone.classList.remove('drag-over');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    await loadFile(files[0]);
                }
            });

            fileInput.addEventListener('change', async (e) => {
                if (e.target.files.length > 0) {
                    await loadFile(e.target.files[0]);
                }
            });
        }

        async function loadFile(file) {
            showProgress('Loading file...', 0);

            try {
                const ext = file.name.split('.').pop().toLowerCase();
                let result;

                if (ext === 'csv') {
                    const text = await file.text();
                    result = await Parsers.parseCSV(text);
                } else if (ext === 'json') {
                    const text = await file.text();
                    result = await Parsers.parseJSON(text);
                } else if (ext === 'xml') {
                    const text = await file.text();
                    result = await Parsers.parseXML(text);
                } else if (ext === 'xlsx' || ext === 'xls') {
                    const buffer = await file.arrayBuffer();
                    result = await Parsers.parseExcel(buffer);
                } else {
                    throw new Error('Unsupported format: ' + ext);
                }

                // Create input node
                const canvas = document.getElementById('canvasContainer');
                const node = pipeline.addNode('input-file', 100, 100);
                node.config.fileName = file.name;
                node.config.format = ext;
                node.data = result;
                renderNode(node);

                updateStats(result.data.length, result.headers.length);
                showToast(`Loaded ${result.data.length} rows from ${file.name}`);
                hideProgress();

            } catch (e) {
                hideProgress();
                showToast('Error: ' + e.message, true);
            }
        }

        function renderNode(node) {
            const canvas = document.getElementById('pipelineCanvas');

            const el = document.createElement('div');
            el.className = 'pipeline-node';
            el.id = node.id;
            el.style.left = node.x + 'px';
            el.style.top = node.y + 'px';

            const typeInfo = getNodeTypeInfo(node.type);

            el.innerHTML = `
                <div class="node-port input-port" data-port="input"></div>
                <div class="pipeline-node-header">
                    <span>${typeInfo.icon}</span>
                    <span>${typeInfo.name}</span>
                </div>
                <div class="pipeline-node-body">
                    ${getNodeBodyContent(node)}
                </div>
                <div class="node-port output-port" data-port="output"></div>
            `;

            // Node drag
            let isDragging = false;
            let startX, startY;

            el.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('node-port')) return;
                isDragging = true;
                startX = e.clientX - node.x;
                startY = e.clientY - node.y;
                el.style.zIndex = 100;
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                node.x = e.clientX - startX;
                node.y = e.clientY - startY;
                el.style.left = node.x + 'px';
                el.style.top = node.y + 'px';
                renderConnections();
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
                el.style.zIndex = '';
            });

            // Port connections
            el.querySelectorAll('.node-port').forEach(port => {
                port.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    if (port.dataset.port === 'output') {
                        startConnection(node.id, e);
                    }
                });

                port.addEventListener('mouseup', (e) => {
                    if (connectingFrom && port.dataset.port === 'input') {
                        pipeline.connect(connectingFrom, node.id);
                        renderConnections();
                    }
                    endConnection();
                });
            });

            el.addEventListener('click', (e) => {
                e.stopPropagation();
                selectNode(node.id);
            });

            canvas.appendChild(el);
        }

        function getNodeTypeInfo(type) {
            const types = {
                'input-file': { icon: 'üìÑ', name: 'File Input' },
                'input-paste': { icon: 'üìã', name: 'Paste Data' },
                'filter': { icon: 'üîç', name: 'Filter' },
                'map': { icon: 'üîÄ', name: 'Map' },
                'select': { icon: '‚úÇÔ∏è', name: 'Select' },
                'sort': { icon: 'üìä', name: 'Sort' },
                'aggregate': { icon: 'üìà', name: 'Aggregate' },
                'join': { icon: 'üîó', name: 'Join' },
                'union': { icon: '‚ûï', name: 'Union' },
                'custom': { icon: '‚ö°', name: 'Custom JS' },
                'output': { icon: 'üíæ', name: 'Export' }
            };
            return types[type] || { icon: '‚ùì', name: type };
        }

        function getNodeBodyContent(node) {
            if (node.data) {
                return `${node.data.data.length} rows`;
            }

            switch(node.type) {
                case 'input-file':
                    return node.config.fileName || 'No file';
                case 'filter':
                    return node.config.expression.substring(0, 20) + '...';
                case 'output':
                    return node.config.format.toUpperCase();
                default:
                    return 'Configure ‚Üí';
            }
        }

        function startConnection(fromId, e) {
            connectingFrom = fromId;

            const svg = document.getElementById('connectionsSvg');
            tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            tempLine.setAttribute('class', 'connection-line');
            tempLine.setAttribute('stroke-dasharray', '5,5');
            svg.appendChild(tempLine);

            document.addEventListener('mousemove', updateTempLine);
            document.addEventListener('mouseup', endConnection);
        }

        function updateTempLine(e) {
            if (!connectingFrom || !tempLine) return;

            const fromEl = document.getElementById(connectingFrom);
            const fromRect = fromEl.getBoundingClientRect();
            const canvasRect = document.getElementById('canvasContainer').getBoundingClientRect();

            const x1 = fromRect.right - canvasRect.left;
            const y1 = fromRect.top + fromRect.height / 2 - canvasRect.top;
            const x2 = e.clientX - canvasRect.left;
            const y2 = e.clientY - canvasRect.top;

            const path = `M ${x1} ${y1} C ${x1 + 50} ${y1}, ${x2 - 50} ${y2}, ${x2} ${y2}`;
            tempLine.setAttribute('d', path);
        }

        function endConnection() {
            connectingFrom = null;
            if (tempLine) {
                tempLine.remove();
                tempLine = null;
            }
            document.removeEventListener('mousemove', updateTempLine);
        }

        function renderConnections() {
            const svg = document.getElementById('connectionsSvg');
            svg.innerHTML = '';

            const canvasRect = document.getElementById('canvasContainer').getBoundingClientRect();

            for (const conn of pipeline.connections) {
                const fromEl = document.getElementById(conn.from);
                const toEl = document.getElementById(conn.to);
                if (!fromEl || !toEl) continue;

                const fromRect = fromEl.getBoundingClientRect();
                const toRect = toEl.getBoundingClientRect();

                const x1 = fromRect.right - canvasRect.left;
                const y1 = fromRect.top + fromRect.height / 2 - canvasRect.top;
                const x2 = toRect.left - canvasRect.left;
                const y2 = toRect.top + toRect.height / 2 - canvasRect.top;

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('class', 'connection-line');
                path.setAttribute('d', `M ${x1} ${y1} C ${x1 + 50} ${y1}, ${x2 - 50} ${y2}, ${x2} ${y2}`);
                svg.appendChild(path);
            }
        }

        function selectNode(nodeId) {
            document.querySelectorAll('.pipeline-node').forEach(el => {
                el.classList.remove('selected');
            });

            pipeline.selectedNode = nodeId;

            if (nodeId) {
                document.getElementById(nodeId).classList.add('selected');
                showNodeProperties(pipeline.nodes.get(nodeId));
            } else {
                showDefaultProperties();
            }
        }

        function showNodeProperties(node) {
            const panel = document.getElementById('propertiesContent');
            const typeInfo = getNodeTypeInfo(node.type);

            let html = `
                <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 1rem;">
                    <span style="font-size: 1.5rem;">${typeInfo.icon}</span>
                    <span style="font-weight: 600;">${typeInfo.name}</span>
                </div>
            `;

            // Properties based on node type
            switch(node.type) {
                case 'input-file':
                    html += `
                        <div class="property-group">
                            <label class="property-label">File</label>
                            <div style="color: var(--text-primary);">${node.config.fileName || 'No file loaded'}</div>
                        </div>
                        <button class="btn btn-secondary" onclick="document.getElementById('fileInput').click()" style="width: 100%;">
                            üìÅ Load File
                        </button>
                    `;
                    break;

                case 'filter':
                    html += `
                        <div class="property-group">
                            <label class="property-label">Filter Expression</label>
                            <textarea class="property-input"
                                placeholder="row.age > 18 && row.status === 'active'"
                                onchange="updateNodeConfig('${node.id}', 'expression', this.value)"
                            >${node.config.expression}</textarea>
                            <small style="color: var(--text-secondary);">Use 'row' to access columns</small>
                        </div>
                    `;
                    break;

                case 'map':
                    html += `
                        <div class="property-group">
                            <label class="property-label">Transform Expression</label>
                            <textarea class="property-input"
                                placeholder="row.fullName = row.first + ' ' + row.last;"
                                onchange="updateNodeConfig('${node.id}', 'expression', this.value)"
                            >${node.config.expression}</textarea>
                            <small style="color: var(--text-secondary);">Modify 'row' properties</small>
                        </div>
                    `;
                    break;

                case 'select':
                    const availableCols = node.data?.headers || getInputHeaders(node.id);
                    html += `
                        <div class="property-group">
                            <label class="property-label">Select Columns</label>
                            <div style="max-height: 200px; overflow-y: auto;">
                                ${availableCols.map(col => `
                                    <label style="display: flex; align-items: center; gap: 0.5rem; padding: 0.25rem 0;">
                                        <input type="checkbox"
                                            ${node.config.columns.includes(col) ? 'checked' : ''}
                                            onchange="toggleColumn('${node.id}', '${col}', this.checked)">
                                        ${col}
                                    </label>
                                `).join('')}
                            </div>
                        </div>
                    `;
                    break;

                case 'sort':
                    const sortCols = node.data?.headers || getInputHeaders(node.id);
                    html += `
                        <div class="property-group">
                            <label class="property-label">Sort Column</label>
                            <select class="property-input" onchange="updateNodeConfig('${node.id}', 'column', this.value)">
                                <option value="">Select column</option>
                                ${sortCols.map(col => `
                                    <option value="${col}" ${node.config.column === col ? 'selected' : ''}>${col}</option>
                                `).join('')}
                            </select>
                        </div>
                        <div class="property-group">
                            <label class="property-label">Direction</label>
                            <select class="property-input" onchange="updateNodeConfig('${node.id}', 'direction', this.value)">
                                <option value="asc" ${node.config.direction === 'asc' ? 'selected' : ''}>Ascending</option>
                                <option value="desc" ${node.config.direction === 'desc' ? 'selected' : ''}>Descending</option>
                            </select>
                        </div>
                    `;
                    break;

                case 'aggregate':
                    const aggCols = node.data?.headers || getInputHeaders(node.id);
                    html += `
                        <div class="property-group">
                            <label class="property-label">Group By</label>
                            <select class="property-input" multiple style="height: 80px;"
                                onchange="updateGroupBy('${node.id}', this)">
                                ${aggCols.map(col => `
                                    <option value="${col}" ${node.config.groupBy.includes(col) ? 'selected' : ''}>${col}</option>
                                `).join('')}
                            </select>
                        </div>
                        <div class="property-group">
                            <label class="property-label">Aggregations</label>
                            <div id="aggregationList">
                                ${(node.config.aggregations || []).map((agg, i) => `
                                    <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
                                        <select class="property-input" style="flex: 1;"
                                            onchange="updateAggregation('${node.id}', ${i}, 'function', this.value)">
                                            <option value="sum" ${agg.function === 'sum' ? 'selected' : ''}>Sum</option>
                                            <option value="avg" ${agg.function === 'avg' ? 'selected' : ''}>Avg</option>
                                            <option value="count" ${agg.function === 'count' ? 'selected' : ''}>Count</option>
                                            <option value="min" ${agg.function === 'min' ? 'selected' : ''}>Min</option>
                                            <option value="max" ${agg.function === 'max' ? 'selected' : ''}>Max</option>
                                        </select>
                                        <select class="property-input" style="flex: 1;"
                                            onchange="updateAggregation('${node.id}', ${i}, 'column', this.value)">
                                            ${aggCols.map(col => `
                                                <option value="${col}" ${agg.column === col ? 'selected' : ''}>${col}</option>
                                            `).join('')}
                                        </select>
                                    </div>
                                `).join('')}
                            </div>
                            <button class="btn btn-secondary" onclick="addAggregation('${node.id}')" style="width: 100%; margin-top: 0.5rem;">
                                + Add Aggregation
                            </button>
                        </div>
                    `;
                    break;

                case 'join':
                    const joinCols = getInputHeaders(node.id);
                    html += `
                        <div class="property-group">
                            <label class="property-label">Join Type</label>
                            <select class="property-input" onchange="updateNodeConfig('${node.id}', 'type', this.value)">
                                <option value="inner" ${node.config.type === 'inner' ? 'selected' : ''}>Inner Join</option>
                                <option value="left" ${node.config.type === 'left' ? 'selected' : ''}>Left Join</option>
                                <option value="right" ${node.config.type === 'right' ? 'selected' : ''}>Right Join</option>
                                <option value="full" ${node.config.type === 'full' ? 'selected' : ''}>Full Outer</option>
                            </select>
                        </div>
                        <div class="property-group">
                            <label class="property-label">Left Key</label>
                            <input class="property-input" type="text" value="${node.config.leftKey}"
                                onchange="updateNodeConfig('${node.id}', 'leftKey', this.value)">
                        </div>
                        <div class="property-group">
                            <label class="property-label">Right Key</label>
                            <input class="property-input" type="text" value="${node.config.rightKey}"
                                onchange="updateNodeConfig('${node.id}', 'rightKey', this.value)">
                        </div>
                    `;
                    break;

                case 'custom':
                    html += `
                        <div class="property-group">
                            <label class="property-label">JavaScript Code</label>
                            <textarea class="property-input" style="min-height: 150px; font-family: monospace;"
                                placeholder="return data.map(row => ({...row}));"
                                onchange="updateNodeConfig('${node.id}', 'code', this.value)"
                            >${node.config.code}</textarea>
                            <small style="color: var(--text-secondary);">'data' is the input array. Return transformed array.</small>
                        </div>
                    `;
                    break;

                case 'output':
                    html += `
                        <div class="property-group">
                            <label class="property-label">Output Format</label>
                            <select class="property-input" onchange="updateNodeConfig('${node.id}', 'format', this.value)">
                                <option value="csv" ${node.config.format === 'csv' ? 'selected' : ''}>CSV</option>
                                <option value="json" ${node.config.format === 'json' ? 'selected' : ''}>JSON</option>
                                <option value="xml" ${node.config.format === 'xml' ? 'selected' : ''}>XML</option>
                            </select>
                        </div>
                        <div class="property-group">
                            <label class="property-label">File Name</label>
                            <input class="property-input" type="text" value="${node.config.fileName}"
                                onchange="updateNodeConfig('${node.id}', 'fileName', this.value)">
                        </div>
                        <button class="btn btn-success" onclick="downloadOutput('${node.id}')" style="width: 100%; margin-top: 1rem;">
                            ‚¨áÔ∏è Download
                        </button>
                    `;
                    break;
            }

            // Data preview
            if (node.data && node.data.data.length > 0) {
                html += `
                    <div class="data-preview">
                        <div class="data-preview-header">Preview (${node.data.data.length} rows)</div>
                        <div class="preview-scroll">
                            <table class="data-table">
                                <thead>
                                    <tr>
                                        ${node.data.headers.slice(0, 5).map(h => `<th>${h}</th>`).join('')}
                                        ${node.data.headers.length > 5 ? '<th>...</th>' : ''}
                                    </tr>
                                </thead>
                                <tbody>
                                    ${node.data.data.slice(0, 10).map(row => `
                                        <tr>
                                            ${node.data.headers.slice(0, 5).map(h => `<td>${row[h] ?? ''}</td>`).join('')}
                                            ${node.data.headers.length > 5 ? '<td>...</td>' : ''}
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        </div>
                    </div>
                `;
            }

            // Delete button
            html += `
                <button class="btn btn-secondary" onclick="deleteNode('${node.id}')"
                    style="width: 100%; margin-top: 1rem; color: var(--error);">
                    üóëÔ∏è Delete Node
                </button>
            `;

            panel.innerHTML = html;
        }

        function showDefaultProperties() {
            document.getElementById('propertiesContent').innerHTML = `
                <p style="color: var(--text-secondary); font-size: 0.875rem;">
                    Select a node to view and edit its properties.
                </p>

                <div class="drop-zone" id="quickDropZone">
                    <div class="drop-zone-icon">üìÅ</div>
                    <div>Drop file here to start</div>
                    <small style="color: var(--text-secondary)">CSV, JSON, XML, XLSX</small>
                </div>
            `;
            setupFileDropZone();
        }

        function getInputHeaders(nodeId) {
            const inputs = pipeline.getInputNodes(nodeId);
            if (inputs.length > 0 && inputs[0].data) {
                return inputs[0].data.headers;
            }
            return [];
        }

        function updateNodeConfig(nodeId, key, value) {
            const node = pipeline.nodes.get(nodeId);
            if (node) {
                node.config[key] = value;
            }
        }

        function toggleColumn(nodeId, column, checked) {
            const node = pipeline.nodes.get(nodeId);
            if (node) {
                if (checked && !node.config.columns.includes(column)) {
                    node.config.columns.push(column);
                } else if (!checked) {
                    node.config.columns = node.config.columns.filter(c => c !== column);
                }
            }
        }

        function updateGroupBy(nodeId, select) {
            const node = pipeline.nodes.get(nodeId);
            if (node) {
                node.config.groupBy = Array.from(select.selectedOptions).map(o => o.value);
            }
        }

        function addAggregation(nodeId) {
            const node = pipeline.nodes.get(nodeId);
            if (node) {
                if (!node.config.aggregations) node.config.aggregations = [];
                node.config.aggregations.push({ function: 'sum', column: '', alias: '' });
                showNodeProperties(node);
            }
        }

        function updateAggregation(nodeId, index, key, value) {
            const node = pipeline.nodes.get(nodeId);
            if (node && node.config.aggregations[index]) {
                node.config.aggregations[index][key] = value;
            }
        }

        function deleteNode(nodeId) {
            pipeline.nodes.delete(nodeId);
            pipeline.connections = pipeline.connections.filter(c => c.from !== nodeId && c.to !== nodeId);
            document.getElementById(nodeId)?.remove();
            renderConnections();
            selectNode(null);
        }

        async function runPipeline() {
            showProgress('Running pipeline...', 0);

            try {
                const result = await pipeline.execute((progress) => {
                    updateProgress(progress.progress, progress.message);
                });

                // Update node displays
                for (const [id, node] of pipeline.nodes) {
                    const el = document.getElementById(id);
                    if (el) {
                        el.querySelector('.pipeline-node-body').textContent = getNodeBodyContent(node);
                    }
                }

                // Update stats
                const outputNodes = Array.from(pipeline.nodes.values()).filter(n => n.type === 'output');
                if (outputNodes.length > 0 && outputNodes[0].data) {
                    updateStats(outputNodes[0].data.data.length, outputNodes[0].data.headers.length, result.duration);
                }

                hideProgress();
                showToast(`Pipeline completed in ${result.duration.toFixed(0)}ms`);

                if (pipeline.selectedNode) {
                    showNodeProperties(pipeline.nodes.get(pipeline.selectedNode));
                }

            } catch (e) {
                hideProgress();
                showToast('Error: ' + e.message, true);
            }
        }

        function downloadOutput(nodeId) {
            const node = pipeline.nodes.get(nodeId);
            if (!node || !node.data) {
                showToast('No data to export', true);
                return;
            }

            let content, mimeType, ext;

            switch(node.config.format) {
                case 'csv':
                    content = Exporters.toCSV(node.data.headers, node.data.data);
                    mimeType = 'text/csv';
                    ext = 'csv';
                    break;
                case 'json':
                    content = Exporters.toJSON(node.data.data);
                    mimeType = 'application/json';
                    ext = 'json';
                    break;
                case 'xml':
                    content = Exporters.toXML(node.data.data);
                    mimeType = 'application/xml';
                    ext = 'xml';
                    break;
            }

            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${node.config.fileName || 'output'}.${ext}`;
            a.click();
            URL.revokeObjectURL(url);

            showToast(`Downloaded ${a.download}`);
        }

        function exportPipeline() {
            const data = pipeline.exportPipeline();
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'pipeline.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function importPipeline() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                const text = await file.text();
                const data = JSON.parse(text);

                document.getElementById('pipelineCanvas').innerHTML = '';
                pipeline.importPipeline(data);

                for (const [id, node] of pipeline.nodes) {
                    renderNode(node);
                }
                renderConnections();
                showToast('Pipeline imported');
            };
            input.click();
        }

        // ============================================
        // TEST SUITE
        // ============================================

        async function runTests() {
            showProgress('Running tests...', 0);

            const tests = [
                { name: 'CSV Parse', fn: testCSVParse },
                { name: 'JSON Parse', fn: testJSONParse },
                { name: 'XML Parse', fn: testXMLParse },
                { name: 'Filter Transform', fn: testFilter },
                { name: 'Map Transform', fn: testMap },
                { name: 'Sort Transform', fn: testSort },
                { name: 'Aggregate Transform', fn: testAggregate },
                { name: 'Join Transform', fn: testJoin },
                { name: 'CSV Export', fn: testCSVExport },
                { name: 'JSON Export', fn: testJSONExport },
                { name: 'Large Dataset (100K rows)', fn: testLargeDataset },
                { name: 'Pipeline Execution', fn: testPipelineExecution },
            ];

            const results = [];

            for (let i = 0; i < tests.length; i++) {
                updateProgress((i / tests.length) * 100, `Testing: ${tests[i].name}`);

                try {
                    const start = performance.now();
                    await tests[i].fn();
                    const duration = performance.now() - start;
                    results.push({ name: tests[i].name, pass: true, duration });
                } catch (e) {
                    results.push({ name: tests[i].name, pass: false, error: e.message });
                }
            }

            hideProgress();
            showTestResults(results);
        }

        async function testCSVParse() {
            const csv = `name,age,city
John,30,NYC
Jane,25,LA
Bob,35,Chicago`;
            const result = await Parsers.parseCSV(csv);
            if (result.data.length !== 3) throw new Error('Wrong row count');
            if (result.headers.length !== 3) throw new Error('Wrong column count');
            if (result.data[0].name !== 'John') throw new Error('Wrong data');
        }

        async function testJSONParse() {
            const json = '[{"name":"John","age":30},{"name":"Jane","age":25}]';
            const result = await Parsers.parseJSON(json);
            if (result.data.length !== 2) throw new Error('Wrong row count');
            if (result.data[0].name !== 'John') throw new Error('Wrong data');
        }

        async function testXMLParse() {
            const xml = `<data><row><name>John</name><age>30</age></row><row><name>Jane</name><age>25</age></row></data>`;
            const result = await Parsers.parseXML(xml);
            if (result.data.length !== 2) throw new Error('Wrong row count');
            if (result.data[0].name !== 'John') throw new Error('Wrong data');
        }

        async function testFilter() {
            const data = [{ age: 20 }, { age: 30 }, { age: 40 }];
            const result = Transforms.filter(data, 'row.age > 25');
            if (result.length !== 2) throw new Error('Filter failed');
        }

        async function testMap() {
            const data = [{ a: 1, b: 2 }];
            const result = Transforms.map(data, 'row.c = row.a + row.b;');
            if (result[0].c !== 3) throw new Error('Map failed');
        }

        async function testSort() {
            const data = [{ n: 3 }, { n: 1 }, { n: 2 }];
            const result = Transforms.sort(data, 'n', 'asc');
            if (result[0].n !== 1) throw new Error('Sort failed');
        }

        async function testAggregate() {
            const data = [
                { cat: 'A', val: 10 },
                { cat: 'A', val: 20 },
                { cat: 'B', val: 30 }
            ];
            const result = Transforms.aggregate(data, ['cat'], [
                { function: 'sum', column: 'val', alias: 'total' }
            ]);
            const groupA = result.find(r => r.cat === 'A');
            if (groupA.total !== 30) throw new Error('Aggregate failed');
        }

        async function testJoin() {
            const left = [{ id: 1, name: 'John' }, { id: 2, name: 'Jane' }];
            const right = [{ id: 1, city: 'NYC' }, { id: 3, city: 'LA' }];
            const result = Transforms.join(left, right, 'id', 'id', 'inner');
            if (result.length !== 1) throw new Error('Join failed');
            if (result[0].city !== 'NYC') throw new Error('Join data wrong');
        }

        async function testCSVExport() {
            const headers = ['name', 'age'];
            const data = [{ name: 'John', age: 30 }];
            const csv = Exporters.toCSV(headers, data);
            if (!csv.includes('John')) throw new Error('CSV export failed');
        }

        async function testJSONExport() {
            const data = [{ name: 'John' }];
            const json = Exporters.toJSON(data);
            const parsed = JSON.parse(json);
            if (parsed[0].name !== 'John') throw new Error('JSON export failed');
        }

        async function testLargeDataset() {
            // Generate 100K rows
            const data = [];
            for (let i = 0; i < 100000; i++) {
                data.push({ id: i, value: Math.random(), category: ['A', 'B', 'C'][i % 3] });
            }

            const start = performance.now();

            // Filter
            const filtered = Transforms.filter(data, 'row.value > 0.5');

            // Sort
            const sorted = Transforms.sort(filtered, 'value', 'desc');

            // Aggregate
            const aggregated = Transforms.aggregate(sorted, ['category'], [
                { function: 'count', column: 'id', alias: 'count' },
                { function: 'avg', column: 'value', alias: 'avg_value' }
            ]);

            const duration = performance.now() - start;

            if (duration > 10000) throw new Error(`Too slow: ${duration}ms`);
            if (aggregated.length !== 3) throw new Error('Wrong aggregation');
        }

        async function testPipelineExecution() {
            const testPipeline = new PipelineManager();

            // Create nodes
            const inputNode = testPipeline.addNode('input-file', 0, 0);
            inputNode.data = {
                headers: ['id', 'value'],
                data: [{ id: 1, value: 10 }, { id: 2, value: 20 }, { id: 3, value: 30 }]
            };

            const filterNode = testPipeline.addNode('filter', 100, 0);
            filterNode.config.expression = 'row.value > 15';

            const outputNode = testPipeline.addNode('output', 200, 0);
            outputNode.config.format = 'json';

            testPipeline.connect(inputNode.id, filterNode.id);
            testPipeline.connect(filterNode.id, outputNode.id);

            await testPipeline.execute();

            if (!outputNode.data || outputNode.data.data.length !== 2) {
                throw new Error('Pipeline execution failed');
            }
        }

        function showTestResults(results) {
            const passed = results.filter(r => r.pass).length;
            const total = results.length;

            let html = `
                <h3 style="margin-bottom: 1rem;">Test Results: ${passed}/${total} passed</h3>
                <div class="test-results">
            `;

            for (const result of results) {
                html += `
                    <div class="test-item ${result.pass ? 'pass' : 'fail'}">
                        <span>${result.pass ? '‚úÖ' : '‚ùå'}</span>
                        <span>${result.name}</span>
                        ${result.duration ? `<span style="margin-left: auto; color: var(--text-secondary);">${result.duration.toFixed(1)}ms</span>` : ''}
                        ${result.error ? `<span style="color: var(--error); font-size: 0.75rem;">${result.error}</span>` : ''}
                    </div>
                `;
            }

            html += '</div>';

            document.getElementById('propertiesContent').innerHTML = html;
        }

        // ============================================
        // UI HELPERS
        // ============================================

        function showProgress(title, percent) {
            document.getElementById('progressOverlay').classList.remove('hidden');
            document.getElementById('progressTitle').textContent = title;
            document.getElementById('progressFill').style.width = percent + '%';
            document.getElementById('progressText').textContent = '';
        }

        function updateProgress(percent, text) {
            document.getElementById('progressFill').style.width = percent + '%';
            document.getElementById('progressText').textContent = text;
        }

        function hideProgress() {
            document.getElementById('progressOverlay').classList.add('hidden');
        }

        function showToast(message, isError = false) {
            const existing = document.querySelector('.toast');
            if (existing) existing.remove();

            const toast = document.createElement('div');
            toast.className = 'toast' + (isError ? ' error' : '');
            toast.textContent = message;
            document.body.appendChild(toast);

            setTimeout(() => toast.remove(), 3000);
        }

        function updateStats(rows, cols, time) {
            document.getElementById('statRows').textContent = rows?.toLocaleString() || '0';
            document.getElementById('statCols').textContent = cols || '0';
            document.getElementById('statTime').textContent = time ? `${time.toFixed(0)}ms` : '-';

            if (performance.memory) {
                const mb = (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(1);
                document.getElementById('statMemory').textContent = mb + 'MB';
            }
        }

        // Initialize
        init();
    </script>
</body>
</html>
