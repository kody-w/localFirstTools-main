<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="rappterzoo:author" content="RappterZoo">
    <meta name="rappterzoo:author-type" content="agent">
    <meta name="rappterzoo:category" content="creative_tools">
    <meta name="rappterzoo:tags" content="circuit, logic, digital, simulator, electronics, gates, education">
    <meta name="rappterzoo:type" content="interactive">
    <meta name="rappterzoo:complexity" content="advanced">
    <meta name="rappterzoo:created" content="2025-01-15">
    <meta name="rappterzoo:generation" content="2">
    <title>Digital Logic Circuit Simulator</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        #toolbar {
            background: #2a2a2a;
            border-bottom: 2px solid #3a3a3a;
            padding: 10px 16px;
            display: flex;
            gap: 16px;
            align-items: center;
            flex-wrap: wrap;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            z-index: 10;
        }
        .toolbar-section {
            display: flex;
            gap: 6px;
            align-items: center;
            padding: 0 10px;
            border-right: 1px solid #3a3a3a;
        }
        .toolbar-section:last-child { border-right: none; }
        .toolbar-section label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #888;
            margin-right: 4px;
        }
        button {
            background: #3a3a3a;
            border: 1px solid #4a4a4a;
            color: #e0e0e0;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.15s;
            font-weight: 500;
        }
        button:hover { background: #4a4a4a; border-color: #5a5a5a; }
        button.active { background: #0066cc; border-color: #0077dd; color: white; }
        button.preset { background: #2a4a2a; border-color: #3a5a3a; }
        button.preset:hover { background: #3a5a3a; }
        button.danger { background: #4a2a2a; border-color: #5a3a3a; }
        button.danger:hover { background: #5a3a3a; }
        button.action { background: #2a3a4a; border-color: #3a4a5a; }
        button.action:hover { background: #3a4a5a; }
        button:disabled { opacity: 0.4; cursor: not-allowed; }
        .component-btn {
            min-width: 50px;
            font-family: monospace;
            font-size: 11px;
            padding: 5px 8px;
        }
        #canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #1e1e1e;
        }
        #canvas { display: block; }
        #canvas.wire-mode { cursor: pointer; }
        #canvas.delete-mode { cursor: not-allowed; }
        #canvas.move-mode { cursor: grab; }
        #status {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(42, 42, 42, 0.95);
            padding: 6px 14px;
            border-radius: 4px;
            font-size: 11px;
            color: #aaa;
            border: 1px solid #3a3a3a;
        }
        #help-overlay {
            display: none;
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }
        #help-overlay.visible { display: flex; }
        #help-content {
            background: #2a2a2a;
            border: 1px solid #4a4a4a;
            padding: 30px;
            border-radius: 8px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }
        #help-content h2 {
            color: #0099ff;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }
        #help-content h3 { color: #88bbdd; margin: 12px 0 6px; font-size: 0.9rem; }
        #help-content p { color: #aaa; margin-bottom: 8px; font-size: 0.85rem; line-height: 1.5; }
        #help-content kbd {
            background: #3a3a3a;
            border: 1px solid #555;
            padding: 1px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 0.8rem;
            color: #ddd;
        }
        .hint {
            color: #666;
            font-size: 10px;
            font-style: italic;
            margin-left: 6px;
        }
        .comp-count {
            font-size: 10px;
            color: #666;
            margin-left: auto;
            font-family: monospace;
        }
        .toast {
            position: fixed;
            top: 60px;
            right: 20px;
            background: #2a4a2a;
            border: 1px solid #3a5a3a;
            color: #88dd88;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 13px;
            z-index: 200;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s;
            pointer-events: none;
        }
        .toast.visible { opacity: 1; transform: translateY(0); }
        .toast.error { background: #4a2a2a; border-color: #5a3a3a; color: #dd8888; }
    </style>
</head>
<body>
    <div id="toolbar">
        <div class="toolbar-section">
            <label>Gates</label>
            <button class="component-btn" data-type="SWITCH" title="Toggle switch (input)">SW</button>
            <button class="component-btn" data-type="LED" title="LED indicator (output)">LED</button>
            <button class="component-btn" data-type="AND" title="AND gate">AND</button>
            <button class="component-btn" data-type="OR" title="OR gate">OR</button>
            <button class="component-btn" data-type="NOT" title="NOT gate (inverter)">NOT</button>
            <button class="component-btn" data-type="NAND" title="NAND gate">NAND</button>
            <button class="component-btn" data-type="NOR" title="NOR gate">NOR</button>
            <button class="component-btn" data-type="XOR" title="XOR gate">XOR</button>
        </div>
        <div class="toolbar-section">
            <label>Mode</label>
            <button id="modePlace" class="active" title="Place components (P)">Place</button>
            <button id="modeWire" title="Wire components (W)">Wire</button>
            <button id="modeMove" title="Move components (M)">Move</button>
            <button id="modeDelete" title="Delete components (D)">Delete</button>
        </div>
        <div class="toolbar-section">
            <label>Circuit</label>
            <button class="action" id="undoBtn" title="Undo (Ctrl+Z)" disabled>Undo</button>
            <button class="action" id="saveBtn" title="Save to browser (Ctrl+S)">Save</button>
            <button class="action" id="exportBtn" title="Export as JSON">Export</button>
            <button class="action" id="importBtn" title="Import from JSON">Import</button>
        </div>
        <div class="toolbar-section">
            <label>Presets</label>
            <button class="preset" data-preset="halfadder">Half Adder</button>
            <button class="preset" data-preset="srlatch">SR Latch</button>
            <button class="preset" data-preset="fulladder">Full Adder</button>
        </div>
        <div class="toolbar-section">
            <button class="danger" id="clearBtn">Clear</button>
            <button id="helpBtn" title="Help (?)" style="background:#2a3a4a;border-color:#3a4a5a">?</button>
        </div>
        <span class="comp-count" id="compCount">0 components, 0 wires</span>
    </div>

    <div id="canvas-container">
        <canvas id="canvas"></canvas>
        <div id="status">Ready -- Press ? for help</div>
    </div>

    <div id="help-overlay">
        <div id="help-content">
            <h2>Digital Logic Circuit Simulator</h2>
            <h3>Components</h3>
            <p><strong>SWITCH</strong> -- Click to toggle between HIGH (1) and LOW (0). This is your input source.</p>
            <p><strong>LED</strong> -- Lights up green when receiving HIGH signal. This is your output indicator.</p>
            <p><strong>AND, OR, NOT, NAND, NOR, XOR</strong> -- Standard logic gates with labeled truth tables.</p>
            <h3>Modes</h3>
            <p><kbd>P</kbd> <strong>Place</strong> -- Click canvas to place selected component. Click switches to toggle them.</p>
            <p><kbd>W</kbd> <strong>Wire</strong> -- Click an output pin (right side), then click an input pin (left side) to connect.</p>
            <p><kbd>M</kbd> <strong>Move</strong> -- Click and drag components to reposition them.</p>
            <p><kbd>D</kbd> <strong>Delete</strong> -- Click a component or wire to remove it.</p>
            <h3>Shortcuts</h3>
            <p><kbd>Ctrl+Z</kbd> Undo | <kbd>Ctrl+S</kbd> Save | <kbd>Ctrl+E</kbd> Export | <kbd>1-8</kbd> Select gate | <kbd>?</kbd> Help</p>
            <h3>Tips</h3>
            <p>Signals propagate automatically. Green = HIGH, gray = LOW. Build combinational or sequential circuits. The SR Latch preset demonstrates memory (feedback loops).</p>
            <p style="margin-top:15px"><button id="helpClose" style="width:100%">Close</button></p>
        </div>
    </div>

    <div class="toast" id="toast"></div>

    <input type="file" id="fileInput" accept=".json" style="display:none">

    <script>
    (function() {
        'use strict';

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');
        const toastEl = document.getElementById('toast');
        const compCountEl = document.getElementById('compCount');

        // --- State ---
        let components = [];
        let wires = [];
        let selectedComponent = 'AND';
        let mode = 'place';
        let wireStart = null;
        let gridSize = 20;
        let componentIdCounter = 0;
        let undoStack = [];
        const MAX_UNDO = 50;
        let movingComp = null;
        let moveOffset = { x: 0, y: 0 };

        // Colors
        const C = {
            bg: '#1e1e1e', grid: '#252525', gridMajor: '#2a2a2a',
            comp: '#3a3a3a', compBorder: '#555', compActive: '#4a5a4a',
            compHover: '#4a4a4a',
            text: '#e0e0e0', textDim: '#888',
            high: '#00ff00', low: '#555',
            ledOff: '#442222', ledOn: '#00ff00',
            pin: '#666', pinHot: '#ffaa00', pinHover: '#ffcc44',
            wire: '#888', wireHigh: '#00ff00', wireLow: '#555',
            wirePreview: '#ffaa00'
        };

        // Component definitions
        const DEFS = {
            SWITCH: { inputs: 0, outputs: 1, w: 3, h: 2, label: 'SW' },
            LED:    { inputs: 1, outputs: 0, w: 2, h: 2, label: 'LED' },
            AND:    { inputs: 2, outputs: 1, w: 4, h: 3, label: 'AND' },
            OR:     { inputs: 2, outputs: 1, w: 4, h: 3, label: 'OR' },
            NOT:    { inputs: 1, outputs: 1, w: 3, h: 2, label: 'NOT' },
            NAND:   { inputs: 2, outputs: 1, w: 4, h: 3, label: 'NAND' },
            NOR:    { inputs: 2, outputs: 1, w: 4, h: 3, label: 'NOR' },
            XOR:    { inputs: 2, outputs: 1, w: 4, h: 3, label: 'XOR' }
        };

        function gateLogic(type, ins, switchState) {
            switch (type) {
                case 'SWITCH': return [switchState ? 1 : 0];
                case 'LED': return [];
                case 'AND': return [(ins[0] && ins[1]) ? 1 : 0];
                case 'OR': return [(ins[0] || ins[1]) ? 1 : 0];
                case 'NOT': return [ins[0] ? 0 : 1];
                case 'NAND': return [(ins[0] && ins[1]) ? 0 : 1];
                case 'NOR': return [(ins[0] || ins[1]) ? 0 : 1];
                case 'XOR': return [(ins[0] !== ins[1]) ? 1 : 0];
                default: return [];
            }
        }

        // --- Toast ---
        let toastTimer = null;
        function showToast(msg, error) {
            toastEl.textContent = msg;
            toastEl.className = 'toast visible' + (error ? ' error' : '');
            clearTimeout(toastTimer);
            toastTimer = setTimeout(() => { toastEl.className = 'toast'; }, 2500);
        }

        // --- Canvas Setup ---
        function resizeCanvas() {
            const container = document.getElementById('canvas-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            render();
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function snap(val) { return Math.round(val / gridSize) * gridSize; }

        // --- Component Class ---
        class Comp {
            constructor(type, x, y, id) {
                this.id = id !== undefined ? id : componentIdCounter++;
                this.type = type;
                this.x = snap(x);
                this.y = snap(y);
                this.def = DEFS[type];
                this.inputValues = new Array(this.def.inputs).fill(0);
                this.outputValues = new Array(this.def.outputs).fill(0);
                this.state = false;
            }
            getInputPos(i) {
                const sp = this.def.h * gridSize / (this.def.inputs + 1);
                return { x: this.x, y: this.y + sp * (i + 1) };
            }
            getOutputPos(i) {
                const sp = this.def.h * gridSize / (this.def.outputs + 1);
                return { x: this.x + this.def.w * gridSize, y: this.y + sp * (i + 1) };
            }
            contains(x, y) {
                return x >= this.x && x <= this.x + this.def.w * gridSize &&
                       y >= this.y && y <= this.y + this.def.h * gridSize;
            }
            getInputAt(x, y) {
                for (let i = 0; i < this.def.inputs; i++) {
                    const p = this.getInputPos(i);
                    if (Math.hypot(x - p.x, y - p.y) < 12) return i;
                }
                return -1;
            }
            getOutputAt(x, y) {
                for (let i = 0; i < this.def.outputs; i++) {
                    const p = this.getOutputPos(i);
                    if (Math.hypot(x - p.x, y - p.y) < 12) return i;
                }
                return -1;
            }
            compute() {
                this.outputValues = gateLogic(this.type, this.inputValues, this.state);
            }
            draw(hovered) {
                const w = this.def.w * gridSize;
                const h = this.def.h * gridSize;
                const isActive = this.type === 'SWITCH' && this.state;

                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fillRect(this.x + 2, this.y + 2, w, h);

                // Body
                ctx.fillStyle = hovered ? C.compHover : (isActive ? C.compActive : C.comp);
                ctx.fillRect(this.x, this.y, w, h);
                ctx.strokeStyle = hovered ? '#777' : C.compBorder;
                ctx.lineWidth = hovered ? 2 : 1.5;
                ctx.strokeRect(this.x, this.y, w, h);

                // Label
                ctx.fillStyle = C.text;
                ctx.font = 'bold 11px monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.def.label, this.x + w / 2, this.y + h / 2);

                // Switch indicator
                if (this.type === 'SWITCH') {
                    ctx.fillStyle = this.state ? C.high : C.low;
                    ctx.font = '9px monospace';
                    ctx.fillText(this.state ? 'ON' : 'OFF', this.x + w / 2, this.y + h / 2 + 12);
                }

                // Input pins
                for (let i = 0; i < this.def.inputs; i++) {
                    const p = this.getInputPos(i);
                    // Connection line
                    ctx.strokeStyle = this.inputValues[i] ? C.high : C.low;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(p.x - 8, p.y);
                    ctx.lineTo(p.x, p.y);
                    ctx.stroke();
                    // Pin dot
                    ctx.fillStyle = this.inputValues[i] ? C.high : C.pin;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }

                // Output pins
                for (let i = 0; i < this.def.outputs; i++) {
                    const p = this.getOutputPos(i);
                    ctx.strokeStyle = this.outputValues[i] ? C.high : C.low;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(p.x + 8, p.y);
                    ctx.stroke();
                    ctx.fillStyle = this.outputValues[i] ? C.high : C.pin;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }

                // LED rendering
                if (this.type === 'LED') {
                    const isOn = this.inputValues[0] === 1;
                    const cx = this.x + w / 2;
                    const cy = this.y + h / 2;
                    if (isOn) {
                        // Glow
                        ctx.shadowColor = C.ledOn;
                        ctx.shadowBlur = 20;
                    }
                    ctx.fillStyle = isOn ? C.ledOn : C.ledOff;
                    ctx.beginPath();
                    ctx.arc(cx, cy, 12, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = isOn ? '#00cc00' : '#553333';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    // Inner highlight
                    if (isOn) {
                        ctx.fillStyle = 'rgba(255,255,255,0.3)';
                        ctx.beginPath();
                        ctx.arc(cx - 3, cy - 3, 5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.shadowBlur = 0;
                    ctx.shadowColor = 'transparent';
                }
            }
        }

        // --- Wire Class ---
        class WireObj {
            constructor(fromComp, fromPin, toComp, toPin) {
                this.fromId = fromComp.id;
                this.fromPin = fromPin;
                this.toId = toComp.id;
                this.toPin = toPin;
                this.signal = 0;
            }
            getFrom() { return components.find(c => c.id === this.fromId); }
            getTo() { return components.find(c => c.id === this.toId); }
            getPath() {
                const from = this.getFrom();
                const to = this.getTo();
                if (!from || !to) return null;
                const s = from.getOutputPos(this.fromPin);
                const e = to.getInputPos(this.toPin);
                const midX = (s.x + e.x) / 2;
                return [s, { x: midX, y: s.y }, { x: midX, y: e.y }, e];
            }
            hitTest(x, y) {
                const path = this.getPath();
                if (!path) return false;
                for (let i = 0; i < path.length - 1; i++) {
                    if (distToSeg(x, y, path[i].x, path[i].y, path[i+1].x, path[i+1].y) < 8)
                        return true;
                }
                return false;
            }
            draw() {
                const path = this.getPath();
                if (!path) return;
                const color = this.signal ? C.wireHigh : C.wireLow;
                // Glow for high signals
                if (this.signal) {
                    ctx.shadowColor = C.wireHigh;
                    ctx.shadowBlur = 6;
                }
                ctx.strokeStyle = color;
                ctx.lineWidth = this.signal ? 3 : 2;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                ctx.moveTo(path[0].x, path[0].y);
                for (let i = 1; i < path.length; i++) ctx.lineTo(path[i].x, path[i].y);
                ctx.stroke();
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
            }
        }

        function distToSeg(px, py, x1, y1, x2, y2) {
            const A = px - x1, B = py - y1, CX = x2 - x1, D = y2 - y1;
            const dot = A * CX + B * D;
            const lenSq = CX * CX + D * D;
            let t = lenSq !== 0 ? dot / lenSq : -1;
            t = Math.max(0, Math.min(1, t));
            return Math.hypot(px - (x1 + t * CX), py - (y1 + t * D));
        }

        // --- Simulation ---
        function propagate() {
            for (let iter = 0; iter < 100; iter++) {
                let changed = false;
                components.forEach(c => {
                    const old = [...c.outputValues];
                    c.compute();
                    if (old.some((v, i) => v !== c.outputValues[i])) changed = true;
                });
                wires.forEach(w => {
                    const from = w.getFrom();
                    const to = w.getTo();
                    if (!from || !to) return;
                    const sig = from.outputValues[w.fromPin] || 0;
                    w.signal = sig;
                    if (to.inputValues[w.toPin] !== sig) {
                        to.inputValues[w.toPin] = sig;
                        changed = true;
                    }
                });
                if (!changed) break;
            }
        }

        // --- Undo System ---
        function pushUndo() {
            undoStack.push(serializeCircuit());
            if (undoStack.length > MAX_UNDO) undoStack.shift();
            document.getElementById('undoBtn').disabled = false;
        }

        function undo() {
            if (undoStack.length === 0) return;
            const data = undoStack.pop();
            loadCircuit(data, true);
            document.getElementById('undoBtn').disabled = undoStack.length === 0;
            showToast('Undo');
        }

        // --- Serialization ---
        function serializeCircuit() {
            return JSON.stringify({
                version: 2,
                idCounter: componentIdCounter,
                components: components.map(c => ({
                    id: c.id, type: c.type, x: c.x, y: c.y, state: c.state
                })),
                wires: wires.map(w => ({
                    fromId: w.fromId, fromPin: w.fromPin,
                    toId: w.toId, toPin: w.toPin
                }))
            });
        }

        function loadCircuit(json, skipUndo) {
            try {
                const data = typeof json === 'string' ? JSON.parse(json) : json;
                if (!skipUndo) pushUndo();
                components = [];
                wires = [];
                wireStart = null;
                componentIdCounter = data.idCounter || 0;
                for (const cd of data.components) {
                    const c = new Comp(cd.type, cd.x, cd.y, cd.id);
                    c.state = cd.state || false;
                    components.push(c);
                    if (c.id >= componentIdCounter) componentIdCounter = c.id + 1;
                }
                for (const wd of data.wires) {
                    const from = components.find(c => c.id === wd.fromId);
                    const to = components.find(c => c.id === wd.toId);
                    if (from && to) {
                        wires.push(new WireObj(from, wd.fromPin, to, wd.toPin));
                    }
                }
                propagate();
                render();
                updateCount();
                return true;
            } catch (e) {
                showToast('Failed to load circuit: ' + e.message, true);
                return false;
            }
        }

        // --- Save/Load ---
        function saveToStorage() {
            try {
                localStorage.setItem('circuit-simulator-data', serializeCircuit());
                showToast('Circuit saved');
            } catch (e) {
                showToast('Save failed', true);
            }
        }

        function loadFromStorage() {
            try {
                const data = localStorage.getItem('circuit-simulator-data');
                if (data) {
                    loadCircuit(data);
                    statusEl.textContent = 'Loaded saved circuit';
                }
            } catch (e) {}
        }

        function exportCircuit() {
            const data = serializeCircuit();
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'circuit-' + new Date().toISOString().slice(0, 10) + '.json';
            a.click();
            URL.revokeObjectURL(url);
            showToast('Circuit exported');
        }

        function importCircuit() {
            document.getElementById('fileInput').click();
        }

        document.getElementById('fileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
                if (loadCircuit(ev.target.result)) {
                    showToast('Circuit imported: ' + file.name);
                }
            };
            reader.readAsText(file);
            e.target.value = '';
        });

        // --- Update Count ---
        function updateCount() {
            compCountEl.textContent = components.length + ' components, ' + wires.length + ' wires';
        }

        // --- Mouse Tracking ---
        let mouseX = 0, mouseY = 0;
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;

            if (mode === 'move' && movingComp) {
                movingComp.x = snap(mouseX - moveOffset.x);
                movingComp.y = snap(mouseY - moveOffset.y);
                render();
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (movingComp) {
                movingComp = null;
                propagate();
                render();
                saveToStorage();
            }
        });

        // --- Rendering ---
        function render() {
            ctx.fillStyle = C.bg;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Grid - minor
            ctx.strokeStyle = C.grid;
            ctx.lineWidth = 0.5;
            for (let x = 0; x < canvas.width; x += gridSize) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
            }
            // Grid - major (every 5)
            ctx.strokeStyle = C.gridMajor;
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += gridSize * 5) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += gridSize * 5) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
            }

            // Wires
            wires.forEach(w => w.draw());

            // Components
            const hoveredComp = (mode === 'place' || mode === 'move' || mode === 'delete')
                ? components.find(c => c.contains(mouseX, mouseY))
                : null;
            components.forEach(c => c.draw(c === hoveredComp));

            // Wire preview
            if (mode === 'wire' && wireStart) {
                const from = wireStart.comp;
                const pos = from.getOutputPos(wireStart.pin);
                // Dashed line to mouse
                ctx.strokeStyle = C.wirePreview;
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                const midX = (pos.x + mouseX) / 2;
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                ctx.lineTo(midX, pos.y);
                ctx.lineTo(midX, mouseY);
                ctx.lineTo(mouseX, mouseY);
                ctx.stroke();
                ctx.setLineDash([]);
                // Highlight source pin
                ctx.strokeStyle = C.pinHot;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 7, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Place preview (ghost)
            if (mode === 'place' && !hoveredComp) {
                const def = DEFS[selectedComponent];
                const sx = snap(mouseX);
                const sy = snap(mouseY);
                ctx.globalAlpha = 0.3;
                ctx.fillStyle = C.comp;
                ctx.fillRect(sx, sy, def.w * gridSize, def.h * gridSize);
                ctx.strokeStyle = C.compBorder;
                ctx.lineWidth = 1;
                ctx.strokeRect(sx, sy, def.w * gridSize, def.h * gridSize);
                ctx.fillStyle = C.text;
                ctx.font = 'bold 11px monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(def.label, sx + def.w * gridSize / 2, sy + def.h * gridSize / 2);
                ctx.globalAlpha = 1;
            }
        }

        // --- Click Handler ---
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (mode === 'place') {
                // Check for switch toggle first
                for (const comp of components) {
                    if (comp.type === 'SWITCH' && comp.contains(x, y)) {
                        pushUndo();
                        comp.state = !comp.state;
                        statusEl.textContent = 'Switch ' + (comp.state ? 'ON' : 'OFF');
                        propagate();
                        render();
                        saveToStorage();
                        return;
                    }
                }
                // Place new component
                const nc = new Comp(selectedComponent, x, y);
                const overlaps = components.some(c =>
                    !(nc.x + nc.def.w * gridSize <= c.x ||
                      nc.x >= c.x + c.def.w * gridSize ||
                      nc.y + nc.def.h * gridSize <= c.y ||
                      nc.y >= c.y + c.def.h * gridSize)
                );
                if (!overlaps) {
                    pushUndo();
                    components.push(nc);
                    statusEl.textContent = 'Placed ' + selectedComponent;
                    propagate();
                    render();
                    updateCount();
                    saveToStorage();
                } else {
                    statusEl.textContent = 'Overlaps existing component';
                }
            } else if (mode === 'wire') {
                for (const comp of components) {
                    if (!wireStart) {
                        const oi = comp.getOutputAt(x, y);
                        if (oi !== -1) {
                            wireStart = { comp, pin: oi };
                            statusEl.textContent = 'Wire from ' + comp.type + ' output ' + oi + ' -- click an input pin';
                            render();
                            return;
                        }
                    } else {
                        const ii = comp.getInputAt(x, y);
                        if (ii !== -1) {
                            // Check for duplicate wire
                            const dup = wires.some(w =>
                                w.toId === comp.id && w.toPin === ii
                            );
                            if (dup) {
                                statusEl.textContent = 'Input already connected';
                                wireStart = null;
                                render();
                                return;
                            }
                            pushUndo();
                            wires.push(new WireObj(wireStart.comp, wireStart.pin, comp, ii));
                            statusEl.textContent = 'Connected to ' + comp.type + ' input ' + ii;
                            wireStart = null;
                            propagate();
                            render();
                            updateCount();
                            saveToStorage();
                            return;
                        }
                    }
                }
                if (wireStart) {
                    wireStart = null;
                    statusEl.textContent = 'Wire cancelled';
                    render();
                }
            } else if (mode === 'move') {
                // Toggle switches in move mode too
                for (const comp of components) {
                    if (comp.type === 'SWITCH' && comp.contains(x, y)) {
                        pushUndo();
                        comp.state = !comp.state;
                        propagate();
                        render();
                        saveToStorage();
                        return;
                    }
                }
            } else if (mode === 'delete') {
                let deleted = false;
                // Check components (last added = top)
                for (let i = components.length - 1; i >= 0; i--) {
                    if (components[i].contains(x, y)) {
                        pushUndo();
                        const comp = components[i];
                        wires = wires.filter(w => w.fromId !== comp.id && w.toId !== comp.id);
                        components.splice(i, 1);
                        statusEl.textContent = 'Deleted ' + comp.type;
                        deleted = true;
                        break;
                    }
                }
                if (!deleted) {
                    for (let i = wires.length - 1; i >= 0; i--) {
                        if (wires[i].hitTest(x, y)) {
                            pushUndo();
                            const to = wires[i].getTo();
                            if (to) to.inputValues[wires[i].toPin] = 0;
                            wires.splice(i, 1);
                            statusEl.textContent = 'Deleted wire';
                            deleted = true;
                            break;
                        }
                    }
                }
                if (deleted) {
                    propagate();
                    render();
                    updateCount();
                    saveToStorage();
                }
            }
        });

        // Move mode: mousedown to start drag
        canvas.addEventListener('mousedown', (e) => {
            if (mode !== 'move') return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            for (let i = components.length - 1; i >= 0; i--) {
                if (components[i].contains(x, y) && components[i].type !== 'SWITCH') {
                    pushUndo();
                    movingComp = components[i];
                    moveOffset.x = x - movingComp.x;
                    moveOffset.y = y - movingComp.y;
                    return;
                }
            }
        });

        // --- Mode Switching ---
        function setMode(newMode) {
            mode = newMode;
            wireStart = null;
            movingComp = null;
            document.querySelectorAll('#toolbar .toolbar-section:nth-child(2) button').forEach(b => b.classList.remove('active'));
            const modeMap = { place: 'modePlace', wire: 'modeWire', move: 'modeMove', delete: 'modeDelete' };
            document.getElementById(modeMap[mode]).classList.add('active');
            canvas.className = mode === 'wire' ? 'wire-mode' : mode === 'delete' ? 'delete-mode' : mode === 'move' ? 'move-mode' : '';
            statusEl.textContent = 'Mode: ' + mode;
            render();
        }

        document.getElementById('modePlace').addEventListener('click', () => setMode('place'));
        document.getElementById('modeWire').addEventListener('click', () => setMode('wire'));
        document.getElementById('modeMove').addEventListener('click', () => setMode('move'));
        document.getElementById('modeDelete').addEventListener('click', () => setMode('delete'));

        // --- Component Selection ---
        document.querySelectorAll('.component-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                selectedComponent = btn.dataset.type;
                setMode('place');
                statusEl.textContent = 'Selected ' + selectedComponent;
            });
        });

        // --- Toolbar Actions ---
        document.getElementById('undoBtn').addEventListener('click', undo);
        document.getElementById('saveBtn').addEventListener('click', saveToStorage);
        document.getElementById('exportBtn').addEventListener('click', exportCircuit);
        document.getElementById('importBtn').addEventListener('click', importCircuit);
        document.getElementById('clearBtn').addEventListener('click', () => {
            if (components.length === 0) return;
            pushUndo();
            components = [];
            wires = [];
            wireStart = null;
            statusEl.textContent = 'Cleared';
            render();
            updateCount();
            saveToStorage();
        });

        // Help overlay
        document.getElementById('helpBtn').addEventListener('click', () => {
            document.getElementById('help-overlay').classList.toggle('visible');
        });
        document.getElementById('helpClose').addEventListener('click', () => {
            document.getElementById('help-overlay').classList.remove('visible');
        });
        document.getElementById('help-overlay').addEventListener('click', (e) => {
            if (e.target === document.getElementById('help-overlay'))
                document.getElementById('help-overlay').classList.remove('visible');
        });

        // --- Presets ---
        document.querySelectorAll('.preset').forEach(btn => {
            btn.addEventListener('click', () => loadPreset(btn.dataset.preset));
        });

        function loadPreset(name) {
            pushUndo();
            components = [];
            wires = [];
            wireStart = null;
            componentIdCounter = 0;

            if (name === 'halfadder') {
                const sa = new Comp('SWITCH', 100, 100);
                const sb = new Comp('SWITCH', 100, 200);
                const xg = new Comp('XOR', 260, 100);
                const ag = new Comp('AND', 260, 220);
                const ls = new Comp('LED', 420, 110);
                const lc = new Comp('LED', 420, 230);
                components.push(sa, sb, xg, ag, ls, lc);
                wires.push(
                    new WireObj(sa, 0, xg, 0), new WireObj(sb, 0, xg, 1),
                    new WireObj(sa, 0, ag, 0), new WireObj(sb, 0, ag, 1),
                    new WireObj(xg, 0, ls, 0), new WireObj(ag, 0, lc, 0)
                );
                statusEl.textContent = 'Half Adder: Sum (top LED) + Carry (bottom LED)';
            } else if (name === 'srlatch') {
                const ss = new Comp('SWITCH', 80, 100);
                const sr = new Comp('SWITCH', 80, 240);
                const n1 = new Comp('NOR', 260, 100);
                const n2 = new Comp('NOR', 260, 240);
                const lq = new Comp('LED', 440, 110);
                const lqb = new Comp('LED', 440, 250);
                components.push(ss, sr, n1, n2, lq, lqb);
                wires.push(
                    new WireObj(ss, 0, n1, 0), new WireObj(sr, 0, n2, 1),
                    new WireObj(n1, 0, n2, 0), new WireObj(n2, 0, n1, 1),
                    new WireObj(n1, 0, lq, 0), new WireObj(n2, 0, lqb, 0)
                );
                statusEl.textContent = 'SR Latch: Set=top switch, Reset=bottom switch';
            } else if (name === 'fulladder') {
                const sa = new Comp('SWITCH', 60, 80);
                const sb = new Comp('SWITCH', 60, 180);
                const sc = new Comp('SWITCH', 60, 300);
                const x1 = new Comp('XOR', 200, 80);
                const a1 = new Comp('AND', 200, 200);
                const x2 = new Comp('XOR', 360, 100);
                const a2 = new Comp('AND', 360, 260);
                const o1 = new Comp('OR', 520, 220);
                const ls = new Comp('LED', 540, 110);
                const lco = new Comp('LED', 680, 230);
                components.push(sa, sb, sc, x1, a1, x2, a2, o1, ls, lco);
                wires.push(
                    new WireObj(sa, 0, x1, 0), new WireObj(sb, 0, x1, 1),
                    new WireObj(sa, 0, a1, 0), new WireObj(sb, 0, a1, 1),
                    new WireObj(x1, 0, x2, 0), new WireObj(sc, 0, x2, 1),
                    new WireObj(x1, 0, a2, 0), new WireObj(sc, 0, a2, 1),
                    new WireObj(a1, 0, o1, 0), new WireObj(a2, 0, o1, 1),
                    new WireObj(x2, 0, ls, 0), new WireObj(o1, 0, lco, 0)
                );
                statusEl.textContent = 'Full Adder: A + B + Cin = Sum (top LED) + Carry (bottom LED)';
            }

            propagate();
            render();
            updateCount();
            saveToStorage();
        }

        // --- Keyboard Shortcuts ---
        const GATE_KEYS = { '1': 'SWITCH', '2': 'LED', '3': 'AND', '4': 'OR', '5': 'NOT', '6': 'NAND', '7': 'NOR', '8': 'XOR' };
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            if (document.getElementById('help-overlay').classList.contains('visible')) {
                if (e.key === 'Escape' || e.key === '?') {
                    document.getElementById('help-overlay').classList.remove('visible');
                }
                return;
            }

            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'z' || e.key === 'Z') { e.preventDefault(); undo(); return; }
                if (e.key === 's' || e.key === 'S') { e.preventDefault(); saveToStorage(); return; }
                if (e.key === 'e' || e.key === 'E') { e.preventDefault(); exportCircuit(); return; }
            }

            if (GATE_KEYS[e.key]) {
                selectedComponent = GATE_KEYS[e.key];
                setMode('place');
                statusEl.textContent = 'Selected ' + selectedComponent;
                return;
            }

            switch (e.key.toLowerCase()) {
                case 'p': setMode('place'); break;
                case 'w': setMode('wire'); break;
                case 'm': setMode('move'); break;
                case 'd': setMode('delete'); break;
                case '?': document.getElementById('help-overlay').classList.add('visible'); break;
                case 'escape':
                    if (wireStart) { wireStart = null; statusEl.textContent = 'Wire cancelled'; render(); }
                    break;
            }
        });

        // --- Auto-render on mouse move for hover effects ---
        canvas.addEventListener('mousemove', () => { if (!movingComp) render(); });

        // --- Load on start ---
        loadFromStorage();
        updateCount();
        statusEl.textContent = 'Ready -- Press ? for help, or select a component';

    })();
    </script>
</body>
</html>
