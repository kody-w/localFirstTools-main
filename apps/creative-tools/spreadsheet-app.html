<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spreadsheet App</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #f5f5f5;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #toolbar {
            background: #fff;
            border-bottom: 1px solid #ddd;
            padding: 8px 12px;
            display: flex;
            gap: 16px;
            align-items: center;
            flex-wrap: wrap;
        }

        .toolbar-group {
            display: flex;
            gap: 4px;
            align-items: center;
            padding: 0 8px;
            border-right: 1px solid #ddd;
        }

        .toolbar-group:last-child {
            border-right: none;
        }

        .toolbar-btn {
            padding: 6px 10px;
            border: 1px solid #ccc;
            background: #fff;
            cursor: pointer;
            border-radius: 3px;
            font-size: 13px;
            transition: all 0.2s;
        }

        .toolbar-btn:hover {
            background: #f0f0f0;
        }

        .toolbar-btn:active {
            background: #e0e0e0;
        }

        .toolbar-btn.active {
            background: #007bff;
            color: #fff;
            border-color: #007bff;
        }

        input[type="color"] {
            width: 32px;
            height: 28px;
            border: 1px solid #ccc;
            border-radius: 3px;
            cursor: pointer;
        }

        select {
            padding: 6px 8px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-size: 13px;
        }

        #formula-bar-container {
            background: #fff;
            border-bottom: 1px solid #ddd;
            padding: 8px 12px;
            display: flex;
            gap: 8px;
            align-items: center;
        }

        #cell-ref {
            font-weight: bold;
            padding: 6px 10px;
            border: 1px solid #ccc;
            border-radius: 3px;
            background: #f8f8f8;
            min-width: 60px;
            text-align: center;
        }

        #formula-bar {
            flex: 1;
            padding: 6px 10px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        #spreadsheet-container {
            flex: 1;
            overflow: auto;
            background: #fff;
            position: relative;
        }

        #spreadsheet {
            border-collapse: collapse;
            background: #fff;
        }

        #spreadsheet th {
            background: #f8f8f8;
            border: 1px solid #ddd;
            padding: 4px 8px;
            font-weight: 600;
            text-align: center;
            font-size: 12px;
            position: sticky;
            top: 0;
            z-index: 10;
            user-select: none;
            cursor: pointer;
        }

        #spreadsheet th.row-header {
            left: 0;
            z-index: 11;
            background: #f0f0f0;
            min-width: 40px;
        }

        #spreadsheet th.col-header {
            min-width: 80px;
            position: relative;
        }

        #spreadsheet th.corner {
            left: 0;
            z-index: 12;
            background: #e8e8e8;
        }

        .resize-handle {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            cursor: col-resize;
            background: transparent;
        }

        .resize-handle:hover {
            background: #007bff;
        }

        #spreadsheet td {
            border: 1px solid #ddd;
            padding: 4px 8px;
            min-width: 80px;
            max-width: 300px;
            height: 24px;
            font-size: 13px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            cursor: cell;
            position: relative;
        }

        #spreadsheet td.selected {
            outline: 2px solid #007bff;
            outline-offset: -1px;
            background: #e7f3ff;
        }

        #spreadsheet td.editing {
            padding: 0;
        }

        #spreadsheet td.error {
            background: #ffe6e6;
            color: #cc0000;
        }

        .cell-input {
            width: 100%;
            height: 100%;
            border: none;
            padding: 4px 8px;
            font-family: inherit;
            font-size: inherit;
            outline: 2px solid #007bff;
        }

        #sheet-tabs {
            background: #f8f8f8;
            border-top: 1px solid #ddd;
            padding: 4px 8px;
            display: flex;
            gap: 4px;
            align-items: center;
            overflow-x: auto;
        }

        .sheet-tab {
            padding: 6px 16px;
            border: 1px solid #ccc;
            border-bottom: none;
            background: #fff;
            cursor: pointer;
            border-radius: 4px 4px 0 0;
            font-size: 13px;
            white-space: nowrap;
            transition: all 0.2s;
        }

        .sheet-tab:hover {
            background: #f0f0f0;
        }

        .sheet-tab.active {
            background: #007bff;
            color: #fff;
            border-color: #007bff;
        }

        .sheet-tab-close {
            margin-left: 8px;
            color: #999;
            font-weight: bold;
        }

        .sheet-tab-close:hover {
            color: #cc0000;
        }

        #add-sheet {
            padding: 6px 12px;
            border: 1px solid #ccc;
            background: #fff;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
        }

        #add-sheet:hover {
            background: #f0f0f0;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: #fff;
            padding: 24px;
            border-radius: 8px;
            min-width: 400px;
            max-width: 90%;
            max-height: 90%;
            overflow: auto;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            margin-bottom: 16px;
            font-size: 18px;
            font-weight: 600;
        }

        .modal-body {
            margin-bottom: 16px;
        }

        .modal-footer {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }

        textarea {
            width: 100%;
            min-height: 200px;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        .modal-btn {
            padding: 8px 16px;
            border: 1px solid #ccc;
            background: #fff;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
        }

        .modal-btn.primary {
            background: #007bff;
            color: #fff;
            border-color: #007bff;
        }

        .modal-btn:hover {
            opacity: 0.9;
        }

        .search-container {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .search-container input {
            flex: 1;
            padding: 6px 10px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-size: 13px;
        }

        th.selected-header {
            background: #d0e8ff;
        }

        label {
            display: block;
            margin-bottom: 4px;
            font-weight: 500;
            font-size: 13px;
        }
    </style>
</head>
<body>
    <div id="toolbar">
        <div class="toolbar-group">
            <button class="toolbar-btn" onclick="app.undo()" title="Undo (Ctrl+Z)">↶ Undo</button>
            <button class="toolbar-btn" onclick="app.redo()" title="Redo (Ctrl+Y)">↷ Redo</button>
        </div>
        <div class="toolbar-group">
            <button class="toolbar-btn" id="bold-btn" onclick="app.toggleFormat('bold')" title="Bold">B</button>
            <button class="toolbar-btn" id="italic-btn" onclick="app.toggleFormat('italic')" title="Italic">I</button>
        </div>
        <div class="toolbar-group">
            <input type="color" id="text-color" onchange="app.setTextColor(this.value)" title="Text Color">
            <input type="color" id="bg-color" onchange="app.setBgColor(this.value)" title="Background Color">
        </div>
        <div class="toolbar-group">
            <select id="align-select" onchange="app.setAlignment(this.value)">
                <option value="left">Left</option>
                <option value="center">Center</option>
                <option value="right">Right</option>
            </select>
        </div>
        <div class="toolbar-group">
            <button class="toolbar-btn" onclick="app.showImportExport('export')">Export JSON</button>
            <button class="toolbar-btn" onclick="app.showImportExport('import')">Import JSON</button>
            <button class="toolbar-btn" onclick="app.exportCSV()">Export CSV</button>
        </div>
        <div class="toolbar-group">
            <button class="toolbar-btn" onclick="app.showSearchReplace()">Search & Replace</button>
        </div>
    </div>

    <div id="formula-bar-container">
        <div id="cell-ref"></div>
        <input type="text" id="formula-bar" placeholder="Enter formula or value...">
    </div>

    <div id="spreadsheet-container">
        <table id="spreadsheet"></table>
    </div>

    <div id="sheet-tabs">
        <button id="add-sheet" onclick="app.addSheet()">+ Add Sheet</button>
    </div>

    <div id="import-export-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header" id="modal-title"></div>
            <div class="modal-body">
                <textarea id="json-textarea"></textarea>
            </div>
            <div class="modal-footer">
                <button class="modal-btn" onclick="app.closeModal()">Cancel</button>
                <button class="modal-btn primary" id="modal-action-btn" onclick="app.handleImportExport()">Confirm</button>
            </div>
        </div>
    </div>

    <div id="search-replace-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">Search & Replace</div>
            <div class="modal-body">
                <div class="search-container">
                    <input type="text" id="search-input" placeholder="Search...">
                    <button class="modal-btn" onclick="app.findNext()">Find Next</button>
                </div>
                <div class="search-container">
                    <input type="text" id="replace-input" placeholder="Replace with...">
                    <button class="modal-btn" onclick="app.replaceOne()">Replace</button>
                    <button class="modal-btn" onclick="app.replaceAll()">Replace All</button>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn" onclick="app.closeSearchReplace()">Close</button>
            </div>
        </div>
    </div>

    <script>
        const app = {
            sheets: [],
            currentSheet: 0,
            selectedCell: null,
            selectedCells: new Set(),
            isSelecting: false,
            editingCell: null,
            clipboard: null,
            history: [],
            historyIndex: -1,
            maxHistory: 100,
            searchIndex: -1,
            searchResults: [],

            init() {
                const saved = localStorage.getItem('spreadsheet-data');
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        this.sheets = data.sheets || [this.createSheet('Sheet 1')];
                        this.currentSheet = data.currentSheet || 0;
                        this.history = [];
                        this.historyIndex = -1;
                    } catch (e) {
                        this.sheets = [this.createSheet('Sheet 1')];
                    }
                } else {
                    this.sheets = [this.createSheet('Sheet 1')];
                }

                this.renderSheetTabs();
                this.renderSpreadsheet();
                this.setupEventListeners();
                this.saveState();
            },

            createSheet(name) {
                const sheet = {
                    name: name,
                    cells: {},
                    columnWidths: {},
                    rows: 100,
                    cols: 26
                };
                return sheet;
            },

            renderSheetTabs() {
                const container = document.getElementById('sheet-tabs');
                const addBtn = document.getElementById('add-sheet');
                container.innerHTML = '';

                this.sheets.forEach((sheet, index) => {
                    const tab = document.createElement('div');
                    tab.className = 'sheet-tab' + (index === this.currentSheet ? ' active' : '');
                    tab.innerHTML = `${sheet.name}${this.sheets.length > 1 ? '<span class="sheet-tab-close" onclick="app.removeSheet(' + index + '); event.stopPropagation();">×</span>' : ''}`;
                    tab.onclick = () => this.switchSheet(index);
                    container.appendChild(tab);
                });

                container.appendChild(addBtn);
            },

            switchSheet(index) {
                if (index === this.currentSheet) return;
                this.currentSheet = index;
                this.selectedCell = null;
                this.selectedCells.clear();
                this.renderSheetTabs();
                this.renderSpreadsheet();
                this.save();
            },

            addSheet() {
                const name = prompt('Sheet name:', `Sheet ${this.sheets.length + 1}`);
                if (!name) return;
                this.sheets.push(this.createSheet(name));
                this.currentSheet = this.sheets.length - 1;
                this.renderSheetTabs();
                this.renderSpreadsheet();
                this.save();
            },

            removeSheet(index) {
                if (this.sheets.length === 1) {
                    alert('Cannot remove the last sheet');
                    return;
                }
                if (!confirm(`Remove sheet "${this.sheets[index].name}"?`)) return;
                this.sheets.splice(index, 1);
                if (this.currentSheet >= this.sheets.length) {
                    this.currentSheet = this.sheets.length - 1;
                }
                this.renderSheetTabs();
                this.renderSpreadsheet();
                this.save();
            },

            renderSpreadsheet() {
                const sheet = this.sheets[this.currentSheet];
                const table = document.getElementById('spreadsheet');
                table.innerHTML = '';

                // Header row
                const headerRow = document.createElement('tr');
                const cornerCell = document.createElement('th');
                cornerCell.className = 'corner';
                headerRow.appendChild(cornerCell);

                for (let col = 0; col < sheet.cols; col++) {
                    const th = document.createElement('th');
                    th.className = 'col-header';
                    th.textContent = this.getColumnName(col);
                    th.onclick = () => this.selectColumn(col);

                    const resizeHandle = document.createElement('div');
                    resizeHandle.className = 'resize-handle';
                    resizeHandle.onmousedown = (e) => this.startResize(e, col);
                    th.appendChild(resizeHandle);

                    if (sheet.columnWidths[col]) {
                        th.style.minWidth = sheet.columnWidths[col] + 'px';
                    }
                    headerRow.appendChild(th);
                }
                table.appendChild(headerRow);

                // Data rows
                for (let row = 0; row < sheet.rows; row++) {
                    const tr = document.createElement('tr');
                    const rowHeader = document.createElement('th');
                    rowHeader.className = 'row-header';
                    rowHeader.textContent = row + 1;
                    rowHeader.onclick = () => this.selectRow(row);
                    tr.appendChild(rowHeader);

                    for (let col = 0; col < sheet.cols; col++) {
                        const td = document.createElement('td');
                        const cellKey = `${row},${col}`;
                        const cellData = sheet.cells[cellKey] || {};

                        td.dataset.row = row;
                        td.dataset.col = col;
                        td.onclick = (e) => this.selectCell(row, col, e);
                        td.ondblclick = () => this.editCell(row, col);

                        if (cellData.value !== undefined) {
                            if (cellData.formula) {
                                const result = this.evaluateFormula(cellData.formula, row, col);
                                if (result.error) {
                                    td.textContent = '#ERROR';
                                    td.className = 'error';
                                    td.title = result.error;
                                } else {
                                    td.textContent = this.formatValue(result.value);
                                }
                            } else {
                                td.textContent = cellData.value;
                            }
                        }

                        // Apply formatting
                        if (cellData.bold) td.style.fontWeight = 'bold';
                        if (cellData.italic) td.style.fontStyle = 'italic';
                        if (cellData.textColor) td.style.color = cellData.textColor;
                        if (cellData.bgColor) td.style.backgroundColor = cellData.bgColor;
                        if (cellData.align) td.style.textAlign = cellData.align;

                        if (sheet.columnWidths[col]) {
                            td.style.minWidth = sheet.columnWidths[col] + 'px';
                        }

                        tr.appendChild(td);
                    }
                    table.appendChild(tr);
                }

                this.updateSelection();
            },

            getColumnName(col) {
                let name = '';
                col = col + 1;
                while (col > 0) {
                    col--;
                    name = String.fromCharCode(65 + (col % 26)) + name;
                    col = Math.floor(col / 26);
                }
                return name;
            },

            parseColumnName(name) {
                let col = 0;
                for (let i = 0; i < name.length; i++) {
                    col = col * 26 + (name.charCodeAt(i) - 64);
                }
                return col - 1;
            },

            selectCell(row, col, event) {
                if (this.editingCell) return;

                if (event.shiftKey && this.selectedCell) {
                    // Range selection
                    this.selectRange(this.selectedCell.row, this.selectedCell.col, row, col);
                } else {
                    this.selectedCell = { row, col };
                    this.selectedCells.clear();
                    this.selectedCells.add(`${row},${col}`);
                }

                this.updateSelection();
                this.updateFormulaBar();
            },

            selectRange(row1, col1, row2, col2) {
                const minRow = Math.min(row1, row2);
                const maxRow = Math.max(row1, row2);
                const minCol = Math.min(col1, col1);
                const maxCol = Math.max(col1, col2);

                this.selectedCells.clear();
                for (let r = minRow; r <= maxRow; r++) {
                    for (let c = minCol; c <= maxCol; c++) {
                        this.selectedCells.add(`${r},${c}`);
                    }
                }
            },

            selectRow(row) {
                const sheet = this.sheets[this.currentSheet];
                this.selectedCells.clear();
                for (let col = 0; col < sheet.cols; col++) {
                    this.selectedCells.add(`${row},${col}`);
                }
                this.selectedCell = { row, col: 0 };
                this.updateSelection();
            },

            selectColumn(col) {
                const sheet = this.sheets[this.currentSheet];
                this.selectedCells.clear();
                for (let row = 0; row < sheet.rows; row++) {
                    this.selectedCells.add(`${row},${col}`);
                }
                this.selectedCell = { row: 0, col };
                this.updateSelection();
            },

            updateSelection() {
                const cells = document.querySelectorAll('#spreadsheet td');
                cells.forEach(cell => {
                    const key = `${cell.dataset.row},${cell.dataset.col}`;
                    if (this.selectedCells.has(key)) {
                        cell.classList.add('selected');
                    } else {
                        cell.classList.remove('selected');
                    }
                });
            },

            editCell(row, col) {
                if (this.editingCell) this.finishEdit();

                const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                if (!cell) return;

                this.editingCell = { row, col };
                const sheet = this.sheets[this.currentSheet];
                const cellData = sheet.cells[`${row},${col}`] || {};

                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'cell-input';
                input.value = cellData.formula || cellData.value || '';

                cell.textContent = '';
                cell.className = 'editing';
                cell.appendChild(input);
                input.focus();

                input.onkeydown = (e) => {
                    if (e.key === 'Enter') {
                        this.finishEdit();
                        this.moveSelection(1, 0);
                    } else if (e.key === 'Tab') {
                        e.preventDefault();
                        this.finishEdit();
                        this.moveSelection(0, e.shiftKey ? -1 : 1);
                    } else if (e.key === 'Escape') {
                        this.cancelEdit();
                    }
                };

                input.onblur = () => {
                    setTimeout(() => this.finishEdit(), 100);
                };
            },

            finishEdit() {
                if (!this.editingCell) return;

                const { row, col } = this.editingCell;
                const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                const input = cell.querySelector('input');

                if (input) {
                    const value = input.value.trim();
                    this.setCellValue(row, col, value);
                }

                this.editingCell = null;
                this.renderSpreadsheet();
            },

            cancelEdit() {
                if (!this.editingCell) return;
                this.editingCell = null;
                this.renderSpreadsheet();
            },

            setCellValue(row, col, value) {
                const sheet = this.sheets[this.currentSheet];
                const cellKey = `${row},${col}`;

                if (!sheet.cells[cellKey]) {
                    sheet.cells[cellKey] = {};
                }

                const cellData = sheet.cells[cellKey];

                if (value.startsWith('=')) {
                    cellData.formula = value;
                    cellData.value = value;
                } else {
                    cellData.value = value;
                    delete cellData.formula;
                }

                this.recalculateDependents(row, col);
                this.saveState();
                this.save();
            },

            evaluateFormula(formula, currentRow, currentCol) {
                try {
                    if (!formula.startsWith('=')) {
                        return { value: formula };
                    }

                    const expr = formula.substring(1);

                    // Check for circular reference
                    if (this.hasCircularReference(currentRow, currentCol, expr)) {
                        return { error: 'Circular reference detected' };
                    }

                    const result = this.parseExpression(expr, currentRow, currentCol);
                    return { value: result };
                } catch (e) {
                    return { error: e.message };
                }
            },

            parseExpression(expr, currentRow, currentCol) {
                // Handle functions
                const funcMatch = expr.match(/^(\w+)\((.*)\)$/);
                if (funcMatch) {
                    const [, funcName, args] = funcMatch;
                    return this.evaluateFunction(funcName.toUpperCase(), args, currentRow, currentCol);
                }

                // Handle cell references and basic math
                let processed = expr;

                // Replace cell references with values
                processed = processed.replace(/([A-Z]+)(\d+)/g, (match, col, row) => {
                    const colIndex = this.parseColumnName(col);
                    const rowIndex = parseInt(row) - 1;
                    const value = this.getCellValue(rowIndex, colIndex);
                    return isNaN(value) ? '0' : value;
                });

                // Evaluate the expression
                try {
                    // Simple eval for basic math (safe in this context as we control the input)
                    const result = Function('"use strict"; return (' + processed + ')')();
                    return result;
                } catch (e) {
                    throw new Error('Invalid expression');
                }
            },

            evaluateFunction(funcName, args, currentRow, currentCol) {
                switch (funcName) {
                    case 'SUM':
                        return this.sum(this.parseArgs(args, currentRow, currentCol));
                    case 'AVERAGE':
                        return this.average(this.parseArgs(args, currentRow, currentCol));
                    case 'MIN':
                        return Math.min(...this.parseArgs(args, currentRow, currentCol));
                    case 'MAX':
                        return Math.max(...this.parseArgs(args, currentRow, currentCol));
                    case 'COUNT':
                        return this.parseArgs(args, currentRow, currentCol).length;
                    case 'ABS':
                        return Math.abs(this.parseExpression(args, currentRow, currentCol));
                    case 'ROUND':
                        const roundArgs = args.split(',').map(a => this.parseExpression(a.trim(), currentRow, currentCol));
                        return roundArgs.length === 2 ?
                            Math.round(roundArgs[0] * Math.pow(10, roundArgs[1])) / Math.pow(10, roundArgs[1]) :
                            Math.round(roundArgs[0]);
                    case 'IF':
                        return this.evaluateIf(args, currentRow, currentCol);
                    case 'CONCAT':
                        return this.concat(args, currentRow, currentCol);
                    default:
                        throw new Error('Unknown function: ' + funcName);
                }
            },

            parseArgs(args, currentRow, currentCol) {
                const values = [];

                // Check for range (A1:A10)
                const rangeMatch = args.match(/([A-Z]+)(\d+):([A-Z]+)(\d+)/);
                if (rangeMatch) {
                    const [, startCol, startRow, endCol, endRow] = rangeMatch;
                    const startColIndex = this.parseColumnName(startCol);
                    const endColIndex = this.parseColumnName(endCol);
                    const startRowIndex = parseInt(startRow) - 1;
                    const endRowIndex = parseInt(endRow) - 1;

                    for (let r = startRowIndex; r <= endRowIndex; r++) {
                        for (let c = startColIndex; c <= endColIndex; c++) {
                            const val = this.getCellValue(r, c);
                            if (!isNaN(val)) values.push(parseFloat(val));
                        }
                    }
                } else {
                    // Multiple args separated by commas
                    const argList = this.splitArgs(args);
                    argList.forEach(arg => {
                        const val = this.parseExpression(arg.trim(), currentRow, currentCol);
                        if (!isNaN(val)) values.push(parseFloat(val));
                    });
                }

                return values;
            },

            splitArgs(args) {
                const result = [];
                let current = '';
                let depth = 0;

                for (let i = 0; i < args.length; i++) {
                    const char = args[i];
                    if (char === '(') depth++;
                    if (char === ')') depth--;

                    if (char === ',' && depth === 0) {
                        result.push(current);
                        current = '';
                    } else {
                        current += char;
                    }
                }

                if (current) result.push(current);
                return result;
            },

            evaluateIf(args, currentRow, currentCol) {
                const parts = this.splitArgs(args);
                if (parts.length < 3) throw new Error('IF requires 3 arguments');

                const condition = this.parseExpression(parts[0].trim(), currentRow, currentCol);
                return condition ?
                    this.parseExpression(parts[1].trim(), currentRow, currentCol) :
                    this.parseExpression(parts[2].trim(), currentRow, currentCol);
            },

            concat(args, currentRow, currentCol) {
                const parts = this.splitArgs(args);
                return parts.map(p => {
                    const val = this.parseExpression(p.trim(), currentRow, currentCol);
                    return String(val);
                }).join('');
            },

            sum(values) {
                return values.reduce((a, b) => a + b, 0);
            },

            average(values) {
                return values.length > 0 ? this.sum(values) / values.length : 0;
            },

            getCellValue(row, col) {
                const sheet = this.sheets[this.currentSheet];
                const cellData = sheet.cells[`${row},${col}`];

                if (!cellData) return '';

                if (cellData.formula) {
                    const result = this.evaluateFormula(cellData.formula, row, col);
                    return result.error ? 0 : result.value;
                }

                return cellData.value || '';
            },

            hasCircularReference(row, col, formula, visited = new Set()) {
                const key = `${row},${col}`;
                if (visited.has(key)) return true;
                visited.add(key);

                // Find all cell references in formula
                const cellRefs = formula.match(/([A-Z]+)(\d+)/g) || [];

                for (const ref of cellRefs) {
                    const match = ref.match(/([A-Z]+)(\d+)/);
                    if (!match) continue;

                    const refCol = this.parseColumnName(match[1]);
                    const refRow = parseInt(match[2]) - 1;
                    const refCellData = this.sheets[this.currentSheet].cells[`${refRow},${refCol}`];

                    if (refCellData && refCellData.formula) {
                        if (this.hasCircularReference(refRow, refCol, refCellData.formula, new Set(visited))) {
                            return true;
                        }
                    }
                }

                return false;
            },

            recalculateDependents(row, col) {
                const sheet = this.sheets[this.currentSheet];
                const cellRef = `${this.getColumnName(col)}${row + 1}`;

                // Find all cells that reference this cell
                Object.keys(sheet.cells).forEach(key => {
                    const cellData = sheet.cells[key];
                    if (cellData.formula && cellData.formula.includes(cellRef)) {
                        // Trigger recalculation by touching the cell
                        const [r, c] = key.split(',').map(Number);
                        // Dependencies will be recalculated during render
                    }
                });
            },

            formatValue(value) {
                if (typeof value === 'number') {
                    return value.toLocaleString(undefined, { maximumFractionDigits: 10 });
                }
                return value;
            },

            moveSelection(rowDelta, colDelta) {
                if (!this.selectedCell) return;

                const sheet = this.sheets[this.currentSheet];
                let { row, col } = this.selectedCell;

                row = Math.max(0, Math.min(sheet.rows - 1, row + rowDelta));
                col = Math.max(0, Math.min(sheet.cols - 1, col + colDelta));

                this.selectedCell = { row, col };
                this.selectedCells.clear();
                this.selectedCells.add(`${row},${col}`);
                this.updateSelection();
                this.updateFormulaBar();

                // Scroll into view
                const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                if (cell) cell.scrollIntoView({ block: 'nearest', inline: 'nearest' });
            },

            updateFormulaBar() {
                const cellRefEl = document.getElementById('cell-ref');
                const formulaBar = document.getElementById('formula-bar');

                if (!this.selectedCell) {
                    cellRefEl.textContent = '';
                    formulaBar.value = '';
                    return;
                }

                const { row, col } = this.selectedCell;
                cellRefEl.textContent = `${this.getColumnName(col)}${row + 1}`;

                const sheet = this.sheets[this.currentSheet];
                const cellData = sheet.cells[`${row},${col}`];
                formulaBar.value = cellData ? (cellData.formula || cellData.value || '') : '';

                // Update format buttons
                document.getElementById('bold-btn').classList.toggle('active', cellData && cellData.bold);
                document.getElementById('italic-btn').classList.toggle('active', cellData && cellData.italic);
                document.getElementById('text-color').value = cellData && cellData.textColor || '#000000';
                document.getElementById('bg-color').value = cellData && cellData.bgColor || '#ffffff';
                document.getElementById('align-select').value = cellData && cellData.align || 'left';
            },

            toggleFormat(format) {
                if (this.selectedCells.size === 0) return;

                const sheet = this.sheets[this.currentSheet];
                this.selectedCells.forEach(key => {
                    if (!sheet.cells[key]) sheet.cells[key] = {};
                    const cellData = sheet.cells[key];
                    cellData[format] = !cellData[format];
                });

                this.renderSpreadsheet();
                this.updateFormulaBar();
                this.saveState();
                this.save();
            },

            setTextColor(color) {
                if (this.selectedCells.size === 0) return;

                const sheet = this.sheets[this.currentSheet];
                this.selectedCells.forEach(key => {
                    if (!sheet.cells[key]) sheet.cells[key] = {};
                    sheet.cells[key].textColor = color;
                });

                this.renderSpreadsheet();
                this.saveState();
                this.save();
            },

            setBgColor(color) {
                if (this.selectedCells.size === 0) return;

                const sheet = this.sheets[this.currentSheet];
                this.selectedCells.forEach(key => {
                    if (!sheet.cells[key]) sheet.cells[key] = {};
                    sheet.cells[key].bgColor = color;
                });

                this.renderSpreadsheet();
                this.saveState();
                this.save();
            },

            setAlignment(align) {
                if (this.selectedCells.size === 0) return;

                const sheet = this.sheets[this.currentSheet];
                this.selectedCells.forEach(key => {
                    if (!sheet.cells[key]) sheet.cells[key] = {};
                    sheet.cells[key].align = align;
                });

                this.renderSpreadsheet();
                this.saveState();
                this.save();
            },

            startResize(e, col) {
                e.preventDefault();
                e.stopPropagation();

                const startX = e.pageX;
                const sheet = this.sheets[this.currentSheet];
                const startWidth = sheet.columnWidths[col] || 80;

                const onMove = (e) => {
                    const diff = e.pageX - startX;
                    const newWidth = Math.max(40, startWidth + diff);
                    sheet.columnWidths[col] = newWidth;

                    // Update all cells in this column
                    const cells = document.querySelectorAll(`td[data-col="${col}"], th:nth-child(${col + 2})`);
                    cells.forEach(cell => {
                        cell.style.minWidth = newWidth + 'px';
                    });
                };

                const onUp = () => {
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                    this.save();
                };

                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            },

            copy() {
                if (this.selectedCells.size === 0) return;

                const sheet = this.sheets[this.currentSheet];
                this.clipboard = [];

                this.selectedCells.forEach(key => {
                    const cellData = sheet.cells[key];
                    this.clipboard.push({
                        key,
                        data: cellData ? JSON.parse(JSON.stringify(cellData)) : {}
                    });
                });
            },

            paste() {
                if (!this.clipboard || !this.selectedCell) return;

                const sheet = this.sheets[this.currentSheet];
                const { row, col } = this.selectedCell;

                this.clipboard.forEach(item => {
                    const [origRow, origCol] = item.key.split(',').map(Number);
                    const newRow = row + (origRow - parseInt(this.clipboard[0].key.split(',')[0]));
                    const newCol = col + (origCol - parseInt(this.clipboard[0].key.split(',')[1]));

                    if (newRow < sheet.rows && newCol < sheet.cols) {
                        const newKey = `${newRow},${newCol}`;
                        sheet.cells[newKey] = JSON.parse(JSON.stringify(item.data));
                    }
                });

                this.renderSpreadsheet();
                this.saveState();
                this.save();
            },

            setupEventListeners() {
                const formulaBar = document.getElementById('formula-bar');

                formulaBar.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        if (this.selectedCell) {
                            const { row, col } = this.selectedCell;
                            this.setCellValue(row, col, formulaBar.value);
                            this.renderSpreadsheet();
                        }
                    }
                });

                document.addEventListener('keydown', (e) => {
                    if (this.editingCell) return;

                    // Navigation
                    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                        e.preventDefault();
                        const moves = {
                            'ArrowUp': [-1, 0],
                            'ArrowDown': [1, 0],
                            'ArrowLeft': [0, -1],
                            'ArrowRight': [0, 1]
                        };
                        const [rowDelta, colDelta] = moves[e.key];
                        this.moveSelection(rowDelta, colDelta);
                    }

                    // Edit on Enter
                    if (e.key === 'Enter' && this.selectedCell) {
                        this.editCell(this.selectedCell.row, this.selectedCell.col);
                    }

                    // Copy/Paste
                    if (e.ctrlKey || e.metaKey) {
                        if (e.key === 'c') {
                            e.preventDefault();
                            this.copy();
                        } else if (e.key === 'v') {
                            e.preventDefault();
                            this.paste();
                        } else if (e.key === 'z') {
                            e.preventDefault();
                            this.undo();
                        } else if (e.key === 'y') {
                            e.preventDefault();
                            this.redo();
                        }
                    }

                    // Delete
                    if (e.key === 'Delete' || e.key === 'Backspace') {
                        if (document.activeElement !== formulaBar) {
                            e.preventDefault();
                            this.deleteSelectedCells();
                        }
                    }
                });
            },

            deleteSelectedCells() {
                if (this.selectedCells.size === 0) return;

                const sheet = this.sheets[this.currentSheet];
                this.selectedCells.forEach(key => {
                    delete sheet.cells[key];
                });

                this.renderSpreadsheet();
                this.saveState();
                this.save();
            },

            saveState() {
                const state = JSON.stringify({
                    sheets: this.sheets,
                    currentSheet: this.currentSheet
                });

                if (this.historyIndex < this.history.length - 1) {
                    this.history = this.history.slice(0, this.historyIndex + 1);
                }

                this.history.push(state);
                if (this.history.length > this.maxHistory) {
                    this.history.shift();
                } else {
                    this.historyIndex++;
                }
            },

            undo() {
                if (this.historyIndex <= 0) return;

                this.historyIndex--;
                const state = JSON.parse(this.history[this.historyIndex]);
                this.sheets = state.sheets;
                this.currentSheet = state.currentSheet;
                this.renderSpreadsheet();
                this.renderSheetTabs();
                this.save();
            },

            redo() {
                if (this.historyIndex >= this.history.length - 1) return;

                this.historyIndex++;
                const state = JSON.parse(this.history[this.historyIndex]);
                this.sheets = state.sheets;
                this.currentSheet = state.currentSheet;
                this.renderSpreadsheet();
                this.renderSheetTabs();
                this.save();
            },

            save() {
                localStorage.setItem('spreadsheet-data', JSON.stringify({
                    sheets: this.sheets,
                    currentSheet: this.currentSheet
                }));
            },

            showImportExport(mode) {
                const modal = document.getElementById('import-export-modal');
                const title = document.getElementById('modal-title');
                const textarea = document.getElementById('json-textarea');
                const actionBtn = document.getElementById('modal-action-btn');

                if (mode === 'export') {
                    title.textContent = 'Export JSON';
                    textarea.value = JSON.stringify({ sheets: this.sheets, currentSheet: this.currentSheet }, null, 2);
                    textarea.readOnly = true;
                    actionBtn.textContent = 'Copy to Clipboard';
                } else {
                    title.textContent = 'Import JSON';
                    textarea.value = '';
                    textarea.readOnly = false;
                    actionBtn.textContent = 'Import';
                }

                modal.dataset.mode = mode;
                modal.classList.add('show');
            },

            handleImportExport() {
                const modal = document.getElementById('import-export-modal');
                const mode = modal.dataset.mode;
                const textarea = document.getElementById('json-textarea');

                if (mode === 'export') {
                    textarea.select();
                    document.execCommand('copy');
                    alert('Copied to clipboard!');
                    this.closeModal();
                } else {
                    try {
                        const data = JSON.parse(textarea.value);
                        if (!data.sheets || !Array.isArray(data.sheets)) {
                            throw new Error('Invalid format');
                        }
                        this.sheets = data.sheets;
                        this.currentSheet = data.currentSheet || 0;
                        this.renderSpreadsheet();
                        this.renderSheetTabs();
                        this.save();
                        this.closeModal();
                        alert('Import successful!');
                    } catch (e) {
                        alert('Import failed: ' + e.message);
                    }
                }
            },

            closeModal() {
                document.getElementById('import-export-modal').classList.remove('show');
            },

            exportCSV() {
                const sheet = this.sheets[this.currentSheet];
                let csv = '';

                for (let row = 0; row < sheet.rows; row++) {
                    const rowData = [];
                    for (let col = 0; col < sheet.cols; col++) {
                        const cellData = sheet.cells[`${row},${col}`];
                        let value = '';

                        if (cellData) {
                            if (cellData.formula) {
                                const result = this.evaluateFormula(cellData.formula, row, col);
                                value = result.error ? '#ERROR' : result.value;
                            } else {
                                value = cellData.value || '';
                            }
                        }

                        // Escape quotes and wrap in quotes if contains comma
                        value = String(value).replace(/"/g, '""');
                        if (value.includes(',') || value.includes('\n') || value.includes('"')) {
                            value = '"' + value + '"';
                        }

                        rowData.push(value);
                    }

                    // Only include rows that have data
                    if (rowData.some(cell => cell !== '')) {
                        csv += rowData.join(',') + '\n';
                    }
                }

                // Download
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${sheet.name}.csv`;
                a.click();
                URL.revokeObjectURL(url);
            },

            showSearchReplace() {
                const modal = document.getElementById('search-replace-modal');
                modal.classList.add('show');
                document.getElementById('search-input').focus();
            },

            closeSearchReplace() {
                document.getElementById('search-replace-modal').classList.remove('show');
                this.searchResults = [];
                this.searchIndex = -1;
            },

            findNext() {
                const searchTerm = document.getElementById('search-input').value.toLowerCase();
                if (!searchTerm) return;

                const sheet = this.sheets[this.currentSheet];

                if (this.searchResults.length === 0 || this.searchResults[0].term !== searchTerm) {
                    // New search
                    this.searchResults = [];
                    Object.keys(sheet.cells).forEach(key => {
                        const cellData = sheet.cells[key];
                        const value = cellData.value || '';
                        if (value.toLowerCase().includes(searchTerm)) {
                            this.searchResults.push({ key, term: searchTerm });
                        }
                    });
                    this.searchIndex = -1;
                }

                if (this.searchResults.length === 0) {
                    alert('No matches found');
                    return;
                }

                this.searchIndex = (this.searchIndex + 1) % this.searchResults.length;
                const [row, col] = this.searchResults[this.searchIndex].key.split(',').map(Number);
                this.selectCell(row, col, { shiftKey: false });

                const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                if (cell) cell.scrollIntoView({ block: 'center', inline: 'center' });
            },

            replaceOne() {
                if (this.searchResults.length === 0 || this.searchIndex === -1) {
                    this.findNext();
                    return;
                }

                const replaceTerm = document.getElementById('replace-input').value;
                const searchTerm = document.getElementById('search-input').value;
                const { key } = this.searchResults[this.searchIndex];
                const [row, col] = key.split(',').map(Number);

                const sheet = this.sheets[this.currentSheet];
                const cellData = sheet.cells[key];
                if (cellData && cellData.value) {
                    cellData.value = cellData.value.replace(new RegExp(searchTerm, 'gi'), replaceTerm);
                }

                this.searchResults.splice(this.searchIndex, 1);
                if (this.searchIndex >= this.searchResults.length) {
                    this.searchIndex = -1;
                }

                this.renderSpreadsheet();
                this.saveState();
                this.save();
                this.findNext();
            },

            replaceAll() {
                const searchTerm = document.getElementById('search-input').value;
                const replaceTerm = document.getElementById('replace-input').value;
                if (!searchTerm) return;

                const sheet = this.sheets[this.currentSheet];
                let count = 0;

                Object.keys(sheet.cells).forEach(key => {
                    const cellData = sheet.cells[key];
                    if (cellData && cellData.value && cellData.value.toLowerCase().includes(searchTerm.toLowerCase())) {
                        cellData.value = cellData.value.replace(new RegExp(searchTerm, 'gi'), replaceTerm);
                        count++;
                    }
                });

                this.searchResults = [];
                this.searchIndex = -1;
                this.renderSpreadsheet();
                this.saveState();
                this.save();
                alert(`Replaced ${count} occurrences`);
            }
        };

        // Initialize app
        window.addEventListener('DOMContentLoaded', () => app.init());
    </script>
</body>
</html>