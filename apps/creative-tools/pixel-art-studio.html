<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Art Studio</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            overflow: hidden;
            user-select: none;
        }

        #app {
            display: flex;
            height: 100vh;
        }

        /* Left Sidebar - Tools */
        #left-panel {
            width: 240px;
            background: #2a2a2a;
            border-right: 1px solid #3a3a3a;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .panel-section {
            padding: 15px;
            border-bottom: 1px solid #3a3a3a;
        }

        .panel-section h3 {
            font-size: 12px;
            text-transform: uppercase;
            color: #888;
            margin-bottom: 10px;
            letter-spacing: 1px;
        }

        /* Tools Grid */
        .tools-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 5px;
        }

        .tool-btn {
            width: 50px;
            height: 50px;
            background: #333;
            border: 2px solid #444;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.2s;
            position: relative;
        }

        .tool-btn:hover {
            background: #3a3a3a;
            border-color: #555;
        }

        .tool-btn.active {
            background: #0066cc;
            border-color: #0088ff;
        }

        .tool-btn::after {
            content: attr(title);
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 9px;
            white-space: nowrap;
            color: #888;
        }

        /* Canvas Size */
        .size-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
        }

        .size-btn {
            padding: 8px;
            background: #333;
            border: 1px solid #444;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            color: #e0e0e0;
        }

        .size-btn:hover {
            background: #3a3a3a;
        }

        .size-btn.active {
            background: #0066cc;
            border-color: #0088ff;
        }

        /* Color Palette */
        .color-palette {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 3px;
        }

        .color-swatch {
            width: 100%;
            aspect-ratio: 1;
            border: 2px solid #444;
            border-radius: 3px;
            cursor: pointer;
            transition: transform 0.1s;
        }

        .color-swatch:hover {
            transform: scale(1.1);
        }

        .color-swatch.active {
            border-color: #fff;
            box-shadow: 0 0 5px rgba(255,255,255,0.5);
        }

        .color-picker-container {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 10px;
        }

        #colorPicker {
            width: 60px;
            height: 30px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }

        #hexInput {
            flex: 1;
            padding: 5px;
            background: #333;
            border: 1px solid #444;
            border-radius: 3px;
            color: #e0e0e0;
            font-size: 12px;
        }

        .recent-colors {
            display: flex;
            gap: 3px;
            margin-top: 10px;
        }

        .recent-color {
            width: 25px;
            height: 25px;
            border: 2px solid #444;
            border-radius: 3px;
            cursor: pointer;
        }

        /* Center - Canvas Area */
        #center-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }

        #toolbar {
            background: #2a2a2a;
            border-bottom: 1px solid #3a3a3a;
            padding: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .toolbar-group {
            display: flex;
            gap: 5px;
            align-items: center;
            padding-right: 10px;
            border-right: 1px solid #3a3a3a;
        }

        .toolbar-group:last-child {
            border-right: none;
        }

        .toolbar-btn {
            padding: 6px 12px;
            background: #333;
            border: 1px solid #444;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            color: #e0e0e0;
            white-space: nowrap;
        }

        .toolbar-btn:hover {
            background: #3a3a3a;
        }

        .toolbar-btn.active {
            background: #0066cc;
        }

        #canvas-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #1a1a1a;
            position: relative;
            overflow: hidden;
            cursor: crosshair;
        }

        #canvas-wrapper {
            position: relative;
            transform-origin: center;
        }

        #displayCanvas {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            border: 2px solid #444;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        #gridCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        /* Right Sidebar - Layers & Animation */
        #right-panel {
            width: 280px;
            background: #2a2a2a;
            border-left: 1px solid #3a3a3a;
            display: flex;
            flex-direction: column;
        }

        /* Layers */
        .layers-container {
            flex: 1;
            overflow-y: auto;
        }

        .layer-item {
            display: flex;
            align-items: center;
            padding: 8px;
            background: #333;
            margin: 5px;
            border-radius: 3px;
            border: 2px solid transparent;
            cursor: pointer;
        }

        .layer-item.active {
            border-color: #0066cc;
            background: #3a3a3a;
        }

        .layer-preview {
            width: 40px;
            height: 40px;
            background: #222;
            border: 1px solid #444;
            border-radius: 3px;
            margin-right: 10px;
            image-rendering: pixelated;
        }

        .layer-info {
            flex: 1;
        }

        .layer-name {
            font-size: 12px;
            margin-bottom: 3px;
        }

        .layer-opacity-slider {
            width: 100%;
            height: 4px;
        }

        .layer-controls {
            display: flex;
            gap: 5px;
        }

        .layer-btn {
            width: 25px;
            height: 25px;
            background: #444;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            color: #e0e0e0;
        }

        .layer-btn:hover {
            background: #555;
        }

        .add-layer-btn {
            margin: 5px;
            padding: 10px;
            background: #0066cc;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            color: #fff;
            font-size: 12px;
        }

        .add-layer-btn:hover {
            background: #0077dd;
        }

        /* Animation */
        .frames-container {
            display: flex;
            overflow-x: auto;
            padding: 10px;
            gap: 5px;
            background: #222;
        }

        .frame-item {
            min-width: 60px;
            height: 60px;
            background: #333;
            border: 2px solid #444;
            border-radius: 3px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .frame-item.active {
            border-color: #0066cc;
        }

        .frame-preview {
            width: 50px;
            height: 50px;
            image-rendering: pixelated;
        }

        .frame-number {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 9px;
            background: rgba(0,0,0,0.7);
            padding: 2px 4px;
            border-radius: 2px;
        }

        .animation-controls {
            padding: 10px;
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        .fps-control {
            display: flex;
            align-items: center;
            gap: 5px;
            width: 100%;
        }

        .fps-control label {
            font-size: 11px;
            width: 60px;
        }

        .fps-control input {
            flex: 1;
        }

        .fps-value {
            font-size: 11px;
            width: 30px;
            text-align: right;
        }

        /* Modals */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: #2a2a2a;
            border-radius: 5px;
            padding: 20px;
            max-width: 500px;
            border: 1px solid #3a3a3a;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .modal-title {
            font-size: 16px;
        }

        .close-btn {
            background: none;
            border: none;
            color: #888;
            font-size: 24px;
            cursor: pointer;
            line-height: 1;
        }

        .close-btn:hover {
            color: #fff;
        }

        .modal-body {
            margin-bottom: 15px;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .modal-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }

        .modal-btn-primary {
            background: #0066cc;
            color: #fff;
        }

        .modal-btn-primary:hover {
            background: #0077dd;
        }

        .modal-btn-secondary {
            background: #444;
            color: #e0e0e0;
        }

        .modal-btn-secondary:hover {
            background: #555;
        }

        /* Export Preview */
        #exportPreview {
            max-width: 100%;
            max-height: 400px;
            image-rendering: pixelated;
            border: 1px solid #444;
            background: #222;
        }

        .export-options {
            margin-top: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .export-option {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .export-option label {
            flex: 1;
            font-size: 12px;
        }

        .export-option input,
        .export-option select {
            padding: 5px;
            background: #333;
            border: 1px solid #444;
            border-radius: 3px;
            color: #e0e0e0;
            font-size: 12px;
        }

        /* Scrollbars */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        ::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Keyboard Shortcuts Help */
        .shortcuts-list {
            font-size: 11px;
            line-height: 1.8;
        }

        .shortcut-item {
            display: flex;
            justify-content: space-between;
            padding: 3px 0;
        }

        .shortcut-key {
            background: #333;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- Left Panel: Tools & Colors -->
        <div id="left-panel">
            <div class="panel-section">
                <h3>Tools</h3>
                <div class="tools-grid">
                    <div class="tool-btn active" data-tool="pencil" title="Pencil">‚úèÔ∏è</div>
                    <div class="tool-btn" data-tool="eraser" title="Eraser">üßπ</div>
                    <div class="tool-btn" data-tool="bucket" title="Bucket">ü™£</div>
                    <div class="tool-btn" data-tool="eyedropper" title="Pick">üíß</div>
                    <div class="tool-btn" data-tool="line" title="Line">üìè</div>
                    <div class="tool-btn" data-tool="rect" title="Rect">‚¨ú</div>
                    <div class="tool-btn" data-tool="rect-fill" title="Fill Rect">‚¨õ</div>
                    <div class="tool-btn" data-tool="circle" title="Circle">‚≠ï</div>
                    <div class="tool-btn" data-tool="circle-fill" title="Fill Circle">‚ö´</div>
                    <div class="tool-btn" data-tool="select" title="Select">üî≤</div>
                </div>
            </div>

            <div class="panel-section">
                <h3>Canvas Size</h3>
                <div class="size-buttons">
                    <div class="size-btn" data-size="8">8x8</div>
                    <div class="size-btn active" data-size="16">16x16</div>
                    <div class="size-btn" data-size="32">32x32</div>
                    <div class="size-btn" data-size="64">64x64</div>
                    <div class="size-btn" data-size="128">128x128</div>
                </div>
            </div>

            <div class="panel-section">
                <h3>Color Palette</h3>
                <div class="color-palette" id="colorPalette"></div>
                <div class="color-picker-container">
                    <input type="color" id="colorPicker" value="#000000">
                    <input type="text" id="hexInput" placeholder="#000000" maxlength="7">
                </div>
                <div class="recent-colors" id="recentColors"></div>
            </div>
        </div>

        <!-- Center Panel: Canvas -->
        <div id="center-panel">
            <div id="toolbar">
                <div class="toolbar-group">
                    <button class="toolbar-btn" id="undoBtn" title="Ctrl+Z">‚Ü∂ Undo</button>
                    <button class="toolbar-btn" id="redoBtn" title="Ctrl+Y">‚Ü∑ Redo</button>
                </div>
                <div class="toolbar-group">
                    <button class="toolbar-btn" id="gridBtn">Grid</button>
                    <button class="toolbar-btn" id="symmetryBtn">Symmetry</button>
                    <button class="toolbar-btn" id="onionSkinBtn">Onion Skin</button>
                </div>
                <div class="toolbar-group">
                    <button class="toolbar-btn" id="flipHBtn">Flip H</button>
                    <button class="toolbar-btn" id="flipVBtn">Flip V</button>
                </div>
                <div class="toolbar-group">
                    <button class="toolbar-btn" id="zoomFitBtn">Fit</button>
                    <button class="toolbar-btn" id="clearBtn">Clear</button>
                </div>
                <div class="toolbar-group">
                    <button class="toolbar-btn" id="importBtn">Import</button>
                    <button class="toolbar-btn" id="exportBtn">Export</button>
                </div>
                <div class="toolbar-group">
                    <button class="toolbar-btn" id="helpBtn">?</button>
                </div>
            </div>

            <div id="canvas-container">
                <div id="canvas-wrapper">
                    <canvas id="displayCanvas"></canvas>
                    <canvas id="gridCanvas"></canvas>
                </div>
            </div>
        </div>

        <!-- Right Panel: Layers & Animation -->
        <div id="right-panel">
            <div class="panel-section">
                <h3>Layers</h3>
                <div class="layers-container" id="layersContainer"></div>
                <button class="add-layer-btn" id="addLayerBtn">+ Add Layer</button>
                <div style="display: flex; gap: 5px; padding: 5px;">
                    <button class="toolbar-btn" id="mergeLayersBtn" style="flex: 1;">Merge</button>
                    <button class="toolbar-btn" id="flattenBtn" style="flex: 1;">Flatten</button>
                </div>
            </div>

            <div class="panel-section">
                <h3>Animation</h3>
                <div class="frames-container" id="framesContainer"></div>
                <div class="animation-controls">
                    <button class="toolbar-btn" id="addFrameBtn" style="flex: 1;">+ Frame</button>
                    <button class="toolbar-btn" id="duplicateFrameBtn" style="flex: 1;">Duplicate</button>
                    <button class="toolbar-btn" id="deleteFrameBtn" style="flex: 1;">Delete</button>
                    <button class="toolbar-btn" id="playBtn" style="flex: 1;">‚ñ∂ Play</button>
                    <div class="fps-control">
                        <label>FPS:</label>
                        <input type="range" id="fpsSlider" min="1" max="30" value="10">
                        <span class="fps-value" id="fpsValue">10</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Export Modal -->
    <div class="modal" id="exportModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Export</h3>
                <button class="close-btn" onclick="closeExportModal()">&times;</button>
            </div>
            <div class="modal-body">
                <canvas id="exportPreview"></canvas>
                <div class="export-options">
                    <div class="export-option">
                        <label>Format:</label>
                        <select id="exportFormat">
                            <option value="png">PNG (Current Frame)</option>
                            <option value="png-scaled">PNG (Scaled)</option>
                            <option value="gif">GIF (Animation)</option>
                            <option value="spritesheet">Sprite Sheet</option>
                        </select>
                    </div>
                    <div class="export-option" id="scaleOption" style="display: none;">
                        <label>Scale:</label>
                        <input type="number" id="exportScale" min="1" max="20" value="4">
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn modal-btn-secondary" onclick="closeExportModal()">Cancel</button>
                <button class="modal-btn modal-btn-primary" onclick="doExport()">Download</button>
            </div>
        </div>
    </div>

    <!-- Import Modal -->
    <div class="modal" id="importModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Import Image</h3>
                <button class="close-btn" onclick="closeImportModal()">&times;</button>
            </div>
            <div class="modal-body">
                <input type="file" id="importFile" accept="image/png,image/jpg,image/jpeg,image/gif">
            </div>
            <div class="modal-footer">
                <button class="modal-btn modal-btn-secondary" onclick="closeImportModal()">Cancel</button>
                <button class="modal-btn modal-btn-primary" onclick="doImport()">Import</button>
            </div>
        </div>
    </div>

    <!-- Help Modal -->
    <div class="modal" id="helpModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Keyboard Shortcuts</h3>
                <button class="close-btn" onclick="closeHelpModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="shortcuts-list">
                    <div class="shortcut-item"><span>Pencil</span><span class="shortcut-key">P</span></div>
                    <div class="shortcut-item"><span>Eraser</span><span class="shortcut-key">E</span></div>
                    <div class="shortcut-item"><span>Bucket Fill</span><span class="shortcut-key">B</span></div>
                    <div class="shortcut-item"><span>Eyedropper</span><span class="shortcut-key">I</span></div>
                    <div class="shortcut-item"><span>Line Tool</span><span class="shortcut-key">L</span></div>
                    <div class="shortcut-item"><span>Rectangle</span><span class="shortcut-key">R</span></div>
                    <div class="shortcut-item"><span>Circle</span><span class="shortcut-key">C</span></div>
                    <div class="shortcut-item"><span>Selection</span><span class="shortcut-key">S</span></div>
                    <div class="shortcut-item"><span>Undo</span><span class="shortcut-key">Ctrl+Z</span></div>
                    <div class="shortcut-item"><span>Redo</span><span class="shortcut-key">Ctrl+Y</span></div>
                    <div class="shortcut-item"><span>Toggle Grid</span><span class="shortcut-key">G</span></div>
                    <div class="shortcut-item"><span>Zoom In</span><span class="shortcut-key">Scroll Up</span></div>
                    <div class="shortcut-item"><span>Zoom Out</span><span class="shortcut-key">Scroll Down</span></div>
                    <div class="shortcut-item"><span>Pan</span><span class="shortcut-key">Space+Drag</span></div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn modal-btn-primary" onclick="closeHelpModal()">Close</button>
            </div>
        </div>
    </div>

    <script>
        // App State
        const app = {
            canvasSize: 16,
            currentTool: 'pencil',
            currentColor: '#000000',
            layers: [],
            currentLayerIndex: 0,
            frames: [],
            currentFrameIndex: 0,
            history: [],
            historyIndex: -1,
            maxHistory: 50,
            zoom: 1,
            panX: 0,
            panY: 0,
            gridEnabled: false,
            symmetryEnabled: false,
            onionSkinEnabled: false,
            isDrawing: false,
            isPanning: false,
            startX: 0,
            startY: 0,
            recentColors: [],
            maxRecentColors: 8,
            animationPlaying: false,
            animationInterval: null,
            fps: 10,
            selection: null
        };

        // Default color palette (classic pixel art colors)
        const defaultPalette = [
            '#000000', '#FFFFFF', '#808080', '#C0C0C0',
            '#FF0000', '#800000', '#FFFF00', '#808000',
            '#00FF00', '#008000', '#00FFFF', '#008080',
            '#0000FF', '#000080', '#FF00FF', '#800080'
        ];

        // Canvas references
        const displayCanvas = document.getElementById('displayCanvas');
        const displayCtx = displayCanvas.getContext('2d', { willReadFrequently: true });
        const gridCanvas = document.getElementById('gridCanvas');
        const gridCtx = gridCanvas.getContext('2d');
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const canvasContainer = document.getElementById('canvas-container');

        // Initialize
        function init() {
            initCanvas();
            initTools();
            initColors();
            initLayers();
            initFrames();
            initEventListeners();
            loadFromLocalStorage();
            render();
        }

        function initCanvas() {
            displayCanvas.width = app.canvasSize;
            displayCanvas.height = app.canvasSize;
            gridCanvas.width = app.canvasSize;
            gridCanvas.height = app.canvasSize;

            displayCtx.imageSmoothingEnabled = false;
            gridCtx.imageSmoothingEnabled = false;

            updateCanvasSize();
        }

        function updateCanvasSize() {
            const scale = Math.min(
                (canvasContainer.clientWidth - 100) / app.canvasSize,
                (canvasContainer.clientHeight - 100) / app.canvasSize
            );
            app.zoom = Math.max(1, Math.floor(scale));
            applyZoom();
        }

        function applyZoom() {
            const size = app.canvasSize * app.zoom;
            displayCanvas.style.width = size + 'px';
            displayCanvas.style.height = size + 'px';
            gridCanvas.style.width = size + 'px';
            gridCanvas.style.height = size + 'px';
            canvasWrapper.style.transform = `translate(${app.panX}px, ${app.panY}px)`;
            drawGrid();
        }

        function initTools() {
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    app.currentTool = btn.dataset.tool;
                    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                });
            });

            document.querySelectorAll('.size-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const newSize = parseInt(btn.dataset.size);
                    if (confirm(`Change canvas size to ${newSize}x${newSize}? This will clear the current canvas.`)) {
                        app.canvasSize = newSize;
                        displayCanvas.width = newSize;
                        displayCanvas.height = newSize;
                        gridCanvas.width = newSize;
                        gridCanvas.height = newSize;

                        document.querySelectorAll('.size-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');

                        clearAllLayers();
                        updateCanvasSize();
                        saveState();
                    }
                });
            });
        }

        function initColors() {
            const palette = document.getElementById('colorPalette');
            defaultPalette.forEach(color => {
                const swatch = document.createElement('div');
                swatch.className = 'color-swatch';
                swatch.style.backgroundColor = color;
                swatch.addEventListener('click', () => setColor(color));
                palette.appendChild(swatch);
            });

            document.getElementById('colorPicker').addEventListener('input', (e) => {
                setColor(e.target.value);
            });

            document.getElementById('hexInput').addEventListener('change', (e) => {
                let value = e.target.value.trim();
                if (!value.startsWith('#')) value = '#' + value;
                if (/^#[0-9A-Fa-f]{6}$/.test(value)) {
                    setColor(value);
                }
            });

            setColor('#000000');
        }

        function setColor(color) {
            app.currentColor = color.toUpperCase();
            document.getElementById('colorPicker').value = color;
            document.getElementById('hexInput').value = color;

            document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
            document.querySelectorAll('.color-swatch').forEach(s => {
                if (s.style.backgroundColor === hexToRgb(color)) {
                    s.classList.add('active');
                }
            });

            addToRecentColors(color);
        }

        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgb(${r}, ${g}, ${b})`;
        }

        function addToRecentColors(color) {
            color = color.toUpperCase();
            app.recentColors = app.recentColors.filter(c => c !== color);
            app.recentColors.unshift(color);
            app.recentColors = app.recentColors.slice(0, app.maxRecentColors);
            updateRecentColors();
        }

        function updateRecentColors() {
            const container = document.getElementById('recentColors');
            container.innerHTML = '';
            app.recentColors.forEach(color => {
                const swatch = document.createElement('div');
                swatch.className = 'recent-color';
                swatch.style.backgroundColor = color;
                swatch.addEventListener('click', () => setColor(color));
                container.appendChild(swatch);
            });
        }

        function initLayers() {
            addLayer();
        }

        function addLayer() {
            const canvas = document.createElement('canvas');
            canvas.width = app.canvasSize;
            canvas.height = app.canvasSize;
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            ctx.imageSmoothingEnabled = false;

            app.layers.push({
                canvas: canvas,
                ctx: ctx,
                visible: true,
                opacity: 1,
                name: `Layer ${app.layers.length + 1}`
            });

            app.currentLayerIndex = app.layers.length - 1;
            updateLayersUI();
            saveState();
        }

        function updateLayersUI() {
            const container = document.getElementById('layersContainer');
            container.innerHTML = '';

            app.layers.slice().reverse().forEach((layer, i) => {
                const actualIndex = app.layers.length - 1 - i;
                const item = document.createElement('div');
                item.className = 'layer-item';
                if (actualIndex === app.currentLayerIndex) {
                    item.classList.add('active');
                }

                const preview = document.createElement('canvas');
                preview.className = 'layer-preview';
                preview.width = 40;
                preview.height = 40;
                const previewCtx = preview.getContext('2d');
                previewCtx.imageSmoothingEnabled = false;
                previewCtx.drawImage(layer.canvas, 0, 0, 40, 40);

                const info = document.createElement('div');
                info.className = 'layer-info';

                const name = document.createElement('div');
                name.className = 'layer-name';
                name.textContent = layer.name;

                const opacitySlider = document.createElement('input');
                opacitySlider.type = 'range';
                opacitySlider.className = 'layer-opacity-slider';
                opacitySlider.min = 0;
                opacitySlider.max = 100;
                opacitySlider.value = layer.opacity * 100;
                opacitySlider.addEventListener('input', (e) => {
                    layer.opacity = e.target.value / 100;
                    render();
                });

                info.appendChild(name);
                info.appendChild(opacitySlider);

                const controls = document.createElement('div');
                controls.className = 'layer-controls';

                const visBtn = document.createElement('button');
                visBtn.className = 'layer-btn';
                visBtn.textContent = layer.visible ? 'üëÅÔ∏è' : 'üëÅÔ∏è‚Äçüó®Ô∏è';
                visBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    layer.visible = !layer.visible;
                    updateLayersUI();
                    render();
                });

                const delBtn = document.createElement('button');
                delBtn.className = 'layer-btn';
                delBtn.textContent = 'üóëÔ∏è';
                delBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (app.layers.length > 1) {
                        app.layers.splice(actualIndex, 1);
                        if (app.currentLayerIndex >= app.layers.length) {
                            app.currentLayerIndex = app.layers.length - 1;
                        }
                        updateLayersUI();
                        render();
                        saveState();
                    }
                });

                controls.appendChild(visBtn);
                controls.appendChild(delBtn);

                item.appendChild(preview);
                item.appendChild(info);
                item.appendChild(controls);

                item.addEventListener('click', () => {
                    app.currentLayerIndex = actualIndex;
                    updateLayersUI();
                });

                container.appendChild(item);
            });
        }

        function clearAllLayers() {
            app.layers.forEach(layer => {
                layer.ctx.clearRect(0, 0, app.canvasSize, app.canvasSize);
            });
            render();
        }

        function initFrames() {
            addFrame();
        }

        function addFrame() {
            const frameData = app.layers.map(layer => {
                const canvas = document.createElement('canvas');
                canvas.width = app.canvasSize;
                canvas.height = app.canvasSize;
                const ctx = canvas.getContext('2d', { willReadFrequently: true });
                ctx.imageSmoothingEnabled = false;
                return { canvas, ctx, visible: layer.visible, opacity: layer.opacity };
            });

            app.frames.push(frameData);
            app.currentFrameIndex = app.frames.length - 1;
            updateFramesUI();
            saveState();
        }

        function duplicateFrame() {
            const frameData = app.layers.map(layer => {
                const canvas = document.createElement('canvas');
                canvas.width = app.canvasSize;
                canvas.height = app.canvasSize;
                const ctx = canvas.getContext('2d', { willReadFrequently: true });
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(layer.canvas, 0, 0);
                return { canvas, ctx, visible: layer.visible, opacity: layer.opacity };
            });

            app.frames.push(frameData);
            app.currentFrameIndex = app.frames.length - 1;
            updateFramesUI();
            saveState();
        }

        function deleteFrame() {
            if (app.frames.length > 1) {
                app.frames.splice(app.currentFrameIndex, 1);
                if (app.currentFrameIndex >= app.frames.length) {
                    app.currentFrameIndex = app.frames.length - 1;
                }
                loadFrame(app.currentFrameIndex);
                updateFramesUI();
                saveState();
            }
        }

        function updateFramesUI() {
            const container = document.getElementById('framesContainer');
            container.innerHTML = '';

            app.frames.forEach((frameData, i) => {
                const item = document.createElement('div');
                item.className = 'frame-item';
                if (i === app.currentFrameIndex) {
                    item.classList.add('active');
                }

                const preview = document.createElement('canvas');
                preview.className = 'frame-preview';
                preview.width = 50;
                preview.height = 50;
                const previewCtx = preview.getContext('2d');
                previewCtx.imageSmoothingEnabled = false;

                // Composite all layers for preview
                frameData.forEach(layerData => {
                    if (layerData.visible) {
                        previewCtx.globalAlpha = layerData.opacity;
                        previewCtx.drawImage(layerData.canvas, 0, 0, 50, 50);
                    }
                });
                previewCtx.globalAlpha = 1;

                const number = document.createElement('div');
                number.className = 'frame-number';
                number.textContent = i + 1;

                item.appendChild(preview);
                item.appendChild(number);

                item.addEventListener('click', () => {
                    saveCurrentFrame();
                    app.currentFrameIndex = i;
                    loadFrame(i);
                    updateFramesUI();
                });

                container.appendChild(item);
            });
        }

        function saveCurrentFrame() {
            const frameData = app.frames[app.currentFrameIndex];
            app.layers.forEach((layer, i) => {
                if (frameData[i]) {
                    frameData[i].ctx.clearRect(0, 0, app.canvasSize, app.canvasSize);
                    frameData[i].ctx.drawImage(layer.canvas, 0, 0);
                    frameData[i].visible = layer.visible;
                    frameData[i].opacity = layer.opacity;
                }
            });
        }

        function loadFrame(index) {
            const frameData = app.frames[index];
            frameData.forEach((layerData, i) => {
                if (app.layers[i]) {
                    app.layers[i].ctx.clearRect(0, 0, app.canvasSize, app.canvasSize);
                    app.layers[i].ctx.drawImage(layerData.canvas, 0, 0);
                    app.layers[i].visible = layerData.visible;
                    app.layers[i].opacity = layerData.opacity;
                }
            });
            updateLayersUI();
            render();
        }

        function initEventListeners() {
            // Canvas mouse events
            displayCanvas.addEventListener('mousedown', handleMouseDown);
            displayCanvas.addEventListener('mousemove', handleMouseMove);
            displayCanvas.addEventListener('mouseup', handleMouseUp);
            displayCanvas.addEventListener('mouseleave', handleMouseUp);

            // Zoom with scroll wheel
            canvasContainer.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? -1 : 1;
                app.zoom = Math.max(1, Math.min(32, app.zoom + delta));
                applyZoom();
            });

            // Toolbar buttons
            document.getElementById('undoBtn').addEventListener('click', undo);
            document.getElementById('redoBtn').addEventListener('click', redo);
            document.getElementById('gridBtn').addEventListener('click', toggleGrid);
            document.getElementById('symmetryBtn').addEventListener('click', toggleSymmetry);
            document.getElementById('onionSkinBtn').addEventListener('click', toggleOnionSkin);
            document.getElementById('flipHBtn').addEventListener('click', flipHorizontal);
            document.getElementById('flipVBtn').addEventListener('click', flipVertical);
            document.getElementById('zoomFitBtn').addEventListener('click', zoomFit);
            document.getElementById('clearBtn').addEventListener('click', clearLayer);
            document.getElementById('importBtn').addEventListener('click', () => {
                document.getElementById('importModal').classList.add('show');
            });
            document.getElementById('exportBtn').addEventListener('click', () => {
                updateExportPreview();
                document.getElementById('exportModal').classList.add('show');
            });
            document.getElementById('helpBtn').addEventListener('click', () => {
                document.getElementById('helpModal').classList.add('show');
            });

            // Layer buttons
            document.getElementById('addLayerBtn').addEventListener('click', addLayer);
            document.getElementById('mergeLayersBtn').addEventListener('click', mergeLayers);
            document.getElementById('flattenBtn').addEventListener('click', flatten);

            // Animation buttons
            document.getElementById('addFrameBtn').addEventListener('click', () => {
                saveCurrentFrame();
                addFrame();
            });
            document.getElementById('duplicateFrameBtn').addEventListener('click', () => {
                saveCurrentFrame();
                duplicateFrame();
            });
            document.getElementById('deleteFrameBtn').addEventListener('click', deleteFrame);
            document.getElementById('playBtn').addEventListener('click', toggleAnimation);

            // FPS slider
            document.getElementById('fpsSlider').addEventListener('input', (e) => {
                app.fps = parseInt(e.target.value);
                document.getElementById('fpsValue').textContent = app.fps;
                if (app.animationPlaying) {
                    stopAnimation();
                    playAnimation();
                }
            });

            // Export format change
            document.getElementById('exportFormat').addEventListener('change', (e) => {
                const scaleOption = document.getElementById('scaleOption');
                scaleOption.style.display = e.target.value === 'png-scaled' ? 'flex' : 'none';
                updateExportPreview();
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', handleKeyboard);

            // Window resize
            window.addEventListener('resize', () => {
                updateCanvasSize();
            });

            // Auto-save
            setInterval(() => {
                saveToLocalStorage();
            }, 30000); // Every 30 seconds
        }

        function handleMouseDown(e) {
            const rect = displayCanvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / app.zoom);
            const y = Math.floor((e.clientY - rect.top) / app.zoom);

            if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
                app.isPanning = true;
                app.startX = e.clientX - app.panX;
                app.startY = e.clientY - app.panY;
                canvasContainer.style.cursor = 'grabbing';
                return;
            }

            app.isDrawing = true;
            app.startX = x;
            app.startY = y;

            if (app.currentTool === 'pencil') {
                drawPixel(x, y);
                saveState();
            } else if (app.currentTool === 'eraser') {
                erasePixel(x, y);
                saveState();
            } else if (app.currentTool === 'bucket') {
                floodFill(x, y);
                saveState();
            } else if (app.currentTool === 'eyedropper') {
                pickColor(x, y);
            }
        }

        function handleMouseMove(e) {
            if (app.isPanning) {
                app.panX = e.clientX - app.startX;
                app.panY = e.clientY - app.startY;
                applyZoom();
                return;
            }

            if (!app.isDrawing) return;

            const rect = displayCanvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / app.zoom);
            const y = Math.floor((e.clientY - rect.top) / app.zoom);

            if (app.currentTool === 'pencil') {
                drawPixel(x, y);
            } else if (app.currentTool === 'eraser') {
                erasePixel(x, y);
            }
        }

        function handleMouseUp(e) {
            if (app.isPanning) {
                app.isPanning = false;
                canvasContainer.style.cursor = 'crosshair';
                return;
            }

            if (!app.isDrawing) return;

            const rect = displayCanvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / app.zoom);
            const y = Math.floor((e.clientY - rect.top) / app.zoom);

            if (app.currentTool === 'line') {
                drawLine(app.startX, app.startY, x, y);
                saveState();
            } else if (app.currentTool === 'rect') {
                drawRect(app.startX, app.startY, x, y, false);
                saveState();
            } else if (app.currentTool === 'rect-fill') {
                drawRect(app.startX, app.startY, x, y, true);
                saveState();
            } else if (app.currentTool === 'circle') {
                drawCircle(app.startX, app.startY, x, y, false);
                saveState();
            } else if (app.currentTool === 'circle-fill') {
                drawCircle(app.startX, app.startY, x, y, true);
                saveState();
            }

            app.isDrawing = false;
        }

        function drawPixel(x, y) {
            if (x < 0 || x >= app.canvasSize || y < 0 || y >= app.canvasSize) return;

            const layer = app.layers[app.currentLayerIndex];
            layer.ctx.fillStyle = app.currentColor;
            layer.ctx.fillRect(x, y, 1, 1);

            if (app.symmetryEnabled) {
                const mirrorX = app.canvasSize - 1 - x;
                layer.ctx.fillRect(mirrorX, y, 1, 1);
            }

            render();
        }

        function erasePixel(x, y) {
            if (x < 0 || x >= app.canvasSize || y < 0 || y >= app.canvasSize) return;

            const layer = app.layers[app.currentLayerIndex];
            layer.ctx.clearRect(x, y, 1, 1);

            if (app.symmetryEnabled) {
                const mirrorX = app.canvasSize - 1 - x;
                layer.ctx.clearRect(mirrorX, y, 1, 1);
            }

            render();
        }

        function drawLine(x0, y0, x1, y1) {
            const layer = app.layers[app.currentLayerIndex];
            layer.ctx.fillStyle = app.currentColor;

            // Bresenham's line algorithm
            const dx = Math.abs(x1 - x0);
            const dy = Math.abs(y1 - y0);
            const sx = x0 < x1 ? 1 : -1;
            const sy = y0 < y1 ? 1 : -1;
            let err = dx - dy;

            while (true) {
                layer.ctx.fillRect(x0, y0, 1, 1);

                if (app.symmetryEnabled) {
                    const mirrorX = app.canvasSize - 1 - x0;
                    layer.ctx.fillRect(mirrorX, y0, 1, 1);
                }

                if (x0 === x1 && y0 === y1) break;

                const e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    x0 += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    y0 += sy;
                }
            }

            render();
        }

        function drawRect(x0, y0, x1, y1, filled) {
            const layer = app.layers[app.currentLayerIndex];
            layer.ctx.fillStyle = app.currentColor;

            const minX = Math.min(x0, x1);
            const minY = Math.min(y0, y1);
            const maxX = Math.max(x0, x1);
            const maxY = Math.max(y0, y1);

            if (filled) {
                for (let x = minX; x <= maxX; x++) {
                    for (let y = minY; y <= maxY; y++) {
                        layer.ctx.fillRect(x, y, 1, 1);
                    }
                }
            } else {
                for (let x = minX; x <= maxX; x++) {
                    layer.ctx.fillRect(x, minY, 1, 1);
                    layer.ctx.fillRect(x, maxY, 1, 1);
                }
                for (let y = minY; y <= maxY; y++) {
                    layer.ctx.fillRect(minX, y, 1, 1);
                    layer.ctx.fillRect(maxX, y, 1, 1);
                }
            }

            render();
        }

        function drawCircle(x0, y0, x1, y1, filled) {
            const layer = app.layers[app.currentLayerIndex];
            layer.ctx.fillStyle = app.currentColor;

            const dx = x1 - x0;
            const dy = y1 - y0;
            const radius = Math.floor(Math.sqrt(dx * dx + dy * dy));

            if (filled) {
                for (let y = -radius; y <= radius; y++) {
                    for (let x = -radius; x <= radius; x++) {
                        if (x * x + y * y <= radius * radius) {
                            layer.ctx.fillRect(x0 + x, y0 + y, 1, 1);
                        }
                    }
                }
            } else {
                // Midpoint circle algorithm
                let x = radius;
                let y = 0;
                let err = 0;

                while (x >= y) {
                    layer.ctx.fillRect(x0 + x, y0 + y, 1, 1);
                    layer.ctx.fillRect(x0 + y, y0 + x, 1, 1);
                    layer.ctx.fillRect(x0 - y, y0 + x, 1, 1);
                    layer.ctx.fillRect(x0 - x, y0 + y, 1, 1);
                    layer.ctx.fillRect(x0 - x, y0 - y, 1, 1);
                    layer.ctx.fillRect(x0 - y, y0 - x, 1, 1);
                    layer.ctx.fillRect(x0 + y, y0 - x, 1, 1);
                    layer.ctx.fillRect(x0 + x, y0 - y, 1, 1);

                    y += 1;
                    err += 1 + 2 * y;
                    if (2 * (err - x) + 1 > 0) {
                        x -= 1;
                        err += 1 - 2 * x;
                    }
                }
            }

            render();
        }

        function floodFill(startX, startY) {
            const layer = app.layers[app.currentLayerIndex];
            const imageData = layer.ctx.getImageData(0, 0, app.canvasSize, app.canvasSize);
            const data = imageData.data;

            const targetColor = getPixelColor(data, startX, startY);
            const fillColor = hexToRgba(app.currentColor);

            if (colorsEqual(targetColor, fillColor)) return;

            const stack = [[startX, startY]];
            const visited = new Set();

            while (stack.length > 0) {
                const [x, y] = stack.pop();
                const key = `${x},${y}`;

                if (visited.has(key)) continue;
                if (x < 0 || x >= app.canvasSize || y < 0 || y >= app.canvasSize) continue;

                const currentColor = getPixelColor(data, x, y);
                if (!colorsEqual(currentColor, targetColor)) continue;

                visited.add(key);
                setPixelColor(data, x, y, fillColor);

                stack.push([x + 1, y]);
                stack.push([x - 1, y]);
                stack.push([x, y + 1]);
                stack.push([x, y - 1]);
            }

            layer.ctx.putImageData(imageData, 0, 0);
            render();
        }

        function getPixelColor(data, x, y) {
            const index = (y * app.canvasSize + x) * 4;
            return [data[index], data[index + 1], data[index + 2], data[index + 3]];
        }

        function setPixelColor(data, x, y, color) {
            const index = (y * app.canvasSize + x) * 4;
            data[index] = color[0];
            data[index + 1] = color[1];
            data[index + 2] = color[2];
            data[index + 3] = color[3];
        }

        function hexToRgba(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return [r, g, b, 255];
        }

        function colorsEqual(c1, c2) {
            return c1[0] === c2[0] && c1[1] === c2[1] && c1[2] === c2[2] && c1[3] === c2[3];
        }

        function pickColor(x, y) {
            const layer = app.layers[app.currentLayerIndex];
            const imageData = layer.ctx.getImageData(x, y, 1, 1);
            const data = imageData.data;

            if (data[3] === 0) return; // Transparent pixel

            const hex = '#' +
                ('0' + data[0].toString(16)).slice(-2) +
                ('0' + data[1].toString(16)).slice(-2) +
                ('0' + data[2].toString(16)).slice(-2);

            setColor(hex.toUpperCase());
        }

        function render() {
            displayCtx.clearRect(0, 0, app.canvasSize, app.canvasSize);

            // Draw onion skin
            if (app.onionSkinEnabled && app.frames.length > 1) {
                const prevFrameIndex = (app.currentFrameIndex - 1 + app.frames.length) % app.frames.length;
                const prevFrame = app.frames[prevFrameIndex];
                prevFrame.forEach(layerData => {
                    if (layerData.visible) {
                        displayCtx.globalAlpha = 0.3 * layerData.opacity;
                        displayCtx.drawImage(layerData.canvas, 0, 0);
                    }
                });
                displayCtx.globalAlpha = 1;
            }

            // Draw layers
            app.layers.forEach(layer => {
                if (layer.visible) {
                    displayCtx.globalAlpha = layer.opacity;
                    displayCtx.drawImage(layer.canvas, 0, 0);
                }
            });
            displayCtx.globalAlpha = 1;

            drawGrid();
        }

        function drawGrid() {
            gridCtx.clearRect(0, 0, app.canvasSize, app.canvasSize);

            if (!app.gridEnabled) return;

            gridCtx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            gridCtx.lineWidth = 1 / app.zoom;

            for (let x = 0; x <= app.canvasSize; x++) {
                gridCtx.beginPath();
                gridCtx.moveTo(x, 0);
                gridCtx.lineTo(x, app.canvasSize);
                gridCtx.stroke();
            }

            for (let y = 0; y <= app.canvasSize; y++) {
                gridCtx.beginPath();
                gridCtx.moveTo(0, y);
                gridCtx.lineTo(app.canvasSize, y);
                gridCtx.stroke();
            }
        }

        function toggleGrid() {
            app.gridEnabled = !app.gridEnabled;
            document.getElementById('gridBtn').classList.toggle('active', app.gridEnabled);
            drawGrid();
        }

        function toggleSymmetry() {
            app.symmetryEnabled = !app.symmetryEnabled;
            document.getElementById('symmetryBtn').classList.toggle('active', app.symmetryEnabled);
        }

        function toggleOnionSkin() {
            app.onionSkinEnabled = !app.onionSkinEnabled;
            document.getElementById('onionSkinBtn').classList.toggle('active', app.onionSkinEnabled);
            render();
        }

        function flipHorizontal() {
            const layer = app.layers[app.currentLayerIndex];
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = app.canvasSize;
            tempCanvas.height = app.canvasSize;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.imageSmoothingEnabled = false;

            tempCtx.save();
            tempCtx.scale(-1, 1);
            tempCtx.drawImage(layer.canvas, -app.canvasSize, 0);
            tempCtx.restore();

            layer.ctx.clearRect(0, 0, app.canvasSize, app.canvasSize);
            layer.ctx.drawImage(tempCanvas, 0, 0);
            render();
            saveState();
        }

        function flipVertical() {
            const layer = app.layers[app.currentLayerIndex];
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = app.canvasSize;
            tempCanvas.height = app.canvasSize;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.imageSmoothingEnabled = false;

            tempCtx.save();
            tempCtx.scale(1, -1);
            tempCtx.drawImage(layer.canvas, 0, -app.canvasSize);
            tempCtx.restore();

            layer.ctx.clearRect(0, 0, app.canvasSize, app.canvasSize);
            layer.ctx.drawImage(tempCanvas, 0, 0);
            render();
            saveState();
        }

        function zoomFit() {
            updateCanvasSize();
        }

        function clearLayer() {
            if (confirm('Clear current layer?')) {
                const layer = app.layers[app.currentLayerIndex];
                layer.ctx.clearRect(0, 0, app.canvasSize, app.canvasSize);
                render();
                saveState();
            }
        }

        function mergeLayers() {
            if (app.currentLayerIndex < app.layers.length - 1) {
                const currentLayer = app.layers[app.currentLayerIndex];
                const nextLayer = app.layers[app.currentLayerIndex + 1];

                nextLayer.ctx.globalAlpha = currentLayer.opacity;
                nextLayer.ctx.drawImage(currentLayer.canvas, 0, 0);
                nextLayer.ctx.globalAlpha = 1;

                app.layers.splice(app.currentLayerIndex, 1);
                app.currentLayerIndex = Math.min(app.currentLayerIndex, app.layers.length - 1);

                updateLayersUI();
                render();
                saveState();
            }
        }

        function flatten() {
            if (confirm('Flatten all layers into one?')) {
                const flatCanvas = document.createElement('canvas');
                flatCanvas.width = app.canvasSize;
                flatCanvas.height = app.canvasSize;
                const flatCtx = flatCanvas.getContext('2d', { willReadFrequently: true });
                flatCtx.imageSmoothingEnabled = false;

                app.layers.forEach(layer => {
                    if (layer.visible) {
                        flatCtx.globalAlpha = layer.opacity;
                        flatCtx.drawImage(layer.canvas, 0, 0);
                    }
                });
                flatCtx.globalAlpha = 1;

                app.layers = [{
                    canvas: flatCanvas,
                    ctx: flatCtx,
                    visible: true,
                    opacity: 1,
                    name: 'Merged'
                }];

                app.currentLayerIndex = 0;
                updateLayersUI();
                render();
                saveState();
            }
        }

        function toggleAnimation() {
            if (app.animationPlaying) {
                stopAnimation();
            } else {
                playAnimation();
            }
        }

        function playAnimation() {
            if (app.frames.length < 2) return;

            saveCurrentFrame();
            app.animationPlaying = true;
            document.getElementById('playBtn').textContent = '‚è∏ Pause';

            app.animationInterval = setInterval(() => {
                app.currentFrameIndex = (app.currentFrameIndex + 1) % app.frames.length;
                loadFrame(app.currentFrameIndex);
                updateFramesUI();
            }, 1000 / app.fps);
        }

        function stopAnimation() {
            app.animationPlaying = false;
            document.getElementById('playBtn').textContent = '‚ñ∂ Play';
            if (app.animationInterval) {
                clearInterval(app.animationInterval);
                app.animationInterval = null;
            }
        }

        function updateExportPreview() {
            const format = document.getElementById('exportFormat').value;
            const preview = document.getElementById('exportPreview');
            const previewCtx = preview.getContext('2d');
            previewCtx.imageSmoothingEnabled = false;

            if (format === 'spritesheet') {
                preview.width = app.canvasSize * app.frames.length;
                preview.height = app.canvasSize;

                app.frames.forEach((frameData, i) => {
                    frameData.forEach(layerData => {
                        if (layerData.visible) {
                            previewCtx.globalAlpha = layerData.opacity;
                            previewCtx.drawImage(layerData.canvas, i * app.canvasSize, 0);
                        }
                    });
                    previewCtx.globalAlpha = 1;
                });
            } else if (format === 'png-scaled') {
                const scale = parseInt(document.getElementById('exportScale').value);
                preview.width = app.canvasSize * scale;
                preview.height = app.canvasSize * scale;
                previewCtx.drawImage(displayCanvas, 0, 0, preview.width, preview.height);
            } else {
                preview.width = app.canvasSize;
                preview.height = app.canvasSize;
                previewCtx.drawImage(displayCanvas, 0, 0);
            }
        }

        function doExport() {
            const format = document.getElementById('exportFormat').value;
            const preview = document.getElementById('exportPreview');

            if (format === 'gif') {
                alert('GIF export requires external library. Exporting as sprite sheet instead.');
                document.getElementById('exportFormat').value = 'spritesheet';
                updateExportPreview();
                return;
            }

            preview.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `pixel-art-${Date.now()}.png`;
                a.click();
                URL.revokeObjectURL(url);
            });

            closeExportModal();
        }

        function closeExportModal() {
            document.getElementById('exportModal').classList.remove('show');
        }

        function doImport() {
            const file = document.getElementById('importFile').files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    const layer = app.layers[app.currentLayerIndex];
                    layer.ctx.clearRect(0, 0, app.canvasSize, app.canvasSize);
                    layer.ctx.drawImage(img, 0, 0, app.canvasSize, app.canvasSize);
                    render();
                    saveState();
                    closeImportModal();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function closeImportModal() {
            document.getElementById('importModal').classList.remove('show');
            document.getElementById('importFile').value = '';
        }

        function closeHelpModal() {
            document.getElementById('helpModal').classList.remove('show');
        }

        function handleKeyboard(e) {
            // Prevent shortcuts when typing
            if (e.target.tagName === 'INPUT') return;

            const key = e.key.toLowerCase();

            // Tool shortcuts
            const toolMap = {
                'p': 'pencil',
                'e': 'eraser',
                'b': 'bucket',
                'i': 'eyedropper',
                'l': 'line',
                'r': 'rect',
                'c': 'circle',
                's': 'select'
            };

            if (toolMap[key]) {
                e.preventDefault();
                app.currentTool = toolMap[key];
                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.tool === app.currentTool);
                });
            }

            // Undo/Redo
            if (e.ctrlKey || e.metaKey) {
                if (key === 'z' && !e.shiftKey) {
                    e.preventDefault();
                    undo();
                } else if (key === 'y' || (key === 'z' && e.shiftKey)) {
                    e.preventDefault();
                    redo();
                }
            }

            // Grid toggle
            if (key === 'g') {
                e.preventDefault();
                toggleGrid();
            }
        }

        function saveState() {
            // Remove any states after current position
            app.history = app.history.slice(0, app.historyIndex + 1);

            // Save current state
            const state = {
                layers: app.layers.map(layer => {
                    const canvas = document.createElement('canvas');
                    canvas.width = app.canvasSize;
                    canvas.height = app.canvasSize;
                    const ctx = canvas.getContext('2d', { willReadFrequently: true });
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(layer.canvas, 0, 0);
                    return {
                        imageData: ctx.getImageData(0, 0, app.canvasSize, app.canvasSize),
                        visible: layer.visible,
                        opacity: layer.opacity,
                        name: layer.name
                    };
                }),
                currentLayerIndex: app.currentLayerIndex
            };

            app.history.push(state);

            // Limit history size
            if (app.history.length > app.maxHistory) {
                app.history.shift();
            } else {
                app.historyIndex++;
            }
        }

        function undo() {
            if (app.historyIndex > 0) {
                app.historyIndex--;
                restoreState(app.history[app.historyIndex]);
            }
        }

        function redo() {
            if (app.historyIndex < app.history.length - 1) {
                app.historyIndex++;
                restoreState(app.history[app.historyIndex]);
            }
        }

        function restoreState(state) {
            app.layers = state.layers.map(layerState => {
                const canvas = document.createElement('canvas');
                canvas.width = app.canvasSize;
                canvas.height = app.canvasSize;
                const ctx = canvas.getContext('2d', { willReadFrequently: true });
                ctx.imageSmoothingEnabled = false;
                ctx.putImageData(layerState.imageData, 0, 0);
                return {
                    canvas: canvas,
                    ctx: ctx,
                    visible: layerState.visible,
                    opacity: layerState.opacity,
                    name: layerState.name
                };
            });

            app.currentLayerIndex = state.currentLayerIndex;
            updateLayersUI();
            render();
        }

        function saveToLocalStorage() {
            try {
                const data = {
                    canvasSize: app.canvasSize,
                    currentColor: app.currentColor,
                    recentColors: app.recentColors,
                    frames: app.frames.map(frameData => {
                        return frameData.map(layerData => ({
                            imageData: Array.from(layerData.ctx.getImageData(0, 0, app.canvasSize, app.canvasSize).data),
                            visible: layerData.visible,
                            opacity: layerData.opacity
                        }));
                    }),
                    currentFrameIndex: app.currentFrameIndex,
                    layerNames: app.layers.map(l => l.name)
                };

                localStorage.setItem('pixelArtStudio', JSON.stringify(data));
            } catch (e) {
                console.error('Failed to save to localStorage:', e);
            }
        }

        function loadFromLocalStorage() {
            try {
                const saved = localStorage.getItem('pixelArtStudio');
                if (!saved) return;

                const data = JSON.parse(saved);

                // Restore canvas size
                if (data.canvasSize && data.canvasSize === app.canvasSize) {
                    // Restore colors
                    if (data.currentColor) setColor(data.currentColor);
                    if (data.recentColors) {
                        app.recentColors = data.recentColors;
                        updateRecentColors();
                    }

                    // Restore frames and layers
                    if (data.frames && data.frames.length > 0) {
                        app.frames = data.frames.map(frameData => {
                            return frameData.map(layerState => {
                                const canvas = document.createElement('canvas');
                                canvas.width = app.canvasSize;
                                canvas.height = app.canvasSize;
                                const ctx = canvas.getContext('2d', { willReadFrequently: true });
                                ctx.imageSmoothingEnabled = false;

                                const imageData = ctx.createImageData(app.canvasSize, app.canvasSize);
                                imageData.data.set(new Uint8ClampedArray(layerState.imageData));
                                ctx.putImageData(imageData, 0, 0);

                                return {
                                    canvas: canvas,
                                    ctx: ctx,
                                    visible: layerState.visible,
                                    opacity: layerState.opacity
                                };
                            });
                        });

                        app.currentFrameIndex = data.currentFrameIndex || 0;
                        loadFrame(app.currentFrameIndex);
                    }

                    // Restore layer names
                    if (data.layerNames) {
                        data.layerNames.forEach((name, i) => {
                            if (app.layers[i]) {
                                app.layers[i].name = name;
                            }
                        });
                    }

                    updateLayersUI();
                    updateFramesUI();
                    render();
                }
            } catch (e) {
                console.error('Failed to load from localStorage:', e);
            }
        }

        // Initialize the app
        init();
    </script>
</body>
</html>