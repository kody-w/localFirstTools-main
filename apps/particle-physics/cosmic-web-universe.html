<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Cosmic Web Universe Simulator - Watch billions of years of cosmic evolution with dark matter filaments, galaxy clusters, black hole mergers, and fleeting civilizations">
    <!-- 3d, webgl, simulation, physics, generative, animation, space -->
    <title>Cosmic Web Universe Simulator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            color: #fff;
        }

        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #ui {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            pointer-events: none;
        }

        .panel {
            background: rgba(0, 10, 30, 0.85);
            border: 1px solid rgba(100, 150, 255, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            backdrop-filter: blur(10px);
            pointer-events: auto;
        }

        h1 {
            font-size: 18px;
            color: #88ccff;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(100, 150, 255, 0.5);
        }

        .stat {
            font-size: 12px;
            color: #aaccff;
            margin: 5px 0;
        }

        .stat span {
            color: #ffcc88;
        }

        #controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 100;
        }

        button {
            background: rgba(50, 100, 200, 0.5);
            border: 1px solid rgba(100, 150, 255, 0.5);
            color: #fff;
            padding: 8px 16px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.2s;
        }

        button:hover {
            background: rgba(80, 130, 230, 0.7);
            border-color: rgba(150, 200, 255, 0.8);
        }

        button.active {
            background: rgba(100, 180, 255, 0.6);
            border-color: #88ccff;
        }

        #zoom-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 100;
        }

        .zoom-scale {
            font-size: 14px;
            color: #88ccff;
            text-align: right;
        }

        .time-scale {
            font-size: 12px;
            color: #ffaa66;
            text-align: right;
            margin-top: 5px;
        }

        #event-log {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 300px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 100;
        }

        .event {
            font-size: 11px;
            padding: 5px;
            margin: 2px 0;
            border-left: 2px solid;
            padding-left: 10px;
            animation: fadeIn 0.5s;
        }

        .event.merger { border-color: #ff6644; color: #ffaa88; }
        .event.birth { border-color: #44ff88; color: #88ffaa; }
        .event.civilization { border-color: #ffff44; color: #ffffaa; }
        .event.supernova { border-color: #ff44ff; color: #ffaaff; }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        #instructions {
            position: fixed;
            bottom: 80px;
            left: 20px;
            font-size: 11px;
            color: rgba(150, 180, 220, 0.7);
        }

        .cosmic-age {
            font-size: 24px;
            color: #ffcc66;
            text-shadow: 0 0 15px rgba(255, 200, 100, 0.5);
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div id="ui">
        <div class="panel">
            <h1>Cosmic Web Universe</h1>
            <div class="cosmic-age">Age: <span id="universe-age">0</span> Gyr</div>
            <div class="stat">Galaxies: <span id="galaxy-count">0</span></div>
            <div class="stat">Black Holes: <span id="blackhole-count">0</span></div>
            <div class="stat">Civilizations: <span id="civ-count">0</span> (total: <span id="civ-total">0</span>)</div>
            <div class="stat">Mergers: <span id="merger-count">0</span></div>
        </div>
    </div>

    <div id="zoom-indicator" class="panel">
        <div class="zoom-scale">Scale: <span id="scale-text">Universe</span></div>
        <div class="zoom-scale"><span id="scale-size">~93 billion ly</span></div>
        <div class="time-scale">Time: <span id="time-rate">1 Myr/s</span></div>
    </div>

    <div id="controls" class="panel">
        <button id="btn-pause">Pause</button>
        <button id="btn-speed-down">Slower</button>
        <button id="btn-speed-up">Faster</button>
        <button id="btn-reset">Reset</button>
    </div>

    <div id="instructions">
        Scroll to zoom | Drag to rotate | Click galaxy to focus
    </div>

    <div id="event-log" class="panel"></div>

    <script>
        // Cosmic Web Universe Simulator
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // State
        let width, height;
        let universeAge = 0; // in billions of years
        let timeSpeed = 0.05; // Gyr per frame (much faster!)
        let paused = false;
        let zoom = 1;
        let targetZoom = 1;
        let cameraX = 0, cameraY = 0;
        let targetCameraX = 0, targetCameraY = 0;
        let dragStartX, dragStartY, isDragging = false;
        let cameraRotX = 0, cameraRotY = 0;

        // Cosmic entities
        let darkMatterNodes = [];
        let filaments = [];
        let galaxies = [];
        let blackHoles = [];
        let civilizations = [];
        let events = [];
        let particles = [];

        // Stats
        let totalCivilizations = 0;
        let totalMergers = 0;

        // Zoom scales
        const ZOOM_SCALES = [
            { name: 'Observable Universe', size: '~93 billion ly', timeRate: '100 Myr/s', factor: 1 },
            { name: 'Supercluster', size: '~500 million ly', timeRate: '10 Myr/s', factor: 5 },
            { name: 'Galaxy Cluster', size: '~10 million ly', timeRate: '1 Myr/s', factor: 25 },
            { name: 'Galaxy Group', size: '~5 million ly', timeRate: '100,000 yr/s', factor: 100 },
            { name: 'Galaxy', size: '~100,000 ly', timeRate: '10,000 yr/s', factor: 500 },
            { name: 'Stellar Region', size: '~1,000 ly', timeRate: '1,000 yr/s', factor: 2000 },
            { name: 'Star System', size: '~100 AU', timeRate: '100 yr/s', factor: 10000 },
            { name: 'Planetary', size: '~1 AU', timeRate: '1 yr/s', factor: 50000 }
        ];

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }

        // Simplex-like noise for cosmic web
        function noise2D(x, y) {
            const n = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
            return (n - Math.floor(n)) * 2 - 1;
        }

        function fbm(x, y, octaves = 4) {
            let value = 0;
            let amplitude = 0.5;
            let frequency = 1;
            for (let i = 0; i < octaves; i++) {
                value += amplitude * noise2D(x * frequency, y * frequency);
                amplitude *= 0.5;
                frequency *= 2;
            }
            return value;
        }

        // Initialize cosmic web structure
        function initializeUniverse() {
            darkMatterNodes = [];
            filaments = [];
            galaxies = [];
            blackHoles = [];
            civilizations = [];
            events = [];
            particles = [];
            universeAge = 0;
            totalCivilizations = 0;
            totalMergers = 0;

            // Create dark matter nodes (attractors) in a 3D cubic volume
            const nodeCount = 120;
            const cubeSize = 400;
            for (let i = 0; i < nodeCount; i++) {
                darkMatterNodes.push({
                    x: (Math.random() - 0.5) * cubeSize * 2,
                    y: (Math.random() - 0.5) * cubeSize * 2,
                    z: (Math.random() - 0.5) * cubeSize * 2,
                    mass: Math.random() * 5 + 1,
                    vx: 0,
                    vy: 0
                });
            }

            // Create filaments between nearby nodes in 3D space
            for (let i = 0; i < darkMatterNodes.length; i++) {
                for (let j = i + 1; j < darkMatterNodes.length; j++) {
                    const dx = darkMatterNodes[j].x - darkMatterNodes[i].x;
                    const dy = darkMatterNodes[j].y - darkMatterNodes[i].y;
                    const dz = darkMatterNodes[j].z - darkMatterNodes[i].z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

                    // Connect nodes within range, probability decreases with distance
                    if (dist < 350 && Math.random() < 0.3 * (1 - dist / 350)) {
                        filaments.push({
                            from: i,
                            to: j,
                            strength: Math.random() * 0.5 + 0.5,
                            phase: Math.random() * Math.PI * 2
                        });
                    }
                }
            }

            logEvent('birth', 'Big Bang - Universe begins');

            // Spawn initial galaxies immediately for visual interest
            for (let i = 0; i < 50; i++) {
                spawnGalaxy();
            }
        }

        // Spawn galaxy along filaments
        function spawnGalaxy() {
            if (filaments.length === 0) return;

            const filament = filaments[Math.floor(Math.random() * filaments.length)];
            const nodeA = darkMatterNodes[filament.from];
            const nodeB = darkMatterNodes[filament.to];
            const t = Math.random();

            const galaxy = {
                x: nodeA.x + (nodeB.x - nodeA.x) * t + (Math.random() - 0.5) * 50,
                y: nodeA.y + (nodeB.y - nodeA.y) * t + (Math.random() - 0.5) * 50,
                z: nodeA.z + (nodeB.z - nodeA.z) * t + (Math.random() - 0.5) * 50,
                vx: (Math.random() - 0.5) * 0.1,
                vy: (Math.random() - 0.5) * 0.1,
                vz: (Math.random() - 0.5) * 0.1,
                mass: Math.random() * 10 + 1,
                size: Math.random() * 3 + 1,
                rotation: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.01,
                type: Math.random() < 0.7 ? 'spiral' : (Math.random() < 0.5 ? 'elliptical' : 'irregular'),
                color: `hsl(${Math.random() * 60 + 200}, 80%, ${Math.random() * 20 + 60}%)`,
                age: 0,
                stars: Math.floor(Math.random() * 400e9 + 100e9),
                hasBlackHole: Math.random() < 0.8,
                id: Math.random().toString(36).substr(2, 9)
            };

            galaxies.push(galaxy);

            if (galaxy.hasBlackHole) {
                blackHoles.push({
                    galaxy: galaxy,
                    mass: galaxy.mass * 0.001,
                    accretionRate: Math.random() * 0.001
                });
            }
        }

        // Update galaxy physics
        function updateGalaxies(dt) {
            for (let i = galaxies.length - 1; i >= 0; i--) {
                const g = galaxies[i];
                g.age += dt;
                g.rotation += g.rotationSpeed;

                // Gravitational attraction to dark matter nodes (full 3D)
                for (const node of darkMatterNodes) {
                    const dx = node.x - g.x;
                    const dy = node.y - g.y;
                    const dz = node.z - g.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz) + 1;
                    const force = node.mass * 0.0001 / (dist * dist);
                    g.vx += dx / dist * force;
                    g.vy += dy / dist * force;
                    g.vz += dz / dist * force;
                }

                // Galaxy-galaxy interactions (full 3D)
                for (let j = 0; j < galaxies.length; j++) {
                    if (i === j) continue;
                    const other = galaxies[j];
                    const dx = other.x - g.x;
                    const dy = other.y - g.y;
                    const dz = other.z - g.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

                    // Merger check
                    if (dist < (g.size + other.size) * 3) {
                        if (g.mass >= other.mass) {
                            // Merge
                            g.mass += other.mass * 0.8;
                            g.size = Math.cbrt(g.size ** 3 + other.size ** 3 * 0.5);
                            g.stars += other.stars * 0.7;
                            g.type = 'elliptical';

                            // Create merger particles (3D)
                            for (let p = 0; p < 20; p++) {
                                particles.push({
                                    x: (g.x + other.x) / 2,
                                    y: (g.y + other.y) / 2,
                                    z: (g.z + other.z) / 2,
                                    vx: (Math.random() - 0.5) * 3,
                                    vy: (Math.random() - 0.5) * 3,
                                    vz: (Math.random() - 0.5) * 3,
                                    life: 1,
                                    color: '#ff8844',
                                    size: Math.random() * 2 + 1
                                });
                            }

                            // Merge black holes
                            const bhA = blackHoles.find(bh => bh.galaxy === g);
                            const bhB = blackHoles.find(bh => bh.galaxy === other);
                            if (bhA && bhB) {
                                bhA.mass += bhB.mass;
                                blackHoles = blackHoles.filter(bh => bh !== bhB);
                                totalMergers++;
                                logEvent('merger', `Galaxy merger! Black holes combined`);
                            }

                            galaxies.splice(j, 1);
                            if (j < i) i--;
                        }
                    } else {
                        // Gravitational attraction (3D)
                        const force = other.mass * 0.00001 / (dist * dist);
                        g.vx += dx / dist * force;
                        g.vy += dy / dist * force;
                        g.vz += dz / dist * force;
                    }
                }

                // Apply velocity with damping (3D)
                g.x += g.vx;
                g.y += g.vy;
                g.z += g.vz;
                g.vx *= 0.999;
                g.vy *= 0.999;
                g.vz *= 0.999;

                // Spawn civilizations randomly on old galaxies
                if (g.age > 2 && Math.random() < 0.0005 * g.stars / 1e11) {
                    spawnCivilization(g);
                }
            }
        }

        // Spawn a civilization (3D)
        function spawnCivilization(galaxy) {
            const civ = {
                galaxy: galaxy,
                age: 0,
                lifespan: Math.random() * 0.5 + 0.1, // Brief on cosmic scale but visible
                brightness: 0,
                x: galaxy.x + (Math.random() - 0.5) * galaxy.size * 3,
                y: galaxy.y + (Math.random() - 0.5) * galaxy.size * 3,
                z: galaxy.z + (Math.random() - 0.5) * galaxy.size * 3
            };
            civilizations.push(civ);
            totalCivilizations++;

            if (Math.random() < 0.3) {
                logEvent('civilization', `Civilization emerged in galaxy`);
            }
        }

        // Update civilizations (3D)
        function updateCivilizations(dt) {
            for (let i = civilizations.length - 1; i >= 0; i--) {
                const civ = civilizations[i];
                civ.age += dt;

                // Track relative offset from galaxy center
                const offsetX = civ.x - civ.galaxy.x;
                const offsetY = civ.y - civ.galaxy.y;
                const offsetZ = civ.z - civ.galaxy.z;

                // Follow galaxy as it moves
                civ.x = civ.galaxy.x + offsetX;
                civ.y = civ.galaxy.y + offsetY;
                civ.z = civ.galaxy.z + offsetZ;

                // Brightness curve
                const progress = civ.age / civ.lifespan;
                if (progress < 0.2) {
                    civ.brightness = progress / 0.2;
                } else if (progress < 0.8) {
                    civ.brightness = 1;
                } else {
                    civ.brightness = (1 - progress) / 0.2;
                }

                // Die
                if (civ.age >= civ.lifespan) {
                    civilizations.splice(i, 1);
                }
            }
        }

        // Update particles (3D)
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.z += p.vz || 0;
                p.vx *= 0.98;
                p.vy *= 0.98;
                if (p.vz) p.vz *= 0.98;
                p.life -= 0.02;
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        // Log cosmic event
        function logEvent(type, message) {
            events.unshift({ type, message, time: universeAge });
            if (events.length > 20) events.pop();

            const log = document.getElementById('event-log');
            log.innerHTML = events.map(e =>
                `<div class="event ${e.type}">[${e.time.toFixed(2)} Gyr] ${e.message}</div>`
            ).join('');
        }

        // Get current zoom scale info
        function getZoomScale() {
            const logZoom = Math.log10(zoom);
            const index = Math.min(Math.floor(logZoom * 1.5), ZOOM_SCALES.length - 1);
            return ZOOM_SCALES[Math.max(0, index)];
        }

        // Project 3D to 2D with rotation
        function project(x, y, z) {
            // Simple rotation
            const cosX = Math.cos(cameraRotX);
            const sinX = Math.sin(cameraRotX);
            const cosY = Math.cos(cameraRotY);
            const sinY = Math.sin(cameraRotY);

            // Rotate around Y
            let rx = x * cosY - z * sinY;
            let rz = x * sinY + z * cosY;

            // Rotate around X
            let ry = y * cosX - rz * sinX;
            rz = y * sinX + rz * cosX;

            // Perspective
            const perspective = 800;
            const scale = perspective / (perspective + rz);

            return {
                x: rx * scale * zoom + width / 2 + cameraX,
                y: ry * scale * zoom + height / 2 + cameraY,
                scale: scale * zoom,
                z: rz
            };
        }

        // Render
        function render() {
            // Clear - solid background for visibility
            ctx.fillStyle = '#000510';
            ctx.fillRect(0, 0, width, height);

            // Draw cosmic background glow
            const gradient = ctx.createRadialGradient(width/2, height/2, 0, width/2, height/2, width/2);
            gradient.addColorStop(0, 'rgba(20, 10, 40, 0.1)');
            gradient.addColorStop(0.5, 'rgba(10, 5, 30, 0.05)');
            gradient.addColorStop(1, 'rgba(0, 0, 10, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);

            // Sort all objects by z for proper depth rendering
            const allObjects = [];

            // Dark matter nodes
            for (const node of darkMatterNodes) {
                const p = project(node.x, node.y, node.z);
                allObjects.push({ type: 'node', obj: node, p });
            }

            // Galaxies
            for (const galaxy of galaxies) {
                const p = project(galaxy.x, galaxy.y, galaxy.z);
                allObjects.push({ type: 'galaxy', obj: galaxy, p });
            }

            // Sort by z (far to near)
            allObjects.sort((a, b) => b.p.z - a.p.z);

            // Draw filaments first (behind everything)
            ctx.globalAlpha = 0.5;
            for (const filament of filaments) {
                const nodeA = darkMatterNodes[filament.from];
                const nodeB = darkMatterNodes[filament.to];
                const pA = project(nodeA.x, nodeA.y, nodeA.z);
                const pB = project(nodeB.x, nodeB.y, nodeB.z);

                const gradient = ctx.createLinearGradient(pA.x, pA.y, pB.x, pB.y);
                const intensity = 0.5 + Math.sin(universeAge * 0.1 + filament.phase) * 0.2;
                gradient.addColorStop(0, `rgba(100, 80, 180, ${intensity})`);
                gradient.addColorStop(0.5, `rgba(140, 100, 220, ${intensity * 1.2})`);
                gradient.addColorStop(1, `rgba(100, 80, 180, ${intensity})`);

                ctx.strokeStyle = gradient;
                ctx.lineWidth = filament.strength * 3 * Math.min(pA.scale, pB.scale);
                ctx.beginPath();
                ctx.moveTo(pA.x, pA.y);

                // Curved filament
                const midX = (pA.x + pB.x) / 2 + Math.sin(universeAge * 0.05 + filament.phase) * 20;
                const midY = (pA.y + pB.y) / 2 + Math.cos(universeAge * 0.05 + filament.phase) * 20;
                ctx.quadraticCurveTo(midX, midY, pB.x, pB.y);
                ctx.stroke();
            }
            ctx.globalAlpha = 1;

            // Draw objects in z-order
            for (const item of allObjects) {
                const { type, obj, p } = item;

                if (type === 'node') {
                    // Dark matter node glow
                    ctx.globalAlpha = 0.4 * Math.min(1, p.scale);
                    const nodeGradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, obj.mass * 20 * p.scale);
                    nodeGradient.addColorStop(0, 'rgba(150, 100, 255, 0.6)');
                    nodeGradient.addColorStop(0.5, 'rgba(100, 60, 200, 0.3)');
                    nodeGradient.addColorStop(1, 'rgba(50, 30, 120, 0)');
                    ctx.fillStyle = nodeGradient;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, obj.mass * 20 * p.scale, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }

                if (type === 'galaxy') {
                    drawGalaxy(obj, p);
                }
            }

            // Draw civilizations (3D)
            for (const civ of civilizations) {
                const p = project(civ.x, civ.y, civ.z);
                if (p.scale > 0.1) {
                    ctx.globalAlpha = civ.brightness * Math.min(1, p.scale);

                    // Civilization glow
                    const civGradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, 5 * p.scale);
                    civGradient.addColorStop(0, 'rgba(255, 255, 150, 1)');
                    civGradient.addColorStop(0.3, 'rgba(255, 220, 100, 0.8)');
                    civGradient.addColorStop(1, 'rgba(255, 200, 50, 0)');
                    ctx.fillStyle = civGradient;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 5 * p.scale, 0, Math.PI * 2);
                    ctx.fill();

                    // Sparkle
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 1 * p.scale, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.globalAlpha = 1;
                }
            }

            // Draw particles (3D)
            for (const p of particles) {
                const proj = project(p.x, p.y, p.z || 0);
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(proj.x, proj.y, p.size * proj.scale, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            // Update UI
            document.getElementById('universe-age').textContent = universeAge.toFixed(3);
            document.getElementById('galaxy-count').textContent = galaxies.length;
            document.getElementById('blackhole-count').textContent = blackHoles.length;
            document.getElementById('civ-count').textContent = civilizations.length;
            document.getElementById('civ-total').textContent = totalCivilizations;
            document.getElementById('merger-count').textContent = totalMergers;

            const scale = getZoomScale();
            document.getElementById('scale-text').textContent = scale.name;
            document.getElementById('scale-size').textContent = scale.size;
            document.getElementById('time-rate').textContent = scale.timeRate;
        }

        // Draw a galaxy
        function drawGalaxy(galaxy, p) {
            if (p.x < -100 || p.x > width + 100 || p.y < -100 || p.y > height + 100) return;
            if (p.scale < 0.02) return;

            const size = galaxy.size * 8 * p.scale;

            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.rotate(galaxy.rotation);

            // Galaxy glow
            const glowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 2);
            glowGradient.addColorStop(0, galaxy.color);
            glowGradient.addColorStop(0.3, galaxy.color.replace('50%', '30%'));
            glowGradient.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(0, 0, size * 2, 0, Math.PI * 2);
            ctx.fill();

            if (galaxy.type === 'spiral' && size > 5) {
                // Draw spiral arms
                ctx.strokeStyle = galaxy.color;
                ctx.lineWidth = size * 0.2;
                ctx.globalAlpha = 0.6;

                for (let arm = 0; arm < 2; arm++) {
                    ctx.beginPath();
                    for (let t = 0; t < Math.PI * 3; t += 0.1) {
                        const r = t * size * 0.15;
                        const x = Math.cos(t + arm * Math.PI) * r;
                        const y = Math.sin(t + arm * Math.PI) * r * 0.4; // Flatten
                        if (t === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;
            }

            // Core
            const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.5);
            coreGradient.addColorStop(0, '#fff');
            coreGradient.addColorStop(0.3, galaxy.color);
            coreGradient.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = coreGradient;
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.5, 0, Math.PI * 2);
            ctx.fill();

            // Black hole indicator at center
            if (galaxy.hasBlackHole && size > 10) {
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(0, 0, size * 0.08, 0, Math.PI * 2);
                ctx.fill();

                // Accretion disk
                ctx.strokeStyle = 'rgba(255, 150, 50, 0.5)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.ellipse(0, 0, size * 0.15, size * 0.05, universeAge * 2, 0, Math.PI * 2);
                ctx.stroke();
            }

            ctx.restore();
        }

        // Main update loop
        function update() {
            if (!paused) {
                const dt = timeSpeed * getZoomScale().factor * 0.01;
                universeAge += dt;

                // Spawn galaxies over time
                if (Math.random() < 0.01 && galaxies.length < 150) {
                    spawnGalaxy();
                }

                // Supernova events (3D)
                if (Math.random() < 0.001 && galaxies.length > 0) {
                    const g = galaxies[Math.floor(Math.random() * galaxies.length)];
                    for (let i = 0; i < 10; i++) {
                        particles.push({
                            x: g.x,
                            y: g.y,
                            z: g.z,
                            vx: (Math.random() - 0.5) * 5,
                            vy: (Math.random() - 0.5) * 5,
                            vz: (Math.random() - 0.5) * 5,
                            life: 1,
                            color: '#ff88ff',
                            size: Math.random() * 2 + 0.5
                        });
                    }
                    if (Math.random() < 0.05) {
                        logEvent('supernova', 'Supernova explosion!');
                    }
                }

                updateGalaxies(dt);
                updateCivilizations(dt);
                updateParticles();
            }

            // Smooth zoom
            zoom += (targetZoom - zoom) * 0.1;
            cameraX += (targetCameraX - cameraX) * 0.1;
            cameraY += (targetCameraY - cameraY) * 0.1;

            render();
            requestAnimationFrame(update);
        }

        // Event handlers
        function setupControls() {
            // Mouse wheel zoom
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                targetZoom = Math.max(0.5, Math.min(100, targetZoom * zoomFactor));
            });

            // Drag to rotate
            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
            });

            canvas.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const dx = e.clientX - dragStartX;
                    const dy = e.clientY - dragStartY;
                    cameraRotY += dx * 0.005;
                    cameraRotX += dy * 0.005;
                    cameraRotX = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraRotX));
                    dragStartX = e.clientX;
                    dragStartY = e.clientY;
                }
            });

            canvas.addEventListener('mouseup', () => isDragging = false);
            canvas.addEventListener('mouseleave', () => isDragging = false);

            // Touch support
            canvas.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    isDragging = true;
                    dragStartX = e.touches[0].clientX;
                    dragStartY = e.touches[0].clientY;
                }
            });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (isDragging && e.touches.length === 1) {
                    const dx = e.touches[0].clientX - dragStartX;
                    const dy = e.touches[0].clientY - dragStartY;
                    cameraRotY += dx * 0.005;
                    cameraRotX += dy * 0.005;
                    cameraRotX = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraRotX));
                    dragStartX = e.touches[0].clientX;
                    dragStartY = e.touches[0].clientY;
                }
            });

            canvas.addEventListener('touchend', () => isDragging = false);

            // Buttons
            document.getElementById('btn-pause').addEventListener('click', () => {
                paused = !paused;
                document.getElementById('btn-pause').textContent = paused ? 'Play' : 'Pause';
                document.getElementById('btn-pause').classList.toggle('active', paused);
            });

            document.getElementById('btn-speed-down').addEventListener('click', () => {
                timeSpeed = Math.max(0.001, timeSpeed * 0.5);
            });

            document.getElementById('btn-speed-up').addEventListener('click', () => {
                timeSpeed = Math.min(0.5, timeSpeed * 2);
            });

            document.getElementById('btn-reset').addEventListener('click', () => {
                initializeUniverse();
            });

            // Click on galaxy to focus
            canvas.addEventListener('click', (e) => {
                if (isDragging) return;

                const clickX = e.clientX;
                const clickY = e.clientY;

                for (const galaxy of galaxies) {
                    const p = project(galaxy.x, galaxy.y, galaxy.z);
                    const dx = clickX - p.x;
                    const dy = clickY - p.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < galaxy.size * 10 * p.scale) {
                        targetCameraX = -galaxy.x * zoom + width/2 - cameraX;
                        targetCameraY = -galaxy.y * zoom + height/2 - cameraY;
                        targetZoom = Math.min(20, targetZoom * 2);
                        break;
                    }
                }
            });
        }

        // Initialize
        resize();
        window.addEventListener('resize', resize);
        setupControls();
        initializeUniverse();
        update();
    </script>
</body>
</html>
