<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Quantum Immortality Brancher - Experience the many-worlds interpretation where every quantum event splits reality and you exist in all branches simultaneously">
    <!-- simulation, quantum, physics, interactive, generative, philosophical -->
    <title>Quantum Immortality Brancher</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: 'Segoe UI', system-ui, sans-serif;
            color: #fff;
        }

        #canvas {
            position: fixed;
            top: 0;
            left: 0;
        }

        .panel {
            position: fixed;
            background: rgba(0, 5, 20, 0.9);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 12px;
            padding: 20px;
            backdrop-filter: blur(15px);
            z-index: 100;
        }

        #stats {
            top: 20px;
            left: 20px;
            min-width: 280px;
        }

        h1 {
            font-size: 20px;
            color: #88ddff;
            margin-bottom: 15px;
            text-shadow: 0 0 20px rgba(100, 200, 255, 0.5);
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 14px;
        }

        .stat-label {
            color: #88aacc;
        }

        .stat-value {
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }

        .alive { color: #44ff88; }
        .dead { color: #ff4466; }
        .thriving { color: #ffdd44; }
        .suffering { color: #ff8844; }

        #choices {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            max-width: 600px;
        }

        .choice-prompt {
            font-size: 18px;
            color: #aaddff;
            margin-bottom: 15px;
        }

        .choice-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .choice-btn {
            background: linear-gradient(135deg, rgba(50, 100, 180, 0.6), rgba(30, 60, 120, 0.8));
            border: 1px solid rgba(100, 180, 255, 0.5);
            color: #fff;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
            min-width: 150px;
        }

        .choice-btn:hover {
            background: linear-gradient(135deg, rgba(80, 140, 220, 0.8), rgba(50, 100, 180, 0.9));
            border-color: rgba(150, 220, 255, 0.8);
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(100, 180, 255, 0.3);
        }

        .choice-btn .risk {
            display: block;
            font-size: 11px;
            color: #ffaa66;
            margin-top: 5px;
        }

        #timeline-info {
            top: 20px;
            right: 20px;
            max-width: 300px;
        }

        .timeline-header {
            font-size: 14px;
            color: #88ddff;
            margin-bottom: 10px;
        }

        .timeline-content {
            font-size: 12px;
            color: #aabbcc;
            line-height: 1.6;
        }

        .branch-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }

        #controls {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
        }

        #controls button {
            background: rgba(50, 80, 120, 0.6);
            border: 1px solid rgba(100, 150, 200, 0.4);
            color: #aaccee;
            padding: 8px 16px;
            margin: 0 5px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        #controls button:hover {
            background: rgba(70, 110, 160, 0.8);
        }

        #quantum-meter {
            position: fixed;
            bottom: 120px;
            left: 20px;
            width: 200px;
        }

        .meter-label {
            font-size: 11px;
            color: #88aacc;
            margin-bottom: 5px;
        }

        .meter-bar {
            height: 8px;
            background: rgba(50, 80, 120, 0.5);
            border-radius: 4px;
            overflow: hidden;
        }

        .meter-fill {
            height: 100%;
            background: linear-gradient(90deg, #4488ff, #88ddff);
            transition: width 0.3s;
        }

        #message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: #ffddaa;
            text-align: center;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            text-shadow: 0 0 30px rgba(255, 200, 100, 0.8);
            z-index: 200;
        }

        .philosophy-note {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 250px;
            font-size: 11px;
            color: rgba(150, 180, 220, 0.7);
            font-style: italic;
            line-height: 1.5;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        .quantum-event {
            animation: pulse 0.5s ease-out;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div id="stats" class="panel">
        <h1>⚛ Quantum Multiverse</h1>
        <div class="stat-row">
            <span class="stat-label">Total Branches:</span>
            <span class="stat-value" id="total-branches">1</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Versions of You Alive:</span>
            <span class="stat-value alive" id="alive-count">1</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Versions Deceased:</span>
            <span class="stat-value dead" id="dead-count">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Thriving Timelines:</span>
            <span class="stat-value thriving" id="thriving-count">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Suffering Timelines:</span>
            <span class="stat-value suffering" id="suffering-count">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Quantum Events:</span>
            <span class="stat-value" id="event-count">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Your Age:</span>
            <span class="stat-value" id="age">0</span> years
        </div>
    </div>

    <div id="controls" class="panel">
        <button id="btn-zoom-out">Zoom Out</button>
        <button id="btn-zoom-in">Zoom In</button>
        <button id="btn-recenter">Recenter</button>
        <button id="btn-pause">Pause Time</button>
        <button id="btn-reset">New Life</button>
    </div>

    <div id="timeline-info" class="panel">
        <div class="timeline-header">Current Focus Timeline</div>
        <div class="timeline-content" id="timeline-desc">
            You are born. Infinite possibilities stretch before you. Every quantum fluctuation in your neurons, every radioactive decay nearby, splits reality into parallel branches where different versions of you will live different lives.
        </div>
    </div>

    <div id="choices" class="panel" style="display: none;">
        <div class="choice-prompt" id="choice-prompt">A choice approaches...</div>
        <div class="choice-buttons" id="choice-buttons"></div>
    </div>

    <div id="quantum-meter" class="panel">
        <div class="meter-label">Quantum Coherence</div>
        <div class="meter-bar">
            <div class="meter-fill" id="coherence-fill" style="width: 100%"></div>
        </div>
        <div class="meter-label" style="margin-top: 10px;">Next Branch Event</div>
        <div class="meter-bar">
            <div class="meter-fill" id="event-fill" style="width: 0%; background: linear-gradient(90deg, #ff8844, #ffdd44);"></div>
        </div>
    </div>

    <div id="message"></div>

    <div class="philosophy-note">
        "From the quantum perspective, you never die. In the branches where fatal events occur, your consciousness simply doesn't continue there - but it always continues somewhere."
        <br><br>— Quantum Immortality Hypothesis
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let time = 0;
        let age = 0;
        let paused = false;
        let zoom = 1;
        let targetZoom = 1;
        let panX = 0, panY = 0;
        let targetPanX = 0, targetPanY = 0;
        let isDragging = false;
        let dragStartX, dragStartY;

        // Timeline tree structure
        let rootTimeline = null;
        let allTimelines = [];
        let focusedTimeline = null;
        let eventCount = 0;
        let nextEventTimer = 0;
        let nextChoiceTimer = 0;
        let currentChoice = null;

        // Life events and choices
        const LIFE_EVENTS = [
            { age: 5, prompt: "Your first day of school", choices: [
                { text: "Make a friend", risk: "Low risk", deathChance: 0, modifier: 0.1 },
                { text: "Stay alone", risk: "Safe", deathChance: 0, modifier: -0.05 }
            ]},
            { age: 10, prompt: "A dare from friends", choices: [
                { text: "Climb the tall tree", risk: "5% mortality", deathChance: 0.05, modifier: 0.15 },
                { text: "Refuse the dare", risk: "Safe", deathChance: 0, modifier: -0.1 }
            ]},
            { age: 16, prompt: "Learning to drive", choices: [
                { text: "Take risks, feel alive", risk: "8% mortality", deathChance: 0.08, modifier: 0.2 },
                { text: "Drive carefully", risk: "2% mortality", deathChance: 0.02, modifier: 0.05 }
            ]},
            { age: 18, prompt: "Life path decision", choices: [
                { text: "Chase your dreams", risk: "High variance", deathChance: 0.02, modifier: 0.3 },
                { text: "Take the safe path", risk: "Low variance", deathChance: 0.01, modifier: 0.1 },
                { text: "Travel the world", risk: "10% mortality", deathChance: 0.1, modifier: 0.25 }
            ]},
            { age: 25, prompt: "A risky opportunity", choices: [
                { text: "Take the leap", risk: "Medium risk", deathChance: 0.03, modifier: 0.35 },
                { text: "Stay comfortable", risk: "Safe", deathChance: 0.005, modifier: 0 }
            ]},
            { age: 30, prompt: "Health crossroads", choices: [
                { text: "Extreme sports hobby", risk: "15% mortality", deathChance: 0.15, modifier: 0.3 },
                { text: "Sedentary lifestyle", risk: "Slow decline", deathChance: 0.02, modifier: -0.2 },
                { text: "Balanced wellness", risk: "Low risk", deathChance: 0.01, modifier: 0.1 }
            ]},
            { age: 40, prompt: "Midlife reflection", choices: [
                { text: "Radical life change", risk: "12% mortality", deathChance: 0.12, modifier: 0.4 },
                { text: "Stay the course", risk: "3% mortality", deathChance: 0.03, modifier: 0 }
            ]},
            { age: 50, prompt: "Legacy consideration", choices: [
                { text: "One last adventure", risk: "20% mortality", deathChance: 0.2, modifier: 0.5 },
                { text: "Focus on family", risk: "Low risk", deathChance: 0.02, modifier: 0.15 }
            ]},
            { age: 65, prompt: "Retirement choice", choices: [
                { text: "Travel extensively", risk: "8% mortality", deathChance: 0.08, modifier: 0.2 },
                { text: "Quiet retirement", risk: "5% mortality", deathChance: 0.05, modifier: 0 }
            ]},
            { age: 80, prompt: "Final chapter", choices: [
                { text: "Live boldly to the end", risk: "25% mortality", deathChance: 0.25, modifier: 0.3 },
                { text: "Peaceful acceptance", risk: "15% mortality", deathChance: 0.15, modifier: 0.1 }
            ]}
        ];

        const QUANTUM_EVENTS = [
            "Cosmic ray strikes a neuron",
            "Radioactive decay nearby",
            "Quantum tunneling in synapse",
            "Photon takes alternate path",
            "Electron spin measurement",
            "Vacuum fluctuation",
            "Neutrino interaction",
            "Quantum decoherence event"
        ];

        const DEATH_CAUSES = [
            "accident", "illness", "natural causes", "misadventure",
            "cosmic ray damage", "quantum fluctuation cascade", "entropy"
        ];

        const TIMELINE_STATES = [
            "struggling but surviving",
            "finding their way",
            "building something meaningful",
            "experiencing joy",
            "facing hardship",
            "at peace",
            "thriving beyond expectation",
            "merely existing",
            "discovering purpose",
            "lost in regret"
        ];

        class Timeline {
            constructor(parent = null, splitReason = "birth", x = 0, y = 0) {
                this.id = Math.random().toString(36).substr(2, 9);
                this.parent = parent;
                this.children = [];
                this.splitReason = splitReason;
                this.splitAge = age;
                this.alive = true;
                this.deathAge = null;
                this.deathCause = null;
                this.wellness = parent ? parent.wellness : 0.5;
                this.x = x;
                this.y = y;
                this.targetX = x;
                this.targetY = y;
                this.state = "beginning their journey";
                this.decisions = parent ? [...parent.decisions] : [];
                this.glowIntensity = 1;
                this.consciousnessParticles = [];

                if (parent) {
                    parent.children.push(this);
                }
                allTimelines.push(this);
            }

            update(dt) {
                // Smooth position
                this.x += (this.targetX - this.x) * 0.1;
                this.y += (this.targetY - this.y) * 0.1;

                if (this.alive) {
                    // Random wellness drift
                    this.wellness += (Math.random() - 0.5) * 0.001;
                    this.wellness = Math.max(0, Math.min(1, this.wellness));

                    // Age-based mortality
                    if (age > 60) {
                        const deathRisk = 0.0001 * Math.pow(1.1, age - 60);
                        if (Math.random() < deathRisk * dt) {
                            this.die("natural causes");
                        }
                    }

                    // Update state based on wellness
                    if (Math.random() < 0.001) {
                        if (this.wellness > 0.7) {
                            this.state = TIMELINE_STATES[Math.floor(Math.random() * 3) + 4];
                        } else if (this.wellness < 0.3) {
                            this.state = TIMELINE_STATES[Math.floor(Math.random() * 3)];
                        } else {
                            this.state = TIMELINE_STATES[Math.floor(Math.random() * TIMELINE_STATES.length)];
                        }
                    }

                    // Consciousness particles
                    if (Math.random() < 0.05) {
                        this.consciousnessParticles.push({
                            x: 0, y: 0,
                            vx: (Math.random() - 0.5) * 2,
                            vy: (Math.random() - 0.5) * 2,
                            life: 1,
                            size: Math.random() * 3 + 1
                        });
                    }
                }

                // Update particles
                for (let i = this.consciousnessParticles.length - 1; i >= 0; i--) {
                    const p = this.consciousnessParticles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= 0.02;
                    if (p.life <= 0) {
                        this.consciousnessParticles.splice(i, 1);
                    }
                }

                // Glow pulse
                this.glowIntensity = 0.7 + Math.sin(time * 2 + this.id.charCodeAt(0)) * 0.3;
            }

            die(cause) {
                if (!this.alive) return;
                this.alive = false;
                this.deathAge = age;
                this.deathCause = cause;
                this.state = `passed away from ${cause}`;

                // Check if this was the focused timeline
                if (focusedTimeline === this) {
                    // Quantum immortality: consciousness continues in a surviving branch
                    const survivors = allTimelines.filter(t => t.alive);
                    if (survivors.length > 0) {
                        // Find closest surviving branch
                        focusedTimeline = survivors.reduce((best, t) =>
                            t.wellness > best.wellness ? t : best
                        );
                        showMessage("Your consciousness shifts to a surviving branch...");
                        updateTimelineInfo();
                    }
                }
            }

            split(reason) {
                if (!this.alive) return null;

                // Create two new branches
                const angle1 = -Math.PI / 6;
                const angle2 = Math.PI / 6;
                const spread = 50 + allTimelines.length * 2;

                const branch1 = new Timeline(
                    this,
                    reason,
                    this.targetX + Math.cos(angle1) * spread,
                    this.targetY + Math.sin(angle1) * spread + 80
                );

                const branch2 = new Timeline(
                    this,
                    reason,
                    this.targetX + Math.cos(angle2) * spread,
                    this.targetY + Math.sin(angle2) * spread + 80
                );

                // Slightly different wellness in each branch
                branch1.wellness += (Math.random() - 0.5) * 0.1;
                branch2.wellness += (Math.random() - 0.5) * 0.1;

                return [branch1, branch2];
            }
        }

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }

        function init() {
            resize();
            window.addEventListener('resize', resize);

            // Create root timeline
            rootTimeline = new Timeline(null, "birth", width / 2, 100);
            focusedTimeline = rootTimeline;

            // Set up controls
            setupControls();

            // Start loop
            requestAnimationFrame(update);
        }

        function setupControls() {
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                targetZoom = Math.max(0.1, Math.min(3, targetZoom * zoomFactor));
            });

            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
            });

            canvas.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    targetPanX += (e.clientX - dragStartX) / zoom;
                    targetPanY += (e.clientY - dragStartY) / zoom;
                    dragStartX = e.clientX;
                    dragStartY = e.clientY;
                }
            });

            canvas.addEventListener('mouseup', () => isDragging = false);
            canvas.addEventListener('mouseleave', () => isDragging = false);

            document.getElementById('btn-zoom-out').onclick = () => targetZoom *= 0.7;
            document.getElementById('btn-zoom-in').onclick = () => targetZoom *= 1.4;
            document.getElementById('btn-recenter').onclick = recenter;
            document.getElementById('btn-pause').onclick = togglePause;
            document.getElementById('btn-reset').onclick = resetLife;
        }

        function recenter() {
            if (focusedTimeline) {
                targetPanX = width / 2 / zoom - focusedTimeline.x;
                targetPanY = height / 2 / zoom - focusedTimeline.y;
            }
        }

        function togglePause() {
            paused = !paused;
            document.getElementById('btn-pause').textContent = paused ? 'Resume Time' : 'Pause Time';
        }

        function resetLife() {
            allTimelines = [];
            rootTimeline = new Timeline(null, "birth", width / 2, 100);
            focusedTimeline = rootTimeline;
            age = 0;
            time = 0;
            eventCount = 0;
            nextEventTimer = 0;
            nextChoiceTimer = 0;
            currentChoice = null;
            document.getElementById('choices').style.display = 'none';
            targetZoom = 1;
            targetPanX = 0;
            targetPanY = 0;
            updateTimelineInfo();
        }

        function showMessage(text) {
            const msg = document.getElementById('message');
            msg.textContent = text;
            msg.style.opacity = 1;
            setTimeout(() => msg.style.opacity = 0, 3000);
        }

        function triggerQuantumEvent() {
            const aliveTimelines = allTimelines.filter(t => t.alive);
            if (aliveTimelines.length === 0) return;

            // Pick a random alive timeline to split
            const timeline = aliveTimelines[Math.floor(Math.random() * aliveTimelines.length)];
            const reason = QUANTUM_EVENTS[Math.floor(Math.random() * QUANTUM_EVENTS.length)];

            timeline.split(reason);
            eventCount++;

            // Small chance one branch dies from quantum event
            if (Math.random() < 0.02) {
                const children = timeline.children.filter(c => c.alive);
                if (children.length > 0) {
                    const victim = children[Math.floor(Math.random() * children.length)];
                    victim.die("quantum fluctuation cascade");
                }
            }
        }

        function showChoice(eventData) {
            currentChoice = eventData;
            const choicesDiv = document.getElementById('choices');
            const promptDiv = document.getElementById('choice-prompt');
            const buttonsDiv = document.getElementById('choice-buttons');

            promptDiv.textContent = `Age ${eventData.age}: ${eventData.prompt}`;
            buttonsDiv.innerHTML = '';

            eventData.choices.forEach((choice, i) => {
                const btn = document.createElement('button');
                btn.className = 'choice-btn';
                btn.innerHTML = `${choice.text}<span class="risk">${choice.risk}</span>`;
                btn.onclick = () => makeChoice(i);
                buttonsDiv.appendChild(btn);
            });

            choicesDiv.style.display = 'block';
        }

        function makeChoice(choiceIndex) {
            if (!currentChoice) return;

            const choice = currentChoice.choices[choiceIndex];
            document.getElementById('choices').style.display = 'none';

            // Split all alive timelines based on choice
            const aliveTimelines = allTimelines.filter(t => t.alive);

            aliveTimelines.forEach(timeline => {
                // Each timeline makes the same choice (many-worlds: all choices happen)
                currentChoice.choices.forEach((c, i) => {
                    if (i === 0) {
                        // Modify existing timeline
                        timeline.wellness += c.modifier;
                        timeline.wellness = Math.max(0, Math.min(1, timeline.wellness));
                        timeline.decisions.push(c.text);
                        timeline.state = `chose to ${c.text.toLowerCase()}`;

                        if (Math.random() < c.deathChance) {
                            timeline.die("the consequences of their choice");
                        }
                    } else {
                        // Create new branch for this choice
                        const branch = new Timeline(
                            timeline.parent || timeline,
                            `chose: ${c.text}`,
                            timeline.x + (i - 0.5) * 100,
                            timeline.y + 50
                        );
                        branch.wellness = timeline.wellness + c.modifier;
                        branch.wellness = Math.max(0, Math.min(1, branch.wellness));
                        branch.decisions = [...timeline.decisions, c.text];
                        branch.state = `chose to ${c.text.toLowerCase()}`;

                        if (Math.random() < c.deathChance) {
                            branch.die("the consequences of their choice");
                        }
                    }
                });
            });

            currentChoice = null;
            eventCount++;

            // Update focus to best surviving timeline
            const survivors = allTimelines.filter(t => t.alive);
            if (survivors.length > 0 && !focusedTimeline.alive) {
                focusedTimeline = survivors.reduce((best, t) =>
                    t.wellness > best.wellness ? t : best
                );
            }

            updateTimelineInfo();
        }

        function updateTimelineInfo() {
            const desc = document.getElementById('timeline-desc');
            if (focusedTimeline) {
                const decisions = focusedTimeline.decisions.slice(-3).join(', ') || 'none yet';
                desc.innerHTML = `
                    <strong>Status:</strong> ${focusedTimeline.alive ? 'Alive' : 'Deceased'}<br>
                    <strong>Wellness:</strong> ${Math.round(focusedTimeline.wellness * 100)}%<br>
                    <strong>State:</strong> ${focusedTimeline.state}<br>
                    <strong>Recent choices:</strong> ${decisions}<br>
                    <strong>Split from:</strong> ${focusedTimeline.splitReason}
                `;
            }
        }

        function updateStats() {
            const alive = allTimelines.filter(t => t.alive);
            const dead = allTimelines.filter(t => !t.alive);
            const thriving = alive.filter(t => t.wellness > 0.7);
            const suffering = alive.filter(t => t.wellness < 0.3);

            document.getElementById('total-branches').textContent = allTimelines.length;
            document.getElementById('alive-count').textContent = alive.length;
            document.getElementById('dead-count').textContent = dead.length;
            document.getElementById('thriving-count').textContent = thriving.length;
            document.getElementById('suffering-count').textContent = suffering.length;
            document.getElementById('event-count').textContent = eventCount;
            document.getElementById('age').textContent = Math.floor(age);

            // Update meters
            const coherence = Math.max(0, 1 - allTimelines.length / 100);
            document.getElementById('coherence-fill').style.width = `${coherence * 100}%`;
            document.getElementById('event-fill').style.width = `${(nextEventTimer % 1) * 100}%`;
        }

        function update(timestamp) {
            const dt = paused ? 0 : 0.016;
            time += dt;

            if (!paused) {
                age += dt * 0.5; // Age 0.5 years per second

                // Quantum events
                nextEventTimer += dt * 0.3;
                if (nextEventTimer >= 1) {
                    nextEventTimer = 0;
                    triggerQuantumEvent();
                }

                // Life choice events
                const nextEvent = LIFE_EVENTS.find(e => e.age > Math.floor(age - dt * 0.5) && e.age <= Math.floor(age));
                if (nextEvent && !currentChoice) {
                    showChoice(nextEvent);
                }

                // Update all timelines
                allTimelines.forEach(t => t.update(dt));

                // Reposition timelines for better visualization
                repositionTimelines();
            }

            // Smooth zoom and pan
            zoom += (targetZoom - zoom) * 0.1;
            panX += (targetPanX - panX) * 0.1;
            panY += (targetPanY - panY) * 0.1;

            render();
            updateStats();
            updateTimelineInfo();

            requestAnimationFrame(update);
        }

        function repositionTimelines() {
            // Arrange timelines in a tree structure
            const levels = {};
            allTimelines.forEach(t => {
                const level = getDepth(t);
                if (!levels[level]) levels[level] = [];
                levels[level].push(t);
            });

            Object.keys(levels).forEach(level => {
                const timelines = levels[level];
                const levelY = 100 + parseInt(level) * 120;
                const totalWidth = timelines.length * 80;
                const startX = width / 2 - totalWidth / 2;

                timelines.forEach((t, i) => {
                    t.targetY = levelY;
                    if (t.parent) {
                        // Position relative to parent
                        const siblingIndex = t.parent.children.indexOf(t);
                        const siblingCount = t.parent.children.length;
                        const spread = 60 * siblingCount;
                        t.targetX = t.parent.targetX + (siblingIndex - (siblingCount - 1) / 2) * spread / siblingCount;
                    } else {
                        t.targetX = startX + i * 80 + 40;
                    }
                });
            });
        }

        function getDepth(timeline) {
            let depth = 0;
            let current = timeline;
            while (current.parent) {
                depth++;
                current = current.parent;
            }
            return depth;
        }

        function render() {
            // Clear
            ctx.fillStyle = '#000510';
            ctx.fillRect(0, 0, width, height);

            // Background stars
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            for (let i = 0; i < 200; i++) {
                const x = (i * 173 + time * 10) % width;
                const y = (i * 259) % height;
                const size = (Math.sin(i + time) + 1) * 0.5 + 0.5;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            // Apply zoom and pan
            ctx.save();
            ctx.translate(width / 2, height / 2);
            ctx.scale(zoom, zoom);
            ctx.translate(-width / 2 + panX, -height / 2 + panY);

            // Draw connections first
            allTimelines.forEach(timeline => {
                if (timeline.parent) {
                    drawConnection(timeline.parent, timeline);
                }
            });

            // Draw timelines
            allTimelines.forEach(timeline => {
                drawTimeline(timeline);
            });

            ctx.restore();
        }

        function drawConnection(parent, child) {
            const gradient = ctx.createLinearGradient(parent.x, parent.y, child.x, child.y);

            if (child.alive) {
                const hue = 200 + child.wellness * 60;
                gradient.addColorStop(0, `hsla(${hue}, 80%, 60%, 0.6)`);
                gradient.addColorStop(1, `hsla(${hue}, 80%, 60%, 0.3)`);
            } else {
                gradient.addColorStop(0, 'rgba(100, 50, 50, 0.4)');
                gradient.addColorStop(1, 'rgba(50, 30, 30, 0.2)');
            }

            ctx.strokeStyle = gradient;
            ctx.lineWidth = child.alive ? 2 : 1;
            ctx.beginPath();
            ctx.moveTo(parent.x, parent.y);

            // Curved connection
            const midY = (parent.y + child.y) / 2;
            ctx.bezierCurveTo(
                parent.x, midY,
                child.x, midY,
                child.x, child.y
            );
            ctx.stroke();

            // Flowing particles along connection
            if (child.alive && focusedTimeline === child) {
                const particlePos = (time * 0.5) % 1;
                const px = parent.x + (child.x - parent.x) * particlePos;
                const py = parent.y + (child.y - parent.y) * particlePos;

                ctx.fillStyle = 'rgba(255, 255, 200, 0.8)';
                ctx.beginPath();
                ctx.arc(px, py, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawTimeline(timeline) {
            const isFocused = timeline === focusedTimeline;
            const size = isFocused ? 20 : 12;

            // Outer glow
            if (timeline.alive) {
                const glowSize = size * 2 * timeline.glowIntensity;
                const gradient = ctx.createRadialGradient(
                    timeline.x, timeline.y, 0,
                    timeline.x, timeline.y, glowSize
                );

                const hue = 200 + timeline.wellness * 60;
                const saturation = 70 + timeline.wellness * 30;
                const lightness = 50 + timeline.wellness * 20;

                gradient.addColorStop(0, `hsla(${hue}, ${saturation}%, ${lightness}%, 0.8)`);
                gradient.addColorStop(0.5, `hsla(${hue}, ${saturation}%, ${lightness}%, 0.3)`);
                gradient.addColorStop(1, 'transparent');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(timeline.x, timeline.y, glowSize, 0, Math.PI * 2);
                ctx.fill();
            }

            // Core
            if (timeline.alive) {
                const hue = 200 + timeline.wellness * 60;
                ctx.fillStyle = `hsl(${hue}, 80%, 70%)`;
            } else {
                ctx.fillStyle = 'rgba(80, 40, 40, 0.8)';
            }

            ctx.beginPath();
            ctx.arc(timeline.x, timeline.y, size, 0, Math.PI * 2);
            ctx.fill();

            // Inner bright core
            if (timeline.alive) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.arc(timeline.x, timeline.y, size * 0.4, 0, Math.PI * 2);
                ctx.fill();
            }

            // Focus indicator
            if (isFocused) {
                ctx.strokeStyle = 'rgba(255, 220, 100, 0.8)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(timeline.x, timeline.y, size + 8, 0, Math.PI * 2);
                ctx.stroke();

                // "YOU ARE HERE" label
                ctx.fillStyle = 'rgba(255, 220, 100, 0.9)';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('◆ YOU', timeline.x, timeline.y - size - 15);
            }

            // Death marker
            if (!timeline.alive) {
                ctx.strokeStyle = 'rgba(255, 100, 100, 0.6)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(timeline.x - size, timeline.y - size);
                ctx.lineTo(timeline.x + size, timeline.y + size);
                ctx.moveTo(timeline.x + size, timeline.y - size);
                ctx.lineTo(timeline.x - size, timeline.y + size);
                ctx.stroke();
            }

            // Consciousness particles
            timeline.consciousnessParticles.forEach(p => {
                ctx.fillStyle = `rgba(255, 255, 200, ${p.life})`;
                ctx.beginPath();
                ctx.arc(timeline.x + p.x, timeline.y + p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // Start
        init();
    </script>
</body>
</html>
