<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Collision Arena</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a0a2e 50%, #0a0a1a 100%);
            color: #e0e0e0;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            background: linear-gradient(90deg, rgba(30, 10, 60, 0.9), rgba(10, 10, 40, 0.9));
            padding: 15px 20px;
            border-bottom: 2px solid #6a0dad;
            box-shadow: 0 4px 20px rgba(106, 13, 173, 0.3);
        }

        h1 {
            font-size: 28px;
            background: linear-gradient(90deg, #ff00ff, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(255, 0, 255, 0.5);
        }

        .subtitle {
            font-size: 12px;
            color: #aaa;
            margin-top: 5px;
        }

        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, rgba(20, 10, 40, 0.8), rgba(5, 5, 15, 0.9));
        }

        #collisionCanvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: crosshair;
        }

        .side-panel {
            width: 320px;
            background: linear-gradient(180deg, rgba(20, 10, 40, 0.95), rgba(10, 5, 20, 0.95));
            border-left: 2px solid #6a0dad;
            padding: 20px;
            overflow-y: auto;
            box-shadow: -4px 0 20px rgba(0, 0, 0, 0.5);
        }

        .panel-section {
            background: rgba(30, 15, 50, 0.6);
            border: 1px solid rgba(106, 13, 173, 0.4);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .panel-section h2 {
            font-size: 16px;
            margin-bottom: 12px;
            color: #ff00ff;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid rgba(255, 0, 255, 0.3);
            padding-bottom: 8px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            font-size: 12px;
            color: #bbb;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            background: linear-gradient(90deg, #4a0e4e, #ff00ff);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #ff00ff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.8);
            transition: all 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 15px rgba(255, 0, 255, 1);
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #ff00ff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.8);
            border: none;
            transition: all 0.2s;
        }

        .value-display {
            display: inline-block;
            background: rgba(255, 0, 255, 0.2);
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: bold;
            color: #ff00ff;
            margin-left: 10px;
        }

        button {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #6a0dad, #ff00ff);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(255, 0, 255, 0.3);
            margin-bottom: 10px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 0, 255, 0.5);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background: linear-gradient(135deg, #1a1a3e, #3a2a5e);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            font-size: 12px;
        }

        .stat-item {
            background: rgba(10, 5, 20, 0.5);
            padding: 8px;
            border-radius: 4px;
            border-left: 3px solid #00ffff;
        }

        .stat-label {
            color: #888;
            font-size: 10px;
            text-transform: uppercase;
        }

        .stat-value {
            color: #00ffff;
            font-size: 16px;
            font-weight: bold;
        }

        .particle-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .particle-item {
            background: rgba(20, 10, 40, 0.5);
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 6px;
            border-left: 4px solid;
            cursor: pointer;
            transition: all 0.2s;
        }

        .particle-item:hover {
            background: rgba(30, 15, 50, 0.7);
            transform: translateX(5px);
        }

        .particle-name {
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 4px;
        }

        .particle-props {
            font-size: 11px;
            color: #aaa;
        }

        .feynman-diagram {
            background: rgba(10, 5, 20, 0.7);
            border-radius: 8px;
            padding: 10px;
            height: 180px;
            position: relative;
            border: 1px solid rgba(106, 13, 173, 0.3);
        }

        #feynmanCanvas {
            width: 100%;
            height: 100%;
            border-radius: 4px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .checkbox-group input[type="checkbox"] {
            margin-right: 8px;
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .checkbox-group label {
            margin: 0;
            cursor: pointer;
            font-size: 13px;
        }

        .discovered-badge {
            display: inline-block;
            background: rgba(0, 255, 0, 0.2);
            color: #0f0;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 10px;
            margin-left: 8px;
        }

        .particle-info-panel {
            background: rgba(10, 5, 30, 0.9);
            border: 2px solid #ff00ff;
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
            display: none;
        }

        .particle-info-panel.active {
            display: block;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .info-title {
            font-size: 16px;
            font-weight: bold;
            color: #ff00ff;
            margin-bottom: 10px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 12px;
        }

        .info-label {
            color: #888;
        }

        .info-value {
            color: #0ff;
            font-weight: bold;
        }

        .decay-modes {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 0, 255, 0.3);
        }

        .decay-mode {
            background: rgba(255, 0, 255, 0.1);
            padding: 6px;
            border-radius: 4px;
            margin-bottom: 4px;
            font-size: 11px;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(10, 5, 20, 0.5);
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #6a0dad, #ff00ff);
            border-radius: 4px;
        }

        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
            }

            .side-panel {
                width: 100%;
                max-height: 40vh;
                border-left: none;
                border-top: 2px solid #6a0dad;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Particle Collision Arena</h1>
        <div class="subtitle">High-Energy Physics Simulation with Decay Products and Feynman Diagrams</div>
    </header>

    <div class="main-container">
        <div class="canvas-container">
            <canvas id="collisionCanvas"></canvas>
        </div>

        <div class="side-panel">
            <div class="panel-section">
                <h2>Controls</h2>
                <div class="control-group">
                    <label>
                        Collision Energy
                        <span class="value-display" id="energyValue">10.0 GeV</span>
                    </label>
                    <input type="range" id="energySlider" min="1" max="100" value="10" step="0.5">
                </div>

                <button id="collideBtn">Trigger Collision</button>

                <div class="checkbox-group">
                    <input type="checkbox" id="autoCollideCheck">
                    <label for="autoCollideCheck">Auto-Collide Mode</label>
                </div>

                <button class="secondary" id="resetBtn">Reset Detector</button>
            </div>

            <div class="panel-section">
                <h2>Statistics</h2>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-label">Collisions</div>
                        <div class="stat-value" id="collisionCount">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Discovered</div>
                        <div class="stat-value" id="discoveredCount">2/12</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Total Particles</div>
                        <div class="stat-value" id="particleCount">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Avg Energy</div>
                        <div class="stat-value" id="avgEnergy">0 GeV</div>
                    </div>
                </div>
            </div>

            <div class="panel-section">
                <h2>Feynman Diagram</h2>
                <div class="feynman-diagram">
                    <canvas id="feynmanCanvas"></canvas>
                </div>
            </div>

            <div class="panel-section">
                <h2>Particle Types</h2>
                <div class="particle-list" id="particleList"></div>
            </div>

            <div class="particle-info-panel" id="particleInfo"></div>
        </div>
    </div>

    <script>
        // Particle Physics Constants and Definitions
        const PARTICLE_TYPES = {
            electron: {
                name: 'Electron',
                symbol: 'e⁻',
                mass: 0.511,
                charge: -1,
                color: '#00ffff',
                discoveryThreshold: 0,
                decayModes: [],
                stable: true
            },
            positron: {
                name: 'Positron',
                symbol: 'e⁺',
                mass: 0.511,
                charge: 1,
                color: '#ff00ff',
                discoveryThreshold: 0,
                decayModes: [],
                stable: true,
                antiparticle: true
            },
            photon: {
                name: 'Photon',
                symbol: 'γ',
                mass: 0,
                charge: 0,
                color: '#ffff00',
                discoveryThreshold: 1,
                decayModes: [],
                stable: true
            },
            muon: {
                name: 'Muon',
                symbol: 'μ⁻',
                mass: 105.7,
                charge: -1,
                color: '#00ff00',
                discoveryThreshold: 10,
                decayModes: [
                    { particles: ['electron', 'neutrino', 'neutrino'], probability: 1.0 }
                ],
                lifetime: 2.2
            },
            antimuon: {
                name: 'Antimuon',
                symbol: 'μ⁺',
                mass: 105.7,
                charge: 1,
                color: '#90ff00',
                discoveryThreshold: 10,
                decayModes: [
                    { particles: ['positron', 'neutrino', 'neutrino'], probability: 1.0 }
                ],
                lifetime: 2.2,
                antiparticle: true
            },
            pion_plus: {
                name: 'Pion+',
                symbol: 'π⁺',
                mass: 139.6,
                charge: 1,
                color: '#ff6600',
                discoveryThreshold: 15,
                decayModes: [
                    { particles: ['antimuon', 'neutrino'], probability: 0.9999 }
                ],
                lifetime: 26.0
            },
            pion_minus: {
                name: 'Pion-',
                symbol: 'π⁻',
                mass: 139.6,
                charge: -1,
                color: '#ff3300',
                discoveryThreshold: 15,
                decayModes: [
                    { particles: ['muon', 'neutrino'], probability: 0.9999 }
                ],
                lifetime: 26.0
            },
            pion_zero: {
                name: 'Pion0',
                symbol: 'π⁰',
                mass: 135.0,
                charge: 0,
                color: '#ff9900',
                discoveryThreshold: 20,
                decayModes: [
                    { particles: ['photon', 'photon'], probability: 0.9885 }
                ],
                lifetime: 0.000084
            },
            kaon_plus: {
                name: 'Kaon+',
                symbol: 'K⁺',
                mass: 493.7,
                charge: 1,
                color: '#cc00ff',
                discoveryThreshold: 30,
                decayModes: [
                    { particles: ['antimuon', 'neutrino'], probability: 0.64 },
                    { particles: ['pion_plus', 'pion_zero'], probability: 0.21 }
                ],
                lifetime: 12.4
            },
            kaon_minus: {
                name: 'Kaon-',
                symbol: 'K⁻',
                mass: 493.7,
                charge: -1,
                color: '#9900ff',
                discoveryThreshold: 30,
                decayModes: [
                    { particles: ['muon', 'neutrino'], probability: 0.64 },
                    { particles: ['pion_minus', 'pion_zero'], probability: 0.21 }
                ],
                lifetime: 12.4
            },
            neutrino: {
                name: 'Neutrino',
                symbol: 'ν',
                mass: 0.001,
                charge: 0,
                color: '#ffffff',
                discoveryThreshold: 5,
                decayModes: [],
                stable: true
            },
            proton: {
                name: 'Proton',
                symbol: 'p',
                mass: 938.3,
                charge: 1,
                color: '#ff0000',
                discoveryThreshold: 0,
                decayModes: [],
                stable: true
            }
        };

        // Canvas Setup
        const canvas = document.getElementById('collisionCanvas');
        const ctx = canvas.getContext('2d');
        const feynmanCanvas = document.getElementById('feynmanCanvas');
        const feynmanCtx = feynmanCanvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            feynmanCanvas.width = feynmanCanvas.offsetWidth;
            feynmanCanvas.height = feynmanCanvas.offsetHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Game State
        const state = {
            particles: [],
            beams: [],
            trails: [],
            detectorRings: [],
            collisionCount: 0,
            totalCollisions: 0,
            discoveredParticles: new Set(['electron', 'positron']),
            energy: 10.0,
            autoCollide: false,
            timeSinceLastCollision: 0,
            lastCollision: null,
            particleCount: 0,
            totalEnergy: 0
        };

        // Load saved state
        function loadState() {
            const saved = localStorage.getItem('particleCollisionArena');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    state.discoveredParticles = new Set(data.discovered || ['electron', 'positron']);
                    state.totalCollisions = data.totalCollisions || 0;
                    state.collisionCount = data.totalCollisions || 0;
                } catch (e) {
                    console.error('Failed to load state:', e);
                }
            }
        }

        function saveState() {
            localStorage.setItem('particleCollisionArena', JSON.stringify({
                discovered: Array.from(state.discoveredParticles),
                totalCollisions: state.totalCollisions
            }));
        }

        // Particle Class
        class Particle {
            constructor(x, y, vx, vy, type, energy = 1) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.type = type;
                this.energy = energy;
                this.data = PARTICLE_TYPES[type];
                this.lifetime = this.data.lifetime || Infinity;
                this.age = 0;
                this.alpha = 1;
                this.size = Math.min(8, 3 + Math.log(energy + 1));
            }

            update(dt) {
                this.x += this.vx * dt * 100;
                this.y += this.vy * dt * 100;
                this.age += dt;

                // Decay check
                if (this.lifetime < Infinity) {
                    const decayProbability = dt / this.lifetime;
                    if (Math.random() < decayProbability) {
                        this.decay();
                        return false;
                    }
                }

                // Fade out over time
                if (this.age > 2) {
                    this.alpha = Math.max(0, 1 - (this.age - 2) / 3);
                }

                // Remove if off screen or faded
                if (this.alpha <= 0 || this.x < -50 || this.x > canvas.width + 50 ||
                    this.y < -50 || this.y > canvas.height + 50) {
                    return false;
                }

                return true;
            }

            decay() {
                if (!this.data.decayModes || this.data.decayModes.length === 0) return;

                const mode = this.selectDecayMode();
                if (!mode) return;

                const products = mode.particles;
                const numProducts = products.length;
                const energyPerProduct = this.energy / numProducts;

                for (let i = 0; i < numProducts; i++) {
                    const angle = (Math.PI * 2 * i / numProducts) + Math.random() * 0.5;
                    const speed = 2 + Math.random() * 2;
                    const productType = products[i];

                    if (PARTICLE_TYPES[productType]) {
                        const particle = new Particle(
                            this.x, this.y,
                            Math.cos(angle) * speed,
                            Math.sin(angle) * speed,
                            productType,
                            energyPerProduct
                        );
                        state.particles.push(particle);
                        discoverParticle(productType);
                    }
                }
            }

            selectDecayMode() {
                if (!this.data.decayModes || this.data.decayModes.length === 0) return null;

                const rand = Math.random();
                let cumulative = 0;

                for (const mode of this.data.decayModes) {
                    cumulative += mode.probability;
                    if (rand < cumulative) {
                        return mode;
                    }
                }

                return this.data.decayModes[0];
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;

                // Glow effect
                ctx.shadowBlur = 20;
                ctx.shadowColor = this.data.color;

                // Particle core
                ctx.fillStyle = this.data.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();

                // Inner glow
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size * 2);
                gradient.addColorStop(0, this.data.color + 'ff');
                gradient.addColorStop(0.5, this.data.color + '88');
                gradient.addColorStop(1, this.data.color + '00');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 2, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();

                // Add trail
                state.trails.push({
                    x: this.x,
                    y: this.y,
                    color: this.data.color,
                    alpha: this.alpha * 0.6,
                    size: this.size * 0.5,
                    life: 1
                });
            }
        }

        // Beam Class
        class Beam {
            constructor(fromLeft) {
                this.fromLeft = fromLeft;
                this.x = fromLeft ? 50 : canvas.width - 50;
                this.y = canvas.height / 2;
                this.targetX = canvas.width / 2;
                this.progress = 0;
                this.type = fromLeft ? 'electron' : 'positron';
                this.particles = [];

                for (let i = 0; i < 20; i++) {
                    this.particles.push({
                        offset: i * 15,
                        phase: Math.random() * Math.PI * 2
                    });
                }
            }

            update(dt) {
                this.progress += dt * 0.8;
                if (this.progress >= 1) {
                    return false;
                }
                return true;
            }

            draw() {
                const currentX = this.x + (this.targetX - this.x) * this.progress;
                const data = PARTICLE_TYPES[this.type];

                ctx.save();

                // Beam particles
                for (const p of this.particles) {
                    const x = this.fromLeft ?
                        this.x + p.offset + (currentX - this.x - p.offset) * this.progress :
                        this.x - p.offset - (this.x - p.offset - currentX) * this.progress;
                    const wobble = Math.sin(p.phase + this.progress * 10) * 3;

                    ctx.shadowBlur = 15;
                    ctx.shadowColor = data.color;
                    ctx.fillStyle = data.color;
                    ctx.globalAlpha = 0.8;
                    ctx.beginPath();
                    ctx.arc(x, this.y + wobble, 4, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }
        }

        // Collision Functions
        function triggerCollision() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            // Create beams
            state.beams.push(new Beam(true));
            state.beams.push(new Beam(false));

            // After delay, create collision
            setTimeout(() => {
                createCollision(centerX, centerY, state.energy);
            }, 1250);
        }

        function createCollision(x, y, energy) {
            state.collisionCount++;
            state.totalCollisions++;
            state.totalEnergy += energy;

            // Create detector ring pulse
            for (let i = 0; i < 5; i++) {
                state.detectorRings.push({
                    x, y,
                    radius: 0,
                    maxRadius: 100 + i * 30,
                    alpha: 1,
                    speed: 2 + i * 0.5
                });
            }

            // Determine products based on energy
            const products = determineCollisionProducts(energy);

            // Create product particles
            const numParticles = products.length;
            const energyPerParticle = energy / numParticles;

            for (let i = 0; i < numParticles; i++) {
                const angle = (Math.PI * 2 * i / numParticles) + (Math.random() - 0.5) * 0.3;
                const speed = 3 + Math.random() * 2;
                const particle = new Particle(
                    x, y,
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    products[i],
                    energyPerParticle
                );
                state.particles.push(particle);
                discoverParticle(products[i]);
            }

            // Store for Feynman diagram
            state.lastCollision = {
                incoming: ['electron', 'positron'],
                outgoing: products,
                energy: energy
            };

            drawFeynmanDiagram();
            updateStats();
            saveState();
        }

        function determineCollisionProducts(energy) {
            const products = [];

            if (energy < 5) {
                // Low energy: just photons
                products.push('photon', 'photon');
            } else if (energy < 15) {
                // Medium energy: muon pair
                products.push('muon', 'antimuon');
                if (Math.random() < 0.3) products.push('photon');
            } else if (energy < 30) {
                // Higher energy: pions
                products.push('pion_plus', 'pion_minus');
                if (Math.random() < 0.5) products.push('pion_zero');
                if (Math.random() < 0.3) products.push('photon');
            } else {
                // Very high energy: kaons and complex products
                if (Math.random() < 0.6) {
                    products.push('kaon_plus', 'kaon_minus');
                } else {
                    products.push('pion_plus', 'pion_minus', 'pion_zero');
                }

                // Add additional particles
                const extraCount = Math.floor(energy / 20);
                for (let i = 0; i < Math.min(extraCount, 4); i++) {
                    const rand = Math.random();
                    if (rand < 0.3) products.push('photon');
                    else if (rand < 0.5) products.push('pion_zero');
                    else if (rand < 0.7) products.push('muon');
                    else products.push('neutrino');
                }
            }

            return products;
        }

        function discoverParticle(type) {
            const data = PARTICLE_TYPES[type];
            if (!data) return;

            if (state.energy >= data.discoveryThreshold && !state.discoveredParticles.has(type)) {
                state.discoveredParticles.add(type);
                saveState();
                updateParticleList();
            }
        }

        // Feynman Diagram
        function drawFeynmanDiagram() {
            if (!state.lastCollision) return;

            const w = feynmanCanvas.width;
            const h = feynmanCanvas.height;
            const centerX = w / 2;
            const centerY = h / 2;

            feynmanCtx.clearRect(0, 0, w, h);

            feynmanCtx.save();
            feynmanCtx.strokeStyle = '#888';
            feynmanCtx.lineWidth = 2;
            feynmanCtx.shadowBlur = 5;

            // Incoming particles (left side)
            const incomingY1 = centerY - 20;
            const incomingY2 = centerY + 20;

            // Electron
            feynmanCtx.shadowColor = PARTICLE_TYPES['electron'].color;
            feynmanCtx.strokeStyle = PARTICLE_TYPES['electron'].color;
            feynmanCtx.beginPath();
            feynmanCtx.moveTo(10, incomingY1);
            feynmanCtx.lineTo(centerX, centerY);
            feynmanCtx.stroke();

            // Positron
            feynmanCtx.shadowColor = PARTICLE_TYPES['positron'].color;
            feynmanCtx.strokeStyle = PARTICLE_TYPES['positron'].color;
            feynmanCtx.beginPath();
            feynmanCtx.moveTo(10, incomingY2);
            feynmanCtx.lineTo(centerX, centerY);
            feynmanCtx.stroke();

            // Vertex
            feynmanCtx.shadowBlur = 10;
            feynmanCtx.shadowColor = '#fff';
            feynmanCtx.fillStyle = '#fff';
            feynmanCtx.beginPath();
            feynmanCtx.arc(centerX, centerY, 4, 0, Math.PI * 2);
            feynmanCtx.fill();

            // Outgoing particles
            const outgoing = state.lastCollision.outgoing;
            const numOut = outgoing.length;

            for (let i = 0; i < numOut; i++) {
                const type = outgoing[i];
                const data = PARTICLE_TYPES[type];
                if (!data) continue;

                const angle = -Math.PI / 4 + (Math.PI / 2) * (i / Math.max(1, numOut - 1));
                const endX = centerX + Math.cos(angle) * (w / 2 - 15);
                const endY = centerY + Math.sin(angle) * (h / 2 - 15);

                feynmanCtx.strokeStyle = data.color;
                feynmanCtx.shadowColor = data.color;
                feynmanCtx.shadowBlur = 5;

                if (type === 'photon') {
                    // Wavy line for photons
                    drawWavyLine(feynmanCtx, centerX, centerY, endX, endY, 5, 3);
                } else {
                    // Straight line for matter
                    feynmanCtx.beginPath();
                    feynmanCtx.moveTo(centerX, centerY);
                    feynmanCtx.lineTo(endX, endY);
                    feynmanCtx.stroke();
                }

                // Arrow
                const arrowSize = 6;
                const arrowAngle = Math.atan2(endY - centerY, endX - centerX);
                feynmanCtx.fillStyle = data.color;
                feynmanCtx.beginPath();
                feynmanCtx.moveTo(endX, endY);
                feynmanCtx.lineTo(
                    endX - arrowSize * Math.cos(arrowAngle - 0.3),
                    endY - arrowSize * Math.sin(arrowAngle - 0.3)
                );
                feynmanCtx.lineTo(
                    endX - arrowSize * Math.cos(arrowAngle + 0.3),
                    endY - arrowSize * Math.sin(arrowAngle + 0.3)
                );
                feynmanCtx.closePath();
                feynmanCtx.fill();
            }

            feynmanCtx.restore();

            // Label
            feynmanCtx.fillStyle = '#888';
            feynmanCtx.font = '10px monospace';
            feynmanCtx.textAlign = 'center';
            feynmanCtx.fillText(`${state.lastCollision.energy.toFixed(1)} GeV`, centerX, h - 5);
        }

        function drawWavyLine(ctx, x1, y1, x2, y2, amplitude, wavelength) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);
            const numWaves = dist / wavelength;

            ctx.beginPath();
            ctx.moveTo(x1, y1);

            for (let i = 0; i <= numWaves * 10; i++) {
                const t = i / (numWaves * 10);
                const baseX = x1 + dx * t;
                const baseY = y1 + dy * t;
                const offset = Math.sin(t * numWaves * Math.PI * 2) * amplitude;
                const offsetX = baseX - Math.sin(angle) * offset;
                const offsetY = baseY + Math.cos(angle) * offset;
                ctx.lineTo(offsetX, offsetY);
            }

            ctx.stroke();
        }

        // Detector Rings
        function updateDetectorRings(dt) {
            state.detectorRings = state.detectorRings.filter(ring => {
                ring.radius += ring.speed * dt * 100;
                ring.alpha = 1 - (ring.radius / ring.maxRadius);
                return ring.radius < ring.maxRadius;
            });
        }

        function drawDetectorRings() {
            state.detectorRings.forEach(ring => {
                ctx.save();
                ctx.globalAlpha = ring.alpha * 0.5;
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 2;
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#00ffff';
                ctx.beginPath();
                ctx.arc(ring.x, ring.y, ring.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            });
        }

        // Trails
        function updateTrails(dt) {
            state.trails = state.trails.filter(trail => {
                trail.life -= dt;
                return trail.life > 0;
            });
        }

        function drawTrails() {
            state.trails.forEach(trail => {
                ctx.save();
                ctx.globalAlpha = trail.alpha * trail.life;
                ctx.shadowBlur = 10;
                ctx.shadowColor = trail.color;
                ctx.fillStyle = trail.color;
                ctx.beginPath();
                ctx.arc(trail.x, trail.y, trail.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
        }

        // UI Functions
        function updateParticleList() {
            const listEl = document.getElementById('particleList');
            listEl.innerHTML = '';

            for (const [key, data] of Object.entries(PARTICLE_TYPES)) {
                const discovered = state.discoveredParticles.has(key);
                if (!discovered && state.energy < data.discoveryThreshold) continue;

                const item = document.createElement('div');
                item.className = 'particle-item';
                item.style.borderLeftColor = data.color;

                const name = document.createElement('div');
                name.className = 'particle-name';
                name.style.color = data.color;
                name.textContent = `${data.symbol} ${data.name}`;
                if (discovered) {
                    const badge = document.createElement('span');
                    badge.className = 'discovered-badge';
                    badge.textContent = 'DISCOVERED';
                    name.appendChild(badge);
                }
                item.appendChild(name);

                if (discovered) {
                    const props = document.createElement('div');
                    props.className = 'particle-props';
                    props.textContent = `Mass: ${data.mass} MeV/c² | Charge: ${data.charge > 0 ? '+' : ''}${data.charge}`;
                    item.appendChild(props);

                    item.addEventListener('click', () => showParticleInfo(key));
                }

                listEl.appendChild(item);
            }
        }

        function showParticleInfo(type) {
            const data = PARTICLE_TYPES[type];
            const panel = document.getElementById('particleInfo');

            let html = `<div class="info-title">${data.symbol} ${data.name}</div>`;
            html += `<div class="info-row"><span class="info-label">Mass:</span><span class="info-value">${data.mass} MeV/c²</span></div>`;
            html += `<div class="info-row"><span class="info-label">Charge:</span><span class="info-value">${data.charge > 0 ? '+' : ''}${data.charge}e</span></div>`;
            html += `<div class="info-row"><span class="info-label">Stability:</span><span class="info-value">${data.stable ? 'Stable' : 'Unstable'}</span></div>`;

            if (data.lifetime && data.lifetime < Infinity) {
                html += `<div class="info-row"><span class="info-label">Lifetime:</span><span class="info-value">${data.lifetime} ns</span></div>`;
            }

            if (data.decayModes && data.decayModes.length > 0) {
                html += `<div class="decay-modes"><strong>Decay Modes:</strong>`;
                data.decayModes.forEach(mode => {
                    const products = mode.particles.map(p => PARTICLE_TYPES[p]?.symbol || p).join(' + ');
                    html += `<div class="decay-mode">${products} (${(mode.probability * 100).toFixed(1)}%)</div>`;
                });
                html += `</div>`;
            }

            panel.innerHTML = html;
            panel.classList.add('active');
        }

        function updateStats() {
            document.getElementById('collisionCount').textContent = state.totalCollisions;
            document.getElementById('discoveredCount').textContent =
                `${state.discoveredParticles.size}/${Object.keys(PARTICLE_TYPES).length}`;
            document.getElementById('particleCount').textContent = state.particles.length;

            const avgEnergy = state.totalCollisions > 0 ?
                (state.totalEnergy / state.totalCollisions).toFixed(1) : '0.0';
            document.getElementById('avgEnergy').textContent = `${avgEnergy} GeV`;
        }

        // Main Loop
        let lastTime = performance.now();

        function gameLoop(currentTime) {
            const dt = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;

            // Update
            state.particles = state.particles.filter(p => p.update(dt));
            state.beams = state.beams.filter(b => b.update(dt));
            updateDetectorRings(dt);
            updateTrails(dt);

            // Auto-collide
            if (state.autoCollide) {
                state.timeSinceLastCollision += dt;
                if (state.timeSinceLastCollision > 3) {
                    state.timeSinceLastCollision = 0;
                    triggerCollision();
                }
            }

            // Draw
            ctx.fillStyle = 'rgba(10, 10, 30, 0.2)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawTrails();
            drawDetectorRings();
            state.beams.forEach(b => b.draw());
            state.particles.forEach(p => p.draw());

            // Draw detector
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            ctx.save();
            ctx.strokeStyle = 'rgba(100, 50, 200, 0.3)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.arc(centerX, centerY, 150, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(centerX, centerY, 200, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();

            // Draw beamlines
            ctx.save();
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.2)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(canvas.width, centerY);
            ctx.stroke();
            ctx.restore();

            updateStats();
            requestAnimationFrame(gameLoop);
        }

        // Event Listeners
        document.getElementById('energySlider').addEventListener('input', (e) => {
            state.energy = parseFloat(e.target.value);
            document.getElementById('energyValue').textContent = `${state.energy.toFixed(1)} GeV`;
            updateParticleList();
        });

        document.getElementById('collideBtn').addEventListener('click', () => {
            triggerCollision();
        });

        document.getElementById('autoCollideCheck').addEventListener('change', (e) => {
            state.autoCollide = e.target.checked;
            state.timeSinceLastCollision = 0;
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            state.particles = [];
            state.beams = [];
            state.trails = [];
            state.detectorRings = [];
            feynmanCtx.clearRect(0, 0, feynmanCanvas.width, feynmanCanvas.height);
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === ' ' || e.key === 'Enter') {
                e.preventDefault();
                triggerCollision();
            } else if (e.key === 'a' || e.key === 'A') {
                const checkbox = document.getElementById('autoCollideCheck');
                checkbox.checked = !checkbox.checked;
                state.autoCollide = checkbox.checked;
                state.timeSinceLastCollision = 0;
            } else if (e.key === 'r' || e.key === 'R') {
                state.particles = [];
                state.beams = [];
                state.trails = [];
                state.detectorRings = [];
            }
        });

        // Initialize
        loadState();
        updateParticleList();
        updateStats();
        gameLoop(performance.now());
    </script>
</body>
</html>
