<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Verlet Physics Ragdoll</title>
    <meta name="description" content="Interactive ragdoll physics simulation using Verlet integration.">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #eee;
            user-select: none;
        }
        canvas {
            display: block;
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 8px;
            pointer-events: auto;
        }
        h1 {
            margin: 0 0 10px 0;
            font-size: 18px;
            color: #4ecdc4;
        }
        p {
            margin: 5px 0;
            font-size: 14px;
            color: #aaa;
        }
        .key {
            display: inline-block;
            background: #333;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            border: 1px solid #555;
        }
        button {
            background: #4ecdc4;
            color: #000;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 10px;
            width: 100%;
        }
        button:hover {
            background: #3dbdb4;
        }
    </style>
</head>
<body>
    <div id="controls">
        <h1>Verlet Ragdoll Physics</h1>
        <p>Drag points to throw the ragdoll.</p>
        <p>Right-click to tear constraints.</p>
        <p><span class="key">R</span> to Reset</p>
        <p><span class="key">G</span> to Toggle Gravity</p>
        <button id="reset-btn">Reset Simulation</button>
    </div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let width, height;
        
        // Physics Config
        const CONFIG = {
            gravity: 0.5,
            friction: 0.99,
            groundFriction: 0.9,
            stiffness: 1.0, // How rigid the constraints are (iterations)
            iterations: 5,
            bounce: 0.7
        };

        // State
        let points = [];
        let constraints = [];
        let draggedPoint = null;
        let gravityEnabled = true;

        // --- Classes ---

        class Point {
            constructor(x, y, pinned = false) {
                this.x = x;
                this.y = y;
                this.oldx = x; // Previous position for Verlet
                this.oldy = y;
                this.pinned = pinned;
                this.radius = 6;
                this.mass = 1;
            }

            update() {
                if (this.pinned) return;

                // Verlet Integration: pos = pos + (pos - oldPos) * friction + acceleration
                const vx = (this.x - this.oldx) * CONFIG.friction;
                const vy = (this.y - this.oldy) * CONFIG.friction;

                this.oldx = this.x;
                this.oldy = this.y;

                this.x += vx;
                this.y += vy;
                
                if (gravityEnabled) {
                    this.y += CONFIG.gravity;
                }
            }

            constrain() {
                if (this.pinned) return;

                // Wall collisions
                if (this.x > width - this.radius) {
                    this.x = width - this.radius;
                    this.oldx = this.x + (this.x - this.oldx) * CONFIG.bounce;
                } else if (this.x < this.radius) {
                    this.x = this.radius;
                    this.oldx = this.x + (this.x - this.oldx) * CONFIG.bounce;
                }

                if (this.y > height - this.radius) {
                    this.y = height - this.radius;
                    // Ground friction
                    const vx = (this.x - this.oldx) * CONFIG.groundFriction;
                    this.oldx = this.x - vx;
                    
                    this.oldy = this.y + (this.y - this.oldy) * CONFIG.bounce;
                } else if (this.y < this.radius) {
                    this.y = this.radius;
                    this.oldy = this.y + (this.y - this.oldy) * CONFIG.bounce;
                }
            }
            
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.pinned ? '#ff4444' : '#fff';
                ctx.fill();
            }
        }

        class Constraint {
            constructor(p1, p2, length = null, visible = true, width = 2) {
                this.p1 = p1;
                this.p2 = p2;
                // If length not provided, calculate current distance
                this.length = length || Math.hypot(p1.x - p2.x, p1.y - p2.y);
                this.visible = visible;
                this.width = width;
            }

            resolve() {
                const dx = this.p2.x - this.p1.x;
                const dy = this.p2.y - this.p1.y;
                const dist = Math.hypot(dx, dy);
                
                if (dist === 0) return; // Avoid division by zero

                const diff = (this.length - dist) / dist;
                
                // Move points apart/together to satisfy constraint
                // Inverse mass weighting could go here, but simple 0.5 split works for equal mass
                const offsetX = dx * diff * 0.5;
                const offsetY = dy * diff * 0.5;

                if (!this.p1.pinned) {
                    this.p1.x -= offsetX;
                    this.p1.y -= offsetY;
                }
                if (!this.p2.pinned) {
                    this.p2.x += offsetX;
                    this.p2.y += offsetY;
                }
            }

            draw() {
                if (!this.visible) return;
                ctx.beginPath();
                ctx.moveTo(this.p1.x, this.p1.y);
                ctx.lineTo(this.p2.x, this.p2.y);
                ctx.strokeStyle = '#4ecdc4';
                ctx.lineWidth = this.width;
                ctx.stroke();
            }
        }

        // --- Setup ---

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }
        window.addEventListener('resize', resize);
        resize();

        function createRagdoll(startX, startY) {
            // Head
            const head = new Point(startX, startY);
            // Neck/Shoulders
            const neck = new Point(startX, startY + 30);
            const shoulderL = new Point(startX - 20, startY + 30);
            const shoulderR = new Point(startX + 20, startY + 30);
            // Elbows
            const elbowL = new Point(startX - 20, startY + 60);
            const elbowR = new Point(startX + 20, startY + 60);
            // Hands
            const handL = new Point(startX - 20, startY + 90);
            const handR = new Point(startX + 20, startY + 90);
            // Hips
            const hips = new Point(startX, startY + 80);
            const hipL = new Point(startX - 15, startY + 80);
            const hipR = new Point(startX + 15, startY + 80);
            // Knees
            const kneeL = new Point(startX - 15, startY + 120);
            const kneeR = new Point(startX + 15, startY + 120);
            // Feet
            const footL = new Point(startX - 15, startY + 160);
            const footR = new Point(startX + 15, startY + 160);

            const newPoints = [head, neck, shoulderL, shoulderR, elbowL, elbowR, handL, handR, hips, hipL, hipR, kneeL, kneeR, footL, footR];
            points.push(...newPoints);

            // Structural Constraints (Bones)
            const newConstraints = [
                // Head & Torso
                new Constraint(head, neck),
                new Constraint(neck, hips),
                new Constraint(neck, shoulderL),
                new Constraint(neck, shoulderR),
                new Constraint(shoulderL, shoulderR), // Clavicle
                
                // Arms
                new Constraint(shoulderL, elbowL),
                new Constraint(elbowL, handL),
                new Constraint(shoulderR, elbowR),
                new Constraint(elbowR, handR),
                
                // Hips
                new Constraint(hips, hipL),
                new Constraint(hips, hipR),
                new Constraint(hipL, hipR), // Pelvis width
                
                // Legs
                new Constraint(hipL, kneeL),
                new Constraint(kneeL, footL),
                new Constraint(hipR, kneeR),
                new Constraint(kneeR, footR)
            ];

            // Internal Constraints (Muscles/Structure - invisible but keep shape)
            // Head to hips to keep upright-ish
            newConstraints.push(new Constraint(head, hips, null, false)); 
            // Shoulder to hips (Torso box)
            newConstraints.push(new Constraint(shoulderL, hips, null, false));
            newConstraints.push(new Constraint(shoulderR, hips, null, false));
            
            constraints.push(...newConstraints);
        }

        function init() {
            points = [];
            constraints = [];
            createRagdoll(width / 2, 100);
            
            // Add a simple box to throw around too
            const boxX = width / 2 + 100;
            const boxY = 100;
            const p1 = new Point(boxX, boxY);
            const p2 = new Point(boxX + 50, boxY);
            const p3 = new Point(boxX + 50, boxY + 50);
            const p4 = new Point(boxX, boxY + 50);
            points.push(p1, p2, p3, p4);
            constraints.push(
                new Constraint(p1, p2), new Constraint(p2, p3), 
                new Constraint(p3, p4), new Constraint(p4, p1),
                new Constraint(p1, p3), new Constraint(p2, p4) // Cross bracing
            );
        }

        // --- Interaction ---

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }

        canvas.addEventListener('mousedown', (e) => {
            const mouse = getMousePos(e);
            
            // Find nearest point
            let nearest = null;
            let minDist = 30; // Interaction radius

            for (const p of points) {
                const dist = Math.hypot(p.x - mouse.x, p.y - mouse.y);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = p;
                }
            }

            if (nearest) {
                if (e.button === 2) { // Right click to cut
                    // Find constraints attached to this point and remove them
                    constraints = constraints.filter(c => c.p1 !== nearest && c.p2 !== nearest);
                } else {
                    draggedPoint = nearest;
                }
            }
        });

        window.addEventListener('mousemove', (e) => {
            if (draggedPoint) {
                const mouse = getMousePos(e);
                // Instead of setting position directly (which breaks physics), 
                // we pull it towards mouse strongly but allow some physics
                // Or for "God Mode" dragging, we just set it:
                draggedPoint.x = mouse.x;
                draggedPoint.y = mouse.y;
                // Reset velocity so it doesn't explode when released
                draggedPoint.oldx = mouse.x; 
                draggedPoint.oldy = mouse.y;
            }
        });

        window.addEventListener('mouseup', () => {
            if (draggedPoint) {
                // Give it a little throw velocity based on last movement
                // (Implicit in Verlet if we just stop updating oldx/oldy manually)
                draggedPoint = null;
            }
        });

        canvas.addEventListener('contextmenu', e => e.preventDefault());

        window.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'r') init();
            if (e.key.toLowerCase() === 'g') gravityEnabled = !gravityEnabled;
        });
        
        document.getElementById('reset-btn').addEventListener('click', init);

        // --- Loop ---

        function update() {
            // 1. Update Points
            for (const p of points) {
                p.update();
                p.constrain();
            }

            // 2. Solve Constraints (Iterate for stability)
            for (let i = 0; i < CONFIG.iterations; i++) {
                for (const c of constraints) {
                    c.resolve();
                }
                // Re-constrain points to walls after constraint resolution
                // prevents points getting pushed out of bounds by stiff constraints
                for (const p of points) {
                    p.constrain();
                }
            }
            
            // Dragging override
            if (draggedPoint) {
                // Keep it pinned to mouse during physics steps
                // (Already handled in mousemove, but good to ensure)
            }
        }

        function draw() {
            ctx.clearRect(0, 0, width, height);

            // Draw Constraints
            for (const c of constraints) {
                c.draw();
            }

            // Draw Points
            for (const p of points) {
                p.draw();
            }
            
            // Draw Mouse Line if dragging
            if (draggedPoint) {
                ctx.beginPath();
                ctx.arc(draggedPoint.x, draggedPoint.y, 10, 0, Math.PI*2);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.stroke();
            }
        }

        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        // Start
        init();
        loop();

    </script>
</body>
</html>