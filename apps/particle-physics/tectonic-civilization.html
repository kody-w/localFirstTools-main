<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tectonic Plate Civilization - Deep Time Simulation</title>
    <meta name="description" content="Watch continents drift, civilizations emerge, and worlds collide across billions of years of geological time. A Three.js simulation of plate tectonics and emergent civilizations.">
    <meta name="theme-color" content="#000011">
    <meta name="color-scheme" content="dark">
    <!-- 3d, simulation, threejs, geology, civilization, procedural, animation, educational -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            height: 100vh;
        }

        #container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
        }

        /* UI Overlay */
        .ui-panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid rgba(100, 150, 255, 0.3);
            border-radius: 8px;
            padding: 15px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        /* Time Display */
        #time-panel {
            top: 20px;
            left: 20px;
            min-width: 280px;
        }

        #era-name {
            font-size: 24px;
            font-weight: 300;
            color: #7eb8ff;
            text-transform: uppercase;
            letter-spacing: 3px;
            margin-bottom: 5px;
        }

        #time-display {
            font-size: 36px;
            font-weight: 200;
            color: #fff;
            font-family: 'Courier New', monospace;
        }

        #time-display span {
            font-size: 14px;
            color: #888;
            margin-left: 5px;
        }

        /* Controls Panel */
        #controls-panel {
            top: 20px;
            right: 20px;
            width: 220px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
        }

        .speed-control {
            display: flex;
            gap: 5px;
        }

        .speed-btn {
            flex: 1;
            padding: 8px;
            background: rgba(100, 150, 255, 0.1);
            border: 1px solid rgba(100, 150, 255, 0.3);
            color: #7eb8ff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .speed-btn:hover {
            background: rgba(100, 150, 255, 0.3);
        }

        .speed-btn.active {
            background: rgba(100, 150, 255, 0.5);
            border-color: #7eb8ff;
        }

        .tool-btn {
            width: 100%;
            padding: 10px;
            margin-bottom: 8px;
            background: rgba(255, 100, 100, 0.1);
            border: 1px solid rgba(255, 100, 100, 0.3);
            color: #ff7e7e;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .tool-btn:hover {
            background: rgba(255, 100, 100, 0.3);
        }

        .tool-btn.volcanic {
            background: rgba(255, 150, 50, 0.1);
            border-color: rgba(255, 150, 50, 0.3);
            color: #ffaa50;
        }

        .tool-btn.volcanic:hover {
            background: rgba(255, 150, 50, 0.3);
        }

        /* Stats Panel */
        #stats-panel {
            bottom: 20px;
            left: 20px;
            width: 300px;
            max-height: 250px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 13px;
        }

        .stat-label {
            color: #888;
        }

        .stat-value {
            color: #7eb8ff;
            font-family: 'Courier New', monospace;
        }

        /* Event Log */
        #event-panel {
            bottom: 20px;
            right: 20px;
            width: 350px;
            max-height: 300px;
        }

        #event-panel h3 {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        #event-log {
            max-height: 230px;
            overflow-y: auto;
            font-size: 12px;
            line-height: 1.6;
        }

        #event-log::-webkit-scrollbar {
            width: 4px;
        }

        #event-log::-webkit-scrollbar-thumb {
            background: rgba(100, 150, 255, 0.3);
            border-radius: 2px;
        }

        .event-entry {
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .event-time {
            color: #666;
            font-family: 'Courier New', monospace;
            font-size: 10px;
        }

        .event-text {
            color: #ccc;
        }

        .event-text.collision {
            color: #ff7e7e;
        }

        .event-text.birth {
            color: #7eff9e;
        }

        .event-text.contact {
            color: #ffeb7e;
        }

        .event-text.extinction {
            color: #ff5555;
        }

        /* Civilization Info Panel */
        #civ-panel {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            display: none;
            z-index: 100;
        }

        #civ-panel.visible {
            display: block;
        }

        #civ-panel h2 {
            font-size: 20px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .civ-close {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: #888;
            font-size: 20px;
            cursor: pointer;
        }

        .civ-trait {
            display: inline-block;
            padding: 3px 8px;
            margin: 2px;
            background: rgba(100, 150, 255, 0.2);
            border-radius: 3px;
            font-size: 11px;
            color: #7eb8ff;
        }

        /* Legend */
        #legend {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 11px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        /* Loading Screen */
        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 1s;
        }

        #loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #loading h1 {
            font-size: 48px;
            font-weight: 200;
            letter-spacing: 10px;
            margin-bottom: 20px;
            color: #7eb8ff;
        }

        #loading p {
            font-size: 14px;
            color: #666;
            letter-spacing: 2px;
        }

        .loading-bar {
            width: 200px;
            height: 2px;
            background: rgba(255, 255, 255, 0.1);
            margin-top: 30px;
            overflow: hidden;
        }

        .loading-progress {
            height: 100%;
            background: #7eb8ff;
            animation: loading 2s ease-in-out infinite;
        }

        @keyframes loading {
            0% { width: 0%; margin-left: 0; }
            50% { width: 100%; margin-left: 0; }
            100% { width: 0%; margin-left: 100%; }
        }

        /* Cinematic Mode */
        .cinematic-mode .ui-panel {
            opacity: 0;
            transition: opacity 0.5s;
        }

        .cinematic-mode #time-panel {
            opacity: 1;
        }

        /* Responsive */
        @media (max-width: 768px) {
            #controls-panel, #event-panel {
                display: none;
            }
            
            #stats-panel {
                width: 200px;
                font-size: 11px;
            }
            
            #time-display {
                font-size: 24px;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <!-- Loading Screen -->
        <div id="loading">
            <h1>DEEP TIME</h1>
            <p>INITIALIZING PLANETARY SIMULATION</p>
            <div class="loading-bar"><div class="loading-progress"></div></div>
        </div>

        <!-- Time Panel -->
        <div id="time-panel" class="ui-panel">
            <div id="era-name">Hadean Eon</div>
            <div id="time-display">4,500<span>Million Years Ago</span></div>
        </div>

        <!-- Controls Panel -->
        <div id="controls-panel" class="ui-panel">
            <div class="control-group">
                <label>Time Speed</label>
                <div class="speed-control">
                    <button class="speed-btn" data-speed="0">||</button>
                    <button class="speed-btn" data-speed="1">1x</button>
                    <button class="speed-btn active" data-speed="5">5x</button>
                    <button class="speed-btn" data-speed="20">20x</button>
                </div>
            </div>
            <div class="control-group">
                <label>Cataclysmic Events</label>
                <button class="tool-btn" id="meteor-btn">Meteor Impact</button>
                <button class="tool-btn volcanic" id="volcanic-btn">Volcanic Winter</button>
            </div>
            <div class="control-group">
                <label>View</label>
                <button class="speed-btn" id="cinematic-btn" style="width: 100%">Cinematic Mode</button>
                <button class="speed-btn" id="reset-btn" style="width: 100%; margin-top: 5px">Reset Simulation</button>
            </div>
        </div>

        <!-- Stats Panel -->
        <div id="stats-panel" class="ui-panel">
            <div class="stat-row">
                <span class="stat-label">Tectonic Plates</span>
                <span class="stat-value" id="stat-plates">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Continents</span>
                <span class="stat-value" id="stat-continents">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Civilizations</span>
                <span class="stat-value" id="stat-civs">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Active Volcanoes</span>
                <span class="stat-value" id="stat-volcanoes">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Mountain Ranges</span>
                <span class="stat-value" id="stat-mountains">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Supercontinent Cycles</span>
                <span class="stat-value" id="stat-cycles">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Mass Extinctions</span>
                <span class="stat-value" id="stat-extinctions">0</span>
            </div>
        </div>

        <!-- Event Log -->
        <div id="event-panel" class="ui-panel">
            <h3>Geological Events</h3>
            <div id="event-log"></div>
        </div>

        <!-- Civilization Info Panel -->
        <div id="civ-panel" class="ui-panel">
            <button class="civ-close" id="civ-close">&times;</button>
            <h2 id="civ-name">Civilization Name</h2>
            <div id="civ-info"></div>
        </div>

        <!-- Legend -->
        <div id="legend">
            <div class="legend-item">
                <div class="legend-dot" style="background: #ff4444;"></div>
                <span>Convergent</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot" style="background: #4444ff;"></div>
                <span>Divergent</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot" style="background: #ffff44;"></div>
                <span>Transform</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot" style="background: #ff8800;"></div>
                <span>Volcanic</span>
            </div>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // ============================================
        // CONFIGURATION
        // ============================================
        const CONFIG = {
            sphereRadius: 5,
            sphereDetail: 64,
            numPlates: 12,
            timeSpeed: 5,
            seaLevel: 0.3,
            mountainGrowthRate: 0.002,
            erosionRate: 0.0001,
            civilizationSpawnThreshold: 500,
            minLandMassForCiv: 0.1,
            volcanoParticles: 100,
            mantleConvectionSpeed: 0.0005
        };

        // ============================================
        // GEOLOGICAL ERAS
        // ============================================
        const GEOLOGICAL_ERAS = [
            { name: 'Hadean Eon', start: 4500, color: '#8B0000' },
            { name: 'Archean Eon', start: 4000, color: '#4B0082' },
            { name: 'Proterozoic Eon', start: 2500, color: '#006400' },
            { name: 'Cambrian Period', start: 541, color: '#228B22' },
            { name: 'Ordovician Period', start: 485, color: '#32CD32' },
            { name: 'Silurian Period', start: 444, color: '#9ACD32' },
            { name: 'Devonian Period', start: 419, color: '#6B8E23' },
            { name: 'Carboniferous Period', start: 359, color: '#556B2F' },
            { name: 'Permian Period', start: 299, color: '#8B4513' },
            { name: 'Triassic Period', start: 252, color: '#A0522D' },
            { name: 'Jurassic Period', start: 201, color: '#CD853F' },
            { name: 'Cretaceous Period', start: 145, color: '#DEB887' },
            { name: 'Paleogene Period', start: 66, color: '#F4A460' },
            { name: 'Neogene Period', start: 23, color: '#DAA520' },
            { name: 'Quaternary Period', start: 2.6, color: '#FFD700' },
            { name: 'Present Day', start: 0, color: '#FFFFFF' }
        ];

        // ============================================
        // CIVILIZATION TRAITS
        // ============================================
        const CIV_TRAITS = {
            island: ['Naval Masters', 'Trade Networks', 'Exploration', 'Fishing Culture', 'Storm Worship'],
            mountain: ['Fortress Builders', 'Mining Expertise', 'Isolationist', 'Sky Worship', 'Terrace Farming'],
            plains: ['Empire Builders', 'Cavalry Masters', 'Agricultural', 'Expansionist', 'River Culture'],
            desert: ['Nomadic', 'Trade Caravans', 'Oasis Keepers', 'Star Navigation', 'Water Wisdom'],
            coastal: ['Shipbuilders', 'Pearl Divers', 'Lighthouse Keepers', 'Tide Readers', 'Salt Merchants'],
            volcanic: ['Fire Worship', 'Obsidian Crafters', 'Hot Spring Bathers', 'Ash Farmers', 'Lava Forgers']
        };

        const CIV_NAMES_PREFIX = ['Zar', 'Keth', 'Mor', 'Vel', 'Tha', 'Xen', 'Gor', 'Phi', 'Nar', 'Bal', 'Dra', 'Kor', 'Eth', 'Mal', 'Syl'];
        const CIV_NAMES_SUFFIX = ['oria', 'andria', 'heim', 'gard', 'opolis', 'istan', 'land', 'mar', 'ven', 'thos', 'ara', 'ion', 'eth', 'um', 'ix'];

        // ============================================
        // GLOBAL STATE
        // ============================================
        let scene, camera, renderer, controls;
        let globe, atmosphereGlow, starField;
        let plates = [];
        let civilizations = [];
        let volcanoes = [];
        let mountainRanges = [];
        let events = [];
        let particles = [];
        
        let currentTime = 4500;
        let timeSpeed = CONFIG.timeSpeed;
        let supercontinentCycles = 0;
        let massExtinctions = 0;
        let isPaused = false;
        let isCinematic = false;
        let cinematicTarget = null;
        
        let vertexHeights = [];
        let vertexPlateIds = [];
        let originalPositions = [];

        // ============================================
        // INITIALIZATION
        // ============================================
        async function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000011);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 12);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            document.getElementById('container').appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 7;
            controls.maxDistance = 25;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.3;

            setupLighting();
            createStarField();
            createGlobe();
            createAtmosphere();
            initializePlates();
            setupUI();

            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
            }, 2000);

            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function setupLighting() {
            const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
            sunLight.position.set(50, 30, 50);
            sunLight.castShadow = true;
            scene.add(sunLight);

            const ambientLight = new THREE.AmbientLight(0x333355, 0.5);
            scene.add(ambientLight);

            const rimLight = new THREE.DirectionalLight(0x4488ff, 0.3);
            rimLight.position.set(-50, 0, -50);
            scene.add(rimLight);
        }

        function createStarField() {
            const starsGeometry = new THREE.BufferGeometry();
            const starCount = 5000;
            const positions = new Float32Array(starCount * 3);
            const colors = new Float32Array(starCount * 3);

            for (let i = 0; i < starCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 100 + Math.random() * 100;

                positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = r * Math.cos(phi);

                const colorVariation = 0.8 + Math.random() * 0.2;
                colors[i * 3] = colorVariation;
                colors[i * 3 + 1] = colorVariation;
                colors[i * 3 + 2] = colorVariation;
            }

            starsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            starsGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const starsMaterial = new THREE.PointsMaterial({
                size: 0.5,
                vertexColors: true,
                transparent: true,
                opacity: 0.8
            });

            starField = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(starField);
        }

        function createGlobe() {
            const geometry = new THREE.IcosahedronGeometry(CONFIG.sphereRadius, CONFIG.sphereDetail);
            
            const positions = geometry.attributes.position.array;
            originalPositions = new Float32Array(positions.length);
            originalPositions.set(positions);
            
            const vertexCount = positions.length / 3;
            vertexHeights = new Float32Array(vertexCount);
            vertexPlateIds = new Int32Array(vertexCount);
            
            for (let i = 0; i < vertexCount; i++) {
                const x = positions[i * 3];
                const y = positions[i * 3 + 1];
                const z = positions[i * 3 + 2];
                
                let height = 0;
                height += simplex3D(x * 0.5, y * 0.5, z * 0.5) * 0.5;
                height += simplex3D(x * 1.0, y * 1.0, z * 1.0) * 0.25;
                height += simplex3D(x * 2.0, y * 2.0, z * 2.0) * 0.125;
                
                height = (height + 1) * 0.5;
                vertexHeights[i] = height;
            }
            
            const terrainMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    seaLevel: { value: CONFIG.seaLevel },
                    time: { value: 0 }
                },
                vertexShader: `
                    attribute float height;
                    varying float vHeight;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    
                    void main() {
                        vHeight = height;
                        vNormal = normalize(normalMatrix * normal);
                        vPosition = position;
                        
                        vec3 displaced = position * (1.0 + height * 0.15);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(displaced, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float seaLevel;
                    uniform float time;
                    varying float vHeight;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    
                    void main() {
                        vec3 lightDir = normalize(vec3(1.0, 0.5, 0.5));
                        float diffuse = max(dot(vNormal, lightDir), 0.0);
                        float ambient = 0.3;
                        float lighting = ambient + diffuse * 0.7;
                        
                        vec3 color;
                        
                        if (vHeight < seaLevel - 0.1) {
                            color = vec3(0.0, 0.1, 0.3);
                        } else if (vHeight < seaLevel) {
                            color = vec3(0.0, 0.3, 0.6);
                        } else if (vHeight < seaLevel + 0.1) {
                            color = vec3(0.76, 0.7, 0.5);
                        } else if (vHeight < seaLevel + 0.3) {
                            color = vec3(0.2, 0.5, 0.2);
                        } else if (vHeight < seaLevel + 0.5) {
                            color = vec3(0.4, 0.35, 0.25);
                        } else if (vHeight < seaLevel + 0.7) {
                            color = vec3(0.5, 0.45, 0.4);
                        } else {
                            color = vec3(0.95, 0.95, 1.0);
                        }
                        
                        gl_FragColor = vec4(color * lighting, 1.0);
                    }
                `
            });
            
            geometry.setAttribute('height', new THREE.BufferAttribute(vertexHeights, 1));
            
            globe = new THREE.Mesh(geometry, terrainMaterial);
            globe.castShadow = true;
            globe.receiveShadow = true;
            scene.add(globe);
            
            const oceanGeometry = new THREE.SphereGeometry(CONFIG.sphereRadius * 0.99, 64, 64);
            const oceanMaterial = new THREE.MeshPhongMaterial({
                color: 0x0055aa,
                transparent: true,
                opacity: 0.6,
                shininess: 100
            });
            const ocean = new THREE.Mesh(oceanGeometry, oceanMaterial);
            scene.add(ocean);
        }

        function createAtmosphere() {
            const atmosphereGeometry = new THREE.SphereGeometry(CONFIG.sphereRadius * 1.15, 64, 64);
            const atmosphereMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    glowColor: { value: new THREE.Color(0x4488ff) },
                    viewVector: { value: camera.position }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 glowColor;
                    varying vec3 vNormal;
                    void main() {
                        float intensity = pow(0.7 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
                        gl_FragColor = vec4(glowColor, intensity * 0.5);
                    }
                `,
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending,
                transparent: true
            });
            
            atmosphereGlow = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
            scene.add(atmosphereGlow);
        }

        function simplex3D(x, y, z) {
            return Math.sin(x * 1.7 + y * 2.3) * Math.cos(y * 1.3 + z * 1.9) * Math.sin(z * 2.1 + x * 1.5);
        }

        // ============================================
        // TECTONIC PLATE SYSTEM
        // ============================================
        function initializePlates() {
            plates = [];
            
            const goldenRatio = (1 + Math.sqrt(5)) / 2;
            
            for (let i = 0; i < CONFIG.numPlates; i++) {
                const theta = 2 * Math.PI * i / goldenRatio;
                const phi = Math.acos(1 - 2 * (i + 0.5) / CONFIG.numPlates);
                
                const x = Math.sin(phi) * Math.cos(theta);
                const y = Math.sin(phi) * Math.sin(theta);
                const z = Math.cos(phi);
                
                const plate = {
                    id: i,
                    center: new THREE.Vector3(x, y, z).normalize(),
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.002,
                        (Math.random() - 0.5) * 0.002,
                        (Math.random() - 0.5) * 0.002
                    ),
                    rotationAxis: new THREE.Vector3(
                        Math.random() - 0.5,
                        Math.random() - 0.5,
                        Math.random() - 0.5
                    ).normalize(),
                    rotationSpeed: (Math.random() - 0.5) * 0.0005,
                    isContinental: Math.random() > 0.4,
                    color: new THREE.Color().setHSL(i / CONFIG.numPlates, 0.7, 0.5),
                    vertices: [],
                    boundaryVertices: new Set(),
                    area: 0
                };
                
                plates.push(plate);
            }
            
            assignVerticesToPlates();
            identifyBoundaries();
        }

        function assignVerticesToPlates() {
            const positions = globe.geometry.attributes.position.array;
            const vertexCount = positions.length / 3;
            
            plates.forEach(p => p.vertices = []);
            
            for (let i = 0; i < vertexCount; i++) {
                const vertex = new THREE.Vector3(
                    positions[i * 3],
                    positions[i * 3 + 1],
                    positions[i * 3 + 2]
                ).normalize();
                
                let nearestPlate = 0;
                let minDist = Infinity;
                
                for (let p = 0; p < plates.length; p++) {
                    const dist = vertex.distanceTo(plates[p].center);
                    if (dist < minDist) {
                        minDist = dist;
                        nearestPlate = p;
                    }
                }
                
                vertexPlateIds[i] = nearestPlate;
                plates[nearestPlate].vertices.push(i);
                
                if (plates[nearestPlate].isContinental) {
                    vertexHeights[i] = Math.max(vertexHeights[i], CONFIG.seaLevel + 0.1);
                } else {
                    vertexHeights[i] = Math.min(vertexHeights[i], CONFIG.seaLevel - 0.1);
                }
            }
            
            plates.forEach(p => {
                p.area = p.vertices.length / vertexCount;
            });
        }

        function identifyBoundaries() {
            const positions = globe.geometry.attributes.position.array;
            const indices = globe.geometry.index ? globe.geometry.index.array : null;
            
            plates.forEach(p => p.boundaryVertices.clear());
            
            if (indices) {
                for (let i = 0; i < indices.length; i += 3) {
                    const v1 = indices[i];
                    const v2 = indices[i + 1];
                    const v3 = indices[i + 2];
                    
                    const p1 = vertexPlateIds[v1];
                    const p2 = vertexPlateIds[v2];
                    const p3 = vertexPlateIds[v3];
                    
                    if (p1 !== p2 || p2 !== p3 || p1 !== p3) {
                        if (p1 !== p2) {
                            plates[p1].boundaryVertices.add(v1);
                            plates[p2].boundaryVertices.add(v2);
                        }
                        if (p2 !== p3) {
                            plates[p2].boundaryVertices.add(v2);
                            plates[p3].boundaryVertices.add(v3);
                        }
                        if (p1 !== p3) {
                            plates[p1].boundaryVertices.add(v1);
                            plates[p3].boundaryVertices.add(v3);
                        }
                    }
                }
            }
        }

        function updatePlates(deltaTime) {
            const timeFactor = deltaTime * timeSpeed;
            
            plates.forEach(plate => {
                const quaternion = new THREE.Quaternion();
                quaternion.setFromAxisAngle(plate.rotationAxis, plate.rotationSpeed * timeFactor);
                plate.center.applyQuaternion(quaternion);
                plate.center.normalize();
                
                if (Math.random() < 0.001 * timeFactor) {
                    plate.velocity.add(new THREE.Vector3(
                        (Math.random() - 0.5) * 0.0005,
                        (Math.random() - 0.5) * 0.0005,
                        (Math.random() - 0.5) * 0.0005
                    ));
                    plate.velocity.clampLength(0, 0.003);
                }
            });
            
            if (Math.random() < 0.1 * timeFactor) {
                assignVerticesToPlates();
                identifyBoundaries();
            }
            
            processBoundaryInteractions(timeFactor);
            applyErosion(timeFactor);
            updateGlobeGeometry();
            checkSupercontinentCycle();
        }

        function processBoundaryInteractions(timeFactor) {
            const positions = globe.geometry.attributes.position.array;
            
            plates.forEach((plate, plateIndex) => {
                plate.boundaryVertices.forEach(vertexIndex => {
                    const neighbors = getVertexNeighbors(vertexIndex);
                    
                    neighbors.forEach(neighborIndex => {
                        const neighborPlateId = vertexPlateIds[neighborIndex];
                        if (neighborPlateId !== plateIndex) {
                            const neighborPlate = plates[neighborPlateId];
                            
                            const relativeVelocity = plate.velocity.clone().sub(neighborPlate.velocity);
                            const boundaryNormal = new THREE.Vector3(
                                positions[vertexIndex * 3],
                                positions[vertexIndex * 3 + 1],
                                positions[vertexIndex * 3 + 2]
                            ).normalize();
                            
                            const convergence = relativeVelocity.dot(boundaryNormal);
                            
                            if (convergence > 0.0001) {
                                if (plate.isContinental && neighborPlate.isContinental) {
                                    vertexHeights[vertexIndex] += CONFIG.mountainGrowthRate * timeFactor;
                                    vertexHeights[vertexIndex] = Math.min(vertexHeights[vertexIndex], 1.0);
                                    trackMountainRange(vertexIndex, positions);
                                } else {
                                    if (Math.random() < 0.01 * timeFactor) {
                                        createVolcano(vertexIndex, positions);
                                    }
                                }
                            } else if (convergence < -0.0001) {
                                vertexHeights[vertexIndex] -= CONFIG.mountainGrowthRate * 0.5 * timeFactor;
                                vertexHeights[vertexIndex] = Math.max(vertexHeights[vertexIndex], 0.0);
                            }
                        }
                    });
                });
            });
        }

        function getVertexNeighbors(vertexIndex) {
            const positions = globe.geometry.attributes.position.array;
            const neighbors = [];
            const threshold = 0.2;
            
            const vx = positions[vertexIndex * 3];
            const vy = positions[vertexIndex * 3 + 1];
            const vz = positions[vertexIndex * 3 + 2];
            
            const vertexCount = positions.length / 3;
            
            for (let i = 0; i < Math.min(50, vertexCount); i++) {
                const idx = Math.floor(Math.random() * vertexCount);
                if (idx === vertexIndex) continue;
                
                const dx = positions[idx * 3] - vx;
                const dy = positions[idx * 3 + 1] - vy;
                const dz = positions[idx * 3 + 2] - vz;
                const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                
                if (dist < threshold) {
                    neighbors.push(idx);
                }
            }
            
            return neighbors;
        }

        function trackMountainRange(vertexIndex, positions) {
            const pos = new THREE.Vector3(
                positions[vertexIndex * 3],
                positions[vertexIndex * 3 + 1],
                positions[vertexIndex * 3 + 2]
            );
            
            const nearExisting = mountainRanges.some(range => {
                return pos.distanceTo(range.center) < 0.5;
            });
            
            if (!nearExisting && vertexHeights[vertexIndex] > CONFIG.seaLevel + 0.5) {
                mountainRanges.push({
                    center: pos.clone(),
                    height: vertexHeights[vertexIndex],
                    age: currentTime,
                    name: generateMountainName()
                });
                
                logEvent('The ' + mountainRanges[mountainRanges.length - 1].name + ' rises as continents collide', 'collision');
            }
        }

        function generateMountainName() {
            const prefixes = ['Great', 'Ancient', 'Eternal', 'Mighty', 'Sacred', 'Crystal', 'Iron', 'Thunder'];
            const names = ['Spine', 'Ridge', 'Divide', 'Peaks', 'Range', 'Heights', 'Barrier', 'Crown'];
            return prefixes[Math.floor(Math.random() * prefixes.length)] + ' ' + names[Math.floor(Math.random() * names.length)];
        }

        function applyErosion(timeFactor) {
            const vertexCount = vertexHeights.length;
            
            for (let i = 0; i < vertexCount; i++) {
                if (vertexHeights[i] > CONFIG.seaLevel) {
                    const erosion = (vertexHeights[i] - CONFIG.seaLevel) * CONFIG.erosionRate * timeFactor;
                    vertexHeights[i] -= erosion;
                }
            }
        }

        function updateGlobeGeometry() {
            const positions = globe.geometry.attributes.position.array;
            const heights = globe.geometry.attributes.height.array;
            const vertexCount = positions.length / 3;
            
            for (let i = 0; i < vertexCount; i++) {
                heights[i] = vertexHeights[i];
                
                const factor = 1.0 + vertexHeights[i] * 0.15;
                positions[i * 3] = originalPositions[i * 3] * factor;
                positions[i * 3 + 1] = originalPositions[i * 3 + 1] * factor;
                positions[i * 3 + 2] = originalPositions[i * 3 + 2] * factor;
            }
            
            globe.geometry.attributes.position.needsUpdate = true;
            globe.geometry.attributes.height.needsUpdate = true;
            globe.geometry.computeVertexNormals();
        }

        function checkSupercontinentCycle() {
            const continentalPlates = plates.filter(p => p.isContinental);
            if (continentalPlates.length < 2) return;
            
            let totalDist = 0;
            let count = 0;
            
            for (let i = 0; i < continentalPlates.length; i++) {
                for (let j = i + 1; j < continentalPlates.length; j++) {
                    totalDist += continentalPlates[i].center.distanceTo(continentalPlates[j].center);
                    count++;
                }
            }
            
            const avgDist = totalDist / count;
            
            if (avgDist < 0.5 && Math.random() < 0.001) {
                supercontinentCycles++;
                logEvent('Supercontinent ' + generateSupercontinentName() + ' forms from colliding landmasses!', 'contact');
                
                setTimeout(() => {
                    plates.forEach(plate => {
                        if (plate.isContinental && Math.random() > 0.5) {
                            plate.velocity.multiplyScalar(-1);
                            plate.rotationSpeed *= -1;
                        }
                    });
                }, 5000);
            }
        }

        function generateSupercontinentName() {
            const names = ['Pangaea', 'Rodinia', 'Columbia', 'Gondwana', 'Laurasia', 'Ur', 'Vaalbara', 'Kenorland'];
            return names[supercontinentCycles % names.length] + (supercontinentCycles > 7 ? ' ' + (Math.floor(supercontinentCycles / 8) + 1) : '');
        }

        // ============================================
        // VOLCANIC SYSTEM
        // ============================================
        function createVolcano(vertexIndex, positions) {
            const pos = new THREE.Vector3(
                positions[vertexIndex * 3],
                positions[vertexIndex * 3 + 1],
                positions[vertexIndex * 3 + 2]
            ).normalize().multiplyScalar(CONFIG.sphereRadius * 1.1);
            
            const nearExisting = volcanoes.some(v => pos.distanceTo(v.position) < 0.3);
            if (nearExisting) return;
            
            const volcanoGeometry = new THREE.ConeGeometry(0.08, 0.15, 8);
            const volcanoMaterial = new THREE.MeshBasicMaterial({ color: 0xff4400 });
            const volcanoMesh = new THREE.Mesh(volcanoGeometry, volcanoMaterial);
            
            volcanoMesh.position.copy(pos);
            volcanoMesh.lookAt(new THREE.Vector3(0, 0, 0));
            volcanoMesh.rotateX(Math.PI / 2);
            
            scene.add(volcanoMesh);
            
            const volcano = {
                mesh: volcanoMesh,
                position: pos.clone(),
                active: true,
                birthTime: currentTime,
                lastEruption: currentTime,
                name: generateVolcanoName()
            };
            
            volcanoes.push(volcano);
            
            vertexHeights[vertexIndex] += 0.2;
            
            logEvent('Mount ' + volcano.name + ' erupts from the depths', 'collision');
            
            createEruptionParticles(pos);
        }

        function generateVolcanoName() {
            const prefixes = ['Mt.', 'Mt.', 'Mt.', 'Peak', 'Fire'];
            const names = ['Ember', 'Fury', 'Ash', 'Doom', 'Thunder', 'Storm', 'Rage', 'Inferno', 'Blaze'];
            return prefixes[Math.floor(Math.random() * prefixes.length)] + ' ' + names[Math.floor(Math.random() * names.length)];
        }

        function createEruptionParticles(position) {
            const particleCount = 50;
            const particleGeometry = new THREE.BufferGeometry();
            const particlePositions = new Float32Array(particleCount * 3);
            const particleVelocities = [];
            
            for (let i = 0; i < particleCount; i++) {
                particlePositions[i * 3] = position.x;
                particlePositions[i * 3 + 1] = position.y;
                particlePositions[i * 3 + 2] = position.z;
                
                particleVelocities.push(new THREE.Vector3(
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1
                ).add(position.clone().normalize().multiplyScalar(0.05)));
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                color: 0xff6600,
                size: 0.1,
                transparent: true,
                opacity: 1
            });
            
            const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particleSystem);
            
            particles.push({
                system: particleSystem,
                velocities: particleVelocities,
                life: 1.0,
                origin: position.clone()
            });
        }

        function updateParticles(deltaTime) {
            particles = particles.filter(particle => {
                particle.life -= deltaTime * 0.5;
                
                if (particle.life <= 0) {
                    scene.remove(particle.system);
                    particle.system.geometry.dispose();
                    particle.system.material.dispose();
                    return false;
                }
                
                const positions = particle.system.geometry.attributes.position.array;
                
                for (let i = 0; i < particle.velocities.length; i++) {
                    const pos = new THREE.Vector3(
                        positions[i * 3],
                        positions[i * 3 + 1],
                        positions[i * 3 + 2]
                    );
                    const gravity = pos.clone().normalize().multiplyScalar(-0.002);
                    particle.velocities[i].add(gravity);
                    
                    positions[i * 3] += particle.velocities[i].x;
                    positions[i * 3 + 1] += particle.velocities[i].y;
                    positions[i * 3 + 2] += particle.velocities[i].z;
                }
                
                particle.system.geometry.attributes.position.needsUpdate = true;
                particle.system.material.opacity = particle.life;
                
                return true;
            });
        }

        function updateVolcanoes(deltaTime) {
            volcanoes.forEach(volcano => {
                if (volcano.active && currentTime - volcano.lastEruption > 50 && Math.random() < 0.01 * deltaTime * timeSpeed) {
                    createEruptionParticles(volcano.position);
                    volcano.lastEruption = currentTime;
                }
                
                if (currentTime - volcano.birthTime > 200 && Math.random() < 0.001 * deltaTime * timeSpeed) {
                    volcano.active = false;
                    volcano.mesh.material.color.setHex(0x666666);
                }
            });
        }

        // ============================================
        // CIVILIZATION SYSTEM
        // ============================================
        function updateCivilizations(deltaTime) {
            const timeFactor = deltaTime * timeSpeed;
            
            if (currentTime < 3500 && civilizations.length < 20 && Math.random() < 0.01 * timeFactor) {
                attemptCivilizationSpawn();
            }
            
            civilizations.forEach(civ => {
                if (civ.population > 0 && Math.random() < 0.1 * timeFactor) {
                    expandTerritory(civ);
                }
                
                if (Math.random() < 0.05 * timeFactor) {
                    advanceTechnology(civ);
                }
                
                checkCivilizationContact(civ);
            });
            
            updateCivilizationMarkers();
        }

        function attemptCivilizationSpawn() {
            const positions = globe.geometry.attributes.position.array;
            const vertexCount = positions.length / 3;
            
            for (let attempt = 0; attempt < 100; attempt++) {
                const vertexIndex = Math.floor(Math.random() * vertexCount);
                
                if (vertexHeights[vertexIndex] > CONFIG.seaLevel + 0.05) {
                    const pos = new THREE.Vector3(
                        positions[vertexIndex * 3],
                        positions[vertexIndex * 3 + 1],
                        positions[vertexIndex * 3 + 2]
                    ).normalize().multiplyScalar(CONFIG.sphereRadius * 1.15);
                    
                    const tooClose = civilizations.some(c => pos.distanceTo(c.capital) < 1.0);
                    if (tooClose) continue;
                    
                    const terrainType = getTerrainType(vertexIndex);
                    
                    const civ = createCivilization(pos, vertexIndex, terrainType);
                    civilizations.push(civ);
                    
                    logEvent('The ' + civ.name + ' civilization emerges in the ' + terrainType + ' regions', 'birth');
                    break;
                }
            }
        }

        function getTerrainType(vertexIndex) {
            const height = vertexHeights[vertexIndex];
            const positions = globe.geometry.attributes.position.array;
            
            const neighbors = getVertexNeighbors(vertexIndex);
            const waterNeighbors = neighbors.filter(n => vertexHeights[n] < CONFIG.seaLevel).length;
            
            if (waterNeighbors > neighbors.length * 0.6) {
                return 'island';
            }
            
            const pos = new THREE.Vector3(
                positions[vertexIndex * 3],
                positions[vertexIndex * 3 + 1],
                positions[vertexIndex * 3 + 2]
            );
            const nearVolcano = volcanoes.some(v => pos.distanceTo(v.position) < 0.5);
            if (nearVolcano) return 'volcanic';
            
            if (height > CONFIG.seaLevel + 0.5) return 'mountain';
            if (height < CONFIG.seaLevel + 0.1) return 'coastal';
            if (waterNeighbors === 0) return 'desert';
            return 'plains';
        }

        function createCivilization(position, vertexIndex, terrainType) {
            const name = CIV_NAMES_PREFIX[Math.floor(Math.random() * CIV_NAMES_PREFIX.length)] + 
                        CIV_NAMES_SUFFIX[Math.floor(Math.random() * CIV_NAMES_SUFFIX.length)];
            
            const color = new THREE.Color().setHSL(Math.random(), 0.7, 0.5);
            
            const markerGeometry = new THREE.SphereGeometry(0.08, 8, 8);
            const markerMaterial = new THREE.MeshBasicMaterial({ color: color });
            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            marker.position.copy(position);
            scene.add(marker);
            
            const territoryGeometry = new THREE.RingGeometry(0.1, 0.15, 16);
            const territoryMaterial = new THREE.MeshBasicMaterial({ 
                color: color, 
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.5
            });
            const territory = new THREE.Mesh(territoryGeometry, territoryMaterial);
            territory.position.copy(position);
            territory.lookAt(new THREE.Vector3(0, 0, 0));
            scene.add(territory);
            
            const traits = CIV_TRAITS[terrainType].slice(0, 2 + Math.floor(Math.random() * 2));
            
            return {
                name: name,
                terrainType: terrainType,
                capital: position.clone(),
                capitalVertex: vertexIndex,
                color: color,
                marker: marker,
                territory: territory,
                territoryRadius: 0.15,
                population: 1000,
                technology: 1,
                traits: traits,
                birthTime: currentTime,
                contactedCivs: new Set(),
                plateId: vertexPlateIds[vertexIndex],
                history: ['Founded in the ' + terrainType + ' lands']
            };
        }

        function expandTerritory(civ) {
            civ.territoryRadius += 0.01;
            civ.territory.geometry.dispose();
            civ.territory.geometry = new THREE.RingGeometry(civ.territoryRadius - 0.05, civ.territoryRadius, 16);
            civ.population += 500;
        }

        function advanceTechnology(civ) {
            civ.technology += 0.1;
            
            if (Math.floor(civ.technology) > Math.floor(civ.technology - 0.1) && civ.technology > 2) {
                const allTraits = Object.values(CIV_TRAITS).flat();
                const newTrait = allTraits[Math.floor(Math.random() * allTraits.length)];
                if (!civ.traits.includes(newTrait)) {
                    civ.traits.push(newTrait);
                    civ.history.push('Developed ' + newTrait);
                }
            }
        }

        function checkCivilizationContact(civ) {
            civilizations.forEach(otherCiv => {
                if (otherCiv === civ) return;
                if (civ.contactedCivs.has(otherCiv.name)) return;
                
                const distance = civ.capital.distanceTo(otherCiv.capital);
                const contactRange = civ.territoryRadius + otherCiv.territoryRadius + 0.5;
                
                if (distance < contactRange || (civ.plateId !== otherCiv.plateId && distance < 2.0)) {
                    civ.contactedCivs.add(otherCiv.name);
                    otherCiv.contactedCivs.add(civ.name);
                    
                    const outcome = determineContactOutcome(civ, otherCiv);
                    
                    logEvent(civ.name + ' and ' + otherCiv.name + ' make first contact: ' + outcome, 'contact');
                    
                    civ.history.push('Met the ' + otherCiv.name + ' - ' + outcome);
                    otherCiv.history.push('Met the ' + civ.name + ' - ' + outcome);
                    
                    createTradeRoute(civ, otherCiv, outcome);
                }
            });
        }

        function determineContactOutcome(civ1, civ2) {
            const outcomes = [];
            
            const techDiff = Math.abs(civ1.technology - civ2.technology);
            
            if (techDiff > 3) {
                outcomes.push('technological dominance');
                outcomes.push('cultural assimilation');
            } else if (techDiff < 1) {
                outcomes.push('mutual trade');
                outcomes.push('cultural exchange');
                outcomes.push('alliance formed');
            } else {
                outcomes.push('trade agreement');
                outcomes.push('border tensions');
                outcomes.push('technology sharing');
            }
            
            if (civ1.traits.includes('Expansionist') || civ2.traits.includes('Expansionist')) {
                outcomes.push('territorial conflict');
            }
            if (civ1.traits.includes('Trade Networks') || civ2.traits.includes('Trade Networks')) {
                outcomes.push('profitable trade');
            }
            if (civ1.traits.includes('Isolationist') || civ2.traits.includes('Isolationist')) {
                outcomes.push('cautious diplomacy');
            }
            
            return outcomes[Math.floor(Math.random() * outcomes.length)];
        }

        function createTradeRoute(civ1, civ2, outcome) {
            const curve = new THREE.QuadraticBezierCurve3(
                civ1.capital,
                civ1.capital.clone().add(civ2.capital).multiplyScalar(0.5).normalize().multiplyScalar(CONFIG.sphereRadius * 1.3),
                civ2.capital
            );
            
            const points = curve.getPoints(20);
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            
            let color = 0x44ff44;
            if (outcome.includes('conflict') || outcome.includes('dominance')) {
                color = 0xff4444;
            } else if (outcome.includes('alliance')) {
                color = 0x4444ff;
            }
            
            const material = new THREE.LineBasicMaterial({ 
                color: color,
                transparent: true,
                opacity: 0.5
            });
            
            const line = new THREE.Line(geometry, material);
            scene.add(line);
            
            setTimeout(() => {
                scene.remove(line);
                geometry.dispose();
                material.dispose();
            }, 10000);
        }

        function updateCivilizationMarkers() {
            civilizations.forEach(civ => {
                const pulse = Math.sin(Date.now() * 0.003) * 0.02 + 1;
                civ.marker.scale.setScalar(pulse);
                
                const plateCenter = plates[civ.plateId]?.center;
                if (plateCenter) {
                    civ.capital.lerp(plateCenter.clone().normalize().multiplyScalar(CONFIG.sphereRadius * 1.15), 0.001);
                    civ.marker.position.copy(civ.capital);
                    civ.territory.position.copy(civ.capital);
                    civ.territory.lookAt(new THREE.Vector3(0, 0, 0));
                }
            });
        }

        // ============================================
        // CATACLYSMIC EVENTS
        // ============================================
        function triggerMeteorImpact() {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            
            const impactPoint = new THREE.Vector3(
                Math.sin(phi) * Math.cos(theta),
                Math.sin(phi) * Math.sin(theta),
                Math.cos(phi)
            ).multiplyScalar(CONFIG.sphereRadius * 1.2);
            
            const flashGeometry = new THREE.SphereGeometry(1, 16, 16);
            const flashMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                transparent: true,
                opacity: 1
            });
            const flash = new THREE.Mesh(flashGeometry, flashMaterial);
            flash.position.copy(impactPoint);
            scene.add(flash);
            
            const expandFlash = () => {
                flash.scale.multiplyScalar(1.1);
                flashMaterial.opacity -= 0.05;
                if (flashMaterial.opacity > 0) {
                    requestAnimationFrame(expandFlash);
                } else {
                    scene.remove(flash);
                    flashGeometry.dispose();
                    flashMaterial.dispose();
                }
            };
            expandFlash();
            
            const positions = globe.geometry.attributes.position.array;
            const vertexCount = positions.length / 3;
            const impactNormalized = impactPoint.clone().normalize();
            
            for (let i = 0; i < vertexCount; i++) {
                const vertex = new THREE.Vector3(
                    originalPositions[i * 3],
                    originalPositions[i * 3 + 1],
                    originalPositions[i * 3 + 2]
                ).normalize();
                
                const distance = vertex.distanceTo(impactNormalized);
                if (distance < 0.5) {
                    vertexHeights[i] -= (0.5 - distance) * 0.5;
                    vertexHeights[i] = Math.max(vertexHeights[i], 0);
                } else if (distance < 0.8) {
                    vertexHeights[i] += (0.8 - distance) * 0.2;
                }
            }
            
            const extinctionRadius = 0.8;
            civilizations = civilizations.filter(civ => {
                const civNormalized = civ.capital.clone().normalize();
                if (civNormalized.distanceTo(impactNormalized) < extinctionRadius) {
                    scene.remove(civ.marker);
                    scene.remove(civ.territory);
                    civ.marker.geometry.dispose();
                    civ.marker.material.dispose();
                    civ.territory.geometry.dispose();
                    civ.territory.material.dispose();
                    logEvent('The ' + civ.name + ' civilization is destroyed by the impact', 'extinction');
                    return false;
                }
                civ.population *= 0.3;
                return true;
            });
            
            massExtinctions++;
            logEvent('METEOR IMPACT - Mass extinction event!', 'extinction');
            
            updateGlobeGeometry();
        }

        function triggerVolcanicWinter() {
            if (volcanoes.length === 0) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const pos = new THREE.Vector3(
                    Math.sin(phi) * Math.cos(theta),
                    Math.sin(phi) * Math.sin(theta),
                    Math.cos(phi)
                ).multiplyScalar(CONFIG.sphereRadius * 1.1);
                
                for (let i = 0; i < 10; i++) {
                    createEruptionParticles(pos);
                }
            } else {
                const volcano = volcanoes[Math.floor(Math.random() * volcanoes.length)];
                for (let i = 0; i < 10; i++) {
                    createEruptionParticles(volcano.position);
                }
            }
            
            const originalBackground = scene.background.clone();
            scene.background = new THREE.Color(0x000000);
            
            setTimeout(() => {
                scene.background = originalBackground;
            }, 3000);
            
            civilizations.forEach(civ => {
                civ.population *= 0.5;
                if (civ.population < 100) {
                    logEvent('The ' + civ.name + ' civilization collapses from famine', 'extinction');
                }
            });
            
            civilizations = civilizations.filter(c => c.population >= 100);
            
            massExtinctions++;
            logEvent('VOLCANIC WINTER - Global temperatures plummet!', 'extinction');
        }

        // ============================================
        // UI SYSTEM
        // ============================================
        function setupUI() {
            document.querySelectorAll('.speed-btn[data-speed]').forEach(btn => {
                btn.addEventListener('click', () => {
                    const speed = parseFloat(btn.dataset.speed);
                    timeSpeed = speed;
                    isPaused = speed === 0;
                    
                    document.querySelectorAll('.speed-btn[data-speed]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                });
            });
            
            document.getElementById('meteor-btn').addEventListener('click', triggerMeteorImpact);
            document.getElementById('volcanic-btn').addEventListener('click', triggerVolcanicWinter);
            
            document.getElementById('cinematic-btn').addEventListener('click', () => {
                isCinematic = !isCinematic;
                document.body.classList.toggle('cinematic-mode', isCinematic);
                controls.autoRotate = isCinematic;
                controls.autoRotateSpeed = isCinematic ? 0.5 : 0.3;
            });
            
            document.getElementById('reset-btn').addEventListener('click', resetSimulation);
            
            document.getElementById('civ-close').addEventListener('click', () => {
                document.getElementById('civ-panel').classList.remove('visible');
            });
            
            renderer.domElement.addEventListener('click', onGlobeClick);
        }

        function onGlobeClick(event) {
            const mouse = new THREE.Vector2(
                (event.clientX / window.innerWidth) * 2 - 1,
                -(event.clientY / window.innerHeight) * 2 + 1
            );
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            const markers = civilizations.map(c => c.marker);
            const intersects = raycaster.intersectObjects(markers);
            
            if (intersects.length > 0) {
                const clickedMarker = intersects[0].object;
                const civ = civilizations.find(c => c.marker === clickedMarker);
                if (civ) {
                    showCivilizationInfo(civ);
                }
            }
        }

        function showCivilizationInfo(civ) {
            const panel = document.getElementById('civ-panel');
            document.getElementById('civ-name').textContent = civ.name;
            document.getElementById('civ-name').style.color = '#' + civ.color.getHexString();
            
            let info = '<div class="stat-row"><span class="stat-label">Terrain</span><span class="stat-value">' + civ.terrainType + '</span></div>' +
                '<div class="stat-row"><span class="stat-label">Population</span><span class="stat-value">' + Math.floor(civ.population).toLocaleString() + '</span></div>' +
                '<div class="stat-row"><span class="stat-label">Technology</span><span class="stat-value">' + civ.technology.toFixed(1) + '</span></div>' +
                '<div class="stat-row"><span class="stat-label">Age</span><span class="stat-value">' + Math.floor(civ.birthTime - currentTime) + ' MY</span></div>' +
                '<div class="stat-row"><span class="stat-label">Contacts</span><span class="stat-value">' + civ.contactedCivs.size + '</span></div>' +
                '<div style="margin-top: 10px;"><div class="stat-label" style="margin-bottom: 5px;">Traits</div>' +
                civ.traits.map(t => '<span class="civ-trait">' + t + '</span>').join('') + '</div>' +
                '<div style="margin-top: 10px;"><div class="stat-label" style="margin-bottom: 5px;">History</div>' +
                '<div style="font-size: 11px; color: #888; max-height: 100px; overflow-y: auto;">' +
                civ.history.slice(-5).map(h => '<div>- ' + h + '</div>').join('') + '</div></div>';
            
            document.getElementById('civ-info').innerHTML = info;
            panel.classList.add('visible');
        }

        function updateUI() {
            const era = GEOLOGICAL_ERAS.find(e => currentTime >= e.start) || GEOLOGICAL_ERAS[GEOLOGICAL_ERAS.length - 1];
            document.getElementById('era-name').textContent = era.name;
            document.getElementById('era-name').style.color = era.color;
            
            const timeStr = currentTime > 0 ? 
                currentTime.toFixed(1) + '<span>Million Years Ago</span>' : 
                'Present Day';
            document.getElementById('time-display').innerHTML = timeStr;
            
            document.getElementById('stat-plates').textContent = plates.length;
            document.getElementById('stat-continents').textContent = plates.filter(p => p.isContinental).length;
            document.getElementById('stat-civs').textContent = civilizations.length;
            document.getElementById('stat-volcanoes').textContent = volcanoes.filter(v => v.active).length;
            document.getElementById('stat-mountains').textContent = mountainRanges.length;
            document.getElementById('stat-cycles').textContent = supercontinentCycles;
            document.getElementById('stat-extinctions').textContent = massExtinctions;
        }

        function logEvent(message, type) {
            type = type || 'info';
            const log = document.getElementById('event-log');
            const entry = document.createElement('div');
            entry.className = 'event-entry';
            
            const timeStr = currentTime > 0 ? currentTime.toFixed(0) + ' MYA' : 'Present';
            entry.innerHTML = '<div class="event-time">' + timeStr + '</div><div class="event-text ' + type + '">' + message + '</div>';
            
            log.insertBefore(entry, log.firstChild);
            
            while (log.children.length > 50) {
                log.removeChild(log.lastChild);
            }
            
            events.push({ time: currentTime, message: message, type: type });
        }

        function resetSimulation() {
            civilizations.forEach(civ => {
                scene.remove(civ.marker);
                scene.remove(civ.territory);
            });
            
            volcanoes.forEach(v => {
                scene.remove(v.mesh);
            });
            
            particles.forEach(p => {
                scene.remove(p.system);
            });
            
            civilizations = [];
            volcanoes = [];
            particles = [];
            mountainRanges = [];
            events = [];
            supercontinentCycles = 0;
            massExtinctions = 0;
            currentTime = 4500;
            
            const vertexCount = vertexHeights.length;
            for (let i = 0; i < vertexCount; i++) {
                const x = originalPositions[i * 3];
                const y = originalPositions[i * 3 + 1];
                const z = originalPositions[i * 3 + 2];
                
                let height = 0;
                height += simplex3D(x * 0.5, y * 0.5, z * 0.5) * 0.5;
                height += simplex3D(x * 1.0, y * 1.0, z * 1.0) * 0.25;
                height = (height + 1) * 0.5;
                vertexHeights[i] = height;
            }
            
            initializePlates();
            updateGlobeGeometry();
            
            document.getElementById('event-log').innerHTML = '';
            logEvent('Simulation reset - New world forming...', 'birth');
        }

        // ============================================
        // ANIMATION LOOP
        // ============================================
        let lastTime = 0;

        function animate(currentTimeMs) {
            currentTimeMs = currentTimeMs || 0;
            requestAnimationFrame(animate);
            
            const deltaTime = Math.min((currentTimeMs - lastTime) / 1000, 0.1);
            lastTime = currentTimeMs;
            
            if (!isPaused) {
                currentTime -= deltaTime * timeSpeed;
                currentTime = Math.max(currentTime, 0);
                
                updatePlates(deltaTime);
                updateVolcanoes(deltaTime);
                updateParticles(deltaTime);
                updateCivilizations(deltaTime);
            }
            
            updateUI();
            controls.update();
            
            if (atmosphereGlow) {
                atmosphereGlow.material.uniforms.viewVector.value = camera.position;
            }
            
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>
