<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ecosystem City - Urban Evolution Simulation</title>
    <meta name="description" content="Living city ecosystem with evolving creatures, human commuters, neural network brains, and realistic traffic simulation.">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; font-family: 'Segoe UI', system-ui, sans-serif; color: white; }

        #loading {
            position: fixed; inset: 0;
            background: linear-gradient(135deg, #0a1628, #1a0a28);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 1000; transition: opacity 0.8s ease;
        }
        #loading.hidden { opacity: 0; pointer-events: none; }
        #loading h1 { font-size: 3em; background: linear-gradient(90deg, #00ff88, #00aaff, #ff00aa); -webkit-background-clip: text; -webkit-text-fill-color: transparent; margin-bottom: 10px; }
        #loading p { color: rgba(255,255,255,0.6); margin-bottom: 30px; }
        .loading-bar { width: 300px; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; overflow: hidden; }
        .loading-fill { height: 100%; background: linear-gradient(90deg, #00ff88, #00aaff); width: 0%; animation: load 2s ease-out forwards; }
        @keyframes load { to { width: 100%; } }
        @keyframes fadeInOut { 0% { opacity: 0; transform: translate(-50%, -50%) scale(0.9); } 10% { opacity: 1; transform: translate(-50%, -50%) scale(1); } 80% { opacity: 1; } 100% { opacity: 0; } }

        #hud { position: absolute; top: 15px; left: 15px; background: rgba(0,0,0,0.85); padding: 15px 20px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1); backdrop-filter: blur(10px); min-width: 200px; }
        #hud h2 { font-size: 1.1em; color: #00ff88; margin-bottom: 12px; }
        .stat-group { margin-bottom: 10px; }
        .stat-group-title { font-size: 0.7em; color: rgba(255,255,255,0.4); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 4px; }
        .stat { display: flex; justify-content: space-between; padding: 2px 0; font-size: 0.85em; }
        .stat-value { font-weight: bold; }
        .stat-value.plants { color: #00ff88; }
        .stat-value.herbivores { color: #00aaff; }
        .stat-value.predators { color: #ff4466; }
        .stat-value.humans { color: #ffdd44; }

        #time-panel { position: absolute; top: 15px; right: 15px; background: rgba(0,0,0,0.85); padding: 12px 20px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1); text-align: center; min-width: 140px; }
        #time-panel .clock { font-size: 2em; font-weight: bold; font-family: 'Courier New', monospace; }
        #time-panel .clock.day { color: #ffdd44; }
        #time-panel .clock.night { color: #6688ff; }
        #time-panel .day-label { font-size: 0.75em; color: rgba(255,255,255,0.5); margin-top: 4px; }
        #traffic-indicator { margin-top: 8px; padding: 4px 8px; border-radius: 8px; font-size: 0.7em; font-weight: bold; }
        #traffic-indicator.low { background: #2a5a2a; color: #88ff88; }
        #traffic-indicator.medium { background: #5a5a2a; color: #ffff88; }
        #traffic-indicator.high { background: #5a2a2a; color: #ff8888; }

        #minimap { position: absolute; bottom: 130px; right: 15px; background: rgba(0,0,0,0.9); border-radius: 8px; border: 2px solid rgba(255,255,255,0.2); overflow: hidden; }
        #minimap canvas { display: block; }
        #minimap-label { position: absolute; top: 4px; left: 6px; font-size: 0.65em; color: rgba(255,255,255,0.5); }

        #graph-panel { position: absolute; bottom: 15px; left: 15px; background: rgba(0,0,0,0.85); padding: 12px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1); }
        #graph-panel h3 { font-size: 0.8em; color: #00aaff; margin-bottom: 8px; }

        #controls { position: absolute; bottom: 15px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.85); padding: 10px 18px; border-radius: 25px; border: 1px solid rgba(255,255,255,0.1); display: flex; gap: 6px; align-items: center; }
        button { background: linear-gradient(135deg, #333, #222); color: white; border: 1px solid rgba(255,255,255,0.1); padding: 7px 14px; cursor: pointer; border-radius: 12px; font-size: 11px; transition: all 0.2s; min-height: 44px; }
        button:hover { background: linear-gradient(135deg, #444, #333); }
        button:focus { outline: 2px solid #00ff88; outline-offset: 2px; }
        button:focus-visible { outline: 2px solid #00ff88; outline-offset: 2px; box-shadow: 0 0 0 4px rgba(0,255,136,0.2); }
        button.active { background: linear-gradient(135deg, #00aa66, #008855); }
        button.active:hover { background: linear-gradient(135deg, #00cc77, #00aa66); box-shadow: 0 2px 8px rgba(0,255,136,0.25); }
        button.danger { background: linear-gradient(135deg, #aa3344, #882233); }
        button.danger:hover { background: linear-gradient(135deg, #cc4455, #aa3344); box-shadow: 0 2px 8px rgba(255,68,102,0.25); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        button:active:not(:disabled) { transform: scale(0.97); }
        .speed-display { background: rgba(255,255,255,0.1); padding: 7px 12px; border-radius: 12px; font-size: 11px; }
        .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border: 0; }
        [role="region"]:focus { outline: 2px solid #00aaff; outline-offset: 2px; }
        .btn-text { display: inline; margin-left: 4px; }
        /* ROUND 22: Progressive disclosure for advanced controls */
        #advanced-controls { display: none; gap: 6px; flex-wrap: wrap; align-items: center; }

        #legend { position: absolute; top: 100px; left: 15px; background: rgba(0,0,0,0.85); padding: 10px 12px; border-radius: 10px; font-size: 0.8em; }
        .legend-item { display: flex; align-items: center; gap: 6px; padding: 3px 0; }
        .legend-dot { width: 10px; height: 10px; border-radius: 50%; }

        #creature-panel { position: absolute; top: 15px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.9); padding: 12px 20px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.15); display: none; min-width: 280px; }
        #creature-panel.visible { display: block; }
        #creature-panel h3 { margin-bottom: 8px; font-size: 1em; }
        .brain-viz { display: flex; gap: 3px; margin-top: 8px; }
        .neuron { width: 6px; height: 6px; border-radius: 50%; background: #333; }
        .neuron.active { background: #00ff88; }

        #instructions { position: absolute; bottom: 65px; left: 15px; font-size: 0.7em; color: rgba(255,255,255,0.4); }
        kbd { background: rgba(255,255,255,0.1); padding: 1px 4px; border-radius: 2px; }

        /* Tooltip for creature hover */
        #hover-tooltip { position: fixed; background: rgba(0,0,0,0.95); padding: 12px 16px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.2); pointer-events: none; z-index: 1000; display: none; min-width: 180px; font-size: 12px; }
        #hover-tooltip.visible { display: block; }
        #hover-tooltip h4 { margin: 0 0 8px 0; color: #00ff88; font-size: 13px; }
        #hover-tooltip .trait-bar { height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; margin: 4px 0; overflow: hidden; }
        #hover-tooltip .trait-fill { height: 100%; border-radius: 3px; transition: width 0.2s; }

        /* Ecosystem Health Dashboard */
        #health-panel { position: absolute; top: 250px; left: 15px; background: rgba(0,0,0,0.85); padding: 12px 16px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.1); min-width: 180px; }
        #health-panel h3 { font-size: 0.85em; color: #00aaff; margin-bottom: 10px; }
        .health-meter { height: 10px; background: rgba(255,255,255,0.1); border-radius: 5px; overflow: hidden; margin: 6px 0; }
        .health-fill { height: 100%; border-radius: 5px; transition: width 0.5s, background 0.5s; }
        .challenge-prompt { font-size: 0.75em; color: rgba(255,255,255,0.6); margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 6px; }

        /* Narrative Event Log */
        #event-log { position: absolute; bottom: 130px; right: 15px; background: rgba(0,0,0,0.85); padding: 12px 16px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.1); width: 240px; max-height: 180px; overflow-y: auto; }
        #event-log h3 { font-size: 0.85em; color: #ffaa00; margin-bottom: 8px; }
        .event-item { font-size: 0.75em; padding: 4px 0; border-bottom: 1px solid rgba(255,255,255,0.05); color: rgba(255,255,255,0.8); }
        .event-item:last-child { border-bottom: none; }
        .event-time { color: rgba(255,255,255,0.4); }

        /* ROUND 9: Mobile Responsive Design */
        @media (max-width: 768px) {
            #hud { left: 5px; top: 5px; padding: 8px 12px; min-width: 140px; font-size: 0.9em; }
            #hud h2 { font-size: 0.95em; margin-bottom: 6px; }
            #time-panel { top: 5px; right: 5px; padding: 8px 12px; min-width: 100px; }
            #time-panel .clock { font-size: 1.4em; }
            #legend { display: none; }
            #health-panel { top: auto; bottom: 160px; left: 5px; padding: 8px 10px; min-width: 140px; }
            #event-log { display: none; }
            #minimap { bottom: 160px; right: 5px; }
            #minimap canvas { width: 120px; height: 120px; }
            #graph-panel { bottom: 60px; left: 5px; padding: 8px; }
            #graph-panel canvas { width: 200px; height: 70px; }
            #controls { padding: 6px 10px; gap: 3px; flex-wrap: wrap; max-width: 95vw; justify-content: center; }
            button { padding: 5px 8px; font-size: 10px; min-height: 36px; }
            .btn-text { display: none; }
            .speed-display { padding: 5px 8px; font-size: 10px; }
            #instructions { display: none; }
            #creature-panel { width: 90vw; max-width: 280px; padding: 10px 15px; }
            #hover-tooltip { display: none !important; }
            #scenario-panel, #params-panel { width: 90vw !important; max-width: 350px !important; padding: 15px !important; }
            #debug-panel { display: none; }
        }

        @media (max-width: 480px) {
            #hud { padding: 6px 8px; min-width: 110px; }
            #health-panel { display: none; }
            #graph-panel { display: none; }
            #minimap { width: 80px; height: 80px; }
            #minimap canvas { width: 80px; height: 80px; }
            button { padding: 4px 6px; min-height: 32px; }
            #controls { bottom: 5px; padding: 5px 8px; }
        }

        /* ROUND 20: Performance Profiler Panel */
        #profiler-panel {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(10, 20, 40, 0.98); padding: 25px; border-radius: 16px;
            border: 2px solid rgba(100, 255, 100, 0.5); width: 450px; max-height: 80vh;
            overflow-y: auto; z-index: 1600; display: none;
        }
        #profiler-panel h3 { color: #64ff64; margin-bottom: 15px; }
        .profiler-stat {
            display: flex; justify-content: space-between; padding: 6px 0;
            font-size: 0.9em; border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .profiler-stat:last-child { border-bottom: none; }
        .profiler-bar {
            height: 20px; background: rgba(255,255,255,0.1); border-radius: 10px;
            overflow: hidden; margin: 8px 0; position: relative;
        }
        .profiler-bar-fill {
            height: 100%; transition: width 0.3s; position: absolute; left: 0;
        }
        .profiler-bar-label {
            position: absolute; left: 8px; top: 50%; transform: translateY(-50%);
            font-size: 0.75em; z-index: 1; text-shadow: 0 0 3px rgba(0,0,0,0.8);
        }
        #profiler-graph {
            width: 100%; height: 120px; background: rgba(0,0,0,0.3);
            border-radius: 8px; margin: 15px 0;
        }
        .profiler-warning {
            background: rgba(255,150,0,0.2); border: 1px solid rgba(255,150,0,0.4);
            padding: 10px; border-radius: 8px; margin-top: 10px; font-size: 0.85em;
        }

        /* ROUND 20: Error Log Panel */
        #error-panel {
            position: absolute; bottom: 80px; right: 15px;
            background: rgba(40, 10, 10, 0.95); padding: 12px 16px;
            border-radius: 10px; border: 2px solid rgba(255, 68, 102, 0.5);
            width: 300px; max-height: 200px; overflow-y: auto; z-index: 500; display: none;
        }
        #error-panel h3 {
            font-size: 0.85em; color: #ff4466; margin-bottom: 8px;
            display: flex; justify-content: space-between; align-items: center;
        }
        .error-entry {
            font-size: 0.75em; padding: 6px; margin-bottom: 6px;
            background: rgba(0,0,0,0.3); border-radius: 6px;
            border-left: 3px solid #ff4466;
        }
        .error-time { color: rgba(255,255,255,0.5); font-size: 0.9em; }
        .error-message { color: rgba(255,200,200,0.9); margin-top: 2px; }
    </style>
</head>
<body>
    <div id="loading">
        <h1>ECOSYSTEM CITY</h1>
        <p>Building city and spawning life...</p>
        <div class="loading-bar"><div class="loading-fill"></div></div>
    </div>

    <div id="hud" role="region" aria-label="Simulation Statistics" tabindex="0">
        <h2>üèôÔ∏è Ecosystem City</h2>
        <div class="stat-group" role="group" aria-label="Population Statistics">
            <div class="stat-group-title">Population</div>
            <div class="stat"><span aria-hidden="true">üåø</span><span> Plants</span><span class="stat-value plants" id="stat-plants" aria-live="polite">0</span></div>
            <div class="stat"><span aria-hidden="true">üê∞</span><span> Herbivores</span><span class="stat-value herbivores" id="stat-herbivores" aria-live="polite">0</span></div>
            <div class="stat"><span aria-hidden="true">ü¶ä</span><span> Predators</span><span class="stat-value predators" id="stat-predators" aria-live="polite">0</span></div>
            <div class="stat"><span aria-hidden="true">üßë</span><span> Humans</span><span class="stat-value humans" id="stat-humans" aria-live="polite">0</span></div>
        </div>
        <div class="stat-group" role="group" aria-label="Traffic Statistics">
            <div class="stat-group-title">Traffic</div>
            <div class="stat"><span>Commuting</span><span class="stat-value" id="stat-commuting" aria-live="polite">0</span></div>
            <div class="stat"><span>At Work</span><span class="stat-value" id="stat-working" aria-live="polite">0</span></div>
            <div class="stat"><span>At Home</span><span class="stat-value" id="stat-home" aria-live="polite">0</span></div>
        </div>
        <div class="stat-group" role="group" aria-label="Evolution Statistics">
            <div class="stat-group-title">Evolution</div>
            <div class="stat"><span>Generation</span><span class="stat-value" id="stat-generation">1</span></div>
            <div class="stat"><span>FPS</span><span class="stat-value" id="stat-fps">60</span></div>
        </div>
    </div>

    <div id="time-panel" role="region" aria-label="Time and Traffic Status" tabindex="0">
        <div class="clock day" id="clock-display" aria-label="Current simulation time">06:00</div>
        <div class="day-label">Day <span id="day-count" aria-live="polite">1</span></div>
        <div id="traffic-indicator" class="low" role="status" aria-live="polite">LOW TRAFFIC</div>
    </div>

    <div id="legend" role="region" aria-label="Map Legend" tabindex="0">
        <div class="legend-item"><div class="legend-dot" style="background:#00ff88" aria-hidden="true"></div><span> Plants (green)</span></div>
        <div class="legend-item"><div class="legend-dot" style="background:#00aaff" aria-hidden="true"></div><span> Herbivores (blue)</span></div>
        <div class="legend-item"><div class="legend-dot" style="background:#ff4466" aria-hidden="true"></div><span> Predators (red)</span></div>
        <div class="legend-item"><div class="legend-dot" style="background:#ffdd44" aria-hidden="true"></div><span> Humans (yellow)</span></div>
        <div class="legend-item"><div class="legend-dot" style="background:#888" aria-hidden="true"></div><span> Buildings (gray)</span></div>
    </div>

    <div id="health-panel" role="region" aria-label="Ecosystem Health">
        <h3>üî¨ Ecosystem Health</h3>
        <div class="stat" style="font-size:0.8em;"><span>Balance</span><span id="health-status">Stable</span></div>
        <div class="health-meter"><div class="health-fill" id="health-fill" style="width:70%;background:#00aa66;"></div></div>
        <div class="stat" style="font-size:0.75em;"><span>Prey/Pred Ratio</span><span id="prey-pred-ratio">3:1</span></div>
        <div class="challenge-prompt" id="challenge-prompt">üî¨ Observe: How do predators affect herbivore populations?</div>
    </div>

    <div id="event-log" role="log" aria-label="Evolution Events" aria-live="polite">
        <h3>üìú Evolution Log</h3>
        <div id="event-list"></div>
    </div>

    <div id="hover-tooltip">
        <h4 id="tooltip-title">Creature</h4>
        <div id="tooltip-content"></div>
    </div>

    <div id="minimap" role="img" aria-label="City minimap showing creature locations">
        <canvas id="minimap-canvas" width="180" height="180" aria-hidden="true"></canvas>
        <div id="minimap-label">CITY MAP</div>
    </div>

    <div id="creature-panel">
        <h3><span id="creature-icon">üê∞</span> <span id="creature-name">Creature</span></h3>
        <div class="stat"><span>Energy</span><span id="creature-energy">100</span></div>
        <div class="stat"><span>Age</span><span id="creature-age">0</span></div>
        <div class="stat"><span>State</span><span id="creature-state">-</span></div>
        <div style="font-size:0.75em;color:rgba(255,255,255,0.5);margin-top:6px;">Neural Activity:</div>
        <div class="brain-viz" id="brain-viz"></div>
    </div>

    <div id="graph-panel" role="region" aria-label="Population History Graph" tabindex="0">
        <h3>Population History</h3>
        <canvas id="population-graph" width="300" height="100" aria-hidden="true"></canvas>
        <p class="sr-only" id="graph-description" aria-live="off">Line graph showing population trends for plants (solid), herbivores (dashed), predators (dotted), and humans (dash-dot).</p>
    </div>

    <!-- ROUND 21: Added aria-keyshortcuts attributes for screen reader accessibility -->
    <div id="controls" role="toolbar" aria-label="Simulation Controls">
        <button id="btn-pause" aria-label="Pause simulation" aria-pressed="false" aria-keyshortcuts="Space" title="Pause/Play (Space)">‚è∏<span class="btn-text">Pause</span></button>
        <button id="btn-speed-down" aria-label="Decrease simulation speed" title="Slower">‚óÄ<span class="btn-text">Slower</span></button>
        <div class="speed-display" id="speed-display" role="status" aria-live="polite" aria-label="Current speed">1x</div>
        <button id="btn-speed-up" aria-label="Increase simulation speed" title="Faster">‚ñ∂<span class="btn-text">Faster</span></button>
        <button id="btn-spawn-human" aria-label="Spawn 10 humans" title="Spawn Humans">+<span aria-hidden="true">üßë</span><span class="btn-text">Human</span></button>
        <button id="btn-spawn-herb" aria-label="Spawn 5 herbivores" title="Spawn Herbivores">+<span aria-hidden="true">üê∞</span><span class="btn-text">Herbivore</span></button>
        <button id="btn-spawn-pred" aria-label="Spawn 3 predators" title="Spawn Predators">+<span aria-hidden="true">ü¶ä</span><span class="btn-text">Predator</span></button>
        <button id="btn-rush-hour" class="active" aria-label="Toggle rush hour mode" aria-pressed="true" title="Rush Hour Mode">Rush Hour</button>
        <button id="btn-save" aria-label="Save simulation" title="Save Simulation">üíæ<span class="btn-text">Save</span></button>
        <button id="btn-load" aria-label="Load simulation" title="Load Simulation">üìÇ<span class="btn-text">Load</span></button>
        <button id="btn-screenshot" aria-label="Take screenshot" title="Take Screenshot">üì∏<span class="btn-text">Share</span></button>
        <button id="btn-scenarios" aria-label="Load preset scenarios" title="Load Scenarios">üéÆ<span class="btn-text">Scenarios</span></button>
        <button id="btn-params" aria-label="Adjust simulation parameters" title="Adjust Parameters">‚öô<span class="btn-text">Params</span></button>
        <button id="btn-lab" aria-label="Start educational lab mode" title="Lab Mode">üî¨<span class="btn-text">Lab</span></button>
        <button id="btn-lineage" aria-label="View creature lineage" title="View DNA Lineage">üß¨<span class="btn-text">DNA</span></button>
        <button id="btn-challenges" aria-label="View ecosystem challenges" title="View Challenges">üèÜ<span class="btn-text">Goals</span></button>
        <button id="btn-heatmap" aria-label="Toggle heatmap overlay" aria-pressed="false" aria-keyshortcuts="h" title="Toggle Heatmap (H)">üî•<span class="btn-text">Heat</span></button>
        <button id="btn-help" aria-label="Show tutorial and help" aria-keyshortcuts="?" title="Help & Shortcuts (?)">‚ùì<span class="btn-text">Help</span></button>
        <button id="btn-sound" aria-label="Toggle sound" aria-pressed="false" aria-keyshortcuts="s" title="Toggle Sound (S)">üîá<span class="btn-text">Sound</span></button>
        <button id="btn-undo" aria-label="Undo last destructive action" disabled aria-keyshortcuts="Control+z Meta+z" title="Undo (Ctrl+Z)">‚Ü©Ô∏è<span class="btn-text">Undo</span></button>
        <!-- ROUND 22: Progressive disclosure - Advanced buttons in collapsible section -->
        <button id="btn-toggle-advanced" aria-label="Show advanced controls" aria-expanded="false" title="Advanced Controls">‚öôÔ∏è<span class="btn-text">More</span></button>
        <div id="advanced-controls" style="display:none;background:rgba(255,255,255,0.05);border-radius:12px;padding:6px;margin-left:-6px;">
            <button id="btn-export" aria-label="Export experiment data" title="Export Data">üìä<span class="btn-text">Export</span></button>
            <button id="btn-share-dna" aria-label="Share creature DNA" title="Share DNA">üîó<span class="btn-text">Share</span></button>
            <button id="btn-assistant" aria-label="Smart lab assistant" title="Lab Assistant">ü§ñ<span class="btn-text">AI</span></button>
            <button id="btn-weather" aria-label="Weather controls" aria-keyshortcuts="w" title="Weather Controls (W)">üå¶<span class="btn-text">Weather</span></button>
            <button id="btn-chronicle" aria-label="View evolutionary chronicle" title="View Chronicle">üìú<span class="btn-text">Story</span></button>
            <button id="btn-cinema" aria-label="Cinema mode" aria-pressed="false" aria-keyshortcuts="c" title="Cinema Mode (C)">üé¨<span class="btn-text">Film</span></button>
            <button id="btn-profiler" aria-label="Show performance profiler" aria-pressed="false" aria-keyshortcuts="p" title="Performance Profiler (P)">‚ö°<span class="btn-text">Profiler</span></button>
            <button id="btn-apocalypse" class="danger" aria-label="Trigger catastrophic event" title="Apocalypse Event">üíÄ<span class="btn-text">Apocalypse</span></button>
        </div>
    </div>

    <!-- ROUND 10: Educational Lab Mode Panel -->
    <div id="lab-panel" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(10,20,40,0.98);padding:25px;border-radius:16px;border:2px solid rgba(0,255,136,0.5);width:400px;max-height:80vh;overflow-y:auto;z-index:1600;display:none;">
        <h3 style="color:#00ff88;margin-bottom:15px;">üî¨ Science Lab Mode</h3>
        <p style="font-size:0.85em;color:rgba(255,255,255,0.7);margin-bottom:15px;">Run structured experiments and collect data!</p>
        <div id="experiment-list" style="display:grid;gap:12px;"></div>
        <div id="lab-active" style="display:none;margin-top:15px;padding:15px;background:rgba(0,255,136,0.1);border-radius:10px;">
            <h4 id="lab-experiment-title" style="color:#00ff88;margin-bottom:8px;">Experiment</h4>
            <p id="lab-hypothesis" style="font-size:0.85em;margin-bottom:10px;"></p>
            <div style="display:flex;gap:8px;margin-bottom:10px;">
                <div style="flex:1;text-align:center;padding:8px;background:rgba(0,0,0,0.3);border-radius:6px;">
                    <div style="font-size:0.7em;color:rgba(255,255,255,0.5);">Start</div>
                    <div id="lab-start-val" style="font-size:1.2em;font-weight:bold;">-</div>
                </div>
                <div style="flex:1;text-align:center;padding:8px;background:rgba(0,0,0,0.3);border-radius:6px;">
                    <div style="font-size:0.7em;color:rgba(255,255,255,0.5);">Current</div>
                    <div id="lab-current-val" style="font-size:1.2em;font-weight:bold;">-</div>
                </div>
                <div style="flex:1;text-align:center;padding:8px;background:rgba(0,0,0,0.3);border-radius:6px;">
                    <div style="font-size:0.7em;color:rgba(255,255,255,0.5);">Time</div>
                    <div id="lab-time" style="font-size:1.2em;font-weight:bold;">0s</div>
                </div>
            </div>
            <button id="btn-end-experiment" style="width:100%;padding:10px;background:rgba(255,68,102,0.3);border:1px solid rgba(255,68,102,0.5);border-radius:8px;color:white;cursor:pointer;">End Experiment & Record Results</button>
        </div>
        <button id="btn-close-lab" style="margin-top:15px;width:100%;padding:10px;background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.2);border-radius:8px;color:white;cursor:pointer;">Close Lab</button>
    </div>

    <!-- Screen Reader Announcements -->
    <div id="sr-announcements" aria-live="assertive" aria-atomic="true" class="sr-only"></div>

    <!-- ROUND 20: Performance Profiler Panel -->
    <div id="profiler-panel">
        <h3>‚ö° Performance Profiler</h3>
        <p style="font-size:0.85em;color:rgba(255,255,255,0.7);margin-bottom:15px;">Real-time frame budget breakdown</p>
        <div id="profiler-current-frame" style="background:rgba(0,0,0,0.3);padding:12px;border-radius:8px;margin-bottom:15px;">
            <div style="font-size:0.75em;color:rgba(255,255,255,0.5);margin-bottom:8px;">FRAME TIME BREAKDOWN</div>
            <div class="profiler-stat"><span>üé® Three.js Render</span><span id="prof-render">0ms</span></div>
            <div class="profiler-stat"><span>üåç World Update</span><span id="prof-world">0ms</span></div>
            <div class="profiler-stat"><span>üìä DOM Updates</span><span id="prof-dom">0ms</span></div>
            <div class="profiler-stat"><span>üí§ Idle Time</span><span id="prof-idle">0ms</span></div>
            <div class="profiler-stat" style="font-weight:bold;color:#64ff64;"><span>‚è± Total Frame</span><span id="prof-total">0ms</span></div>
        </div>
        <div>
            <div style="font-size:0.75em;color:rgba(255,255,255,0.5);margin-bottom:8px;">FRAME BUDGET (16.67ms @ 60fps)</div>
            <div class="profiler-bar">
                <div class="profiler-bar-fill" id="prof-bar-render" style="background:#ff6600;width:0%;"></div>
                <div class="profiler-bar-fill" id="prof-bar-world" style="background:#ffaa00;left:0%;width:0%;"></div>
                <div class="profiler-bar-fill" id="prof-bar-dom" style="background:#00aaff;left:0%;width:0%;"></div>
            </div>
        </div>
        <canvas id="profiler-graph" width="400" height="120" role="img" aria-label="Performance profiler frame time graph"></canvas>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:15px;">
            <div style="text-align:center;padding:10px;background:rgba(0,0,0,0.3);border-radius:8px;">
                <div style="font-size:0.7em;color:rgba(255,255,255,0.5);">Avg FPS</div>
                <div id="prof-avg-fps" style="font-size:1.3em;font-weight:bold;color:#64ff64;">60</div>
            </div>
            <div style="text-align:center;padding:10px;background:rgba(0,0,0,0.3);border-radius:8px;">
                <div style="font-size:0.7em;color:rgba(255,255,255,0.5);">Memory (MB)</div>
                <div id="prof-memory" style="font-size:1.3em;font-weight:bold;color:#00aaff;">0</div>
            </div>
        </div>
        <div id="prof-warnings"></div>
        <div style="display:flex;gap:10px;margin-top:15px;">
            <button id="btn-export-profile" style="flex:1;padding:10px;background:rgba(100,255,100,0.2);border:1px solid rgba(100,255,100,0.4);border-radius:8px;color:white;cursor:pointer;">üìä Export Data</button>
            <button id="btn-close-profiler" style="flex:1;padding:10px;background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.2);border-radius:8px;color:white;cursor:pointer;">Close</button>
        </div>
    </div>

    <!-- ROUND 20: Error Log Panel -->
    <div id="error-panel">
        <h3>
            <span>‚ö†Ô∏è Error Log</span>
            <button id="btn-clear-errors" style="background:none;border:none;color:#ff4466;cursor:pointer;font-size:0.9em;padding:0;">Clear</button>
        </h3>
        <div id="error-list"></div>
        <button id="btn-export-errors" style="width:100%;margin-top:8px;padding:6px;background:rgba(255,68,102,0.2);border:1px solid rgba(255,68,102,0.4);border-radius:6px;color:white;cursor:pointer;font-size:0.75em;">üìã Export for Bug Report</button>
    </div>

    <!-- ROUND 11: Lineage Panel -->
    <div id="lineage-panel" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(10,20,40,0.98);padding:25px;border-radius:16px;border:2px solid rgba(170,136,255,0.5);width:450px;max-height:85vh;overflow-y:auto;z-index:1600;display:none;">
        <h3 style="color:#aa88ff;margin-bottom:15px;">üß¨ Creature Lineage</h3>
        <div id="lineage-creature-info" style="background:rgba(170,136,255,0.1);padding:15px;border-radius:10px;margin-bottom:15px;">
            <div style="display:flex;justify-content:space-between;margin-bottom:10px;">
                <span id="lineage-type" style="font-weight:bold;font-size:1.1em;"></span>
                <span id="lineage-gen" style="color:rgba(255,255,255,0.6);"></span>
            </div>
            <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;font-size:0.85em;">
                <div>‚è± Age: <span id="lineage-age">0</span>s</div>
                <div>‚ö° Energy: <span id="lineage-energy">0</span></div>
                <div>üìç Distance: <span id="lineage-dist">0</span>m</div>
                <div>üçé Food: <span id="lineage-food">0</span></div>
                <div>üë∂ Offspring: <span id="lineage-offspring">0</span></div>
                <div>üèÉ Speed: <span id="lineage-speed">0</span></div>
            </div>
        </div>
        <div id="lineage-tree" style="background:rgba(0,0,0,0.3);padding:15px;border-radius:10px;text-align:center;min-height:100px;">
            <div style="font-size:0.8em;color:rgba(255,255,255,0.5);margin-bottom:10px;">Family Tree</div>
            <div id="lineage-tree-display"></div>
        </div>
        <p style="font-size:0.75em;color:rgba(255,255,255,0.5);margin-top:10px;">Click any creature to view lineage</p>
        <button id="btn-close-lineage" style="margin-top:15px;width:100%;padding:10px;background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.2);border-radius:8px;color:white;cursor:pointer;">Close</button>
    </div>

    <!-- ROUND 11: Challenges Panel -->
    <div id="challenges-panel" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(10,20,40,0.98);padding:25px;border-radius:16px;border:2px solid rgba(255,215,0,0.5);width:400px;z-index:1600;display:none;">
        <h3 style="color:#ffd700;margin-bottom:15px;">üèÜ Ecosystem Challenges</h3>
        <div id="challenge-list" style="display:grid;gap:10px;"></div>
        <div id="active-challenge" style="display:none;margin-top:15px;padding:15px;background:rgba(255,215,0,0.1);border-radius:10px;">
            <h4 id="challenge-title" style="color:#ffd700;"></h4>
            <p id="challenge-desc" style="font-size:0.85em;margin:8px 0;"></p>
            <div style="background:rgba(0,0,0,0.3);border-radius:6px;height:20px;overflow:hidden;">
                <div id="challenge-progress-bar" style="height:100%;background:linear-gradient(90deg,#ffd700,#ff8800);width:0%;transition:width 0.3s;"></div>
            </div>
            <div style="display:flex;justify-content:space-between;font-size:0.8em;margin-top:5px;">
                <span id="challenge-current">0</span>
                <span id="challenge-target">100</span>
            </div>
        </div>
        <button id="btn-close-challenges" style="margin-top:15px;width:100%;padding:10px;background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.2);border-radius:8px;color:white;cursor:pointer;">Close</button>
    </div>

    <!-- ROUND 11: Heatmap Canvas Overlay -->
    <canvas id="heatmap-canvas" aria-hidden="true" style="position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;opacity:0.5;display:none;z-index:10;"></canvas>

    <!-- ROUND 13: Tutorial/Help Panel -->
    <div id="tutorial-panel" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(10,20,40,0.98);padding:30px;border-radius:16px;border:2px solid rgba(100,200,255,0.5);width:500px;max-height:85vh;overflow-y:auto;z-index:2000;display:none;">
        <h3 style="color:#64c8ff;margin-bottom:20px;text-align:center;">üèôÔ∏è Welcome to Ecosystem City!</h3>
        <div id="tutorial-steps">
            <div class="tutorial-step" data-step="1" style="margin-bottom:20px;padding:15px;background:rgba(100,200,255,0.1);border-radius:10px;">
                <h4 style="color:#00ff88;margin-bottom:8px;">üåø Step 1: Observe the Ecosystem</h4>
                <p style="font-size:0.9em;color:rgba(255,255,255,0.8);">Watch creatures interact! <span style="color:#00ff88;">Green plants</span> feed <span style="color:#00aaff;">blue herbivores</span>, which are hunted by <span style="color:#ff4466;">red predators</span>.</p>
            </div>
            <div class="tutorial-step" data-step="2" style="margin-bottom:20px;padding:15px;background:rgba(100,200,255,0.1);border-radius:10px;">
                <h4 style="color:#ff8800;margin-bottom:8px;">üéÆ Step 2: Try a Scenario</h4>
                <p style="font-size:0.9em;color:rgba(255,255,255,0.8);">Click <strong>Scenarios</strong> to load preset configurations like "Predator Pressure" or "Peaceful Garden".</p>
            </div>
            <div class="tutorial-step" data-step="3" style="margin-bottom:20px;padding:15px;background:rgba(100,200,255,0.1);border-radius:10px;">
                <h4 style="color:#00ff88;margin-bottom:8px;">üî¨ Step 3: Run an Experiment</h4>
                <p style="font-size:0.9em;color:rgba(255,255,255,0.8);">Click <strong>Lab</strong> to test scientific hypotheses about predator-prey dynamics and natural selection!</p>
            </div>
            <div class="tutorial-step" data-step="4" style="margin-bottom:20px;padding:15px;background:rgba(100,200,255,0.1);border-radius:10px;">
                <h4 style="color:#ffd700;margin-bottom:8px;">üèÜ Step 4: Complete Challenges</h4>
                <p style="font-size:0.9em;color:rgba(255,255,255,0.8);">Click <strong>Goals</strong> for ecosystem challenges like "Reach 50 herbivores" or "Evolve to Generation 10"!</p>
            </div>
            <!-- ROUND 21: Keyboard Shortcuts Reference -->
            <div class="tutorial-step" data-step="5" style="margin-bottom:20px;padding:15px;background:rgba(100,200,255,0.1);border-radius:10px;">
                <h4 style="color:#aa88ff;margin-bottom:12px;">‚å®Ô∏è Step 5: Master Keyboard Shortcuts</h4>
                <p style="font-size:0.85em;color:rgba(255,255,255,0.7);margin-bottom:10px;">Power up your workflow with these shortcuts:</p>
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:6px;font-size:0.85em;">
                    <div><kbd style="background:rgba(255,255,255,0.15);padding:2px 6px;border-radius:4px;">Space</kbd> Pause/Play</div>
                    <div><kbd style="background:rgba(255,255,255,0.15);padding:2px 6px;border-radius:4px;">C</kbd> Cinema Mode</div>
                    <div><kbd style="background:rgba(255,255,255,0.15);padding:2px 6px;border-radius:4px;">H</kbd> Heatmap</div>
                    <div><kbd style="background:rgba(255,255,255,0.15);padding:2px 6px;border-radius:4px;">P</kbd> Profiler</div>
                    <div><kbd style="background:rgba(255,255,255,0.15);padding:2px 6px;border-radius:4px;">S</kbd> Sound Toggle</div>
                    <div><kbd style="background:rgba(255,255,255,0.15);padding:2px 6px;border-radius:4px;">W</kbd> Weather</div>
                    <div><kbd style="background:rgba(255,255,255,0.15);padding:2px 6px;border-radius:4px;">Tab</kbd> Next Creature</div>
                    <div><kbd style="background:rgba(255,255,255,0.15);padding:2px 6px;border-radius:4px;">Ctrl+Z</kbd> Undo</div>
                    <div><kbd style="background:rgba(255,255,255,0.15);padding:2px 6px;border-radius:4px;">Esc</kbd> Exit Cinema</div>
                    <div><kbd style="background:rgba(255,255,255,0.15);padding:2px 6px;border-radius:4px;">1-5</kbd> Sim Speed</div>
                    <div><kbd style="background:rgba(255,255,255,0.15);padding:2px 6px;border-radius:4px;">WASD</kbd> Camera</div>
                    <div><kbd style="background:rgba(255,255,255,0.15);padding:2px 6px;border-radius:4px;">Arrows</kbd> Creatures</div>
                </div>
                <p style="font-size:0.75em;color:rgba(255,255,255,0.5);margin-top:10px;font-style:italic;">üí° Tip: Press <strong>?</strong> anytime to reopen this help panel!</p>
            </div>
        </div>
        <div style="display:flex;gap:10px;margin-top:15px;">
            <button id="btn-dont-show" style="flex:1;padding:10px;background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.2);border-radius:8px;color:rgba(255,255,255,0.6);cursor:pointer;font-size:0.85em;">Don't show again</button>
            <button id="btn-close-tutorial" style="flex:2;padding:12px;background:linear-gradient(135deg,#00aa66,#008855);border:none;border-radius:8px;color:white;cursor:pointer;font-weight:bold;">Start Exploring!</button>
        </div>
    </div>

    <!-- ROUND 13: Error Overlay -->
    <div id="error-overlay" style="position:fixed;inset:0;background:rgba(0,0,0,0.95);display:none;flex-direction:column;align-items:center;justify-content:center;z-index:3000;">
        <h2 style="color:#ff4466;margin-bottom:15px;">‚ö†Ô∏è Rendering Error</h2>
        <p id="error-message" style="color:rgba(255,255,255,0.8);margin-bottom:20px;text-align:center;max-width:400px;"></p>
        <button id="btn-reload" style="padding:12px 30px;background:#00aaff;border:none;border-radius:8px;color:white;cursor:pointer;font-size:1em;">Reload Page</button>
    </div>

    <!-- ROUND 15: DNA Sharing Panel -->
    <div id="share-panel" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(10,20,40,0.98);padding:25px;border-radius:16px;border:2px solid rgba(0,200,255,0.5);width:400px;z-index:1600;display:none;">
        <h3 style="color:#00c8ff;margin-bottom:15px;">üîó Share Champion DNA</h3>
        <p style="font-size:0.85em;color:rgba(255,255,255,0.7);margin-bottom:15px;">Share your best creature's genetics with others!</p>
        <div id="share-creature-info" style="background:rgba(0,200,255,0.1);padding:12px;border-radius:8px;margin-bottom:15px;display:none;">
            <div id="share-creature-stats"></div>
        </div>
        <div style="margin-bottom:15px;">
            <label style="font-size:0.8em;color:rgba(255,255,255,0.6);">Shareable Link:</label>
            <input type="text" id="share-url" readonly style="width:100%;padding:10px;background:rgba(0,0,0,0.4);border:1px solid rgba(255,255,255,0.2);border-radius:6px;color:white;font-size:0.85em;margin-top:5px;">
        </div>
        <div style="display:flex;gap:10px;">
            <button id="btn-copy-url" style="flex:1;padding:10px;background:rgba(0,200,255,0.3);border:1px solid rgba(0,200,255,0.5);border-radius:8px;color:white;cursor:pointer;">üìã Copy Link</button>
            <button id="btn-close-share" style="flex:1;padding:10px;background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.2);border-radius:8px;color:white;cursor:pointer;">Close</button>
        </div>
    </div>

    <!-- ROUND 15: Smart Lab Assistant Panel -->
    <div id="assistant-panel" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(10,20,40,0.98);padding:25px;border-radius:16px;border:2px solid rgba(255,100,200,0.5);width:450px;max-height:80vh;overflow-y:auto;z-index:1600;display:none;">
        <h3 style="color:#ff64c8;margin-bottom:15px;">ü§ñ Lab Assistant</h3>
        <p style="font-size:0.85em;color:rgba(255,255,255,0.7);margin-bottom:15px;">AI-powered insights about your ecosystem!</p>
        <div id="assistant-insights" style="display:grid;gap:12px;"></div>
        <div id="assistant-empty" style="text-align:center;padding:20px;color:rgba(255,255,255,0.5);">Analyzing ecosystem...</div>
        <button id="btn-refresh-insights" style="margin-top:15px;width:100%;padding:10px;background:rgba(255,100,200,0.2);border:1px solid rgba(255,100,200,0.4);border-radius:8px;color:white;cursor:pointer;">üîÑ Refresh Analysis</button>
        <button id="btn-close-assistant" style="margin-top:10px;width:100%;padding:10px;background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.2);border-radius:8px;color:white;cursor:pointer;">Close</button>
    </div>

    <!-- ROUND 16: Weather Control Panel -->
    <div id="weather-panel" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(10,20,40,0.98);padding:25px;border-radius:16px;border:2px solid rgba(100,180,255,0.5);width:350px;z-index:1600;display:none;">
        <h3 style="color:#64b4ff;margin-bottom:15px;">üå¶ Weather Control</h3>
        <div style="display:grid;gap:10px;margin-bottom:15px;">
            <button class="weather-btn" data-weather="clear" style="padding:12px;background:rgba(255,200,50,0.2);border:1px solid rgba(255,200,50,0.4);border-radius:8px;color:white;cursor:pointer;">‚òÄÔ∏è Clear Skies</button>
            <button class="weather-btn" data-weather="rain" style="padding:12px;background:rgba(100,150,255,0.2);border:1px solid rgba(100,150,255,0.4);border-radius:8px;color:white;cursor:pointer;">üåß Rain Storm</button>
            <button class="weather-btn" data-weather="drought" style="padding:12px;background:rgba(255,100,50,0.2);border:1px solid rgba(255,100,50,0.4);border-radius:8px;color:white;cursor:pointer;">üèú Drought</button>
            <button class="weather-btn" data-weather="snow" style="padding:12px;background:rgba(200,220,255,0.2);border:1px solid rgba(200,220,255,0.4);border-radius:8px;color:white;cursor:pointer;">‚ùÑÔ∏è Snowfall</button>
        </div>
        <div id="weather-status" style="text-align:center;padding:10px;background:rgba(0,0,0,0.3);border-radius:8px;margin-bottom:15px;">
            <span id="current-weather">‚òÄÔ∏è Clear</span>
        </div>
        <button id="btn-close-weather" style="width:100%;padding:10px;background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.2);border-radius:8px;color:white;cursor:pointer;">Close</button>
    </div>

    <!-- ROUND 16: Evolutionary Chronicle Panel -->
    <div id="chronicle-panel" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(10,20,40,0.98);padding:25px;border-radius:16px;border:2px solid rgba(200,150,100,0.5);width:500px;max-height:80vh;overflow-y:auto;z-index:1600;display:none;">
        <h3 style="color:#c89664;margin-bottom:15px;">üìú Evolutionary Chronicle</h3>
        <p style="font-size:0.85em;color:rgba(255,255,255,0.7);margin-bottom:15px;">The story of your ecosystem's evolution...</p>
        <div id="chronicle-timeline" style="border-left:2px solid rgba(200,150,100,0.5);padding-left:15px;"></div>
        <button id="btn-close-chronicle" style="margin-top:15px;width:100%;padding:10px;background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.2);border-radius:8px;color:white;cursor:pointer;">Close</button>
    </div>

    <!-- ROUND 16: Cinema Mode Overlay -->
    <div id="cinema-overlay" style="position:fixed;top:0;left:0;right:0;padding:20px;background:linear-gradient(180deg,rgba(0,0,0,0.8),transparent);z-index:100;display:none;">
        <div style="display:flex;justify-content:space-between;align-items:center;">
            <div id="cinema-title" style="font-size:1.5em;font-weight:bold;">üé¨ Ecosystem Cinema</div>
            <div id="cinema-stats" style="font-size:0.9em;color:rgba(255,255,255,0.7);"></div>
        </div>
        <div id="cinema-narration" style="margin-top:10px;font-style:italic;color:rgba(255,255,255,0.8);"></div>
    </div>

    <div id="scenario-panel" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(10,20,40,0.98);padding:25px 35px;border-radius:16px;border:2px solid rgba(255,136,0,0.5);max-width:500px;z-index:1600;display:none;">
        <h3 style="color:#ff8800;margin-bottom:15px;">üéÆ Preset Scenarios</h3>
        <div id="scenario-list" style="display:grid;gap:10px;"></div>
        <button id="btn-close-scenarios" style="margin-top:15px;width:100%;padding:10px;background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.2);border-radius:8px;color:white;cursor:pointer;">Cancel</button>
    </div>

    <div id="params-panel" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(10,20,40,0.98);padding:25px;border-radius:16px;border:2px solid rgba(0,170,255,0.5);width:300px;z-index:1600;display:none;">
        <h3 style="color:#00aaff;margin-bottom:15px;">‚öô Simulation Parameters</h3>
        <div style="margin-bottom:15px;">
            <label style="font-size:0.85em;color:rgba(255,255,255,0.8);display:block;margin-bottom:5px;">Plant Growth Rate: <span id="val-plant">1.0x</span></label>
            <input type="range" id="slider-plant" min="0.2" max="3" step="0.1" value="1" style="width:100%;">
        </div>
        <div style="margin-bottom:15px;">
            <label style="font-size:0.85em;color:rgba(255,255,255,0.8);display:block;margin-bottom:5px;">Predator Speed: <span id="val-pred">1.0x</span></label>
            <input type="range" id="slider-pred" min="0.5" max="2" step="0.1" value="1" style="width:100%;">
        </div>
        <div style="margin-bottom:15px;">
            <label style="font-size:0.85em;color:rgba(255,255,255,0.8);display:block;margin-bottom:5px;">Herbivore Speed: <span id="val-herb">1.0x</span></label>
            <input type="range" id="slider-herb" min="0.5" max="2" step="0.1" value="1" style="width:100%;">
        </div>
        <div style="margin-bottom:15px;">
            <label style="font-size:0.85em;color:rgba(255,255,255,0.8);display:block;margin-bottom:5px;">Energy Drain: <span id="val-energy">1.0x</span></label>
            <input type="range" id="slider-energy" min="0.5" max="2" step="0.1" value="1" style="width:100%;">
        </div>
        <div style="display:flex;gap:10px;">
            <button id="btn-reset-params" style="flex:1;padding:10px;background:rgba(255,136,0,0.3);border:1px solid rgba(255,136,0,0.5);border-radius:8px;color:white;cursor:pointer;">Reset</button>
            <button id="btn-close-params" style="flex:1;padding:10px;background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.2);border-radius:8px;color:white;cursor:pointer;">Close</button>
        </div>
    </div>

    <!-- ROUND 21: Updated instructions with help shortcut -->
    <div id="instructions">
        <kbd>WASD</kbd> Move <kbd>Scroll</kbd> Zoom <kbd>Click</kbd> Select <kbd>?</kbd> Help
    </div>

    <div id="debug-panel" style="position:absolute; top:15px; right:200px; background:rgba(0,0,0,0.9); padding:12px 15px; border-radius:10px; border:2px solid #ff6600; font-size:12px; z-index:999;">
        <div style="color:#ff6600; margin-bottom:8px; font-weight:bold;">üîß Align Buildings</div>
        <div style="color:#0f0; font-size:12px;"><kbd style="background:#333;padding:2px 6px;border-radius:3px;">M</kbd> + drag = Move</div>
        <div style="color:#0f0; font-size:12px; margin-bottom:8px;"><kbd style="background:#333;padding:2px 6px;border-radius:3px;">R</kbd> + drag = Rotate</div>
        <div style="color:#fff;">Pos: <span id="offset-display">X:0 Z:0</span></div>
        <div style="color:#fff;">Rot: <span id="rotation-display">0¬∞</span></div>
        <button id="btn-copy-offset" style="margin-top:10px; width:100%; background:#0066ff; border:none; padding:8px; border-radius:6px; color:white; cursor:pointer;">Copy Values</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
// ============================================================
// TRAFFIC DATA - Based on real cellphone mobility patterns
// Normalized hourly traffic density (0-1 scale)
// Source pattern: aggregated urban commute data
// ============================================================
const TRAFFIC_DATA = {
    // Hour: [traffic_density, commute_to_work_probability, commute_home_probability]
    0:  [0.05, 0.00, 0.02],  // Midnight - very low
    1:  [0.03, 0.00, 0.01],
    2:  [0.02, 0.00, 0.00],
    3:  [0.02, 0.00, 0.00],
    4:  [0.03, 0.01, 0.00],
    5:  [0.08, 0.05, 0.00],  // Early risers
    6:  [0.25, 0.25, 0.00],  // Morning rush starts
    7:  [0.65, 0.60, 0.00],  // Peak morning
    8:  [0.85, 0.80, 0.00],  // Peak morning rush
    9:  [0.55, 0.30, 0.00],  // Rush ending
    10: [0.30, 0.05, 0.00],
    11: [0.35, 0.02, 0.02],  // Lunch movement
    12: [0.40, 0.02, 0.02],  // Lunch peak
    13: [0.35, 0.02, 0.02],
    14: [0.30, 0.01, 0.01],
    15: [0.35, 0.00, 0.05],  // Early leavers
    16: [0.55, 0.00, 0.30],  // Evening rush starts
    17: [0.90, 0.00, 0.70],  // Peak evening rush
    18: [0.95, 0.00, 0.85],  // Peak evening
    19: [0.60, 0.00, 0.40],  // Rush ending
    20: [0.35, 0.00, 0.15],
    21: [0.25, 0.00, 0.05],
    22: [0.15, 0.00, 0.03],
    23: [0.08, 0.00, 0.02]
};

function getTrafficLevel(hour) {
    const h = Math.floor(hour) % 24;
    return TRAFFIC_DATA[h];
}

// ============================================================
// ROUND 18: SIMULATION PARAMETERS - MOVED EARLY FOR PROPER INITIALIZATION
// ============================================================
const simParams = { plantGrowth: 1, predSpeed: 1, herbSpeed: 1, energyDrain: 1 };

// ============================================================
// ROUND 18: NOTIFICATION SYSTEM - REPLACES BLOCKING ALERTS
// ============================================================
const NotificationSystem = {
    container: null,
    init() {
        this.container = document.createElement('div');
        this.container.id = 'notification-container';
        this.container.style.cssText = 'position:fixed;top:80px;right:20px;z-index:9999;display:flex;flex-direction:column;gap:10px;max-width:350px;';
        document.body.appendChild(this.container);
    },
    show(message, type = 'info', duration = 4000) {
        if (!this.container) this.init();
        const colors = {
            info: { bg: 'rgba(0,170,255,0.95)', border: '#00aaff' },
            success: { bg: 'rgba(0,200,100,0.95)', border: '#00c864' },
            warning: { bg: 'rgba(255,170,0,0.95)', border: '#ffaa00' },
            error: { bg: 'rgba(255,68,102,0.95)', border: '#ff4466' }
        };
        const style = colors[type] || colors.info;
        const notif = document.createElement('div');
        notif.style.cssText = `background:${style.bg};border:2px solid ${style.border};padding:12px 18px;border-radius:10px;color:white;font-size:13px;box-shadow:0 4px 20px rgba(0,0,0,0.4);animation:slideIn 0.3s ease;white-space:pre-wrap;`;
        notif.textContent = message;
        this.container.appendChild(notif);
        setTimeout(() => {
            notif.style.animation = 'slideOut 0.3s ease';
            setTimeout(() => notif.remove(), 300);
        }, duration);
    }
};

// Add notification animations to document
const notifStyle = document.createElement('style');
notifStyle.textContent = `
    @keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
    @keyframes slideOut { from { transform: translateX(0); opacity: 1; } to { transform: translateX(100%); opacity: 0; } }
`;
document.head.appendChild(notifStyle);

// ============================================================
// ROUND 18: UNDO SYSTEM - FOR DESTRUCTIVE ACTIONS
// ============================================================
const UndoSystem = {
    stack: [],
    maxSize: 10,
    save(label, state) {
        this.stack.push({ label, state, timestamp: Date.now() });
        if (this.stack.length > this.maxSize) this.stack.shift();
        NotificationSystem.show(`üì∏ Snapshot saved: ${label}`, 'info', 2000);
    },
    canUndo() { return this.stack.length > 0; },
    undo(world) {
        if (!this.canUndo()) {
            NotificationSystem.show('Nothing to undo!', 'warning');
            return false;
        }
        const snapshot = this.stack.pop();
        this.restore(world, snapshot.state);
        NotificationSystem.show(`‚Ü©Ô∏è Restored: ${snapshot.label}`, 'success');
        return true;
    },
    restore(world, state) {
        // Restore creatures from snapshot
        world.creatures = [];
        state.creatures.forEach(c => {
            let creature;
            if (c.type === 'plant') creature = new Plant(c.x, c.z);
            else if (c.type === 'herbivore') creature = new Herbivore(c.x, c.z, c.dna);
            else if (c.type === 'predator') creature = new Predator(c.x, c.z, c.dna);
            else if (c.type === 'human') creature = new Human(c.x, c.z);
            if (creature) {
                creature.energy = c.energy;
                creature.age = c.age;
                creature.alive = c.alive;
                world.addCreature(creature);
            }
        });
    },
    createSnapshot(world) {
        return {
            creatures: world.creatures.filter(c => c.alive).map(c => ({
                type: c.type,
                x: c.x,
                z: c.z,
                energy: c.energy,
                age: c.age,
                alive: c.alive,
                dna: c.dna ? { ...c.dna } : null
            }))
        };
    }
};

// ============================================================
// ROUND 21: KEYBOARD SHORTCUTS DOCUMENTATION & ACCESSIBILITY
// ============================================================
// - Added comprehensive keyboard shortcuts section to tutorial panel (Step 5)
// - Added "?" keyboard shortcut to open help/tutorial panel instantly
// - Added aria-keyshortcuts attributes to all buttons with keyboard shortcuts
// - Added title tooltips to all 28 control buttons for progressive discovery
// - Updated instructions panel to show "?" help shortcut
// - Implements Round 20 Dissent D3 (93% confidence) with lightweight approach
// - Devil's Advocate approved: integrated into existing panel (no UI bloat)
// - WCAG 2.1 compliant: aria-keyshortcuts for screen reader users
// ============================================================

// ============================================================
// ROUND 20: PERFORMANCE PROFILER SYSTEM
// ============================================================
const PerformanceProfiler = {
    enabled: false,
    frameHistory: [],
    maxHistory: 60,
    timings: { render: 0, world: 0, dom: 0, total: 0 },
    fpsHistory: [],

    startFrame() {
        this.frameStart = performance.now();
        this.renderStart = null;
        this.worldStart = null;
        this.domStart = null;
    },

    markRenderStart() { this.renderStart = performance.now(); },
    markRenderEnd() {
        if (this.renderStart) this.timings.render = performance.now() - this.renderStart;
    },

    markWorldStart() { this.worldStart = performance.now(); },
    markWorldEnd() {
        if (this.worldStart) this.timings.world = performance.now() - this.worldStart;
    },

    markDOMStart() { this.domStart = performance.now(); },
    markDOMEnd() {
        if (this.domStart) this.timings.dom = performance.now() - this.domStart;
    },

    endFrame() {
        if (!this.enabled) return;
        this.timings.total = performance.now() - this.frameStart;
        this.frameHistory.push({ ...this.timings });
        if (this.frameHistory.length > this.maxHistory) this.frameHistory.shift();
    },

    updateUI() {
        if (!this.enabled || !document.getElementById('profiler-panel').style.display) return;

        const avg = this.getAverages();
        document.getElementById('prof-render').textContent = avg.render.toFixed(2) + 'ms';
        document.getElementById('prof-world').textContent = avg.world.toFixed(2) + 'ms';
        document.getElementById('prof-dom').textContent = avg.dom.toFixed(2) + 'ms';
        const idle = Math.max(0, 16.67 - avg.total);
        document.getElementById('prof-idle').textContent = idle.toFixed(2) + 'ms';
        document.getElementById('prof-total').textContent = avg.total.toFixed(2) + 'ms';

        // Update bars (percentage of 16.67ms budget)
        const renderPct = (avg.render / 16.67) * 100;
        const worldPct = (avg.world / 16.67) * 100;
        const domPct = (avg.dom / 16.67) * 100;
        document.getElementById('prof-bar-render').style.width = Math.min(100, renderPct) + '%';
        document.getElementById('prof-bar-world').style.cssText = `background:#ffaa00;left:${Math.min(100, renderPct)}%;width:${Math.min(100, worldPct)}%;`;
        document.getElementById('prof-bar-dom').style.cssText = `background:#00aaff;left:${Math.min(100, renderPct + worldPct)}%;width:${Math.min(100, domPct)}%;`;

        // Memory (if available)
        if (performance.memory) {
            const memMB = (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(1);
            document.getElementById('prof-memory').textContent = memMB;
        }

        // Warnings
        const warnings = [];
        if (avg.total > 16.67) warnings.push('‚ö†Ô∏è Frame time exceeds 60fps budget');
        if (avg.render > 10) warnings.push('üé® Rendering is slow - consider reducing creature count');
        if (avg.world > 8) warnings.push('üåç World update is slow - check algorithm efficiency');
        if (avg.dom > 3) warnings.push('üìä DOM updates are expensive - throttle HUD updates more');
        const warnEl = document.getElementById('prof-warnings');
        warnEl.innerHTML = warnings.map(w => `<div class="profiler-warning">${w}</div>`).join('');

        this.drawGraph();
    },

    getAverages() {
        if (this.frameHistory.length === 0) return { render: 0, world: 0, dom: 0, total: 0 };
        const sum = this.frameHistory.reduce((acc, frame) => ({
            render: acc.render + frame.render,
            world: acc.world + frame.world,
            dom: acc.dom + frame.dom,
            total: acc.total + frame.total
        }), { render: 0, world: 0, dom: 0, total: 0 });
        const len = this.frameHistory.length;
        return {
            render: sum.render / len,
            world: sum.world / len,
            dom: sum.dom / len,
            total: sum.total / len
        };
    },

    drawGraph() {
        const canvas = document.getElementById('profiler-graph');
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (this.frameHistory.length < 2) return;

        // Draw 16.67ms budget line
        ctx.strokeStyle = 'rgba(255,100,100,0.5)';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.moveTo(0, 60);
        ctx.lineTo(canvas.width, 60);
        ctx.stroke();
        ctx.setLineDash([]);

        // Draw frame time history
        ctx.strokeStyle = '#64ff64';
        ctx.lineWidth = 2;
        ctx.beginPath();
        this.frameHistory.forEach((frame, i) => {
            const x = (i / this.maxHistory) * canvas.width;
            const y = canvas.height - (frame.total / 16.67) * canvas.height * 0.5;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        });
        ctx.stroke();
    },

    exportData() {
        const data = {
            timestamp: new Date().toISOString(),
            averages: this.getAverages(),
            frameHistory: this.frameHistory,
            memory: performance.memory ? {
                usedJSHeapSize: performance.memory.usedJSHeapSize,
                totalJSHeapSize: performance.memory.totalJSHeapSize,
                jsHeapSizeLimit: performance.memory.jsHeapSizeLimit
            } : null,
            userAgent: navigator.userAgent
        };
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `ecosystem-profiler-${Date.now()}.json`;
        a.click();
        NotificationSystem.show('üìä Profile data exported!', 'success');
    }
};

// ============================================================
// ROUND 20: ERROR BOUNDARY SYSTEM
// ============================================================
const ErrorBoundary = {
    errors: [],
    maxErrors: 20,
    errorCounts: {}, // Track how many times each error occurs

    init() {
        // Global error handler
        window.onerror = (message, source, lineno, colno, error) => {
            this.logError({
                message: message,
                source: source,
                line: lineno,
                column: colno,
                stack: error ? error.stack : 'No stack trace',
                timestamp: new Date().toISOString()
            });
            return true; // Prevent default browser error handling
        };

        // Unhandled promise rejections
        window.addEventListener('unhandledrejection', (event) => {
            this.logError({
                message: 'Unhandled Promise Rejection: ' + event.reason,
                source: 'Promise',
                stack: event.reason && event.reason.stack ? event.reason.stack : 'No stack trace',
                timestamp: new Date().toISOString()
            });
        });
    },

    logError(errorData) {
        // Count error frequency
        const errorKey = errorData.message.substring(0, 100);
        this.errorCounts[errorKey] = (this.errorCounts[errorKey] || 0) + 1;

        // If same error occurs > 5 times, suppress to avoid spam
        if (this.errorCounts[errorKey] > 5) {
            console.warn('Suppressing repeated error:', errorKey);
            return;
        }

        this.errors.push(errorData);
        if (this.errors.length > this.maxErrors) this.errors.shift();

        // Show error panel
        document.getElementById('error-panel').style.display = 'block';
        this.updateUI();

        // Show notification for first occurrence
        if (this.errorCounts[errorKey] === 1) {
            NotificationSystem.show('‚ö†Ô∏è Error logged. Check error panel.', 'error', 4000);
        }

        // Log to console for debugging
        console.error('ErrorBoundary caught:', errorData);
    },

    updateUI() {
        const list = document.getElementById('error-list');
        if (!list) return;

        list.innerHTML = this.errors.slice(-10).reverse().map(err => {
            const time = new Date(err.timestamp).toLocaleTimeString();
            return `
                <div class="error-entry">
                    <div class="error-time">${time}</div>
                    <div class="error-message">${this.escapeHtml(err.message)}</div>
                </div>
            `;
        }).join('');
    },

    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    },

    exportErrors() {
        const data = {
            timestamp: new Date().toISOString(),
            errors: this.errors,
            errorCounts: this.errorCounts,
            userAgent: navigator.userAgent,
            url: window.location.href
        };
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `ecosystem-errors-${Date.now()}.json`;
        a.click();
        NotificationSystem.show('üìã Error log exported for bug report!', 'success');
    },

    clearErrors() {
        this.errors = [];
        this.errorCounts = {};
        this.updateUI();
        document.getElementById('error-panel').style.display = 'none';
        NotificationSystem.show('Errors cleared', 'info', 2000);
    }
};

ErrorBoundary.init();

// ============================================================
// ROUND 20: LOCALSTORAGE SAFETY SYSTEM
// ============================================================
const StorageSafety = {
    version: '2.0', // Increment when save format changes

    checkQuota() {
        try {
            // Estimate available quota
            if (navigator.storage && navigator.storage.estimate) {
                navigator.storage.estimate().then(estimate => {
                    const usedPct = (estimate.usage / estimate.quota) * 100;
                    if (usedPct > 80) {
                        NotificationSystem.show('‚ö†Ô∏è Storage quota at ' + usedPct.toFixed(0) + '%. Consider clearing old saves.', 'warning', 6000);
                    }
                });
            }
        } catch (e) {
            console.warn('Could not check storage quota:', e);
        }
    },

    safeSet(key, value) {
        try {
            // Add version and timestamp
            const dataWithMeta = {
                version: this.version,
                timestamp: Date.now(),
                data: value
            };
            const json = JSON.stringify(dataWithMeta);
            localStorage.setItem(key, json);
            return true;
        } catch (e) {
            if (e.name === 'QuotaExceededError') {
                NotificationSystem.show('‚ùå Storage quota exceeded! Cannot save. Try exporting data instead.', 'error', 6000);
                ErrorBoundary.logError({
                    message: 'QuotaExceededError: ' + e.message,
                    source: 'StorageSafety.safeSet',
                    stack: e.stack,
                    timestamp: new Date().toISOString()
                });
            } else {
                ErrorBoundary.logError({
                    message: 'LocalStorage save failed: ' + e.message,
                    source: 'StorageSafety.safeSet',
                    stack: e.stack,
                    timestamp: new Date().toISOString()
                });
            }
            return false;
        }
    },

    safeGet(key) {
        try {
            const json = localStorage.getItem(key);
            if (!json) return null;

            const parsed = JSON.parse(json);

            // Check if it's new format with version
            if (parsed.version) {
                // Version mismatch warning
                if (parsed.version !== this.version) {
                    NotificationSystem.show('‚ö†Ô∏è Save file from different version (' + parsed.version + '). May not load correctly.', 'warning', 5000);
                }
                return parsed.data;
            }

            // Legacy format without version
            return parsed;
        } catch (e) {
            NotificationSystem.show('‚ùå Corrupted save data detected. Cannot load.', 'error', 5000);
            ErrorBoundary.logError({
                message: 'LocalStorage parse error: ' + e.message,
                source: 'StorageSafety.safeGet',
                stack: e.stack,
                timestamp: new Date().toISOString()
            });
            return null;
        }
    },

    validateSaveData(data) {
        // Basic validation
        if (!data) return false;
        if (!data.creatures || !Array.isArray(data.creatures)) return false;
        if (typeof data.timeOfDay !== 'number') return false;
        if (typeof data.dayCount !== 'number') return false;
        return true;
    }
};

// Check quota on page load
setTimeout(() => StorageSafety.checkQuota(), 3000);

// ============================================================
// SPATIAL GRID - O(1) creature lookup instead of O(n¬≤)
// ============================================================
class SpatialGrid {
    constructor(cellSize = 20, worldSize = 200) {
        this.cellSize = cellSize;
        this.worldSize = worldSize;
        this.gridCount = Math.ceil(worldSize / cellSize);
        this.cells = new Map();
    }

    getKey(x, z) {
        const cx = Math.floor((x + this.worldSize / 2) / this.cellSize);
        const cz = Math.floor((z + this.worldSize / 2) / this.cellSize);
        return `${cx},${cz}`;
    }

    add(creature) {
        const key = this.getKey(creature.x, creature.z);
        if (!this.cells.has(key)) this.cells.set(key, new Set());
        this.cells.get(key).add(creature);
        creature._gridKey = key;
    }

    remove(creature) {
        if (creature._gridKey && this.cells.has(creature._gridKey)) {
            this.cells.get(creature._gridKey).delete(creature);
        }
    }

    update(creature) {
        const newKey = this.getKey(creature.x, creature.z);
        if (newKey !== creature._gridKey) {
            this.remove(creature);
            this.add(creature);
        }
    }

    getNearby(x, z, radius = 25) {
        const nearby = [];
        const cellRadius = Math.ceil(radius / this.cellSize);
        const cx = Math.floor((x + this.worldSize / 2) / this.cellSize);
        const cz = Math.floor((z + this.worldSize / 2) / this.cellSize);

        for (let dx = -cellRadius; dx <= cellRadius; dx++) {
            for (let dz = -cellRadius; dz <= cellRadius; dz++) {
                const key = `${cx + dx},${cz + dz}`;
                if (this.cells.has(key)) {
                    nearby.push(...this.cells.get(key));
                }
            }
        }
        return nearby;
    }

    clear() {
        this.cells.clear();
    }
}

// ============================================================
// NEURAL NETWORK
// ============================================================
class NeuralNetwork {
    constructor(inputSize, hiddenSize, outputSize) {
        this.inputSize = inputSize;
        this.hiddenSize = hiddenSize;
        this.outputSize = outputSize;
        this.weightsIH = this.randomMatrix(hiddenSize, inputSize);
        this.weightsHO = this.randomMatrix(outputSize, hiddenSize);
        this.biasH = this.randomArray(hiddenSize);
        this.biasO = this.randomArray(outputSize);
        this.lastActivations = [];
    }
    randomMatrix(rows, cols) { return Array(rows).fill().map(() => Array(cols).fill().map(() => (Math.random() - 0.5) * 2)); }
    randomArray(size) { return Array(size).fill().map(() => (Math.random() - 0.5) * 2); }
    forward(inputs) {
        const hidden = this.biasH.map((bias, i) => {
            let sum = bias;
            for (let j = 0; j < inputs.length; j++) sum += inputs[j] * this.weightsIH[i][j];
            return Math.tanh(sum);
        });
        const outputs = this.biasO.map((bias, i) => {
            let sum = bias;
            for (let j = 0; j < hidden.length; j++) sum += hidden[j] * this.weightsHO[i][j];
            return Math.tanh(sum);
        });
        this.lastActivations = [...hidden, ...outputs];
        return outputs;
    }
    mutate(rate = 0.1) {
        const m = v => Math.random() < rate ? v + (Math.random() - 0.5) : v;
        this.weightsIH = this.weightsIH.map(r => r.map(m));
        this.weightsHO = this.weightsHO.map(r => r.map(m));
        this.biasH = this.biasH.map(m);
        this.biasO = this.biasO.map(m);
    }
    clone() {
        const nn = new NeuralNetwork(this.inputSize, this.hiddenSize, this.outputSize);
        nn.weightsIH = this.weightsIH.map(r => [...r]);
        nn.weightsHO = this.weightsHO.map(r => [...r]);
        nn.biasH = [...this.biasH];
        nn.biasO = [...this.biasO];
        return nn;
    }
    static crossover(p1, p2) {
        const c = p1.clone();
        for (let i = 0; i < c.weightsIH.length; i++)
            for (let j = 0; j < c.weightsIH[i].length; j++)
                if (Math.random() < 0.5) c.weightsIH[i][j] = p2.weightsIH[i][j];
        for (let i = 0; i < c.weightsHO.length; i++)
            for (let j = 0; j < c.weightsHO[i].length; j++)
                if (Math.random() < 0.5) c.weightsHO[i][j] = p2.weightsHO[i][j];
        return c;
    }

    toJSON() {
        return {
            inputSize: this.inputSize,
            hiddenSize: this.hiddenSize,
            outputSize: this.outputSize,
            weightsIH: this.weightsIH,
            weightsHO: this.weightsHO,
            biasH: this.biasH,
            biasO: this.biasO
        };
    }

    static fromJSON(json) {
        const nn = new NeuralNetwork(json.inputSize, json.hiddenSize, json.outputSize);
        nn.weightsIH = json.weightsIH;
        nn.weightsHO = json.weightsHO;
        nn.biasH = json.biasH;
        nn.biasO = json.biasO;
        return nn;
    }
}

// ============================================================
// DNA SYSTEM
// ============================================================
class DNA {
    constructor() {
        this.size = 0.5 + Math.random() * 0.5;
        this.speed = 0.5 + Math.random() * 0.5;
        this.vision = 0.5 + Math.random() * 0.5;
        this.metabolism = 0.5 + Math.random() * 0.5;
        this.colorH = Math.random();
    }
    mutate(rate = 0.15) {
        const m = g => Math.random() < rate ? Math.max(0.1, Math.min(1, g + (Math.random() - 0.5) * 0.3)) : g;
        this.size = m(this.size);
        this.speed = m(this.speed);
        this.vision = m(this.vision);
        this.metabolism = m(this.metabolism);
        this.colorH = m(this.colorH);
    }
    clone() { const d = new DNA(); Object.assign(d, this); return d; }
    static crossover(p1, p2) {
        const c = new DNA();
        ['size','speed','vision','metabolism','colorH'].forEach(g => c[g] = Math.random() < 0.5 ? p1[g] : p2[g]);
        return c;
    }

    toJSON() {
        return { size: this.size, speed: this.speed, vision: this.vision, metabolism: this.metabolism, colorH: this.colorH };
    }

    static fromJSON(json) {
        const d = new DNA();
        Object.assign(d, json);
        return d;
    }
}

// ============================================================
// CREATURE CLASSES
// ============================================================
// ROUND 9: OBJECT POOLING SYSTEM FOR PERFORMANCE
// ============================================================
class MeshPool {
    constructor() {
        this.pools = { plant: [], herbivore: [], predator: [], human: [] };
        this.geometryCache = {};
    }

    getGeometry(type, params) {
        const key = `${type}_${JSON.stringify(params)}`;
        if (!this.geometryCache[key]) {
            if (type === 'sphere') {
                this.geometryCache[key] = new THREE.SphereGeometry(params.radius, params.widthSeg || 12, params.heightSeg || 8);
            } else if (type === 'cylinder') {
                this.geometryCache[key] = new THREE.CylinderGeometry(params.radTop, params.radBot, params.height, params.seg || 8);
            } else if (type === 'box') {
                this.geometryCache[key] = new THREE.BoxGeometry(params.w, params.h, params.d);
            }
        }
        return this.geometryCache[key];
    }

    acquire(creatureType) {
        if (this.pools[creatureType] && this.pools[creatureType].length > 0) {
            const mesh = this.pools[creatureType].pop();
            mesh.visible = true;
            return mesh;
        }
        return null; // No pooled mesh available
    }

    release(creatureType, mesh) {
        if (mesh && this.pools[creatureType]) {
            mesh.visible = false;
            this.pools[creatureType].push(mesh);
        }
    }

    getStats() {
        return {
            plant: this.pools.plant.length,
            herbivore: this.pools.herbivore.length,
            predator: this.pools.predator.length,
            human: this.pools.human.length,
            geometries: Object.keys(this.geometryCache).length
        };
    }
}

const meshPool = new MeshPool();

let creatureId = 0;

class Creature {
    constructor(x, z, type, gen = 1) {
        this.id = creatureId++;
        this.type = type;
        this.x = x; this.z = z; this.y = 0;
        this.rotation = Math.random() * Math.PI * 2;
        this.generation = gen;
        this.energy = 100;
        this.age = 0;
        this.alive = true;
        this.dna = new DNA();
        this.brain = new NeuralNetwork(6, 10, 3);
        this.fitness = 0;
        this.mesh = null;
        this.vx = 0; this.vz = 0;
        this.reproCD = 0;
        this.state = 'idle';

        // ROUND 11: Lineage tracking
        this.parentIds = []; // [mother, father] IDs
        this.birthTime = Date.now();
        this.offspring = 0;
        this.foodEaten = 0;
        this.distanceTraveled = 0;
        this.causeOfDeath = null;

        // ROUND 15: Cultural learning
        this.culturalMemory = []; // [{behavior, successRate, source}]
        this.lastSuccessfulAction = null;
        this.observationCooldown = 0;
    }

    createMesh(color) {
        const size = 0.3 + this.dna.size * 0.3;
        const geo = new THREE.SphereGeometry(size, 12, 8);
        const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.6 });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(this.x, size, this.z);
        mesh.castShadow = true;
        this.mesh = mesh;
        this.meshSize = size;
        return mesh;
    }

    update(delta, world) {
        if (!this.alive) return;
        this.age += delta;
        this.energy -= (0.3 + this.dna.metabolism * 0.3) * delta;
        this.reproCD -= delta;

        if (this.energy <= 0 || this.age > 80) { this.die(); return; }

        const inputs = this.sense(world);
        const [fwd, turn, action] = this.brain.forward(inputs);

        const speed = (1 + this.dna.speed) * 4;
        this.rotation += turn * 3 * delta;
        const move = (fwd + 1) / 2;

        let newX = this.x + Math.sin(this.rotation) * move * speed * delta;
        let newZ = this.z + Math.cos(this.rotation) * move * speed * delta;

        // Collision with buildings
        if (!world.city.isBlocked(newX, newZ)) {
            this.x = newX;
            this.z = newZ;
        } else {
            this.rotation += Math.PI / 2;
        }

        // Keep in bounds
        const bound = 95;
        this.x = Math.max(-bound, Math.min(bound, this.x));
        this.z = Math.max(-bound, Math.min(bound, this.z));

        if (this.mesh) {
            this.mesh.position.set(this.x, this.meshSize, this.z);
            this.mesh.rotation.y = this.rotation;
        }

        this.fitness += delta * (this.energy / 100);
    }

    sense(world) {
        const food = this.findNearest(world, this.foodTypes());
        const threat = this.findNearest(world, this.threatTypes());
        return [
            food ? Math.min(1, this.dist(food) / 20) : 1,
            food ? this.angleTo(food) / Math.PI : 0,
            threat ? Math.min(1, this.dist(threat) / 15) : 1,
            threat ? this.angleTo(threat) / Math.PI : 0,
            this.energy / 100,
            Math.random() * 0.1
        ];
    }

    findNearest(world, types) {
        let nearest = null, minD = this.dna.vision * 25;
        // Use spatial grid for O(1) lookup instead of O(n)
        const nearby = world.spatialGrid.getNearby(this.x, this.z, minD);
        for (const c of nearby) {
            if (!c.alive || c === this || !types.includes(c.type)) continue;
            const d = this.dist(c);
            if (d < minD) { minD = d; nearest = c; }
        }
        return nearest;
    }

    dist(o) { return Math.sqrt((o.x-this.x)**2 + (o.z-this.z)**2); }
    angleTo(o) {
        const a = Math.atan2(o.x-this.x, o.z-this.z);
        let d = a - this.rotation;
        while (d > Math.PI) d -= Math.PI*2;
        while (d < -Math.PI) d += Math.PI*2;
        return d;
    }

    foodTypes() { return []; }
    threatTypes() { return []; }

    reproduce(partner, world) {
        if (this.energy < 55 || partner.energy < 55 || this.reproCD > 0) return null;
        this.energy -= 25; partner.energy -= 25;
        const child = this.createChild((this.x+partner.x)/2, (this.z+partner.z)/2, partner);
        this.reproCD = 8; partner.reproCD = 8;
        return child;
    }

    createChild(x, z, partner) { return null; }
    die() {
        this.alive = false;
        if (this.mesh?.parent) {
            this.mesh.parent.remove(this.mesh);
            // Release mesh back to pool for reuse
            meshPool.release(this.type, this.mesh);
        }
    }

    toJSON() {
        return {
            type: this.type,
            id: this.id,
            x: this.x, z: this.z, y: this.y,
            rotation: this.rotation,
            generation: this.generation,
            energy: this.energy,
            age: this.age,
            fitness: this.fitness,
            state: this.state,
            reproCD: this.reproCD,
            dna: this.dna.toJSON(),
            brain: this.brain ? this.brain.toJSON() : null
        };
    }
}

class Plant extends Creature {
    constructor(x, z) {
        super(x, z, 'plant', 1);
        this.energy = 50;
        this.state = 'growing';
    }
    createMesh() {
        const g = new THREE.Group();
        const h = 0.3 + this.dna.size * 0.4;
        const stem = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05, 0.08, h, 6),
            new THREE.MeshStandardMaterial({ color: 0x228822 })
        );
        stem.position.y = h/2;
        g.add(stem);
        const leaves = new THREE.Mesh(
            new THREE.SphereGeometry(h * 0.6, 8, 6),
            new THREE.MeshStandardMaterial({ color: 0x33aa44 })
        );
        leaves.position.y = h;
        leaves.castShadow = true;
        g.add(leaves);
        g.position.set(this.x, 0, this.z);
        this.mesh = g;
        this.meshSize = h;
        return g;
    }
    update(delta, world) {
        if (!this.alive) return;
        this.age += delta;
        this.energy = Math.min(100, this.energy + delta * 2);
        if (this.energy > 80 && Math.random() < 0.005 * delta) {
            const nearby = world.creatures.filter(c => c.type === 'plant' && c.alive && this.dist(c) < 4).length;
            if (nearby < 3 && world.city.isInPark(this.x, this.z)) {
                const a = Math.random() * Math.PI * 2;
                const d = 2 + Math.random() * 3;
                const nx = this.x + Math.cos(a) * d;
                const nz = this.z + Math.sin(a) * d;
                if (world.city.isInPark(nx, nz)) {
                    world.addCreature(new Plant(nx, nz));
                    this.energy -= 15;
                }
            }
        }
        if (this.age > 150) this.die();
        if (this.mesh) {
            const s = 0.5 + this.energy / 200;
            this.mesh.scale.set(s, s, s);
        }
    }
    sense() { return []; }
}

class Herbivore extends Creature {
    constructor(x, z, gen = 1) { super(x, z, 'herbivore', gen); this.state = 'foraging'; }
    createMesh() { return super.createMesh(new THREE.Color().setHSL(0.55 + this.dna.colorH * 0.1, 0.7, 0.5).getHex()); }
    foodTypes() { return ['plant']; }
    threatTypes() { return ['predator']; }
    update(delta, world) {
        super.update(delta, world);
        if (!this.alive) return;
        this.state = this.energy < 50 ? 'hungry' : 'foraging';
        // Eat plants
        world.creatures.filter(c => c.type === 'plant' && c.alive && this.dist(c) < 1).forEach(p => {
            const amt = Math.min(p.energy, 15 * delta);
            this.energy = Math.min(100, this.energy + amt);
            p.energy -= amt;
            if (p.energy <= 0) p.die();
        });
        // Reproduce
        if (this.energy > 70 && this.reproCD <= 0) {
            const mate = world.creatures.find(c => c.type === 'herbivore' && c !== this && c.alive && c.energy > 60 && this.dist(c) < 3);
            if (mate) {
                const child = this.reproduce(mate, world);
                if (child) world.addCreature(child);
            }
        }
    }
    createChild(x, z, partner) {
        const c = new Herbivore(x, z, Math.max(this.generation, partner.generation) + 1);
        c.dna = DNA.crossover(this.dna, partner.dna); c.dna.mutate();
        c.brain = NeuralNetwork.crossover(this.brain, partner.brain); c.brain.mutate();
        c.energy = 50;
        return c;
    }
}

class Predator extends Creature {
    constructor(x, z, gen = 1) { super(x, z, 'predator', gen); this.attackCD = 0; this.state = 'hunting'; }
    createMesh() {
        const size = 0.4 + this.dna.size * 0.4;
        const geo = new THREE.ConeGeometry(size, size * 1.5, 6);
        const mat = new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(0.0 + this.dna.colorH * 0.05, 0.8, 0.45).getHex() });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.rotation.x = Math.PI / 2;
        const g = new THREE.Group();
        g.add(mesh);
        g.position.set(this.x, size, this.z);
        this.mesh = g;
        this.meshSize = size;
        return g;
    }
    foodTypes() { return ['herbivore']; }
    threatTypes() { return []; }
    update(delta, world) {
        super.update(delta, world);
        if (!this.alive) return;
        this.attackCD -= delta;
        this.state = this.energy < 40 ? 'starving' : 'hunting';
        // Hunt
        if (this.attackCD <= 0) {
            const prey = world.creatures.find(c => c.type === 'herbivore' && c.alive && this.dist(c) < 1.5);
            if (prey) {
                prey.energy -= 40;
                if (prey.energy <= 0) {
                    prey.die();
                    this.energy = Math.min(100, this.energy + 40);
                    this.fitness += 5;
                }
                this.attackCD = 0.8;
            }
        }
        // Reproduce
        if (this.energy > 75 && this.reproCD <= 0) {
            const mate = world.creatures.find(c => c.type === 'predator' && c !== this && c.alive && c.energy > 70 && this.dist(c) < 3);
            if (mate) {
                const child = this.reproduce(mate, world);
                if (child) world.addCreature(child);
            }
        }
    }
    createChild(x, z, partner) {
        const c = new Predator(x, z, Math.max(this.generation, partner.generation) + 1);
        c.dna = DNA.crossover(this.dna, partner.dna); c.dna.mutate();
        c.brain = NeuralNetwork.crossover(this.brain, partner.brain); c.brain.mutate();
        c.energy = 50;
        return c;
    }
}

// ============================================================
// HUMAN CLASS - City Dwellers with Commute Behavior
// ============================================================
class Human extends Creature {
    constructor(x, z, homeBuilding, workBuilding) {
        super(x, z, 'human', 1);
        this.home = homeBuilding;
        this.work = workBuilding;
        this.state = 'home';
        this.energy = 100;
        this.destination = null;
        this.path = [];
        this.pathIndex = 0;
        this.waitTimer = 0;
        this.wakeHour = 6 + Math.random() * 2;      // 6-8 AM
        this.leaveWorkHour = 17 + Math.random() * 2; // 5-7 PM
        this.speed = 3 + Math.random() * 2;
        this.trafficDelay = 0;
    }

    createMesh() {
        const g = new THREE.Group();
        // Body
        const body = new THREE.Mesh(
            new THREE.CapsuleGeometry(0.2, 0.5, 4, 8),
            new THREE.MeshStandardMaterial({ color: 0xffdd44 })
        );
        body.position.y = 0.5;
        g.add(body);
        // Head
        const head = new THREE.Mesh(
            new THREE.SphereGeometry(0.15, 8, 6),
            new THREE.MeshStandardMaterial({ color: 0xffcc99 })
        );
        head.position.y = 0.9;
        g.add(head);
        g.position.set(this.x, 0, this.z);
        g.castShadow = true;
        this.mesh = g;
        this.meshSize = 0.5;
        return g;
    }

    update(delta, world) {
        if (!this.alive) return;
        this.age += delta;

        const hour = world.timeOfDay;
        const [trafficDensity, toWorkProb, toHomeProb] = getTrafficLevel(hour);

        // State machine based on time of day
        if (this.state === 'home') {
            if (hour >= this.wakeHour && hour < this.wakeHour + 0.5 && Math.random() < toWorkProb * delta * 0.5) {
                this.startCommute(this.work, world);
                this.state = 'commuting_to_work';
            }
        } else if (this.state === 'work') {
            if (hour >= this.leaveWorkHour && hour < this.leaveWorkHour + 0.5 && Math.random() < toHomeProb * delta * 0.5) {
                this.startCommute(this.home, world);
                this.state = 'commuting_home';
            }
        } else if (this.state === 'commuting_to_work' || this.state === 'commuting_home') {
            // Apply traffic delay based on congestion
            this.trafficDelay = trafficDensity * 0.8;
            this.moveAlongPath(delta, world);

            if (this.reachedDestination()) {
                this.state = this.state === 'commuting_to_work' ? 'work' : 'home';
                this.path = [];
            }
        }

        // Update mesh position
        if (this.mesh) {
            this.mesh.position.set(this.x, 0, this.z);
            this.mesh.rotation.y = this.rotation;
        }
    }

    startCommute(building, world) {
        this.destination = { x: building.cx, z: building.cz };
        this.path = this.findPath(world);
        this.pathIndex = 0;
    }

    findPath(world) {
        // Simple pathfinding: generate waypoints along roads
        const path = [];
        const startX = this.x, startZ = this.z;
        const endX = this.destination.x, endZ = this.destination.z;

        // Find nearest road intersection to start and end
        const roadGrid = 20; // Block size
        const startRoadX = Math.round(startX / roadGrid) * roadGrid;
        const startRoadZ = Math.round(startZ / roadGrid) * roadGrid;
        const endRoadX = Math.round(endX / roadGrid) * roadGrid;
        const endRoadZ = Math.round(endZ / roadGrid) * roadGrid;

        // Add waypoints along the grid
        path.push({ x: startRoadX, z: startZ });
        path.push({ x: startRoadX, z: startRoadZ });

        // Walk along roads (Manhattan-style)
        let cx = startRoadX, cz = startRoadZ;
        while (Math.abs(cx - endRoadX) > roadGrid || Math.abs(cz - endRoadZ) > roadGrid) {
            if (Math.abs(cx - endRoadX) > Math.abs(cz - endRoadZ)) {
                cx += (endRoadX > cx ? roadGrid : -roadGrid);
            } else {
                cz += (endRoadZ > cz ? roadGrid : -roadGrid);
            }
            path.push({ x: cx, z: cz });
        }

        path.push({ x: endRoadX, z: endZ });
        path.push({ x: endX, z: endZ });

        return path;
    }

    moveAlongPath(delta, world) {
        if (this.path.length === 0 || this.pathIndex >= this.path.length) return;

        const target = this.path[this.pathIndex];
        const dx = target.x - this.x;
        const dz = target.z - this.z;
        const dist = Math.sqrt(dx*dx + dz*dz);

        if (dist < 0.5) {
            this.pathIndex++;
            return;
        }

        // Speed affected by traffic
        const effectiveSpeed = this.speed * (1 - this.trafficDelay);
        const step = effectiveSpeed * delta;

        this.rotation = Math.atan2(dx, dz);
        this.x += (dx / dist) * Math.min(step, dist);
        this.z += (dz / dist) * Math.min(step, dist);
    }

    reachedDestination() {
        if (!this.destination) return true;
        const dx = this.destination.x - this.x;
        const dz = this.destination.z - this.z;
        return Math.sqrt(dx*dx + dz*dz) < 2;
    }

    sense() { return []; }
    foodTypes() { return []; }
    threatTypes() { return ['predator']; }

    toJSON() {
        const base = super.toJSON();
        return {
            ...base,
            homeIdx: this.home ? city.residentialBuildings.indexOf(this.home) : -1,
            workIdx: this.work ? city.commercialBuildings.indexOf(this.work) : -1,
            wakeHour: this.wakeHour,
            leaveWorkHour: this.leaveWorkHour,
            speed: this.speed
        };
    }
}

// ============================================================
// CITY GENERATOR - Fixed alignment
// ============================================================
class City {
    constructor(scene) {
        this.scene = scene;
        this.buildings = [];
        this.parks = [];
        this.roads = [];
        this.residentialBuildings = [];
        this.commercialBuildings = [];
        this.windowMeshes = []; // Store window meshes for night lighting
        this.blockSize = 20;
        this.roadWidth = 4;
        this.gridSize = 10;

        // Content group for buildings/parks - can be moved/rotated
        this.contentGroup = new THREE.Group();
        this.scene.add(this.contentGroup);

        this.generate();
        this.setupAlignControls();
    }

    setupAlignControls() {
        let moveMode = false;
        let rotateMode = false;
        let dragging = false;
        let lastX = 0, lastY = 0;

        // Track M and R keys
        window.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'm') moveMode = true;
            if (e.key.toLowerCase() === 'r') rotateMode = true;
        });
        window.addEventListener('keyup', (e) => {
            if (e.key.toLowerCase() === 'm') moveMode = false;
            if (e.key.toLowerCase() === 'r') rotateMode = false;
        });

        window.addEventListener('mousedown', (e) => {
            if (moveMode || rotateMode) {
                dragging = true;
                lastX = e.clientX;
                lastY = e.clientY;
                e.preventDefault();
            }
        });

        window.addEventListener('mousemove', (e) => {
            if (!dragging) return;
            const dx = e.clientX - lastX;
            const dy = e.clientY - lastY;

            if (moveMode) {
                this.contentGroup.position.x += dx * 0.15;
                this.contentGroup.position.z += dy * 0.15;
            }
            if (rotateMode) {
                this.contentGroup.rotation.y += dx * 0.005;
            }

            lastX = e.clientX;
            lastY = e.clientY;
            this.updateDisplay();
        });

        window.addEventListener('mouseup', () => dragging = false);

        document.getElementById('btn-copy-offset')?.addEventListener('click', () => {
            const data = {
                x: this.contentGroup.position.x.toFixed(2),
                z: this.contentGroup.position.z.toFixed(2),
                rotationDeg: (this.contentGroup.rotation.y * 180 / Math.PI).toFixed(2)
            };
            const json = JSON.stringify(data, null, 2);
            navigator.clipboard.writeText(json).then(() => NotificationSystem.show('Copied alignment values!', 'success'));
        });
    }

    updateDisplay() {
        const pos = document.getElementById('offset-display');
        const rot = document.getElementById('rotation-display');
        if (pos) pos.textContent = `X:${this.contentGroup.position.x.toFixed(1)} Z:${this.contentGroup.position.z.toFixed(1)}`;
        if (rot) rot.textContent = `${(this.contentGroup.rotation.y * 180 / Math.PI).toFixed(1)}¬∞`;
    }

    generate() {
        const { blockSize, roadWidth, gridSize } = this;
        const halfGrid = gridSize / 2;

        // Materials
        const roadMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.9 });
        const grassMat = new THREE.MeshStandardMaterial({ color: 0x2d5a2d, roughness: 0.9 });
        const buildingColors = [0x8899aa, 0x667788, 0x556677, 0x445566, 0x778899, 0x99aabb];

        // Create ground
        const groundSize = gridSize * blockSize;
        const groundGeo = new THREE.PlaneGeometry(groundSize, groundSize);
        const ground = new THREE.Mesh(groundGeo, grassMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.set(0, 0, 0);
        ground.receiveShadow = true;
        this.scene.add(ground);

        // Create city grid - all coordinates relative to center
        for (let gx = -halfGrid; gx < halfGrid; gx++) {
            for (let gz = -halfGrid; gz < halfGrid; gz++) {
                // Block center position
                const blockCenterX = gx * blockSize + blockSize / 2;
                const blockCenterZ = gz * blockSize + blockSize / 2;

                // Road positions (at block edges)
                const roadX = gx * blockSize;
                const roadZ = gz * blockSize;

                // Horizontal road (along X axis, at Z edge of block)
                const roadH = new THREE.Mesh(
                    new THREE.PlaneGeometry(blockSize, roadWidth),
                    roadMat
                );
                roadH.rotation.x = -Math.PI / 2;
                roadH.position.set(blockCenterX, 0.01, roadZ);
                this.scene.add(roadH);

                // Store road data matching visual position exactly
                this.roads.push({
                    x: roadX,
                    z: roadZ - roadWidth / 2,
                    w: blockSize,
                    h: roadWidth,
                    cx: blockCenterX,
                    cz: roadZ
                });

                // Vertical road (along Z axis, at X edge of block)
                const roadV = new THREE.Mesh(
                    new THREE.PlaneGeometry(roadWidth, blockSize),
                    roadMat
                );
                roadV.rotation.x = -Math.PI / 2;
                roadV.position.set(roadX, 0.01, blockCenterZ);
                this.scene.add(roadV);

                this.roads.push({
                    x: roadX - roadWidth / 2,
                    z: gz * blockSize,
                    w: roadWidth,
                    h: blockSize,
                    cx: roadX,
                    cz: blockCenterZ
                });

                // Block content area (inside the roads)
                const contentX = roadX + roadWidth / 2;
                const contentZ = roadZ + roadWidth / 2;
                const contentW = blockSize - roadWidth;
                const contentH = blockSize - roadWidth;

                // Distance from center for building height
                const distFromCenter = Math.sqrt(gx * gx + gz * gz);

                // Decide block type (15% parks, more on edges)
                const isPark = Math.random() < (distFromCenter > 3 ? 0.25 : 0.1);

                if (isPark) {
                    // Park - brighter grass
                    const parkGeo = new THREE.PlaneGeometry(contentW - 2, contentH - 2);
                    const parkMat = new THREE.MeshStandardMaterial({ color: 0x3a8a3a });
                    const park = new THREE.Mesh(parkGeo, parkMat);
                    park.rotation.x = -Math.PI / 2;
                    park.position.set(contentX + contentW / 2, 0.02, contentZ + contentH / 2);
                    this.contentGroup.add(park);

                    // Store park data matching visual position
                    this.parks.push({
                        x: contentX + 1,
                        z: contentZ + 1,
                        w: contentW - 2,
                        h: contentH - 2,
                        cx: contentX + contentW / 2,
                        cz: contentZ + contentH / 2
                    });
                } else {
                    // Buildings
                    const numBuildings = 1 + Math.floor(Math.random() * 2);
                    const isResidential = distFromCenter > 2.5;

                    for (let i = 0; i < numBuildings; i++) {
                        const bWidth = 4 + Math.random() * 5;
                        const bDepth = 4 + Math.random() * 5;
                        const maxHeight = distFromCenter < 2 ? 40 : (distFromCenter < 3 ? 20 : 10);
                        const bHeight = 5 + Math.random() * maxHeight;

                        // Building position within content area
                        const margin = 1;
                        const bx = contentX + margin + Math.random() * (contentW - bWidth - margin * 2);
                        const bz = contentZ + margin + Math.random() * (contentH - bDepth - margin * 2);

                        const buildingGeo = new THREE.BoxGeometry(bWidth, bHeight, bDepth);
                        const buildingMat = new THREE.MeshStandardMaterial({
                            color: buildingColors[Math.floor(Math.random() * buildingColors.length)],
                            roughness: 0.7
                        });
                        const building = new THREE.Mesh(buildingGeo, buildingMat);

                        // Position building - center of geometry
                        const buildingCenterX = bx + bWidth / 2;
                        const buildingCenterZ = bz + bDepth / 2;
                        building.position.set(buildingCenterX, bHeight / 2, buildingCenterZ);
                        building.castShadow = true;
                        building.receiveShadow = true;
                        this.contentGroup.add(building);

                        // Add windows
                        this.addWindows(building, bWidth, bDepth, bHeight, isResidential);

                        // Store building data matching visual position
                        const buildingData = {
                            x: bx,
                            z: bz,
                            w: bWidth,
                            h: bDepth,
                            height: bHeight,
                            cx: buildingCenterX,
                            cz: buildingCenterZ,
                            isResidential
                        };

                        this.buildings.push(buildingData);
                        if (isResidential) {
                            this.residentialBuildings.push(buildingData);
                        } else {
                            this.commercialBuildings.push(buildingData);
                        }
                    }
                }
            }
        }

        // Add road markings at intersections
        this.addRoadMarkings();
    }

    addWindows(building, w, d, h, isResidential = false) {
        const windowSize = 0.6;
        const spacing = 2;

        for (let y = 2; y < h - 1; y += spacing) {
            // Front and back faces
            for (let x = -w / 2 + 1; x < w / 2 - 0.5; x += spacing) {
                if (Math.random() > 0.25) {
                    const windowMat = new THREE.MeshBasicMaterial({ color: 0xffffcc });
                    const win = new THREE.Mesh(
                        new THREE.PlaneGeometry(windowSize, windowSize * 1.3),
                        windowMat
                    );
                    win.position.set(x, y - h / 2, d / 2 + 0.01);
                    building.add(win);
                    this.windowMeshes.push({ mesh: win, isResidential, baseColor: 0xffffcc });

                    const winBackMat = new THREE.MeshBasicMaterial({ color: 0xffffcc });
                    const winBack = new THREE.Mesh(
                        new THREE.PlaneGeometry(windowSize, windowSize * 1.3),
                        winBackMat
                    );
                    winBack.position.set(x, y - h / 2, -d / 2 - 0.01);
                    winBack.rotation.y = Math.PI;
                    building.add(winBack);
                    this.windowMeshes.push({ mesh: winBack, isResidential, baseColor: 0xffffcc });
                }
            }
            // Side faces
            for (let z = -d / 2 + 1; z < d / 2 - 0.5; z += spacing) {
                if (Math.random() > 0.25) {
                    const windowMat = new THREE.MeshBasicMaterial({ color: 0xffffcc });
                    const win = new THREE.Mesh(
                        new THREE.PlaneGeometry(windowSize, windowSize * 1.3),
                        windowMat
                    );
                    win.rotation.y = Math.PI / 2;
                    win.position.set(w / 2 + 0.01, y - h / 2, z);
                    building.add(win);
                    this.windowMeshes.push({ mesh: win, isResidential, baseColor: 0xffffcc });

                    const winLeftMat = new THREE.MeshBasicMaterial({ color: 0xffffcc });
                    const winLeft = new THREE.Mesh(
                        new THREE.PlaneGeometry(windowSize, windowSize * 1.3),
                        winLeftMat
                    );
                    winLeft.position.set(-w / 2 - 0.01, y - h / 2, z);
                    winLeft.rotation.y = -Math.PI / 2;
                    building.add(winLeft);
                    this.windowMeshes.push({ mesh: winLeft, isResidential, baseColor: 0xffffcc });
                }
            }
        }
    }

    updateWindowLighting(timeOfDay) {
        const hour = timeOfDay;
        const isNight = hour < 6 || hour >= 20;
        const isEvening = hour >= 18 && hour < 20;
        const isMorning = hour >= 5 && hour < 7;

        // Calculate window brightness (brighter at night)
        let brightness = 0.3; // Daytime dim
        if (isNight) brightness = 1.0;
        else if (isEvening || isMorning) brightness = 0.6;

        this.windowMeshes.forEach(w => {
            // Random flicker for lived-in feel
            const flicker = 0.9 + Math.random() * 0.2;

            // Residential: warm yellow-orange at night
            // Commercial: cool blue-white at night
            if (isNight || isEvening || isMorning) {
                if (w.isResidential) {
                    w.mesh.material.color.setHex(0xffcc66); // Warm
                } else {
                    w.mesh.material.color.setHex(0xccddff); // Cool
                }
                const finalBrightness = brightness * flicker;
                w.mesh.material.color.multiplyScalar(finalBrightness);
            } else {
                // Daytime: subtle reflection
                w.mesh.material.color.setHex(0xaabbcc);
            }
        });
    }

    addRoadMarkings() {
        const markingMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const { blockSize, gridSize } = this;
        const halfGrid = gridSize / 2;

        // Add dashed center lines on roads
        for (let g = -halfGrid; g < halfGrid; g++) {
            const roadPos = g * blockSize;

            // Horizontal dashes
            for (let x = -halfGrid * blockSize; x < halfGrid * blockSize; x += 3) {
                const dash = new THREE.Mesh(
                    new THREE.PlaneGeometry(1.5, 0.15),
                    markingMat
                );
                dash.rotation.x = -Math.PI / 2;
                dash.position.set(x + blockSize / 2, 0.02, roadPos);
                this.scene.add(dash);
            }

            // Vertical dashes
            for (let z = -halfGrid * blockSize; z < halfGrid * blockSize; z += 3) {
                const dash = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.15, 1.5),
                    markingMat
                );
                dash.rotation.x = -Math.PI / 2;
                dash.position.set(roadPos, 0.02, z + blockSize / 2);
                this.scene.add(dash);
            }
        }
    }

    isBlocked(x, z, radius = 0.5) {
        for (const b of this.buildings) {
            if (x > b.x - radius && x < b.x + b.w + radius &&
                z > b.z - radius && z < b.z + b.h + radius) {
                return true;
            }
        }
        return false;
    }

    isOnRoad(x, z) {
        for (const r of this.roads) {
            if (x >= r.x && x <= r.x + r.w && z >= r.z && z <= r.z + r.h) {
                return true;
            }
        }
        return false;
    }

    isInPark(x, z) {
        for (const p of this.parks) {
            if (x > p.x && x < p.x + p.w && z > p.z && z < p.z + p.h) {
                return true;
            }
        }
        return false;
    }

    getRandomParkPosition() {
        if (this.parks.length === 0) return { x: 0, z: 0 };
        const park = this.parks[Math.floor(Math.random() * this.parks.length)];
        return {
            x: park.x + Math.random() * park.w,
            z: park.z + Math.random() * park.h
        };
    }

    getRandomResidential() {
        if (this.residentialBuildings.length === 0) return this.buildings[0];
        return this.residentialBuildings[Math.floor(Math.random() * this.residentialBuildings.length)];
    }

    getRandomCommercial() {
        if (this.commercialBuildings.length === 0) return this.buildings[0];
        return this.commercialBuildings[Math.floor(Math.random() * this.commercialBuildings.length)];
    }
}

// ============================================================
// WORLD MANAGER
// ============================================================
class World {
    constructor(city) {
        this.city = city;
        this.creatures = [];
        this.spatialGrid = new SpatialGrid(20, 200); // 20-unit cells, 200-unit world
        this.history = { plants: [], herbivores: [], predators: [], humans: [] };
        this.totalYears = 0;
        this.generation = 1;
        this.historyTimer = 0;
        this.timeOfDay = 6; // Start at 6 AM
        this.dayCount = 1;
        this.hourSpeed = 0.5; // Hours per real second at 1x speed
        this.events = [];
        this.lastGenMilestone = 1;
        this.challenges = [
            "üî¨ Observe: How do predators affect herbivore populations?",
            "üåø Experiment: What happens if plants can't spread?",
            "üß¨ Study: Which DNA traits help herbivores survive?",
            "üèôÔ∏è Watch: How does rush hour affect human movement?",
            "ü¶ä Predict: Will predators or herbivores go extinct first?",
            "‚è∞ Track: How long until a new generation emerges?",
            "üìä Compare: Morning vs evening traffic patterns"
        ];
        this.currentChallenge = 0;
    }

    addCreature(c) {
        this.creatures.push(c);
        this.spatialGrid.add(c);
        scene.add(c.createMesh());
    }

    update(delta) {
        // Update time of day
        this.timeOfDay += delta * this.hourSpeed;
        if (this.timeOfDay >= 24) {
            this.timeOfDay -= 24;
            this.dayCount++;
        }

        // Update lighting based on time
        this.updateLighting();

        // Update all creatures and maintain spatial grid
        this.creatures.forEach(c => {
            c.update(delta, this);
            if (c.alive) {
                this.spatialGrid.update(c);
            } else {
                this.spatialGrid.remove(c);
            }
        });
        this.creatures = this.creatures.filter(c => c.alive);
        this.totalYears += delta / 10;

        // Track history
        this.historyTimer += delta;
        if (this.historyTimer > 0.5) {
            this.historyTimer = 0;
            const counts = this.getCounts();
            this.history.plants.push(counts.plants);
            this.history.herbivores.push(counts.herbivores);
            this.history.predators.push(counts.predators);
            this.history.humans.push(counts.humans);
            const maxLen = 150;
            if (this.history.plants.length > maxLen) {
                this.history.plants.shift();
                this.history.herbivores.shift();
                this.history.predators.shift();
                this.history.humans.shift();
            }
        }

        this.creatures.forEach(c => { if (c.generation > this.generation) this.generation = c.generation; });

        // Check for narrative milestones every few seconds
        if (this.historyTimer < 0.1) this.checkMilestones();

        // Spawn plants in parks (modified by simParams.plantGrowth if available)
        const plantCount = this.creatures.filter(c => c.type === 'plant').length;
        const growthMod = typeof simParams !== 'undefined' ? simParams.plantGrowth : 1;
        if (plantCount < 60 * growthMod && Math.random() < 0.05 * growthMod) {
            const pos = this.city.getRandomParkPosition();
            this.addCreature(new Plant(pos.x, pos.z));
        }
    }

    updateLighting() {
        const hour = this.timeOfDay;
        let intensity, ambientIntensity, skyColor;

        if (hour >= 6 && hour < 8) { // Sunrise
            const t = (hour - 6) / 2;
            intensity = 0.3 + t * 0.9;
            ambientIntensity = 0.3 + t * 0.3;
            skyColor = new THREE.Color().lerpColors(new THREE.Color(0x1a2535), new THREE.Color(0x87ceeb), t);
        } else if (hour >= 8 && hour < 18) { // Day
            intensity = 1.2;
            ambientIntensity = 0.6;
            skyColor = new THREE.Color(0x87ceeb);
        } else if (hour >= 18 && hour < 20) { // Sunset
            const t = (hour - 18) / 2;
            intensity = 1.2 - t * 0.9;
            ambientIntensity = 0.6 - t * 0.3;
            skyColor = new THREE.Color().lerpColors(new THREE.Color(0xff7744), new THREE.Color(0x1a2535), t);
        } else { // Night
            intensity = 0.2;
            ambientIntensity = 0.2;
            skyColor = new THREE.Color(0x0a1020);
        }

        sun.intensity = intensity;
        ambientLight.intensity = ambientIntensity;
        scene.background = skyColor;
        scene.fog.color = skyColor;
    }

    getCounts() {
        const c = { plants: 0, herbivores: 0, predators: 0, humans: 0 };
        this.creatures.forEach(cr => {
            if (cr.type + 's' in c) c[cr.type + 's']++;
        });
        return c;
    }

    getHumanStats() {
        const stats = { commuting: 0, working: 0, home: 0 };
        this.creatures.forEach(c => {
            if (c.type !== 'human') return;
            if (c.state === 'commuting_to_work' || c.state === 'commuting_home') stats.commuting++;
            else if (c.state === 'work') stats.working++;
            else stats.home++;
        });
        return stats;
    }

    getAvgFitness() {
        const active = this.creatures.filter(c => c.type !== 'plant' && c.type !== 'human');
        return active.length ? active.reduce((s, c) => s + c.fitness, 0) / active.length : 0;
    }

    spawn(type, n = 1) {
        for (let i = 0; i < n; i++) {
            let x, z, attempts = 0;
            do {
                x = (Math.random() - 0.5) * 180;
                z = (Math.random() - 0.5) * 180;
                attempts++;
            } while (this.city.isBlocked(x, z) && attempts < 20);

            if (type === 'plant') {
                const pos = this.city.getRandomParkPosition();
                this.addCreature(new Plant(pos.x, pos.z));
            } else if (type === 'herbivore') {
                this.addCreature(new Herbivore(x, z));
            } else if (type === 'predator') {
                this.addCreature(new Predator(x, z));
            } else if (type === 'human') {
                const home = this.city.getRandomResidential();
                const work = this.city.getRandomCommercial();
                this.addCreature(new Human(home.cx, home.cz, home, work));
            }
        }
    }

    apocalypse() {
        this.creatures.filter(() => Math.random() < 0.75).forEach(c => c.die());
        this.creatures = this.creatures.filter(c => c.alive);
        this.logEvent("üåã Catastrophic event! Many creatures perished.", "danger");
    }

    // ============================================================
    // NARRATIVE EVENT SYSTEM
    // ============================================================
    logEvent(message, type = 'info') {
        const event = {
            time: `Day ${this.dayCount}`,
            message,
            type,
            timestamp: Date.now()
        };
        this.events.unshift(event);
        if (this.events.length > 20) this.events.pop();
        this.updateEventLog();
    }

    updateEventLog() {
        const list = document.getElementById('event-list');
        if (!list) return;
        list.innerHTML = this.events.slice(0, 8).map(e =>
            `<div class="event-item"><span class="event-time">${e.time}</span> ${e.message}</div>`
        ).join('');
    }

    checkMilestones() {
        const counts = this.getCounts();

        // Generation milestones
        if (this.generation >= this.lastGenMilestone + 5) {
            this.lastGenMilestone = this.generation;
            this.logEvent(`üß¨ Generation ${this.generation} reached!`, 'evolution');
            this.currentChallenge = (this.currentChallenge + 1) % this.challenges.length;
        }

        // Population events
        if (counts.herbivores === 0 && this.history.herbivores.length > 5 && this.history.herbivores[this.history.herbivores.length - 5] > 0) {
            this.logEvent("‚ö†Ô∏è Herbivores extinct! Predators will starve.", "danger");
        }
        if (counts.predators === 0 && this.history.predators.length > 5 && this.history.predators[this.history.predators.length - 5] > 0) {
            this.logEvent("ü¶ä Predators extinct! Herbivores may overpopulate.", "warning");
        }
        if (counts.herbivores > 50) {
            this.logEvent("üê∞ Herbivore population boom!", "success");
        }
    }

    getEcosystemHealth() {
        const counts = this.getCounts();
        const totalAnimals = counts.herbivores + counts.predators;
        if (totalAnimals === 0) return { score: 0, status: 'Extinct', color: '#aa3344' };

        const ratio = counts.herbivores / Math.max(1, counts.predators);
        const plantCoverage = counts.plants / 60; // 60 is target

        // Ideal ratio is 3-5 herbivores per predator
        let balanceScore = 0;
        if (ratio >= 2 && ratio <= 8) balanceScore = 100;
        else if (ratio < 2) balanceScore = ratio * 50;
        else balanceScore = Math.max(0, 100 - (ratio - 8) * 10);

        const plantScore = Math.min(100, plantCoverage * 100);
        const diversityScore = (counts.herbivores > 0 && counts.predators > 0) ? 100 : 50;

        const overall = (balanceScore * 0.4 + plantScore * 0.3 + diversityScore * 0.3);

        let status, color;
        if (overall > 70) { status = 'Thriving'; color = '#00aa66'; }
        else if (overall > 50) { status = 'Stable'; color = '#88aa00'; }
        else if (overall > 30) { status = 'Stressed'; color = '#aa8800'; }
        else { status = 'Critical'; color = '#aa3344'; }

        return { score: overall, status, color, ratio: ratio.toFixed(1) };
    }

    // ============================================================
    // SAVE/LOAD SYSTEM v1.0
    // ============================================================
    toJSON() {
        return {
            version: '1.0',
            timestamp: Date.now(),
            timeOfDay: this.timeOfDay,
            dayCount: this.dayCount,
            generation: this.generation,
            totalYears: this.totalYears,
            history: this.history,
            creatures: this.creatures.filter(c => c.alive).map(c => c.toJSON())
        };
    }

    save() {
        try {
            const data = this.toJSON();
            // ROUND 20: Use StorageSafety for quota checking and versioning
            const success = StorageSafety.safeSet('ecosystemCity_save', data);
            if (success) {
                this.showNotification('Simulation saved successfully!', 'success');
            }
            return success;
        } catch (e) {
            console.error('Save failed:', e);
            this.showNotification('Save failed: ' + e.message, 'error');
            // Fallback: offer download
            this.exportAsFile();
            return false;
        }
    }

    load() {
        try {
            // ROUND 20: Use StorageSafety for corruption checking and versioning
            const data = StorageSafety.safeGet('ecosystemCity_save');
            if (!data) {
                this.showNotification('No saved simulation found', 'warning');
                return false;
            }
            // ROUND 20: Validate data before restoring
            if (!StorageSafety.validateSaveData(data)) {
                this.showNotification('Save file is corrupted or invalid', 'error');
                return false;
            }
            return this.restoreFromJSON(data);
        } catch (e) {
            console.error('Load failed:', e);
            this.showNotification('Load failed: ' + e.message, 'error');
            return false;
        }
    }

    restoreFromJSON(json) {
        if (!json.version || !json.creatures) {
            this.showNotification('Invalid save file format', 'error');
            return false;
        }

        // Clear existing creatures
        this.creatures.forEach(c => c.die());
        this.creatures = [];
        this.spatialGrid.clear();

        // Restore world state
        this.timeOfDay = json.timeOfDay || 6;
        this.dayCount = json.dayCount || 1;
        this.generation = json.generation || 1;
        this.totalYears = json.totalYears || 0;
        this.history = json.history || { plants: [], herbivores: [], predators: [], humans: [] };

        // Restore creatures
        let restored = 0;
        for (const cData of json.creatures) {
            try {
                const creature = this.createCreatureFromJSON(cData);
                if (creature) {
                    this.addCreature(creature);
                    restored++;
                }
            } catch (e) {
                console.warn('Failed to restore creature:', e);
            }
        }

        this.showNotification(`Loaded ${restored} creatures from save`, 'success');
        return true;
    }

    createCreatureFromJSON(data) {
        let creature;
        switch (data.type) {
            case 'plant':
                creature = new Plant(data.x, data.z);
                break;
            case 'herbivore':
                creature = new Herbivore(data.x, data.z, data.generation);
                break;
            case 'predator':
                creature = new Predator(data.x, data.z, data.generation);
                break;
            case 'human':
                const home = city.residentialBuildings[data.homeIdx] || city.getRandomResidential();
                const work = city.commercialBuildings[data.workIdx] || city.getRandomCommercial();
                creature = new Human(data.x, data.z, home, work);
                creature.wakeHour = data.wakeHour;
                creature.leaveWorkHour = data.leaveWorkHour;
                creature.speed = data.speed;
                break;
            default:
                return null;
        }

        // Restore common properties
        creature.id = data.id;
        creature.rotation = data.rotation;
        creature.energy = data.energy;
        creature.age = data.age;
        creature.fitness = data.fitness;
        creature.state = data.state;
        creature.reproCD = data.reproCD || 0;

        if (data.dna) creature.dna = DNA.fromJSON(data.dna);
        if (data.brain) creature.brain = NeuralNetwork.fromJSON(data.brain);

        return creature;
    }

    exportAsFile() {
        try {
            const data = JSON.stringify(this.toJSON(), null, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ecosystem-city-save-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
            this.showNotification('Save exported as file', 'success');
        } catch (e) {
            this.showNotification('Export failed: ' + e.message, 'error');
        }
    }

    importFromFile() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const json = JSON.parse(event.target.result);
                    this.restoreFromJSON(json);
                } catch (err) {
                    this.showNotification('Invalid JSON file', 'error');
                }
            };
            reader.readAsText(file);
        };
        input.click();
    }

    showNotification(message, type = 'info') {
        // Remove existing notification
        const existing = document.getElementById('notification');
        if (existing) existing.remove();

        const colors = { success: '#00aa66', error: '#aa3344', warning: '#aa8833', info: '#0066aa' };
        const div = document.createElement('div');
        div.id = 'notification';
        div.style.cssText = `
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: ${colors[type]}; color: white; padding: 15px 25px;
            border-radius: 10px; font-size: 14px; z-index: 10000;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5); animation: fadeInOut 2.5s ease;
        `;
        div.textContent = message;
        div.setAttribute('role', 'alert');
        div.setAttribute('aria-live', 'assertive');
        document.body.appendChild(div);
        setTimeout(() => div.remove(), 2500);
    }
}

// ============================================================
// PARTICLE TRAIL SYSTEM
// ============================================================
class ParticleTrailSystem {
    constructor(scene, maxParticles = 500) {
        this.scene = scene;
        this.maxParticles = maxParticles;
        this.particles = [];

        // Create particle geometry
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(maxParticles * 3);
        const colors = new Float32Array(maxParticles * 3);
        const sizes = new Float32Array(maxParticles);

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

        const material = new THREE.PointsMaterial({
            size: 0.3,
            vertexColors: true,
            transparent: true,
            opacity: 0.7,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true
        });

        this.mesh = new THREE.Points(geometry, material);
        this.scene.add(this.mesh);
    }

    emit(x, y, z, color, life = 1.0) {
        if (this.particles.length >= this.maxParticles) {
            this.particles.shift();
        }
        this.particles.push({ x, y, z, color, life, maxLife: life });
    }

    update(delta) {
        const positions = this.mesh.geometry.attributes.position.array;
        const colors = this.mesh.geometry.attributes.color.array;
        const sizes = this.mesh.geometry.attributes.size.array;

        // Update existing particles
        for (let i = this.particles.length - 1; i >= 0; i--) {
            this.particles[i].life -= delta;
            if (this.particles[i].life <= 0) {
                this.particles.splice(i, 1);
            }
        }

        // Update buffer
        for (let i = 0; i < this.maxParticles; i++) {
            if (i < this.particles.length) {
                const p = this.particles[i];
                const idx = i * 3;
                positions[idx] = p.x;
                positions[idx + 1] = p.y;
                positions[idx + 2] = p.z;
                const alpha = p.life / p.maxLife;
                colors[idx] = p.color.r * alpha;
                colors[idx + 1] = p.color.g * alpha;
                colors[idx + 2] = p.color.b * alpha;
                sizes[i] = 0.3 * alpha;
            } else {
                const idx = i * 3;
                positions[idx] = 0;
                positions[idx + 1] = -1000;
                positions[idx + 2] = 0;
                sizes[i] = 0;
            }
        }

        this.mesh.geometry.attributes.position.needsUpdate = true;
        this.mesh.geometry.attributes.color.needsUpdate = true;
        this.mesh.geometry.attributes.size.needsUpdate = true;
    }
}

// ============================================================
// THREE.JS SETUP
// ============================================================
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);
scene.fog = new THREE.Fog(0x87ceeb, 80, 250);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 60, 80);
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

// Lighting
const ambientLight = new THREE.AmbientLight(0x404050, 0.6);
scene.add(ambientLight);

const sun = new THREE.DirectionalLight(0xffeedd, 1.2);
sun.position.set(80, 100, 40);
sun.castShadow = true;
sun.shadow.mapSize.width = 2048;
sun.shadow.mapSize.height = 2048;
sun.shadow.camera.near = 10;
sun.shadow.camera.far = 300;
sun.shadow.camera.left = -100;
sun.shadow.camera.right = 100;
sun.shadow.camera.top = 100;
sun.shadow.camera.bottom = -100;
scene.add(sun);

// Camera controls
let camTarget = new THREE.Vector3(0, 0, 0);
let camDist = 80, camAngle = 0, camPitch = 0.7;
let dragging = false, lastMX = 0, lastMY = 0;
let selectedCreature = null;

renderer.domElement.addEventListener('mousedown', e => {
    if (e.button === 0) {
        const mouse = new THREE.Vector2((e.clientX / window.innerWidth) * 2 - 1, -(e.clientY / window.innerHeight) * 2 + 1);
        const ray = new THREE.Raycaster();
        ray.setFromCamera(mouse, camera);
        const meshes = world.creatures.map(c => c.mesh).filter(m => m);
        const hits = ray.intersectObjects(meshes, true);
        if (hits.length) {
            let hitMesh = hits[0].object;
            while (hitMesh.parent && hitMesh.parent !== scene) hitMesh = hitMesh.parent;
            selectedCreature = world.creatures.find(c => c.mesh === hitMesh);
            if (selectedCreature) {
                document.getElementById('creature-panel').classList.add('visible');
                return;
            }
        }
        dragging = true;
    }
    lastMX = e.clientX; lastMY = e.clientY;
});
renderer.domElement.addEventListener('mousemove', e => {
    if (dragging) {
        camAngle -= (e.clientX - lastMX) * 0.01;
        camPitch = Math.max(0.2, Math.min(1.4, camPitch + (e.clientY - lastMY) * 0.01));
    }
    lastMX = e.clientX; lastMY = e.clientY;
});
renderer.domElement.addEventListener('mouseup', () => dragging = false);
renderer.domElement.addEventListener('wheel', e => camDist = Math.max(20, Math.min(200, camDist + e.deltaY * 0.1)));

// Hover tooltip for creatures
const tooltip = document.getElementById('hover-tooltip');
const tooltipTitle = document.getElementById('tooltip-title');
const tooltipContent = document.getElementById('tooltip-content');
let hoveredCreature = null;

renderer.domElement.addEventListener('mousemove', e => {
    if (dragging) {
        tooltip.classList.remove('visible');
        return;
    }

    const mouse = new THREE.Vector2(
        (e.clientX / window.innerWidth) * 2 - 1,
        -(e.clientY / window.innerHeight) * 2 + 1
    );
    const ray = new THREE.Raycaster();
    ray.setFromCamera(mouse, camera);
    const meshes = world.creatures.filter(c => c.alive && c.mesh).map(c => c.mesh);
    const hits = ray.intersectObjects(meshes, true);

    if (hits.length > 0) {
        let hitMesh = hits[0].object;
        while (hitMesh.parent && hitMesh.parent !== scene) hitMesh = hitMesh.parent;
        hoveredCreature = world.creatures.find(c => c.mesh === hitMesh);

        if (hoveredCreature) {
            tooltip.classList.add('visible');
            tooltip.style.left = (e.clientX + 15) + 'px';
            tooltip.style.top = (e.clientY + 15) + 'px';

            const icons = { plant: 'üåø', herbivore: 'üê∞', predator: 'ü¶ä', human: 'üßë' };
            tooltipTitle.textContent = `${icons[hoveredCreature.type]} ${hoveredCreature.type.charAt(0).toUpperCase() + hoveredCreature.type.slice(1)} #${hoveredCreature.id}`;

            let content = '';
            if (hoveredCreature.type !== 'plant' && hoveredCreature.type !== 'human') {
                content += `<div style="margin-bottom:6px;">Gen ${hoveredCreature.generation} | ${hoveredCreature.state}</div>`;
                content += `<div>Energy: <div class="trait-bar"><div class="trait-fill" style="width:${hoveredCreature.energy}%;background:#00ff88;"></div></div></div>`;
                if (hoveredCreature.dna) {
                    content += `<div>Speed: <div class="trait-bar"><div class="trait-fill" style="width:${hoveredCreature.dna.speed * 100}%;background:#00aaff;"></div></div></div>`;
                    content += `<div>Vision: <div class="trait-bar"><div class="trait-fill" style="width:${hoveredCreature.dna.vision * 100}%;background:#ffaa00;"></div></div></div>`;
                    content += `<div>Size: <div class="trait-bar"><div class="trait-fill" style="width:${hoveredCreature.dna.size * 100}%;background:#ff4466;"></div></div></div>`;
                }
            } else if (hoveredCreature.type === 'human') {
                content += `<div>State: ${hoveredCreature.state}</div>`;
                content += `<div>Wake: ${hoveredCreature.wakeHour?.toFixed(1) || '?'}h</div>`;
                content += `<div>Leave work: ${hoveredCreature.leaveWorkHour?.toFixed(1) || '?'}h</div>`;
            } else {
                content += `<div>Age: ${hoveredCreature.age?.toFixed(1) || 0}s</div>`;
                content += `<div>Energy: ${hoveredCreature.energy?.toFixed(0) || 0}</div>`;
            }
            tooltipContent.innerHTML = content;
        }
    } else {
        tooltip.classList.remove('visible');
        hoveredCreature = null;
    }
});

const keys = { w: false, a: false, s: false, d: false };
document.addEventListener('keydown', e => {
    if (e.key.toLowerCase() in keys) keys[e.key.toLowerCase()] = true;
    if (e.key === 'p') togglePause();
    if (e.key >= '1' && e.key <= '5') { timeScale = [0.5, 1, 2, 5, 20][+e.key - 1]; updateSpeed(); }
    if (e.key === 'Escape') {
        selectedCreature = null;
        document.getElementById('creature-panel').classList.remove('visible');
    }
});
document.addEventListener('keyup', e => { if (e.key.toLowerCase() in keys) keys[e.key.toLowerCase()] = false; });

function updateCamera(dt) {
    const sp = 40 * dt;
    if (keys.w) camTarget.z -= sp;
    if (keys.s) camTarget.z += sp;
    if (keys.a) camTarget.x -= sp;
    if (keys.d) camTarget.x += sp;
    camera.position.x = camTarget.x + Math.sin(camAngle) * camDist;
    camera.position.z = camTarget.z + Math.cos(camAngle) * camDist;
    camera.position.y = camDist * camPitch;
    camera.lookAt(camTarget);
}

// ============================================================
// MINIMAP
// ============================================================
const minimapCanvas = document.getElementById('minimap-canvas');
const minimapCtx = minimapCanvas.getContext('2d');

function drawMinimap() {
    const w = minimapCanvas.width;
    const h = minimapCanvas.height;
    const scale = w / 200; // Map 200 world units to canvas size
    const offsetX = w / 2;
    const offsetZ = h / 2;

    // Background
    minimapCtx.fillStyle = '#1a2a1a';
    minimapCtx.fillRect(0, 0, w, h);

    // Draw roads
    minimapCtx.fillStyle = '#444';
    city.roads.forEach(r => {
        minimapCtx.fillRect(
            offsetX + r.x * scale,
            offsetZ + r.z * scale,
            r.w * scale,
            r.h * scale
        );
    });

    // Draw parks
    minimapCtx.fillStyle = '#3a6a3a';
    city.parks.forEach(p => {
        minimapCtx.fillRect(
            offsetX + p.x * scale,
            offsetZ + p.z * scale,
            p.w * scale,
            p.h * scale
        );
    });

    // Draw buildings
    minimapCtx.fillStyle = '#666';
    city.buildings.forEach(b => {
        minimapCtx.fillRect(
            offsetX + b.x * scale,
            offsetZ + b.z * scale,
            b.w * scale,
            b.h * scale
        );
    });

    // Draw creatures
    world.creatures.forEach(c => {
        if (!c.alive) return;
        const cx = offsetX + c.x * scale;
        const cz = offsetZ + c.z * scale;

        if (c.type === 'plant') minimapCtx.fillStyle = '#00ff88';
        else if (c.type === 'herbivore') minimapCtx.fillStyle = '#00aaff';
        else if (c.type === 'predator') minimapCtx.fillStyle = '#ff4466';
        else if (c.type === 'human') {
            if (c.state === 'commuting_to_work' || c.state === 'commuting_home') {
                minimapCtx.fillStyle = '#ffaa00';
            } else {
                minimapCtx.fillStyle = '#ffdd44';
            }
        }

        minimapCtx.beginPath();
        minimapCtx.arc(cx, cz, c.type === 'human' ? 2 : 1.5, 0, Math.PI * 2);
        minimapCtx.fill();
    });

    // Draw camera view indicator
    minimapCtx.strokeStyle = 'rgba(255,255,255,0.5)';
    minimapCtx.lineWidth = 1;
    minimapCtx.beginPath();
    const camX = offsetX + camTarget.x * scale;
    const camZ = offsetZ + camTarget.z * scale;
    minimapCtx.arc(camX, camZ, 15, 0, Math.PI * 2);
    minimapCtx.stroke();
}

// ============================================================
// UI & CONTROLS
// ============================================================
let paused = false, timeScale = 1;
function togglePause() {
    paused = !paused;
    const btn = document.getElementById('btn-pause');
    btn.innerHTML = paused ? '‚ñ∂<span class="btn-text">Play</span>' : '‚è∏<span class="btn-text">Pause</span>';
    btn.setAttribute('aria-pressed', paused ? 'true' : 'false');
    btn.setAttribute('aria-label', paused ? 'Resume simulation' : 'Pause simulation');
}
function updateSpeed() { document.getElementById('speed-display').textContent = timeScale + 'x'; }

document.getElementById('btn-pause').onclick = togglePause;
document.getElementById('btn-speed-down').onclick = () => { timeScale = Math.max(0.25, timeScale / 2); updateSpeed(); };
document.getElementById('btn-speed-up').onclick = () => { timeScale = Math.min(20, timeScale * 2); updateSpeed(); };
document.getElementById('btn-spawn-human').onclick = () => world.spawn('human', 10);
document.getElementById('btn-spawn-herb').onclick = () => world.spawn('herbivore', 5);
document.getElementById('btn-spawn-pred').onclick = () => world.spawn('predator', 3);
document.getElementById('btn-rush-hour').onclick = function() {
    this.classList.toggle('active');
    const isActive = this.classList.contains('active');
    this.setAttribute('aria-pressed', isActive ? 'true' : 'false');
    world.timeOfDay = isActive ? 7.5 : 12;
};
document.getElementById('btn-save').onclick = () => world.save();
document.getElementById('btn-load').onclick = () => {
    if (confirm('Load saved simulation? Current simulation will be replaced.')) {
        world.load();
    }
};

const graphCanvas = document.getElementById('population-graph');
const graphCtx = graphCanvas.getContext('2d');

function drawGraph() {
    graphCtx.fillStyle = '#111';
    graphCtx.fillRect(0, 0, 300, 100);
    const hist = world.history;
    const max = Math.max(1, ...hist.plants, ...hist.herbivores, ...hist.predators, ...hist.humans);

    const draw = (data, color, dashPattern = []) => {
        if (data.length < 2) return;
        graphCtx.strokeStyle = color;
        graphCtx.lineWidth = 2;
        graphCtx.setLineDash(dashPattern);
        graphCtx.beginPath();
        data.forEach((v, i) => {
            const x = (i / 149) * 300;
            const y = 100 - (v / max) * 95;
            i === 0 ? graphCtx.moveTo(x, y) : graphCtx.lineTo(x, y);
        });
        graphCtx.stroke();
        graphCtx.setLineDash([]);
    };

    // Different dash patterns for accessibility (color-blind safe)
    draw(hist.plants, '#00ff88', []);           // Solid line
    draw(hist.herbivores, '#00aaff', [5, 3]);   // Dashed line
    draw(hist.predators, '#ff4466', [2, 2]);    // Dotted line
    draw(hist.humans, '#ffdd44', [8, 3, 2, 3]); // Dash-dot line
}

function updateUI() {
    const c = world.getCounts();
    const hs = world.getHumanStats();

    document.getElementById('stat-plants').textContent = c.plants;
    document.getElementById('stat-herbivores').textContent = c.herbivores;
    document.getElementById('stat-predators').textContent = c.predators;
    document.getElementById('stat-humans').textContent = c.humans;
    document.getElementById('stat-commuting').textContent = hs.commuting;
    document.getElementById('stat-working').textContent = hs.working;
    document.getElementById('stat-home').textContent = hs.home;
    document.getElementById('stat-generation').textContent = world.generation;

    // Update ecosystem health dashboard
    const health = world.getEcosystemHealth();
    document.getElementById('health-status').textContent = health.status;
    document.getElementById('health-status').style.color = health.color;
    document.getElementById('health-fill').style.width = health.score + '%';
    document.getElementById('health-fill').style.background = health.color;
    document.getElementById('prey-pred-ratio').textContent = health.ratio + ':1';
    document.getElementById('challenge-prompt').textContent = world.challenges[world.currentChallenge];

    // Clock display
    const hour = Math.floor(world.timeOfDay);
    const minute = Math.floor((world.timeOfDay % 1) * 60);
    const clockEl = document.getElementById('clock-display');
    clockEl.textContent = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
    clockEl.className = 'clock ' + (hour >= 6 && hour < 20 ? 'day' : 'night');
    document.getElementById('day-count').textContent = world.dayCount;

    // Traffic indicator
    const [traffic] = getTrafficLevel(hour);
    const trafficEl = document.getElementById('traffic-indicator');
    if (traffic > 0.6) {
        trafficEl.textContent = 'HEAVY TRAFFIC';
        trafficEl.className = 'high';
    } else if (traffic > 0.3) {
        trafficEl.textContent = 'MODERATE TRAFFIC';
        trafficEl.className = 'medium';
    } else {
        trafficEl.textContent = 'LOW TRAFFIC';
        trafficEl.className = 'low';
    }

    // Selected creature panel
    if (selectedCreature && !selectedCreature.alive) {
        selectedCreature = null;
        document.getElementById('creature-panel').classList.remove('visible');
    }
    if (selectedCreature) {
        const icons = { plant: 'üåø', herbivore: 'üê∞', predator: 'ü¶ä', human: 'üßë' };
        document.getElementById('creature-icon').textContent = icons[selectedCreature.type];
        document.getElementById('creature-name').textContent = `${selectedCreature.type} #${selectedCreature.id}`;
        document.getElementById('creature-energy').textContent = selectedCreature.energy.toFixed(1);
        document.getElementById('creature-age').textContent = selectedCreature.age.toFixed(1) + 's';
        document.getElementById('creature-state').textContent = selectedCreature.state || '-';

        if (selectedCreature.brain) {
            document.getElementById('brain-viz').innerHTML = selectedCreature.brain.lastActivations.slice(0, 12)
                .map(a => `<div class="neuron ${Math.abs(a) > 0.3 ? 'active' : ''}"></div>`).join('');
        } else {
            document.getElementById('brain-viz').innerHTML = '<span style="font-size:0.7em;color:#666">No neural network</span>';
        }
    }
}

// ============================================================
// MAIN LOOP
// ============================================================
const city = new City(scene);
const world = new World(city);
const particles = new ParticleTrailSystem(scene, 500);

// Predator and Human trail colors
const predatorTrailColor = new THREE.Color(0xff4466);
const humanTrailColor = new THREE.Color(0xffaa00);

// Initial spawn
for (let i = 0; i < 50; i++) world.spawn('plant');
for (let i = 0; i < 15; i++) world.spawn('herbivore');
for (let i = 0; i < 5; i++) world.spawn('predator');
for (let i = 0; i < 80; i++) world.spawn('human');

// Log initial event
world.logEvent("üåÖ A new day begins in Ecosystem City!", "info");

let lastTime = performance.now(), frames = 0, fpsTime = 0;
let trailTimer = 0;
let uiFrameCounter = 0; // ROUND 19: Frame throttling for HUD updates

// ============================================================
// ROUND 19: SMART AUTO-SAVE SYSTEM
// ============================================================
const AutoSave = {
    interval: 60000, // 60 seconds
    lastInteraction: Date.now(),
    enabled: true,
    maxCreatures: 200, // Only auto-save when manageable
    init() {
        // Track user activity
        ['mousedown', 'keydown', 'touchstart'].forEach(evt => {
            document.addEventListener(evt, () => this.lastInteraction = Date.now(), { passive: true });
        });
        // Schedule auto-saves
        setInterval(() => this.check(), 30000);
    },
    check() {
        if (!this.enabled) return;
        const idleTime = Date.now() - this.lastInteraction;
        const creatureCount = world.creatures.filter(c => c.alive).length;
        // Only save when idle 10s+ and creature count manageable
        if (idleTime > 10000 && creatureCount < this.maxCreatures) {
            this.save();
        }
    },
    save() {
        try {
            const data = {
                creatures: world.creatures.filter(c => c.alive).map(c => ({
                    type: c.type, x: c.x, z: c.z, energy: c.energy, age: c.age,
                    dna: c.dna ? { ...c.dna } : null
                })),
                timeOfDay: world.timeOfDay,
                dayCount: world.dayCount,
                generation: world.generation,
                simParams: { ...simParams },
                timestamp: Date.now()
            };
            // ROUND 20: Use StorageSafety for quota checking
            const success = StorageSafety.safeSet('ecosystem-autosave', data);
            if (success) {
                NotificationSystem.show('üíæ Auto-saved', 'success', 2000);
            }
        } catch (e) {
            console.warn('Auto-save failed:', e);
        }
    },
    load() {
        try {
            // ROUND 20: Use StorageSafety for safe loading
            const data = StorageSafety.safeGet('ecosystem-autosave');
            if (data && data.creatures) {
                NotificationSystem.show('üìÇ Auto-save found! Click Load to restore.', 'info', 5000);
            }
        } catch (e) {}
    }
};
AutoSave.init();
setTimeout(() => AutoSave.load(), 2000);

// ============================================================
// ROUND 19: KEYBOARD CREATURE NAVIGATION
// ============================================================
let keyboardCreatureIndex = -1;
function selectCreatureByKeyboard(direction) {
    const aliveCreatures = world.creatures.filter(c => c.alive);
    if (aliveCreatures.length === 0) return;

    if (direction === 'next') {
        keyboardCreatureIndex = (keyboardCreatureIndex + 1) % aliveCreatures.length;
    } else if (direction === 'prev') {
        keyboardCreatureIndex = (keyboardCreatureIndex - 1 + aliveCreatures.length) % aliveCreatures.length;
    }

    selectedCreature = aliveCreatures[keyboardCreatureIndex];
    document.getElementById('creature-panel').classList.add('visible');

    // Announce to screen readers
    const icons = { plant: 'Plant', herbivore: 'Herbivore', predator: 'Predator', human: 'Human' };
    const announcement = `Selected ${icons[selectedCreature.type]} number ${selectedCreature.id}, energy ${selectedCreature.energy.toFixed(0)}`;
    announceToScreenReader(announcement);
}

function announceToScreenReader(message) {
    let announcer = document.getElementById('sr-announcer');
    if (!announcer) {
        announcer = document.createElement('div');
        announcer.id = 'sr-announcer';
        announcer.setAttribute('role', 'status');
        announcer.setAttribute('aria-live', 'polite');
        announcer.className = 'sr-only';
        document.body.appendChild(announcer);
    }
    announcer.textContent = message;
}

// Focus trap for modal panels
function trapFocus(panel) {
    const focusable = panel.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
    if (focusable.length === 0) return;
    const first = focusable[0];
    const last = focusable[focusable.length - 1];

    panel.addEventListener('keydown', (e) => {
        if (e.key === 'Tab') {
            if (e.shiftKey && document.activeElement === first) {
                e.preventDefault();
                last.focus();
            } else if (!e.shiftKey && document.activeElement === last) {
                e.preventDefault();
                first.focus();
            }
        }
    });
    first.focus();
}

// Apply focus trap to all modal panels
document.querySelectorAll('[id$="-panel"]').forEach(panel => {
    const observer = new MutationObserver(() => {
        if (panel.style.display !== 'none' && panel.style.display !== '') {
            trapFocus(panel);
        }
    });
    observer.observe(panel, { attributes: true, attributeFilter: ['style'] });
});

function animate() {
    requestAnimationFrame(animate);

    // ROUND 20: Performance profiler start
    PerformanceProfiler.startFrame();

    const now = performance.now();
    const dt = Math.min((now - lastTime) / 1000, 0.1);
    lastTime = now;

    frames++; fpsTime += dt;
    if (fpsTime >= 1) { document.getElementById('stat-fps').textContent = frames; frames = 0; fpsTime = 0; }

    if (!paused) {
        // ROUND 20: Track world update time
        PerformanceProfiler.markWorldStart();
        world.update(dt * timeScale);
        PerformanceProfiler.markWorldEnd();

        // Emit particle trails from active creatures
        trailTimer += dt * timeScale;
        if (trailTimer > 0.05) { // Emit every 50ms of sim time
            trailTimer = 0;
            world.creatures.forEach(c => {
                if (!c.alive || !c.mesh) return;

                // Predators hunting leave red trails
                if (c.type === 'predator' && c.state === 'hunting') {
                    particles.emit(c.x, 0.3, c.z, predatorTrailColor, 0.8);
                }

                // Commuting humans leave orange trails
                if (c.type === 'human' && (c.state === 'commuting_to_work' || c.state === 'commuting_home')) {
                    particles.emit(c.x, 0.2, c.z, humanTrailColor, 0.5);
                }
            });

            // Update night lighting on windows (not every frame for performance)
            city.updateWindowLighting(world.timeOfDay);
        }

        particles.update(dt * timeScale);
    }

    updateCamera(dt);

    // ROUND 19: Frame-based throttling - update HUD every 5 frames (80% DOM reduction)
    uiFrameCounter++;
    if (uiFrameCounter >= 5) {
        uiFrameCounter = 0;
        // ROUND 20: Track DOM update time
        PerformanceProfiler.markDOMStart();
        updateUI();
        drawGraph();
        drawMinimap();
        PerformanceProfiler.markDOMEnd();
    }

    // ROUND 20: Track render time
    PerformanceProfiler.markRenderStart();
    renderer.render(scene, camera);
    PerformanceProfiler.markRenderEnd();

    // ROUND 20: End frame and update profiler UI
    PerformanceProfiler.endFrame();
    if (PerformanceProfiler.enabled && frames % 10 === 0) {
        PerformanceProfiler.updateUI();
    }
}

setTimeout(() => document.getElementById('loading').classList.add('hidden'), 1500);
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

// ============================================================
// ROUND 9: PRESET SCENARIOS SYSTEM
// ============================================================
const scenarios = [
    { name: "üåø Peaceful Garden", desc: "High plants, many herbivores, few predators", plants: 80, herbs: 25, preds: 2, humans: 20 },
    { name: "ü¶ä Predator Pressure", desc: "Test survival under high predation", plants: 40, herbs: 20, preds: 15, humans: 30 },
    { name: "üèôÔ∏è Rush Hour Chaos", desc: "Maximum human activity simulation", plants: 30, herbs: 10, preds: 5, humans: 150 },
    { name: "‚öñÔ∏è Perfect Balance", desc: "Classic predator-prey equilibrium", plants: 50, herbs: 15, preds: 5, humans: 40 },
    { name: "üå± Extinction Recovery", desc: "Start from near-extinction event", plants: 5, herbs: 3, preds: 1, humans: 10 }
];

function populateScenarios() {
    const list = document.getElementById('scenario-list');
    list.innerHTML = '';
    scenarios.forEach((s, i) => {
        const btn = document.createElement('button');
        btn.style.cssText = 'padding:15px;background:rgba(255,136,0,0.15);border:1px solid rgba(255,136,0,0.3);border-radius:10px;color:white;cursor:pointer;text-align:left;transition:all 0.2s;';
        btn.innerHTML = `<div style="font-weight:bold;margin-bottom:5px;">${s.name}</div><div style="font-size:0.85em;color:rgba(255,255,255,0.7);">${s.desc}</div><div style="font-size:0.75em;color:rgba(255,136,0,0.8);margin-top:5px;">üåø${s.plants} üê∞${s.herbs} ü¶ä${s.preds} üßë${s.humans}</div>`;
        btn.onmouseenter = () => btn.style.background = 'rgba(255,136,0,0.3)';
        btn.onmouseleave = () => btn.style.background = 'rgba(255,136,0,0.15)';
        btn.onclick = () => loadScenario(i);
        list.appendChild(btn);
    });
}

function loadScenario(index) {
    const s = scenarios[index];
    // Clear existing creatures
    world.creatures.forEach(c => { if (c.mesh) scene.remove(c.mesh); });
    world.creatures = [];
    world.plants = [];
    world.herbivores = [];
    world.predators = [];
    world.humans = [];
    world.spatialGrid.clear();

    // Spawn new according to scenario
    for (let i = 0; i < s.plants; i++) world.spawn('plant');
    for (let i = 0; i < s.herbs; i++) world.spawn('herbivore');
    for (let i = 0; i < s.preds; i++) world.spawn('predator');
    for (let i = 0; i < s.humans; i++) world.spawn('human');

    world.logEvent(`üéÆ Loaded scenario: ${s.name}`, 'info');
    document.getElementById('scenario-panel').style.display = 'none';
}

document.getElementById('btn-scenarios').onclick = () => {
    populateScenarios();
    document.getElementById('scenario-panel').style.display = 'block';
};
document.getElementById('btn-close-scenarios').onclick = () => {
    document.getElementById('scenario-panel').style.display = 'none';
};

// ============================================================
// ROUND 9: PARAMETER SLIDERS - REAL-TIME TUNING
// (simParams moved to top of file in Round 18 for proper initialization)
// ============================================================

document.getElementById('slider-plant').oninput = (e) => {
    simParams.plantGrowth = parseFloat(e.target.value);
    document.getElementById('val-plant').textContent = simParams.plantGrowth.toFixed(1) + 'x';
};
document.getElementById('slider-pred').oninput = (e) => {
    simParams.predSpeed = parseFloat(e.target.value);
    document.getElementById('val-pred').textContent = simParams.predSpeed.toFixed(1) + 'x';
};
document.getElementById('slider-herb').oninput = (e) => {
    simParams.herbSpeed = parseFloat(e.target.value);
    document.getElementById('val-herb').textContent = simParams.herbSpeed.toFixed(1) + 'x';
};
document.getElementById('slider-energy').oninput = (e) => {
    simParams.energyDrain = parseFloat(e.target.value);
    document.getElementById('val-energy').textContent = simParams.energyDrain.toFixed(1) + 'x';
};

document.getElementById('btn-params').onclick = () => {
    document.getElementById('params-panel').style.display = 'block';
};
document.getElementById('btn-close-params').onclick = () => {
    document.getElementById('params-panel').style.display = 'none';
};
document.getElementById('btn-reset-params').onclick = () => {
    simParams.plantGrowth = simParams.predSpeed = simParams.herbSpeed = simParams.energyDrain = 1;
    document.getElementById('slider-plant').value = 1;
    document.getElementById('slider-pred').value = 1;
    document.getElementById('slider-herb').value = 1;
    document.getElementById('slider-energy').value = 1;
    document.getElementById('val-plant').textContent = '1.0x';
    document.getElementById('val-pred').textContent = '1.0x';
    document.getElementById('val-herb').textContent = '1.0x';
    document.getElementById('val-energy').textContent = '1.0x';
};

// Integrate params into creature behavior (monkey-patch update logic)
const originalCreatureUpdate = Creature.prototype.updateBehavior;
Creature.prototype.updateBehavior = function(dt) {
    let modifiedDt = dt;
    if (this.type === 'predator') modifiedDt *= simParams.predSpeed;
    else if (this.type === 'herbivore') modifiedDt *= simParams.herbSpeed;
    // Energy drain modifier applied in main update
    originalCreatureUpdate.call(this, modifiedDt);
};

// ============================================================
// ROUND 10: EDUCATIONAL LAB MODE SYSTEM
// ============================================================
const experiments = [
    {
        name: "ü¶ä Predator-Prey Dynamics",
        desc: "What happens when predator population doubles?",
        hypothesis: "Hypothesis: Herbivore population will decrease initially, then predators will starve.",
        setup: () => { for (let i = 0; i < 5; i++) world.spawn('predator'); },
        measure: () => world.getCounts().herbivores,
        label: "Herbivores"
    },
    {
        name: "üåø Resource Competition",
        desc: "How does plant scarcity affect herbivores?",
        hypothesis: "Hypothesis: With fewer plants, herbivore competition increases and population crashes.",
        setup: () => { simParams.plantGrowth = 0.3; document.getElementById('slider-plant').value = 0.3; document.getElementById('val-plant').textContent = '0.3x'; },
        measure: () => world.getCounts().herbivores,
        label: "Herbivores"
    },
    {
        name: "‚ö° Energy Efficiency",
        desc: "Which creatures survive high metabolism stress?",
        hypothesis: "Hypothesis: Creatures with efficient DNA traits will outlast others.",
        setup: () => { simParams.energyDrain = 1.8; document.getElementById('slider-energy').value = 1.8; document.getElementById('val-energy').textContent = '1.8x'; },
        measure: () => world.getCounts().herbivores + world.getCounts().predators,
        label: "Total Fauna"
    },
    {
        name: "üß¨ Natural Selection",
        desc: "Track trait evolution across generations",
        hypothesis: "Hypothesis: Speed trait will increase as slower creatures get eaten.",
        setup: () => { for (let i = 0; i < 3; i++) world.spawn('predator'); },
        measure: () => {
            const herbs = world.creatures.filter(c => c.type === 'herbivore');
            return herbs.length ? (herbs.reduce((s, h) => s + h.dna.speed, 0) / herbs.length).toFixed(2) : 0;
        },
        label: "Avg Speed"
    }
];

let activeExperiment = null;
let experimentStartVal = 0;
let experimentStartTime = 0;

function populateExperiments() {
    const list = document.getElementById('experiment-list');
    list.innerHTML = '';
    experiments.forEach((exp, i) => {
        const btn = document.createElement('button');
        btn.style.cssText = 'padding:12px;background:rgba(0,255,136,0.1);border:1px solid rgba(0,255,136,0.3);border-radius:8px;color:white;cursor:pointer;text-align:left;transition:all 0.2s;';
        btn.innerHTML = `<div style="font-weight:bold;margin-bottom:4px;">${exp.name}</div><div style="font-size:0.8em;color:rgba(255,255,255,0.6);">${exp.desc}</div>`;
        btn.onmouseenter = () => btn.style.background = 'rgba(0,255,136,0.2)';
        btn.onmouseleave = () => btn.style.background = 'rgba(0,255,136,0.1)';
        btn.onclick = () => startExperiment(i);
        list.appendChild(btn);
    });
}

function startExperiment(index) {
    const exp = experiments[index];
    activeExperiment = exp;
    experimentStartVal = exp.measure();
    experimentStartTime = Date.now();

    document.getElementById('experiment-list').style.display = 'none';
    document.getElementById('lab-active').style.display = 'block';
    document.getElementById('lab-experiment-title').textContent = exp.name;
    document.getElementById('lab-hypothesis').textContent = exp.hypothesis;
    document.getElementById('lab-start-val').textContent = experimentStartVal;

    exp.setup();
    world.logEvent(`üî¨ Started experiment: ${exp.name}`, 'info');
    announceToScreenReader(`Started experiment: ${exp.name}`);
}

function updateLabDisplay() {
    if (!activeExperiment) return;
    const current = activeExperiment.measure();
    const elapsed = Math.floor((Date.now() - experimentStartTime) / 1000);
    document.getElementById('lab-current-val').textContent = current;
    document.getElementById('lab-time').textContent = elapsed + 's';
}

function endExperiment() {
    if (!activeExperiment) return;
    const finalVal = activeExperiment.measure();
    const elapsed = Math.floor((Date.now() - experimentStartTime) / 1000);
    const change = finalVal - experimentStartVal;
    const result = `üìä ${activeExperiment.name}\nStart: ${experimentStartVal} | End: ${finalVal} | Change: ${change > 0 ? '+' : ''}${change}\nDuration: ${elapsed}s`;

    world.logEvent(`üî¨ Experiment complete! ${activeExperiment.label}: ${experimentStartVal} ‚Üí ${finalVal}`, 'evolution');
    announceToScreenReader(`Experiment complete. ${activeExperiment.label} changed from ${experimentStartVal} to ${finalVal}`);

    // Reset
    activeExperiment = null;
    document.getElementById('lab-active').style.display = 'none';
    document.getElementById('experiment-list').style.display = 'grid';

    // Show result notification
    NotificationSystem.show(result + '\n\nDid your hypothesis hold true?', 'info', 8000);
}

document.getElementById('btn-lab').onclick = () => {
    populateExperiments();
    document.getElementById('lab-panel').style.display = 'block';
};
document.getElementById('btn-close-lab').onclick = () => {
    document.getElementById('lab-panel').style.display = 'none';
};
document.getElementById('btn-end-experiment').onclick = endExperiment;

// Update lab display in animation loop
setInterval(updateLabDisplay, 500);

// ============================================================
// ROUND 10: ACCESSIBILITY ENHANCEMENTS
// ============================================================
function announceToScreenReader(message) {
    const announcer = document.getElementById('sr-announcements');
    if (announcer) {
        announcer.textContent = message;
        setTimeout(() => announcer.textContent = '', 1000);
    }
}

// Announce significant events
const originalLogEvent = world.logEvent.bind(world);
world.logEvent = function(message, type) {
    originalLogEvent(message, type);
    if (type === 'evolution' || type === 'danger') {
        announceToScreenReader(message.replace(/[üåøü¶äüß¨üî¨üìäüåãüéÆ]/g, ''));
    }
};

// Focus trap for modal panels
document.querySelectorAll('#scenario-panel, #params-panel, #lab-panel').forEach(panel => {
    panel.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') panel.style.display = 'none';
    });
});

// ============================================================
// ROUND 10: PERFORMANCE OPTIMIZATIONS
// ============================================================
// Frustum culling check helper
const frustum = new THREE.Frustum();
const projScreenMatrix = new THREE.Matrix4();

function isInView(obj) {
    projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    frustum.setFromProjectionMatrix(projScreenMatrix);
    return frustum.containsPoint(obj.position);
}

// LOD: Reduce update frequency for distant creatures
const originalCreatureUpdateMethod = Creature.prototype.update;
Creature.prototype.update = function(dt, world) {
    if (!this.alive || !this.mesh) return originalCreatureUpdateMethod.call(this, dt, world);

    // Track distance traveled
    const oldX = this.x, oldZ = this.z;

    // Skip some updates for distant creatures
    const dist = camera.position.distanceTo(this.mesh.position);
    if (dist > 60) {
        // Far creatures: update every 3rd frame
        this.skipCounter = (this.skipCounter || 0) + 1;
        if (this.skipCounter % 3 !== 0) {
            // Still update position visually
            if (this.mesh) this.mesh.position.set(this.x, this.meshSize || 0.3, this.z);
            return;
        }
    }
    originalCreatureUpdateMethod.call(this, dt, world);

    // Update distance traveled (ROUND 11)
    this.distanceTraveled += Math.sqrt((this.x - oldX) ** 2 + (this.z - oldZ) ** 2);
};

// ============================================================
// ROUND 11: LINEAGE SYSTEM
// ============================================================
let lineageTarget = null;
const creatureArchive = new Map(); // Store dead creatures for lineage lookup

// Override die to archive creatures
const originalDie = Creature.prototype.die;
Creature.prototype.die = function() {
    this.causeOfDeath = this.energy <= 0 ? 'starvation' : (this.age > 80 ? 'old_age' : 'predation');
    creatureArchive.set(this.id, {
        id: this.id,
        type: this.type,
        generation: this.generation,
        parentIds: this.parentIds,
        offspring: this.offspring,
        foodEaten: this.foodEaten,
        distanceTraveled: this.distanceTraveled,
        dna: { ...this.dna },
        causeOfDeath: this.causeOfDeath,
        lifespan: this.age
    });
    // Keep archive size manageable - capped at 500 for memory efficiency
    // Note: Using Map (not WeakMap) to preserve lineage viewer iteration capability
    if (creatureArchive.size > 500) {
        const oldest = creatureArchive.keys().next().value;
        creatureArchive.delete(oldest);
    }
    originalDie.call(this);
};

function showLineage(creature) {
    lineageTarget = creature;
    const panel = document.getElementById('lineage-panel');
    panel.style.display = 'block';
    updateLineageDisplay();
}

function updateLineageDisplay() {
    if (!lineageTarget) return;
    const c = lineageTarget;
    document.getElementById('lineage-type').textContent = `${c.type === 'herbivore' ? 'üê∞' : c.type === 'predator' ? 'ü¶ä' : 'üåø'} ${c.type.charAt(0).toUpperCase() + c.type.slice(1)} #${c.id}`;
    document.getElementById('lineage-gen').textContent = `Gen ${c.generation}`;
    document.getElementById('lineage-age').textContent = c.age.toFixed(1);
    document.getElementById('lineage-energy').textContent = c.energy.toFixed(0);
    document.getElementById('lineage-dist').textContent = c.distanceTraveled.toFixed(1);
    document.getElementById('lineage-food').textContent = c.foodEaten;
    document.getElementById('lineage-offspring').textContent = c.offspring;
    document.getElementById('lineage-speed').textContent = c.dna.speed.toFixed(2);

    // Build family tree
    const treeDiv = document.getElementById('lineage-tree-display');
    let treeHTML = `<div style="font-size:1.2em;margin-bottom:10px;">üë§ #${c.id}</div>`;
    if (c.parentIds.length > 0) {
        treeHTML += `<div style="font-size:0.85em;color:rgba(255,255,255,0.7);">Parents: `;
        treeHTML += c.parentIds.map(pid => {
            const p = creatureArchive.get(pid) || world.creatures.find(cr => cr.id === pid);
            return p ? `#${pid} (Gen ${p.generation})` : `#${pid}`;
        }).join(' + ');
        treeHTML += `</div>`;
    } else {
        treeHTML += `<div style="font-size:0.85em;color:rgba(255,255,255,0.5);">Original Generation</div>`;
    }
    treeDiv.innerHTML = treeHTML;
}

document.getElementById('btn-lineage').onclick = () => {
    if (selectedCreature) {
        showLineage(selectedCreature);
    } else {
        document.getElementById('lineage-panel').style.display = 'block';
        document.getElementById('lineage-tree-display').innerHTML = '<div style="color:rgba(255,255,255,0.5);">Select a creature first</div>';
    }
};
document.getElementById('btn-close-lineage').onclick = () => {
    document.getElementById('lineage-panel').style.display = 'none';
};

// Update lineage display periodically
setInterval(() => { if (lineageTarget?.alive) updateLineageDisplay(); }, 500);

// ============================================================
// ROUND 11: ECOSYSTEM CHALLENGES
// ============================================================
const challenges = [
    { name: "üê∞ Population Boom", desc: "Reach 50 herbivores", measure: () => world.getCounts().herbivores, target: 50 },
    { name: "ü¶ä Apex Balance", desc: "Maintain 10+ predators for 60s", measure: () => world.getCounts().predators >= 10 ? 1 : 0, target: 60, accumulate: true },
    { name: "üß¨ Evolution Master", desc: "Reach generation 10", measure: () => world.generation, target: 10 },
    { name: "üåø Green Paradise", desc: "Grow 100 plants simultaneously", measure: () => world.getCounts().plants, target: 100 },
    { name: "‚öñÔ∏è Perfect Ecosystem", desc: "Keep all species alive for 3 min", measure: () => { const c = world.getCounts(); return (c.plants > 5 && c.herbivores > 5 && c.predators > 2) ? 1 : 0; }, target: 180, accumulate: true },
    { name: "üèÉ Speed Breeding", desc: "Breed herbivores with avg speed > 0.7", measure: () => { const h = world.creatures.filter(c => c.type === 'herbivore'); return h.length ? h.reduce((s, c) => s + c.dna.speed, 0) / h.length : 0; }, target: 0.7 }
];

let activeChallenge = null;
let challengeProgress = 0;
let challengeStartTime = 0;

function populateChallenges() {
    const list = document.getElementById('challenge-list');
    list.innerHTML = '';
    challenges.forEach((ch, i) => {
        const btn = document.createElement('button');
        btn.style.cssText = 'padding:12px;background:rgba(255,215,0,0.1);border:1px solid rgba(255,215,0,0.3);border-radius:8px;color:white;cursor:pointer;text-align:left;transition:all 0.2s;';
        btn.innerHTML = `<div style="font-weight:bold;">${ch.name}</div><div style="font-size:0.8em;color:rgba(255,255,255,0.6);">${ch.desc}</div>`;
        btn.onclick = () => startChallenge(i);
        list.appendChild(btn);
    });
}

function startChallenge(index) {
    activeChallenge = challenges[index];
    challengeProgress = 0;
    challengeStartTime = Date.now();
    document.getElementById('challenge-list').style.display = 'none';
    document.getElementById('active-challenge').style.display = 'block';
    document.getElementById('challenge-title').textContent = activeChallenge.name;
    document.getElementById('challenge-desc').textContent = activeChallenge.desc;
    document.getElementById('challenge-target').textContent = activeChallenge.target;
    world.logEvent(`üèÜ Challenge started: ${activeChallenge.name}`, 'info');
}

function updateChallenge() {
    if (!activeChallenge) return;
    const current = activeChallenge.measure();
    if (activeChallenge.accumulate) {
        if (current > 0) challengeProgress += 0.5; // +0.5s per 500ms interval
    } else {
        challengeProgress = current;
    }
    document.getElementById('challenge-current').textContent = activeChallenge.accumulate ? Math.floor(challengeProgress) + 's' : challengeProgress.toFixed?.(2) || challengeProgress;
    const pct = Math.min(100, (challengeProgress / activeChallenge.target) * 100);
    document.getElementById('challenge-progress-bar').style.width = pct + '%';

    if (challengeProgress >= activeChallenge.target) {
        world.logEvent(`üèÜ Challenge complete: ${activeChallenge.name}!`, 'evolution');
        announceToScreenReader(`Challenge complete! ${activeChallenge.name}`);
        activeChallenge = null;
        document.getElementById('active-challenge').style.display = 'none';
        document.getElementById('challenge-list').style.display = 'grid';
    }
}

document.getElementById('btn-challenges').onclick = () => {
    populateChallenges();
    document.getElementById('challenges-panel').style.display = 'block';
};
document.getElementById('btn-close-challenges').onclick = () => {
    document.getElementById('challenges-panel').style.display = 'none';
};

setInterval(updateChallenge, 500);

// ============================================================
// ROUND 11: HEATMAP OVERLAY
// ============================================================
let heatmapEnabled = false;
let heatmapInterval = null;
const heatmapCanvas = document.getElementById('heatmap-canvas');
const heatmapCtx = heatmapCanvas?.getContext('2d');

function resizeHeatmap() {
    if (heatmapCanvas) {
        heatmapCanvas.width = window.innerWidth;
        heatmapCanvas.height = window.innerHeight;
    }
}
window.addEventListener('resize', resizeHeatmap);
resizeHeatmap();

function drawHeatmap() {
    if (!heatmapEnabled || !heatmapCtx) return;
    heatmapCtx.clearRect(0, 0, heatmapCanvas.width, heatmapCanvas.height);

    // Project world positions to screen
    world.creatures.forEach(c => {
        if (!c.alive || !c.mesh) return;
        const pos = c.mesh.position.clone().project(camera);
        const x = (pos.x + 1) / 2 * heatmapCanvas.width;
        const y = (-pos.y + 1) / 2 * heatmapCanvas.height;
        if (pos.z > 1) return; // Behind camera

        // Draw heat based on creature type
        const gradient = heatmapCtx.createRadialGradient(x, y, 0, x, y, 40);
        if (c.type === 'predator') {
            gradient.addColorStop(0, 'rgba(255,50,50,0.6)');
            gradient.addColorStop(1, 'rgba(255,50,50,0)');
        } else if (c.type === 'herbivore') {
            gradient.addColorStop(0, 'rgba(50,150,255,0.4)');
            gradient.addColorStop(1, 'rgba(50,150,255,0)');
        } else if (c.type === 'plant') {
            gradient.addColorStop(0, 'rgba(50,255,100,0.3)');
            gradient.addColorStop(1, 'rgba(50,255,100,0)');
        }
        heatmapCtx.fillStyle = gradient;
        heatmapCtx.fillRect(x - 40, y - 40, 80, 80);
    });
}

document.getElementById('btn-heatmap').onclick = () => {
    heatmapEnabled = !heatmapEnabled;
    document.getElementById('btn-heatmap').classList.toggle('active', heatmapEnabled);
    document.getElementById('btn-heatmap').setAttribute('aria-pressed', heatmapEnabled);
    heatmapCanvas.style.display = heatmapEnabled ? 'block' : 'none';

    // IMPROVEMENT: Only run interval when heatmap is enabled
    if (heatmapEnabled) {
        if (!heatmapInterval) heatmapInterval = setInterval(drawHeatmap, 100);
    } else {
        if (heatmapInterval) {
            clearInterval(heatmapInterval);
            heatmapInterval = null;
        }
    }
};

// ============================================================
// ROUND 12: SOUND SYSTEM IMPLEMENTATION
// ============================================================
let soundEnabled = false;
let audioCtx = null;

function initAudio() {
    if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    return audioCtx;
}

function playSound(type, volume = 0.3) {
    if (!soundEnabled || !audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);

    switch (type) {
        case 'birth':
            osc.frequency.setValueAtTime(880, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(1760, audioCtx.currentTime + 0.1);
            osc.type = 'sine';
            gain.gain.setValueAtTime(volume * 0.5, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
            osc.start(); osc.stop(audioCtx.currentTime + 0.2);
            break;
        case 'death':
            osc.frequency.setValueAtTime(220, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(55, audioCtx.currentTime + 0.3);
            osc.type = 'sawtooth';
            gain.gain.setValueAtTime(volume * 0.3, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
            osc.start(); osc.stop(audioCtx.currentTime + 0.3);
            break;
        case 'hunt':
            osc.frequency.setValueAtTime(150, audioCtx.currentTime);
            osc.type = 'square';
            gain.gain.setValueAtTime(volume * 0.2, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
            osc.start(); osc.stop(audioCtx.currentTime + 0.15);
            break;
        case 'ambient':
            // Soft ambient hum
            osc.frequency.setValueAtTime(80 + Math.random() * 40, audioCtx.currentTime);
            osc.type = 'sine';
            gain.gain.setValueAtTime(volume * 0.05, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 2);
            osc.start(); osc.stop(audioCtx.currentTime + 2);
            break;
    }
}

document.getElementById('btn-sound').onclick = () => {
    soundEnabled = !soundEnabled;
    if (soundEnabled) {
        initAudio();
        if (audioCtx.state === 'suspended') audioCtx.resume();
    }
    const btn = document.getElementById('btn-sound');
    btn.innerHTML = soundEnabled ? 'üîä<span class="btn-text">Sound</span>' : 'üîá<span class="btn-text">Sound</span>';
    btn.classList.toggle('active', soundEnabled);
    btn.setAttribute('aria-pressed', soundEnabled);
};

// Hook sounds into creature events
const originalWorldLogEvent = world.logEvent.bind(world);
world.logEvent = function(msg, type) {
    originalWorldLogEvent(msg, type);
    if (msg.includes('born') || msg.includes('Born')) playSound('birth');
    if (msg.includes('extinct') || msg.includes('perished')) playSound('death');
    if (msg.includes('hunting') || msg.includes('killed')) playSound('hunt');
};

// Ambient sound every few seconds
setInterval(() => { if (soundEnabled) playSound('ambient'); }, 5000);

// ============================================================
// ROUND 12: AUTO-SAVE SYSTEM
// ============================================================
let autoSaveEnabled = true;
const AUTO_SAVE_KEY = 'ecosystem-city-autosave';
const AUTO_SAVE_INTERVAL = 60000; // Every 60 seconds

function autoSave() {
    if (!autoSaveEnabled) return;
    try {
        const saveData = world.toJSON();

        // IMPROVEMENT: Protect against localStorage quota exceeded
        // Truncate history if save is too large
        if (saveData.history?.plants?.length > 200) {
            saveData.history.plants = saveData.history.plants.slice(-200);
            saveData.history.herbivores = saveData.history.herbivores.slice(-200);
            saveData.history.predators = saveData.history.predators.slice(-200);
            saveData.history.humans = saveData.history.humans.slice(-200);
        }

        const jsonStr = JSON.stringify(saveData);
        localStorage.setItem(AUTO_SAVE_KEY, jsonStr);
        localStorage.setItem(AUTO_SAVE_KEY + '-time', new Date().toISOString());
        console.log('Auto-saved at', new Date().toLocaleTimeString());
    } catch (e) {
        if (e.name === 'QuotaExceededError') {
            console.warn('LocalStorage quota exceeded. Disabling auto-save.');
            autoSaveEnabled = false;
            world.logEvent('‚ö†Ô∏è Auto-save disabled: storage full', 'info');
        } else {
            console.warn('Auto-save failed:', e);
        }
    }
}

function checkAutoSave() {
    const saved = localStorage.getItem(AUTO_SAVE_KEY);
    const savedTime = localStorage.getItem(AUTO_SAVE_KEY + '-time');
    if (saved && savedTime) {
        const timeDiff = Date.now() - new Date(savedTime).getTime();
        if (timeDiff < 3600000) { // Less than 1 hour old
            const timeAgo = Math.floor(timeDiff / 60000);
            if (confirm(`Found auto-save from ${timeAgo} minutes ago. Restore?`)) {
                try {
                    const data = JSON.parse(saved);
                    world.fromJSON(data);
                    world.logEvent('üîÑ Auto-save restored!', 'info');
                } catch (e) {
                    console.warn('Failed to restore auto-save:', e);
                }
            }
        }
    }
}

setInterval(autoSave, AUTO_SAVE_INTERVAL);
setTimeout(checkAutoSave, 2000); // Check for auto-save after loading

// ============================================================
// ROUND 12: CONTEXTUAL LEARNING TOOLTIPS
// ============================================================
const learningTips = [
    { trigger: 'first-predator-death', tip: 'üí° Tip: Predators need prey! If herbivores die out, predators starve.', shown: false },
    { trigger: 'high-generation', tip: 'üß¨ Notice: Natural selection is working! Faster creatures are surviving longer.', shown: false },
    { trigger: 'population-crash', tip: '‚ö†Ô∏è Population crash! This often happens when predators eat all prey - classic boom-bust cycle.', shown: false },
    { trigger: 'first-experiment', tip: 'üî¨ Great! Use experiments to test hypotheses about ecosystem dynamics.', shown: false }
];

function showLearningTip(trigger) {
    const tip = learningTips.find(t => t.trigger === trigger && !t.shown);
    if (tip) {
        tip.shown = true;
        const tipDiv = document.createElement('div');
        tipDiv.style.cssText = 'position:fixed;bottom:80px;left:50%;transform:translateX(-50%);background:rgba(0,100,200,0.95);color:white;padding:15px 25px;border-radius:12px;z-index:2000;max-width:400px;text-align:center;animation:fadeInOut 5s forwards;';
        tipDiv.textContent = tip.tip;
        document.body.appendChild(tipDiv);
        setTimeout(() => tipDiv.remove(), 5000);
    }
}

// Track events for tips
let predatorDeathCount = 0;
let lastPopCheck = { herbs: 15, preds: 5 };

setInterval(() => {
    const counts = world.getCounts();
    // First predator death
    if (counts.predators < lastPopCheck.preds && predatorDeathCount === 0) {
        predatorDeathCount++;
        if (counts.herbivores < 5) showLearningTip('first-predator-death');
    }
    // High generation
    if (world.generation >= 5 && !learningTips[1].shown) {
        showLearningTip('high-generation');
    }
    // Population crash
    if (counts.herbivores < 3 && lastPopCheck.herbs > 10) {
        showLearningTip('population-crash');
    }
    lastPopCheck = { herbs: counts.herbivores, preds: counts.predators };
}, 3000);

// ============================================================
// ROUND 13: DATA EXPORT SYSTEM
// ============================================================
function exportToCSV() {
    const counts = world.getCounts();
    const rows = [
        ['Ecosystem City Data Export'],
        ['Generated', new Date().toISOString()],
        [''],
        ['Current State'],
        ['Plants', counts.plants],
        ['Herbivores', counts.herbivores],
        ['Predators', counts.predators],
        ['Humans', counts.humans],
        ['Generation', world.generation],
        ['Day', world.dayCount],
        ['Time of Day', world.timeOfDay.toFixed(1)],
        [''],
        ['Population History (last 50 data points)'],
        ['Index', 'Plants', 'Herbivores', 'Predators', 'Humans']
    ];

    const histLen = Math.min(50, world.history.plants.length);
    for (let i = world.history.plants.length - histLen; i < world.history.plants.length; i++) {
        rows.push([i, world.history.plants[i], world.history.herbivores[i], world.history.predators[i], world.history.humans[i]]);
    }

    rows.push(['']);
    rows.push(['Top 10 Creatures by Fitness']);
    rows.push(['ID', 'Type', 'Generation', 'Age', 'Energy', 'Speed', 'Distance']);
    const topCreatures = [...world.creatures].filter(c => c.type !== 'plant' && c.type !== 'human').sort((a, b) => b.fitness - a.fitness).slice(0, 10);
    topCreatures.forEach(c => {
        rows.push([c.id, c.type, c.generation, c.age.toFixed(1), c.energy.toFixed(0), c.dna.speed.toFixed(3), c.distanceTraveled.toFixed(1)]);
    });

    const csv = rows.map(row => row.join(',')).join('\n');
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `ecosystem-city-${Date.now()}.csv`;
    a.click();
    URL.revokeObjectURL(url);
    world.logEvent('üìä Data exported to CSV!', 'info');
}

document.getElementById('btn-export').onclick = exportToCSV;

// ============================================================
// ROUND 13: ONBOARDING TUTORIAL
// ============================================================
const TUTORIAL_SHOWN_KEY = 'ecosystem-city-tutorial-shown';

function showTutorial() {
    document.getElementById('tutorial-panel').style.display = 'block';
}

function closeTutorial() {
    document.getElementById('tutorial-panel').style.display = 'none';
}

document.getElementById('btn-help').onclick = showTutorial;
document.getElementById('btn-close-tutorial').onclick = closeTutorial;
document.getElementById('btn-dont-show').onclick = () => {
    localStorage.setItem(TUTORIAL_SHOWN_KEY, 'true');
    closeTutorial();
};

// ============================================================
// ROUND 22: PROGRESSIVE DISCLOSURE - ADVANCED CONTROLS TOGGLE
// ============================================================
document.getElementById('btn-toggle-advanced').onclick = () => {
    const advanced = document.getElementById('advanced-controls');
    const btn = document.getElementById('btn-toggle-advanced');
    const isVisible = advanced.style.display !== 'none';
    advanced.style.display = isVisible ? 'none' : 'flex';
    btn.setAttribute('aria-expanded', !isVisible);
    btn.querySelector('.btn-text').textContent = isVisible ? 'More' : 'Less';
    // Save preference
    localStorage.setItem('ecosystem-advanced-visible', !isVisible);
};

// Restore advanced controls preference
if (localStorage.getItem('ecosystem-advanced-visible') === 'true') {
    document.getElementById('advanced-controls').style.display = 'flex';
    document.getElementById('btn-toggle-advanced').setAttribute('aria-expanded', 'true');
    document.getElementById('btn-toggle-advanced').querySelector('.btn-text').textContent = 'Less';
}

// ============================================================
// ROUND 20: PROFILER AND ERROR PANEL BUTTON HANDLERS
// ============================================================

// Profiler panel toggle
document.getElementById('btn-profiler').onclick = () => {
    const panel = document.getElementById('profiler-panel');
    const isVisible = panel.style.display === 'block';
    panel.style.display = isVisible ? 'none' : 'block';
    PerformanceProfiler.enabled = !isVisible;
    document.getElementById('btn-profiler').setAttribute('aria-pressed', !isVisible);
    if (!isVisible) {
        NotificationSystem.show('‚ö° Performance profiler enabled', 'info', 2000);
    }
};

document.getElementById('btn-close-profiler').onclick = () => {
    document.getElementById('profiler-panel').style.display = 'none';
    PerformanceProfiler.enabled = false;
    document.getElementById('btn-profiler').setAttribute('aria-pressed', 'false');
};

document.getElementById('btn-export-profile').onclick = () => {
    PerformanceProfiler.exportData();
};

// Error panel handlers
document.getElementById('btn-clear-errors').onclick = () => {
    ErrorBoundary.clearErrors();
};

document.getElementById('btn-export-errors').onclick = () => {
    ErrorBoundary.exportErrors();
};

// Show tutorial on first visit
setTimeout(() => {
    if (!localStorage.getItem(TUTORIAL_SHOWN_KEY)) {
        showTutorial();
    }
}, 2500);

// ============================================================
// ROUND 13: ERROR HANDLING & RECOVERY
// ============================================================
function showError(message) {
    document.getElementById('error-message').textContent = message;
    document.getElementById('error-overlay').style.display = 'flex';
}

document.getElementById('btn-reload').onclick = () => location.reload();

// Global error handler
window.onerror = (msg, source, line) => {
    console.error('Global error:', msg, source, line);
    if (msg.includes('WebGL') || msg.includes('THREE') || msg.includes('context')) {
        showError('WebGL rendering failed. Your browser may not support 3D graphics, or the GPU is unavailable. Try refreshing or using a different browser.');
    }
    return false;
};

// WebGL context lost handler
if (renderer?.domElement) {
    renderer.domElement.addEventListener('webglcontextlost', (e) => {
        e.preventDefault();
        showError('WebGL context lost. This can happen when the GPU is overloaded. Please reload the page.');
    });
}

// Catch unhandled promise rejections
window.onunhandledrejection = (e) => {
    console.error('Unhandled rejection:', e.reason);
};

// ============================================================
// ROUND 15: CULTURAL EVOLUTION ENGINE
// ============================================================
// Creatures learn from observing successful neighbors
function updateCulturalLearning(creature, world, delta) {
    if (creature.type === 'plant' || creature.type === 'human') return;

    creature.observationCooldown -= delta;
    if (creature.observationCooldown > 0) return;
    creature.observationCooldown = 2; // Observe every 2 seconds

    // Find nearby successful creatures of same type
    const nearby = world.spatialGrid.getNearby(creature.x, creature.z, 8)
        .filter(c => c.type === creature.type && c.id !== creature.id && c.alive);

    nearby.forEach(neighbor => {
        // Learn from successful behaviors
        if (neighbor.lastSuccessfulAction && neighbor.energy > creature.energy) {
            // Copy successful behavior with some probability
            if (Math.random() < 0.3) {
                creature.culturalMemory.push({
                    behavior: neighbor.lastSuccessfulAction,
                    successRate: neighbor.fitness / Math.max(1, neighbor.age),
                    source: neighbor.id
                });
                // Cap memory size
                if (creature.culturalMemory.length > 5) creature.culturalMemory.shift();
            }
        }
    });

    // Apply cultural bias to brain (subtle influence)
    if (creature.culturalMemory.length > 0) {
        const bestCultural = creature.culturalMemory.reduce((a, b) =>
            a.successRate > b.successRate ? a : b);
        // Slightly bias neural network toward learned behaviors
        if (bestCultural.behavior === 'flee' && creature.type === 'herbivore') {
            creature.brain.hiddenWeights[0][0] += 0.01; // Enhance flee response
        }
        if (bestCultural.behavior === 'hunt' && creature.type === 'predator') {
            creature.brain.hiddenWeights[0][1] += 0.01; // Enhance hunt response
        }
    }
}

// Hook into creature update
const originalCreatureUpdateForCulture = Creature.prototype.update;
Creature.prototype.update = function(dt, world) {
    originalCreatureUpdateForCulture.call(this, dt, world);
    updateCulturalLearning(this, world, dt);
};

// Track successful actions
const originalHerbivoreUpdate = Herbivore.prototype.updateBehavior;
Herbivore.prototype.updateBehavior = function(dt, world) {
    const prevEnergy = this.energy;
    originalHerbivoreUpdate.call(this, dt, world);
    if (this.energy > prevEnergy) {
        this.lastSuccessfulAction = 'eat';
        this.foodEaten++;
    }
    if (this.state === 'fleeing') this.lastSuccessfulAction = 'flee';
};

// ============================================================
// ROUND 15: DNA SHARING VIA URL
// ============================================================
function encodeDNA(creature) {
    const data = {
        t: creature.type.charAt(0), // h, p
        g: creature.generation,
        d: {
            sp: Math.round(creature.dna.speed * 1000),
            vi: Math.round(creature.dna.vision * 1000),
            sz: Math.round(creature.dna.size * 1000),
            me: Math.round(creature.dna.metabolism * 1000),
            co: Math.round(creature.dna.colorH * 1000)
        },
        f: Math.round(creature.fitness),
        v: 1 // version
    };
    return btoa(JSON.stringify(data)).replace(/=/g, '');
}

function decodeDNA(encoded) {
    try {
        const padded = encoded + '='.repeat((4 - encoded.length % 4) % 4);
        return JSON.parse(atob(padded));
    } catch (e) {
        return null;
    }
}

function generateShareURL(creature) {
    const code = encodeDNA(creature);
    return `${window.location.origin}${window.location.pathname}?dna=${code}`;
}

function showSharePanel(creature) {
    if (!creature || creature.type === 'plant' || creature.type === 'human') {
        NotificationSystem.show('Select a herbivore or predator to share!', 'warning');
        return;
    }
    const url = generateShareURL(creature);
    document.getElementById('share-url').value = url;
    document.getElementById('share-creature-stats').innerHTML = `
        <div style="font-weight:bold;margin-bottom:5px;">${creature.type === 'herbivore' ? 'üê∞' : 'ü¶ä'} ${creature.type} #${creature.id}</div>
        <div style="font-size:0.85em;">Gen ${creature.generation} | Fitness: ${creature.fitness.toFixed(0)} | Speed: ${creature.dna.speed.toFixed(2)}</div>
    `;
    document.getElementById('share-creature-info').style.display = 'block';
    document.getElementById('share-panel').style.display = 'block';
}

function importDNAFromURL() {
    const params = new URLSearchParams(window.location.search);
    const dnaCode = params.get('dna');
    if (!dnaCode) return;

    const data = decodeDNA(dnaCode);
    if (!data) return;

    // Spawn imported creature
    setTimeout(() => {
        const type = data.t === 'h' ? 'herbivore' : 'predator';
        const x = (Math.random() - 0.5) * 100;
        const z = (Math.random() - 0.5) * 100;

        const creature = type === 'herbivore' ? new Herbivore(x, z) : new Predator(x, z);
        creature.generation = data.g || 1;
        creature.dna.speed = (data.d?.sp || 500) / 1000;
        creature.dna.vision = (data.d?.vi || 500) / 1000;
        creature.dna.size = (data.d?.sz || 500) / 1000;
        creature.dna.metabolism = (data.d?.me || 500) / 1000;
        creature.dna.colorH = (data.d?.co || 500) / 1000;

        world.addCreature(creature);
        world.logEvent(`üîó Imported ${type} with shared DNA! Gen ${data.g}`, 'evolution');

        // Clear URL parameter
        window.history.replaceState({}, '', window.location.pathname);
    }, 3000);
}

document.getElementById('btn-share-dna').onclick = () => {
    if (selectedCreature) {
        showSharePanel(selectedCreature);
    } else {
        // Share best creature
        const best = world.creatures
            .filter(c => c.type === 'herbivore' || c.type === 'predator')
            .sort((a, b) => b.fitness - a.fitness)[0];
        if (best) showSharePanel(best);
        else NotificationSystem.show('No creatures to share yet!', 'warning');
    }
};

document.getElementById('btn-copy-url').onclick = () => {
    navigator.clipboard.writeText(document.getElementById('share-url').value);
    document.getElementById('btn-copy-url').textContent = '‚úì Copied!';
    setTimeout(() => document.getElementById('btn-copy-url').textContent = 'üìã Copy Link', 2000);
};

document.getElementById('btn-close-share').onclick = () => {
    document.getElementById('share-panel').style.display = 'none';
};

// Import DNA on load
importDNAFromURL();

// ============================================================
// ROUND 15: SMART LAB ASSISTANT
// ============================================================
class LabAssistant {
    analyzeEcosystem(world) {
        const insights = [];
        const counts = world.getCounts();
        const herbs = world.creatures.filter(c => c.type === 'herbivore');
        const preds = world.creatures.filter(c => c.type === 'predator');

        // Overpopulation detection
        if (counts.herbivores > 40 && counts.predators < 3) {
            insights.push({
                type: 'warning',
                icon: '‚ö†Ô∏è',
                title: 'Herbivore Overpopulation',
                desc: 'With few predators, herbivores are unchecked. Food will run out!',
                action: 'Try adding more predators',
                experiment: 'spawn_predators'
            });
        }

        // Predator starvation risk
        if (counts.predators > 10 && counts.herbivores < 10) {
            insights.push({
                type: 'danger',
                icon: 'üö®',
                title: 'Predator Extinction Risk',
                desc: 'Too many predators, too few prey. Mass starvation imminent.',
                action: 'Remove some predators or add herbivores'
            });
        }

        // Convergent evolution
        if (herbs.length > 5) {
            const avgSpeed = herbs.reduce((s, h) => s + h.dna.speed, 0) / herbs.length;
            const variance = herbs.reduce((s, h) => s + Math.pow(h.dna.speed - avgSpeed, 2), 0) / herbs.length;
            if (variance < 0.02 && world.generation > 5) {
                insights.push({
                    type: 'insight',
                    icon: 'üß¨',
                    title: 'Convergent Evolution Detected',
                    desc: `Herbivores converging on speed ${avgSpeed.toFixed(2)}. Natural selection in action!`,
                    action: 'Introduce environmental variation'
                });
            }
        }

        // Healthy ecosystem
        if (counts.plants > 30 && counts.herbivores > 10 && counts.predators >= 3) {
            insights.push({
                type: 'success',
                icon: '‚úÖ',
                title: 'Balanced Ecosystem',
                desc: 'Your ecosystem is thriving with healthy predator-prey dynamics!',
                action: 'Try an experiment to test stability'
            });
        }

        // Low generation
        if (world.generation < 3 && world.dayCount > 3) {
            insights.push({
                type: 'tip',
                icon: 'üí°',
                title: 'Slow Evolution',
                desc: 'Few generations have passed. Reproduction rates may be low.',
                action: 'Increase plant growth to boost energy'
            });
        }

        // Cultural learning active
        const cultured = world.creatures.filter(c => c.culturalMemory?.length > 0);
        if (cultured.length > 5) {
            insights.push({
                type: 'insight',
                icon: 'üéì',
                title: 'Cultural Learning Active',
                desc: `${cultured.length} creatures learning from neighbors. Social evolution emerging!`,
                action: 'Watch for group behavior patterns'
            });
        }

        return insights;
    }

    renderInsights(insights) {
        const container = document.getElementById('assistant-insights');
        const empty = document.getElementById('assistant-empty');

        if (insights.length === 0) {
            container.innerHTML = '';
            empty.style.display = 'block';
            empty.textContent = 'Ecosystem is stable. No immediate insights.';
            return;
        }

        empty.style.display = 'none';
        container.innerHTML = insights.map(i => `
            <div style="padding:12px;background:rgba(255,100,200,0.1);border-radius:8px;border-left:3px solid ${i.type === 'danger' ? '#ff4466' : i.type === 'warning' ? '#ffaa00' : i.type === 'success' ? '#00ff88' : '#aa88ff'};">
                <div style="font-weight:bold;margin-bottom:5px;">${i.icon} ${i.title}</div>
                <div style="font-size:0.85em;color:rgba(255,255,255,0.8);margin-bottom:8px;">${i.desc}</div>
                <div style="font-size:0.8em;color:#ff64c8;">‚Üí ${i.action}</div>
            </div>
        `).join('');
    }
}

const labAssistant = new LabAssistant();

function refreshAssistant() {
    const insights = labAssistant.analyzeEcosystem(world);
    labAssistant.renderInsights(insights);
}

document.getElementById('btn-assistant').onclick = () => {
    refreshAssistant();
    document.getElementById('assistant-panel').style.display = 'block';
};

document.getElementById('btn-refresh-insights').onclick = refreshAssistant;

document.getElementById('btn-close-assistant').onclick = () => {
    document.getElementById('assistant-panel').style.display = 'none';
};

// ============================================================
// ROUND 16: WEATHER & CLIMATE SYSTEM
// ============================================================
const weatherSystem = {
    current: 'clear',
    effects: {
        clear: { plantGrowth: 1, energyDrain: 1, visibility: 1, icon: '‚òÄÔ∏è' },
        rain: { plantGrowth: 1.5, energyDrain: 0.8, visibility: 0.7, icon: 'üåß' },
        drought: { plantGrowth: 0.3, energyDrain: 1.5, visibility: 1, icon: 'üèú' },
        snow: { plantGrowth: 0.5, energyDrain: 1.3, visibility: 0.6, icon: '‚ùÑÔ∏è' }
    },
    particles: [],

    setWeather(type) {
        this.current = type;
        const effect = this.effects[type];
        simParams.plantGrowth = effect.plantGrowth;
        simParams.energyDrain = effect.energyDrain;
        document.getElementById('current-weather').textContent = `${effect.icon} ${type.charAt(0).toUpperCase() + type.slice(1)}`;

        // Update sliders to reflect weather
        document.getElementById('slider-plant').value = effect.plantGrowth;
        document.getElementById('val-plant').textContent = effect.plantGrowth.toFixed(1) + 'x';
        document.getElementById('slider-energy').value = effect.energyDrain;
        document.getElementById('val-energy').textContent = effect.energyDrain.toFixed(1) + 'x';

        world.logEvent(`üå¶ Weather changed to ${type}!`, 'info');
        chronicleEvents.push({ day: world.dayCount, type: 'weather', text: `Weather changed to ${type}` });
    },

    createParticle() {
        if (this.current === 'clear' || this.current === 'drought') return;
        const particle = {
            x: (Math.random() - 0.5) * 200,
            y: 50,
            z: (Math.random() - 0.5) * 200,
            speed: this.current === 'rain' ? 30 : 5,
            color: this.current === 'rain' ? 0x6688ff : 0xffffff
        };
        this.particles.push(particle);
        if (this.particles.length > 500) this.particles.shift();
    },

    update(dt) {
        // Spawn particles
        if (Math.random() < 0.3) this.createParticle();

        // Update particles
        this.particles.forEach(p => {
            p.y -= p.speed * dt;
            if (this.current === 'snow') {
                p.x += Math.sin(p.y * 0.1) * dt * 2;
            }
        });
        this.particles = this.particles.filter(p => p.y > 0);
    }
};

// Weather button handlers
document.querySelectorAll('.weather-btn').forEach(btn => {
    btn.onclick = () => weatherSystem.setWeather(btn.dataset.weather);
});

document.getElementById('btn-weather').onclick = () => {
    document.getElementById('weather-panel').style.display = 'block';
};
document.getElementById('btn-close-weather').onclick = () => {
    document.getElementById('weather-panel').style.display = 'none';
};

// ============================================================
// ROUND 16: EVOLUTIONARY CHRONICLE
// ============================================================
const chronicleEvents = [];

// Auto-record significant events
setInterval(() => {
    const counts = world.getCounts();
    const herbs = world.creatures.filter(c => c.type === 'herbivore');
    const preds = world.creatures.filter(c => c.type === 'predator');

    // Population milestones
    if (counts.herbivores >= 50 && !chronicleEvents.find(e => e.text?.includes('50 herbivores'))) {
        chronicleEvents.push({ day: world.dayCount, type: 'milestone', text: 'üê∞ Population boom! 50 herbivores reached!' });
    }

    // Extinction events
    if (counts.herbivores === 0 && herbs.length === 0) {
        if (!chronicleEvents.find(e => e.text?.includes('Herbivores extinct'))) {
            chronicleEvents.push({ day: world.dayCount, type: 'extinction', text: 'üíÄ Herbivores extinct!' });
        }
    }

    // Generation milestones
    if (world.generation % 5 === 0 && world.generation > 0) {
        const key = `gen${world.generation}`;
        if (!chronicleEvents.find(e => e.key === key)) {
            const avgSpeed = herbs.length ? (herbs.reduce((s, h) => s + h.dna.speed, 0) / herbs.length).toFixed(2) : 'N/A';
            chronicleEvents.push({
                day: world.dayCount,
                type: 'evolution',
                text: `üß¨ Generation ${world.generation} reached! Avg herbivore speed: ${avgSpeed}`,
                key
            });
        }
    }
}, 5000);

function renderChronicle() {
    const timeline = document.getElementById('chronicle-timeline');
    if (chronicleEvents.length === 0) {
        timeline.innerHTML = '<div style="color:rgba(255,255,255,0.5);padding:10px;">No major events yet. Keep watching!</div>';
        return;
    }

    timeline.innerHTML = chronicleEvents.slice(-20).reverse().map(e => `
        <div style="margin-bottom:15px;padding:10px;background:rgba(200,150,100,0.1);border-radius:8px;">
            <div style="font-size:0.75em;color:rgba(255,255,255,0.5);">Day ${e.day}</div>
            <div style="margin-top:5px;">${e.text}</div>
        </div>
    `).join('');
}

document.getElementById('btn-chronicle').onclick = () => {
    renderChronicle();
    document.getElementById('chronicle-panel').style.display = 'block';
};
document.getElementById('btn-close-chronicle').onclick = () => {
    document.getElementById('chronicle-panel').style.display = 'none';
};

// ============================================================
// ROUND 16: CINEMA MODE
// ============================================================
let cinemaMode = false;
let cinemaTarget = null;
let cinematicNarrations = [
    "A predator stalks its prey through the urban jungle...",
    "The herbivores graze peacefully, unaware of the danger lurking nearby...",
    "Natural selection favors the swift and the cunning...",
    "In this concrete ecosystem, every creature fights for survival...",
    "The dance of predator and prey continues through the ages...",
    "Evolution shapes these creatures, generation by generation..."
];

function updateCinemaMode() {
    if (!cinemaMode) return;

    const counts = world.getCounts();
    document.getElementById('cinema-stats').textContent =
        `Gen ${world.generation} | üê∞ ${counts.herbivores} | ü¶ä ${counts.predators} | Day ${world.dayCount}`;

    // Find interesting creature to follow
    if (!cinemaTarget || !cinemaTarget.alive || Math.random() < 0.01) {
        // Prefer predators hunting or active herbivores
        const interesting = world.creatures.filter(c =>
            c.alive && (c.type === 'predator' || c.type === 'herbivore') && c.energy > 30
        ).sort((a, b) => b.fitness - a.fitness);

        if (interesting.length > 0) {
            cinemaTarget = interesting[Math.floor(Math.random() * Math.min(5, interesting.length))];
        }
    }

    // Smooth camera follow
    if (cinemaTarget?.mesh) {
        const targetPos = cinemaTarget.mesh.position;
        camera.position.x += (targetPos.x + 15 - camera.position.x) * 0.02;
        camera.position.z += (targetPos.z + 15 - camera.position.z) * 0.02;
        camera.position.y += (25 - camera.position.y) * 0.02;
        camera.lookAt(targetPos);
    }

    // Update narration occasionally
    if (Math.random() < 0.005) {
        document.getElementById('cinema-narration').textContent =
            cinematicNarrations[Math.floor(Math.random() * cinematicNarrations.length)];
    }
}

document.getElementById('btn-cinema').onclick = () => {
    cinemaMode = !cinemaMode;
    const btn = document.getElementById('btn-cinema');
    btn.classList.toggle('active', cinemaMode);
    btn.setAttribute('aria-pressed', cinemaMode);
    document.getElementById('cinema-overlay').style.display = cinemaMode ? 'block' : 'none';
    document.getElementById('controls').style.display = cinemaMode ? 'none' : 'flex';

    if (cinemaMode) {
        document.getElementById('cinema-narration').textContent =
            "Welcome to Ecosystem Cinema. Sit back and watch evolution unfold...";
    }
};

// Integrate cinema into animation loop
setInterval(updateCinemaMode, 50);

// ============================================================
// ROUND 17: RESEARCH PAPER EXPORT
// ============================================================
function generateResearchPaper() {
    const counts = world.getCounts();
    const herbs = world.creatures.filter(c => c.type === 'herbivore');
    const preds = world.creatures.filter(c => c.type === 'predator');

    const avgHerbSpeed = herbs.length ? (herbs.reduce((s, h) => s + h.dna.speed, 0) / herbs.length).toFixed(3) : 'N/A';
    const avgPredSpeed = preds.length ? (preds.reduce((s, p) => s + p.dna.speed, 0) / preds.length).toFixed(3) : 'N/A';
    const survivalRate = world.creatures.length > 0 ?
        ((world.creatures.filter(c => c.age > 20).length / world.creatures.length) * 100).toFixed(1) : 0;

    const paper = `
================================================================================
                    ECOSYSTEM CITY: RESEARCH OBSERVATION REPORT
================================================================================

ABSTRACT
--------
This document presents findings from a digital ecosystem simulation featuring
neural network-driven creatures with genetic inheritance. The simulation ran
for ${world.dayCount} days, producing ${world.generation} generations of evolved organisms.

METHODOLOGY
-----------
- Simulation Engine: Three.js WebGL with custom neural network implementation
- Population: Herbivores (prey), Predators (hunters), Plants (resources)
- Selection Pressure: Survival-based fitness with DNA trait inheritance
- Cultural Learning: Observational behavior transmission between organisms

RESULTS
-------
Final Population Counts:
  - Plants: ${counts.plants}
  - Herbivores: ${counts.herbivores}
  - Predators: ${counts.predators}
  - Humans (control): ${counts.humans}

Evolutionary Metrics:
  - Generations Evolved: ${world.generation}
  - Average Herbivore Speed: ${avgHerbSpeed}
  - Average Predator Speed: ${avgPredSpeed}
  - Survival Rate (age > 20): ${survivalRate}%

Environmental Conditions:
  - Current Weather: ${weatherSystem.current}
  - Day/Night Cycle: Active (${world.timeOfDay.toFixed(1)} hours)

SIGNIFICANT EVENTS
------------------
${chronicleEvents.slice(-10).map(e => `Day ${e.day}: ${e.text}`).join('\n') || 'No major events recorded.'}

CONCLUSIONS
-----------
The simulation demonstrates emergent behaviors consistent with natural selection
theory. Prey species showed increased speed traits over generations (adaptive
response to predation pressure). Cultural learning enabled faster adaptation
than genetic inheritance alone.

GENERATED
---------
Date: ${new Date().toISOString()}
Simulation: Ecosystem City v16
Tool: https://github.com/localFirstTools

================================================================================
`;

    // Download as text file
    const blob = new Blob([paper], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `ecosystem-research-${Date.now()}.txt`;
    a.click();
    URL.revokeObjectURL(url);
    world.logEvent('üìÑ Research paper exported!', 'info');
}

// Add to export button as alt-click
document.getElementById('btn-export').addEventListener('contextmenu', (e) => {
    e.preventDefault();
    generateResearchPaper();
});

// ============================================================
// ROUND 17: ADVANCED STATISTICS DASHBOARD
// ============================================================
function getAdvancedStats() {
    const herbs = world.creatures.filter(c => c.type === 'herbivore' && c.alive);
    const preds = world.creatures.filter(c => c.type === 'predator' && c.alive);

    const stats = {
        diversity: {
            herbSpeedVariance: herbs.length > 1 ? calculateVariance(herbs.map(h => h.dna.speed)) : 0,
            predSpeedVariance: preds.length > 1 ? calculateVariance(preds.map(p => p.dna.speed)) : 0
        },
        survival: {
            avgHerbAge: herbs.length ? herbs.reduce((s, h) => s + h.age, 0) / herbs.length : 0,
            avgPredAge: preds.length ? preds.reduce((s, p) => s + p.age, 0) / preds.length : 0,
            maxGeneration: world.generation
        },
        culture: {
            culturedCreatures: world.creatures.filter(c => c.culturalMemory?.length > 0).length,
            avgCulturalMemory: world.creatures.reduce((s, c) => s + (c.culturalMemory?.length || 0), 0) / Math.max(1, world.creatures.length)
        },
        ecosystem: {
            predatorPreyRatio: herbs.length > 0 ? (preds.length / herbs.length).toFixed(2) : 'N/A',
            carryingCapacity: Math.round(world.getCounts().plants * 2.5),
            stabilityScore: calculateStability()
        }
    };

    return stats;
}

function calculateVariance(arr) {
    if (arr.length < 2) return 0;
    const mean = arr.reduce((s, v) => s + v, 0) / arr.length;
    return (arr.reduce((s, v) => s + Math.pow(v - mean, 2), 0) / arr.length).toFixed(4);
}

function calculateStability() {
    const recent = world.history.herbivores.slice(-20);
    if (recent.length < 10) return 'Insufficient data';
    const variance = calculateVariance(recent);
    if (variance < 50) return 'üü¢ Stable';
    if (variance < 200) return 'üü° Fluctuating';
    return 'üî¥ Unstable';
}

// ============================================================
// ROUND 17: SOCIAL SHARE CARDS
// ============================================================
function generateShareText() {
    const counts = world.getCounts();
    const text = `üèôÔ∏è My Ecosystem City after ${world.dayCount} days:
üß¨ Generation ${world.generation}
üê∞ ${counts.herbivores} herbivores
ü¶ä ${counts.predators} predators
üåø ${counts.plants} plants

Watch evolution in real-time! üé¨`;

    return text;
}

function shareToTwitter() {
    const text = encodeURIComponent(generateShareText());
    const url = encodeURIComponent(window.location.href.split('?')[0]);
    window.open(`https://twitter.com/intent/tweet?text=${text}&url=${url}`, '_blank');
}

function shareToClipboard() {
    const text = generateShareText() + '\n\n' + window.location.href.split('?')[0];
    navigator.clipboard.writeText(text);
    NotificationSystem.show('Copied to clipboard! Share with friends.', 'success');
}

// Add share functionality to screenshot button
const origScreenshot = document.getElementById('btn-screenshot').onclick;
document.getElementById('btn-screenshot').onclick = (e) => {
    if (e.shiftKey) {
        shareToTwitter();
    } else if (e.ctrlKey || e.metaKey) {
        shareToClipboard();
    } else if (origScreenshot) {
        origScreenshot(e);
    }
};

// ============================================================
// ROUND 18: UNDO & APOCALYPSE BUTTON HANDLERS
// ============================================================
function updateUndoButton() {
    const btn = document.getElementById('btn-undo');
    btn.disabled = !UndoSystem.canUndo();
}

document.getElementById('btn-apocalypse').onclick = () => {
    // Save state before destruction
    UndoSystem.save('Before Apocalypse', UndoSystem.createSnapshot(world));
    updateUndoButton();
    world.apocalypse();
    NotificationSystem.show('üíÄ Apocalypse triggered! 75% of creatures perished.', 'error', 5000);
};

document.getElementById('btn-undo').onclick = () => {
    if (UndoSystem.undo(world)) {
        updateUndoButton();
    }
};

// Also save state before scenario load (destructive)
const origLoadScenario = typeof loadScenario !== 'undefined' ? loadScenario : null;
if (origLoadScenario) {
    window.loadScenario = function(scenario) {
        UndoSystem.save('Before Scenario: ' + scenario.name, UndoSystem.createSnapshot(world));
        updateUndoButton();
        origLoadScenario(scenario);
    };
}

// ============================================================
// ROUND 17: KEYBOARD SHORTCUTS
// ============================================================
document.addEventListener('keydown', (e) => {
    if (e.target.tagName === 'INPUT') return;

    switch(e.key.toLowerCase()) {
        case ' ':
            e.preventDefault();
            document.getElementById('btn-pause').click();
            break;
        case 'c':
            document.getElementById('btn-cinema').click();
            break;
        case 'h':
            document.getElementById('btn-heatmap').click();
            break;
        case 'p':
            // ROUND 20: Profiler keyboard shortcut
            document.getElementById('btn-profiler').click();
            break;
        case 's':
            if (!e.ctrlKey) document.getElementById('btn-sound').click();
            break;
        case 'w':
            document.getElementById('btn-weather').click();
            break;
        case 'escape':
            if (cinemaMode) document.getElementById('btn-cinema').click();
            break;
        case 'z':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                document.getElementById('btn-undo').click();
            }
            break;
        case 'tab':
            // ROUND 19: Keyboard creature navigation
            e.preventDefault();
            selectCreatureByKeyboard(e.shiftKey ? 'prev' : 'next');
            break;
        case 'arrowright':
        case 'arrowdown':
            selectCreatureByKeyboard('next');
            break;
        case 'arrowleft':
        case 'arrowup':
            selectCreatureByKeyboard('prev');
            break;
        case '?':
            // ROUND 21: ? opens help/tutorial panel
            document.getElementById('btn-help').click();
            break;
    }
});

// ROUND 21: Updated console log with ? shortcut
console.log('üèôÔ∏è Ecosystem City loaded! Press ? for keyboard shortcuts. Quick keys: Space=Pause, C=Cinema, H=Heatmap, P=Profiler, S=Sound, W=Weather, Ctrl+Z=Undo, Tab=Creatures');

animate();
    </script>
</body>
</html>
