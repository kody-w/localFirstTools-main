<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fluid Dynamics Sim</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            color: #e0e0e0;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            background: linear-gradient(90deg, hsl(220, 70%, 15%) 0%, hsl(240, 60%, 20%) 100%);
            padding: 12px 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
            z-index: 100;
        }

        h1 {
            font-size: 24px;
            font-weight: 700;
            background: linear-gradient(90deg, hsl(200, 90%, 60%), hsl(280, 80%, 70%));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 2px 8px rgba(100, 200, 255, 0.3);
        }

        .header-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        button {
            background: linear-gradient(135deg, hsl(220, 60%, 35%), hsl(240, 50%, 25%));
            border: 1px solid hsl(220, 60%, 45%);
            color: #ffffff;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        button:hover {
            background: linear-gradient(135deg, hsl(220, 70%, 45%), hsl(240, 60%, 35%));
            box-shadow: 0 4px 12px rgba(100, 150, 255, 0.4);
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        button.active {
            background: linear-gradient(135deg, hsl(140, 70%, 40%), hsl(160, 60%, 30%));
            border-color: hsl(140, 70%, 50%);
        }

        #fps {
            font-size: 13px;
            color: hsl(100, 70%, 60%);
            font-weight: 600;
            padding: 4px 12px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 4px;
        }

        main {
            flex: 1;
            display: flex;
            position: relative;
            overflow: hidden;
        }

        #canvas {
            flex: 1;
            cursor: crosshair;
            background: #000000;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        .side-panel {
            width: 300px;
            background: linear-gradient(180deg, hsl(220, 30%, 12%) 0%, hsl(230, 25%, 8%) 100%);
            padding: 20px;
            overflow-y: auto;
            box-shadow: -4px 0 12px rgba(0, 0, 0, 0.5);
            transition: transform 0.3s ease;
        }

        .side-panel.collapsed {
            transform: translateX(100%);
        }

        .control-group {
            margin-bottom: 24px;
            padding: 16px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .control-group:hover {
            background: rgba(255, 255, 255, 0.05);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .control-group h3 {
            font-size: 14px;
            margin-bottom: 12px;
            color: hsl(200, 70%, 70%);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
        }

        .control-item {
            margin-bottom: 12px;
        }

        .control-item label {
            display: block;
            font-size: 12px;
            margin-bottom: 6px;
            color: #b0b0b0;
            font-weight: 500;
        }

        .control-item input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: linear-gradient(90deg, hsl(220, 50%, 20%), hsl(220, 60%, 40%));
            outline: none;
            -webkit-appearance: none;
        }

        .control-item input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, hsl(200, 80%, 60%), hsl(220, 70%, 50%));
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
            transition: all 0.2s ease;
        }

        .control-item input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 12px rgba(100, 180, 255, 0.6);
        }

        .control-item input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, hsl(200, 80%, 60%), hsl(220, 70%, 50%));
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
        }

        .value-display {
            display: inline-block;
            float: right;
            color: hsl(100, 70%, 60%);
            font-weight: 600;
            font-size: 12px;
        }

        select {
            width: 100%;
            padding: 8px;
            background: hsl(220, 30%, 15%);
            border: 1px solid hsl(220, 40%, 25%);
            color: #e0e0e0;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        select:hover {
            border-color: hsl(220, 60%, 40%);
            background: hsl(220, 30%, 18%);
        }

        select:focus {
            outline: none;
            border-color: hsl(200, 80%, 50%);
            box-shadow: 0 0 8px rgba(100, 180, 255, 0.4);
        }

        .color-palette {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 8px;
        }

        .color-swatch {
            width: 36px;
            height: 36px;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s ease;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .color-swatch:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(255, 255, 255, 0.3);
        }

        .color-swatch.active {
            border-color: #ffffff;
            box-shadow: 0 0 12px rgba(255, 255, 255, 0.6);
            transform: scale(1.15);
        }

        .toggle-panel {
            position: absolute;
            top: 80px;
            right: 10px;
            z-index: 50;
            background: linear-gradient(135deg, hsl(220, 60%, 25%), hsl(240, 50%, 20%));
            border: 1px solid hsl(220, 60%, 35%);
            border-radius: 6px;
            padding: 8px 12px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
        }

        .toggle-panel:hover {
            background: linear-gradient(135deg, hsl(220, 70%, 35%), hsl(240, 60%, 30%));
            box-shadow: 0 6px 16px rgba(100, 150, 255, 0.4);
        }

        .checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .checkbox-wrapper input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: hsl(200, 80%, 50%);
        }

        .checkbox-wrapper label {
            margin: 0;
            cursor: pointer;
            user-select: none;
        }

        .info-text {
            font-size: 11px;
            color: #888;
            margin-top: 8px;
            line-height: 1.4;
        }

        @media (max-width: 768px) {
            .side-panel {
                position: absolute;
                right: 0;
                top: 0;
                bottom: 0;
                width: 280px;
                transform: translateX(100%);
            }

            .side-panel.show {
                transform: translateX(0);
            }

            h1 {
                font-size: 18px;
            }

            button {
                padding: 6px 12px;
                font-size: 12px;
            }
        }

        .velocity-arrow {
            stroke: rgba(255, 255, 255, 0.6);
            stroke-width: 1;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }

        .recording {
            animation: pulse 1.5s ease-in-out infinite;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, hsl(220, 30%, 15%) 0%, hsl(230, 25%, 10%) 100%);
            border: 2px solid hsl(220, 60%, 40%);
            border-radius: 12px;
            padding: 30px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
        }

        .modal-content h2 {
            color: hsl(200, 80%, 60%);
            margin-bottom: 20px;
            font-size: 24px;
        }

        .modal-content h3 {
            color: hsl(200, 70%, 70%);
            margin-top: 20px;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .modal-content p {
            color: #e0e0e0;
            line-height: 1.6;
            margin-bottom: 12px;
        }

        .modal-content ul {
            color: #e0e0e0;
            line-height: 1.8;
            margin-left: 20px;
            margin-bottom: 12px;
        }

        .modal-content code {
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 3px;
            color: hsl(100, 70%, 60%);
            font-family: 'Courier New', monospace;
        }

        .close-modal {
            background: linear-gradient(135deg, hsl(0, 60%, 45%), hsl(0, 50%, 35%));
            border: 1px solid hsl(0, 60%, 55%);
            color: #ffffff;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            margin-top: 20px;
            transition: all 0.3s ease;
        }

        .close-modal:hover {
            background: linear-gradient(135deg, hsl(0, 70%, 55%), hsl(0, 60%, 45%));
            box-shadow: 0 4px 12px rgba(255, 100, 100, 0.4);
            transform: translateY(-2px);
        }

        .difficulty-buttons {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
        }

        .difficulty-btn {
            flex: 1;
            padding: 12px;
            font-size: 14px;
            font-weight: 600;
        }

        .difficulty-btn.easy {
            background: linear-gradient(135deg, hsl(120, 50%, 35%), hsl(140, 45%, 25%));
            border-color: hsl(120, 60%, 45%);
        }

        .difficulty-btn.medium {
            background: linear-gradient(135deg, hsl(40, 60%, 40%), hsl(50, 55%, 30%));
            border-color: hsl(40, 70%, 50%);
        }

        .difficulty-btn.hard {
            background: linear-gradient(135deg, hsl(0, 60%, 40%), hsl(10, 55%, 30%));
            border-color: hsl(0, 70%, 50%);
        }

        .challenge-active {
            border: 2px solid hsl(50, 90%, 60%);
        }

        .target-pattern {
            display: inline-block;
            padding: 4px 8px;
            background: rgba(255, 200, 0, 0.2);
            border-radius: 4px;
            color: hsl(50, 90%, 70%);
            font-weight: 600;
            margin-left: 8px;
        }
    </style>
</head>
<body>
    <header>
        <h1>‚öóÔ∏è Fluid Dynamics Simulator</h1>
        <div class="header-controls">
            <button id="playPauseBtn" class="active">‚è∏Ô∏è Pause</button>
            <button id="stepBtn">‚è≠Ô∏è Step</button>
            <button id="resetBtn">üîÑ Reset</button>
            <button id="toggleArrowsBtn">üéØ Arrows: OFF</button>
            <button id="instructionsBtn">‚ùì How to Play</button>
            <button id="challengeBtn">üéØ Challenge Mode</button>
            <span id="fps">FPS: 60</span>
            <span id="score" style="display: none; font-size: 13px; color: hsl(50, 90%, 60%); font-weight: 600; padding: 4px 12px; background: rgba(0, 0, 0, 0.4); border-radius: 4px;">Score: 0</span>
        </div>
    </header>

    <main>
        <canvas id="canvas"></canvas>

        <div class="toggle-panel" id="togglePanel">
            ‚ò∞ Controls
        </div>

        <aside class="side-panel" id="sidePanel">
            <div class="control-group">
                <h3>‚öôÔ∏è Simulation</h3>
                <div class="control-item">
                    <label>Difficulty Preset</label>
                    <div class="difficulty-buttons">
                        <button class="difficulty-btn easy" id="easyBtn">Easy</button>
                        <button class="difficulty-btn medium active" id="mediumBtn">Medium</button>
                        <button class="difficulty-btn hard" id="hardBtn">Hard</button>
                    </div>
                </div>
                <div class="control-item">
                    <label>Grid Resolution</label>
                    <select id="resolutionSelect">
                        <option value="64">64√ó64 (Fast)</option>
                        <option value="128" selected>128√ó128 (Balanced)</option>
                        <option value="192">192√ó192 (Detailed)</option>
                    </select>
                </div>
                <div class="control-item">
                    <label>
                        Viscosity
                        <span class="value-display" id="viscosityValue">0.0001</span>
                    </label>
                    <input type="range" id="viscositySlider" min="0" max="100" value="10" step="1">
                </div>
                <div class="control-item">
                    <label>
                        Diffusion Rate
                        <span class="value-display" id="diffusionValue">0.0001</span>
                    </label>
                    <input type="range" id="diffusionSlider" min="0" max="100" value="10" step="1">
                </div>
                <div class="control-item">
                    <label>
                        Density Injection
                        <span class="value-display" id="densityValue">100</span>
                    </label>
                    <input type="range" id="densitySlider" min="10" max="500" value="100" step="10">
                </div>
                <div class="control-item">
                    <label>
                        Velocity Force
                        <span class="value-display" id="velocityValue">50</span>
                    </label>
                    <input type="range" id="velocitySlider" min="10" max="200" value="50" step="5">
                </div>
            </div>

            <div class="control-group">
                <h3>üé® Visualization</h3>
                <div class="control-item">
                    <label>Color Mode</label>
                    <select id="colorModeSelect">
                        <option value="rainbow">Rainbow (Velocity)</option>
                        <option value="thermal" selected>Thermal (Density)</option>
                        <option value="monochrome">Monochrome</option>
                        <option value="neon">Neon</option>
                    </select>
                </div>
                <div class="control-item">
                    <label>Injection Color</label>
                    <div class="color-palette">
                        <div class="color-swatch active" data-color="0" style="background: hsl(0, 100%, 50%);"></div>
                        <div class="color-swatch" data-color="60" style="background: hsl(60, 100%, 50%);"></div>
                        <div class="color-swatch" data-color="120" style="background: hsl(120, 100%, 50%);"></div>
                        <div class="color-swatch" data-color="180" style="background: hsl(180, 100%, 50%);"></div>
                        <div class="color-swatch" data-color="240" style="background: hsl(240, 100%, 50%);"></div>
                        <div class="color-swatch" data-color="300" style="background: hsl(300, 100%, 50%);"></div>
                    </div>
                </div>
                <div class="checkbox-wrapper">
                    <input type="checkbox" id="showArrows">
                    <label for="showArrows">Show Velocity Arrows</label>
                </div>
                <div class="checkbox-wrapper">
                    <input type="checkbox" id="fadeOut" checked>
                    <label for="fadeOut">Density Fade</label>
                </div>
            </div>

            <div class="control-group">
                <h3>‚ÑπÔ∏è Information</h3>
                <p class="info-text">
                    Click and drag to inject dye and apply velocity forces. The simulation uses a simplified Navier-Stokes solver with advection, diffusion, and projection steps.
                </p>
                <p class="info-text">
                    <strong>Controls:</strong> Mouse/Touch drag to interact. Adjust sliders for different fluid behaviors. Rainbow mode shows velocity direction as color.
                </p>
                <p class="info-text">
                    <strong>Keyboard:</strong> <code>Space</code>=Pause, <code>R</code>=Reset, <code>1</code>=Rainbow, <code>2</code>=Thermal, <code>3</code>=Neon
                </p>
                <p class="info-text" id="personalBest" style="color: hsl(50, 90%, 60%); font-weight: 600;">
                    Personal Best: 0
                </p>
            </div>
        </aside>
    </main>

    <!-- Instructions Modal -->
    <div class="modal" id="instructionsModal">
        <div class="modal-content">
            <h2>üåä How to Play - Fluid Dynamics Simulator</h2>

            <h3>Basic Controls</h3>
            <ul>
                <li><strong>Mouse/Touch Drag:</strong> Click and drag on the canvas to inject colored dye and create fluid motion</li>
                <li><strong>Space:</strong> Pause/Resume simulation</li>
                <li><strong>R:</strong> Reset the simulation</li>
                <li><strong>1/2/3:</strong> Switch color modes (Rainbow/Thermal/Neon)</li>
            </ul>

            <h3>Difficulty Presets</h3>
            <ul>
                <li><strong>Easy:</strong> Low resolution (64√ó64), slow dynamics, high viscosity</li>
                <li><strong>Medium:</strong> Balanced settings (128√ó128)</li>
                <li><strong>Hard:</strong> High resolution (192√ó192), fast turbulent flow, low viscosity</li>
            </ul>

            <h3>Challenge Mode</h3>
            <p>Try to match target flow patterns to earn points:</p>
            <ul>
                <li><strong>Vortex:</strong> Create circular swirling patterns</li>
                <li><strong>Laminar:</strong> Create smooth parallel flows</li>
                <li><strong>Turbulent:</strong> Create chaotic mixing patterns</li>
                <li><strong>Symmetrical:</strong> Create mirror-image flows</li>
            </ul>
            <p>Your score increases when you successfully match the target pattern. Beat your personal best!</p>

            <h3>Physics Parameters</h3>
            <ul>
                <li><strong>Viscosity:</strong> Fluid thickness (higher = slower, more honey-like)</li>
                <li><strong>Diffusion:</strong> How fast dye spreads through the fluid</li>
                <li><strong>Density Injection:</strong> Amount of dye added per click</li>
                <li><strong>Velocity Force:</strong> Strength of motion applied</li>
            </ul>

            <h3>Visualization Modes</h3>
            <ul>
                <li><strong>Rainbow:</strong> Colors show velocity direction (like wind maps)</li>
                <li><strong>Thermal:</strong> Shows density concentration (like heat maps)</li>
                <li><strong>Monochrome:</strong> Grayscale density view</li>
                <li><strong>Neon:</strong> Bright, high-contrast colors</li>
            </ul>

            <button class="close-modal" id="closeInstructions">Got it!</button>
        </div>
    </div>

    <script>
        // Configuration and State
        const config = {
            resolution: 128,
            viscosity: 0.0001,
            diffusion: 0.0001,
            densityAmount: 100,
            velocityAmount: 50,
            colorMode: 'thermal',
            injectionHue: 0,
            showArrows: false,
            fadeOut: true,
            dt: 0.016,
            iterations: 4,
            difficulty: 'medium'
        };

        let isPlaying = true;
        let lastTime = 0;
        let fps = 60;
        let fpsFrames = 0;
        let fpsTime = 0;

        // Challenge mode state
        let challengeMode = false;
        let challengeScore = 0;
        let personalBest = 0;
        let targetPattern = '';
        const patterns = ['vortex', 'laminar', 'turbulent', 'symmetrical'];
        let patternStartTime = 0;

        // Difficulty presets
        const difficultyPresets = {
            easy: {
                resolution: 64,
                viscosity: 0.001,
                diffusion: 0.0005,
                velocityAmount: 30,
                dt: 0.02
            },
            medium: {
                resolution: 128,
                viscosity: 0.0001,
                diffusion: 0.0001,
                velocityAmount: 50,
                dt: 0.016
            },
            hard: {
                resolution: 192,
                viscosity: 0.00001,
                diffusion: 0.00005,
                velocityAmount: 80,
                dt: 0.012
            }
        };

        // Canvas Setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { alpha: false });

        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Fluid Simulation Class
        class FluidSimulation {
            constructor(resolution) {
                this.N = resolution;
                this.size = (resolution + 2) * (resolution + 2);

                // Velocity fields (u = x-component, v = y-component)
                this.u = new Float32Array(this.size);
                this.v = new Float32Array(this.size);
                this.u_prev = new Float32Array(this.size);
                this.v_prev = new Float32Array(this.size);

                // Density fields (separate for RGB channels)
                this.density = new Float32Array(this.size);
                this.density_prev = new Float32Array(this.size);

                // Color channels
                this.r = new Float32Array(this.size);
                this.g = new Float32Array(this.size);
                this.b = new Float32Array(this.size);
                this.r_prev = new Float32Array(this.size);
                this.g_prev = new Float32Array(this.size);
                this.b_prev = new Float32Array(this.size);
            }

            IX(x, y) {
                return x + (this.N + 2) * y;
            }

            addDensity(x, y, amount, hue) {
                const index = this.IX(x, y);
                const rgb = this.hslToRgb(hue, 100, 50);
                this.density[index] += amount;
                this.r[index] += rgb.r * amount;
                this.g[index] += rgb.g * amount;
                this.b[index] += rgb.b * amount;
            }

            addVelocity(x, y, amountX, amountY) {
                const index = this.IX(x, y);
                this.u[index] += amountX;
                this.v[index] += amountY;
            }

            hslToRgb(h, s, l) {
                h = h / 360;
                s = s / 100;
                l = l / 100;

                let r, g, b;
                if (s === 0) {
                    r = g = b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };

                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }

                return { r: r * 255, g: g * 255, b: b * 255 };
            }

            step(dt) {
                const visc = config.viscosity;
                const diff = config.diffusion;

                // Velocity step
                this.diffuse(1, this.u_prev, this.u, visc, dt);
                this.diffuse(2, this.v_prev, this.v, visc, dt);

                this.project(this.u_prev, this.v_prev, this.u, this.v);

                this.advect(1, this.u, this.u_prev, this.u_prev, this.v_prev, dt);
                this.advect(2, this.v, this.v_prev, this.u_prev, this.v_prev, dt);

                this.project(this.u, this.v, this.u_prev, this.v_prev);

                // Density step
                this.diffuse(0, this.density_prev, this.density, diff, dt);
                this.advect(0, this.density, this.density_prev, this.u, this.v, dt);

                // Color channels
                this.diffuse(0, this.r_prev, this.r, diff, dt);
                this.advect(0, this.r, this.r_prev, this.u, this.v, dt);

                this.diffuse(0, this.g_prev, this.g, diff, dt);
                this.advect(0, this.g, this.g_prev, this.u, this.v, dt);

                this.diffuse(0, this.b_prev, this.b, diff, dt);
                this.advect(0, this.b, this.b_prev, this.u, this.v, dt);

                // Fade out density
                if (config.fadeOut) {
                    const fade = 0.995;
                    for (let i = 0; i < this.size; i++) {
                        this.density[i] *= fade;
                        this.r[i] *= fade;
                        this.g[i] *= fade;
                        this.b[i] *= fade;
                    }
                }
            }

            setBounds(b, x) {
                const N = this.N;

                for (let i = 1; i <= N; i++) {
                    x[this.IX(0, i)] = b === 1 ? -x[this.IX(1, i)] : x[this.IX(1, i)];
                    x[this.IX(N+1, i)] = b === 1 ? -x[this.IX(N, i)] : x[this.IX(N, i)];
                    x[this.IX(i, 0)] = b === 2 ? -x[this.IX(i, 1)] : x[this.IX(i, 1)];
                    x[this.IX(i, N+1)] = b === 2 ? -x[this.IX(i, N)] : x[this.IX(i, N)];
                }

                x[this.IX(0, 0)] = 0.5 * (x[this.IX(1, 0)] + x[this.IX(0, 1)]);
                x[this.IX(0, N+1)] = 0.5 * (x[this.IX(1, N+1)] + x[this.IX(0, N)]);
                x[this.IX(N+1, 0)] = 0.5 * (x[this.IX(N, 0)] + x[this.IX(N+1, 1)]);
                x[this.IX(N+1, N+1)] = 0.5 * (x[this.IX(N, N+1)] + x[this.IX(N+1, N)]);
            }

            diffuse(b, x, x0, diff, dt) {
                const a = dt * diff * this.N * this.N;
                this.linearSolve(b, x, x0, a, 1 + 4 * a);
            }

            linearSolve(b, x, x0, a, c) {
                const N = this.N;
                const cRecip = 1.0 / c;

                for (let k = 0; k < config.iterations; k++) {
                    for (let j = 1; j <= N; j++) {
                        for (let i = 1; i <= N; i++) {
                            const idx = this.IX(i, j);
                            x[idx] = (x0[idx] + a * (
                                x[this.IX(i-1, j)] +
                                x[this.IX(i+1, j)] +
                                x[this.IX(i, j-1)] +
                                x[this.IX(i, j+1)]
                            )) * cRecip;
                        }
                    }
                    this.setBounds(b, x);
                }
            }

            project(u, v, p, div) {
                const N = this.N;
                const h = 1.0 / N;

                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        const idx = this.IX(i, j);
                        div[idx] = -0.5 * h * (
                            u[this.IX(i+1, j)] - u[this.IX(i-1, j)] +
                            v[this.IX(i, j+1)] - v[this.IX(i, j-1)]
                        );
                        p[idx] = 0;
                    }
                }

                this.setBounds(0, div);
                this.setBounds(0, p);
                this.linearSolve(0, p, div, 1, 4);

                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        const idx = this.IX(i, j);
                        u[idx] -= 0.5 * (p[this.IX(i+1, j)] - p[this.IX(i-1, j)]) / h;
                        v[idx] -= 0.5 * (p[this.IX(i, j+1)] - p[this.IX(i, j-1)]) / h;
                    }
                }

                this.setBounds(1, u);
                this.setBounds(2, v);
            }

            advect(b, d, d0, u, v, dt) {
                const N = this.N;
                const dt0 = dt * N;

                for (let j = 1; j <= N; j++) {
                    for (let i = 1; i <= N; i++) {
                        let x = i - dt0 * u[this.IX(i, j)];
                        let y = j - dt0 * v[this.IX(i, j)];

                        if (x < 0.5) x = 0.5;
                        if (x > N + 0.5) x = N + 0.5;
                        let i0 = Math.floor(x);
                        let i1 = i0 + 1;

                        if (y < 0.5) y = 0.5;
                        if (y > N + 0.5) y = N + 0.5;
                        let j0 = Math.floor(y);
                        let j1 = j0 + 1;

                        const s1 = x - i0;
                        const s0 = 1 - s1;
                        const t1 = y - j0;
                        const t0 = 1 - t1;

                        d[this.IX(i, j)] =
                            s0 * (t0 * d0[this.IX(i0, j0)] + t1 * d0[this.IX(i0, j1)]) +
                            s1 * (t0 * d0[this.IX(i1, j0)] + t1 * d0[this.IX(i1, j1)]);
                    }
                }

                this.setBounds(b, d);
            }

            reset() {
                this.u.fill(0);
                this.v.fill(0);
                this.u_prev.fill(0);
                this.v_prev.fill(0);
                this.density.fill(0);
                this.density_prev.fill(0);
                this.r.fill(0);
                this.g.fill(0);
                this.b.fill(0);
                this.r_prev.fill(0);
                this.g_prev.fill(0);
                this.b_prev.fill(0);
            }
        }

        let fluid = new FluidSimulation(config.resolution);

        // Rendering
        function render() {
            const N = fluid.N;
            const cellWidth = canvas.width / N;
            const cellHeight = canvas.height / N;

            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;

            for (let j = 0; j < N; j++) {
                for (let i = 0; i < N; i++) {
                    const idx = fluid.IX(i + 1, j + 1);
                    const d = fluid.density[idx];

                    let r, g, b;

                    if (config.colorMode === 'rainbow') {
                        const vx = fluid.u[idx];
                        const vy = fluid.v[idx];
                        const angle = Math.atan2(vy, vx);
                        const hue = ((angle + Math.PI) / (2 * Math.PI)) * 360;
                        const speed = Math.sqrt(vx * vx + vy * vy);
                        const sat = Math.min(100, speed * 10);
                        const rgb = fluid.hslToRgb(hue, sat, 50);
                        r = rgb.r * Math.min(1, d / 50);
                        g = rgb.g * Math.min(1, d / 50);
                        b = rgb.b * Math.min(1, d / 50);
                    } else if (config.colorMode === 'thermal') {
                        const intensity = Math.min(1, d / 100);
                        if (d > 0) {
                            r = Math.min(255, fluid.r[idx] / d * 255);
                            g = Math.min(255, fluid.g[idx] / d * 255);
                            b = Math.min(255, fluid.b[idx] / d * 255);
                        } else {
                            const temp = intensity;
                            r = temp * 255;
                            g = temp * temp * 255;
                            b = Math.max(0, (temp - 0.5) * 2) * 128;
                        }
                    } else if (config.colorMode === 'monochrome') {
                        const val = Math.min(255, d * 2.5);
                        r = g = b = val;
                    } else if (config.colorMode === 'neon') {
                        const intensity = Math.min(1, d / 80);
                        r = Math.min(255, fluid.r[idx] / Math.max(1, d) * 255 * intensity * 1.5);
                        g = Math.min(255, fluid.g[idx] / Math.max(1, d) * 255 * intensity * 1.5);
                        b = Math.min(255, fluid.b[idx] / Math.max(1, d) * 255 * intensity * 1.5);
                    }

                    // Fill pixels for this cell
                    const x0 = Math.floor(i * cellWidth);
                    const y0 = Math.floor(j * cellHeight);
                    const x1 = Math.floor((i + 1) * cellWidth);
                    const y1 = Math.floor((j + 1) * cellHeight);

                    for (let py = y0; py < y1; py++) {
                        for (let px = x0; px < x1; px++) {
                            const pIdx = (py * canvas.width + px) * 4;
                            data[pIdx] = r;
                            data[pIdx + 1] = g;
                            data[pIdx + 2] = b;
                            data[pIdx + 3] = 255;
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);

            // Draw velocity arrows
            if (config.showArrows) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 1;

                const step = 8;
                for (let j = 0; j < N; j += step) {
                    for (let i = 0; i < N; i += step) {
                        const idx = fluid.IX(i + 1, j + 1);
                        const vx = fluid.u[idx];
                        const vy = fluid.v[idx];
                        const mag = Math.sqrt(vx * vx + vy * vy);

                        if (mag > 0.5) {
                            const x = (i + 0.5) * cellWidth;
                            const y = (j + 0.5) * cellHeight;
                            const scale = Math.min(cellWidth * 2, mag * 5);
                            const dx = (vx / mag) * scale;
                            const dy = (vy / mag) * scale;

                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            ctx.lineTo(x + dx, y + dy);
                            ctx.stroke();

                            // Arrow head
                            const angle = Math.atan2(dy, dx);
                            const headLen = 3;
                            ctx.beginPath();
                            ctx.moveTo(x + dx, y + dy);
                            ctx.lineTo(
                                x + dx - headLen * Math.cos(angle - Math.PI / 6),
                                y + dy - headLen * Math.sin(angle - Math.PI / 6)
                            );
                            ctx.moveTo(x + dx, y + dy);
                            ctx.lineTo(
                                x + dx - headLen * Math.cos(angle + Math.PI / 6),
                                y + dy - headLen * Math.sin(angle + Math.PI / 6)
                            );
                            ctx.stroke();
                        }
                    }
                }
            }
        }

        // Mouse/Touch Interaction
        let isMouseDown = false;
        let lastMouseX = null;
        let lastMouseY = null;

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = fluid.N / rect.width;
            const scaleY = fluid.N / rect.height;

            let clientX, clientY;
            if (e.touches) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            return {
                x: Math.floor((clientX - rect.left) * scaleX) + 1,
                y: Math.floor((clientY - rect.top) * scaleY) + 1
            };
        }

        function handleMouseDown(e) {
            e.preventDefault();
            isMouseDown = true;
            const pos = getMousePos(e);
            lastMouseX = pos.x;
            lastMouseY = pos.y;
        }

        function handleMouseMove(e) {
            if (!isMouseDown) return;
            e.preventDefault();

            const pos = getMousePos(e);

            if (lastMouseX !== null && lastMouseY !== null) {
                const dx = pos.x - lastMouseX;
                const dy = pos.y - lastMouseY;

                // Add density
                fluid.addDensity(pos.x, pos.y, config.densityAmount, config.injectionHue);

                // Add velocity
                fluid.addVelocity(pos.x, pos.y, dx * config.velocityAmount, dy * config.velocityAmount);
            }

            lastMouseX = pos.x;
            lastMouseY = pos.y;
        }

        function handleMouseUp() {
            isMouseDown = false;
            lastMouseX = null;
            lastMouseY = null;
        }

        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mouseleave', handleMouseUp);

        canvas.addEventListener('touchstart', handleMouseDown, { passive: false });
        canvas.addEventListener('touchmove', handleMouseMove, { passive: false });
        canvas.addEventListener('touchend', handleMouseUp);
        canvas.addEventListener('touchcancel', handleMouseUp);

        // UI Controls
        document.getElementById('playPauseBtn').addEventListener('click', () => {
            isPlaying = !isPlaying;
            const btn = document.getElementById('playPauseBtn');
            btn.textContent = isPlaying ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Play';
            btn.classList.toggle('active', isPlaying);
        });

        document.getElementById('stepBtn').addEventListener('click', () => {
            if (!isPlaying) {
                fluid.step(config.dt);
                render();
            }
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            fluid.reset();
            render();
        });

        document.getElementById('toggleArrowsBtn').addEventListener('click', () => {
            config.showArrows = !config.showArrows;
            document.getElementById('showArrows').checked = config.showArrows;
            document.getElementById('toggleArrowsBtn').textContent =
                config.showArrows ? 'üéØ Arrows: ON' : 'üéØ Arrows: OFF';
            saveSettings();
        });

        // Sliders
        const viscositySlider = document.getElementById('viscositySlider');
        const viscosityValue = document.getElementById('viscosityValue');
        viscositySlider.addEventListener('input', (e) => {
            config.viscosity = Math.pow(10, (e.target.value / 100) * 6 - 6);
            viscosityValue.textContent = config.viscosity.toExponential(4);
            saveSettings();
        });

        const diffusionSlider = document.getElementById('diffusionSlider');
        const diffusionValue = document.getElementById('diffusionValue');
        diffusionSlider.addEventListener('input', (e) => {
            config.diffusion = Math.pow(10, (e.target.value / 100) * 6 - 6);
            diffusionValue.textContent = config.diffusion.toExponential(4);
            saveSettings();
        });

        const densitySlider = document.getElementById('densitySlider');
        const densityDisplayValue = document.getElementById('densityValue');
        densitySlider.addEventListener('input', (e) => {
            config.densityAmount = parseFloat(e.target.value);
            densityDisplayValue.textContent = config.densityAmount;
            saveSettings();
        });

        const velocitySlider = document.getElementById('velocitySlider');
        const velocityValue = document.getElementById('velocityValue');
        velocitySlider.addEventListener('input', (e) => {
            config.velocityAmount = parseFloat(e.target.value);
            velocityValue.textContent = config.velocityAmount;
            saveSettings();
        });

        // Resolution select
        document.getElementById('resolutionSelect').addEventListener('change', (e) => {
            config.resolution = parseInt(e.target.value);
            fluid = new FluidSimulation(config.resolution);
            saveSettings();
        });

        // Color mode select
        document.getElementById('colorModeSelect').addEventListener('change', (e) => {
            config.colorMode = e.target.value;
            saveSettings();
        });

        // Color swatches
        document.querySelectorAll('.color-swatch').forEach(swatch => {
            swatch.addEventListener('click', () => {
                document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
                swatch.classList.add('active');
                config.injectionHue = parseInt(swatch.dataset.color);
                saveSettings();
            });
        });

        // Checkboxes
        document.getElementById('showArrows').addEventListener('change', (e) => {
            config.showArrows = e.target.checked;
            document.getElementById('toggleArrowsBtn').textContent =
                config.showArrows ? 'üéØ Arrows: ON' : 'üéØ Arrows: OFF';
            saveSettings();
        });

        document.getElementById('fadeOut').addEventListener('change', (e) => {
            config.fadeOut = e.target.checked;
            saveSettings();
        });

        // Difficulty buttons
        document.getElementById('easyBtn').addEventListener('click', () => {
            applyDifficulty('easy');
        });

        document.getElementById('mediumBtn').addEventListener('click', () => {
            applyDifficulty('medium');
        });

        document.getElementById('hardBtn').addEventListener('click', () => {
            applyDifficulty('hard');
        });

        function applyDifficulty(level) {
            config.difficulty = level;
            const preset = difficultyPresets[level];

            config.resolution = preset.resolution;
            config.viscosity = preset.viscosity;
            config.diffusion = preset.diffusion;
            config.velocityAmount = preset.velocityAmount;
            config.dt = preset.dt;

            // Update UI
            document.getElementById('resolutionSelect').value = preset.resolution;
            viscositySlider.value = (Math.log10(preset.viscosity) + 6) * 100 / 6;
            viscosityValue.textContent = preset.viscosity.toExponential(4);
            diffusionSlider.value = (Math.log10(preset.diffusion) + 6) * 100 / 6;
            diffusionValue.textContent = preset.diffusion.toExponential(4);
            velocitySlider.value = preset.velocityAmount;
            velocityValue.textContent = preset.velocityAmount;

            // Update button states
            document.querySelectorAll('.difficulty-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(level + 'Btn').classList.add('active');

            // Recreate fluid simulation
            fluid = new FluidSimulation(config.resolution);
            saveSettings();
        }

        // Instructions modal
        document.getElementById('instructionsBtn').addEventListener('click', () => {
            document.getElementById('instructionsModal').classList.add('show');
        });

        document.getElementById('closeInstructions').addEventListener('click', () => {
            document.getElementById('instructionsModal').classList.remove('show');
        });

        // Challenge mode
        document.getElementById('challengeBtn').addEventListener('click', () => {
            challengeMode = !challengeMode;
            const btn = document.getElementById('challengeBtn');
            const scoreDisplay = document.getElementById('score');

            if (challengeMode) {
                challengeScore = 0;
                btn.textContent = 'üéØ Challenge: ON';
                btn.classList.add('challenge-active');
                scoreDisplay.style.display = 'inline-block';
                scoreDisplay.textContent = 'Score: 0';
                selectNewPattern();
            } else {
                btn.textContent = 'üéØ Challenge Mode';
                btn.classList.remove('challenge-active');
                scoreDisplay.style.display = 'none';

                // Update personal best
                if (challengeScore > personalBest) {
                    personalBest = challengeScore;
                    localStorage.setItem('fluidSimPersonalBest', personalBest);
                    document.getElementById('personalBest').textContent = 'Personal Best: ' + personalBest;
                }
            }
        });

        function selectNewPattern() {
            targetPattern = patterns[Math.floor(Math.random() * patterns.length)];
            patternStartTime = Date.now();
            const btn = document.getElementById('challengeBtn');
            btn.innerHTML = 'üéØ Challenge: <span class="target-pattern">' + targetPattern.toUpperCase() + '</span>';
        }

        function checkPattern() {
            if (!challengeMode) return;

            // Simple pattern detection based on velocity field characteristics
            let totalVelocity = 0;
            let vortexScore = 0;
            let symmetryScore = 0;
            let turbulenceScore = 0;
            let laminarScore = 0;

            const N = fluid.N;
            const centerX = Math.floor(N / 2);
            const centerY = Math.floor(N / 2);

            for (let j = 1; j <= N; j++) {
                for (let i = 1; i <= N; i++) {
                    const idx = fluid.IX(i, j);
                    const vx = fluid.u[idx];
                    const vy = fluid.v[idx];
                    const speed = Math.sqrt(vx * vx + vy * vy);
                    totalVelocity += speed;

                    // Vortex detection: circular flow around center
                    const dx = i - centerX;
                    const dy = j - centerY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 5 && dist < N / 2) {
                        const expectedVx = -dy / dist;
                        const expectedVy = dx / dist;
                        const dot = (vx * expectedVx + vy * expectedVy) / (speed + 0.001);
                        vortexScore += Math.max(0, dot);
                    }

                    // Turbulence: high variation in adjacent cells
                    if (i < N && j < N) {
                        const idx2 = fluid.IX(i + 1, j);
                        const idx3 = fluid.IX(i, j + 1);
                        const diff1 = Math.abs(vx - fluid.u[idx2]) + Math.abs(vy - fluid.v[idx2]);
                        const diff2 = Math.abs(vx - fluid.u[idx3]) + Math.abs(vy - fluid.v[idx3]);
                        turbulenceScore += diff1 + diff2;
                    }

                    // Laminar: consistent direction
                    if (speed > 0.5) {
                        laminarScore += 1;
                    }

                    // Symmetry: compare left/right
                    if (i <= centerX) {
                        const mirrorIdx = fluid.IX(N - i + 1, j);
                        const diff = Math.abs(vx + fluid.u[mirrorIdx]) + Math.abs(vy - fluid.v[mirrorIdx]);
                        symmetryScore += Math.max(0, 5 - diff);
                    }
                }
            }

            // Normalize scores
            vortexScore /= (N * N);
            turbulenceScore /= (N * N);
            laminarScore /= (N * N);
            symmetryScore /= (N * N);

            // Check if pattern matches
            let matched = false;
            const threshold = 0.15;

            if (targetPattern === 'vortex' && vortexScore > threshold) {
                matched = true;
            } else if (targetPattern === 'turbulent' && turbulenceScore > 3) {
                matched = true;
            } else if (targetPattern === 'laminar' && laminarScore > 20 && turbulenceScore < 2) {
                matched = true;
            } else if (targetPattern === 'symmetrical' && symmetryScore > 0.5) {
                matched = true;
            }

            if (matched && Date.now() - patternStartTime > 2000) {
                const timeBonus = Math.max(0, 20 - Math.floor((Date.now() - patternStartTime) / 1000));
                challengeScore += 10 + timeBonus;
                document.getElementById('score').textContent = 'Score: ' + challengeScore;
                selectNewPattern();
            }
        }

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

            switch(e.key.toLowerCase()) {
                case ' ':
                    e.preventDefault();
                    document.getElementById('playPauseBtn').click();
                    break;
                case 'r':
                    e.preventDefault();
                    document.getElementById('resetBtn').click();
                    break;
                case '1':
                    config.colorMode = 'rainbow';
                    document.getElementById('colorModeSelect').value = 'rainbow';
                    saveSettings();
                    break;
                case '2':
                    config.colorMode = 'thermal';
                    document.getElementById('colorModeSelect').value = 'thermal';
                    saveSettings();
                    break;
                case '3':
                    config.colorMode = 'neon';
                    document.getElementById('colorModeSelect').value = 'neon';
                    saveSettings();
                    break;
            }
        });

        // Panel toggle
        document.getElementById('togglePanel').addEventListener('click', () => {
            document.getElementById('sidePanel').classList.toggle('show');
        });

        // localStorage
        function saveSettings() {
            localStorage.setItem('fluidSimSettings', JSON.stringify({
                resolution: config.resolution,
                viscosity: config.viscosity,
                diffusion: config.diffusion,
                densityAmount: config.densityAmount,
                velocityAmount: config.velocityAmount,
                colorMode: config.colorMode,
                injectionHue: config.injectionHue,
                showArrows: config.showArrows,
                fadeOut: config.fadeOut,
                difficulty: config.difficulty
            }));
        }

        function loadSettings() {
            const saved = localStorage.getItem('fluidSimSettings');
            if (saved) {
                try {
                    const settings = JSON.parse(saved);
                    Object.assign(config, settings);

                    // Update UI
                    document.getElementById('resolutionSelect').value = config.resolution;
                    document.getElementById('colorModeSelect').value = config.colorMode;
                    document.getElementById('showArrows').checked = config.showArrows;
                    document.getElementById('fadeOut').checked = config.fadeOut;

                    // Update slider values
                    viscositySlider.value = (Math.log10(config.viscosity) + 6) * 100 / 6;
                    viscosityValue.textContent = config.viscosity.toExponential(4);

                    diffusionSlider.value = (Math.log10(config.diffusion) + 6) * 100 / 6;
                    diffusionValue.textContent = config.diffusion.toExponential(4);

                    densitySlider.value = config.densityAmount;
                    densityDisplayValue.textContent = config.densityAmount;

                    velocitySlider.value = config.velocityAmount;
                    velocityValue.textContent = config.velocityAmount;

                    // Update color swatch
                    document.querySelectorAll('.color-swatch').forEach(s => {
                        s.classList.toggle('active', parseInt(s.dataset.color) === config.injectionHue);
                    });

                    // Update arrows button
                    document.getElementById('toggleArrowsBtn').textContent =
                        config.showArrows ? 'üéØ Arrows: ON' : 'üéØ Arrows: OFF';

                    // Update difficulty buttons
                    if (config.difficulty) {
                        document.querySelectorAll('.difficulty-btn').forEach(btn => btn.classList.remove('active'));
                        const diffBtn = document.getElementById(config.difficulty + 'Btn');
                        if (diffBtn) diffBtn.classList.add('active');
                    }
                } catch (e) {
                    console.error('Failed to load settings:', e);
                }
            }

            // Load personal best
            const savedBest = localStorage.getItem('fluidSimPersonalBest');
            if (savedBest) {
                personalBest = parseInt(savedBest);
                document.getElementById('personalBest').textContent = 'Personal Best: ' + personalBest;
            }
        }

        loadSettings();

        // Animation Loop
        function animate(currentTime) {
            const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;

            // FPS calculation
            fpsFrames++;
            fpsTime += deltaTime;
            if (fpsTime >= 1.0) {
                fps = Math.round(fpsFrames / fpsTime);
                document.getElementById('fps').textContent = 'FPS: ' + fps;
                fpsFrames = 0;
                fpsTime = 0;
            }

            if (isPlaying) {
                fluid.step(config.dt);
            }

            render();

            // Check challenge pattern every 500ms
            if (challengeMode && fpsFrames % 30 === 0) {
                checkPattern();
            }

            requestAnimationFrame(animate);
        }

        requestAnimationFrame(animate);
    </script>
</body>
</html>