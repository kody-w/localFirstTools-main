<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real City Ecosystem - OSM Urban Evolution</title>
    <meta name="description" content="Evolution simulation in real cities from OpenStreetMap data. Explore Manhattan, Tokyo, London with AI creatures navigating actual streets.">
    <meta name="theme-color" content="#0a1628">
    <meta name="color-scheme" content="dark">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; font-family: 'Segoe UI', system-ui, sans-serif; color: white; }

        #loading {
            position: fixed; inset: 0;
            background: linear-gradient(135deg, #0a1628, #1a0a28);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 1000; transition: opacity 0.8s ease;
        }
        #loading.hidden { opacity: 0; pointer-events: none; }
        #loading h1 { font-size: 2.5em; background: linear-gradient(90deg, #00ff88, #00aaff, #ff00aa); -webkit-background-clip: text; -webkit-text-fill-color: transparent; margin-bottom: 10px; text-align: center; }
        #loading p { color: rgba(255,255,255,0.6); margin-bottom: 20px; text-align: center; }
        #loading-status { color: #00ff88; font-size: 0.9em; margin-top: 15px; }
        .loading-bar { width: 350px; height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; overflow: hidden; }
        .loading-fill { height: 100%; background: linear-gradient(90deg, #00ff88, #00aaff); width: 0%; transition: width 0.3s; }

        #city-select-container {
            position: fixed; inset: 0;
            background: linear-gradient(135deg, #0a1628, #1a0a28);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 999;
        }
        #city-select-container.hidden { display: none; }
        #city-select-container h1 { font-size: 2.8em; background: linear-gradient(90deg, #00ff88, #00aaff); -webkit-background-clip: text; -webkit-text-fill-color: transparent; margin-bottom: 10px; }
        #city-select-container .subtitle { color: rgba(255,255,255,0.5); margin-bottom: 40px; }
        .city-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; max-width: 900px; }
        .city-card {
            background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1);
            border-radius: 16px; padding: 25px; cursor: pointer; transition: all 0.3s;
            text-align: center; min-width: 250px;
        }
        .city-card:hover { background: rgba(255,255,255,0.1); transform: translateY(-5px); border-color: #00ff88; }
        .city-card h3 { font-size: 1.4em; margin-bottom: 5px; }
        .city-card .country { color: rgba(255,255,255,0.4); font-size: 0.85em; margin-bottom: 12px; }
        .city-card .stats { font-size: 0.8em; color: rgba(255,255,255,0.6); }
        .city-card .emoji { font-size: 2.5em; margin-bottom: 10px; }

        #hud { position: absolute; top: 15px; left: 15px; background: rgba(0,0,0,0.9); padding: 15px 20px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1); backdrop-filter: blur(10px); min-width: 220px; z-index: 100; }
        #hud h2 { font-size: 1em; color: #00ff88; margin-bottom: 8px; display: flex; align-items: center; gap: 8px; }
        #hud .city-name { font-size: 0.7em; color: rgba(255,255,255,0.5); font-weight: normal; }
        .stat-group { margin-bottom: 10px; }
        .stat-group-title { font-size: 0.65em; color: rgba(255,255,255,0.4); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 4px; }
        .stat { display: flex; justify-content: space-between; padding: 2px 0; font-size: 0.8em; }
        .stat-value { font-weight: bold; }
        .stat-value.plants { color: #00ff88; }
        .stat-value.herbivores { color: #00aaff; }
        .stat-value.predators { color: #ff4466; }

        #scale-indicator { position: absolute; bottom: 80px; right: 15px; background: rgba(0,0,0,0.85); padding: 8px 12px; border-radius: 8px; font-size: 0.75em; }
        #scale-indicator .scale-bar { width: 100px; height: 4px; background: white; margin-top: 4px; position: relative; }
        #scale-indicator .scale-bar::before, #scale-indicator .scale-bar::after { content: ''; position: absolute; width: 2px; height: 8px; background: white; top: -2px; }
        #scale-indicator .scale-bar::before { left: 0; }
        #scale-indicator .scale-bar::after { right: 0; }

        #minimap { position: absolute; top: 15px; right: 15px; width: 180px; height: 180px; background: rgba(0,0,0,0.9); border-radius: 12px; border: 1px solid rgba(255,255,255,0.1); overflow: hidden; }
        #minimap canvas { width: 100%; height: 100%; }
        #minimap-label { position: absolute; bottom: 5px; left: 50%; transform: translateX(-50%); font-size: 0.65em; color: rgba(255,255,255,0.5); }

        #controls { position: absolute; bottom: 15px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.9); padding: 10px 18px; border-radius: 25px; border: 1px solid rgba(255,255,255,0.1); display: flex; gap: 6px; align-items: center; z-index: 100; }
        button { background: linear-gradient(135deg, #333, #222); color: white; border: 1px solid rgba(255,255,255,0.1); padding: 7px 14px; cursor: pointer; border-radius: 12px; font-size: 11px; transition: all 0.2s; }
        button:hover { background: linear-gradient(135deg, #444, #333); }
        button.active { background: linear-gradient(135deg, #00aa66, #008855); }
        button.danger { background: linear-gradient(135deg, #aa3344, #882233); }
        .speed-display { background: rgba(255,255,255,0.1); padding: 7px 12px; border-radius: 12px; font-size: 11px; min-width: 35px; text-align: center; }

        #graph-panel { position: absolute; bottom: 15px; left: 15px; background: rgba(0,0,0,0.9); padding: 12px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1); z-index: 100; }
        #graph-panel h3 { font-size: 0.75em; color: #00aaff; margin-bottom: 6px; }

        #legend { position: absolute; top: 210px; right: 15px; background: rgba(0,0,0,0.9); padding: 10px 12px; border-radius: 10px; font-size: 0.75em; }
        .legend-item { display: flex; align-items: center; gap: 6px; padding: 2px 0; }
        .legend-dot { width: 10px; height: 10px; border-radius: 50%; }

        #osm-credit { position: absolute; bottom: 15px; right: 15px; font-size: 0.65em; color: rgba(255,255,255,0.4); }
        #osm-credit a { color: #00aaff; }

        #data-stats { position: absolute; top: 210px; left: 15px; background: rgba(0,0,0,0.85); padding: 10px 15px; border-radius: 10px; font-size: 0.75em; }
        #data-stats .title { color: #ffaa00; margin-bottom: 5px; font-weight: bold; }

        .tooltip { position: absolute; background: rgba(0,0,0,0.95); padding: 8px 12px; border-radius: 8px; font-size: 0.8em; pointer-events: none; display: none; z-index: 200; border: 1px solid rgba(255,255,255,0.2); }
    </style>
</head>
<body>
    <div id="city-select-container">
        <h1>üåç Real City Ecosystem</h1>
        <p class="subtitle">Select a city to simulate evolution in real urban environments</p>
        <div class="city-grid">
            <div class="city-card" data-city="manhattan">
                <div class="emoji">üóΩ</div>
                <h3>Manhattan</h3>
                <div class="country">New York, USA</div>
                <div class="stats">~47,000 buildings ‚Ä¢ Dense urban</div>
            </div>
            <div class="city-card" data-city="tokyo-shibuya">
                <div class="emoji">üóº</div>
                <h3>Shibuya</h3>
                <div class="country">Tokyo, Japan</div>
                <div class="stats">~12,000 buildings ‚Ä¢ Neon district</div>
            </div>
            <div class="city-card" data-city="london-city">
                <div class="emoji">üé°</div>
                <h3>The City</h3>
                <div class="country">London, UK</div>
                <div class="stats">~8,000 buildings ‚Ä¢ Financial</div>
            </div>
            <div class="city-card" data-city="paris-center">
                <div class="emoji">üóº</div>
                <h3>Le Marais</h3>
                <div class="country">Paris, France</div>
                <div class="stats">~6,000 buildings ‚Ä¢ Historic</div>
            </div>
            <div class="city-card" data-city="singapore">
                <div class="emoji">ü¶Å</div>
                <h3>Marina Bay</h3>
                <div class="country">Singapore</div>
                <div class="stats">~4,000 buildings ‚Ä¢ Modern</div>
            </div>
            <div class="city-card" data-city="custom">
                <div class="emoji">üìç</div>
                <h3>Custom Location</h3>
                <div class="country">Enter coordinates</div>
                <div class="stats">Any location worldwide</div>
            </div>
        </div>
    </div>

    <div id="loading" class="hidden">
        <h1>Loading City Data</h1>
        <p id="loading-city">Manhattan, New York</p>
        <div class="loading-bar"><div class="loading-fill" id="loading-fill"></div></div>
        <div id="loading-status">Connecting to OpenStreetMap...</div>
    </div>

    <div id="hud" style="display:none;">
        <h2>üåÜ <span id="hud-city-name">Manhattan</span></h2>
        <div class="stat-group">
            <div class="stat-group-title">Population</div>
            <div class="stat"><span>üåø Plants</span><span class="stat-value plants" id="stat-plants">0</span></div>
            <div class="stat"><span>üê∞ Herbivores</span><span class="stat-value herbivores" id="stat-herbivores">0</span></div>
            <div class="stat"><span>ü¶ä Predators</span><span class="stat-value predators" id="stat-predators">0</span></div>
        </div>
        <div class="stat-group">
            <div class="stat-group-title">Evolution</div>
            <div class="stat"><span>Generation</span><span class="stat-value" id="stat-generation">1</span></div>
            <div class="stat"><span>Births</span><span class="stat-value" id="stat-births">0</span></div>
        </div>
    </div>

    <div id="minimap" style="display:none;">
        <canvas id="minimap-canvas"></canvas>
        <div id="minimap-label">Minimap</div>
    </div>

    <div id="legend" style="display:none;">
        <div class="legend-item"><div class="legend-dot" style="background:#00ff88"></div> Plants</div>
        <div class="legend-item"><div class="legend-dot" style="background:#00aaff"></div> Herbivores</div>
        <div class="legend-item"><div class="legend-dot" style="background:#ff4466"></div> Predators</div>
        <div class="legend-item"><div class="legend-dot" style="background:#556677"></div> Buildings</div>
        <div class="legend-item"><div class="legend-dot" style="background:#3a3a3a"></div> Roads</div>
        <div class="legend-item"><div class="legend-dot" style="background:#2d5a2d"></div> Parks</div>
    </div>

    <div id="data-stats" style="display:none;">
        <div class="title">üìä City Data</div>
        <div class="stat"><span>Buildings</span><span id="stat-buildings">0</span></div>
        <div class="stat"><span>Roads</span><span id="stat-roads">0</span></div>
        <div class="stat"><span>Parks</span><span id="stat-parks">0</span></div>
        <div class="stat"><span>Area</span><span id="stat-area">0 km¬≤</span></div>
    </div>

    <div id="scale-indicator" style="display:none;">
        <span id="scale-text">100m</span>
        <div class="scale-bar"></div>
    </div>

    <div id="graph-panel" style="display:none;">
        <h3>Population Over Time</h3>
        <canvas id="population-graph" width="280" height="80"></canvas>
    </div>

    <div id="controls" style="display:none;">
        <button id="btn-change-city">üåç City</button>
        <button id="btn-pause">‚è∏</button>
        <button id="btn-speed-down">‚óÄ</button>
        <div class="speed-display" id="speed-display">1x</div>
        <button id="btn-speed-up">‚ñ∂</button>
        <button id="btn-spawn-herb">+üê∞</button>
        <button id="btn-spawn-pred">+ü¶ä</button>
        <button id="btn-reset" class="danger">‚Ü∫</button>
    </div>

    <div id="osm-credit" style="display:none;">
        Data ¬© <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors
    </div>

    <div class="tooltip" id="tooltip"></div>

    <!-- SIMPLE DRAG ALIGN PANEL -->
    <div id="debug-panel" style="display:none; position:absolute; top:210px; right:15px; background:rgba(0,0,0,0.9); padding:10px 12px; border-radius:10px; font-size:0.75em; border:1px solid #ff6600; z-index:999;">
        <div style="color:#ff6600; margin-bottom:8px; font-weight:bold;">üîß Align Mode</div>
        <div style="color:#0f0; font-size:0.95em;"><kbd style="background:#333;padding:2px 5px;border-radius:3px;">M</kbd> + drag = Move</div>
        <div style="color:#0f0; font-size:0.95em; margin-bottom:5px;"><kbd style="background:#333;padding:2px 5px;border-radius:3px;">R</kbd> + drag = Rotate</div>
        <div style="color:#fff;">Pos: <span id="offset-display">X:0 Z:0</span></div>
        <div style="color:#fff;">Rot: <span id="rotation-display">0¬∞</span></div>
        <button id="btn-copy-offset" style="margin-top:8px; width:100%;">Copy Values</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
// ============================================================
// CITY PRESETS - Real-world bounding boxes
// ============================================================
const CITY_PRESETS = {
    'manhattan': {
        name: 'Manhattan',
        fullName: 'Manhattan, New York',
        bounds: { south: 40.7000, north: 40.7600, west: -74.0150, east: -73.9700 },
        center: { lat: 40.7300, lon: -73.9925 },
        defaultZoom: 0.8,
        style: 'american',
        buildingColor: 0x667788,
        ambientLight: 0x404060
    },
    'tokyo-shibuya': {
        name: 'Shibuya',
        fullName: 'Shibuya, Tokyo',
        bounds: { south: 35.6550, north: 35.6700, west: 139.6950, east: 139.7100 },
        center: { lat: 35.6625, lon: 139.7025 },
        defaultZoom: 1.2,
        style: 'japanese',
        buildingColor: 0x778899,
        ambientLight: 0x503060
    },
    'london-city': {
        name: 'The City',
        fullName: 'City of London, UK',
        bounds: { south: 51.5050, north: 51.5200, west: -0.1000, east: -0.0700 },
        center: { lat: 51.5125, lon: -0.0850 },
        defaultZoom: 1.0,
        style: 'european',
        buildingColor: 0x8899aa,
        ambientLight: 0x405060
    },
    'paris-center': {
        name: 'Le Marais',
        fullName: 'Le Marais, Paris',
        bounds: { south: 48.8500, north: 48.8650, west: 2.3450, east: 2.3700 },
        center: { lat: 48.8575, lon: 2.3575 },
        defaultZoom: 1.0,
        style: 'parisian',
        buildingColor: 0xc4b69c,
        ambientLight: 0x605040
    },
    'singapore': {
        name: 'Marina Bay',
        fullName: 'Marina Bay, Singapore',
        bounds: { south: 1.2750, north: 1.2950, west: 103.8500, east: 103.8700 },
        center: { lat: 1.2850, lon: 103.8600 },
        defaultZoom: 1.0,
        style: 'modern',
        buildingColor: 0x99aabb,
        ambientLight: 0x406050
    }
};

// ============================================================
// COORDINATE PROJECTION - Web Mercator
// ============================================================
class GeoProjection {
    constructor(centerLat, centerLon, scale = 1) {
        this.centerLat = centerLat;
        this.centerLon = centerLon;
        this.scale = scale;
        // Meters per degree at the equator
        this.metersPerDegreeLon = 111320;
        this.metersPerDegreeLat = 110574;
        // Adjust for latitude
        this.latFactor = Math.cos(centerLat * Math.PI / 180);
    }

    project(lat, lon) {
        const x = (lon - this.centerLon) * this.metersPerDegreeLon * this.latFactor * this.scale;
        const z = (this.centerLat - lat) * this.metersPerDegreeLat * this.scale;
        return { x, z };
    }

    unproject(x, z) {
        const lon = x / (this.metersPerDegreeLon * this.latFactor * this.scale) + this.centerLon;
        const lat = this.centerLat - z / (this.metersPerDegreeLat * this.scale);
        return { lat, lon };
    }
}

// ============================================================
// OSM DATA FETCHER
// ============================================================
class OSMFetcher {
    constructor() {
        this.overpassUrl = 'https://overpass-api.de/api/interpreter';
    }

    async fetchCityData(bounds, onProgress) {
        const query = `
            [out:json][timeout:60];
            (
                way["building"](${bounds.south},${bounds.west},${bounds.north},${bounds.east});
                way["highway"~"primary|secondary|tertiary|residential|footway|pedestrian"](${bounds.south},${bounds.west},${bounds.north},${bounds.east});
                way["leisure"="park"](${bounds.south},${bounds.west},${bounds.north},${bounds.east});
                way["landuse"="grass"](${bounds.south},${bounds.west},${bounds.north},${bounds.east});
                relation["leisure"="park"](${bounds.south},${bounds.west},${bounds.north},${bounds.east});
            );
            out body;
            >;
            out skel qt;
        `;

        onProgress('Querying OpenStreetMap...');

        try {
            const response = await fetch(this.overpassUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: 'data=' + encodeURIComponent(query)
            });

            if (!response.ok) throw new Error(`HTTP ${response.status}`);

            onProgress('Downloading city data...');
            const data = await response.json();

            onProgress('Processing buildings and roads...');
            return this.parseOSMData(data);
        } catch (error) {
            console.error('OSM fetch error:', error);
            onProgress('Using cached fallback data...');
            return this.generateFallbackData(bounds);
        }
    }

    parseOSMData(data) {
        const nodes = new Map();
        const buildings = [];
        const roads = [];
        const parks = [];

        // First pass: index all nodes
        for (const element of data.elements) {
            if (element.type === 'node') {
                nodes.set(element.id, { lat: element.lat, lon: element.lon });
            }
        }

        // Second pass: process ways
        for (const element of data.elements) {
            if (element.type === 'way' && element.nodes) {
                const coords = element.nodes
                    .map(nodeId => nodes.get(nodeId))
                    .filter(n => n);

                if (coords.length < 2) continue;

                const tags = element.tags || {};

                if (tags.building) {
                    const levels = parseInt(tags['building:levels']) ||
                                   parseInt(tags.levels) ||
                                   Math.floor(Math.random() * 8) + 1;
                    const height = parseFloat(tags.height) || levels * 3.5;

                    buildings.push({
                        id: element.id,
                        coords,
                        height,
                        levels,
                        type: tags.building,
                        name: tags.name
                    });
                } else if (tags.highway) {
                    roads.push({
                        id: element.id,
                        coords,
                        type: tags.highway,
                        name: tags.name,
                        width: this.getRoadWidth(tags.highway)
                    });
                } else if (tags.leisure === 'park' || tags.landuse === 'grass') {
                    parks.push({
                        id: element.id,
                        coords,
                        name: tags.name
                    });
                }
            }
        }

        return { buildings, roads, parks, nodeCount: nodes.size };
    }

    getRoadWidth(type) {
        const widths = {
            'primary': 12, 'secondary': 10, 'tertiary': 8,
            'residential': 6, 'footway': 2, 'pedestrian': 4
        };
        return widths[type] || 6;
    }

    generateFallbackData(bounds) {
        // Generate procedural city data as fallback
        const buildings = [];
        const roads = [];
        const parks = [];

        const latRange = bounds.north - bounds.south;
        const lonRange = bounds.east - bounds.west;

        // Generate grid of buildings
        const gridSize = 20;
        for (let i = 0; i < gridSize; i++) {
            for (let j = 0; j < gridSize; j++) {
                if (Math.random() > 0.7) continue; // Some empty lots

                const lat = bounds.south + (i / gridSize) * latRange + Math.random() * 0.001;
                const lon = bounds.west + (j / gridSize) * lonRange + Math.random() * 0.001;
                const size = 0.0003 + Math.random() * 0.0004;

                // Taller in center
                const distFromCenter = Math.sqrt(
                    Math.pow((i / gridSize) - 0.5, 2) +
                    Math.pow((j / gridSize) - 0.5, 2)
                );
                const heightFactor = 1 - distFromCenter;
                const height = 10 + Math.random() * 80 * heightFactor;

                buildings.push({
                    id: `fallback-${i}-${j}`,
                    coords: [
                        { lat, lon },
                        { lat: lat + size, lon },
                        { lat: lat + size, lon: lon + size },
                        { lat, lon: lon + size }
                    ],
                    height,
                    levels: Math.ceil(height / 3.5),
                    type: 'yes'
                });
            }
        }

        // Generate roads
        for (let i = 0; i <= gridSize; i += 4) {
            const lat = bounds.south + (i / gridSize) * latRange;
            roads.push({
                id: `road-h-${i}`,
                coords: [
                    { lat, lon: bounds.west },
                    { lat, lon: bounds.east }
                ],
                type: i % 8 === 0 ? 'primary' : 'secondary',
                width: i % 8 === 0 ? 12 : 8
            });

            const lon = bounds.west + (i / gridSize) * lonRange;
            roads.push({
                id: `road-v-${i}`,
                coords: [
                    { lat: bounds.south, lon },
                    { lat: bounds.north, lon }
                ],
                type: i % 8 === 0 ? 'primary' : 'secondary',
                width: i % 8 === 0 ? 12 : 8
            });
        }

        // Generate parks
        for (let i = 0; i < 5; i++) {
            const lat = bounds.south + Math.random() * latRange * 0.8 + latRange * 0.1;
            const lon = bounds.west + Math.random() * lonRange * 0.8 + lonRange * 0.1;
            const size = 0.001 + Math.random() * 0.002;

            parks.push({
                id: `park-${i}`,
                coords: [
                    { lat, lon },
                    { lat: lat + size, lon },
                    { lat: lat + size, lon: lon + size },
                    { lat, lon: lon + size }
                ],
                name: `Park ${i + 1}`
            });
        }

        return { buildings, roads, parks, nodeCount: 0, isFallback: true };
    }
}

// ============================================================
// NEURAL NETWORK (Simplified for creatures)
// ============================================================
class NeuralNetwork {
    constructor(inputSize = 6, hiddenSize = 8, outputSize = 3) {
        this.weightsIH = this.randomMatrix(hiddenSize, inputSize);
        this.weightsHO = this.randomMatrix(outputSize, hiddenSize);
        this.biasH = this.randomArray(hiddenSize);
        this.biasO = this.randomArray(outputSize);
    }

    randomMatrix(rows, cols) {
        return Array(rows).fill().map(() =>
            Array(cols).fill().map(() => (Math.random() - 0.5) * 2)
        );
    }

    randomArray(size) {
        return Array(size).fill().map(() => (Math.random() - 0.5) * 2);
    }

    forward(inputs) {
        const hidden = this.biasH.map((bias, i) => {
            let sum = bias;
            for (let j = 0; j < inputs.length; j++) {
                sum += inputs[j] * this.weightsIH[i][j];
            }
            return Math.tanh(sum);
        });

        return this.biasO.map((bias, i) => {
            let sum = bias;
            for (let j = 0; j < hidden.length; j++) {
                sum += hidden[j] * this.weightsHO[i][j];
            }
            return Math.tanh(sum);
        });
    }

    mutate(rate = 0.1) {
        const mutateArray = arr => arr.map(v =>
            Math.random() < rate ? v + (Math.random() - 0.5) * 0.5 : v
        );
        const mutateMatrix = m => m.map(row => mutateArray(row));

        this.weightsIH = mutateMatrix(this.weightsIH);
        this.weightsHO = mutateMatrix(this.weightsHO);
        this.biasH = mutateArray(this.biasH);
        this.biasO = mutateArray(this.biasO);
    }

    clone() {
        const nn = new NeuralNetwork();
        nn.weightsIH = this.weightsIH.map(r => [...r]);
        nn.weightsHO = this.weightsHO.map(r => [...r]);
        nn.biasH = [...this.biasH];
        nn.biasO = [...this.biasO];
        return nn;
    }
}

// ============================================================
// CREATURE CLASSES
// ============================================================
class Creature {
    constructor(x, z, dna = null) {
        this.x = x;
        this.z = z;
        this.vx = 0;
        this.vz = 0;
        this.energy = 100;
        this.age = 0;
        this.generation = 1;
        this.alive = true;

        this.dna = dna || {
            size: 0.3 + Math.random() * 0.4,
            speed: 1 + Math.random() * 2,
            vision: 10 + Math.random() * 20,
            metabolism: 0.5 + Math.random() * 1,
            colorH: Math.random()
        };

        this.brain = new NeuralNetwork();
        this.mesh = null;
    }

    think(nearestFood, nearestThreat, nearestMate) {
        const inputs = [
            nearestFood ? (nearestFood.x - this.x) / this.dna.vision : 0,
            nearestFood ? (nearestFood.z - this.z) / this.dna.vision : 0,
            nearestThreat ? (nearestThreat.x - this.x) / this.dna.vision : 0,
            nearestThreat ? (nearestThreat.z - this.z) / this.dna.vision : 0,
            this.energy / 100,
            Math.sin(this.age * 0.1)
        ];

        const outputs = this.brain.forward(inputs);
        return { dx: outputs[0], dz: outputs[1], action: outputs[2] };
    }

    reproduce(partner = null) {
        const childDna = {};
        for (const key in this.dna) {
            if (partner && Math.random() > 0.5) {
                childDna[key] = partner.dna[key];
            } else {
                childDna[key] = this.dna[key];
            }
            // Mutation
            if (Math.random() < 0.1) {
                childDna[key] *= 0.8 + Math.random() * 0.4;
            }
        }

        const child = new this.constructor(
            this.x + (Math.random() - 0.5) * 2,
            this.z + (Math.random() - 0.5) * 2,
            childDna
        );
        child.generation = this.generation + 1;
        child.brain = this.brain.clone();
        child.brain.mutate(0.15);

        return child;
    }
}

class Herbivore extends Creature {
    constructor(x, z, dna) {
        super(x, z, dna);
        this.type = 'herbivore';
    }
}

class Predator extends Creature {
    constructor(x, z, dna) {
        super(x, z, dna);
        this.type = 'predator';
        this.dna.speed *= 1.2;
    }
}

class Plant {
    constructor(x, z) {
        this.x = x;
        this.z = z;
        this.energy = 30;
        this.alive = true;
        this.mesh = null;
    }
}

// ============================================================
// MAIN SIMULATION
// ============================================================
class CityEcosystem {
    constructor() {
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.controls = null;

        this.cityData = null;
        this.projection = null;
        this.currentCity = null;
        this.bounds = null;

        this.creatures = [];
        this.plants = [];
        this.buildings = [];
        this.buildingMeshes = [];

        this.paused = false;
        this.speed = 1;
        this.time = 0;
        this.births = 0;
        this.maxGeneration = 1;

        this.populationHistory = { plants: [], herbivores: [], predators: [] };
        this.historyMaxLength = 200;

        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();
        this.selectedCreature = null;

        // Content group for draggable alignment
        this.contentGroup = null;
        this.alignDragging = false;
        this.lastAlignX = 0;
        this.lastAlignY = 0;

        this.setupEventListeners();
        this.setupAlignDrag();
    }

    setupEventListeners() {
        document.querySelectorAll('.city-card').forEach(card => {
            card.addEventListener('click', () => {
                const cityId = card.dataset.city;
                if (cityId === 'custom') {
                    this.promptCustomLocation();
                } else {
                    this.loadCity(cityId);
                }
            });
        });

        document.getElementById('btn-pause').addEventListener('click', () => this.togglePause());
        document.getElementById('btn-speed-up').addEventListener('click', () => this.changeSpeed(1));
        document.getElementById('btn-speed-down').addEventListener('click', () => this.changeSpeed(-1));
        document.getElementById('btn-spawn-herb').addEventListener('click', () => this.spawnCreature('herbivore'));
        document.getElementById('btn-spawn-pred').addEventListener('click', () => this.spawnCreature('predator'));
        document.getElementById('btn-reset').addEventListener('click', () => this.resetSimulation());
        document.getElementById('btn-change-city').addEventListener('click', () => this.showCitySelect());

        window.addEventListener('resize', () => this.onResize());
        window.addEventListener('keydown', e => this.onKeyDown(e));
    }

    setupAlignDrag() {
        let moveMode = false;
        let rotateMode = false;
        let dragging = false;

        // Track M and R keys
        window.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'm') moveMode = true;
            if (e.key.toLowerCase() === 'r') rotateMode = true;
        });
        window.addEventListener('keyup', (e) => {
            if (e.key.toLowerCase() === 'm') moveMode = false;
            if (e.key.toLowerCase() === 'r') rotateMode = false;
        });

        window.addEventListener('mousedown', (e) => {
            if ((moveMode || rotateMode) && this.contentGroup) {
                dragging = true;
                this.lastAlignX = e.clientX;
                this.lastAlignY = e.clientY;
                e.preventDefault();
            }
        });

        window.addEventListener('mousemove', (e) => {
            if (!dragging || !this.contentGroup) return;

            const dx = e.clientX - this.lastAlignX;
            const dy = e.clientY - this.lastAlignY;

            if (moveMode) {
                this.contentGroup.position.x += dx * 0.15;
                this.contentGroup.position.z += dy * 0.15;
            }
            if (rotateMode) {
                this.contentGroup.rotation.y += dx * 0.005;
            }

            this.lastAlignX = e.clientX;
            this.lastAlignY = e.clientY;
            this.updateOffsetDisplay();
        });

        window.addEventListener('mouseup', () => dragging = false);

        // Copy values button
        document.getElementById('btn-copy-offset')?.addEventListener('click', () => {
            if (this.contentGroup) {
                const offset = {
                    city: this.currentCity?.name || 'unknown',
                    x: this.contentGroup.position.x.toFixed(2),
                    z: this.contentGroup.position.z.toFixed(2),
                    rotationDeg: (this.contentGroup.rotation.y * 180 / Math.PI).toFixed(2)
                };
                const json = JSON.stringify(offset, null, 2);
                navigator.clipboard.writeText(json).then(() => alert('Copied!\n' + json));
            }
        });
    }

    updateOffsetDisplay() {
        const pos = document.getElementById('offset-display');
        const rot = document.getElementById('rotation-display');
        if (this.contentGroup) {
            if (pos) pos.textContent = `X:${this.contentGroup.position.x.toFixed(1)} Z:${this.contentGroup.position.z.toFixed(1)}`;
            if (rot) rot.textContent = `${(this.contentGroup.rotation.y * 180 / Math.PI).toFixed(1)}¬∞`;
        }
    }

    promptCustomLocation() {
        const lat = prompt('Enter latitude (e.g., 40.7128):');
        const lon = prompt('Enter longitude (e.g., -74.0060):');

        if (lat && lon) {
            const latNum = parseFloat(lat);
            const lonNum = parseFloat(lon);

            if (!isNaN(latNum) && !isNaN(lonNum)) {
                const customPreset = {
                    name: 'Custom',
                    fullName: `${latNum.toFixed(4)}, ${lonNum.toFixed(4)}`,
                    bounds: {
                        south: latNum - 0.01,
                        north: latNum + 0.01,
                        west: lonNum - 0.01,
                        east: lonNum + 0.01
                    },
                    center: { lat: latNum, lon: lonNum },
                    defaultZoom: 1.0,
                    style: 'default',
                    buildingColor: 0x778899,
                    ambientLight: 0x404040
                };

                CITY_PRESETS['custom-loc'] = customPreset;
                this.loadCity('custom-loc');
            }
        }
    }

    async loadCity(cityId) {
        const preset = CITY_PRESETS[cityId];
        if (!preset) return;

        this.currentCity = preset;
        this.bounds = preset.bounds;

        // Show loading
        document.getElementById('city-select-container').classList.add('hidden');
        document.getElementById('loading').classList.remove('hidden');
        document.getElementById('loading-city').textContent = preset.fullName;

        const updateStatus = (status) => {
            document.getElementById('loading-status').textContent = status;
        };

        const updateProgress = (percent) => {
            document.getElementById('loading-fill').style.width = `${percent}%`;
        };

        try {
            // Fetch OSM data
            updateProgress(10);
            const fetcher = new OSMFetcher();
            this.cityData = await fetcher.fetchCityData(preset.bounds, updateStatus);

            updateProgress(50);
            updateStatus('Building 3D city...');

            // Initialize Three.js if not already done
            if (!this.scene) {
                this.initThreeJS();
            } else {
                this.clearScene();
            }

            // Setup projection
            this.projection = new GeoProjection(
                preset.center.lat,
                preset.center.lon,
                0.1 // Scale factor (1 unit = 10 meters)
            );

            updateProgress(60);
            this.buildCity();

            updateProgress(80);
            updateStatus('Spawning life...');
            this.initializeLife();

            updateProgress(100);

            // Show UI
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
                this.showUI();
                this.updateStats();
                this.animate();
            }, 500);

        } catch (error) {
            console.error('Failed to load city:', error);
            updateStatus('Error loading city. Using fallback...');
        }
    }

    initThreeJS() {
        // Scene
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x1a1a2e);
        this.scene.fog = new THREE.Fog(0x1a1a2e, 50, 300);

        // Camera
        this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.camera.position.set(0, 80, 80);
        this.camera.lookAt(0, 0, 0);

        // Renderer
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(this.renderer.domElement);

        // Lights
        const ambient = new THREE.AmbientLight(this.currentCity?.ambientLight || 0x404060, 0.6);
        this.scene.add(ambient);

        const sun = new THREE.DirectionalLight(0xffffff, 0.8);
        sun.position.set(50, 100, 50);
        sun.castShadow = true;
        sun.shadow.mapSize.width = 2048;
        sun.shadow.mapSize.height = 2048;
        sun.shadow.camera.near = 1;
        sun.shadow.camera.far = 300;
        sun.shadow.camera.left = -100;
        sun.shadow.camera.right = 100;
        sun.shadow.camera.top = 100;
        sun.shadow.camera.bottom = -100;
        this.scene.add(sun);

        // Simple orbit controls
        this.setupControls();

        // Click handler
        this.renderer.domElement.addEventListener('click', e => this.onClick(e));
    }

    setupControls() {
        let isDragging = false;
        let lastX = 0, lastY = 0;
        let theta = 0, phi = Math.PI / 4;
        let distance = 100;
        const target = new THREE.Vector3(0, 0, 0);

        const updateCamera = () => {
            this.camera.position.x = target.x + distance * Math.sin(phi) * Math.sin(theta);
            this.camera.position.y = target.y + distance * Math.cos(phi);
            this.camera.position.z = target.z + distance * Math.sin(phi) * Math.cos(theta);
            this.camera.lookAt(target);
        };

        this.renderer.domElement.addEventListener('mousedown', e => {
            if (e.shiftKey) return; // Let align drag handle shift+drag
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
        });

        window.addEventListener('mouseup', () => isDragging = false);

        window.addEventListener('mousemove', e => {
            if (!isDragging) return;
            const dx = e.clientX - lastX;
            const dy = e.clientY - lastY;
            theta -= dx * 0.01;
            phi = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, phi + dy * 0.01));
            updateCamera();
            lastX = e.clientX;
            lastY = e.clientY;
        });

        this.renderer.domElement.addEventListener('wheel', e => {
            distance = Math.max(20, Math.min(300, distance + e.deltaY * 0.1));
            updateCamera();
        });

        // Keyboard controls
        const moveSpeed = 2;
        window.addEventListener('keydown', e => {
            switch(e.key.toLowerCase()) {
                case 'w': target.z -= moveSpeed; break;
                case 's': target.z += moveSpeed; break;
                case 'a': target.x -= moveSpeed; break;
                case 'd': target.x += moveSpeed; break;
            }
            updateCamera();
        });

        updateCamera();
        this.updateCameraFn = updateCamera;
    }

    clearScene() {
        // Remove old meshes
        while(this.scene.children.length > 2) { // Keep lights
            const obj = this.scene.children[this.scene.children.length - 1];
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material) {
                if (Array.isArray(obj.material)) {
                    obj.material.forEach(m => m.dispose());
                } else {
                    obj.material.dispose();
                }
            }
            this.scene.remove(obj);
        }

        this.buildingMeshes = [];
        this.creatures = [];
        this.plants = [];
        this.buildings = [];
    }

    buildCity() {
        const { buildings, roads, parks } = this.cityData;

        // Ground plane
        const groundGeo = new THREE.PlaneGeometry(400, 400);
        const groundMat = new THREE.MeshStandardMaterial({
            color: 0x2d3a2d,
            roughness: 0.9
        });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        ground.userData = { type: 'ground' };
        this.scene.add(ground);

        // Build roads (stay fixed)
        const roadMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.9 });
        for (const road of roads) {
            this.buildRoad(road, roadMat);
        }

        // Create content group for buildings and parks (can be dragged)
        this.contentGroup = new THREE.Group();
        this.scene.add(this.contentGroup);

        // Build parks (in content group)
        const parkMat = new THREE.MeshStandardMaterial({ color: 0x3a5a3a, roughness: 0.8 });
        for (const park of parks) {
            this.buildPark(park, parkMat);
        }

        // Build buildings (in content group)
        const buildingMat = new THREE.MeshStandardMaterial({
            color: this.currentCity.buildingColor,
            roughness: 0.7,
            metalness: 0.1
        });

        for (const building of buildings) {
            this.buildBuilding(building, buildingMat);
        }

        // Update stats
        document.getElementById('stat-buildings').textContent = buildings.length;
        document.getElementById('stat-roads').textContent = roads.length;
        document.getElementById('stat-parks').textContent = parks.length;

        const areaKm2 = (
            (this.bounds.north - this.bounds.south) * 110.574 *
            (this.bounds.east - this.bounds.west) * 111.32 *
            Math.cos(this.currentCity.center.lat * Math.PI / 180)
        ).toFixed(2);
        document.getElementById('stat-area').textContent = areaKm2 + ' km¬≤';

        document.getElementById('hud-city-name').textContent = this.currentCity.name;
    }

    buildBuilding(data, material) {
        if (data.coords.length < 3) return;

        const points = data.coords.map(c => this.projection.project(c.lat, c.lon));

        // Create shape from points
        const shape = new THREE.Shape();
        shape.moveTo(points[0].x, points[0].z);
        for (let i = 1; i < points.length; i++) {
            shape.lineTo(points[i].x, points[i].z);
        }
        shape.closePath();

        const height = data.height * 0.1; // Scale height

        const extrudeSettings = {
            steps: 1,
            depth: height,
            bevelEnabled: false
        };

        const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        geometry.rotateX(-Math.PI / 2);

        // Slightly randomize color
        const color = new THREE.Color(this.currentCity.buildingColor);
        color.offsetHSL(0, 0, (Math.random() - 0.5) * 0.1);
        const mat = material.clone();
        mat.color = color;

        const mesh = new THREE.Mesh(geometry, mat);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        mesh.userData = { type: 'building', data };

        // Add to content group (draggable)
        this.contentGroup.add(mesh);
        this.buildingMeshes.push(mesh);

        // Store building bounds for collision
        const minX = Math.min(...points.map(p => p.x));
        const maxX = Math.max(...points.map(p => p.x));
        const minZ = Math.min(...points.map(p => p.z));
        const maxZ = Math.max(...points.map(p => p.z));

        this.buildings.push({ minX, maxX, minZ, maxZ, height });

        // Add windows for tall buildings
        if (height > 5) {
            this.addWindowsToBuilding(mesh, points, height);
        }
    }

    addWindowsToBuilding(buildingMesh, points, height) {
        const windowMat = new THREE.MeshBasicMaterial({
            color: 0xffffcc,
            transparent: true,
            opacity: 0.6
        });

        // Simplified: just add some point lights on tall buildings
        if (height > 10 && Math.random() > 0.7) {
            const centerX = points.reduce((s, p) => s + p.x, 0) / points.length;
            const centerZ = points.reduce((s, p) => s + p.z, 0) / points.length;

            const light = new THREE.PointLight(0xffffcc, 0.3, 10);
            light.position.set(centerX, height * 0.7, centerZ);
            this.scene.add(light);
        }
    }

    buildRoad(data, material) {
        if (data.coords.length < 2) return;

        const points = data.coords.map(c => {
            const p = this.projection.project(c.lat, c.lon);
            return new THREE.Vector3(p.x, 0.02, p.z);
        });

        const curve = new THREE.CatmullRomCurve3(points);
        const tubeGeo = new THREE.TubeGeometry(curve, points.length * 2, data.width * 0.05, 4, false);

        // Flatten to road
        const positions = tubeGeo.attributes.position.array;
        for (let i = 1; i < positions.length; i += 3) {
            positions[i] = 0.02; // Keep flat
        }
        tubeGeo.attributes.position.needsUpdate = true;

        const mesh = new THREE.Mesh(tubeGeo, material);
        mesh.receiveShadow = true;
        mesh.userData = { type: 'road', data };
        this.scene.add(mesh);
    }

    buildPark(data, material) {
        if (data.coords.length < 3) return;

        const points = data.coords.map(c => this.projection.project(c.lat, c.lon));

        const shape = new THREE.Shape();
        shape.moveTo(points[0].x, points[0].z);
        for (let i = 1; i < points.length; i++) {
            shape.lineTo(points[i].x, points[i].z);
        }
        shape.closePath();

        const geometry = new THREE.ShapeGeometry(shape);
        geometry.rotateX(-Math.PI / 2);

        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.y = 0.03;
        mesh.receiveShadow = true;
        mesh.userData = { type: 'park', data, points };

        // Add to content group (draggable)
        this.contentGroup.add(mesh);

        // Store park for plant spawning
        this.cityData.parkMeshes = this.cityData.parkMeshes || [];
        this.cityData.parkMeshes.push({ points, name: data.name });
    }

    initializeLife() {
        // Spawn plants in parks
        if (this.cityData.parkMeshes) {
            for (const park of this.cityData.parkMeshes) {
                const numPlants = 5 + Math.floor(Math.random() * 10);
                for (let i = 0; i < numPlants; i++) {
                    const pos = this.randomPointInPolygon(park.points);
                    if (pos) this.spawnPlant(pos.x, pos.z);
                }
            }
        }

        // Spawn initial creatures in open areas
        for (let i = 0; i < 30; i++) {
            this.spawnCreature('herbivore');
        }
        for (let i = 0; i < 10; i++) {
            this.spawnCreature('predator');
        }
    }

    randomPointInPolygon(points) {
        if (points.length < 3) return null;

        const minX = Math.min(...points.map(p => p.x));
        const maxX = Math.max(...points.map(p => p.x));
        const minZ = Math.min(...points.map(p => p.z));
        const maxZ = Math.max(...points.map(p => p.z));

        for (let i = 0; i < 50; i++) {
            const x = minX + Math.random() * (maxX - minX);
            const z = minZ + Math.random() * (maxZ - minZ);

            if (this.pointInPolygon(x, z, points)) {
                return { x, z };
            }
        }

        return { x: (minX + maxX) / 2, z: (minZ + maxZ) / 2 };
    }

    pointInPolygon(x, z, points) {
        let inside = false;
        for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
            const xi = points[i].x, zi = points[i].z;
            const xj = points[j].x, zj = points[j].z;

            if ((zi > z) !== (zj > z) && x < (xj - xi) * (z - zi) / (zj - zi) + xi) {
                inside = !inside;
            }
        }
        return inside;
    }

    spawnPlant(x, z) {
        const plant = new Plant(x, z);

        const geo = new THREE.ConeGeometry(0.3, 0.8, 6);
        const mat = new THREE.MeshStandardMaterial({ color: 0x00ff66 });
        plant.mesh = new THREE.Mesh(geo, mat);
        plant.mesh.position.set(x, 0.4, z);
        plant.mesh.castShadow = true;

        this.scene.add(plant.mesh);
        this.plants.push(plant);
    }

    spawnCreature(type) {
        // Find valid spawn position
        let x, z;
        let attempts = 0;
        do {
            x = (Math.random() - 0.5) * 100;
            z = (Math.random() - 0.5) * 100;
            attempts++;
        } while (this.isInBuilding(x, z) && attempts < 50);

        const creature = type === 'herbivore'
            ? new Herbivore(x, z)
            : new Predator(x, z);

        const color = type === 'herbivore' ? 0x00aaff : 0xff4466;
        const geo = new THREE.SphereGeometry(creature.dna.size * 0.5, 8, 6);
        const mat = new THREE.MeshStandardMaterial({ color });
        creature.mesh = new THREE.Mesh(geo, mat);
        creature.mesh.position.set(x, creature.dna.size * 0.5, z);
        creature.mesh.castShadow = true;

        this.scene.add(creature.mesh);
        this.creatures.push(creature);
    }

    isInBuilding(x, z, margin = 0.5) {
        for (const b of this.buildings) {
            if (x >= b.minX - margin && x <= b.maxX + margin &&
                z >= b.minZ - margin && z <= b.maxZ + margin) {
                return true;
            }
        }
        return false;
    }

    update(dt) {
        if (this.paused) return;

        const scaledDt = dt * this.speed;
        this.time += scaledDt;

        // Update creatures
        for (const creature of this.creatures) {
            if (!creature.alive) continue;

            // Find nearest entities
            const nearestFood = this.findNearest(creature,
                creature.type === 'herbivore' ? this.plants :
                this.creatures.filter(c => c.type === 'herbivore' && c.alive)
            );
            const nearestThreat = creature.type === 'herbivore'
                ? this.findNearest(creature, this.creatures.filter(c => c.type === 'predator' && c.alive))
                : null;

            // Think and move
            const decision = creature.think(nearestFood, nearestThreat, null);

            creature.vx = decision.dx * creature.dna.speed;
            creature.vz = decision.dz * creature.dna.speed;

            const newX = creature.x + creature.vx * scaledDt;
            const newZ = creature.z + creature.vz * scaledDt;

            // Building collision
            if (!this.isInBuilding(newX, newZ)) {
                creature.x = newX;
                creature.z = newZ;
            } else {
                // Try to slide along buildings
                if (!this.isInBuilding(newX, creature.z)) {
                    creature.x = newX;
                } else if (!this.isInBuilding(creature.x, newZ)) {
                    creature.z = newZ;
                }
            }

            // Keep in bounds
            creature.x = Math.max(-100, Math.min(100, creature.x));
            creature.z = Math.max(-100, Math.min(100, creature.z));

            // Update mesh
            if (creature.mesh) {
                creature.mesh.position.set(creature.x, creature.dna.size * 0.5, creature.z);
            }

            // Energy
            creature.energy -= creature.dna.metabolism * scaledDt * 0.5;
            creature.age += scaledDt;

            // Eating
            if (nearestFood && this.distance(creature, nearestFood) < creature.dna.size + 0.5) {
                if (creature.type === 'herbivore' && nearestFood.constructor === Plant) {
                    creature.energy += 25;
                    nearestFood.alive = false;
                    if (nearestFood.mesh) {
                        this.scene.remove(nearestFood.mesh);
                    }
                } else if (creature.type === 'predator' && nearestFood.type === 'herbivore') {
                    creature.energy += 40;
                    nearestFood.alive = false;
                    if (nearestFood.mesh) {
                        this.scene.remove(nearestFood.mesh);
                    }
                }
            }

            // Reproduction
            if (creature.energy > 150 && decision.action > 0.5) {
                const child = creature.reproduce();
                creature.energy -= 50;

                const color = creature.type === 'herbivore' ? 0x00aaff : 0xff4466;
                const geo = new THREE.SphereGeometry(child.dna.size * 0.5, 8, 6);
                const mat = new THREE.MeshStandardMaterial({ color });
                child.mesh = new THREE.Mesh(geo, mat);
                child.mesh.position.set(child.x, child.dna.size * 0.5, child.z);
                child.mesh.castShadow = true;

                this.scene.add(child.mesh);
                this.creatures.push(child);
                this.births++;
                this.maxGeneration = Math.max(this.maxGeneration, child.generation);
            }

            // Death
            if (creature.energy <= 0 || creature.age > 60) {
                creature.alive = false;
                if (creature.mesh) {
                    this.scene.remove(creature.mesh);
                }
            }
        }

        // Remove dead
        this.creatures = this.creatures.filter(c => c.alive);
        this.plants = this.plants.filter(p => p.alive);

        // Spawn new plants in parks
        if (Math.random() < 0.1 * scaledDt && this.cityData.parkMeshes) {
            const park = this.cityData.parkMeshes[Math.floor(Math.random() * this.cityData.parkMeshes.length)];
            const pos = this.randomPointInPolygon(park.points);
            if (pos) this.spawnPlant(pos.x, pos.z);
        }

        // Respawn if population too low
        const herbivores = this.creatures.filter(c => c.type === 'herbivore');
        const predators = this.creatures.filter(c => c.type === 'predator');

        if (herbivores.length < 5) this.spawnCreature('herbivore');
        if (predators.length < 2) this.spawnCreature('predator');

        // Update stats periodically
        if (Math.floor(this.time) % 2 === 0) {
            this.updateStats();
            this.updatePopulationHistory();
        }
    }

    findNearest(creature, targets) {
        let nearest = null;
        let minDist = creature.dna.vision;

        for (const target of targets) {
            if (target === creature || (target.alive === false)) continue;
            const dist = this.distance(creature, target);
            if (dist < minDist) {
                minDist = dist;
                nearest = target;
            }
        }

        return nearest;
    }

    distance(a, b) {
        return Math.sqrt((a.x - b.x) ** 2 + (a.z - b.z) ** 2);
    }

    updateStats() {
        const herbivores = this.creatures.filter(c => c.type === 'herbivore');
        const predators = this.creatures.filter(c => c.type === 'predator');

        document.getElementById('stat-plants').textContent = this.plants.length;
        document.getElementById('stat-herbivores').textContent = herbivores.length;
        document.getElementById('stat-predators').textContent = predators.length;
        document.getElementById('stat-generation').textContent = this.maxGeneration;
        document.getElementById('stat-births').textContent = this.births;
    }

    updatePopulationHistory() {
        const herbivores = this.creatures.filter(c => c.type === 'herbivore').length;
        const predators = this.creatures.filter(c => c.type === 'predator').length;

        this.populationHistory.plants.push(this.plants.length);
        this.populationHistory.herbivores.push(herbivores);
        this.populationHistory.predators.push(predators);

        if (this.populationHistory.plants.length > this.historyMaxLength) {
            this.populationHistory.plants.shift();
            this.populationHistory.herbivores.shift();
            this.populationHistory.predators.shift();
        }

        this.drawPopulationGraph();
    }

    drawPopulationGraph() {
        const canvas = document.getElementById('population-graph');
        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;

        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(0, 0, w, h);

        const maxPop = Math.max(
            Math.max(...this.populationHistory.plants, 1),
            Math.max(...this.populationHistory.herbivores, 1),
            Math.max(...this.populationHistory.predators, 1)
        );

        const drawLine = (data, color) => {
            if (data.length < 2) return;
            ctx.strokeStyle = color;
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            data.forEach((v, i) => {
                const x = (i / this.historyMaxLength) * w;
                const y = h - (v / maxPop) * h * 0.9;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
        };

        drawLine(this.populationHistory.plants, '#00ff88');
        drawLine(this.populationHistory.herbivores, '#00aaff');
        drawLine(this.populationHistory.predators, '#ff4466');
    }

    updateMinimap() {
        const canvas = document.getElementById('minimap-canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 180;
        canvas.height = 180;

        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, 0, 180, 180);

        // Draw buildings
        ctx.fillStyle = '#445566';
        for (const b of this.buildings) {
            const x = 90 + b.minX * 0.8;
            const y = 90 + b.minZ * 0.8;
            const w = (b.maxX - b.minX) * 0.8;
            const h = (b.maxZ - b.minZ) * 0.8;
            ctx.fillRect(x, y, Math.max(1, w), Math.max(1, h));
        }

        // Draw creatures
        for (const c of this.creatures) {
            ctx.fillStyle = c.type === 'herbivore' ? '#00aaff' : '#ff4466';
            ctx.beginPath();
            ctx.arc(90 + c.x * 0.8, 90 + c.z * 0.8, 2, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    showUI() {
        ['hud', 'minimap', 'legend', 'data-stats', 'scale-indicator', 'graph-panel', 'controls', 'osm-credit', 'debug-panel']
            .forEach(id => document.getElementById(id).style.display = 'block');
    }

    showCitySelect() {
        // Reset simulation
        this.paused = true;
        if (this.renderer) {
            document.body.removeChild(this.renderer.domElement);
        }
        this.scene = null;
        this.renderer = null;

        ['hud', 'minimap', 'legend', 'data-stats', 'scale-indicator', 'graph-panel', 'controls', 'osm-credit', 'debug-panel']
            .forEach(id => document.getElementById(id).style.display = 'none');

        document.getElementById('city-select-container').classList.remove('hidden');
    }

    resetSimulation() {
        // Remove all creatures and plants
        for (const c of this.creatures) {
            if (c.mesh) this.scene.remove(c.mesh);
        }
        for (const p of this.plants) {
            if (p.mesh) this.scene.remove(p.mesh);
        }

        this.creatures = [];
        this.plants = [];
        this.births = 0;
        this.maxGeneration = 1;
        this.time = 0;
        this.populationHistory = { plants: [], herbivores: [], predators: [] };

        this.initializeLife();
    }

    togglePause() {
        this.paused = !this.paused;
        document.getElementById('btn-pause').textContent = this.paused ? '‚ñ∂' : '‚è∏';
    }

    changeSpeed(delta) {
        const speeds = [0.25, 0.5, 1, 2, 4, 8];
        const currentIndex = speeds.indexOf(this.speed);
        const newIndex = Math.max(0, Math.min(speeds.length - 1, currentIndex + delta));
        this.speed = speeds[newIndex];
        document.getElementById('speed-display').textContent = this.speed + 'x';
    }

    onKeyDown(e) {
        if (e.key >= '1' && e.key <= '5') {
            this.speed = [0.25, 0.5, 1, 2, 4][parseInt(e.key) - 1];
            document.getElementById('speed-display').textContent = this.speed + 'x';
        } else if (e.key === ' ') {
            this.togglePause();
        }
    }

    onClick(e) {
        this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

        this.raycaster.setFromCamera(this.mouse, this.camera);
        const intersects = this.raycaster.intersectObjects(
            this.creatures.map(c => c.mesh).filter(m => m)
        );

        if (intersects.length > 0) {
            const creature = this.creatures.find(c => c.mesh === intersects[0].object);
            if (creature) {
                this.showCreatureInfo(creature);
            }
        }
    }

    showCreatureInfo(creature) {
        const tooltip = document.getElementById('tooltip');
        tooltip.innerHTML = `
            <strong>${creature.type === 'herbivore' ? 'üê∞ Herbivore' : 'ü¶ä Predator'}</strong><br>
            Energy: ${Math.round(creature.energy)}<br>
            Age: ${creature.age.toFixed(1)}s<br>
            Gen: ${creature.generation}<br>
            Speed: ${creature.dna.speed.toFixed(2)}
        `;
        tooltip.style.display = 'block';
        tooltip.style.left = '50%';
        tooltip.style.top = '60px';
        tooltip.style.transform = 'translateX(-50%)';

        setTimeout(() => {
            tooltip.style.display = 'none';
        }, 3000);
    }

    onResize() {
        if (!this.camera || !this.renderer) return;
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }

    animate() {
        const clock = new THREE.Clock();

        const loop = () => {
            requestAnimationFrame(loop);

            const dt = Math.min(clock.getDelta(), 0.1);
            this.update(dt);

            if (Math.floor(this.time * 2) % 2 === 0) {
                this.updateMinimap();
            }

            if (this.renderer && this.scene && this.camera) {
                this.renderer.render(this.scene, this.camera);
            }
        };

        loop();
    }
}

// Initialize
const simulation = new CityEcosystem();
    </script>
</body>
</html>
