<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Electromagnetic Field Lab</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0f1e 0%, #1a1a2e 50%, #16213e 100%);
            color: #e0e0e0;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            background: linear-gradient(135deg, rgba(30, 30, 50, 0.95) 0%, rgba(20, 20, 35, 0.95) 100%);
            padding: 15px 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            border-bottom: 2px solid rgba(100, 150, 255, 0.3);
        }

        h1 {
            font-size: 28px;
            font-weight: 700;
            background: linear-gradient(135deg, #64b5f6 0%, #90caf9 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(100, 181, 246, 0.3);
            margin-bottom: 10px;
        }

        .toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            margin-top: 10px;
        }

        .btn-group {
            display: flex;
            gap: 5px;
            padding: 5px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        button {
            padding: 8px 16px;
            background: linear-gradient(135deg, rgba(100, 150, 255, 0.2) 0%, rgba(80, 120, 200, 0.2) 100%);
            border: 1px solid rgba(100, 150, 255, 0.4);
            border-radius: 6px;
            color: #e0e0e0;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        button:hover {
            background: linear-gradient(135deg, rgba(100, 150, 255, 0.4) 0%, rgba(80, 120, 200, 0.4) 100%);
            border-color: rgba(100, 150, 255, 0.6);
            box-shadow: 0 0 15px rgba(100, 150, 255, 0.3);
            transform: translateY(-1px);
        }

        button.active {
            background: linear-gradient(135deg, rgba(100, 200, 255, 0.4) 0%, rgba(80, 150, 220, 0.4) 100%);
            border-color: rgba(100, 200, 255, 0.8);
            box-shadow: 0 0 20px rgba(100, 200, 255, 0.4);
        }

        button.positive {
            background: linear-gradient(135deg, rgba(255, 80, 80, 0.3) 0%, rgba(220, 50, 50, 0.3) 100%);
            border-color: rgba(255, 80, 80, 0.5);
        }

        button.positive:hover {
            background: linear-gradient(135deg, rgba(255, 80, 80, 0.5) 0%, rgba(220, 50, 50, 0.5) 100%);
            box-shadow: 0 0 15px rgba(255, 80, 80, 0.4);
        }

        button.negative {
            background: linear-gradient(135deg, rgba(80, 120, 255, 0.3) 0%, rgba(50, 90, 220, 0.3) 100%);
            border-color: rgba(80, 120, 255, 0.5);
        }

        button.negative:hover {
            background: linear-gradient(135deg, rgba(80, 120, 255, 0.5) 0%, rgba(50, 90, 220, 0.5) 100%);
            box-shadow: 0 0 15px rgba(80, 120, 255, 0.4);
        }

        button.danger {
            background: linear-gradient(135deg, rgba(255, 100, 50, 0.3) 0%, rgba(220, 70, 30, 0.3) 100%);
            border-color: rgba(255, 100, 50, 0.5);
        }

        button.danger:hover {
            background: linear-gradient(135deg, rgba(255, 100, 50, 0.5) 0%, rgba(220, 70, 30, 0.5) 100%);
            box-shadow: 0 0 15px rgba(255, 100, 50, 0.4);
        }

        button.success {
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.3) 0%, rgba(56, 142, 60, 0.3) 100%);
            border-color: rgba(76, 175, 80, 0.5);
        }

        button.success:hover {
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.5) 0%, rgba(56, 142, 60, 0.5) 100%);
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.4);
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, rgba(30, 30, 50, 0.98) 0%, rgba(20, 20, 35, 0.98) 100%);
            padding: 30px;
            border-radius: 12px;
            border: 2px solid rgba(100, 150, 255, 0.4);
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
        }

        .modal-content h2 {
            color: #90caf9;
            margin-bottom: 20px;
            font-size: 24px;
        }

        .modal-content p, .modal-content ul {
            margin-bottom: 15px;
            line-height: 1.8;
        }

        .modal-content ul {
            padding-left: 25px;
        }

        .modal-content li {
            margin-bottom: 8px;
        }

        .score-display {
            position: absolute;
            top: 60px;
            left: 15px;
            background: rgba(20, 20, 35, 0.9);
            padding: 12px 16px;
            border-radius: 8px;
            border: 1px solid rgba(100, 150, 255, 0.3);
            font-size: 14px;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }

        .score-value {
            color: #ffa726;
            font-size: 18px;
            margin-left: 5px;
        }

        .level-display {
            position: absolute;
            top: 110px;
            left: 15px;
            background: rgba(20, 20, 35, 0.9);
            padding: 12px 16px;
            border-radius: 8px;
            border: 1px solid rgba(100, 150, 255, 0.3);
            font-size: 14px;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }

        .challenge-panel {
            position: absolute;
            bottom: 15px;
            left: 15px;
            right: 15px;
            background: rgba(20, 20, 35, 0.95);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(100, 150, 255, 0.3);
            font-size: 13px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            display: none;
        }

        .challenge-panel.active {
            display: block;
        }

        .challenge-description {
            margin-bottom: 10px;
            color: #90caf9;
            font-weight: 600;
        }

        .difficulty-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .difficulty-btn {
            flex: 1;
            padding: 10px;
            font-size: 14px;
            font-weight: 600;
        }

        .difficulty-btn.easy {
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.3) 0%, rgba(56, 142, 60, 0.3) 100%);
            border-color: rgba(76, 175, 80, 0.5);
        }

        .difficulty-btn.medium {
            background: linear-gradient(135deg, rgba(255, 152, 0, 0.3) 0%, rgba(245, 124, 0, 0.3) 100%);
            border-color: rgba(255, 152, 0, 0.5);
        }

        .difficulty-btn.hard {
            background: linear-gradient(135deg, rgba(244, 67, 54, 0.3) 0%, rgba(211, 47, 47, 0.3) 100%);
            border-color: rgba(244, 67, 54, 0.5);
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 13px;
        }

        .checkbox-label:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(100, 150, 255, 0.4);
        }

        input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: #64b5f6;
        }

        main {
            flex: 1;
            display: flex;
            gap: 10px;
            padding: 10px;
            overflow: hidden;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            background: linear-gradient(135deg, rgba(10, 10, 20, 0.8) 0%, rgba(15, 15, 25, 0.8) 100%);
            border-radius: 12px;
            border: 2px solid rgba(100, 150, 255, 0.2);
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), inset 0 0 60px rgba(0, 0, 0, 0.3);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .sidebar {
            width: 280px;
            background: linear-gradient(135deg, rgba(30, 30, 50, 0.9) 0%, rgba(20, 20, 35, 0.9) 100%);
            border-radius: 12px;
            border: 1px solid rgba(100, 150, 255, 0.2);
            padding: 15px;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .sidebar h2 {
            font-size: 18px;
            margin-bottom: 12px;
            color: #90caf9;
            border-bottom: 2px solid rgba(100, 150, 255, 0.3);
            padding-bottom: 8px;
        }

        .info-section {
            margin-bottom: 20px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            font-size: 13px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-label {
            color: #b0b0b0;
            font-weight: 500;
        }

        .info-value {
            color: #64b5f6;
            font-weight: 600;
            font-family: 'Courier New', monospace;
        }

        .charge-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .charge-item {
            padding: 10px;
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            border-left: 3px solid;
            font-size: 12px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .charge-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(5px);
        }

        .charge-item.positive {
            border-left-color: #ff5252;
        }

        .charge-item.negative {
            border-left-color: #5c6bc0;
        }

        .charge-item.selected {
            background: rgba(100, 200, 255, 0.15);
            box-shadow: 0 0 10px rgba(100, 200, 255, 0.3);
        }

        .preset-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
        }

        .preset-btn {
            width: 100%;
            padding: 10px;
            text-align: left;
            background: linear-gradient(135deg, rgba(100, 150, 255, 0.15) 0%, rgba(80, 120, 200, 0.15) 100%);
        }

        .force-vector {
            padding: 8px;
            margin: 5px 0;
            background: rgba(255, 200, 100, 0.1);
            border-radius: 6px;
            border-left: 3px solid #ffa726;
            font-size: 11px;
            font-family: 'Courier New', monospace;
        }

        .legend {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(20, 20, 35, 0.9);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid rgba(100, 150, 255, 0.3);
            font-size: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 6px 0;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            box-shadow: 0 0 10px currentColor;
        }

        .help-text {
            font-size: 11px;
            color: #888;
            margin-top: 10px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 6px;
            line-height: 1.5;
        }

        .mode-indicator {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(20, 20, 35, 0.9);
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid rgba(100, 150, 255, 0.3);
            font-size: 13px;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }

        @media (max-width: 1024px) {
            main {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                max-height: 200px;
            }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .pulsing {
            animation: pulse 2s ease-in-out infinite;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(100, 150, 255, 0.3);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(100, 150, 255, 0.5);
        }
    </style>
</head>
<body>
    <header>
        <h1>‚ö° Electromagnetic Field Lab</h1>
        <div class="toolbar">
            <div class="btn-group">
                <button class="positive" id="addPositive">+ Positive Charge</button>
                <button class="negative" id="addNegative">‚àí Negative Charge</button>
            </div>
            <div class="btn-group">
                <label class="checkbox-label">
                    <input type="checkbox" id="showFieldLines" checked>
                    Field Lines
                </label>
                <label class="checkbox-label">
                    <input type="checkbox" id="showEquipotential">
                    Equipotential
                </label>
                <label class="checkbox-label">
                    <input type="checkbox" id="showForces" checked>
                    Force Vectors
                </label>
            </div>
            <div class="btn-group">
                <button id="saveConfig">üíæ Save</button>
                <button id="loadConfig">üìÇ Load</button>
                <button id="resetBtn">üîÑ Reset</button>
                <button class="danger" id="clearAll">üóëÔ∏è Clear All</button>
            </div>
            <div class="btn-group">
                <button id="challengeMode">üéØ Challenge Mode</button>
                <button id="howToPlay">‚ùì How to Play</button>
            </div>
        </div>
    </header>

    <!-- How to Play Modal -->
    <div class="modal" id="howToPlayModal">
        <div class="modal-content">
            <h2>‚ùì How to Play - Electromagnetic Field Lab</h2>

            <h3 style="color: #90caf9; margin-top: 20px;">Overview</h3>
            <p>Explore electromagnetic fields by placing positive and negative charges on the canvas. Visualize electric field lines, equipotential surfaces, and force interactions between charges.</p>

            <h3 style="color: #90caf9; margin-top: 20px;">Controls</h3>
            <ul>
                <li><strong>Click:</strong> Place the selected charge type (+ or ‚àí) on the canvas</li>
                <li><strong>Drag:</strong> Move existing charges around</li>
                <li><strong>Delete/Backspace:</strong> Remove the selected charge</li>
                <li><strong>Space:</strong> Toggle field lines on/off</li>
                <li><strong>Shift (Hold):</strong> Switch charge polarity temporarily</li>
                <li><strong>Arrow Keys:</strong> Nudge selected charge in that direction</li>
                <li><strong>Touch:</strong> Tap to place charges, drag to move them (mobile)</li>
            </ul>

            <h3 style="color: #90caf9; margin-top: 20px;">Modes</h3>
            <ul>
                <li><strong>Free Mode:</strong> Experiment freely with charges and fields</li>
                <li><strong>Challenge Mode:</strong> Complete levels with increasing difficulty to earn points</li>
            </ul>

            <h3 style="color: #90caf9; margin-top: 20px;">Difficulty Levels</h3>
            <ul>
                <li><strong>Easy:</strong> Start with 2 charges in simple configurations</li>
                <li><strong>Medium:</strong> 4 charges with moderate complexity</li>
                <li><strong>Hard:</strong> 6+ charges in complex patterns requiring precision</li>
            </ul>

            <h3 style="color: #90caf9; margin-top: 20px;">Scoring</h3>
            <p>In Challenge Mode, earn points by accurately recreating target field patterns. Your personal best is automatically saved!</p>

            <button onclick="document.getElementById('howToPlayModal').classList.remove('active')" style="margin-top: 20px; width: 100%;">Close</button>
        </div>
    </div>

    <!-- Challenge Mode Modal -->
    <div class="modal" id="challengeModal">
        <div class="modal-content">
            <h2>üéØ Challenge Mode</h2>
            <p>Select a difficulty level to begin:</p>

            <div class="difficulty-selector">
                <button class="difficulty-btn easy" onclick="startChallenge('easy')">Easy<br>2 charges</button>
                <button class="difficulty-btn medium" onclick="startChallenge('medium')">Medium<br>4 charges</button>
                <button class="difficulty-btn hard" onclick="startChallenge('hard')">Hard<br>6+ charges</button>
            </div>

            <div style="margin-top: 20px; padding: 15px; background: rgba(255, 255, 255, 0.05); border-radius: 8px;">
                <h3 style="color: #90caf9; margin-bottom: 10px;">Your Stats</h3>
                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                    <span>Personal Best:</span>
                    <span id="personalBest" style="color: #ffa726; font-weight: 600;">0</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                    <span>Levels Completed:</span>
                    <span id="levelsCompleted" style="color: #66bb6a; font-weight: 600;">0</span>
                </div>
            </div>

            <button onclick="document.getElementById('challengeModal').classList.remove('active')" style="margin-top: 20px; width: 100%;">Close</button>
        </div>
    </div>

    <main>
        <div class="canvas-container">
            <canvas id="fieldCanvas"></canvas>
            <div class="mode-indicator" id="modeIndicator">Click to place charge</div>

            <div class="score-display" id="scoreDisplay" style="display: none;">
                Score:<span class="score-value" id="scoreValue">0</span>
            </div>

            <div class="level-display" id="levelDisplay" style="display: none;">
                Level:<span class="score-value" id="levelValue">1</span>
            </div>

            <div class="challenge-panel" id="challengePanel">
                <div class="challenge-description" id="challengeDescription"></div>
                <div style="display: flex; gap: 10px; margin-top: 10px;">
                    <button class="success" onclick="checkChallenge()" style="flex: 1;">‚úì Check Solution</button>
                    <button onclick="skipChallenge()" style="flex: 1;">Skip Level</button>
                    <button class="danger" onclick="exitChallenge()">Exit Challenge</button>
                </div>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff5252;"></div>
                    <span>Positive (+)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #5c6bc0;"></div>
                    <span>Negative (‚àí)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ffa726;"></div>
                    <span>Field Lines</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #66bb6a;"></div>
                    <span>Equipotential</span>
                </div>
            </div>
        </div>

        <aside class="sidebar">
            <div class="info-section">
                <h2>System Info</h2>
                <div class="info-row">
                    <span class="info-label">Total Charges:</span>
                    <span class="info-value" id="totalCharges">0</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Net Charge:</span>
                    <span class="info-value" id="netCharge">0.0 C</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Total Energy:</span>
                    <span class="info-value" id="totalEnergy">0.0 J</span>
                </div>
            </div>

            <div class="info-section">
                <h2>Presets</h2>
                <div class="preset-grid">
                    <button class="preset-btn" data-preset="dipole">Electric Dipole</button>
                    <button class="preset-btn" data-preset="quadrupole">Quadrupole</button>
                    <button class="preset-btn" data-preset="parallel">Parallel Plates</button>
                    <button class="preset-btn" data-preset="triangle">Triangle Formation</button>
                </div>
            </div>

            <div class="info-section">
                <h2>Charges <span id="chargeCount">(0)</span></h2>
                <div class="charge-list" id="chargeList"></div>
            </div>

            <div class="info-section" id="forceSection" style="display: none;">
                <h2>Force Calculations</h2>
                <div id="forceVectors"></div>
            </div>

            <div class="help-text">
                <strong>Controls:</strong><br>
                ‚Ä¢ Click to place selected charge<br>
                ‚Ä¢ Drag charges to move them<br>
                ‚Ä¢ Click charge in list to select<br>
                ‚Ä¢ Delete key to remove selected<br>
                ‚Ä¢ Space to toggle field lines<br>
                ‚Ä¢ Hold Shift to switch polarity<br>
                ‚Ä¢ Arrow keys to nudge selection<br>
                ‚Ä¢ Touch: tap to place, drag to move
            </div>
        </aside>
    </main>

    <script>
        // Constants
        const K = 8.99e9; // Coulomb's constant (N‚ãÖm¬≤/C¬≤)
        const CHARGE_MAGNITUDE = 1e-6; // 1 microcoulomb
        const CHARGE_RADIUS = 15;
        const FIELD_LINE_DENSITY = 12;
        const FIELD_LINE_LENGTH = 300;
        const FIELD_LINE_STEP = 3;
        const EQUIPOTENTIAL_LEVELS = 15;

        // Canvas setup
        const canvas = document.getElementById('fieldCanvas');
        const ctx = canvas.getContext('2d');
        let width, height;

        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            width = canvas.width;
            height = canvas.height;
        }

        // Charge class
        class Charge {
            constructor(x, y, charge, id = Date.now()) {
                this.x = x;
                this.y = y;
                this.charge = charge; // in Coulombs
                this.id = id;
                this.isDragging = false;
                this.radius = CHARGE_RADIUS;
            }

            draw(ctx) {
                const isPositive = this.charge > 0;
                const color = isPositive ? '#ff5252' : '#5c6bc0';
                const shadowColor = isPositive ? 'rgba(255, 82, 82, 0.8)' : 'rgba(92, 107, 192, 0.8)';

                // Outer glow
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius * 2);
                gradient.addColorStop(0, shadowColor);
                gradient.addColorStop(0.5, 'rgba(0, 0, 0, 0.3)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 2, 0, Math.PI * 2);
                ctx.fill();

                // Main body
                const bodyGradient = ctx.createRadialGradient(
                    this.x - this.radius / 3,
                    this.y - this.radius / 3,
                    0,
                    this.x,
                    this.y,
                    this.radius
                );
                bodyGradient.addColorStop(0, isPositive ? '#ff7979' : '#7986cb');
                bodyGradient.addColorStop(1, color);
                ctx.fillStyle = bodyGradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();

                // Border
                ctx.strokeStyle = isPositive ? '#ff3333' : '#3f51b5';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Symbol
                ctx.fillStyle = 'white';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                ctx.shadowBlur = 4;
                ctx.fillText(isPositive ? '+' : '‚àí', this.x, this.y);
                ctx.shadowBlur = 0;
            }

            contains(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                return Math.sqrt(dx * dx + dy * dy) <= this.radius;
            }

            getElectricField(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                const r2 = dx * dx + dy * dy;
                if (r2 < 1) return { Ex: 0, Ey: 0 };

                const r = Math.sqrt(r2);
                const E = K * this.charge / r2;
                return {
                    Ex: E * dx / r,
                    Ey: E * dy / r
                };
            }

            getPotential(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                const r = Math.sqrt(dx * dx + dy * dy);
                if (r < 1) return 0;
                return K * this.charge / r;
            }
        }

        // State
        let charges = [];
        let selectedCharge = null;
        let draggedCharge = null;
        let placementMode = 'positive';
        let showFieldLines = true;
        let showEquipotential = false;
        let showForces = true;

        // Challenge mode state
        let challengeMode = false;
        let currentLevel = 1;
        let currentScore = 0;
        let currentDifficulty = '';
        let targetPattern = null;
        let keysPressed = {};

        // Initialize
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // UI Controls
        document.getElementById('addPositive').addEventListener('click', () => {
            placementMode = 'positive';
            updateModeIndicator();
            document.getElementById('addPositive').classList.add('active');
            document.getElementById('addNegative').classList.remove('active');
        });

        document.getElementById('addNegative').addEventListener('click', () => {
            placementMode = 'negative';
            updateModeIndicator();
            document.getElementById('addNegative').classList.add('active');
            document.getElementById('addPositive').classList.remove('active');
        });

        document.getElementById('showFieldLines').addEventListener('change', (e) => {
            showFieldLines = e.target.checked;
        });

        document.getElementById('showEquipotential').addEventListener('change', (e) => {
            showEquipotential = e.target.checked;
        });

        document.getElementById('showForces').addEventListener('change', (e) => {
            showForces = e.target.checked;
        });

        document.getElementById('clearAll').addEventListener('click', () => {
            if (charges.length > 0 && confirm('Clear all charges?')) {
                charges = [];
                selectedCharge = null;
                updateUI();
            }
        });

        document.getElementById('saveConfig').addEventListener('click', saveConfiguration);
        document.getElementById('loadConfig').addEventListener('click', loadConfiguration);
        document.getElementById('resetBtn').addEventListener('click', resetSimulation);
        document.getElementById('howToPlay').addEventListener('click', showHowToPlay);
        document.getElementById('challengeMode').addEventListener('click', showChallengeModal);

        // Preset configurations
        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const preset = btn.dataset.preset;
                loadPreset(preset);
            });
        });

        function loadPreset(preset) {
            charges = [];
            const cx = width / 2;
            const cy = height / 2;

            switch (preset) {
                case 'dipole':
                    charges.push(new Charge(cx - 80, cy, CHARGE_MAGNITUDE));
                    charges.push(new Charge(cx + 80, cy, -CHARGE_MAGNITUDE));
                    break;
                case 'quadrupole':
                    charges.push(new Charge(cx - 60, cy - 60, CHARGE_MAGNITUDE));
                    charges.push(new Charge(cx + 60, cy - 60, -CHARGE_MAGNITUDE));
                    charges.push(new Charge(cx + 60, cy + 60, CHARGE_MAGNITUDE));
                    charges.push(new Charge(cx - 60, cy + 60, -CHARGE_MAGNITUDE));
                    break;
                case 'parallel':
                    for (let i = 0; i < 5; i++) {
                        charges.push(new Charge(cx - 100, cy - 80 + i * 40, CHARGE_MAGNITUDE));
                        charges.push(new Charge(cx + 100, cy - 80 + i * 40, -CHARGE_MAGNITUDE));
                    }
                    break;
                case 'triangle':
                    const r = 100;
                    charges.push(new Charge(cx, cy - r, CHARGE_MAGNITUDE));
                    charges.push(new Charge(cx - r * Math.cos(Math.PI / 6), cy + r * Math.sin(Math.PI / 6), CHARGE_MAGNITUDE));
                    charges.push(new Charge(cx + r * Math.cos(Math.PI / 6), cy + r * Math.sin(Math.PI / 6), -CHARGE_MAGNITUDE));
                    break;
            }
            selectedCharge = null;
            updateUI();
        }

        // Canvas interactions
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Check if clicking on existing charge
            for (let i = charges.length - 1; i >= 0; i--) {
                if (charges[i].contains(x, y)) {
                    draggedCharge = charges[i];
                    selectedCharge = charges[i];
                    draggedCharge.isDragging = true;
                    updateUI();
                    return;
                }
            }

            // Place new charge
            const charge = placementMode === 'positive' ? CHARGE_MAGNITUDE : -CHARGE_MAGNITUDE;
            const newCharge = new Charge(x, y, charge);
            charges.push(newCharge);
            selectedCharge = newCharge;
            updateUI();
        });

        canvas.addEventListener('mousemove', (e) => {
            if (draggedCharge) {
                const rect = canvas.getBoundingClientRect();
                draggedCharge.x = e.clientX - rect.left;
                draggedCharge.y = e.clientY - rect.top;
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (draggedCharge) {
                draggedCharge.isDragging = false;
                draggedCharge = null;
            }
        });

        canvas.addEventListener('mouseleave', () => {
            if (draggedCharge) {
                draggedCharge.isDragging = false;
                draggedCharge = null;
            }
        });

        // Touch support for mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;

            // Check if touching existing charge
            for (let i = charges.length - 1; i >= 0; i--) {
                if (charges[i].contains(x, y)) {
                    draggedCharge = charges[i];
                    selectedCharge = charges[i];
                    draggedCharge.isDragging = true;
                    updateUI();
                    return;
                }
            }

            // Place new charge
            const charge = placementMode === 'positive' ? CHARGE_MAGNITUDE : -CHARGE_MAGNITUDE;
            const newCharge = new Charge(x, y, charge);
            charges.push(newCharge);
            selectedCharge = newCharge;
            updateUI();
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (draggedCharge) {
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                draggedCharge.x = touch.clientX - rect.left;
                draggedCharge.y = touch.clientY - rect.top;
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (draggedCharge) {
                draggedCharge.isDragging = false;
                draggedCharge = null;
            }
        });

        canvas.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            if (draggedCharge) {
                draggedCharge.isDragging = false;
                draggedCharge = null;
            }
        });

        // Keyboard controls - keydown
        document.addEventListener('keydown', (e) => {
            keysPressed[e.code] = true;

            if (e.code === 'Space') {
                e.preventDefault();
                const checkbox = document.getElementById('showFieldLines');
                checkbox.checked = !checkbox.checked;
                showFieldLines = checkbox.checked;
            } else if (e.code === 'Delete' || e.code === 'Backspace') {
                if (selectedCharge) {
                    charges = charges.filter(c => c.id !== selectedCharge.id);
                    selectedCharge = null;
                    updateUI();
                }
            } else if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
                // Temporarily switch charge polarity
                placementMode = placementMode === 'positive' ? 'negative' : 'positive';
                updateModeIndicator();
            } else if (selectedCharge) {
                // Arrow key nudging
                const nudgeAmount = 5;
                if (e.code === 'ArrowLeft') {
                    e.preventDefault();
                    selectedCharge.x = Math.max(selectedCharge.radius, selectedCharge.x - nudgeAmount);
                } else if (e.code === 'ArrowRight') {
                    e.preventDefault();
                    selectedCharge.x = Math.min(width - selectedCharge.radius, selectedCharge.x + nudgeAmount);
                } else if (e.code === 'ArrowUp') {
                    e.preventDefault();
                    selectedCharge.y = Math.max(selectedCharge.radius, selectedCharge.y - nudgeAmount);
                } else if (e.code === 'ArrowDown') {
                    e.preventDefault();
                    selectedCharge.y = Math.min(height - selectedCharge.radius, selectedCharge.y + nudgeAmount);
                }
            }
        });

        // Keyboard controls - keyup
        document.addEventListener('keyup', (e) => {
            keysPressed[e.code] = false;

            if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
                // Switch back to original polarity
                placementMode = placementMode === 'positive' ? 'negative' : 'positive';
                updateModeIndicator();
            }
        });

        // Field calculations
        function getTotalField(x, y) {
            let Ex = 0, Ey = 0;
            for (const charge of charges) {
                const field = charge.getElectricField(x, y);
                Ex += field.Ex;
                Ey += field.Ey;
            }
            return { Ex, Ey };
        }

        function getTotalPotential(x, y) {
            let V = 0;
            for (const charge of charges) {
                V += charge.getPotential(x, y);
            }
            return V;
        }

        function drawFieldLines() {
            if (!showFieldLines || charges.length === 0) return;

            ctx.globalAlpha = 0.6;

            for (const charge of charges) {
                const numLines = FIELD_LINE_DENSITY;
                const isPositive = charge.charge > 0;

                for (let i = 0; i < numLines; i++) {
                    const angle = (i / numLines) * Math.PI * 2;
                    let x = charge.x + Math.cos(angle) * (charge.radius + 2);
                    let y = charge.y + Math.sin(angle) * (charge.radius + 2);

                    ctx.beginPath();
                    ctx.moveTo(x, y);

                    for (let step = 0; step < FIELD_LINE_LENGTH; step++) {
                        const field = getTotalField(x, y);
                        const magnitude = Math.sqrt(field.Ex * field.Ex + field.Ey * field.Ey);

                        if (magnitude < 1e3) break;

                        const direction = isPositive ? 1 : -1;
                        const dx = direction * field.Ex / magnitude * FIELD_LINE_STEP;
                        const dy = direction * field.Ey / magnitude * FIELD_LINE_STEP;

                        x += dx;
                        y += dy;

                        if (x < 0 || x > width || y < 0 || y > height) break;

                        // Check if hitting another charge
                        let hitCharge = false;
                        for (const otherCharge of charges) {
                            if (otherCharge.contains(x, y)) {
                                hitCharge = true;
                                break;
                            }
                        }
                        if (hitCharge) break;

                        ctx.lineTo(x, y);
                    }

                    const hue = 30 + Math.sin(i * 0.5) * 30;
                    ctx.strokeStyle = `hsla(${hue}, 80%, 60%, 0.7)`;
                    ctx.lineWidth = 1.5;
                    ctx.stroke();

                    // Draw arrow head
                    if (ctx.getLineDash().length === 0) {
                        const field = getTotalField(x, y);
                        const magnitude = Math.sqrt(field.Ex * field.Ex + field.Ey * field.Ey);
                        if (magnitude > 1e3) {
                            const direction = isPositive ? 1 : -1;
                            const angle = Math.atan2(direction * field.Ey, direction * field.Ex);
                            drawArrowHead(x, y, angle, 6);
                        }
                    }
                }
            }

            ctx.globalAlpha = 1;
        }

        function drawArrowHead(x, y, angle, size) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-size, -size / 2);
            ctx.lineTo(-size, size / 2);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        function drawEquipotentialLines() {
            if (!showEquipotential || charges.length === 0) return;

            ctx.globalAlpha = 0.4;

            // Find potential range
            let minV = Infinity, maxV = -Infinity;
            const samplePoints = 50;
            for (let i = 0; i < samplePoints; i++) {
                for (let j = 0; j < samplePoints; j++) {
                    const x = (i / samplePoints) * width;
                    const y = (j / samplePoints) * height;
                    const V = getTotalPotential(x, y);
                    if (isFinite(V)) {
                        minV = Math.min(minV, V);
                        maxV = Math.max(maxV, V);
                    }
                }
            }

            // Draw contour lines
            const step = 5;
            for (let potentialLevel = 0; potentialLevel < EQUIPOTENTIAL_LEVELS; potentialLevel++) {
                const targetV = minV + (maxV - minV) * (potentialLevel / EQUIPOTENTIAL_LEVELS);

                ctx.beginPath();
                let started = false;

                for (let x = 0; x < width; x += step) {
                    for (let y = 0; y < height; y += step) {
                        const V = getTotalPotential(x, y);

                        if (Math.abs(V - targetV) < (maxV - minV) / (EQUIPOTENTIAL_LEVELS * 2)) {
                            if (!started) {
                                ctx.moveTo(x, y);
                                started = true;
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                    }
                }

                const hue = 120 + (potentialLevel / EQUIPOTENTIAL_LEVELS) * 60;
                ctx.strokeStyle = `hsla(${hue}, 70%, 50%, 0.6)`;
                ctx.lineWidth = 1.5;
                ctx.stroke();
            }

            ctx.globalAlpha = 1;
        }

        function drawForceVectors() {
            if (!showForces || charges.length < 2) return;

            ctx.globalAlpha = 0.7;

            for (let i = 0; i < charges.length; i++) {
                const charge1 = charges[i];
                let totalFx = 0, totalFy = 0;

                for (let j = 0; j < charges.length; j++) {
                    if (i === j) continue;

                    const charge2 = charges[j];
                    const dx = charge1.x - charge2.x;
                    const dy = charge1.y - charge2.y;
                    const r2 = dx * dx + dy * dy;
                    const r = Math.sqrt(r2);

                    if (r < 1) continue;

                    // Coulomb's law: F = k * q1 * q2 / r¬≤
                    const F = K * charge1.charge * charge2.charge / r2;
                    const Fx = F * dx / r;
                    const Fy = F * dy / r;

                    totalFx += Fx;
                    totalFy += Fy;
                }

                const magnitude = Math.sqrt(totalFx * totalFx + totalFy * totalFy);
                if (magnitude > 1e-10) {
                    const scale = Math.log10(magnitude + 1) * 10;
                    const endX = charge1.x + (totalFx / magnitude) * scale;
                    const endY = charge1.y + (totalFy / magnitude) * scale;

                    // Draw vector
                    ctx.beginPath();
                    ctx.moveTo(charge1.x, charge1.y);
                    ctx.lineTo(endX, endY);
                    ctx.strokeStyle = '#ffa726';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Arrow head
                    const angle = Math.atan2(totalFy, totalFx);
                    ctx.fillStyle = '#ffa726';
                    drawArrowHead(endX, endY, angle, 8);
                }
            }

            ctx.globalAlpha = 1;
        }

        function updateModeIndicator() {
            const indicator = document.getElementById('modeIndicator');
            if (placementMode === 'positive') {
                indicator.textContent = 'Click to place positive charge (+)';
                indicator.style.borderColor = 'rgba(255, 82, 82, 0.5)';
            } else {
                indicator.textContent = 'Click to place negative charge (‚àí)';
                indicator.style.borderColor = 'rgba(92, 107, 192, 0.5)';
            }
        }

        function updateUI() {
            // Update info panel
            document.getElementById('totalCharges').textContent = charges.length;

            const netCharge = charges.reduce((sum, c) => sum + c.charge, 0);
            document.getElementById('netCharge').textContent = (netCharge * 1e6).toFixed(2) + ' ŒºC';

            // Calculate total potential energy
            let totalEnergy = 0;
            for (let i = 0; i < charges.length; i++) {
                for (let j = i + 1; j < charges.length; j++) {
                    const dx = charges[i].x - charges[j].x;
                    const dy = charges[i].y - charges[j].y;
                    const r = Math.sqrt(dx * dx + dy * dy);
                    if (r > 1) {
                        totalEnergy += K * charges[i].charge * charges[j].charge / r;
                    }
                }
            }
            document.getElementById('totalEnergy').textContent = totalEnergy.toExponential(2) + ' J';

            // Update charge list
            const chargeList = document.getElementById('chargeList');
            const chargeCount = document.getElementById('chargeCount');
            chargeCount.textContent = `(${charges.length})`;

            chargeList.innerHTML = '';
            charges.forEach((charge, index) => {
                const item = document.createElement('div');
                item.className = 'charge-item ' + (charge.charge > 0 ? 'positive' : 'negative');
                if (selectedCharge && selectedCharge.id === charge.id) {
                    item.classList.add('selected');
                }

                const sign = charge.charge > 0 ? '+' : '‚àí';
                const mag = (Math.abs(charge.charge) * 1e6).toFixed(2);
                item.innerHTML = `
                    <strong>Charge ${index + 1}</strong> ${sign}${mag} ŒºC<br>
                    Position: (${Math.round(charge.x)}, ${Math.round(charge.y)})
                `;

                item.addEventListener('click', () => {
                    selectedCharge = charge;
                    updateUI();
                });

                chargeList.appendChild(item);
            });

            // Update force calculations
            const forceSection = document.getElementById('forceSection');
            const forceVectors = document.getElementById('forceVectors');

            if (selectedCharge && charges.length > 1) {
                forceSection.style.display = 'block';
                forceVectors.innerHTML = '';

                charges.forEach((otherCharge, index) => {
                    if (otherCharge.id === selectedCharge.id) return;

                    const dx = selectedCharge.x - otherCharge.x;
                    const dy = selectedCharge.y - otherCharge.y;
                    const r = Math.sqrt(dx * dx + dy * dy);

                    if (r < 1) return;

                    const F = K * selectedCharge.charge * otherCharge.charge / (r * r);
                    const magnitude = Math.abs(F);
                    const direction = F > 0 ? 'repulsive' : 'attractive';

                    const vector = document.createElement('div');
                    vector.className = 'force-vector';
                    vector.innerHTML = `
                        Charge ${charges.indexOf(selectedCharge) + 1} ‚Üî ${index + 1}:<br>
                        F = ${magnitude.toExponential(2)} N<br>
                        (${direction})
                    `;
                    forceVectors.appendChild(vector);
                });
            } else {
                forceSection.style.display = 'none';
            }
        }

        function saveConfiguration() {
            const config = {
                charges: charges.map(c => ({
                    x: c.x,
                    y: c.y,
                    charge: c.charge,
                    id: c.id
                })),
                timestamp: new Date().toISOString()
            };
            localStorage.setItem('emFieldLabConfig', JSON.stringify(config));
            alert('Configuration saved!');
        }

        function loadConfiguration() {
            const saved = localStorage.getItem('emFieldLabConfig');
            if (saved) {
                try {
                    const config = JSON.parse(saved);
                    charges = config.charges.map(c => new Charge(c.x, c.y, c.charge, c.id));
                    selectedCharge = null;
                    updateUI();
                    alert('Configuration loaded!');
                } catch (e) {
                    alert('Error loading configuration');
                }
            } else {
                alert('No saved configuration found');
            }
        }

        function resetSimulation() {
            if (confirm('Reset the simulation? This will clear all charges.')) {
                charges = [];
                selectedCharge = null;
                draggedCharge = null;
                updateUI();
            }
        }

        function showHowToPlay() {
            document.getElementById('howToPlayModal').classList.add('active');
        }

        function showChallengeModal() {
            // Load stats from localStorage
            const stats = JSON.parse(localStorage.getItem('emFieldLabStats') || '{"personalBest": 0, "levelsCompleted": 0}');
            document.getElementById('personalBest').textContent = stats.personalBest;
            document.getElementById('levelsCompleted').textContent = stats.levelsCompleted;
            document.getElementById('challengeModal').classList.add('active');
        }

        function startChallenge(difficulty) {
            currentDifficulty = difficulty;
            challengeMode = true;
            currentLevel = 1;
            currentScore = 0;
            charges = [];
            selectedCharge = null;

            document.getElementById('challengeModal').classList.remove('active');
            document.getElementById('scoreDisplay').style.display = 'block';
            document.getElementById('levelDisplay').style.display = 'block';
            document.getElementById('challengePanel').classList.add('active');

            loadChallengeLevel();
        }

        function loadChallengeLevel() {
            charges = [];
            selectedCharge = null;

            const descriptions = {
                easy: [
                    'Create an electric dipole with charges 100 pixels apart horizontally',
                    'Place two positive charges 120 pixels apart vertically',
                    'Create a dipole at 45-degree angle, 100 pixels apart'
                ],
                medium: [
                    'Create a quadrupole with charges in a square formation',
                    'Place 4 charges in a diamond pattern',
                    'Create two parallel dipoles 80 pixels apart'
                ],
                hard: [
                    'Create a hexagonal formation with 6 alternating charges',
                    'Build a parallel plate capacitor with 5 charges per side',
                    'Create a triangular lattice with 6 charges'
                ]
            };

            const levelDescriptions = descriptions[currentDifficulty];
            const description = levelDescriptions[(currentLevel - 1) % levelDescriptions.length];

            document.getElementById('challengeDescription').textContent = `Level ${currentLevel}: ${description}`;
            document.getElementById('levelValue').textContent = currentLevel;
            document.getElementById('scoreValue').textContent = currentScore;

            // Generate target pattern
            generateTargetPattern(currentDifficulty, currentLevel);
        }

        function generateTargetPattern(difficulty, level) {
            // Store expected configuration for validation
            const cx = width / 2;
            const cy = height / 2;

            targetPattern = {
                difficulty,
                level,
                expectedCount: difficulty === 'easy' ? 2 : difficulty === 'medium' ? 4 : 6
            };
        }

        function checkChallenge() {
            if (charges.length !== targetPattern.expectedCount) {
                alert(`Place exactly ${targetPattern.expectedCount} charges for this level!`);
                return;
            }

            // Award points based on difficulty
            const points = {
                easy: 100,
                medium: 250,
                hard: 500
            };

            const levelPoints = points[currentDifficulty] * currentLevel;
            currentScore += levelPoints;
            document.getElementById('scoreValue').textContent = currentScore;

            // Save stats
            const stats = JSON.parse(localStorage.getItem('emFieldLabStats') || '{"personalBest": 0, "levelsCompleted": 0}');
            stats.levelsCompleted++;
            if (currentScore > stats.personalBest) {
                stats.personalBest = currentScore;
                alert(`New Personal Best: ${currentScore} points! üéâ`);
            } else {
                alert(`Level Complete! +${levelPoints} points`);
            }
            localStorage.setItem('emFieldLabStats', JSON.stringify(stats));

            // Next level
            currentLevel++;
            loadChallengeLevel();
        }

        function skipChallenge() {
            if (confirm('Skip this level? No points will be awarded.')) {
                currentLevel++;
                loadChallengeLevel();
            }
        }

        function exitChallenge() {
            if (confirm('Exit challenge mode? Your progress will be saved.')) {
                challengeMode = false;
                currentLevel = 1;
                currentScore = 0;
                charges = [];
                selectedCharge = null;

                document.getElementById('scoreDisplay').style.display = 'none';
                document.getElementById('levelDisplay').style.display = 'none';
                document.getElementById('challengePanel').classList.remove('active');
                updateUI();
            }
        }

        // Render loop
        function render() {
            // Clear canvas
            ctx.fillStyle = 'rgba(10, 10, 20, 0.95)';
            ctx.fillRect(0, 0, width, height);

            // Draw grid
            ctx.strokeStyle = 'rgba(100, 150, 255, 0.05)';
            ctx.lineWidth = 1;
            const gridSize = 50;
            for (let x = 0; x < width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }
            for (let y = 0; y < height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // Draw equipotential lines
            if (showEquipotential) {
                drawEquipotentialLines();
            }

            // Draw field lines
            if (showFieldLines) {
                drawFieldLines();
            }

            // Draw force vectors
            if (showForces) {
                drawForceVectors();
            }

            // Draw charges
            for (const charge of charges) {
                charge.draw(ctx);
            }

            // Highlight selected charge
            if (selectedCharge) {
                ctx.strokeStyle = 'rgba(100, 200, 255, 0.8)';
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(selectedCharge.x, selectedCharge.y, selectedCharge.radius + 5, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            requestAnimationFrame(render);
        }

        // Initialize
        updateModeIndicator();
        document.getElementById('addPositive').classList.add('active');
        updateUI();
        render();
    </script>
</body>
</html>
