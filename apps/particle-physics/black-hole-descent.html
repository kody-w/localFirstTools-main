<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Black Hole Descent Experience</title>
    <meta name="description" content="Fall into a black hole. Experience spaghettification, time dilation, gravitational lensing, the photon sphere, event horizon, and the singularity. A scientifically-grounded cosmic horror experience.">
    <meta name="theme-color" content="#000000">
    <meta name="color-scheme" content="dark">
    <!-- 3d, physics, simulation, webgl, immersive, educational -->
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #fff;
            overflow: hidden;
            height: 100vh;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Overlay */
        #ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        /* Phase Indicator */
        #phase-indicator {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            text-shadow: 0 0 20px currentColor;
            transition: all 0.5s ease;
        }

        #phase-name {
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 4px;
            text-transform: uppercase;
        }

        #phase-subtitle {
            font-size: 14px;
            opacity: 0.7;
            margin-top: 5px;
        }

        /* Info Panel */
        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 100, 50, 0.3);
            font-size: 12px;
            min-width: 200px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .info-label {
            color: #888;
        }

        .info-value {
            color: #ff6633;
            font-weight: bold;
        }

        /* Clocks */
        #clocks {
            position: absolute;
            top: 20px;
            right: 20px;
            text-align: right;
        }

        .clock {
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            border: 1px solid rgba(100, 150, 255, 0.3);
        }

        .clock-label {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .clock-value {
            font-size: 24px;
            font-family: 'Courier New', monospace;
        }

        #proper-time .clock-value { color: #66ff66; }
        #coordinate-time .clock-value { color: #ff6666; }

        /* Controls */
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            pointer-events: auto;
        }

        .control-btn {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 100, 50, 0.5);
            color: #fff;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s;
        }

        .control-btn:hover {
            background: rgba(255, 100, 50, 0.3);
            border-color: #ff6633;
        }

        .control-btn.active {
            background: rgba(255, 100, 50, 0.5);
            border-color: #ff6633;
        }

        /* Speed Slider */
        #speed-control {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 15px;
            pointer-events: auto;
        }

        #speed-slider {
            width: 200px;
            -webkit-appearance: none;
            height: 4px;
            background: rgba(255, 100, 50, 0.3);
            border-radius: 2px;
            outline: none;
        }

        #speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #ff6633;
            border-radius: 50%;
            cursor: pointer;
        }

        /* Educational Overlay */
        #education-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(100, 200, 255, 0.3);
            max-width: 350px;
            font-size: 13px;
            line-height: 1.6;
            display: none;
        }

        #education-panel.visible {
            display: block;
        }

        #education-panel h3 {
            color: #66ccff;
            margin-bottom: 10px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #education-panel p {
            color: #ccc;
            margin-bottom: 10px;
        }

        /* Spaghettification Overlay */
        #spaghetti-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            opacity: 0;
            transition: opacity 0.5s;
        }

        /* Warning Messages */
        #warning-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 32px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 8px;
            opacity: 0;
            color: #ff3333;
            text-shadow: 0 0 30px #ff0000;
            text-align: center;
            pointer-events: none;
        }

        /* Living Art Mode Banner */
        #living-art-banner {
            position: absolute;
            top: 50%;
            left: 20px;
            transform: translateY(-50%) rotate(-90deg);
            transform-origin: left center;
            font-size: 10px;
            letter-spacing: 3px;
            color: rgba(255, 255, 255, 0.3);
            display: none;
        }

        /* Loading Screen */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        #loading h1 {
            font-size: 36px;
            margin-bottom: 20px;
            letter-spacing: 8px;
        }

        #loading p {
            color: #666;
            margin-bottom: 30px;
        }

        .loading-bar {
            width: 300px;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
        }

        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #ff3300, #ff6633, #ffaa00);
            width: 0%;
            transition: width 0.3s;
        }

        /* Tidal Force Meter */
        #tidal-meter {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 200px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 100, 50, 0.3);
            border-radius: 10px;
            overflow: hidden;
        }

        #tidal-fill {
            position: absolute;
            bottom: 0;
            width: 100%;
            background: linear-gradient(to top, #00ff00, #ffff00, #ff0000);
            transition: height 0.2s;
        }

        #tidal-label {
            position: absolute;
            left: 30px;
            top: 50%;
            transform: translateY(-50%) rotate(-90deg);
            transform-origin: left center;
            font-size: 10px;
            letter-spacing: 2px;
            color: #666;
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading">
        <h1>DESCENT</h1>
        <p>Preparing to cross the event horizon...</p>
        <div class="loading-bar">
            <div class="loading-progress" id="loading-progress"></div>
        </div>
    </div>

    <!-- Canvas Container -->
    <div id="canvas-container"></div>

    <!-- Spaghettification Overlay -->
    <canvas id="spaghetti-overlay"></canvas>

    <!-- UI Overlay -->
    <div id="ui-overlay">
        <!-- Phase Indicator -->
        <div id="phase-indicator">
            <div id="phase-name">APPROACH</div>
            <div id="phase-subtitle">Safe observation distance</div>
        </div>

        <!-- Info Panel -->
        <div id="info-panel">
            <div class="info-row">
                <span class="info-label">Distance to Horizon</span>
                <span class="info-value" id="distance-value">100.0 Rs</span>
            </div>
            <div class="info-row">
                <span class="info-label">Time Dilation</span>
                <span class="info-value" id="dilation-value">1.00x</span>
            </div>
            <div class="info-row">
                <span class="info-label">Tidal Force</span>
                <span class="info-value" id="tidal-value">0.00 g/m</span>
            </div>
            <div class="info-row">
                <span class="info-label">Velocity</span>
                <span class="info-value" id="velocity-value">0.00 c</span>
            </div>
        </div>

        <!-- Clocks -->
        <div id="clocks">
            <div class="clock" id="proper-time">
                <div class="clock-label">Your Time (Proper)</div>
                <div class="clock-value" id="proper-time-value">00:00:00</div>
            </div>
            <div class="clock" id="coordinate-time">
                <div class="clock-label">Universe Time</div>
                <div class="clock-value" id="coordinate-time-value">00:00:00</div>
            </div>
        </div>

        <!-- Tidal Force Meter -->
        <div id="tidal-meter">
            <div id="tidal-fill" style="height: 0%"></div>
        </div>
        <div id="tidal-label">TIDAL FORCE</div>

        <!-- Warning Message -->
        <div id="warning-message"></div>

        <!-- Speed Control -->
        <div id="speed-control">
            <span style="color: #666; font-size: 12px;">DESCENT SPEED</span>
            <input type="range" id="speed-slider" min="0" max="100" value="30">
            <span id="speed-value" style="color: #ff6633; font-size: 12px;">30%</span>
        </div>

        <!-- Controls -->
        <div id="controls">
            <button class="control-btn" id="btn-restart">Restart</button>
            <button class="control-btn" id="btn-pause">Pause</button>
            <button class="control-btn" id="btn-education">Physics</button>
            <button class="control-btn" id="btn-living-art">Living Art</button>
        </div>

        <!-- Educational Panel -->
        <div id="education-panel">
            <h3 id="edu-title">Gravitational Lensing</h3>
            <p id="edu-content">Light from distant stars bends around the massive black hole, creating distorted and multiple images of background objects.</p>
        </div>

        <!-- Living Art Banner -->
        <div id="living-art-banner">LIVING ART MODE</div>

        <!-- Controls Help -->
        <div id="controls-help" style="position: absolute; bottom: 80px; left: 20px; background: rgba(0,0,0,0.8); padding: 12px 15px; border-radius: 8px; border: 1px solid rgba(255,100,50,0.3); font-size: 11px; color: #aaa;">
            <div style="color: #ff6633; font-weight: bold; margin-bottom: 8px; letter-spacing: 1px;">CONTROLS</div>
            <div style="margin: 4px 0;"><span style="color: #fff;">W / ↑</span> — Descend toward black hole</div>
            <div style="margin: 4px 0;"><span style="color: #fff;">S / ↓</span> — Move away</div>
            <div style="margin: 4px 0;"><span style="color: #fff;">Space</span> — Pause/Resume</div>
            <div style="margin: 4px 0;"><span style="color: #fff;">1-4</span> — Set speed (0%, 25%, 50%, 100%)</div>
            <div style="margin: 4px 0;"><span style="color: #fff;">R</span> — Restart</div>
            <div style="margin: 4px 0;"><span style="color: #fff;">Slider</span> — Auto-descent speed</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    (function() {
        'use strict';

        // ============================================
        // PHYSICS CONSTANTS (Normalized Units)
        // ============================================
        const SCHWARZSCHILD_RADIUS = 1.0;  // Rs = 1
        const PHOTON_SPHERE = 1.5 * SCHWARZSCHILD_RADIUS;
        const ISCO = 3.0 * SCHWARZSCHILD_RADIUS;  // Innermost Stable Circular Orbit
        const START_DISTANCE = 50.0 * SCHWARZSCHILD_RADIUS;
        const BLACK_HOLE_MASS = 10;  // Solar masses (for display)

        // ============================================
        // STATE
        // ============================================
        let scene, camera, renderer;
        let blackHole, accretionDisk, starField, photonSphere;
        let composer;
        let clock = new THREE.Clock();
        
        let state = {
            distance: START_DISTANCE,
            properTime: 0,
            coordinateTime: 0,
            velocity: 0,
            tidalForce: 0,
            timeDilation: 1,
            phase: 0,
            paused: false,
            speed: 0.3,
            livingArtMode: false,
            showEducation: false,
            initialized: false
        };

        const PHASES = [
            { name: 'APPROACH', subtitle: 'Safe observation distance', color: '#66ccff', distance: 10 },
            { name: 'PHOTON SPHERE', subtitle: 'Light orbits the darkness', color: '#ffcc00', distance: 1.5 },
            { name: 'EVENT HORIZON', subtitle: 'Point of no return', color: '#ff6600', distance: 1.0 },
            { name: 'INSIDE', subtitle: 'Space and time exchange', color: '#ff3300', distance: 0.5 },
            { name: 'SINGULARITY', subtitle: 'Beyond physics', color: '#ffffff', distance: 0 }
        ];

        const EDUCATION_CONTENT = {
            0: {
                title: 'Gravitational Lensing',
                content: 'Light from distant stars bends around the massive black hole due to the curvature of spacetime. This creates Einstein rings and multiple distorted images of background objects. The closer to the black hole, the more extreme the bending.'
            },
            1: {
                title: 'Photon Sphere',
                content: 'At 1.5 times the Schwarzschild radius, light can orbit the black hole. Photons here are in unstable circular orbits. A flashlight pointed sideways would illuminate the back of your own head. This is where gravity becomes truly extreme.'
            },
            2: {
                title: 'Event Horizon & Time Dilation',
                content: 'The event horizon marks where escape velocity equals the speed of light. To an outside observer, you appear to freeze and redshift into invisibility. But from your perspective, the entire future of the universe plays out in moments as you cross.'
            },
            3: {
                title: 'Spaghettification',
                content: 'Inside the horizon, tidal forces stretch you vertically while compressing horizontally. Your feet accelerate faster than your head. Space itself flows inward faster than light - the singularity is no longer a place, but your inevitable future.'
            },
            4: {
                title: 'The Singularity',
                content: 'What happens at infinite density? General relativity breaks down. Some theories suggest a quantum fuzz, others a new universe born through a white hole. The information paradox asks: where does your information go? We simply do not know.'
            }
        };

        // ============================================
        // SHADERS
        // ============================================
        
        // Gravitational Lensing Shader
        const lensVertexShader = `
            varying vec2 vUv;
            varying vec3 vPosition;
            void main() {
                vUv = uv;
                vPosition = position;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const lensFragmentShader = `
            uniform float time;
            uniform float blackHoleRadius;
            uniform vec3 blackHolePos;
            uniform float lensStrength;
            uniform sampler2D starTexture;
            varying vec2 vUv;
            varying vec3 vPosition;

            #define PI 3.14159265359

            // Procedural stars
            float hash(vec2 p) {
                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
            }

            vec3 stars(vec2 uv, float density) {
                vec3 col = vec3(0.0);
                vec2 gv = fract(uv * density) - 0.5;
                vec2 id = floor(uv * density);
                
                float star = hash(id);
                if (star > 0.97) {
                    float brightness = (star - 0.97) / 0.03;
                    float size = brightness * 0.3;
                    float d = length(gv);
                    float glow = exp(-d * 15.0) * brightness;
                    
                    // Star color based on hash
                    vec3 starColor = mix(
                        vec3(1.0, 0.8, 0.6),  // Warm
                        vec3(0.6, 0.8, 1.0),  // Cool
                        hash(id + 100.0)
                    );
                    
                    col += starColor * glow;
                }
                return col;
            }

            void main() {
                vec2 uv = vUv;
                
                // Calculate direction from black hole center
                vec2 center = vec2(0.5, 0.5);
                vec2 dir = uv - center;
                float dist = length(dir);
                
                // Gravitational lensing distortion
                float lensFactor = lensStrength / (dist * dist + 0.01);
                lensFactor = min(lensFactor, 2.0);  // Clamp extreme values
                
                // Apply radial distortion (light bends toward black hole)
                vec2 lensedUv = uv + dir * lensFactor * 0.1;
                
                // Create shadow region (event horizon)
                float shadow = smoothstep(blackHoleRadius * 0.8, blackHoleRadius * 1.2, dist);
                
                // Einstein ring glow at the edge
                float ringDist = abs(dist - blackHoleRadius * 1.1);
                float ring = exp(-ringDist * 30.0) * lensStrength * 0.5;
                
                // Generate stars with lensing
                vec3 col = vec3(0.0);
                col += stars(lensedUv * 3.0, 50.0);
                col += stars(lensedUv * 5.0 + 10.0, 80.0) * 0.5;
                col += stars(lensedUv * 7.0 + 20.0, 120.0) * 0.3;
                
                // Apply shadow
                col *= shadow;
                
                // Add Einstein ring
                col += vec3(1.0, 0.9, 0.7) * ring;
                
                // Subtle nebula background
                float nebula = hash(floor(lensedUv * 20.0)) * 0.03;
                col += vec3(0.1, 0.05, 0.15) * nebula;
                
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        // Accretion Disk Shader with Doppler Shift
        const diskVertexShader = `
            varying vec2 vUv;
            varying vec3 vWorldPos;
            void main() {
                vUv = uv;
                vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const diskFragmentShader = `
            uniform float time;
            uniform float innerRadius;
            uniform float outerRadius;
            uniform vec3 viewPos;
            
            varying vec2 vUv;
            varying vec3 vWorldPos;

            #define PI 3.14159265359

            float hash(vec2 p) {
                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
            }

            float noise(vec2 p) {
                vec2 i = floor(p);
                vec2 f = fract(p);
                f = f * f * (3.0 - 2.0 * f);
                
                float a = hash(i);
                float b = hash(i + vec2(1.0, 0.0));
                float c = hash(i + vec2(0.0, 1.0));
                float d = hash(i + vec2(1.0, 1.0));
                
                return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
            }

            void main() {
                vec2 centered = vUv - 0.5;
                float dist = length(centered);
                float angle = atan(centered.y, centered.x);
                
                // Disk boundaries
                float diskMask = smoothstep(innerRadius, innerRadius + 0.05, dist) *
                                 smoothstep(outerRadius + 0.05, outerRadius, dist);
                
                if (diskMask < 0.01) discard;
                
                // Orbital velocity (Keplerian)
                float orbitalSpeed = 1.0 / sqrt(dist);
                float rotatedAngle = angle + time * orbitalSpeed * 0.5;
                
                // Temperature gradient (inner is hotter)
                float temp = 1.0 - (dist - innerRadius) / (outerRadius - innerRadius);
                temp = pow(temp, 0.7);
                
                // Doppler shift based on velocity relative to viewer
                vec3 toViewer = normalize(viewPos - vWorldPos);
                vec2 velocityDir = vec2(-sin(angle), cos(angle));
                float dopplerFactor = dot(vec2(toViewer.x, toViewer.z), velocityDir);
                
                // Blue shift for approaching, red shift for receding
                vec3 hotColor = vec3(0.9, 0.95, 1.0);  // Blue-white (inner)
                vec3 warmColor = vec3(1.0, 0.6, 0.2);  // Orange (middle)
                vec3 coolColor = vec3(0.8, 0.2, 0.1);  // Red (outer)
                
                vec3 baseColor = mix(coolColor, mix(warmColor, hotColor, temp), temp);
                
                // Apply Doppler shift
                float blueShift = max(0.0, dopplerFactor) * 0.5;
                float redShift = max(0.0, -dopplerFactor) * 0.3;
                baseColor = mix(baseColor, vec3(0.5, 0.7, 1.0), blueShift);
                baseColor = mix(baseColor, vec3(1.0, 0.3, 0.1), redShift);
                
                // Turbulence pattern
                vec2 noiseCoord = vec2(rotatedAngle * 5.0 + dist * 10.0, dist * 20.0);
                float turb = noise(noiseCoord) * 0.5 + noise(noiseCoord * 2.0) * 0.25;
                
                // Spiral arms
                float spiral = sin(rotatedAngle * 3.0 - dist * 15.0 + time) * 0.5 + 0.5;
                spiral = pow(spiral, 2.0);
                
                // Combine
                float brightness = (turb * 0.5 + spiral * 0.3 + 0.2) * diskMask;
                brightness *= (1.0 + temp * 0.5);  // Brighter toward center
                
                // Glow
                float glow = exp(-abs(dist - innerRadius) * 5.0) * 0.3;
                
                vec3 finalColor = baseColor * brightness + vec3(1.0, 0.8, 0.6) * glow;
                
                // Fade at edges
                finalColor *= diskMask;
                
                gl_FragColor = vec4(finalColor, diskMask * 0.9);
            }
        `;

        // Post-processing spaghettification shader
        const spaghettiVertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const spaghettiFragmentShader = `
            uniform sampler2D tDiffuse;
            uniform float stretch;
            uniform float time;
            varying vec2 vUv;

            void main() {
                vec2 uv = vUv;
                
                // Vertical stretch, horizontal compress
                float centerY = 0.5;
                float centerX = 0.5;
                
                // Stretch vertically from center
                float yOffset = (uv.y - centerY) * (1.0 - stretch * 0.5);
                uv.y = centerY + yOffset;
                
                // Compress horizontally toward center
                float xOffset = (uv.x - centerX) * (1.0 + stretch * 0.3);
                uv.x = centerX + xOffset;
                
                // Add some waviness
                uv.x += sin(uv.y * 20.0 + time * 2.0) * stretch * 0.02;
                
                // Chromatic aberration increases with stretch
                float aberration = stretch * 0.01;
                vec4 col;
                col.r = texture2D(tDiffuse, uv + vec2(aberration, 0.0)).r;
                col.g = texture2D(tDiffuse, uv).g;
                col.b = texture2D(tDiffuse, uv - vec2(aberration, 0.0)).b;
                col.a = 1.0;
                
                // Vignette intensifies
                float vignette = 1.0 - length(vUv - 0.5) * stretch * 0.5;
                col.rgb *= vignette;
                
                gl_FragColor = col;
            }
        `;

        // ============================================
        // INITIALIZATION
        // ============================================
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 1000);
            camera.position.set(0, 5, state.distance);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Create scene elements
            createStarField();
            createBlackHole();
            createAccretionDisk();
            createPhotonSphereVisualization();
            createAmbientParticles();

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x111111);
            scene.add(ambientLight);

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            setupControls();

            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loading').style.opacity = '0';
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 500);
            }, 1500);

            // Simulate loading
            let progress = 0;
            const loadingInterval = setInterval(() => {
                progress += Math.random() * 30;
                if (progress >= 100) {
                    progress = 100;
                    clearInterval(loadingInterval);
                }
                document.getElementById('loading-progress').style.width = progress + '%';
            }, 200);

            state.initialized = true;
            animate();
        }

        function createStarField() {
            // Create a large sphere for the star background with lensing shader
            const geometry = new THREE.SphereGeometry(200, 64, 64);
            geometry.scale(-1, 1, 1);  // Invert for inside view

            const material = new THREE.ShaderMaterial({
                vertexShader: lensVertexShader,
                fragmentShader: lensFragmentShader,
                uniforms: {
                    time: { value: 0 },
                    blackHoleRadius: { value: 0.02 },
                    blackHolePos: { value: new THREE.Vector3(0, 0, 0) },
                    lensStrength: { value: 0.01 }
                },
                side: THREE.BackSide
            });

            starField = new THREE.Mesh(geometry, material);
            scene.add(starField);
        }

        function createBlackHole() {
            // The black hole itself - pure darkness
            const geometry = new THREE.SphereGeometry(SCHWARZSCHILD_RADIUS, 64, 64);
            const material = new THREE.MeshBasicMaterial({
                color: 0x000000,
                transparent: false
            });

            blackHole = new THREE.Mesh(geometry, material);
            scene.add(blackHole);

            // Event horizon glow
            const glowGeometry = new THREE.SphereGeometry(SCHWARZSCHILD_RADIUS * 1.05, 64, 64);
            const glowMaterial = new THREE.ShaderMaterial({
                vertexShader: `
                    varying vec3 vNormal;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec3 vNormal;
                    uniform float time;
                    void main() {
                        float intensity = pow(0.7 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 3.0);
                        vec3 color = mix(vec3(1.0, 0.3, 0.0), vec3(1.0, 0.8, 0.3), sin(time) * 0.5 + 0.5);
                        gl_FragColor = vec4(color, intensity * 0.5);
                    }
                `,
                uniforms: {
                    time: { value: 0 }
                },
                transparent: true,
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide
            });

            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            scene.add(glow);
        }

        function createAccretionDisk() {
            // Accretion disk with Doppler shifting
            const innerRadius = SCHWARZSCHILD_RADIUS * 1.5;
            const outerRadius = SCHWARZSCHILD_RADIUS * 8;

            const geometry = new THREE.RingGeometry(innerRadius, outerRadius, 128, 32);
            
            const material = new THREE.ShaderMaterial({
                vertexShader: diskVertexShader,
                fragmentShader: diskFragmentShader,
                uniforms: {
                    time: { value: 0 },
                    innerRadius: { value: 0.15 },
                    outerRadius: { value: 0.5 },
                    viewPos: { value: camera.position }
                },
                transparent: true,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide,
                depthWrite: false
            });

            accretionDisk = new THREE.Mesh(geometry, material);
            accretionDisk.rotation.x = -Math.PI / 2;
            scene.add(accretionDisk);

            // Second disk slightly tilted for depth
            const disk2 = accretionDisk.clone();
            disk2.rotation.x = -Math.PI / 2 + 0.1;
            disk2.rotation.z = 0.05;
            disk2.material = material.clone();
            scene.add(disk2);
        }

        function createPhotonSphereVisualization() {
            // Wireframe sphere at photon sphere radius
            const geometry = new THREE.SphereGeometry(PHOTON_SPHERE, 32, 32);
            const material = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                wireframe: true,
                transparent: true,
                opacity: 0
            });

            photonSphere = new THREE.Mesh(geometry, material);
            scene.add(photonSphere);
        }

        function createAmbientParticles() {
            // Particles representing matter falling into black hole
            const particleCount = 2000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const r = SCHWARZSCHILD_RADIUS * 2 + Math.random() * 20;

                positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = (Math.random() - 0.5) * 4;
                positions[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta);

                velocities[i * 3] = (Math.random() - 0.5) * 0.1;
                velocities[i * 3 + 1] = (Math.random() - 0.5) * 0.1;
                velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.1;

                // Color based on temperature/distance
                const temp = 1 - (r - SCHWARZSCHILD_RADIUS * 2) / 20;
                colors[i * 3] = 1.0;
                colors[i * 3 + 1] = 0.5 + temp * 0.5;
                colors[i * 3 + 2] = temp;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.05,
                vertexColors: true,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });

            const particles = new THREE.Points(geometry, material);
            particles.name = 'ambientParticles';
            scene.add(particles);
        }

        // ============================================
        // AUDIO SYNTHESIS
        // ============================================
        let audioContext, oscillators = [], gainNodes = [];
        let audioInitialized = false;

        function initAudio() {
            if (audioInitialized) return;
            
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Deep bass drone
                const bassOsc = audioContext.createOscillator();
                bassOsc.type = 'sine';
                bassOsc.frequency.value = 30;
                
                const bassGain = audioContext.createGain();
                bassGain.gain.value = 0;
                
                bassOsc.connect(bassGain);
                bassGain.connect(audioContext.destination);
                bassOsc.start();
                
                oscillators.push(bassOsc);
                gainNodes.push(bassGain);

                // Mid frequency rumble
                const midOsc = audioContext.createOscillator();
                midOsc.type = 'triangle';
                midOsc.frequency.value = 60;
                
                const midGain = audioContext.createGain();
                midGain.gain.value = 0;
                
                midOsc.connect(midGain);
                midGain.connect(audioContext.destination);
                midOsc.start();
                
                oscillators.push(midOsc);
                gainNodes.push(midGain);

                // High frequency static (Hawking radiation)
                const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 2, audioContext.sampleRate);
                const noiseData = noiseBuffer.getChannelData(0);
                for (let i = 0; i < noiseData.length; i++) {
                    noiseData[i] = Math.random() * 2 - 1;
                }
                
                const noiseSource = audioContext.createBufferSource();
                noiseSource.buffer = noiseBuffer;
                noiseSource.loop = true;
                
                const noiseFilter = audioContext.createBiquadFilter();
                noiseFilter.type = 'highpass';
                noiseFilter.frequency.value = 8000;
                
                const noiseGain = audioContext.createGain();
                noiseGain.gain.value = 0;
                
                noiseSource.connect(noiseFilter);
                noiseFilter.connect(noiseGain);
                noiseGain.connect(audioContext.destination);
                noiseSource.start();
                
                gainNodes.push(noiseGain);

                audioInitialized = true;
            } catch (e) {
                console.log('Audio not available:', e);
            }
        }

        function updateAudio() {
            if (!audioInitialized || !audioContext) return;

            const intensity = 1 - (state.distance / START_DISTANCE);
            const normalizedDist = state.distance / SCHWARZSCHILD_RADIUS;

            // Bass increases as we approach
            if (gainNodes[0]) {
                gainNodes[0].gain.setTargetAtTime(intensity * 0.3, audioContext.currentTime, 0.1);
                oscillators[0].frequency.setTargetAtTime(20 + intensity * 30, audioContext.currentTime, 0.1);
            }

            // Mid rumble
            if (gainNodes[1]) {
                gainNodes[1].gain.setTargetAtTime(intensity * 0.15, audioContext.currentTime, 0.1);
            }

            // Hawking radiation static near horizon
            if (gainNodes[2]) {
                const hawkingIntensity = normalizedDist < 3 ? (1 - normalizedDist / 3) * 0.1 : 0;
                gainNodes[2].gain.setTargetAtTime(hawkingIntensity, audioContext.currentTime, 0.1);
            }
        }

        // ============================================
        // PHYSICS CALCULATIONS
        // ============================================
        function calculateTimeDilation(r) {
            // Schwarzschild time dilation: sqrt(1 - Rs/r)
            if (r <= SCHWARZSCHILD_RADIUS) return 0.001;  // Nearly stopped at horizon
            return Math.sqrt(1 - SCHWARZSCHILD_RADIUS / r);
        }

        function calculateTidalForce(r) {
            // Tidal force proportional to M/r^3
            if (r <= 0) return Infinity;
            return BLACK_HOLE_MASS / Math.pow(r, 3);
        }

        function calculateVelocity(r) {
            // Free-fall velocity: sqrt(Rs/r) * c
            if (r <= SCHWARZSCHILD_RADIUS) return 1;  // Speed of light at horizon
            return Math.sqrt(SCHWARZSCHILD_RADIUS / r);
        }

        function determinePhase(distance) {
            if (distance > 10 * SCHWARZSCHILD_RADIUS) return 0;  // Approach
            if (distance > 1.5 * SCHWARZSCHILD_RADIUS) return 1;  // Photon sphere approach
            if (distance > SCHWARZSCHILD_RADIUS) return 2;  // Event horizon
            if (distance > 0.1 * SCHWARZSCHILD_RADIUS) return 3;  // Inside
            return 4;  // Singularity
        }

        // ============================================
        // UPDATE FUNCTIONS
        // ============================================
        function updatePhysics(delta) {
            if (state.paused) return;

            // Calculate descent rate based on speed and distance
            const fallRate = state.speed * 0.5 * Math.pow(state.distance / START_DISTANCE + 0.1, 0.5);
            
            // Update distance
            if (state.distance > 0.01) {
                state.distance -= fallRate * delta;
                state.distance = Math.max(0.01, state.distance);
            }

            // Update physics values
            state.timeDilation = calculateTimeDilation(state.distance);
            state.tidalForce = calculateTidalForce(state.distance);
            state.velocity = calculateVelocity(state.distance);

            // Update time
            state.properTime += delta;
            state.coordinateTime += delta / Math.max(state.timeDilation, 0.001);

            // Determine phase
            const newPhase = determinePhase(state.distance);
            if (newPhase !== state.phase) {
                onPhaseChange(newPhase);
            }
            state.phase = newPhase;
        }

        function onPhaseChange(newPhase) {
            const phase = PHASES[newPhase];
            const indicator = document.getElementById('phase-indicator');
            document.getElementById('phase-name').textContent = phase.name;
            document.getElementById('phase-subtitle').textContent = phase.subtitle;
            indicator.style.color = phase.color;

            // Show warning for critical phases
            if (newPhase === 2) {
                showWarning('CROSSING EVENT HORIZON', 3000);
            } else if (newPhase === 4) {
                showWarning('SINGULARITY', 5000);
            }

            // Update education content
            const edu = EDUCATION_CONTENT[newPhase];
            document.getElementById('edu-title').textContent = edu.title;
            document.getElementById('edu-content').textContent = edu.content;
        }

        function showWarning(text, duration) {
            const warning = document.getElementById('warning-message');
            warning.textContent = text;
            warning.style.opacity = '1';
            
            setTimeout(() => {
                warning.style.opacity = '0';
            }, duration);
        }

        function updateUI() {
            // Info panel
            const distInRs = state.distance / SCHWARZSCHILD_RADIUS;
            document.getElementById('distance-value').textContent = 
                distInRs > 10 ? distInRs.toFixed(1) + ' Rs' : distInRs.toFixed(3) + ' Rs';
            
            document.getElementById('dilation-value').textContent = 
                state.timeDilation < 0.01 ? '> 100x' : (1 / state.timeDilation).toFixed(2) + 'x';
            
            document.getElementById('tidal-value').textContent = 
                state.tidalForce > 1000 ? 'EXTREME' : state.tidalForce.toFixed(2) + ' g/m';
            
            document.getElementById('velocity-value').textContent = 
                (state.velocity * 100).toFixed(1) + '% c';

            // Clocks
            document.getElementById('proper-time-value').textContent = formatTime(state.properTime);
            document.getElementById('coordinate-time-value').textContent = formatTime(state.coordinateTime);

            // Tidal meter
            const tidalPercent = Math.min(100, state.tidalForce * 10);
            document.getElementById('tidal-fill').style.height = tidalPercent + '%';

            // Phase color updates
            const phase = PHASES[state.phase];
            document.getElementById('info-panel').style.borderColor = phase.color + '50';
        }

        function formatTime(seconds) {
            if (seconds > 31536000000) {  // Billion years
                return (seconds / 31536000000).toFixed(1) + ' Gyr';
            }
            if (seconds > 31536000000000) {  // Trillion years
                return (seconds / 31536000000000).toFixed(1) + ' Tyr';
            }
            if (seconds > 3600) {
                const h = Math.floor(seconds / 3600);
                const m = Math.floor((seconds % 3600) / 60);
                return h + 'h ' + m + 'm';
            }
            const m = Math.floor(seconds / 60);
            const s = Math.floor(seconds % 60);
            return String(m).padStart(2, '0') + ':' + String(s).padStart(2, '0');
        }

        function updateVisuals(delta, time) {
            // Camera position
            const targetZ = Math.max(state.distance, SCHWARZSCHILD_RADIUS * 0.5);
            const camHeight = 2 + Math.sin(time * 0.1) * (state.livingArtMode ? 3 : 0.5);
            
            if (state.livingArtMode) {
                // Cinematic camera movement
                camera.position.x = Math.sin(time * 0.05) * targetZ * 0.3;
                camera.position.y = camHeight + Math.sin(time * 0.08) * 2;
                camera.position.z = targetZ + Math.cos(time * 0.05) * targetZ * 0.2;
            } else {
                camera.position.y = camHeight;
                camera.position.z = targetZ;
            }
            camera.lookAt(0, 0, 0);

            // Update star field shader
            if (starField && starField.material.uniforms) {
                starField.material.uniforms.time.value = time;
                const lensStrength = 0.01 + (1 - state.distance / START_DISTANCE) * 0.2;
                starField.material.uniforms.lensStrength.value = lensStrength;
                starField.material.uniforms.blackHoleRadius.value = 0.02 + (1 - state.distance / START_DISTANCE) * 0.1;
            }

            // Update accretion disk
            if (accretionDisk && accretionDisk.material.uniforms) {
                accretionDisk.material.uniforms.time.value = time;
                accretionDisk.material.uniforms.viewPos.value.copy(camera.position);
            }

            // Update photon sphere visibility
            if (photonSphere) {
                const distToPhoton = Math.abs(state.distance - PHOTON_SPHERE * SCHWARZSCHILD_RADIUS);
                photonSphere.material.opacity = Math.max(0, 0.3 - distToPhoton * 0.1);
                photonSphere.rotation.y = time * 0.1;
            }

            // Update ambient particles
            const particles = scene.getObjectByName('ambientParticles');
            if (particles) {
                const positions = particles.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    const x = positions[i];
                    const y = positions[i + 1];
                    const z = positions[i + 2];
                    const dist = Math.sqrt(x * x + z * z);
                    
                    // Spiral toward black hole
                    const angle = Math.atan2(z, x) + delta * (2 / (dist + 1));
                    const newDist = dist - delta * 0.1 * (dist < 5 ? 1 : 0.1);
                    
                    if (newDist < SCHWARZSCHILD_RADIUS * 1.2) {
                        // Respawn far out
                        const respawnDist = 15 + Math.random() * 10;
                        const respawnAngle = Math.random() * Math.PI * 2;
                        positions[i] = respawnDist * Math.cos(respawnAngle);
                        positions[i + 2] = respawnDist * Math.sin(respawnAngle);
                    } else {
                        positions[i] = newDist * Math.cos(angle);
                        positions[i + 2] = newDist * Math.sin(angle);
                    }
                }
                particles.geometry.attributes.position.needsUpdate = true;
            }

            // Spaghettification effect
            updateSpaghettification();

            // Black hole glow
            const glowMesh = scene.children.find(c => c.material && c.material.uniforms && c.material.uniforms.time);
            if (glowMesh) {
                glowMesh.material.uniforms.time.value = time;
            }
        }

        function updateSpaghettification() {
            const canvas = document.getElementById('spaghetti-overlay');
            const ctx = canvas.getContext('2d');
            
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // Spaghettification intensity based on phase
            let intensity = 0;
            if (state.phase >= 3) {
                intensity = Math.min(1, (1 - state.distance / SCHWARZSCHILD_RADIUS) * 2);
            }

            if (intensity > 0) {
                canvas.style.opacity = '1';
                
                // Draw stretching grid
                ctx.strokeStyle = `rgba(255, 100, 50, ${intensity * 0.3})`;
                ctx.lineWidth = 1;

                const gridSize = 50;
                const stretchY = 1 + intensity * 2;
                const compressX = 1 - intensity * 0.5;

                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;

                // Vertical lines (being stretched)
                for (let x = -10; x <= 10; x++) {
                    ctx.beginPath();
                    const baseX = centerX + x * gridSize * compressX;
                    ctx.moveTo(baseX, centerY - 200 * stretchY);
                    ctx.lineTo(baseX + Math.sin(state.properTime * 3 + x) * intensity * 20, centerY + 200 * stretchY);
                    ctx.stroke();
                }

                // Horizontal lines (being compressed)
                for (let y = -4; y <= 4; y++) {
                    ctx.beginPath();
                    const baseY = centerY + y * gridSize / stretchY;
                    ctx.moveTo(centerX - 500, baseY);
                    ctx.lineTo(centerX + 500, baseY);
                    ctx.stroke();
                }

                // Tidal force arrows
                if (intensity > 0.3) {
                    ctx.fillStyle = `rgba(255, 50, 0, ${intensity * 0.5})`;
                    
                    // Up arrow (head being pulled)
                    drawArrow(ctx, centerX, centerY - 100, centerX, centerY - 200 - intensity * 100);
                    // Down arrow (feet being pulled)
                    drawArrow(ctx, centerX, centerY + 100, centerX, centerY + 200 + intensity * 100);
                    // Compression arrows
                    drawArrow(ctx, centerX - 150, centerY, centerX - 50, centerY);
                    drawArrow(ctx, centerX + 150, centerY, centerX + 50, centerY);
                }
            } else {
                canvas.style.opacity = '0';
            }
        }

        function drawArrow(ctx, fromX, fromY, toX, toY) {
            const headLen = 15;
            const angle = Math.atan2(toY - fromY, toX - fromX);
            
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.lineTo(toX - headLen * Math.cos(angle - Math.PI / 6), toY - headLen * Math.sin(angle - Math.PI / 6));
            ctx.moveTo(toX, toY);
            ctx.lineTo(toX - headLen * Math.cos(angle + Math.PI / 6), toY - headLen * Math.sin(angle + Math.PI / 6));
            ctx.stroke();
        }

        // ============================================
        // CONTROLS
        // ============================================
        function setupControls() {
            // Speed slider
            const speedSlider = document.getElementById('speed-slider');
            speedSlider.addEventListener('input', (e) => {
                state.speed = e.target.value / 100;
                document.getElementById('speed-value').textContent = e.target.value + '%';
            });

            // Buttons
            document.getElementById('btn-restart').addEventListener('click', () => {
                initAudio();
                restart();
            });
            
            document.getElementById('btn-pause').addEventListener('click', (e) => {
                state.paused = !state.paused;
                e.target.textContent = state.paused ? 'Resume' : 'Pause';
                e.target.classList.toggle('active', state.paused);
            });
            
            document.getElementById('btn-education').addEventListener('click', (e) => {
                state.showEducation = !state.showEducation;
                document.getElementById('education-panel').classList.toggle('visible', state.showEducation);
                e.target.classList.toggle('active', state.showEducation);
            });
            
            document.getElementById('btn-living-art').addEventListener('click', (e) => {
                state.livingArtMode = !state.livingArtMode;
                e.target.classList.toggle('active', state.livingArtMode);
                document.getElementById('living-art-banner').style.display = state.livingArtMode ? 'block' : 'none';
                
                if (state.livingArtMode) {
                    // Hide UI elements for cleaner view
                    document.getElementById('info-panel').style.opacity = '0.3';
                    document.getElementById('clocks').style.opacity = '0.3';
                } else {
                    document.getElementById('info-panel').style.opacity = '1';
                    document.getElementById('clocks').style.opacity = '1';
                }
            });

            // Click to start audio
            document.addEventListener('click', () => {
                initAudio();
            }, { once: true });

            // Keyboard controls for manual position
            document.addEventListener('keydown', (e) => {
                const moveAmount = 2.0; // Distance to move per keypress

                switch(e.key.toLowerCase()) {
                    case 'w':
                    case 'arrowup':
                        // Move toward black hole
                        state.distance = Math.max(0.05, state.distance - moveAmount);
                        break;
                    case 's':
                    case 'arrowdown':
                        // Move away from black hole
                        state.distance = Math.min(START_DISTANCE, state.distance + moveAmount);
                        break;
                    case ' ':
                        // Toggle pause
                        state.paused = !state.paused;
                        document.getElementById('btn-pause').textContent = state.paused ? 'Resume' : 'Pause';
                        document.getElementById('btn-pause').classList.toggle('active', state.paused);
                        e.preventDefault();
                        break;
                    case 'r':
                        // Restart
                        restart();
                        break;
                    case '1':
                        state.speed = 0;
                        document.getElementById('speed-slider').value = 0;
                        document.getElementById('speed-value').textContent = '0%';
                        break;
                    case '2':
                        state.speed = 0.25;
                        document.getElementById('speed-slider').value = 25;
                        document.getElementById('speed-value').textContent = '25%';
                        break;
                    case '3':
                        state.speed = 0.5;
                        document.getElementById('speed-slider').value = 50;
                        document.getElementById('speed-value').textContent = '50%';
                        break;
                    case '4':
                        state.speed = 1.0;
                        document.getElementById('speed-slider').value = 100;
                        document.getElementById('speed-value').textContent = '100%';
                        break;
                }
            });
        }

        function restart() {
            state.distance = START_DISTANCE;
            state.properTime = 0;
            state.coordinateTime = 0;
            state.phase = 0;
            state.paused = false;
            
            document.getElementById('btn-pause').textContent = 'Pause';
            document.getElementById('btn-pause').classList.remove('active');
            
            onPhaseChange(0);
        }

        // ============================================
        // RESIZE HANDLER
        // ============================================
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ============================================
        // ANIMATION LOOP
        // ============================================
        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // Living art auto-restart
            if (state.livingArtMode && state.distance < 0.05) {
                restart();
            }

            // Update systems
            updatePhysics(delta);
            updateUI();
            updateVisuals(delta, time);
            updateAudio();

            // Render
            renderer.render(scene, camera);
        }

        // ============================================
        // START
        // ============================================
        init();

    })();
    </script>
</body>
</html>
