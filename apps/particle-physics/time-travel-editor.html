<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Time-Travel Code Editor (4D)</title>
    <meta name="description" content="A 4D HTML/JS Playground with time-travel capabilities. Visualize your coding session as a 3D tree of diverging realities.">
    <meta name="theme-color" content="#1e1e1e">
    <meta name="color-scheme" content="dark">
    <style>
        :root {
            --bg-color: #1e1e1e;
            --panel-bg: #252526;
            --text-color: #d4d4d4;
            --accent-color: #007acc;
            --branch-color: #ffaa00;
            --border-color: #333;
        }

        body {
            margin: 0;
            background: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        #toolbar {
            background: var(--panel-bg);
            padding: 10px 20px;
            display: flex;
            gap: 15px;
            border-bottom: 1px solid var(--border-color);
            align-items: center;
            height: 40px;
        }

        h1 { margin: 0; font-size: 18px; color: var(--accent-color); margin-right: 20px; }

        button {
            background: #0e639c;
            color: white;
            border: none;
            padding: 6px 12px;
            cursor: pointer;
            font-family: inherit;
            border-radius: 3px;
            font-size: 12px;
            transition: background 0.2s;
        }

        button:hover { background: #1177bb; }
        button:disabled { background: #444; cursor: not-allowed; opacity: 0.7; }
        button.secondary { background: #444; }
        button.secondary:hover { background: #555; }
        button.danger { background: #a1260d; }
        button.danger:hover { background: #c1381d; }

        #main-area {
            display: flex;
            flex: 1;
            overflow: hidden;
            height: calc(100vh - 250px); /* Reserve space for timeline */
        }

        #editor-pane, #preview-pane {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        #editor-pane {
            border-right: 1px solid var(--border-color);
        }

        .pane-header {
            background: #2d2d2d;
            padding: 5px 10px;
            font-size: 12px;
            font-weight: bold;
            color: #aaa;
            text-transform: uppercase;
            display: flex;
            justify-content: space-between;
        }

        textarea {
            flex: 1;
            background: var(--bg-color);
            color: #d4d4d4;
            border: none;
            padding: 15px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            resize: none;
            outline: none;
            line-height: 1.5;
            white-space: pre;
            overflow: auto;
        }

        iframe {
            flex: 1;
            border: none;
            background: white;
        }

        #timeline-panel {
            height: 250px;
            background: #111;
            border-top: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            position: relative;
        }

        #timeline-controls {
            padding: 5px 10px;
            background: #252526;
            display: flex;
            align-items: center;
            gap: 10px;
            border-bottom: 1px solid #333;
        }

        #timeline-canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            cursor: grab;
        }
        
        #timeline-canvas-container:active {
            cursor: grabbing;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #scrubber-container {
            padding: 0 10px;
            flex: 1;
            display: flex;
            align-items: center;
        }

        input[type="range"] {
            width: 100%;
            cursor: pointer;
        }

        .badge {
            background: #007acc;
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            margin-left: 5px;
        }

        #status-bar {
            background: #007acc;
            color: white;
            padding: 2px 10px;
            font-size: 11px;
            display: flex;
            justify-content: space-between;
        }

        /* 3D Overlay UI */
        #viz-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            pointer-events: none;
        }
        
        .viz-info {
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            color: #fff;
            margin-bottom: 5px;
        }

        #merge-btn {
            display: none; /* Hidden by default, shown when needed */
            background: #3fb950;
        }
        #merge-btn:hover { background: #2ea043; }

    </style>
</head>
<body>

    <div id="toolbar">
        <h1>Time-Travel Editor <span style="font-size: 12px; color: #888; font-weight: normal;">4D Playground</span></h1>
        <button onclick="resetProject()" class="danger">New Project</button>
        <button onclick="toggleAutoRun()" id="autorun-btn">Auto-Run: ON</button>
        <div style="flex:1"></div>
        <button id="merge-btn" onclick="mergeBranch()">Merge Branch Here</button>
        <button onclick="exportProject()">Export JSON</button>
    </div>

    <div id="main-area">
        <div id="editor-pane">
            <div class="pane-header">
                <span>Code Editor</span>
                <span id="char-count">0 chars</span>
            </div>
            <textarea id="code-editor" spellcheck="false" placeholder="<!-- Type HTML/JS/CSS here -->"></textarea>
        </div>
        <div id="preview-pane">
            <div class="pane-header">
                <span>Live Preview</span>
                <button onclick="runCode()" style="padding: 2px 8px; font-size: 10px;">Run ▶</button>
            </div>
            <iframe id="preview-frame"></iframe>
        </div>
    </div>

    <div id="timeline-panel">
        <div id="timeline-controls">
            <button onclick="togglePlay()" id="play-btn">▶ Play</button>
            <span style="font-size: 12px; color: #aaa;">Time Travel:</span>
            <div id="scrubber-container">
                <input type="range" id="time-scrubber" min="0" max="0" value="0">
            </div>
            <span id="time-display" style="font-size: 12px; width: 80px; text-align: right;">00:00:00</span>
        </div>
        <div id="timeline-canvas-container">
            <canvas id="viz-canvas"></canvas>
            <div id="viz-overlay">
                <div class="viz-info">Drag to rotate 3D view</div>
                <div class="viz-info">Click node to travel</div>
            </div>
        </div>
    </div>
    
    <div id="status-bar">
        <span id="status-msg">Ready</span>
        <span id="branch-info">Branch: main</span>
    </div>

    <script>
        // --- State Management ---
        const state = {
            nodes: [],
            branches: {}, // branchId -> { color, name, startNodeId }
            rootId: null,
            headId: null, // The tip of the current branch
            currentId: null, // The node currently displayed
            isAutoRun: true,
            isPlaying: false,
            nextBranchId: 0
        };

        // Node structure: { id, text, timestamp, parentId, childrenIds, branchId, x, y, z }
        
        // --- DOM Elements ---
        const editor = document.getElementById('code-editor');
        const iframe = document.getElementById('preview-frame');
        const scrubber = document.getElementById('time-scrubber');
        const timeDisplay = document.getElementById('time-display');
        const canvas = document.getElementById('viz-canvas');
        const ctx = canvas.getContext('2d');
        const statusMsg = document.getElementById('status-msg');
        const branchInfo = document.getElementById('branch-info');
        const mergeBtn = document.getElementById('merge-btn');

        // --- Initialization ---
        const STAGE_1_CODE = `<!DOCTYPE html>
<html>
<head>
    <title>Stage 1: Basic Boids</title>
    <style>body { margin: 0; background: #111; overflow: hidden; }</style>
</head>
<body>
    <canvas id="c"></canvas>
    <script>
        const c = document.getElementById('c');
        const ctx = c.getContext('2d');
        c.width = window.innerWidth; c.height = window.innerHeight;
        
        const boids = [];
        for(let i=0; i<50; i++) boids.push({x:Math.random()*c.width, y:Math.random()*c.height, vx:Math.random()*2-1, vy:Math.random()*2-1});
        
        function loop() {
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.fillRect(0,0,c.width,c.height);
            ctx.fillStyle = '#0f0';
            boids.forEach(b => {
                b.x += b.vx; b.y += b.vy;
                if(b.x<0||b.x>c.width) b.vx*=-1;
                if(b.y<0||b.y>c.height) b.vy*=-1;
                ctx.fillRect(b.x,b.y,2,2);
            });
            requestAnimationFrame(loop);
        }
        loop();
    <\/script>
</body>
</html>`;

        const STAGE_2_CODE = `<!DOCTYPE html>
<html>
<head>
    <title>Stage 2: 3D Setup</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"><\/script>
    <style>body { margin: 0; overflow: hidden; }</style>
</head>
<body>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        const geometry = new THREE.BoxGeometry();
        const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
        const cube = new THREE.Mesh(geometry, material);
        scene.add(cube);
        
        camera.position.z = 5;
        
        function animate() {
            requestAnimationFrame(animate);
            cube.rotation.x += 0.01;
            cube.rotation.y += 0.01;
            renderer.render(scene, camera);
        }
        animate();
    <\/script>
</body>
</html>`;

        const STAGE_3_CODE = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PalBoids 3D: Swarm Collector</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"><\/script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #0f172a; font-family: sans-serif; color: #e2e8f0; user-select: none; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #hud { position: absolute; top: 20px; left: 20px; background: rgba(15, 23, 42, 0.8); padding: 20px; border-radius: 12px; border: 1px solid rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px); width: 280px; pointer-events: auto; }
        h1 { margin: 0 0 10px 0; font-size: 1.4rem; font-weight: 700; color: #38bdf8; text-transform: uppercase; letter-spacing: 1px; }
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 0.9rem; }
        .stat-label { color: #94a3b8; }
        .stat-value { font-weight: bold; color: #f1f5f9; }
        #controls-hint { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255, 255, 255, 0.1); font-size: 0.8rem; color: #64748b; line-height: 1.5; }
        .health-bar-container { width: 100%; height: 8px; background: #334155; border-radius: 4px; margin-top: 5px; overflow: hidden; }
        .health-bar { height: 100%; background: #22c55e; width: 100%; transition: width 0.2s; }
        #game-over { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(15, 23, 42, 0.95); padding: 40px; border-radius: 20px; text-align: center; border: 2px solid #38bdf8; pointer-events: auto; }
        button { background: #38bdf8; color: #0f172a; border: none; padding: 10px 20px; border-radius: 6px; font-weight: bold; font-size: 1rem; cursor: pointer; margin-top: 20px; }
        button:hover { background: #0ea5e9; }
        .notification { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.7); color: white; padding: 10px 20px; border-radius: 20px; opacity: 0; transition: opacity 0.3s; }
    </style>
</head>
<body>
    <div id="ui-layer">
        <div id="hud">
            <h1>PalBoids 3D</h1>
            <div class="stat-row"><span class="stat-label">Player Health</span><span class="stat-value" id="hp-val">100%</span></div>
            <div class="health-bar-container"><div class="health-bar" id="player-hp-bar"></div></div>
            <div style="margin-top: 15px;"></div>
            <div class="stat-row"><span class="stat-label">Swarm Size</span><span class="stat-value" id="swarm-count">0</span></div>
            <div class="stat-row"><span class="stat-label">Wild Boids</span><span class="stat-value" id="wild-count">0</span></div>
            <div class="stat-row"><span class="stat-label">Predators</span><span class="stat-value" id="predator-count" style="color: #ef4444;">0</span></div>
            <div id="controls-hint"><strong>WASD</strong> to Move<br><strong>Click</strong> to throw Tame Sphere<br><strong>Space</strong> to recall swarm<br><strong>Scroll</strong> to Zoom<br>Build your swarm to defeat predators!</div>
        </div>
        <div id="game-over"><h1 style="font-size: 2rem; margin-bottom: 10px;">GAME OVER</h1><p id="game-over-msg">Your swarm was defeated.</p><button onclick="location.reload()">Respawn</button></div>
        <div id="notification" class="notification"></div>
    </div>
    <script>
        const scene = new THREE.Scene(); scene.background = new THREE.Color(0x0f172a); scene.fog = new THREE.Fog(0x0f172a, 50, 150);
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000); camera.position.set(0, 60, 40); camera.lookAt(0, 0, 0);
        const renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled = true; document.body.appendChild(renderer.domElement);
        const ambientLight = new THREE.AmbientLight(0x404040, 1.5); scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1); dirLight.position.set(50, 100, 50); dirLight.castShadow = true; dirLight.shadow.camera.left = -100; dirLight.shadow.camera.right = 100; dirLight.shadow.camera.top = 100; dirLight.shadow.camera.bottom = -100; dirLight.shadow.mapSize.width = 2048; dirLight.shadow.mapSize.height = 2048; scene.add(dirLight);
        const planeGeometry = new THREE.PlaneGeometry(400, 400); const planeMaterial = new THREE.MeshStandardMaterial({ color: 0x1e293b, roughness: 0.8, metalness: 0.2 }); const plane = new THREE.Mesh(planeGeometry, planeMaterial); plane.rotation.x = -Math.PI / 2; plane.receiveShadow = true; scene.add(plane);
        const gridHelper = new THREE.GridHelper(400, 40, 0x334155, 0x334155); scene.add(gridHelper);
        const WORLD_SIZE = 200;
        class Player {
            constructor() {
                this.position = new THREE.Vector3(0, 0, 0); this.velocity = new THREE.Vector3(0, 0, 0); this.speed = 0.8; this.health = 100; this.maxHealth = 100; this.radius = 2; this.keys = {};
                const geometry = new THREE.CapsuleGeometry(1, 2, 4, 8); const material = new THREE.MeshStandardMaterial({ color: 0x38bdf8 }); this.mesh = new THREE.Mesh(geometry, material); this.mesh.position.y = 1.5; this.mesh.castShadow = true; scene.add(this.mesh);
                const ringGeo = new THREE.RingGeometry(2, 2.2, 32); const ringMat = new THREE.MeshBasicMaterial({ color: 0x38bdf8, side: THREE.DoubleSide, transparent: true, opacity: 0.5 }); this.ring = new THREE.Mesh(ringGeo, ringMat); this.ring.rotation.x = -Math.PI / 2; this.ring.position.y = 0.1; scene.add(this.ring);
            }
            update() {
                this.velocity.set(0, 0, 0);
                if (this.keys['w'] || this.keys['ArrowUp']) this.velocity.z = -1; if (this.keys['s'] || this.keys['ArrowDown']) this.velocity.z = 1; if (this.keys['a'] || this.keys['ArrowLeft']) this.velocity.x = -1; if (this.keys['d'] || this.keys['ArrowRight']) this.velocity.x = 1;
                if (this.velocity.length() > 0) this.velocity.normalize().multiplyScalar(this.speed);
                this.position.add(this.velocity);
                this.position.x = Math.max(-WORLD_SIZE, Math.min(WORLD_SIZE, this.position.x)); this.position.z = Math.max(-WORLD_SIZE, Math.min(WORLD_SIZE, this.position.z));
                this.mesh.position.x = this.position.x; this.mesh.position.z = this.position.z; this.ring.position.x = this.position.x; this.ring.position.z = this.position.z;
                camera.position.x += (this.position.x - camera.position.x) * 0.1; camera.position.z += (this.position.z + 40 - camera.position.z) * 0.1; camera.lookAt(this.position.x, 0, this.position.z);
            }
            takeDamage(amount) {
                this.health -= amount; if (this.health < 0) this.health = 0; updateHealthUI(); if (this.health <= 0) gameOver("You were defeated by a predator!");
                this.mesh.material.color.setHex(0xff0000); setTimeout(() => this.mesh.material.color.setHex(0x38bdf8), 100);
            }
        }
        class Projectile {
            constructor(x, z, targetX, targetZ) {
                this.position = new THREE.Vector3(x, 1.5, z); this.velocity = new THREE.Vector3(targetX - x, 0, targetZ - z); this.velocity.normalize().multiplyScalar(1.5); this.active = true; this.life = 60; this.radius = 0.5;
                const geometry = new THREE.SphereGeometry(0.5, 8, 8); const material = new THREE.MeshStandardMaterial({ color: 0xfbbf24, emissive: 0xfbbf24, emissiveIntensity: 0.5 }); this.mesh = new THREE.Mesh(geometry, material); this.mesh.position.copy(this.position); this.mesh.castShadow = true; scene.add(this.mesh);
            }
            update() { this.position.add(this.velocity); this.mesh.position.copy(this.position); this.mesh.rotation.x += 0.1; this.mesh.rotation.z += 0.1; this.life--; if (this.life <= 0) this.destroy(); }
            destroy() { this.active = false; scene.remove(this.mesh); this.mesh.geometry.dispose(); this.mesh.material.dispose(); }
        }
        class Boid {
            constructor(x, z, type = 'wild') {
                this.position = new THREE.Vector3(x, 1 + Math.random(), z); this.velocity = new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5); this.velocity.normalize().multiplyScalar(0.5); this.acceleration = new THREE.Vector3(0, 0, 0);
                this.type = type; this.isTamed = (type === 'tamed'); this.isPredator = (type === 'predator');
                if (this.isPredator) { this.maxForce = 0.05; this.maxSpeed = 0.7; this.color = 0xef4444; this.size = 1.5; this.health = 200; this.geometry = new THREE.IcosahedronGeometry(1, 0); }
                else if (this.isTamed) { this.maxForce = 0.04; this.maxSpeed = 0.9; this.color = 0x22c55e; this.size = 0.8; this.health = 50; this.geometry = new THREE.ConeGeometry(0.5, 1.5, 8); }
                else { this.maxForce = 0.03; this.maxSpeed = 0.6; this.color = 0x94a3b8; this.size = 0.8; this.health = 30; this.geometry = new THREE.ConeGeometry(0.5, 1.5, 8); }
                this.material = new THREE.MeshStandardMaterial({ color: this.color }); this.mesh = new THREE.Mesh(this.geometry, this.material); this.mesh.position.copy(this.position); this.mesh.castShadow = true; this.mesh.geometry.rotateX(Math.PI / 2); scene.add(this.mesh);
            }
            edges() {
                if (this.position.x > WORLD_SIZE) this.position.x = -WORLD_SIZE; else if (this.position.x < -WORLD_SIZE) this.position.x = WORLD_SIZE;
                if (this.position.z > WORLD_SIZE) this.position.z = -WORLD_SIZE; else if (this.position.z < -WORLD_SIZE) this.position.z = WORLD_SIZE;
            }
            align(boids, perception) {
                let steering = new THREE.Vector3(); let total = 0;
                for (let other of boids) { let d = this.position.distanceTo(other.position); if (other !== this && d < perception && other.type === this.type) { steering.add(other.velocity); total++; } }
                if (total > 0) steering.divideScalar(total).normalize().multiplyScalar(this.maxSpeed).sub(this.velocity).clampLength(0, this.maxForce); return steering;
            }
            cohesion(boids, perception) {
                let steering = new THREE.Vector3(); let total = 0;
                for (let other of boids) { let d = this.position.distanceTo(other.position); if (other !== this && d < perception && other.type === this.type) { steering.add(other.position); total++; } }
                if (total > 0) steering.divideScalar(total).sub(this.position).normalize().multiplyScalar(this.maxSpeed).sub(this.velocity).clampLength(0, this.maxForce); return steering;
            }
            separation(boids, perception) {
                let steering = new THREE.Vector3(); let total = 0;
                for (let other of boids) {
                    let d = this.position.distanceTo(other.position);
                    if (other !== this && d < perception) {
                        let diff = new THREE.Vector3().subVectors(this.position, other.position); diff.divideScalar(d * d);
                        if (other.isPredator && !this.isPredator) diff.multiplyScalar(10);
                        steering.add(diff); total++;
                    }
                }
                if (total > 0) steering.divideScalar(total).normalize().multiplyScalar(this.maxSpeed).sub(this.velocity).clampLength(0, this.maxForce * 1.5); return steering;
            }
            seek(target) { let desired = new THREE.Vector3().subVectors(target, this.position); desired.normalize().multiplyScalar(this.maxSpeed); let steer = new THREE.Vector3().subVectors(desired, this.velocity); steer.clampLength(0, this.maxForce); return steer; }
            flee(target) { let desired = new THREE.Vector3().subVectors(this.position, target); desired.normalize().multiplyScalar(this.maxSpeed); let steer = new THREE.Vector3().subVectors(desired, this.velocity); steer.clampLength(0, this.maxForce); return steer; }
            behavior(boids, player) {
                let perception = 15; let alignment = this.align(boids, perception); let cohesion = this.cohesion(boids, perception); let separation = this.separation(boids, perception);
                alignment.multiplyScalar(1.0); cohesion.multiplyScalar(1.0); separation.multiplyScalar(1.5);
                this.acceleration.add(alignment); this.acceleration.add(cohesion); this.acceleration.add(separation);
                if (this.isTamed) {
                    let followForce = this.seek(player.position); let d = this.position.distanceTo(player.position); if (d < 15) followForce.multiplyScalar(0.5); else followForce.multiplyScalar(1.5); this.acceleration.add(followForce);
                    let nearestPredator = null; let minDist = 40;
                    for (let other of boids) { if (other.isPredator) { let d = this.position.distanceTo(other.position); if (d < minDist) { minDist = d; nearestPredator = other; } } }
                    if (nearestPredator) { let attackForce = this.seek(nearestPredator.position); attackForce.multiplyScalar(3.0); this.acceleration.add(attackForce); if (minDist < 3) { nearestPredator.takeDamage(0.5); nearestPredator.mesh.material.emissive.setHex(0xffffff); setTimeout(() => nearestPredator.mesh.material.emissive.setHex(0x000000), 50); } }
                } else if (this.isPredator) {
                    let chaseForce = this.seek(player.position); chaseForce.multiplyScalar(0.8); this.acceleration.add(chaseForce); let d = this.position.distanceTo(player.position); if (d < 3) player.takeDamage(0.5);
                } else {
                    let d = this.position.distanceTo(player.position); if (d < 20) { let fleeForce = this.flee(player.position); fleeForce.multiplyScalar(2.0); this.acceleration.add(fleeForce); }
                }
            }
            takeDamage(amount) { this.health -= amount; if (this.health <= 0) return true; return false; }
            update() {
                this.position.add(this.velocity); this.velocity.add(this.acceleration); this.velocity.clampLength(0, this.maxSpeed); this.acceleration.set(0, 0, 0);
                this.position.y = 1 + Math.sin(Date.now() * 0.005 + this.position.x) * 0.5; this.mesh.position.copy(this.position);
                const lookTarget = new THREE.Vector3().copy(this.position).add(this.velocity); this.mesh.lookAt(lookTarget);
            }
            transformToTamed() { this.type = 'tamed'; this.isTamed = true; this.color = 0x22c55e; this.maxSpeed = 0.9; this.health = 50; this.mesh.material.color.setHex(this.color); createExplosion(this.position, 0x22c55e); }
            destroy() { scene.remove(this.mesh); this.mesh.geometry.dispose(); this.mesh.material.dispose(); }
        }
        const particles = [];
        function createExplosion(pos, color) {
            const particleCount = 10; const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2); const material = new THREE.MeshBasicMaterial({ color: color });
            for (let i = 0; i < particleCount; i++) {
                const mesh = new THREE.Mesh(geometry, material); mesh.position.copy(pos); mesh.position.x += (Math.random() - 0.5) * 2; mesh.position.z += (Math.random() - 0.5) * 2;
                const velocity = new THREE.Vector3((Math.random() - 0.5) * 0.5, Math.random() * 0.5, (Math.random() - 0.5) * 0.5); scene.add(mesh); particles.push({ mesh, velocity, life: 30 });
            }
        }
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i]; p.mesh.position.add(p.velocity); p.velocity.y -= 0.02; p.life--; p.mesh.rotation.x += 0.1; p.mesh.rotation.y += 0.1;
                if (p.life <= 0) { scene.remove(p.mesh); p.mesh.geometry.dispose(); particles.splice(i, 1); }
            }
        }
        let boids = []; let projectiles = []; let player; let gameActive = true;
        window.addEventListener('keydown', e => player.keys[e.key] = true); window.addEventListener('keyup', e => player.keys[e.key] = false);
        window.addEventListener('mousedown', e => {
            if (!gameActive) return;
            const mouse = new THREE.Vector2((e.clientX / window.innerWidth) * 2 - 1, -(e.clientY / window.innerHeight) * 2 + 1);
            const raycaster = new THREE.Raycaster(); raycaster.setFromCamera(mouse, camera); const intersects = raycaster.intersectObject(plane);
            if (intersects.length > 0) { const target = intersects[0].point; projectiles.push(new Projectile(player.position.x, player.position.z, target.x, target.z)); }
        });
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
        function initGame() {
            player = new Player();
            for (let i = 0; i < 80; i++) boids.push(new Boid((Math.random() - 0.5) * WORLD_SIZE, (Math.random() - 0.5) * WORLD_SIZE, 'wild'));
            spawnPredator(); updateUI(); animate();
        }
        function spawnPredator() {
            let x, z; do { x = (Math.random() - 0.5) * WORLD_SIZE; z = (Math.random() - 0.5) * WORLD_SIZE; } while (new THREE.Vector3(x, 0, z).distanceTo(player.position) < 60);
            boids.push(new Boid(x, z, 'predator')); showNotification("A Predator has appeared!");
        }
        function updateUI() {
            const wild = boids.filter(b => !b.isTamed && !b.isPredator).length; const tamed = boids.filter(b => b.isTamed).length; const preds = boids.filter(b => b.isPredator).length;
            document.getElementById('wild-count').textContent = wild; document.getElementById('swarm-count').textContent = tamed; document.getElementById('predator-count').textContent = preds;
        }
        function updateHealthUI() {
            const pct = (player.health / player.maxHealth) * 100; document.getElementById('player-hp-bar').style.width = \`\${pct}%\`; document.getElementById('hp-val').textContent = \`\${Math.ceil(pct)}%\`;
            if (pct < 30) document.getElementById('player-hp-bar').style.background = '#ef4444'; else document.getElementById('player-hp-bar').style.background = '#22c55e';
        }
        function showNotification(msg) { const el = document.getElementById('notification'); el.textContent = msg; el.style.opacity = 1; setTimeout(() => el.style.opacity = 0, 3000); }
        function gameOver(reason) { gameActive = false; document.getElementById('game-over').style.display = 'block'; document.getElementById('game-over-msg').textContent = reason; }
        function animate() {
            if (!gameActive) return; requestAnimationFrame(animate);
            player.update(); updateParticles();
            for (let i = projectiles.length - 1; i >= 0; i--) {
                let p = projectiles[i]; p.update(); if (!p.active) { projectiles.splice(i, 1); continue; }
                for (let boid of boids) { if (boid.type === 'wild' && p.position.distanceTo(boid.position) < 2) { boid.transformToTamed(); p.destroy(); updateUI(); break; } }
            }
            for (let i = boids.length - 1; i >= 0; i--) {
                let boid = boids[i]; boid.edges(); boid.behavior(boids, player); boid.update();
                if (boid.health <= 0) {
                    createExplosion(boid.position, boid.color);
                    if (boid.isPredator) { showNotification("Predator Defeated!"); boids.push(new Boid((Math.random()-0.5)*WORLD_SIZE, (Math.random()-0.5)*WORLD_SIZE, 'wild')); boids.push(new Boid((Math.random()-0.5)*WORLD_SIZE, (Math.random()-0.5)*WORLD_SIZE, 'wild')); setTimeout(spawnPredator, 5000); }
                    boid.destroy(); boids.splice(i, 1); updateUI();
                }
            }
            if (boids.filter(b => b.type === 'wild').length < 20 && Math.random() < 0.01) { boids.push(new Boid((Math.random()-0.5)*WORLD_SIZE, (Math.random()-0.5)*WORLD_SIZE, 'wild')); updateUI(); }
            renderer.render(scene, camera);
        }
        initGame();
    <\/script>
</body>
</html>`;

        function init() {
            // Create history chain
            const node1 = createNode(STAGE_1_CODE, null);
            const node2 = createNode(STAGE_2_CODE, node1.id);
            const node3 = createNode(STAGE_3_CODE, node2.id);
            
            state.rootId = node1.id;
            state.headId = node3.id;
            state.currentId = node3.id;
            state.branches[0] = { color: '#007acc', name: 'main', startNodeId: node1.id };
            
            updateEditor(node3.text);
            runCode();
            updateUI();
            
            // Start animation loop for 3D viz
            requestAnimationFrame(renderLoop);
        }

        function createNode(text, parentId) {
            const id = state.nodes.length;
            let branchId = 0;
            let x = 0, y = 0, z = 0;

            if (parentId !== null) {
                const parent = state.nodes[parentId];
                z = parent.z + 20; // Time progresses along Z
                
                // Branching logic
                if (parent.childrenIds.length > 0) {
                    // Parent already has a child, so this is a new branch
                    state.nextBranchId++;
                    branchId = state.nextBranchId;
                    
                    // Calculate position offset for new branch
                    // Simple spiral or alternating offset
                    const angle = (branchId * 0.5) + Math.PI / 2;
                    const radius = 40 + (branchId * 10);
                    x = parent.x + Math.cos(angle) * 20;
                    y = parent.y + Math.sin(angle) * 20;
                    
                    state.branches[branchId] = {
                        color: `hsl(${(branchId * 137.5) % 360}, 70%, 50%)`,
                        name: `experiment-${branchId}`,
                        startNodeId: id
                    };
                } else {
                    // Continue existing branch
                    branchId = parent.branchId;
                    x = parent.x;
                    y = parent.y;
                }
                
                parent.childrenIds.push(id);
            }

            const node = {
                id,
                text,
                timestamp: Date.now(),
                parentId,
                childrenIds: [],
                branchId,
                x, y, z
            };
            
            state.nodes.push(node);
            return node;
        }

        // --- Editor Logic ---
        let debounceTimer;
        editor.addEventListener('input', () => {
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(() => {
                handleCodeChange(editor.value);
            }, 1000); // Snapshot every 1s of inactivity
        });

        function handleCodeChange(newText) {
            const currentNode = state.nodes[state.currentId];
            
            // If text hasn't changed, do nothing
            if (newText === currentNode.text) return;

            // If we are not at the head of the current branch, we are forking history!
            // Or if we are at head, we just append.
            
            // Actually, "Time Travel" implies if I go back and edit, I create a new branch.
            // If I am at the head, I just extend the line.
            
            const newNode = createNode(newText, state.currentId);
            state.currentId = newNode.id;
            state.headId = newNode.id; // This node becomes the new head of whatever branch it's on
            
            if (state.isAutoRun) runCode();
            updateUI();
        }

        function runCode() {
            const code = editor.value;
            iframe.srcdoc = code;
        }

        function updateEditor(text) {
            editor.value = text;
            document.getElementById('char-count').textContent = `${text.length} chars`;
        }

        // --- Time Travel Logic ---
        scrubber.addEventListener('input', (e) => {
            const index = parseInt(e.target.value);
            const path = getPathToRoot(state.headId).reverse();
            if (path[index]) {
                const node = state.nodes[path[index]];
                travelTo(node.id, false); // Don't update scrubber while dragging it
            }
        });

        function travelTo(nodeId, updateScrubberVal = true) {
            state.currentId = nodeId;
            const node = state.nodes[nodeId];
            updateEditor(node.text);
            if (state.isAutoRun) runCode();
            
            // Update UI
            statusMsg.textContent = `Traveled to ${new Date(node.timestamp).toLocaleTimeString()}`;
            
            // Check if we can merge
            // We can merge if the current node is NOT an ancestor of the headNode of the branch we were working on?
            // Or simply: if we are on a different branch than the "main" one, show merge.
            // Let's simplify: If current node is not the head of its branch, or if it's a different branch.
            
            updateUI(updateScrubberVal);
        }

        function getPathToRoot(nodeId) {
            const path = [];
            let curr = state.nodes[nodeId];
            while (curr) {
                path.push(curr.id);
                if (curr.parentId === null) break;
                curr = state.nodes[curr.parentId];
            }
            return path;
        }

        function updateUI(updateScrubberVal = true) {
            const path = getPathToRoot(state.headId).reverse();
            
            scrubber.max = path.length - 1;
            
            // Find where currentId is in the current head's path
            // If currentId is NOT in the path, it means we are viewing a different branch history
            // but keeping the "head" as the reference for the scrubber.
            // This is confusing. Let's switch "head" to be the tip of the branch containing currentId.
            
            // Find the tip of the branch containing currentId
            // Actually, let's just find the path from currentId to root.
            const currentPath = getPathToRoot(state.currentId).reverse();
            
            if (updateScrubberVal) {
                scrubber.value = currentPath.length - 1;
                scrubber.max = currentPath.length - 1; // This might be misleading if we are in middle of history
                
                // Better: Scrubber represents the timeline of the CURRENT VIEWED BRANCH.
                // So we need to find the "tip" of the branch that currentId belongs to.
                // But a node can be part of multiple potential futures.
                // Let's just use the path to root as the linear timeline.
            }
            
            timeDisplay.textContent = new Date(state.nodes[state.currentId].timestamp).toLocaleTimeString();
            
            const branch = state.branches[state.nodes[state.currentId].branchId];
            branchInfo.textContent = `Branch: ${branch ? branch.name : 'unknown'}`;
            branchInfo.style.color = branch ? branch.color : '#fff';

            // Merge button logic
            // Show merge if we are NOT on the main branch (0) and we are at the tip of a branch
            // OR if we are just viewing a different reality.
            // Let's allow merging ANY node into the current "head" if they are different.
            // But "head" changes when we travel.
            // Let's define "Main" as branch 0. If we are on branch X and want to merge to Main?
            // Or simply: "Create New Branch from Here" is automatic on edit.
            // "Merge" usually means bring changes from B to A.
            // Let's implement "Merge to Main": if current branch != 0, show "Merge to Main".
            
            if (state.nodes[state.currentId].branchId !== 0) {
                mergeBtn.style.display = 'block';
                mergeBtn.textContent = "Merge to Main";
            } else {
                mergeBtn.style.display = 'none';
            }
        }

        function mergeBranch() {
            // Take current text and append to Main branch tip
            // Find tip of Main
            let mainTip = state.nodes[0];
            // Naive search for latest node on branch 0
            // Better: track tips.
            for(let i=state.nodes.length-1; i>=0; i--) {
                if (state.nodes[i].branchId === 0) {
                    mainTip = state.nodes[i];
                    break;
                }
            }
            
            // Create new node on Main with current text
            // This effectively merges the code state.
            // We need to set parent to mainTip
            
            // Special case: createNode uses parent to determine branch.
            // If we force parent to be mainTip, it will continue branch 0.
            
            const mergedText = editor.value; // The code we want to keep
            
            // We need to hack createNode or just manually do it to ensure it stays on branch 0
            // Actually createNode logic: if parent has children, it forks.
            // If mainTip already has children (e.g. we went back in time on main and forked),
            // then adding to mainTip will create a NEW branch, not continue branch 0.
            // This is correct behavior for a tree. "Main" is just a label for the first line.
            // If we merge, we want to bring the code back to the "mainline".
            
            // Let's just create a new node from mainTip.
            const newNode = createNode(mergedText, mainTip.id);
            
            // Force branchId to 0 to signify it's back on main?
            // Or just let it be a new branch that we rename "Merged Main"?
            // Let's force it for visual clarity if possible, or just let the tree grow.
            // Let's just let it grow.
            
            state.currentId = newNode.id;
            state.headId = newNode.id;
            travelTo(newNode.id);
            statusMsg.textContent = "Merged branch back to timeline!";
        }

        // --- 3D Visualization (Canvas) ---
        let camera = { x: 0, y: 0, z: 0, pitch: 0.2, yaw: 0.5, dist: 300 };
        let isDragging = false;
        let lastMouse = { x: 0, y: 0 };

        canvas.addEventListener('mousedown', e => {
            isDragging = true;
            lastMouse = { x: e.clientX, y: e.clientY };
        });
        
        window.addEventListener('mousemove', e => {
            if (isDragging) {
                const dx = e.clientX - lastMouse.x;
                const dy = e.clientY - lastMouse.y;
                camera.yaw -= dx * 0.01;
                camera.pitch -= dy * 0.01;
                lastMouse = { x: e.clientX, y: e.clientY };
            }
        });
        
        window.addEventListener('mouseup', () => isDragging = false);
        
        // Click to travel
        canvas.addEventListener('click', e => {
            if (isDragging) return; // Don't click if dragged
            
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            
            // Raycast or simple distance check to projected points
            // We need the projected points from the last render
            // Let's re-project to find closest node
            let closest = null;
            let minDist = 10; // Hit radius
            
            state.nodes.forEach(node => {
                const p = project(node.x, node.y, node.z);
                if (p.z > 0) { // In front of camera
                    const d = Math.hypot(p.x - mx, p.y - my);
                    if (d < minDist) {
                        minDist = d;
                        closest = node;
                    }
                }
            });
            
            if (closest) {
                travelTo(closest.id);
            }
        });

        // Wheel to zoom
        canvas.addEventListener('wheel', e => {
            e.preventDefault();
            camera.dist += e.deltaY * 0.5;
            if (camera.dist < 50) camera.dist = 50;
        });

        function project(x, y, z) {
            // Simple 3D projection
            // Translate to camera relative
            // We want to center the view on the current node or the tree center
            // Let's center on the "current" node but smooth it?
            // For now, center on 0,0,0 but camera moves.
            
            // Rotate point around origin based on camera yaw/pitch
            // Then translate by camera dist
            
            // Actually, standard lookAt camera is better.
            // Let's keep it simple: Camera orbits a target.
            // Target is the centroid or the current node.
            const target = state.nodes[state.currentId] || {x:0, y:0, z:0};
            
            // World space relative to target
            let wx = x - target.x;
            let wy = y - target.y;
            let wz = z - target.z;
            
            // Rotate Yaw (around Y)
            let x1 = wx * Math.cos(camera.yaw) - wz * Math.sin(camera.yaw);
            let z1 = wx * Math.sin(camera.yaw) + wz * Math.cos(camera.yaw);
            
            // Rotate Pitch (around X)
            let y2 = wy * Math.cos(camera.pitch) - z1 * Math.sin(camera.pitch);
            let z2 = wy * Math.sin(camera.pitch) + z1 * Math.cos(camera.pitch);
            
            // Translate away (camera distance)
            z2 += camera.dist;
            
            // Perspective project
            const fov = 300;
            if (z2 <= 0) return { x: -9999, y: -9999, z: -1 }; // Behind camera
            
            const scale = fov / z2;
            const px = x1 * scale + canvas.width / 2;
            const py = y2 * scale + canvas.height / 2;
            
            return { x: px, y: py, z: z2, scale };
        }

        function renderLoop() {
            // Resize canvas
            if (canvas.width !== canvas.offsetWidth || canvas.height !== canvas.offsetHeight) {
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
            }
            
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw connections
            ctx.lineWidth = 1;
            state.nodes.forEach(node => {
                if (node.parentId !== null) {
                    const parent = state.nodes[node.parentId];
                    const p1 = project(parent.x, parent.y, parent.z);
                    const p2 = project(node.x, node.y, node.z);
                    
                    if (p1.z > 0 && p2.z > 0) {
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        
                        // Color based on branch
                        const branch = state.branches[node.branchId];
                        ctx.strokeStyle = branch ? branch.color : '#555';
                        ctx.globalAlpha = 0.6;
                        ctx.stroke();
                        ctx.globalAlpha = 1.0;
                    }
                }
            });
            
            // Draw nodes
            // Sort by Z for painter's algorithm (furthest first)
            // Actually project returns z2 (distance from camera plane), larger is further?
            // Yes, z2 = z_rotated + dist. Larger z2 is further away.
            // We want to draw furthest first.
            
            const projectedNodes = state.nodes.map(n => {
                const p = project(n.x, n.y, n.z);
                return { ...n, px: p.x, py: p.y, pz: p.z, scale: p.scale };
            }).filter(n => n.pz > 0).sort((a, b) => b.pz - a.pz);
            
            projectedNodes.forEach(node => {
                const size = 4 * node.scale * (node.id === state.currentId ? 2 : 1);
                
                ctx.beginPath();
                ctx.arc(node.px, node.py, size, 0, Math.PI * 2);
                
                const branch = state.branches[node.branchId];
                ctx.fillStyle = node.id === state.currentId ? '#fff' : (branch ? branch.color : '#007acc');
                
                ctx.fill();
                
                // Glow for current
                if (node.id === state.currentId) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            });
            
            requestAnimationFrame(renderLoop);
        }

        // --- Utils ---
        function toggleAutoRun() {
            state.isAutoRun = !state.isAutoRun;
            document.getElementById('autorun-btn').textContent = `Auto-Run: ${state.isAutoRun ? 'ON' : 'OFF'}`;
        }

        function resetProject() {
            if(confirm("Delete all history and start over?")) {
                state.nodes = [];
                state.branches = {};
                state.nextBranchId = 0;
                init();
            }
        }
        
        function exportProject() {
            const data = JSON.stringify(state, null, 2);
            const blob = new Blob([data], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'time-travel-project.json';
            a.click();
        }

        function togglePlay() {
            if (state.isPlaying) {
                state.isPlaying = false;
                document.getElementById('play-btn').textContent = "▶ Play";
                return;
            }
            
            state.isPlaying = true;
            document.getElementById('play-btn').textContent = "⏸ Pause";
            
            const path = getPathToRoot(state.headId).reverse();
            let idx = path.indexOf(state.currentId);
            if (idx === -1 || idx === path.length - 1) idx = 0;
            
            const interval = setInterval(() => {
                if (!state.isPlaying || idx >= path.length) {
                    clearInterval(interval);
                    state.isPlaying = false;
                    document.getElementById('play-btn').textContent = "▶ Play";
                    return;
                }
                
                travelTo(path[idx]);
                idx++;
            }, 100);
        }

        // Start
        init();

    </script>
</body>
</html>
