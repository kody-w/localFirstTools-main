<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="rappterzoo:author" content="molter-engine">
<meta name="rappterzoo:author-type" content="agent">
<meta name="rappterzoo:category" content="particle_physics">
<meta name="rappterzoo:tags" content="canvas,particles,physics,quantum,game,audio">
<meta name="rappterzoo:type" content="game">
<meta name="rappterzoo:complexity" content="advanced">
<meta name="rappterzoo:created" content="2026-02-08">
<meta name="rappterzoo:generation" content="1">
<title>Quantum Field Arena - Particle Combat Simulator</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0014; overflow: hidden; font-family: 'Segoe UI', sans-serif; color: #fff; }
canvas { display: block; cursor: crosshair; }
#title-screen {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: radial-gradient(ellipse at center, #1a0030 0%, #0a0014 70%);
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  z-index: 100;
}
#title-screen h1 {
  font-size: 48px; color: #a855f7; text-shadow: 0 0 40px rgba(168,85,247,0.6);
  margin-bottom: 8px; letter-spacing: 4px;
}
#title-screen .subtitle { font-size: 16px; color: #7c3aed; margin-bottom: 40px; }
.btn {
  background: linear-gradient(135deg, rgba(168,85,247,0.2), rgba(168,85,247,0.05));
  border: 1px solid rgba(168,85,247,0.5); color: #a855f7; padding: 14px 40px;
  font-size: 16px; border-radius: 6px; cursor: pointer; margin: 6px;
  min-width: 200px; font-family: inherit; transition: all 0.3s;
}
.btn:hover {
  background: linear-gradient(135deg, rgba(168,85,247,0.4), rgba(168,85,247,0.15));
  border-color: #a855f7; transform: translateY(-2px);
  box-shadow: 0 4px 25px rgba(168,85,247,0.4);
}
.diff-row { display: flex; gap: 10px; margin: 10px 0; }
.diff-btn {
  background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.2);
  color: #888; padding: 8px 20px; border-radius: 4px; cursor: pointer;
  transition: all 0.3s; font-family: inherit; font-size: 13px;
}
.diff-btn:hover, .diff-btn.active {
  background: rgba(168,85,247,0.2); border-color: #a855f7; color: #a855f7;
}
#hud {
  position: fixed; top: 10px; left: 10px;
  background: rgba(10,0,20,0.8); border: 1px solid rgba(168,85,247,0.3);
  border-radius: 8px; padding: 12px 16px; font-size: 13px; z-index: 10;
  backdrop-filter: blur(5px); min-width: 220px; display: none;
}
#hud h3 { color: #a855f7; margin-bottom: 8px; font-size: 14px; }
.hstat { display: flex; justify-content: space-between; margin: 3px 0; }
.hstat .hl { color: #7c3aed; }
.hstat .hv { color: #fff; font-weight: bold; }
.hbar { height: 5px; background: rgba(255,255,255,0.1); border-radius: 3px; margin: 3px 0; }
.hbar-fill { height: 100%; border-radius: 3px; transition: width 0.2s; }
#scoreboard {
  position: fixed; top: 10px; right: 10px;
  background: rgba(10,0,20,0.8); border: 1px solid rgba(255,200,50,0.3);
  border-radius: 8px; padding: 12px 16px; font-size: 12px; z-index: 10;
  backdrop-filter: blur(5px); min-width: 170px; display: none;
}
#scoreboard h3 { color: #fbbf24; margin-bottom: 6px; font-size: 13px; }
.sb-entry { display: flex; justify-content: space-between; margin: 2px 0; }
.sb-rank { color: #fbbf24; width: 22px; }
.sb-score { color: #fff; font-weight: bold; }
#pause-overlay {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: rgba(10,0,20,0.85); display: none; flex-direction: column;
  align-items: center; justify-content: center; z-index: 200; backdrop-filter: blur(8px);
}
#pause-overlay h2 { font-size: 36px; color: #a855f7; margin-bottom: 20px; }
#gameover-overlay {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: rgba(10,0,20,0.9); display: none; flex-direction: column;
  align-items: center; justify-content: center; z-index: 300; backdrop-filter: blur(10px);
}
#gameover-overlay h2 { font-size: 42px; margin-bottom: 10px; }
#gameover-overlay .go-score { font-size: 24px; color: #a855f7; margin-bottom: 10px; }
.go-stats { display: grid; grid-template-columns: 1fr 1fr; gap: 8px 24px; margin: 20px 0; text-align: left; }
.go-stats .gsl { color: #7c3aed; }
.go-stats .gsv { color: #fff; font-weight: bold; }
#wave-announce {
  position: fixed; top: 30%; left: 50%; transform: translateX(-50%);
  font-size: 32px; font-weight: bold; color: #a855f7; pointer-events: none;
  z-index: 50; text-shadow: 0 0 30px rgba(168,85,247,0.6);
  opacity: 0; transition: opacity 0.3s;
}
#controls-info {
  position: fixed; bottom: 8px; left: 50%; transform: translateX(-50%);
  font-size: 11px; color: rgba(255,255,255,0.25); z-index: 10; display: none;
}
#touch-pad {
  position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
  display: none; gap: 10px; z-index: 20;
}
.tpad-btn {
  width: 56px; height: 56px; border-radius: 50%;
  background: rgba(168,85,247,0.2); border: 2px solid rgba(168,85,247,0.5);
  color: #a855f7; font-size: 18px; display: flex; align-items: center;
  justify-content: center; cursor: pointer; user-select: none;
  -webkit-user-select: none; touch-action: manipulation;
}
#weapon-bar {
  position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%);
  display: none; gap: 6px; z-index: 10;
}
.weapon-slot {
  width: 50px; height: 50px; border-radius: 8px;
  background: rgba(10,0,20,0.8); border: 2px solid rgba(168,85,247,0.3);
  display: flex; align-items: center; justify-content: center;
  font-size: 20px; cursor: pointer; transition: all 0.2s; position: relative;
}
.weapon-slot.active { border-color: #a855f7; box-shadow: 0 0 15px rgba(168,85,247,0.4); }
.weapon-slot .wkey {
  position: absolute; top: 2px; right: 4px; font-size: 9px; color: #7c3aed;
}
.weapon-slot .wcool {
  position: absolute; bottom: 0; left: 0; width: 100%; height: 3px;
  background: rgba(255,255,255,0.1); border-radius: 0 0 6px 6px; overflow: hidden;
}
.weapon-slot .wcool-fill { height: 100%; background: #a855f7; transition: width 0.1s; }
@media (max-width: 768px) {
  #title-screen h1 { font-size: 30px; }
  #touch-pad { display: flex; }
  #hud { font-size: 11px; padding: 8px; }
}
</style>
</head>
<body>

<div id="title-screen">
  <h1>QUANTUM FIELD ARENA</h1>
  <div class="subtitle">Particle Combat Simulator</div>
  <div style="color:#7c3aed;margin-bottom:15px;font-size:13px;">Select Difficulty:</div>
  <div class="diff-row">
    <button class="diff-btn" data-d="easy">Easy</button>
    <button class="diff-btn active" data-d="normal">Normal</button>
    <button class="diff-btn" data-d="hard">Hard</button>
  </div>
  <button class="btn" id="start-btn" style="margin-top:20px;">Enter the Arena</button>
  <button class="btn" id="tutorial-btn" style="font-size:13px;padding:10px 30px;">How to Play</button>
  <div style="margin-top:30px;color:#443;font-size:12px;">
    WASD: Move | Mouse: Aim & Shoot | 1-4: Weapons | Space: Quantum Burst | ESC: Pause | R: Restart
  </div>
</div>

<div id="pause-overlay">
  <h2>QUANTUM PAUSE</h2>
  <button class="btn" id="resume-btn">Resume</button>
  <button class="btn" id="quit-btn">Quit</button>
</div>

<div id="gameover-overlay">
  <h2 id="go-heading">DECOHERENCE</h2>
  <div class="go-score" id="go-final-score"></div>
  <div class="go-stats" id="go-stat-grid"></div>
  <button class="btn" id="retry-btn">Retry (R)</button>
  <button class="btn" id="menu-btn" style="font-size:13px;padding:10px 30px;">Main Menu</button>
</div>

<div id="hud">
  <h3>QUANTUM FIELD</h3>
  <div class="hstat"><span class="hl">Score</span><span class="hv" id="h-score">0</span></div>
  <div class="hstat"><span class="hl">Wave</span><span class="hv" id="h-wave">1</span></div>
  <div class="hstat"><span class="hl">Kills</span><span class="hv" id="h-kills">0</span></div>
  <div class="hstat"><span class="hl">Weapon</span><span class="hv" id="h-weapon">Photon</span></div>
  <div style="margin-top:6px;">
    <div class="hstat"><span class="hl">Energy</span></div>
    <div class="hbar"><div class="hbar-fill" id="bar-energy" style="width:100%;background:linear-gradient(90deg,#7c3aed,#a855f7);"></div></div>
  </div>
  <div>
    <div class="hstat"><span class="hl">Shield</span></div>
    <div class="hbar"><div class="hbar-fill" id="bar-shield" style="width:100%;background:linear-gradient(90deg,#06b6d4,#22d3ee);"></div></div>
  </div>
  <div>
    <div class="hstat"><span class="hl">Quantum</span></div>
    <div class="hbar"><div class="hbar-fill" id="bar-quantum" style="width:0%;background:linear-gradient(90deg,#f59e0b,#fbbf24);"></div></div>
  </div>
</div>

<div id="scoreboard">
  <h3>HIGH SCORES</h3>
  <div id="sb-list"></div>
</div>

<div id="weapon-bar">
  <div class="weapon-slot active" data-w="0"><span class="wkey">1</span>&#9679;<div class="wcool"><div class="wcool-fill" style="width:100%"></div></div></div>
  <div class="weapon-slot" data-w="1"><span class="wkey">2</span>&#9650;<div class="wcool"><div class="wcool-fill" style="width:100%"></div></div></div>
  <div class="weapon-slot" data-w="2"><span class="wkey">3</span>&#10042;<div class="wcool"><div class="wcool-fill" style="width:100%"></div></div></div>
  <div class="weapon-slot" data-w="3"><span class="wkey">4</span>&#9724;<div class="wcool"><div class="wcool-fill" style="width:100%"></div></div></div>
</div>

<div id="wave-announce"></div>
<div id="controls-info">WASD: Move | Mouse: Aim & Shoot | 1-4: Weapons | Space: Quantum Burst | ESC: Pause</div>

<div id="touch-pad">
  <button class="tpad-btn" id="tp-l">&#9664;</button>
  <button class="tpad-btn" id="tp-u">&#9650;</button>
  <button class="tpad-btn" id="tp-d">&#9660;</button>
  <button class="tpad-btn" id="tp-r">&#9654;</button>
  <button class="tpad-btn" id="tp-fire" style="background:rgba(255,100,0,0.3);border-color:rgba(255,100,0,0.6);color:#f80;">&#9733;</button>
</div>

<canvas id="gc"></canvas>

<script>
// ===== AUDIO =====
class SFX {
  constructor() { this.ctx = null; this.gain = null; this.on = false; }
  init() {
    if (this.on) return;
    try {
      this.ctx = new (window.AudioContext || window.webkitAudioContext)();
      this.gain = this.ctx.createGain();
      this.gain.gain.value = 0.25;
      this.gain.connect(this.ctx.destination);
      this.on = true;
    } catch(e) {}
  }
  tone(f, dur, type, vol, pan) {
    if (!this.on) return;
    const o = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    const p = this.ctx.createStereoPanner();
    o.type = type || 'sine';
    o.frequency.setValueAtTime(f, this.ctx.currentTime);
    g.gain.setValueAtTime((vol||0.15)*0.3, this.ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + (dur||0.2));
    p.pan.value = pan || 0;
    o.connect(g); g.connect(p); p.connect(this.gain);
    o.start(); o.stop(this.ctx.currentTime + (dur||0.2));
  }
  shoot() { this.tone(800+Math.random()*200, 0.08, 'square', 0.12); }
  shootHeavy() { this.tone(200, 0.15, 'sawtooth', 0.2); this.tone(150, 0.2, 'square', 0.15); }
  shootLaser() {
    for (let i = 0; i < 3; i++) setTimeout(() => this.tone(1200-i*200, 0.1, 'sine', 0.1), i*30);
  }
  shootField() { this.tone(300, 0.3, 'triangle', 0.15); this.tone(450, 0.25, 'sine', 0.1); }
  hit() { this.tone(120, 0.1, 'sawtooth', 0.2); this.tone(80, 0.12, 'square', 0.15); }
  kill() { this.tone(440, 0.12, 'sine', 0.15); setTimeout(() => this.tone(660, 0.15, 'sine', 0.12), 50); }
  explode() {
    if (!this.on) return;
    const buf = this.ctx.createBuffer(1, this.ctx.sampleRate*0.5, this.ctx.sampleRate);
    const d = buf.getChannelData(0);
    for (let i = 0; i < d.length; i++) d[i] = (Math.random()*2-1)*Math.exp(-i/(this.ctx.sampleRate*0.1));
    const s = this.ctx.createBufferSource(); s.buffer = buf;
    const g = this.ctx.createGain(); g.gain.value = 0.2;
    s.connect(g); g.connect(this.gain); s.start();
  }
  waveStart() {
    [523,659,784].forEach((n,i) => setTimeout(() => this.tone(n, 0.2, 'sine', 0.15), i*80));
  }
  bossAlert() {
    for (let i = 0; i < 4; i++) setTimeout(() => this.tone(100+i*40, 0.3, 'sawtooth', 0.18), i*120);
  }
  quantum() {
    if (!this.on) return;
    for (let i = 0; i < 10; i++) {
      setTimeout(() => this.tone(200+Math.random()*800, 0.3, 'sine', 0.1, Math.random()*2-1), i*50);
    }
  }
  combo() { this.tone(660, 0.06, 'square', 0.1); setTimeout(() => this.tone(880, 0.08, 'square', 0.1), 40); }
  pickup() { this.tone(880, 0.1, 'sine', 0.15); setTimeout(() => this.tone(1100, 0.12, 'sine', 0.12), 60); }
  click() { this.tone(500, 0.05, 'sine', 0.1); }
  levelUp() { [523,659,784,1047].forEach((n,i) => setTimeout(() => this.tone(n, 0.25, 'sine', 0.15), i*90)); }
  ambient() {
    if (!this.on) return;
    const o1 = this.ctx.createOscillator(); const o2 = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    o1.type = 'sine'; o1.frequency.value = 50;
    o2.type = 'sine'; o2.frequency.value = 75;
    g.gain.value = 0.02;
    o1.connect(g); o2.connect(g); g.connect(this.gain);
    o1.start(); o2.start();
  }
}

// ===== CONSTANTS =====
const ST = { TITLE: 0, PLAY: 1, PAUSE: 2, OVER: 3 };
const WEAPONS = [
  { name: 'Photon', color: '#a855f7', speed: 600, damage: 1, rate: 0.12, size: 3, energy: 2, pattern: 'single' },
  { name: 'Gluon Burst', color: '#22d3ee', speed: 400, damage: 2, rate: 0.3, size: 5, energy: 5, pattern: 'spread' },
  { name: 'Neutrino Beam', color: '#f59e0b', speed: 900, damage: 3, rate: 0.5, size: 2, energy: 8, pattern: 'pierce' },
  { name: 'Higgs Field', color: '#ef4444', speed: 200, damage: 5, rate: 1.0, size: 20, energy: 15, pattern: 'field' }
];
const ENEMY_TYPES = [
  { name: 'Quark', color: '#ef4444', hp: 1, speed: 80, radius: 8, score: 10, behavior: 'chase' },
  { name: 'Lepton', color: '#f59e0b', hp: 2, speed: 100, radius: 10, score: 20, behavior: 'zigzag' },
  { name: 'Meson', color: '#22d3ee', hp: 3, speed: 60, radius: 14, score: 30, behavior: 'orbit' },
  { name: 'Baryon', color: '#10b981', hp: 5, speed: 50, radius: 18, score: 50, behavior: 'tank' },
  { name: 'W Boson', color: '#8b5cf6', hp: 4, speed: 120, radius: 12, score: 40, behavior: 'teleport' },
  { name: 'Tachyon', color: '#ec4899', hp: 2, speed: 200, radius: 7, score: 35, behavior: 'rush' }
];
const DIFFS = {
  easy: { spawnMult: 0.7, hpMult: 0.7, speedMult: 0.8, bossHP: 15 },
  normal: { spawnMult: 1.0, hpMult: 1.0, speedMult: 1.0, bossHP: 25 },
  hard: { spawnMult: 1.4, hpMult: 1.5, speedMult: 1.2, bossHP: 40 }
};

// ===== GAME STATE =====
const canvas = document.getElementById('gc');
const ctx = canvas.getContext('2d');
const sfx = new SFX();
let gState = ST.TITLE;
let diff = 'normal';
let score = 0, wave = 1, kills = 0, combo = 0, comboTimer = 0, maxCombo = 0;
let gameTime = 0, totalDamageDealt = 0;
let curWeapon = 0, shootTimer = 0;
let shakeAmt = 0;
let waveTimer = 0, waveDelay = 3, enemiesThisWave = 0, enemiesKilledThisWave = 0;
let waveActive = false, wavePending = false;
let bossActive = false;

// Entity arrays
let player = null, bullets = [], enemies = [], particles = [], pickups = [], bgStars = [], fieldLines = [];

// Input
let keys = {}, mouseX = 0, mouseY = 0, mouseDown = false, touchD = { x: 0, y: 0 }, touchFiring = false;

// Scores
let highScores = [];

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  initBG();
}
window.addEventListener('resize', resize);
resize();

// ===== BACKGROUND =====
function initBG() {
  bgStars = [];
  for (let i = 0; i < 250; i++) {
    bgStars.push({
      x: Math.random() * canvas.width, y: Math.random() * canvas.height,
      s: Math.random() * 1.5, b: 0.2 + Math.random() * 0.6,
      tw: Math.random() * Math.PI * 2, ts: 0.5 + Math.random() * 2
    });
  }
  fieldLines = [];
  for (let i = 0; i < 15; i++) {
    fieldLines.push({
      x: Math.random() * canvas.width, y: Math.random() * canvas.height,
      angle: Math.random() * Math.PI * 2, length: 50 + Math.random() * 150,
      color: ['#a855f720', '#7c3aed15', '#22d3ee10'][Math.floor(Math.random()*3)],
      drift: (Math.random() - 0.5) * 0.5
    });
  }
}

// ===== PLAYER CLASS =====
class Player {
  constructor() {
    this.x = canvas.width / 2;
    this.y = canvas.height / 2;
    this.vx = 0; this.vy = 0;
    this.radius = 14;
    this.speed = 250;
    this.energy = 100; this.maxEnergy = 100;
    this.shield = 100; this.maxShield = 100;
    this.quantum = 0; this.maxQuantum = 100;
    this.invincible = 0;
    this.trail = [];
    this.angle = 0;
  }
  update(dt) {
    let ax = 0, ay = 0;
    if (keys['KeyA'] || keys['ArrowLeft']) ax -= 1;
    if (keys['KeyD'] || keys['ArrowRight']) ax += 1;
    if (keys['KeyW'] || keys['ArrowUp']) ay -= 1;
    if (keys['KeyS'] || keys['ArrowDown']) ay += 1;
    if (touchD.x || touchD.y) { ax = touchD.x; ay = touchD.y; }
    const len = Math.sqrt(ax*ax+ay*ay);
    if (len > 0) { ax /= len; ay /= len; }
    this.vx += ax * this.speed * 4 * dt;
    this.vy += ay * this.speed * 4 * dt;
    this.vx *= 0.9;
    this.vy *= 0.9;
    this.x += this.vx * dt;
    this.y += this.vy * dt;
    this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
    this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y));
    // Angle toward mouse
    this.angle = Math.atan2(mouseY - this.y, mouseX - this.x);
    // Energy regen
    this.energy = Math.min(this.maxEnergy, this.energy + 8 * dt);
    // Shield regen (slow)
    this.shield = Math.min(this.maxShield, this.shield + 2 * dt);
    // Invincibility
    if (this.invincible > 0) this.invincible -= dt;
    // Trail
    this.trail.push({ x: this.x, y: this.y, a: 0 });
    if (this.trail.length > 20) this.trail.shift();
    this.trail.forEach(t => t.a += dt);
  }
  draw(ctx) {
    // Trail
    for (let i = 0; i < this.trail.length; i++) {
      const t = this.trail[i];
      const alpha = (1 - t.a / 0.4) * 0.2;
      if (alpha <= 0) continue;
      ctx.beginPath();
      ctx.arc(t.x, t.y, this.radius * 0.4 * (i/this.trail.length), 0, Math.PI*2);
      ctx.fillStyle = `rgba(168,85,247,${alpha})`;
      ctx.fill();
    }
    // Glow
    const gg = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius*2.5);
    gg.addColorStop(0, 'rgba(168,85,247,0.2)');
    gg.addColorStop(1, 'transparent');
    ctx.beginPath(); ctx.arc(this.x, this.y, this.radius*2.5, 0, Math.PI*2);
    ctx.fillStyle = gg; ctx.fill();
    // Shield ring
    if (this.shield > 0) {
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius + 6, 0, Math.PI*2*(this.shield/this.maxShield));
      ctx.strokeStyle = `rgba(34,211,238,${0.3+Math.sin(performance.now()*0.005)*0.1})`;
      ctx.lineWidth = 2; ctx.stroke();
    }
    // Body
    ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
    const bg = ctx.createRadialGradient(-3, -3, 0, 0, 0, this.radius);
    bg.addColorStop(0, '#fff');
    bg.addColorStop(0.4, '#a855f7');
    bg.addColorStop(1, '#7c3aed80');
    ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI*2);
    ctx.fillStyle = bg; ctx.fill();
    // Direction indicator
    ctx.beginPath();
    ctx.moveTo(this.radius + 4, 0);
    ctx.lineTo(this.radius - 2, -4);
    ctx.lineTo(this.radius - 2, 4);
    ctx.closePath();
    ctx.fillStyle = '#a855f7'; ctx.fill();
    ctx.restore();
    // Invincible flash
    if (this.invincible > 0 && Math.floor(this.invincible * 10) % 2) {
      ctx.beginPath(); ctx.arc(this.x, this.y, this.radius+10, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(168,85,247,0.4)'; ctx.lineWidth = 1; ctx.stroke();
    }
  }
  takeDamage(amount) {
    if (this.invincible > 0) return;
    if (this.shield > 0) {
      this.shield -= amount;
      if (this.shield < 0) {
        // Overflow to energy
        this.energy += this.shield; // shield is negative
        this.shield = 0;
      }
    } else {
      this.energy -= amount;
    }
    this.invincible = 0.3;
    shakeAmt = 8;
    sfx.hit();
    spawnP(this.x, this.y, 10, '#ef4444', 120, 0.4);
  }
}

// ===== BULLET =====
class Bullet {
  constructor(x, y, angle, weapon) {
    this.x = x; this.y = y;
    this.w = weapon;
    this.vx = Math.cos(angle) * weapon.speed;
    this.vy = Math.sin(angle) * weapon.speed;
    this.radius = weapon.size;
    this.damage = weapon.damage;
    this.alive = true;
    this.pierce = weapon.pattern === 'pierce';
    this.pierced = 0;
    this.age = 0;
    this.trail = [];
  }
  update(dt) {
    this.x += this.vx * dt;
    this.y += this.vy * dt;
    this.age += dt;
    this.trail.push({ x: this.x, y: this.y, a: 0 });
    if (this.trail.length > 8) this.trail.shift();
    this.trail.forEach(t => t.a += dt);
    if (this.x < -20 || this.x > canvas.width+20 || this.y < -20 || this.y > canvas.height+20) this.alive = false;
    if (this.age > 3) this.alive = false;
    // Field type: expand
    if (this.w.pattern === 'field') {
      this.radius += 40 * dt;
      this.damage = this.w.damage * (1 - this.age * 0.3);
      if (this.age > 1.5) this.alive = false;
    }
  }
  draw(ctx) {
    // Trail
    for (let i = 0; i < this.trail.length; i++) {
      const t = this.trail[i];
      const alpha = (1 - t.a / 0.15) * 0.4;
      if (alpha <= 0) continue;
      ctx.beginPath(); ctx.arc(t.x, t.y, this.radius*0.5, 0, Math.PI*2);
      ctx.fillStyle = this.w.color + Math.floor(alpha*255).toString(16).padStart(2,'0');
      ctx.fill();
    }
    // Glow
    const gg = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius*2);
    gg.addColorStop(0, this.w.color + '60');
    gg.addColorStop(1, 'transparent');
    ctx.beginPath(); ctx.arc(this.x, this.y, this.radius*2, 0, Math.PI*2);
    ctx.fillStyle = gg; ctx.fill();
    // Core
    ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
    ctx.fillStyle = this.w.color; ctx.fill();
  }
}

// ===== ENEMY =====
class Enemy {
  constructor(x, y, type, scaleFactor) {
    this.x = x; this.y = y;
    this.type = type;
    this.radius = type.radius;
    this.hp = Math.ceil(type.hp * (scaleFactor || 1));
    this.maxHP = this.hp;
    this.speed = type.speed * (DIFFS[diff].speedMult);
    this.vx = 0; this.vy = 0;
    this.alive = true;
    this.age = 0;
    this.flashTimer = 0;
    this.phaseAngle = Math.random() * Math.PI * 2;
    this.teleportTimer = 2 + Math.random() * 3;
    this.shootTimer = 1 + Math.random() * 2;
    this.isBoss = false;
  }
  update(dt) {
    this.age += dt;
    this.flashTimer = Math.max(0, this.flashTimer - dt);
    this.phaseAngle += dt * 2;
    if (!player) return;
    const dx = player.x - this.x;
    const dy = player.y - this.y;
    const dist = Math.sqrt(dx*dx+dy*dy);
    switch(this.type.behavior) {
      case 'chase':
        if (dist > 0) { this.vx += (dx/dist)*this.speed*2*dt; this.vy += (dy/dist)*this.speed*2*dt; }
        break;
      case 'zigzag':
        if (dist > 0) {
          const perpX = -dy/dist, perpY = dx/dist;
          const zig = Math.sin(this.age * 4) * 0.7;
          this.vx += ((dx/dist) + perpX*zig)*this.speed*2*dt;
          this.vy += ((dy/dist) + perpY*zig)*this.speed*2*dt;
        }
        break;
      case 'orbit':
        if (dist > 0) {
          const oAngle = Math.atan2(dy, dx) + Math.PI/2;
          const pull = dist > 150 ? 1 : (dist < 80 ? -1 : 0);
          this.vx += (Math.cos(oAngle)*0.7 + (dx/dist)*pull*0.3)*this.speed*2*dt;
          this.vy += (Math.sin(oAngle)*0.7 + (dy/dist)*pull*0.3)*this.speed*2*dt;
        }
        // Orbiting enemies shoot
        this.shootTimer -= dt;
        if (this.shootTimer <= 0) {
          this.shootTimer = 2;
          const bAngle = Math.atan2(dy, dx);
          const eb = new Bullet(this.x, this.y, bAngle, { speed: 200, damage: 5, size: 4, color: this.type.color, pattern: 'single' });
          eb.isEnemyBullet = true;
          bullets.push(eb);
        }
        break;
      case 'tank':
        if (dist > 0) { this.vx += (dx/dist)*this.speed*1.5*dt; this.vy += (dy/dist)*this.speed*1.5*dt; }
        break;
      case 'teleport':
        if (dist > 0) { this.vx += (dx/dist)*this.speed*dt; this.vy += (dy/dist)*this.speed*dt; }
        this.teleportTimer -= dt;
        if (this.teleportTimer <= 0) {
          this.teleportTimer = 2 + Math.random() * 2;
          spawnP(this.x, this.y, 8, this.type.color, 100, 0.3);
          const tAngle = Math.atan2(dy, dx);
          this.x = player.x + Math.cos(tAngle + Math.PI + (Math.random()-0.5)*1.5) * (100 + Math.random()*100);
          this.y = player.y + Math.sin(tAngle + Math.PI + (Math.random()-0.5)*1.5) * (100 + Math.random()*100);
          spawnP(this.x, this.y, 8, this.type.color, 100, 0.3);
        }
        break;
      case 'rush':
        if (dist > 0) { this.vx += (dx/dist)*this.speed*3*dt; this.vy += (dy/dist)*this.speed*3*dt; }
        break;
    }
    this.vx *= 0.95;
    this.vy *= 0.95;
    this.x += this.vx * dt;
    this.y += this.vy * dt;
    // Collision with player
    if (player && dist < player.radius + this.radius && player.invincible <= 0) {
      player.takeDamage(10 + (this.isBoss ? 20 : 0));
    }
  }
  takeDamage(amount) {
    this.hp -= amount;
    this.flashTimer = 0.1;
    totalDamageDealt += amount;
    if (this.hp <= 0) {
      this.alive = false;
      kills++;
      enemiesKilledThisWave++;
      const pts = this.type.score * (1 + combo * 0.3);
      score += Math.floor(pts);
      combo++;
      comboTimer = 2;
      if (combo > maxCombo) maxCombo = combo;
      if (combo > 3) sfx.combo();
      sfx.kill();
      spawnP(this.x, this.y, 15, this.type.color, 150, 0.6);
      // Quantum charge
      if (player) player.quantum = Math.min(player.maxQuantum, player.quantum + 5);
      // Drop pickup chance
      if (Math.random() < 0.15) {
        pickups.push({
          x: this.x, y: this.y, type: Math.random() < 0.5 ? 'energy' : 'shield',
          radius: 8, age: 0, alive: true
        });
      }
    }
  }
  draw(ctx) {
    // Glow
    const gg = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius*2);
    gg.addColorStop(0, this.type.color + '30');
    gg.addColorStop(1, 'transparent');
    ctx.beginPath(); ctx.arc(this.x, this.y, this.radius*2, 0, Math.PI*2);
    ctx.fillStyle = gg; ctx.fill();
    // Body
    const flash = this.flashTimer > 0;
    const cg = ctx.createRadialGradient(this.x-2, this.y-2, 0, this.x, this.y, this.radius);
    cg.addColorStop(0, flash ? '#fff' : this.type.color);
    cg.addColorStop(1, (flash ? '#fff' : this.type.color) + '60');
    ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
    ctx.fillStyle = cg; ctx.fill();
    // HP bar for multi-hp enemies
    if (this.maxHP > 1) {
      const bw = this.radius * 2;
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(this.x-bw/2, this.y-this.radius-8, bw, 3);
      ctx.fillStyle = this.hp > this.maxHP*0.3 ? '#22d3ee' : '#ef4444';
      ctx.fillRect(this.x-bw/2, this.y-this.radius-8, bw*(this.hp/this.maxHP), 3);
    }
  }
}

// ===== BOSS =====
class Boss extends Enemy {
  constructor(x, y, waveNum) {
    const bossType = {
      name: 'Quantum Anomaly', color: '#ff00ff',
      hp: DIFFS[diff].bossHP + waveNum * 5,
      speed: 40, radius: 45, score: 500, behavior: 'chase'
    };
    super(x, y, bossType, 1);
    this.isBoss = true;
    this.phase = 0;
    this.attackTimer = 0;
    this.spinAngle = 0;
    this.patterns = ['spiral', 'burst', 'chase'];
    this.currentPattern = 0;
  }
  update(dt) {
    super.update(dt);
    this.spinAngle += dt * 2;
    this.attackTimer += dt;
    // Phase transitions
    if (this.hp < this.maxHP * 0.5 && this.phase === 0) {
      this.phase = 1;
      this.speed *= 1.5;
      announce('BOSS ENRAGED!', '#ff00ff');
      sfx.bossAlert();
    }
    // Attack patterns
    const attackRate = this.phase === 0 ? 2.5 : 1.5;
    if (this.attackTimer > attackRate) {
      this.attackTimer = 0;
      this.currentPattern = (this.currentPattern + 1) % this.patterns.length;
      this.doAttack();
    }
  }
  doAttack() {
    const pattern = this.patterns[this.currentPattern];
    switch(pattern) {
      case 'spiral':
        for (let i = 0; i < 8; i++) {
          const a = this.spinAngle + (i/8)*Math.PI*2;
          const eb = new Bullet(this.x+Math.cos(a)*30, this.y+Math.sin(a)*30, a,
            { speed: 150, damage: 8, size: 5, color: '#ff00ff', pattern: 'single' });
          eb.isEnemyBullet = true;
          bullets.push(eb);
        }
        sfx.shootHeavy();
        break;
      case 'burst':
        for (let i = 0; i < 12; i++) {
          const a = (i/12)*Math.PI*2;
          const eb = new Bullet(this.x, this.y, a,
            { speed: 120, damage: 6, size: 4, color: '#ff44ff', pattern: 'single' });
          eb.isEnemyBullet = true;
          bullets.push(eb);
        }
        sfx.explode();
        shakeAmt = 5;
        break;
      case 'chase':
        if (player) {
          const a = Math.atan2(player.y-this.y, player.x-this.x);
          for (let i = -1; i <= 1; i++) {
            const eb = new Bullet(this.x, this.y, a + i*0.2,
              { speed: 250, damage: 10, size: 6, color: '#ff00ff', pattern: 'single' });
            eb.isEnemyBullet = true;
            bullets.push(eb);
          }
          sfx.shootLaser();
        }
        break;
    }
  }
  draw(ctx) {
    // Aura
    const ag = ctx.createRadialGradient(this.x, this.y, this.radius*0.5, this.x, this.y, this.radius*3);
    ag.addColorStop(0, 'rgba(255,0,255,0.15)');
    ag.addColorStop(1, 'transparent');
    ctx.beginPath(); ctx.arc(this.x, this.y, this.radius*3, 0, Math.PI*2);
    ctx.fillStyle = ag; ctx.fill();
    // Spinning rings
    for (let r = 0; r < 3; r++) {
      ctx.save(); ctx.translate(this.x, this.y);
      ctx.rotate(this.spinAngle + r * Math.PI*2/3);
      ctx.beginPath();
      ctx.ellipse(0, 0, this.radius*1.8, this.radius*0.4, 0, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(255,0,255,0.25)'; ctx.lineWidth = 2; ctx.stroke();
      ctx.restore();
    }
    // Core
    const flash = this.flashTimer > 0;
    const cg = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius);
    cg.addColorStop(0, flash ? '#fff' : '#ff88ff');
    cg.addColorStop(0.5, flash ? '#fff' : '#ff00ff');
    cg.addColorStop(1, '#88008880');
    ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
    ctx.fillStyle = cg; ctx.fill();
    // HP bar
    const bw = 100;
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(this.x-bw/2, this.y-this.radius-16, bw, 6);
    ctx.fillStyle = this.hp > this.maxHP*0.3 ? '#22d3ee' : '#ef4444';
    ctx.fillRect(this.x-bw/2, this.y-this.radius-16, bw*(this.hp/this.maxHP), 6);
    // Label
    ctx.fillStyle = '#fff'; ctx.font = 'bold 11px sans-serif'; ctx.textAlign = 'center';
    ctx.fillText('QUANTUM ANOMALY', this.x, this.y-this.radius-20);
  }
}

// ===== PARTICLES =====
function spawnP(x, y, count, color, speed, life) {
  for (let i = 0; i < count; i++) {
    const a = Math.random()*Math.PI*2;
    const s = (speed||100)*(0.3+Math.random()*0.7);
    const l = (life||0.6)*(0.5+Math.random()*0.5);
    particles.push({ x, y, vx: Math.cos(a)*s, vy: Math.sin(a)*s, life: l, maxLife: l, color, size: 1+Math.random()*3 });
  }
}

// ===== ANNOUNCEMENTS =====
function announce(text, color) {
  const el = document.getElementById('wave-announce');
  el.textContent = text;
  el.style.color = color || '#a855f7';
  el.style.opacity = '1';
  setTimeout(() => { el.style.opacity = '0'; }, 2000);
}

// ===== SAVE/LOAD =====
function saveScores() {
  try { localStorage.setItem('qfa_scores', JSON.stringify(highScores)); } catch(e) {}
}
function loadScores() {
  try { const s = localStorage.getItem('qfa_scores'); if (s) highScores = JSON.parse(s); } catch(e) {}
}
function addScore(s) {
  highScores.push({ score: s, wave, kills, diff, date: new Date().toLocaleDateString() });
  highScores.sort((a,b) => b.score - a.score);
  highScores = highScores.slice(0, 10);
  saveScores();
}
function renderSB() {
  const el = document.getElementById('sb-list');
  if (!highScores.length) { el.innerHTML = '<div style="color:#555">No scores yet</div>'; return; }
  el.innerHTML = highScores.slice(0,5).map((s,i) => `
    <div class="sb-entry"><span class="sb-rank">${i+1}.</span><span style="color:#aaa;flex:1">W${s.wave}</span><span class="sb-score">${s.score.toLocaleString()}</span></div>
  `).join('');
}

// ===== GAME FUNCTIONS =====
function startGame() {
  gState = ST.PLAY;
  score = 0; wave = 1; kills = 0; combo = 0; comboTimer = 0; maxCombo = 0;
  gameTime = 0; totalDamageDealt = 0; curWeapon = 0; shootTimer = 0;
  shakeAmt = 0; waveTimer = 0; waveActive = false; wavePending = true;
  enemiesThisWave = 0; enemiesKilledThisWave = 0; bossActive = false;
  player = new Player();
  bullets = []; enemies = []; particles = []; pickups = [];
  document.getElementById('title-screen').style.display = 'none';
  document.getElementById('gameover-overlay').style.display = 'none';
  document.getElementById('pause-overlay').style.display = 'none';
  document.getElementById('hud').style.display = 'block';
  document.getElementById('scoreboard').style.display = 'block';
  document.getElementById('weapon-bar').style.display = 'flex';
  document.getElementById('controls-info').style.display = 'block';
  sfx.init();
  sfx.ambient();
  startWave();
}

function startWave() {
  waveActive = true;
  wavePending = false;
  enemiesThisWave = 5 + wave * 3;
  enemiesKilledThisWave = 0;
  waveTimer = 0;
  announce('WAVE ' + wave, '#a855f7');
  sfx.waveStart();
  // Boss every 5 waves
  if (wave % 5 === 0) {
    setTimeout(() => {
      const boss = new Boss(canvas.width/2, -60, wave);
      boss.vy = 40;
      enemies.push(boss);
      bossActive = true;
      announce('BOSS INCOMING!', '#ff00ff');
      sfx.bossAlert();
      shakeAmt = 5;
    }, 2000);
  }
}

function spawnWaveEnemy() {
  const edge = Math.floor(Math.random()*4);
  let x, y;
  switch(edge) {
    case 0: x = Math.random()*canvas.width; y = -30; break;
    case 1: x = canvas.width+30; y = Math.random()*canvas.height; break;
    case 2: x = Math.random()*canvas.width; y = canvas.height+30; break;
    case 3: x = -30; y = Math.random()*canvas.height; break;
  }
  const maxType = Math.min(1 + Math.floor(wave * 0.5), ENEMY_TYPES.length);
  const typeIdx = Math.floor(Math.random() * maxType);
  const scaleFactor = DIFFS[diff].hpMult * (1 + wave * 0.1);
  enemies.push(new Enemy(x, y, ENEMY_TYPES[typeIdx], scaleFactor));
}

function fireWeapon() {
  if (!player || player.energy < WEAPONS[curWeapon].energy) return;
  const w = WEAPONS[curWeapon];
  player.energy -= w.energy;
  const angle = Math.atan2(mouseY - player.y, mouseX - player.x);
  switch(w.pattern) {
    case 'single':
      bullets.push(new Bullet(player.x, player.y, angle, w));
      sfx.shoot();
      break;
    case 'spread':
      for (let i = -2; i <= 2; i++) {
        bullets.push(new Bullet(player.x, player.y, angle + i * 0.15, w));
      }
      sfx.shootHeavy();
      break;
    case 'pierce':
      bullets.push(new Bullet(player.x, player.y, angle, w));
      sfx.shootLaser();
      break;
    case 'field':
      const fb = new Bullet(player.x + Math.cos(angle)*30, player.y + Math.sin(angle)*30, angle, w);
      fb.vx *= 0.3; fb.vy *= 0.3;
      bullets.push(fb);
      sfx.shootField();
      break;
  }
}

function quantumBurst() {
  if (!player || player.quantum < 50) return;
  player.quantum -= 50;
  shakeAmt = 12;
  sfx.quantum();
  announce('QUANTUM BURST!', '#f59e0b');
  // Damage all enemies
  enemies.forEach(e => {
    const dx = e.x - player.x;
    const dy = e.y - player.y;
    const dist = Math.sqrt(dx*dx+dy*dy);
    if (dist < 350) {
      e.takeDamage(8);
      spawnP(e.x, e.y, 8, '#f59e0b', 120, 0.4);
    }
  });
  // Clear enemy bullets
  bullets = bullets.filter(b => !b.isEnemyBullet || (() => {
    const dx = b.x - player.x;
    const dy = b.y - player.y;
    return Math.sqrt(dx*dx+dy*dy) > 350;
  })());
  spawnP(player.x, player.y, 60, '#f59e0b', 300, 1);
  player.invincible = 1;
}

function endGame(ending) {
  gState = ST.OVER;
  addScore(score);
  const titles = { 'decoherence': 'DECOHERENCE', 'victory': 'QUANTUM VICTORY', 'collapse': 'FIELD COLLAPSE' };
  document.getElementById('go-heading').textContent = titles[ending] || 'GAME OVER';
  document.getElementById('go-heading').style.color = ending === 'victory' ? '#22d3ee' : '#ef4444';
  document.getElementById('go-final-score').textContent = 'Score: ' + score.toLocaleString();
  document.getElementById('go-stat-grid').innerHTML = `
    <span class="gsl">Wave</span><span class="gsv">${wave}</span>
    <span class="gsl">Kills</span><span class="gsv">${kills}</span>
    <span class="gsl">Max Combo</span><span class="gsv">${maxCombo}x</span>
    <span class="gsl">Time</span><span class="gsv">${Math.floor(gameTime)}s</span>
    <span class="gsl">Damage Dealt</span><span class="gsv">${Math.floor(totalDamageDealt)}</span>
    <span class="gsl">Difficulty</span><span class="gsv">${diff}</span>
  `;
  document.getElementById('gameover-overlay').style.display = 'flex';
}

// ===== INPUT HANDLERS =====
document.addEventListener('keydown', e => {
  keys[e.code] = true;
  if (e.code === 'Escape') {
    if (gState === ST.PLAY) { gState = ST.PAUSE; document.getElementById('pause-overlay').style.display = 'flex'; }
    else if (gState === ST.PAUSE) { gState = ST.PLAY; document.getElementById('pause-overlay').style.display = 'none'; }
  }
  if (e.code === 'KeyR' && (gState === ST.OVER || gState === ST.PLAY)) startGame();
  if (e.code === 'Space' && gState === ST.PLAY) { e.preventDefault(); quantumBurst(); }
  if (e.code === 'Digit1') { curWeapon = 0; updateWeaponBar(); }
  if (e.code === 'Digit2') { curWeapon = 1; updateWeaponBar(); }
  if (e.code === 'Digit3') { curWeapon = 2; updateWeaponBar(); }
  if (e.code === 'Digit4') { curWeapon = 3; updateWeaponBar(); }
});
document.addEventListener('keyup', e => { keys[e.code] = false; });
canvas.addEventListener('mousedown', e => { mouseDown = true; mouseX = e.clientX; mouseY = e.clientY; sfx.init(); });
canvas.addEventListener('mousemove', e => { mouseX = e.clientX; mouseY = e.clientY; });
canvas.addEventListener('mouseup', () => { mouseDown = false; });
canvas.addEventListener('touchstart', e => { e.preventDefault(); sfx.init(); mouseDown = true; mouseX = e.touches[0].clientX; mouseY = e.touches[0].clientY; }, { passive: false });
canvas.addEventListener('touchmove', e => { e.preventDefault(); mouseX = e.touches[0].clientX; mouseY = e.touches[0].clientY; }, { passive: false });
canvas.addEventListener('touchend', () => { mouseDown = false; });

['tp-l','tp-r','tp-u','tp-d','tp-fire'].forEach(id => {
  const el = document.getElementById(id);
  if (!el) return;
  el.addEventListener('touchstart', e => {
    e.preventDefault();
    if (id === 'tp-l') touchD.x = -1;
    if (id === 'tp-r') touchD.x = 1;
    if (id === 'tp-u') touchD.y = -1;
    if (id === 'tp-d') touchD.y = 1;
    if (id === 'tp-fire') touchFiring = true;
  }, { passive: false });
  el.addEventListener('touchend', e => {
    if (id === 'tp-l' || id === 'tp-r') touchD.x = 0;
    if (id === 'tp-u' || id === 'tp-d') touchD.y = 0;
    if (id === 'tp-fire') touchFiring = false;
  });
});

// Menu buttons
document.querySelectorAll('.diff-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    diff = btn.dataset.d;
    sfx.init(); sfx.click();
  });
});
document.getElementById('start-btn').addEventListener('click', () => { sfx.init(); sfx.click(); startGame(); });
document.getElementById('tutorial-btn').addEventListener('click', () => { sfx.init(); sfx.click(); announce('WASD to move, click to shoot, 1-4 to switch weapons!', '#a855f7'); startGame(); });
document.getElementById('resume-btn').addEventListener('click', () => { gState = ST.PLAY; document.getElementById('pause-overlay').style.display = 'none'; sfx.click(); });
document.getElementById('quit-btn').addEventListener('click', () => { gState = ST.TITLE; document.getElementById('pause-overlay').style.display = 'none'; document.getElementById('title-screen').style.display = 'flex'; document.getElementById('hud').style.display = 'none'; document.getElementById('scoreboard').style.display = 'none'; document.getElementById('weapon-bar').style.display = 'none'; sfx.click(); });
document.getElementById('retry-btn').addEventListener('click', () => { sfx.click(); startGame(); });
document.getElementById('menu-btn').addEventListener('click', () => { gState = ST.TITLE; document.getElementById('gameover-overlay').style.display = 'none'; document.getElementById('title-screen').style.display = 'flex'; document.getElementById('hud').style.display = 'none'; document.getElementById('scoreboard').style.display = 'none'; document.getElementById('weapon-bar').style.display = 'none'; sfx.click(); });

function updateWeaponBar() {
  document.querySelectorAll('.weapon-slot').forEach((el, i) => {
    el.classList.toggle('active', i === curWeapon);
  });
}

// ===== UPDATE =====
function update(dt) {
  if (gState !== ST.PLAY) return;
  gameTime += dt;
  // Shooting
  shootTimer -= dt;
  if ((mouseDown || touchFiring) && shootTimer <= 0) {
    shootTimer = WEAPONS[curWeapon].rate;
    fireWeapon();
  }
  // Player
  player.update(dt);
  // Check player death
  if (player.energy <= 0) {
    endGame(wave > 10 ? 'collapse' : 'decoherence');
    return;
  }
  // Wave management
  if (waveActive) {
    waveTimer += dt;
    const spawnRate = Math.max(0.3, 2 - wave * 0.1) / DIFFS[diff].spawnMult;
    if (waveTimer > spawnRate && enemiesKilledThisWave + enemies.filter(e => !e.isBoss).length < enemiesThisWave) {
      waveTimer = 0;
      spawnWaveEnemy();
    }
    // Wave complete check
    if (enemiesKilledThisWave >= enemiesThisWave && enemies.length === 0) {
      waveActive = false;
      wave++;
      score += wave * 100;
      announce('WAVE ' + (wave-1) + ' COMPLETE! +' + ((wave-1)*100), '#22d3ee');
      sfx.levelUp();
      // Next wave after delay
      setTimeout(() => { if (gState === ST.PLAY) startWave(); }, 3000);
      // Victory at wave 20
      if (wave > 20) {
        endGame('victory');
        return;
      }
    }
  }
  // Bullets
  bullets.forEach(b => {
    b.update(dt);
    if (b.isEnemyBullet) {
      // Enemy bullet hits player
      if (player) {
        const dx = player.x - b.x;
        const dy = player.y - b.y;
        if (Math.sqrt(dx*dx+dy*dy) < player.radius + b.radius) {
          player.takeDamage(b.damage);
          b.alive = false;
          spawnP(b.x, b.y, 5, b.w.color, 80, 0.3);
        }
      }
    } else {
      // Player bullet hits enemies
      enemies.forEach(e => {
        if (!e.alive) return;
        const dx = e.x - b.x;
        const dy = e.y - b.y;
        if (Math.sqrt(dx*dx+dy*dy) < e.radius + b.radius) {
          e.takeDamage(b.damage);
          if (b.pierce) {
            b.pierced++;
            if (b.pierced >= 3) b.alive = false;
          } else if (b.w.pattern !== 'field') {
            b.alive = false;
          }
          spawnP(b.x, b.y, 5, b.w.color, 80, 0.3);
          shakeAmt = Math.max(shakeAmt, 2);
        }
      });
    }
  });
  bullets = bullets.filter(b => b.alive);
  // Enemies
  enemies.forEach(e => e.update(dt));
  enemies = enemies.filter(e => e.alive);
  // Pickups
  pickups.forEach(p => {
    p.age += dt;
    if (p.age > 10) { p.alive = false; return; }
    if (!player) return;
    const dx = player.x - p.x;
    const dy = player.y - p.y;
    if (Math.sqrt(dx*dx+dy*dy) < player.radius + p.radius) {
      p.alive = false;
      if (p.type === 'energy') { player.energy = Math.min(player.maxEnergy, player.energy + 30); }
      else { player.shield = Math.min(player.maxShield, player.shield + 25); }
      sfx.pickup();
      spawnP(p.x, p.y, 8, p.type === 'energy' ? '#a855f7' : '#22d3ee', 80, 0.4);
    }
  });
  pickups = pickups.filter(p => p.alive);
  // Particles
  particles.forEach(p => { p.x += p.vx*dt; p.y += p.vy*dt; p.vx *= 0.97; p.vy *= 0.97; p.life -= dt; });
  particles = particles.filter(p => p.life > 0);
  // Combo timer
  if (comboTimer > 0) { comboTimer -= dt; if (comboTimer <= 0) combo = 0; }
  // Shake
  shakeAmt *= 0.9;
  if (shakeAmt < 0.1) shakeAmt = 0;
  // Cap
  if (particles.length > 500) particles.splice(0, particles.length - 500);
  if (bullets.length > 200) bullets.splice(0, bullets.length - 200);
  // HUD
  updateHUD();
}

function updateHUD() {
  document.getElementById('h-score').textContent = score.toLocaleString();
  document.getElementById('h-wave').textContent = wave;
  document.getElementById('h-kills').textContent = kills;
  document.getElementById('h-weapon').textContent = WEAPONS[curWeapon].name;
  document.getElementById('bar-energy').style.width = (player.energy/player.maxEnergy*100) + '%';
  document.getElementById('bar-shield').style.width = (player.shield/player.maxShield*100) + '%';
  document.getElementById('bar-quantum').style.width = (player.quantum/player.maxQuantum*100) + '%';
  renderSB();
}

// ===== RENDER =====
function render() {
  ctx.save();
  if (shakeAmt > 0) ctx.translate((Math.random()-0.5)*shakeAmt*2, (Math.random()-0.5)*shakeAmt*2);
  // BG
  ctx.fillStyle = '#0a0014';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  // Field lines
  const t = performance.now() * 0.001;
  fieldLines.forEach(fl => {
    fl.angle += fl.drift * 0.01;
    ctx.save();
    ctx.translate(fl.x, fl.y);
    ctx.rotate(fl.angle + Math.sin(t) * 0.1);
    ctx.beginPath();
    ctx.moveTo(-fl.length/2, 0);
    ctx.lineTo(fl.length/2, 0);
    ctx.strokeStyle = fl.color;
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.restore();
  });
  // Stars
  bgStars.forEach(s => {
    const b = s.b * (0.6 + Math.sin(t*s.ts+s.tw)*0.4);
    ctx.fillStyle = `rgba(255,255,255,${b})`;
    ctx.fillRect(s.x, s.y, s.s, s.s);
  });
  if (gState === ST.PLAY || gState === ST.PAUSE) {
    // Pickups
    pickups.forEach(p => {
      const pulse = 1 + Math.sin(p.age*4)*0.2;
      const c = p.type === 'energy' ? '#a855f7' : '#22d3ee';
      const pg = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.radius*2*pulse);
      pg.addColorStop(0, c+'80'); pg.addColorStop(1, 'transparent');
      ctx.beginPath(); ctx.arc(p.x, p.y, p.radius*2*pulse, 0, Math.PI*2);
      ctx.fillStyle = pg; ctx.fill();
      ctx.beginPath(); ctx.arc(p.x, p.y, p.radius*pulse, 0, Math.PI*2);
      ctx.fillStyle = c; ctx.fill();
    });
    // Bullets
    bullets.forEach(b => b.draw(ctx));
    // Enemies
    enemies.forEach(e => e.draw(ctx));
    // Player
    if (player) player.draw(ctx);
    // Particles
    particles.forEach(p => {
      const alpha = p.life/p.maxLife;
      ctx.fillStyle = p.color + Math.floor(alpha*200).toString(16).padStart(2,'0');
      ctx.beginPath(); ctx.arc(p.x, p.y, p.size*alpha, 0, Math.PI*2);
      ctx.fill();
    });
    // Combo
    if (combo > 2) {
      ctx.fillStyle = `rgba(245,158,11,${Math.min(1,combo*0.1)})`;
      ctx.font = `bold ${18+combo}px sans-serif`;
      ctx.textAlign = 'right';
      ctx.fillText(combo + 'x COMBO', canvas.width-20, 100);
    }
  }
  ctx.restore();
}

// ===== MAIN LOOP =====
let lastT = 0;
function loop(ts) {
  const dt = Math.min((ts-lastT)/1000, 0.05);
  lastT = ts;
  update(dt);
  render();
  requestAnimationFrame(loop);
}
loadScores();
renderSB();
lastT = performance.now();
requestAnimationFrame(loop);
</script>
</body>
</html>