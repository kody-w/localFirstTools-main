<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lava Lamp Chemistry Lab</title>
    <meta name="description" content="Interactive lava lamp physics simulation with metaball rendering, real thermodynamics, convection modeling, and educational content">
    <meta name="rappterzoo:category" content="particle-physics">
    <meta name="rappterzoo:title" content="Lava Lamp Chemistry Lab">
    <meta name="rappterzoo:description" content="Interactive lava lamp physics simulation with metaball rendering, real thermodynamics, convection modeling, and educational content">
    <meta name="rappterzoo:tags" content="physics,thermodynamics,convection,fluid-dynamics,simulation,lava-lamp">
    <meta name="rappterzoo:experience" content="wonder,flow,relaxation">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #08080f; min-height: 100vh; font-family: 'Courier New', monospace; color: #c0a0e0; overflow: hidden; user-select: none; }
        canvas { position: fixed; top: 0; left: 0; }
        #controls {
            position: fixed; left: 16px; top: 16px; width: 220px;
            background: rgba(15,12,25,0.92); padding: 18px; border-radius: 12px;
            border: 1px solid rgba(150,100,200,0.25); z-index: 10;
            max-height: calc(100vh - 32px); overflow-y: auto;
        }
        #controls::-webkit-scrollbar { width: 4px; }
        #controls::-webkit-scrollbar-thumb { background: rgba(150,100,200,0.3); border-radius: 2px; }
        h3 { margin-bottom: 14px; color: #e0c0ff; font-size: 15px; letter-spacing: 1px; }
        .section-title { font-size: 10px; text-transform: uppercase; letter-spacing: 2px; opacity: 0.5; margin: 14px 0 8px; }
        .control-row { margin: 8px 0; }
        .control-row label { display: block; font-size: 10px; margin-bottom: 4px; opacity: 0.7; }
        .val { float: right; color: #ff9966; font-size: 11px; }
        input[type="range"] { width: 100%; height: 6px; -webkit-appearance: none; background: rgba(100,60,150,0.3); border-radius: 3px; outline: none; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 14px; height: 14px; background: #c080ff; border-radius: 50%; cursor: pointer; }
        select { width: 100%; padding: 6px; background: rgba(30,20,50,0.9); color: #c0a0e0; border: 1px solid rgba(150,100,200,0.3); border-radius: 6px; font-family: inherit; font-size: 11px; outline: none; }
        button { display: block; width: 100%; padding: 8px; margin: 4px 0; background: rgba(80,50,120,0.35); border: 1px solid rgba(150,100,200,0.3); color: #c0a0e0; cursor: pointer; border-radius: 6px; font-family: inherit; font-size: 11px; transition: background 0.2s; }
        button:hover { background: rgba(120,70,180,0.4); }
        .btn-row { display: flex; gap: 6px; }
        .btn-row button { flex: 1; }
        #info-panel {
            position: fixed; right: 16px; top: 16px; width: 240px;
            background: rgba(15,12,25,0.92); padding: 18px; border-radius: 12px;
            border: 1px solid rgba(150,100,200,0.25); z-index: 10;
            max-height: calc(100vh - 32px); overflow-y: auto;
        }
        #info-panel::-webkit-scrollbar { width: 4px; }
        #info-panel::-webkit-scrollbar-thumb { background: rgba(150,100,200,0.3); border-radius: 2px; }
        .stat-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin: 10px 0; }
        .stat-box { background: rgba(40,25,60,0.5); padding: 8px; border-radius: 6px; text-align: center; }
        .stat-val { font-size: 18px; color: #ff9966; }
        .stat-lbl { font-size: 9px; opacity: 0.6; margin-top: 2px; }
        #energy-graph { width: 100%; height: 60px; background: rgba(20,15,30,0.5); border-radius: 6px; margin: 8px 0; }
        #temp-bar { width: 100%; height: 20px; border-radius: 4px; margin: 8px 0; background: linear-gradient(90deg, #2040a0, #a04020, #ffcc00); }
        .learn-toggle { cursor: pointer; font-size: 11px; color: #a080d0; margin-top: 12px; }
        .learn-content { display: none; font-size: 10px; line-height: 1.6; opacity: 0.75; margin-top: 8px; padding: 10px; background: rgba(30,20,50,0.4); border-radius: 6px; }
        .learn-content.open { display: block; }
        .learn-content h4 { color: #d0b0ff; margin: 8px 0 4px; font-size: 11px; }
        .learn-content p { margin: 4px 0; }
        #hint { position: fixed; bottom: 16px; left: 50%; transform: translateX(-50%); font-size: 11px; opacity: 0.4; z-index: 10; text-align: center; pointer-events: none; }
        .paused-overlay { position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%); font-size: 36px; color: rgba(200,160,255,0.5); pointer-events: none; z-index: 20; display: none; letter-spacing: 8px; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="controls">
        <h3>ü´ß Lava Lamp Lab</h3>
        <div class="section-title">Preset</div>
        <select id="preset">
            <option value="classic">Classic Orange</option>
            <option value="ocean">Deep Ocean</option>
            <option value="alien">Alien Goo</option>
            <option value="solar">Solar Plasma</option>
            <option value="frozen">Frozen</option>
        </select>
        <div class="section-title">Thermodynamics</div>
        <div class="control-row">
            <label>Heat Intensity <span class="val" id="heat-val">70%</span></label>
            <input type="range" id="heat" min="0" max="100" value="70">
        </div>
        <div class="control-row">
            <label>Wax Density <span class="val" id="density-val">0.95 g/cm¬≥</span></label>
            <input type="range" id="density" min="80" max="110" value="95">
        </div>
        <div class="control-row">
            <label>Viscosity <span class="val" id="viscosity-val">50</span></label>
            <input type="range" id="viscosity" min="5" max="100" value="50">
        </div>
        <div class="section-title">Appearance</div>
        <div class="control-row">
            <label>Wax Hue <span class="val" id="wax-hue-val">30¬∞</span></label>
            <input type="range" id="wax-hue" min="0" max="360" value="30">
        </div>
        <div class="control-row">
            <label>Liquid Hue <span class="val" id="liquid-hue-val">240¬∞</span></label>
            <input type="range" id="liquid-hue" min="0" max="360" value="240">
        </div>
        <div class="control-row">
            <label>Blob Count <span class="val" id="blob-count-val">8</span></label>
            <input type="range" id="blob-count" min="3" max="20" value="8">
        </div>
        <div class="control-row">
            <label>Glass Tint</label>
            <select id="glass-tint">
                <option value="clear">Clear</option>
                <option value="amber">Amber</option>
                <option value="blue">Blue</option>
                <option value="green">Green</option>
            </select>
        </div>
        <div class="section-title">Actions</div>
        <div class="btn-row">
            <button id="shake-btn">ü´® Shake</button>
            <button id="reset-btn">‚Ü∫ Reset</button>
        </div>
        <div class="btn-row">
            <button id="add-btn">+ Blob</button>
            <button id="pause-btn">‚è∏ Pause</button>
        </div>
    </div>
    <div id="info-panel">
        <h3>üìä Lab Readings</h3>
        <div class="stat-grid">
            <div class="stat-box"><div class="stat-val" id="s-blobs">0</div><div class="stat-lbl">Blobs</div></div>
            <div class="stat-box"><div class="stat-val" id="s-temp">25¬∞</div><div class="stat-lbl">Avg Temp</div></div>
            <div class="stat-box"><div class="stat-val" id="s-energy">0</div><div class="stat-lbl">Kinetic E</div></div>
            <div class="stat-box"><div class="stat-val" id="s-convect">0</div><div class="stat-lbl">Convection</div></div>
        </div>
        <div class="section-title">Temperature Gradient</div>
        <canvas id="temp-canvas" width="200" height="20" style="width:100%;height:20px;border-radius:4px"></canvas>
        <div class="section-title">System Energy</div>
        <canvas id="energy-canvas" width="200" height="60" style="width:100%;height:60px;border-radius:6px;background:rgba(20,15,30,0.5)"></canvas>
        <div class="learn-toggle" id="learn-toggle">‚ñ∂ Learn: How Lava Lamps Work</div>
        <div class="learn-content" id="learn-content">
            <h4>üî¨ Density &amp; Temperature</h4>
            <p>Lava lamps exploit the fact that wax expands when heated. At room temperature, wax is slightly denser than the surrounding liquid and sinks. The heat coil at the base warms the wax, causing it to expand and become less dense than the liquid ‚Äî so it rises.</p>
            <h4>üåä Convection Currents</h4>
            <p>As warm wax blobs rise, they cool down, become denser again, and sink back to the bottom. This creates a continuous convection cycle ‚Äî the same process that drives ocean currents and weather systems.</p>
            <h4>ü´ß Rayleigh-B√©nard Convection</h4>
            <p>The lava lamp is a beautiful example of Rayleigh-B√©nard convection: a fluid heated from below becomes unstable and forms organized convection cells. The critical Rayleigh number determines when convection begins.</p>
            <h4>üíß Merging &amp; Splitting</h4>
            <p>Blobs merge when they collide because surface tension pulls them together. They split when buoyant forces overcome surface tension ‚Äî typically at the top where cooling creates internal stress.</p>
            <h4>üåç Real-World Parallels</h4>
            <p>Earth's mantle behaves like a giant lava lamp: hot rock rises from the core-mantle boundary, cools at the surface, and sinks back down over millions of years. This drives plate tectonics!</p>
        </div>
    </div>
    <div id="hint">Click lamp to add heat pulse ¬∑ Drag blobs ¬∑ Scroll to adjust heat ¬∑ Space to pause ¬∑ S to shake</div>
    <div class="paused-overlay" id="paused">PAUSED</div>

    <script>
    (function() {
        'use strict';
        const C = document.getElementById('canvas');
        const ctx = C.getContext('2d');
        let W, H;
        function resize() { W = C.width = innerWidth; H = C.height = innerHeight; }
        resize();
        window.addEventListener('resize', resize);

        // --- State ---
        let paused = false;
        let heat = 70, waxDensity = 0.95, viscosity = 50;
        let waxHue = 30, liquidHue = 240, glassTint = 'clear';
        let targetBlobCount = 8;
        let blobs = [];
        let energyHistory = [];
        let dragBlob = null, dragOffX = 0, dragOffY = 0;
        let shakeTimer = 0;

        // --- Lamp geometry (responsive) ---
        function lampGeom() {
            const lampH = H * 0.82;
            const lampW = lampH * 0.28;
            const cx = W / 2, cy = H / 2;
            const top = cy - lampH / 2;
            const bot = cy + lampH / 2;
            const capH = lampH * 0.08;
            const baseH = lampH * 0.10;
            const glassTop = top + capH;
            const glassBot = bot - baseH;
            return { cx, cy, top, bot, lampW, lampH, capH, baseH, glassTop, glassBot,
                     glassH: glassBot - glassTop, halfW: lampW / 2 };
        }

        // Glass shape: wider in middle, narrower at ends (bezier)
        function glassWidthAt(yNorm, halfW) {
            // yNorm 0=top, 1=bottom. Wider in middle.
            const bulge = Math.sin(yNorm * Math.PI);
            return halfW * (0.55 + 0.45 * bulge);
        }

        // --- Blob class ---
        class Blob {
            constructor(x, y, radius) {
                this.x = x; this.y = y;
                this.radius = radius;
                this.vx = 0; this.vy = 0;
                this.temp = 25 + Math.random() * 10;
                this.wobblePhase = Math.random() * Math.PI * 2;
                this.wobbleSpeed = 0.02 + Math.random() * 0.02;
                this.mass = radius * radius;
            }
            update(dt, g) {
                if (paused) return;
                const { glassTop, glassBot, glassH, cx, halfW } = lampGeom();
                // Normalized y position in glass (0=top, 1=bottom)
                const yNorm = Math.max(0, Math.min(1, (this.y - glassTop) / glassH));

                // Heat transfer
                const heatZoneNorm = 0.85; // bottom 15% is heat zone
                if (yNorm > heatZoneNorm) {
                    const heatFactor = (yNorm - heatZoneNorm) / (1 - heatZoneNorm);
                    this.temp += heat * 0.035 * heatFactor * dt;
                }
                // Cooling (radiative loss to glass walls + top)
                const ambientTemp = 22;
                this.temp += (ambientTemp - this.temp) * 0.008 * dt;
                // Extra cooling at top
                if (yNorm < 0.2) {
                    this.temp += (ambientTemp - this.temp) * 0.015 * dt;
                }
                this.temp = Math.max(20, Math.min(105, this.temp));

                // Buoyancy: density decreases with temp
                const expansionCoeff = 0.005;
                const effectiveDensity = waxDensity * (1 - expansionCoeff * (this.temp - 25));
                const liquidDensityVal = 1.0;
                const buoyancyForce = (liquidDensityVal - effectiveDensity) * 9.81 * this.mass * 0.0004;

                // Drag
                const dragCoeff = viscosity * 0.0003;
                const dragFx = -dragCoeff * this.vx * Math.abs(this.vx);
                const dragFy = -dragCoeff * this.vy * Math.abs(this.vy);

                // Gravity
                const gravity = 0.04;

                this.vx += dragFx * dt;
                this.vy += (gravity - buoyancyForce + dragFy) * dt;

                // Wobble (lateral)
                this.wobblePhase += this.wobbleSpeed * dt * 60;
                this.vx += Math.sin(this.wobblePhase) * 0.003 * dt * 60;

                // Shake
                if (shakeTimer > 0) {
                    this.vx += (Math.random() - 0.5) * 0.8;
                    this.vy += (Math.random() - 0.5) * 0.4;
                }

                this.x += this.vx * dt * 60;
                this.y += this.vy * dt * 60;

                // Constrain to glass shape
                const yN2 = Math.max(0, Math.min(1, (this.y - glassTop) / glassH));
                const wallW = glassWidthAt(yN2, halfW);
                const minX = cx - wallW + this.radius + 5;
                const maxX = cx + wallW - this.radius - 5;
                if (this.x < minX) { this.x = minX; this.vx *= -0.3; }
                if (this.x > maxX) { this.x = maxX; this.vx *= -0.3; }
                if (this.y < glassTop + this.radius + 4) { this.y = glassTop + this.radius + 4; this.vy *= -0.2; }
                if (this.y > glassBot - this.radius - 4) { this.y = glassBot - this.radius - 4; this.vy *= -0.2; }
            }
        }

        function initBlobs(count) {
            const { cx, glassBot, glassH, halfW } = lampGeom();
            blobs = [];
            for (let i = 0; i < count; i++) {
                const y = glassBot - 20 - Math.random() * glassH * 0.3;
                const yN = Math.max(0, Math.min(1, (y - lampGeom().glassTop) / glassH));
                const ww = glassWidthAt(yN, halfW);
                const x = cx + (Math.random() - 0.5) * ww * 1.2;
                const r = 12 + Math.random() * 18;
                blobs.push(new Blob(x, y, r));
            }
        }

        // --- Metaball rendering ---
        function renderMetaballs() {
            const { cx, glassTop, glassBot, glassH, halfW } = lampGeom();
            const step = 4; // pixel step for performance
            const threshold = 1.0;

            // Create offscreen buffer for the metaball field
            const gw = Math.ceil(halfW * 2.4 / step);
            const gh = Math.ceil(glassH / step);
            const originX = cx - halfW * 1.2;
            const originY = glassTop;

            for (let gy = 0; gy < gh; gy++) {
                for (let gx = 0; gx < gw; gx++) {
                    const px = originX + gx * step;
                    const py = originY + gy * step;

                    // Check if inside glass shape
                    const yN = (py - glassTop) / glassH;
                    if (yN < 0 || yN > 1) continue;
                    const wallW = glassWidthAt(yN, halfW);
                    if (Math.abs(px - cx) > wallW) continue;

                    // Compute metaball field
                    let field = 0;
                    let tempSum = 0;
                    let weightSum = 0;
                    for (let i = 0; i < blobs.length; i++) {
                        const b = blobs[i];
                        const dx = px - b.x;
                        const dy = py - b.y;
                        const dist2 = dx * dx + dy * dy;
                        const r2 = (b.radius * 1.8) * (b.radius * 1.8);
                        const val = r2 / (dist2 + 1);
                        field += val;
                        tempSum += b.temp * val;
                        weightSum += val;
                    }

                    if (field > threshold) {
                        const avgTemp = weightSum > 0 ? tempSum / weightSum : 25;
                        const hotness = Math.max(0, Math.min(1, (avgTemp - 25) / 75));
                        const lightness = 40 + hotness * 30;
                        const sat = 90 + hotness * 10;
                        const alpha = Math.min(1, (field - threshold) * 1.5) * 0.92;
                        ctx.fillStyle = `hsla(${waxHue + hotness * 15}, ${sat}%, ${lightness}%, ${alpha})`;
                        ctx.fillRect(px - step/2, py - step/2, step + 1, step + 1);
                    }
                }
            }
        }

        // --- Draw lamp structure ---
        function drawLamp() {
            const { cx, top, bot, lampW, capH, baseH, glassTop, glassBot, glassH, halfW } = lampGeom();

            // Ambient glow
            const ambGrad = ctx.createRadialGradient(cx, (glassTop + glassBot) / 2, 10, cx, (glassTop + glassBot) / 2, halfW * 3);
            const glowHue = waxHue;
            ambGrad.addColorStop(0, `hsla(${glowHue}, 70%, 30%, 0.12)`);
            ambGrad.addColorStop(0.5, `hsla(${glowHue}, 60%, 20%, 0.05)`);
            ambGrad.addColorStop(1, 'transparent');
            ctx.fillStyle = ambGrad;
            ctx.fillRect(0, 0, W, H);

            // Glass body outline (bezier shape)
            ctx.save();
            ctx.beginPath();
            const segments = 40;
            // Right side
            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const w = glassWidthAt(t, halfW);
                const y = glassTop + t * glassH;
                if (i === 0) ctx.moveTo(cx + w, y); else ctx.lineTo(cx + w, y);
            }
            // Left side (reverse)
            for (let i = segments; i >= 0; i--) {
                const t = i / segments;
                const w = glassWidthAt(t, halfW);
                const y = glassTop + t * glassH;
                ctx.lineTo(cx - w, y);
            }
            ctx.closePath();
            ctx.clip();

            // Liquid fill
            const tintAlpha = glassTint === 'clear' ? 0.02 : 0.08;
            const tintHues = { clear: liquidHue, amber: 35, blue: 220, green: 140 };
            const liqHue = tintHues[glassTint] || liquidHue;
            const liqGrad = ctx.createLinearGradient(0, glassTop, 0, glassBot);
            liqGrad.addColorStop(0, `hsla(${liqHue}, 40%, 8%, 0.9)`);
            liqGrad.addColorStop(0.5, `hsla(${liqHue}, 35%, 12%, 0.85)`);
            liqGrad.addColorStop(1, `hsla(${liqHue}, 50%, 15%, 0.9)`);
            ctx.fillStyle = liqGrad;
            ctx.fillRect(cx - halfW * 1.5, glassTop, halfW * 3, glassH);

            // Heat glow at bottom
            const heatGrad = ctx.createLinearGradient(0, glassBot, 0, glassBot - glassH * 0.25);
            heatGrad.addColorStop(0, `rgba(255, 100, 20, ${heat / 200})`);
            heatGrad.addColorStop(1, 'transparent');
            ctx.fillStyle = heatGrad;
            ctx.fillRect(cx - halfW * 1.5, glassTop, halfW * 3, glassH);

            // Render metaballs
            renderMetaballs();

            ctx.restore();

            // Glass outline
            ctx.beginPath();
            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const w = glassWidthAt(t, halfW);
                const y = glassTop + t * glassH;
                if (i === 0) ctx.moveTo(cx + w, y); else ctx.lineTo(cx + w, y);
            }
            for (let i = segments; i >= 0; i--) {
                const t = i / segments;
                const w = glassWidthAt(t, halfW);
                const y = glassTop + t * glassH;
                ctx.lineTo(cx - w, y);
            }
            ctx.closePath();
            ctx.strokeStyle = 'rgba(180, 160, 220, 0.2)';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Glass highlight (reflection)
            ctx.beginPath();
            const hlX = cx - halfW * 0.55;
            ctx.moveTo(hlX, glassTop + glassH * 0.1);
            ctx.quadraticCurveTo(hlX - 5, glassTop + glassH * 0.5, hlX + 3, glassTop + glassH * 0.85);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
            ctx.lineWidth = 3;
            ctx.stroke();

            // Cap
            const capW = halfW * 0.7;
            const capGrad = ctx.createLinearGradient(0, top, 0, top + capH);
            capGrad.addColorStop(0, '#555');
            capGrad.addColorStop(0.4, '#3a3a3a');
            capGrad.addColorStop(1, '#222');
            ctx.fillStyle = capGrad;
            ctx.beginPath();
            ctx.moveTo(cx - capW, glassTop);
            ctx.lineTo(cx - capW * 0.8, top);
            ctx.lineTo(cx + capW * 0.8, top);
            ctx.lineTo(cx + capW, glassTop);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = 'rgba(100,100,120,0.5)';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Base
            const baseW = halfW * 1.1;
            const baseGrad = ctx.createLinearGradient(0, glassBot, 0, bot);
            baseGrad.addColorStop(0, '#3a3a3a');
            baseGrad.addColorStop(0.5, '#222');
            baseGrad.addColorStop(1, '#111');
            ctx.fillStyle = baseGrad;
            ctx.beginPath();
            ctx.moveTo(cx - halfW * 0.65, glassBot);
            ctx.lineTo(cx - baseW, bot);
            ctx.lineTo(cx + baseW, bot);
            ctx.lineTo(cx + halfW * 0.65, glassBot);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = 'rgba(100,100,120,0.4)';
            ctx.stroke();

            // Heat coil glow
            const coilY = bot - baseH * 0.4;
            const coilGrad = ctx.createRadialGradient(cx, coilY, 2, cx, coilY, baseW * 0.6);
            coilGrad.addColorStop(0, `rgba(255, 80, 0, ${heat / 120})`);
            coilGrad.addColorStop(1, 'transparent');
            ctx.fillStyle = coilGrad;
            ctx.fillRect(cx - baseW, coilY - 15, baseW * 2, 30);

            // Table glow
            const tableGrad = ctx.createRadialGradient(cx, bot, 5, cx, bot + 60, baseW * 2);
            tableGrad.addColorStop(0, `hsla(${waxHue}, 50%, 30%, 0.08)`);
            tableGrad.addColorStop(1, 'transparent');
            ctx.fillStyle = tableGrad;
            ctx.fillRect(cx - baseW * 3, bot, baseW * 6, 120);
        }

        // --- Blob physics ---
        function mergeBlobs() {
            for (let i = 0; i < blobs.length; i++) {
                for (let j = i + 1; j < blobs.length; j++) {
                    const dx = blobs[i].x - blobs[j].x;
                    const dy = blobs[i].y - blobs[j].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const minDist = (blobs[i].radius + blobs[j].radius) * 0.6;
                    if (dist < minDist) {
                        const areaSum = blobs[i].radius * blobs[i].radius + blobs[j].radius * blobs[j].radius;
                        blobs[i].radius = Math.min(40, Math.sqrt(areaSum));
                        blobs[i].temp = (blobs[i].temp + blobs[j].temp) / 2;
                        blobs[i].vx = (blobs[i].vx + blobs[j].vx) / 2;
                        blobs[i].vy = (blobs[i].vy + blobs[j].vy) / 2;
                        blobs[i].mass = blobs[i].radius * blobs[i].radius;
                        blobs.splice(j, 1);
                        if (dragBlob === j) dragBlob = null;
                        if (dragBlob > j) dragBlob--;
                        j--;
                    }
                }
            }
        }

        function splitBlobs() {
            const { glassTop, glassH } = lampGeom();
            const toAdd = [];
            blobs.forEach((b, i) => {
                if (b.radius > 22 && b.temp < 35 && Math.random() < 0.006) {
                    const yN = (b.y - glassTop) / glassH;
                    if (yN < 0.25) {
                        const newR = b.radius * 0.55;
                        b.radius = newR;
                        b.mass = b.radius * b.radius;
                        const nb = new Blob(b.x + (Math.random() - 0.5) * 15, b.y, newR * 0.9);
                        nb.temp = b.temp;
                        nb.vy = b.vy * 0.5;
                        toAdd.push(nb);
                    }
                }
            });
            blobs.push(...toAdd);
        }

        function respawnIfNeeded() {
            if (blobs.length < 3) {
                const { cx, glassBot, glassH, halfW } = lampGeom();
                const y = glassBot - 15;
                blobs.push(new Blob(cx + (Math.random() - 0.5) * halfW * 0.5, y, 14 + Math.random() * 12));
            }
        }

        // --- Stats ---
        function updateStats() {
            const avgTemp = blobs.length ? blobs.reduce((s, b) => s + b.temp, 0) / blobs.length : 22;
            const kineticE = blobs.reduce((s, b) => s + 0.5 * b.mass * (b.vx * b.vx + b.vy * b.vy), 0);
            const convection = blobs.reduce((s, b) => s + Math.abs(b.vy), 0);

            document.getElementById('s-blobs').textContent = blobs.length;
            document.getElementById('s-temp').textContent = Math.round(avgTemp) + '¬∞';
            document.getElementById('s-energy').textContent = kineticE.toFixed(1);
            document.getElementById('s-convect').textContent = convection.toFixed(1);

            energyHistory.push(kineticE);
            if (energyHistory.length > 100) energyHistory.shift();

            // Draw energy sparkline
            const ec = document.getElementById('energy-canvas');
            const ectx = ec.getContext('2d');
            ectx.clearRect(0, 0, 200, 60);
            if (energyHistory.length > 1) {
                const maxE = Math.max(1, ...energyHistory);
                ectx.beginPath();
                ectx.moveTo(0, 60 - (energyHistory[0] / maxE) * 55);
                for (let i = 1; i < energyHistory.length; i++) {
                    ectx.lineTo(i * (200 / 100), 60 - (energyHistory[i] / maxE) * 55);
                }
                ectx.strokeStyle = 'rgba(255, 150, 100, 0.7)';
                ectx.lineWidth = 1.5;
                ectx.stroke();
            }

            // Temp gradient bar
            const tc = document.getElementById('temp-canvas');
            const tctx = tc.getContext('2d');
            tctx.clearRect(0, 0, 200, 20);
            const { glassTop, glassH } = lampGeom();
            const buckets = 20;
            for (let i = 0; i < buckets; i++) {
                const yMin = glassTop + (i / buckets) * glassH;
                const yMax = glassTop + ((i + 1) / buckets) * glassH;
                let sumT = 0, cnt = 0;
                blobs.forEach(b => { if (b.y >= yMin && b.y < yMax) { sumT += b.temp; cnt++; } });
                const t = cnt > 0 ? sumT / cnt : 22;
                const hotness = Math.max(0, Math.min(1, (t - 22) / 75));
                tctx.fillStyle = `hsl(${30 - hotness * 30}, ${70 + hotness * 30}%, ${20 + hotness * 50}%)`;
                tctx.fillRect(i * 10, 0, 10, 20);
            }
        }

        // --- Interaction ---
        function getLampCoords(e) {
            const rect = C.getBoundingClientRect();
            return { mx: e.clientX - rect.left, my: e.clientY - rect.top };
        }

        function isInsideGlass(mx, my) {
            const { cx, glassTop, glassBot, glassH, halfW } = lampGeom();
            const yN = (my - glassTop) / glassH;
            if (yN < 0 || yN > 1) return false;
            const w = glassWidthAt(yN, halfW);
            return Math.abs(mx - cx) < w;
        }

        function findBlobAt(mx, my) {
            for (let i = blobs.length - 1; i >= 0; i--) {
                const dx = mx - blobs[i].x, dy = my - blobs[i].y;
                if (Math.sqrt(dx * dx + dy * dy) < blobs[i].radius * 1.5) return i;
            }
            return -1;
        }

        C.addEventListener('mousedown', e => {
            const { mx, my } = getLampCoords(e);
            const bi = findBlobAt(mx, my);
            if (bi >= 0) {
                dragBlob = bi;
                dragOffX = mx - blobs[bi].x;
                dragOffY = my - blobs[bi].y;
            } else if (isInsideGlass(mx, my)) {
                // Heat pulse
                blobs.forEach(b => {
                    const d = Math.sqrt((mx - b.x) ** 2 + (my - b.y) ** 2);
                    if (d < 80) b.temp += (80 - d) * 0.5;
                });
            }
        });

        C.addEventListener('mousemove', e => {
            if (dragBlob !== null && dragBlob < blobs.length) {
                const { mx, my } = getLampCoords(e);
                blobs[dragBlob].x = mx - dragOffX;
                blobs[dragBlob].y = my - dragOffY;
                blobs[dragBlob].vx = 0;
                blobs[dragBlob].vy = 0;
            }
        });

        C.addEventListener('mouseup', () => { dragBlob = null; });

        C.addEventListener('dblclick', e => {
            const { mx, my } = getLampCoords(e);
            if (isInsideGlass(mx, my) && blobs.length < 25) {
                blobs.push(new Blob(mx, my, 12 + Math.random() * 14));
            }
        });

        C.addEventListener('wheel', e => {
            e.preventDefault();
            heat = Math.max(0, Math.min(100, heat + (e.deltaY > 0 ? -3 : 3)));
            document.getElementById('heat').value = heat;
            document.getElementById('heat-val').textContent = heat + '%';
            saveState();
        }, { passive: false });

        document.addEventListener('keydown', e => {
            if (e.code === 'Space') { e.preventDefault(); togglePause(); }
            if (e.key === 's' || e.key === 'S') doShake();
        });

        // --- Controls ---
        function bindSlider(id, cb) {
            document.getElementById(id).addEventListener('input', e => { cb(e.target.value); saveState(); });
        }
        bindSlider('heat', v => { heat = +v; document.getElementById('heat-val').textContent = v + '%'; });
        bindSlider('density', v => { waxDensity = v / 100; document.getElementById('density-val').textContent = waxDensity.toFixed(2) + ' g/cm¬≥'; });
        bindSlider('viscosity', v => { viscosity = +v; document.getElementById('viscosity-val').textContent = v; });
        bindSlider('wax-hue', v => { waxHue = +v; document.getElementById('wax-hue-val').textContent = v + '¬∞'; });
        bindSlider('liquid-hue', v => { liquidHue = +v; document.getElementById('liquid-hue-val').textContent = v + '¬∞'; });
        bindSlider('blob-count', v => {
            targetBlobCount = +v;
            document.getElementById('blob-count-val').textContent = v;
            while (blobs.length < targetBlobCount) {
                const { cx, glassBot, halfW } = lampGeom();
                blobs.push(new Blob(cx + (Math.random() - 0.5) * halfW * 0.6, glassBot - 20, 12 + Math.random() * 15));
            }
            while (blobs.length > targetBlobCount + 5) blobs.pop();
        });
        document.getElementById('glass-tint').addEventListener('change', e => { glassTint = e.target.value; saveState(); });

        // Presets
        const presets = {
            classic: { heat: 70, density: 95, viscosity: 50, waxHue: 30, liquidHue: 240, glassTint: 'clear' },
            ocean:   { heat: 60, density: 92, viscosity: 65, waxHue: 200, liquidHue: 260, glassTint: 'blue' },
            alien:   { heat: 55, density: 98, viscosity: 80, waxHue: 120, liquidHue: 160, glassTint: 'green' },
            solar:   { heat: 100, density: 88, viscosity: 25, waxHue: 45, liquidHue: 20, glassTint: 'amber' },
            frozen:  { heat: 0, density: 102, viscosity: 90, waxHue: 210, liquidHue: 230, glassTint: 'blue' }
        };

        document.getElementById('preset').addEventListener('change', e => {
            const p = presets[e.target.value];
            if (!p) return;
            heat = p.heat; waxDensity = p.density / 100; viscosity = p.viscosity;
            waxHue = p.waxHue; liquidHue = p.liquidHue; glassTint = p.glassTint;
            document.getElementById('heat').value = heat;
            document.getElementById('heat-val').textContent = heat + '%';
            document.getElementById('density').value = p.density;
            document.getElementById('density-val').textContent = waxDensity.toFixed(2) + ' g/cm¬≥';
            document.getElementById('viscosity').value = viscosity;
            document.getElementById('viscosity-val').textContent = viscosity;
            document.getElementById('wax-hue').value = waxHue;
            document.getElementById('wax-hue-val').textContent = waxHue + '¬∞';
            document.getElementById('liquid-hue').value = liquidHue;
            document.getElementById('liquid-hue-val').textContent = liquidHue + '¬∞';
            document.getElementById('glass-tint').value = glassTint;
            saveState();
        });

        document.getElementById('shake-btn').addEventListener('click', doShake);
        document.getElementById('reset-btn').addEventListener('click', () => { initBlobs(targetBlobCount); });
        document.getElementById('add-btn').addEventListener('click', () => {
            if (blobs.length < 25) {
                const { cx, glassBot, halfW } = lampGeom();
                blobs.push(new Blob(cx + (Math.random() - 0.5) * halfW * 0.4, glassBot - 20, 12 + Math.random() * 14));
            }
        });
        document.getElementById('pause-btn').addEventListener('click', togglePause);

        function doShake() { shakeTimer = 30; }
        function togglePause() {
            paused = !paused;
            document.getElementById('pause-btn').textContent = paused ? '‚ñ∂ Play' : '‚è∏ Pause';
            document.getElementById('paused').style.display = paused ? 'block' : 'none';
        }

        // Learn toggle
        document.getElementById('learn-toggle').addEventListener('click', () => {
            const el = document.getElementById('learn-content');
            const isOpen = el.classList.toggle('open');
            document.getElementById('learn-toggle').textContent = (isOpen ? '‚ñº' : '‚ñ∂') + ' Learn: How Lava Lamps Work';
            saveState();
        });

        // --- localStorage ---
        const STORAGE_KEY = 'lava-lamp-lab-state';
        function saveState() {
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify({
                    heat, waxDensity, viscosity, waxHue, liquidHue, glassTint, targetBlobCount,
                    preset: document.getElementById('preset').value,
                    learnOpen: document.getElementById('learn-content').classList.contains('open')
                }));
            } catch(e) {}
        }
        function loadState() {
            try {
                const s = JSON.parse(localStorage.getItem(STORAGE_KEY));
                if (!s) return;
                heat = s.heat ?? 70;
                waxDensity = s.waxDensity ?? 0.95;
                viscosity = s.viscosity ?? 50;
                waxHue = s.waxHue ?? 30;
                liquidHue = s.liquidHue ?? 240;
                glassTint = s.glassTint ?? 'clear';
                targetBlobCount = s.targetBlobCount ?? 8;
                document.getElementById('heat').value = heat;
                document.getElementById('heat-val').textContent = heat + '%';
                document.getElementById('density').value = Math.round(waxDensity * 100);
                document.getElementById('density-val').textContent = waxDensity.toFixed(2) + ' g/cm¬≥';
                document.getElementById('viscosity').value = viscosity;
                document.getElementById('viscosity-val').textContent = viscosity;
                document.getElementById('wax-hue').value = waxHue;
                document.getElementById('wax-hue-val').textContent = waxHue + '¬∞';
                document.getElementById('liquid-hue').value = liquidHue;
                document.getElementById('liquid-hue-val').textContent = liquidHue + '¬∞';
                document.getElementById('blob-count').value = targetBlobCount;
                document.getElementById('blob-count-val').textContent = targetBlobCount;
                document.getElementById('glass-tint').value = glassTint;
                if (s.preset) document.getElementById('preset').value = s.preset;
                if (s.learnOpen) {
                    document.getElementById('learn-content').classList.add('open');
                    document.getElementById('learn-toggle').textContent = '‚ñº Learn: How Lava Lamps Work';
                }
            } catch(e) {}
        }

        // --- Background ---
        const stars = Array.from({length: 80}, () => ({
            x: Math.random() * 3000, y: Math.random() * 2000,
            r: Math.random() * 1.2, a: Math.random() * 0.3 + 0.1
        }));

        function drawBackground() {
            ctx.fillStyle = '#08080f';
            ctx.fillRect(0, 0, W, H);
            stars.forEach(s => {
                ctx.beginPath();
                ctx.arc(s.x % W, s.y % H, s.r, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(180, 180, 220, ${s.a})`;
                ctx.fill();
            });
        }

        // --- Main loop ---
        let lastTime = 0;
        function animate(now) {
            const dt = Math.min(0.05, (now - lastTime) / 1000) || 0.016;
            lastTime = now;

            drawBackground();

            if (!paused) {
                blobs.forEach(b => b.update(dt * 60, lampGeom()));
                mergeBlobs();
                splitBlobs();
                respawnIfNeeded();
                if (shakeTimer > 0) shakeTimer--;
            }

            drawLamp();
            updateStats();

            requestAnimationFrame(animate);
        }

        // --- Init ---
        loadState();
        initBlobs(targetBlobCount);
        requestAnimationFrame(animate);
    })();
    </script>
</body>
</html>
