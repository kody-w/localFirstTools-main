<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wave Interference Lab</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%);
            color: #e0e0e0;
            overflow-x: hidden;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            background: linear-gradient(135deg, #1a237e 0%, #283593 100%);
            padding: 1.5rem;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
        }

        header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 0%, transparent 70%);
            animation: wave-pulse 8s ease-in-out infinite;
        }

        @keyframes wave-pulse {
            0%, 100% { transform: translate(0, 0) scale(1); }
            50% { transform: translate(10px, 10px) scale(1.1); }
        }

        h1 {
            font-size: 2rem;
            text-align: center;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.5);
            position: relative;
            z-index: 1;
            letter-spacing: 1px;
        }

        .subtitle {
            text-align: center;
            font-size: 0.9rem;
            opacity: 0.8;
            margin-top: 0.5rem;
            position: relative;
            z-index: 1;
        }

        main {
            flex: 1;
            display: flex;
            gap: 1rem;
            padding: 1rem;
            max-width: 1800px;
            margin: 0 auto;
            width: 100%;
        }

        .canvas-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            min-width: 0;
        }

        .canvas-wrapper {
            background: linear-gradient(135deg, #1a1f3a 0%, #0f1320 100%);
            border-radius: 12px;
            padding: 1rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(100, 150, 255, 0.2);
            position: relative;
        }

        canvas {
            display: block;
            width: 100%;
            border-radius: 8px;
            cursor: crosshair;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
            background: #000;
        }

        .intensity-graph {
            background: linear-gradient(135deg, #1a1f3a 0%, #0f1320 100%);
            border-radius: 12px;
            padding: 1rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(100, 150, 255, 0.2);
            height: 150px;
        }

        .intensity-graph h3 {
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            opacity: 0.9;
        }

        #intensityCanvas {
            width: 100%;
            height: 100px;
            border-radius: 4px;
            background: #000;
        }

        .sidebar {
            width: 320px;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            overflow-y: auto;
            max-height: calc(100vh - 150px);
        }

        .panel {
            background: linear-gradient(135deg, #1e2340 0%, #161a2e 100%);
            border-radius: 12px;
            padding: 1.2rem;
            box-shadow: 0 6px 24px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(100, 150, 255, 0.2);
            transition: all 0.3s ease;
        }

        .panel:hover {
            box-shadow: 0 8px 32px rgba(100, 150, 255, 0.2);
            border-color: rgba(100, 150, 255, 0.4);
        }

        .panel h2 {
            font-size: 1.1rem;
            margin-bottom: 1rem;
            color: #64b5f6;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 2px solid rgba(100, 181, 246, 0.3);
            padding-bottom: 0.5rem;
        }

        .control-group {
            margin-bottom: 1.2rem;
        }

        .control-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            color: #b0b0b0;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 0.8rem;
        }

        input[type="range"] {
            flex: 1;
            height: 6px;
            background: linear-gradient(to right, #283593, #64b5f6);
            border-radius: 3px;
            outline: none;
            transition: all 0.3s ease;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, #64b5f6, #42a5f5);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(100, 181, 246, 0.5);
            transition: all 0.2s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 12px rgba(100, 181, 246, 0.7);
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, #64b5f6, #42a5f5);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(100, 181, 246, 0.5);
        }

        .value-display {
            min-width: 60px;
            text-align: right;
            font-weight: 600;
            color: #64b5f6;
            font-size: 0.9rem;
        }

        button {
            width: 100%;
            padding: 0.8rem;
            margin-bottom: 0.6rem;
            border: none;
            border-radius: 6px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .btn-primary {
            background: linear-gradient(135deg, #1976d2, #2196f3);
            color: white;
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #1565c0, #1976d2);
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(33, 150, 243, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #388e3c, #4caf50);
            color: white;
        }

        .btn-success:hover {
            background: linear-gradient(135deg, #2e7d32, #388e3c);
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(76, 175, 80, 0.4);
        }

        .btn-warning {
            background: linear-gradient(135deg, #f57c00, #ff9800);
            color: white;
        }

        .btn-warning:hover {
            background: linear-gradient(135deg, #e65100, #f57c00);
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(255, 152, 0, 0.4);
        }

        .btn-danger {
            background: linear-gradient(135deg, #d32f2f, #f44336);
            color: white;
        }

        .btn-danger:hover {
            background: linear-gradient(135deg, #c62828, #d32f2f);
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(244, 67, 54, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #455a64, #607d8b);
            color: white;
        }

        .btn-secondary:hover {
            background: linear-gradient(135deg, #37474f, #455a64);
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(96, 125, 139, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.6rem;
            margin-bottom: 1rem;
        }

        .mode-selector {
            display: flex;
            flex-direction: column;
            gap: 0.6rem;
        }

        .mode-btn {
            position: relative;
            overflow: hidden;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #4caf50, #66bb6a);
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.5);
        }

        .mode-btn.active::before {
            content: 'âœ“';
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 1.2rem;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 0.8rem;
            margin-bottom: 0.8rem;
            padding: 0.6rem;
            background: rgba(100, 181, 246, 0.05);
            border-radius: 6px;
            transition: all 0.3s ease;
        }

        .checkbox-group:hover {
            background: rgba(100, 181, 246, 0.1);
        }

        .checkbox-group input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: #64b5f6;
        }

        .checkbox-group label {
            margin: 0;
            flex: 1;
            cursor: pointer;
            user-select: none;
        }

        .preset-list {
            display: flex;
            flex-direction: column;
            gap: 0.6rem;
        }

        .info-display {
            background: rgba(100, 181, 246, 0.1);
            padding: 0.8rem;
            border-radius: 6px;
            font-size: 0.85rem;
            line-height: 1.6;
            border-left: 3px solid #64b5f6;
        }

        .info-display strong {
            color: #64b5f6;
        }

        .source-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 0.5rem;
            box-shadow: 0 0 8px currentColor;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.6rem;
            background: rgba(100, 181, 246, 0.05);
            border-radius: 6px;
            font-size: 0.85rem;
        }

        .status-bar .label {
            color: #b0b0b0;
        }

        .status-bar .value {
            color: #64b5f6;
            font-weight: 600;
        }

        @media (max-width: 1024px) {
            main {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                max-height: none;
            }

            .button-group {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 600px) {
            h1 {
                font-size: 1.5rem;
            }

            .panel {
                padding: 1rem;
            }

            .sidebar {
                gap: 0.8rem;
            }
        }

        .color-scheme-selector {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .color-scheme-btn {
            flex: 1;
            padding: 0.5rem;
            font-size: 0.8rem;
            margin: 0;
        }

        .color-scheme-btn.active {
            background: linear-gradient(135deg, #4caf50, #66bb6a);
        }

        .slit-controls {
            display: none;
        }

        .slit-controls.active {
            display: block;
        }

        @keyframes fade-in {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .panel {
            animation: fade-in 0.4s ease;
        }

        #tryAgainBtn {
            background: linear-gradient(135deg, #fb8c00, #ffa726);
        }

        #tryAgainBtn:hover {
            background: linear-gradient(135deg, #ef6c00, #fb8c00);
        }
    </style>
</head>
<body>
    <header>
        <h1>ðŸŒŠ Wave Interference Lab</h1>
        <div class="subtitle">Explore wave phenomena, interference patterns, and quantum experiments</div>
    </header>

    <main>
        <div class="canvas-container">
            <div class="canvas-wrapper">
                <canvas id="waveCanvas" width="800" height="600"></canvas>
            </div>
            <div class="intensity-graph">
                <h3>Intensity Profile (Vertical Center Line)</h3>
                <canvas id="intensityCanvas" width="800" height="100"></canvas>
            </div>
        </div>

        <aside class="sidebar">
            <div class="panel">
                <h2>Experiment Mode</h2>
                <div class="mode-selector">
                    <button class="mode-btn btn-primary active" data-mode="free">Free Placement</button>
                    <button class="mode-btn btn-primary" data-mode="single-slit">Single Slit</button>
                    <button class="mode-btn btn-primary" data-mode="double-slit">Double Slit</button>
                </div>
                <div class="slit-controls" id="slitControls">
                    <div class="control-group">
                        <label>Slit Width: <span id="slitWidthValue">40</span>px</label>
                        <div class="slider-container">
                            <input type="range" id="slitWidth" min="10" max="100" value="40">
                        </div>
                    </div>
                    <div class="control-group" id="slitSeparationControl">
                        <label>Slit Separation: <span id="slitSeparationValue">80</span>px</label>
                        <div class="slider-container">
                            <input type="range" id="slitSeparation" min="40" max="200" value="80">
                        </div>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h2>Wave Parameters</h2>
                <div class="control-group">
                    <label>Wavelength: <span id="wavelengthValue">30</span>px</label>
                    <div class="slider-container">
                        <input type="range" id="wavelength" min="10" max="80" value="30">
                    </div>
                </div>
                <div class="control-group">
                    <label>Amplitude: <span id="amplitudeValue">50</span></label>
                    <div class="slider-container">
                        <input type="range" id="amplitude" min="10" max="100" value="50">
                    </div>
                </div>
                <div class="control-group">
                    <label>Wave Speed: <span id="speedValue">2.0</span>px/frame</label>
                    <div class="slider-container">
                        <input type="range" id="speed" min="0.5" max="5" step="0.1" value="2">
                    </div>
                </div>
                <div class="control-group">
                    <label>Damping: <span id="dampingValue">0.01</span></label>
                    <div class="slider-container">
                        <input type="range" id="damping" min="0" max="0.05" step="0.001" value="0.01">
                    </div>
                </div>
            </div>

            <div class="panel">
                <h2>Visualization</h2>
                <div class="checkbox-group">
                    <input type="checkbox" id="showWavefronts" checked>
                    <label for="showWavefronts">Show Wave Fronts</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="showSources" checked>
                    <label for="showSources">Show Sources</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="showBarrier" checked>
                    <label for="showBarrier">Show Barrier</label>
                </div>
                <div class="control-group">
                    <label>Color Scheme</label>
                    <div class="color-scheme-selector">
                        <button class="color-scheme-btn btn-secondary active" data-scheme="classic">Classic</button>
                        <button class="color-scheme-btn btn-secondary" data-scheme="rainbow">Rainbow</button>
                        <button class="color-scheme-btn btn-secondary" data-scheme="thermal">Thermal</button>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h2>Controls</h2>
                <div class="button-group">
                    <button id="playPauseBtn" class="btn-success">Pause</button>
                    <button id="resetBtn" class="btn-danger">Reset</button>
                </div>
                <button id="tryAgainBtn" class="btn-warning">Try Again</button>
                <button id="clearSourcesBtn" class="btn-warning">Clear Sources</button>
                <button id="saveBtn" class="btn-secondary">Save Experiment</button>
                <button id="loadBtn" class="btn-secondary">Load Experiment</button>
            </div>

            <div class="panel">
                <h2>Difficulty Presets</h2>
                <div class="preset-list">
                    <button class="btn-primary" data-difficulty="easy">Easy (1-2 Sources)</button>
                    <button class="btn-primary" data-difficulty="medium">Medium (3-4 Sources)</button>
                    <button class="btn-primary" data-difficulty="hard">Hard (5+ with Barriers)</button>
                </div>
            </div>

            <div class="panel">
                <h2>Challenge Mode</h2>
                <button id="startChallengeBtn" class="btn-success">Start Challenge</button>
                <div class="status-bar">
                    <span class="label">Score:</span>
                    <span class="value" id="scoreDisplay">0</span>
                </div>
                <div class="status-bar">
                    <span class="label">Personal Best:</span>
                    <span class="value" id="bestScoreDisplay">0</span>
                </div>
                <div class="info-display" id="challengeInfo" style="display: none;">
                    <strong>Challenge:</strong><br>
                    <span id="challengeText">Match the target pattern!</span>
                </div>
            </div>

            <div class="panel">
                <h2>Preset Experiments</h2>
                <div class="preset-list">
                    <button class="btn-primary" data-preset="two-point">Two Point Sources</button>
                    <button class="btn-primary" data-preset="three-line">Three in Line</button>
                    <button class="btn-primary" data-preset="square">Four Corners</button>
                    <button class="btn-primary" data-preset="circle">Circular Array</button>
                </div>
            </div>

            <div class="panel">
                <h2>Information</h2>
                <div class="status-bar">
                    <span class="label">Active Sources:</span>
                    <span class="value" id="sourceCount">0</span>
                </div>
                <div class="status-bar">
                    <span class="label">Time:</span>
                    <span class="value" id="timeDisplay">0.0s</span>
                </div>
                <button id="howToPlayBtn" class="btn-primary" style="margin-bottom: 0.8rem;">How to Play</button>
                <div class="info-display" id="howToPlayPanel" style="display: none;">
                    <strong>How to Play:</strong><br>
                    â€¢ <strong>Click</strong> canvas to add wave sources<br>
                    â€¢ <strong>Space</strong> = Pause/Play<br>
                    â€¢ <strong>R</strong> = Reset simulation<br>
                    â€¢ <strong>1</strong> = Free placement mode<br>
                    â€¢ <strong>2</strong> = Single slit experiment<br>
                    â€¢ <strong>3</strong> = Double slit experiment<br>
                    â€¢ Watch interference patterns form<br>
                    â€¢ Observe constructive (bright) and destructive (dark) interference<br>
                    â€¢ Try challenge mode for pattern matching!
                </div>
                <div class="info-display">
                    <strong>Quick Tips:</strong><br>
                    â€¢ Adjust wavelength and amplitude<br>
                    â€¢ Try different difficulty presets<br>
                    â€¢ Touch support enabled for mobile
                </div>
            </div>
        </aside>
    </main>

    <script>
        // Canvas setup
        const canvas = document.getElementById('waveCanvas');
        const ctx = canvas.getContext('2d');
        const intensityCanvas = document.getElementById('intensityCanvas');
        const intensityCtx = intensityCanvas.getContext('2d');

        // State
        let sources = [];
        let time = 0;
        let running = true;
        let mode = 'free';
        let colorScheme = 'classic';
        let gameState = 'setup'; // State machine: setup, running, paused, challenge
        let challengeScore = 0;
        let challengeActive = false;
        let targetPattern = null;
        let personalBest = parseInt(localStorage.getItem('waveLabBestScore') || '0');

        // Parameters
        let wavelength = 30;
        let amplitude = 50;
        let speed = 2;
        let damping = 0.01;
        let slitWidth = 40;
        let slitSeparation = 80;

        // Display options
        let showWavefronts = true;
        let showSources = true;
        let showBarrier = true;

        // Barrier position (for slit experiments)
        const barrierX = canvas.width * 0.3;

        // Wave source class
        class WaveSource {
            constructor(x, y, phase = 0) {
                this.x = x;
                this.y = y;
                this.phase = phase;
                this.color = `hsl(${Math.random() * 360}, 70%, 60%)`;
                this.id = Math.random().toString(36).substr(2, 9);
            }

            getAmplitude(x, y, t) {
                const dx = x - this.x;
                const dy = y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance === 0) return amplitude;

                // Wave equation: A * sin(k*r - Ï‰*t + Ï†)
                const k = (2 * Math.PI) / wavelength; // Wave number
                const omega = speed * k; // Angular frequency
                const phase = k * distance - omega * t + this.phase;

                // Damping with distance
                const dampingFactor = Math.exp(-damping * distance);

                return amplitude * Math.sin(phase) * dampingFactor / Math.sqrt(distance + 1);
            }

            // Collision/overlap detection with another source
            intersects(other) {
                const dx = this.x - other.x;
                const dy = this.y - other.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < wavelength * 2; // Sources overlap if within 2 wavelengths
            }
        }

        // Detector class for measuring interference patterns
        class Detector {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.measurements = [];
                this.maxMeasurements = 100;
            }

            measure(amplitude) {
                this.measurements.push(amplitude);
                if (this.measurements.length > this.maxMeasurements) {
                    this.measurements.shift();
                }
            }

            getAverage() {
                if (this.measurements.length === 0) return 0;
                const sum = this.measurements.reduce((a, b) => a + b, 0);
                return sum / this.measurements.length;
            }
        }

        // Initialize
        function init() {
            resizeCanvas();
            loadFromLocalStorage();
            setupEventListeners();
            updateBestScoreDisplay();
            gameState = 'running';
            animate();
        }

        // Resize canvas to fit container
        function resizeCanvas() {
            const wrapper = canvas.parentElement;
            const rect = wrapper.getBoundingClientRect();
            const displayWidth = rect.width - 32; // Account for padding
            const aspectRatio = 4 / 3;
            const displayHeight = displayWidth / aspectRatio;

            canvas.style.width = displayWidth + 'px';
            canvas.style.height = displayHeight + 'px';

            intensityCanvas.style.width = displayWidth + 'px';
        }

        // Add wave source
        function addSource(x, y, phase = 0) {
            if (mode === 'free' && sources.length < 20) {
                const newSource = new WaveSource(x, y, phase);

                // Check for collisions/overlaps with existing sources
                let hasCollision = false;
                for (const existing of sources) {
                    if (newSource.intersects(existing)) {
                        hasCollision = true;
                        break;
                    }
                }

                sources.push(newSource);
                updateSourceCount();

                // Update challenge score if active
                if (challengeActive) {
                    calculateChallengeScore();
                }
            }
        }

        // Clear all sources
        function clearSources() {
            sources = [];
            updateSourceCount();
        }

        // Calculate total amplitude at a point
        function calculateAmplitude(x, y, t) {
            if (sources.length === 0) return 0;

            let totalAmplitude = 0;

            for (const source of sources) {
                totalAmplitude += source.getAmplitude(x, y, t);
            }

            return totalAmplitude;
        }

        // Check if point is blocked by barrier
        function isBlocked(x, y) {
            if (!showBarrier || mode === 'free') return false;

            if (x < barrierX) return false;

            const barrierThickness = 10;
            if (Math.abs(x - barrierX) > barrierThickness) return false;

            const centerY = canvas.height / 2;

            if (mode === 'single-slit') {
                const slitTop = centerY - slitWidth / 2;
                const slitBottom = centerY + slitWidth / 2;
                return y < slitTop || y > slitBottom;
            } else if (mode === 'double-slit') {
                const slit1Center = centerY - slitSeparation / 2;
                const slit2Center = centerY + slitSeparation / 2;

                const inSlit1 = Math.abs(y - slit1Center) < slitWidth / 2;
                const inSlit2 = Math.abs(y - slit2Center) < slitWidth / 2;

                return !inSlit1 && !inSlit2;
            }

            return false;
        }

        // Get color for amplitude value
        function getColor(amp, maxAmp) {
            const normalized = amp / maxAmp;

            if (colorScheme === 'classic') {
                // Blue (negative) -> White (zero) -> Red (positive)
                if (normalized < 0) {
                    const t = Math.abs(normalized);
                    const r = Math.floor(255 * (1 - t));
                    const g = Math.floor(255 * (1 - t));
                    const b = 255;
                    return `rgb(${r}, ${g}, ${b})`;
                } else {
                    const t = normalized;
                    const r = 255;
                    const g = Math.floor(255 * (1 - t));
                    const b = Math.floor(255 * (1 - t));
                    return `rgb(${r}, ${g}, ${b})`;
                }
            } else if (colorScheme === 'rainbow') {
                // Rainbow spectrum
                const hue = ((normalized + 1) / 2) * 300;
                const saturation = 100;
                const lightness = 50 + Math.abs(normalized) * 30;
                return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
            } else if (colorScheme === 'thermal') {
                // Thermal (black -> red -> yellow -> white)
                const t = (normalized + 1) / 2;
                let r, g, b;
                if (t < 0.33) {
                    const s = t / 0.33;
                    r = Math.floor(255 * s);
                    g = 0;
                    b = 0;
                } else if (t < 0.66) {
                    const s = (t - 0.33) / 0.33;
                    r = 255;
                    g = Math.floor(255 * s);
                    b = 0;
                } else {
                    const s = (t - 0.66) / 0.34;
                    r = 255;
                    g = 255;
                    b = Math.floor(255 * s);
                }
                return `rgb(${r}, ${g}, ${b})`;
            }
        }

        // Render wave field
        function renderWaveField() {
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;

            const maxAmp = amplitude * sources.length * 0.5;

            // Calculate amplitude for each pixel
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const index = (y * canvas.width + x) * 4;

                    if (isBlocked(x, y)) {
                        // Barrier is dark gray
                        data[index] = 40;
                        data[index + 1] = 40;
                        data[index + 2] = 40;
                        data[index + 3] = 255;
                    } else {
                        const amp = calculateAmplitude(x, y, time);
                        const color = getColor(amp, maxAmp);

                        // Parse RGB from color string
                        const match = color.match(/\d+/g);
                        if (match) {
                            data[index] = parseInt(match[0]);
                            data[index + 1] = parseInt(match[1]);
                            data[index + 2] = parseInt(match[2]);
                            data[index + 3] = 255;
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        // Draw wavefronts
        function drawWavefronts() {
            if (!showWavefronts) return;

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;

            for (const source of sources) {
                const maxRadius = Math.max(canvas.width, canvas.height);
                const numWavefronts = Math.floor(maxRadius / wavelength);

                for (let i = 1; i <= numWavefronts; i++) {
                    const phase = (time * speed * 2 * Math.PI / wavelength + source.phase) % (2 * Math.PI);
                    const radius = i * wavelength - (phase / (2 * Math.PI)) * wavelength;

                    if (radius > 0) {
                        ctx.beginPath();
                        ctx.arc(source.x, source.y, radius, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }
            }
        }

        // Draw sources
        function drawSources() {
            if (!showSources) return;

            for (const source of sources) {
                // Outer glow
                const gradient = ctx.createRadialGradient(source.x, source.y, 0, source.x, source.y, 15);
                gradient.addColorStop(0, source.color);
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.fillRect(source.x - 15, source.y - 15, 30, 30);

                // Inner circle
                ctx.fillStyle = source.color;
                ctx.beginPath();
                ctx.arc(source.x, source.y, 5, 0, Math.PI * 2);
                ctx.fill();

                // White center
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(source.x, source.y, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Draw barrier
        function drawBarrier() {
            if (!showBarrier || mode === 'free') return;

            ctx.fillStyle = 'rgba(100, 100, 100, 0.8)';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 10;

            const centerY = canvas.height / 2;

            if (mode === 'single-slit') {
                const slitTop = centerY - slitWidth / 2;
                const slitBottom = centerY + slitWidth / 2;

                // Top barrier
                ctx.fillRect(barrierX - 5, 0, 10, slitTop);
                // Bottom barrier
                ctx.fillRect(barrierX - 5, slitBottom, 10, canvas.height - slitBottom);
            } else if (mode === 'double-slit') {
                const slit1Center = centerY - slitSeparation / 2;
                const slit2Center = centerY + slitSeparation / 2;

                const slit1Top = slit1Center - slitWidth / 2;
                const slit1Bottom = slit1Center + slitWidth / 2;
                const slit2Top = slit2Center - slitWidth / 2;
                const slit2Bottom = slit2Center + slitWidth / 2;

                // Top barrier
                ctx.fillRect(barrierX - 5, 0, 10, slit1Top);
                // Middle barrier
                ctx.fillRect(barrierX - 5, slit1Bottom, 10, slit2Top - slit1Bottom);
                // Bottom barrier
                ctx.fillRect(barrierX - 5, slit2Bottom, 10, canvas.height - slit2Bottom);
            }

            ctx.shadowBlur = 0;
        }

        // Draw intensity graph
        function drawIntensityGraph() {
            intensityCtx.fillStyle = '#000';
            intensityCtx.fillRect(0, 0, intensityCanvas.width, intensityCanvas.height);

            if (sources.length === 0) return;

            const centerY = canvas.height / 2;
            const maxAmp = amplitude * sources.length;

            intensityCtx.strokeStyle = '#64b5f6';
            intensityCtx.lineWidth = 2;
            intensityCtx.beginPath();

            for (let x = 0; x < intensityCanvas.width; x++) {
                const canvasX = (x / intensityCanvas.width) * canvas.width;
                const amp = calculateAmplitude(canvasX, centerY, time);
                const intensity = (amp / maxAmp + 1) / 2; // Normalize to 0-1
                const y = intensityCanvas.height - (intensity * intensityCanvas.height);

                if (x === 0) {
                    intensityCtx.moveTo(x, y);
                } else {
                    intensityCtx.lineTo(x, y);
                }
            }

            intensityCtx.stroke();

            // Draw center line
            intensityCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            intensityCtx.lineWidth = 1;
            intensityCtx.beginPath();
            intensityCtx.moveTo(0, intensityCanvas.height / 2);
            intensityCtx.lineTo(intensityCanvas.width, intensityCanvas.height / 2);
            intensityCtx.stroke();
        }

        // Animation loop
        function animate() {
            if (running && gameState === 'running') {
                time += 0.1;
                document.getElementById('timeDisplay').textContent = (time / 10).toFixed(1) + 's';
            }

            // Render
            renderWaveField();
            drawWavefronts();
            drawBarrier();
            drawSources();
            drawIntensityGraph();

            requestAnimationFrame(animate);
        }

        // Challenge mode functions
        function startChallenge() {
            clearSources();
            challengeActive = true;
            challengeScore = 0;
            gameState = 'running';
            running = true;

            // Generate random target pattern
            const numSources = Math.floor(Math.random() * 3) + 2; // 2-4 sources
            targetPattern = [];
            for (let i = 0; i < numSources; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                targetPattern.push({ x, y });
            }

            document.getElementById('challengeInfo').style.display = 'block';
            document.getElementById('challengeText').textContent =
                `Create an interference pattern with ${numSources} sources. Match the target as closely as possible!`;
        }

        function calculateChallengeScore() {
            if (!challengeActive || !targetPattern) return;

            // Simple scoring: based on source count and pattern similarity
            let score = 100;

            // Penalty for wrong number of sources
            const targetCount = targetPattern.length;
            const diff = Math.abs(sources.length - targetCount);
            score -= diff * 20;

            // Bonus for time efficiency
            score += Math.max(0, 50 - time / 10);

            challengeScore = Math.max(0, Math.floor(score));
            document.getElementById('scoreDisplay').textContent = challengeScore;

            // Update personal best
            if (challengeScore > personalBest) {
                personalBest = challengeScore;
                localStorage.setItem('waveLabBestScore', personalBest.toString());
                updateBestScoreDisplay();
            }
        }

        function updateBestScoreDisplay() {
            document.getElementById('bestScoreDisplay').textContent = personalBest;
        }

        // Load difficulty presets
        function loadDifficultyPreset(difficulty) {
            clearSources();
            gameState = 'running';
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;

            switch (difficulty) {
                case 'easy':
                    // 1-2 sources, simple pattern
                    mode = 'free';
                    addSource(cx - 100, cy);
                    addSource(cx + 100, cy);
                    wavelength = 40;
                    amplitude = 60;
                    document.getElementById('wavelength').value = wavelength;
                    document.getElementById('wavelengthValue').textContent = wavelength;
                    document.getElementById('amplitude').value = amplitude;
                    document.getElementById('amplitudeValue').textContent = amplitude;
                    break;

                case 'medium':
                    // 3-4 sources, moderate complexity
                    mode = 'free';
                    addSource(cx - 150, cy - 80);
                    addSource(cx + 150, cy - 80);
                    addSource(cx, cy + 100);
                    addSource(cx - 75, cy);
                    wavelength = 30;
                    amplitude = 50;
                    document.getElementById('wavelength').value = wavelength;
                    document.getElementById('wavelengthValue').textContent = wavelength;
                    document.getElementById('amplitude').value = amplitude;
                    document.getElementById('amplitudeValue').textContent = amplitude;
                    break;

                case 'hard':
                    // 5+ sources with barrier (double slit)
                    mode = 'double-slit';
                    document.querySelectorAll('.mode-btn').forEach(btn => {
                        btn.classList.toggle('active', btn.dataset.mode === 'double-slit');
                    });
                    const slitControls = document.getElementById('slitControls');
                    const slitSeparationControl = document.getElementById('slitSeparationControl');
                    slitControls.classList.add('active');
                    slitSeparationControl.style.display = 'block';
                    setupSlitSources();
                    wavelength = 25;
                    amplitude = 45;
                    slitWidth = 30;
                    slitSeparation = 100;
                    document.getElementById('wavelength').value = wavelength;
                    document.getElementById('wavelengthValue').textContent = wavelength;
                    document.getElementById('amplitude').value = amplitude;
                    document.getElementById('amplitudeValue').textContent = amplitude;
                    document.getElementById('slitWidth').value = slitWidth;
                    document.getElementById('slitWidthValue').textContent = slitWidth;
                    document.getElementById('slitSeparation').value = slitSeparation;
                    document.getElementById('slitSeparationValue').textContent = slitSeparation;
                    break;
            }
        }

        // Setup slit experiment sources
        function setupSlitSources() {
            clearSources();
            const sourceX = 50;
            const numSources = 5;
            const spacing = canvas.height / (numSources + 1);

            for (let i = 1; i <= numSources; i++) {
                addSource(sourceX, spacing * i, 0);
            }
        }

        // Event listeners
        function setupEventListeners() {
            // Canvas click
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;

                addSource(x, y);
            });

            // Touch support for mobile
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const touch = e.touches[0];
                const x = (touch.clientX - rect.left) * scaleX;
                const y = (touch.clientY - rect.top) * scaleY;

                addSource(x, y);
            });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const touch = e.touches[0];
                const x = (touch.clientX - rect.left) * scaleX;
                const y = (touch.clientY - rect.top) * scaleY;

                addSource(x, y);
            });

            // Keyboard controls
            let keysPressed = {};

            document.addEventListener('keydown', (e) => {
                keysPressed[e.key.toLowerCase()] = true;

                // Space = pause/play
                if (e.key === ' ') {
                    e.preventDefault();
                    running = !running;
                    gameState = running ? 'running' : 'paused';
                    document.getElementById('playPauseBtn').textContent = running ? 'Pause' : 'Play';
                }

                // R = reset
                if (e.key.toLowerCase() === 'r') {
                    e.preventDefault();
                    time = 0;
                    clearSources();
                }

                // 1 = free mode
                if (e.key === '1') {
                    e.preventDefault();
                    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                    const btn = document.querySelector('[data-mode="free"]');
                    btn.classList.add('active');
                    mode = 'free';
                    document.getElementById('slitControls').classList.remove('active');
                    clearSources();
                }

                // 2 = single slit
                if (e.key === '2') {
                    e.preventDefault();
                    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                    const btn = document.querySelector('[data-mode="single-slit"]');
                    btn.classList.add('active');
                    mode = 'single-slit';
                    const slitControls = document.getElementById('slitControls');
                    const slitSeparationControl = document.getElementById('slitSeparationControl');
                    slitControls.classList.add('active');
                    slitSeparationControl.style.display = 'none';
                    setupSlitSources();
                }

                // 3 = double slit
                if (e.key === '3') {
                    e.preventDefault();
                    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                    const btn = document.querySelector('[data-mode="double-slit"]');
                    btn.classList.add('active');
                    mode = 'double-slit';
                    const slitControls = document.getElementById('slitControls');
                    const slitSeparationControl = document.getElementById('slitSeparationControl');
                    slitControls.classList.add('active');
                    slitSeparationControl.style.display = 'block';
                    setupSlitSources();
                }
            });

            document.addEventListener('keyup', (e) => {
                keysPressed[e.key.toLowerCase()] = false;
            });

            // Mode buttons
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    mode = btn.dataset.mode;

                    const slitControls = document.getElementById('slitControls');
                    const slitSeparationControl = document.getElementById('slitSeparationControl');

                    if (mode === 'single-slit' || mode === 'double-slit') {
                        slitControls.classList.add('active');
                        slitSeparationControl.style.display = mode === 'double-slit' ? 'block' : 'none';
                        setupSlitSources();
                    } else {
                        slitControls.classList.remove('active');
                        clearSources();
                    }
                });
            });

            // Wavelength slider
            document.getElementById('wavelength').addEventListener('input', (e) => {
                wavelength = parseFloat(e.target.value);
                document.getElementById('wavelengthValue').textContent = wavelength;
            });

            // Amplitude slider
            document.getElementById('amplitude').addEventListener('input', (e) => {
                amplitude = parseFloat(e.target.value);
                document.getElementById('amplitudeValue').textContent = amplitude;
            });

            // Speed slider
            document.getElementById('speed').addEventListener('input', (e) => {
                speed = parseFloat(e.target.value);
                document.getElementById('speedValue').textContent = speed.toFixed(1);
            });

            // Damping slider
            document.getElementById('damping').addEventListener('input', (e) => {
                damping = parseFloat(e.target.value);
                document.getElementById('dampingValue').textContent = damping.toFixed(3);
            });

            // Slit width slider
            document.getElementById('slitWidth').addEventListener('input', (e) => {
                slitWidth = parseFloat(e.target.value);
                document.getElementById('slitWidthValue').textContent = slitWidth;
            });

            // Slit separation slider
            document.getElementById('slitSeparation').addEventListener('input', (e) => {
                slitSeparation = parseFloat(e.target.value);
                document.getElementById('slitSeparationValue').textContent = slitSeparation;
            });

            // Checkboxes
            document.getElementById('showWavefronts').addEventListener('change', (e) => {
                showWavefronts = e.target.checked;
            });

            document.getElementById('showSources').addEventListener('change', (e) => {
                showSources = e.target.checked;
            });

            document.getElementById('showBarrier').addEventListener('change', (e) => {
                showBarrier = e.target.checked;
            });

            // Color scheme
            document.querySelectorAll('.color-scheme-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.color-scheme-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    colorScheme = btn.dataset.scheme;
                });
            });

            // Play/Pause button
            document.getElementById('playPauseBtn').addEventListener('click', () => {
                running = !running;
                gameState = running ? 'running' : 'paused';
                document.getElementById('playPauseBtn').textContent = running ? 'Pause' : 'Play';
            });

            // Reset button
            document.getElementById('resetBtn').addEventListener('click', () => {
                time = 0;
                clearSources();
                gameState = 'running';
                challengeActive = false;
                document.getElementById('challengeInfo').style.display = 'none';
            });

            // Try Again button
            document.getElementById('tryAgainBtn').addEventListener('click', () => {
                time = 0;
                gameState = 'running';
                running = true;
                document.getElementById('playPauseBtn').textContent = 'Pause';
            });

            // Clear sources button
            document.getElementById('clearSourcesBtn').addEventListener('click', () => {
                clearSources();
            });

            // How to Play button
            document.getElementById('howToPlayBtn').addEventListener('click', () => {
                const panel = document.getElementById('howToPlayPanel');
                panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            });

            // Difficulty preset buttons
            document.querySelectorAll('[data-difficulty]').forEach(btn => {
                btn.addEventListener('click', () => {
                    loadDifficultyPreset(btn.dataset.difficulty);
                });
            });

            // Challenge mode button
            document.getElementById('startChallengeBtn').addEventListener('click', () => {
                startChallenge();
            });

            // Save button
            document.getElementById('saveBtn').addEventListener('click', saveToLocalStorage);

            // Load button
            document.getElementById('loadBtn').addEventListener('click', loadFromLocalStorage);

            // Preset buttons
            document.querySelectorAll('[data-preset]').forEach(btn => {
                btn.addEventListener('click', () => {
                    loadPreset(btn.dataset.preset);
                });
            });

            // Window resize
            window.addEventListener('resize', resizeCanvas);
        }

        // Update source count display
        function updateSourceCount() {
            document.getElementById('sourceCount').textContent = sources.length;
        }

        // Load preset
        function loadPreset(preset) {
            clearSources();
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;

            switch (preset) {
                case 'two-point':
                    addSource(cx - 100, cy);
                    addSource(cx + 100, cy);
                    break;

                case 'three-line':
                    addSource(cx - 150, cy);
                    addSource(cx, cy);
                    addSource(cx + 150, cy);
                    break;

                case 'square':
                    addSource(100, 100);
                    addSource(canvas.width - 100, 100);
                    addSource(100, canvas.height - 100);
                    addSource(canvas.width - 100, canvas.height - 100);
                    break;

                case 'circle':
                    const numSources = 8;
                    const radius = 150;
                    for (let i = 0; i < numSources; i++) {
                        const angle = (i / numSources) * Math.PI * 2;
                        const x = cx + Math.cos(angle) * radius;
                        const y = cy + Math.sin(angle) * radius;
                        addSource(x, y, angle);
                    }
                    break;
            }
        }

        // Save to localStorage
        function saveToLocalStorage() {
            const state = {
                sources: sources.map(s => ({ x: s.x, y: s.y, phase: s.phase, color: s.color })),
                wavelength,
                amplitude,
                speed,
                damping,
                mode,
                colorScheme,
                slitWidth,
                slitSeparation,
                showWavefronts,
                showSources,
                showBarrier
            };

            localStorage.setItem('waveInterferenceLab', JSON.stringify(state));
            alert('Experiment saved successfully!');
        }

        // Load from localStorage
        function loadFromLocalStorage() {
            const saved = localStorage.getItem('waveInterferenceLab');
            if (!saved) return;

            try {
                const state = JSON.parse(saved);

                // Restore sources
                sources = state.sources.map(s => {
                    const source = new WaveSource(s.x, s.y, s.phase);
                    source.color = s.color;
                    return source;
                });

                // Restore parameters
                wavelength = state.wavelength || 30;
                amplitude = state.amplitude || 50;
                speed = state.speed || 2;
                damping = state.damping || 0.01;
                mode = state.mode || 'free';
                colorScheme = state.colorScheme || 'classic';
                slitWidth = state.slitWidth || 40;
                slitSeparation = state.slitSeparation || 80;
                showWavefronts = state.showWavefronts !== false;
                showSources = state.showSources !== false;
                showBarrier = state.showBarrier !== false;

                // Update UI
                document.getElementById('wavelength').value = wavelength;
                document.getElementById('wavelengthValue').textContent = wavelength;
                document.getElementById('amplitude').value = amplitude;
                document.getElementById('amplitudeValue').textContent = amplitude;
                document.getElementById('speed').value = speed;
                document.getElementById('speedValue').textContent = speed.toFixed(1);
                document.getElementById('damping').value = damping;
                document.getElementById('dampingValue').textContent = damping.toFixed(3);
                document.getElementById('slitWidth').value = slitWidth;
                document.getElementById('slitWidthValue').textContent = slitWidth;
                document.getElementById('slitSeparation').value = slitSeparation;
                document.getElementById('slitSeparationValue').textContent = slitSeparation;
                document.getElementById('showWavefronts').checked = showWavefronts;
                document.getElementById('showSources').checked = showSources;
                document.getElementById('showBarrier').checked = showBarrier;

                // Update mode buttons
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.mode === mode);
                });

                // Update color scheme buttons
                document.querySelectorAll('.color-scheme-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.scheme === colorScheme);
                });

                // Update slit controls
                const slitControls = document.getElementById('slitControls');
                const slitSeparationControl = document.getElementById('slitSeparationControl');
                if (mode === 'single-slit' || mode === 'double-slit') {
                    slitControls.classList.add('active');
                    slitSeparationControl.style.display = mode === 'double-slit' ? 'block' : 'none';
                } else {
                    slitControls.classList.remove('active');
                }

                updateSourceCount();
            } catch (e) {
                console.error('Failed to load saved state:', e);
            }
        }

        // Initialize app
        init();
    </script>
</body>
</html>