<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Colony Mind</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üêú</text></svg>">
    <meta name="description" content="CYCLE 14: Advanced Emergence - Ant Legends immortalize exceptional ants, Queen Dynasties span generations, Seasonal Weather creates strategic depth, Emergent Personalities bring ants to life, and Heroic Last Stands let you choose sacrifice over survival. Your colony's story will be unforgettable.">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #1a1510; min-height: 100vh; font-family: 'Georgia', serif; color: #a09070; overflow: hidden; }
        #canvas { position: fixed; top: 0; left: 0; cursor: crosshair; }
        #controls {
            position: fixed; bottom: 20px; left: 20px; background: rgba(26,21,16,0.7);
            padding: 20px; border-radius: 10px; border: 1px solid rgba(160,120,80,0.3);
            z-index: 100;
            transition: opacity 0.3s ease, transform 0.3s ease;
            opacity: 0.15;
            backdrop-filter: blur(4px);
            max-height: 40vh;
            overflow-y: auto;
        }
        #controls:hover { opacity: 1; }
        #controls.minimized { transform: translateY(92%); opacity: 0.1; }
        #controls.minimized:hover { opacity: 0.8; transform: translateY(88%); }
        #controls.hidden { display: none; }

        #controls-minimize {
            position: absolute; top: 5px; right: 10px;
            width: 24px; height: 24px; padding: 0; margin: 0;
            background: none; border: none; color: #c0a070;
            font-size: 18px; cursor: pointer; display: flex;
            align-items: center; justify-content: center;
            opacity: 0.6;
        }
        #controls-minimize:hover { opacity: 1; background: rgba(255,255,255,0.1); border-radius: 4px; }

        h3 { margin-bottom: 10px; color: #c0a070; font-weight: normal; padding-right: 20px; font-size: 16px; }
        .control-row { margin: 8px 0; }
        label { display: block; font-size: 11px; margin-bottom: 5px; opacity: 0.8; }
        input[type="range"] { width: 140px; }
        .value { float: right; color: #d0b080; font-size: 12px; }
        button {
            display: block; width: 100%; padding: 8px; margin: 4px 0;
            background: rgba(100,80,50,0.4); border: 1px solid rgba(160,120,80,0.4);
            color: #a09060; cursor: pointer; border-radius: 6px; font-family: inherit;
        }
        button:hover { background: rgba(120,100,70,0.5); }
        .btn-group { display: flex; gap: 6px; }
        .btn-group button { flex: 1; }
        .btn-export { background: rgba(80,100,60,0.4); border-color: rgba(120,160,80,0.4); }
        .btn-import { background: rgba(60,80,100,0.4); border-color: rgba(80,120,160,0.4); }
        #file-input { display: none; }
        .save-info { font-size: 10px; opacity: 0.6; text-align: center; margin-top: 8px; }
        #stats {
            position: fixed; bottom: 20px; right: 20px; font-size: 12px; color: #806050; z-index: 100; text-align: right;
            border: 2px solid rgba(160,120,80,0.3); padding: 12px; border-radius: 8px;
            background: rgba(26,21,16,0.6); transition: all 0.3s ease;
            opacity: 0.15; backdrop-filter: blur(4px);
        }
        #stats:hover { opacity: 1; }
        #stats.hidden { display: none; }

        #info { position: fixed; bottom: 5px; left: 50%; transform: translateX(-50%); font-size: 10px; opacity: 0.2; z-index: 100; transition: opacity 0.3s ease; }
        #info:hover { opacity: 0.8; }
        #info.hidden { display: none; }

        #weather-indicator {
            position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: rgba(26,21,16,0.7); padding: 8px 16px; border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.1); z-index: 100;
            font-size: 13px; display: flex; align-items: center; gap: 8px;
            opacity: 0.15; transition: opacity 0.3s ease;
            backdrop-filter: blur(4px);
        }
        #weather-indicator:hover { opacity: 1; }
        #weather-indicator.hidden { display: none !important; }
        .hidden { display: none !important; }
        #weather-icon { font-size: 18px; }
        #weather-name { color: #c0a070; }
        #weather-timer { color: #806050; font-size: 11px; }
        .speed-controls { display: flex; gap: 4px; margin: 6px 0; }
        .speed-btn {
            flex: 1; padding: 6px 4px; font-size: 10px;
            background: rgba(60,50,40,0.4); border: 1px solid rgba(120,100,80,0.3);
        }
        .speed-btn.active { background: rgba(120,100,60,0.6); border-color: rgba(180,140,80,0.5); }
        .btn-pause { background: rgba(120,80,60,0.4); border-color: rgba(180,120,80,0.4); }
        .btn-pause.paused { background: rgba(80,120,60,0.5); border-color: rgba(120,180,80,0.5); }

        /* ============ UI/UX IMPROVEMENTS ============ */

        /* Button categories */
        .btn-sound { background: rgba(80,60,100,0.4); border-color: rgba(140,100,180,0.4); }
        .btn-sound.active { background: rgba(100,80,140,0.6); border-color: rgba(160,120,200,0.6); }
        .btn-visual { background: rgba(100,80,60,0.4); border-color: rgba(160,120,80,0.4); }
        .btn-visual.active { background: rgba(120,100,80,0.6); border-color: rgba(180,140,100,0.6); }
        .btn-bloom { background: rgba(100,60,120,0.4); border-color: rgba(160,100,180,0.4); }
        .btn-bloom.active { background: rgba(120,80,140,0.6); border-color: rgba(180,120,200,0.6); }
        .btn-danger { background: rgba(120,60,60,0.4); border-color: rgba(180,80,80,0.4); }
        .btn-danger.active { background: rgba(140,80,80,0.6); border-color: rgba(200,100,100,0.6); }
        .btn-legacy { background: rgba(140,110,50,0.4); border-color: rgba(200,160,80,0.4); }
        .btn-share { background: rgba(80,120,180,0.4); border-color: rgba(100,160,220,0.4); }
        .btn-small { font-size: 10px; padding: 6px; opacity: 0.8; }

        /* Control sections */
        .control-section {
            margin: 12px 0;
            padding-top: 10px;
            border-top: 1px solid rgba(160,120,80,0.2);
        }
        .control-section:first-child {
            margin-top: 0;
            padding-top: 0;
            border-top: none;
        }
        .control-section-title {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #806050;
            margin-bottom: 8px;
        }

        /* Collapsible advanced section */
        .advanced-toggle {
            width: 100%;
            text-align: center;
            font-size: 11px;
            padding: 6px;
            background: rgba(60,50,40,0.3);
            border: 1px dashed rgba(120,100,80,0.3);
            color: #908070;
            cursor: pointer;
        }
        .advanced-toggle:hover {
            background: rgba(80,70,60,0.4);
        }
        .advanced-section {
            display: none;
            margin-top: 8px;
        }
        .advanced-section.visible {
            display: block;
        }

        /* Improved button grid */
        .btn-row {
            display: flex;
            gap: 6px;
            margin: 6px 0;
        }
        .btn-row button {
            flex: 1;
            margin: 0;
        }

        /* Keyboard hint */
        .kbd-hint {
            font-size: 9px;
            opacity: 0.5;
            margin-left: 4px;
        }

        /* Improved Stats Panel */
        .stat-row {
            margin: 3px 0;
        }
        .stats-roles {
            margin-top: 8px;
            padding-top: 6px;
            border-top: 1px solid rgba(128,96,80,0.3);
        }
        .role-bar {
            width: 100%;
            height: 8px;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            overflow: hidden;
            display: flex;
            margin-bottom: 6px;
        }
        .role-bar-segment {
            height: 100%;
            transition: width 0.3s;
        }
        .role-workers { background: #8B7355; }
        .role-excavators { background: #A0522D; }
        .role-gatherers { background: #6B8E23; }
        .role-nurses { background: #CD853F; }
        .role-legend {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
        }
        .role-label {
            display: inline-flex;
            align-items: center;
            gap: 2px;
        }
        .role-label.role-workers { color: #C4A87C; }
        .role-label.role-excavators { color: #D4886A; }
        .role-label.role-gatherers { color: #9CB86B; }
        .role-label.role-nurses { color: #E8B87C; }
        .dynasty-info {
            margin-top: 8px;
            padding-top: 6px;
            border-top: 1px solid rgba(128,96,80,0.3);
            display: none;
        }
        .dynasty-info.visible {
            display: block;
        }
        .dynasty-queen-name {
            color: #d4a060;
            font-weight: bold;
        }
        .dynasty-generation {
            font-size: 11px;
            color: #a09070;
        }
        .dynasty-age {
            font-size: 10px;
            color: #808070;
            margin-top: 4px;
        }

        /* ============ CYCLE 6: ACCESSIBILITY ============ */
        .visually-hidden { position: absolute; left: -10000px; width: 1px; height: 1px; overflow: hidden; }
        button:focus, input:focus { outline: 2px solid #d0a060; outline-offset: 2px; box-shadow: 0 0 8px rgba(208, 160, 96, 0.5); }

        /* High-contrast mode */
        body.high-contrast { background: #000; }
        body.high-contrast #controls { background: rgba(0,0,0,0.95); border-color: #fff; }
        body.high-contrast h3, body.high-contrast label, body.high-contrast button { color: #fff; }
        body.high-contrast #stats { background: rgba(0,0,0,0.9); border-color: #fff; color: #fff; }
        body.high-contrast #weather-indicator { background: rgba(0,0,0,0.9); border-color: #fff; }
        body.high-contrast #info { color: #fff; }

        /* Auto-save indicator */
        #autosave-indicator {
            position: fixed; top: 20px; left: 20px; padding: 8px 12px;
            background: rgba(80,120,60,0.8); border-radius: 6px; font-size: 11px;
            opacity: 0; transition: opacity 0.3s; pointer-events: none; z-index: 200;
        }
        #autosave-indicator.saving { opacity: 1; background: rgba(180,140,60,0.8); }
        #autosave-indicator.saved { opacity: 1; }

        /* Performance indicator */
        #fps-indicator {
            position: fixed; top: 20px; right: 20px; font-size: 11px; color: #806050;
            background: rgba(26,21,16,0.8); padding: 6px 10px; border-radius: 6px;
            border: 1px solid rgba(160,120,80,0.3); z-index: 100;
        }
        #fps-indicator.fps-low { color: #d08060; border-color: rgba(208,128,96,0.5); }

        /* ============ CYCLE 6: MOBILE RESPONSIVENESS ============ */
        @media (max-width: 768px) {
            #controls {
                bottom: 10px; top: auto; left: 10px; padding: 12px; max-width: calc(100vw - 20px);
                max-height: 40vh; overflow-y: auto; font-size: 11px;
            }
            h3 { font-size: 14px; margin-bottom: 10px; }
            button { padding: 8px; margin: 4px 0; font-size: 11px; }
            input[type="range"] { width: 100px; }
            .save-info { font-size: 9px; }
            #stats {
                bottom: 10px; right: 10px; top: auto; font-size: 10px; padding: 8px;
                max-width: 140px;
            }
            #weather-indicator {
                bottom: 60px; top: auto; left: 50%; transform: translateX(-50%);
                padding: 6px 12px; font-size: 11px;
            }
            #info { display: none; } /* Hide on mobile to save space */
            #autosave-indicator { top: 10px; left: 10px; font-size: 10px; }
            #fps-indicator { top: 10px; right: 10px; }
        }

        /* Virtual joystick for mobile */
        #mobile-joystick {
            display: none; position: fixed; bottom: 80px; left: 20px;
            width: 100px; height: 100px; background: rgba(26,21,16,0.7);
            border: 2px solid rgba(160,120,80,0.4); border-radius: 50%;
            z-index: 150; touch-action: none;
        }
        #mobile-joystick-knob {
            position: absolute; width: 40px; height: 40px;
            background: rgba(160,120,80,0.8); border-radius: 50%;
            top: 50%; left: 50%; transform: translate(-50%, -50%);
            transition: transform 0.1s ease-out;
        }
        @media (max-width: 768px) and (pointer: coarse) {
            #mobile-joystick { display: block; }
        }

        /* Mobile action buttons */
        #mobile-actions {
            display: none; position: fixed; bottom: 80px; right: 20px; z-index: 150;
        }
        #mobile-actions button {
            width: 50px; height: 50px; border-radius: 50%; margin: 8px 0;
            font-size: 20px; padding: 0; display: flex; align-items: center;
            justify-content: center; background: rgba(100,80,50,0.8);
            border: 2px solid rgba(160,120,80,0.5);
        }
        @media (max-width: 768px) and (pointer: coarse) {
            #mobile-actions { display: block; }
        }

        /* Accessibility toolbar */
        #a11y-toolbar {
            position: fixed; top: 10px; left: 50%; transform: translateX(-50%);
            background: rgba(26,21,16,0.9); padding: 6px; border-radius: 8px;
            border: 1px solid rgba(160,120,80,0.3); z-index: 200;
            display: flex; gap: 8px; opacity: 0; transition: opacity 0.3s;
        }
        #a11y-toolbar.visible { opacity: 1; }
        #a11y-toolbar button {
            width: auto; padding: 6px 12px; margin: 0; font-size: 11px;
            background: rgba(80,60,40,0.6); border: 1px solid rgba(140,100,60,0.4);
        }
        #a11y-toolbar button:hover { background: rgba(100,80,60,0.7); }

        /* ============ CYCLE 7: PROFESSIONAL POLISH ============ */

        /* Tutorial Overlay System */
        #tutorial-overlay {
            position: fixed; inset: 0; background: rgba(0, 0, 0, 0.85); z-index: 1000;
            display: none; align-items: center; justify-content: center;
            animation: fadeIn 0.3s ease-out;
        }
        #tutorial-overlay.active { display: flex; }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        #tutorial-content {
            background: rgba(26,21,16,0.98); padding: 30px; border-radius: 12px;
            border: 2px solid rgba(200,160,100,0.6); max-width: 500px; width: 90%;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5); position: relative;
        }
        #tutorial-title {
            font-size: 24px; color: #d0a070; margin-bottom: 20px; text-align: center;
            font-weight: normal;
        }
        #tutorial-text {
            font-size: 16px; line-height: 1.8; color: #b09080; margin-bottom: 25px;
            min-height: 80px;
        }
        #tutorial-spotlight {
            position: fixed; border: 3px solid rgba(255,255,255,0.6); border-radius: 8px;
            pointer-events: none; z-index: 999; box-shadow: 0 0 30px rgba(255,255,255,0.3);
            transition: all 0.4s ease-out; display: none;
        }
        #tutorial-spotlight.active { display: block; }
        .tutorial-buttons {
            display: flex; gap: 12px; justify-content: center;
        }
        .tutorial-buttons button {
            padding: 12px 24px; margin: 0; width: auto; font-size: 14px;
            transition: all 0.2s ease;
        }
        .tutorial-buttons button:hover {
            transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        .tutorial-progress {
            display: flex; gap: 8px; justify-content: center; margin-top: 20px;
        }
        .tutorial-dot {
            width: 8px; height: 8px; border-radius: 50%; background: rgba(160,120,80,0.3);
            transition: background 0.3s ease;
        }
        .tutorial-dot.active { background: rgba(200,160,100,0.9); }

        /* Help Panel System */
        #help-panel {
            position: fixed; right: -400px; top: 0; width: 380px; height: 100vh;
            background: rgba(26,21,16,0.97); border-left: 2px solid rgba(160,120,80,0.4);
            z-index: 500; overflow-y: auto; padding: 20px; transition: right 0.3s ease-out;
            box-shadow: -5px 0 20px rgba(0,0,0,0.5);
        }
        #help-panel.visible { right: 0; }
        #help-panel-close {
            position: absolute; top: 15px; right: 15px; width: 30px; height: 30px;
            background: rgba(120,80,60,0.6); border-radius: 50%; padding: 0;
            display: flex; align-items: center; justify-content: center; cursor: pointer;
            font-size: 18px; line-height: 1; margin: 0;
        }
        #help-panel h2 {
            color: #d0a070; font-size: 20px; margin-bottom: 20px; font-weight: normal;
        }
        #help-panel h4 {
            color: #c0a070; font-size: 14px; margin: 18px 0 10px; font-weight: normal;
            border-bottom: 1px solid rgba(160,120,80,0.3); padding-bottom: 6px;
        }
        .help-section {
            margin-bottom: 15px; font-size: 12px; line-height: 1.6;
        }
        .help-legend {
            display: flex; align-items: center; gap: 10px; margin: 6px 0;
        }
        .help-legend-color {
            width: 20px; height: 20px; border-radius: 4px; border: 1px solid rgba(160,120,80,0.4);
        }
        .help-key {
            display: inline-block; background: rgba(100,80,60,0.4); padding: 2px 8px;
            border-radius: 4px; margin: 2px; font-family: monospace; font-size: 11px;
        }

        /* Enhanced Milestone Toast */
        #milestone-toast {
            position: fixed; bottom: 180px; left: 50%; transform: translateX(-50%) translateY(150%);
            background: rgba(26,21,16,0.9);
            color: #fff; padding: 16px 28px; border-radius: 16px; font-size: 15px;
            opacity: 0; transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: none; text-align: center; max-width: 400px; z-index: 800;
            border: 1px solid rgba(200,160,100,0.3); box-shadow: 0 12px 40px rgba(0,0,0,0.6);
            backdrop-filter: blur(12px);
        }
        #milestone-toast.show {
            opacity: 1; transform: translateX(-50%) translateY(0);
        }
        #milestone-title {
            font-size: 16px; font-weight: bold; margin-bottom: 6px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        #milestone-subtitle {
            font-size: 13px; opacity: 0.95;
        }
        #milestone-icon {
            font-size: 24px; margin-bottom: 8px;
        }

        /* Button Ripple Effect */
        button {
            position: relative; overflow: hidden; transition: all 0.15s ease;
        }
        button:active {
            transform: scale(0.98);
        }
        @keyframes ripple {
            from {
                transform: scale(0); opacity: 0.6;
            }
            to {
                transform: scale(4); opacity: 0;
            }
        }
        .ripple-effect {
            position: absolute; border-radius: 50%; background: rgba(255,255,255,0.6);
            width: 20px; height: 20px; pointer-events: none;
            animation: ripple 0.6s ease-out;
        }

        /* Auto-Save Recovery Banner */
        #autosave-recovery {
            position: fixed; bottom: 220px; left: 50%; transform: translateX(-50%) translateY(150%);
            background: rgba(26,21,16,0.95); color: #fff; padding: 14px 24px;
            border-radius: 16px; z-index: 1100; display: flex; align-items: center; gap: 15px;
            box-shadow: 0 12px 48px rgba(0,0,0,0.6); transition: all 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            border: 1px solid rgba(255,255,255,0.15);
            backdrop-filter: blur(12px);
            max-width: 90%;
        }
        #autosave-recovery.visible {
            transform: translateX(-50%) translateY(0);
        }
        #autosave-recovery-text {
            font-size: 13px; flex: 1; color: #d0b080; line-height: 1.4;
        }
        #autosave-recovery button {
            padding: 10px 20px; margin: 0; width: auto; font-size: 13px;
            background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2);
            color: #fff; border-radius: 8px; cursor: pointer;
        }
        #autosave-recovery button:hover {
            background: rgba(255,255,255,0.2);
            border-color: rgba(255,255,255,0.4);
        }
        #autosave-recovery-dismiss {
            font-size: 20px !important; padding: 5px 12px !important;
            color: #a09070 !important;
        }

        /* Tooltip System */
        .tooltip {
            position: absolute; background: rgba(26,21,16,0.95); color: #d0b080;
            padding: 8px 12px; border-radius: 6px; font-size: 11px; pointer-events: none;
            border: 1px solid rgba(160,120,80,0.4); z-index: 1100; white-space: nowrap;
            opacity: 0; transition: opacity 0.2s ease; box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        }
        .tooltip.visible { opacity: 1; }

        /* Mobile Adjustments for New Elements */
        @media (max-width: 768px) {
            #help-panel { width: 100%; right: -100%; }
            #tutorial-content { padding: 20px; max-width: 90%; }
            #tutorial-title { font-size: 20px; }
            #tutorial-text { font-size: 14px; min-height: 60px; }
            #milestone-toast { max-width: 90%; font-size: 13px; padding: 12px 20px; }
            #autosave-recovery { max-width: 90%; font-size: 12px; padding: 10px 16px; }
        }

        /* ============ CYCLE 8: SECRETS & SURPRISES ============ */

        /* Photo Mode Overlay */
        #photo-mode-overlay {
            position: fixed; inset: 0; background: rgba(0,0,0,0.95); z-index: 2000;
            display: none; align-items: center; justify-content: center; flex-direction: column;
        }
        #photo-mode-overlay.active { display: flex; }
        #photo-mode-canvas { max-width: 95vw; max-height: 85vh; border: 2px solid rgba(200,160,100,0.6); }
        #photo-mode-controls {
            margin-top: 20px; display: flex; gap: 12px; align-items: center;
        }
        #photo-mode-controls button {
            padding: 12px 24px; background: rgba(100,80,50,0.8); border: 1px solid rgba(160,120,80,0.5);
            color: #d0b080; cursor: pointer; border-radius: 8px; font-family: inherit; font-size: 14px;
        }
        #photo-mode-controls button:hover { background: rgba(120,100,70,0.9); }
        #photo-mode-zoom {
            width: 200px; height: 30px; background: rgba(60,50,40,0.6); border: 1px solid rgba(120,100,80,0.4);
            color: #d0b080; border-radius: 6px; padding: 0 10px; font-family: inherit;
        }

        /* Colony Legacy Panel */
        #legacy-panel {
            position: fixed; right: -450px; top: 0; width: 430px; height: 100vh;
            background: rgba(26,21,16,0.97); border-left: 2px solid rgba(160,120,80,0.4);
            z-index: 500; overflow-y: auto; padding: 20px; transition: right 0.3s ease-out;
            box-shadow: -5px 0 20px rgba(0,0,0,0.5);
        }
        #legacy-panel.visible { right: 0; }
        #legacy-panel-close {
            position: absolute; top: 15px; right: 15px; width: 30px; height: 30px;
            background: rgba(120,80,60,0.6); border-radius: 50%; padding: 0;
            display: flex; align-items: center; justify-content: center; cursor: pointer;
            font-size: 18px; line-height: 1; margin: 0; border: 1px solid rgba(160,120,80,0.4);
        }
        .legacy-section {
            margin-bottom: 20px; padding: 12px; background: rgba(40,30,20,0.4);
            border-radius: 8px; border: 1px solid rgba(100,80,60,0.3);
        }
        .legacy-section h3 {
            color: #d0a070; font-size: 16px; margin-bottom: 12px; border-bottom: 1px solid rgba(160,120,80,0.3);
            padding-bottom: 6px;
        }
        .legacy-stat {
            display: flex; justify-content: space-between; margin: 6px 0; font-size: 13px;
        }
        .legacy-stat-label { color: #a09070; }
        .legacy-stat-value { color: #d0b080; font-weight: bold; }
        .hall-of-fame-entry {
            background: rgba(60,50,40,0.5); padding: 10px; margin: 8px 0; border-radius: 6px;
            border: 1px solid rgba(140,100,60,0.4); cursor: pointer; transition: all 0.2s;
        }
        .hall-of-fame-entry:hover { background: rgba(80,70,60,0.6); border-color: rgba(180,140,80,0.6); }
        .hall-of-fame-name { font-size: 14px; color: #d0a070; margin-bottom: 4px; font-weight: bold; }
        .hall-of-fame-stats { font-size: 11px; color: #909070; }

        /* Achievement Tracker */
        #achievement-tracker {
            position: fixed; bottom: 160px; left: 20px; background: rgba(26,21,16,0.9);
            padding: 10px 14px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.1);
            z-index: 100; font-size: 11px; color: #a09070; max-width: 200px;
            opacity: 0; transition: opacity 0.3s; pointer-events: none;
            backdrop-filter: blur(8px);
        }
        #achievement-tracker.visible { opacity: 1; pointer-events: auto; }
        #achievement-progress { margin-top: 4px; color: #d0b080; }

        /* Achievement Toast */
        #achievement-toast {
            position: fixed; bottom: 100px; right: -400px; background: rgba(26,21,16,0.95);
            color: #fff; padding: 14px 20px; border-radius: 12px; font-size: 14px;
            transition: right 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); z-index: 800;
            border: 1px solid rgba(200,160,100,0.3); box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            max-width: 300px; backdrop-filter: blur(10px);
        }
        #achievement-toast.show { right: 20px; }
        #achievement-toast-icon { font-size: 20px; margin-bottom: 6px; color: #ffd700; }
        #achievement-toast-title { font-weight: bold; margin-bottom: 4px; color: #ffd700; }
        #achievement-toast-desc { font-size: 12px; opacity: 0.9; color: #d0b080; }

        /* Ant Thought Bubbles */
        .ant-thought-bubble {
            position: absolute; background: rgba(255,255,255,0.95); color: #2a1a10;
            padding: 6px 10px; border-radius: 12px; font-size: 10px; pointer-events: none;
            border: 1px solid rgba(100,80,60,0.6); box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            white-space: nowrap; z-index: 150; animation: thoughtFadeIn 0.3s ease-out;
        }
        .ant-thought-bubble::after {
            content: ''; position: absolute; bottom: -6px; left: 50%; transform: translateX(-50%);
            width: 0; height: 0; border-left: 6px solid transparent; border-right: 6px solid transparent;
            border-top: 6px solid rgba(255,255,255,0.95);
        }
        @keyframes thoughtFadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Visual Theme Indicator */
        #theme-indicator {
            position: fixed; top: 100px; left: 50%; transform: translateX(-50%) translateY(-100%);
            background: rgba(26,21,16,0.95); padding: 12px 20px; border-radius: 20px;
            border: 2px solid rgba(200,160,100,0.6); z-index: 800; font-size: 14px;
            color: #d0b080; opacity: 0; transition: all 0.4s ease-out;
        }
        #theme-indicator.show {
            opacity: 1; transform: translateX(-50%) translateY(0);
        }

        /* Mobile adjustments for CYCLE 8 */
        @media (max-width: 768px) {
            #legacy-panel { width: 100%; right: -100%; }
            #photo-mode-controls { flex-direction: column; }
            #achievement-tracker { bottom: 100px; left: 10px; max-width: 150px; font-size: 10px; }
            #achievement-toast { max-width: 250px; font-size: 12px; }
        }

        /* ============ CYCLE 14: ADVANCED EMERGENCE ============ */

        /* Ant Legends Panel (reuses legacy panel styles) */
        #legends-panel {
            position: fixed; right: -450px; top: 0; width: 430px; height: 100vh;
            background: rgba(26,21,16,0.97); border-left: 2px solid rgba(200,160,100,0.5);
            z-index: 500; overflow-y: auto; padding: 20px; transition: right 0.3s ease-out;
            box-shadow: -5px 0 20px rgba(0,0,0,0.5);
        }
        #legends-panel.visible { right: 0; }
        #legends-panel-close {
            position: absolute; top: 15px; right: 15px; width: 30px; height: 30px;
            background: rgba(120,80,60,0.6); border-radius: 50%; padding: 0;
            display: flex; align-items: center; justify-content: center; cursor: pointer;
            font-size: 18px; line-height: 1; margin: 0; border: 1px solid rgba(200,160,100,0.5);
        }
        .legend-entry {
            background: linear-gradient(135deg, rgba(80,60,40,0.6), rgba(100,80,60,0.5));
            padding: 14px; margin: 10px 0; border-radius: 8px;
            border: 2px solid rgba(200,160,100,0.4); position: relative;
        }
        .legend-entry::before {
            content: '‚≠ê'; position: absolute; top: -8px; left: 10px;
            font-size: 20px; background: rgba(26,21,16,0.9); padding: 0 6px; border-radius: 50%;
        }
        .legend-name {
            font-size: 16px; color: #ffd700; margin-bottom: 6px; font-weight: bold;
        }
        .legend-achievement {
            font-size: 12px; color: #d0a070; margin-bottom: 8px; font-style: italic;
        }
        .legend-stats {
            font-size: 11px; color: #a09070; line-height: 1.6;
        }
        .legend-memorial-marker {
            display: inline-block; margin-right: 6px; opacity: 0.7;
        }

        /* Dynasty Display in Stats Panel */
        #dynasty-info {
            margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(160,120,80,0.3);
            font-size: 11px;
        }
        .dynasty-queen-name {
            color: #ffd700; font-weight: bold; margin-bottom: 4px;
        }
        .dynasty-generation {
            color: #c0a070; font-size: 10px; opacity: 0.8;
        }
        .dynasty-age-warning {
            color: #ff8060; transition: opacity 1s ease-in-out;
        }
        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1.0; }
        }

        /* Seasonal Indicator (enhances weather indicator) */
        #season-name {
            margin-left: 8px; padding-left: 8px; border-left: 1px solid rgba(160,120,80,0.4);
            color: #90a070; font-size: 11px;
        }

        /* Danger Mode Panel */
        #danger-panel {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.8);
            background: linear-gradient(135deg, rgba(180,60,40,0.95), rgba(160,40,30,0.95));
            border: 3px solid rgba(255,100,80,0.8); border-radius: 16px; padding: 30px;
            z-index: 2000; box-shadow: 0 20px 60px rgba(0,0,0,0.8), 0 0 100px rgba(255,80,60,0.4);
            opacity: 0; pointer-events: none; transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            max-width: 500px; text-align: center;
        }
        #danger-panel.active {
            opacity: 1; transform: translate(-50%, -50%) scale(1); pointer-events: auto;
        }
        #danger-panel-title {
            font-size: 28px; color: #fff; margin-bottom: 16px; font-weight: bold;
            text-shadow: 0 2px 8px rgba(0,0,0,0.6);
        }
        @keyframes dangerPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        #danger-panel-message {
            font-size: 16px; color: #ffe0d0; margin-bottom: 24px; line-height: 1.6;
        }
        .danger-choice-btn {
            display: block; width: 100%; padding: 14px 20px; margin: 10px 0;
            background: rgba(40,30,30,0.7); border: 2px solid rgba(255,200,180,0.6);
            color: #fff; font-size: 15px; border-radius: 8px; cursor: pointer;
            font-family: inherit; transition: all 0.2s; position: relative; overflow: hidden;
        }
        .danger-choice-btn:hover {
            background: rgba(60,50,50,0.8); border-color: rgba(255,220,200,0.9);
            transform: translateY(-2px); box-shadow: 0 6px 20px rgba(0,0,0,0.5);
        }
        .danger-choice-success {
            color: #90ff90; font-size: 12px; margin-left: 8px;
        }
        .danger-choice-cost {
            color: #ffa0a0; font-size: 12px; margin-left: 8px;
        }

        /* Memorial Markers (in-world) */
        .memorial-marker {
            position: absolute; pointer-events: none; animation: memorialFadeIn 1s ease-out;
        }
        @keyframes memorialFadeIn {
            from { opacity: 0; transform: translateY(-10px) scale(0.5); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        /* Personality Trait Icons (hover tooltip) */
        .ant-personality-tooltip {
            position: absolute; background: rgba(26,21,16,0.95); color: #d0b080;
            padding: 8px 12px; border-radius: 6px; font-size: 11px; pointer-events: none;
            border: 1px solid rgba(200,160,100,0.5); z-index: 1100; white-space: nowrap;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4); opacity: 0; transition: opacity 0.2s;
        }
        .ant-personality-tooltip.visible { opacity: 1; }
        .trait-icon {
            display: inline-block; margin-right: 4px; font-size: 12px;
        }

        /* Mobile adjustments for CYCLE 14 */
        @media (max-width: 768px) {
            #legends-panel { width: 100%; right: -100%; }
            #danger-panel { max-width: 90%; padding: 20px; }
            #danger-panel-title { font-size: 22px; }
            #danger-panel-message { font-size: 14px; }
            .danger-choice-btn { font-size: 13px; padding: 12px 16px; }
        }

        /* ============ CYCLE 10: CHALLENGE MODES ============ */

        /* Challenge Mode Selector Modal */
        #challenge-mode-selector {
            position: fixed; inset: 0; background: rgba(0, 0, 0, 0.92); z-index: 2500;
            display: none; align-items: center; justify-content: center;
            animation: fadeIn 0.3s ease-out;
        }
        #challenge-mode-selector.active { display: flex; }
        #challenge-selector-content {
            background: rgba(26,21,16,0.98); padding: 40px; border-radius: 16px;
            border: 2px solid rgba(200,160,100,0.6); max-width: 900px; width: 90%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.7);
        }
        #challenge-selector-title {
            font-size: 28px; color: #d0a070; margin-bottom: 12px; text-align: center;
            font-weight: normal;
        }
        #challenge-selector-subtitle {
            font-size: 14px; color: #909070; text-align: center; margin-bottom: 30px;
        }
        .challenge-mode-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px; margin-bottom: 25px;
        }
        .challenge-mode-card {
            background: rgba(40,30,20,0.6); border: 2px solid rgba(120,100,80,0.4);
            border-radius: 12px; padding: 20px; cursor: pointer; transition: all 0.3s ease;
            position: relative; overflow: hidden;
        }
        .challenge-mode-card:hover {
            border-color: rgba(200,160,100,0.8); transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(0,0,0,0.4);
        }
        .challenge-mode-card.locked {
            opacity: 0.5; cursor: not-allowed;
        }
        .challenge-mode-card.locked:hover {
            transform: none; border-color: rgba(120,100,80,0.4);
        }
        .challenge-mode-icon {
            font-size: 48px; text-align: center; margin-bottom: 12px;
        }
        .challenge-mode-name {
            font-size: 18px; color: #d0a070; text-align: center; margin-bottom: 8px;
            font-weight: normal;
        }
        .challenge-mode-desc {
            font-size: 12px; color: #a09070; text-align: center; line-height: 1.5;
            margin-bottom: 12px;
        }
        .challenge-mode-difficulty {
            display: flex; justify-content: center; gap: 4px; margin-top: 10px;
        }
        .difficulty-dot {
            width: 8px; height: 8px; border-radius: 50%; background: rgba(160,120,80,0.3);
        }
        .difficulty-dot.filled { background: rgba(255,180,80,0.9); }
        .challenge-unlock-req {
            font-size: 11px; color: #806050; text-align: center; font-style: italic;
            margin-top: 8px;
        }
        .challenge-selector-footer {
            text-align: center; padding-top: 20px; border-top: 1px solid rgba(120,100,80,0.3);
        }
        .challenge-selector-footer button {
            padding: 12px 32px; margin: 0 8px; background: rgba(80,60,40,0.6);
            border: 1px solid rgba(140,100,60,0.4); color: #d0b080; cursor: pointer;
            border-radius: 8px; font-size: 14px; font-family: inherit;
        }
        .challenge-selector-footer button:hover {
            background: rgba(100,80,60,0.8);
        }

        /* Disaster Warning System */
        #disaster-warning {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0);
            background: linear-gradient(135deg, rgba(180,60,60,0.95), rgba(200,80,80,0.95));
            color: #fff; padding: 30px 40px; border-radius: 16px; z-index: 1500;
            border: 3px solid rgba(255,100,100,0.8); box-shadow: 0 0 40px rgba(200,60,60,0.6);
            opacity: 0; transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            text-align: center; min-width: 300px;
        }
        #disaster-warning.show {
            opacity: 1; transform: translate(-50%, -50%) scale(1);
        }
        #disaster-warning-icon { font-size: 64px; margin-bottom: 16px; }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        #disaster-warning-name { font-size: 24px; font-weight: bold; margin-bottom: 12px; }
        #disaster-warning-desc { font-size: 14px; margin-bottom: 16px; opacity: 0.95; }
        #disaster-warning-timer {
            font-size: 48px; font-weight: bold; font-family: 'Courier New', monospace;
            text-shadow: 0 0 20px rgba(255,255,255,0.5);
        }

        /* Disaster HUD */
        #disaster-hud {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(26,21,16,0.9); padding: 12px 20px; border-radius: 10px;
            border: 2px solid rgba(180,80,80,0.6); z-index: 500; display: none;
        }
        #disaster-hud.active { display: block; }
        #disaster-hud-text { font-size: 13px; color: #d0a070; text-align: center; }

        /* Speedrun Timer HUD */
        #speedrun-hud {
            position: fixed; top: 100px; right: 20px; background: rgba(26,21,16,0.95);
            padding: 16px; border-radius: 10px; border: 2px solid rgba(100,180,120,0.6);
            z-index: 500; display: none; min-width: 200px;
        }
        #speedrun-hud.active { display: block; }
        #speedrun-challenge-name {
            font-size: 14px; color: #d0a070; margin-bottom: 8px; font-weight: bold;
        }
        #speedrun-timer {
            font-size: 32px; font-family: 'Courier New', monospace; color: #80d080;
            text-align: center; margin: 8px 0; text-shadow: 0 0 10px rgba(128,208,128,0.5);
        }
        #speedrun-target { font-size: 12px; color: #909070; text-align: center; margin-bottom: 8px; }
        #speedrun-progress-bar {
            width: 100%; height: 8px; background: rgba(40,40,40,0.6); border-radius: 4px;
            overflow: hidden; margin: 8px 0;
        }
        #speedrun-progress-fill {
            height: 100%; background: linear-gradient(90deg, rgba(80,180,120,0.8), rgba(100,200,140,0.9));
            width: 0%; transition: width 0.3s ease;
        }
        #speedrun-pb { font-size: 11px; color: #b0a080; text-align: center; }

        /* Speedrun Results Modal */
        #speedrun-results {
            position: fixed; inset: 0; background: rgba(0, 0, 0, 0.9); z-index: 2000;
            display: none; align-items: center; justify-content: center;
        }
        #speedrun-results.active { display: flex; }
        #speedrun-results-content {
            background: rgba(26,21,16,0.98); padding: 40px; border-radius: 16px;
            border: 2px solid rgba(200,160,100,0.6); max-width: 500px; width: 90%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.7); text-align: center;
        }
        #speedrun-results-title {
            font-size: 32px; color: #d0a070; margin-bottom: 20px;
        }
        #speedrun-results-score {
            font-size: 64px; font-weight: bold; color: #80d080;
            margin: 20px 0; text-shadow: 0 0 20px rgba(128,208,128,0.6);
        }
        .speedrun-stat-row {
            display: flex; justify-content: space-between; padding: 8px 0;
            border-bottom: 1px solid rgba(120,100,80,0.3); font-size: 14px;
        }
        .speedrun-stat-label { color: #a09070; }
        .speedrun-stat-value { color: #d0b080; font-weight: bold; }
        #speedrun-results-buttons {
            margin-top: 30px; display: flex; gap: 12px; justify-content: center;
        }
        #speedrun-results-buttons button {
            padding: 12px 24px; background: rgba(100,80,60,0.6); border: 1px solid rgba(160,120,80,0.5);
            color: #d0b080; cursor: pointer; border-radius: 8px; font-size: 14px;
            font-family: inherit; margin: 0;
        }
        #speedrun-results-buttons button:hover { background: rgba(120,100,80,0.8); }

        /* Rival Colony Minimap */
        #rival-minimap {
            position: fixed; top: 200px; right: 20px; width: 150px; height: 150px;
            background: rgba(26,21,16,0.95); border: 2px solid rgba(160,120,80,0.5);
            border-radius: 8px; z-index: 500; display: none; padding: 8px;
        }
        #rival-minimap.active { display: block; }
        #rival-minimap-title {
            font-size: 11px; color: #d0a070; text-align: center; margin-bottom: 6px;
        }
        #rival-minimap-canvas {
            width: 100%; height: 120px; background: rgba(20,15,10,0.8); border-radius: 4px;
        }

        /* Rival Colony Stats */
        #rival-stats {
            position: fixed; top: 380px; right: 20px; background: rgba(26,21,16,0.9);
            padding: 12px; border-radius: 8px; border: 2px solid rgba(140,80,80,0.5);
            z-index: 500; display: none; font-size: 11px; min-width: 150px;
        }
        #rival-stats.active { display: block; }
        #rival-stats-title {
            color: #d08060; font-weight: bold; margin-bottom: 8px; text-align: center;
        }
        .rival-stat { display: flex; justify-content: space-between; margin: 4px 0; color: #a09070; }
        .rival-stat-value { color: #d08060; font-weight: bold; }

        /* Challenge Mode Badge */
        #challenge-mode-badge {
            position: fixed; bottom: 160px; left: 50%; transform: translateX(-50%);
            background: rgba(100,80,160,0.8);
            color: #fff; padding: 8px 16px; border-radius: 20px; font-size: 12px;
            border: 1px solid rgba(160,140,200,0.4); z-index: 150; display: none;
            font-weight: bold; text-shadow: 0 2px 4px rgba(0,0,0,0.4);
            backdrop-filter: blur(4px);
        }
        #challenge-mode-badge.active { display: block; }

        /* Mobile adjustments for CYCLE 10 */
        @media (max-width: 768px) {
            #challenge-selector-content { padding: 20px; }
            #challenge-selector-title { font-size: 22px; }
            .challenge-mode-grid { grid-template-columns: 1fr; gap: 12px; }
            .challenge-mode-card { padding: 16px; }
            #disaster-warning { padding: 20px 24px; min-width: 250px; }
            #disaster-warning-icon { font-size: 48px; }
            #disaster-warning-name { font-size: 20px; }
            #disaster-warning-timer { font-size: 36px; }
            #speedrun-hud { top: auto; bottom: 120px; right: 10px; min-width: 160px; padding: 12px; }
            #speedrun-timer { font-size: 24px; }
            #rival-minimap { top: auto; bottom: 280px; right: 10px; width: 120px; height: 120px; }
            #rival-stats { top: auto; bottom: 410px; right: 10px; min-width: 120px; }
            #speedrun-results-content { padding: 24px; }
            #speedrun-results-title { font-size: 24px; }
            #speedrun-results-score { font-size: 48px; }
        }

        /* ============ CYCLE 11: CREATIVE & SANDBOX MODE ============ */

        /* Creative Mode Toolbar */
        #creative-toolbar {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(26,21,16,0.95); padding: 12px 20px; border-radius: 12px;
            border: 2px solid rgba(120,180,100,0.6); z-index: 600; display: none;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5); min-width: 600px;
        }
        #creative-toolbar.active { display: block; }
        #creative-toolbar-title {
            font-size: 12px; color: #90d070; text-align: center; margin-bottom: 8px;
            font-weight: bold; text-transform: uppercase; letter-spacing: 1px;
        }
        .creative-tool-row {
            display: flex; gap: 8px; align-items: center; margin: 6px 0;
        }
        .creative-tool-btn {
            flex: 1; padding: 8px 12px; font-size: 11px; background: rgba(80,100,60,0.5);
            border: 1px solid rgba(120,160,80,0.4); color: #c0d0a0; cursor: pointer;
            border-radius: 6px; font-family: inherit; transition: all 0.2s;
        }
        .creative-tool-btn:hover { background: rgba(100,140,80,0.6); border-color: rgba(140,200,100,0.6); }
        .creative-tool-btn.active { background: rgba(120,180,100,0.8); border-color: rgba(160,220,120,0.8); color: #fff; }
        .creative-label { font-size: 10px; color: #90a070; min-width: 70px; }
        .creative-slider { width: 120px; }

        /* God Mode Warning Badge */
        #god-mode-badge {
            position: fixed; bottom: 160px; right: 20px; background: rgba(26,21,16,0.9);
            color: #ffd700; padding: 8px 14px; border-radius: 20px; z-index: 700;
            font-size: 12px; font-weight: bold; display: none; border: 1px solid rgba(255,215,0,0.3);
            box-shadow: 0 4px 16px rgba(0,0,0,0.4);
            backdrop-filter: blur(4px);
        }
        #god-mode-badge.active { display: block; }
        @keyframes godPulse {
            0%, 100% { border-color: rgba(255,215,0,0.2); box-shadow: 0 4px 16px rgba(0,0,0,0.4); }
            50% { border-color: rgba(255,215,0,0.5); box-shadow: 0 4px 20px rgba(255,215,0,0.2); }
        }

        /* Scenario Selector */
        #scenario-panel {
            position: fixed; right: -420px; top: 0; width: 400px; height: 100vh;
            background: rgba(26,21,16,0.97); border-left: 2px solid rgba(120,180,100,0.4);
            z-index: 500; overflow-y: auto; padding: 20px; transition: right 0.3s ease-out;
            box-shadow: -5px 0 20px rgba(0,0,0,0.5);
        }
        #scenario-panel.visible { right: 0; }
        #scenario-panel-close {
            position: absolute; top: 15px; right: 15px; width: 30px; height: 30px;
            background: rgba(120,80,60,0.6); border-radius: 50%; padding: 0;
            display: flex; align-items: center; justify-content: center; cursor: pointer;
            font-size: 18px; line-height: 1; margin: 0; border: 1px solid rgba(160,120,80,0.4);
        }
        .scenario-card {
            background: rgba(40,50,30,0.5); padding: 14px; margin: 10px 0; border-radius: 8px;
            border: 2px solid rgba(100,140,80,0.4); cursor: pointer; transition: all 0.2s;
        }
        .scenario-card:hover { background: rgba(60,80,50,0.6); border-color: rgba(140,200,100,0.6); }
        .scenario-card.active { border-color: rgba(160,220,120,0.8); box-shadow: 0 0 12px rgba(120,180,100,0.4); }
        .scenario-name { font-size: 16px; color: #c0d0a0; margin-bottom: 6px; font-weight: bold; }
        .scenario-desc { font-size: 12px; color: #90a070; line-height: 1.5; }

        /* Color Picker Panel */
        #color-picker-panel {
            position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%);
            background: rgba(26,21,16,0.95); padding: 16px; border-radius: 10px;
            border: 2px solid rgba(160,120,200,0.6); z-index: 650; display: none;
            box-shadow: 0 4px 20px rgba(0,0,0,0.6); min-width: 400px;
        }
        #color-picker-panel.active { display: block; }
        .color-picker-row {
            display: flex; align-items: center; justify-content: space-between; margin: 8px 0;
        }
        .color-picker-label { font-size: 12px; color: #c0a0d0; }
        .color-picker-input { width: 60px; height: 30px; border: 1px solid rgba(160,120,200,0.4); border-radius: 4px; cursor: pointer; }
        .color-preset-btns {
            display: flex; gap: 6px; margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(120,100,120,0.3);
        }
        .color-preset-btn {
            flex: 1; padding: 6px; font-size: 10px; background: rgba(80,60,100,0.4);
            border: 1px solid rgba(140,100,180,0.4); color: #d0c0e0; cursor: pointer;
            border-radius: 6px; font-family: inherit;
        }
        .color-preset-btn:hover { background: rgba(100,80,140,0.6); }

        /* Time Control HUD */
        #time-control-hud {
            position: fixed; top: 140px; left: 20px; background: rgba(26,21,16,0.9);
            padding: 10px 14px; border-radius: 8px; border: 1px solid rgba(100,140,160,0.4);
            z-index: 100; font-size: 11px; color: #a0c0d0; display: none;
        }
        #time-control-hud.active { display: block; }
        #time-control-speed { font-size: 16px; font-weight: bold; color: #80c0e0; }

        /* Undo Button */
        #undo-btn {
            position: fixed; bottom: 80px; right: 20px; width: 50px; height: 50px;
            background: rgba(100,140,80,0.8); border: 2px solid rgba(140,200,100,0.6);
            border-radius: 50%; font-size: 24px; display: none; align-items: center;
            justify-content: center; cursor: pointer; z-index: 650; color: #fff;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4); transition: all 0.2s;
        }
        #undo-btn.active { display: flex; }
        #undo-btn:hover { background: rgba(120,180,100,0.9); transform: scale(1.1); }
        #undo-btn:disabled { opacity: 0.4; cursor: not-allowed; }

        /* Mobile adjustments for CYCLE 11 */
        @media (max-width: 768px) {
            #creative-toolbar { min-width: calc(100vw - 40px); bottom: 10px; padding: 10px 14px; }
            .creative-tool-row { flex-wrap: wrap; }
            .creative-tool-btn { font-size: 10px; padding: 6px 8px; }
            #color-picker-panel { min-width: calc(100vw - 40px); }
            #scenario-panel { width: 100%; right: -100%; }
            #god-mode-badge { top: auto; bottom: 120px; right: 10px; font-size: 11px; }
            #undo-btn { bottom: 120px; right: 10px; width: 44px; height: 44px; font-size: 20px; }
        }

        /* ============ CYCLE 12: SOCIAL & SHARING ============ */

        /* Share Panel */
        #share-panel {
            position: fixed; right: -500px; top: 0; width: 480px; height: 100vh;
            background: rgba(26,21,16,0.97); border-left: 2px solid rgba(100,180,220,0.5);
            z-index: 500; overflow-y: auto; padding: 20px; transition: right 0.3s ease-out;
            box-shadow: -5px 0 20px rgba(0,0,0,0.5);
        }
        #share-panel.visible { right: 0; }
        #share-panel-close {
            position: absolute; top: 15px; right: 15px; width: 30px; height: 30px;
            background: rgba(120,80,60,0.6); border-radius: 50%; padding: 0;
            display: flex; align-items: center; justify-content: center; cursor: pointer;
            font-size: 18px; line-height: 1; margin: 0; border: 1px solid rgba(160,120,80,0.4);
        }
        .share-section {
            margin-bottom: 20px; padding: 16px; background: rgba(40,50,60,0.4);
            border-radius: 10px; border: 1px solid rgba(100,140,180,0.3);
        }
        .share-section h3 {
            color: #a0c0e0; font-size: 16px; margin-bottom: 12px; border-bottom: 1px solid rgba(100,140,180,0.3);
            padding-bottom: 6px; font-weight: normal;
        }
        .share-btn {
            display: block; width: 100%; padding: 12px; margin: 8px 0;
            background: rgba(80,120,180,0.5); border: 1px solid rgba(100,160,220,0.5);
            color: #c0d0e0; cursor: pointer; border-radius: 8px; font-family: inherit;
            font-size: 13px; transition: all 0.2s;
        }
        .share-btn:hover { background: rgba(100,160,220,0.6); border-color: rgba(120,200,240,0.7); }
        .share-preview-canvas {
            width: 100%; max-height: 300px; border-radius: 8px; margin: 10px 0;
            border: 2px solid rgba(100,160,220,0.4); cursor: pointer;
        }

        /* Colony Card Modal */
        #colony-card-modal {
            position: fixed; inset: 0; background: rgba(0, 0, 0, 0.92); z-index: 2500;
            display: none; align-items: center; justify-content: center; flex-direction: column;
        }
        #colony-card-modal.active { display: flex; }
        #colony-card-canvas {
            max-width: 90vw; max-height: 70vh; border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.7); border: 3px solid rgba(200,160,100,0.6);
        }
        #colony-card-controls {
            margin-top: 20px; display: flex; gap: 12px; flex-wrap: wrap; justify-content: center;
        }
        #colony-card-controls button {
            padding: 12px 24px; background: rgba(100,80,60,0.8); border: 1px solid rgba(160,120,80,0.5);
            color: #d0b080; cursor: pointer; border-radius: 8px; font-family: inherit; font-size: 14px;
            margin: 0; transition: all 0.2s;
        }
        #colony-card-controls button:hover { background: rgba(120,100,80,0.9); transform: translateY(-2px); }
        .theme-selector {
            display: flex; gap: 6px; margin-top: 10px; padding: 10px; background: rgba(30,25,20,0.6);
            border-radius: 6px; flex-wrap: wrap; justify-content: center;
        }
        .theme-btn {
            padding: 8px 14px; font-size: 11px; background: rgba(60,50,40,0.6);
            border: 1px solid rgba(120,100,80,0.4); color: #c0a080; cursor: pointer;
            border-radius: 6px; font-family: inherit; margin: 0;
        }
        .theme-btn.active { background: rgba(120,100,60,0.8); border-color: rgba(180,140,80,0.6); color: #fff; }

        /* Colony Story Display */
        #colony-story-display {
            background: rgba(40,50,60,0.6); padding: 14px; border-radius: 8px; margin: 10px 0;
            border: 1px solid rgba(100,140,180,0.4); font-size: 13px; line-height: 1.6;
            color: #c0d0e0; font-style: italic; position: relative;
        }
        .story-copy-btn {
            position: absolute; top: 10px; right: 10px; padding: 6px 12px; font-size: 11px;
            background: rgba(80,120,180,0.6); border: 1px solid rgba(100,160,220,0.5);
            color: #fff; cursor: pointer; border-radius: 6px; font-family: inherit; margin: 0;
        }

        /* Statistics Dashboard */
        #stats-dashboard {
            position: fixed; inset: 0; background: rgba(0, 0, 0, 0.9); z-index: 2000;
            display: none; align-items: center; justify-content: center; overflow-y: auto;
        }
        #stats-dashboard.active { display: flex; }
        #stats-dashboard-content {
            background: rgba(26,21,16,0.98); padding: 30px; border-radius: 16px;
            border: 2px solid rgba(100,180,220,0.6); max-width: 900px; width: 90%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.7); max-height: 90vh; overflow-y: auto;
        }
        #stats-dashboard-close {
            float: right; background: rgba(120,80,60,0.6); width: 30px; height: 30px;
            border-radius: 50%; border: 1px solid rgba(160,120,80,0.4); cursor: pointer;
            font-size: 16px; display: flex; align-items: center; justify-content: center; margin: 0;
        }
        .stats-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px; margin: 20px 0;
        }
        .stat-card {
            background: rgba(40,50,60,0.5); padding: 16px; border-radius: 10px;
            border: 2px solid rgba(100,140,180,0.4); text-align: center;
        }
        .stat-card-value {
            font-size: 32px; font-weight: bold; color: #80c0e0; margin: 8px 0;
            text-shadow: 0 2px 8px rgba(128,192,224,0.4);
        }
        .stat-card-label {
            font-size: 12px; color: #a0c0d0; text-transform: uppercase; letter-spacing: 1px;
        }
        .stat-chart-placeholder {
            height: 120px; background: rgba(20,30,40,0.6); border-radius: 8px; margin: 10px 0;
            display: flex; align-items: center; justify-content: center; color: #708090;
            font-size: 11px; border: 1px solid rgba(80,100,120,0.4);
        }

        /* Enhanced Screenshot Features */
        #screenshot-metadata-overlay {
            position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.8);
            padding: 12px; border-radius: 8px; color: #fff; font-size: 11px; pointer-events: none;
        }
        .metadata-toggle-btn {
            padding: 8px 16px; background: rgba(100,80,160,0.6); border: 1px solid rgba(140,120,200,0.5);
            color: #e0d0f0; cursor: pointer; border-radius: 6px; font-family: inherit; font-size: 12px;
            margin: 0;
        }

        /* Scenario Library Browser */
        .scenario-library-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 12px; margin: 16px 0;
        }
        .scenario-library-card {
            background: rgba(40,50,40,0.5); padding: 12px; border-radius: 8px;
            border: 2px solid rgba(100,140,80,0.4); cursor: pointer; transition: all 0.2s;
        }
        .scenario-library-card:hover {
            background: rgba(60,80,60,0.6); border-color: rgba(140,200,100,0.6);
            transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        .scenario-library-card.community {
            border-color: rgba(180,120,200,0.5);
        }
        .scenario-name { font-size: 14px; color: #c0d0a0; margin-bottom: 6px; font-weight: bold; }
        .scenario-author { font-size: 10px; color: #809070; margin-bottom: 8px; font-style: italic; }
        .scenario-difficulty {
            display: inline-block; padding: 3px 8px; font-size: 10px; border-radius: 4px;
            background: rgba(60,80,100,0.5); color: #a0c0e0; margin-top: 6px;
        }
        .scenario-import-box {
            margin: 16px 0; padding: 12px; background: rgba(40,40,50,0.5);
            border-radius: 8px; border: 1px dashed rgba(100,140,180,0.4);
        }
        .scenario-import-box textarea {
            width: 100%; height: 80px; background: rgba(20,20,25,0.6); border: 1px solid rgba(80,100,120,0.4);
            border-radius: 6px; padding: 10px; color: #c0d0e0; font-family: monospace; font-size: 11px;
            resize: vertical;
        }

        /* Mobile adjustments for CYCLE 12 */
        @media (max-width: 768px) {
            #share-panel { width: 100%; right: -100%; }
            #colony-card-modal #colony-card-canvas { max-width: 95vw; max-height: 60vh; }
            #colony-card-controls { gap: 8px; }
            #colony-card-controls button { padding: 10px 16px; font-size: 12px; }
            #stats-dashboard-content { padding: 20px; max-width: 95%; }
            .stats-grid { grid-template-columns: 1fr; gap: 12px; }
            .scenario-library-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <!-- CYCLE 6: Accessibility toolbar -->
    <div id="a11y-toolbar" role="toolbar" aria-label="Accessibility Options">
        <button id="high-contrast-btn" aria-label="Toggle high contrast mode">High Contrast</button>
        <button id="screen-reader-help-btn" aria-label="Show screen reader help">Help</button>
    </div>

    <canvas id="canvas" role="img" aria-label="Colony Mind simulation canvas"></canvas>

    <!-- CYCLE 6: Auto-save indicator -->
    <div id="autosave-indicator" role="status" aria-live="polite" aria-atomic="true">Auto-saved</div>

    <!-- CYCLE 6: FPS indicator -->
    <div id="fps-indicator" role="status" aria-live="polite">FPS: <span id="fps-value">60</span></div>

    <!-- CYCLE 6: Mobile joystick -->
    <div id="mobile-joystick" role="button" aria-label="Virtual joystick for camera control" tabindex="0">
        <div id="mobile-joystick-knob"></div>
    </div>

    <!-- CYCLE 6: Mobile action buttons -->
    <div id="mobile-actions" role="group" aria-label="Quick actions">
        <button aria-label="Place food">üçØ</button>
        <button aria-label="Pause simulation">‚è∏Ô∏è</button>
        <button aria-label="Toggle weather">üå§Ô∏è</button>
    </div>

    <div id="controls" role="region" aria-label="Colony controls">
        <button id="controls-minimize" title="Minimize controls" aria-label="Minimize controls">‚àí</button>
        <h3 id="controls-title">Colony Mind</h3>

        <!-- Core Controls Section -->
        <div class="control-section">
            <div class="control-row">
                <label for="size">Colony Size <span class="value" id="size-val">150</span></label>
                <input type="range" id="size" min="50" max="500" value="150"
                       aria-valuemin="50" aria-valuemax="500" aria-valuenow="150"
                       aria-label="Colony size slider">
            </div>
            <div class="control-row">
                <label for="speed">Dig Speed <span class="value" id="speed-val">50</span></label>
                <input type="range" id="speed" min="20" max="100" value="50"
                       aria-valuemin="20" aria-valuemax="100" aria-valuenow="50"
                       aria-label="Dig speed slider">
            </div>
        </div>

        <!-- Simulation Section -->
        <div class="control-section">
            <div class="control-section-title">Simulation</div>
            <button id="pause-btn" class="btn-pause" aria-label="Pause or resume simulation" aria-pressed="false">
                ‚è∏ Pause <span class="kbd-hint">[Space]</span>
            </button>
            <div class="speed-controls" role="group" aria-label="Simulation speed controls">
                <button class="speed-btn" data-speed="0.5" aria-label="Set speed to 0.5x">0.5x</button>
                <button class="speed-btn active" data-speed="1" aria-label="Set speed to 1x" aria-pressed="true">1x</button>
                <button class="speed-btn" data-speed="2" aria-label="Set speed to 2x">2x</button>
                <button class="speed-btn" data-speed="4" aria-label="Set speed to 4x">4x</button>
            </div>
        </div>

        <!-- Actions Section -->
        <div class="control-section">
            <div class="control-section-title">Actions</div>
            <div class="btn-row">
                <button id="food-btn" aria-label="Toggle food placement mode">üçØ Food</button>
                <button id="reset-btn" aria-label="Reset and create new colony">üîÑ New</button>
            </div>
            <div class="btn-group" role="group" aria-label="Save and load buttons">
                <button id="export-btn" class="btn-export" aria-label="Export colony to JSON file">üíæ Save</button>
                <button id="import-btn" class="btn-import" aria-label="Import colony from JSON file">üìÇ Load</button>
            </div>
        </div>

        <!-- Features Section -->
        <div class="control-section">
            <div class="control-section-title">Features</div>
            <div class="btn-row">
                <button id="legacy-btn" class="btn-legacy" aria-label="View colony legacy">üèõÔ∏è Legacy</button>
                <button id="share-btn-main" class="btn-share" aria-label="Share your colony">üì§ Share</button>
            </div>
        </div>

        <!-- Visual/Audio Settings (Collapsible) -->
        <div class="control-section">
            <button class="advanced-toggle" id="settings-toggle" aria-expanded="false">
                ‚öôÔ∏è Settings & Visuals ‚ñº
            </button>
            <div class="advanced-section" id="settings-section">
                <div class="btn-row">
                    <button id="sound-btn" class="btn-sound" aria-label="Toggle ambient sound" aria-pressed="false">üîá Sound</button>
                    <button id="pheromone-btn" class="btn-visual" aria-label="Toggle trails" aria-pressed="false">üëÅ Trails</button>
                </div>
                <div class="btn-row">
                    <button id="bloom-btn" class="btn-bloom" aria-label="Cycle bloom quality">‚ú® Bloom</button>
                    <button id="predator-btn" class="btn-danger" aria-label="Toggle predators" aria-pressed="false">üï∑Ô∏è Predators</button>
                </div>
                <button id="reset-lineage-btn" class="btn-small" aria-label="Reset all genetic memory">Reset Genetic Lineage</button>
            </div>
        </div>

        <input type="file" id="file-input" accept=".json" aria-label="Select save file to import">
        <div class="save-info" role="note" aria-label="Keyboard shortcuts">
            Press <strong>H</strong> for help ¬∑ <strong>Space</strong> pause ¬∑ <strong>1-4</strong> speed
        </div>
    </div>
    <div id="weather-indicator" role="status" aria-live="polite" aria-label="Current weather and time">
        <span id="weather-icon">‚òÄÔ∏è</span>
        <span id="weather-name">Clear</span>
        <span id="weather-timer"></span>
        <!-- CYCLE 14: Seasonal indicator -->
        <span id="season-name">üå∏ Spring</span>
    </div>
    <div id="stats" role="region" aria-label="Colony statistics" aria-live="polite">
        <div class="stat-row">üêú <span id="ant-count">0</span> ants</div>
        <div class="stat-row">üï≥Ô∏è <span id="tunnel-length">0</span>m ¬∑ üè† <span id="chamber-count">0</span></div>
        <div class="stat-row">üìä <span id="explored-pct">0</span>% ¬∑ ‚¨áÔ∏è <span id="world-depth">1</span>x</div>
        <div class="stat-row">üëë Fed: <span id="queen-fed">0</span></div>
        <div class="stat-row">‚ÜóÔ∏è<span id="birth-count">0</span> ‚ÜòÔ∏è<span id="death-count">0</span> Gen <span id="generation-count">0</span></div>

        <div class="stats-roles">
            <div id="role-bar" class="role-bar">
                <div id="bar-workers" class="role-bar-segment role-workers"></div>
                <div id="bar-excavators" class="role-bar-segment role-excavators"></div>
                <div id="bar-gatherers" class="role-bar-segment role-gatherers"></div>
                <div id="bar-nurses" class="role-bar-segment role-nurses"></div>
            </div>
            <div class="role-legend">
                <span class="role-label role-workers">‚öí<span id="worker-count">0</span></span>
                <span class="role-label role-excavators">‚õè<span id="excavator-count">0</span></span>
                <span class="role-label role-gatherers">üåæ<span id="gatherer-count">0</span></span>
                <span class="role-label role-nurses">üíó<span id="nurse-count">0</span></span>
            </div>
        </div>

        <div id="dynasty-info" class="dynasty-info">
            <div class="dynasty-queen-name">‚ôï <span id="current-queen-name">Queen</span></div>
            <div class="dynasty-generation">Generation <span id="queen-generation">1</span></div>
            <div class="dynasty-age">Age: <span id="queen-age">0</span>s / <span id="queen-lifespan">300</span>s</div>
        </div>
    </div>
    <div id="info">Press <strong>H</strong> for help ¬∑ <strong>L</strong> for Legends ¬∑ <strong>S</strong> to share</div>

    <!-- CYCLE 7: Enhanced Milestone Toast -->
    <div id="milestone-toast" role="status" aria-live="polite" aria-atomic="true">
        <div id="milestone-icon"></div>
        <div id="milestone-title"></div>
        <div id="milestone-subtitle"></div>
    </div>

    <!-- CYCLE 7: Auto-Save Recovery Banner -->
    <div id="autosave-recovery" role="alert">
        <div id="autosave-recovery-text"></div>
        <button id="autosave-recovery-load" aria-label="Load auto-saved colony">Load</button>
        <button id="autosave-recovery-dismiss" aria-label="Dismiss auto-save notification">√ó</button>
    </div>

    <!-- CYCLE 7: Interactive Tutorial Overlay -->
    <div id="tutorial-overlay" role="dialog" aria-labelledby="tutorial-title" aria-modal="true">
        <div id="tutorial-spotlight" aria-hidden="true"></div>
        <div id="tutorial-content">
            <h1 id="tutorial-title">Welcome to Colony Mind</h1>
            <div id="tutorial-text"></div>
            <div class="tutorial-buttons">
                <button id="tutorial-skip" aria-label="Skip tutorial">Skip Tutorial</button>
                <button id="tutorial-next" aria-label="Next tutorial step">Next</button>
            </div>
            <div class="tutorial-progress" role="progressbar" aria-valuemin="0" aria-valuemax="5" aria-valuenow="1">
                <div class="tutorial-dot active"></div>
                <div class="tutorial-dot"></div>
                <div class="tutorial-dot"></div>
                <div class="tutorial-dot"></div>
                <div class="tutorial-dot"></div>
            </div>
        </div>
    </div>

    <!-- CYCLE 7: Help Panel -->
    <div id="help-panel" role="complementary" aria-label="Help and reference">
        <button id="help-panel-close" aria-label="Close help panel">√ó</button>
        <h2>Colony Mind Guide</h2>

        <h4>üéÆ Controls</h4>
        <div class="help-section">
            <span class="help-key">Space</span> Pause/Resume<br>
            <span class="help-key">1-4</span> Speed controls<br>
            <span class="help-key">S</span> Share panel (NEW in CYCLE 12!)<br>
            <span class="help-key">W</span> Toggle weather<br>
            <span class="help-key">P</span> Photo mode (take screenshots)<br>
            <span class="help-key">B</span> Bloom quality<br>
            <span class="help-key">H</span> Toggle this help<br>
            <span class="help-key">L</span> Colony legacy & achievements<br>
            <span class="help-key">F</span> Place food<br>
            <span class="help-key">G</span> Place fungus garden<br>
            <span class="help-key">T</span> Place water tank<br>
            <span class="help-key">C</span> High contrast mode
        </div>

        <h4>üêú Ant Roles</h4>
        <div class="help-section">
            <div class="help-legend">
                <div class="help-legend-color" style="background: #3a2a1a;"></div>
                <span><strong>Workers</strong> - Generalists, can do anything</span>
            </div>
            <div class="help-legend">
                <div class="help-legend-color" style="background: #5a3a2a;"></div>
                <span><strong>Excavators</strong> - Specialize in tunnel digging</span>
            </div>
            <div class="help-legend">
                <div class="help-legend-color" style="background: #4a6a3a;"></div>
                <span><strong>Gatherers</strong> - Collect and deliver food</span>
            </div>
            <div class="help-legend">
                <div class="help-legend-color" style="background: #6a5a4a;"></div>
                <span><strong>Nurses</strong> - Care for queen and larvae</span>
            </div>
            <p style="margin-top: 8px; font-size: 11px; opacity: 0.8;">
                Ants automatically specialize after gaining 50 experience in a task.
            </p>
        </div>

        <h4>üèõÔ∏è Chamber Types</h4>
        <div class="help-section">
            <div class="help-legend">
                <div class="help-legend-color" style="background: rgba(120,100,80,0.6);"></div>
                <span><strong>Nest</strong> - Queen's chamber, spawns ants</span>
            </div>
            <div class="help-legend">
                <div class="help-legend-color" style="background: rgba(80,120,180,0.6);"></div>
                <span><strong>Water Storage</strong> - Protects from drought (unlocked at 100 ants)</span>
            </div>
            <div class="help-legend">
                <div class="help-legend-color" style="background: rgba(100,160,100,0.6);"></div>
                <span><strong>Fungus Garden</strong> - Produces food over time (unlocked at 50 ants)</span>
            </div>
        </div>

        <h4>üå¶Ô∏è Weather Effects</h4>
        <div class="help-section">
            <strong>‚òÄÔ∏è Clear</strong> - Normal conditions<br>
            <strong>üåßÔ∏è Rain</strong> - Slows ants, floods deep tunnels<br>
            <strong>üî• Drought</strong> - Food depletes faster<br>
            <strong>‚ùÑÔ∏è Cold</strong> - Ants move slower, elders vulnerable<br>
            <strong>‚õàÔ∏è Storm</strong> - Heavy flooding, lightning
        </div>

        <h4>üß™ Pheromone Trails</h4>
        <div class="help-section">
            <div class="help-legend">
                <div class="help-legend-color" style="background: rgba(255,180,80,0.7);"></div>
                <span><strong>Amber</strong> - Food trail (to food sources)</span>
            </div>
            <div class="help-legend">
                <div class="help-legend-color" style="background: rgba(100,150,220,0.7);"></div>
                <span><strong>Blue</strong> - Exploration (dig sites)</span>
            </div>
            <div class="help-legend">
                <div class="help-legend-color" style="background: rgba(220,100,100,0.7);"></div>
                <span><strong>Red</strong> - Alarm (danger, ants avoid)</span>
            </div>
        </div>

        <h4>üí° Tips</h4>
        <div class="help-section">
            ‚Ä¢ Feed the queen to grow your colony<br>
            ‚Ä¢ Watch for red hunger glow when queen is starving<br>
            ‚Ä¢ Ants learn behaviors across generations<br>
            ‚Ä¢ Hover over ants to see their thoughts<br>
            ‚Ä¢ Auto-save runs every 30 seconds<br>
            ‚Ä¢ Export your colony as JSON backup
        </div>

        <h4>üéÅ Secrets & Surprises (CYCLE 8)</h4>
        <div class="help-section">
            ‚Ä¢ Dig deep to discover hidden underground chambers<br>
            ‚Ä¢ Watch for rare celestial events in the sky<br>
            ‚Ä¢ Triple-click the queen for a special blessing<br>
            ‚Ä¢ Unlock 24 secret achievements by experimenting<br>
            ‚Ä¢ Press L to view your colony legacy & hall of fame<br>
            ‚Ä¢ Your best colonies are immortalized at 200 ants<br>
            ‚Ä¢ Ant thought bubbles reveal their memories<br>
            ‚Ä¢ Press P to capture perfect screenshots
        </div>
    </div>

    <!-- CYCLE 7: Global Tooltip (for button hover hints) -->
    <div class="tooltip" id="global-tooltip" role="tooltip"></div>

    <!-- ============ CYCLE 8: SECRETS & SURPRISES UI ============ -->

    <!-- Photo Mode Overlay -->
    <div id="photo-mode-overlay" role="dialog" aria-label="Photo Mode">
        <canvas id="photo-mode-canvas" role="img" aria-label="Photo mode preview of colony"></canvas>
        <div id="photo-mode-controls">
            <label for="photo-mode-zoom" style="color: #d0b080; font-size: 13px;">Zoom:</label>
            <input type="range" id="photo-mode-zoom" min="50" max="200" value="100" aria-label="Photo zoom level">
            <button id="photo-save-btn" aria-label="Save photo">üíæ Save Photo</button>
            <button id="photo-close-btn" aria-label="Close photo mode">‚úï Close</button>
        </div>
    </div>

    <!-- Colony Legacy Panel -->
    <div id="legacy-panel" role="complementary" aria-label="Colony Legacy & Hall of Fame">
        <button id="legacy-panel-close" aria-label="Close legacy panel">√ó</button>
        <h2 style="color: #d0a070; font-size: 22px; margin-bottom: 20px; font-weight: normal;">üèõÔ∏è Colony Legacy</h2>

        <div class="legacy-section">
            <h3>üìä Lifetime Statistics</h3>
            <div class="legacy-stat">
                <span class="legacy-stat-label">Total Colonies:</span>
                <span class="legacy-stat-value" id="legacy-colonies">0</span>
            </div>
            <div class="legacy-stat">
                <span class="legacy-stat-label">Total Ants Born:</span>
                <span class="legacy-stat-value" id="legacy-births">0</span>
            </div>
            <div class="legacy-stat">
                <span class="legacy-stat-label">Total Food Gathered:</span>
                <span class="legacy-stat-value" id="legacy-food">0</span>
            </div>
            <div class="legacy-stat">
                <span class="legacy-stat-label">Deepest Excavation:</span>
                <span class="legacy-stat-value" id="legacy-depth">0m</span>
            </div>
            <div class="legacy-stat">
                <span class="legacy-stat-label">Longest Colony:</span>
                <span class="legacy-stat-value" id="legacy-longevity">0 min</span>
            </div>
        </div>

        <div class="legacy-section">
            <h3>üèÜ Hall of Fame (Top 5)</h3>
            <div id="hall-of-fame-list">
                <p style="font-size: 12px; opacity: 0.7; text-align: center; padding: 20px;">
                    No legendary colonies yet.<br>Reach 200 ants to immortalize your colony!
                </p>
            </div>
        </div>

        <div class="legacy-section">
            <h3>üéñÔ∏è Secret Achievements</h3>
            <div id="legacy-achievements">
                <p style="font-size: 11px; opacity: 0.6; font-style: italic;">
                    Achievements are hidden until discovered. Try experimenting with different strategies!
                </p>
            </div>
        </div>
    </div>

    <!-- Achievement Tracker (bottom-left) -->
    <div id="achievement-tracker" role="status" aria-live="polite">
        <div>üéñÔ∏è Achievements</div>
        <div id="achievement-progress">0 / 24</div>
    </div>

    <!-- Achievement Toast (slide from right) -->
    <div id="achievement-toast" role="status" aria-live="assertive" aria-atomic="true">
        <div id="achievement-toast-icon"></div>
        <div id="achievement-toast-title"></div>
        <div id="achievement-toast-desc"></div>
    </div>

    <!-- Visual Theme Indicator -->
    <div id="theme-indicator" role="status" aria-live="polite"></div>

    <!-- ============ CYCLE 14: ADVANCED EMERGENCE UI ============ -->

    <!-- Ant Legends Panel -->
    <div id="legends-panel" role="complementary" aria-label="Ant Legends Hall of Fame">
        <button id="legends-panel-close" aria-label="Close legends panel">√ó</button>
        <h2 style="color: #ffd700; font-size: 24px; margin-bottom: 20px; font-weight: normal; text-align: center;">‚≠ê Ant Legends ‚≠ê</h2>

        <div class="legacy-section" style="background: rgba(60,50,30,0.5); border-color: rgba(200,160,100,0.5);">
            <h3 style="color: #ffd700;">üèÜ Hall of Legends</h3>
            <div id="legends-hall">
                <p style="font-size: 12px; opacity: 0.7; text-align: center; padding: 20px; color: #c0a070;">
                    No legendary ants yet.<br>
                    Exceptional ants will be immortalized here!<br><br>
                    <span style="font-size: 11px; opacity: 0.6;">
                    Legends are created by extreme achievements:<br>
                    - Living 5+ minutes<br>
                    - Gathering 50+ food<br>
                    - Excavating 200+ soil<br>
                    - Heroic sacrifice for the queen
                    </span>
                </p>
            </div>
        </div>

        <div class="legacy-section">
            <h3>ü™¶ Memorial Markers</h3>
            <div id="memorial-list">
                <p style="font-size: 11px; opacity: 0.6; text-align: center; padding: 12px;">
                    Golden markers appear in the soil where legendary ants fell.
                </p>
            </div>
        </div>

        <div class="legacy-section">
            <h3>üëë Queen Dynasty</h3>
            <div id="dynasty-chronicle">
                <p style="font-size: 11px; opacity: 0.6; text-align: center; padding: 12px;">
                    Track the lineage of queens across generations.
                </p>
            </div>
        </div>
    </div>

    <!-- Danger Mode Panel (when queen threatened) -->
    <div id="danger-panel" role="dialog" aria-labelledby="danger-panel-title" aria-modal="true">
        <div id="danger-panel-title">‚ö†Ô∏è QUEEN IN DANGER ‚ö†Ô∏è</div>
        <div id="danger-panel-message">
            A predator threatens the queen! Choose your response wisely.
        </div>
        <div id="danger-choices">
            <button class="danger-choice-btn" data-choice="flee" aria-label="Flee - Relocate queen to safety">
                üèÉ <strong>FLEE</strong>
                <span class="danger-choice-success">20% success</span>
                <span class="danger-choice-cost">Queen moves, tunnel disrupted</span>
            </button>
            <button class="danger-choice-btn" data-choice="defend" aria-label="Defend - Send 5 ants to fight predator">
                üõ°Ô∏è <strong>DEFEND</strong>
                <span class="danger-choice-success">70% success</span>
                <span class="danger-choice-cost">~2-3 ants may die</span>
            </button>
            <button class="danger-choice-btn" data-choice="sacrifice" aria-label="Sacrifice - Send 10 ants for heroic last stand">
                ‚öîÔ∏è <strong>HEROIC SACRIFICE</strong>
                <span class="danger-choice-success">95% success</span>
                <span class="danger-choice-cost">~7-9 ants will die defending queen</span>
            </button>
            <button class="danger-choice-btn" data-choice="nothing" aria-label="Do Nothing - Let fate decide" style="opacity: 0.7;">
                ü§∑ <strong>DO NOTHING</strong>
                <span class="danger-choice-cost">60% chance queen dies</span>
            </button>
        </div>
    </div>

    <!-- ============ CYCLE 10: CHALLENGE MODES UI ============ -->

    <!-- Challenge Mode Selector Modal -->
    <div id="challenge-mode-selector" role="dialog" aria-labelledby="challenge-selector-title" aria-modal="true">
        <div id="challenge-selector-content">
            <h1 id="challenge-selector-title">Choose Your Challenge</h1>
            <div id="challenge-selector-subtitle">CYCLE 10: Challenge Modes - Test your colony mastery</div>

            <div class="challenge-mode-grid">
                <!-- Classic Mode -->
                <div class="challenge-mode-card" data-mode="classic">
                    <div class="challenge-mode-icon">üêú</div>
                    <div class="challenge-mode-name">Classic Mode</div>
                    <div class="challenge-mode-desc">Build and grow your colony in the original sandbox experience</div>
                    <div class="challenge-mode-difficulty">
                        <div class="difficulty-dot filled"></div>
                        <div class="difficulty-dot"></div>
                        <div class="difficulty-dot"></div>
                    </div>
                </div>

                <!-- Disaster Survival -->
                <div class="challenge-mode-card" data-mode="disaster" data-unlock="50">
                    <div class="challenge-mode-icon">üå™Ô∏è</div>
                    <div class="challenge-mode-name">Disaster Survival</div>
                    <div class="challenge-mode-desc">Survive floods, fires, earthquakes, famine, and plague</div>
                    <div class="challenge-mode-difficulty">
                        <div class="difficulty-dot filled"></div>
                        <div class="difficulty-dot filled"></div>
                        <div class="difficulty-dot filled"></div>
                    </div>
                    <div class="challenge-unlock-req">Unlock: 50 ants in Classic</div>
                </div>

                <!-- Speedrun Challenge -->
                <div class="challenge-mode-card" data-mode="speedrun" data-unlock="100">
                    <div class="challenge-mode-icon">‚ö°</div>
                    <div class="challenge-mode-name">Speedrun Challenge</div>
                    <div class="challenge-mode-desc">Race against time in timed scenarios with leaderboards</div>
                    <div class="challenge-mode-difficulty">
                        <div class="difficulty-dot filled"></div>
                        <div class="difficulty-dot filled"></div>
                        <div class="difficulty-dot"></div>
                    </div>
                    <div class="challenge-unlock-req">Unlock: 100 ants in Classic</div>
                </div>

                <!-- Rival Colony -->
                <div class="challenge-mode-card" data-mode="rival" data-unlock="150">
                    <div class="challenge-mode-icon">‚öîÔ∏è</div>
                    <div class="challenge-mode-name">Rival Colony</div>
                    <div class="challenge-mode-desc">Compete against AI colony for resources and territory</div>
                    <div class="challenge-mode-difficulty">
                        <div class="difficulty-dot filled"></div>
                        <div class="difficulty-dot filled"></div>
                        <div class="difficulty-dot filled"></div>
                    </div>
                    <div class="challenge-unlock-req">Unlock: 150 ants in Classic</div>
                </div>
            </div>

            <div class="challenge-selector-footer">
                <button id="challenge-selector-cancel">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Challenge Mode Badge -->
    <div id="challenge-mode-badge" role="status" aria-live="polite"></div>

    <!-- Disaster Warning Modal -->
    <div id="disaster-warning" role="alert" aria-live="assertive">
        <div id="disaster-warning-icon"></div>
        <div id="disaster-warning-name"></div>
        <div id="disaster-warning-desc"></div>
        <div id="disaster-warning-timer">10</div>
    </div>

    <!-- Disaster HUD -->
    <div id="disaster-hud" role="status" aria-live="polite">
        <div id="disaster-hud-text"></div>
    </div>

    <!-- Speedrun HUD -->
    <div id="speedrun-hud" role="region" aria-label="Speedrun timer">
        <div id="speedrun-challenge-name"></div>
        <div id="speedrun-timer">0:00.0</div>
        <div id="speedrun-target"></div>
        <div id="speedrun-progress-bar">
            <div id="speedrun-progress-fill"></div>
        </div>
        <div id="speedrun-pb"></div>
    </div>

    <!-- Speedrun Results Modal -->
    <div id="speedrun-results" role="dialog" aria-labelledby="speedrun-results-title" aria-modal="true">
        <div id="speedrun-results-content">
            <div id="speedrun-results-title"></div>
            <div id="speedrun-results-score">0</div>
            <div id="speedrun-results-breakdown"></div>
            <div id="speedrun-results-buttons">
                <button id="speedrun-retry">Retry</button>
                <button id="speedrun-menu">Main Menu</button>
            </div>
        </div>
    </div>

    <!-- Rival Colony Minimap -->
    <div id="rival-minimap" role="region" aria-label="Territory minimap">
        <div id="rival-minimap-title">Territory</div>
        <canvas id="rival-minimap-canvas" width="134" height="120" role="img" aria-label="Territory control minimap showing colony boundaries"></canvas>
    </div>

    <!-- Rival Colony Stats -->
    <div id="rival-stats" role="region" aria-label="Rival colony statistics">
        <div id="rival-stats-title">Rival Colony</div>
        <div class="rival-stat">
            <span>Ants:</span>
            <span class="rival-stat-value" id="rival-ant-count">0</span>
        </div>
        <div class="rival-stat">
            <span>Chambers:</span>
            <span class="rival-stat-value" id="rival-chamber-count">0</span>
        </div>
        <div class="rival-stat">
            <span>Food:</span>
            <span class="rival-stat-value" id="rival-food-count">0</span>
        </div>
    </div>

    <!-- ============ CYCLE 11: CREATIVE & SANDBOX MODE UI ============ -->

    <!-- Creative Mode Toolbar -->
    <div id="creative-toolbar" role="region" aria-label="Creative mode tools">
        <div id="creative-toolbar-title">üé® CREATIVE MODE - Press V to toggle</div>
        <div class="creative-tool-row">
            <span class="creative-label">God Mode:</span>
            <button class="creative-tool-btn" id="god-mode-btn" aria-label="Toggle god mode">Off</button>
            <span class="creative-label">Spawn:</span>
            <button class="creative-tool-btn" id="spawn-ant-btn" data-spawn="ant" aria-label="Spawn ants">üêú Ant</button>
            <button class="creative-tool-btn" id="spawn-food-btn" data-spawn="food" aria-label="Spawn food">üçØ Food</button>
            <button class="creative-tool-btn" id="spawn-chamber-btn" data-spawn="chamber" aria-label="Place chamber">üèõÔ∏è Chamber</button>
        </div>
        <div class="creative-tool-row">
            <span class="creative-label">Quantity:</span>
            <input type="range" id="spawn-quantity" class="creative-slider" min="1" max="50" value="1" aria-label="Spawn quantity">
            <span id="spawn-quantity-val">1</span>
            <button class="creative-tool-btn" id="open-scenarios-btn" aria-label="Open scenarios">üìã Scenarios</button>
            <button class="creative-tool-btn" id="open-colors-btn" aria-label="Customize colors">üé® Colors</button>
        </div>
    </div>

    <!-- God Mode Badge -->
    <div id="god-mode-badge" role="status" aria-live="polite">‚ö° GOD MODE - Achievements Disabled</div>

    <!-- Time Control HUD -->
    <div id="time-control-hud" role="status" aria-live="polite">
        <div>Time Control</div>
        <div id="time-control-speed">1.0x</div>
        <div style="font-size: 9px; opacity: 0.7; margin-top: 4px;">[ = Slower | ] = Faster | \ = Frame Step</div>
    </div>

    <!-- Undo Button -->
    <button id="undo-btn" aria-label="Undo last action" title="Undo (Ctrl+Z)">‚Ü∂</button>

    <!-- Scenario Panel -->
    <div id="scenario-panel" role="dialog" aria-labelledby="scenario-panel-title">
        <button id="scenario-panel-close" aria-label="Close scenario panel">√ó</button>
        <h2 id="scenario-panel-title">Scenarios</h2>
        <p style="font-size: 12px; color: #90a070; margin-bottom: 16px;">Load pre-built starting conditions or save your own custom scenarios.</p>

        <h4 style="color: #c0d0a0; font-size: 14px; margin: 16px 0 8px;">Built-in Scenarios</h4>
        <div class="scenario-card" data-scenario="classic">
            <div class="scenario-name">Classic Sandbox</div>
            <div class="scenario-desc">Original experience - balanced resources, normal growth</div>
        </div>
        <div class="scenario-card" data-scenario="desert">
            <div class="scenario-name">Desert Survival</div>
            <div class="scenario-desc">Limited water, harsh sun, scarce food - test your colony's resilience</div>
        </div>
        <div class="scenario-card" data-scenario="flood">
            <div class="scenario-name">Flood Zone</div>
            <div class="scenario-desc">Frequent floods, build chambers high above ground to survive</div>
        </div>
        <div class="scenario-card" data-scenario="paradise">
            <div class="scenario-name">Paradise Island</div>
            <div class="scenario-desc">Abundant resources, no threats - pure creative freedom</div>
        </div>
        <div class="scenario-card" data-scenario="chaos">
            <div class="scenario-name">Chaos Mode</div>
            <div class="scenario-desc">Extreme weather, predators, disasters - survive the ultimate challenge</div>
        </div>

        <h4 style="color: #c0d0a0; font-size: 14px; margin: 20px 0 8px; border-top: 1px solid rgba(120,100,80,0.3); padding-top: 16px;">Share & Import</h4>
        <button id="save-scenario-btn" style="width: 100%; padding: 10px; margin-bottom: 8px; background: rgba(80,120,60,0.5); border: 1px solid rgba(120,180,100,0.4); color: #c0d0a0; cursor: pointer; border-radius: 6px; font-family: inherit;">
            üíæ Export Scenario
        </button>
        <div class="scenario-import-box">
            <label style="font-size: 11px; color: #a0b090; margin-bottom: 6px; display: block;">Import Scenario from Clipboard:</label>
            <textarea id="scenario-import-text" placeholder='Paste scenario JSON here...' aria-label="Scenario import text area"></textarea>
            <button id="scenario-import-btn" style="width: 100%; padding: 8px; margin-top: 8px; background: rgba(80,100,140,0.5); border: 1px solid rgba(100,140,180,0.4); color: #c0d0e0; cursor: pointer; border-radius: 6px; font-family: inherit; font-size: 12px;">
                üì• Import & Load
            </button>
        </div>
        <div style="font-size: 10px; color: #706050; margin-top: 8px; text-align: center;">Share scenarios as JSON text with other players!</div>
    </div>

    <!-- Color Picker Panel -->
    <div id="color-picker-panel" role="dialog" aria-labelledby="color-picker-title">
        <h3 id="color-picker-title" style="font-size: 14px; color: #d0b0e0; margin-bottom: 12px; text-align: center;">Customize Colony Colors</h3>
        <div class="color-picker-row">
            <span class="color-picker-label">Ant Color:</span>
            <input type="color" id="color-ant" class="color-picker-input" value="#8B6F47" aria-label="Ant color">
        </div>
        <div class="color-picker-row">
            <span class="color-picker-label">Queen Color:</span>
            <input type="color" id="color-queen" class="color-picker-input" value="#D4AF37" aria-label="Queen color">
        </div>
        <div class="color-picker-row">
            <span class="color-picker-label">Pheromone Trail:</span>
            <input type="color" id="color-pheromone" class="color-picker-input" value="#78B464" aria-label="Pheromone color">
        </div>
        <div class="color-picker-row">
            <span class="color-picker-label">Particles:</span>
            <input type="color" id="color-particle" class="color-picker-input" value="#C8A064" aria-label="Particle color">
        </div>
        <div class="color-preset-btns">
            <button class="color-preset-btn" data-preset="classic">Classic</button>
            <button class="color-preset-btn" data-preset="fire">Fire</button>
            <button class="color-preset-btn" data-preset="ice">Ice</button>
            <button class="color-preset-btn" data-preset="toxic">Toxic</button>
            <button class="color-preset-btn" data-preset="rainbow">Rainbow</button>
        </div>
        <button id="color-picker-close" style="width: 100%; margin-top: 12px; padding: 8px; background: rgba(80,60,80,0.4); border: 1px solid rgba(140,100,140,0.4); color: #d0b0e0; cursor: pointer; border-radius: 6px; font-family: inherit;">Close</button>
    </div>

    <!-- ============ CYCLE 12: SOCIAL & SHARING UI ============ -->

    <!-- Share Panel -->
    <div id="share-panel" role="dialog" aria-labelledby="share-panel-title">
        <button id="share-panel-close" aria-label="Close share panel">√ó</button>
        <h2 id="share-panel-title" style="color: #a0c0e0; font-size: 22px; margin-bottom: 20px; font-weight: normal;">üì§ Share & Celebrate</h2>

        <div class="share-section">
            <h3>üé¥ Colony Card</h3>
            <p style="font-size: 12px; color: #90a0b0; margin-bottom: 12px;">Generate a beautiful shareable card showcasing your colony's achievements</p>
            <canvas id="card-preview-canvas" class="share-preview-canvas" width="400" height="300" aria-label="Colony card preview"></canvas>
            <button class="share-btn" id="generate-card-btn">üé® Generate Colony Card</button>
            <div class="theme-selector">
                <button class="theme-btn active" data-theme="default">Classic</button>
                <button class="theme-btn" data-theme="aggressive">Warrior</button>
                <button class="theme-btn" data-theme="builder">Architect</button>
                <button class="theme-btn" data-theme="survivor">Survivor</button>
                <button class="theme-btn" data-theme="explorer">Explorer</button>
            </div>
        </div>

        <div class="share-section">
            <h3>üìñ Colony Story</h3>
            <div id="colony-story-display">
                <button class="story-copy-btn" id="story-copy-btn">üìã Copy</button>
                <span id="colony-story-text">Click "Generate Story" to create your colony's tale...</span>
            </div>
            <button class="share-btn" id="generate-story-btn">‚ú® Generate Colony Story</button>
        </div>

        <div class="share-section">
            <h3>üìä Statistics</h3>
            <button class="share-btn" id="open-stats-dashboard-btn">üìà Open Stats Dashboard</button>
            <button class="share-btn" id="share-stats-card-btn">üì§ Share Stats Card</button>
        </div>

        <div class="share-section">
            <h3>üì∏ Screenshot</h3>
            <label style="display: flex; align-items: center; gap: 8px; margin: 10px 0; font-size: 12px; color: #b0c0d0;">
                <input type="checkbox" id="screenshot-metadata-toggle" checked aria-label="Include metadata in screenshot">
                Include metadata overlay
            </label>
            <button class="share-btn" id="quick-screenshot-btn">üì∑ Quick Screenshot</button>
        </div>
    </div>

    <!-- Colony Card Modal -->
    <div id="colony-card-modal" role="dialog" aria-label="Colony Card">
        <canvas id="colony-card-canvas" width="800" height="1000" role="img" aria-label="Generated colony achievement card"></canvas>
        <div id="colony-card-controls">
            <button id="card-copy-btn">üìã Copy to Clipboard</button>
            <button id="card-download-btn">üíæ Download PNG</button>
            <button id="card-share-btn" style="display: none;">üì§ Share</button>
            <button id="card-close-btn">‚úï Close</button>
        </div>
    </div>

    <!-- Statistics Dashboard -->
    <div id="stats-dashboard" role="dialog" aria-labelledby="stats-dashboard-title">
        <div id="stats-dashboard-content">
            <button id="stats-dashboard-close" aria-label="Close statistics dashboard">√ó</button>
            <h1 id="stats-dashboard-title" style="color: #a0c0e0; font-size: 28px; margin-bottom: 8px;">üìä Statistics Dashboard</h1>
            <p style="color: #708090; font-size: 13px; margin-bottom: 20px;">CYCLE 12: Your colony's journey in numbers</p>

            <h3 style="color: #90b0c0; font-size: 16px; margin: 20px 0 12px;">Current Colony</h3>
            <div class="stats-grid" id="current-stats-grid">
                <div class="stat-card">
                    <div class="stat-card-label">Population</div>
                    <div class="stat-card-value" id="stat-population">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-card-label">Generation</div>
                    <div class="stat-card-value" id="stat-generation">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-card-label">Chambers</div>
                    <div class="stat-card-value" id="stat-chambers">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-card-label">Food Gathered</div>
                    <div class="stat-card-value" id="stat-food">0</div>
                </div>
            </div>

            <h3 style="color: #90b0c0; font-size: 16px; margin: 20px 0 12px;">Lifetime Stats</h3>
            <div class="stats-grid" id="lifetime-stats-grid">
                <div class="stat-card">
                    <div class="stat-card-label">Total Colonies</div>
                    <div class="stat-card-value" id="stat-total-colonies">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-card-label">Total Ants Born</div>
                    <div class="stat-card-value" id="stat-total-births">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-card-label">Achievements</div>
                    <div class="stat-card-value" id="stat-achievements">0/33</div>
                </div>
                <div class="stat-card">
                    <div class="stat-card-label">Disasters Survived</div>
                    <div class="stat-card-value" id="stat-disasters">0</div>
                </div>
            </div>

            <div style="text-align: center; margin-top: 30px;">
                <button class="share-btn" id="dashboard-share-btn" style="display: inline-block; width: auto; padding: 12px 32px;">
                    üì§ Share Stats Card
                </button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let W, H;

        // ============ CYCLE 6: SAVE SYSTEM CONSTANTS ============
        const SAVE_VERSION = "2.1"; // CYCLE 7 version
        const AUTOSAVE_INTERVAL = 30000; // 30 seconds
        const AUTOSAVE_KEY = 'colonyMindAutoSave';
        const AUTOSAVE_TIMESTAMP_KEY = 'colonyMindAutoSaveTime';

        // ============ CYCLE 6: PERFORMANCE TRACKING ============
        let fpsHistory = [];
        let lastFrameTime = performance.now();
        let performanceMode = 'auto'; // 'auto', 'high', 'balanced', 'low'

        // ============ CYCLE 6: ACCESSIBILITY STATE ============
        let highContrastMode = false;
        let announcements = []; // Screen reader announcement queue

        // ============ CYCLE 6: MOBILE STATE ============
        let isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        let touchState = { active: false, startX: 0, startY: 0, currentX: 0, currentY: 0 };

        // ============ CYCLE 7: PROFESSIONAL POLISH STATE ============
        const TUTORIAL_COMPLETED_KEY = 'colonyMindTutorialCompleted';
        const AUTOSAVE_RECOVERY_TIMEOUT = 300000; // 5 minutes
        let tutorialStep = 0;
        let helpPanelVisible = false;
        let lastMilestoneTime = 0;
        const MILESTONE_SOUND_COOLDOWN = 3000;

        // ============ CYCLE 8: SECRETS & SURPRISES STATE ============
        const LEGACY_DATA_KEY = 'colonyMindLegacyData';
        const ACHIEVEMENTS_KEY = 'colonyMindAchievements';
        const HALL_OF_FAME_KEY = 'colonyMindHallOfFame';
        const VISUAL_THEME_KEY = 'colonyMindVisualTheme';
        let legacyPanelVisible = false;
        let photoModeActive = false;
        let currentVisualTheme = 'default'; // default, aurora, sunset, matrix, night
        let celestialEventActive = null; // null, 'aurora', 'eclipse', 'meteor'
        let lastCelestialCheck = 0;
        let queenClickCount = 0;
        let queenClickTimer = null;
        let goldenAntBlessing = false; // Triple-click queen easter egg
        const namedAnts = new Map(); // ant -> name
        const thoughtBubbles = []; // Active thought bubble display elements
        let lastThoughtBubbleTime = 0;
        const undergroundChambers = []; // Hidden discovery chambers
        let artifactsFound = new Set(); // Track discovered artifacts
        let colonyStartTime = Date.now();
        let currentColonyPeakPopulation = 0;
        let currentGeneration = 1;
        let currentQueenName = "Queen Mother";
        let queenAge = 0;
        let queenLifespan = 300;
        let queenFed = 0;

        // ============ CYCLE 10: CHALLENGE MODES STATE ============
        const CHALLENGE_MODES_KEY = 'colonyMindChallengeModes';
        const CHALLENGE_PROGRESS_KEY = 'colonyMindChallengeProgress';
        const SPEEDRUN_LEADERBOARDS_KEY = 'colonyMindSpeedrunLeaderboards';

        // Challenge Mode State
        let currentChallengeMode = 'classic'; // classic, disaster, speedrun, rival
        let challengeModesUnlocked = {
            classic: true,
            disaster: false,
            speedrun: false,
            rival: false
        };

        // ============ CYCLE 15: PRESTIGE & META-PROGRESSION ============
        const PRESTIGE_SAVE_KEY = 'colonyMindPrestigeData';
        const PRESTIGE_VERSION = "1.0";

        // Prestige State
        let prestigeData = {
            version: PRESTIGE_VERSION,
            prestigePoints: 0,
            totalResets: 0,
            lifetimeStats: {
                totalPopulation: 0,
                totalSurvivalTime: 0,
                totalDeaths: 0,
                totalBirths: 0,
                totalFood: 0,
                totalDepthDug: 0,
                totalPredatorsDefeated: 0,
                totalDisastersSurvived: 0,
                totalLegends: 0
            },
            upgrades: {
                startingFood: 0,        // Max 10 levels
                queenBirthRate: 0,      // Max 8 levels
                excavationSpeed: 0,     // Max 10 levels
                gatheringEfficiency: 0, // Max 10 levels
                startingChambers: 0,    // Max 5 levels
                pheromonePersistence: 0, // Max 8 levels
                weatherResistance: 0,   // Max 6 levels
                antLongevity: 0         // Max 8 levels
            },
            titles: [],
            ascensionTier: 0,
            firstResetCompleted: false,
            lastResetDate: null
        };

        // Prestige Formulas & Constants
        const PRESTIGE_FORMULAS = {
            calculatePrestigePoints: (peakPop, survivalMinutes, difficultyMult, achievementCount) => {
                return Math.floor(peakPop * (survivalMinutes / 10) * difficultyMult * (1 + achievementCount * 0.1));
            },
            getUpgradeCost: (upgradeLevel) => {
                // Exponential cost curve
                return Math.floor(10 * Math.pow(1.5, upgradeLevel));
            },
            getUpgradeBonus: (upgradeLevel) => {
                // Diminishing returns
                if (upgradeLevel === 0) return 0;
                const baseBonus = 0.10; // 10%
                const diminish = Math.pow(0.85, upgradeLevel - 1);
                return baseBonus * (1 + (upgradeLevel - 1) * 0.5) * diminish;
            }
        };

        // Title Definitions (10 starting titles)
        const PRESTIGE_TITLES = {
            architect: { name: 'The Architect', requirement: 'Dig 10,000m total', icon: 'üèóÔ∏è', check: () => prestigeData.lifetimeStats.totalDepthDug >= 10000 },
            survivor: { name: 'The Survivor', requirement: 'Survive 100 total minutes', icon: '‚è±Ô∏è', check: () => prestigeData.lifetimeStats.totalSurvivalTime >= 100 },
            breeder: { name: 'The Breeder', requirement: 'Birth 1,000 total ants', icon: 'üêú', check: () => prestigeData.lifetimeStats.totalBirths >= 1000 },
            warrior: { name: 'The Warrior', requirement: 'Defeat 50 predators', icon: '‚öîÔ∏è', check: () => prestigeData.lifetimeStats.totalPredatorsDefeated >= 50 },
            gardener: { name: 'The Gardener', requirement: 'Harvest 10,000 food total', icon: 'üå±', check: () => prestigeData.lifetimeStats.totalFood >= 10000 },
            resilient: { name: 'The Resilient', requirement: 'Survive 10 disasters', icon: 'üõ°Ô∏è', check: () => prestigeData.lifetimeStats.totalDisastersSurvived >= 10 },
            legend_maker: { name: 'Legend Maker', requirement: 'Create 5 legendary ants', icon: '‚≠ê', check: () => prestigeData.lifetimeStats.totalLegends >= 5 },
            ascendant: { name: 'The Ascendant', requirement: 'Complete 10 prestige resets', icon: '‚ú®', check: () => prestigeData.totalResets >= 10 },
            immortal: { name: 'The Immortal', requirement: 'Complete 50 prestige resets', icon: 'üëë', check: () => prestigeData.totalResets >= 50 },
            eternity: { name: 'Master of Eternity', requirement: 'Complete 100 prestige resets', icon: '‚ôæÔ∏è', check: () => prestigeData.totalResets >= 100 }
        };

        let ascensionPanelVisible = false;

        // Disaster Mode State
        const DISASTER_TYPES = {
            FLOOD: {
                name: 'Flood', icon: 'üåä', warning: 45,
                desc: 'Rising water will drown ants in deep tunnels. Evacuate to upper levels!'
            },
            FIRE: {
                name: 'Wildfire', icon: 'üî•', warning: 30,
                desc: 'Surface fire spreading down tunnels. Dig firebreaks or evacuate deep!'
            },
            EARTHQUAKE: {
                name: 'Earthquake', icon: 'üèöÔ∏è', warning: 15,
                desc: 'Chambers will collapse! Distribute your ants to minimize losses!'
            },
            FAMINE: {
                name: 'Famine', icon: 'üçÇ', warning: 60,
                desc: 'Food depleting 5x faster. Stockpile now or your colony will starve!'
            },
            PLAGUE: {
                name: 'Plague', icon: 'ü¶†', warning: 20,
                desc: 'Disease spreads on contact. Quarantine infected ants immediately!'
            }
        };

        let activeDisaster = null;
        let disasterWarningTime = 0;
        let disasterActive = false;
        let disasterStartTime = 0;
        let disasterQueue = []; // Upcoming disasters
        let disasterParticles = []; // Fire/water particles
        let infectedAnts = new Set(); // For plague tracking
        let disasterScore = 0;
        let disastersSurvived = 0; // CYCLE 13: Fixed typo for proper disaster tracking

        // Speedrun Mode State
        const SPEEDRUN_CHALLENGES = {
            POPULATION: {
                name: 'Population Boom', target: 150, time: 180, metric: 'ants',
                desc: 'Reach 150 ants as fast as possible'
            },
            DEPTH: {
                name: 'Deep Dive', target: 0.8, time: 300, metric: 'depth',
                desc: 'Excavate to 80% depth'
            },
            CHAMBERS: {
                name: 'Chamber Master', target: 8, time: 240, metric: 'chambers',
                desc: 'Build 8 chambers'
            },
            GAUNTLET: {
                name: 'The Gauntlet', target: { ants: 100, chambers: 5, disasters: 1 }, time: 480, metric: 'combo',
                desc: 'Survive 1 disaster with 100 ants and 5 chambers'
            }
        };

        let currentSpeedrunChallenge = null;
        let speedrunStartTime = 0;
        let speedrunTargetTime = 0;
        let speedrunCompleted = false;
        let speedrunPersonalBests = {};

        // Rival Colony State
        let rivalQueen = null;
        let rivalAnts = [];
        let rivalChambers = [];
        let rivalFoodSources = [];
        let rivalAIState = {
            strategy: 'balanced', // passive, balanced, aggressive
            lastDecisionTime: 0,
            targetFood: null,
            targetExpansion: null,
            lastAction: 'idle'
        };
        let rivalSpatialGrid = null; // Initialized after SpatialGrid class definition
        const RIVAL_ANT_COLOR = [80, 70, 60]; // Dark gray-brown
        const RIVAL_UPDATE_INTERVAL = 90; // frames between AI decisions (1.5 seconds)

        // Constants must be declared before resize() which uses them
        const SOIL_RESOLUTION = 4;
        let soilGrid = [];
        let pheromoneGrid = [];          // Food trail pheromones (amber)
        let explorationPheromoneGrid = []; // Dig site pheromones (blue)
        let alarmPheromoneGrid = [];     // Danger/death pheromones (red) - ants avoid
        const ants = [];
        const foodSources = [];
        const chambers = [];
        const predators = []; // CYCLE 3: Predator system

        let colonySize = 150; // Start with more ants for better survival
        let digSpeed = 0.5;
        let time = 0;
        let placingFood = false;
        let predatorsEnabled = false; // CYCLE 3: Toggle for challenge mode
        let hoveredAnt = null; // CYCLE 3: For thought bubble visualization

        // ============ CYCLE 4: UNDERGROUND FEATURES & RESOURCE VARIETY ============
        // Food types with unique properties
        const FOOD_TYPES = {
            BASIC: { name: 'Nectar', color: [255, 200, 100], birthBonus: 0, speedBonus: 0 },
            PROTEIN: { name: 'Protein', color: [255, 150, 50], birthBonus: 0.3, speedBonus: 0.1 } // Rare, underground
        };

        // Chamber types with weather-reactive behavior
        const CHAMBER_TYPES = {
            NEST: { name: 'Nest', color: [120, 100, 80], unlocked: true },
            WATER_STORAGE: { name: 'Water Storage', color: [80, 120, 180], unlocked: false, unlockPop: 100 },
            FUNGUS_GARDEN: { name: 'Fungus Garden', color: [100, 160, 100], unlocked: false, unlockPop: 50 }
        };

        // Underground resource deposits (discovered when digging)
        const undergroundDeposits = [];
        let placingChamber = null; // Which chamber type to place (null = not placing)

        // ============ PERPETUAL EXPANSION SYSTEM ============
        let worldScale = 1.0;           // Current zoom level (1.0 = starting view)
        let targetScale = 1.0;          // Target scale for smooth transitions
        let totalExpansions = 0;        // Number of times world has expanded
        const EXPANSION_THRESHOLD = 0.25; // CYCLE 13: Expand when 25% of soil is excavated (tunable)
        const EXPANSION_FACTOR = 1.5;   // CYCLE 13: How much to grow on each expansion (tunable)
        let lastExpansionCheck = 0;     // Throttle expansion checks
        let exploredPercentage = 0;     // Current excavation percentage
        let pheromoneDecayOffset = 0;   // PERFORMANCE: Track partial grid decay position (STILL USED - see updatePheromones)

        const SOIL_COLORS = [
            { depth: 0, color: [60, 45, 30] },
            { depth: 0.3, color: [80, 55, 35] },
            { depth: 0.6, color: [100, 70, 45] },
            { depth: 1, color: [70, 50, 35] }
        ];

        // ============ UNDERGROUND OBSTACLES SYSTEM ============
        // Obstacles that ants must dig around or through
        const OBSTACLE_TYPES = {
            NONE: { id: 0, name: 'None', hardness: 0, color: null },
            SMALL_ROCK: { id: 1, name: 'Pebble', hardness: 3, color: [120, 115, 110], minDepth: 0.15, maxDepth: 1.0, size: 1 },
            LARGE_ROCK: { id: 2, name: 'Rock', hardness: 8, color: [90, 85, 80], minDepth: 0.25, maxDepth: 1.0, size: 2 },
            BOULDER: { id: 3, name: 'Boulder', hardness: 0, color: [70, 65, 60], minDepth: 0.4, maxDepth: 1.0, size: 3, impassable: true },
            ROOT: { id: 4, name: 'Root', hardness: 2, color: [100, 70, 50], minDepth: 0.15, maxDepth: 0.5, size: 1 },
            THICK_ROOT: { id: 5, name: 'Thick Root', hardness: 4, color: [80, 55, 40], minDepth: 0.2, maxDepth: 0.6, size: 2 },
            CLAY: { id: 6, name: 'Clay', hardness: 2, color: [140, 100, 70], minDepth: 0.3, maxDepth: 0.7, size: 2 },
            GRAVEL: { id: 7, name: 'Gravel', hardness: 1.5, color: [110, 105, 100], minDepth: 0.2, maxDepth: 0.9, size: 1 },
            FOSSIL: { id: 8, name: 'Fossil', hardness: 5, color: [180, 170, 150], minDepth: 0.5, maxDepth: 1.0, size: 2 }
        };
        let obstacleGrid = []; // Stores obstacle type ID at each grid position

        // ============ SIMULATION CONTROL ============
        let isPaused = false;
        let simulationSpeed = 1.0;

        // ============ CYCLE 15: OBSERVER CAMERA FOLLOW MODE ============
        let followedAnt = null;
        let cameraOffset = { x: 0, y: 0 };
        let observerModeEnabled = false;

        // ============ CYCLE 11: CREATIVE & SANDBOX MODE ============
        let creativeMode = false;
        let godModeEnabled = false;
        let spawnMode = null; // 'ant', 'queen', 'food', 'predator', 'chamber'
        let spawnQuantity = 1;
        let undoSnapshot = null; // Single-level undo

        // Colony appearance customization
        let colonyColors = {
            ant: '#8B6F47',
            queen: '#D4AF37',
            pheromone: 'rgba(120,180,100,0.3)',
            particle: 'rgba(200,160,100,0.7)'
        };
        let colorPreset = 'classic'; // 'classic', 'fire', 'ice', 'toxic', 'rainbow'

        // Scenarios
        let currentScenario = 'classic';
        const builtInScenarios = {
            classic: { name: 'Classic', desc: 'Original sandbox experience' },
            desert: { name: 'Desert Survival', desc: 'Limited water, harsh weather' },
            flood: { name: 'Flood Zone', desc: 'Frequent floods, build high' },
            paradise: { name: 'Paradise Island', desc: 'Abundant resources, no threats' },
            chaos: { name: 'Chaos Mode', desc: 'Everything at once, survive!' }
        };

        // ============ CYCLE 5: LIVING ART / AMBIENCE MODE ============
        let ambienceMode = false;
        let ambienceFadeProgress = 0; // 0-1 for UI fade
        let cameraX = 0, cameraY = 0; // Camera offset for panning
        let cameraTargetX = 0, cameraTargetY = 0;
        let ambienceHideTimeout = null;
        let lastInteractionTime = Date.now();

        // ============ SPATIAL PARTITIONING FOR O(1) LOOKUPS ============
        class SpatialGrid {
            constructor(cellSize = 40) {
                this.cellSize = cellSize;
                this.cells = new Map();
            }

            getKey(x, y) {
                const cx = Math.floor(x / this.cellSize);
                const cy = Math.floor(y / this.cellSize);
                return `${cx},${cy}`;
            }

            insert(entity) {
                const key = this.getKey(entity.x, entity.y);
                if (!this.cells.has(key)) {
                    this.cells.set(key, []);
                }
                this.cells.get(key).push(entity);
                entity._spatialKey = key;
            }

            remove(entity) {
                if (entity._spatialKey) {
                    const cell = this.cells.get(entity._spatialKey);
                    if (cell) {
                        const idx = cell.indexOf(entity);
                        if (idx !== -1) cell.splice(idx, 1);
                    }
                }
            }

            update(entity) {
                const newKey = this.getKey(entity.x, entity.y);
                if (newKey !== entity._spatialKey) {
                    this.remove(entity);
                    this.insert(entity);
                }
            }

            getNearby(x, y, radius) {
                const results = [];
                const cellRadius = Math.ceil(radius / this.cellSize);
                const cx = Math.floor(x / this.cellSize);
                const cy = Math.floor(y / this.cellSize);

                for (let dy = -cellRadius; dy <= cellRadius; dy++) {
                    for (let dx = -cellRadius; dx <= cellRadius; dx++) {
                        const key = `${cx + dx},${cy + dy}`;
                        const cell = this.cells.get(key);
                        if (cell) {
                            for (const entity of cell) {
                                const dist = Math.hypot(entity.x - x, entity.y - y);
                                if (dist <= radius) {
                                    results.push(entity);
                                }
                            }
                        }
                    }
                }
                return results;
            }

            clear() {
                this.cells.clear();
            }
        }

        const antSpatialGrid = new SpatialGrid(40);
        const foodSpatialGrid = new SpatialGrid(60); // CYCLE 4: Spatial partitioning for food sources
        rivalSpatialGrid = new SpatialGrid(40); // Initialize rival spatial grid now that class is defined

        // ============ WEATHER SYSTEM ============
        const WEATHER_STATES = {
            CLEAR: { name: 'Clear', icon: '‚òÄÔ∏è', duration: [45, 75], color: [135, 180, 220] },
            RAIN: { name: 'Rain', icon: 'üåßÔ∏è', duration: [30, 60], color: [80, 100, 130] },
            DROUGHT: { name: 'Drought', icon: 'üî•', duration: [40, 70], color: [180, 140, 100] },
            COLD: { name: 'Cold', icon: '‚ùÑÔ∏è', duration: [35, 55], color: [150, 170, 200] },
            STORM: { name: 'Storm', icon: '‚õàÔ∏è', duration: [20, 35], color: [50, 60, 80] }
        };

        // ============ CYCLE 5: DAY/NIGHT SYSTEM ============
        class DayNightCycle {
            constructor() {
                this.time = 0; // 0-180 seconds (90 day, 90 night)
                this.cycleDuration = 180;
            }

            update(dt) {
                this.time = (this.time + dt) % this.cycleDuration;
            }

            isDaytime() {
                return this.time < 90;
            }

            getSkyBrightness() {
                // Smooth transitions at dawn/dusk
                const t = this.time;
                if (t < 10) return 0.5 + (t / 10) * 0.5; // Dawn: 0.5 -> 1.0
                if (t < 80) return 1.0; // Day
                if (t < 90) return 1.0 - ((t - 80) / 10) * 0.5; // Dusk: 1.0 -> 0.5
                if (t < 100) return 0.5 - ((t - 90) / 10) * 0.2; // Night fall: 0.5 -> 0.3
                if (t < 170) return 0.3; // Night
                return 0.3 + ((t - 170) / 10) * 0.2; // Pre-dawn: 0.3 -> 0.5
            }

            getTimeIcon() {
                return this.isDaytime() ? '‚òÄÔ∏è' : 'üåô';
            }
        }

        const dayNightCycle = new DayNightCycle();

        class WeatherSystem {
            constructor() {
                this.state = 'CLEAR';
                this.stateTime = 0;
                this.cycleDuration = 120; // Start with long clear period (grace period)
                this.transitionProgress = 1; // 1 = fully in current state
                this.previousState = 'CLEAR';
                this.particles = [];
                this.maxParticles = 200;
                this.floodLevel = 0; // 0-1, how flooded deep tunnels are
                this.lightningFlash = 0;
                this.windStrength = 0;
                this.gracePeriod = true; // First weather cycle is guaranteed clear
            }

            getRandomDuration(state) {
                const [min, max] = WEATHER_STATES[state].duration;
                return min + Math.random() * (max - min);
            }

            getNextState() {
                // After grace period, still favor clear/mild weather
                // Grace period guarantees first transition stays clear-ish
                if (this.gracePeriod) {
                    this.gracePeriod = false;
                    // 70% chance of another clear period, 30% chance of mild rain
                    return Math.random() < 0.7 ? 'CLEAR' : 'RAIN';
                }

                const states = Object.keys(WEATHER_STATES);
                // Weight heavily toward clear weather, storms are very rare
                const weights = { CLEAR: 5, RAIN: 2, DROUGHT: 1.5, COLD: 1.5, STORM: 0.5 };
                const totalWeight = Object.values(weights).reduce((a, b) => a + b, 0);
                let r = Math.random() * totalWeight;
                for (const state of states) {
                    r -= weights[state];
                    if (r <= 0) return state;
                }
                return 'CLEAR';
            }

            update(dt) {
                this.stateTime += dt;

                // Transition effect
                if (this.transitionProgress < 1) {
                    this.transitionProgress = Math.min(1, this.transitionProgress + dt * 0.2);
                }

                // Check for state change
                if (this.stateTime >= this.cycleDuration) {
                    this.previousState = this.state;
                    this.state = this.getNextState();
                    this.cycleDuration = this.getRandomDuration(this.state);
                    this.stateTime = 0;
                    this.transitionProgress = 0;
                    this.updateUI();
                }

                // Update weather-specific effects
                this.updateEffects(dt);
                this.updateParticles(dt);
                this.updateUI();
            }

            updateEffects(dt) {
                // Lightning in storms
                if (this.state === 'STORM') {
                    if (Math.random() < 0.002) { // Reduced frequency
                        this.lightningFlash = 0.6; // Reduced intensity
                    }
                    this.windStrength = 0.8 + Math.sin(time * 2) * 0.2;
                } else {
                    this.windStrength = this.state === 'RAIN' ? 0.3 : 0;
                }
                this.lightningFlash *= 0.92; // Slower decay for smoother fade

                // Flood level during rain/storm
                if (this.state === 'RAIN' || this.state === 'STORM') {
                    this.floodLevel = Math.min(1, this.floodLevel + dt * 0.02);
                } else {
                    this.floodLevel = Math.max(0, this.floodLevel - dt * 0.03);
                }
            }

            updateParticles(dt) {
                // Spawn weather particles
                const spawnRates = { CLEAR: 0, RAIN: 3, DROUGHT: 0.3, COLD: 1.5, STORM: 5 };
                const rate = spawnRates[this.state] || 0;

                for (let i = 0; i < rate; i++) {
                    if (this.particles.length < this.maxParticles && Math.random() < 0.5) {
                        this.spawnParticle();
                    }
                }

                // Update existing particles
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.x += p.vx * dt * 60;
                    p.y += p.vy * dt * 60;
                    p.life -= p.decay * dt * 60;

                    if (p.life <= 0 || p.y > H || p.x < 0 || p.x > W) {
                        this.particles.splice(i, 1);
                    }
                }
            }

            spawnParticle() {
                const types = {
                    RAIN: { vy: 8, vx: 2, size: 2, color: [150, 180, 220], decay: 0.01 },
                    STORM: { vy: 12, vx: 4, size: 3, color: [120, 150, 200], decay: 0.015 },
                    COLD: { vy: 1.5, vx: 0.5, size: 3, color: [220, 230, 255], decay: 0.008 },
                    DROUGHT: { vy: -0.5, vx: 1, size: 2, color: [200, 160, 100], decay: 0.02 }
                };

                const config = types[this.state];
                if (!config) return;

                this.particles.push({
                    x: Math.random() * W,
                    y: this.state === 'DROUGHT' ? H * 0.3 + Math.random() * H * 0.5 : -10,
                    vx: (Math.random() - 0.5) * config.vx + this.windStrength * 2,
                    vy: config.vy + Math.random() * 2,
                    size: config.size * (0.5 + Math.random() * 0.5),
                    color: config.color,
                    life: 1,
                    decay: config.decay
                });
            }

            draw() {
                // Draw weather particles
                for (const p of this.particles) {
                    ctx.beginPath();
                    if (this.state === 'RAIN' || this.state === 'STORM') {
                        // Rain streaks
                        ctx.moveTo(p.x, p.y);
                        ctx.lineTo(p.x - p.vx * 0.3, p.y - p.vy * 0.5);
                        ctx.strokeStyle = `rgba(${p.color.join(',')}, ${p.life * 0.6})`;
                        ctx.lineWidth = p.size * 0.5;
                        ctx.stroke();
                    } else if (this.state === 'COLD') {
                        // Snowflakes
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(${p.color.join(',')}, ${p.life * 0.8})`;
                        ctx.fill();
                    } else if (this.state === 'DROUGHT') {
                        // Heat shimmer / dust
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(${p.color.join(',')}, ${p.life * 0.4})`;
                        ctx.fill();
                    }
                }

                // Lightning flash overlay
                if (this.lightningFlash > 0.05) {
                    ctx.fillStyle = `rgba(255, 255, 255, ${this.lightningFlash * 0.15})`;
                    ctx.fillRect(0, 0, W, H);
                }

                // Flood water in deep tunnels
                if (this.floodLevel > 0) {
                    this.drawFloodWater();
                }
            }

            drawFloodWater() {
                const floodStartY = H * (0.6 - this.floodLevel * 0.2);
                const cols = soilGrid[0]?.length || 0;
                const rows = soilGrid.length || 0;

                ctx.globalAlpha = this.floodLevel * 0.4;
                for (let gy = Math.floor(floodStartY / SOIL_RESOLUTION); gy < rows; gy++) {
                    for (let gx = 0; gx < cols; gx++) {
                        if (soilGrid[gy] && soilGrid[gy][gx] < 0.5) {
                            const sx = gx * (W / cols);
                            const sy = gy * (H / rows);
                            const waterDepth = (gy / rows - 0.5) * 2;
                            ctx.fillStyle = `rgba(60, 100, 150, ${0.3 + waterDepth * 0.3})`;
                            ctx.fillRect(sx, sy, W / cols + 1, H / rows + 1);
                        }
                    }
                }
                ctx.globalAlpha = 1;
            }

            getSpeedModifier() {
                // Less harsh speed penalties to help colony survive
                const mods = { CLEAR: 1.0, RAIN: 0.9, DROUGHT: 0.9, COLD: 0.75, STORM: 0.8 };
                return mods[this.state] || 1.0;
            }

            getDeathRiskMultiplier() {
                // Elders have slightly higher death risk in cold (reduced from 2.0)
                return this.state === 'COLD' ? 1.5 : 1.0;
            }

            getFoodDepletionMultiplier() {
                // Drought depletes food faster but not as extreme
                return this.state === 'DROUGHT' ? 2.0 : 1.0;
            }

            isFlooded(y) {
                // Only deep tunnels flood (below 70% instead of 60%)
                if (this.floodLevel < 0.2) return false;
                const floodStartY = H * (0.7 - this.floodLevel * 0.15);
                return y > floodStartY;
            }

            updateUI() {
                const stateInfo = WEATHER_STATES[this.state];
                // CYCLE 5: Blend day/night icon with weather
                const timeIcon = dayNightCycle.getTimeIcon();
                document.getElementById('weather-icon').textContent = `${timeIcon} ${stateInfo.icon}`;
                const timeName = dayNightCycle.isDaytime() ? 'Day' : 'Night';
                document.getElementById('weather-name').textContent = `${timeName} | ${stateInfo.name}`;
                const remaining = Math.ceil(this.cycleDuration - this.stateTime);
                document.getElementById('weather-timer').textContent = `${remaining}s`;
            }

            getSkyColor() {
                const current = WEATHER_STATES[this.state].color;
                const prev = WEATHER_STATES[this.previousState].color;
                const t = this.transitionProgress;
                return [
                    Math.round(prev[0] * (1 - t) + current[0] * t),
                    Math.round(prev[1] * (1 - t) + current[1] * t),
                    Math.round(prev[2] * (1 - t) + current[2] * t)
                ];
            }
        }

        const weather = new WeatherSystem();

        // ============ QUEEN ANT REPRODUCTION SYSTEM ============
        let queen = null;
        let totalBirths = 0;
        const QUEEN_SPAWN_INTERVAL = 4; // seconds between spawn attempts - IMPROVED for faster early-game reproduction
        const FOOD_PER_BIRTH = 1; // food deliveries needed per new ant (easier to grow colony)

        // CYCLE 13: Magic numbers extracted for maintainability
        const QUEEN_HUNGER_WARNING_THRESHOLD = 15; // seconds before red glow starts
        const QUEEN_HUNGER_RAMP_DURATION = 10; // seconds to reach full hunger intensity

        class QueenAnt {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.foodReceived = 0;
                this.lastSpawnTime = 0;
                this.pulsePhase = 0;
                this.eggProgress = 0; // Visual indicator of egg development
                this.timeSinceLastFood = 0; // HUNGER INDICATOR: tracks time since last feeding
            }

            feedQueen() {
                this.foodReceived++;
                this.eggProgress = Math.min(1, this.eggProgress + (1 / FOOD_PER_BIRTH));
                this.timeSinceLastFood = 0; // Reset hunger timer when fed
            }

            update(currentTime) {
                this.pulsePhase += 0.02;
                this.timeSinceLastFood += 0.016; // ~1 second per 60 frames

                // Check if ready to spawn new ants
                if (currentTime - this.lastSpawnTime >= QUEEN_SPAWN_INTERVAL) {
                    if (this.foodReceived >= FOOD_PER_BIRTH) {
                        const antsToSpawn = Math.min(2, Math.floor(this.foodReceived / FOOD_PER_BIRTH));
                        for (let i = 0; i < antsToSpawn; i++) {
                            this.spawnWorker();
                        }
                        this.foodReceived -= antsToSpawn * FOOD_PER_BIRTH;
                        this.eggProgress = this.foodReceived / FOOD_PER_BIRTH;
                        this.lastSpawnTime = currentTime;
                    }
                }
            }

            spawnWorker() {
                const ant = new Ant();
                // Spawn near queen
                ant.x = this.x + (Math.random() - 0.5) * 25;
                ant.y = this.y + (Math.random() - 0.5) * 25;
                ant.angle = Math.random() * Math.PI * 2;

                // Apply genetic memory - inherited behaviors from successful ancestors
                applyGeneticMemory(ant);

                ants.push(ant);
                antSpatialGrid.insert(ant); // Register in spatial grid
                totalBirths++;

                // Visual birth effect - brief glow
                this.pulsePhase = 0;

                // IMPROVEMENT #5: Birth sound + haptic feedback
                playBirthSound();
                hapticFeedback(HAPTIC_PATTERNS.birth);
            }

            draw() {
                const pulse = 1 + Math.sin(this.pulsePhase) * 0.1;

                ctx.save();
                ctx.translate(this.x, this.y);

                // Glow effect based on egg progress
                if (this.eggProgress > 0) {
                    const glowRadius = 20 + this.eggProgress * 15;
                    const gradient = ctx.createRadialGradient(0, 0, 5, 0, 0, glowRadius);
                    gradient.addColorStop(0, `rgba(255, 220, 150, ${this.eggProgress * 0.3})`);
                    gradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(-glowRadius, -glowRadius, glowRadius * 2, glowRadius * 2);
                }

                // HUNGER GLOW - red pulsing when queen hasn't been fed
                // CYCLE 13: Using named constants instead of magic numbers
                if (this.timeSinceLastFood > QUEEN_HUNGER_WARNING_THRESHOLD) {
                    const hungerIntensity = Math.min(1, (this.timeSinceLastFood - QUEEN_HUNGER_WARNING_THRESHOLD) / QUEEN_HUNGER_RAMP_DURATION);
                    const hungerPulse = 0.5 + Math.sin(this.pulsePhase * 3) * 0.5; // Fast pulse
                    const hungerRadius = 25;
                    const hungerGradient = ctx.createRadialGradient(0, 0, 5, 0, 0, hungerRadius);
                    hungerGradient.addColorStop(0, `rgba(255, 100, 80, ${hungerIntensity * hungerPulse * 0.5})`);
                    hungerGradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = hungerGradient;
                    ctx.fillRect(-hungerRadius, -hungerRadius, hungerRadius * 2, hungerRadius * 2);
                }

                // Queen abdomen (larger, golden) - CYCLE 11: Custom color
                ctx.beginPath();
                ctx.ellipse(0, 0, 8 * pulse, 5 * pulse, 0, 0, Math.PI * 2);
                ctx.fillStyle = colonyColors.queen || '#c4a040'; // CYCLE 11: Customizable
                ctx.fill();
                ctx.strokeStyle = '#8a7030';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Thorax
                ctx.beginPath();
                ctx.ellipse(-7, 0, 4 * pulse, 3 * pulse, 0, 0, Math.PI * 2);
                ctx.fillStyle = '#a08030';
                ctx.fill();

                // Head
                ctx.beginPath();
                ctx.ellipse(-11, 0, 3 * pulse, 2.5 * pulse, 0, 0, Math.PI * 2);
                ctx.fillStyle = '#8a6020';
                ctx.fill();

                // Antennae
                ctx.beginPath();
                ctx.moveTo(-13, -2);
                ctx.lineTo(-17, -5);
                ctx.moveTo(-13, 2);
                ctx.lineTo(-17, 5);
                ctx.strokeStyle = '#6a5020';
                ctx.lineWidth = 0.8;
                ctx.stroke();

                // Crown indicator (simple dots)
                ctx.beginPath();
                ctx.arc(-11, -4, 1.5, 0, Math.PI * 2);
                ctx.fillStyle = '#ffd700';
                ctx.fill();

                // Egg progress indicator (small eggs around queen)
                const numEggs = Math.floor(this.eggProgress * 3);
                for (let i = 0; i < numEggs; i++) {
                    const eggAngle = (i / 3) * Math.PI - Math.PI / 2;
                    const eggX = Math.cos(eggAngle) * 12;
                    const eggY = Math.sin(eggAngle) * 12;
                    ctx.beginPath();
                    ctx.ellipse(eggX, eggY, 2, 3, eggAngle + Math.PI / 2, 0, Math.PI * 2);
                    ctx.fillStyle = '#fffde0';
                    ctx.fill();
                    ctx.strokeStyle = '#e0d8a0';
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                }

                ctx.restore();

                // "QUEEN" label
                ctx.font = '9px Georgia';
                ctx.fillStyle = '#c4a040';
                ctx.textAlign = 'center';
                ctx.fillText('‚ôï', this.x, this.y - 18);
            }
        }

        function resize() {
            W = canvas.width = innerWidth;
            H = canvas.height = innerHeight;
            // Only init soil if grids are empty (first load)
            if (soilGrid.length === 0) {
                initSoil();
            }
            // Otherwise just redraw - grids maintain their own size
        }
        window.onresize = resize;

        function initSoil() {
            const cols = Math.ceil(W / SOIL_RESOLUTION);
            const rows = Math.ceil(H / SOIL_RESOLUTION);
            soilGrid = [];
            pheromoneGrid = [];
            explorationPheromoneGrid = [];
            alarmPheromoneGrid = [];
            obstacleGrid = [];

            for (let y = 0; y < rows; y++) {
                soilGrid[y] = [];
                pheromoneGrid[y] = [];
                explorationPheromoneGrid[y] = [];
                alarmPheromoneGrid[y] = [];
                obstacleGrid[y] = [];
                for (let x = 0; x < cols; x++) {
                    const surfaceY = H * 0.15;
                    const worldY = y * SOIL_RESOLUTION;
                    soilGrid[y][x] = worldY > surfaceY ? 1 : 0;
                    pheromoneGrid[y][x] = 0;
                    explorationPheromoneGrid[y][x] = 0;
                    alarmPheromoneGrid[y][x] = 0;
                    obstacleGrid[y][x] = 0; // OBSTACLE_TYPES.NONE.id
                }
            }

            // Generate underground obstacles before clearing nest area
            generateObstacles(cols, rows);

            const nestX = Math.floor(W / 2 / SOIL_RESOLUTION);
            const nestY = Math.floor(H * 0.2 / SOIL_RESOLUTION);
            const surfaceGridY = Math.floor(H * 0.15 / SOIL_RESOLUTION);

            // Create nest chamber (clear soil AND obstacles)
            for (let dy = -3; dy <= 3; dy++) {
                for (let dx = -4; dx <= 4; dx++) {
                    const gx = nestX + dx;
                    const gy = nestY + dy;
                    if (gx >= 0 && gx < cols && gy >= 0 && gy < rows) {
                        if (Math.sqrt(dx*dx + dy*dy) < 4) {
                            soilGrid[gy][gx] = 0;
                            obstacleGrid[gy][gx] = 0; // Clear obstacles from nest
                        }
                    }
                }
            }

            // Create a simple vertical tunnel from nest to surface (clear obstacles too)
            for (let y = surfaceGridY; y <= nestY + 2; y++) {
                for (let dx = -2; dx <= 2; dx++) {
                    if (soilGrid[y] && nestX + dx >= 0 && nestX + dx < cols) {
                        soilGrid[y][nestX + dx] = 0;
                        obstacleGrid[y][nestX + dx] = 0; // Clear obstacles from tunnel
                    }
                }
            }

            chambers.push({
                x: W/2,
                y: H * 0.2,
                radius: 15,
                type: 'NEST', // CYCLE 4: Chamber types
                waterLevel: 0, // For water storage chambers
                fungusHealth: 1.0, // For fungus gardens (0-1, affected by floods)
                foodProduction: 0 // Food accumulated in fungus gardens
            });

            // Create the queen at the nest center
            queen = new QueenAnt(W / 2, H * 0.2);

            // Initialize AO cache
            initAOCache();

            // Generate organic root tendrils
            generateRoots();

            // Generate buried food sources throughout the underground
            generateBuriedFood(cols, rows);
        }

        // Generate underground obstacles based on depth
        function generateObstacles(cols, rows) {
            const surfaceGridY = Math.floor(H * 0.15 / SOIL_RESOLUTION);

            // Place clusters of different obstacle types
            const obstacleConfigs = [
                { type: OBSTACLE_TYPES.SMALL_ROCK, density: 0.04, clusterSize: [1, 2] },
                { type: OBSTACLE_TYPES.LARGE_ROCK, density: 0.015, clusterSize: [2, 4] },
                { type: OBSTACLE_TYPES.BOULDER, density: 0.004, clusterSize: [3, 5] },
                { type: OBSTACLE_TYPES.ROOT, density: 0.03, clusterSize: [1, 3] },
                { type: OBSTACLE_TYPES.THICK_ROOT, density: 0.01, clusterSize: [2, 4] },
                { type: OBSTACLE_TYPES.CLAY, density: 0.02, clusterSize: [4, 8] },
                { type: OBSTACLE_TYPES.GRAVEL, density: 0.025, clusterSize: [2, 5] },
                { type: OBSTACLE_TYPES.FOSSIL, density: 0.003, clusterSize: [2, 3] }
            ];

            for (const config of obstacleConfigs) {
                const type = config.type;
                const numClusters = Math.floor(cols * rows * config.density);

                for (let i = 0; i < numClusters; i++) {
                    // Pick a random position within the valid depth range
                    const minGridY = Math.floor(type.minDepth * rows);
                    const maxGridY = Math.floor(type.maxDepth * rows);

                    if (minGridY >= maxGridY) continue;

                    const centerX = Math.floor(Math.random() * cols);
                    const centerY = minGridY + Math.floor(Math.random() * (maxGridY - minGridY));

                    // Skip if above surface
                    if (centerY <= surfaceGridY) continue;

                    // Create cluster
                    const clusterSize = config.clusterSize[0] +
                        Math.floor(Math.random() * (config.clusterSize[1] - config.clusterSize[0]));

                    for (let j = 0; j < clusterSize; j++) {
                        // Organic cluster shape
                        const offsetX = Math.floor((Math.random() - 0.5) * type.size * 3);
                        const offsetY = Math.floor((Math.random() - 0.5) * type.size * 2);
                        const gx = centerX + offsetX;
                        const gy = centerY + offsetY;

                        if (gx >= 0 && gx < cols && gy > surfaceGridY && gy < rows) {
                            // Don't overwrite existing obstacles with lower-priority ones
                            if (obstacleGrid[gy][gx] === 0) {
                                obstacleGrid[gy][gx] = type.id;
                            }
                        }
                    }
                }
            }

            // Create some horizontal root networks near surface
            const numRootNetworks = 3 + Math.floor(Math.random() * 4);
            for (let i = 0; i < numRootNetworks; i++) {
                let x = Math.floor(Math.random() * cols);
                let y = surfaceGridY + 2 + Math.floor(Math.random() * (rows * 0.2));
                const length = 10 + Math.floor(Math.random() * 30);
                const direction = Math.random() > 0.5 ? 1 : -1;

                for (let j = 0; j < length; j++) {
                    if (x >= 0 && x < cols && y > surfaceGridY && y < rows) {
                        if (obstacleGrid[y][x] === 0) {
                            obstacleGrid[y][x] = Math.random() > 0.3 ?
                                OBSTACLE_TYPES.ROOT.id : OBSTACLE_TYPES.THICK_ROOT.id;
                        }
                    }
                    x += direction;
                    // Slight vertical wandering
                    if (Math.random() < 0.3) y += Math.random() > 0.5 ? 1 : -1;
                }
            }
        }

        // Get obstacle at grid position
        function getObstacleAt(gx, gy) {
            if (gy >= 0 && gy < obstacleGrid.length && gx >= 0 && gx < (obstacleGrid[0]?.length || 0)) {
                const id = obstacleGrid[gy][gx];
                for (const key in OBSTACLE_TYPES) {
                    if (OBSTACLE_TYPES[key].id === id) return OBSTACLE_TYPES[key];
                }
            }
            return OBSTACLE_TYPES.NONE;
        }

        // Generate buried food sources throughout the underground
        function generateBuriedFood(cols, rows) {
            const surfaceY = H * 0.15;

            // Buried food types with spawn properties
            const buriedFoodTypes = [
                { type: 'BASIC', name: 'Seed Cache', amount: [50, 150], minDepth: 0.2, maxDepth: 0.5, count: [3, 6] },
                { type: 'BASIC', name: 'Nectar Pool', amount: [80, 200], minDepth: 0.15, maxDepth: 0.4, count: [2, 4] },
                { type: 'PROTEIN', name: 'Dead Insect', amount: [100, 250], minDepth: 0.3, maxDepth: 0.7, count: [2, 4] },
                { type: 'PROTEIN', name: 'Larva Cache', amount: [150, 300], minDepth: 0.5, maxDepth: 0.9, count: [1, 3] },
                { type: 'BASIC', name: 'Fungal Deposit', amount: [60, 120], minDepth: 0.25, maxDepth: 0.6, count: [2, 5] }
            ];

            for (const foodDef of buriedFoodTypes) {
                const count = foodDef.count[0] + Math.floor(Math.random() * (foodDef.count[1] - foodDef.count[0] + 1));

                for (let i = 0; i < count; i++) {
                    // Random position within depth range
                    const depthRange = foodDef.maxDepth - foodDef.minDepth;
                    const depth = foodDef.minDepth + Math.random() * depthRange;
                    const y = surfaceY + (H - surfaceY) * depth;
                    const x = 50 + Math.random() * (W - 100); // Keep away from edges

                    // Random amount within range
                    const amount = foodDef.amount[0] + Math.floor(Math.random() * (foodDef.amount[1] - foodDef.amount[0] + 1));

                    // Check this position isn't in the nest area
                    const distFromCenter = Math.abs(x - W/2);
                    const distFromNest = Math.hypot(x - W/2, y - H * 0.2);
                    if (distFromNest < 60) continue; // Skip if too close to nest

                    const buriedFood = {
                        x: x,
                        y: y,
                        amount: amount,
                        maxAmount: amount,
                        type: foodDef.type,
                        buried: true, // Mark as buried - only visible when excavated
                        name: foodDef.name
                    };

                    foodSources.push(buriedFood);
                    foodSpatialGrid.insert(buriedFood);
                }
            }
        }

        // ============ ROLE SPECIALIZATION SYSTEM ============
        const ROLE_THRESHOLD = 50; // CYCLE 13: Experience needed to specialize (was magic number)
        const ANT_ROLES = {
            WORKER: 'worker',      // Generalist, can do anything
            EXCAVATOR: 'excavator', // Specializes in digging
            GATHERER: 'gatherer',   // Specializes in food collection
            NURSE: 'nurse'          // Stays near queen, helps with larvae
        };

        // ============ TUNNEL ROOT TENDRIL SYSTEM ============
        // Organic roots that grow down from surface, visible when tunnels are dug
        let rootTendrils = [];

        function generateRoots() {
            rootTendrils = [];
            const numRoots = 8 + Math.floor(Math.random() * 6); // 8-13 major roots

            for (let i = 0; i < numRoots; i++) {
                const startX = 0.1 + Math.random() * 0.8; // Normalized x (10%-90%)
                const root = {
                    segments: [],
                    color: Math.random() > 0.5 ? 'warm' : 'cool'
                };

                // Generate root path using random walk
                let x = startX;
                let y = 0.15; // Start at surface
                let angle = Math.PI / 2 + (Math.random() - 0.5) * 0.3; // Mostly downward
                const maxDepth = 0.4 + Math.random() * 0.4; // Grow 40-80% down

                while (y < maxDepth) {
                    const thickness = Math.max(0.5, 3 * (1 - (y - 0.15) / (maxDepth - 0.15)));
                    root.segments.push({ x, y, thickness });

                    // Continue path with slight wandering
                    const stepSize = 0.01 + Math.random() * 0.015;
                    x += Math.cos(angle) * stepSize;
                    y += Math.sin(angle) * stepSize;

                    // Random angle changes (organic feel)
                    angle += (Math.random() - 0.5) * 0.4;
                    angle = Math.max(Math.PI * 0.3, Math.min(Math.PI * 0.7, angle)); // Keep mostly downward

                    // Occasionally branch
                    if (Math.random() < 0.1 && root.segments.length > 5) {
                        const branchRoot = {
                            segments: [],
                            color: root.color
                        };
                        let bx = x, by = y;
                        let bAngle = angle + (Math.random() > 0.5 ? 0.5 : -0.5);
                        const branchLength = 3 + Math.floor(Math.random() * 8);

                        for (let j = 0; j < branchLength && by < maxDepth + 0.1; j++) {
                            const bThick = Math.max(0.3, thickness * 0.5 * (1 - j / branchLength));
                            branchRoot.segments.push({ x: bx, y: by, thickness: bThick });
                            bx += Math.cos(bAngle) * 0.008;
                            by += Math.sin(bAngle) * 0.008;
                            bAngle += (Math.random() - 0.5) * 0.3;
                        }

                        if (branchRoot.segments.length > 2) {
                            rootTendrils.push(branchRoot);
                        }
                    }
                }

                rootTendrils.push(root);
            }
        }

        function drawRoots() {
            const gridCols = soilGrid[0]?.length || 0;
            const gridRows = soilGrid.length || 0;
            if (gridCols === 0 || gridRows === 0) return;

            ctx.save();

            for (const root of rootTendrils) {
                if (root.segments.length < 2) continue;

                ctx.beginPath();

                let hasVisibleSegment = false;

                for (let i = 0; i < root.segments.length; i++) {
                    const seg = root.segments[i];
                    const screenX = seg.x * W;
                    const screenY = seg.y * H;

                    // Check if this segment is in excavated soil
                    const gx = Math.floor(seg.x * gridCols);
                    const gy = Math.floor(seg.y * gridRows);

                    // Only draw if in a dug area OR near surface
                    const inTunnel = soilGrid[gy]?.[gx] !== undefined && soilGrid[gy][gx] < 0.5;
                    const nearSurface = seg.y < 0.18;

                    if (inTunnel || nearSurface) {
                        if (!hasVisibleSegment) {
                            ctx.moveTo(screenX, screenY);
                            hasVisibleSegment = true;
                        } else {
                            ctx.lineTo(screenX, screenY);
                        }
                    } else if (hasVisibleSegment) {
                        // End this stroke, potentially start new one later
                        hasVisibleSegment = false;
                    }
                }

                if (hasVisibleSegment) {
                    // Root color
                    if (root.color === 'warm') {
                        ctx.strokeStyle = 'rgba(90, 60, 40, 0.7)';
                    } else {
                        ctx.strokeStyle = 'rgba(70, 55, 45, 0.6)';
                    }
                    ctx.lineWidth = root.segments[0]?.thickness || 2;
                    ctx.lineCap = 'round';
                    ctx.stroke();
                }
            }

            // Draw fine root hairs at tips
            ctx.globalAlpha = 0.4;
            for (const root of rootTendrils) {
                if (root.segments.length < 3) continue;

                const tipSeg = root.segments[root.segments.length - 1];
                const screenX = tipSeg.x * W;
                const screenY = tipSeg.y * H;

                const gx = Math.floor(tipSeg.x * gridCols);
                const gy = Math.floor(tipSeg.y * gridRows);
                const inTunnel = soilGrid[gy]?.[gx] !== undefined && soilGrid[gy][gx] < 0.5;

                if (inTunnel) {
                    // Draw tiny root hairs
                    for (let h = 0; h < 4; h++) {
                        const hairAngle = Math.PI * 0.3 + Math.random() * Math.PI * 0.4;
                        const hairLen = 3 + Math.random() * 6;
                        ctx.beginPath();
                        ctx.moveTo(screenX, screenY);
                        ctx.lineTo(
                            screenX + Math.cos(hairAngle) * hairLen * (h % 2 === 0 ? 1 : -1),
                            screenY + Math.sin(hairAngle) * hairLen
                        );
                        ctx.strokeStyle = 'rgba(80, 50, 35, 0.5)';
                        ctx.lineWidth = 0.5;
                        ctx.stroke();
                    }
                }
            }

            ctx.restore();
        }

        // ============ DIGGING DUST PARTICLE SYSTEM ============
        const dustParticles = [];
        const MAX_DUST_PARTICLES = 100;

        class DustParticle {
            constructor(x, y, depth) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2 - 1; // Slight upward bias
                this.life = 1.0;
                this.decay = 0.02 + Math.random() * 0.02;
                this.size = 1 + Math.random() * 2;
                // Color based on soil depth
                const color = getSoilColor(depth);
                this.r = color[0];
                this.g = color[1];
                this.b = color[2];
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.1; // Gravity
                this.vx *= 0.95; // Air resistance
                this.life -= this.decay;
                return this.life > 0;
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * this.life, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${this.r}, ${this.g}, ${this.b}, ${this.life * 0.7})`;
                ctx.fill();
            }
        }

        function spawnDustParticle(x, y, depth) {
            // Use object pool instead of creating new particles
            dustPool.spawn(x, y, depth);
        }

        function updateAndDrawDust() {
            // Use pooled particles
            dustPool.update();
            dustPool.draw(ctx);
        }

        // ============ ANT DEATH SPIRIT SYSTEM ============
        const deadAntSpirits = [];
        const MAX_SPIRITS = 30;

        class DeadAntSpirit {
            constructor(x, y, role) {
                this.x = x;
                this.y = y;
                this.startY = y;
                this.life = 1.0;
                this.decay = 0.008; // ~2 seconds at 60fps
                this.role = role;
                this.driftX = (Math.random() - 0.5) * 0.3;
                this.wobble = Math.random() * Math.PI * 2;
            }

            update() {
                this.y -= 0.4; // Gentle upward drift
                this.x += this.driftX + Math.sin(this.wobble) * 0.15;
                this.wobble += 0.08;
                this.life -= this.decay;
                return this.life > 0;
            }

            draw(ctx) {
                const alpha = this.life * 0.6;

                // Outer glow - warm golden light
                const glowRadius = 12 * this.life + 4;
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, glowRadius
                );
                gradient.addColorStop(0, `rgba(255, 240, 200, ${alpha * 0.5})`);
                gradient.addColorStop(0.5, `rgba(255, 200, 120, ${alpha * 0.2})`);
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.fillRect(this.x - glowRadius, this.y - glowRadius, glowRadius * 2, glowRadius * 2);

                // Faint ant shape rising
                ctx.save();
                ctx.globalAlpha = alpha * 0.7;
                ctx.translate(this.x, this.y);

                // Spirit body
                ctx.beginPath();
                ctx.ellipse(0, 0, 2.5 * this.life, 1.5 * this.life, 0, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 250, 230, 0.8)';
                ctx.fill();

                // Spirit head
                ctx.beginPath();
                ctx.ellipse(-3 * this.life, 0, 1.5 * this.life, 1 * this.life, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        function spawnDeadAntSpirit(x, y, role) {
            // Use object pool + play death sound + haptic feedback
            spiritPool.spawn(x, y, role);
            playDeathSound();
            hapticFeedback(HAPTIC_PATTERNS.death);
        }

        function updateAndDrawSpirits() {
            // Use pooled particles
            spiritPool.update();
            spiritPool.draw(ctx);
        }

        // ============ IMPROVEMENT #4: PARTICLE OBJECT POOLING ============
        // Reusable particle pool to reduce GC pressure
        class ParticlePool {
            constructor(ParticleClass, maxSize) {
                this.ParticleClass = ParticleClass;
                this.active = [];
                this.inactive = [];
                this.maxSize = maxSize;
            }

            spawn(...args) {
                let particle;
                if (this.inactive.length > 0) {
                    particle = this.inactive.pop();
                    particle.reset(...args);
                } else if (this.active.length < this.maxSize) {
                    particle = new this.ParticleClass(...args);
                } else {
                    return null; // Pool exhausted
                }
                this.active.push(particle);
                return particle;
            }

            update() {
                for (let i = this.active.length - 1; i >= 0; i--) {
                    const particle = this.active[i];
                    if (!particle.update()) {
                        // Recycle to inactive pool
                        this.active.splice(i, 1);
                        this.inactive.push(particle);
                    }
                }
            }

            draw(ctx) {
                for (const particle of this.active) {
                    particle.draw(ctx);
                }
            }

            clear() {
                this.inactive.push(...this.active);
                this.active = [];
            }
        }

        // Pooled dust particles
        class PooledDustParticle extends DustParticle {
            reset(x, y, depth) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2 - 1;
                this.life = 1.0;
                this.decay = 0.02 + Math.random() * 0.02;
                this.size = 1 + Math.random() * 2;
                const color = getSoilColor(depth);
                this.r = color[0];
                this.g = color[1];
                this.b = color[2];
            }
        }

        // Pooled spirit particles
        class PooledDeadAntSpirit extends DeadAntSpirit {
            reset(x, y, role) {
                this.x = x;
                this.y = y;
                this.startY = y;
                this.life = 1.0;
                this.decay = 0.008;
                this.role = role;
                this.driftX = (Math.random() - 0.5) * 0.3;
                this.wobble = Math.random() * Math.PI * 2;
            }
        }

        const dustPool = new ParticlePool(PooledDustParticle, MAX_DUST_PARTICLES);
        const spiritPool = new ParticlePool(PooledDeadAntSpirit, MAX_SPIRITS);

        // ============ IMPROVEMENT #1: BLOOM/GLOW POST-PROCESSING ============
        let bloomEnabled = true;
        let bloomQuality = 'auto'; // 'auto', 'high', 'low', 'off'
        let detectedFPS = 60;
        let frameCount = 0;
        let lastFPSCheck = Date.now();

        function detectPerformance() {
            frameCount++;
            const now = Date.now();
            if (now - lastFPSCheck >= 1000) {
                detectedFPS = frameCount;
                frameCount = 0;
                lastFPSCheck = now;

                // Auto-adjust bloom quality based on FPS
                if (bloomQuality === 'auto') {
                    if (detectedFPS < 30) {
                        bloomEnabled = false; // Disable on low-end devices
                    } else if (detectedFPS < 50) {
                        bloomEnabled = true; // Simple glow only
                    } else {
                        bloomEnabled = true; // Full bloom
                    }
                }
            }
        }

        function applyBloomToContext(targetElements) {
            if (!bloomEnabled) return;

            ctx.save();
            ctx.globalCompositeOperation = 'lighter';

            // Apply glow to each target (queen, pheromone hotspots)
            for (const element of targetElements) {
                if (element.type === 'queen' && queen) {
                    // Queen glow - warm golden aura
                    const glowRadius = 35 + Math.sin(time * 2) * 5;
                    const gradient = ctx.createRadialGradient(
                        queen.x, queen.y, 0,
                        queen.x, queen.y, glowRadius
                    );
                    gradient.addColorStop(0, 'rgba(255, 220, 120, 0.3)');
                    gradient.addColorStop(0.5, 'rgba(255, 180, 80, 0.15)');
                    gradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(queen.x - glowRadius, queen.y - glowRadius, glowRadius * 2, glowRadius * 2);
                } else if (element.type === 'pheromone') {
                    // Pheromone glow - subtle bloom on strong trails
                    const intensity = element.intensity;
                    if (intensity < 0.3) continue; // Only glow bright trails

                    const glowRadius = element.radius * 1.5;
                    const gradient = ctx.createRadialGradient(
                        element.x, element.y, 0,
                        element.x, element.y, glowRadius
                    );
                    gradient.addColorStop(0, `rgba(${element.color}, ${intensity * 0.2})`);
                    gradient.addColorStop(0.7, `rgba(${element.color}, ${intensity * 0.1})`);
                    gradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(element.x - glowRadius, element.y - glowRadius, glowRadius * 2, glowRadius * 2);
                }
            }

            ctx.restore();
        }

        // ============ IMPROVEMENT #3: HAPTIC FEEDBACK SYSTEM ============
        let supportsHaptics = false;
        let hasInteracted = false;
        if ('vibrate' in navigator) {
            supportsHaptics = true;
        }

        // Track user interaction to avoid vibration intervention
        const markInteracted = () => {
            hasInteracted = true;
            window.removeEventListener('click', markInteracted);
            window.removeEventListener('keydown', markInteracted);
            window.removeEventListener('touchstart', markInteracted);
        };
        window.addEventListener('click', markInteracted);
        window.addEventListener('keydown', markInteracted);
        window.addEventListener('touchstart', markInteracted);

        function hapticFeedback(pattern) {
            if (!supportsHaptics || !hasInteracted) return;
            // Pattern: number = duration in ms, array = [vibrate, pause, vibrate, ...]
            try {
                navigator.vibrate(pattern);
            } catch (e) {
                // Silently fail if still blocked
            }
        }

        // Haptic patterns for different events
        const HAPTIC_PATTERNS = {
            birth: [10], // Short tap
            death: [20, 10, 20], // Double pulse
            milestone: [15, 10, 15, 10, 30], // Celebration pattern
            food: [8], // Tiny tap
            expansion: [50, 20, 50, 20, 50], // Big achievement
            danger: [100, 50, 100] // Warning pulse
        };

        // ============ MILESTONE EVENTS SYSTEM ============
        const milestones = {
            firstExcavator: false,
            firstGatherer: false,
            firstNurse: false,
            population50: false,
            population100: false,
            population200: false,
            births25: false,
            births50: false,
            births100: false,
            firstExpansion: false,
            secondExpansion: false,
            elderAnt: false, // Ant survives to 90% of max age
            queenFed25: false,
            queenFed50: false,
            balanced: false, // All roles have at least 5 ants
            agePolyethism: false, // All three age stages working together
            // CYCLE 4: Feature unlocks
            fungusUnlocked: false,
            waterStorageUnlocked: false,
            proteinUnlocked: false
        };
        let milestoneToastTimeout = null;
        let peakPopulation = 0;
        const celebrationParticles = []; // CYCLE 4: Milestone celebration particles

        // ============ CYCLE 5: EMERGENT NARRATIVE EVENTS ============
        const narrativeEvents = {
            starvationTriggered: false,
            lastStarvationCheck: 0,
            collapseTriggered: false,
            collapseDeathCount: 0,
            collapseStartTime: 0,
            breakthroughDepth: 0,
            lastIsolatedAntCheck: new Map(), // ant -> time isolated
            roleRevolutions: new Set() // Tracks which roles have had their revolution
        };

        // ============ CYCLE 8: SECRET ACHIEVEMENT SYSTEM ============
        const ACHIEVEMENTS = {
            // Population Achievements
            'tiny_colony': { name: 'Tiny But Mighty', desc: 'Reach 50 ants', icon: 'üêú', hidden: false },
            'thriving_colony': { name: 'Thriving Colony', desc: 'Reach 150 ants', icon: 'üèòÔ∏è', hidden: false },
            'megacolony': { name: 'Mega Colony', desc: 'Reach 300 ants', icon: 'üèôÔ∏è', hidden: false },
            'ant_empire': { name: 'Ant Empire', desc: 'Reach 500 ants', icon: 'üëë', hidden: false },

            // Secret/Hidden Achievements
            'perfectionist': { name: 'Perfectionist', desc: 'No deaths in first 100 ants', icon: 'üíé', hidden: true },
            'queen_never_hungry': { name: 'Royal Service', desc: 'Queen never hungry for 5 minutes', icon: 'üë∏', hidden: true },
            'golden_blessing': { name: 'Golden Blessing', desc: 'Discover the queen\'s secret', icon: '‚ú®', hidden: true },
            'ancient_artifact': { name: 'Archaeologist', desc: 'Discover an ancient artifact', icon: 'üè∫', hidden: true },
            'deep_delver': { name: 'Deep Delver', desc: 'Excavate to 80% depth', icon: '‚õèÔ∏è', hidden: true },
            'crystal_cave': { name: 'Crystal Cave', desc: 'Discover underground crystal chamber', icon: 'üíé', hidden: true },
            'fossil_finder': { name: 'Fossil Finder', desc: 'Discover prehistoric fossil chamber', icon: 'ü¶¥', hidden: true },
            'mushroom_grotto': { name: 'Mushroom Grotto', desc: 'Discover bioluminescent fungi', icon: 'üçÑ', hidden: true },

            // Strategy Achievements
            'specialist_nation': { name: 'Specialist Nation', desc: '30+ ants of same role', icon: 'üéñÔ∏è', hidden: true },
            'balanced_colony': { name: 'Perfect Harmony', desc: 'All roles have 10+ ants', icon: '‚öñÔ∏è', hidden: true },
            'speed_demon': { name: 'Speed Demon', desc: 'Reach 100 ants in under 3 minutes', icon: '‚ö°', hidden: true },
            'survivor': { name: 'Survivor', desc: 'Colony survives 15 minutes', icon: 'üõ°Ô∏è', hidden: true },

            // Rare Event Achievements
            'aurora_witness': { name: 'Aurora Witness', desc: 'Experience the aurora borealis', icon: 'üåå', hidden: true },
            'eclipse_touched': { name: 'Eclipse Touched', desc: 'Witness a solar eclipse', icon: 'üåë', hidden: true },
            'meteor_strike': { name: 'Meteor Strike', desc: 'Survive a meteor impact', icon: '‚òÑÔ∏è', hidden: true },

            // Meta Achievements
            'legacy_builder': { name: 'Legacy Builder', desc: 'Immortalize 3 colonies', icon: 'üèõÔ∏è', hidden: false },
            'collector': { name: 'Achievement Hunter', desc: 'Unlock 10 achievements', icon: 'üèÜ', hidden: false },
            'completionist': { name: 'Completionist', desc: 'Unlock all achievements', icon: 'üíØ', hidden: true },

            // Ant Relationship Achievements
            'ant_whisperer': { name: 'Ant Whisperer', desc: 'Name 5 ants', icon: 'üí¨', hidden: true },
            'memory_keeper': { name: 'Memory Keeper', desc: 'Witness 50 ant memories', icon: 'üß†', hidden: true },

            // CYCLE 10: Challenge Mode Achievements
            // Disaster Mode
            'disaster_master': { name: 'Disaster Master', desc: 'Survive all 5 disaster types', icon: 'üå™Ô∏è', hidden: false },
            'perfect_survival': { name: 'Perfect Survival', desc: 'Survive disaster with zero ant deaths', icon: 'üõ°Ô∏è', hidden: true },
            'phoenix_colony': { name: 'Phoenix Colony', desc: 'Rebuild to 100 ants after 90% population loss', icon: 'üî•', hidden: true },

            // Speedrun Mode
            'speed_demon': { name: 'Speed Demon II', desc: 'Complete Population Boom in under 2 minutes', icon: '‚ö°', hidden: false },
            'flawless_run': { name: 'Flawless Run', desc: 'Complete speedrun with zero deaths', icon: 'üíé', hidden: true },
            'gauntlet_champion': { name: 'Gauntlet Champion', desc: 'Complete The Gauntlet challenge', icon: 'üëë', hidden: false },

            // Rival Colony Mode
            'rival_defeated': { name: 'Rival Defeated', desc: 'Win against rival colony', icon: '‚öîÔ∏è', hidden: false },
            'underdog_victory': { name: 'Underdog Victory', desc: 'Win while being outnumbered 2:1', icon: 'üèÜ', hidden: true },
            'colony_domination': { name: 'Colony Domination', desc: 'Reach 300 ants in Rival mode', icon: 'üëë', hidden: false }
        };

        let unlockedAchievements = new Set();
        let achievementCheckCounters = {
            noDeathsCount: 0,
            queenFedStreak: 0,
            memoriesWitnessed: 0
        };

        function checkEmergentNarratives() {
            // THE STARVATION - Queen hasn't been fed in 45+ seconds
            if (queen && queen.timeSinceLastFood > 45 && !narrativeEvents.starvationTriggered) {
                narrativeEvents.starvationTriggered = true;
                showMilestone('The Queen Hungers', 'Emergency food gathering initiated', false);
                // Boost all nurse pheromone strength
                for (const ant of ants) {
                    if (ant.role === ANT_ROLES.NURSE) {
                        ant.speed *= 1.3; // Nurses move faster in crisis
                    }
                }
            }
            // Reset when queen is fed
            if (queen && queen.timeSinceLastFood < 10) {
                narrativeEvents.starvationTriggered = false;
            }

            // THE COLLAPSE - 10+ deaths in 30 seconds
            const now = time;
            if (now - narrativeEvents.collapseStartTime > 30) {
                narrativeEvents.collapseDeathCount = 0;
                narrativeEvents.collapseStartTime = now;
            }
            if (narrativeEvents.collapseDeathCount >= 10 && !narrativeEvents.collapseTriggered) {
                narrativeEvents.collapseTriggered = true;
                showMilestone('Catastrophe Strikes', 'Many ants have perished', false);
                setTimeout(() => { narrativeEvents.collapseTriggered = false; }, 60000);
            }

            // THE BREAKTHROUGH - New depth record
            let maxDepth = 0;
            for (const ant of ants) {
                if (ant.y / H > maxDepth) maxDepth = ant.y / H;
            }
            if (maxDepth > narrativeEvents.breakthroughDepth + 0.1) {
                narrativeEvents.breakthroughDepth = maxDepth;
                showMilestone('Uncharted Depths', `Reached ${Math.round(maxDepth * 100)}% depth`, false);
            }

            // THE REUNION - Isolated ant returns
            for (const ant of ants) {
                const nearbyAnts = antSpatialGrid.getNearby(ant.x, ant.y, 100);
                const isIsolated = nearbyAnts.length <= 1; // Only itself

                if (isIsolated) {
                    if (!narrativeEvents.lastIsolatedAntCheck.has(ant)) {
                        narrativeEvents.lastIsolatedAntCheck.set(ant, now);
                    }
                } else {
                    const isolatedTime = narrativeEvents.lastIsolatedAntCheck.get(ant);
                    if (isolatedTime && now - isolatedTime > 15) {
                        showMilestone('A Lost Ant Returns', 'Reunion with the colony', false);
                        // Joy particles around returning ant
                        for (let i = 0; i < 10; i++) {
                            celebrationParticles.push(new CelebrationParticle(ant.x, ant.y));
                        }
                    }
                    narrativeEvents.lastIsolatedAntCheck.delete(ant);
                }
            }

            // THE UPRISING - 20+ ants of same role
            const roleCounts = { worker: 0, excavator: 0, gatherer: 0, nurse: 0 };
            for (const ant of ants) {
                if (roleCounts[ant.role] !== undefined) roleCounts[ant.role]++;
            }
            for (const [role, count] of Object.entries(roleCounts)) {
                if (count >= 20 && !narrativeEvents.roleRevolutions.has(role)) {
                    narrativeEvents.roleRevolutions.add(role);
                    const roleName = role.charAt(0).toUpperCase() + role.slice(1);
                    showMilestone(`${roleName} Revolution`, `${count} ${roleName}s dominate the colony`, false);
                }
            }
        }

        function recordDeathForNarrative() {
            narrativeEvents.collapseDeathCount++;
        }

        // CYCLE 4: Celebration particle for milestone achievements
        class CelebrationParticle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 8;
                this.vy = -Math.random() * 8 - 4;
                this.life = 1.0;
                this.decay = 0.015 + Math.random() * 0.01;
                this.size = 2 + Math.random() * 4;
                this.hue = Math.random() * 360;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.3;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.3; // Gravity
                this.vx *= 0.98;
                this.rotation += this.rotationSpeed;
                this.life -= this.decay;
                return this.life > 0 && this.y < H + 50;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.globalAlpha = this.life;
                ctx.fillStyle = `hsl(${this.hue}, 80%, 60%)`;
                ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
                ctx.restore();
            }
        }

        // ============ CYCLE 7: ENHANCED MILESTONE TOAST SYSTEM ============
        function showMilestone(title, description, spawnParticles = true) {
            const now = Date.now();
            if (now - lastMilestoneTime < 500) return; // Prevent spam
            lastMilestoneTime = now;

            const toast = document.getElementById('milestone-toast');
            const titleEl = document.getElementById('milestone-title');
            const subtitleEl = document.getElementById('milestone-subtitle');
            const iconEl = document.getElementById('milestone-icon');

            // Categorize milestone and assign icon
            let icon = 'üéâ';
            if (title.includes('Birth') || title.includes('population')) icon = 'üêú';
            if (title.includes('Death') || title.includes('Catastrophe') || title.includes('Collapse')) icon = 'üíÄ';
            if (title.includes('Specialist') || title.includes('Revolution')) icon = '‚ö°';
            if (title.includes('Depth') || title.includes('Breakthrough')) icon = '‚õèÔ∏è';
            if (title.includes('Queen') || title.includes('Hungers') || title.includes('Fed')) icon = 'üëë';
            if (title.includes('Reunion') || title.includes('Returns')) icon = 'üè°';
            if (title.includes('Expansion')) icon = 'üåç';
            if (title.includes('Unlocked') || title.includes('Fungus') || title.includes('Water')) icon = 'üîì';

            iconEl.textContent = icon;
            titleEl.textContent = title;
            subtitleEl.textContent = description;

            // Trigger animation
            toast.classList.remove('show');
            setTimeout(() => toast.classList.add('show'), 10);

            // Play milestone sound
            if (now - lastMilestoneTime > MILESTONE_SOUND_COOLDOWN) {
                playMilestoneSound();
            }

            // Haptic feedback for milestone achievements
            hapticFeedback(HAPTIC_PATTERNS.milestone);

            // CYCLE 4: Spawn celebration particles at queen location
            if (spawnParticles && queen) {
                for (let i = 0; i < 30; i++) {
                    celebrationParticles.push(new CelebrationParticle(queen.x, queen.y));
                }
            }

            // Screen reader announcement
            announceToScreenReader(`Milestone achieved: ${title}. ${description}`);

            if (milestoneToastTimeout) clearTimeout(milestoneToastTimeout);
            milestoneToastTimeout = setTimeout(() => {
                toast.classList.remove('show');
            }, 5000);
        }

        function playMilestoneSound() {
            if (!audioEnabled || !audioCtx) return;

            // Cheerful three-note chime
            const notes = [440, 554.37, 659.25]; // A4, C#5, E5 (A major chord)
            notes.forEach((freq, i) => {
                const osc = audioCtx.createOscillator();
                osc.type = 'sine';
                osc.frequency.value = freq;

                const gain = audioCtx.createGain();
                gain.gain.value = 0.08;

                osc.connect(gain);
                gain.connect(audioNodes.masterGain);

                const startTime = audioCtx.currentTime + i * 0.12;
                const duration = 0.3;

                gain.gain.setValueAtTime(0.08, startTime);
                gain.gain.exponentialRampToValueAtTime(0.001, startTime + duration);

                osc.start(startTime);
                osc.stop(startTime + duration);
            });
        }

        function checkMilestones() {
            // Count roles
            let workers = 0, excavators = 0, gatherers = 0, nurses = 0;
            let hasElder = false;
            ants.forEach(ant => {
                switch(ant.role) {
                    case ANT_ROLES.WORKER: workers++; break;
                    case ANT_ROLES.EXCAVATOR: excavators++; break;
                    case ANT_ROLES.GATHERER: gatherers++; break;
                    case ANT_ROLES.NURSE: nurses++; break;
                }
                if (ant.getAgeRatio() >= 0.9) hasElder = true;
            });

            // Track peak population
            if (ants.length > peakPopulation) peakPopulation = ants.length;

            // First specialists
            if (!milestones.firstExcavator && excavators > 0) {
                milestones.firstExcavator = true;
                showMilestone('First Excavator!', 'A worker has specialized in digging');
            }
            if (!milestones.firstGatherer && gatherers > 0) {
                milestones.firstGatherer = true;
                showMilestone('First Gatherer!', 'A worker has specialized in food collection');
            }
            if (!milestones.firstNurse && nurses > 0) {
                milestones.firstNurse = true;
                showMilestone('First Nurse!', 'A worker has devoted itself to the queen');
            }

            // Population milestones
            if (!milestones.population50 && ants.length >= 50) {
                milestones.population50 = true;
                // CYCLE 4: Unlock Fungus Gardens
                CHAMBER_TYPES.FUNGUS_GARDEN.unlocked = true;
                milestones.fungusUnlocked = true;
                showMilestone('Fungus Gardens Unlocked!', '50 ants strong! You can now build fungus gardens (F key)');
            }
            if (!milestones.population100 && ants.length >= 100) {
                milestones.population100 = true;
                // CYCLE 4: Unlock Water Storage
                CHAMBER_TYPES.WATER_STORAGE.unlocked = true;
                milestones.waterStorageUnlocked = true;
                showMilestone('Water Storage Unlocked!', '100 ants! Water chambers protect from drought (W key)');
            }
            if (!milestones.population200 && ants.length >= 200) {
                milestones.population200 = true;
                showMilestone('Supercolony!', '200 ants working as one');
            }

            // CYCLE 4: Protein food unlocks after 150 ants
            if (!milestones.proteinUnlocked && ants.length >= 150) {
                milestones.proteinUnlocked = true;
                showMilestone('Protein Detection!', 'Ants can now find protein-rich food underground');
            }

            // Birth milestones
            if (!milestones.births25 && totalBirths >= 25) {
                milestones.births25 = true;
                showMilestone('25 Births', 'The queen has raised a generation');
            }
            if (!milestones.births50 && totalBirths >= 50) {
                milestones.births50 = true;
                showMilestone('50 Births', 'A prolific queen!');
            }
            if (!milestones.births100 && totalBirths >= 100) {
                milestones.births100 = true;
                showMilestone('100 Births', 'Dynasty established');
            }

            // Expansion milestones
            if (!milestones.firstExpansion && totalExpansions >= 1) {
                milestones.firstExpansion = true;
                showMilestone('World Expanded!', 'New territory unlocked');
            }
            if (!milestones.secondExpansion && totalExpansions >= 2) {
                milestones.secondExpansion = true;
                showMilestone('Deep Colony', 'The empire grows deeper');
            }

            // Elder ant
            if (!milestones.elderAnt && hasElder) {
                milestones.elderAnt = true;
                showMilestone('Elder Ant', 'One ant has lived to old age');
            }

            // Queen milestones
            if (!milestones.queenFed25 && queen && queen.foodReceived >= 25) {
                milestones.queenFed25 = true;
                showMilestone('Well-Fed Queen', '25 food deliveries');
            }
            if (!milestones.queenFed50 && queen && queen.foodReceived >= 50) {
                milestones.queenFed50 = true;
                showMilestone('Pampered Royalty', '50 food deliveries');
            }

            // Balanced colony
            if (!milestones.balanced && excavators >= 5 && gatherers >= 5 && nurses >= 5) {
                milestones.balanced = true;
                showMilestone('Balanced Society', 'All specialist roles represented');
            }

            // Age Polyethism - all three age stages working together
            if (!milestones.agePolyethism && ants.length >= 30) {
                let hasYoung = false, hasMature = false, hasElder = false;
                ants.forEach(ant => {
                    const stage = ant.getAgeStage();
                    if (stage === 'young') hasYoung = true;
                    if (stage === 'mature') hasMature = true;
                    if (stage === 'elder') hasElder = true;
                });
                if (hasYoung && hasMature && hasElder) {
                    milestones.agePolyethism = true;
                    showMilestone('Age Polyethism', 'Young, mature, and elder ants unite');
                }
            }
        }

        // ============ PROCEDURAL AMBIENT AUDIO SYSTEM ============
        let audioCtx = null;
        let audioEnabled = false;
        let audioNodes = {};

        // ============ PHEROMONE VISUALIZATION ============
        let showPheromones = false; // Toggle for pheromone trail overlay

        function initAudio() {
            if (audioCtx) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();

            // Master gain
            const masterGain = audioCtx.createGain();
            masterGain.gain.value = 0.15;
            masterGain.connect(audioCtx.destination);

            // Deep earth drone (fundamental)
            const droneOsc = audioCtx.createOscillator();
            droneOsc.type = 'sine';
            droneOsc.frequency.value = 55; // Low A

            const droneGain = audioCtx.createGain();
            droneGain.gain.value = 0.3;
            droneOsc.connect(droneGain);
            droneGain.connect(masterGain);
            droneOsc.start();

            // Harmonic layer 1 (fifth)
            const harmonic1 = audioCtx.createOscillator();
            harmonic1.type = 'sine';
            harmonic1.frequency.value = 82.5; // E

            const harmonic1Gain = audioCtx.createGain();
            harmonic1Gain.gain.value = 0.15;
            harmonic1.connect(harmonic1Gain);
            harmonic1Gain.connect(masterGain);
            harmonic1.start();

            // Harmonic layer 2 (octave)
            const harmonic2 = audioCtx.createOscillator();
            harmonic2.type = 'triangle';
            harmonic2.frequency.value = 110; // High A

            const harmonic2Gain = audioCtx.createGain();
            harmonic2Gain.gain.value = 0.08;
            harmonic2.connect(harmonic2Gain);
            harmonic2Gain.connect(masterGain);
            harmonic2.start();

            // Activity-modulated filtered noise (digging sounds)
            const noiseBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 2, audioCtx.sampleRate);
            const noiseData = noiseBuffer.getChannelData(0);
            for (let i = 0; i < noiseData.length; i++) {
                noiseData[i] = Math.random() * 2 - 1;
            }

            const noiseSource = audioCtx.createBufferSource();
            noiseSource.buffer = noiseBuffer;
            noiseSource.loop = true;

            const noiseFilter = audioCtx.createBiquadFilter();
            noiseFilter.type = 'bandpass';
            noiseFilter.frequency.value = 400;
            noiseFilter.Q.value = 2;

            const noiseGain = audioCtx.createGain();
            noiseGain.gain.value = 0;

            noiseSource.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(masterGain);
            noiseSource.start();

            // Movement swoosh (filtered noise)
            const swooshFilter = audioCtx.createBiquadFilter();
            swooshFilter.type = 'lowpass';
            swooshFilter.frequency.value = 200;
            swooshFilter.Q.value = 1;

            const swooshGain = audioCtx.createGain();
            swooshGain.gain.value = 0;

            const swooshSource = audioCtx.createBufferSource();
            swooshSource.buffer = noiseBuffer;
            swooshSource.loop = true;
            swooshSource.connect(swooshFilter);
            swooshFilter.connect(swooshGain);
            swooshGain.connect(masterGain);
            swooshSource.start();

            // Store references
            audioNodes = {
                masterGain,
                droneOsc, droneGain,
                harmonic1, harmonic1Gain,
                harmonic2, harmonic2Gain,
                noiseGain, noiseFilter,
                swooshGain, swooshFilter
            };
        }

        function updateAudio() {
            if (!audioEnabled || !audioCtx || !audioNodes.masterGain) return;

            // Count activity metrics
            let diggingCount = 0;
            let movementSpeed = 0;
            let gatheringCount = 0;

            ants.forEach(ant => {
                if (ant.digging) diggingCount++;
                movementSpeed += ant.speed;
                if (ant.hasFood) gatheringCount++;
            });

            const antCount = ants.length || 1;
            const diggingRatio = diggingCount / antCount;
            const avgSpeed = movementSpeed / antCount;
            const gatheringRatio = gatheringCount / antCount;

            // Modulate digging noise
            const targetNoiseGain = diggingRatio * 0.15;
            audioNodes.noiseGain.gain.linearRampToValueAtTime(
                targetNoiseGain, audioCtx.currentTime + 0.1
            );
            audioNodes.noiseFilter.frequency.linearRampToValueAtTime(
                300 + diggingRatio * 600, audioCtx.currentTime + 0.1
            );

            // Modulate movement swoosh
            const targetSwooshGain = avgSpeed * 0.02;
            audioNodes.swooshGain.gain.linearRampToValueAtTime(
                targetSwooshGain, audioCtx.currentTime + 0.1
            );

            // Modulate drone pitch slightly based on colony depth
            const depthFactor = 1 + (worldScale - 1) * 0.02;
            audioNodes.droneOsc.frequency.linearRampToValueAtTime(
                55 * depthFactor, audioCtx.currentTime + 0.5
            );

            // Food gathering adds brightness
            audioNodes.harmonic2Gain.gain.linearRampToValueAtTime(
                0.08 + gatheringRatio * 0.1, audioCtx.currentTime + 0.2
            );
        }

        function toggleAudio() {
            if (!audioCtx) {
                initAudio();
            }

            audioEnabled = !audioEnabled;

            const soundBtn = document.getElementById('sound-btn');
            if (audioEnabled) {
                audioCtx.resume();
                soundBtn.textContent = 'üîä Sound';
                soundBtn.classList.add('active');
            } else {
                audioNodes.masterGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
                setTimeout(() => {
                    if (!audioEnabled) audioCtx.suspend();
                }, 400);
                soundBtn.textContent = 'üîá Sound';
                soundBtn.classList.remove('active');
            }

            // Restore master gain when re-enabling
            if (audioEnabled) {
                audioNodes.masterGain.gain.linearRampToValueAtTime(0.15, audioCtx.currentTime + 0.3);
            }
        }

        // ============ IMPROVEMENT #2 & #5: WEATHER AUDIO + BIRTH/DEATH SOUNDS ============
        let weatherAudioNodes = null;
        let lastBirthSoundTime = 0;
        let lastDeathSoundTime = 0;
        const BIRTH_SOUND_COOLDOWN = 3000; // 3 seconds between birth sounds
        const DEATH_SOUND_COOLDOWN = 5000; // 5 seconds between death sounds

        function initWeatherAudio() {
            if (!audioCtx || weatherAudioNodes) return;

            // Rain layer - filtered noise
            const rainNoise = audioCtx.createBuffer(1, audioCtx.sampleRate * 2, audioCtx.sampleRate);
            const rainData = rainNoise.getChannelData(0);
            for (let i = 0; i < rainData.length; i++) {
                rainData[i] = Math.random() * 2 - 1;
            }

            const rainSource = audioCtx.createBufferSource();
            rainSource.buffer = rainNoise;
            rainSource.loop = true;

            const rainFilter = audioCtx.createBiquadFilter();
            rainFilter.type = 'bandpass';
            rainFilter.frequency.value = 1200;
            rainFilter.Q.value = 0.5;

            const rainGain = audioCtx.createGain();
            rainGain.gain.value = 0;

            rainSource.connect(rainFilter);
            rainFilter.connect(rainGain);
            rainGain.connect(audioNodes.masterGain);
            rainSource.start();

            // Wind layer - low frequency sweep
            const windOsc = audioCtx.createOscillator();
            windOsc.type = 'sawtooth';
            windOsc.frequency.value = 30;

            const windFilter = audioCtx.createBiquadFilter();
            windFilter.type = 'lowpass';
            windFilter.frequency.value = 150;
            windFilter.Q.value = 2;

            const windGain = audioCtx.createGain();
            windGain.gain.value = 0;

            windOsc.connect(windFilter);
            windFilter.connect(windGain);
            windGain.connect(audioNodes.masterGain);
            windOsc.start();

            // Thunder rumble (very low sine with envelope)
            const thunderOsc = audioCtx.createOscillator();
            thunderOsc.type = 'sine';
            thunderOsc.frequency.value = 40;

            const thunderGain = audioCtx.createGain();
            thunderGain.gain.value = 0;

            thunderOsc.connect(thunderGain);
            thunderGain.connect(audioNodes.masterGain);
            thunderOsc.start();

            weatherAudioNodes = {
                rainGain, rainFilter,
                windGain, windFilter, windOsc,
                thunderGain, thunderOsc
            };
        }

        function updateWeatherAudio() {
            if (!audioEnabled || !audioCtx || !weatherAudioNodes) {
                if (audioEnabled && audioCtx && !weatherAudioNodes) {
                    initWeatherAudio();
                }
                return;
            }

            const now = audioCtx.currentTime;

            // Adjust weather sounds based on weather state
            switch(weather.state) {
                case 'RAIN':
                    weatherAudioNodes.rainGain.gain.linearRampToValueAtTime(0.03, now + 0.5);
                    weatherAudioNodes.windGain.gain.linearRampToValueAtTime(0.01, now + 0.5);
                    weatherAudioNodes.thunderGain.gain.linearRampToValueAtTime(0, now + 0.5);
                    break;

                case 'STORM':
                    weatherAudioNodes.rainGain.gain.linearRampToValueAtTime(0.06, now + 0.3);
                    weatherAudioNodes.windGain.gain.linearRampToValueAtTime(0.025, now + 0.3);
                    // Thunder rumble during lightning
                    if (weather.lightningFlash > 0.5) {
                        weatherAudioNodes.thunderGain.gain.setValueAtTime(0.08, now);
                        weatherAudioNodes.thunderGain.gain.exponentialRampToValueAtTime(0.001, now + 1.5);
                    }
                    break;

                case 'COLD':
                    // Gentle wind for cold weather
                    weatherAudioNodes.windGain.gain.linearRampToValueAtTime(0.015, now + 0.5);
                    weatherAudioNodes.windFilter.frequency.linearRampToValueAtTime(120, now + 0.5);
                    weatherAudioNodes.rainGain.gain.linearRampToValueAtTime(0, now + 0.5);
                    weatherAudioNodes.thunderGain.gain.linearRampToValueAtTime(0, now + 0.5);
                    break;

                case 'DROUGHT':
                    // Silence for drought
                    weatherAudioNodes.rainGain.gain.linearRampToValueAtTime(0, now + 0.5);
                    weatherAudioNodes.windGain.gain.linearRampToValueAtTime(0.008, now + 0.5);
                    weatherAudioNodes.windFilter.frequency.linearRampToValueAtTime(200, now + 0.5);
                    weatherAudioNodes.thunderGain.gain.linearRampToValueAtTime(0, now + 0.5);
                    break;

                default: // CLEAR
                    weatherAudioNodes.rainGain.gain.linearRampToValueAtTime(0, now + 1.0);
                    weatherAudioNodes.windGain.gain.linearRampToValueAtTime(0, now + 1.0);
                    weatherAudioNodes.thunderGain.gain.linearRampToValueAtTime(0, now + 1.0);
            }
        }

        function playBirthSound() {
            if (!audioEnabled || !audioCtx) return;

            const now = Date.now();
            if (now - lastBirthSoundTime < BIRTH_SOUND_COOLDOWN) return;
            lastBirthSoundTime = now;

            // Cheerful upward chirp
            const osc = audioCtx.createOscillator();
            osc.type = 'sine';

            const gain = audioCtx.createGain();
            gain.gain.value = 0.1;

            osc.connect(gain);
            gain.connect(audioNodes.masterGain);

            const startTime = audioCtx.currentTime;
            const duration = 0.15;

            // Pitch variation for variety
            const basePitch = 800 + Math.random() * 200;
            osc.frequency.setValueAtTime(basePitch, startTime);
            osc.frequency.exponentialRampToValueAtTime(basePitch * 1.5, startTime + duration);

            gain.gain.setValueAtTime(0.1, startTime);
            gain.gain.exponentialRampToValueAtTime(0.001, startTime + duration);

            osc.start(startTime);
            osc.stop(startTime + duration);
        }

        function playDeathSound() {
            if (!audioEnabled || !audioCtx) return;

            const now = Date.now();
            if (now - lastDeathSoundTime < DEATH_SOUND_COOLDOWN) return;
            lastDeathSoundTime = now;

            // Gentle downward sigh
            const osc = audioCtx.createOscillator();
            osc.type = 'sine';

            const gain = audioCtx.createGain();
            gain.gain.value = 0.08;

            osc.connect(gain);
            gain.connect(audioNodes.masterGain);

            const startTime = audioCtx.currentTime;
            const duration = 0.4;

            // Descending pitch with variation
            const basePitch = 400 + Math.random() * 100;
            osc.frequency.setValueAtTime(basePitch, startTime);
            osc.frequency.exponentialRampToValueAtTime(basePitch * 0.6, startTime + duration);

            gain.gain.setValueAtTime(0.08, startTime);
            gain.gain.exponentialRampToValueAtTime(0.001, startTime + duration);

            osc.start(startTime);
            osc.stop(startTime + duration);
        }

        // ============ GENETIC MEMORY SYSTEM ============
        // Colony learns across generations - successful behaviors are inherited
        const colonyMemory = {
            // Track which roles have been most successful
            roleSuccess: {
                excavator: { totalLifespan: 0, count: 0 },
                gatherer: { totalLifespan: 0, count: 0 },
                nurse: { totalLifespan: 0, count: 0 }
            },
            // Danger zones where many ants died young
            dangerZones: new Map(),
            // Preferred depth for foraging (learned over time)
            bestForagingDepth: 0.5,
            // Generation counter
            generation: 0,
            // Total successful food deliveries (used for learning)
            successfulDeliveries: 0
        };

        function getMostSuccessfulRole() {
            const roles = colonyMemory.roleSuccess;
            let bestRole = null;
            let bestAvgLife = 0;

            for (const [role, data] of Object.entries(roles)) {
                if (data.count > 5) { // Need at least 5 samples
                    const avgLife = data.totalLifespan / data.count;
                    if (avgLife > bestAvgLife) {
                        bestAvgLife = avgLife;
                        bestRole = role;
                    }
                }
            }
            return bestRole;
        }

        function recordAntDeath(ant) {
            // Record role success (longer-lived ants = more successful)
            if (ant.role !== ANT_ROLES.WORKER) {
                const roleKey = ant.role.toLowerCase();
                if (colonyMemory.roleSuccess[roleKey]) {
                    colonyMemory.roleSuccess[roleKey].totalLifespan += ant.age;
                    colonyMemory.roleSuccess[roleKey].count++;
                }
            }

            // If ant died young (<50% lifespan), mark danger zone AND deposit alarm pheromones
            if (ant.getAgeRatio() < 0.5) {
                const g = ant.screenToGrid(ant.x, ant.y);
                const key = `${g.x},${g.y}`;
                colonyMemory.dangerZones.set(key, (colonyMemory.dangerZones.get(key) || 0) + 1);

                // Deposit alarm pheromones - stronger for younger deaths
                const alarmStrength = 0.8 * (1 - ant.getAgeRatio() * 2);
                if (alarmPheromoneGrid[g.y]) {
                    alarmPheromoneGrid[g.y][g.x] = Math.min(1,
                        (alarmPheromoneGrid[g.y][g.x] || 0) + alarmStrength);

                    // Spread alarm to neighboring cells
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const ny = g.y + dy, nx = g.x + dx;
                            if (alarmPheromoneGrid[ny]) {
                                alarmPheromoneGrid[ny][nx] = Math.min(1,
                                    (alarmPheromoneGrid[ny][nx] || 0) + alarmStrength * 0.3);
                            }
                        }
                    }
                }

                // Clean up old danger zones if too many
                if (colonyMemory.dangerZones.size > 100) {
                    const entries = [...colonyMemory.dangerZones.entries()];
                    entries.sort((a, b) => a[1] - b[1]);
                    for (let i = 0; i < 20; i++) {
                        colonyMemory.dangerZones.delete(entries[i][0]);
                    }
                }
            }

            // Update best foraging depth based on successful ant positions
            if (ant.gatherExperience > 20) {
                const normalizedY = ant.y / H;
                colonyMemory.bestForagingDepth = colonyMemory.bestForagingDepth * 0.95 + normalizedY * 0.05;
            }
        }

        function applyGeneticMemory(ant) {
            // Apply inherited biases to new ant
            const bestRole = getMostSuccessfulRole();

            // Give slight XP boost toward successful role (10-20 points)
            if (bestRole && Math.random() < 0.7) { // 70% chance to inherit
                const inheritedXP = 10 + Math.random() * 15;
                switch(bestRole) {
                    case 'excavator': ant.digExperience = inheritedXP; break;
                    case 'gatherer': ant.gatherExperience = inheritedXP; break;
                    case 'nurse': ant.nurseExperience = inheritedXP; break;
                }
            }

            // Store preferred foraging depth for ant to use
            ant.inheritedForagingDepth = colonyMemory.bestForagingDepth;

            colonyMemory.generation++;
        }

        // ============ ANT MORTALITY SYSTEM ============
        const BASE_LIFESPAN = 9000;     // Base lifespan in update cycles (~2.5 min at 60fps) - IMPROVED for colony survival
        const LIFESPAN_VARIANCE = 3000; // Random variance (120-200 seconds lifespan) - IMPROVED
        let totalDeaths = 0;

        class Ant {
            constructor() {
                this.x = W / 2 + (Math.random() - 0.5) * 20;
                this.y = H * 0.2;
                this.angle = Math.random() * Math.PI * 2;
                this.speed = 2 + Math.random() * 1; // Faster ants (2-3 speed)
                this.hasFood = false;
                this.digging = false;
                this.wanderPhase = Math.random() * Math.PI * 2;

                // Role specialization
                this.role = ANT_ROLES.WORKER;
                this.digExperience = 0;
                this.gatherExperience = 0;
                this.nurseExperience = 0;

                // Genetic memory - inherited from colony
                this.inheritedForagingDepth = 0.5;
                this.inheritedDigEfficiency = 1.0; // CYCLE 3: Persistent genetic traits
                this.inheritedSpeedBonus = 0; // CYCLE 3: Can be positive or negative

                // Task recruitment system - ant-to-ant communication
                this.recruitmentBias = null; // {angle: number, strength: number}
                this.recruitmentDecay = 0;   // Frames until bias fades

                // CYCLE 3: Flocking coordination
                this.flockingVelocity = { x: 0, y: 0 };

                // CYCLE 3: Current thought/intent for visualization
                this.currentIntent = 'explore'; // explore, dig, gather, nurse, flee

                // Mortality system
                this.age = 0;
                this.maxAge = BASE_LIFESPAN + Math.random() * LIFESPAN_VARIANCE;
                this.isAlive = true;
            }

            // Age the ant and check for death
            updateAge() {
                this.age++;

                // Nurses near queen live longer (care extends life)
                if (this.role === ANT_ROLES.NURSE && queen) {
                    const distToQueen = Math.hypot(queen.x - this.x, queen.y - this.y);
                    if (distToQueen < 40) {
                        this.maxAge += 0.1; // Slow aging when near queen
                    }
                }

                // Weather affects elder ant survival
                if (this.getAgeStage() === 'elder') {
                    const weatherDeathRisk = weather.getDeathRiskMultiplier();
                    if (weatherDeathRisk > 1 && Math.random() < 0.0005 * weatherDeathRisk) {
                        this.isAlive = false;
                        totalDeaths++;
                        recordDeathForNarrative(); // CYCLE 5: Track for narrative events
                        return;
                    }
                }

                // Check for natural death
                if (this.age >= this.maxAge) {
                    this.isAlive = false;
                    totalDeaths++;
                    recordDeathForNarrative(); // CYCLE 5: Track for narrative events
                }

                // Older ants slow down slightly
                if (this.age > this.maxAge * 0.8) {
                    this.speed *= 0.995; // Gradual slowdown
                }
            }

            getAgeRatio() {
                return this.age / this.maxAge;
            }

            // Age Polyethism - task division based on life stage
            getAgeStage() {
                const ratio = this.getAgeRatio();
                if (ratio < 0.3) return 'young';
                if (ratio < 0.7) return 'mature';
                return 'elder';
            }

            // Check for role specialization based on experience
            updateRole() {
                if (this.role !== ANT_ROLES.WORKER) return; // Already specialized

                const maxExp = Math.max(this.digExperience, this.gatherExperience, this.nurseExperience);
                if (maxExp >= ROLE_THRESHOLD) {
                    if (this.digExperience === maxExp) {
                        this.role = ANT_ROLES.EXCAVATOR;
                        this.speed *= 0.8; // Slower but stronger digger
                    } else if (this.gatherExperience === maxExp) {
                        this.role = ANT_ROLES.GATHERER;
                        this.speed *= 1.2; // Faster for food runs
                    } else if (this.nurseExperience === maxExp) {
                        this.role = ANT_ROLES.NURSE;
                    }
                }
            }
            
            // Helper to convert screen coords to grid coords
            screenToGrid(sx, sy) {
                const cols = soilGrid[0]?.length || 1;
                const rows = soilGrid.length || 1;
                return {
                    x: Math.floor(sx / W * cols),
                    y: Math.floor(sy / H * rows)
                };
            }

            update() {
                this.wanderPhase += 0.1;

                const cols = soilGrid[0]?.length || 1;
                const rows = soilGrid.length || 1;

                // Weather effects on movement speed
                const weatherSpeedMod = weather.getSpeedModifier();

                // Check if ant is in flooded area - push toward surface
                if (weather.isFlooded(this.y)) {
                    // Ant is struggling in water, push upward
                    this.y -= 2;
                    this.angle = -Math.PI / 2 + (Math.random() - 0.5) * 0.5; // Point upward
                    // Small chance of drowning
                    if (Math.random() < 0.001) {
                        this.isAlive = false;
                        totalDeaths++;
                        recordDeathForNarrative(); // CYCLE 5: Track for narrative events
                    }
                    return; // Skip normal behavior when flooded
                }

                // CYCLE 3: FLOCKING COORDINATION - Subtle close-range alignment
                // Only applies within 20px to preserve individual chaos at larger scales
                const nearbyAnts = antSpatialGrid.getNearby(this.x, this.y, 20);
                if (nearbyAnts.length > 1) {
                    let avgAngle = 0;
                    let avgSpeed = 0;
                    let count = 0;

                    for (const other of nearbyAnts) {
                        if (other !== this && other.isAlive) {
                            avgAngle += other.angle;
                            avgSpeed += other.speed;
                            count++;
                        }
                    }

                    if (count > 0) {
                        avgAngle /= count;
                        avgSpeed /= count;

                        // Gentle alignment - only 5% influence to maintain individuality
                        this.angle = this.angle * 0.95 + avgAngle * 0.05;
                        // Speed matching for natural clustering
                        this.speed = this.speed * 0.98 + avgSpeed * 0.02;
                    }
                }

                // Cold weather: ants cluster near queen for warmth
                if (weather.state === 'COLD' && queen && !this.hasFood) {
                    const distToQueen = Math.hypot(queen.x - this.x, queen.y - this.y);
                    if (distToQueen > 60) {
                        const toQueen = Math.atan2(queen.y - this.y, queen.x - this.x);
                        this.angle = this.angle * 0.9 + toQueen * 0.1;
                    }
                }

                // Age Polyethism - behavioral biases based on life stage
                const ageStage = this.getAgeStage();

                // Young ants (0-30%): Stay near queen, gain nurse experience faster
                if (ageStage === 'young' && this.role === ANT_ROLES.WORKER && !this.hasFood && queen) {
                    const distToQueen = Math.hypot(queen.x - this.x, queen.y - this.y);
                    if (distToQueen > 50) {
                        // Young ants naturally gravitate toward queen
                        const toQueen = Math.atan2(queen.y - this.y, queen.x - this.x);
                        this.angle = this.angle * 0.95 + toQueen * 0.05;
                    }
                    this.nurseExperience += 0.08; // Faster nurse XP for young
                }

                // Elder ants (70-100%): Venture farther, gain gatherer experience faster
                if (ageStage === 'elder') {
                    this.gatherExperience += 0.05; // Faster gatherer XP for elders
                    // Elders move slightly faster - urgency of remaining time
                    if (this.speed < 1.5) this.speed *= 1.002;
                }

                // Nurse behavior: stay near queen
                if (this.role === ANT_ROLES.NURSE && queen && !this.hasFood) {
                    this.currentIntent = 'nurse'; // CYCLE 3: Intent tracking
                    const distToQueen = Math.hypot(queen.x - this.x, queen.y - this.y);
                    if (distToQueen > 40) {
                        // Return to queen
                        const toQueen = Math.atan2(queen.y - this.y, queen.x - this.x);
                        this.angle = this.angle * 0.8 + toQueen * 0.2;
                    } else {
                        // Circle around queen
                        this.angle += 0.03;
                        this.nurseExperience += 0.1;
                    }
                }

                if (this.hasFood) {
                    this.currentIntent = 'gather'; // CYCLE 3: Returning with food
                    // Head toward queen if she exists, otherwise nest center
                    const targetX = queen ? queen.x : W / 2;
                    const targetY = queen ? queen.y : H * 0.2;
                    const toNest = Math.atan2(targetY - this.y, targetX - this.x);
                    this.angle = this.angle * 0.9 + toNest * 0.1;

                    const dist = Math.hypot(targetX - this.x, targetY - this.y);
                    if (dist < 20) {
                        this.hasFood = false;
                        // Feed the queen!
                        if (queen) {
                            queen.feedQueen();
                        }
                        // Gain gatherer experience for successful delivery
                        this.gatherExperience += 5;
                    }

                    const g = this.screenToGrid(this.x, this.y);
                    if (g.x >= 0 && g.x < cols && g.y >= 0 && g.y < rows && pheromoneGrid[g.y]) {
                        pheromoneGrid[g.y][g.x] = Math.min(1, (pheromoneGrid[g.y][g.x] || 0) + 0.1);
                    }

                    // Task Recruitment - recruit nearby idle ants using spatial grid (O(1) instead of O(N))
                    if (Math.random() < 0.02) { // Check occasionally, not every frame
                        const nearbyAnts = antSpatialGrid.getNearby(this.x, this.y, 25);
                        for (const other of nearbyAnts) {
                            if (other === this || other.hasFood || other.digging) continue;
                            if (Math.random() < 0.4) {
                                // Calculate opposite direction (toward where food came from)
                                const recruitAngle = this.angle + Math.PI;
                                other.recruitmentBias = { angle: recruitAngle, strength: 0.25 };
                                other.recruitmentDecay = 45; // ~0.75 seconds
                                // Visual feedback stored for drawing
                                this.lastRecruitedAnt = other;
                                this.recruitFlashTime = 8;
                                break; // Only recruit one ant per check
                            }
                        }
                    }
                } else {
                    // Apply recruitment bias if active
                    if (this.recruitmentDecay > 0 && this.recruitmentBias) {
                        this.angle = this.angle * (1 - this.recruitmentBias.strength) +
                                     this.recruitmentBias.angle * this.recruitmentBias.strength;
                        this.recruitmentDecay--;
                        this.recruitmentBias.strength *= 0.97; // Fade influence
                    }

                    // FOOD SCENT DETECTION - ants can smell food from far away!
                    // CYCLE 15: Use spatial grid for O(1) food detection instead of O(n)
                    let closestFood = null;
                    let closestFoodDist = 300; // Detection range
                    const nearbyFood = foodSpatialGrid.getNearby(this.x, this.y, 300);
                    for (const food of nearbyFood) {
                        if (food.amount <= 0) continue;
                        const dist = Math.hypot(food.x - this.x, food.y - this.y);
                        if (dist < closestFoodDist) {
                            closestFoodDist = dist;
                            closestFood = food;
                        }
                    }

                    // If food detected, move toward it
                    if (closestFood) {
                        const toFood = Math.atan2(closestFood.y - this.y, closestFood.x - this.x);
                        // Stronger attraction when closer
                        const strength = 0.1 + (1 - closestFoodDist / 300) * 0.3;
                        this.angle = this.angle * (1 - strength) + toFood * strength;
                    } else {
                        // No food detected - explore toward surface (upward bias)
                        // This helps ants find food on the surface
                        if (Math.random() < 0.05) {
                            this.angle += (Math.random() < 0.6 ? -0.3 : 0.3); // Bias upward (-Y)
                        }
                    }

                    let bestPheromone = 0;
                    let bestAngle = this.angle;

                    // Role-based pheromone sensitivity weights
                    // Gatherers prefer food trails, Excavators prefer exploration trails
                    let foodWeight, explorationWeight;
                    switch(this.role) {
                        case ANT_ROLES.GATHERER:
                            foodWeight = 1.5; explorationWeight = 0.3;
                            break;
                        case ANT_ROLES.EXCAVATOR:
                            foodWeight = 0.3; explorationWeight = 1.5;
                            break;
                        case ANT_ROLES.NURSE:
                            foodWeight = 1.0; explorationWeight = 0.2; // Nurses mostly follow food to queen
                            break;
                        default: // WORKER
                            foodWeight = 1.0; explorationWeight = 0.8;
                    }

                    for (let i = 0; i < 5; i++) {
                        const testAngle = this.angle + (i - 2) * 0.4;
                        const testX = this.x + Math.cos(testAngle) * 10;
                        const testY = this.y + Math.sin(testAngle) * 10;
                        const g = this.screenToGrid(testX, testY);

                        if (g.x >= 0 && g.x < cols && g.y >= 0 && g.y < rows && pheromoneGrid[g.y]) {
                            const foodPheromone = (pheromoneGrid[g.y][g.x] || 0) * foodWeight;
                            const explorePheromone = (explorationPheromoneGrid[g.y]?.[g.x] || 0) * explorationWeight;
                            // Alarm pheromones repel ants (negative weight)
                            const alarmPheromone = (alarmPheromoneGrid[g.y]?.[g.x] || 0) * 2.0;
                            const combinedPheromone = foodPheromone + explorePheromone - alarmPheromone;
                            if (combinedPheromone > bestPheromone) {
                                bestPheromone = combinedPheromone;
                                bestAngle = testAngle;
                            }
                        }
                    }

                    if (bestPheromone > 0.1) {
                        this.angle = this.angle * 0.7 + bestAngle * 0.3;
                        // Gatherers gain experience from following trails
                        if (this.role === ANT_ROLES.WORKER) {
                            this.gatherExperience += 0.1;
                        }
                    } else {
                        this.angle += Math.sin(this.wanderPhase) * 0.3;
                    }

                    // CYCLE 15: Use spatial grid for O(1) food pickup instead of O(n)
                    const pickupRange = this.role === ANT_ROLES.GATHERER ? 25 : 15;
                    const nearbyFoodPickup = foodSpatialGrid.getNearby(this.x, this.y, pickupRange);
                    for (const food of nearbyFoodPickup) {
                        const dist = Math.hypot(food.x - this.x, food.y - this.y);
                        if (dist < pickupRange && food.amount > 0) {
                            this.hasFood = true;
                            food.amount -= 1;
                            this.gatherExperience += 2;
                            break;
                        }
                    }
                }

                // Apply weather modifier to movement speed
                const effectiveSpeed = this.speed * weatherSpeedMod;
                const nextX = this.x + Math.cos(this.angle) * effectiveSpeed;
                const nextY = this.y + Math.sin(this.angle) * effectiveSpeed;
                const g = this.screenToGrid(nextX, nextY);

                if (g.x >= 0 && g.x < cols && g.y >= 0 && g.y < rows && soilGrid[g.y]) {
                    if (soilGrid[g.y][g.x] > 0) {
                        // Check for obstacles at this position
                        const obstacle = getObstacleAt(g.x, g.y);

                        // Handle impassable obstacles (boulders) - ant must go around
                        if (obstacle.impassable) {
                            this.digging = false;
                            this.currentIntent = 'blocked'; // Can't dig through boulder
                            // Redirect ant - try to find a way around
                            this.angle += (Math.random() > 0.5 ? 1 : -1) * (Math.PI / 3 + Math.random() * Math.PI / 3);
                            // Spawn dust to show impact
                            if (Math.random() < 0.3) {
                                spawnDustParticle(this.x, this.y, g.y / (soilGrid.length || 1));
                            }
                        } else {
                            this.digging = true;
                            this.currentIntent = obstacle.id > 0 ? 'dig_obstacle' : 'dig'; // CYCLE 3: Intent tracking

                            // Excavators dig faster, weather slows digging
                            // Obstacles slow digging based on hardness
                            const digMultiplier = this.role === ANT_ROLES.EXCAVATOR ? 2.0 : 1.0;
                            const obstacleSlowdown = obstacle.hardness > 0 ? (1 / (1 + obstacle.hardness * 0.3)) : 1.0;

                            const prevSoil = soilGrid[g.y][g.x];
                            soilGrid[g.y][g.x] -= 0.02 * digSpeed * digMultiplier * weatherSpeedMod * obstacleSlowdown;
                            if (soilGrid[g.y][g.x] <= 0) {
                                soilGrid[g.y][g.x] = 0;
                                // Clear the obstacle when soil is fully excavated
                                if (obstacleGrid[g.y]) {
                                    obstacleGrid[g.y][g.x] = 0;
                                }
                            }
                            // Mark AO cache dirty if cell changed significantly
                            if (prevSoil > 0.5 && soilGrid[g.y][g.x] <= 0.5) {
                                markAODirty(g.x, g.y);

                                // CYCLE 4: Chance to discover underground protein deposits when digging deep
                                const depth = g.y / (soilGrid.length || 1);
                                if (milestones.proteinUnlocked && depth > 0.5 && Math.random() < 0.015) {
                                    // Spawn protein food underground
                                    const proteinFood = {
                                        x: nextX + (Math.random() - 0.5) * 20,
                                        y: nextY + (Math.random() - 0.5) * 20,
                                        amount: 150,
                                        maxAmount: 150,
                                        type: 'PROTEIN'
                                    };
                                    foodSources.push(proteinFood);
                                    foodSpatialGrid.insert(proteinFood);
                                }
                            }
                            // Spawn dust/debris particles when digging - more particles for obstacles
                            const dustChance = obstacle.id > 0 ? 0.25 : 0.15;
                            if (Math.random() < dustChance) {
                                const depth = g.y / (soilGrid.length || 1);
                                spawnDustParticle(this.x, this.y, depth);
                            }
                            // Deposit exploration pheromones while digging
                            // Excavators leave stronger exploration trails
                            const explorationStrength = this.role === ANT_ROLES.EXCAVATOR ? 0.15 : 0.05;
                            if (explorationPheromoneGrid[g.y]) {
                                explorationPheromoneGrid[g.y][g.x] = Math.min(1,
                                    (explorationPheromoneGrid[g.y][g.x] || 0) + explorationStrength);
                            }
                            // Gain digging experience - more XP for harder obstacles
                            const xpMultiplier = obstacle.hardness > 0 ? (1 + obstacle.hardness * 0.2) : 1.0;
                            this.digExperience += 0.5 * digMultiplier * xpMultiplier;
                            this.speed = 0.3 * obstacleSlowdown; // Slower when digging through obstacles
                        }
                    } else {
                        this.digging = false;
                        // Base speed varies by role
                        const baseSpeed = this.role === ANT_ROLES.GATHERER ? 1.3 :
                                         this.role === ANT_ROLES.EXCAVATOR ? 0.9 : 1.0;
                        this.speed = baseSpeed + Math.random() * 0.5;
                        this.x = nextX;
                        this.y = nextY;
                    }
                }

                // Track time near queen for nurse experience
                if (queen && !this.hasFood) {
                    const distToQueen = Math.hypot(queen.x - this.x, queen.y - this.y);
                    if (distToQueen < 30) {
                        this.nurseExperience += 0.2;
                    }
                }

                if (this.x < 10 || this.x > W - 10) this.angle = Math.PI - this.angle;
                if (this.y < 10 || this.y > H - 10) this.angle = -this.angle;

                this.x = Math.max(10, Math.min(W - 10, this.x));
                this.y = Math.max(10, Math.min(H - 10, this.y));

                // Check for role specialization
                this.updateRole();

                // Age the ant
                this.updateAge();
            }
            
            getRoleColor() {
                // Color coding by role
                switch(this.role) {
                    case ANT_ROLES.EXCAVATOR: return '#5a3a2a'; // Dark brown
                    case ANT_ROLES.GATHERER: return '#4a6a3a';  // Green tint
                    case ANT_ROLES.NURSE: return '#6a5a4a';     // Warm brown
                    default: return '#3a2a1a';                   // Default dark
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                // CYCLE 11: Custom colony colors
                const ageRatio = this.getAgeRatio();
                let baseColor = this.hasFood ? '#d4a054' : (colonyColors.ant || this.getRoleColor());

                // Fade to gray as ant ages (after 60% of lifespan) - unless in creative mode
                if (ageRatio > 0.6 && !creativeMode) {
                    const fadeFactor = (ageRatio - 0.6) / 0.4; // 0 to 1
                    const grayValue = Math.floor(60 + fadeFactor * 30);
                    baseColor = `rgb(${grayValue + 20}, ${grayValue + 10}, ${grayValue})`;
                }

                const size = this.role === ANT_ROLES.EXCAVATOR ? 1.2 : 1.0; // Excavators slightly bigger

                // Abdomen
                ctx.beginPath();
                ctx.ellipse(0, 0, 3 * size, 2 * size, 0, 0, Math.PI * 2);
                ctx.fillStyle = baseColor;
                ctx.fill();

                // Role indicator stripe
                if (this.role !== ANT_ROLES.WORKER) {
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 2 * size, 1.2 * size, 0, 0, Math.PI * 2);
                    let stripeColor;
                    switch(this.role) {
                        case ANT_ROLES.EXCAVATOR: stripeColor = 'rgba(100, 60, 40, 0.5)'; break;
                        case ANT_ROLES.GATHERER: stripeColor = 'rgba(80, 140, 60, 0.5)'; break;
                        case ANT_ROLES.NURSE: stripeColor = 'rgba(180, 140, 100, 0.5)'; break;
                    }
                    ctx.fillStyle = stripeColor;
                    ctx.fill();
                }

                // Head
                ctx.beginPath();
                ctx.ellipse(-4 * size, 0, 2 * size, 1.5 * size, 0, 0, Math.PI * 2);
                ctx.fillStyle = baseColor;
                ctx.fill();

                // Mandibles for excavators
                if (this.role === ANT_ROLES.EXCAVATOR) {
                    ctx.beginPath();
                    ctx.moveTo(-5 * size, -1);
                    ctx.lineTo(-7 * size, -2);
                    ctx.lineTo(-6 * size, 0);
                    ctx.moveTo(-5 * size, 1);
                    ctx.lineTo(-7 * size, 2);
                    ctx.lineTo(-6 * size, 0);
                    ctx.strokeStyle = '#4a3020';
                    ctx.lineWidth = 0.8;
                    ctx.stroke();
                }

                // Antennae
                ctx.beginPath();
                ctx.moveTo(-5, -1);
                ctx.lineTo(-8, -3);
                ctx.moveTo(-5, 1);
                ctx.lineTo(-8, 3);
                ctx.strokeStyle = baseColor;
                ctx.lineWidth = 0.5;
                ctx.stroke();

                ctx.restore();

                // Draw recruitment line to recently recruited ant
                if (this.recruitFlashTime > 0 && this.lastRecruitedAnt) {
                    ctx.save();
                    ctx.globalAlpha = this.recruitFlashTime / 8;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.lastRecruitedAnt.x, this.lastRecruitedAnt.y);
                    ctx.strokeStyle = 'rgba(255, 200, 100, 0.6)';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();

                    // Small spark at recruited ant
                    ctx.beginPath();
                    ctx.arc(this.lastRecruitedAnt.x, this.lastRecruitedAnt.y, 4, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 220, 120, 0.5)';
                    ctx.fill();
                    ctx.restore();

                    this.recruitFlashTime--;
                }
            }
        }
        
        function getSoilColor(depth) {
            for (let i = 1; i < SOIL_COLORS.length; i++) {
                if (depth <= SOIL_COLORS[i].depth) {
                    const t = (depth - SOIL_COLORS[i-1].depth) / (SOIL_COLORS[i].depth - SOIL_COLORS[i-1].depth);
                    const c1 = SOIL_COLORS[i-1].color;
                    const c2 = SOIL_COLORS[i].color;
                    return [
                        c1[0] + (c2[0] - c1[0]) * t,
                        c1[1] + (c2[1] - c1[1]) * t,
                        c1[2] + (c2[2] - c1[2]) * t
                    ];
                }
            }
            return SOIL_COLORS[SOIL_COLORS.length - 1].color;
        }
        
        // ============ CACHED AMBIENT OCCLUSION SYSTEM ============
        let aoCache = [];           // Cached AO values
        let aoDirtyRegions = [];    // Regions that need recalculation

        function initAOCache() {
            const rows = soilGrid.length;
            const cols = soilGrid[0]?.length || 0;
            aoCache = [];
            for (let y = 0; y < rows; y++) {
                aoCache[y] = [];
                for (let x = 0; x < cols; x++) {
                    aoCache[y][x] = 0;
                }
            }
            // Mark entire grid for initial calculation
            aoDirtyRegions = [[0, 0, cols - 1, rows - 1]];
        }

        function markAODirty(x, y) {
            // Mark a 5x5 region around the changed cell
            const cols = soilGrid[0]?.length || 0;
            const rows = soilGrid.length;
            const minX = Math.max(0, x - 3);
            const maxX = Math.min(cols - 1, x + 3);
            const minY = Math.max(0, y - 3);
            const maxY = Math.min(rows - 1, y + 3);
            aoDirtyRegions.push([minX, minY, maxX, maxY]);
        }

        function calculateAO(x, y, gridCols, gridRows) {
            if (!soilGrid[y] || soilGrid[y][x] <= 0) return 0;

            let tunnelNeighbors = 0;
            let totalChecked = 0;

            for (let dy = -2; dy <= 2; dy++) {
                for (let dx = -2; dx <= 2; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < gridCols && ny >= 0 && ny < gridRows) {
                        totalChecked++;
                        if (soilGrid[ny] && soilGrid[ny][nx] < 0.5) {
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            tunnelNeighbors += (3 - dist) / 3;
                        }
                    }
                }
            }
            return totalChecked > 0 ? Math.min(1, tunnelNeighbors / 4) : 0;
        }

        function updateAOCache() {
            if (aoDirtyRegions.length === 0) return;

            const cols = soilGrid[0]?.length || 0;
            const rows = soilGrid.length;

            // Process all dirty regions
            for (const [minX, minY, maxX, maxY] of aoDirtyRegions) {
                for (let y = minY; y <= maxY && y < rows; y++) {
                    for (let x = minX; x <= maxX && x < cols; x++) {
                        if (!aoCache[y]) aoCache[y] = [];
                        aoCache[y][x] = calculateAO(x, y, cols, rows);
                    }
                }
            }
            aoDirtyRegions = []; // Clear after processing
        }

        // Fast cached lookup
        function getAmbientOcclusion(x, y) {
            return aoCache[y]?.[x] || 0;
        }

        function drawPheromones() {
            if (!showPheromones) return;

            const cols = pheromoneGrid[0]?.length || 0;
            const rows = pheromoneGrid.length || 0;
            if (cols === 0 || rows === 0) return;

            const cellW = W / cols;
            const cellH = H / rows;

            ctx.globalAlpha = 0.4;

            // PERFORMANCE: Only draw cells with significant pheromone (skip empty cells)
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const foodPh = pheromoneGrid[y]?.[x] || 0;
                    const explorePh = explorationPheromoneGrid[y]?.[x] || 0;
                    const alarmPh = alarmPheromoneGrid[y]?.[x] || 0;

                    // Skip if no pheromone (performance optimization)
                    if (foodPh < 0.1 && explorePh < 0.1 && alarmPh < 0.1) continue;

                    const sx = x * cellW;
                    const sy = y * cellH;

                    // Food pheromone = amber/gold
                    if (foodPh > 0.1) {
                        ctx.fillStyle = `rgba(255, 200, 100, ${foodPh * 0.6})`;
                        ctx.fillRect(sx, sy, cellW + 1, cellH + 1);
                    }

                    // Exploration pheromone = blue
                    if (explorePh > 0.1) {
                        ctx.fillStyle = `rgba(100, 150, 255, ${explorePh * 0.4})`;
                        ctx.fillRect(sx, sy, cellW + 1, cellH + 1);
                    }

                    // Alarm pheromone = red
                    if (alarmPh > 0.1) {
                        ctx.fillStyle = `rgba(255, 100, 80, ${alarmPh * 0.5})`;
                        ctx.fillRect(sx, sy, cellW + 1, cellH + 1);
                    }
                }
            }

            ctx.globalAlpha = 1.0;
        }

        function drawSoil() {
            const gridRows = soilGrid.length;
            const gridCols = soilGrid[0]?.length || 0;

            // Guard against uninitialized grids
            if (gridRows === 0 || gridCols === 0) {
                // Clear canvas with dark background if grids aren't ready
                ctx.fillStyle = '#1a1510';
                ctx.fillRect(0, 0, W, H);
                return;
            }

            // Update AO cache for any dirty regions
            updateAOCache();

            // Calculate pixel size of each grid cell on screen
            const cellPixelWidth = W / gridCols;
            const cellPixelHeight = H / gridRows;

            const imageData = ctx.createImageData(W, H);

            for (let y = 0; y < gridRows; y++) {
                for (let x = 0; x < gridCols; x++) {
                    const soil = soilGrid[y] ? soilGrid[y][x] || 0 : 0;
                    const pheromone = pheromoneGrid[y] ? pheromoneGrid[y][x] || 0 : 0;
                    const obstacle = getObstacleAt(x, y);

                    let r, g, b;
                    if (soil > 0) {
                        const depth = y / gridRows;
                        let color = getSoilColor(depth);

                        // Blend obstacle color with soil color
                        if (obstacle.color) {
                            // Obstacles are partially visible in unexcavated soil
                            // More visible as soil is dug away
                            const obstacleVisibility = 0.3 + (1 - soil) * 0.5;
                            color = [
                                color[0] * (1 - obstacleVisibility) + obstacle.color[0] * obstacleVisibility,
                                color[1] * (1 - obstacleVisibility) + obstacle.color[1] * obstacleVisibility,
                                color[2] * (1 - obstacleVisibility) + obstacle.color[2] * obstacleVisibility
                            ];
                        }

                        // Use cached ambient occlusion (much faster!)
                        const occlusion = getAmbientOcclusion(x, y);
                        const shadowFactor = 1 - (occlusion * 0.4); // Darken by up to 40%

                        r = color[0] * soil * shadowFactor;
                        g = color[1] * soil * shadowFactor;
                        b = color[2] * soil * shadowFactor;
                    } else {
                        // Tunnel interior - subtle gradient based on depth
                        const tunnelDepth = y / gridRows;
                        const depthDarken = 0.7 + tunnelDepth * 0.3; // Darker at bottom

                        // Check if there's an impassable obstacle (boulder) exposed in tunnel
                        if (obstacle.impassable && obstacle.color) {
                            // Show boulder clearly in excavated area
                            r = obstacle.color[0] * depthDarken;
                            g = obstacle.color[1] * depthDarken;
                            b = obstacle.color[2] * depthDarken;
                        } else {
                            r = (15 + pheromone * 30) * depthDarken;
                            g = (12 + pheromone * 20) * depthDarken;
                            b = (10 + pheromone * 10) * depthDarken;

                            // Add subtle highlight on "ceiling" of tunnels
                            if (y > 0 && soilGrid[y-1] && soilGrid[y-1][x] > 0.5) {
                                // This is just below solid soil - add highlight
                                r = Math.min(255, r + 8);
                                g = Math.min(255, g + 6);
                                b = Math.min(255, b + 4);
                            }
                        }
                    }

                    // Calculate screen pixel bounds for this grid cell
                    const startX = Math.floor(x * cellPixelWidth);
                    const endX = Math.floor((x + 1) * cellPixelWidth);
                    const startY = Math.floor(y * cellPixelHeight);
                    const endY = Math.floor((y + 1) * cellPixelHeight);

                    for (let py = startY; py < endY && py < H; py++) {
                        for (let px = startX; px < endX && px < W; px++) {
                            const i = (py * W + px) * 4;
                            imageData.data[i] = r;
                            imageData.data[i + 1] = g;
                            imageData.data[i + 2] = b;
                            imageData.data[i + 3] = 255;
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }
        
        function drawSky() {
            const skyColor = weather.getSkyColor();
            // CYCLE 5: Blend with day/night cycle
            const brightness = dayNightCycle.getSkyBrightness();
            const gradient = ctx.createLinearGradient(0, 0, 0, H * 0.15);
            // Blend weather color with base sky and day/night brightness
            const topR = Math.round(skyColor[0] * 0.6 * brightness);
            const topG = Math.round(skyColor[1] * 0.6 * brightness);
            const topB = Math.round(skyColor[2] * 0.7 * brightness);
            gradient.addColorStop(0, `rgb(${topR}, ${topG}, ${topB})`);
            gradient.addColorStop(1, `rgb(${Math.round(skyColor[0] * brightness)}, ${Math.round(skyColor[1] * brightness)}, ${Math.round(skyColor[2] * brightness)})`);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, W, H * 0.15);

            // Draw moon during night
            if (!dayNightCycle.isDaytime()) {
                const moonX = W * 0.8;
                const moonY = H * 0.08;
                const moonRadius = 12;
                ctx.beginPath();
                ctx.arc(moonX, moonY, moonRadius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(220, 220, 240, 0.6)';
                ctx.fill();
                // Moon glow
                const moonGlow = ctx.createRadialGradient(moonX, moonY, moonRadius * 0.5, moonX, moonY, moonRadius * 2);
                moonGlow.addColorStop(0, 'rgba(200, 200, 220, 0.2)');
                moonGlow.addColorStop(1, 'transparent');
                ctx.fillStyle = moonGlow;
                ctx.beginPath();
                ctx.arc(moonX, moonY, moonRadius * 2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Cloud overlay during rain/storm
            if (weather.state === 'RAIN' || weather.state === 'STORM' || weather.state === 'COLD') {
                ctx.globalAlpha = weather.state === 'STORM' ? 0.4 : 0.25;
                for (let i = 0; i < 5; i++) {
                    const cloudX = (W * (0.15 + i * 0.2) + time * 5) % (W + 100) - 50;
                    const cloudY = H * 0.05 + Math.sin(i * 1.5) * 10;
                    ctx.beginPath();
                    ctx.arc(cloudX, cloudY, 30 + i * 5, 0, Math.PI * 2);
                    ctx.arc(cloudX + 25, cloudY - 5, 25, 0, Math.PI * 2);
                    ctx.arc(cloudX + 50, cloudY, 28, 0, Math.PI * 2);
                    ctx.fillStyle = weather.state === 'STORM' ? '#3a4050' : '#607080';
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
            }
        }

        // ============ SURFACE LIGHT SHAFTS ============
        function drawLightShafts() {
            // Light shafts are dimmer in bad weather
            const weatherIntensity = {
                CLEAR: 1.0, RAIN: 0.4, DROUGHT: 1.2, COLD: 0.6, STORM: 0.15
            };
            const intensity = weatherIntensity[weather.state] || 1.0;
            if (intensity < 0.1) return; // Skip in heavy storms

            const surfaceY = H * 0.15;
            const shaftCount = 3;

            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            ctx.globalAlpha = 0.12 * intensity;

            for (let i = 0; i < shaftCount; i++) {
                const shaftX = W * (0.25 + i * 0.25);
                const shaftWidth = 25 + Math.sin(time * 0.3 + i * 2) * 8;
                const shaftLength = H * 0.4;
                const angle = -0.12 + i * 0.06;

                ctx.save();
                ctx.translate(shaftX, surfaceY);
                ctx.rotate(angle);

                const gradient = ctx.createLinearGradient(0, 0, 0, shaftLength);
                gradient.addColorStop(0, 'rgba(255, 250, 210, 0.5)');
                gradient.addColorStop(0.2, 'rgba(255, 240, 190, 0.3)');
                gradient.addColorStop(0.6, 'rgba(255, 230, 170, 0.1)');
                gradient.addColorStop(1, 'transparent');

                ctx.fillStyle = gradient;
                ctx.fillRect(-shaftWidth / 2, 0, shaftWidth, shaftLength);

                ctx.restore();
            }

            ctx.restore();
        }

        // ============ VISIBLE PHEROMONE TRAIL SYSTEM ============
        // CYCLE 15: Enhanced with flowing animation for strong pheromone cells

        // Helper: Calculate pheromone flow direction (toward weaker concentration)
        function getPheromoneGradientAngle(gx, gy, grid) {
            const current = grid[gy]?.[gx] || 0;
            let maxDiff = 0;
            let flowAngle = 0;
            const offsets = [[1,0,0],[1,1,Math.PI/4],[0,1,Math.PI/2],[-1,1,3*Math.PI/4],
                           [-1,0,Math.PI],[-1,-1,-3*Math.PI/4],[0,-1,-Math.PI/2],[1,-1,-Math.PI/4]];

            for (const [dx, dy, angle] of offsets) {
                const neighbor = grid[gy+dy]?.[gx+dx] || 0;
                const diff = current - neighbor; // Flow toward weaker
                if (diff > maxDiff) {
                    maxDiff = diff;
                    flowAngle = angle;
                }
            }
            return flowAngle;
        }

        function drawPheromoneTrails() {
            const gridRows = pheromoneGrid.length;
            const gridCols = pheromoneGrid[0]?.length || 0;
            if (gridRows === 0 || gridCols === 0) return;

            const cellPixelWidth = W / gridCols;
            const cellPixelHeight = H / gridRows;
            const flowTime = time * 3; // Animation speed multiplier

            ctx.save();
            ctx.globalCompositeOperation = 'lighter'; // Additive blending for glow

            for (let y = 0; y < gridRows; y++) {
                for (let x = 0; x < gridCols; x++) {
                    // Only draw in tunnels (excavated areas)
                    if (soilGrid[y]?.[x] > 0.3) continue;

                    const centerX = (x + 0.5) * cellPixelWidth;
                    const centerY = (y + 0.5) * cellPixelHeight;

                    // Draw food pheromone trails (amber) with FLOWING ANIMATION
                    const foodPheromone = pheromoneGrid[y]?.[x] || 0;
                    if (foodPheromone >= 0.05) {
                        const intensity = Math.min(1, foodPheromone * 1.5);
                        const radius = cellPixelWidth * (0.8 + foodPheromone * 0.5);

                        // CYCLE 15: Animated pulse for strong trails (>0.3)
                        let pulseIntensity = 1.0;
                        if (foodPheromone >= 0.3) {
                            // Subtle pulsing animation (safer for gradients than offset)
                            pulseIntensity = 0.85 + Math.sin(flowTime + x * 0.5 + y * 0.3) * 0.15;
                        }

                        const gradient = ctx.createRadialGradient(
                            centerX, centerY, 0,
                            centerX, centerY, radius
                        );
                        gradient.addColorStop(0, `rgba(255, 180, 80, ${intensity * 0.4 * pulseIntensity})`);
                        gradient.addColorStop(0.5, `rgba(255, 140, 40, ${intensity * 0.2 * pulseIntensity})`);
                        gradient.addColorStop(1, 'transparent');

                        ctx.fillStyle = gradient;
                        ctx.fillRect(centerX - radius, centerY - radius, radius * 2, radius * 2);
                    }

                    // Draw exploration pheromone trails (cool blue) with FLOWING ANIMATION
                    const explorePheromone = explorationPheromoneGrid[y]?.[x] || 0;
                    if (explorePheromone >= 0.05) {
                        const intensity = Math.min(1, explorePheromone * 1.5);
                        const radius = cellPixelWidth * (0.6 + explorePheromone * 0.4);

                        // CYCLE 15: Animated flow for strong trails
                        let flowX = 0, flowY = 0;
                        if (explorePheromone >= 0.3) {
                            const flowAngle = getPheromoneGradientAngle(x, y, explorationPheromoneGrid);
                            const flowOffset = Math.sin(flowTime * 0.8 + x * 0.4 + y * 0.5) * 2.5;
                            flowX = Math.cos(flowAngle) * flowOffset;
                            flowY = Math.sin(flowAngle) * flowOffset;
                        }

                        const gradient = ctx.createRadialGradient(
                            centerX + flowX, centerY + flowY, 0,
                            centerX, centerY, radius
                        );
                        gradient.addColorStop(0, `rgba(100, 180, 255, ${intensity * 0.35})`);
                        gradient.addColorStop(0.5, `rgba(60, 120, 200, ${intensity * 0.15})`);
                        gradient.addColorStop(1, 'transparent');

                        ctx.fillStyle = gradient;
                        ctx.fillRect(centerX - radius, centerY - radius, radius * 2, radius * 2);
                    }

                    // Draw alarm pheromone zones (danger red) with PULSING effect
                    const alarmPheromone = alarmPheromoneGrid[y]?.[x] || 0;
                    if (alarmPheromone >= 0.05) {
                        // CYCLE 15: Pulsing alarm effect
                        const pulse = 1 + Math.sin(flowTime * 2) * 0.15;
                        const intensity = Math.min(1, alarmPheromone * 1.2 * pulse);
                        const radius = cellPixelWidth * (0.7 + alarmPheromone * 0.5);

                        const gradient = ctx.createRadialGradient(
                            centerX, centerY, 0,
                            centerX, centerY, radius
                        );
                        gradient.addColorStop(0, `rgba(255, 80, 60, ${intensity * 0.4})`);
                        gradient.addColorStop(0.5, `rgba(200, 40, 30, ${intensity * 0.2})`);
                        gradient.addColorStop(1, 'transparent');

                        ctx.fillStyle = gradient;
                        ctx.fillRect(centerX - radius, centerY - radius, radius * 2, radius * 2);
                    }
                }
            }

            ctx.restore();
        }

        // ============ CYCLE 15: OBSERVER CAMERA FOLLOW MODE ============

        // Generate unique ant names based on ID
        const ANT_NAME_PREFIXES = ['Scout', 'Brave', 'Swift', 'Digger', 'Forager', 'Guard', 'Worker', 'Elder'];
        const ANT_NAME_SUFFIXES = ['Alpha', 'Beta', 'Delta', 'Gamma', 'Prime', 'One', 'Two', 'Rex', 'Max', 'Nova'];

        function getAntName(ant) {
            if (!ant._antName) {
                const idx = ants.indexOf(ant);
                const prefix = ANT_NAME_PREFIXES[idx % ANT_NAME_PREFIXES.length];
                const suffix = ANT_NAME_SUFFIXES[Math.floor(idx / ANT_NAME_PREFIXES.length) % ANT_NAME_SUFFIXES.length];
                ant._antName = `${prefix}-${suffix}`;
            }
            return ant._antName;
        }

        function getAntAgeStage(ant) {
            const ageRatio = ant.age / ant.maxAge;
            if (ageRatio < 0.2) return 'Young';
            if (ageRatio < 0.5) return 'Adult';
            if (ageRatio < 0.8) return 'Mature';
            return 'Elder';
        }

        function drawAntFollowHUD() {
            if (!followedAnt || !observerModeEnabled) return;

            // Check if ant is still alive
            if (!ants.includes(followedAnt)) {
                showMilestone('Ant Lost', `${getAntName(followedAnt)} is no longer with us...`, false);
                followedAnt = null;
                observerModeEnabled = false;
                return;
            }

            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform for HUD

            // Top-center ant info card
            const cardW = 280;
            const cardH = 140;
            const cardX = W / 2 - cardW / 2;
            const cardY = 20;

            // Card background
            ctx.fillStyle = 'rgba(26,21,16,0.95)';
            ctx.beginPath();
            ctx.roundRect(cardX, cardY, cardW, cardH, 12);
            ctx.fill();

            ctx.strokeStyle = 'rgba(200,160,100,0.6)';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Ant name with icon
            ctx.fillStyle = '#d0a070';
            ctx.font = 'bold 16px Georgia';
            ctx.textAlign = 'center';
            ctx.fillText(`üêú ${getAntName(followedAnt)}`, W / 2, cardY + 28);

            // Stats
            ctx.font = '12px Georgia';
            ctx.fillStyle = '#a09070';
            ctx.textAlign = 'left';
            const leftCol = cardX + 15;
            const rightCol = cardX + 155;
            let row = cardY + 52;

            // Role with color indicator
            const roleColors = {
                [ANT_ROLES.WORKER]: '#8B6F47',
                [ANT_ROLES.EXCAVATOR]: '#6B5B3A',
                [ANT_ROLES.GATHERER]: '#9B7F57',
                [ANT_ROLES.NURSE]: '#A08060'
            };
            ctx.fillStyle = roleColors[followedAnt.role] || '#a09070';
            ctx.fillText(`Role: ${followedAnt.role}`, leftCol, row);

            ctx.fillStyle = '#a09070';
            ctx.fillText(`Age: ${getAntAgeStage(followedAnt)}`, rightCol, row);
            row += 20;

            // Health bar
            const healthPct = (followedAnt.health || 100) / 100;
            ctx.fillText('Health:', leftCol, row);
            ctx.fillStyle = 'rgba(60,40,30,0.6)';
            ctx.fillRect(leftCol + 50, row - 10, 80, 12);
            ctx.fillStyle = healthPct > 0.5 ? 'rgba(100,180,80,0.8)' : 'rgba(180,80,60,0.8)';
            ctx.fillRect(leftCol + 50, row - 10, 80 * healthPct, 12);

            // Speed
            ctx.fillStyle = '#a09070';
            ctx.fillText(`Speed: ${followedAnt.speed.toFixed(1)}`, rightCol, row);
            row += 20;

            // Status
            ctx.fillText(`Status: ${followedAnt.currentIntent || 'exploring'}`, leftCol, row);
            ctx.fillText(`Food: ${followedAnt.hasFood ? '‚úì Carrying' : '‚úó Empty'}`, rightCol, row);
            row += 20;

            // Experience
            ctx.fillStyle = '#806050';
            ctx.font = '10px Georgia';
            ctx.fillText(`Dig XP: ${followedAnt.digExperience || 0}  |  Gather XP: ${followedAnt.gatherExperience || 0}`, leftCol, row);

            // Target indicator around followed ant
            const pulse = Math.sin(time * 4) * 0.3 + 0.7;
            const targetX = followedAnt.x + cameraOffset.x;
            const targetY = followedAnt.y + cameraOffset.y;

            ctx.strokeStyle = `rgba(255, 200, 100, ${pulse})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(targetX, targetY, 20 + Math.sin(time * 3) * 3, 0, Math.PI * 2);
            ctx.stroke();

            // Exit hint
            ctx.fillStyle = 'rgba(160,120,80,0.6)';
            ctx.font = '10px Georgia';
            ctx.textAlign = 'center';
            ctx.fillText('Press O or click elsewhere to exit Observer Mode', W / 2, cardY + cardH - 8);

            ctx.restore();
        }

        function selectAntToFollow(mx, my) {
            // Find closest ant to click position
            let closest = null;
            let closestDist = 40; // Max selection distance

            for (const ant of ants) {
                const dist = Math.hypot(ant.x - mx, ant.y - my);
                if (dist < closestDist) {
                    closestDist = dist;
                    closest = ant;
                }
            }

            if (closest) {
                if (followedAnt === closest) {
                    // Deselect if clicking same ant
                    followedAnt = null;
                    observerModeEnabled = false;
                    cameraOffset = { x: 0, y: 0 };
                    showMilestone('Observer Mode', 'Camera released', false);
                } else {
                    followedAnt = closest;
                    observerModeEnabled = true;
                    showMilestone('Following', `Tracking ${getAntName(closest)}`, false);
                }
                return true;
            }

            // Click elsewhere to exit
            if (observerModeEnabled) {
                followedAnt = null;
                observerModeEnabled = false;
                cameraOffset = { x: 0, y: 0 };
                showMilestone('Observer Mode', 'Camera released', false);
                return true;
            }

            return false;
        }

        function updateCameraFollow() {
            if (!followedAnt || !observerModeEnabled) {
                // Smoothly return to center
                cameraOffset.x *= 0.9;
                cameraOffset.y *= 0.9;
                return;
            }

            // Smooth camera follow with lerp
            const targetX = W / 2 - followedAnt.x;
            const targetY = H / 2 - followedAnt.y;
            cameraOffset.x += (targetX - cameraOffset.x) * 0.08;
            cameraOffset.y += (targetY - cameraOffset.y) * 0.08;
        }

        // ============ END CYCLE 15: OBSERVER CAMERA ============

        function drawFoodSources() {
            for (let i = foodSources.length - 1; i >= 0; i--) {
                const food = foodSources[i];
                if (food.amount <= 0) {
                    foodSources.splice(i, 1);
                    foodSpatialGrid.remove(food); // CYCLE 4: Remove from spatial grid
                    continue;
                }

                // Check if buried food is exposed (soil excavated around it)
                if (food.buried) {
                    const gx = Math.floor(food.x / SOIL_RESOLUTION);
                    const gy = Math.floor(food.y / SOIL_RESOLUTION);
                    // Only show buried food if surrounding soil is mostly excavated
                    let excavatedCount = 0;
                    let totalChecked = 0;
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const checkY = gy + dy;
                            const checkX = gx + dx;
                            if (soilGrid[checkY] && soilGrid[checkY][checkX] !== undefined) {
                                totalChecked++;
                                if (soilGrid[checkY][checkX] < 0.5) excavatedCount++;
                            }
                        }
                    }
                    // Need at least 3 adjacent cells excavated to see the food
                    if (excavatedCount < 3) continue;
                    // Once discovered, mark as no longer buried for future renders
                    if (excavatedCount >= 5) food.buried = false;
                }

                const size = 5 + (food.amount / food.maxAmount) * 10;

                // CYCLE 4: Color based on food type
                const foodType = FOOD_TYPES[food.type || 'BASIC'];
                const [r, g, b] = foodType.color;

                ctx.beginPath();
                ctx.arc(food.x, food.y, size, 0, Math.PI * 2);
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                ctx.fill();
                ctx.strokeStyle = `rgb(${r * 0.7}, ${g * 0.7}, ${b * 0.7})`;
                ctx.lineWidth = 2;
                ctx.stroke();

                // CYCLE 4: Protein food glows golden
                if (food.type === 'PROTEIN') {
                    const glowRadius = size * 1.5;
                    const gradient = ctx.createRadialGradient(food.x, food.y, 0, food.x, food.y, glowRadius);
                    gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.4)`);
                    gradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(food.x - glowRadius, food.y - glowRadius, glowRadius * 2, glowRadius * 2);
                }
            }
        }

        // CYCLE 4: Draw chambers with type-specific visuals
        function drawChamber(chamber) {
            const chamberType = CHAMBER_TYPES[chamber.type];
            if (!chamberType) return;

            ctx.save();

            // Chamber background circle
            ctx.beginPath();
            ctx.arc(chamber.x, chamber.y, chamber.radius, 0, Math.PI * 2);
            const [r, g, b] = chamberType.color;
            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.3)`;
            ctx.fill();
            ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.6)`;
            ctx.lineWidth = 1;
            ctx.stroke();

            // Type-specific effects
            if (chamber.type === 'WATER_STORAGE' && chamber.waterLevel > 0) {
                // Draw water level with shimmer
                const waterY = chamber.y + chamber.radius * (1 - chamber.waterLevel);
                ctx.beginPath();
                ctx.arc(chamber.x, chamber.y, chamber.radius * 0.9, 0, Math.PI * 2);
                ctx.clip();
                ctx.fillStyle = `rgba(80, 150, 220, ${chamber.waterLevel * 0.5})`;
                ctx.fillRect(chamber.x - chamber.radius, waterY, chamber.radius * 2, chamber.radius * 2);

                // Shimmer effect
                const shimmer = Math.sin(time * 3) * 0.2 + 0.3;
                ctx.fillStyle = `rgba(120, 180, 255, ${shimmer * chamber.waterLevel})`;
                ctx.fillRect(chamber.x - chamber.radius, waterY, chamber.radius * 2, 3);
            }

            if (chamber.type === 'FUNGUS_GARDEN' && chamber.fungusHealth > 0) {
                // Draw fungus glow
                const glowIntensity = chamber.fungusHealth * 0.6;
                const glowRadius = chamber.radius * 0.8;
                const gradient = ctx.createRadialGradient(
                    chamber.x, chamber.y, 0,
                    chamber.x, chamber.y, glowRadius
                );
                gradient.addColorStop(0, `rgba(100, 255, 150, ${glowIntensity})`);
                gradient.addColorStop(0.5, `rgba(80, 200, 120, ${glowIntensity * 0.5})`);
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.fillRect(
                    chamber.x - glowRadius,
                    chamber.y - glowRadius,
                    glowRadius * 2,
                    glowRadius * 2
                );
            }

            ctx.restore();

            // Chamber label
            if (chamber.type !== 'NEST') {
                ctx.font = '9px Georgia';
                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.8)`;
                ctx.textAlign = 'center';
                ctx.fillText(chamberType.name, chamber.x, chamber.y + chamber.radius + 12);
            }
        }

        // CYCLE 4: Update chambers with weather-reactive behavior
        function updateChambers(dt) {
            const weatherState = weather.state;

            for (const chamber of chambers) {
                // Water storage chambers
                if (chamber.type === 'WATER_STORAGE') {
                    // Fill during rain/storms
                    if (weatherState === 'RAIN' || weatherState === 'STORM') {
                        chamber.waterLevel = Math.min(1, chamber.waterLevel + dt * 0.1);
                    }
                    // Deplete during drought
                    if (weatherState === 'DROUGHT') {
                        chamber.waterLevel = Math.max(0, chamber.waterLevel - dt * 0.05);
                    }
                }

                // Fungus gardens
                if (chamber.type === 'FUNGUS_GARDEN') {
                    // Fungus floods during storms (bad for growth)
                    if (weather.isFlooded(chamber.y)) {
                        chamber.fungusHealth = Math.max(0, chamber.fungusHealth - dt * 0.2);
                    } else {
                        // Recover health in normal conditions
                        chamber.fungusHealth = Math.min(1, chamber.fungusHealth + dt * 0.05);
                    }

                    // Produce food slowly when healthy
                    if (chamber.fungusHealth > 0.5 && weatherState !== 'STORM') {
                        chamber.foodProduction += dt * 0.5;

                        // Convert accumulated production to actual food
                        if (chamber.foodProduction >= 10) {
                            chamber.foodProduction -= 10;
                            // Spawn small food source near chamber
                            const newFood = {
                                x: chamber.x + (Math.random() - 0.5) * chamber.radius,
                                y: chamber.y + (Math.random() - 0.5) * chamber.radius,
                                amount: 50,
                                maxAmount: 50,
                                type: 'BASIC'
                            };
                            foodSources.push(newFood);
                            foodSpatialGrid.insert(newFood);
                        }
                    }
                }
            }
        }
        
        function decayPheromones() {
            // PERFORMANCE OPTIMIZATION: Partial grid iteration
            // Instead of decaying all 45k cells per frame, decay 20% per frame (5 frames = full grid)
            // This reduces pheromone ops from 135k/frame to 27k/frame (80% reduction)
            const rows = pheromoneGrid.length;
            if (rows === 0) return;

            const DECAY_RATE = 0.2; // Decay 20% of grid per frame
            const decayChunkSize = Math.max(1, Math.floor(rows * DECAY_RATE));
            const startRow = pheromoneDecayOffset;
            const endRow = Math.min(rows, startRow + decayChunkSize);

            for (let y = startRow; y < endRow; y++) {
                const cols = pheromoneGrid[y]?.length || 0;
                for (let x = 0; x < cols; x++) {
                    // Decay food pheromones
                    if (pheromoneGrid[y][x]) {
                        pheromoneGrid[y][x] *= 0.999;
                    }
                    // Decay exploration pheromones (slightly faster - dig sites become "old news")
                    if (explorationPheromoneGrid[y]?.[x]) {
                        explorationPheromoneGrid[y][x] *= 0.997;
                    }
                    // Decay alarm pheromones (slowest - danger memories persist longest)
                    if (alarmPheromoneGrid[y]?.[x]) {
                        alarmPheromoneGrid[y][x] *= 0.9995;
                    }
                }
            }

            // Advance offset, wrap to 0 when we complete full grid
            pheromoneDecayOffset = (endRow >= rows) ? 0 : endRow;
        }

        function countTunnelLength() {
            const rows = soilGrid.length;
            const surfaceRow = Math.floor(rows * 0.15);
            let dugCells = 0;

            for (let y = surfaceRow; y < rows; y++) {
                const cols = soilGrid[y]?.length || 0;
                for (let x = 0; x < cols; x++) {
                    if (soilGrid[y][x] === 0) {
                        dugCells++;
                    }
                }
            }

            // Scale by world size to give meaningful lengths
            const cellSize = (W / (soilGrid[0]?.length || 1)) * worldScale;
            return Math.floor(dugCells * cellSize / 10);
        }
        
        function updateStats() {
            document.getElementById('ant-count').textContent = ants.length;
            document.getElementById('tunnel-length').textContent = countTunnelLength();
            document.getElementById('chamber-count').textContent = chambers.length;
            document.getElementById('world-depth').textContent = worldScale.toFixed(1);
            document.getElementById('explored-pct').textContent = (exploredPercentage * 100).toFixed(1);
            document.getElementById('queen-fed').textContent = queen ? queen.foodReceived : 0;
            document.getElementById('birth-count').textContent = totalBirths;
            document.getElementById('death-count').textContent = totalDeaths;
            document.getElementById('generation-count').textContent = colonyMemory.generation;

            // Count roles
            let workers = 0, excavators = 0, gatherers = 0, nurses = 0;
            ants.forEach(ant => {
                switch(ant.role) {
                    case ANT_ROLES.WORKER: workers++; break;
                    case ANT_ROLES.EXCAVATOR: excavators++; break;
                    case ANT_ROLES.GATHERER: gatherers++; break;
                    case ANT_ROLES.NURSE: nurses++; break;
                }
            });
            document.getElementById('worker-count').textContent = workers;
            document.getElementById('excavator-count').textContent = excavators;
            document.getElementById('gatherer-count').textContent = gatherers;
            document.getElementById('nurse-count').textContent = nurses;

            // Update role distribution bar
            const total = workers + excavators + gatherers + nurses;
            if (total > 0) {
                document.getElementById('bar-workers').style.width = (workers / total * 100) + '%';
                document.getElementById('bar-excavators').style.width = (excavators / total * 100) + '%';
                document.getElementById('bar-gatherers').style.width = (gatherers / total * 100) + '%';
                document.getElementById('bar-nurses').style.width = (nurses / total * 100) + '%';
            }

            // COLONY RISK INDICATOR (SUBTLE - visual feedback only, no text warnings)
            const statsPanel = document.getElementById('stats');
            const antCount = ants.length;
            const queenEggProgress = queen ? queen.eggProgress : 0;

            // Critical: < 30 ants AND queen not pregnant
            if (antCount < 30 && queenEggProgress < 0.5) {
                statsPanel.style.borderColor = 'rgba(255, 80, 60, 0.5)'; // Subtle Red
                statsPanel.style.boxShadow = '0 8px 32px rgba(255, 80, 60, 0.2)';
            }
            // Warning: < 60 ants
            else if (antCount < 60) {
                statsPanel.style.borderColor = 'rgba(255, 255, 255, 0.2)'; // Subtle White
                statsPanel.style.boxShadow = '0 8px 32px rgba(255, 255, 255, 0.05)';
            }
            // Healthy
            else {
                statsPanel.style.borderColor = 'rgba(255, 255, 255, 0.1)'; // Default Glass
                statsPanel.style.boxShadow = '0 8px 32px rgba(0, 0, 0, 0.3)';
            }
        }
        
        function initAnts() {
            ants.length = 0;
            antSpatialGrid.clear(); // Clear spatial grid

            // Most ants start at nest
            for (let i = 0; i < colonySize - 20; i++) {
                const ant = new Ant();
                ants.push(ant);
                antSpatialGrid.insert(ant);
            }

            // Spawn starter food sources ON THE SURFACE
            foodSources.length = 0;
            foodSpatialGrid.clear(); // CYCLE 4: Clear food spatial grid
            const food1 = { x: W / 2 + 100, y: H * 0.10, amount: 500, maxAmount: 500, type: 'BASIC' }; // CYCLE 4: Added food type
            const food2 = { x: W / 2 - 120, y: H * 0.08, amount: 500, maxAmount: 500, type: 'BASIC' };
            const food3 = { x: W / 2, y: H * 0.05, amount: 400, maxAmount: 400, type: 'BASIC' };
            foodSources.push(food1, food2, food3);
            // CYCLE 4: Add food sources to spatial grid
            foodSpatialGrid.insert(food1);
            foodSpatialGrid.insert(food2);
            foodSpatialGrid.insert(food3);

            // Spawn 20 SCOUT ANTS directly near food sources - they'll find food immediately!
            const scoutFoods = [food1, food2, food3];
            for (let i = 0; i < 20; i++) {
                const ant = new Ant();
                const targetFood = scoutFoods[i % 3];
                ant.x = targetFood.x + (Math.random() - 0.5) * 40;
                ant.y = targetFood.y + (Math.random() - 0.5) * 20;
                ant.angle = Math.random() * Math.PI * 2;
                ants.push(ant);
                antSpatialGrid.insert(ant);
            }
        }

        // ============ EXPANSION SYSTEM FUNCTIONS ============

        function calculateExploredPercentage() {
            const cols = soilGrid[0]?.length || 0;
            const rows = soilGrid.length;
            const surfaceRow = Math.floor(rows * 0.15);
            let totalSoilCells = 0;
            let dugCells = 0;

            for (let y = surfaceRow; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (soilGrid[y] && soilGrid[y][x] !== undefined) {
                        totalSoilCells++;
                        if (soilGrid[y][x] < 0.5) {  // Consider < 50% as "dug"
                            dugCells++;
                        }
                    }
                }
            }

            return totalSoilCells > 0 ? dugCells / totalSoilCells : 0;
        }

        function checkForExpansion() {
            // Throttle checks to every 60 frames (~1 second)
            if (time - lastExpansionCheck < 1) return;
            lastExpansionCheck = time;

            exploredPercentage = calculateExploredPercentage();

            if (exploredPercentage >= EXPANSION_THRESHOLD) {
                expandWorld();
            }
        }

        function expandWorld() {
            console.log(`Expanding world! Current scale: ${worldScale.toFixed(2)}, Explored: ${(exploredPercentage * 100).toFixed(1)}%`);

            const oldCols = soilGrid[0]?.length || 0;
            const oldRows = soilGrid.length;

            // Calculate new dimensions
            const newCols = Math.ceil(oldCols * EXPANSION_FACTOR);
            const newRows = Math.ceil(oldRows * EXPANSION_FACTOR);

            // Calculate offset to center the old content
            const offsetX = Math.floor((newCols - oldCols) / 2);
            const offsetY = Math.floor((newRows - oldRows) / 2);

            // Create new grids
            const newSoilGrid = [];
            const newPheromoneGrid = [];
            const newExplorationPheromoneGrid = [];
            const newAlarmPheromoneGrid = [];

            // Surface line in new grid coordinates
            const newSurfaceRow = Math.floor(newRows * 0.15 / EXPANSION_FACTOR);

            for (let y = 0; y < newRows; y++) {
                newSoilGrid[y] = [];
                newPheromoneGrid[y] = [];
                newExplorationPheromoneGrid[y] = [];
                newAlarmPheromoneGrid[y] = [];
                for (let x = 0; x < newCols; x++) {
                    // Check if this maps to old grid
                    const oldX = x - offsetX;
                    const oldY = y - offsetY;

                    if (oldX >= 0 && oldX < oldCols && oldY >= 0 && oldY < oldRows) {
                        // Copy from old grid
                        newSoilGrid[y][x] = soilGrid[oldY][oldX];
                        newPheromoneGrid[y][x] = pheromoneGrid[oldY]?.[oldX] || 0;
                        newExplorationPheromoneGrid[y][x] = explorationPheromoneGrid[oldY]?.[oldX] || 0;
                        newAlarmPheromoneGrid[y][x] = alarmPheromoneGrid[oldY]?.[oldX] || 0;
                    } else {
                        // New territory - solid soil (except sky)
                        const worldY = y * SOIL_RESOLUTION / worldScale;
                        const surfaceY = H * 0.15;
                        newSoilGrid[y][x] = worldY > surfaceY ? 1 : 0;
                        newPheromoneGrid[y][x] = 0;
                        newExplorationPheromoneGrid[y][x] = 0;
                        newAlarmPheromoneGrid[y][x] = 0;
                    }
                }
            }

            // Update grids
            soilGrid = newSoilGrid;
            pheromoneGrid = newPheromoneGrid;
            explorationPheromoneGrid = newExplorationPheromoneGrid;
            alarmPheromoneGrid = newAlarmPheromoneGrid;

            // Scale ant positions to new grid
            const scaleRatio = 1 / EXPANSION_FACTOR;
            const centerX = W / 2;
            const centerY = H / 2;

            ants.forEach(ant => {
                // Scale position relative to center
                ant.x = centerX + (ant.x - centerX) * scaleRatio;
                ant.y = centerY + (ant.y - centerY) * scaleRatio;
            });

            // Scale food sources
            foodSources.forEach(food => {
                food.x = centerX + (food.x - centerX) * scaleRatio;
                food.y = centerY + (food.y - centerY) * scaleRatio;
            });

            // Scale chambers
            chambers.forEach(chamber => {
                chamber.x = centerX + (chamber.x - centerX) * scaleRatio;
                chamber.y = centerY + (chamber.y - centerY) * scaleRatio;
                chamber.radius *= scaleRatio;
            });

            // Scale queen position
            if (queen) {
                queen.x = centerX + (queen.x - centerX) * scaleRatio;
                queen.y = centerY + (queen.y - centerY) * scaleRatio;
            }

            // Update world scale
            worldScale *= EXPANSION_FACTOR;
            totalExpansions++;

            // Spawn more ants as colony grows
            const newAnts = Math.floor(colonySize * 0.2);
            for (let i = 0; i < newAnts; i++) {
                const ant = new Ant();
                // Spawn near existing ants
                if (ants.length > 0) {
                    const template = ants[Math.floor(Math.random() * ants.length)];
                    ant.x = template.x + (Math.random() - 0.5) * 30;
                    ant.y = template.y + (Math.random() - 0.5) * 30;
                }
                ants.push(ant);
            }

            console.log(`Expansion complete! New scale: ${worldScale.toFixed(2)}, Grid: ${newCols}x${newRows}, Ants: ${ants.length}`);
        }

        // ============ SAVE/LOAD SYSTEM ============

        function compressSoilGrid() {
            // Store only dug cells (value < 1) with their positions
            const dugCells = [];
            const rows = soilGrid.length;
            for (let y = 0; y < rows; y++) {
                const cols = soilGrid[y]?.length || 0;
                for (let x = 0; x < cols; x++) {
                    const val = soilGrid[y][x];
                    if (val < 1) {
                        // Store as [y, x, value] - only non-solid cells
                        dugCells.push([y, x, Math.round(val * 100) / 100]);
                    }
                }
            }
            return dugCells;
        }

        function compressPheromoneGrid() {
            // Store only significant pheromone values (> 0.01)
            const pheromones = [];
            const rows = pheromoneGrid.length;
            for (let y = 0; y < rows; y++) {
                const cols = pheromoneGrid[y]?.length || 0;
                for (let x = 0; x < cols; x++) {
                    const val = pheromoneGrid[y][x];
                    if (val > 0.01) {
                        pheromones.push([y, x, Math.round(val * 1000) / 1000]);
                    }
                }
            }
            return pheromones;
        }

        function compressExplorationPheromoneGrid() {
            // Store only significant exploration pheromone values (> 0.01)
            const pheromones = [];
            const rows = explorationPheromoneGrid.length;
            for (let y = 0; y < rows; y++) {
                const cols = explorationPheromoneGrid[y]?.length || 0;
                for (let x = 0; x < cols; x++) {
                    const val = explorationPheromoneGrid[y][x];
                    if (val > 0.01) {
                        pheromones.push([y, x, Math.round(val * 1000) / 1000]);
                    }
                }
            }
            return pheromones;
        }

        function compressAlarmPheromoneGrid() {
            // Store only significant alarm pheromone values (> 0.01)
            const pheromones = [];
            const rows = alarmPheromoneGrid.length;
            for (let y = 0; y < rows; y++) {
                const cols = alarmPheromoneGrid[y]?.length || 0;
                for (let x = 0; x < cols; x++) {
                    const val = alarmPheromoneGrid[y][x];
                    if (val > 0.01) {
                        pheromones.push([y, x, Math.round(val * 1000) / 1000]);
                    }
                }
            }
            return pheromones;
        }

        function compressObstacleGrid() {
            // Store only non-zero obstacle positions
            const obstacles = [];
            const rows = obstacleGrid.length;
            for (let y = 0; y < rows; y++) {
                const cols = obstacleGrid[y]?.length || 0;
                for (let x = 0; x < cols; x++) {
                    const val = obstacleGrid[y][x];
                    if (val > 0) {
                        obstacles.push([y, x, val]);
                    }
                }
            }
            return obstacles;
        }

        function serializeAnts() {
            return ants.map(ant => ({
                x: ant.x / W,  // Normalize to 0-1 for screen size independence
                y: ant.y / H,
                angle: ant.angle,
                speed: ant.speed,
                hasFood: ant.hasFood,
                digging: ant.digging,
                wanderPhase: ant.wanderPhase,
                // Role specialization
                role: ant.role,
                digExperience: ant.digExperience,
                gatherExperience: ant.gatherExperience,
                nurseExperience: ant.nurseExperience,
                // Mortality
                age: ant.age,
                maxAge: ant.maxAge
            }));
        }

        // ============ CYCLE 6: AUTO-SAVE SYSTEM ============
        let lastAutoSaveTime = 0;
        let autoSaveTimer = null;

        /**
         * CYCLE 13: Enhanced auto-save with robust error handling
         * Handles QuotaExceededError by clearing old saves and retrying
         * Falls back gracefully in private browsing mode
         */
        function performAutoSave() {
            try {
                const saveData = generateSaveData();
                const saveJSON = JSON.stringify(saveData);

                // CYCLE 13: Check localStorage availability and quota
                if (!window.localStorage) {
                    throw new Error('localStorage not available (private browsing?)');
                }

                // Try to save - may throw QuotaExceededError
                try {
                    localStorage.setItem(AUTOSAVE_KEY, saveJSON);
                    localStorage.setItem(AUTOSAVE_TIMESTAMP_KEY, Date.now().toString());
                } catch (quotaError) {
                    // CYCLE 13: Handle quota exceeded - try to clear old data
                    if (quotaError.name === 'QuotaExceededError') {
                        console.warn('localStorage quota exceeded - clearing old saves');
                        // Remove autosave and try again (keeps manual exports safe)
                        localStorage.removeItem(AUTOSAVE_KEY);
                        localStorage.removeItem(AUTOSAVE_TIMESTAMP_KEY);
                        // Retry once
                        localStorage.setItem(AUTOSAVE_KEY, saveJSON);
                        localStorage.setItem(AUTOSAVE_TIMESTAMP_KEY, Date.now().toString());
                    } else {
                        throw quotaError;
                    }
                }

                // Show save indicator
                const indicator = document.getElementById('autosave-indicator');
                indicator.textContent = 'Auto-saved';
                indicator.classList.add('saved');
                indicator.classList.remove('saving');

                setTimeout(() => {
                    indicator.classList.remove('saved');
                }, 2000);

                announceToScreenReader('Colony auto-saved successfully');
            } catch (e) {
                console.error('Auto-save failed:', e);
                const indicator = document.getElementById('autosave-indicator');
                indicator.textContent = 'Auto-save failed!';
                indicator.classList.remove('saving', 'saved');
                setTimeout(() => { indicator.textContent = 'Auto-saved'; }, 3000);
                announceToScreenReader('Auto-save failed. Export manually to preserve your colony.');
            }
        }

        function attemptCrashRecovery() {
            try {
                const autoSave = localStorage.getItem(AUTOSAVE_KEY);
                const saveTime = localStorage.getItem(AUTOSAVE_TIMESTAMP_KEY);

                if (autoSave && saveTime) {
                    const ageMinutes = Math.floor((Date.now() - parseInt(saveTime)) / 60000);
                    if (confirm(`Found auto-save from ${ageMinutes} minute(s) ago. Restore?`)) {
                        const saveData = JSON.parse(autoSave);
                        importFarm(saveData);
                        announceToScreenReader(`Colony restored from auto-save (${ageMinutes} minutes old)`);
                    }
                }
            } catch (e) {
                console.error('Crash recovery failed:', e);
            }
        }

        function startAutoSave() {
            autoSaveTimer = setInterval(() => {
                if (!isPaused && ants.length > 0) {
                    const indicator = document.getElementById('autosave-indicator');
                    indicator.textContent = 'Saving...';
                    indicator.classList.add('saving');

                    // Delay actual save slightly to show indicator
                    setTimeout(performAutoSave, 300);
                }
            }, AUTOSAVE_INTERVAL);
        }

        // ============ CYCLE 6: ACCESSIBILITY FUNCTIONS ============
        function announceToScreenReader(message) {
            const liveRegion = document.getElementById('autosave-indicator');
            if (liveRegion) {
                liveRegion.textContent = message;
                setTimeout(() => {
                    if (liveRegion.textContent === message) {
                        liveRegion.textContent = 'Auto-saved';
                    }
                }, 3000);
            }
        }

        function toggleHighContrast() {
            highContrastMode = !highContrastMode;
            document.body.classList.toggle('high-contrast', highContrastMode);
            const btn = document.getElementById('high-contrast-btn');
            btn.textContent = highContrastMode ? 'Normal Contrast' : 'High Contrast';
            btn.setAttribute('aria-pressed', highContrastMode.toString());
            announceToScreenReader(highContrastMode ? 'High contrast mode enabled' : 'Normal contrast mode restored');

            // Save preference
            localStorage.setItem('highContrastMode', highContrastMode.toString());
        }

        function showScreenReaderHelp() {
            const helpText = `Colony Mind Accessibility Help.
Controls: Use Tab to navigate buttons, Enter or Space to activate.
Keyboard shortcuts: Space for pause, 1-4 for speed, C for high contrast, W for weather, F for food, P for trails.
Statistics update automatically and are announced to screen readers.
Current colony has ${ants.length} ants with ${totalBirths} total births.`;

            alert(helpText);
            announceToScreenReader('Help dialog displayed');
        }

        // ============ CYCLE 6: MOBILE TOUCH HANDLERS ============
        function setupMobileControls() {
            const joystick = document.getElementById('mobile-joystick');
            const knob = document.getElementById('mobile-joystick-knob');

            let joystickActive = false;
            let joystickCenterX = 0;
            let joystickCenterY = 0;

            function handleJoystickStart(e) {
                joystickActive = true;
                const rect = joystick.getBoundingClientRect();
                joystickCenterX = rect.left + rect.width / 2;
                joystickCenterY = rect.top + rect.height / 2;
                e.preventDefault();
            }

            function handleJoystickMove(e) {
                if (!joystickActive) return;

                const touch = e.touches ? e.touches[0] : e;
                const dx = touch.clientX - joystickCenterX;
                const dy = touch.clientY - joystickCenterY;

                const distance = Math.min(30, Math.hypot(dx, dy));
                const angle = Math.atan2(dy, dx);

                const offsetX = Math.cos(angle) * distance;
                const offsetY = Math.sin(angle) * distance;

                knob.style.transform = `translate(calc(-50% + ${offsetX}px), calc(-50% + ${offsetY}px))`;

                // Apply to camera in ambience mode
                if (ambienceMode) {
                    cameraTargetX += Math.cos(angle) * distance * 0.3;
                    cameraTargetY += Math.sin(angle) * distance * 0.3;
                }

                e.preventDefault();
            }

            function handleJoystickEnd(e) {
                joystickActive = false;
                knob.style.transform = 'translate(-50%, -50%)';
                e.preventDefault();
            }

            joystick.addEventListener('touchstart', handleJoystickStart);
            joystick.addEventListener('touchmove', handleJoystickMove);
            joystick.addEventListener('touchend', handleJoystickEnd);
            joystick.addEventListener('mousedown', handleJoystickStart);
            joystick.addEventListener('mousemove', handleJoystickMove);
            joystick.addEventListener('mouseup', handleJoystickEnd);

            // Mobile action buttons
            const actionButtons = document.querySelectorAll('#mobile-actions button');
            actionButtons[0].addEventListener('click', () => document.getElementById('food-btn').click());
            actionButtons[1].addEventListener('click', () => document.getElementById('pause-btn').click());
            actionButtons[2].addEventListener('click', () => weather.stateTime = weather.cycleDuration);
        }

        // ============ CYCLE 6: PERFORMANCE MONITORING ============
        function updateFPS(deltaTime) {
            const fps = Math.round(1000 / deltaTime);
            fpsHistory.push(fps);
            if (fpsHistory.length > 60) fpsHistory.shift();

            const avgFPS = Math.round(fpsHistory.reduce((a, b) => a + b, 0) / fpsHistory.length);

            const fpsElement = document.getElementById('fps-value');
            const fpsIndicator = document.getElementById('fps-indicator');

            if (fpsElement) fpsElement.textContent = avgFPS;

            // Auto-adjust performance mode
            if (performanceMode === 'auto') {
                if (avgFPS < 30 && ants.length > 200) {
                    // Reduce particle counts
                    dustPool.maxSize = Math.floor(MAX_DUST_PARTICLES * 0.5);
                    spiritPool.maxSize = Math.floor(MAX_SPIRITS * 0.5);
                    fpsIndicator.classList.add('fps-low');
                    announceToScreenReader('Performance mode activated: reduced particle effects');
                } else if (avgFPS > 55) {
                    fpsIndicator.classList.remove('fps-low');
                }
            }

            return avgFPS;
        }

        // ============ CYCLE 6: PHEROMONE OPTIMIZATION ============
        // Chunked pheromone decay - process grid in batches to spread CPU load
        // CYCLE 13: Removed unused activePheromoneCells Set (dead code cleanup)
        let pheromoneDecayBatch = 0;
        const PHEROMONE_DECAY_CHUNKS = 10; // Process 10% of grid per frame

        /**
         * Optimized pheromone decay using chunked processing
         * Processes 1/10th of grid per frame to spread CPU load evenly
         * Handles 3 pheromone types: food (amber), exploration (blue), alarm (red)
         * CYCLE 13: Cleaned up unused activePheromoneCells tracking
         */
        function updatePheromonesOptimized(dt) {
            const cols = pheromoneGrid[0]?.length || 0;
            const rows = pheromoneGrid.length;
            const chunkSize = Math.ceil(rows / PHEROMONE_DECAY_CHUNKS);
            const startRow = pheromoneDecayBatch * chunkSize;
            const endRow = Math.min(rows, startRow + chunkSize);

            // Decay only active chunk
            for (let y = startRow; y < endRow; y++) {
                if (!pheromoneGrid[y]) continue;
                for (let x = 0; x < cols; x++) {
                    // Food pheromones
                    if (pheromoneGrid[y][x] > 0.001) {
                        pheromoneGrid[y][x] *= 0.995;
                        // CYCLE 13: Removed dead code - activePheromoneCells was never read
                    } else if (pheromoneGrid[y][x] > 0) {
                        pheromoneGrid[y][x] = 0;
                    }

                    // Exploration pheromones
                    if (explorationPheromoneGrid[y]?.[x] > 0.001) {
                        explorationPheromoneGrid[y][x] *= 0.998;
                    } else if (explorationPheromoneGrid[y]?.[x] > 0) {
                        explorationPheromoneGrid[y][x] = 0;
                    }

                    // Alarm pheromones - decay faster
                    if (alarmPheromoneGrid[y]?.[x] > 0.001) {
                        alarmPheromoneGrid[y][x] *= 0.99;
                    } else if (alarmPheromoneGrid[y]?.[x] > 0) {
                        alarmPheromoneGrid[y][x] = 0;
                    }
                }
            }

            // Move to next chunk
            pheromoneDecayBatch = (pheromoneDecayBatch + 1) % PHEROMONE_DECAY_CHUNKS;
        }

        // ============ CYCLE 6: ENHANCED SAVE DATA GENERATOR ============
        function generateSaveData() {
            const cols = Math.ceil(W / SOIL_RESOLUTION);
            const rows = Math.ceil(H / SOIL_RESOLUTION);

            const saveData = {
                version: SAVE_VERSION,
                timestamp: new Date().toISOString(),
                name: "Colony Mind Save",
                playtime: Math.floor(time), // CYCLE 6: Track total playtime

                // Grid dimensions (for reconstruction)
                grid: {
                    cols: cols,
                    rows: rows,
                    resolution: SOIL_RESOLUTION
                },

                // Compressed grids (only store non-default values)
                soilDugCells: compressSoilGrid(),
                pheromones: compressPheromoneGrid(),
                explorationPheromones: compressExplorationPheromoneGrid(),
                alarmPheromones: compressAlarmPheromoneGrid(),
                obstacles: compressObstacleGrid(),

                // Entities
                ants: serializeAnts(),
                foodSources: foodSources.map(f => ({
                    x: f.x / W,
                    y: f.y / H,
                    amount: f.amount,
                    maxAmount: f.maxAmount,
                    type: f.type || 'BASIC',
                    buried: f.buried || false,
                    name: f.name || null
                })),
                chambers: chambers.map(c => ({
                    x: c.x / W,
                    y: c.y / H,
                    radius: c.radius,
                    type: c.type || 'NEST',
                    waterLevel: c.waterLevel || 0,
                    fungusHealth: c.fungusHealth || 1.0,
                    foodProduction: c.foodProduction || 0
                })),

                // CYCLE 6: Predator state
                predators: predators.map(p => ({
                    x: p.x / W,
                    y: p.y / H,
                    angle: p.angle,
                    huntCooldown: p.huntCooldown
                })),

                // Settings
                settings: {
                    colonySize: colonySize,
                    digSpeed: digSpeed,
                    predatorsEnabled: predatorsEnabled, // CYCLE 6
                    showPheromones: showPheromones, // CYCLE 6
                    bloomQuality: bloomQuality, // CYCLE 6
                    audioEnabled: audioEnabled // CYCLE 6
                },

                // Simulation state
                time: time,
                isPaused: isPaused,
                simulationSpeed: simulationSpeed,

                // CYCLE 6: Weather state
                weather: {
                    state: weather.state,
                    stateTime: weather.stateTime,
                    cycleDuration: weather.cycleDuration,
                    floodLevel: weather.floodLevel,
                    gracePeriod: weather.gracePeriod
                },

                // CYCLE 6: Day/night state
                dayNight: {
                    time: dayNightCycle.time
                },

                // Expansion state
                expansion: {
                    worldScale: worldScale,
                    totalExpansions: totalExpansions,
                    exploredPercentage: exploredPercentage
                },

                // Queen state
                queen: queen ? {
                    x: queen.x / W,
                    y: queen.y / H,
                    foodReceived: queen.foodReceived,
                    lastSpawnTime: queen.lastSpawnTime,
                    eggProgress: queen.eggProgress,
                    timeSinceLastFood: queen.timeSinceLastFood
                } : null,
                totalBirths: totalBirths,
                totalDeaths: totalDeaths,

                // Genetic memory
                geneticMemory: {
                    roleSuccess: colonyMemory.roleSuccess,
                    bestForagingDepth: colonyMemory.bestForagingDepth,
                    generation: colonyMemory.generation,
                    successfulDeliveries: colonyMemory.successfulDeliveries,
                    dangerZones: Array.from(colonyMemory.dangerZones.entries())
                },

                // CYCLE 6: Narrative events state
                narrativeEvents: {
                    starvationTriggered: narrativeEvents.starvationTriggered,
                    breakthroughDepth: narrativeEvents.breakthroughDepth,
                    roleRevolutions: Array.from(narrativeEvents.roleRevolutions)
                },

                // Milestone state
                milestones: milestones,
                peakPopulation: peakPopulation,

                // Stats for display
                stats: {
                    tunnelLength: countTunnelLength(),
                    antCount: ants.length,
                    chamberCount: chambers.length,
                    worldDepth: worldScale,
                    queenFed: queen ? queen.foodReceived : 0,
                    births: totalBirths,
                    deaths: totalDeaths
                }
            };

            return saveData;
        }

        // CYCLE 6: Enhanced export function with validation
        function exportFarm() {
            const saveData = generateSaveData();

            const json = JSON.stringify(saveData, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = `colony-mind-v${SAVE_VERSION}-${new Date().toISOString().slice(0,10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            announceToScreenReader(`Colony exported: ${ants.length} ants, generation ${colonyMemory.generation}`);
            console.log(`[CYCLE 6] Exported: ${ants.length} ants, ${saveData.soilDugCells.length} dug cells, version ${SAVE_VERSION}`);
        }

        function importFarm(saveData) {
            try {
                // Validate version
                if (!saveData.version) {
                    throw new Error("Invalid save file: missing version");
                }

                // Get current grid dimensions
                const currentCols = Math.ceil(W / SOIL_RESOLUTION);
                const currentRows = Math.ceil(H / SOIL_RESOLUTION);

                // Calculate scale factors for different screen sizes
                const scaleX = currentCols / saveData.grid.cols;
                const scaleY = currentRows / saveData.grid.rows;

                // Reinitialize grids (fills with solid soil)
                initSoil();

                // Clear the default nest chamber (initSoil adds one)
                chambers.length = 0;

                // Restore dug cells with scaling
                for (const [y, x, val] of saveData.soilDugCells) {
                    const newY = Math.floor(y * scaleY);
                    const newX = Math.floor(x * scaleX);
                    if (newY >= 0 && newY < currentRows && newX >= 0 && newX < currentCols) {
                        if (!soilGrid[newY]) soilGrid[newY] = [];
                        soilGrid[newY][newX] = val;
                    }
                }

                // Restore pheromones with scaling
                for (const [y, x, val] of saveData.pheromones) {
                    const newY = Math.floor(y * scaleY);
                    const newX = Math.floor(x * scaleX);
                    if (newY >= 0 && newY < currentRows && newX >= 0 && newX < currentCols) {
                        if (!pheromoneGrid[newY]) pheromoneGrid[newY] = [];
                        pheromoneGrid[newY][newX] = val;
                    }
                }

                // Restore exploration pheromones with scaling
                if (saveData.explorationPheromones) {
                    for (const [y, x, val] of saveData.explorationPheromones) {
                        const newY = Math.floor(y * scaleY);
                        const newX = Math.floor(x * scaleX);
                        if (newY >= 0 && newY < currentRows && newX >= 0 && newX < currentCols) {
                            if (!explorationPheromoneGrid[newY]) explorationPheromoneGrid[newY] = [];
                            explorationPheromoneGrid[newY][newX] = val;
                        }
                    }
                }

                // Restore alarm pheromones with scaling
                if (saveData.alarmPheromones) {
                    for (const [y, x, val] of saveData.alarmPheromones) {
                        const newY = Math.floor(y * scaleY);
                        const newX = Math.floor(x * scaleX);
                        if (newY >= 0 && newY < currentRows && newX >= 0 && newX < currentCols) {
                            if (!alarmPheromoneGrid[newY]) alarmPheromoneGrid[newY] = [];
                            alarmPheromoneGrid[newY][newX] = val;
                        }
                    }
                }

                // Restore obstacles with scaling (new saves) or regenerate (legacy saves)
                if (saveData.obstacles && saveData.obstacles.length > 0) {
                    // Clear existing obstacles first
                    for (let y = 0; y < currentRows; y++) {
                        if (!obstacleGrid[y]) obstacleGrid[y] = [];
                        for (let x = 0; x < currentCols; x++) {
                            obstacleGrid[y][x] = 0;
                        }
                    }
                    // Restore saved obstacles
                    for (const [y, x, val] of saveData.obstacles) {
                        const newY = Math.floor(y * scaleY);
                        const newX = Math.floor(x * scaleX);
                        if (newY >= 0 && newY < currentRows && newX >= 0 && newX < currentCols) {
                            if (!obstacleGrid[newY]) obstacleGrid[newY] = [];
                            obstacleGrid[newY][newX] = val;
                        }
                    }
                }
                // Note: For legacy saves without obstacles, they were already generated in initSoil

                // Restore ants
                ants.length = 0;
                for (const antData of saveData.ants) {
                    const ant = new Ant();
                    ant.x = antData.x * W;
                    ant.y = antData.y * H;
                    ant.angle = antData.angle;
                    ant.speed = antData.speed;
                    ant.hasFood = antData.hasFood;
                    ant.digging = antData.digging;
                    ant.wanderPhase = antData.wanderPhase;
                    // Restore role specialization
                    ant.role = antData.role || ANT_ROLES.WORKER;
                    ant.digExperience = antData.digExperience || 0;
                    ant.gatherExperience = antData.gatherExperience || 0;
                    ant.nurseExperience = antData.nurseExperience || 0;
                    // Restore mortality
                    ant.age = antData.age || 0;
                    ant.maxAge = antData.maxAge || (BASE_LIFESPAN + Math.random() * LIFESPAN_VARIANCE);
                    ants.push(ant);
                }

                totalDeaths = saveData.totalDeaths || 0;

                // Restore food sources
                foodSources.length = 0;
                foodSpatialGrid.clear(); // CYCLE 4: Clear food spatial grid
                for (const f of saveData.foodSources) {
                    const food = {
                        x: f.x * W,
                        y: f.y * H,
                        amount: f.amount,
                        maxAmount: f.maxAmount,
                        type: f.type || 'BASIC', // CYCLE 4: Restore food type
                        buried: f.buried || false,
                        name: f.name || null
                    };
                    foodSources.push(food);
                    foodSpatialGrid.insert(food); // CYCLE 4: Add to spatial grid
                }

                // Restore chambers
                for (const c of saveData.chambers) {
                    chambers.push({
                        x: c.x * W,
                        y: c.y * H,
                        radius: c.radius,
                        type: c.type || 'NEST', // CYCLE 4: Restore chamber type
                        waterLevel: c.waterLevel || 0,
                        fungusHealth: c.fungusHealth || 1.0,
                        foodProduction: c.foodProduction || 0
                    });
                }

                // Restore settings
                colonySize = saveData.settings.colonySize;
                digSpeed = saveData.settings.digSpeed;
                time = saveData.time || 0;

                // Restore expansion state
                if (saveData.expansion) {
                    worldScale = saveData.expansion.worldScale || 1.0;
                    totalExpansions = saveData.expansion.totalExpansions || 0;
                    exploredPercentage = saveData.expansion.exploredPercentage || 0;
                } else {
                    worldScale = 1.0;
                    totalExpansions = 0;
                    exploredPercentage = 0;
                }
                lastExpansionCheck = time;

                // Restore queen state
                if (saveData.queen) {
                    queen = new QueenAnt(saveData.queen.x * W, saveData.queen.y * H);
                    queen.foodReceived = saveData.queen.foodReceived || 0;
                    queen.lastSpawnTime = saveData.queen.lastSpawnTime || 0;
                    queen.eggProgress = saveData.queen.eggProgress || 0;
                } else {
                    queen = new QueenAnt(W / 2, H * 0.2);
                }
                totalBirths = saveData.totalBirths || 0;

                // Restore genetic memory
                if (saveData.geneticMemory) {
                    colonyMemory.roleSuccess = saveData.geneticMemory.roleSuccess || {
                        excavator: { totalLifespan: 0, count: 0 },
                        gatherer: { totalLifespan: 0, count: 0 },
                        nurse: { totalLifespan: 0, count: 0 }
                    };
                    colonyMemory.bestForagingDepth = saveData.geneticMemory.bestForagingDepth || 0.5;
                    colonyMemory.generation = saveData.geneticMemory.generation || 0;
                    colonyMemory.successfulDeliveries = saveData.geneticMemory.successfulDeliveries || 0;
                    colonyMemory.dangerZones = new Map(saveData.geneticMemory.dangerZones || []);
                }

                // CYCLE 4: Restore milestones and unlock state
                if (saveData.milestones) {
                    Object.assign(milestones, saveData.milestones);
                    // Re-apply unlocks based on milestone state
                    if (milestones.fungusUnlocked) CHAMBER_TYPES.FUNGUS_GARDEN.unlocked = true;
                    if (milestones.waterStorageUnlocked) CHAMBER_TYPES.WATER_STORAGE.unlocked = true;
                }

                // CYCLE 6: Restore additional CYCLE 6 state
                if (saveData.version >= "2.0") {
                    // Restore predators
                    if (saveData.predators) {
                        predators.length = 0;
                        for (const p of saveData.predators) {
                            predators.push({
                                x: p.x * W,
                                y: p.y * H,
                                angle: p.angle,
                                huntCooldown: p.huntCooldown || 0
                            });
                        }
                    }

                    // Restore settings
                    if (saveData.settings) {
                        predatorsEnabled = saveData.settings.predatorsEnabled || false;
                        showPheromones = saveData.settings.showPheromones || false;
                        bloomQuality = saveData.settings.bloomQuality || 'auto';
                        audioEnabled = saveData.settings.audioEnabled || false;

                        // Update UI buttons
                        document.getElementById('predator-btn').textContent = predatorsEnabled ? 'Predators: On' : 'Predators: Off';
                        document.getElementById('pheromone-btn').textContent = showPheromones ? 'Hide Trails' : 'Show Trails';
                        document.getElementById('bloom-btn').textContent = `Bloom: ${bloomQuality.charAt(0).toUpperCase() + bloomQuality.slice(1)}`;
                        document.getElementById('sound-btn').textContent = audioEnabled ? 'Sound On' : 'Sound Off';
                    }

                    // Restore simulation state
                    isPaused = saveData.isPaused || false;
                    simulationSpeed = saveData.simulationSpeed || 1.0;

                    // Restore weather state
                    if (saveData.weather) {
                        weather.state = saveData.weather.state || 'CLEAR';
                        weather.stateTime = saveData.weather.stateTime || 0;
                        weather.cycleDuration = saveData.weather.cycleDuration || 120;
                        weather.floodLevel = saveData.weather.floodLevel || 0;
                        weather.gracePeriod = saveData.weather.gracePeriod || false;
                        weather.updateUI();
                    }

                    // Restore day/night state
                    if (saveData.dayNight) {
                        dayNightCycle.time = saveData.dayNight.time || 0;
                    }

                    // Restore queen hunger timer
                    if (saveData.queen && saveData.queen.timeSinceLastFood !== undefined) {
                        queen.timeSinceLastFood = saveData.queen.timeSinceLastFood;
                    }

                    // Restore narrative events
                    if (saveData.narrativeEvents) {
                        narrativeEvents.starvationTriggered = saveData.narrativeEvents.starvationTriggered || false;
                        narrativeEvents.breakthroughDepth = saveData.narrativeEvents.breakthroughDepth || 0;
                        narrativeEvents.roleRevolutions = new Set(saveData.narrativeEvents.roleRevolutions || []);
                    }

                    // Restore peak population
                    peakPopulation = saveData.peakPopulation || ants.length;
                }

                // Rebuild spatial grids
                antSpatialGrid.clear();
                for (const ant of ants) {
                    antSpatialGrid.insert(ant);
                }

                // Update UI
                document.getElementById('size').value = colonySize;
                document.getElementById('size-val').textContent = colonySize;
                document.getElementById('speed').value = Math.round(digSpeed * 100);
                document.getElementById('speed-val').textContent = Math.round(digSpeed * 100);

                // CYCLE 6: Announce successful import
                const playtimeMin = saveData.playtime ? Math.floor(saveData.playtime / 60) : 0;
                announceToScreenReader(`Colony imported: ${ants.length} ants, generation ${colonyMemory.generation}, ${playtimeMin} minutes playtime`);
                console.log(`[CYCLE 6] Imported v${saveData.version}: ${ants.length} ants, ${saveData.soilDugCells.length} dug cells, scale: ${worldScale}x`);
                return true;
            } catch (err) {
                console.error("Import error:", err);
                alert("Failed to import: " + err.message);
                return false;
            }
        }

        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const saveData = JSON.parse(e.target.result);
                    importFarm(saveData);
                } catch (err) {
                    alert("Invalid JSON file: " + err.message);
                }
            };
            reader.readAsText(file);

            // Reset file input so same file can be loaded again
            event.target.value = '';
        }
        
        // CYCLE 3: Thought Bubble Visualization
        function drawAntThought(ant) {
            const icons = {
                explore: 'üß≠',
                dig: '‚õèÔ∏è',
                dig_obstacle: 'ü™®',
                blocked: 'üö´',
                gather: 'üåæ',
                nurse: 'üëë',
                flee: '‚ö†Ô∏è'
            };

            const icon = icons[ant.currentIntent] || '‚ùì';

            // Thought bubble background
            ctx.save();
            ctx.translate(ant.x, ant.y - 18);

            // Bubble
            ctx.beginPath();
            ctx.arc(0, 0, 10, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fill();
            ctx.strokeStyle = 'rgba(100, 80, 60, 0.6)';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Small bubble connectors
            ctx.beginPath();
            ctx.arc(2, 8, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(4, 12, 1.5, 0, Math.PI * 2);
            ctx.fill();

            // Icon
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#333';
            ctx.fillText(icon, 0, 0);

            ctx.restore();
        }

        function animate() {
            const dt = 0.016 * simulationSpeed;

            // CYCLE 6: FPS tracking and performance monitoring
            const now = performance.now();
            const deltaTime = now - lastFrameTime;
            lastFrameTime = now;
            updateFPS(deltaTime);

            // IMPROVEMENT #1: FPS detection for adaptive bloom quality
            detectPerformance();

            // CYCLE 15: Update observer camera follow
            updateCameraFollow();

            // CYCLE 14: Queen Dynasty Logic
            if (!isPaused) {
                queenAge += dt;
                if (queenAge >= queenLifespan) {
                    // Queen dies, new generation starts
                    currentGeneration++;
                    queenAge = 0;
                    queenLifespan = 300 + (currentGeneration * 10); // Slightly longer each time
                    currentQueenName = generateQueenName(currentGeneration);
                    showMilestone(`Generation ${currentGeneration}`, `Long live ${currentQueenName}!`);
                    hapticFeedback(HAPTIC_PATTERNS.milestone);
                }
            }

            // Clear canvas to prevent any flash artifacts
            ctx.fillStyle = '#1a1510';
            ctx.fillRect(0, 0, W, H);

            // CYCLE 15: Apply camera transform for observer mode
            let cameraTransformApplied = false;
            if (observerModeEnabled && (Math.abs(cameraOffset.x) > 0.1 || Math.abs(cameraOffset.y) > 0.1)) {
                ctx.save();
                ctx.translate(cameraOffset.x, cameraOffset.y);
                cameraTransformApplied = true;
            }

            // Always draw even when paused
            drawSoil();
            drawSky();
            drawLightShafts();      // Atmospheric light beams from surface
            drawRoots();            // Organic root tendrils in tunnels
            drawPheromones();       // OPTIONAL: Pheromone trail overlay (toggled by button)

            // CYCLE 8: Draw underground chambers
            renderUndergroundChambers();

            // Draw weather effects (particles, overlays)
            weather.draw();

            // CYCLE 8: Draw celestial events
            renderCelestialEvents();

            drawPheromoneTrails();  // Visible glowing trails
            drawFoodSources();

            // Draw all ants (even when paused)
            for (const ant of ants) {
                ant.draw();
            }

            // CYCLE 10: Draw rival ants
            if (currentChallengeMode === 'rival') {
                rivalAnts.forEach(ant => {
                    // Draw rival ant (simplified gray version)
                    ctx.fillStyle = `rgba(${RIVAL_ANT_COLOR[0]}, ${RIVAL_ANT_COLOR[1]}, ${RIVAL_ANT_COLOR[2]}, 0.9)`;
                    ctx.beginPath();
                    ctx.arc(ant.x, ant.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Draw rival queen
                if (rivalQueen) {
                    ctx.fillStyle = 'rgba(100,80,70,0.9)';
                    ctx.beginPath();
                    ctx.arc(rivalQueen.x, rivalQueen.y, 6, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // CYCLE 3: Draw thought bubble for hovered ant
            if (hoveredAnt && hoveredAnt.isAlive) {
                drawAntThought(hoveredAnt);
            }

            // Draw digging dust particles
            updateAndDrawDust();

            // Draw rising ant spirits
            updateAndDrawSpirits();

            // CYCLE 4: Draw celebration particles
            for (let i = celebrationParticles.length - 1; i >= 0; i--) {
                const particle = celebrationParticles[i];
                if (!particle.update()) {
                    celebrationParticles.splice(i, 1);
                } else {
                    particle.draw(ctx);
                }
            }

            // CYCLE 4: Draw chambers with type-specific visuals
            for (const chamber of chambers) {
                drawChamber(chamber);
            }

            // Draw the queen
            if (queen) {
                queen.draw();
            }

            // IMPROVEMENT #1: Apply bloom/glow post-processing
            const bloomTargets = [];
            bloomTargets.push({ type: 'queen' });

            // Add pheromone hotspots for bloom
            const gridRows = pheromoneGrid.length;
            const gridCols = pheromoneGrid[0]?.length || 0;
            const cellW = W / gridCols;
            const cellH = H / gridRows;

            for (let y = 0; y < gridRows; y++) {
                for (let x = 0; x < gridCols; x++) {
                    const foodPh = pheromoneGrid[y]?.[x] || 0;
                    if (foodPh > 0.5) {
                        bloomTargets.push({
                            type: 'pheromone',
                            x: (x + 0.5) * cellW,
                            y: (y + 0.5) * cellH,
                            radius: cellW * 0.8,
                            intensity: foodPh,
                            color: '255, 180, 80'
                        });
                    }
                }
            }

            applyBloomToContext(bloomTargets);

            ctx.font = '10px Georgia';
            ctx.fillStyle = '#a08060';
            ctx.textAlign = 'center';
            ctx.fillText('NEST', W/2, H * 0.2 + 25);

            // Only update simulation when not paused
            if (!isPaused) {
                time += dt;

                // CYCLE 5: Update day/night cycle
                dayNightCycle.update(dt);

                // Update weather system
                weather.update(dt);

                // CYCLE 6: Optimized pheromone decay (processes 10% of grid per frame)
                updatePheromonesOptimized(dt);

                // Check for world expansion
                checkForExpansion();

                // Update ants and remove dead ones
                for (let i = ants.length - 1; i >= 0; i--) {
                    const ant = ants[i];
                    ant.update();

                    // Update spatial grid position
                    antSpatialGrid.update(ant);

                    // CYCLE 11: God Mode prevents death
                    if (!ant.isAlive && !godModeEnabled) {
                        // Record death for genetic memory
                        recordAntDeath(ant);
                        // Remove from spatial grid
                        antSpatialGrid.remove(ant);
                        // Spawn spirit effect before removing ant
                        spawnDeadAntSpirit(ant.x, ant.y, ant.role);
                        ants.splice(i, 1);  // Remove dead ant
                    } else if (!ant.isAlive && godModeEnabled) {
                        // God mode: Reset ant lifespan instead of dying
                        ant.isAlive = true;
                        ant.age = 0;
                    }
                }

                // Update queen
                if (queen) {
                    queen.update(time);
                }

                // CYCLE 4: Update chambers (weather reactions, food production)
                updateChambers(dt);

                // Check for milestone achievements (throttled to every 60 frames)
                if (Math.floor(time * 60) % 60 === 0) {
                    checkMilestones();
                    // CYCLE 5: Check for emergent narrative events
                    checkEmergentNarratives();
                    // CYCLE 8: Check for secret achievements
                    checkCycle8Achievements();
                    // CYCLE 8: Check for celestial events
                    checkCelestialEvents();
                    // CYCLE 8: Check for chamber discoveries
                    checkChamberDiscovery();
                }

                // CYCLE 8: Random ant thought bubbles
                tryShowRandomThought();

                // CYCLE 10: Update challenge modes
                updateDisasterMode(dt);
                updateSpeedrunMode(dt);
                updateRivalColony(dt);
            }

            updateStats();

            // CYCLE 5: Update ambience mode UI fading
            const controlsEl = document.getElementById('controls');
            const statsEl = document.getElementById('stats');
            const infoEl = document.getElementById('info');
            const weatherEl = document.getElementById('weather-indicator');
            if (ambienceMode) {
                controlsEl.style.opacity = '0.1';
                statsEl.style.opacity = '0.2';
                infoEl.style.opacity = '0';
                weatherEl.style.opacity = '0.3';
            } else {
                controlsEl.style.opacity = '1';
                statsEl.style.opacity = '1';
                infoEl.style.opacity = '0.5';
                weatherEl.style.opacity = '1';
            }

            // Update procedural audio based on colony activity
            if (audioEnabled) {
                updateAudio();
                // IMPROVEMENT #2: Update weather audio layers
                updateWeatherAudio();
            }

            // CYCLE 15: Restore camera transform and draw observer HUD
            if (cameraTransformApplied) {
                ctx.restore();
            }
            drawAntFollowHUD();

            requestAnimationFrame(animate);
        }
        
        // CYCLE 3: Mouse tracking for thought bubble visualization
        let mouseX = 0, mouseY = 0;
        canvas.onmousemove = e => {
            mouseX = e.clientX;
            mouseY = e.clientY;

            // Find closest ant to mouse for hover effect
            let closest = null;
            let closestDist = 30; // Within 30px

            for (const ant of ants) {
                const dist = Math.hypot(ant.x - mouseX, ant.y - mouseY);
                if (dist < closestDist) {
                    closestDist = dist;
                    closest = ant;
                }
            }

            hoveredAnt = closest;
        };

        canvas.onclick = e => {
            if (e.clientX < 200 && e.clientY < 280) return;

            const rect = canvas.getBoundingClientRect();
            const clickX = (e.clientX - rect.left) * (W / rect.width);
            const clickY = (e.clientY - rect.top) * (H / rect.height);

            // CYCLE 15: Observer Mode - click to follow ants
            // Adjust click position for camera offset if in observer mode
            const adjustedX = clickX - cameraOffset.x;
            const adjustedY = clickY - cameraOffset.y;
            if (selectAntToFollow(adjustedX, adjustedY)) {
                return; // Ant was selected, don't process other clicks
            }

            // CYCLE 11: Creative Mode Spawning
            if (creativeMode && spawnMode) {
                createUndoSnapshot();
                const mx = clickX;
                const my = clickY;

                if (spawnMode === 'ant') {
                    for (let i = 0; i < spawnQuantity; i++) {
                        ants.push(new Ant(mx + (Math.random() - 0.5) * 20, my + (Math.random() - 0.5) * 20));
                    }
                    showMilestone('Spawned', `${spawnQuantity} ant${spawnQuantity > 1 ? 's' : ''}`, 'üêú');
                } else if (spawnMode === 'food') {
                    const newFood = {
                        x: mx,
                        y: my,
                        amount: spawnQuantity * 100,
                        maxAmount: spawnQuantity * 100,
                        type: 'BASIC'
                    };
                    foodSources.push(newFood);
                    foodSpatialGrid.insert(newFood);
                    showMilestone('Spawned', `Food (${spawnQuantity * 100})`, 'üçØ');
                } else if (spawnMode === 'chamber') {
                    if (my > H * 0.15) {
                        chambers.push({
                            x: mx,
                            y: my,
                            radius: 20 + spawnQuantity * 2,
                            type: 'NEST',
                            waterLevel: 0,
                            fungusHealth: 1.0,
                            foodProduction: 0
                        });
                        showMilestone('Spawned', 'Chamber', 'üèõÔ∏è');
                    }
                }
                hapticFeedback(HAPTIC_PATTERNS.food);
                return;
            }

            if (placingFood) {
                const newFood = {
                    x: e.clientX,
                    y: e.clientY,
                    amount: 100,
                    maxAmount: 100,
                    type: 'BASIC' // CYCLE 4: Default to basic food
                };
                foodSources.push(newFood);
                foodSpatialGrid.insert(newFood); // CYCLE 4: Add to spatial grid
                placingFood = false;
                document.getElementById('food-btn').textContent = 'Place Food Source';
                canvas.style.cursor = 'default';
                // IMPROVEMENT #3: Haptic feedback for food placement
                hapticFeedback(HAPTIC_PATTERNS.food);
            }
            // CYCLE 4: Chamber placement
            else if (placingChamber) {
                // Check if underground (below surface level)
                if (e.clientY > H * 0.15) {
                    chambers.push({
                        x: e.clientX,
                        y: e.clientY,
                        radius: 20,
                        type: placingChamber,
                        waterLevel: 0,
                        fungusHealth: 1.0,
                        foodProduction: 0
                    });
                    hapticFeedback(HAPTIC_PATTERNS.milestone);
                    placingChamber = null;
                    canvas.style.cursor = 'default';
                }
            }
        };
        
        document.getElementById('size').oninput = e => {
            colonySize = parseInt(e.target.value);
            document.getElementById('size-val').textContent = e.target.value;
        };
        
        document.getElementById('speed').oninput = e => {
            digSpeed = e.target.value / 100;
            document.getElementById('speed-val').textContent = e.target.value;
        };
        
        document.getElementById('food-btn').onclick = () => {
            placingFood = !placingFood;
            document.getElementById('food-btn').textContent = placingFood ? 'Click to Place...' : 'Place Food Source';
        };
        
        document.getElementById('reset-btn').onclick = () => {
            // Reset expansion state
            worldScale = 1.0;
            targetScale = 1.0;
            totalExpansions = 0;
            exploredPercentage = 0;
            lastExpansionCheck = 0;

            // Reset queen and mortality state
            totalBirths = 0;
            totalDeaths = 0;

            // Reset weather with grace period
            weather.state = 'CLEAR';
            weather.stateTime = 0;
            weather.cycleDuration = 120; // Long initial clear period
            weather.floodLevel = 0;
            weather.particles = [];
            weather.gracePeriod = true; // Reset grace period
            weather.updateUI();

            initSoil();  // This creates a new queen
            initAnts();  // This also clears spatial grid and spawns starter food
            chambers.length = 1;
        };

        document.getElementById('export-btn').onclick = exportFarm;
        document.getElementById('import-btn').onclick = () => {
            document.getElementById('file-input').click();
        };
        document.getElementById('file-input').onchange = handleFileImport;
        document.getElementById('sound-btn').onclick = toggleAudio;

        // Pheromone trails visualization toggle
        document.getElementById('pheromone-btn').onclick = () => {
            showPheromones = !showPheromones;
            const btn = document.getElementById('pheromone-btn');
            btn.textContent = showPheromones ? 'üëÅ Trails ‚úì' : 'üëÅ Trails';
            btn.classList.toggle('active', showPheromones);
        };

        // CYCLE 3: Predator toggle (Challenge Mode)
        document.getElementById('predator-btn').onclick = () => {
            predatorsEnabled = !predatorsEnabled;
            const btn = document.getElementById('predator-btn');
            btn.textContent = predatorsEnabled ? 'üï∑Ô∏è Predators ‚úì' : 'üï∑Ô∏è Predators';
            btn.classList.toggle('active', predatorsEnabled);

            if (!predatorsEnabled) {
                predators.length = 0; // Remove all predators
            }
        };

        // CYCLE 8: Legacy & Achievements button
        document.getElementById('legacy-btn').onclick = () => {
            toggleLegacyPanel();
        };

        // CYCLE 3: Reset genetic lineage
        document.getElementById('reset-lineage-btn').onclick = () => {
            if (confirm('Reset genetic lineage to default? This will clear all inherited traits.')) {
                // Reset colony memory
                colonyMemory = {
                    roleSuccess: {
                        excavator: { totalLifespan: 0, count: 0 },
                        gatherer: { totalLifespan: 0, count: 0 },
                        nurse: { totalLifespan: 0, count: 0 }
                    },
                    bestForagingDepth: 0.5,
                    generation: 0,
                    successfulDeliveries: 0,
                    dangerZones: new Map()
                };

                // Reset all living ants to default genetics
                ants.forEach(ant => {
                    ant.inheritedForagingDepth = 0.5;
                    ant.inheritedDigEfficiency = 1.0;
                    ant.inheritedSpeedBonus = 0;
                });

                // Clear localStorage
                localStorage.removeItem('colonyGeneticMemory');

                alert('Genetic lineage reset! Future ants will have neutral traits.');
            }
        };

        // Bloom quality toggle
        document.getElementById('bloom-btn').onclick = () => {
            const qualities = ['auto', 'high', 'low', 'off'];
            const currentIndex = qualities.indexOf(bloomQuality);
            bloomQuality = qualities[(currentIndex + 1) % qualities.length];

            const btn = document.getElementById('bloom-btn');
            const label = bloomQuality.charAt(0).toUpperCase() + bloomQuality.slice(1);
            btn.textContent = `‚ú® ${label}`;

            // Update bloom state based on quality
            bloomEnabled = bloomQuality !== 'off';
            btn.classList.toggle('active', bloomEnabled);
        };

        // Pause button
        document.getElementById('pause-btn').onclick = () => {
            isPaused = !isPaused;
            const btn = document.getElementById('pause-btn');
            btn.innerHTML = isPaused
                ? '‚ñ∂ Resume <span class="kbd-hint">[Space]</span>'
                : '‚è∏ Pause <span class="kbd-hint">[Space]</span>';
            btn.classList.toggle('paused', isPaused);
        };

        // Speed control buttons
        document.querySelectorAll('.speed-btn').forEach(btn => {
            btn.onclick = () => {
                simulationSpeed = parseFloat(btn.dataset.speed);
                document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            };
        });

        // Settings toggle (collapsible advanced section)
        const settingsToggle = document.getElementById('settings-toggle');
        const settingsSection = document.getElementById('settings-section');
        if (settingsToggle && settingsSection) {
            settingsToggle.onclick = () => {
                const isVisible = settingsSection.classList.toggle('visible');
                settingsToggle.setAttribute('aria-expanded', isVisible.toString());
                settingsToggle.textContent = isVisible ? '‚öôÔ∏è Settings & Visuals ‚ñ≤' : '‚öôÔ∏è Settings & Visuals ‚ñº';
            };
        }

        // Minimize controls logic
        const controlsMinimize = document.getElementById('controls-minimize');
        const controlsPanel = document.getElementById('controls');
        if (controlsMinimize && controlsPanel) {
            controlsMinimize.onclick = () => {
                const isMinimized = controlsPanel.classList.toggle('minimized');
                controlsMinimize.textContent = isMinimized ? '+' : '‚àí';
                controlsMinimize.title = isMinimized ? 'Expand controls' : 'Minimize controls';
            };
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', e => {
            // Don't trigger if typing in an input
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

            switch(e.key.toLowerCase()) {
                case 'u': // U = toggle UI visibility
                    const uiElements = ['controls', 'stats', 'info', 'weather-indicator', 'fps-indicator', 'a11y-toolbar', 'achievement-tracker'];
                    uiElements.forEach(id => {
                        const el = document.getElementById(id);
                        if (el) el.classList.toggle('hidden');
                    });
                    break;
                case ' ': // Space = pause
                    e.preventDefault();
                    document.getElementById('pause-btn').click();
                    break;
                case 'f': // F = food mode
                    document.getElementById('food-btn').click();
                    break;
                case '1':
                    simulationSpeed = 0.5;
                    updateSpeedButtons();
                    break;
                case '2':
                    simulationSpeed = 1;
                    updateSpeedButtons();
                    break;
                case '3':
                    simulationSpeed = 2;
                    updateSpeedButtons();
                    break;
                case '4':
                    simulationSpeed = 4;
                    updateSpeedButtons();
                    break;
                case 'w': // W = cycle weather
                    weather.stateTime = weather.cycleDuration; // Force weather change
                    break;
                case 'p': // P = toggle pheromone trails
                    document.getElementById('pheromone-btn').click();
                    break;
                case 'b': // B = toggle bloom
                    document.getElementById('bloom-btn').click();
                    break;
                case 'h': // H = toggle predators (CYCLE 3)
                    document.getElementById('predator-btn').click();
                    break;
                case 'a': // A = toggle ambience mode (CYCLE 5)
                    ambienceMode = !ambienceMode;
                    if (ambienceMode) {
                        // Enter ambience mode - boost effects
                        if (bloomQuality === 'auto') bloomEnabled = true;
                        if (audioEnabled && audioNodes.masterGain) {
                            audioNodes.masterGain.gain.setTargetAtTime(0.25, audioCtx.currentTime, 0.5);
                        }
                    } else {
                        // Exit ambience mode - restore normal
                        if (audioEnabled && audioNodes.masterGain) {
                            audioNodes.masterGain.gain.setTargetAtTime(0.15, audioCtx.currentTime, 0.5);
                        }
                    }
                    break;
                case 'o': // O = toggle observer/follow mode (CYCLE 15)
                    if (observerModeEnabled) {
                        followedAnt = null;
                        observerModeEnabled = false;
                        cameraOffset = { x: 0, y: 0 };
                        showMilestone('Observer Mode', 'Camera released', false);
                    } else {
                        showMilestone('Observer Mode', 'Click any ant to follow', false);
                    }
                    break;
                case 'g': // G = place fungus garden (CYCLE 4)
                    if (CHAMBER_TYPES.FUNGUS_GARDEN.unlocked) {
                        placingChamber = placingChamber === 'FUNGUS_GARDEN' ? null : 'FUNGUS_GARDEN';
                        placingFood = false;
                        canvas.style.cursor = placingChamber ? 'crosshair' : 'default';
                    }
                    break;
                case 't': // T = place water tank/storage (CYCLE 4)
                    if (CHAMBER_TYPES.WATER_STORAGE.unlocked) {
                        placingChamber = placingChamber === 'WATER_STORAGE' ? null : 'WATER_STORAGE';
                        placingFood = false;
                        canvas.style.cursor = placingChamber ? 'crosshair' : 'default';
                    }
                    break;
                case 'escape': // ESC = cancel placement
                    placingChamber = null;
                    placingFood = false;
                    canvas.style.cursor = 'default';
                    break;
                case 'c': // C = toggle high contrast (CYCLE 6)
                    toggleHighContrast();
                    break;
                case '?': // ? = show help (CYCLE 6)
                    showScreenReaderHelp();
                    break;
            }
        });

        function updateSpeedButtons() {
            document.querySelectorAll('.speed-btn').forEach(btn => {
                btn.classList.toggle('active', parseFloat(btn.dataset.speed) === simulationSpeed);
            });
        }

        // ============ CYCLE 6: INITIALIZATION ============
        function initializeCycle6() {
            // Wire up accessibility toolbar
            document.getElementById('high-contrast-btn').addEventListener('click', toggleHighContrast);
            document.getElementById('screen-reader-help-btn').addEventListener('click', showScreenReaderHelp);

            // Show accessibility toolbar on Tab key (keyboard users)
            let tabPressed = false;
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Tab' && !tabPressed) {
                    tabPressed = true;
                    document.getElementById('a11y-toolbar').classList.add('visible');
                }
            });

            // Load saved high-contrast preference
            const savedHighContrast = localStorage.getItem('highContrastMode');
            if (savedHighContrast === 'true') {
                toggleHighContrast();
            }

            // Setup mobile controls if on mobile device
            if (isMobileDevice) {
                setupMobileControls();
            }

            // Attempt crash recovery
            attemptCrashRecovery();

            // Start auto-save system
            startAutoSave();

            // Update ARIA attributes on initial load
            document.getElementById('pause-btn').setAttribute('aria-pressed', isPaused.toString());
            document.getElementById('sound-btn').setAttribute('aria-pressed', audioEnabled.toString());
            document.getElementById('predator-btn').setAttribute('aria-pressed', predatorsEnabled.toString());
            document.getElementById('pheromone-btn').setAttribute('aria-pressed', showPheromones.toString());

            console.log('[CYCLE 6] Initialized: Auto-save, accessibility, mobile controls, performance monitoring');
            announceToScreenReader('Colony Mind initialized. Press H for help.');
        }

        // ============ CYCLE 7: PROFESSIONAL POLISH SYSTEMS ============

        // Tutorial System
        const tutorialSteps = [
            {
                text: "Welcome to Colony Mind! This is your <strong>Queen</strong> - the heart of your colony. Feed her to grow your population.",
                spotlight: '#stats'
            },
            {
                text: "Click anywhere to <strong>place food sources</strong>. Your ants will automatically gather and deliver food to the queen.",
                spotlight: '#food-btn'
            },
            {
                text: "Ants will <strong>specialize into roles</strong> as they gain experience: Workers, Excavators, Gatherers, and Nurses.",
                spotlight: '#stats'
            },
            {
                text: "<strong>Weather affects your colony.</strong> Watch the indicator at the top - rain floods tunnels, drought depletes food.",
                spotlight: '#weather-indicator'
            },
            {
                text: "Press <strong>H</strong> anytime for the full help guide. Your colony auto-saves every 30 seconds. Good luck!",
                spotlight: null
            }
        ];

        function initTutorial() {
            const completed = localStorage.getItem(TUTORIAL_COMPLETED_KEY);
            if (completed) return;

            const overlay = document.getElementById('tutorial-overlay');
            const textEl = document.getElementById('tutorial-text');
            const spotlight = document.getElementById('tutorial-spotlight');
            const nextBtn = document.getElementById('tutorial-next');
            const skipBtn = document.getElementById('tutorial-skip');
            const dots = document.querySelectorAll('.tutorial-dot');

            tutorialStep = 0;
            showTutorialStep();

            function showTutorialStep() {
                if (tutorialStep >= tutorialSteps.length) {
                    closeTutorial();
                    return;
                }

                const step = tutorialSteps[tutorialStep];
                textEl.innerHTML = step.text;

                // Update progress dots
                dots.forEach((dot, i) => {
                    dot.classList.toggle('active', i === tutorialStep);
                });

                // Update ARIA progressbar
                overlay.querySelector('.tutorial-progress').setAttribute('aria-valuenow', tutorialStep + 1);

                // Position spotlight
                if (step.spotlight) {
                    const target = document.querySelector(step.spotlight);
                    if (target) {
                        const rect = target.getBoundingClientRect();
                        spotlight.style.left = rect.left - 10 + 'px';
                        spotlight.style.top = rect.top - 10 + 'px';
                        spotlight.style.width = rect.width + 20 + 'px';
                        spotlight.style.height = rect.height + 20 + 'px';
                        spotlight.classList.add('active');
                    }
                } else {
                    spotlight.classList.remove('active');
                }

                nextBtn.textContent = tutorialStep === tutorialSteps.length - 1 ? 'Start' : 'Next';
            }

            function closeTutorial() {
                overlay.classList.remove('active');
                localStorage.setItem(TUTORIAL_COMPLETED_KEY, 'true');
                announceToScreenReader('Tutorial completed. Colony Mind is ready.');
            }

            nextBtn.onclick = () => {
                tutorialStep++;
                showTutorialStep();
            };

            skipBtn.onclick = closeTutorial;

            // Show tutorial after brief delay
            setTimeout(() => {
                overlay.classList.add('active');
                announceToScreenReader('Tutorial started. Press Escape to skip.');
            }, 1000);

            // ESC to skip
            document.addEventListener('keydown', function handleEscape(e) {
                if (e.key === 'Escape' && overlay.classList.contains('active')) {
                    closeTutorial();
                    document.removeEventListener('keydown', handleEscape);
                }
            });
        }

        // Help Panel System
        function initHelpPanel() {
            const panel = document.getElementById('help-panel');
            const closeBtn = document.getElementById('help-panel-close');

            closeBtn.onclick = () => toggleHelpPanel();

            // H key toggles help
            document.addEventListener('keydown', (e) => {
                if (e.key === 'h' || e.key === 'H') {
                    toggleHelpPanel();
                }
            });
        }

        function toggleHelpPanel() {
            const panel = document.getElementById('help-panel');
            helpPanelVisible = !helpPanelVisible;
            panel.classList.toggle('visible', helpPanelVisible);

            if (helpPanelVisible) {
                announceToScreenReader('Help panel opened');
                panel.querySelector('#help-panel-close').focus();
            } else {
                announceToScreenReader('Help panel closed');
            }
        }

        // Auto-Save Recovery System
        function initAutoSaveRecovery() {
            const lastSaveTime = localStorage.getItem(AUTOSAVE_TIMESTAMP_KEY);
            if (!lastSaveTime) return;

            const timeSinceLastSave = Date.now() - parseInt(lastSaveTime);
            if (timeSinceLastSave > AUTOSAVE_RECOVERY_TIMEOUT) return; // Too old

            try {
                const saveData = JSON.parse(localStorage.getItem(AUTOSAVE_KEY));
                if (!saveData || !saveData.ants || saveData.ants.length === 0) return;

                const banner = document.getElementById('autosave-recovery');
                const textEl = document.getElementById('autosave-recovery-text');
                const loadBtn = document.getElementById('autosave-recovery-load');
                const dismissBtn = document.getElementById('autosave-recovery-dismiss');

                const minutesAgo = Math.round(timeSinceLastSave / 60000);
                textEl.textContent = `Resume colony with ${saveData.ants.length} ants, generation ${saveData.geneticMemory?.generation || 0}? (${minutesAgo}m ago)`;

                loadBtn.addEventListener('click', () => {
                    importFarm(saveData);
                    banner.classList.remove('visible');
                    showMilestone('Colony Restored', `${saveData.ants.length} ants resumed`, false);
                    announceToScreenReader(`Auto-save loaded: ${saveData.ants.length} ants`);
                }, { once: true });

                dismissBtn.addEventListener('click', () => {
                    banner.classList.remove('visible');
                }, { once: true });

                // Show banner after brief delay
                setTimeout(() => {
                    if (banner) banner.classList.add('visible');
                }, 2000);

                // Auto-dismiss after 15 seconds
                setTimeout(() => {
                    if (banner) banner.classList.remove('visible');
                }, 17000);

            } catch (err) {
                console.error('[CYCLE 7] Auto-save recovery failed:', err);
            }
        }

        // Button Ripple Effect System
        function initButtonFeedback() {
            document.querySelectorAll('button').forEach(button => {
                button.addEventListener('click', function(e) {
                    const ripple = document.createElement('span');
                    ripple.classList.add('ripple-effect');

                    const rect = this.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    ripple.style.left = x + 'px';
                    ripple.style.top = y + 'px';

                    this.appendChild(ripple);

                    setTimeout(() => ripple.remove(), 600);

                    // Play button click sound
                    playButtonSound();
                });
            });
        }

        function playButtonSound() {
            if (!audioCtx) return;

            const osc = audioCtx.createOscillator();
            osc.type = 'sine';
            osc.frequency.value = 800;

            const gain = audioCtx.createGain();
            gain.gain.value = 0.02;

            osc.connect(gain);
            gain.connect(audioCtx.destination);

            const now = audioCtx.currentTime;
            gain.gain.setValueAtTime(0.02, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);

            osc.start(now);
            osc.stop(now + 0.08);
        }

        // Tooltip System
        function initTooltips() {
            const tooltip = document.getElementById('global-tooltip');
            const tooltipMap = {
                'food-btn': 'Click on canvas to place food sources for your ants',
                'reset-btn': 'Start a new colony from scratch',
                'export-btn': 'Download your colony as a JSON file',
                'import-btn': 'Load a previously exported colony',
                'pause-btn': 'Pause or resume the simulation',
                'sound-btn': 'Toggle ambient soundscape',
                'pheromone-btn': 'Show/hide pheromone trail visualization',
                'bloom-btn': 'Adjust visual bloom quality (auto/high/low/off)',
                'predator-btn': 'Enable predator challenge mode',
                'high-contrast-btn': 'Toggle high contrast mode for accessibility'
            };

            document.querySelectorAll('button').forEach(btn => {
                const tooltipText = tooltipMap[btn.id];
                if (!tooltipText) return;

                btn.addEventListener('mouseenter', (e) => {
                    tooltip.textContent = tooltipText;
                    const rect = btn.getBoundingClientRect();
                    tooltip.style.left = rect.left + rect.width / 2 + 'px';
                    tooltip.style.top = rect.bottom + 8 + 'px';
                    tooltip.style.transform = 'translateX(-50%)';
                    setTimeout(() => tooltip.classList.add('visible'), 10);
                });

                btn.addEventListener('mouseleave', () => {
                    tooltip.classList.remove('visible');
                });
            });
        }

        // ============ CYCLE 15: PRESTIGE & META-PROGRESSION FUNCTIONS ============

        // Prestige Manager Class
        class PrestigeManager {
            static loadPrestigeData() {
                try {
                    const saved = localStorage.getItem(PRESTIGE_SAVE_KEY);
                    if (saved) {
                        const loaded = JSON.parse(saved);
                        // Merge with defaults to handle version updates
                        prestigeData = Object.assign({}, prestigeData, loaded);

                        // Ensure upgrades object exists with all properties
                        if (!prestigeData.upgrades) prestigeData.upgrades = {};
                        const defaultUpgrades = {
                            startingFood: 0, queenBirthRate: 0, excavationSpeed: 0,
                            gatheringEfficiency: 0, startingChambers: 0, pheromonePersistence: 0,
                            weatherResistance: 0, antLongevity: 0
                        };
                        prestigeData.upgrades = Object.assign({}, defaultUpgrades, prestigeData.upgrades);

                        console.log(`[CYCLE 15] Loaded prestige data: ${prestigeData.prestigePoints} PP, ${prestigeData.totalResets} resets`);
                        return true;
                    }
                } catch (err) {
                    console.error('[CYCLE 15] Failed to load prestige data:', err);
                }
                return false;
            }

            static savePrestigeData() {
                try {
                    localStorage.setItem(PRESTIGE_SAVE_KEY, JSON.stringify(prestigeData));
                    console.log('[CYCLE 15] Prestige data saved successfully');
                    return true;
                } catch (err) {
                    console.error('[CYCLE 15] Failed to save prestige data:', err);
                    return false;
                }
            }

            static calculateCurrentPrestige() {
                const survivalMinutes = (Date.now() - colonyStartTime) / 60000;
                const difficultyMult = currentChallengeMode === 'disaster' ? 1.5 : currentChallengeMode === 'speedrun' ? 1.3 : 1.0;
                return PRESTIGE_FORMULAS.calculatePrestigePoints(
                    currentColonyPeakPopulation,
                    survivalMinutes,
                    difficultyMult,
                    unlockedAchievements.size
                );
            }

            static getUpgradeMultiplier(upgradeName) {
                const level = prestigeData.upgrades[upgradeName] || 0;
                return 1 + PRESTIGE_FORMULAS.getUpgradeBonus(level);
            }

            static canAffordUpgrade(upgradeName) {
                const currentLevel = prestigeData.upgrades[upgradeName] || 0;
                const cost = PRESTIGE_FORMULAS.getUpgradeCost(currentLevel);
                return prestigeData.prestigePoints >= cost;
            }

            static purchaseUpgrade(upgradeName) {
                const currentLevel = prestigeData.upgrades[upgradeName] || 0;
                const cost = PRESTIGE_FORMULAS.getUpgradeCost(currentLevel);

                if (prestigeData.prestigePoints >= cost) {
                    prestigeData.prestigePoints -= cost;
                    prestigeData.upgrades[upgradeName]++;
                    this.savePrestigeData();
                    updateAscensionPanel();
                    showMilestone('Upgrade Purchased!', `${upgradeName} level ${prestigeData.upgrades[upgradeName]}`, '‚¨ÜÔ∏è');
                    return true;
                }
                return false;
            }

            static updateLifetimeStats() {
                // Update lifetime stats from current colony
                prestigeData.lifetimeStats.totalPopulation = Math.max(prestigeData.lifetimeStats.totalPopulation, currentColonyPeakPopulation);
                prestigeData.lifetimeStats.totalSurvivalTime += (Date.now() - colonyStartTime) / 60000;
                prestigeData.lifetimeStats.totalDeaths += totalDeaths;
                prestigeData.lifetimeStats.totalBirths += totalBirths;
                prestigeData.lifetimeStats.totalFood += queenFed;
                prestigeData.lifetimeStats.totalDepthDug += countTunnelLength();

                if (typeof predatorsDefeated !== 'undefined') {
                    prestigeData.lifetimeStats.totalPredatorsDefeated += predatorsDefeated;
                }
                if (typeof disastersSurvived !== 'undefined') {
                    prestigeData.lifetimeStats.totalDisastersSurvived += disastersSurvived;
                }

                // Count legends
                const legendsData = loadLegendsData();
                if (legendsData && legendsData.legends) {
                    prestigeData.lifetimeStats.totalLegends = legendsData.legends.length;
                }
            }

            static checkAndAwardTitles() {
                let newTitlesAwarded = false;
                for (const [id, title] of Object.entries(PRESTIGE_TITLES)) {
                    if (!prestigeData.titles.includes(id) && title.check()) {
                        prestigeData.titles.push(id);
                        showMilestone(`Title Earned: ${title.name}`, title.requirement, title.icon);
                        newTitlesAwarded = true;
                    }
                }
                if (newTitlesAwarded) {
                    this.savePrestigeData();
                }
            }

            static performPrestigeReset() {
                // Calculate prestige points to award
                const earnedPP = this.calculateCurrentPrestige();

                // Update lifetime stats one last time
                this.updateLifetimeStats();

                // Award prestige points
                prestigeData.prestigePoints += earnedPP;
                prestigeData.totalResets++;
                prestigeData.lastResetDate = Date.now();
                prestigeData.firstResetCompleted = true;

                // Check for new titles
                this.checkAndAwardTitles();

                // Save prestige data
                this.savePrestigeData();

                // Show ascension animation
                showAscensionAnimation(earnedPP);

                // Reset colony after animation
                setTimeout(() => {
                    resetColonyWithPrestigeBonuses();
                }, 3000);
            }
        }

        function showAscensionAnimation(ppEarned) {
            // Create custom ascension overlay
            const overlay = document.createElement('div');
            overlay.id = 'ascension-animation';
            overlay.style.cssText = `
                position: fixed;
                inset: 0;
                background: linear-gradient(180deg, rgba(0,0,0,0.95) 0%, rgba(26,21,16,0.98) 100%);
                z-index: 3000;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                animation: fadeIn 1s ease-out;
            `;

            overlay.innerHTML = `
                <div style="text-align: center; color: #ffd700; animation: slideDown 1.5s ease-out;">
                    <div style="font-size: 72px; margin-bottom: 20px;">‚ú®</div>
                    <div style="font-size: 36px; font-weight: bold; margin-bottom: 10px;">ASCENSION</div>
                    <div style="font-size: 24px; color: #d0a070; margin-bottom: 30px;">Your colony's legacy lives on</div>
                    <div style="font-size: 48px; color: #fff; font-weight: bold; margin: 20px 0;">+${ppEarned} Prestige Points</div>
                    <div style="font-size: 16px; color: #a09070; margin-top: 20px;">Total: ${prestigeData.prestigePoints} PP | Resets: ${prestigeData.totalResets}</div>
                </div>
            `;

            document.body.appendChild(overlay);

            // Remove after 3 seconds
            setTimeout(() => {
                overlay.style.animation = 'fadeOut 1s ease-out';
                setTimeout(() => overlay.remove(), 1000);
            }, 2000);
        }

        function resetColonyWithPrestigeBonuses() {
            // Clear localStorage autosave (but keep prestige data)
            localStorage.removeItem(AUTOSAVE_KEY);
            localStorage.removeItem(AUTOSAVE_TIMESTAMP_KEY);

            // Reload page to reset colony
            location.reload();
        }

        function toggleAscensionPanel() {
            ascensionPanelVisible = !ascensionPanelVisible;
            const panel = document.getElementById('ascension-panel');
            if (panel) {
                panel.classList.toggle('visible', ascensionPanelVisible);
                if (ascensionPanelVisible) {
                    updateAscensionPanel();
                }
            }
        }

        function updateAscensionPanel() {
            // Update prestige points display
            const ppDisplay = document.getElementById('prestige-points-display');
            if (ppDisplay) {
                ppDisplay.textContent = prestigeData.prestigePoints;
            }

            // Update prestige preview
            const preview = document.getElementById('prestige-preview');
            if (preview) {
                const earnedPP = PrestigeManager.calculateCurrentPrestige();
                preview.textContent = earnedPP;
            }

            // Update upgrade buttons
            const upgradeNames = Object.keys(prestigeData.upgrades);
            upgradeNames.forEach(upgradeName => {
                const btn = document.getElementById(`upgrade-${upgradeName}`);
                if (btn) {
                    const level = prestigeData.upgrades[upgradeName];
                    const cost = PRESTIGE_FORMULAS.getUpgradeCost(level);
                    const canAfford = PrestigeManager.canAffordUpgrade(upgradeName);

                    btn.disabled = !canAfford;
                    btn.style.opacity = canAfford ? '1' : '0.5';

                    const costSpan = btn.querySelector('.upgrade-cost');
                    if (costSpan) costSpan.textContent = cost;

                    const levelSpan = btn.querySelector('.upgrade-level');
                    if (levelSpan) levelSpan.textContent = level;
                }
            });

            // Update titles display
            updateTitlesDisplay();
        }

        function updateTitlesDisplay() {
            const container = document.getElementById('titles-container');
            if (!container) return;

            container.innerHTML = '';

            for (const [id, title] of Object.entries(PRESTIGE_TITLES)) {
                const earned = prestigeData.titles.includes(id);
                const div = document.createElement('div');
                div.className = 'title-card';
                div.style.cssText = `
                    padding: 12px;
                    margin: 8px 0;
                    background: ${earned ? 'rgba(255,215,0,0.2)' : 'rgba(60,50,40,0.3)'};
                    border: 1px solid ${earned ? 'rgba(255,215,0,0.5)' : 'rgba(100,80,60,0.3)'};
                    border-radius: 6px;
                    opacity: ${earned ? '1' : '0.6'};
                `;

                div.innerHTML = `
                    <div style="font-size: 18px; margin-bottom: 4px;">${title.icon} ${title.name}</div>
                    <div style="font-size: 11px; color: #a09070;">${title.requirement}</div>
                    ${earned ? '<div style="font-size: 10px; color: #ffd700; margin-top: 4px;">‚úì EARNED</div>' : ''}
                `;

                container.appendChild(div);
            }
        }

        function applyPrestigeBonuses() {
            // This function is called during colony initialization
            // Bonuses are applied via PrestigeManager.getUpgradeMultiplier() in relevant systems
            console.log('[CYCLE 15] Applying prestige bonuses...');

            // Starting food bonus
            const foodBonus = PrestigeManager.getUpgradeMultiplier('startingFood');
            food.forEach(f => f.amount *= foodBonus);

            // Starting chambers bonus
            const chamberBonus = prestigeData.upgrades.startingChambers || 0;
            for (let i = 0; i < chamberBonus; i++) {
                chambers.push({
                    x: W / 2 + (Math.random() - 0.5) * 100,
                    y: H * 0.2 + Math.random() * 50,
                    radius: 30,
                    type: 'NEST',
                    waterLevel: 0,
                    fungusHealth: 1.0,
                    foodProduction: 0
                });
            }

            console.log(`[CYCLE 15] Bonuses: Food x${foodBonus.toFixed(2)}, +${chamberBonus} chambers`);
        }

        // ============ CYCLE 8: SECRETS & SURPRISES FUNCTIONS ============

        // ===== FEATURE 1: UNDERGROUND CHAMBERS & ANCIENT ARTIFACTS =====
        function generateUndergroundChambers() {
            undergroundChambers.length = 0;

            const chamberTypes = [
                {
                    type: 'crystal',
                    name: 'Crystal Cave',
                    color: [150, 200, 255],
                    achievement: 'crystal_cave',
                    glowColor: 'rgba(150, 200, 255, 0.3)',
                    artifactChance: 0.3
                },
                {
                    type: 'fossil',
                    name: 'Fossil Layer',
                    color: [200, 180, 140],
                    achievement: 'fossil_finder',
                    glowColor: 'rgba(200, 180, 140, 0.2)',
                    artifactChance: 0.5
                },
                {
                    type: 'fungus',
                    name: 'Mushroom Grotto',
                    color: [100, 255, 150],
                    achievement: 'mushroom_grotto',
                    glowColor: 'rgba(100, 255, 150, 0.4)',
                    artifactChance: 0.1
                }
            ];

            // Generate 2-4 chambers in deep layers
            const numChambers = 2 + Math.floor(Math.random() * 3);
            const cols = soilGrid[0]?.length || 0;
            const rows = soilGrid.length || 0;

            for (let i = 0; i < numChambers; i++) {
                const chamberType = chamberTypes[Math.floor(Math.random() * chamberTypes.length)];
                const chamber = {
                    ...chamberType,
                    x: Math.floor(cols * 0.2 + Math.random() * cols * 0.6),
                    y: Math.floor(rows * 0.5 + Math.random() * rows * 0.3), // Deep underground
                    radius: 8 + Math.floor(Math.random() * 6),
                    discovered: false,
                    particles: []
                };
                undergroundChambers.push(chamber);
            }
        }

        function checkChamberDiscovery() {
            const cols = soilGrid[0]?.length || 0;

            for (const chamber of undergroundChambers) {
                if (chamber.discovered) continue;

                // Check if ants are digging near chamber
                const chamberWorldX = chamber.x * SOIL_RESOLUTION;
                const chamberWorldY = chamber.y * SOIL_RESOLUTION;

                const nearbyAnts = antSpatialGrid.getNearby(chamberWorldX, chamberWorldY, chamber.radius * SOIL_RESOLUTION * 2);
                if (nearbyAnts.length === 0) continue;

                // Check if soil around chamber is excavated
                const excavatedCount = checkExcavatedAroundChamber(chamber);
                if (excavatedCount > chamber.radius * 4) { // Threshold for discovery
                    chamber.discovered = true;
                    showMilestone(`${chamber.name} Discovered!`, 'A hidden wonder revealed', true);
                    unlockAchievement(chamber.achievement);

                    // Spawn celebration particles
                    for (let i = 0; i < 30; i++) {
                        celebrationParticles.push(new CelebrationParticle(chamberWorldX, chamberWorldY));
                    }

                    // Chance for ancient artifact
                    if (Math.random() < chamber.artifactChance && !artifactsFound.has(chamber.type)) {
                        artifactsFound.add(chamber.type);
                        unlockAchievement('ancient_artifact');
                        showMilestone('Ancient Artifact Found!', `A mysterious ${chamber.type} relic`, true);

                        // Permanent bonus based on artifact
                        if (chamber.type === 'crystal') {
                            // +15% speed for all ants
                            for (const ant of ants) {
                                ant.speed *= 1.15;
                            }
                        } else if (chamber.type === 'fossil') {
                            // +20% dig speed
                            digSpeed *= 1.2;
                        }
                    }
                }
            }
        }

        function checkExcavatedAroundChamber(chamber) {
            let excavatedCount = 0;
            const checkRadius = Math.ceil(chamber.radius * 1.5);

            for (let dy = -checkRadius; dy <= checkRadius; dy++) {
                for (let dx = -checkRadius; dx <= checkRadius; dx++) {
                    const gx = chamber.x + dx;
                    const gy = chamber.y + dy;
                    if (gx >= 0 && gx < soilGrid[0]?.length && gy >= 0 && gy < soilGrid.length) {
                        if (soilGrid[gy][gx] === 0) excavatedCount++;
                    }
                }
            }
            return excavatedCount;
        }

        function renderUndergroundChambers() {
            for (const chamber of undergroundChambers) {
                if (!chamber.discovered) continue;

                const cx = chamber.x * SOIL_RESOLUTION;
                const cy = chamber.y * SOIL_RESOLUTION;
                const radius = chamber.radius * SOIL_RESOLUTION;

                // Draw chamber glow
                const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, radius * 1.5);
                gradient.addColorStop(0, chamber.glowColor);
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.fillRect(cx - radius * 1.5, cy - radius * 1.5, radius * 3, radius * 3);

                // Draw chamber particles (crystals, fungi, fossils)
                if (chamber.type === 'crystal') {
                    renderCrystalChamber(cx, cy, chamber.radius);
                } else if (chamber.type === 'fungus') {
                    renderFungusChamber(cx, cy, chamber.radius);
                } else if (chamber.type === 'fossil') {
                    renderFossilChamber(cx, cy, chamber.radius);
                }
            }
        }

        function renderCrystalChamber(cx, cy, radius) {
            ctx.save();
            const numCrystals = 8;
            for (let i = 0; i < numCrystals; i++) {
                const angle = (i / numCrystals) * Math.PI * 2 + time * 0.1;
                const dist = radius * SOIL_RESOLUTION * 0.7;
                const x = cx + Math.cos(angle) * dist;
                const y = cy + Math.sin(angle) * dist;

                ctx.fillStyle = `rgba(150, 200, 255, ${0.6 + Math.sin(time * 3 + i) * 0.2})`;
                ctx.beginPath();
                ctx.moveTo(x, y - 8);
                ctx.lineTo(x + 4, y + 8);
                ctx.lineTo(x - 4, y + 8);
                ctx.closePath();
                ctx.fill();
            }
            ctx.restore();
        }

        function renderFungusChamber(cx, cy, radius) {
            ctx.save();
            const numMushrooms = 12;
            for (let i = 0; i < numMushrooms; i++) {
                const angle = (i / numMushrooms) * Math.PI * 2;
                const dist = (radius * SOIL_RESOLUTION * 0.5) + Math.sin(time * 2 + i) * 5;
                const x = cx + Math.cos(angle) * dist;
                const y = cy + Math.sin(angle) * dist;

                // Bioluminescent glow pulse
                const pulseSize = 3 + Math.sin(time * 4 + i * 0.5) * 1.5;
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, pulseSize * 3);
                gradient.addColorStop(0, 'rgba(100, 255, 150, 0.6)');
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, pulseSize * 3, 0, Math.PI * 2);
                ctx.fill();

                // Mushroom cap
                ctx.fillStyle = `rgba(100, 255, 150, 0.8)`;
                ctx.beginPath();
                ctx.arc(x, y, pulseSize, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }

        function renderFossilChamber(cx, cy, radius) {
            ctx.save();
            ctx.strokeStyle = 'rgba(200, 180, 140, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            // Draw fossil bone structure
            const segments = 6;
            for (let i = 0; i < segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const x = cx + Math.cos(angle) * radius * SOIL_RESOLUTION * 0.6;
                const y = cy + Math.sin(angle) * radius * SOIL_RESOLUTION * 0.6;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.stroke();
            ctx.restore();
        }

        // ===== FEATURE 2: COLONY LEGACY SYSTEM =====
        function initColonyLegacy() {
            loadLegacyData();
            loadAchievements();
            updateLegacyUI();
            setupLegacyPanel();
        }

        function setupLegacyPanel() {
            const closeBtn = document.getElementById('legacy-panel-close');
            closeBtn.addEventListener('click', toggleLegacyPanel);

            // Add keyboard shortcut: L for Legacy
            document.addEventListener('keydown', (e) => {
                if (e.key === 'l' || e.key === 'L') {
                    if (!tutorialStep && !helpPanelVisible) { // Don't interfere with tutorial/help
                        toggleLegacyPanel();
                    }
                }
            });
        }

        function toggleLegacyPanel() {
            const panel = document.getElementById('legacy-panel');
            legacyPanelVisible = !legacyPanelVisible;
            panel.classList.toggle('visible', legacyPanelVisible);

            if (legacyPanelVisible) {
                updateLegacyUI();
                announceToScreenReader('Colony legacy panel opened');
            } else {
                announceToScreenReader('Colony legacy panel closed');
            }
        }

        function loadLegacyData() {
            try {
                const data = localStorage.getItem(LEGACY_DATA_KEY);
                if (data) {
                    const legacy = JSON.parse(data);
                    return legacy;
                }
            } catch (err) {
                console.error('[CYCLE 8] Failed to load legacy data:', err);
            }
            return {
                totalColonies: 0,
                totalBirths: 0,
                totalFood: 0,
                deepestDepth: 0,
                longestColony: 0
            };
        }

        function loadAchievements() {
            try {
                const data = localStorage.getItem(ACHIEVEMENTS_KEY);
                if (data) {
                    const unlocked = JSON.parse(data);
                    unlockedAchievements = new Set(unlocked);
                    updateAchievementTracker();
                }
            } catch (err) {
                console.error('[CYCLE 8] Failed to load achievements:', err);
            }
        }

        function unlockAchievement(achievementId) {
            if (unlockedAchievements.has(achievementId)) return;

            unlockedAchievements.add(achievementId);
            saveAchievements();
            updateAchievementTracker();

            const achievement = ACHIEVEMENTS[achievementId];
            if (achievement) {
                showAchievementToast(achievement);
                hapticFeedback(HAPTIC_PATTERNS.milestone);
            }

            // Check meta-achievements
            if (unlockedAchievements.size >= 10 && !unlockedAchievements.has('collector')) {
                setTimeout(() => unlockAchievement('collector'), 1000);
            }
            if (unlockedAchievements.size >= Object.keys(ACHIEVEMENTS).length && !unlockedAchievements.has('completionist')) {
                setTimeout(() => unlockAchievement('completionist'), 1500);
            }
        }

        function saveAchievements() {
            try {
                localStorage.setItem(ACHIEVEMENTS_KEY, JSON.stringify([...unlockedAchievements]));
            } catch (err) {
                console.error('[CYCLE 8] Failed to save achievements:', err);
            }
        }

        function showAchievementToast(achievement) {
            const toast = document.getElementById('achievement-toast');
            const iconEl = document.getElementById('achievement-toast-icon');
            const titleEl = document.getElementById('achievement-toast-title');
            const descEl = document.getElementById('achievement-toast-desc');

            iconEl.textContent = achievement.icon;
            titleEl.textContent = achievement.name;
            descEl.textContent = achievement.desc;

            toast.classList.add('show');
            announceToScreenReader(`Achievement unlocked: ${achievement.name}`);

            setTimeout(() => {
                toast.classList.remove('show');
            }, 4000);
        }

        function updateAchievementTracker() {
            const tracker = document.getElementById('achievement-tracker');
            const progress = document.getElementById('achievement-progress');
            const total = Object.keys(ACHIEVEMENTS).length;
            const unlocked = unlockedAchievements.size;

            progress.textContent = `${unlocked} / ${total}`;

            // Show tracker when achievements start unlocking
            if (unlocked > 0) {
                tracker.classList.add('visible');
            }
        }

        function updateLegacyUI() {
            const legacy = loadLegacyData();

            document.getElementById('legacy-colonies').textContent = legacy.totalColonies || 0;
            document.getElementById('legacy-births').textContent = legacy.totalBirths || 0;
            document.getElementById('legacy-food').textContent = legacy.totalFood || 0;
            document.getElementById('legacy-depth').textContent = Math.round(legacy.deepestDepth || 0) + 'm';
            document.getElementById('legacy-longevity').textContent = Math.round((legacy.longestColony || 0) / 60) + ' min';

            updateHallOfFame();
            updateAchievementsList();
        }

        function updateHallOfFame() {
            try {
                const data = localStorage.getItem(HALL_OF_FAME_KEY);
                const hallOfFame = data ? JSON.parse(data) : [];
                const listEl = document.getElementById('hall-of-fame-list');

                if (hallOfFame.length === 0) {
                    listEl.innerHTML = '<p style="font-size: 12px; opacity: 0.7; text-align: center; padding: 20px;">No legendary colonies yet.<br>Reach 200 ants to immortalize your colony!</p>';
                    return;
                }

                listEl.innerHTML = hallOfFame.map((colony, index) => `
                    <div class="hall-of-fame-entry">
                        <div class="hall-of-fame-name">#${index + 1} - ${colony.name || 'Unnamed Colony'}</div>
                        <div class="hall-of-fame-stats">
                            üëë ${colony.population} ants | üèõÔ∏è Gen ${colony.generation} | ‚è±Ô∏è ${Math.round(colony.survivalTime / 60)}min
                        </div>
                    </div>
                `).join('');
            } catch (err) {
                console.error('[CYCLE 8] Failed to update hall of fame:', err);
            }
        }

        function updateAchievementsList() {
            const listEl = document.getElementById('legacy-achievements');
            const unlockedList = [...unlockedAchievements].map(id => {
                const ach = ACHIEVEMENTS[id];
                return `<div style="margin: 6px 0; font-size: 12px;">
                    <span style="font-size: 16px; margin-right: 6px;">${ach.icon}</span>
                    <strong>${ach.name}</strong> - ${ach.desc}
                </div>`;
            }).join('');

            if (unlockedList) {
                listEl.innerHTML = unlockedList;
            }
        }

        function immortalizeColony() {
            if (ants.length < 200) return; // Must have significant colony

            try {
                const data = localStorage.getItem(HALL_OF_FAME_KEY);
                const hallOfFame = data ? JSON.parse(data) : [];

                const colonyData = {
                    name: `Colony ${hallOfFame.length + 1}`,
                    population: ants.length,
                    generation: geneticMemory?.generation || 0,
                    survivalTime: (Date.now() - colonyStartTime) / 1000,
                    timestamp: Date.now()
                };

                hallOfFame.push(colonyData);
                hallOfFame.sort((a, b) => b.population - a.population);
                hallOfFame.splice(5); // Keep top 5

                localStorage.setItem(HALL_OF_FAME_KEY, JSON.stringify(hallOfFame));

                // Update legacy stats
                const legacy = loadLegacyData();
                legacy.totalColonies = (legacy.totalColonies || 0) + 1;
                legacy.totalBirths = (legacy.totalBirths || 0) + totalBirths;
                legacy.totalFood = (legacy.totalFood || 0) + (queen?.foodReceived || 0);

                const currentDepth = Math.max(...ants.map(a => a.y)) / SOIL_RESOLUTION;
                if (currentDepth > (legacy.deepestDepth || 0)) {
                    legacy.deepestDepth = currentDepth;
                }

                const survivalTime = (Date.now() - colonyStartTime) / 1000;
                if (survivalTime > (legacy.longestColony || 0)) {
                    legacy.longestColony = survivalTime;
                }

                localStorage.setItem(LEGACY_DATA_KEY, JSON.stringify(legacy));

                // Achievement check
                if (legacy.totalColonies >= 3) {
                    unlockAchievement('legacy_builder');
                }

                showMilestone('Colony Immortalized!', `${ants.length} ants preserved in history`, true);
            } catch (err) {
                console.error('[CYCLE 8] Failed to immortalize colony:', err);
            }
        }

        // ===== FEATURE 3: RARE CELESTIAL EVENTS =====
        function checkCelestialEvents() {
            const now = time;
            if (now - lastCelestialCheck < 60) return; // Check every 60 seconds
            lastCelestialCheck = now;

            // Aurora Borealis (3% chance during clear nights)
            if (!celestialEventActive && weather.state === 'CLEAR' && !dayNightCycle.isDaytime() && Math.random() < 0.03) {
                celestialEventActive = 'aurora';
                unlockAchievement('aurora_witness');
                showMilestone('Aurora Borealis!', 'The northern lights shimmer above', true);
                setTimeout(() => { celestialEventActive = null; }, 45000); // 45 seconds
            }

            // Solar Eclipse (2% chance during daytime)
            else if (!celestialEventActive && dayNightCycle.isDaytime() && Math.random() < 0.02) {
                celestialEventActive = 'eclipse';
                unlockAchievement('eclipse_touched');
                showMilestone('Solar Eclipse!', 'All ants move with supernatural speed', true);

                // Buff all ants for 30 seconds
                const originalSpeeds = new Map();
                for (const ant of ants) {
                    originalSpeeds.set(ant, ant.speed);
                    ant.speed *= 2;
                }

                setTimeout(() => {
                    celestialEventActive = null;
                    for (const ant of ants) {
                        if (originalSpeeds.has(ant)) {
                            ant.speed = originalSpeeds.get(ant);
                        }
                    }
                }, 30000);
            }

            // Meteor Strike (0.5% chance, any time)
            else if (!celestialEventActive && Math.random() < 0.005) {
                triggerMeteorStrike();
            }
        }

        function triggerMeteorStrike() {
            celestialEventActive = 'meteor';
            unlockAchievement('meteor_strike');

            // Random impact location
            const meteorX = W * (0.3 + Math.random() * 0.4);
            const meteorY = H * (0.4 + Math.random() * 0.3);

            showMilestone('Meteor Strike!', 'A celestial visitor carves a new path', true);

            // Create explosion - instantly excavate circular area
            const impactRadius = 30;
            const cols = soilGrid[0]?.length || 0;
            const rows = soilGrid.length || 0;

            for (let dy = -impactRadius; dy <= impactRadius; dy++) {
                for (let dx = -impactRadius; dx <= impactRadius; dx++) {
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= impactRadius) {
                        const gx = Math.floor(meteorX / SOIL_RESOLUTION) + dx;
                        const gy = Math.floor(meteorY / SOIL_RESOLUTION) + dy;

                        if (gx >= 0 && gx < cols && gy >= 0 && gy < rows) {
                            soilGrid[gy][gx] = 0; // Excavate
                        }
                    }
                }
            }

            // Spawn massive celebration particles
            for (let i = 0; i < 100; i++) {
                celebrationParticles.push(new CelebrationParticle(meteorX, meteorY));
            }

            // Chance for rare protein food source at impact
            if (Math.random() < 0.5) {
                const newFood = {
                    x: meteorX,
                    y: meteorY,
                    amount: 80,
                    type: 'PROTEIN',
                    ...FOOD_TYPES.PROTEIN
                };
                foodSources.push(newFood);
                foodSpatialGrid.add(newFood);
                unlockAchievement('ancient_artifact');
            }

            hapticFeedback(HAPTIC_PATTERNS.expansion);

            setTimeout(() => {
                celestialEventActive = null;
            }, 10000);
        }

        function renderCelestialEvents() {
            if (!celestialEventActive) return;

            if (celestialEventActive === 'aurora') {
                renderAuroraBorealis();
            } else if (celestialEventActive === 'eclipse') {
                renderSolarEclipse();
            } else if (celestialEventActive === 'meteor') {
                renderMeteorStrike();
            }
        }

        function renderAuroraBorealis() {
            ctx.save();
            const waves = 5;
            for (let i = 0; i < waves; i++) {
                const gradient = ctx.createLinearGradient(0, H * 0.1 + i * 30, 0, H * 0.4 + i * 30);
                const hue1 = (time * 20 + i * 60) % 360;
                const hue2 = (time * 20 + i * 60 + 120) % 360;

                gradient.addColorStop(0, `hsla(${hue1}, 70%, 60%, 0.15)`);
                gradient.addColorStop(0.5, `hsla(${hue2}, 70%, 60%, 0.25)`);
                gradient.addColorStop(1, `hsla(${hue1}, 70%, 60%, 0.1)`);

                ctx.fillStyle = gradient;
                ctx.beginPath();
                for (let x = 0; x <= W; x += 10) {
                    const wave = Math.sin(x * 0.01 + time * 2 + i) * 30;
                    const y = H * 0.2 + i * 25 + wave;
                    if (x === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.lineTo(W, H * 0.6);
                ctx.lineTo(0, H * 0.6);
                ctx.closePath();
                ctx.fill();
            }
            ctx.restore();
        }

        function renderSolarEclipse() {
            ctx.save();
            // Darken sky
            ctx.fillStyle = 'rgba(0, 0, 20, 0.4)';
            ctx.fillRect(0, 0, W, H * 0.3);

            // Draw eclipse corona
            const eclipseCenterX = W * 0.7;
            const eclipseCenterY = H * 0.15;
            const gradient = ctx.createRadialGradient(eclipseCenterX, eclipseCenterY, 15, eclipseCenterX, eclipseCenterY, 40);
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0.9)');
            gradient.addColorStop(0.8, 'rgba(255, 200, 100, 0.6)');
            gradient.addColorStop(1, 'transparent');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(eclipseCenterX, eclipseCenterY, 40, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        function renderMeteorStrike() {
            // Visual handled by celebration particles
        }

        // ===== FEATURE 4: ANT MEMORY & NAMING SYSTEM =====
        function generateAntMemory(ant) {
            const memories = [
                'Found food here before...',
                'This tunnel feels familiar',
                'Sister worked here once',
                'The queen called to me',
                'Digging brings me peace',
                'I remember the old colony',
                'This soil is rich',
                'A predator lurked here',
                'Rain flooded this path',
                'I was born nearby'
            ];

            return memories[Math.floor(Math.random() * memories.length)];
        }

        function showAntThoughtBubble(ant) {
            const now = time;
            if (now - lastThoughtBubbleTime < 5) return; // Rate limit
            if (thoughtBubbles.length > 5) return; // Max 5 at once

            lastThoughtBubbleTime = now;

            const bubble = document.createElement('div');
            bubble.className = 'ant-thought-bubble';
            bubble.textContent = namedAnts.has(ant) ? `${namedAnts.get(ant)}: ${generateAntMemory(ant)}` : generateAntMemory(ant);
            bubble.style.left = ant.x + 'px';
            bubble.style.top = (ant.y - 30) + 'px';

            document.body.appendChild(bubble);
            thoughtBubbles.push(bubble);

            achievementCheckCounters.memoriesWitnessed++;
            if (achievementCheckCounters.memoriesWitnessed >= 50) {
                unlockAchievement('memory_keeper');
            }

            setTimeout(() => {
                bubble.remove();
                const index = thoughtBubbles.indexOf(bubble);
                if (index > -1) thoughtBubbles.splice(index, 1);
            }, 4000);
        }

        function tryShowRandomThought() {
            if (Math.random() < 0.01 && ants.length > 0) { // 1% chance per frame
                const randomAnt = ants[Math.floor(Math.random() * ants.length)];
                showAntThoughtBubble(randomAnt);
            }
        }

        function setupQueenClickEasterEgg() {
            // Triple-click queen for Golden Ant blessing
            canvas.addEventListener('click', (e) => {
                if (!queen) return;

                const rect = canvas.getBoundingClientRect();
                const mx = (e.clientX - rect.left) * (W / rect.width);
                const my = (e.clientY - rect.top) * (H / rect.height);

                const dist = Math.hypot(mx - queen.x, my - queen.y);
                if (dist < 20) {
                    queenClickCount++;

                    if (queenClickTimer) clearTimeout(queenClickTimer);
                    queenClickTimer = setTimeout(() => {
                        queenClickCount = 0;
                    }, 1000);

                    if (queenClickCount >= 3 && !goldenAntBlessing) {
                        goldenAntBlessing = true;
                        queenClickCount = 0;
                        unlockAchievement('golden_blessing');
                        showMilestone('Golden Blessing!', 'The queen grants her favor - all ants dig 2x faster!', true);

                        // Permanent 2x dig speed
                        for (const ant of ants) {
                            ant.speed *= 2;
                        }

                        hapticFeedback(HAPTIC_PATTERNS.expansion);
                    }
                }
            });
        }

        // ===== FEATURE 5: PHOTO MODE =====
        function initPhotoMode() {
            const photoOverlay = document.getElementById('photo-mode-overlay');
            const photoCanvas = document.getElementById('photo-mode-canvas');
            const photoZoom = document.getElementById('photo-mode-zoom');
            const photoSaveBtn = document.getElementById('photo-save-btn');
            const photoCloseBtn = document.getElementById('photo-close-btn');

            // Keyboard shortcut: P for Photo
            document.addEventListener('keydown', (e) => {
                if ((e.key === 'p' || e.key === 'P') && !e.shiftKey) {
                    if (!tutorialStep && !helpPanelVisible && !legacyPanelVisible) {
                        e.preventDefault();
                        togglePhotoMode();
                    }
                }
            });

            photoCloseBtn.addEventListener('click', () => {
                togglePhotoMode();
            });

            photoSaveBtn.addEventListener('click', () => {
                const link = document.createElement('a');
                link.download = `colony-mind-${Date.now()}.png`;
                link.href = photoCanvas.toDataURL();
                link.click();
                showMilestone('Photo Saved!', 'Your colony is immortalized', false);
            });

            photoZoom.addEventListener('input', () => {
                if (photoModeActive) {
                    capturePhotoModeFrame(photoCanvas, parseInt(photoZoom.value) / 100);
                }
            });
        }

        function togglePhotoMode() {
            photoModeActive = !photoModeActive;
            const overlay = document.getElementById('photo-mode-overlay');
            overlay.classList.toggle('active', photoModeActive);

            if (photoModeActive) {
                const photoCanvas = document.getElementById('photo-mode-canvas');
                const zoom = parseInt(document.getElementById('photo-mode-zoom').value) / 100;
                capturePhotoModeFrame(photoCanvas, zoom);
                announceToScreenReader('Photo mode activated');
            } else {
                announceToScreenReader('Photo mode closed');
            }
        }

        function capturePhotoModeFrame(photoCanvas, zoomLevel = 1) {
            photoCanvas.width = W * zoomLevel;
            photoCanvas.height = H * zoomLevel;

            const photoCtx = photoCanvas.getContext('2d');
            photoCtx.scale(zoomLevel, zoomLevel);

            // Copy main canvas
            photoCtx.drawImage(canvas, 0, 0);
        }

        // ===== CYCLE 8 ACHIEVEMENT CHECKS =====
        function checkCycle8Achievements() {
            // Population achievements
            if (ants.length >= 50 && !unlockedAchievements.has('tiny_colony')) {
                unlockAchievement('tiny_colony');
            }
            if (ants.length >= 150 && !unlockedAchievements.has('thriving_colony')) {
                unlockAchievement('thriving_colony');
            }
            if (ants.length >= 300 && !unlockedAchievements.has('megacolony')) {
                unlockAchievement('megacolony');
            }
            if (ants.length >= 500 && !unlockedAchievements.has('ant_empire')) {
                unlockAchievement('ant_empire');
            }

            // Track peak population for hall of fame
            if (ants.length > currentColonyPeakPopulation) {
                currentColonyPeakPopulation = ants.length;

                // Auto-immortalize at 200
                if (currentColonyPeakPopulation >= 200 && currentColonyPeakPopulation < 201) {
                    immortalizeColony();
                }
            }

            // Deep delver
            const maxDepthPercent = Math.max(...ants.map(a => a.y / H));
            if (maxDepthPercent > 0.8 && !unlockedAchievements.has('deep_delver')) {
                unlockAchievement('deep_delver');
            }

            // Specialist nation
            const roleCounts = { worker: 0, excavator: 0, gatherer: 0, nurse: 0 };
            for (const ant of ants) {
                if (roleCounts[ant.role] !== undefined) roleCounts[ant.role]++;
            }
            if (Math.max(...Object.values(roleCounts)) >= 30 && !unlockedAchievements.has('specialist_nation')) {
                unlockAchievement('specialist_nation');
            }

            // Balanced colony
            if (Object.values(roleCounts).every(count => count >= 10) && !unlockedAchievements.has('balanced_colony')) {
                unlockAchievement('balanced_colony');
            }

            // Speed demon (100 ants in under 3 minutes)
            const elapsedMinutes = (Date.now() - colonyStartTime) / 60000;
            if (ants.length >= 100 && elapsedMinutes < 3 && !unlockedAchievements.has('speed_demon')) {
                unlockAchievement('speed_demon');
            }

            // Survivor
            if (elapsedMinutes > 15 && !unlockedAchievements.has('survivor')) {
                unlockAchievement('survivor');
            }

            // Queen never hungry
            if (queen && queen.timeSinceLastFood < 5) {
                achievementCheckCounters.queenFedStreak++;
                if (achievementCheckCounters.queenFedStreak > 300 && !unlockedAchievements.has('queen_never_hungry')) { // ~5 minutes at 60fps
                    unlockAchievement('queen_never_hungry');
                }
            } else {
                achievementCheckCounters.queenFedStreak = 0;
            }

            // Perfectionist (no deaths in first 100 ants)
            if (ants.length <= 100 && totalDeaths === 0) {
                achievementCheckCounters.noDeathsCount = totalBirths;
            }
            if (achievementCheckCounters.noDeathsCount >= 100 && totalDeaths === 0 && !unlockedAchievements.has('perfectionist')) {
                unlockAchievement('perfectionist');
            }

            // Ant whisperer
            if (namedAnts.size >= 5 && !unlockedAchievements.has('ant_whisperer')) {
                unlockAchievement('ant_whisperer');
            }
        }

        // CYCLE 7 Initialization
        function initializeCycle7() {
            initHelpPanel();
            initButtonFeedback();
            initTooltips();
            initAutoSaveRecovery();
            initTutorial(); // Last, so it appears on top

            console.log('[CYCLE 7] Initialized: Tutorial, help panel, auto-save recovery, button feedback, tooltips');
        }

        // ============ CYCLE 10: CHALLENGE MODES IMPLEMENTATION ============

        // ===== CHALLENGE MODE SELECTOR =====
        function showChallengeModeSelector() {
            const modal = document.getElementById('challenge-mode-selector');
            const cards = modal.querySelectorAll('.challenge-mode-card');

            // Check unlocks based on lifetime peak population
            const legacyData = loadLegacyData();
            const peakPopulation = legacyData.peakPopulation || 0;

            challengeModesUnlocked.disaster = peakPopulation >= 50;
            challengeModesUnlocked.speedrun = peakPopulation >= 100;
            challengeModesUnlocked.rival = peakPopulation >= 150;

            // Update card states
            cards.forEach(card => {
                const mode = card.dataset.mode;
                const unlockReq = parseInt(card.dataset.unlock) || 0;
                const isUnlocked = challengeModesUnlocked[mode];

                if (isUnlocked || mode === 'classic') {
                    card.classList.remove('locked');
                } else {
                    card.classList.add('locked');
                }

                card.onclick = () => {
                    if (isUnlocked || mode === 'classic') {
                        selectChallengeMode(mode);
                        modal.classList.remove('active');
                    }
                };
            });

            modal.classList.add('active');
        }

        function selectChallengeMode(mode) {
            currentChallengeMode = mode;

            // Reset colony for new challenge
            initAnts();

            // Show mode badge
            const badge = document.getElementById('challenge-mode-badge');
            const badgeNames = {
                classic: 'Classic Mode',
                disaster: 'üå™Ô∏è Disaster Survival',
                speedrun: '‚ö° Speedrun Challenge',
                rival: '‚öîÔ∏è Rival Colony'
            };
            badge.textContent = badgeNames[mode] || 'Classic Mode';
            badge.classList.toggle('active', mode !== 'classic');

            // Initialize mode-specific systems
            if (mode === 'disaster') {
                startDisasterMode();
            } else if (mode === 'speedrun') {
                showSpeedrunChallengeSelector();
            } else if (mode === 'rival') {
                startRivalMode();
            }

            announceToScreenReader(`Started ${badgeNames[mode]}`);
        }

        // ===== DISASTER SURVIVAL MODE =====
        /**
         * CYCLE 10: Disaster Survival Mode
         * Spawns random disasters (flood, fire, earthquake, famine, plague)
         * CYCLE 13: Fixed typo in disastersSurvived tracking for proper stats
         */
        function startDisasterMode() {
            disasterQueue = [];
            disasterScore = 0;
            disastersSurvived = 0; // CYCLE 13: Fixed typo

            // Schedule first disaster in 60-90 seconds
            const firstDisasterDelay = 60 + Math.random() * 30;
            scheduleDisaster(firstDisasterDelay);

            showMilestone('Disaster Mode', 'Survive as long as you can!', false);
        }

        function scheduleDisaster(delaySeconds) {
            const types = Object.keys(DISASTER_TYPES);
            const randomType = types[Math.floor(Math.random() * types.length)];
            const disaster = DISASTER_TYPES[randomType];

            disasterQueue.push({
                type: randomType,
                triggerTime: Date.now() + (delaySeconds * 1000),
                ...disaster
            });
        }

        function updateDisasterMode(dt) {
            if (currentChallengeMode !== 'disaster') return;

            const now = Date.now();

            // Check for queued disasters
            if (disasterQueue.length > 0 && !activeDisaster && !disasterActive) {
                const nextDisaster = disasterQueue[0];
                if (now >= nextDisaster.triggerTime) {
                    disasterQueue.shift();
                    startDisasterWarning(nextDisaster);
                }
            }

            // Update warning countdown
            if (activeDisaster && !disasterActive) {
                const timeLeft = Math.max(0, activeDisaster.warning - ((now - disasterWarningTime) / 1000));
                const timerEl = document.getElementById('disaster-warning-timer');
                timerEl.textContent = Math.ceil(timeLeft);

                if (timeLeft <= 0) {
                    triggerDisaster();
                }
            }

            // Update active disaster
            if (disasterActive) {
                const elapsed = (now - disasterStartTime) / 1000;

                if (activeDisaster.type === 'FLOOD') {
                    updateFloodDisaster(elapsed);
                } else if (activeDisaster.type === 'FIRE') {
                    updateFireDisaster(elapsed);
                } else if (activeDisaster.type === 'EARTHQUAKE') {
                    // Earthquake is instant
                    if (elapsed > 2) endDisaster();
                } else if (activeDisaster.type === 'FAMINE') {
                    updateFamineDisaster(elapsed);
                } else if (activeDisaster.type === 'PLAGUE') {
                    updatePlagueDisaster(elapsed);
                }

                // End disaster after duration
                if (elapsed > 30) {
                    endDisaster();
                }
            }
        }

        function startDisasterWarning(disaster) {
            activeDisaster = disaster;
            disasterWarningTime = Date.now();

            const warningEl = document.getElementById('disaster-warning');
            document.getElementById('disaster-warning-icon').textContent = disaster.icon;
            document.getElementById('disaster-warning-name').textContent = disaster.name;
            document.getElementById('disaster-warning-desc').textContent = disaster.desc;
            document.getElementById('disaster-warning-timer').textContent = disaster.warning;

            warningEl.classList.add('show');

            // Play warning sound
            if (soundEnabled) playDisasterWarningSound();

            announceToScreenReader(`Warning: ${disaster.name} in ${disaster.warning} seconds!`);

            setTimeout(() => warningEl.classList.remove('show'), disaster.warning * 1000);
        }

        function triggerDisaster() {
            disasterActive = true;
            disasterStartTime = Date.now();

            const hudEl = document.getElementById('disaster-hud');
            document.getElementById('disaster-hud-text').textContent = `‚ö†Ô∏è ${activeDisaster.name} Active!`;
            hudEl.classList.add('active');

            // Instant disasters
            if (activeDisaster.type === 'EARTHQUAKE') {
                triggerEarthquake();
            }

            announceToScreenReader(`${activeDisaster.name} disaster started!`);
        }

        function updateFloodDisaster(elapsed) {
            // Drown ants in bottom 30% of world
            ants.forEach(ant => {
                if (ant.y > H * 0.7 && Math.random() < 0.001) {
                    ant.health = 0; // Drown
                }
            });
        }

        function updateFireDisaster(elapsed) {
            // Fire spreads from top, burns ants in top 40%
            ants.forEach(ant => {
                if (ant.y < H * 0.4 && Math.random() < 0.002) {
                    ant.health = 0; // Burn
                }
            });
        }

        function triggerEarthquake() {
            // Collapse random chambers
            chambers.forEach(chamber => {
                if (Math.random() < 0.3) {
                    // Kill ants near chamber
                    ants.forEach(ant => {
                        const dist = Math.hypot(ant.x - chamber.x, ant.y - chamber.y);
                        if (dist < 60) {
                            ant.health = 0;
                        }
                    });
                }
            });
        }

        function updateFamineDisaster(elapsed) {
            // Deplete food 5x faster
            foodSources.forEach(food => {
                if (Math.random() < 0.05) {
                    food.amount = Math.max(0, food.amount - 5);
                }
            });
        }

        function updatePlagueDisaster(elapsed) {
            // Spread disease on contact
            ants.forEach(ant => {
                if (infectedAnts.has(ant)) {
                    // Infected ant spreads to nearby
                    ants.forEach(other => {
                        if (!infectedAnts.has(other)) {
                            const dist = Math.hypot(ant.x - other.x, ant.y - other.y);
                            if (dist < 10 && Math.random() < 0.01) {
                                infectedAnts.add(other);
                            }
                        }
                    });

                    // Infected ants slowly die
                    if (Math.random() < 0.001) {
                        ant.health = 0;
                    }
                } else {
                    // Random infection start
                    if (infectedAnts.size === 0 && Math.random() < 0.0001) {
                        infectedAnts.add(ant);
                    }
                }
            });
        }

        function endDisaster() {
            disasterActive = false;
            disastersSurvived++;

            const survivingAnts = ants.length;
            disasterScore += survivingAnts * 100;

            document.getElementById('disaster-hud').classList.remove('active');

            showMilestone('Disaster Survived!', `${survivingAnts} ants survived`, false);

            // Check for perfect survival
            if (survivingAnts >= 50 && /* no deaths during disaster */ true) {
                // Note: Would need death tracking during disaster
                // unlockAchievement('perfect_survival');
            }

            // Schedule next disaster (60-120 seconds)
            const nextDelay = 60 + Math.random() * 60;
            scheduleDisaster(nextDelay);

            activeDisaster = null;
            infectedAnts.clear();

            announceToScreenReader(`Disaster ended. ${survivingAnts} ants survived.`);
        }

        // ===== SPEEDRUN CHALLENGE MODE =====
        function showSpeedrunChallengeSelector() {
            // Use existing modal pattern to select speedrun type
            // For now, default to POPULATION challenge
            startSpeedrunChallenge('POPULATION');
        }

        function startSpeedrunChallenge(challengeKey) {
            const challenge = SPEEDRUN_CHALLENGES[challengeKey];
            if (!challenge) return;

            currentSpeedrunChallenge = challengeKey;
            speedrunStartTime = Date.now();
            speedrunTargetTime = challenge.time;
            speedrunCompleted = false;

            // Load personal best
            const pbs = loadSpeedrunLeaderboards();
            const pb = pbs[challengeKey] ? pbs[challengeKey][0] : null;

            // Update HUD
            const hud = document.getElementById('speedrun-hud');
            document.getElementById('speedrun-challenge-name').textContent = challenge.name;
            document.getElementById('speedrun-target').textContent = `Target: ${formatTime(challenge.time)}`;
            if (pb) {
                document.getElementById('speedrun-pb').textContent = `PB: ${formatTime(pb.time)}`;
            }
            hud.classList.add('active');

            showMilestone('Speedrun Challenge', challenge.desc, false);
        }

        function updateSpeedrunMode(dt) {
            if (currentChallengeMode !== 'speedrun' || !currentSpeedrunChallenge) return;
            if (speedrunCompleted) return;

            const challenge = SPEEDRUN_CHALLENGES[currentSpeedrunChallenge];
            const elapsed = (Date.now() - speedrunStartTime) / 1000;

            // Update timer display
            document.getElementById('speedrun-timer').textContent = formatTime(elapsed);

            // Check completion
            let isComplete = false;
            let progress = 0;

            if (challenge.metric === 'ants') {
                progress = ants.length / challenge.target;
                isComplete = ants.length >= challenge.target;
            } else if (challenge.metric === 'depth') {
                progress = exploredPercentage / challenge.target;
                isComplete = exploredPercentage >= challenge.target;
            } else if (challenge.metric === 'chambers') {
                progress = chambers.length / challenge.target;
                isComplete = chambers.length >= challenge.target;
            } else if (challenge.metric === 'combo') {
                const targets = challenge.target;
                progress = Math.min(
                    ants.length / targets.ants,
                    chambers.length / targets.chambers,
                    disastersSurvived / targets.disasters
                );
                isComplete = ants.length >= targets.ants &&
                             chambers.length >= targets.chambers &&
                             disastersSurvived >= targets.disasters;
            }

            // Update progress bar
            document.getElementById('speedrun-progress-fill').style.width = `${Math.min(100, progress * 100)}%`;

            if (isComplete) {
                completeSpeedrunChallenge(elapsed);
            }
        }

        function completeSpeedrunChallenge(time) {
            speedrunCompleted = true;
            document.getElementById('speedrun-hud').classList.remove('active');

            const challenge = SPEEDRUN_CHALLENGES[currentSpeedrunChallenge];

            // Calculate score (0-1000)
            const speedScore = Math.min(400, (challenge.time / time) * 400);
            const efficiencyScore = (ants.length / (totalDeaths + 1)) * 15; // max ~300
            const economyScore = Math.min(300, (foodSources.reduce((sum, f) => sum + f.amount, 0) / 100) * 300);
            const totalScore = Math.floor(speedScore + efficiencyScore + economyScore);

            // Save to leaderboard
            saveSpeedrunScore(currentSpeedrunChallenge, time, totalScore);

            // Show results
            showSpeedrunResults(time, totalScore, speedScore, efficiencyScore, economyScore);

            // Check achievements
            if (currentSpeedrunChallenge === 'POPULATION' && time < 120) {
                unlockAchievement('speed_demon');
            }
            if (totalDeaths === 0) {
                unlockAchievement('flawless_run');
            }
            if (currentSpeedrunChallenge === 'GAUNTLET') {
                unlockAchievement('gauntlet_champion');
            }
        }

        function showSpeedrunResults(time, score, speedScore, effScore, econScore) {
            const modal = document.getElementById('speedrun-results');
            const challenge = SPEEDRUN_CHALLENGES[currentSpeedrunChallenge];

            document.getElementById('speedrun-results-title').textContent = `${challenge.name} Complete!`;
            document.getElementById('speedrun-results-score').textContent = score;

            const breakdown = document.getElementById('speedrun-results-breakdown');
            breakdown.innerHTML = `
                <div class="speedrun-stat-row">
                    <span class="speedrun-stat-label">Time:</span>
                    <span class="speedrun-stat-value">${formatTime(time)}</span>
                </div>
                <div class="speedrun-stat-row">
                    <span class="speedrun-stat-label">Speed Bonus:</span>
                    <span class="speedrun-stat-value">${Math.floor(speedScore)} pts</span>
                </div>
                <div class="speedrun-stat-row">
                    <span class="speedrun-stat-label">Efficiency:</span>
                    <span class="speedrun-stat-value">${Math.floor(effScore)} pts</span>
                </div>
                <div class="speedrun-stat-row">
                    <span class="speedrun-stat-label">Economy:</span>
                    <span class="speedrun-stat-value">${Math.floor(econScore)} pts</span>
                </div>
            `;

            modal.classList.add('active');
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            const ms = Math.floor((seconds % 1) * 10);
            return `${mins}:${secs.toString().padStart(2, '0')}.${ms}`;
        }

        // ===== RIVAL COLONY MODE =====
        function startRivalMode() {
            // Create rival queen on opposite side
            rivalQueen = new QueenAnt(W * 0.8, H * 0.2);
            rivalQueen.isRival = true;

            // Create initial rival nest
            rivalChambers.push({
                x: W * 0.8,
                y: H * 0.2,
                radius: 40,
                type: 'NEST',
                waterLevel: 0,
                fungusHealth: 1.0,
                foodProduction: 0,
                isRival: true
            });

            // Create initial rival ants
            for (let i = 0; i < 20; i++) {
                createRivalAnt(W * 0.8 + (Math.random() - 0.5) * 100, H * 0.2 + (Math.random() - 0.5) * 100);
            }

            // Show UI
            document.getElementById('rival-minimap').classList.add('active');
            document.getElementById('rival-stats').classList.add('active');

            showMilestone('Rival Colony', 'Compete for dominance!', false);
        }

        function createRivalAnt(x, y) {
            const ant = {
                x, y,
                vx: 0, vy: 0,
                state: 'wander',
                target: null,
                carrying: null,
                health: 100,
                age: 0,
                experience: { dig: 0, gather: 0, nurse: 0 },
                role: 'worker',
                isRival: true
            };
            rivalAnts.push(ant);
            rivalSpatialGrid.insert(ant);
            return ant;
        }

        function updateRivalColony(dt) {
            if (currentChallengeMode !== 'rival') return;

            // Update rival queen
            if (rivalQueen && rivalQueen.timeSinceLastFood < 60) {
                if (Math.random() < 0.002) {
                    const nestChamber = rivalChambers.find(c => c.type === 'NEST');
                    if (nestChamber && rivalAnts.length < 200) {
                        const newAnt = createRivalAnt(
                            nestChamber.x + (Math.random() - 0.5) * 60,
                            nestChamber.y + (Math.random() - 0.5) * 60
                        );
                    }
                }
            }

            // Update rival AI (every 90 frames)
            if (time % RIVAL_UPDATE_INTERVAL === 0) {
                updateRivalAI();
            }

            // Update rival ants
            rivalAnts.forEach(ant => {
                updateRivalAntBehavior(ant, dt);
            });

            // Update rival stats display
            document.getElementById('rival-ant-count').textContent = rivalAnts.length;
            document.getElementById('rival-chamber-count').textContent = rivalChambers.length;
            document.getElementById('rival-food-count').textContent = rivalFoodSources.length;

            // Check win/lose conditions
            if (!rivalQueen || rivalAnts.length === 0) {
                winRivalMode();
            } else if (!queen || ants.length === 0) {
                loseRivalMode();
            }
        }

        function updateRivalAI() {
            // Simple 12-rule AI decision tree
            const rivalPop = rivalAnts.length;
            const playerPop = ants.length;

            // Rule 1-2: Prioritize reproduction if below 30 ants
            if (rivalPop < 30) {
                rivalAIState.lastAction = 'reproduce';
                // Ants auto-seek food for queen
                return;
            }

            // Rule 3-4: Gather food if sources available
            if (foodSources.length > 0) {
                rivalAIState.lastAction = 'gather';
                rivalAIState.targetFood = foodSources[Math.floor(Math.random() * foodSources.length)];
                return;
            }

            // Rule 5-6: Emergency food if queen hungry
            if (rivalQueen && rivalQueen.timeSinceLastFood > 60) {
                rivalAIState.lastAction = 'emergency_gather';
                return;
            }

            // Rule 7-8: Expand territory if strong
            if (rivalPop > playerPop * 1.5) {
                rivalAIState.lastAction = 'expand';
                return;
            }

            // Rule 9-12: Wander/explore
            rivalAIState.lastAction = 'explore';
        }

        function updateRivalAntBehavior(ant, dt) {
            // Simplified ant behavior (reuses player ant logic)
            // Just move toward rival queen if no specific task
            if (!ant.target && rivalQueen) {
                const dx = rivalQueen.x - ant.x;
                const dy = rivalQueen.y - ant.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > 100) {
                    ant.vx += (dx / dist) * 0.1;
                    ant.vy += (dy / dist) * 0.1;
                }
            }

            // Apply velocity
            ant.x += ant.vx * simulationSpeed;
            ant.y += ant.vy * simulationSpeed;

            // Friction
            ant.vx *= 0.95;
            ant.vy *= 0.95;

            // Bounds
            ant.x = Math.max(0, Math.min(W, ant.x));
            ant.y = Math.max(0, Math.min(H, ant.y));

            rivalSpatialGrid.update(ant);
        }

        function winRivalMode() {
            showMilestone('Victory!', 'Rival colony eliminated!', true);
            unlockAchievement('rival_defeated');

            if (ants.length >= 300) {
                unlockAchievement('colony_domination');
            }

            // Check underdog achievement
            // (would need tracking of max rival:player ratio)

            setTimeout(() => {
                currentChallengeMode = 'classic';
                showChallengeModeSelector();
            }, 5000);
        }

        function loseRivalMode() {
            showMilestone('Defeated', 'Your colony has fallen...', false);

            setTimeout(() => {
                currentChallengeMode = 'classic';
                showChallengeModeSelector();
            }, 5000);
        }

        // ===== PERSISTENCE & LEADERBOARDS =====
        function loadLegacyData() {
            try {
                const data = localStorage.getItem(LEGACY_DATA_KEY);
                if (data) {
                    return JSON.parse(data);
                }
            } catch (err) {
                console.error('[CYCLE 10] Failed to load legacy data:', err);
            }
            return { peakPopulation: 0 };
        }

        function loadSpeedrunLeaderboards() {
            try {
                const data = localStorage.getItem(SPEEDRUN_LEADERBOARDS_KEY);
                if (data) {
                    return JSON.parse(data);
                }
            } catch (err) {
                console.error('[CYCLE 10] Failed to load leaderboards:', err);
            }
            return {};
        }

        function saveSpeedrunScore(challengeKey, time, score) {
            try {
                const boards = loadSpeedrunLeaderboards();
                if (!boards[challengeKey]) {
                    boards[challengeKey] = [];
                }

                boards[challengeKey].push({ time, score, date: Date.now() });
                boards[challengeKey].sort((a, b) => b.score - a.score);
                boards[challengeKey] = boards[challengeKey].slice(0, 5); // Top 5

                localStorage.setItem(SPEEDRUN_LEADERBOARDS_KEY, JSON.stringify(boards));
            } catch (err) {
                console.error('[CYCLE 10] Failed to save leaderboard:', err);
            }
        }

        // ===== AUDIO CUES =====
        function playDisasterWarningSound() {
            if (!audioContext) return;
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();

            osc.type = 'sine';
            osc.frequency.setValueAtTime(220, audioContext.currentTime);
            osc.frequency.exponentialRampToValueAtTime(440, audioContext.currentTime + 0.5);

            gain.gain.setValueAtTime(0.3, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);

            osc.connect(gain);
            gain.connect(audioContext.destination);

            osc.start();
            osc.stop(audioContext.currentTime + 0.5);
        }

        // ===== CYCLE 10 INITIALIZATION =====
        function initializeCycle10() {
            // Set up challenge mode selector
            document.getElementById('reset-btn').addEventListener('click', () => {
                showChallengeModeSelector();
            });

            document.getElementById('challenge-selector-cancel').addEventListener('click', () => {
                document.getElementById('challenge-mode-selector').classList.remove('active');
            });

            // Speedrun results buttons
            document.getElementById('speedrun-retry').addEventListener('click', () => {
                document.getElementById('speedrun-results').classList.remove('active');
                startSpeedrunChallenge(currentSpeedrunChallenge);
            });

            document.getElementById('speedrun-menu').addEventListener('click', () => {
                document.getElementById('speedrun-results').classList.remove('active');
                currentChallengeMode = 'classic';
                showChallengeModeSelector();
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.key === 'M' || e.key === 'm') {
                    showChallengeModeSelector();
                }
            });

            console.log('[CYCLE 10] Initialized: Challenge modes, disasters, speedruns, rival AI');
        }

        // ============ CYCLE 8 INITIALIZATION ============
        function initializeCycle8() {
            initColonyLegacy();
            initPhotoMode();
            setupQueenClickEasterEgg();
            generateUndergroundChambers();

            console.log('[CYCLE 8] Initialized: Achievements, legacy system, photo mode, underground chambers, celestial events');
        }

        // ============ CYCLE 11: CREATIVE & SANDBOX MODE INITIALIZATION ============
        function initializeCycle11() {
            const creativeToolbar = document.getElementById('creative-toolbar');
            const godModeBadge = document.getElementById('god-mode-badge');
            const godModeBtn = document.getElementById('god-mode-btn');
            const spawnQuantitySlider = document.getElementById('spawn-quantity');
            const spawnQuantityVal = document.getElementById('spawn-quantity-val');
            const undoBtn = document.getElementById('undo-btn');
            const timeControlHud = document.getElementById('time-control-hud');
            const scenarioPanel = document.getElementById('scenario-panel');
            const colorPickerPanel = document.getElementById('color-picker-panel');

            // Toggle Creative Mode (V key)
            document.addEventListener('keydown', (e) => {
                if (e.key === 'v' || e.key === 'V') {
                    creativeMode = !creativeMode;
                    creativeToolbar.classList.toggle('active', creativeMode);
                    undoBtn.classList.toggle('active', creativeMode);
                    timeControlHud.classList.toggle('active', creativeMode);
                    showMilestone('Creative Mode', creativeMode ? 'Enabled - Explore freely!' : 'Disabled', creativeMode ? 'üé®' : 'üìä');
                }
            });

            // God Mode Toggle
            godModeBtn.addEventListener('click', () => {
                createUndoSnapshot();
                godModeEnabled = !godModeEnabled;
                godModeBtn.textContent = godModeEnabled ? 'On' : 'Off';
                godModeBtn.classList.toggle('active', godModeEnabled);
                godModeBadge.classList.toggle('active', godModeEnabled);
                showMilestone('God Mode', godModeEnabled ? 'Unlimited power!' : 'Normal mode restored', '‚ö°');
            });

            // Spawn Tools
            document.querySelectorAll('[data-spawn]').forEach(btn => {
                btn.addEventListener('click', () => {
                    const mode = btn.dataset.spawn;
                    if (spawnMode === mode) {
                        spawnMode = null;
                        btn.classList.remove('active');
                    } else {
                        document.querySelectorAll('[data-spawn]').forEach(b => b.classList.remove('active'));
                        spawnMode = mode;
                        btn.classList.add('active');
                    }
                });
            });

            // Spawn Quantity Slider
            spawnQuantitySlider.addEventListener('input', (e) => {
                spawnQuantity = parseInt(e.target.value);
                spawnQuantityVal.textContent = spawnQuantity;
            });

            // Scenarios Button
            document.getElementById('open-scenarios-btn').addEventListener('click', () => {
                scenarioPanel.classList.toggle('visible');
                colorPickerPanel.classList.remove('active');
            });

            document.getElementById('scenario-panel-close').addEventListener('click', () => {
                scenarioPanel.classList.remove('visible');
            });

            // Scenario Cards
            document.querySelectorAll('[data-scenario]').forEach(card => {
                card.addEventListener('click', () => {
                    const scenario = card.dataset.scenario;
                    loadScenario(scenario);
                    document.querySelectorAll('[data-scenario]').forEach(c => c.classList.remove('active'));
                    card.classList.add('active');
                    currentScenario = scenario;
                    showMilestone('Scenario Loaded', builtInScenarios[scenario].name, 'üìã');
                });
            });

            // Save Scenario
            document.getElementById('save-scenario-btn').addEventListener('click', () => {
                const scenarioData = createScenarioSnapshot();
                const blob = new Blob([JSON.stringify(scenarioData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `colony-scenario-${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
                showMilestone('Scenario Saved', 'Downloaded to your device', 'üíæ');
            });

            // Colors Button
            document.getElementById('open-colors-btn').addEventListener('click', () => {
                colorPickerPanel.classList.toggle('active');
                scenarioPanel.classList.remove('visible');
            });

            document.getElementById('color-picker-close').addEventListener('click', () => {
                colorPickerPanel.classList.remove('active');
            });

            // Color Pickers
            document.getElementById('color-ant').addEventListener('change', (e) => {
                colonyColors.ant = e.target.value;
            });
            document.getElementById('color-queen').addEventListener('change', (e) => {
                colonyColors.queen = e.target.value;
            });
            document.getElementById('color-pheromone').addEventListener('change', (e) => {
                const hex = e.target.value;
                const r = parseInt(hex.slice(1,3), 16);
                const g = parseInt(hex.slice(3,5), 16);
                const b = parseInt(hex.slice(5,7), 16);
                colonyColors.pheromone = `rgba(${r},${g},${b},0.3)`;
            });
            document.getElementById('color-particle').addEventListener('change', (e) => {
                const hex = e.target.value;
                const r = parseInt(hex.slice(1,3), 16);
                const g = parseInt(hex.slice(3,5), 16);
                const b = parseInt(hex.slice(5,7), 16);
                colonyColors.particle = `rgba(${r},${g},${b},0.7)`;
            });

            // Color Presets
            const colorPresets = {
                classic: { ant: '#8B6F47', queen: '#D4AF37', pheromone: '#78B464', particle: '#C8A064' },
                fire: { ant: '#D04020', queen: '#FF6020', pheromone: '#FF8040', particle: '#FFA060' },
                ice: { ant: '#6090C0', queen: '#80D0FF', pheromone: '#A0C0FF', particle: '#C0E0FF' },
                toxic: { ant: '#80C040', queen: '#A0FF60', pheromone: '#C0FF80', particle: '#E0FFA0' },
                rainbow: { ant: '#FF69B4', queen: '#FFD700', pheromone: '#00CED1', particle: '#FF1493' }
            };

            document.querySelectorAll('[data-preset]').forEach(btn => {
                btn.addEventListener('click', () => {
                    const preset = btn.dataset.preset;
                    colorPreset = preset;
                    const colors = colorPresets[preset];
                    document.getElementById('color-ant').value = colors.ant;
                    document.getElementById('color-queen').value = colors.queen;
                    colonyColors.ant = colors.ant;
                    colonyColors.queen = colors.queen;

                    // Convert to rgba
                    const hexToRgba = (hex, alpha) => {
                        const r = parseInt(hex.slice(1,3), 16);
                        const g = parseInt(hex.slice(3,5), 16);
                        const b = parseInt(hex.slice(5,7), 16);
                        return `rgba(${r},${g},${b},${alpha})`;
                    };
                    colonyColors.pheromone = hexToRgba(colors.pheromone, 0.3);
                    colonyColors.particle = hexToRgba(colors.particle, 0.7);

                    showMilestone('Color Preset', preset.charAt(0).toUpperCase() + preset.slice(1), 'üé®');
                });
            });

            // Undo Button
            undoBtn.addEventListener('click', () => {
                if (undoSnapshot) {
                    restoreUndoSnapshot();
                    showMilestone('Undo', 'Last action reverted', '‚Ü∂');
                }
            });

            // Undo Keyboard Shortcut (Ctrl+Z)
            document.addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && e.key === 'z' && creativeMode && undoSnapshot) {
                    e.preventDefault();
                    restoreUndoSnapshot();
                    showMilestone('Undo', 'Last action reverted', '‚Ü∂');
                }
            });

            // Time Controls
            const speeds = [0.1, 0.25, 0.5, 1, 2, 4, 8];
            let currentSpeedIndex = 3; // 1x

            document.addEventListener('keydown', (e) => {
                if (!creativeMode) return;

                // [ = Slower
                if (e.key === '[') {
                    if (currentSpeedIndex > 0) {
                        currentSpeedIndex--;
                        simulationSpeed = speeds[currentSpeedIndex];
                        document.getElementById('time-control-speed').textContent = simulationSpeed + 'x';
                        showMilestone('Speed', simulationSpeed + 'x', '‚è±Ô∏è');
                    }
                }

                // ] = Faster
                if (e.key === ']') {
                    if (currentSpeedIndex < speeds.length - 1) {
                        currentSpeedIndex++;
                        simulationSpeed = speeds[currentSpeedIndex];
                        document.getElementById('time-control-speed').textContent = simulationSpeed + 'x';
                        showMilestone('Speed', simulationSpeed + 'x', '‚è±Ô∏è');
                    }
                }

                // \ = Frame Step (advance 1 frame while paused)
                if (e.key === '\\') {
                    if (!isPaused) {
                        isPaused = true;
                        document.getElementById('pause-btn').textContent = 'Resume';
                    }
                    // Advance one frame manually
                    updateSimulation();
                    showMilestone('Frame Step', 'Advanced 1 frame', '‚è≠Ô∏è');
                }
            });

            console.log('[CYCLE 11] Initialized: Creative mode, God mode, spawn tools, scenarios, color customization, time controls, undo system');
        }

        // Helper: Create undo snapshot
        function createUndoSnapshot() {
            undoSnapshot = {
                ants: JSON.parse(JSON.stringify(ants.map(a => ({ x: a.x, y: a.y, age: a.age, role: a.role })))),
                food: JSON.parse(JSON.stringify(food)),
                chambers: JSON.parse(JSON.stringify(chambers)),
                queenFed: queenFed,
                totalBirths: totalBirths,
                totalDeaths: totalDeaths
            };
        }

        // Helper: Restore undo snapshot
        function restoreUndoSnapshot() {
            if (!undoSnapshot) return;

            // Restore ants (simplified - just count)
            while (ants.length > undoSnapshot.ants.length) {
                ants.pop();
            }

            // Restore food
            food.length = 0;
            food.push(...JSON.parse(JSON.stringify(undoSnapshot.food)));
            foodSpatialGrid.clear();
            food.forEach(f => foodSpatialGrid.insert(f));

            // Restore chambers
            chambers.length = 0;
            chambers.push(...JSON.parse(JSON.stringify(undoSnapshot.chambers)));

            // Restore stats
            queenFed = undoSnapshot.queenFed;
            totalBirths = undoSnapshot.totalBirths;
            totalDeaths = undoSnapshot.totalDeaths;

            undoSnapshot = null;
        }

        // Helper: Load scenario
        function loadScenario(scenario) {
            createUndoSnapshot();

            switch(scenario) {
                case 'desert':
                    currentWeather = WEATHER_STATES.HARSH_SUN;
                    weatherDuration = 180;
                    food.forEach(f => f.amount = Math.max(50, f.amount * 0.3));
                    break;
                case 'flood':
                    currentWeather = WEATHER_STATES.HEAVY_RAIN;
                    weatherDuration = 120;
                    break;
                case 'paradise':
                    godModeEnabled = true;
                    godModeBtn.textContent = 'On';
                    godModeBadge.classList.add('active');
                    food.forEach(f => f.amount = f.maxAmount);
                    currentWeather = WEATHER_STATES.CLEAR;
                    predatorsEnabled = false;
                    break;
                case 'chaos':
                    predatorsEnabled = true;
                    currentWeather = WEATHER_STATES.STORM;
                    weatherDuration = 60;
                    break;
                default: // classic
                    currentWeather = WEATHER_STATES.CLEAR;
                    godModeEnabled = false;
                    godModeBtn.textContent = 'Off';
                    godModeBadge.classList.remove('active');
                    break;
            }

            updateWeatherDisplay();
        }

        // Helper: Create scenario snapshot for saving
        function createScenarioSnapshot() {
            return {
                version: "scenario-1.0",
                name: "Custom Scenario",
                timestamp: new Date().toISOString(),
                ants: ants.length,
                food: food.map(f => ({ x: f.x, y: f.y, amount: f.amount, type: f.type })),
                chambers: chambers.map(c => ({ x: c.x, y: c.y, r: c.r, type: c.type })),
                weather: currentWeather ? currentWeather.name : 'Clear',
                godMode: godModeEnabled,
                predators: predatorsEnabled,
                colors: { ...colonyColors }
            };
        }

        // ============ CYCLE 12: SOCIAL & SHARING ============
        function initializeCycle12() {
            // State
            let sharePanelVisible = false;
            let currentCardTheme = 'default';
            let screenshotMetadataEnabled = true;

            // Keyboard shortcut: S for Share
            document.addEventListener('keydown', (e) => {
                if ((e.key === 's' || e.key === 'S') && !e.ctrlKey && !e.metaKey) {
                    if (!tutorialStep && !helpPanelVisible && !legacyPanelVisible) {
                        e.preventDefault();
                        toggleSharePanel();
                    }
                }
            });

            // Share Panel Toggle
            document.getElementById('share-btn-main').onclick = () => toggleSharePanel();
            document.getElementById('share-panel-close').onclick = () => toggleSharePanel();

            function toggleSharePanel() {
                sharePanelVisible = !sharePanelVisible;
                document.getElementById('share-panel').classList.toggle('visible', sharePanelVisible);
                if (sharePanelVisible) {
                    updateCardPreview();
                    announceToScreenReader('Share panel opened');
                } else {
                    announceToScreenReader('Share panel closed');
                }
            }

            // 1. COLONY CARD GENERATOR
            const cardThemes = {
                default: { bg: ['#2a1a10', '#1a1510'], accent: '#d0a070', name: 'Classic Explorer' },
                aggressive: { bg: ['#3a1010', '#200808'], accent: '#d08060', name: 'Warrior Colony' },
                builder: { bg: ['#1a2a1a', '#0a1510'], accent: '#90c070', name: 'Master Architect' },
                survivor: { bg: ['#1a1a2a', '#101020'], accent: '#8090d0', name: 'Endurance Specialist' },
                explorer: { bg: ['#2a1a2a', '#15101a'], accent: '#c080c0', name: 'Deep Delver' }
            };

            document.querySelectorAll('.theme-btn').forEach(btn => {
                btn.onclick = () => {
                    document.querySelectorAll('.theme-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentCardTheme = btn.dataset.theme;
                    updateCardPreview();
                };
            });

            function updateCardPreview() {
                const previewCanvas = document.getElementById('card-preview-canvas');
                if (!previewCanvas) return;
                const ctx = previewCanvas.getContext('2d');
                const theme = cardThemes[currentCardTheme];

                // Simple preview
                const gradient = ctx.createLinearGradient(0, 0, 0, 300);
                gradient.addColorStop(0, theme.bg[0]);
                gradient.addColorStop(1, theme.bg[1]);
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 400, 300);

                ctx.fillStyle = theme.accent;
                ctx.font = 'bold 24px Georgia';
                ctx.textAlign = 'center';
                ctx.fillText('Colony Card Preview', 200, 150);
                ctx.font = '14px Georgia';
                ctx.fillText(theme.name, 200, 180);
            }

            document.getElementById('generate-card-btn').onclick = () => {
                generateColonyCard(currentCardTheme);
            };

            function generateColonyCard(theme) {
                const modal = document.getElementById('colony-card-modal');
                const cardCanvas = document.getElementById('colony-card-canvas');
                const ctx = cardCanvas.getContext('2d');
                const themeData = cardThemes[theme];

                // Card dimensions
                cardCanvas.width = 800;
                cardCanvas.height = 1000;

                // Background gradient
                const gradient = ctx.createLinearGradient(0, 0, 0, 1000);
                gradient.addColorStop(0, themeData.bg[0]);
                gradient.addColorStop(1, themeData.bg[1]);
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 800, 1000);

                // Border
                ctx.strokeStyle = themeData.accent;
                ctx.lineWidth = 4;
                ctx.strokeRect(10, 10, 780, 980);

                // Title
                ctx.fillStyle = themeData.accent;
                ctx.font = 'bold 48px Georgia';
                ctx.textAlign = 'center';
                ctx.fillText('COLONY MIND', 400, 80);
                ctx.font = '20px Georgia';
                ctx.fillText(themeData.name, 400, 120);

                // Stats section
                ctx.font = 'bold 28px Georgia';
                ctx.fillText('COLONY STATS', 400, 200);

                ctx.font = '22px Georgia';
                ctx.textAlign = 'left';
                const stats = [
                    ['Population', ants.length],
                    ['Generation', currentGeneration],
                    ['Chambers', chambers.length],
                    ['Food Gathered', queenFed],
                    ['Deaths', totalDeaths],
                    ['Achievements', unlockedAchievements.size + '/33']
                ];

                let y = 260;
                stats.forEach(([label, value]) => {
                    ctx.fillStyle = 'rgba(255,255,255,0.7)';
                    ctx.fillText(label + ':', 100, y);
                    ctx.fillStyle = themeData.accent;
                    ctx.fillText(String(value), 500, y);
                    y += 50;
                });

                // Top achievement
                ctx.font = 'bold 20px Georgia';
                ctx.textAlign = 'center';
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                ctx.fillText('TOP ACHIEVEMENT', 400, 650);
                const topAchievement = Array.from(unlockedAchievements)[0] || 'None';
                const achievementName = ACHIEVEMENTS[topAchievement]?.name || 'First Steps';
                ctx.font = '18px Georgia';
                ctx.fillStyle = themeData.accent;
                ctx.fillText(achievementName, 400, 690);

                // Colony age
                const ageMinutes = Math.floor((Date.now() - colonyStartTime) / 60000);
                ctx.font = '16px Georgia';
                ctx.fillStyle = 'rgba(255,255,255,0.6)';
                ctx.fillText(`Colony Age: ${ageMinutes} minutes`, 400, 900);
                ctx.fillText(new Date().toLocaleDateString(), 400, 930);

                // Alt text for accessibility
                const altText = `Colony card showing ${ants.length} ants, generation ${currentGeneration}, ${unlockedAchievements.size} achievements unlocked. Theme: ${themeData.name}.`;
                cardCanvas.setAttribute('aria-label', altText);

                // Show modal
                modal.classList.add('active');

                // Show Web Share API button if available
                if (navigator.share) {
                    document.getElementById('card-share-btn').style.display = 'inline-block';
                }
            }

            // Colony card controls
            document.getElementById('card-copy-btn').onclick = async () => {
                const cardCanvas = document.getElementById('colony-card-canvas');
                try {
                    const blob = await new Promise(resolve => cardCanvas.toBlob(resolve));
                    await navigator.clipboard.write([
                        new ClipboardItem({ 'image/png': blob })
                    ]);
                    showMilestone('Copied!', 'Colony card copied to clipboard', false);
                } catch (err) {
                    showMilestone('Error', 'Clipboard not supported', false);
                }
            };

            document.getElementById('card-download-btn').onclick = () => {
                const cardCanvas = document.getElementById('colony-card-canvas');
                const link = document.createElement('a');
                link.download = `colony-card-${Date.now()}.png`;
                link.href = cardCanvas.toDataURL();
                link.click();
                showMilestone('Downloaded!', 'Colony card saved', false);
            };

            document.getElementById('card-share-btn').onclick = async () => {
                const cardCanvas = document.getElementById('colony-card-canvas');
                try {
                    const blob = await new Promise(resolve => cardCanvas.toBlob(resolve));
                    const file = new File([blob], 'colony-card.png', { type: 'image/png' });
                    await navigator.share({
                        title: 'My Colony Mind Colony',
                        text: generateColonyStory(),
                        files: [file]
                    });
                } catch (err) {
                    showMilestone('Error', 'Sharing failed', false);
                }
            };

            document.getElementById('card-close-btn').onclick = () => {
                document.getElementById('colony-card-modal').classList.remove('active');
            };

            // 2. COLONY STORY GENERATOR
            function generateColonyStory() {
                const templates = [
                    `After ${currentGeneration} generations, my colony of ${ants.length} ants has ${chambers.length} chambers & survived ${totalDeaths} deaths. üêú`,
                    `${ants.length} ants strong, generation ${currentGeneration}! Built ${chambers.length} chambers, gathering food like champions. #ColonyMind üèõÔ∏è`,
                    `My ant empire: ${ants.length} workers, ${chambers.length} chambers, ${queenFed} food gathered. Generation ${currentGeneration} thriving! üåü`,
                    `${currentGeneration} generations of survival! ${ants.length} ants call ${chambers.length} chambers home. This colony has heart! ‚ù§Ô∏èüêú`
                ];
                return templates[Math.floor(Math.random() * templates.length)];
            }

            document.getElementById('generate-story-btn').onclick = () => {
                const story = generateColonyStory();
                document.getElementById('colony-story-text').textContent = story;
            };

            document.getElementById('story-copy-btn').onclick = async () => {
                const story = document.getElementById('colony-story-text').textContent;
                try {
                    await navigator.clipboard.writeText(story);
                    showMilestone('Copied!', 'Story copied to clipboard', false);
                } catch (err) {
                    // Fallback
                    const textarea = document.createElement('textarea');
                    textarea.value = story;
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                    showMilestone('Copied!', 'Story copied', false);
                }
            };

            // 3. STATISTICS DASHBOARD
            document.getElementById('open-stats-dashboard-btn').onclick = () => {
                openStatsDashboard();
            };

            document.getElementById('share-stats-card-btn').onclick = () => {
                openStatsDashboard();
                // Auto-trigger share after opening
                setTimeout(() => {
                    document.getElementById('dashboard-share-btn').click();
                }, 500);
            };

            document.getElementById('stats-dashboard-close').onclick = () => {
                document.getElementById('stats-dashboard').classList.remove('active');
            };

            function openStatsDashboard() {
                // Update current stats
                document.getElementById('stat-population').textContent = ants.length;
                document.getElementById('stat-generation').textContent = currentGeneration;
                document.getElementById('stat-chambers').textContent = chambers.length;
                document.getElementById('stat-food').textContent = queenFed;

                // Load lifetime stats
                const legacyData = loadLegacyData();
                document.getElementById('stat-total-colonies').textContent = legacyData.totalColonies || 1;
                document.getElementById('stat-total-births').textContent = legacyData.totalAnts || totalBirths;
                document.getElementById('stat-achievements').textContent = `${unlockedAchievements.size}/33`;
                document.getElementById('stat-disasters').textContent = disastersSurvived || 0;

                document.getElementById('stats-dashboard').classList.add('active');
            }

            document.getElementById('dashboard-share-btn').onclick = () => {
                currentCardTheme = 'default';
                generateColonyCard(currentCardTheme);
                document.getElementById('stats-dashboard').classList.remove('active');
            };

            // 4. ENHANCED SCREENSHOT
            document.getElementById('screenshot-metadata-toggle').onchange = (e) => {
                screenshotMetadataEnabled = e.target.checked;
            };

            document.getElementById('quick-screenshot-btn').onclick = () => {
                captureQuickScreenshot(screenshotMetadataEnabled);
            };

            function captureQuickScreenshot(includeMetadata) {
                const screenshotCanvas = document.createElement('canvas');
                screenshotCanvas.width = W;
                screenshotCanvas.height = H;
                const screenshotCtx = screenshotCanvas.getContext('2d');

                // Copy main canvas
                screenshotCtx.drawImage(canvas, 0, 0);

                // Add metadata overlay if enabled
                if (includeMetadata) {
                    screenshotCtx.fillStyle = 'rgba(0,0,0,0.75)';
                    screenshotCtx.fillRect(10, 10, 280, 100);
                    screenshotCtx.fillStyle = '#fff';
                    screenshotCtx.font = 'bold 16px Georgia';
                    screenshotCtx.fillText('COLONY MIND', 20, 35);
                    screenshotCtx.font = '12px Georgia';
                    screenshotCtx.fillText(`Ants: ${ants.length} | Gen: ${currentGeneration}`, 20, 55);
                    screenshotCtx.fillText(`Chambers: ${chambers.length} | Food: ${queenFed}`, 20, 75);
                    screenshotCtx.fillText(new Date().toLocaleString(), 20, 95);
                }

                // Download
                const link = document.createElement('a');
                link.download = `colony-screenshot-${Date.now()}.png`;
                link.href = screenshotCanvas.toDataURL();
                link.click();

                // Auto-generate caption
                const caption = generateColonyStory();
                showMilestone('Screenshot Saved!', caption, false);

                // Try to copy caption
                if (navigator.clipboard) {
                    navigator.clipboard.writeText(caption);
                }
            }

            // 5. SCENARIO SHARING
            document.getElementById('save-scenario-btn').onclick = () => {
                exportScenarioToClipboard();
            };

            document.getElementById('scenario-import-btn').onclick = () => {
                importScenarioFromClipboard();
            };

            function exportScenarioToClipboard() {
                const scenario = {
                    name: `Custom Scenario ${Date.now()}`,
                    version: '1.0',
                    author: 'Colony Mind Player',
                    created: new Date().toISOString(),
                    difficulty: 'Custom',
                    state: {
                        ants: ants.length,
                        food: food.map(f => ({ x: f.x, y: f.y, amount: f.amount })),
                        chambers: chambers.map(c => ({ x: c.x, y: c.y, type: c.type, radius: c.radius })),
                        weather: currentWeather,
                        worldDepthMultiplier: worldDepthMultiplier
                    },
                    description: `A custom scenario with ${ants.length} ants and ${chambers.length} chambers.`
                };

                const json = JSON.stringify(scenario, null, 2);

                if (navigator.clipboard) {
                    navigator.clipboard.writeText(json).then(() => {
                        showMilestone('Exported!', 'Scenario copied to clipboard - share it!', false);
                    });
                } else {
                    // Fallback
                    const textarea = document.createElement('textarea');
                    textarea.value = json;
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                    showMilestone('Exported!', 'Scenario copied to clipboard', false);
                }
            }

            function importScenarioFromClipboard() {
                const jsonText = document.getElementById('scenario-import-text').value.trim();
                if (!jsonText) {
                    showMilestone('Error', 'Paste scenario JSON first', false);
                    return;
                }

                try {
                    const scenario = JSON.parse(jsonText);

                    // Validate
                    if (!scenario.state) {
                        throw new Error('Invalid scenario format');
                    }

                    // Apply scenario
                    createUndoSnapshot();

                    // Clear and load food
                    food.length = 0;
                    foodSpatialGrid.clear();
                    scenario.state.food.forEach(f => {
                        const foodItem = { x: f.x, y: f.y, amount: f.amount || 100, type: 'sugar' };
                        food.push(foodItem);
                        foodSpatialGrid.insert(foodItem);
                    });

                    // Load chambers
                    chambers.length = 0;
                    scenario.state.chambers.forEach(c => {
                        chambers.push({
                            x: c.x,
                            y: c.y,
                            radius: c.radius || 40,
                            type: c.type || 'NEST',
                            waterLevel: 0,
                            fungusHealth: 1.0,
                            foodProduction: 0
                        });
                    });

                    // Set weather if specified
                    if (scenario.state.weather) {
                        currentWeather = scenario.state.weather;
                    }

                    showMilestone('Loaded!', scenario.name || 'Scenario imported successfully', false);
                    document.getElementById('scenario-panel').classList.remove('visible');
                    document.getElementById('scenario-import-text').value = '';

                } catch (err) {
                    showMilestone('Error', 'Invalid scenario JSON - check format', false);
                    console.error('Scenario import error:', err);
                }
            }

            console.log('[CYCLE 12] Initialized: Share panel, colony cards, story generator, stats dashboard, enhanced screenshots, scenario sharing');
        }

        // ============ CYCLE 13: OPTIMIZATION & BUG FIXES ============
        function initializeCycle13() {
            // Fix for disaster tracking
            if (typeof disastersSurvived === 'undefined') {
                window.disastersSurvived = 0;
            }
            
            // Extract magic numbers for maintainability
            window.EXPANSION_THRESHOLD = 0.25;
            window.EXPANSION_FACTOR = 1.5;
            window.ROLE_THRESHOLD = 50;

            console.log('[CYCLE 13] Initialized: Magic numbers extracted, disaster tracking fixed, expansion logic tuned');
        }

        // ============ CYCLE 14: ADVANCED EMERGENCE ============
        function initializeCycle14() {
            // 1. ANT LEGENDS SYSTEM
            window.loadLegendsData = function() {
                try {
                    const saved = localStorage.getItem('colony_legends');
                    return saved ? JSON.parse(saved) : { legends: [] };
                } catch (e) {
                    return { legends: [] };
                }
            };

            window.saveLegendsData = function(data) {
                localStorage.setItem('colony_legends', JSON.stringify(data));
            };

            // 2. QUEEN DYNASTY SYSTEM
            window.generateQueenName = function(gen) {
                const prefixes = ["Aria", "Bella", "Cleo", "Dora", "Elsa", "Faye", "Gia", "Hera", "Iris", "Juno"];
                const suffixes = ["the Great", "the Wise", "the Bold", "the Kind", "the Swift", "the Eternal"];
                const name = prefixes[Math.floor(Math.random() * prefixes.length)];
                const suffix = suffixes[Math.floor(Math.random() * suffixes.length)];
                return `${name} ${suffix} (${gen})`;
            };

            function updateDynastyUI() {
                const nameEl = document.getElementById('current-queen-name');
                const genEl = document.getElementById('queen-generation');
                const ageEl = document.getElementById('queen-age');
                const lifespanEl = document.getElementById('queen-lifespan');

                if (nameEl) nameEl.textContent = currentQueenName || 'Queen';
                if (genEl) genEl.textContent = currentGeneration || 1;
                if (ageEl) ageEl.textContent = Math.floor(queenAge || 0);
                if (lifespanEl) lifespanEl.textContent = Math.floor(queenLifespan || 300);
            }

            // Update UI every second
            setInterval(updateDynastyUI, 1000);

            console.log('[CYCLE 14] Initialized: Ant Legends, Queen Dynasties, Seasonal Weather, Emergent Personalities');
        }

        // ============ CYCLE 15: PRESTIGE & META-PROGRESSION ============
        function initializeCycle15() {
            // Initialize Prestige Manager
            PrestigeManager.loadPrestigeData();
            
            // Setup Ascension Panel
            const ascensionBtn = document.getElementById('ascension-btn');
            if (ascensionBtn) {
                ascensionBtn.onclick = () => toggleAscensionPanel();
            }

            // Observer Camera Follow Mode
            window.observerMode = false;
            window.followedAnt = null;

            document.addEventListener('keydown', (e) => {
                if (e.key === 'o' || e.key === 'O') {
                    window.observerMode = !window.observerMode;
                    if (window.observerMode && ants.length > 0) {
                        window.followedAnt = ants[Math.floor(Math.random() * ants.length)];
                        showMilestone('Observer Mode', `Following ${window.followedAnt.name || 'Ant'}`);
                    } else {
                        window.followedAnt = null;
                        showMilestone('Observer Mode', 'Disabled');
                    }
                }
            });

            console.log('[CYCLE 15] Initialized: Prestige system, Meta-progression, Spatial grid optimizations, Observer camera');
        }

        resize();  // Initialize W, H and soil
        initAnts();
        initializeCycle6(); // CYCLE 6 initialization
        initializeCycle7(); // CYCLE 7 polish
        initializeCycle8(); // CYCLE 8 secrets & surprises
        initializeCycle10(); // CYCLE 10 challenge modes
        initializeCycle11(); // CYCLE 11 creative & sandbox mode
        initializeCycle12(); // CYCLE 12 social & sharing
        initializeCycle13(); // CYCLE 13 optimization
        initializeCycle14(); // CYCLE 14 advanced emergence
        initializeCycle15(); // CYCLE 15 prestige
        animate();
    </script>
</body>
</html>