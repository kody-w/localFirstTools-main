<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>REGEX DEFENDER // PROTECT THE CORE</title>
    <style>
        :root {
            --bg-color: #0d1117;
            --term-green: #00ff41;
            --term-red: #ff0033;
            --term-blue: #00bfff;
            --term-yellow: #f2ff00;
            --ui-bg: rgba(13, 17, 23, 0.9);
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Courier New', monospace;
            color: var(--term-green);
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            box-sizing: border-box;
            background: linear-gradient(to top, var(--bg-color) 80%, transparent);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        #input-container {
            position: relative;
            width: 600px;
            max-width: 90%;
        }

        #regex-input {
            width: 100%;
            background: rgba(0, 20, 0, 0.8);
            border: 2px solid var(--term-green);
            color: var(--term-green);
            font-family: 'Courier New', monospace;
            font-size: 1.5rem;
            padding: 15px;
            outline: none;
            box-shadow: 0 0 15px rgba(0, 255, 65, 0.3);
            border-radius: 5px;
        }

        #regex-input.error {
            border-color: var(--term-red);
            box-shadow: 0 0 15px rgba(255, 0, 51, 0.3);
            color: var(--term-red);
        }

        #regex-input::placeholder {
            color: rgba(0, 255, 65, 0.3);
        }

        .slash {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            font-size: 1.5rem;
            color: var(--term-green);
            font-weight: bold;
            pointer-events: none;
        }

        .slash.left { left: -20px; }
        .slash.right { right: -20px; }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 1.2rem;
            text-shadow: 0 0 5px var(--term-green);
            pointer-events: none;
        }

        #health-bar {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 20px;
            border: 2px solid var(--term-green);
            border-radius: 4px;
            overflow: hidden;
        }

        #health-fill {
            width: 100%;
            height: 100%;
            background-color: var(--term-green);
            transition: width 0.3s, background-color 0.3s;
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border: 2px solid var(--term-green);
            border-radius: 10px;
            display: none;
            z-index: 100;
        }

        h1 { margin: 0 0 20px 0; text-shadow: 0 0 10px var(--term-green); }
        
        button {
            background: transparent;
            border: 2px solid var(--term-green);
            color: var(--term-green);
            padding: 10px 30px;
            font-family: 'Courier New', monospace;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover {
            background: var(--term-green);
            color: black;
            box-shadow: 0 0 20px var(--term-green);
        }

        .tutorial {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border: 2px solid var(--term-blue);
            border-radius: 10px;
            max-width: 600px;
            z-index: 90;
        }

        .tag {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            margin: 0 2px;
            font-weight: bold;
        }
        .tag.email { background: rgba(0, 191, 255, 0.2); color: var(--term-blue); border: 1px solid var(--term-blue); }
        .tag.digit { background: rgba(242, 255, 0, 0.2); color: var(--term-yellow); border: 1px solid var(--term-yellow); }
        .tag.word { background: rgba(0, 255, 65, 0.2); color: var(--term-green); border: 1px solid var(--term-green); }

    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <div id="hud">
            SCORE: <span id="score">0</span><br>
            WAVE: <span id="wave">1</span>
        </div>

        <div id="health-bar">
            <div id="health-fill"></div>
        </div>

        <div id="ui-layer">
            <div id="input-container">
                <span class="slash left">/</span>
                <input type="text" id="regex-input" placeholder="Type regex pattern..." autocomplete="off" spellcheck="false">
                <span class="slash right">/g</span>
            </div>
            <div style="font-size: 0.8rem; opacity: 0.7;">Press ENTER to fire â€¢ Matches destroy targets</div>
        </div>

        <div id="start-screen" class="tutorial">
            <h1 style="color: var(--term-blue)">REGEX DEFENDER</h1>
            <p>Data packets are falling! Use Regular Expressions to intercept them.</p>
            <div style="text-align: left; margin: 20px 0; line-height: 1.6;">
                <p>ðŸŽ¯ <strong>MISSION:</strong> Type a regex pattern that matches the text of falling enemies.</p>
                <p>Examples:</p>
                <ul>
                    <li><span class="tag digit">\d+</span> matches numbers (e.g., "404", "2025")</li>
                    <li><span class="tag email">@</span> matches emails (e.g., "user@host")</li>
                    <li><span class="tag word">^[A-Z]</span> matches uppercase starts</li>
                    <li><span class="tag word">.</span> matches EVERYTHING (Emergency use!)</li>
                </ul>
            </div>
            <button onclick="startGame()">INITIALIZE SYSTEM</button>
        </div>

        <div id="game-over">
            <h1 style="color: var(--term-red)">SYSTEM FAILURE</h1>
            <p>FINAL SCORE: <span id="final-score">0</span></p>
            <button onclick="location.reload()">REBOOT</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const input = document.getElementById('regex-input');
        const scoreEl = document.getElementById('score');
        const waveEl = document.getElementById('wave');
        const healthFill = document.getElementById('health-fill');
        const finalScoreEl = document.getElementById('final-score');

        // Game State
        let enemies = [];
        let particles = [];
        let score = 0;
        let wave = 1;
        let health = 100;
        let gameActive = false;
        let lastTime = 0;
        let spawnTimer = 0;
        let spawnRate = 2000;

        // Word Banks
        const wordTypes = {
            digits: ['404', '200', '500', '1337', '8080', '12345', '007', '99.9'],
            emails: ['dev@git.io', 'root@sys', 'admin@local', 'bug@fix.me', 'spam@egg.com'],
            words: ['ERROR', 'Warning', 'Debug', 'Deploy', 'Commit', 'Push', 'Merge', 'Main'],
            files: ['index.js', 'style.css', 'app.py', 'data.json', 'image.png', 'readme.md']
        };

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        class Enemy {
            constructor() {
                this.x = Math.random() * (canvas.width - 100) + 50;
                this.y = -50;
                this.speed = Math.random() * 0.5 + 0.5 + (wave * 0.1);
                
                // Pick random type
                const types = Object.keys(wordTypes);
                this.type = types[Math.floor(Math.random() * types.length)];
                const list = wordTypes[this.type];
                this.text = list[Math.floor(Math.random() * list.length)];
                
                this.color = this.getColor();
                this.matched = false;
            }

            getColor() {
                switch(this.type) {
                    case 'digits': return '#f2ff00'; // Yellow
                    case 'emails': return '#00bfff'; // Blue
                    case 'files': return '#ff00ff'; // Magenta
                    default: return '#00ff41'; // Green
                }
            }

            update(dt) {
                this.y += this.speed;
                
                // Hit bottom
                if (this.y > canvas.height) {
                    health -= 10;
                    updateHealth();
                    return false; // Remove
                }
                return true; // Keep
            }

            draw() {
                ctx.font = 'bold 20px "Courier New"';
                ctx.fillStyle = this.color;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 10;
                ctx.fillText(this.text, this.x, this.y);
                ctx.shadowBlur = 0;

                // Draw "hitbox" line for visual flair
                ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x, 0);
                ctx.stroke();
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.vx = (Math.random() - 0.5) * 10;
                this.vy = (Math.random() - 0.5) * 10;
                this.life = 1.0;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= 0.05;
                return this.life > 0;
            }

            draw() {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, 3, 3);
                ctx.globalAlpha = 1.0;
            }
        }

        function updateHealth() {
            healthFill.style.width = `${Math.max(0, health)}%`;
            if (health <= 30) {
                healthFill.style.backgroundColor = 'var(--term-red)';
            } else {
                healthFill.style.backgroundColor = 'var(--term-green)';
            }

            if (health <= 0) {
                gameOver();
            }
        }

        function spawnEnemy() {
            enemies.push(new Enemy());
        }

        function createExplosion(x, y, color) {
            for (let i = 0; i < 15; i++) {
                particles.push(new Particle(x, y, color));
            }
        }

        function checkRegex() {
            const pattern = input.value;
            if (!pattern) return;

            try {
                const regex = new RegExp(pattern);
                let hit = false;

                // Check all enemies
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    if (regex.test(enemy.text)) {
                        // Match found!
                        createExplosion(enemy.x, enemy.y, enemy.color);
                        enemies.splice(i, 1);
                        score += 10 * wave;
                        hit = true;
                    }
                }

                if (hit) {
                    input.value = '';
                    input.classList.remove('error');
                    scoreEl.innerText = score;
                    
                    // Wave progression
                    if (score > wave * 500) {
                        wave++;
                        waveEl.innerText = wave;
                        spawnRate = Math.max(500, 2000 - (wave * 200));
                        health = Math.min(100, health + 20); // Heal on wave up
                        updateHealth();
                    }
                } else {
                    // Valid regex but no match
                    input.classList.add('error');
                    setTimeout(() => input.classList.remove('error'), 500);
                }

            } catch (e) {
                // Invalid regex syntax
                input.classList.add('error');
            }
        }

        // Input handling
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                checkRegex();
            }
            input.classList.remove('error');
        });

        function gameLoop(timestamp) {
            if (!gameActive) return;

            const dt = timestamp - lastTime;
            lastTime = timestamp;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Spawning
            spawnTimer += dt;
            if (spawnTimer > spawnRate) {
                spawnEnemy();
                spawnTimer = 0;
            }

            // Update & Draw Enemies
            enemies = enemies.filter(e => {
                const alive = e.update(dt);
                if (alive) e.draw();
                return alive;
            });

            // Update & Draw Particles
            particles = particles.filter(p => {
                const alive = p.update();
                if (alive) p.draw();
                return alive;
            });

            requestAnimationFrame(gameLoop);
        }

        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            gameActive = true;
            lastTime = performance.now();
            input.focus();
            requestAnimationFrame(gameLoop);
        }

        function gameOver() {
            gameActive = false;
            document.getElementById('game-over').style.display = 'block';
            finalScoreEl.innerText = score;
        }

    </script>
</body>
</html>