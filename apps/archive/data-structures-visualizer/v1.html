<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Structures Visualizer</title>
    <meta name="description" content="Interactive data structure visualization: arrays, linked lists, stacks, queues, trees, graphs with step-by-step animations and operations">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Monaco', monospace;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #e0e0e0;
            height: 100vh;
            overflow: hidden;
        }
        #app { display: flex; height: 100vh; }
        #sidebar {
            width: 250px;
            background: rgba(20, 30, 60, 0.95);
            border-right: 2px solid #4a9eff;
            padding: 20px;
            overflow-y: auto;
        }
        h1 { font-size: 18px; color: #4a9eff; margin-bottom: 20px; text-align: center; }
        .ds-btn {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            background: rgba(74, 158, 255, 0.2);
            border: 1px solid #4a9eff;
            border-radius: 5px;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }
        .ds-btn:hover { background: rgba(74, 158, 255, 0.4); }
        .ds-btn.active { background: #4a9eff; color: #fff; }
        #main { flex: 1; display: flex; flex-direction: column; }
        #header {
            background: rgba(20, 30, 60, 0.95);
            padding: 15px 30px;
            border-bottom: 2px solid #4a9eff;
        }
        #title { font-size: 20px; color: #4a9eff; margin-bottom: 5px; }
        #description { font-size: 12px; color: #aaa; }
        #canvas-area {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #controls {
            background: rgba(20, 30, 60, 0.95);
            padding: 20px;
            border-top: 2px solid #4a9eff;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }
        input[type="text"], input[type="number"] {
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #4a9eff;
            color: #e0e0e0;
            border-radius: 4px;
            font-family: inherit;
            font-size: 12px;
        }
        button {
            padding: 8px 16px;
            background: #4a9eff;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
        }
        button:hover { background: #5aafff; }
        .node {
            position: absolute;
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #4a9eff 0%, #357abd 100%);
            border: 2px solid #5aafff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(74, 158, 255, 0.4);
            transition: all 0.3s ease;
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="sidebar">
            <h1>ðŸ“Š Data Structures</h1>
            <button class="ds-btn active" data-ds="array">Array</button>
            <button class="ds-btn" data-ds="linkedlist">Linked List</button>
            <button class="ds-btn" data-ds="stack">Stack</button>
            <button class="ds-btn" data-ds="queue">Queue</button>
            <button class="ds-btn" data-ds="binarytree">Binary Tree</button>
            <button class="ds-btn" data-ds="graph">Graph</button>
        </div>
        <div id="main">
            <div id="header">
                <div id="title">Array Visualization</div>
                <div id="description">Dynamic array with insert, delete, and search operations</div>
            </div>
            <div id="canvas-area">
                <canvas id="canvas"></canvas>
            </div>
            <div id="controls">
                <input type="number" id="valueInput" placeholder="Value" value="42">
                <input type="number" id="indexInput" placeholder="Index" value="0">
                <button onclick="insertValue()">Insert</button>
                <button onclick="deleteValue()">Delete</button>
                <button onclick="searchValue()">Search</button>
                <button onclick="clearDS()">Clear</button>
                <button onclick="randomize()">Random Fill</button>
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let currentDS = 'array';
        let data = [10, 20, 30, 40, 50];

        function resize() {
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
            render();
        }
        resize();
        window.addEventListener('resize', resize);

        const dataStructures = {
            array: {
                title: 'Array Visualization',
                description: 'Dynamic array with insert, delete, and search operations',
                draw: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    const cellWidth = 80;
                    const cellHeight = 60;
                    const startX = (canvas.width - data.length * cellWidth) / 2;
                    const startY = canvas.height / 2 - cellHeight / 2;

                    data.forEach((val, i) => {
                        const x = startX + i * cellWidth;
                        ctx.fillStyle = '#4a9eff';
                        ctx.fillRect(x, startY, cellWidth - 5, cellHeight);
                        ctx.strokeStyle = '#5aafff';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x, startY, cellWidth - 5, cellHeight);

                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 20px Monaco';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(val, x + (cellWidth - 5) / 2, startY + cellHeight / 2);

                        ctx.fillStyle = '#aaa';
                        ctx.font = '12px Monaco';
                        ctx.fillText(`[${i}]`, x + (cellWidth - 5) / 2, startY + cellHeight + 20);
                    });
                }
            },
            linkedlist: {
                title: 'Linked List Visualization',
                description: 'Singly linked list with node insertion and traversal',
                draw: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    const nodeRadius = 30;
                    const spacing = 120;
                    const startX = 100;
                    const y = canvas.height / 2;

                    data.forEach((val, i) => {
                        const x = startX + i * spacing;

                        ctx.fillStyle = '#4a9eff';
                        ctx.beginPath();
                        ctx.arc(x, y, nodeRadius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#5aafff';
                        ctx.lineWidth = 3;
                        ctx.stroke();

                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 18px Monaco';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(val, x, y);

                        if (i < data.length - 1) {
                            ctx.strokeStyle = '#5aafff';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(x + nodeRadius, y);
                            ctx.lineTo(x + spacing - nodeRadius - 10, y);
                            ctx.stroke();

                            ctx.beginPath();
                            ctx.moveTo(x + spacing - nodeRadius - 10, y);
                            ctx.lineTo(x + spacing - nodeRadius - 20, y - 8);
                            ctx.lineTo(x + spacing - nodeRadius - 20, y + 8);
                            ctx.closePath();
                            ctx.fill();
                        }
                    });
                }
            },
            stack: {
                title: 'Stack (LIFO)',
                description: 'Last In First Out - Push and Pop operations',
                draw: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    const cellWidth = 120;
                    const cellHeight = 50;
                    const x = canvas.width / 2 - cellWidth / 2;
                    const bottomY = canvas.height - 100;

                    data.forEach((val, i) => {
                        const y = bottomY - i * cellHeight;
                        ctx.fillStyle = '#4a9eff';
                        ctx.fillRect(x, y, cellWidth, cellHeight - 5);
                        ctx.strokeStyle = '#5aafff';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x, y, cellWidth, cellHeight - 5);

                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 18px Monaco';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(val, x + cellWidth / 2, y + (cellHeight - 5) / 2);
                    });

                    ctx.fillStyle = '#aaa';
                    ctx.font = '14px Monaco';
                    ctx.fillText('â† TOP', x + cellWidth + 40, bottomY - (data.length - 1) * cellHeight + 25);
                }
            },
            queue: {
                title: 'Queue (FIFO)',
                description: 'First In First Out - Enqueue and Dequeue operations',
                draw: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    const cellWidth = 80;
                    const cellHeight = 60;
                    const startX = 100;
                    const y = canvas.height / 2 - cellHeight / 2;

                    data.forEach((val, i) => {
                        const x = startX + i * cellWidth;
                        ctx.fillStyle = '#4a9eff';
                        ctx.fillRect(x, y, cellWidth - 5, cellHeight);
                        ctx.strokeStyle = '#5aafff';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x, y, cellWidth - 5, cellHeight);

                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 18px Monaco';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(val, x + (cellWidth - 5) / 2, y + cellHeight / 2);
                    });

                    ctx.fillStyle = '#aaa';
                    ctx.font = '14px Monaco';
                    ctx.fillText('FRONT', startX, y - 20);
                    ctx.fillText('REAR', startX + (data.length - 1) * cellWidth, y - 20);
                }
            },
            binarytree: {
                title: 'Binary Tree',
                description: 'Hierarchical binary tree structure',
                draw: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    if (data.length === 0) return;

                    const nodeRadius = 25;
                    const levelHeight = 80;
                    const rootX = canvas.width / 2;

                    function drawNode(val, x, y, level) {
                        ctx.fillStyle = '#4a9eff';
                        ctx.beginPath();
                        ctx.arc(x, y, nodeRadius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#5aafff';
                        ctx.lineWidth = 2;
                        ctx.stroke();

                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 16px Monaco';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(val, x, y);
                    }

                    function drawTree(index, x, y, level) {
                        if (index >= data.length || data[index] === null) return;

                        drawNode(data[index], x, y, level);

                        const offset = Math.pow(2, 4 - level) * 30;
                        const nextY = y + levelHeight;

                        const leftIndex = 2 * index + 1;
                        if (leftIndex < data.length && data[leftIndex] !== null) {
                            const leftX = x - offset;
                            ctx.strokeStyle = '#5aafff';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(x, y + nodeRadius);
                            ctx.lineTo(leftX, nextY - nodeRadius);
                            ctx.stroke();
                            drawTree(leftIndex, leftX, nextY, level + 1);
                        }

                        const rightIndex = 2 * index + 2;
                        if (rightIndex < data.length && data[rightIndex] !== null) {
                            const rightX = x + offset;
                            ctx.strokeStyle = '#5aafff';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(x, y + nodeRadius);
                            ctx.lineTo(rightX, nextY - nodeRadius);
                            ctx.stroke();
                            drawTree(rightIndex, rightX, nextY, level + 1);
                        }
                    }

                    drawTree(0, rootX, 80, 0);
                }
            },
            graph: {
                title: 'Graph Visualization',
                description: 'Vertices and edges in a graph structure',
                draw: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    const nodeRadius = 30;
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    const radius = Math.min(canvas.width, canvas.height) * 0.3;

                    const positions = data.map((_, i) => {
                        const angle = (i / data.length) * Math.PI * 2 - Math.PI / 2;
                        return {
                            x: centerX + Math.cos(angle) * radius,
                            y: centerY + Math.sin(angle) * radius
                        };
                    });

                    // Draw edges
                    ctx.strokeStyle = '#5aafff';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < positions.length; i++) {
                        for (let j = i + 1; j < positions.length; j++) {
                            if (Math.random() > 0.6) {
                                ctx.beginPath();
                                ctx.moveTo(positions[i].x, positions[i].y);
                                ctx.lineTo(positions[j].x, positions[j].y);
                                ctx.stroke();
                            }
                        }
                    }

                    // Draw nodes
                    positions.forEach((pos, i) => {
                        ctx.fillStyle = '#4a9eff';
                        ctx.beginPath();
                        ctx.arc(pos.x, pos.y, nodeRadius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#5aafff';
                        ctx.lineWidth = 3;
                        ctx.stroke();

                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 16px Monaco';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(data[i], pos.x, pos.y);
                    });
                }
            }
        };

        function render() {
            dataStructures[currentDS].draw();
        }

        document.querySelectorAll('.ds-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.ds-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentDS = btn.dataset.ds;
                document.getElementById('title').textContent = dataStructures[currentDS].title;
                document.getElementById('description').textContent = dataStructures[currentDS].description;

                // Reset data for specific structures
                if (currentDS === 'binarytree') {
                    data = [50, 30, 70, 20, 40, 60, 80];
                } else {
                    data = [10, 20, 30, 40, 50];
                }
                render();
            });
        });

        window.insertValue = function() {
            const val = parseInt(document.getElementById('valueInput').value);
            const idx = parseInt(document.getElementById('indexInput').value);
            if (!isNaN(val)) {
                if (currentDS === 'stack') {
                    data.push(val);
                } else if (currentDS === 'queue') {
                    data.push(val);
                } else if (!isNaN(idx) && idx >= 0) {
                    data.splice(idx, 0, val);
                } else {
                    data.push(val);
                }
                render();
            }
        };

        window.deleteValue = function() {
            const idx = parseInt(document.getElementById('indexInput').value);
            if (currentDS === 'stack') {
                data.pop();
            } else if (currentDS === 'queue') {
                data.shift();
            } else if (!isNaN(idx) && idx >= 0 && idx < data.length) {
                data.splice(idx, 1);
            } else {
                data.pop();
            }
            render();
        };

        window.searchValue = function() {
            const val = parseInt(document.getElementById('valueInput').value);
            const idx = data.indexOf(val);
            alert(idx !== -1 ? `Found at index ${idx}` : 'Not found');
        };

        window.clearDS = function() {
            data = [];
            render();
        };

        window.randomize = function() {
            data = Array.from({length: 8}, () => Math.floor(Math.random() * 90) + 10);
            render();
        };

        render();
    </script>
</body>
</html>