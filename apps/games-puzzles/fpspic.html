<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FaceCraft Arena - Bot Battle FPS</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: #000;
            overflow: hidden;
            cursor: none;
        }
        
        #gameCanvas {
            display: block;
            background: linear-gradient(to bottom, #87CEEB 0%, #98D8E8 50%, #7EC850 100%);
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 24px;
            height: 24px;
            border: 3px solid rgba(255, 0, 0, 0.8);
            border-radius: 50%;
            box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.5), 0 0 15px rgba(255, 0, 0, 0.3);
        }
        
        #crosshair::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 6px;
            height: 6px;
            background: rgba(255, 0, 0, 0.9);
            border-radius: 50%;
            box-shadow: 0 0 8px rgba(255, 0, 0, 0.6);
        }
        
        #hud {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            font-size: 14px;
            line-height: 1.6;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
        }
        
        #scoreBoard {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            font-size: 16px;
            background: rgba(0, 0, 0, 0.4);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
            border: 2px solid rgba(255, 215, 0, 0.5);
        }
        
        #photoCollection {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.4);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
            max-width: 300px;
        }
        
        .collected-photo {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            margin: 5px;
            display: inline-block;
            border: 2px solid #FFD700;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .collected-photo:hover {
            transform: scale(1.2);
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            font-size: 12px;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
        }
        
        #webcamPreview {
            position: absolute;
            bottom: 100px;
            left: 20px;
            width: 150px;
            height: 112px;
            border-radius: 10px;
            border: 3px solid rgba(255, 255, 255, 0.5);
            background: rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }
        
        #webcamVideo {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        #killFeed {
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            color: white;
            font-size: 14px;
            text-align: right;
            max-height: 300px;
            overflow: hidden;
        }
        
        .kill-message {
            background: rgba(255, 0, 0, 0.8);
            padding: 8px 12px;
            margin: 5px 0;
            border-radius: 5px;
            animation: slideInRight 0.5s ease, fadeOut 0.5s ease 4.5s;
        }
        
        #gameSetup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        #gameSetup button {
            background: linear-gradient(45deg, #FF6B6B, #FF8E8E);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 16px;
            border-radius: 8px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s ease;
            pointer-events: all;
        }
        
        #gameSetup button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(255, 107, 107, 0.3);
        }
        
        .respawn-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            font-size: 18px;
            backdrop-filter: blur(10px);
        }
        
        .photo-capture-effect {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            animation: photoFlash 0.3s ease;
            pointer-events: none;
        }
        
        @keyframes slideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes fadeOut {
            to { opacity: 0; transform: translateX(100%); }
        }
        
        @keyframes photoFlash {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }
        
        .hidden { display: none !important; }
        
        #downloadedPhotos {
            position: absolute;
            bottom: 280px;
            left: 20px;
            color: white;
            font-size: 12px;
        }
        
        .cpu-nametag {
            position: absolute;
            color: white;
            font-size: 12px;
            text-align: center;
            background: rgba(0, 0, 0, 0.7);
            padding: 2px 8px;
            border-radius: 4px;
            pointer-events: none;
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <div id="gameSetup">
            <h2>üéØ FaceCraft Arena</h2>
            <p>Bot Battle FPS</p>
            <p style="margin: 15px 0; font-size: 14px;">
                üì∏ Capture bot photos by eliminating them!<br>
                üéØ Battle against AI opponents<br>
                üèÜ Collect the most photos to win!
            </p>
            <button id="startGame">Start Game</button>
            <button id="startGameWithCam">Start with Webcam</button>
            <div style="margin-top: 15px; font-size: 12px; opacity: 0.8;">
                Play with or without camera
            </div>
        </div>
        
        <div id="crosshair" class="hidden"></div>
        
        <div id="scoreBoard" class="hidden">
            <div style="color: #FFD700; font-weight: bold; margin-bottom: 10px;">üì∏ PHOTO HUNT</div>
            <div>Score: <span id="playerScore">0</span></div>
            <div>Kills: <span id="playerKills">0</span></div>
            <div>Deaths: <span id="playerDeaths">0</span></div>
            <div style="margin-top: 10px; font-size: 12px;">
                Bots Active: <span id="botsActive">5</span>
            </div>
        </div>
        
        <div id="photoCollection" class="hidden">
            <div style="color: #FFD700; font-weight: bold; margin-bottom: 10px;">üì∑ Collected Photos</div>
            <div id="collectedPhotos"></div>
            <button id="exportPhotos" style="margin-top: 10px; padding: 5px 10px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; pointer-events: all;">üíæ Export All</button>
        </div>
        
        <div id="webcamPreview" class="hidden">
            <video id="webcamVideo" autoplay muted playsinline></video>
        </div>
        
        <div id="hud" class="hidden">
            <div>Health: <span id="health">100</span>/100</div>
            <div>Ammo: <span id="ammo">30</span>/30</div>
            <div>FPS: <span id="fps">60</span></div>
            <div>Position: <span id="position">0, 0, 0</span></div>
        </div>
        
        <div id="instructions" class="hidden">
            <strong>CONTROLS</strong><br>
            WASD - Move<br>
            Mouse - Look<br>
            Shift - Run<br>
            Space - Jump<br>
            Click - Shoot<br>
            R - Reload<br>
            ESC - Menu
        </div>
        
        <div id="killFeed"></div>
        
        <div id="downloadedPhotos" class="hidden">
            <div>üìÅ Downloaded Photos: <span id="downloadCount">0</span></div>
        </div>
    </div>

    <!-- Hidden canvas for photo capture -->
    <canvas id="photoCanvas" style="display: none;"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class FaceCraftArena {
            constructor() {
                this.gameStarted = false;
                this.webcamStream = null;
                this.useWebcam = false;
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: document.getElementById('gameCanvas'),
                    antialias: true 
                });
                
                this.setupRenderer();
                this.setupLighting();
                this.setupGameState();
                this.setupUI();
                this.setupControls();
                this.setupWorld();
                
                // Clean up handlers
                this.nametags = [];
                this.animationId = null;
            }
            
            setupRenderer() {
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x87CEEB);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                
                // Fog for depth
                this.scene.fog = new THREE.Fog(0x87CEEB, 50, 300);
            }
            
            setupLighting() {
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);
                
                this.sunLight = new THREE.DirectionalLight(0xffffff, 1);
                this.sunLight.position.set(50, 100, 50);
                this.sunLight.castShadow = true;
                this.sunLight.shadow.mapSize.width = 2048;
                this.sunLight.shadow.mapSize.height = 2048;
                this.sunLight.shadow.camera.near = 0.5;
                this.sunLight.shadow.camera.far = 200;
                this.sunLight.shadow.camera.left = -50;
                this.sunLight.shadow.camera.right = 50;
                this.sunLight.shadow.camera.top = 50;
                this.sunLight.shadow.camera.bottom = -50;
                this.scene.add(this.sunLight);
                
                // Add hemisphere light for better outdoor feel
                const hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x7EC850, 0.3);
                this.scene.add(hemiLight);
            }
            
            setupGameState() {
                this.gameState = {
                    health: 100,
                    maxHealth: 100,
                    ammo: 30,
                    maxAmmo: 30,
                    score: 0,
                    kills: 0,
                    deaths: 0,
                    isAlive: true,
                    collectedPhotos: [],
                    downloadedCount: 0
                };
                
                this.cpuPlayers = [];
                this.bullets = [];
                this.respawnTime = 0;
            }
            
            setupUI() {
                document.getElementById('startGame').addEventListener('click', () => this.startGame(false));
                document.getElementById('startGameWithCam').addEventListener('click', () => this.startGame(true));
                document.getElementById('exportPhotos').addEventListener('click', () => this.exportAllPhotos());
                
                this.stats = {
                    fps: 60,
                    frameCount: 0,
                    lastTime: performance.now()
                };
            }
            
            setupControls() {
                this.keys = {};
                this.mouse = { x: 0, y: 0, sensitivity: 0.002 };
                this.player = {
                    position: new THREE.Vector3(0, 10, 0),
                    velocity: new THREE.Vector3(0, 0, 0),
                    rotation: { x: 0, y: 0 },
                    speed: 0.15,
                    jumpPower: 0.3,
                    onGround: false,
                    height: 2,
                    radius: 0.5
                };
                
                this.camera.position.copy(this.player.position);
                
                // Mouse controls
                document.addEventListener('click', (e) => {
                    if (this.gameStarted && !e.target.closest('button')) {
                        if (document.pointerLockElement) {
                            this.shoot();
                        } else {
                            document.body.requestPointerLock();
                        }
                    }
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (document.pointerLockElement && this.gameState.isAlive) {
                        this.player.rotation.y -= e.movementX * this.mouse.sensitivity;
                        this.player.rotation.x -= e.movementY * this.mouse.sensitivity;
                        this.player.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.player.rotation.x));
                    }
                });
                
                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    if (e.code === 'KeyR' && this.gameStarted) this.reload();
                    if (e.code === 'Escape' && this.gameStarted) {
                        if (document.pointerLockElement) {
                            document.exitPointerLock();
                        } else {
                            document.body.requestPointerLock();
                        }
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
                
                // Prevent right click menu
                document.addEventListener('contextmenu', (e) => e.preventDefault());
            }
            
            async startGame(withWebcam) {
                this.useWebcam = withWebcam;
                
                if (withWebcam) {
                    try {
                        this.webcamStream = await navigator.mediaDevices.getUserMedia({ 
                            video: { width: 640, height: 480, facingMode: 'user' } 
                        });
                        
                        const video = document.getElementById('webcamVideo');
                        video.srcObject = this.webcamStream;
                        document.getElementById('webcamPreview').classList.remove('hidden');
                    } catch (error) {
                        console.log('Camera not available, continuing without webcam');
                        this.useWebcam = false;
                    }
                }
                
                // Hide setup, show game UI
                document.getElementById('gameSetup').classList.add('hidden');
                document.getElementById('crosshair').classList.remove('hidden');
                document.getElementById('scoreBoard').classList.remove('hidden');
                document.getElementById('photoCollection').classList.remove('hidden');
                document.getElementById('hud').classList.remove('hidden');
                document.getElementById('instructions').classList.remove('hidden');
                document.getElementById('downloadedPhotos').classList.remove('hidden');
                
                this.gameStarted = true;
                
                // Generate world and start game
                this.generateSimpleWorld();
                this.generateCPUPlayers();
                this.startGameLoop();
                
                // Request pointer lock after a short delay
                setTimeout(() => {
                    document.body.requestPointerLock();
                }, 100);
            }
            
            setupWorld() {
                this.world = {
                    size: 200,
                    blocks: []
                };
            }
            
            generateSimpleWorld() {
                // Create ground
                const groundGeometry = new THREE.PlaneGeometry(this.world.size, this.world.size);
                const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x7EC850 });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                this.scene.add(ground);
                
                // Create some buildings/obstacles
                const buildingMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
                const treeMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                const woodMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                
                // Add buildings
                for (let i = 0; i < 15; i++) {
                    const width = Math.random() * 10 + 5;
                    const height = Math.random() * 20 + 10;
                    const depth = Math.random() * 10 + 5;
                    
                    const building = new THREE.Mesh(
                        new THREE.BoxGeometry(width, height, depth),
                        buildingMaterial
                    );
                    
                    building.position.set(
                        (Math.random() - 0.5) * (this.world.size - 20),
                        height / 2,
                        (Math.random() - 0.5) * (this.world.size - 20)
                    );
                    
                    building.castShadow = true;
                    building.receiveShadow = true;
                    this.scene.add(building);
                    this.world.blocks.push(building);
                }
                
                // Add trees
                for (let i = 0; i < 20; i++) {
                    // Tree trunk
                    const trunk = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.5, 0.7, 5),
                        woodMaterial
                    );
                    
                    trunk.position.set(
                        (Math.random() - 0.5) * this.world.size,
                        2.5,
                        (Math.random() - 0.5) * this.world.size
                    );
                    
                    trunk.castShadow = true;
                    trunk.receiveShadow = true;
                    this.scene.add(trunk);
                    this.world.blocks.push(trunk);
                    
                    // Tree leaves
                    const leaves = new THREE.Mesh(
                        new THREE.SphereGeometry(3, 8, 6),
                        treeMaterial
                    );
                    
                    leaves.position.copy(trunk.position);
                    leaves.position.y += 5;
                    
                    leaves.castShadow = true;
                    leaves.receiveShadow = true;
                    this.scene.add(leaves);
                }
                
                // Add some cover objects
                const coverMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
                for (let i = 0; i < 30; i++) {
                    const cover = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 1.5, 2),
                        coverMaterial
                    );
                    
                    cover.position.set(
                        (Math.random() - 0.5) * this.world.size,
                        0.75,
                        (Math.random() - 0.5) * this.world.size
                    );
                    
                    cover.castShadow = true;
                    cover.receiveShadow = true;
                    this.scene.add(cover);
                    this.world.blocks.push(cover);
                }
            }
            
            generateCPUPlayers() {
                const names = ['AIBot_Alpha', 'CyberSniper', 'BlockHunter', 'PixelWarrior', 'DataGhost'];
                const colors = [0xFF6B6B, 0x4ECDC4, 0x45B7D1, 0x96CEB4, 0xFCEA2B];
                
                for (let i = 0; i < 5; i++) {
                    const cpu = {
                        id: `cpu_${i}`,
                        name: names[i],
                        position: new THREE.Vector3(
                            (Math.random() - 0.5) * 100,
                            2,
                            (Math.random() - 0.5) * 100
                        ),
                        rotation: { x: 0, y: Math.random() * Math.PI * 2 },
                        health: 100,
                        isAlive: true,
                        target: null,
                        lastShot: 0,
                        moveDirection: new THREE.Vector3(),
                        velocity: new THREE.Vector3(),
                        mesh: null,
                        nametag: null,
                        photo: null,
                        lastMove: Date.now(),
                        nextMoveChange: Math.random() * 3000 + 1000,
                        color: colors[i],
                        height: 2,
                        radius: 0.5,
                        onGround: true
                    };
                    
                    cpu.photo = this.generateCPUPhoto(cpu.name, cpu.color);
                    this.createCPUMesh(cpu);
                    this.cpuPlayers.push(cpu);
                }
                
                this.updateBotsActive();
            }
            
            generateCPUPhoto(name, color) {
                const canvas = document.createElement('canvas');
                canvas.width = 128;
                canvas.height = 128;
                const ctx = canvas.getContext('2d');
                
                // Background
                ctx.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
                ctx.fillRect(0, 0, 128, 128);
                
                // Create robot face pattern
                ctx.fillStyle = '#000';
                
                // Eyes
                ctx.fillRect(30, 40, 20, 20);
                ctx.fillRect(78, 40, 20, 20);
                
                // Mouth
                ctx.fillRect(40, 80, 48, 8);
                
                // Add some digital effects
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(10, 10);
                ctx.lineTo(20, 10);
                ctx.moveTo(108, 10);
                ctx.lineTo(118, 10);
                ctx.moveTo(10, 118);
                ctx.lineTo(20, 118);
                ctx.moveTo(108, 118);
                ctx.lineTo(118, 118);
                ctx.stroke();
                
                // Name initial
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(name[0], 64, 25);
                
                return canvas.toDataURL();
            }
            
            createCPUMesh(cpu) {
                // Create a group for the CPU
                const group = new THREE.Group();
                
                // Create body
                const bodyGeometry = new THREE.BoxGeometry(1, 1.5, 0.6);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: cpu.color });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.75;
                body.castShadow = true;
                body.receiveShadow = true;
                group.add(body);
                
                // Create head with face texture
                const headGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                const canvas = this.photoToCanvas(cpu.photo);
                const texture = new THREE.CanvasTexture(canvas);
                texture.needsUpdate = true;
                
                const materials = [
                    new THREE.MeshLambertMaterial({ color: cpu.color }), // right
                    new THREE.MeshLambertMaterial({ color: cpu.color }), // left
                    new THREE.MeshLambertMaterial({ color: cpu.color }), // top
                    new THREE.MeshLambertMaterial({ color: cpu.color }), // bottom
                    new THREE.MeshLambertMaterial({ map: texture }),     // front
                    new THREE.MeshLambertMaterial({ color: cpu.color })  // back
                ];
                
                const head = new THREE.Mesh(headGeometry, materials);
                head.position.y = 1.9;
                head.castShadow = true;
                head.receiveShadow = true;
                group.add(head);
                
                // Arms
                const armGeometry = new THREE.BoxGeometry(0.3, 1, 0.3);
                const armMaterial = new THREE.MeshLambertMaterial({ color: cpu.color });
                
                const leftArm = new THREE.Mesh(armGeometry, armMaterial);
                leftArm.position.set(-0.65, 0.75, 0);
                leftArm.castShadow = true;
                group.add(leftArm);
                
                const rightArm = new THREE.Mesh(armGeometry, armMaterial);
                rightArm.position.set(0.65, 0.75, 0);
                rightArm.castShadow = true;
                group.add(rightArm);
                
                // Position the group
                group.position.copy(cpu.position);
                
                cpu.mesh = group;
                cpu.head = head;
                this.scene.add(group);
                
                // Create nametag
                this.createNametag(cpu);
            }
            
            createNametag(cpu) {
                const nametagDiv = document.createElement('div');
                nametagDiv.className = 'cpu-nametag';
                nametagDiv.textContent = cpu.name;
                nametagDiv.style.display = 'none';
                document.body.appendChild(nametagDiv);
                cpu.nametag = nametagDiv;
                this.nametags.push(nametagDiv);
            }
            
            photoToCanvas(dataUrl) {
                const canvas = document.createElement('canvas');
                canvas.width = 128;
                canvas.height = 128;
                const ctx = canvas.getContext('2d');
                
                const img = new Image();
                img.onload = () => {
                    ctx.drawImage(img, 0, 0, 128, 128);
                };
                img.src = dataUrl;
                
                // Draw immediately with data URL
                ctx.fillStyle = '#888';
                ctx.fillRect(0, 0, 128, 128);
                
                return canvas;
            }
            
            updatePlayer() {
                if (!this.gameState.isAlive) return;
                
                const speed = this.keys['ShiftLeft'] ? this.player.speed * 2 : this.player.speed;
                
                // Movement
                const direction = new THREE.Vector3();
                if (this.keys['KeyW']) direction.z -= 1;
                if (this.keys['KeyS']) direction.z += 1;
                if (this.keys['KeyA']) direction.x -= 1;
                if (this.keys['KeyD']) direction.x += 1;
                
                direction.normalize();
                direction.multiplyScalar(speed);
                
                // Apply rotation to direction
                const rotation = new THREE.Euler(0, this.player.rotation.y, 0);
                direction.applyEuler(rotation);
                
                this.player.velocity.x = direction.x;
                this.player.velocity.z = direction.z;
                
                // Jumping
                if (this.keys['Space'] && this.player.onGround) {
                    this.player.velocity.y = this.player.jumpPower;
                    this.player.onGround = false;
                }
                
                // Gravity
                if (!this.player.onGround) {
                    this.player.velocity.y -= 0.015;
                }
                
                // Save old position for collision rollback
                const oldPosition = this.player.position.clone();
                
                // Update position
                this.player.position.add(this.player.velocity);
                
                // Ground collision
                if (this.player.position.y < this.player.height / 2) {
                    this.player.position.y = this.player.height / 2;
                    this.player.velocity.y = 0;
                    this.player.onGround = true;
                }
                
                // World boundary
                const boundary = this.world.size / 2 - 5;
                this.player.position.x = Math.max(-boundary, Math.min(boundary, this.player.position.x));
                this.player.position.z = Math.max(-boundary, Math.min(boundary, this.player.position.z));
                
                // Simple collision with obstacles
                let collision = false;
                for (const block of this.world.blocks) {
                    if (this.checkPlayerBlockCollision(this.player.position, block)) {
                        collision = true;
                        break;
                    }
                }
                
                if (collision) {
                    this.player.position.copy(oldPosition);
                }
                
                // Update camera
                this.camera.position.copy(this.player.position);
                this.camera.position.y += this.player.height / 2;
                
                // Update camera rotation
                this.camera.quaternion.setFromEuler(new THREE.Euler(
                    this.player.rotation.x,
                    this.player.rotation.y,
                    0,
                    'YXZ'
                ));
            }
            
            checkPlayerBlockCollision(playerPos, block) {
                const blockBox = new THREE.Box3().setFromObject(block);
                const playerBox = new THREE.Box3(
                    new THREE.Vector3(
                        playerPos.x - this.player.radius,
                        playerPos.y - this.player.height / 2,
                        playerPos.z - this.player.radius
                    ),
                    new THREE.Vector3(
                        playerPos.x + this.player.radius,
                        playerPos.y + this.player.height / 2,
                        playerPos.z + this.player.radius
                    )
                );
                
                return blockBox.intersectsBox(playerBox);
            }
            
            updateCPUPlayers() {
                const currentTime = Date.now();
                
                this.cpuPlayers.forEach(cpu => {
                    if (!cpu.isAlive) return;
                    
                    // Update nametag position
                    if (cpu.nametag && cpu.mesh) {
                        const screenPos = cpu.position.clone();
                        screenPos.y += 3;
                        screenPos.project(this.camera);
                        
                        if (screenPos.z < 1 && screenPos.z > -1) {
                            const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
                            const y = (screenPos.y * -0.5 + 0.5) * window.innerHeight;
                            
                            cpu.nametag.style.left = (x - cpu.nametag.offsetWidth/2) + 'px';
                            cpu.nametag.style.top = (y - 30) + 'px';
                            cpu.nametag.style.display = 'block';
                        } else {
                            cpu.nametag.style.display = 'none';
                        }
                    }
                    
                    // AI Movement
                    if (currentTime - cpu.lastMove > cpu.nextMoveChange) {
                        // Random movement with some intelligence
                        const toPlayer = this.player.position.clone().sub(cpu.position);
                        const distance = toPlayer.length();
                        
                        if (distance < 50 && Math.random() < 0.7) {
                            // Move towards or away from player
                            if (distance < 20) {
                                // Too close, move away
                                cpu.moveDirection = toPlayer.normalize().multiplyScalar(-1);
                            } else {
                                // Move towards player
                                cpu.moveDirection = toPlayer.normalize();
                            }
                            // Add some randomness
                            cpu.moveDirection.x += (Math.random() - 0.5) * 0.5;
                            cpu.moveDirection.z += (Math.random() - 0.5) * 0.5;
                        } else {
                            // Random movement
                            cpu.moveDirection = new THREE.Vector3(
                                (Math.random() - 0.5) * 2,
                                0,
                                (Math.random() - 0.5) * 2
                            );
                        }
                        
                        cpu.moveDirection.normalize();
                        cpu.lastMove = currentTime;
                        cpu.nextMoveChange = Math.random() * 3000 + 1000;
                    }
                    
                    // Save old position for collision
                    const oldPosition = cpu.position.clone();
                    
                    // Move CPU
                    const moveSpeed = 0.08;
                    cpu.velocity.x = cpu.moveDirection.x * moveSpeed;
                    cpu.velocity.z = cpu.moveDirection.z * moveSpeed;
                    
                    // Apply gravity
                    if (!cpu.onGround) {
                        cpu.velocity.y -= 0.015;
                    } else {
                        cpu.velocity.y = 0;
                    }
                    
                    // Update position
                    cpu.position.add(cpu.velocity);
                    
                    // Ground collision
                    if (cpu.position.y < cpu.height / 2) {
                        cpu.position.y = cpu.height / 2;
                        cpu.velocity.y = 0;
                        cpu.onGround = true;
                    }
                    
                    // World boundary
                    const boundary = this.world.size / 2 - 5;
                    cpu.position.x = Math.max(-boundary, Math.min(boundary, cpu.position.x));
                    cpu.position.z = Math.max(-boundary, Math.min(boundary, cpu.position.z));
                    
                    // Check collisions with obstacles
                    let collision = false;
                    for (const block of this.world.blocks) {
                        if (this.checkCPUBlockCollision(cpu, block)) {
                            collision = true;
                            break;
                        }
                    }
                    
                    if (collision) {
                        cpu.position.copy(oldPosition);
                        // Change direction on collision
                        cpu.moveDirection.x = -cpu.moveDirection.x + (Math.random() - 0.5) * 0.5;
                        cpu.moveDirection.z = -cpu.moveDirection.z + (Math.random() - 0.5) * 0.5;
                        cpu.moveDirection.normalize();
                    }
                    
                    // Update mesh position and rotation
                    if (cpu.mesh) {
                        cpu.mesh.position.copy(cpu.position);
                        // Make CPU face movement direction
                        if (cpu.moveDirection.length() > 0.1) {
                            const angle = Math.atan2(cpu.moveDirection.x, cpu.moveDirection.z);
                            cpu.mesh.rotation.y = angle;
                        }
                    }
                    
                    // AI Shooting
                    const distanceToPlayer = cpu.position.distanceTo(this.player.position);
                    if (distanceToPlayer < 40 && this.gameState.isAlive) {
                        // Check line of sight
                        const hasLineOfSight = this.checkLineOfSight(cpu.position, this.player.position);
                        
                        if (hasLineOfSight && currentTime - cpu.lastShot > 2000 && Math.random() < 0.4) {
                            this.cpuShoot(cpu);
                            cpu.lastShot = currentTime;
                        }
                    }
                });
            }
            
            checkCPUBlockCollision(cpu, block) {
                const blockBox = new THREE.Box3().setFromObject(block);
                const cpuBox = new THREE.Box3(
                    new THREE.Vector3(
                        cpu.position.x - cpu.radius,
                        cpu.position.y - cpu.height / 2,
                        cpu.position.z - cpu.radius
                    ),
                    new THREE.Vector3(
                        cpu.position.x + cpu.radius,
                        cpu.position.y + cpu.height / 2,
                        cpu.position.z + cpu.radius
                    )
                );
                
                return blockBox.intersectsBox(cpuBox);
            }
            
            checkLineOfSight(from, to) {
                const direction = to.clone().sub(from).normalize();
                const distance = from.distanceTo(to);
                const raycaster = new THREE.Raycaster(from, direction, 0, distance);
                
                const intersects = raycaster.intersectObjects(this.world.blocks);
                return intersects.length === 0;
            }
            
            cpuShoot(cpu) {
                // Predict player movement
                const targetPos = this.player.position.clone();
                const distance = cpu.position.distanceTo(targetPos);
                const travelTime = distance / 1.5; // bullet speed
                
                // Add some prediction
                targetPos.add(this.player.velocity.clone().multiplyScalar(travelTime * 0.5));
                
                // Add some inaccuracy
                targetPos.x += (Math.random() - 0.5) * 2;
                targetPos.y += (Math.random() - 0.5) * 1;
                targetPos.z += (Math.random() - 0.5) * 2;
                
                const direction = targetPos.sub(cpu.position).normalize();
                
                const bullet = {
                    position: cpu.position.clone(),
                    position: new THREE.Vector3(
                        cpu.position.x,
                        cpu.position.y + cpu.height / 2,
                        cpu.position.z
                    ),
                    direction: direction,
                    speed: 1.5,
                    life: 100,
                    shooter: cpu,
                    damage: 25,
                    mesh: null
                };
                
                // Create bullet visual
                const bulletGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const bulletMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 0.5
                });
                bullet.mesh = new THREE.Mesh(bulletGeometry, bulletMaterial);
                bullet.mesh.position.copy(bullet.position);
                this.scene.add(bullet.mesh);
                
                this.bullets.push(bullet);
            }
            
            shoot() {
                if (this.gameState.ammo <= 0 || !this.gameState.isAlive) {
                    if (this.gameState.ammo <= 0) {
                        this.addKillFeedMessage('Out of ammo! Press R to reload');
                    }
                    return;
                }
                
                this.gameState.ammo--;
                
                // Create bullet from camera position
                const direction = new THREE.Vector3(0, 0, -1);
                direction.applyQuaternion(this.camera.quaternion);
                
                const bullet = {
                    position: this.camera.position.clone(),
                    direction: direction,
                    speed: 2,
                    life: 100,
                    shooter: 'player',
                    damage: 50,
                    mesh: null
                };
                
                // Create bullet visual
                const bulletGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const bulletMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00,
                    emissive: 0xffff00,
                    emissiveIntensity: 0.5
                });
                bullet.mesh = new THREE.Mesh(bulletGeometry, bulletMaterial);
                bullet.mesh.position.copy(bullet.position);
                this.scene.add(bullet.mesh);
                
                this.bullets.push(bullet);
                
                // Muzzle flash effect
                this.createMuzzleFlash();
            }
            
            createMuzzleFlash() {
                const flash = new THREE.PointLight(0xffff88, 2, 10);
                flash.position.copy(this.camera.position);
                this.scene.add(flash);
                
                setTimeout(() => {
                    this.scene.remove(flash);
                }, 50);
            }
            
            updateBullets() {
                this.bullets = this.bullets.filter(bullet => {
                    // Move bullet
                    const moveDistance = bullet.direction.clone().multiplyScalar(bullet.speed);
                    bullet.position.add(moveDistance);
                    bullet.life--;
                    
                    if (bullet.mesh) {
                        bullet.mesh.position.copy(bullet.position);
                    }
                    
                    // Check if bullet hit ground
                    if (bullet.position.y < 0.5) {
                        this.removeBullet(bullet);
                        return false;
                    }
                    
                    // Check collisions with obstacles
                    for (const block of this.world.blocks) {
                        const blockBox = new THREE.Box3().setFromObject(block);
                        const bulletPoint = bullet.position;
                        
                        if (blockBox.containsPoint(bulletPoint)) {
                            this.removeBullet(bullet);
                            return false;
                        }
                    }
                    
                    // Check collisions with targets
                    if (bullet.shooter === 'player') {
                        // Check CPU hits
                        for (const cpu of this.cpuPlayers) {
                            if (cpu.isAlive && bullet.position.distanceTo(cpu.position) < 1.5) {
                                this.hitCPU(cpu, bullet.damage);
                                this.removeBullet(bullet);
                                return false;
                            }
                        }
                    } else {
                        // Check player hits
                        if (this.gameState.isAlive && bullet.position.distanceTo(this.player.position) < 1.5) {
                            this.hitPlayer(bullet.shooter, bullet.damage);
                            this.removeBullet(bullet);
                            return false;
                        }
                    }
                    
                    // Remove old bullets
                    if (bullet.life <= 0) {
                        this.removeBullet(bullet);
                        return false;
                    }
                    
                    return true;
                });
            }
            
            removeBullet(bullet) {
                if (bullet.mesh) {
                    this.scene.remove(bullet.mesh);
                    bullet.mesh.geometry.dispose();
                    bullet.mesh.material.dispose();
                }
            }
            
            hitCPU(cpu, damage) {
                cpu.health -= damage;
                
                // Create hit effect
                this.createHitEffect(cpu.position);
                
                if (cpu.health <= 0) {
                    cpu.isAlive = false;
                    
                    // Capture CPU's photo
                    this.captureEnemyPhoto(cpu);
                    
                    // Update score
                    this.gameState.kills++;
                    this.gameState.score += 100;
                    
                    // Add kill message
                    this.addKillFeedMessage(`You eliminated ${cpu.name}! +100 points`);
                    
                    // Remove CPU from scene
                    if (cpu.mesh) {
                        this.scene.remove(cpu.mesh);
                    }
                    if (cpu.nametag) {
                        cpu.nametag.style.display = 'none';
                    }
                    
                    // Update active bot count
                    this.updateBotsActive();
                    
                    // Respawn CPU after delay
                    setTimeout(() => {
                        this.respawnCPU(cpu);
                    }, 5000);
                }
            }
            
            hitPlayer(shooter, damage) {
                this.gameState.health -= damage;
                
                // Create hit effect
                this.createHitEffect(this.player.position);
                
                // Screen flash
                this.createScreenFlash(0xff0000, 0.3);
                
                if (this.gameState.health <= 0) {
                    this.gameState.isAlive = false;
                    this.gameState.deaths++;
                    
                    // Add death message
                    this.addKillFeedMessage(`You were eliminated by ${shooter.name}!`);
                    
                    // Show respawn overlay
                    this.showRespawnOverlay();
                    
                    // Respawn after delay
                    setTimeout(() => {
                        this.respawnPlayer();
                    }, 3000);
                }
            }
            
            createHitEffect(position) {
                // Create particle effect
                const particleCount = 10;
                const particles = new THREE.Group();
                
                for (let i = 0; i < particleCount; i++) {
                    const particle = new THREE.Mesh(
                        new THREE.BoxGeometry(0.1, 0.1, 0.1),
                        new THREE.MeshBasicMaterial({ color: 0xff0000 })
                    );
                    
                    particle.position.copy(position);
                    particle.userData.velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 0.5,
                        Math.random() * 0.5,
                        (Math.random() - 0.5) * 0.5
                    );
                    
                    particles.add(particle);
                }
                
                this.scene.add(particles);
                
                // Animate particles
                let frame = 0;
                const animateParticles = () => {
                    frame++;
                    if (frame > 30) {
                        this.scene.remove(particles);
                        return;
                    }
                    
                    particles.children.forEach(particle => {
                        particle.position.add(particle.userData.velocity);
                        particle.userData.velocity.y -= 0.02;
                        particle.scale.multiplyScalar(0.95);
                    });
                    
                    requestAnimationFrame(animateParticles);
                };
                animateParticles();
            }
            
            createScreenFlash(color, opacity) {
                const flash = document.createElement('div');
                flash.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: #${color.toString(16).padStart(6, '0')};
                    opacity: ${opacity};
                    pointer-events: none;
                    z-index: 1000;
                `;
                document.body.appendChild(flash);
                
                setTimeout(() => {
                    flash.style.transition = 'opacity 0.3s';
                    flash.style.opacity = '0';
                    setTimeout(() => flash.remove(), 300);
                }, 50);
            }
            
            captureEnemyPhoto(cpu) {
                // Add photo to collection
                this.gameState.collectedPhotos.push({
                    id: cpu.id,
                    name: cpu.name,
                    photo: cpu.photo,
                    timestamp: Date.now()
                });
                
                // Update photo collection UI
                this.updatePhotoCollection();
                
                // Show photo capture effect
                this.showPhotoCaptureEffect();
            }
            
            updatePhotoCollection() {
                const container = document.getElementById('collectedPhotos');
                container.innerHTML = '';
                
                this.gameState.collectedPhotos.forEach(photo => {
                    const img = document.createElement('img');
                    img.src = photo.photo;
                    img.className = 'collected-photo';
                    img.title = `${photo.name} - ${new Date(photo.timestamp).toLocaleTimeString()}`;
                    img.addEventListener('click', () => {
                        this.viewPhoto(photo);
                    });
                    container.appendChild(img);
                });
            }
            
            viewPhoto(photo) {
                // Create modal to view photo
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.8);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 1000;
                    cursor: pointer;
                `;
                
                modal.innerHTML = `
                    <div style="text-align: center;">
                        <img src="../../${photo.photo}" style="max-width: 400px; max-height: 400px; border-radius: 10px; border: 3px solid #FFD700;">
                        <div style="color: white; margin-top: 20px;">
                            <h3>${photo.name}</h3>
                            <p>Captured: ${new Date(photo.timestamp).toLocaleString()}</p>
                            <p style="opacity: 0.7;">Click anywhere to close</p>
                        </div>
                    </div>
                `;
                
                modal.addEventListener('click', () => modal.remove());
                document.body.appendChild(modal);
            }
            
            exportAllPhotos() {
                if (this.gameState.collectedPhotos.length === 0) {
                    this.addKillFeedMessage('No photos to export!');
                    return;
                }
                
                this.gameState.collectedPhotos.forEach((photo, index) => {
                    setTimeout(() => {
                        const link = document.createElement('a');
                        link.download = `facecraft_${photo.name}_${photo.timestamp}.png`;
                        link.href = photo.photo;
                        link.click();
                    }, index * 100); // Stagger downloads
                });
                
                this.gameState.downloadedCount += this.gameState.collectedPhotos.length;
                this.addKillFeedMessage(`Exported ${this.gameState.collectedPhotos.length} photos!`);
            }
            
            showPhotoCaptureEffect() {
                const effect = document.createElement('div');
                effect.className = 'photo-capture-effect';
                document.body.appendChild(effect);
                
                // Camera shutter sound effect (visual)
                this.createScreenFlash(0xffffff, 0.8);
                
                setTimeout(() => {
                    effect.remove();
                }, 300);
            }
            
            showRespawnOverlay() {
                const overlay = document.createElement('div');
                overlay.className = 'respawn-overlay';
                overlay.innerHTML = `
                    <h2>üíÄ ELIMINATED!</h2>
                    <p>Respawning in 3 seconds...</p>
                `;
                document.getElementById('ui').appendChild(overlay);
                
                setTimeout(() => {
                    overlay.remove();
                }, 3000);
            }
            
            respawnPlayer() {
                this.gameState.health = this.gameState.maxHealth;
                this.gameState.ammo = this.gameState.maxAmmo;
                this.gameState.isAlive = true;
                
                // Find safe spawn point
                let spawnPoint;
                let attempts = 0;
                do {
                    spawnPoint = new THREE.Vector3(
                        (Math.random() - 0.5) * 100,
                        10,
                        (Math.random() - 0.5) * 100
                    );
                    attempts++;
                } while (this.isSpawnPointBlocked(spawnPoint) && attempts < 10);
                
                this.player.position.copy(spawnPoint);
                this.player.velocity.set(0, 0, 0);
                
                this.addKillFeedMessage('You have respawned!');
                
                // Request pointer lock again
                setTimeout(() => {
                    document.body.requestPointerLock();
                }, 100);
            }
            
            isSpawnPointBlocked(point) {
                for (const block of this.world.blocks) {
                    const blockBox = new THREE.Box3().setFromObject(block);
                    if (blockBox.containsPoint(point)) {
                        return true;
                    }
                }
                return false;
            }
            
            respawnCPU(cpu) {
                cpu.health = 100;
                cpu.isAlive = true;
                
                // Find safe spawn point
                let spawnPoint;
                let attempts = 0;
                do {
                    spawnPoint = new THREE.Vector3(
                        (Math.random() - 0.5) * 150,
                        10,
                        (Math.random() - 0.5) * 150
                    );
                    attempts++;
                } while (this.isSpawnPointBlocked(spawnPoint) && attempts < 10);
                
                cpu.position.copy(spawnPoint);
                cpu.velocity.set(0, 0, 0);
                
                // Re-add to scene
                if (cpu.mesh) {
                    cpu.mesh.position.copy(cpu.position);
                    this.scene.add(cpu.mesh);
                }
                if (cpu.nametag) {
                    cpu.nametag.style.display = 'block';
                }
                
                this.addKillFeedMessage(`${cpu.name} has respawned`);
                this.updateBotsActive();
            }
            
            reload() {
                if (this.gameState.ammo < this.gameState.maxAmmo) {
                    this.gameState.ammo = this.gameState.maxAmmo;
                    this.addKillFeedMessage('Reloaded!');
                }
            }
            
            addKillFeedMessage(message) {
                const killFeed = document.getElementById('killFeed');
                const msg = document.createElement('div');
                msg.className = 'kill-message';
                msg.textContent = message;
                killFeed.appendChild(msg);
                
                // Remove after animation
                setTimeout(() => {
                    if (msg.parentNode) {
                        msg.remove();
                    }
                }, 5000);
                
                // Keep only last 5 messages
                while (killFeed.children.length > 5) {
                    killFeed.removeChild(killFeed.firstChild);
                }
            }
            
            updateBotsActive() {
                const activeCount = this.cpuPlayers.filter(cpu => cpu.isAlive).length;
                document.getElementById('botsActive').textContent = activeCount;
            }
            
            updateUI() {
                document.getElementById('playerScore').textContent = this.gameState.score;
                document.getElementById('playerKills').textContent = this.gameState.kills;
                document.getElementById('playerDeaths').textContent = this.gameState.deaths;
                document.getElementById('health').textContent = Math.max(0, this.gameState.health);
                document.getElementById('ammo').textContent = this.gameState.ammo;
                document.getElementById('downloadCount').textContent = this.gameState.downloadedCount;
                
                // Health bar color
                const healthElement = document.getElementById('health');
                if (this.gameState.health <= 25) {
                    healthElement.style.color = '#ff4444';
                } else if (this.gameState.health <= 50) {
                    healthElement.style.color = '#ffaa44';
                } else {
                    healthElement.style.color = '#44ff44';
                }
                
                // Low ammo warning
                const ammoElement = document.getElementById('ammo');
                if (this.gameState.ammo <= 5) {
                    ammoElement.style.color = '#ff4444';
                } else {
                    ammoElement.style.color = 'white';
                }
            }
            
            updateStats() {
                this.stats.frameCount++;
                const currentTime = performance.now();
                
                if (currentTime - this.stats.lastTime >= 1000) {
                    this.stats.fps = this.stats.frameCount;
                    this.stats.frameCount = 0;
                    this.stats.lastTime = currentTime;
                }
                
                document.getElementById('fps').textContent = this.stats.fps;
                document.getElementById('position').textContent = 
                    `${Math.floor(this.player.position.x)}, ${Math.floor(this.player.position.y)}, ${Math.floor(this.player.position.z)}`;
            }
            
            startGameLoop() {
                const animate = () => {
                    this.animationId = requestAnimationFrame(animate);
                    
                    if (this.gameStarted) {
                        this.updatePlayer();
                        this.updateCPUPlayers();
                        this.updateBullets();
                        this.updateUI();
                        this.updateStats();
                    }
                    
                    this.renderer.render(this.scene, this.camera);
                };
                
                animate();
            }
            
            cleanup() {
                // Cancel animation loop
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
                
                // Clean up nametags
                this.nametags.forEach(tag => tag.remove());
                
                // Stop webcam
                if (this.webcamStream) {
                    this.webcamStream.getTracks().forEach(track => track.stop());
                }
                
                // Clean up Three.js
                this.scene.traverse(object => {
                    if (object.geometry) object.geometry.dispose();
                    if (object.material) {
                        if (Array.isArray(object.material)) {
                            object.material.forEach(material => material.dispose());
                        } else {
                            object.material.dispose();
                        }
                    }
                });
                this.renderer.dispose();
            }
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            if (window.game) {
                window.game.camera.aspect = window.innerWidth / window.innerHeight;
                window.game.camera.updateProjectionMatrix();
                window.game.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });
        
        // Handle page unload
        window.addEventListener('beforeunload', () => {
            if (window.game) {
                window.game.cleanup();
            }
        });
        
        // Start the game
        window.addEventListener('load', () => {
            window.game = new FaceCraftArena();
        });
    </script>
</body>
</html>