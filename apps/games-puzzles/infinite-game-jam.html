<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Game Jam: Self-Evolving Game</title>
    <meta name="description" content="Watch a game evolve itself through AI playtesting - autonomous game design through computational iteration">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg-dark: #0a0a0f;
            --bg-panel: #12121a;
            --accent: #00ff88;
            --accent-dim: #00aa55;
            --warning: #ffaa00;
            --danger: #ff4444;
            --text: #e0e0e0;
            --text-dim: #888;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg-dark);
            color: var(--text);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 380px;
            grid-template-rows: auto 1fr auto;
            height: 100vh;
            gap: 1px;
            background: #333;
        }

        header {
            grid-column: 1 / -1;
            background: var(--bg-panel);
            padding: 1rem 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid #333;
        }

        h1 {
            font-size: 1.5rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        h1 span { font-size: 1.75rem; }

        .generation-badge {
            background: linear-gradient(135deg, var(--accent), #00ccff);
            color: #000;
            padding: 0.4rem 1rem;
            border-radius: 2rem;
            font-weight: 700;
            font-size: 0.9rem;
        }

        .controls {
            display: flex;
            gap: 0.75rem;
        }

        button {
            background: var(--bg-dark);
            border: 1px solid #444;
            color: var(--text);
            padding: 0.6rem 1.25rem;
            border-radius: 0.5rem;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        button:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        button.primary {
            background: var(--accent);
            color: #000;
            border-color: var(--accent);
            font-weight: 600;
        }

        button.primary:hover {
            background: #00ffaa;
            transform: scale(1.02);
        }

        /* CYCLE 8: Button press feedback for tactile response */
        button:active {
            transform: scale(0.97);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
        }

        button.primary:active {
            background: #00cc77;
            transform: scale(0.97);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .game-area {
            background: var(--bg-panel);
            display: flex;
            flex-direction: column;
            position: relative;
        }

        #gameCanvas {
            width: 100%;
            flex: 1;
            background: #000;
        }

        .game-hud {
            position: absolute;
            top: 1rem;
            left: 1rem;
            right: 1rem;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
        }

        .hud-stat {
            background: rgba(0,0,0,0.7);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-family: monospace;
        }

        /* CYCLE 25: Score pop animation when points are earned */
        .hud-stat.score-pop {
            animation: scorePop 0.25s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes scorePop {
            0% { transform: scale(1); filter: brightness(1); }
            30% { transform: scale(1.12); filter: brightness(1.3) drop-shadow(0 0 6px var(--accent)); }
            100% { transform: scale(1); filter: brightness(1); }
        }

        .sidebar {
            background: var(--bg-panel);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .panel {
            padding: 1rem;
            border-bottom: 1px solid #333;
        }

        .panel h3 {
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-dim);
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
        }

        .metric {
            background: var(--bg-dark);
            padding: 0.75rem;
            border-radius: 0.5rem;
            text-align: center;
        }

        .metric-value {
            font-size: 1.5rem;
            font-weight: 700;
            font-family: monospace;
        }

        .metric-label {
            font-size: 0.7rem;
            color: var(--text-dim);
            text-transform: uppercase;
        }

        .metric.good .metric-value { color: var(--accent); }
        .metric.warning .metric-value { color: var(--warning); }
        .metric.bad .metric-value { color: var(--danger); }

        .evolution-log {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }

        .log-entry {
            background: var(--bg-dark);
            padding: 0.75rem;
            border-radius: 0.5rem;
            margin-bottom: 0.5rem;
            font-size: 0.85rem;
            border-left: 3px solid var(--accent);
        }

        .log-entry.mutation {
            border-left-color: #ff00ff;
        }

        .log-entry.analysis {
            border-left-color: #00aaff;
        }

        .log-entry .gen {
            color: var(--accent);
            font-weight: 600;
        }

        .log-entry .time {
            color: var(--text-dim);
            font-size: 0.75rem;
            float: right;
        }

        .progress-bar {
            height: 4px;
            background: var(--bg-dark);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 0.5rem;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), #00ccff);
            transition: width 0.3s;
        }

        .gene-display {
            display: grid;
            gap: 0.4rem;
            font-family: monospace;
            font-size: 0.8rem;
        }

        .gene {
            display: flex;
            justify-content: space-between;
            background: var(--bg-dark);
            padding: 0.4rem 0.6rem;
            border-radius: 0.25rem;
        }

        .gene-name { color: var(--text-dim); }
        .gene-value { color: var(--accent); }
        .gene-change { font-size: 0.7rem; margin-left: 0.5rem; }
        .gene-change.up { color: var(--accent); }
        .gene-change.down { color: var(--danger); }

        footer {
            grid-column: 1 / -1;
            background: var(--bg-panel);
            padding: 0.75rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
            color: var(--text-dim);
            border-top: 1px solid #333;
        }

        .fitness-bar {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex: 1;
            max-width: 400px;
        }

        .fitness-track {
            flex: 1;
            height: 8px;
            background: var(--bg-dark);
            border-radius: 4px;
            overflow: hidden;
        }

        .fitness-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--danger), var(--warning), var(--accent));
            transition: width 0.5s;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .evolving {
            animation: pulse 1s infinite;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .speed-control input {
            width: 100px;
        }

        /* Death heatmap overlay */
        .heatmap-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            opacity: 0.3;
        }

        .evolution-graph {
            background: var(--bg-dark);
            border-radius: 0.5rem;
            padding: 0.5rem;
            margin-top: 0.5rem;
        }

        #fitnessGraph {
            width: 100%;
            height: 80px;
            display: block;
        }

        .best-dna-banner {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 1px solid var(--accent);
            border-radius: 0.5rem;
            padding: 0.75rem;
            margin-top: 0.5rem;
            display: none;
        }

        .best-dna-banner.show {
            display: block;
        }

        .best-dna-banner h4 {
            color: var(--accent);
            font-size: 0.8rem;
            margin-bottom: 0.5rem;
        }

        .best-score {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--accent);
        }

        .load-best-btn {
            margin-top: 0.5rem;
            width: 100%;
            background: var(--accent-dim);
            border: none;
        }

        .death-chart {
            display: flex;
            gap: 0.25rem;
            margin-top: 0.5rem;
        }

        .death-bar {
            flex: 1;
            height: 20px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.6rem;
            color: #fff;
        }

        .death-bar.fall { background: #3498db; }
        .death-bar.obstacle { background: #e74c3c; }
        .death-bar.leftEdge { background: #9b59b6; }
        .death-bar.survived { background: var(--accent); }

        /* ============================================
           CYCLE 1: 8-STRATEGY CONSENSUS FEATURES
           ============================================ */

        /* FEATURE 1: Virtual Touch Controls */
        .touch-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            display: none;
            justify-content: space-between;
            padding: 0 20px;
            pointer-events: none;
            z-index: 100;
        }

        .touch-controls.active {
            display: flex;
        }

        .touch-dpad {
            display: grid;
            grid-template-columns: repeat(3, 60px);
            grid-template-rows: repeat(2, 60px);
            gap: 5px;
            pointer-events: auto;
        }

        .touch-btn {
            width: 60px;
            height: 60px;
            border-radius: 12px;
            background: rgba(0, 255, 136, 0.3);
            border: 2px solid var(--accent);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: var(--accent);
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
            /* CYCLE 12: Removed transition for zero-delay touch feedback */
        }

        .touch-btn:active, .touch-btn.pressed {
            transform: scale(0.9);
            background: rgba(0, 255, 136, 0.6);
        }

        .touch-btn.left { grid-column: 1; grid-row: 2; }
        .touch-btn.right { grid-column: 3; grid-row: 2; }
        .touch-btn.spacer { visibility: hidden; grid-column: 2; }

        .touch-jump {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: rgba(0, 255, 136, 0.3);
            border: 3px solid var(--accent);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            color: var(--accent);
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
            align-self: flex-end;
        }

        .touch-jump:active, .touch-jump.pressed {
            transform: scale(0.9);
            background: rgba(0, 255, 136, 0.6);
        }

        /* CYCLE 23: Touch ripple effect for spatial feedback */
        .touch-btn, .touch-jump { position: relative; overflow: hidden; }
        .touch-btn::after, .touch-jump::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: inherit;
            background: radial-gradient(circle, var(--accent) 0%, transparent 70%);
            opacity: 0;
            transform: scale(0.5);
            pointer-events: none;
        }
        .touch-btn.ripple::after, .touch-jump.ripple::after {
            animation: touchRipple 0.25s ease-out;
        }
        @keyframes touchRipple {
            0% { opacity: 0.6; transform: scale(0.5); }
            100% { opacity: 0; transform: scale(1.3); }
        }

        /* FEATURE 2: Momentum/Combo HUD */
        .momentum-hud {
            position: absolute;
            top: 50px;
            left: 1rem;
            background: rgba(0,0,0,0.8);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-family: monospace;
            pointer-events: none;
            display: none;
        }

        .momentum-hud.active {
            display: block;
        }

        .momentum-bar {
            width: 120px;
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 4px;
        }

        .momentum-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), #00ccff, #ff00ff);
            /* CYCLE 6: Spring-loaded easing for satisfying momentum feedback */
            transition: width 0.25s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .combo-display {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--warning);
            text-shadow: 0 0 10px var(--warning);
        }

        .combo-display.high {
            color: #ff00ff;
            text-shadow: 0 0 15px #ff00ff;
            animation: comboPulse 0.3s ease-in-out;
        }

        @keyframes comboPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        /* CYCLE 20: Combo expiry warning pulse */
        .combo-display.expiring {
            animation: comboExpiring 0.25s ease-in-out infinite;
        }

        @keyframes comboExpiring {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.9); }
        }

        /* CYCLE 4: Jump Availability Indicator */
        .jump-indicator {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            gap: 8px;
            pointer-events: none;
            z-index: 100;
        }

        .jump-indicator.active {
            display: flex;
        }

        .jump-pip {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: rgba(0, 255, 136, 0.3);
            border: 2px solid var(--accent);
            transition: all 0.15s ease-out;
        }

        .jump-pip.available {
            background: var(--accent);
            box-shadow: 0 0 10px var(--accent);
        }

        .jump-pip.used {
            background: rgba(100, 100, 100, 0.3);
            border-color: #555;
            transform: scale(0.8);
        }

        /* CYCLE 10: Control Hints Overlay for First-Time Players */
        .control-hints {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 12px 16px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 14px;
            color: #aaa;
            pointer-events: none;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.5s;
            border: 1px solid #333;
        }

        .control-hints.visible {
            opacity: 1;
        }

        .control-hints kbd {
            background: #333;
            padding: 2px 6px;
            border-radius: 3px;
            color: var(--accent);
            font-weight: bold;
            margin: 0 2px;
        }

        /* Responsive Mobile Layout */
        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr auto auto;
            }

            header {
                padding: 0.5rem 1rem;
                flex-wrap: wrap;
                gap: 0.5rem;
            }

            h1 { font-size: 1.1rem; }

            .controls {
                flex-wrap: wrap;
                justify-content: center;
            }

            button {
                padding: 0.5rem 0.75rem;
                font-size: 0.8rem;
                min-height: 44px;
            }

            .sidebar {
                max-height: 35vh;
                order: 4;
            }

            .speed-control {
                display: none;
            }

            .generation-badge {
                font-size: 0.75rem;
                padding: 0.3rem 0.75rem;
            }
        }

        /* Reduced Motion Support */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Focus indicators for accessibility */
        button:focus-visible {
            outline: 3px solid var(--accent);
            outline-offset: 2px;
            box-shadow: 0 0 0 6px rgba(0, 255, 136, 0.25);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1><span>üéÆ</span> Infinite Game Jam</h1>
            <div class="generation-badge" id="genBadge">Generation 0</div>
            <div class="controls">
                <button id="playHuman">Play Yourself</button>
                <button id="evolveOnce">Evolve Once</button>
                <button id="autoEvolve" class="primary">Auto-Evolve</button>
                <div class="speed-control">
                    <label>Speed:</label>
                    <input type="range" id="speedSlider" min="1" max="100" value="50">
                </div>
            </div>
        </header>

        <div class="game-area">
            <canvas id="gameCanvas" role="img" aria-label="Platformer game canvas showing AI-controlled player navigating obstacles"></canvas>
            <div class="game-hud">
                <div class="hud-stat" id="hudScore">Score: 0</div>
                <div class="hud-stat" id="hudStatus">AI Playtesting...</div>
            </div>
            <!-- CYCLE 1: Momentum/Combo HUD -->
            <div class="momentum-hud" id="momentumHud">
                <div class="combo-display" id="comboDisplay">x1</div>
                <div class="momentum-bar">
                    <div class="momentum-fill" id="momentumFill" style="width: 0%"></div>
                </div>
            </div>
            <!-- CYCLE 4: Jump Availability Indicator -->
            <div class="jump-indicator" id="jumpIndicator">
                <div class="jump-pip" id="jumpPip1"></div>
                <div class="jump-pip" id="jumpPip2"></div>
            </div>
            <!-- CYCLE 1: Virtual Touch Controls -->
            <div class="touch-controls" id="touchControls">
                <div class="touch-dpad">
                    <div class="touch-btn spacer"></div>
                    <div class="touch-btn spacer"></div>
                    <div class="touch-btn spacer"></div>
                    <div class="touch-btn left" id="touchLeft">‚óÄ</div>
                    <div class="touch-btn spacer"></div>
                    <div class="touch-btn right" id="touchRight">‚ñ∂</div>
                </div>
                <div class="touch-jump" id="touchJump">JUMP</div>
            </div>
            <!-- CYCLE 10: Control Hints for Desktop Players -->
            <div class="control-hints" id="controlHints">
                <kbd>‚Üê</kbd><kbd>‚Üí</kbd> or <kbd>A</kbd><kbd>D</kbd> Move<br>
                <kbd>Space</kbd> or <kbd>W</kbd> Jump (x2)
            </div>
        </div>

        <div class="sidebar">
            <div class="panel">
                <h3>üìä Current Metrics</h3>
                <div class="metrics-grid">
                    <div class="metric" id="metricSurvival">
                        <div class="metric-value">0%</div>
                        <div class="metric-label">Survival Rate</div>
                    </div>
                    <div class="metric" id="metricAvgScore">
                        <div class="metric-value">0</div>
                        <div class="metric-label">Avg Score</div>
                    </div>
                    <div class="metric" id="metricFun">
                        <div class="metric-value">0</div>
                        <div class="metric-label">Fun Score</div>
                    </div>
                    <div class="metric" id="metricDifficulty">
                        <div class="metric-value">?</div>
                        <div class="metric-label">Difficulty</div>
                    </div>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="testProgress" style="width: 0%"></div>
                </div>
                <div class="death-chart" id="deathChart"></div>
                <div class="evolution-graph">
                    <canvas id="fitnessGraph" role="img" aria-label="Fitness evolution graph showing game performance over generations"></canvas>
                </div>
                <div class="best-dna-banner" id="bestDNABanner">
                    <h4>üèÜ Best Generation</h4>
                    <span>Gen <span id="bestGen">0</span>: </span>
                    <span class="best-score" id="bestScore">0%</span> fun
                    <button class="load-best-btn" id="loadBest">Load Best DNA</button>
                </div>
            </div>

            <div class="panel">
                <h3>üß¨ Game DNA</h3>
                <div class="gene-display" id="geneDisplay">
                    <!-- Filled dynamically -->
                </div>
            </div>

            <div class="panel evolution-log" id="evolutionLog">
                <h3>üìú Evolution Log</h3>
                <!-- Log entries appear here -->
            </div>
        </div>

        <footer>
            <div class="fitness-bar">
                <span>Fitness:</span>
                <div class="fitness-track">
                    <div class="fitness-fill" id="fitnessFill" style="width: 10%"></div>
                </div>
                <span id="fitnessValue">10%</span>
            </div>
            <div id="statusText" role="status" aria-live="polite">Ready to evolve</div>
        </footer>
    </div>

    <script>
        // ============================================
        // INFINITE GAME JAM: SELF-EVOLVING GAME ENGINE
        // ============================================

        // Game DNA - all tweakable parameters that define the game
        let gameDNA = {
            // Player physics
            playerSpeed: 5,
            jumpForce: 12,
            gravity: 0.5,
            airControl: 0.8,

            // Platform generation
            platformWidth: 100,
            platformGap: 150,
            platformVariance: 50,
            movingPlatformChance: 0.2,
            movingPlatformSpeed: 2,

            // Obstacles
            obstacleChance: 0.3,
            obstacleSpeed: 3,
            obstacleSize: 30,

            // Collectibles
            coinChance: 0.5,
            coinValue: 10,
            powerupChance: 0.1,

            // Difficulty scaling
            difficultyRamp: 0.001,
            maxDifficulty: 2.0,

            // World
            scrollSpeed: 3,
            worldWidth: 800,
            worldHeight: 600
        };

        // Evolution state
        let generation = 0;
        let isAutoEvolving = false;
        let evolutionSpeed = 50;
        let testResults = [];
        let evolutionHistory = [];
        let bestDNA = null;
        let bestFunScore = 0;
        let bestGeneration = 0;
        let fitnessHistory = [];

        // CYCLE 5: Personal Best Tracking
        let personalBests = {
            score: 0,
            distance: 0,
            combo: 0
        };

        function loadPersonalBests() {
            try {
                const stored = localStorage.getItem('infiniteGameJam_personalBests');
                if (stored) {
                    personalBests = JSON.parse(stored);
                }
            } catch (e) {
                console.warn('Could not load personal bests:', e);
            }
        }

        function savePersonalBests() {
            try {
                localStorage.setItem('infiniteGameJam_personalBests', JSON.stringify(personalBests));
            } catch (e) {
                console.warn('Could not save personal bests:', e);
            }
        }
        loadPersonalBests(); // Load on startup

        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            gameDNA.worldWidth = canvas.width;
            gameDNA.worldHeight = canvas.height;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ============================================
        // CYCLE 1: PARTICLE POOL (Object Pooling)
        // ============================================
        class ParticlePool {
            constructor(maxSize = 200) {
                this.maxSize = maxSize;
                this.pool = [];
                this.active = [];

                // Pre-allocate particles
                for (let i = 0; i < maxSize; i++) {
                    this.pool.push({
                        x: 0, y: 0,
                        vx: 0, vy: 0,
                        color: '#fff',
                        life: 0,
                        maxLife: 0,
                        active: false
                    });
                }
            }

            acquire(x, y, vx, vy, color, life) {
                let particle;
                if (this.pool.length > 0) {
                    particle = this.pool.pop();
                } else if (this.active.length > 0) {
                    // Recycle oldest active particle if pool empty
                    particle = this.active.shift();
                } else {
                    return null; // Should never happen with proper sizing
                }

                particle.x = x;
                particle.y = y;
                particle.vx = vx;
                particle.vy = vy;
                particle.color = color;
                particle.life = life;
                particle.maxLife = life;
                particle.active = true;
                this.active.push(particle);
                return particle;
            }

            update() {
                for (let i = this.active.length - 1; i >= 0; i--) {
                    const p = this.active[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.2;
                    p.life--;

                    if (p.life <= 0) {
                        p.active = false;
                        this.pool.push(this.active.splice(i, 1)[0]);
                    }
                }
            }

            clear() {
                while (this.active.length > 0) {
                    const p = this.active.pop();
                    p.active = false;
                    this.pool.push(p);
                }
            }

            getActive() {
                return this.active;
            }
        }

        // Global particle pool (shared across game instances for efficiency)
        const particlePool = new ParticlePool(200);

        // CYCLE 34: Cached vignette gradient (avoids per-frame createRadialGradient)
        let cachedVignetteGradient = null;
        let cachedVignetteHeight = 0;

        // ============================================
        // CYCLE 19: AFTERIMAGE OBJECT POOL
        // Eliminates GC pressure from afterimage object churn
        // ============================================
        class AfterimagePool {
            constructor(maxSize = 8) {
                this.pool = [];
                this.active = [];
                for (let i = 0; i < maxSize; i++) {
                    this.pool.push({ x: 0, y: 0, alpha: 0, scaleX: 1, scaleY: 1 });
                }
            }

            acquire(x, y, alpha, scaleX, scaleY) {
                const img = this.pool.length > 0 ? this.pool.pop() : this.active.shift();
                img.x = x; img.y = y; img.alpha = alpha;
                img.scaleX = scaleX; img.scaleY = scaleY;
                this.active.push(img);
                return img;
            }

            update(fadeRate = 0.05) {
                for (let i = this.active.length - 1; i >= 0; i--) {
                    this.active[i].alpha -= fadeRate;
                    if (this.active[i].alpha <= 0) {
                        this.pool.push(this.active.splice(i, 1)[0]);
                    }
                }
            }

            getActive() { return this.active; }
            clear() { while (this.active.length) this.pool.push(this.active.pop()); }
        }

        const afterimagePool = new AfterimagePool(8);

        // ============================================
        // CYCLE 22: FLOATING TEXT OBJECT POOL
        // Eliminates GC pressure from score popup churn
        // ============================================
        class FloatingTextPool {
            constructor(maxSize = 20) {
                this.pool = [];
                this.active = [];
                for (let i = 0; i < maxSize; i++) {
                    this.pool.push({ x: 0, y: 0, text: '', color: '', vy: 0, alpha: 0 });
                }
            }

            acquire(x, y, text, color, vy = -2) {
                const ft = this.pool.length > 0 ? this.pool.pop() : this.active.shift();
                ft.x = x; ft.y = y; ft.text = text; ft.color = color; ft.vy = vy; ft.alpha = 1.0;
                this.active.push(ft);
                return ft;
            }

            update() {
                // CYCLE 33: Ease-out floating text - decelerating rise with smooth alpha fade
                for (let i = this.active.length - 1; i >= 0; i--) {
                    const ft = this.active[i];
                    ft.y += ft.vy;
                    ft.vy *= 0.94; // Decelerate upward movement for ease-out feel
                    // Ease-out alpha: faster fade at start, slower at end
                    ft.alpha -= 0.02 + (1 - ft.alpha) * 0.015;
                    if (ft.alpha <= 0) {
                        this.pool.push(this.active.splice(i, 1)[0]);
                    }
                }
            }

            getActive() { return this.active; }
            clear() { while (this.active.length) this.pool.push(this.active.pop()); }
        }

        const floatingTextPool = new FloatingTextPool(20);

        // ============================================
        // CYCLE 18: HAPTIC FEEDBACK SYSTEM
        // Multi-sensory feedback for mobile touch controls
        // ============================================
        const Haptics = {
            enabled: true,
            canVibrate: 'vibrate' in navigator,

            light() {
                if (this.enabled && this.canVibrate) navigator.vibrate(10);
            },
            medium() {
                if (this.enabled && this.canVibrate) navigator.vibrate(25);
            },
            heavy() {
                if (this.enabled && this.canVibrate) navigator.vibrate([15, 10, 40]);
            }
        };

        // ============================================
        // CYCLE 4: PROCEDURAL AUDIO SYSTEM
        // ============================================
        const Audio = {
            ctx: null,
            masterGain: null,
            enabled: true,

            init() {
                if (this.ctx) return;
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.25;
                this.masterGain.connect(this.ctx.destination);
            },

            resume() {
                if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume();
            },

            playJump(isDouble = false) {
                if (!this.enabled || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.frequency.setValueAtTime(isDouble ? 280 : 200, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(isDouble ? 560 : 400, this.ctx.currentTime + 0.08);
                gain.gain.setValueAtTime(0.15, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.08);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.08);
            },

            playCoin(momentum = 1) {
                if (!this.enabled || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.masterGain);
                const basePitch = 800 + momentum * 200;
                osc.frequency.setValueAtTime(basePitch, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(basePitch * 1.5, this.ctx.currentTime + 0.05);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.05);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.05);
            },

            playDeath() {
                if (!this.enabled || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.frequency.setValueAtTime(300, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(60, this.ctx.currentTime + 0.2);
                gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.2);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.2);
            },

            // CYCLE 6: Platform landing thump
            playLanding(velocity = 0) {
                if (!this.enabled || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.connect(gain);
                gain.connect(this.masterGain);
                // Lower pitch = heavier landing feel, velocity affects intensity
                const intensity = Math.min(1, Math.abs(velocity) / 15);
                osc.frequency.setValueAtTime(80 + intensity * 40, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(40, this.ctx.currentTime + 0.06);
                gain.gain.setValueAtTime(0.08 * intensity, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.06);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.06);
            },

            // CYCLE 7: Close-call whoosh sound
            playCloseCall(isInsane = false) {
                if (!this.enabled || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sawtooth';
                osc.connect(gain);
                gain.connect(this.masterGain);
                // Insane = lower dramatic sweep, regular = quick high whoosh
                const startFreq = isInsane ? 200 : 400;
                const endFreq = isInsane ? 80 : 200;
                const duration = isInsane ? 0.15 : 0.08;
                const volume = isInsane ? 0.12 : 0.06;
                osc.frequency.setValueAtTime(startFreq, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(endFreq, this.ctx.currentTime + duration);
                gain.gain.setValueAtTime(volume, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },

            // CYCLE 10: Platform chain reward sound with escalating pitch
            playChain(chainCount = 1) {
                if (!this.enabled || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'triangle'; // Warmer ding quality
                osc.connect(gain);
                gain.connect(this.masterGain);
                // Escalating pitch per chain level (440Hz base, +10% per chain)
                const freq = 440 * (1 + chainCount * 0.1);
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(freq * 1.5, this.ctx.currentTime + 0.05);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.12);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.12);
            },

            // CYCLE 15: UI button click sound - snappy feedback
            playClick() {
                if (!this.enabled || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'square';
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.frequency.setValueAtTime(600, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(400, this.ctx.currentTime + 0.04);
                gain.gain.setValueAtTime(0.08, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.04);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.04);
            },

            // CYCLE 17: Personal best celebration fanfare - triumphant 3-note arpeggio
            playPersonalBest() {
                if (!this.enabled || !this.ctx) return;
                const notes = [523.25, 659.25, 783.99]; // C5, E5, G5 major chord
                notes.forEach((freq, i) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = 'triangle';
                    osc.connect(gain);
                    gain.connect(this.masterGain);
                    const startTime = this.ctx.currentTime + i * 0.1;
                    osc.frequency.setValueAtTime(freq, startTime);
                    gain.gain.setValueAtTime(0, startTime);
                    gain.gain.linearRampToValueAtTime(0.12, startTime + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.18);
                    osc.start(startTime);
                    osc.stop(startTime + 0.18);
                });
            },

            // CYCLE 19: Momentum tier breakthrough sound - ethereal ascending chime
            playMomentumTier(tier) {
                if (!this.enabled || !this.ctx) return;
                const baseFreq = 330 * tier; // Scales with tier (1.5, 2.0, 2.5, 3.0)
                const osc1 = this.ctx.createOscillator();
                const osc2 = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc1.type = 'sine';
                osc2.type = 'triangle';
                osc2.detune.value = 7; // Slight detune for shimmer
                osc1.connect(gain);
                osc2.connect(gain);
                gain.connect(this.masterGain);
                osc1.frequency.setValueAtTime(baseFreq, this.ctx.currentTime);
                osc2.frequency.setValueAtTime(baseFreq * 2, this.ctx.currentTime);
                osc1.frequency.exponentialRampToValueAtTime(baseFreq * 1.5, this.ctx.currentTime + 0.15);
                osc2.frequency.exponentialRampToValueAtTime(baseFreq * 3, this.ctx.currentTime + 0.15);
                gain.gain.setValueAtTime(0.08, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.2);
                osc1.start(); osc2.start();
                osc1.stop(this.ctx.currentTime + 0.2);
                osc2.stop(this.ctx.currentTime + 0.2);
            },

            // CYCLE 21: Combo break sound - descending "sad" tone when combo lost
            playComboBreak(comboLost = 1) {
                if (!this.enabled || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.connect(gain);
                gain.connect(this.masterGain);
                // Higher combos = more dramatic descending tone
                const intensity = Math.min(1, comboLost / 10);
                const startFreq = 180 + intensity * 80;
                const endFreq = 90;
                const duration = 0.1 + intensity * 0.06;
                osc.frequency.setValueAtTime(startFreq, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(endFreq, this.ctx.currentTime + duration);
                gain.gain.setValueAtTime(0.05 + intensity * 0.03, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },

            // CYCLE 23: Survival streak reward - warm ascending chime
            playSurvivalStreak(streakCount = 1) {
                if (!this.enabled || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'triangle';
                osc.connect(gain);
                gain.connect(this.masterGain);
                const baseFreq = 320 + streakCount * 40;
                osc.frequency.setValueAtTime(baseFreq, this.ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(baseFreq * 1.25, this.ctx.currentTime + 0.15);
                gain.gain.setValueAtTime(0.06, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.2);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.2);
            },

            // CYCLE 35: Respawn ready sound - bright ascending tone for fresh start
            playRespawn() {
                if (!this.enabled || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.frequency.setValueAtTime(220, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(440, this.ctx.currentTime + 0.12);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.15);
            }
        };

        // ============================================
        // GAME ENGINE
        // ============================================

        class Game {
            // CYCLE 12: Pre-computed player colors (eliminates per-frame string allocation)
            // Momentum 1.0->3.0 maps to index 0->20 (green -> cyan gradient)
            static playerColors = (() => {
                const colors = [];
                for (let i = 0; i <= 20; i++) {
                    const mix = i / 20; // 0 to 1
                    const r = 0;
                    const g = Math.floor(255 - mix * 55);
                    const b = Math.floor(136 + mix * 119);
                    colors.push(`rgb(${r},${g},${b})`);
                }
                return colors;
            })();

            // CYCLE 16: Static milestones array - avoids per-reset allocation
            // CYCLE 17: Added 50m for early achievable goal
            static milestones = [50, 100, 250, 500, 1000, 2000, 5000];

            constructor(dna, isAI = true) {
                this.dna = { ...dna };
                this.isAI = isAI;
                this.sessionAttempt = 0; // CYCLE 33: Session attempt counter
                this.reset();
            }

            reset() {
                this.sessionAttempt++; // CYCLE 33: Track attempts this session
                this.player = {
                    x: 100,
                    y: this.dna.worldHeight / 2,
                    vx: 0,
                    vy: 0,
                    width: 30,
                    height: 40,
                    grounded: false,
                    jumpsLeft: 2
                };

                this.platforms = [];
                this.obstacles = [];
                this.coins = [];
                // CYCLE 1: Use particle pool instead of array
                particlePool.clear();

                this.score = 0;
                this.distance = 0;
                this.time = 0;
                this.alive = true;
                this.won = false;

                this.difficulty = 1;
                this.scrollOffset = 0;

                // Analytics
                this.deathLocation = null;
                this.coinsMissed = 0;
                this.coinsCollected = 0;
                this.jumpsUsed = 0;
                this.closeCallCount = 0;
                this.hasJumpedThisSession = false; // CYCLE 30: First-jump invitation arrow
                this.closeCallCooldown = 0; // CYCLE 16: Cooldown to prevent farming
                this.survivalTimer = 0;     // CYCLE 23: Frames survived continuously
                this.survivalStreak = 0;    // CYCLE 23: 10-second survival bonuses earned
                this.spawnInTimer = this.isAI ? 0 : 15; // CYCLE 34: Respawn fade-in (15 frames)
                this.idleTime = 0;
                this.actionVariety = new Set();

                // CYCLE 1: Momentum/Combo System
                this.momentum = 1.0;        // Multiplier from 1.0 to 3.0
                this.combo = 0;             // Current combo count
                this.maxCombo = 0;          // Best combo this run
                this.lastPlatformTime = 0;  // For chain bonus tracking
                this.platformChain = 0;     // Consecutive platform landings

                // CYCLE 2: Physics Feel Improvements
                this.coyoteTimer = 0;       // Frames of grace after leaving platform
                this.jumpBufferTimer = 0;   // Frames to remember jump input
                this.isJumpHeld = false;    // For variable jump height
                this.jumpReleased = false;  // CYCLE 31: Graded jump dampening state
                this.wasGrounded = false;   // Track ground state changes

                // CYCLE 2: Visual Juice
                this.shakeIntensity = 0;    // Screen shake on death
                this.floatingTexts = [];    // Floating score popups

                // CYCLE 3: Animation and Polish
                this.scaleX = 1.0;          // Squash/stretch horizontal
                this.scaleY = 1.0;          // Squash/stretch vertical
                this.targetScaleX = 1.0;
                this.targetScaleY = 1.0;
                this.afterimages = [];      // Position history for trail
                this.cameraX = 0;           // Smooth camera position
                this.cameraTargetX = 0;

                // CYCLE 25: Apex shimmer effect state
                this.apexIntensity = 0;     // Current apex glow strength (0-1)
                this.apexPulsePhase = 0;    // Phase for shimmer animation

                // CYCLE 28: Platform landing ripple effect
                this.landingRipples = [];   // Active ripple animations

                // CYCLE 4: Death flash effect
                this.deathFlash = 0;
                this.collectFlash = 0; // CYCLE 31: Collection flash pulse
                this.closeCallFlash = 0; // CYCLE 32: Close-call visual sync
                this.approachedBest = false; // CYCLE 32: Near-best tracking

                // CYCLE 5: Distance milestones
                this.lastMilestone = 0;
                // CYCLE 16: milestones now static (Game.milestones)

                // CYCLE 19: Momentum tier tracking for audio cues
                this.lastMomentumTier = 1.0;

                // CYCLE 7: Hit freeze for impactful moments
                this.hitFreezeFrames = 0;
                this.bufferedJump = false; // CYCLE 20: Input buffer during hit-freeze

                // CYCLE 21: Jump anticipation (pre-jump squash)
                this.jumpAnticipationFrames = 0;
                this.pendingJump = false;
                this.pendingJumpIsDouble = false;

                // Generate initial platforms
                this.generateInitialWorld();
            }

            generateInitialWorld() {
                let x = 50;

                // CYCLE 15: Grounded start - spawn player ON first platform, not mid-air
                // First platform is always stable (non-moving) and at a comfortable height
                const firstPlatformY = this.dna.worldHeight * 0.6; // Slightly below center
                const firstPlatform = {
                    x: x,
                    y: firstPlatformY,
                    width: this.dna.platformWidth * 1.2, // Wider first platform for safety
                    height: 20,
                    isMoving: false, // First platform never moves
                    moveDir: 1,
                    moveRange: 0,
                    baseY: firstPlatformY
                };
                this.platforms.push(firstPlatform);

                // Position player grounded on first platform
                this.player.x = x + firstPlatform.width / 2 - this.player.width / 2;
                this.player.y = firstPlatformY - this.player.height;
                this.player.grounded = true;
                this.player.vy = 0;

                // CYCLE 17: First Coin Gift - guaranteed easy win in first 2 seconds
                // Positioned directly above starting position for single-jump collection
                this.coins.push({
                    x: x + firstPlatform.width / 2,
                    y: firstPlatformY - 70, // Easy jump height
                    collected: false,
                    spawnTime: 0 // CYCLE 24: For shimmer animation offset
                });

                // Generate remaining platforms normally
                x += this.dna.platformGap + (Math.random() - 0.5) * this.dna.platformVariance;
                for (let i = 1; i < 20; i++) {
                    this.addPlatform(x);
                    x += this.dna.platformGap + (Math.random() - 0.5) * this.dna.platformVariance;
                }
            }

            addPlatform(x) {
                const isMoving = Math.random() < this.dna.movingPlatformChance * this.difficulty;
                const platform = {
                    x: x,
                    y: 100 + Math.random() * (this.dna.worldHeight - 250),
                    width: this.dna.platformWidth * (0.7 + Math.random() * 0.6),
                    height: 20,
                    isMoving: isMoving,
                    moveDir: Math.random() > 0.5 ? 1 : -1,
                    moveRange: 50 + Math.random() * 50,
                    baseY: 0
                };
                platform.baseY = platform.y;
                this.platforms.push(platform);

                // Maybe add obstacle
                if (Math.random() < this.dna.obstacleChance * this.difficulty && this.platforms.length > 3) {
                    this.obstacles.push({
                        x: x + platform.width / 2,
                        y: platform.y - this.dna.obstacleSize - 10,
                        size: this.dna.obstacleSize,
                        vx: (Math.random() > 0.5 ? 1 : -1) * this.dna.obstacleSpeed
                    });
                }

                // Maybe add coin
                if (Math.random() < this.dna.coinChance) {
                    this.coins.push({
                        x: x + Math.random() * platform.width,
                        y: platform.y - 40 - Math.random() * 60,
                        collected: false,
                        spawnTime: this.time // CYCLE 24: For shimmer animation offset
                    });
                }
            }

            update(input) {
                if (!this.alive) return;

                // CYCLE 7: Hit freeze pauses game logic for dramatic impact
                if (this.hitFreezeFrames > 0) {
                    // CYCLE 20: Buffer jump input during hit-freeze to prevent lost inputs
                    if (input.jump && this.player.jumpsLeft > 0) {
                        this.bufferedJump = true;
                    }
                    this.hitFreezeFrames--;
                    return; // Skip game logic, render still runs
                }

                // CYCLE 20: Apply buffered jump input after hit-freeze ends
                if (this.bufferedJump) {
                    input.jump = true;
                    this.bufferedJump = false;
                }

                this.time++;
                const dt = 1;

                // CYCLE 16: Decrement close-call cooldown
                if (this.closeCallCooldown > 0) this.closeCallCooldown--;

                // Apply difficulty scaling
                this.difficulty = Math.min(
                    this.dna.maxDifficulty,
                    1 + this.distance * this.dna.difficultyRamp
                );

                // Player input
                // CYCLE 16: Turn-around acceleration boost - snappier direction changes
                const turningLeft = input.left && this.player.vx > 0.5;
                const turningRight = input.right && this.player.vx < -0.5;
                const turnBoost = (turningLeft || turningRight) ? 1.6 : 1.0;

                if (input.left) {
                    this.player.vx -= this.dna.playerSpeed * (this.player.grounded ? 1 : this.dna.airControl) * turnBoost;
                    this.actionVariety.add('left');
                }
                if (input.right) {
                    this.player.vx += this.dna.playerSpeed * (this.player.grounded ? 1 : this.dna.airControl) * turnBoost;
                    this.actionVariety.add('right');
                }

                // CYCLE 2: Coyote Time - grace frames after leaving platform
                if (this.player.grounded) {
                    this.coyoteTimer = 8; // 8 frames of grace
                } else if (this.coyoteTimer > 0) {
                    this.coyoteTimer--;
                }

                // CYCLE 2: Jump Buffering - remember jump input
                if (input.jump) {
                    this.jumpBufferTimer = 8; // Remember for 8 frames
                    this.isJumpHeld = true;
                } else {
                    this.isJumpHeld = false;
                }
                if (this.jumpBufferTimer > 0) this.jumpBufferTimer--;

                // CYCLE 2: Enhanced Jump with Coyote Time + Buffer
                const canJump = (this.coyoteTimer > 0 || this.player.jumpsLeft > 0);
                const wantsJump = (input.jump || this.jumpBufferTimer > 0);

                // CYCLE 21: Process jump anticipation countdown
                if (this.jumpAnticipationFrames > 0) {
                    this.jumpAnticipationFrames--;
                    if (this.jumpAnticipationFrames === 0 && this.pendingJump) {
                        // Execute the actual jump after anticipation
                        this.player.vy = -this.dna.jumpForce;
                        // CYCLE 35: Double-jump momentum carry - horizontal speed boosts vertical lift
                        if (this.pendingJumpIsDouble) {
                            const horizontalBoost = Math.min(0.15, Math.abs(this.player.vx) / 40);
                            this.player.vy *= (1 + horizontalBoost);
                            if (Math.abs(this.player.vx) > 1) this.player.vx *= 1.08;
                        }
                        this.player.jumpsLeft = Math.max(0, this.player.jumpsLeft - 1);
                        this.player.grounded = false;
                        this.coyoteTimer = 0;
                        this.jumpBufferTimer = 0;
                        this.jumpsUsed++;
                        this.hasJumpedThisSession = true; // CYCLE 30: First-jump invitation
                        this.actionVariety.add('jump');
                        // CYCLE 3: Post-squat stretch on jump
                        this.targetScaleX = 0.7;
                        this.targetScaleY = 1.35;
                        // CYCLE 4: Jump sound
                        if (!this.isAI) Audio.playJump(this.pendingJumpIsDouble);
                        // CYCLE 25: Jump burst particles - visual feedback for jump action
                        if (!this.isAI) {
                            const isDouble = this.pendingJumpIsDouble;
                            const particleCount = isDouble ? 6 : 8;
                            const baseColor = isDouble ? '#00ffff' : '#8a9fdf';
                            const altColor = isDouble ? '#ff00ff' : '#6a79bd';
                            for (let i = 0; i < particleCount; i++) {
                                const angle = Math.PI * 0.35 + (Math.PI * 0.3 * i / (particleCount - 1));
                                const speed = (isDouble ? 4 : 3) + Math.random() * 2;
                                const vx = Math.cos(angle) * speed * (Math.random() > 0.5 ? 1 : -1);
                                const vy = Math.sin(angle) * speed * 0.6;
                                const color = Math.random() > 0.3 ? baseColor : altColor;
                                const life = isDouble ? (12 + Math.random() * 8) : (18 + Math.random() * 10);
                                particlePool.acquire(
                                    this.player.x + this.player.width / 2 + (Math.random() - 0.5) * 8,
                                    this.player.y + this.player.height - 2,
                                    vx, vy, color, life
                                );
                            }
                        }
                        this.pendingJump = false;
                    }
                // CYCLE 30: Rising-phase double jump fix - allow double jumps while rising
                } else if (wantsJump && canJump && !this.pendingJump) {
                    const isDoubleJump = this.player.jumpsLeft < 2 && !this.player.grounded;
                    // Block first jump while rising (prevents ground-bounce), allow double jumps anytime
                    const isFirstJumpWhileRising = !isDoubleJump && this.player.vy < 0 && this.coyoteTimer > 0;
                    if (isFirstJumpWhileRising) {
                        // Skip this frame, player is rising from ground
                    } else {
                        // CYCLE 21: Initiate jump anticipation (pre-jump squash)
                        this.pendingJump = true;
                        this.pendingJumpIsDouble = isDoubleJump;
                        this.jumpAnticipationFrames = isDoubleJump ? 2 : 3; // Shorter for double jump
                        // Pre-jump squat visual (compress before spring)
                        this.targetScaleX = 1.2;
                        this.targetScaleY = 0.75;
                    }
                }

                // CYCLE 31: Graded jump release dampening - analog-feeling height control
                if (!this.isJumpHeld && this.player.vy < 0) {
                    if (!this.jumpReleased) {
                        // First frame of release: strong initial cut for responsive short hops
                        this.jumpReleased = true;
                        if (this.player.vy < -this.dna.jumpForce * 0.5) {
                            this.player.vy *= 0.6; // Strong initial cut for high-velocity release
                        }
                    } else if (this.player.vy < -this.dna.jumpForce * 0.2) {
                        // Subsequent frames: gentler decay for smooth arc
                        this.player.vy *= 0.85; // Gradual decay feels more analog
                    }
                }
                // Reset jumpReleased when grounded
                if (this.player.grounded) this.jumpReleased = false;

                // Physics
                // CYCLE 13: Asymmetric gravity - apex hang time + weighty falls
                let effectiveGravity = this.dna.gravity;
                if (Math.abs(this.player.vy) < 2) {
                    effectiveGravity *= 0.6; // Apex hang time - reduced gravity near peak
                } else if (this.player.vy > 0) {
                    effectiveGravity *= 1.4; // Falling - increased gravity for snappy landings
                }
                this.player.vy += effectiveGravity;

                // CYCLE 25: Track apex state for shimmer visual feedback
                const isAtApex = Math.abs(this.player.vy) < 2 && !this.player.grounded;
                if (isAtApex) {
                    this.apexIntensity = Math.min(1, this.apexIntensity + 0.12);
                    this.apexPulsePhase += 0.1;
                } else {
                    this.apexIntensity *= 0.85; // Smooth fade out
                }

                // CYCLE 18: Pre-landing stretch animation - anticipation before squash
                // When falling fast, stretch vertically (Disney's 12 Principles)
                if (this.player.vy > 5 && !this.player.grounded) {
                    const stretchFactor = Math.min(1.4, 1 + this.player.vy / 40);
                    this.targetScaleY = stretchFactor;
                    this.targetScaleX = 1 / Math.sqrt(stretchFactor); // Preserve volume
                }

                // CYCLE 13: Dynamic friction - crisp ground stops, floaty air control
                if (this.player.grounded) {
                    this.player.vx *= 0.82; // Aggressive ground friction
                    if (Math.abs(this.player.vx) < 0.3) this.player.vx = 0; // Dead stop threshold

                    // CYCLE 30: Running dust trail - continuous movement feedback
                    if (!this.isAI && Math.abs(this.player.vx) > 1.5 && this.time % 5 === 0) {
                        const dustCount = Math.abs(this.player.vx) > 4 ? 2 : 1;
                        for (let i = 0; i < dustCount; i++) {
                            const offsetX = (Math.random() - 0.5) * this.player.width * 0.8;
                            const kickDir = this.player.vx > 0 ? -1 : 1;
                            const velX = kickDir * (0.5 + Math.random() * 1.5);
                            const velY = -(0.3 + Math.random() * 0.8);
                            particlePool.acquire(
                                this.player.x + this.player.width / 2 + offsetX,
                                this.player.y + this.player.height,
                                velX, velY, '#7a8fbf', 10 + Math.random() * 8
                            );
                        }
                    }
                } else {
                    this.player.vx *= 0.94; // Light air friction - preserve momentum
                }

                this.player.x += this.player.vx;
                this.player.y += this.player.vy;

                // Platform collision
                this.player.grounded = false;
                for (const plat of this.platforms) {
                    // Update moving platforms
                    if (plat.isMoving) {
                        plat.y = plat.baseY + Math.sin(this.time * 0.02 * this.dna.movingPlatformSpeed) * plat.moveRange;
                    }

                    if (this.collides(this.player, plat) && this.player.vy >= 0) {
                        if (this.player.y + this.player.height - this.player.vy <= plat.y + 10) {
                            // CYCLE 1: Platform chain bonus
                            if (!this.player.grounded) {
                                this.platformChain++;
                                const timeSinceLast = this.time - this.lastPlatformTime;
                                // Quick landing = bigger bonus
                                if (timeSinceLast < 60 && this.platformChain > 1) {
                                    const chainBonus = this.platformChain * 5 * (plat.isMoving ? 2 : 1);
                                    const earnedBonus = Math.round(chainBonus * this.momentum);
                                    this.score += earnedBonus;
                                    this.combo++;
                                    this.maxCombo = Math.max(this.maxCombo, this.combo);
                                    this.checkComboMilestone(this.combo); // CYCLE 31
                                    this.momentum = Math.min(3.0, this.momentum + 0.1);
                                    // CYCLE 2: Floating chain bonus text
                                    // CYCLE 11: Show actual points earned for scoring clarity
                                    this.spawnFloatingText(this.player.x, this.player.y - 30, `+${earnedBonus} CHAIN x${this.platformChain}`, '#00ff88');
                                    // CYCLE 10: Chain reward sound with escalating pitch
                                    if (!this.isAI) Audio.playChain(this.platformChain);
                                }
                                this.lastPlatformTime = this.time;
                            }

                            this.player.y = plat.y - this.player.height;
                            // CYCLE 6: Capture velocity before reset for landing sound
                            const landingVelocity = this.player.vy;
                            this.player.vy = 0;
                            this.player.grounded = true;
                            this.player.jumpsLeft = 2;
                            // CYCLE 3: Squash on landing
                            // CYCLE 11: Velocity-proportional squash - heavier falls squash more
                            if (!this.wasGrounded) {
                                const squashIntensity = Math.min(1.5, Math.abs(landingVelocity) / 12);
                                this.targetScaleX = 1 + 0.35 * squashIntensity;
                                this.targetScaleY = 1 - 0.35 * squashIntensity;

                                // CYCLE 14: Landing dust cloud - velocity-proportional particles
                                const dustCount = Math.floor(4 + squashIntensity * 6);
                                const dustColor = plat.isMoving ? '#5a79cd' : '#8a9fdf';
                                for (let i = 0; i < dustCount; i++) {
                                    const spreadX = (Math.random() - 0.5) * this.player.width * 1.5;
                                    const velX = (Math.random() - 0.5) * 3 * squashIntensity;
                                    const velY = -(0.5 + Math.random() * 1.5) * squashIntensity;
                                    particlePool.acquire(
                                        this.player.x + this.player.width / 2 + spreadX,
                                        plat.y - 2, velX, velY, dustColor, 15 + Math.random() * 15
                                    );
                                }

                                // CYCLE 14: Landing screen shake for impact feel
                                if (squashIntensity > 0.5) {
                                    this.shakeIntensity = Math.max(this.shakeIntensity, squashIntensity * 4);
                                }

                                // CYCLE 28: Platform landing ripple - expanding ring effect
                                // CYCLE 32: Platform-matched color for visual coherence
                                if (!this.isAI && squashIntensity > 0.2) {
                                    this.landingRipples.push({
                                        x: this.player.x + this.player.width / 2,
                                        y: plat.y,
                                        radius: 10,
                                        maxRadius: 40 + squashIntensity * 30,
                                        alpha: 0.6 + squashIntensity * 0.3,
                                        isMoving: plat.isMoving
                                    });
                                }

                                // CYCLE 6: Landing thump sound
                                if (!this.isAI) Audio.playLanding(landingVelocity);

                                // CYCLE 20: Landing haptic feedback - velocity-proportional intensity
                                if (!this.isAI) {
                                    const landingIntensity = Math.min(1, Math.abs(landingVelocity) / 15);
                                    if (landingIntensity > 0.6) {
                                        Haptics.heavy();
                                    } else if (landingIntensity > 0.3) {
                                        Haptics.medium();
                                    } else if (landingIntensity > 0.1) {
                                        Haptics.light();
                                    }
                                }
                            }
                        }
                    }
                }

                // Obstacle collision
                for (const obs of this.obstacles) {
                    obs.x += obs.vx;

                    // Bounce off screen edges
                    if (obs.x < this.scrollOffset || obs.x > this.scrollOffset + this.dna.worldWidth) {
                        obs.vx *= -1;
                    }

                    // CYCLE 22: Squared distance (avoids sqrt per obstacle per frame)
                    const dx = this.player.x + this.player.width/2 - obs.x;
                    const dy = this.player.y + this.player.height/2 - obs.y;
                    const distSq = dx * dx + dy * dy;
                    const halfSize = obs.size / 2;
                    const deathThreshSq = (halfSize + 15) * (halfSize + 15);
                    const closeThreshSq = (halfSize + 40) * (halfSize + 40);
                    const insaneThreshSq = (halfSize + 20) * (halfSize + 20);

                    if (distSq < deathThreshSq) {
                        this.die('obstacle');
                    } else if (distSq < closeThreshSq && this.closeCallCooldown <= 0) {
                        // CYCLE 16: Cooldown prevents farming same obstacle
                        this.closeCallCooldown = 30; // 30 frame cooldown (~0.5s)
                        this.closeCallCount++;
                        this.combo++;
                        this.maxCombo = Math.max(this.maxCombo, this.combo);
                        this.checkComboMilestone(this.combo); // CYCLE 31
                        // CYCLE 6: Graduated close-call feedback
                        if (distSq < insaneThreshSq) {
                            // Ultra-close (5px from death!) - INSANE reward
                            this.momentum = Math.min(3.0, this.momentum + 0.15);
                            // CYCLE 16: INSANE close-call score bonus
                            const insaneBonus = Math.round(50 * this.momentum);
                            this.score += insaneBonus;
                            if (!this.isAI) {
                                this.spawnFloatingText(this.player.x, this.player.y - 50, `+${insaneBonus} INSANE!`, '#ff00ff');
                                this.shakeIntensity = 8;
                                Audio.playCloseCall(true); // CYCLE 7: Dramatic whoosh
                                Haptics.heavy(); // CYCLE 19: Heavy haptic for INSANE
                                this.hitFreezeFrames = 3; // CYCLE 7: Brief dramatic pause
                            }
                        } else {
                            // Regular close call
                            this.momentum = Math.min(3.0, this.momentum + 0.05);
                            // CYCLE 16: Regular close-call score bonus
                            const closeBonus = Math.round(15 * this.momentum);
                            this.score += closeBonus;
                            if (!this.isAI) {
                                // CYCLE 8: Changed from orange to cyan for positive/danger color distinction
                                this.spawnFloatingText(this.player.x, this.player.y - 40, `+${closeBonus} CLOSE!`, '#00ffd5');
                                Audio.playCloseCall(false); // CYCLE 7: Quick whoosh
                                Haptics.medium(); // CYCLE 19: Medium haptic for close call
                                // CYCLE 32: Close-call visual sync - subtle shake and flash
                                this.shakeIntensity = Math.max(this.shakeIntensity, 2.5);
                                this.closeCallFlash = 0.4;
                            }
                        }
                    }
                }

                // Coin collection with momentum multiplier
                // CYCLE 11: Coin magnetism - coins pull toward player when close
                // CYCLE 22: Squared distance (sqrt only when in magnet zone)
                for (const coin of this.coins) {
                    if (coin.collected) continue;
                    const playerCenterX = this.player.x + this.player.width / 2;
                    const playerCenterY = this.player.y + this.player.height / 2;
                    const dx = playerCenterX - coin.x;
                    const dy = playerCenterY - coin.y;
                    const distSq = dx * dx + dy * dy;

                    // Magnetic pull zone (larger than collection, scales with momentum)
                    const magnetRange = 60 + (this.momentum - 1) * 15;
                    const magnetRangeSq = magnetRange * magnetRange;
                    const collectSq = 625; // 25 * 25
                    if (distSq < magnetRangeSq && distSq > collectSq) {
                        // Only compute sqrt when actually in magnet zone
                        const dist = Math.sqrt(distSq);
                        const pullStrength = 0.12 * (1 - dist / magnetRange) * this.momentum;
                        // CYCLE 27: Coin vacuum swirl - spiral toward player
                        if (!coin.swirlDir) coin.swirlDir = (coin.x % 2 < 1) ? 1 : -1;
                        const swirlStrength = 0.05 * this.momentum * (dist / magnetRange);
                        const perpX = (-dy / dist) * swirlStrength * coin.swirlDir;
                        const perpY = (dx / dist) * swirlStrength * coin.swirlDir;
                        coin.x += dx * pullStrength + perpX;
                        coin.y += dy * pullStrength + perpY;
                    }

                    if (distSq < collectSq) {
                        coin.collected = true;
                        if (!this.isAI) this.collectFlash = 1.0; // CYCLE 31: Collection flash
                        // CYCLE 1: Score multiplied by momentum
                        const coinScore = Math.round(this.dna.coinValue * this.momentum);
                        this.score += coinScore;
                        this.coinsCollected++;
                        this.combo++;
                        this.maxCombo = Math.max(this.maxCombo, this.combo);
                        this.checkComboMilestone(this.combo); // CYCLE 31
                        this.momentum = Math.min(3.0, this.momentum + 0.02);
                        this.spawnParticles(coin.x, coin.y, '#ffdd00', 5);
                        // CYCLE 2: Floating score text
                        this.spawnFloatingText(coin.x, coin.y - 20, `+${coinScore}`, '#ffcc00');
                        // CYCLE 4: Coin sound (pitch increases with momentum)
                        // CYCLE 19: Light haptic for coin collection
                        if (!this.isAI) { Audio.playCoin(this.momentum); Haptics.light(); }
                    }
                }

                // World scrolling
                const targetScroll = this.player.x - 200;
                if (targetScroll > this.scrollOffset) {
                    this.scrollOffset = targetScroll;
                    this.distance = this.scrollOffset;

                    // CYCLE 5: Distance milestone callouts
                    for (const milestone of Game.milestones) {
                        if (this.distance >= milestone && this.lastMilestone < milestone) {
                            this.lastMilestone = milestone;
                            // CYCLE 17: Special first milestone celebration
                            const text = milestone === 50 ? 'FIRST GOAL!' : `${milestone}m!`;
                            const color = milestone === 50 ? '#00ff88' :
                                         (milestone >= 1000 ? '#ff00ff' : '#00ffff');
                            this.spawnFloatingText(this.player.x, this.player.y - 60, text, color);
                            if (!this.isAI) {
                                Audio.playCoin(2.5); // High-pitch milestone sound
                                Haptics.medium(); // CYCLE 19: Medium haptic for milestone
                                // CYCLE 7: Hit freeze for major milestones
                                if (milestone >= 1000) this.hitFreezeFrames = 4;
                            }
                            // CYCLE 17: Extra celebration for first goal
                            this.shakeIntensity = milestone === 50 ? 6 : 5;
                        }
                    }

                    // CYCLE 32: Approaching personal best warning
                    if (!this.approachedBest && !this.isAI && personalBests.distance > 100 &&
                        this.distance >= personalBests.distance * 0.8) {
                        this.approachedBest = true;
                        this.spawnFloatingText(this.player.x, this.player.y - 60, 'APPROACHING BEST!', '#ffd700');
                        this.shakeIntensity = 4;
                        Audio.playMomentumTier(2.5);
                    }

                    // Generate new platforms ahead
                    // CYCLE 15: Replace .map() with simple loop to avoid array allocation
                    let lastPlatX = 0;
                    for (let i = 0; i < this.platforms.length; i++) {
                        if (this.platforms[i].x > lastPlatX) lastPlatX = this.platforms[i].x;
                    }
                    if (lastPlatX < this.scrollOffset + this.dna.worldWidth + 200) {
                        this.addPlatform(lastPlatX + this.dna.platformGap + (Math.random() - 0.5) * this.dna.platformVariance);
                    }

                    // CYCLE 15: In-place array compaction - zero allocations
                    // Clean up old platforms (in-place)
                    const platThreshold = this.scrollOffset - 100;
                    let platWrite = 0;
                    for (let i = 0; i < this.platforms.length; i++) {
                        if (this.platforms[i].x + this.platforms[i].width > platThreshold) {
                            if (platWrite !== i) this.platforms[platWrite] = this.platforms[i];
                            platWrite++;
                        }
                    }
                    this.platforms.length = platWrite;

                    // Clean up old obstacles (in-place)
                    let obsWrite = 0;
                    for (let i = 0; i < this.obstacles.length; i++) {
                        if (this.obstacles[i].x > platThreshold) {
                            if (obsWrite !== i) this.obstacles[obsWrite] = this.obstacles[i];
                            obsWrite++;
                        }
                    }
                    this.obstacles.length = obsWrite;

                    // Clean up old coins (in-place) and track missed
                    const coinThreshold = this.scrollOffset - 50;
                    let coinWrite = 0;
                    for (let i = 0; i < this.coins.length; i++) {
                        const coin = this.coins[i];
                        if (coin.x > coinThreshold) {
                            if (coinWrite !== i) this.coins[coinWrite] = coin;
                            coinWrite++;
                        } else if (!coin.collected) {
                            this.coinsMissed++;
                        }
                    }
                    this.coins.length = coinWrite;
                }

                // Fall death
                if (this.player.y > this.dna.worldHeight + 50) {
                    this.die('fall');
                }

                // Screen edge death
                if (this.player.x < this.scrollOffset - 50) {
                    this.die('leftEdge');
                }

                // CYCLE 1: Update particles via pool (more efficient)
                particlePool.update();

                // Track idle time
                if (!input.left && !input.right && !input.jump) {
                    this.idleTime++;
                    // CYCLE 1: Momentum decay when idle
                    this.momentum = Math.max(1.0, this.momentum - 0.01);
                    if (this.time - this.lastPlatformTime > 120) {
                        // CYCLE 21: Play combo break sound before resetting
                        if (this.combo > 0 && !this.isAI) {
                            Audio.playComboBreak(this.combo);
                        }
                        this.combo = 0; // Reset combo after 2 seconds of no chains
                        this.platformChain = 0;
                    }
                } else if (input.right) {
                    // CYCLE 1: Moving forward builds momentum slightly
                    this.momentum = Math.min(3.0, this.momentum + 0.001);
                } else if (input.left) {
                    // CYCLE 1: Moving backward decays momentum
                    this.momentum = Math.max(1.0, this.momentum - 0.005);
                }

                // CYCLE 19: Momentum tier breakthrough audio cue
                // Trigger at 1.5, 2.0, 2.5, 3.0 thresholds
                const currentTier = Math.floor(this.momentum * 2) / 2; // Round to nearest 0.5
                if (currentTier > this.lastMomentumTier && currentTier >= 1.5 && !this.isAI) {
                    Audio.playMomentumTier(currentTier);
                    Haptics.light(); // Subtle haptic for tier up
                    // CYCLE 34: Momentum tier visual celebration - floating text + radial burst
                    const tierColor = currentTier >= 2.5 ? '#ff44ff' : (currentTier >= 2.0 ? '#00ffff' : '#88ff88');
                    this.spawnFloatingText(this.player.x, this.player.y - 60, `x${currentTier.toFixed(1)} MOMENTUM!`, tierColor);
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        const speed = 3 + currentTier;
                        particlePool.acquire(
                            this.player.x + this.player.width / 2, this.player.y + this.player.height / 2,
                            Math.cos(angle) * speed, Math.sin(angle) * speed, tierColor, 20 + Math.random() * 10
                        );
                    }
                    this.lastMomentumTier = currentTier;
                } else if (currentTier < this.lastMomentumTier) {
                    this.lastMomentumTier = currentTier; // Track tier down (no sound)
                }

                // CYCLE 23: Survival streak timer - reward for continuous play
                this.survivalTimer++;
                if (this.survivalTimer >= 600) { // 10 seconds at 60fps
                    this.survivalTimer = 0;
                    this.survivalStreak++;
                    const bonus = Math.round((10 + this.survivalStreak * 5) * this.momentum);
                    this.score += bonus;
                    if (!this.isAI) {
                        this.spawnFloatingText(this.player.x, this.player.y - 70, `+${bonus} SURVIVOR`, '#88ff88');
                        Audio.playSurvivalStreak(this.survivalStreak);
                        Haptics.light();
                    }
                }

                // CYCLE 3: Squash/Stretch interpolation
                this.scaleX += (this.targetScaleX - this.scaleX) * 0.2;
                this.scaleY += (this.targetScaleY - this.scaleY) * 0.2;
                this.targetScaleX += (1.0 - this.targetScaleX) * 0.15;
                this.targetScaleY += (1.0 - this.targetScaleY) * 0.15;

                // CYCLE 3: Afterimage trail (only when moving fast and high momentum)
                // CYCLE 19: Use pooled afterimages for human player (zero GC pressure)
                if (this.momentum > 1.3 && this.time % 3 === 0) {
                    if (!this.isAI) {
                        afterimagePool.acquire(this.player.x, this.player.y, 0.4, this.scaleX, this.scaleY);
                    } else {
                        // AI still uses simple array (less critical path)
                        this.afterimages.push({ x: this.player.x, y: this.player.y, alpha: 0.4, scaleX: this.scaleX, scaleY: this.scaleY });
                        if (this.afterimages.length > 8) this.afterimages.shift();
                    }
                }
                // Fade out afterimages
                if (!this.isAI) {
                    afterimagePool.update(0.05);
                } else {
                    for (let i = this.afterimages.length - 1; i >= 0; i--) {
                        this.afterimages[i].alpha -= 0.05;
                        if (this.afterimages[i].alpha <= 0) this.afterimages.splice(i, 1);
                    }
                }

                // CYCLE 3: Smooth camera following
                // CYCLE 9: Velocity look-ahead - show more ahead at high momentum
                const lookAhead = (this.momentum - 1) * 80; // 0-160px ahead based on momentum
                this.cameraTargetX = this.player.x - 200 + lookAhead;
                if (this.cameraTargetX > this.cameraX) {
                    this.cameraX += (this.cameraTargetX - this.cameraX) * 0.08;
                }

                // Track grounded state for landing detection
                this.wasGrounded = this.player.grounded;
            }

            collides(a, b) {
                return a.x < b.x + b.width &&
                       a.x + a.width > b.x &&
                       a.y < b.y + b.height &&
                       a.y + a.height > b.y;
            }

            die(reason) {
                this.alive = false;
                // CYCLE 29: Compute death stats for ghost marker display
                const deathStats = [
                    `Combo: x${this.maxCombo}`,
                    this.closeCallCount > 0 ? `Close: ${this.closeCallCount}` : null,
                    `Coins: ${this.coinsCollected}`
                ].filter(Boolean);
                this.deathLocation = {
                    x: this.player.x,
                    y: this.player.y,
                    reason: reason,
                    distance: this.distance,
                    stats: deathStats
                };
                this.spawnParticles(this.player.x, this.player.y, '#ff4444', 15);
                // CYCLE 2: Screen shake on death
                this.shakeIntensity = 15;
                // CYCLE 4: Death sound + CYCLE 19: Heavy haptic on death
                if (!this.isAI) { Audio.playDeath(); Haptics.heavy(); }
                // CYCLE 4: Death flash intensity
                this.deathFlash = 1.0;

                // CYCLE 10: Death reason floating text for learning
                if (!this.isAI) {
                    const deathMessages = {
                        fall: 'Fell into the void!',
                        obstacle: 'Hit an obstacle!',
                        leftEdge: 'Left behind!'
                    };
                    const msg = deathMessages[reason] || 'Game Over!';
                    this.spawnFloatingText(this.player.x, this.player.y - 50, msg, '#ff6666');
                }

                // CYCLE 5: Check personal bests (human players only)
                if (!this.isAI) {
                    let newBest = false;
                    if (this.score > personalBests.score) {
                        personalBests.score = this.score;
                        newBest = true;
                    }
                    if (this.distance > personalBests.distance) {
                        personalBests.distance = Math.round(this.distance);
                        newBest = true;
                    }
                    if (this.maxCombo > personalBests.combo) {
                        personalBests.combo = this.maxCombo;
                        newBest = true;
                    }
                    if (newBest) {
                        savePersonalBests();
                        this.spawnFloatingText(this.player.x, this.player.y - 80, 'NEW BEST!', '#ff00ff');
                        Audio.playPersonalBest(); // CYCLE 17: Celebration fanfare
                        Haptics.heavy(); // CYCLE 19: Celebration haptic
                    } else if (personalBests.distance > 100 && this.distance >= personalBests.distance * 0.85) {
                        // CYCLE 32: Near-miss encouragement
                        const gap = Math.round(personalBests.distance - this.distance);
                        this.spawnFloatingText(this.player.x, this.player.y - 80, `SO CLOSE! ${gap}m away!`, '#ffaa00');
                        Audio.playSurvivalStreak(2); // Encouraging but bittersweet
                    }
                }
            }

            // CYCLE 2: Spawn floating score text
            // CYCLE 22: Use pool for human player (zero GC), array for AI
            spawnFloatingText(x, y, text, color = '#ffcc00') {
                if (!this.isAI) {
                    floatingTextPool.acquire(x, y, text, color, -2);
                } else {
                    // CYCLE 14: Cap array size to prevent memory leak during AI simulation
                    if (this.floatingTexts.length >= 20) {
                        this.floatingTexts.shift();
                    }
                    this.floatingTexts.push({ x, y, text, color, vy: -2, alpha: 1.0 });
                }
            }

            // CYCLE 31: Combo milestone celebrations - reward hitting round numbers
            checkComboMilestone(newCombo) {
                if (this.isAI) return;
                const milestones = [5, 10, 15, 20, 25, 30, 40, 50];
                if (milestones.includes(newCombo)) {
                    const tier = milestones.indexOf(newCombo);
                    this.spawnFloatingText(this.player.x, this.player.y - 50, `COMBO x${newCombo}!`, '#ff44ff');
                    this.shakeIntensity = 4 + tier * 1.5;
                    Audio.playChain(Math.min(8, tier + 3));
                    Haptics.medium();
                    // Celebration particles
                    for (let i = 0; i < 6 + tier * 2; i++) {
                        particlePool.acquire(
                            this.player.x + this.player.width / 2,
                            this.player.y,
                            (Math.random() - 0.5) * 10,
                            -Math.random() * 8,
                            '#ff44ff', 25 + Math.random() * 15
                        );
                    }
                }
            }

            spawnParticles(x, y, color, count) {
                // CYCLE 1: Use particle pool for efficiency
                for (let i = 0; i < count; i++) {
                    particlePool.acquire(
                        x, y,
                        (Math.random() - 0.5) * 8,
                        (Math.random() - 1) * 8,
                        color,
                        30 + Math.random() * 20
                    );
                }
            }

            render() {
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // CYCLE 2: Apply screen shake
                ctx.save();
                if (this.shakeIntensity > 0) {
                    const shakeX = (Math.random() - 0.5) * this.shakeIntensity;
                    const shakeY = (Math.random() - 0.5) * this.shakeIntensity;
                    ctx.translate(shakeX, shakeY);
                    this.shakeIntensity *= 0.85; // Decay shake
                    if (this.shakeIntensity < 0.5) this.shakeIntensity = 0;
                }

                // CYCLE 27: Distant ambient stars - atmospheric depth layer
                ctx.fillStyle = '#4a5a8a';
                for (let i = 0; i < 25; i++) {
                    const starX = ((i * 80 - this.scrollOffset * 0.08) % (canvas.width + 80)) - 40;
                    const starY = 40 + ((i * 37) % 220);
                    const pulse = 0.3 + Math.sin(this.time * 0.015 + i) * 0.25;
                    ctx.globalAlpha = pulse;
                    ctx.fillRect(starX, starY, 2, 2);
                }
                ctx.globalAlpha = 1;

                // Parallax background
                const bgOffset = this.scrollOffset * 0.3;
                ctx.fillStyle = '#16213e';
                for (let i = 0; i < 20; i++) {
                    const x = ((i * 100 - bgOffset) % (canvas.width + 100)) - 50;
                    ctx.fillRect(x, 100 + (i % 5) * 80, 40, 300);
                }

                // CYCLE 29: Scroll-beat background pulse - rhythmic tempo tied to distance
                if (this.alive) {
                    const beatPhase = (this.scrollOffset % 100) / 100;
                    const beatCurve = beatPhase < 0.08 ? Math.sin(beatPhase * Math.PI / 0.08) : 0;
                    const beatIntensity = (0.03 + (this.momentum - 1) * 0.04) * beatCurve;
                    if (beatIntensity > 0.005) {
                        ctx.fillStyle = `rgba(100, 180, 255, ${beatIntensity})`;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }
                }

                ctx.save();
                // CYCLE 3: Use smooth camera instead of hard scrollOffset
                ctx.translate(-this.cameraX, 0);

                // CYCLE 3: Draw afterimages first (behind player)
                // CYCLE 19: Use pooled afterimages for human player
                const ghosts = this.isAI ? this.afterimages : afterimagePool.getActive();
                for (const ghost of ghosts) {
                    ctx.globalAlpha = ghost.alpha * 0.5;
                    ctx.fillStyle = '#00ff88';
                    const gw = this.player.width * ghost.scaleX;
                    const gh = this.player.height * ghost.scaleY;
                    ctx.fillRect(
                        ghost.x + (this.player.width - gw) / 2,
                        ghost.y + (this.player.height - gh),
                        gw, gh
                    );
                }
                ctx.globalAlpha = 1;

                // CYCLE 28: Viewport culling bounds - skip off-screen objects
                const viewLeft = this.cameraX - 50;  // Small buffer for objects entering view
                const viewRight = this.cameraX + canvas.width + 50;

                // Platforms - CYCLE 23: Batched rendering (3 passes instead of 3n state changes)
                // Static platforms - body
                ctx.fillStyle = '#6a89cc';
                for (const plat of this.platforms) {
                    if (!plat.isMoving && plat.x + plat.width > viewLeft && plat.x < viewRight)
                        ctx.fillRect(plat.x, plat.y, plat.width, plat.height);
                }
                // Moving platforms - body
                ctx.fillStyle = '#4a69bd';
                for (const plat of this.platforms) {
                    if (plat.isMoving && plat.x + plat.width > viewLeft && plat.x < viewRight)
                        ctx.fillRect(plat.x, plat.y, plat.width, plat.height);
                }
                // All platforms - highlight strip
                ctx.fillStyle = '#82ccdd';
                for (const plat of this.platforms) {
                    if (plat.x + plat.width > viewLeft && plat.x < viewRight)
                        ctx.fillRect(plat.x, plat.y, plat.width, 4);
                }

                // CYCLE 26: Platform rhythm glow - traveling wave synchronized to momentum
                const rhythmSpeed = 0.003 + (this.momentum - 1) * 0.001;
                for (const plat of this.platforms) {
                    const wavePos = ((this.time * rhythmSpeed + plat.x * 0.001) % 1);
                    const glowX = plat.x + wavePos * plat.width;
                    const glowIntensity = Math.sin(wavePos * Math.PI);
                    ctx.globalAlpha = glowIntensity * 0.3 * (0.5 + this.momentum * 0.2);
                    ctx.fillStyle = '#aaddff';
                    ctx.fillRect(glowX - 15, plat.y, 30, 4);
                }
                ctx.globalAlpha = 1;

                // CYCLE 28: Landing ripple rendering - expanding rings on platform
                for (let i = this.landingRipples.length - 1; i >= 0; i--) {
                    const rip = this.landingRipples[i];
                    rip.radius += 3;
                    const progress = rip.radius / rip.maxRadius;
                    rip.alpha = (1 - progress) * 0.5;
                    if (rip.radius >= rip.maxRadius) {
                        this.landingRipples.splice(i, 1);
                        continue;
                    }
                    // CYCLE 32: Platform-matched ripple color
                    const ripColor = rip.isMoving
                        ? `rgba(74, 105, 189, ${rip.alpha})`   // Moving platform blue
                        : `rgba(106, 137, 204, ${rip.alpha})`; // Static platform blue
                    ctx.strokeStyle = ripColor;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.ellipse(rip.x, rip.y, rip.radius, rip.radius * 0.3, 0, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Coins - CYCLE 18: Batched rendering (2 draw calls instead of 2n)
                // CYCLE 28: Added viewport culling
                // Coin bodies - single path for all coins
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                for (const coin of this.coins) {
                    if (coin.collected || coin.x < viewLeft || coin.x > viewRight) continue;
                    ctx.moveTo(coin.x + 10, coin.y);
                    ctx.arc(coin.x, coin.y, 10, 0, Math.PI * 2);
                }
                ctx.fill();
                // Coin highlights - single path for all coins
                ctx.fillStyle = '#ffed4a';
                ctx.beginPath();
                for (const coin of this.coins) {
                    if (coin.collected || coin.x < viewLeft || coin.x > viewRight) continue;
                    ctx.moveTo(coin.x - 2 + 4, coin.y - 2);
                    ctx.arc(coin.x - 2, coin.y - 2, 4, 0, Math.PI * 2);
                }
                ctx.fill();
                // CYCLE 24: Coin shimmer - sweeping shine effect
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                for (const coin of this.coins) {
                    if (coin.collected || coin.x < viewLeft || coin.x > viewRight) continue;
                    const phase = (this.time - (coin.spawnTime || 0)) % 90;
                    if (phase < 15) {
                        const shimmerX = coin.x - 8 + (phase / 15) * 16;
                        ctx.beginPath();
                        ctx.arc(shimmerX, coin.y - 2, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // Obstacles - CYCLE 5: Orange with glow (distinct from death flash)
                // CYCLE 12: Removed shadowBlur (10-20x perf hit) - use stroke layers instead
                // CYCLE 21: Batched rendering (3 draw calls instead of 3n)

                // CYCLE 27: Proximity danger pulse - obstacles pulse when player approaches
                const playerCX = this.player.x + this.player.width / 2;
                const playerCY = this.player.y + this.player.height / 2;
                for (const obs of this.obstacles) {
                    const dx = playerCX - obs.x;
                    const dy = playerCY - obs.y;
                    const distSq = dx * dx + dy * dy;
                    const dangerRange = 120;
                    if (distSq < dangerRange * dangerRange) {
                        const proximity = 1 - Math.sqrt(distSq) / dangerRange;
                        const pulseSpeed = 0.12 + proximity * 0.25;
                        const pulse = 0.3 + Math.sin(this.time * pulseSpeed) * 0.3 * proximity;
                        ctx.strokeStyle = `rgba(255, 50, 0, ${proximity * pulse * 0.5})`;
                        ctx.lineWidth = 2 + proximity * 3;
                        ctx.beginPath();
                        const r = obs.size * (0.7 + pulse * 0.3);
                        ctx.moveTo(obs.x, obs.y - r/2);
                        ctx.lineTo(obs.x + r/2, obs.y + r/2);
                        ctx.lineTo(obs.x - r/2, obs.y + r/2);
                        ctx.closePath();
                        ctx.stroke();
                    }
                }

                // CYCLE 24: Motion trails behind moving obstacles (direction indicator)
                // CYCLE 28: Added viewport culling to obstacle rendering
                for (let t = 3; t >= 1; t--) {
                    ctx.fillStyle = `rgba(255, 150, 0, ${0.04 * t})`;
                    ctx.beginPath();
                    for (const obs of this.obstacles) {
                        if (obs.vx === 0 || obs.x < viewLeft || obs.x > viewRight) continue;
                        const trailOffset = obs.vx > 0 ? -t * 12 : t * 12;
                        ctx.moveTo(obs.x + trailOffset, obs.y - obs.size/2);
                        ctx.lineTo(obs.x + trailOffset + obs.size/2, obs.y + obs.size/2);
                        ctx.lineTo(obs.x + trailOffset - obs.size/2, obs.y + obs.size/2);
                        ctx.closePath();
                    }
                    ctx.fill();
                }
                // Outer glow layer - single path for all obstacles
                ctx.strokeStyle = 'rgba(255, 170, 0, 0.3)';
                ctx.lineWidth = 8;
                ctx.beginPath();
                for (const obs of this.obstacles) {
                    if (obs.x < viewLeft || obs.x > viewRight) continue;
                    ctx.moveTo(obs.x, obs.y - obs.size/2);
                    ctx.lineTo(obs.x + obs.size/2, obs.y + obs.size/2);
                    ctx.lineTo(obs.x - obs.size/2, obs.y + obs.size/2);
                    ctx.closePath();
                }
                ctx.stroke();

                // Main fill - single path for all obstacles
                ctx.fillStyle = '#ff9500';
                ctx.beginPath();
                for (const obs of this.obstacles) {
                    if (obs.x < viewLeft || obs.x > viewRight) continue;
                    ctx.moveTo(obs.x, obs.y - obs.size/2);
                    ctx.lineTo(obs.x + obs.size/2, obs.y + obs.size/2);
                    ctx.lineTo(obs.x - obs.size/2, obs.y + obs.size/2);
                    ctx.closePath();
                }
                ctx.fill();

                // Border accent - single path for all obstacles
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (const obs of this.obstacles) {
                    if (obs.x < viewLeft || obs.x > viewRight) continue;
                    ctx.moveTo(obs.x, obs.y - obs.size/2);
                    ctx.lineTo(obs.x + obs.size/2, obs.y + obs.size/2);
                    ctx.lineTo(obs.x - obs.size/2, obs.y + obs.size/2);
                    ctx.closePath();
                }
                ctx.stroke();

                // Player with CYCLE 3 Squash/Stretch
                if (this.alive) {
                    // CYCLE 34: Respawn spawn-in effect - scale and fade from 0.3 to 1.0
                    let spawnAlpha = 1, spawnScale = 1;
                    if (this.spawnInTimer > 0) {
                        const t = 1 - (this.spawnInTimer / 15);
                        spawnScale = 0.3 + t * 0.7;
                        spawnAlpha = t;
                        this.spawnInTimer--;
                    }
                    const pw = this.player.width * this.scaleX * spawnScale;
                    const ph = this.player.height * this.scaleY * spawnScale;
                    const px = this.player.x + (this.player.width - pw) / 2;
                    const py = this.player.y + (this.player.height - ph);
                    ctx.globalAlpha = spawnAlpha;

                    // CYCLE 22: Speed lines behind player at high momentum
                    if (this.momentum > 1.5) {
                        const lineCount = Math.floor((this.momentum - 1) * 4);
                        ctx.strokeStyle = `rgba(255, 255, 255, ${(this.momentum - 1) * 0.15})`;
                        ctx.lineWidth = 2;
                        for (let i = 0; i < lineCount; i++) {
                            const lineY = this.player.y + 5 + (i * 8) - (lineCount * 4);
                            const lineLen = 20 + this.momentum * 15;
                            ctx.beginPath();
                            ctx.moveTo(this.player.x - 10, lineY);
                            ctx.lineTo(this.player.x - 10 - lineLen, lineY);
                            ctx.stroke();
                        }
                    }

                    // CYCLE 12: Use pre-computed color lookup (no per-frame allocation)
                    const colorIndex = Math.min(20, Math.floor((this.momentum - 1) * 10));
                    ctx.fillStyle = Game.playerColors[colorIndex];

                    // CYCLE 22: Player tilt based on vertical velocity
                    ctx.save();
                    const tilt = Math.max(-0.2, Math.min(0.2, this.player.vy * 0.015));
                    ctx.translate(this.player.x + this.player.width / 2, this.player.y + this.player.height / 2);
                    ctx.rotate(tilt);
                    ctx.fillRect(-pw / 2, -ph / 2, pw, ph);
                    // CYCLE 29: Dynamic expressive eyes - gaze direction and state
                    ctx.fillStyle = '#000';
                    const eyeScale = Math.min(this.scaleX, this.scaleY);
                    const eyeBaseX1 = -pw / 2 + 8 * eyeScale;
                    const eyeBaseX2 = -pw / 2 + 18 * eyeScale;
                    const eyeBaseY = -ph / 2 + 10 * eyeScale;
                    const eyeW = 5 * eyeScale;
                    const eyeH = 5 * eyeScale;

                    // Horizontal gaze follows velocity (look toward movement)
                    const gazeX = Math.max(-2, Math.min(2, this.player.vx * 0.4));
                    // Vertical gaze follows vertical velocity
                    const gazeY = Math.max(-2, Math.min(2, this.player.vy * 0.15));

                    // Eye widening on excitement (momentum, apex, close-calls)
                    const exciteFactor = Math.max(
                        (this.momentum - 1) * 0.3,
                        this.apexIntensity * 0.4,
                        this.closeCallCooldown > 25 ? 0.5 : 0
                    );
                    const wideH = eyeH * (1 + exciteFactor * 0.5);

                    // Squint when falling fast
                    const squintFactor = this.player.vy > 8 ? Math.min(0.6, (this.player.vy - 8) * 0.1) : 0;
                    const finalH = wideH * (1 - squintFactor);

                    ctx.fillRect(eyeBaseX1 + gazeX, eyeBaseY + gazeY, eyeW, finalH);
                    ctx.fillRect(eyeBaseX2 + gazeX, eyeBaseY + gazeY, eyeW, finalH);

                    // CYCLE 25: Apex shimmer effect - visual feedback for hang time
                    if (this.apexIntensity > 0.05) {
                        for (let ring = 0; ring < 3; ring++) {
                            const ringPhase = this.apexPulsePhase + ring * 0.7;
                            const ringRadius = 18 + Math.sin(ringPhase) * 6 + ring * 10;
                            const ringAlpha = this.apexIntensity * (0.25 - ring * 0.06) * (0.7 + Math.sin(ringPhase * 2) * 0.3);
                            ctx.strokeStyle = `rgba(180, 220, 255, ${ringAlpha})`;
                            ctx.lineWidth = 2 - ring * 0.5;
                            ctx.beginPath();
                            ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                    }

                    // CYCLE 31: Collection flash pulse - gold overlay when collecting coins
                    if (this.collectFlash > 0) {
                        ctx.globalAlpha = this.collectFlash * 0.6;
                        ctx.fillStyle = '#ffd700';
                        ctx.fillRect(-pw / 2, -ph / 2, pw, ph);
                        ctx.globalAlpha = 1;
                        this.collectFlash *= 0.8;
                        if (this.collectFlash < 0.05) this.collectFlash = 0;
                    }

                    ctx.restore();
                    ctx.globalAlpha = 1; // CYCLE 34: Reset after spawn-in effect
                }

                // CYCLE 35: Death tumble animation - visual closure for player death
                if (!this.alive && this.deathLocation && !this.isAI) {
                    if (!this.deathLocation.tumbleAngle) {
                        this.deathLocation.tumbleAngle = 0;
                        this.deathLocation.tumbleVX = this.player.vx * 0.5;
                        this.deathLocation.tumbleVY = -8;
                        this.deathLocation.tumbleX = this.player.x;
                        this.deathLocation.tumbleY = this.player.y;
                    }
                    const dt = this.deathLocation;
                    const tumbleAlpha = Math.max(0, 1 - dt.ghostTimer / 25);
                    if (tumbleAlpha > 0) {
                        dt.tumbleAngle += 0.35;
                        dt.tumbleVY += 0.8;
                        dt.tumbleX += dt.tumbleVX;
                        dt.tumbleY += dt.tumbleVY;
                        ctx.save();
                        ctx.globalAlpha = tumbleAlpha * 0.7;
                        ctx.translate(dt.tumbleX - this.cameraX, dt.tumbleY);
                        ctx.rotate(dt.tumbleAngle);
                        ctx.fillStyle = '#ff6666';
                        ctx.fillRect(-15, -20, 30, 40);
                        ctx.restore();
                    }
                }

                // CYCLE 30: First-jump invitation arrow - guides new players
                if (!this.isAI && !this.hasJumpedThisSession && this.alive) {
                    const arrowX = this.player.x + this.player.width / 2;
                    const arrowY = this.player.y - 40;
                    const bobOffset = Math.sin(this.time * 0.15) * 6;
                    const pulseAlpha = 0.6 + Math.sin(this.time * 0.1) * 0.3;

                    ctx.save();
                    ctx.translate(arrowX, arrowY + bobOffset);
                    ctx.globalAlpha = pulseAlpha;

                    // Arrow pointing down
                    ctx.fillStyle = '#4ecdc4';
                    ctx.beginPath();
                    ctx.moveTo(0, 15);
                    ctx.lineTo(-10, 0);
                    ctx.lineTo(-4, 0);
                    ctx.lineTo(-4, -12);
                    ctx.lineTo(4, -12);
                    ctx.lineTo(4, 0);
                    ctx.lineTo(10, 0);
                    ctx.closePath();
                    ctx.fill();

                    // "SPACE" text hint
                    ctx.font = 'bold 10px system-ui';
                    ctx.fillStyle = '#fff';
                    ctx.textAlign = 'center';
                    ctx.fillText('SPACE', 0, -20);

                    ctx.restore();
                }

                // CYCLE 1: Particles from pool
                // CYCLE 26: Color-batched particle rendering (reduces fillStyle changes)
                const particles = particlePool.getActive();
                const colorBuckets = {};
                for (const p of particles) {
                    (colorBuckets[p.color] || (colorBuckets[p.color] = [])).push(p);
                }
                for (const color in colorBuckets) {
                    ctx.fillStyle = color;
                    for (const p of colorBuckets[color]) {
                        const lifeRatio = p.life / p.maxLife;
                        ctx.globalAlpha = lifeRatio;
                        // CYCLE 33: Particle size scaling - sqrt ease-out for natural shrink
                        const size = 6 * Math.sqrt(lifeRatio);
                        ctx.fillRect(p.x - size / 2, p.y - size / 2, size, size);
                    }
                }
                ctx.globalAlpha = 1;

                // CYCLE 2: Floating score texts (CYCLE 7: Added text stroke for readability)
                // CYCLE 22: Use pool for human player, array for AI
                ctx.font = 'bold 16px system-ui';
                ctx.textAlign = 'center';
                ctx.lineWidth = 3;
                ctx.strokeStyle = '#000';
                const texts = this.isAI ? this.floatingTexts : floatingTextPool.getActive();
                if (!this.isAI) floatingTextPool.update();
                for (let i = texts.length - 1; i >= 0; i--) {
                    const ft = texts[i];
                    if (this.isAI) {
                        ft.y += ft.vy;
                        ft.alpha -= 0.025;
                        if (ft.alpha <= 0) { this.floatingTexts.splice(i, 1); continue; }
                    }
                    ctx.globalAlpha = ft.alpha;
                    ctx.strokeText(ft.text, ft.x, ft.y); // CYCLE 7: Dark outline
                    ctx.fillStyle = ft.color;
                    ctx.fillText(ft.text, ft.x, ft.y);
                }
                ctx.globalAlpha = 1;

                ctx.restore(); // World transform

                // Death location marker (uses smooth camera)
                // CYCLE 26: Ghost marker with run summary
                if (this.deathLocation) {
                    if (!this.deathLocation.ghostTimer) this.deathLocation.ghostTimer = 0;
                    const gt = this.deathLocation.ghostTimer++;
                    const ghostAlpha = Math.max(0, 1 - gt / 35);
                    const pulseRadius = 20 + gt * 1.5;
                    const dx = this.deathLocation.x - this.cameraX;

                    // Expanding pulse ring
                    ctx.strokeStyle = `rgba(255,100,100,${ghostAlpha * 0.4})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(dx, this.deathLocation.y, pulseRadius, 0, Math.PI * 2);
                    ctx.stroke();

                    // Ghost silhouette
                    ctx.globalAlpha = ghostAlpha * 0.5;
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(dx - 15, this.deathLocation.y - 20, 30, 40);

                    // Run summary text
                    ctx.globalAlpha = ghostAlpha;
                    ctx.font = 'bold 12px system-ui';
                    ctx.fillStyle = '#ffcc00';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${Math.round(this.distance)}m`, dx, this.deathLocation.y - 30);
                    // CYCLE 33: Session attempt counter
                    ctx.font = 'bold 10px system-ui';
                    ctx.fillStyle = '#88aaff';
                    ctx.fillText(`Attempt #${this.sessionAttempt}`, dx, this.deathLocation.y - 42);

                    // CYCLE 29: Death stat flash - show run stats below ghost
                    if (this.deathLocation.stats) {
                        ctx.font = 'bold 10px system-ui';
                        ctx.fillStyle = '#aaccff';
                        let statY = this.deathLocation.y + 30;
                        for (const stat of this.deathLocation.stats) {
                            ctx.fillText(stat, dx, statY);
                            statY += 14;
                        }
                    }
                    ctx.globalAlpha = 1;
                }

                // CYCLE 4: Death flash overlay
                if (this.deathFlash > 0) {
                    ctx.fillStyle = `rgba(255, 68, 68, ${this.deathFlash * 0.6})`;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    this.deathFlash *= 0.85; // Rapid fade out
                    if (this.deathFlash < 0.05) this.deathFlash = 0;
                }

                // CYCLE 32: Close-call flash overlay (cyan to match floating text)
                if (this.closeCallFlash > 0) {
                    ctx.fillStyle = `rgba(0, 255, 213, ${this.closeCallFlash * 0.3})`;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    this.closeCallFlash *= 0.85;
                    if (this.closeCallFlash < 0.05) this.closeCallFlash = 0;
                }

                // CYCLE 28+34: Momentum vignette with cached gradient (eliminates per-frame allocation)
                if (this.momentum > 1.2 && this.alive) {
                    if (!cachedVignetteGradient || cachedVignetteHeight !== canvas.height) {
                        cachedVignetteHeight = canvas.height;
                        cachedVignetteGradient = ctx.createRadialGradient(
                            canvas.width / 2, canvas.height / 2, canvas.height * 0.3,
                            canvas.width / 2, canvas.height / 2, canvas.height * 0.85
                        );
                        cachedVignetteGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
                        cachedVignetteGradient.addColorStop(1, 'rgba(20, 10, 40, 0.4)');
                    }
                    const vignetteIntensity = Math.min(1, (this.momentum - 1.2) * 0.625);
                    ctx.globalAlpha = vignetteIntensity;
                    ctx.fillStyle = cachedVignetteGradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.globalAlpha = 1;
                }

                ctx.restore(); // CYCLE 2: Screen shake restore
            }

            getAnalytics() {
                return {
                    score: this.score,
                    distance: this.distance,
                    timeAlive: this.time,
                    deathReason: this.deathLocation?.reason || 'survived',
                    deathDistance: this.deathLocation?.distance || this.distance,
                    coinsCollected: this.coinsCollected,
                    coinsMissed: this.coinsMissed,
                    jumpsUsed: this.jumpsUsed,
                    closeCallCount: this.closeCallCount,
                    idleTimeRatio: this.idleTime / Math.max(1, this.time),
                    actionVariety: this.actionVariety.size
                };
            }
        }

        // ============================================
        // AI PLAYTESTER
        // ============================================

        class AIPlayer {
            constructor(skill = 0.7) {
                this.skill = skill; // 0-1, affects reaction time and decision quality
                this.reactionDelay = Math.floor((1 - skill) * 10);
                this.jumpBuffer = 0;
                // CYCLE 24: Pre-allocated input object (eliminates ~150K allocs/evolution)
                this._input = { left: false, right: false, jump: false };
            }

            getInput(game) {
                // CYCLE 24: Reuse cached input object instead of allocating new one
                const input = this._input;
                input.left = false; input.right = false; input.jump = false;
                const player = game.player;

                // Find nearest platform ahead
                let targetPlatform = null;
                let minDist = Infinity;

                for (const plat of game.platforms) {
                    if (plat.x + plat.width > player.x && plat.x > player.x - 50) {
                        const dist = plat.x - player.x;
                        if (dist < minDist && dist > 0) {
                            minDist = dist;
                            targetPlatform = plat;
                        }
                    }
                }

                // Check for obstacles
                let dangerAhead = false;
                for (const obs of game.obstacles) {
                    if (obs.x > player.x && obs.x < player.x + 150) {
                        if (Math.abs(obs.y - player.y) < 60) {
                            dangerAhead = true;
                        }
                    }
                }

                // Decision making with skill factor
                const makeGoodDecision = Math.random() < this.skill;

                // Always try to move right (it's an endless runner)
                input.right = true;

                // Jump logic
                if (targetPlatform) {
                    const needsJump = targetPlatform.y < player.y - 20 ||
                                     !player.grounded ||
                                     minDist > 80;

                    if (needsJump && makeGoodDecision) {
                        // Predictive jump timing
                        const timeToReach = minDist / (game.dna.playerSpeed * 0.9);
                        const jumpTime = Math.sqrt(2 * Math.abs(targetPlatform.y - player.y) / game.dna.gravity);

                        if (timeToReach < jumpTime + 5 + this.reactionDelay) {
                            input.jump = player.grounded || player.jumpsLeft > 0;
                        }
                    }
                }

                // Dodge obstacles
                if (dangerAhead && makeGoodDecision) {
                    input.jump = true;
                }

                // Prevent falling off screen
                if (player.y > game.dna.worldHeight - 150 && !player.grounded) {
                    input.jump = player.jumpsLeft > 0;
                }

                // Random mistakes based on skill
                if (Math.random() > this.skill * 0.95) {
                    input.jump = !input.jump;
                }

                return input;
            }
        }

        // ============================================
        // EVOLUTION ENGINE
        // ============================================

        class EvolutionEngine {
            constructor() {
                this.populationSize = 50; // AI runs per generation
                this.mutationRate = 0.15;
                this.mutationStrength = 0.2;
                this.evolutionStrategy = 'balanced'; // balanced, conservative, aggressive, themed
                this.presets = new Map();
                this.loadPresets();
            }

            setStrategy(strategy, theme = null) {
                this.evolutionStrategy = strategy;
                this.currentTheme = theme;

                switch(strategy) {
                    case 'conservative':
                        this.mutationRate = 0.08;
                        this.mutationStrength = 0.1;
                        break;
                    case 'aggressive':
                        this.mutationRate = 0.25;
                        this.mutationStrength = 0.35;
                        break;
                    case 'themed':
                        this.mutationRate = 0.15;
                        this.mutationStrength = 0.25;
                        break;
                    default: // balanced
                        this.mutationRate = 0.15;
                        this.mutationStrength = 0.2;
                }
            }

            savePreset(name, dna, analysis) {
                this.presets.set(name, {
                    dna: {...dna},
                    analysis: {...analysis},
                    timestamp: new Date().toISOString(),
                    generation: generation
                });
                this.savePresetsToStorage();
            }

            savePresetsToStorage() {
                const presetsObj = {};
                this.presets.forEach((val, key) => {
                    presetsObj[key] = val;
                });
                localStorage.setItem('gameJamPresets', JSON.stringify(presetsObj));
            }

            loadPresets() {
                try {
                    const stored = localStorage.getItem('gameJamPresets');
                    if (stored) {
                        const presetsObj = JSON.parse(stored);
                        Object.entries(presetsObj).forEach(([key, val]) => {
                            this.presets.set(key, val);
                        });
                    }
                } catch(e) {
                    console.warn('Could not load presets:', e);
                }
            }

            loadPreset(name) {
                return this.presets.get(name);
            }

            async runGeneration(dna, onProgress) {
                const results = [];
                const aiSkills = [0.5, 0.6, 0.7, 0.8, 0.9]; // Different skill levels

                for (let i = 0; i < this.populationSize; i++) {
                    const skill = aiSkills[i % aiSkills.length];
                    const ai = new AIPlayer(skill);
                    const game = new Game(dna, true);

                    // Run simulation
                    const maxSteps = 3000;
                    for (let step = 0; step < maxSteps && game.alive; step++) {
                        const input = ai.getInput(game);
                        game.update(input);

                        // Visualize occasionally
                        if (i === 0 && step % 5 === 0) {
                            game.render();
                            await new Promise(r => setTimeout(r, Math.max(1, 50 - evolutionSpeed)));
                        }
                    }

                    results.push(game.getAnalytics());
                    onProgress((i + 1) / this.populationSize);
                }

                return this.analyzeResults(results);
            }

            analyzeResults(results) {
                const analysis = {
                    avgScore: 0,
                    avgDistance: 0,
                    avgTimeAlive: 0,
                    survivalRate: 0,
                    deathReasons: {},
                    avgCoinsCollected: 0,
                    avgCoinsMissed: 0,
                    avgCloseCall: 0,
                    avgIdleRatio: 0,
                    difficultyAssessment: 'balanced',
                    funScore: 0,
                    issues: [],
                    recommendations: []
                };

                // Aggregate stats
                for (const r of results) {
                    analysis.avgScore += r.score;
                    analysis.avgDistance += r.distance;
                    analysis.avgTimeAlive += r.timeAlive;
                    analysis.survivalRate += r.deathReason === 'survived' ? 1 : 0;
                    analysis.deathReasons[r.deathReason] = (analysis.deathReasons[r.deathReason] || 0) + 1;
                    analysis.avgCoinsCollected += r.coinsCollected;
                    analysis.avgCoinsMissed += r.coinsMissed;
                    analysis.avgCloseCall += r.closeCallCount;
                    analysis.avgIdleRatio += r.idleTimeRatio;
                }

                const n = results.length;
                analysis.avgScore /= n;
                analysis.avgDistance /= n;
                analysis.avgTimeAlive /= n;
                analysis.survivalRate /= n;
                analysis.avgCoinsCollected /= n;
                analysis.avgCoinsMissed /= n;
                analysis.avgCloseCall /= n;
                analysis.avgIdleRatio /= n;

                // Assess difficulty
                if (analysis.survivalRate < 0.1) {
                    analysis.difficultyAssessment = 'too hard';
                    analysis.issues.push('Game is too difficult - most players die quickly');
                } else if (analysis.survivalRate > 0.8) {
                    analysis.difficultyAssessment = 'too easy';
                    analysis.issues.push('Game is too easy - not enough challenge');
                } else if (analysis.avgDistance < 500) {
                    analysis.difficultyAssessment = 'frustrating start';
                    analysis.issues.push('Early game is too punishing');
                }

                // Assess engagement
                if (analysis.avgIdleRatio > 0.3) {
                    analysis.issues.push('Too much idle time - game feels slow');
                }
                if (analysis.avgCloseCall < 2) {
                    analysis.issues.push('Not enough exciting moments');
                }
                if (analysis.avgCoinsMissed > analysis.avgCoinsCollected * 2) {
                    analysis.issues.push('Coins are too hard to collect');
                }

                // Death analysis
                const topDeathReason = Object.entries(analysis.deathReasons)
                    .sort((a, b) => b[1] - a[1])[0];
                if (topDeathReason) {
                    if (topDeathReason[0] === 'fall' && topDeathReason[1] > n * 0.5) {
                        analysis.issues.push('Too many fall deaths - platforms too far apart');
                    }
                    if (topDeathReason[0] === 'obstacle' && topDeathReason[1] > n * 0.5) {
                        analysis.issues.push('Obstacles are too deadly');
                    }
                }

                // Calculate fun score (0-100)
                analysis.funScore = Math.min(100, Math.max(0,
                    50 +
                    (analysis.survivalRate - 0.3) * 50 +
                    Math.min(analysis.avgCloseCall, 10) * 3 -
                    analysis.avgIdleRatio * 30 +
                    Math.min(analysis.avgDistance / 100, 20) -
                    analysis.issues.length * 10
                ));

                // Generate recommendations
                this.generateRecommendations(analysis);

                return analysis;
            }

            generateRecommendations(analysis) {
                if (analysis.difficultyAssessment === 'too hard') {
                    analysis.recommendations.push({ gene: 'platformGap', direction: 'decrease', reason: 'reduce jump distance' });
                    analysis.recommendations.push({ gene: 'obstacleChance', direction: 'decrease', reason: 'fewer obstacles' });
                    analysis.recommendations.push({ gene: 'jumpForce', direction: 'increase', reason: 'higher jumps help' });
                }

                if (analysis.difficultyAssessment === 'too easy') {
                    analysis.recommendations.push({ gene: 'obstacleChance', direction: 'increase', reason: 'add challenge' });
                    analysis.recommendations.push({ gene: 'difficultyRamp', direction: 'increase', reason: 'faster scaling' });
                    analysis.recommendations.push({ gene: 'movingPlatformChance', direction: 'increase', reason: 'more dynamic' });
                }

                if (analysis.avgIdleRatio > 0.3) {
                    analysis.recommendations.push({ gene: 'scrollSpeed', direction: 'increase', reason: 'force action' });
                    analysis.recommendations.push({ gene: 'coinChance', direction: 'increase', reason: 'more goals' });
                }

                if (analysis.avgCloseCall < 2) {
                    analysis.recommendations.push({ gene: 'obstacleSpeed', direction: 'increase', reason: 'more tension' });
                    analysis.recommendations.push({ gene: 'obstacleSize', direction: 'decrease', reason: 'closer dodges' });
                }

                if (analysis.avgCoinsMissed > analysis.avgCoinsCollected * 2) {
                    analysis.recommendations.push({ gene: 'coinValue', direction: 'increase', reason: 'reward collection more' });
                }
            }

            mutate(dna, analysis) {
                const newDNA = { ...dna };
                const changes = [];

                // Apply themed mutations if in themed mode
                if (this.evolutionStrategy === 'themed' && this.currentTheme) {
                    this.applyThemedMutation(newDNA, changes);
                }

                // Apply recommendations
                const recApplyRate = this.evolutionStrategy === 'aggressive' ? 0.85 : 0.7;
                for (const rec of analysis.recommendations) {
                    if (Math.random() < recApplyRate) {
                        const oldVal = newDNA[rec.gene];
                        const change = oldVal * this.mutationStrength;

                        if (rec.direction === 'increase') {
                            newDNA[rec.gene] = oldVal + change;
                        } else {
                            newDNA[rec.gene] = Math.max(oldVal * 0.1, oldVal - change);
                        }

                        changes.push({
                            gene: rec.gene,
                            old: oldVal,
                            new: newDNA[rec.gene],
                            reason: rec.reason
                        });
                    }
                }

                // Random mutations for exploration
                const genes = Object.keys(dna).filter(k => typeof dna[k] === 'number');
                for (const gene of genes) {
                    if (Math.random() < this.mutationRate) {
                        const oldVal = newDNA[gene];
                        const mutation = (Math.random() - 0.5) * 2 * this.mutationStrength * oldVal;
                        newDNA[gene] = Math.max(0.1, oldVal + mutation);

                        if (!changes.find(c => c.gene === gene)) {
                            changes.push({
                                gene: gene,
                                old: oldVal,
                                new: newDNA[gene],
                                reason: 'random exploration'
                            });
                        }
                    }
                }

                return { dna: newDNA, changes };
            }

            applyThemedMutation(dna, changes) {
                const themes = {
                    'better-jumps': ['jumpForce', 'gravity', 'airControl'],
                    'better-flow': ['scrollSpeed', 'platformGap', 'platformVariance'],
                    'more-exciting': ['obstacleChance', 'obstacleSpeed', 'movingPlatformChance'],
                    'more-rewarding': ['coinChance', 'coinValue', 'powerupChance'],
                    'smoother-difficulty': ['difficultyRamp', 'maxDifficulty'],
                    'speedrun-mode': ['scrollSpeed', 'playerSpeed', 'jumpForce', 'gravity'],
                    'hardcore-mode': ['obstacleChance', 'obstacleSpeed', 'platformGap', 'difficultyRamp'],
                    'casual-mode': ['platformWidth', 'platformGap', 'jumpForce', 'coinChance']
                };

                const targetGenes = themes[this.currentTheme] || [];
                for (const gene of targetGenes) {
                    if (dna[gene] !== undefined) {
                        const oldVal = dna[gene];
                        const mutation = (Math.random() - 0.5) * 2 * this.mutationStrength * 1.5 * oldVal;
                        dna[gene] = Math.max(0.1, oldVal + mutation);

                        changes.push({
                            gene: gene,
                            old: oldVal,
                            new: dna[gene],
                            reason: `themed: ${this.currentTheme}`
                        });
                    }
                }
            }
        }

        // ============================================
        // UI UPDATES
        // ============================================

        const evolutionEngine = new EvolutionEngine();
        let currentGame = new Game(gameDNA, false);
        let humanPlaying = false;

        function updateGeneDisplay() {
            const display = document.getElementById('geneDisplay');
            const genes = [
                ['jumpForce', 'Jump Force'],
                ['gravity', 'Gravity'],
                ['platformGap', 'Platform Gap'],
                ['obstacleChance', 'Obstacle %'],
                ['coinChance', 'Coin %'],
                ['scrollSpeed', 'Scroll Speed'],
                ['difficultyRamp', 'Difficulty Ramp']
            ];

            display.innerHTML = genes.map(([key, label]) => `
                <div class="gene">
                    <span class="gene-name">${label}</span>
                    <span class="gene-value">${gameDNA[key].toFixed(2)}</span>
                </div>
            `).join('');
        }

        function updateMetrics(analysis) {
            const survivalEl = document.getElementById('metricSurvival');
            const survivalPct = (analysis.survivalRate * 100).toFixed(0);
            survivalEl.querySelector('.metric-value').textContent = survivalPct + '%';
            survivalEl.className = 'metric ' + (survivalPct > 50 ? 'good' : survivalPct > 20 ? 'warning' : 'bad');

            const scoreEl = document.getElementById('metricAvgScore');
            scoreEl.querySelector('.metric-value').textContent = Math.round(analysis.avgScore);

            const funEl = document.getElementById('metricFun');
            funEl.querySelector('.metric-value').textContent = Math.round(analysis.funScore);
            funEl.className = 'metric ' + (analysis.funScore > 60 ? 'good' : analysis.funScore > 40 ? 'warning' : 'bad');

            const diffEl = document.getElementById('metricDifficulty');
            diffEl.querySelector('.metric-value').textContent = analysis.difficultyAssessment.split(' ')[0];
            diffEl.className = 'metric ' + (analysis.difficultyAssessment === 'balanced' ? 'good' : 'warning');

            document.getElementById('fitnessFill').style.width = analysis.funScore + '%';
            document.getElementById('fitnessValue').textContent = Math.round(analysis.funScore) + '%';

            // Update death chart
            updateDeathChart(analysis.deathReasons);

            // Update fitness graph
            fitnessHistory.push(analysis.funScore);
            drawFitnessGraph();

            // Track best DNA
            if (analysis.funScore > bestFunScore) {
                bestFunScore = analysis.funScore;
                bestDNA = { ...gameDNA };
                bestGeneration = generation;
                document.getElementById('bestGen').textContent = generation;
                document.getElementById('bestScore').textContent = Math.round(analysis.funScore) + '%';
                document.getElementById('bestDNABanner').classList.add('show');
            }
        }

        function updateDeathChart(deathReasons) {
            const chart = document.getElementById('deathChart');
            const total = Object.values(deathReasons).reduce((a, b) => a + b, 0);
            if (total === 0) return;

            const colors = {
                fall: 'fall',
                obstacle: 'obstacle',
                leftEdge: 'leftEdge',
                survived: 'survived'
            };

            chart.innerHTML = Object.entries(deathReasons)
                .filter(([_, count]) => count > 0)
                .map(([reason, count]) => {
                    const pct = Math.round(count / total * 100);
                    return `<div class="death-bar ${colors[reason] || ''}" style="flex: ${count}">${pct}% ${reason}</div>`;
                }).join('');
        }

        function drawFitnessGraph() {
            const graphCanvas = document.getElementById('fitnessGraph');
            const gctx = graphCanvas.getContext('2d');
            const rect = graphCanvas.parentElement.getBoundingClientRect();
            graphCanvas.width = rect.width - 16;
            graphCanvas.height = 80;

            const w = graphCanvas.width;
            const h = graphCanvas.height;

            // Clear
            gctx.fillStyle = '#0a0a0f';
            gctx.fillRect(0, 0, w, h);

            // Grid lines
            gctx.strokeStyle = '#222';
            gctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = (i / 4) * h;
                gctx.beginPath();
                gctx.moveTo(0, y);
                gctx.lineTo(w, y);
                gctx.stroke();
            }

            if (fitnessHistory.length < 2) return;

            // Draw fitness line
            const maxPoints = 50;
            const data = fitnessHistory.slice(-maxPoints);
            const step = w / (maxPoints - 1);

            gctx.beginPath();
            gctx.strokeStyle = '#00ff88';
            gctx.lineWidth = 2;

            data.forEach((val, i) => {
                const x = i * step;
                const y = h - (val / 100) * h;
                if (i === 0) gctx.moveTo(x, y);
                else gctx.lineTo(x, y);
            });
            gctx.stroke();

            // Fill under curve
            gctx.lineTo((data.length - 1) * step, h);
            gctx.lineTo(0, h);
            gctx.closePath();
            gctx.fillStyle = 'rgba(0, 255, 136, 0.1)';
            gctx.fill();

            // Current value marker
            const lastVal = data[data.length - 1];
            const lastX = (data.length - 1) * step;
            const lastY = h - (lastVal / 100) * h;
            gctx.fillStyle = '#00ff88';
            gctx.beginPath();
            gctx.arc(lastX, lastY, 4, 0, Math.PI * 2);
            gctx.fill();
        }

        function addLogEntry(message, type = 'info') {
            const log = document.getElementById('evolutionLog');
            const entry = document.createElement('div');
            entry.className = 'log-entry ' + type;
            entry.innerHTML = `
                <span class="gen">Gen ${generation}</span>
                <span class="time">${new Date().toLocaleTimeString()}</span>
                <div>${message}</div>
            `;
            log.insertBefore(entry, log.querySelector('.log-entry'));

            // Keep only last 50 entries
            while (log.querySelectorAll('.log-entry').length > 50) {
                log.removeChild(log.lastElementChild);
            }
        }

        async function evolveOnce() {
            generation++;
            document.getElementById('genBadge').textContent = `Generation ${generation}`;
            document.getElementById('genBadge').classList.add('evolving');
            document.getElementById('statusText').textContent = 'Running AI playtests...';

            addLogEntry('Starting AI playtest population...', 'analysis');

            // Run tests
            const analysis = await evolutionEngine.runGeneration(gameDNA, (progress) => {
                document.getElementById('testProgress').style.width = (progress * 100) + '%';
            });

            updateMetrics(analysis);

            // Log issues
            for (const issue of analysis.issues) {
                addLogEntry(`Issue: ${issue}`, 'analysis');
            }

            // Mutate
            const { dna: newDNA, changes } = evolutionEngine.mutate(gameDNA, analysis);
            gameDNA = newDNA;

            // Log changes
            for (const change of changes) {
                const direction = change.new > change.old ? '‚Üë' : '‚Üì';
                addLogEntry(`Mutated ${change.gene}: ${change.old.toFixed(2)} ‚Üí ${change.new.toFixed(2)} ${direction} (${change.reason})`, 'mutation');
            }

            updateGeneDisplay();

            evolutionHistory.push({
                generation,
                funScore: analysis.funScore,
                dna: { ...gameDNA },
                analysis
            });

            // Auto-save presets at milestones
            if (generation % 10 === 0) {
                evolutionEngine.savePreset(`Generation_${generation}`, gameDNA, analysis);
                addLogEntry(`Milestone preset saved: Generation_${generation}`, 'info');
                console.log(`[MILESTONE] Gen ${generation}: Fun=${Math.round(analysis.funScore)}%, Survival=${Math.round(analysis.survivalRate*100)}%, AvgDist=${Math.round(analysis.avgDistance)}`);
            }

            // Console log for autonomous tracking
            console.log(`[GEN ${generation}] Strategy: ${evolutionEngine.evolutionStrategy}, Fun: ${Math.round(analysis.funScore)}%, Issues: ${analysis.issues.length}, Changes: ${changes.length}`);

            document.getElementById('genBadge').classList.remove('evolving');
            document.getElementById('statusText').textContent = `Gen ${generation} complete. Fun score: ${Math.round(analysis.funScore)}%`;

            return analysis;
        }

        async function autoEvolve() {
            isAutoEvolving = !isAutoEvolving;
            const btn = document.getElementById('autoEvolve');
            btn.textContent = isAutoEvolving ? 'Stop Evolution' : 'Auto-Evolve';
            btn.classList.toggle('primary', !isAutoEvolving);

            // Autonomous evolution orchestrator
            let strategyPhase = 0;
            const strategies = [
                { name: 'conservative', cycles: 10, description: 'Baseline establishment' },
                { name: 'aggressive', cycles: 15, description: 'Aggressive exploration' },
                { name: 'balanced', cycles: 10, description: 'Refinement phase' },
                { name: 'themed', cycles: 5, description: 'Themed optimization', theme: 'better-flow' },
                { name: 'aggressive', cycles: 10, description: 'Second exploration' },
                { name: 'balanced', cycles: 10, description: 'Final refinement' }
            ];

            let cyclesInPhase = 0;
            let stagnantGenerations = 0;
            let lastBestScore = bestFunScore;

            while (isAutoEvolving) {
                // Switch strategy based on progress
                if (strategyPhase < strategies.length) {
                    const currentStrategy = strategies[strategyPhase];

                    if (cyclesInPhase === 0) {
                        evolutionEngine.setStrategy(currentStrategy.name, currentStrategy.theme);
                        addLogEntry(`Strategy: ${currentStrategy.description} (${currentStrategy.name})`, 'info');
                        console.log(`[STRATEGY CHANGE] Phase ${strategyPhase + 1}: ${currentStrategy.description}`);
                    }

                    cyclesInPhase++;

                    if (cyclesInPhase >= currentStrategy.cycles) {
                        cyclesInPhase = 0;
                        strategyPhase++;
                    }
                }

                const analysis = await evolveOnce();

                // Track stagnation
                if (analysis.funScore <= lastBestScore + 1) {
                    stagnantGenerations++;
                } else {
                    stagnantGenerations = 0;
                    lastBestScore = analysis.funScore;
                }

                // Adaptive strategy switching on stagnation
                if (stagnantGenerations >= 5 && generation > 15) {
                    addLogEntry(`Detected stagnation. Switching to aggressive exploration.`, 'info');
                    evolutionEngine.setStrategy('aggressive');
                    stagnantGenerations = 0;
                    console.log('[ADAPTIVE] Stagnation detected, switching to aggressive mode');
                }

                // Try themed evolution if stuck
                if (stagnantGenerations >= 8 && generation > 20) {
                    const themes = ['better-jumps', 'better-flow', 'more-exciting', 'more-rewarding'];
                    const randomTheme = themes[Math.floor(Math.random() * themes.length)];
                    addLogEntry(`Deep stagnation. Trying themed evolution: ${randomTheme}`, 'info');
                    evolutionEngine.setStrategy('themed', randomTheme);
                    stagnantGenerations = 0;
                    console.log(`[ADAPTIVE] Deep stagnation, trying theme: ${randomTheme}`);
                }

                // Stop if we've achieved target or hit generation limit
                if (analysis.funScore >= 80) {
                    addLogEntry(`Target achieved! Fun score: ${Math.round(analysis.funScore)}%`, 'info');
                    console.log(`[SUCCESS] Target fun score reached at generation ${generation}`);
                    evolutionEngine.savePreset('Target_Achieved', gameDNA, analysis);
                    isAutoEvolving = false;
                    btn.textContent = 'Auto-Evolve';
                    btn.classList.add('primary');
                } else if (generation >= 100) {
                    addLogEntry(`Reached generation limit (100). Best score: ${Math.round(bestFunScore)}%`, 'info');
                    console.log(`[LIMIT] Generation limit reached. Best: ${Math.round(bestFunScore)}%`);
                    isAutoEvolving = false;
                    btn.textContent = 'Auto-Evolve';
                    btn.classList.add('primary');
                }

                await new Promise(r => setTimeout(r, 500));
            }

            // Export data when stopping
            if (generation > 0) {
                console.log('[AUTO-EVOLVE] Stopped. Exporting evolution data...');
                exportEvolutionData();
            }
        }

        function playHuman() {
            humanPlaying = !humanPlaying;
            document.getElementById('playHuman').textContent = humanPlaying ? 'Stop Playing' : 'Play Yourself';
            document.getElementById('hudStatus').textContent = humanPlaying ? 'You are playing!' : 'AI Playtesting...';

            // CYCLE 1: Toggle touch controls and momentum HUD
            const touchControls = document.getElementById('touchControls');
            const momentumHud = document.getElementById('momentumHud');

            if (humanPlaying) {
                // CYCLE 4: Initialize audio on user gesture
                Audio.init();
                Audio.resume();
                currentGame = new Game(gameDNA, false);
                // Show touch controls on mobile devices
                if (isMobile && touchControls) {
                    touchControls.classList.add('active');
                }
                // Always show momentum HUD when playing
                if (momentumHud) {
                    momentumHud.classList.add('active');
                }
                // CYCLE 4: Show jump indicator
                if (jumpIndicator) {
                    jumpIndicator.classList.add('active');
                }
                // CYCLE 10: Show control hints on desktop for first 8 seconds
                const controlHints = document.getElementById('controlHints');
                if (!isMobile && controlHints) {
                    controlHints.classList.add('visible');
                    setTimeout(() => controlHints.classList.remove('visible'), 8000);
                }
                gameLoop();
            } else {
                // Hide controls when stopping
                if (touchControls) touchControls.classList.remove('active');
                if (momentumHud) momentumHud.classList.remove('active');
                if (jumpIndicator) jumpIndicator.classList.remove('active');
                // CYCLE 10: Hide control hints
                const controlHints = document.getElementById('controlHints');
                if (controlHints) controlHints.classList.remove('visible');
            }
        }

        const keys = { left: false, right: false, jump: false };
        document.addEventListener('keydown', e => {
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = true;
            if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = true;
            if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') {
                keys.jump = true;
                e.preventDefault();
            }
        });
        document.addEventListener('keyup', e => {
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
            if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
            if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') keys.jump = false;
        });

        // ============================================
        // CYCLE 1: Touch Controls Setup
        // ============================================
        const touchLeft = document.getElementById('touchLeft');
        const touchRight = document.getElementById('touchRight');
        const touchJump = document.getElementById('touchJump');
        const touchControls = document.getElementById('touchControls');
        const momentumHud = document.getElementById('momentumHud');
        const momentumFill = document.getElementById('momentumFill');
        const comboDisplay = document.getElementById('comboDisplay');

        // CYCLE 4: Jump indicator elements
        const jumpIndicator = document.getElementById('jumpIndicator');
        const jumpPip1 = document.getElementById('jumpPip1');
        const jumpPip2 = document.getElementById('jumpPip2');

        // Detect mobile device
        const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

        function setupTouchControls() {
            if (!touchLeft || !touchRight || !touchJump) return;

            // CYCLE 23: Touch ripple helper
            const triggerRipple = (el) => {
                el.classList.remove('ripple');
                void el.offsetWidth; // Force reflow for re-trigger
                el.classList.add('ripple');
            };

            // Left button - CYCLE 18: Added haptic feedback
            touchLeft.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys.left = true;
                touchLeft.classList.add('pressed');
                triggerRipple(touchLeft); // CYCLE 23: Ripple effect
                Haptics.light();
            }, { passive: false });
            touchLeft.addEventListener('touchend', () => {
                keys.left = false;
                touchLeft.classList.remove('pressed');
            });

            // Right button - CYCLE 18: Added haptic feedback
            touchRight.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys.right = true;
                touchRight.classList.add('pressed');
                triggerRipple(touchRight); // CYCLE 23: Ripple effect
                Haptics.light();
            }, { passive: false });
            touchRight.addEventListener('touchend', () => {
                keys.right = false;
                touchRight.classList.remove('pressed');
            });

            // Jump button - CYCLE 8: Fixed touchend to reset keys.jump
            // CYCLE 18: Added haptic feedback (medium intensity for jump)
            touchJump.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys.jump = true;
                touchJump.classList.add('pressed');
                triggerRipple(touchJump); // CYCLE 23: Ripple effect
                Haptics.medium();
            }, { passive: false });
            touchJump.addEventListener('touchend', () => {
                keys.jump = false; // CYCLE 8: Critical fix for variable jump height
                touchJump.classList.remove('pressed');
            });
            // CYCLE 8: Handle touch cancellation (calls, notifications)
            touchJump.addEventListener('touchcancel', () => {
                keys.jump = false;
                touchJump.classList.remove('pressed');
            });
            touchLeft.addEventListener('touchcancel', () => {
                keys.left = false;
                touchLeft.classList.remove('pressed');
            });
            touchRight.addEventListener('touchcancel', () => {
                keys.right = false;
                touchRight.classList.remove('pressed');
            });
        }
        setupTouchControls();

        // CYCLE 13: HUD throttling state (reduce DOM updates 60‚Üí20 fps)
        let hudFrameCounter = 0;
        let lastHudScore = -1;
        let lastHudCombo = -1;
        let lastHudDist = -1;

        function gameLoop() {
            if (!humanPlaying) return;

            if (currentGame.alive) {
                currentGame.update(keys);
                keys.jump = false; // Consume jump

                // CYCLE 1: Update momentum HUD
                // CYCLE 9: Contextual visibility - only show when momentum > 1.05
                if (momentumFill && comboDisplay) {
                    const momentumHud = momentumFill.closest('.momentum-hud');
                    if (momentumHud) {
                        const shouldShow = currentGame.momentum > 1.05;
                        momentumHud.style.opacity = shouldShow ? '1' : '0';
                        momentumHud.style.transition = 'opacity 0.3s';
                    }

                    const momentumPct = ((currentGame.momentum - 1) / 2) * 100;
                    momentumFill.style.width = momentumPct + '%';

                    if (currentGame.combo > 0) {
                        comboDisplay.textContent = `x${currentGame.combo}`;
                        comboDisplay.classList.toggle('high', currentGame.combo >= 5);

                        // CYCLE 20: Combo expiry warning pulse - starts at 60 frames (1 second) remaining
                        const timeSinceLastPlatform = currentGame.time - currentGame.lastPlatformTime;
                        const comboExpiring = timeSinceLastPlatform > 60 && timeSinceLastPlatform < 120;
                        comboDisplay.classList.toggle('expiring', comboExpiring);
                    } else {
                        comboDisplay.textContent = `x${currentGame.momentum.toFixed(1)}`;
                        comboDisplay.classList.remove('high');
                        comboDisplay.classList.remove('expiring');
                    }
                }

                // CYCLE 4: Update jump availability indicator
                // CYCLE 9: Progressive disclosure - show only when airborne or jumps used
                if (jumpPip1 && jumpPip2) {
                    const jumps = currentGame.player.jumpsLeft;
                    const jumpIndicator = jumpPip1.closest('.jump-indicator');
                    if (jumpIndicator) {
                        const shouldShow = !currentGame.player.grounded || jumps < 2;
                        jumpIndicator.style.opacity = shouldShow ? '1' : '0';
                        jumpIndicator.style.transition = 'opacity 0.2s';
                    }
                    jumpPip1.className = 'jump-pip ' + (jumps >= 1 ? 'available' : 'used');
                    jumpPip2.className = 'jump-pip ' + (jumps >= 2 ? 'available' : 'used');
                }
            } else {
                // CYCLE 4: Quick respawn (reduced from 1000ms to 500ms)
                setTimeout(() => {
                    if (humanPlaying) {
                        currentGame = new Game(gameDNA, false);
                        Audio.playRespawn(); // CYCLE 35: Audio feedback for respawn
                    }
                }, 500);
            }

            currentGame.render();

            // CYCLE 13: Throttle HUD DOM updates to every 3rd frame (~20fps)
            hudFrameCounter++;
            if (hudFrameCounter % 3 === 0) {
                const score = currentGame.score;
                const combo = currentGame.combo;
                const dist = Math.round(currentGame.distance);
                if (score !== lastHudScore || combo !== lastHudCombo || dist !== lastHudDist) {
                    const hudScoreEl = document.getElementById('hudScore');
                    // CYCLE 25: Score pop animation when score increases
                    if (score > lastHudScore) {
                        hudScoreEl.classList.remove('score-pop');
                        void hudScoreEl.offsetWidth; // Force reflow to restart animation
                        hudScoreEl.classList.add('score-pop');
                    }
                    hudScoreEl.textContent = `Score: ${score} | Combo: x${combo} | Dist: ${dist}`;
                    lastHudScore = score;
                    lastHudCombo = combo;
                    lastHudDist = dist;
                }
            }

            requestAnimationFrame(gameLoop);
        }

        // Export evolution data for analysis
        function exportEvolutionData() {
            const exportData = {
                timestamp: new Date().toISOString(),
                totalGenerations: generation,
                bestGeneration: bestGeneration,
                bestFunScore: bestFunScore,
                bestDNA: bestDNA,
                currentDNA: gameDNA,
                evolutionHistory: evolutionHistory,
                fitnessHistory: fitnessHistory,
                presets: Array.from(evolutionEngine.presets.entries()).map(([name, data]) => ({name, ...data}))
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `evolution-data-gen${generation}.json`;
            link.click();
            URL.revokeObjectURL(url);

            console.log('[EXPORT] Evolution data exported:', exportData);
            addLogEntry('Evolution data exported to JSON file', 'info');
        }

        // Create specialized game modes from best DNA
        function createGameModes() {
            if (!bestDNA) {
                console.log('[MODES] No best DNA found yet');
                return;
            }

            // Hardcore Mode - amp up difficulty
            const hardcoreDNA = {...bestDNA};
            hardcoreDNA.obstacleChance *= 1.5;
            hardcoreDNA.obstacleSpeed *= 1.3;
            hardcoreDNA.platformGap *= 1.2;
            hardcoreDNA.difficultyRamp *= 1.5;
            hardcoreDNA.movingPlatformChance *= 1.4;
            evolutionEngine.savePreset('Hardcore_Mode', hardcoreDNA, {funScore: 0, difficultyAssessment: 'hardcore'});

            // Casual Mode - make it easier and more relaxed
            const casualDNA = {...bestDNA};
            casualDNA.platformWidth *= 1.3;
            casualDNA.platformGap *= 0.8;
            casualDNA.jumpForce *= 1.2;
            casualDNA.coinChance *= 1.5;
            casualDNA.obstacleChance *= 0.6;
            casualDNA.scrollSpeed *= 0.8;
            evolutionEngine.savePreset('Casual_Mode', casualDNA, {funScore: 0, difficultyAssessment: 'casual'});

            // Speedrun Mode - fast and smooth
            const speedrunDNA = {...bestDNA};
            speedrunDNA.scrollSpeed *= 1.5;
            speedrunDNA.playerSpeed *= 1.4;
            speedrunDNA.jumpForce *= 1.2;
            speedrunDNA.gravity *= 1.1;
            speedrunDNA.platformGap *= 1.1;
            speedrunDNA.coinValue *= 2;
            evolutionEngine.savePreset('Speedrun_Mode', speedrunDNA, {funScore: 0, difficultyAssessment: 'speedrun'});

            console.log('[MODES] Created specialized game modes: Hardcore, Casual, Speedrun');
            addLogEntry('Created specialized game modes from best DNA', 'info');

            return {hardcore: hardcoreDNA, casual: casualDNA, speedrun: speedrunDNA};
        }

        // Make functions available via console
        window.exportEvolutionData = exportEvolutionData;
        window.createGameModes = createGameModes;
        window.setEvolutionStrategy = (strategy, theme) => {
            evolutionEngine.setStrategy(strategy, theme);
            console.log(`[STRATEGY] Set to ${strategy}${theme ? ` with theme ${theme}` : ''}`);
        };

        // CYCLE 15: Add click sound to all UI buttons
        document.querySelectorAll('button').forEach(btn => {
            btn.addEventListener('click', () => {
                Audio.init();
                Audio.playClick();
            });
        });

        // Event listeners
        document.getElementById('evolveOnce').addEventListener('click', evolveOnce);
        document.getElementById('autoEvolve').addEventListener('click', autoEvolve);
        document.getElementById('playHuman').addEventListener('click', playHuman);
        document.getElementById('speedSlider').addEventListener('input', e => {
            evolutionSpeed = parseInt(e.target.value);
        });
        document.getElementById('loadBest').addEventListener('click', () => {
            if (bestDNA) {
                gameDNA = { ...bestDNA };
                updateGeneDisplay();
                addLogEntry(`Loaded best DNA from generation ${bestGeneration} (${Math.round(bestFunScore)}% fun)`, 'info');
                currentGame = new Game(gameDNA, false);
                currentGame.render();
            }
        });

        // Initial setup
        updateGeneDisplay();
        addLogEntry('Infinite Game Jam initialized. Click "Auto-Evolve" to begin!', 'info');

        // Render initial state
        currentGame.render();
    </script>
</body>
</html>
