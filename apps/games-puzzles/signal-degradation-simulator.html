<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Signal Degradation Simulator</title>
    <meta name="description" content="Draw perfect shapes and watch them dissolve into analog glitch, pixelation, and pure entropy noise">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0a0c; min-height: 100vh; font-family: 'Courier New', monospace; color: #a0a0b0; overflow: hidden; }
        #canvas { position: fixed; top: 0; left: 0; cursor: crosshair; }
        #controls {
            position: fixed; top: 20px; left: 20px; background: rgba(15,15,20,0.95);
            padding: 20px; border-radius: 10px; border: 1px solid rgba(100,100,120,0.3);
            z-index: 100;
        }
        h3 { margin-bottom: 15px; color: #c0c0d0; font-weight: normal; }
        .control-row { margin: 10px 0; }
        label { display: block; font-size: 11px; margin-bottom: 5px; opacity: 0.8; }
        input[type="range"] { width: 140px; }
        .value { float: right; color: #8080a0; font-size: 12px; }
        button {
            display: block; width: 100%; padding: 10px; margin: 6px 0;
            background: rgba(60,60,80,0.4); border: 1px solid rgba(100,100,120,0.4);
            color: #a0a0b0; cursor: pointer; border-radius: 6px;
        }
        #entropy-meter {
            position: fixed; top: 20px; right: 20px; background: rgba(15,15,20,0.95);
            padding: 15px 20px; border-radius: 10px; border: 1px solid rgba(100,100,120,0.3);
            z-index: 100; text-align: center;
        }
        #entropy-bar { width: 100px; height: 10px; background: #1a1a20; border-radius: 5px; margin-top: 10px; overflow: hidden; }
        #entropy-fill { height: 100%; background: linear-gradient(90deg, #4040ff, #ff4040); width: 0%; transition: width 0.3s; }
        #info { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); font-size: 12px; opacity: 0.5; z-index: 100; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="controls">
        <h3>Entropy Lab</h3>
        <div class="control-row">
            <label>Decay Speed <span class="value" id="speed-val">50</span></label>
            <input type="range" id="speed" min="10" max="100" value="50">
        </div>
        <div class="control-row">
            <label>Noise Intensity <span class="value" id="noise-val">30</span></label>
            <input type="range" id="noise" min="0" max="100" value="30">
        </div>
        <button id="clear-btn">Clear Canvas</button>
        <button id="freeze-btn">Freeze Decay</button>
    </div>
    <div id="entropy-meter">
        <div style="font-size:12px;color:#8080a0">ENTROPY LEVEL</div>
        <div id="entropy-bar"><div id="entropy-fill"></div></div>
    </div>
    <div id="info">Draw shapes | Watch them decay through 5 stages to pure noise</div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let W, H;
        function resize() { W = canvas.width = innerWidth; H = canvas.height = innerHeight; }
        resize(); window.onresize = resize;
        
        let decaySpeed = 0.5;
        let noiseIntensity = 0.3;
        let frozen = false;
        let isDrawing = false;
        let currentPath = [];
        let shapes = [];
        let noiseParticles = [];
        let totalEntropy = 0;
        
        class Shape {
            constructor(points, color) {
                this.points = points.map(p => ({...p}));
                this.originalPoints = points.map(p => ({...p}));
                this.color = color;
                this.stage = 0;
                this.decay = 0;
                this.noise = [];
                this.glitchOffset = 0;
                this.ditherPhase = 0;
                
                for (let i = 0; i < 20; i++) {
                    this.noise.push({
                        x: Math.random() * 100 - 50,
                        y: Math.random() * 100 - 50,
                        size: 2 + Math.random() * 5,
                        speed: Math.random() * 0.02
                    });
                }
            }
            update() {
                if (frozen) return;
                
                this.decay += 0.001 * decaySpeed;
                this.stage = Math.min(4, Math.floor(this.decay * 5));
                
                if (this.stage >= 1) {
                    this.points.forEach((p, i) => {
                        p.x += (Math.random() - 0.5) * this.decay * 2;
                        p.y += (Math.random() - 0.5) * this.decay * 2;
                    });
                }
                
                if (this.stage >= 2) {
                    this.glitchOffset = Math.sin(Date.now() * 0.01) * this.decay * 20;
                }
                
                if (this.stage >= 3) {
                    this.ditherPhase += 0.1;
                }
                
                if (this.stage >= 4 && Math.random() < 0.1 * decaySpeed) {
                    const center = this.getCenter();
                    noiseParticles.push({
                        x: center.x + (Math.random() - 0.5) * 100,
                        y: center.y + (Math.random() - 0.5) * 100,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        size: 1 + Math.random() * 3,
                        life: 1,
                        color: this.color
                    });
                }
                
                this.noise.forEach(n => {
                    n.x += Math.sin(Date.now() * n.speed) * 0.5;
                    n.y += Math.cos(Date.now() * n.speed) * 0.5;
                });
            }
            getCenter() {
                const avgX = this.points.reduce((s, p) => s + p.x, 0) / this.points.length;
                const avgY = this.points.reduce((s, p) => s + p.y, 0) / this.points.length;
                return {x: avgX, y: avgY};
            }
            draw() {
                if (this.points.length < 2) return;
                
                const alpha = Math.max(0.1, 1 - this.decay);
                const center = this.getCenter();
                
                ctx.save();
                
                if (this.stage >= 2) {
                    ctx.translate(this.glitchOffset, 0);
                }
                
                ctx.beginPath();
                ctx.moveTo(this.points[0].x, this.points[0].y);
                for (let i = 1; i < this.points.length; i++) {
                    ctx.lineTo(this.points[i].x, this.points[i].y);
                }
                
                let strokeColor = this.color;
                let lineWidth = 3;
                
                if (this.stage === 0) {
                    strokeColor = this.color;
                } else if (this.stage === 1) {
                    const r = parseInt(this.color.slice(1, 3), 16);
                    const g = parseInt(this.color.slice(3, 5), 16);
                    const b = parseInt(this.color.slice(5, 7), 16);
                    const noise = Math.random() * 30;
                    strokeColor = "rgb(" + Math.min(255, r + noise) + "," + Math.min(255, g + noise) + "," + Math.min(255, b + noise) + ")";
                } else if (this.stage === 2) {
                    ctx.setLineDash([5, 3]);
                    strokeColor = "rgba(" + 
                        parseInt(this.color.slice(1, 3), 16) + "," +
                        parseInt(this.color.slice(3, 5), 16) + "," +
                        parseInt(this.color.slice(5, 7), 16) + "," + alpha + ")";
                } else if (this.stage === 3) {
                    lineWidth = 1 + Math.sin(this.ditherPhase) * 2;
                    strokeColor = "rgba(128, 128, 128, " + alpha + ")";
                } else {
                    strokeColor = "rgba(80, 80, 80, " + (alpha * 0.5) + ")";
                }
                
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = lineWidth;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.stroke();
                
                if (this.stage >= 1) {
                    for (let i = 0; i < this.decay * 10; i++) {
                        const px = this.points[Math.floor(Math.random() * this.points.length)];
                        if (px) {
                            ctx.fillStyle = "rgba(255, 100, 100, " + (0.3 * (1 - this.decay)) + ")";
                            ctx.fillRect(px.x + (Math.random() - 0.5) * 20, px.y + (Math.random() - 0.5) * 20, 2, 2);
                        }
                    }
                }
                
                if (this.stage >= 3) {
                    this.noise.forEach(n => {
                        ctx.beginPath();
                        ctx.arc(center.x + n.x, center.y + n.y, n.size, 0, Math.PI * 2);
                        ctx.fillStyle = "rgba(100, 100, 120, " + (this.decay * 0.5) + ")";
                        ctx.fill();
                    });
                }
                
                if (this.stage >= 2) {
                    for (let i = 0; i < 3; i++) {
                        const scanY = center.y + (Math.random() - 0.5) * 100;
                        ctx.fillStyle = "rgba(255, 255, 255, " + (0.1 * this.decay) + ")";
                        ctx.fillRect(center.x - 50, scanY, 100, 1);
                    }
                }
                
                ctx.restore();
            }
            isDecayed() {
                return this.decay >= 1;
            }
        }
        
        function getRandomColor() {
            const hue = Math.floor(Math.random() * 360);
            return "hsl(" + hue + ", 70%, 60%)";
        }
        
        function hslToHex(hsl) {
            const match = hsl.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
            if (!match) return '#888888';
            
            let h = parseInt(match[1]) / 360;
            let s = parseInt(match[2]) / 100;
            let l = parseInt(match[3]) / 100;
            
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            
            const toHex = x => {
                const hex = Math.round(x * 255).toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            };
            
            return '#' + toHex(r) + toHex(g) + toHex(b);
        }
        
        function drawBackground() {
            ctx.fillStyle = '#0a0a0c';
            ctx.fillRect(0, 0, W, H);
            
            if (noiseIntensity > 0) {
                for (let i = 0; i < noiseIntensity * 100; i++) {
                    const x = Math.random() * W;
                    const y = Math.random() * H;
                    const brightness = Math.random() * 30;
                    ctx.fillStyle = "rgb(" + brightness + "," + brightness + "," + brightness + ")";
                    ctx.fillRect(x, y, 1, 1);
                }
            }
        }
        
        function updateEntropy() {
            totalEntropy = shapes.reduce((sum, s) => sum + s.decay, 0) / Math.max(1, shapes.length);
            document.getElementById('entropy-fill').style.width = (totalEntropy * 100) + '%';
        }
        
        function animate() {
            drawBackground();
            
            shapes.forEach(s => {
                s.update();
                s.draw();
            });
            
            shapes = shapes.filter(s => !s.isDecayed());
            
            noiseParticles = noiseParticles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.02;
                
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                ctx.fillStyle = "rgba(100, 100, 120, " + p.life + ")";
                ctx.fill();
                
                return p.life > 0;
            });
            
            if (isDrawing && currentPath.length > 0) {
                ctx.beginPath();
                ctx.moveTo(currentPath[0].x, currentPath[0].y);
                for (let i = 1; i < currentPath.length; i++) {
                    ctx.lineTo(currentPath[i].x, currentPath[i].y);
                }
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.stroke();
            }
            
            updateEntropy();
            requestAnimationFrame(animate);
        }
        
        canvas.onmousedown = e => {
            isDrawing = true;
            currentPath = [{x: e.clientX, y: e.clientY}];
        };
        
        canvas.onmousemove = e => {
            if (isDrawing) {
                currentPath.push({x: e.clientX, y: e.clientY});
            }
        };
        
        canvas.onmouseup = e => {
            if (isDrawing && currentPath.length > 2) {
                const color = hslToHex(getRandomColor());
                shapes.push(new Shape(currentPath, color));
            }
            isDrawing = false;
            currentPath = [];
        };
        
        canvas.ontouchstart = e => {
            e.preventDefault();
            isDrawing = true;
            currentPath = [{x: e.touches[0].clientX, y: e.touches[0].clientY}];
        };
        
        canvas.ontouchmove = e => {
            e.preventDefault();
            if (isDrawing) {
                currentPath.push({x: e.touches[0].clientX, y: e.touches[0].clientY});
            }
        };
        
        canvas.ontouchend = e => {
            if (isDrawing && currentPath.length > 2) {
                const color = hslToHex(getRandomColor());
                shapes.push(new Shape(currentPath, color));
            }
            isDrawing = false;
            currentPath = [];
        };
        
        document.getElementById('speed').oninput = e => {
            decaySpeed = e.target.value / 100;
            document.getElementById('speed-val').textContent = e.target.value;
        };
        
        document.getElementById('noise').oninput = e => {
            noiseIntensity = e.target.value / 100;
            document.getElementById('noise-val').textContent = e.target.value;
        };
        
        document.getElementById('clear-btn').onclick = () => {
            shapes = [];
            noiseParticles = [];
        };
        
        document.getElementById('freeze-btn').onclick = () => {
            frozen = !frozen;
            document.getElementById('freeze-btn').textContent = frozen ? 'Resume Decay' : 'Freeze Decay';
        };
        
        animate();
    </script>
</body>
</html>