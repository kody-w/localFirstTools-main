<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Entity-Component-System game engine with live inspector - asteroid field demo running 1000+ entities at 60fps">
    <meta name="theme-color" content="#0a0a12">
    <meta name="color-scheme" content="dark">
    <title>ECS Game Engine</title>
    <!-- game, ecs, entity-component-system, canvas, performance -->
    <style>
        :root {
            --bg-primary: #0a0a12;
            --bg-secondary: #12121f;
            --bg-tertiary: #1a1a2e;
            --text-primary: #e8e8f0;
            --text-secondary: #8888a0;
            --accent: #00d4ff;
            --accent-dim: #0088aa;
            --warning: #ffaa00;
            --danger: #ff4466;
            --success: #44ff88;
            --player: #00ffcc;
            --enemy: #ff4466;
            --asteroid: #888899;
            --bullet: #ffff44;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Mono', 'Consolas', monospace;
            background: var(--bg-primary);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
            display: flex;
        }

        .game-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--bg-tertiary);
        }

        .game-title {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .game-title h1 {
            font-size: 1rem;
            background: linear-gradient(135deg, var(--accent), var(--player));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .game-stats {
            display: flex;
            gap: 1.5rem;
            font-size: 0.75rem;
        }

        .stat {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .stat-label {
            color: var(--text-secondary);
        }

        .stat-value {
            font-weight: 600;
            min-width: 50px;
        }

        .stat-value.good { color: var(--success); }
        .stat-value.warn { color: var(--warning); }
        .stat-value.bad { color: var(--danger); }

        .canvas-wrapper {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            background: radial-gradient(ellipse at center, #0a0a18 0%, #000008 100%);
        }

        .game-hud {
            position: absolute;
            top: 1rem;
            left: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            pointer-events: none;
        }

        .hud-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
            text-shadow: 0 0 10px rgba(0,0,0,0.8);
        }

        .hud-score { color: var(--accent); }
        .hud-lives { color: var(--player); }
        .hud-wave { color: var(--warning); }

        .game-over {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.8);
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
        }

        .game-over.active {
            opacity: 1;
            visibility: visible;
        }

        .game-over h2 {
            font-size: 3rem;
            color: var(--danger);
            margin-bottom: 1rem;
        }

        .game-over p {
            font-size: 1.25rem;
            color: var(--text-secondary);
            margin-bottom: 2rem;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: var(--accent);
            color: var(--bg-primary);
        }

        .btn-primary:hover {
            background: var(--player);
            transform: scale(1.05);
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--accent-dim);
        }

        /* Inspector Panel */
        .inspector {
            width: 320px;
            background: var(--bg-secondary);
            border-left: 1px solid var(--bg-tertiary);
            display: flex;
            flex-direction: column;
            font-size: 0.75rem;
        }

        .inspector-header {
            padding: 0.75rem 1rem;
            background: var(--bg-tertiary);
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .inspector-toggle {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 1rem;
        }

        .inspector-section {
            border-bottom: 1px solid var(--bg-tertiary);
        }

        .section-header {
            padding: 0.5rem 1rem;
            background: var(--bg-primary);
            color: var(--text-secondary);
            font-size: 0.625rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            display: flex;
            justify-content: space-between;
        }

        .system-timings {
            padding: 0.5rem 1rem;
        }

        .timing-row {
            display: flex;
            justify-content: space-between;
            padding: 0.25rem 0;
        }

        .timing-name {
            color: var(--text-secondary);
        }

        .timing-bar {
            width: 100px;
            height: 4px;
            background: var(--bg-primary);
            border-radius: 2px;
            overflow: hidden;
            margin-left: 0.5rem;
        }

        .timing-fill {
            height: 100%;
            background: var(--accent);
            transition: width 0.1s;
        }

        .entity-list {
            flex: 1;
            overflow-y: auto;
            max-height: 200px;
        }

        .entity-item {
            padding: 0.375rem 1rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--bg-primary);
        }

        .entity-item:hover {
            background: var(--bg-tertiary);
        }

        .entity-item.selected {
            background: var(--accent-dim);
        }

        .entity-id {
            font-weight: 600;
        }

        .entity-tags {
            display: flex;
            gap: 0.25rem;
        }

        .entity-tag {
            padding: 0.125rem 0.375rem;
            border-radius: 3px;
            font-size: 0.625rem;
            background: var(--bg-primary);
        }

        .entity-tag.player { background: var(--player); color: black; }
        .entity-tag.enemy { background: var(--enemy); color: white; }
        .entity-tag.asteroid { background: var(--asteroid); color: white; }
        .entity-tag.bullet { background: var(--bullet); color: black; }

        .component-inspector {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
        }

        .component-card {
            background: var(--bg-primary);
            border-radius: 6px;
            margin-bottom: 0.5rem;
            overflow: hidden;
        }

        .component-header {
            padding: 0.5rem;
            background: var(--bg-tertiary);
            font-weight: 600;
            color: var(--accent);
        }

        .component-props {
            padding: 0.5rem;
        }

        .prop-row {
            display: flex;
            justify-content: space-between;
            padding: 0.125rem 0;
        }

        .prop-name {
            color: var(--text-secondary);
        }

        .prop-value {
            color: var(--text-primary);
            font-weight: 500;
        }

        .controls-help {
            padding: 0.75rem 1rem;
            background: var(--bg-primary);
            font-size: 0.625rem;
            color: var(--text-secondary);
        }

        .controls-help kbd {
            background: var(--bg-tertiary);
            padding: 0.125rem 0.375rem;
            border-radius: 3px;
            margin: 0 0.125rem;
        }

        /* Spawn controls */
        .spawn-controls {
            padding: 0.75rem 1rem;
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .spawn-btn {
            padding: 0.375rem 0.75rem;
            font-size: 0.625rem;
            border-radius: 4px;
            border: 1px solid var(--bg-tertiary);
            background: var(--bg-primary);
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s;
        }

        .spawn-btn:hover {
            background: var(--bg-tertiary);
            border-color: var(--accent);
        }

        /* Stars background */
        .stars {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <div class="game-title">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="var(--accent)" stroke-width="2">
                    <polygon points="12,2 22,20 2,20"/>
                </svg>
                <h1>ECS Game Engine</h1>
            </div>
            <div class="game-stats">
                <div class="stat">
                    <span class="stat-label">Entities:</span>
                    <span class="stat-value" id="entityCount">0</span>
                </div>
                <div class="stat">
                    <span class="stat-label">FPS:</span>
                    <span class="stat-value" id="fpsCounter">60</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Frame:</span>
                    <span class="stat-value" id="frameTime">0.0ms</span>
                </div>
            </div>
        </div>

        <div class="canvas-wrapper">
            <canvas id="gameCanvas"></canvas>
            <div class="game-hud">
                <div class="hud-item hud-score">SCORE: <span id="score">0</span></div>
                <div class="hud-item hud-lives">LIVES: <span id="lives">3</span></div>
                <div class="hud-item hud-wave">WAVE: <span id="wave">1</span></div>
            </div>
            <div class="game-over" id="gameOver">
                <h2>GAME OVER</h2>
                <p>Final Score: <span id="finalScore">0</span></p>
                <button class="btn btn-primary" onclick="restartGame()">PLAY AGAIN</button>
            </div>
        </div>
    </div>

    <div class="inspector">
        <div class="inspector-header">
            <span>ECS Inspector</span>
            <button class="inspector-toggle" onclick="toggleInspector()">Ã—</button>
        </div>

        <div class="inspector-section">
            <div class="section-header">
                <span>System Timings</span>
                <span id="totalTime">0.0ms</span>
            </div>
            <div class="system-timings" id="systemTimings"></div>
        </div>

        <div class="inspector-section">
            <div class="section-header">
                <span>Entities</span>
                <span id="entityListCount">0</span>
            </div>
            <div class="entity-list" id="entityList"></div>
        </div>

        <div class="inspector-section" style="flex:1;display:flex;flex-direction:column;">
            <div class="section-header">
                <span>Components</span>
                <span id="selectedEntity">None</span>
            </div>
            <div class="component-inspector" id="componentInspector">
                <p style="color:var(--text-secondary);padding:1rem;text-align:center;">
                    Select an entity to inspect
                </p>
            </div>
        </div>

        <div class="spawn-controls">
            <button class="spawn-btn" onclick="spawn100Asteroids()">+100 Asteroids</button>
            <button class="spawn-btn" onclick="spawn100Enemies()">+100 Enemies</button>
            <button class="spawn-btn" onclick="spawn1000Entities()">+1000 Mixed</button>
            <button class="spawn-btn" onclick="clearNonPlayer()">Clear All</button>
        </div>

        <div class="controls-help">
            <kbd>WASD</kbd> or <kbd>Arrows</kbd> Move
            <kbd>Space</kbd> Shoot
            <kbd>P</kbd> Pause
        </div>
    </div>

    <script>
        // ============================================
        // ECS CORE
        // ============================================

        // Entity is just an ID
        let nextEntityId = 0;
        function createEntityId() {
            return nextEntityId++;
        }

        // Component storage - Sparse sets for performance
        class ComponentStorage {
            constructor() {
                this.dense = [];      // Actual component data
                this.sparse = [];     // Entity ID -> dense index
                this.entities = [];   // Dense index -> entity ID
            }

            has(entityId) {
                return this.sparse[entityId] !== undefined &&
                       this.entities[this.sparse[entityId]] === entityId;
            }

            get(entityId) {
                if (!this.has(entityId)) return undefined;
                return this.dense[this.sparse[entityId]];
            }

            set(entityId, component) {
                if (this.has(entityId)) {
                    this.dense[this.sparse[entityId]] = component;
                } else {
                    const index = this.dense.length;
                    this.dense.push(component);
                    this.entities.push(entityId);
                    this.sparse[entityId] = index;
                }
            }

            remove(entityId) {
                if (!this.has(entityId)) return;

                const index = this.sparse[entityId];
                const lastIndex = this.dense.length - 1;
                const lastEntity = this.entities[lastIndex];

                // Swap with last element
                this.dense[index] = this.dense[lastIndex];
                this.entities[index] = lastEntity;
                this.sparse[lastEntity] = index;

                // Remove last element
                this.dense.pop();
                this.entities.pop();
                delete this.sparse[entityId];
            }

            *[Symbol.iterator]() {
                for (let i = 0; i < this.dense.length; i++) {
                    yield [this.entities[i], this.dense[i]];
                }
            }

            get count() {
                return this.dense.length;
            }
        }

        // World manages all entities and components
        class World {
            constructor() {
                this.entities = new Set();
                this.components = new Map();
                this.systems = [];
                this.toDestroy = [];
                this.systemTimings = new Map();
            }

            createEntity() {
                const id = createEntityId();
                this.entities.add(id);
                return id;
            }

            destroyEntity(entityId) {
                this.toDestroy.push(entityId);
            }

            _destroyEntity(entityId) {
                for (const storage of this.components.values()) {
                    storage.remove(entityId);
                }
                this.entities.delete(entityId);
            }

            addComponent(entityId, componentType, data) {
                if (!this.components.has(componentType)) {
                    this.components.set(componentType, new ComponentStorage());
                }
                this.components.get(componentType).set(entityId, data);
            }

            getComponent(entityId, componentType) {
                const storage = this.components.get(componentType);
                return storage ? storage.get(entityId) : undefined;
            }

            hasComponent(entityId, componentType) {
                const storage = this.components.get(componentType);
                return storage ? storage.has(entityId) : false;
            }

            removeComponent(entityId, componentType) {
                const storage = this.components.get(componentType);
                if (storage) storage.remove(entityId);
            }

            // Query entities with specific components
            query(...componentTypes) {
                const results = [];
                const storages = componentTypes.map(t => this.components.get(t));

                if (storages.some(s => !s)) return results;

                // Use smallest storage for iteration
                let smallest = storages[0];
                for (const storage of storages) {
                    if (storage.count < smallest.count) smallest = storage;
                }

                for (const [entityId] of smallest) {
                    if (componentTypes.every(t => this.hasComponent(entityId, t))) {
                        results.push(entityId);
                    }
                }

                return results;
            }

            addSystem(system) {
                this.systems.push(system);
                this.systemTimings.set(system.name, 0);
            }

            update(deltaTime) {
                // Run all systems
                for (const system of this.systems) {
                    const start = performance.now();
                    system.update(this, deltaTime);
                    this.systemTimings.set(system.name, performance.now() - start);
                }

                // Process deferred destruction
                for (const entityId of this.toDestroy) {
                    this._destroyEntity(entityId);
                }
                this.toDestroy = [];
            }

            get entityCount() {
                return this.entities.size;
            }
        }

        // ============================================
        // COMPONENTS (Pure Data)
        // ============================================

        const Components = {
            Transform: 'Transform',
            Velocity: 'Velocity',
            Sprite: 'Sprite',
            Collider: 'Collider',
            Health: 'Health',
            Player: 'Player',
            Enemy: 'Enemy',
            Asteroid: 'Asteroid',
            Bullet: 'Bullet',
            AI: 'AI',
            Lifetime: 'Lifetime',
            Tag: 'Tag'
        };

        function createTransform(x = 0, y = 0, rotation = 0, scale = 1) {
            return { x, y, rotation, scale };
        }

        function createVelocity(vx = 0, vy = 0, angularVel = 0, drag = 0) {
            return { vx, vy, angularVel, drag };
        }

        function createSprite(shape = 'circle', color = '#ffffff', size = 10, layer = 0) {
            return { shape, color, size, layer, visible: true };
        }

        function createCollider(radius = 10, group = 'default', mask = ['default']) {
            return { radius, group, mask, active: true };
        }

        function createHealth(max = 100, invulnerableTime = 0) {
            return { current: max, max, invulnerable: 0, invulnerableTime };
        }

        function createAI(type = 'chase', target = null, fireRate = 1, lastFire = 0) {
            return { type, target, fireRate, lastFire, state: 'idle' };
        }

        function createLifetime(duration) {
            return { remaining: duration, initial: duration };
        }

        // ============================================
        // SYSTEMS
        // ============================================

        // Movement System
        const MovementSystem = {
            name: 'Movement',
            update(world, dt) {
                const entities = world.query(Components.Transform, Components.Velocity);

                for (const entityId of entities) {
                    const transform = world.getComponent(entityId, Components.Transform);
                    const velocity = world.getComponent(entityId, Components.Velocity);

                    // Apply velocity
                    transform.x += velocity.vx * dt;
                    transform.y += velocity.vy * dt;
                    transform.rotation += velocity.angularVel * dt;

                    // Apply drag
                    if (velocity.drag > 0) {
                        const factor = Math.pow(1 - velocity.drag, dt);
                        velocity.vx *= factor;
                        velocity.vy *= factor;
                    }

                    // Screen wrapping
                    const margin = 50;
                    if (transform.x < -margin) transform.x = canvas.width + margin;
                    if (transform.x > canvas.width + margin) transform.x = -margin;
                    if (transform.y < -margin) transform.y = canvas.height + margin;
                    if (transform.y > canvas.height + margin) transform.y = -margin;
                }
            }
        };

        // Rendering System
        const RenderingSystem = {
            name: 'Rendering',
            update(world, dt) {
                // Sort by layer
                const entities = world.query(Components.Transform, Components.Sprite);
                const sorted = entities.map(id => ({
                    id,
                    transform: world.getComponent(id, Components.Transform),
                    sprite: world.getComponent(id, Components.Sprite)
                })).sort((a, b) => a.sprite.layer - b.sprite.layer);

                for (const { id, transform, sprite } of sorted) {
                    if (!sprite.visible) continue;

                    ctx.save();
                    ctx.translate(transform.x, transform.y);
                    ctx.rotate(transform.rotation);
                    ctx.scale(transform.scale, transform.scale);

                    // Check for invulnerability flicker
                    const health = world.getComponent(id, Components.Health);
                    if (health && health.invulnerable > 0) {
                        if (Math.floor(health.invulnerable * 10) % 2 === 0) {
                            ctx.globalAlpha = 0.3;
                        }
                    }

                    ctx.fillStyle = sprite.color;
                    ctx.strokeStyle = sprite.color;
                    ctx.lineWidth = 2;

                    switch (sprite.shape) {
                        case 'triangle':
                            ctx.beginPath();
                            ctx.moveTo(0, -sprite.size);
                            ctx.lineTo(-sprite.size * 0.7, sprite.size * 0.7);
                            ctx.lineTo(sprite.size * 0.7, sprite.size * 0.7);
                            ctx.closePath();
                            ctx.stroke();
                            break;

                        case 'circle':
                            ctx.beginPath();
                            ctx.arc(0, 0, sprite.size, 0, Math.PI * 2);
                            ctx.stroke();
                            break;

                        case 'asteroid':
                            ctx.beginPath();
                            const points = 8;
                            for (let i = 0; i < points; i++) {
                                const angle = (i / points) * Math.PI * 2;
                                const variance = 0.7 + Math.sin(id * 1000 + i * 1.5) * 0.3;
                                const r = sprite.size * variance;
                                if (i === 0) ctx.moveTo(Math.cos(angle) * r, Math.sin(angle) * r);
                                else ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
                            }
                            ctx.closePath();
                            ctx.stroke();
                            break;

                        case 'enemy':
                            ctx.beginPath();
                            ctx.moveTo(0, -sprite.size);
                            ctx.lineTo(-sprite.size, sprite.size);
                            ctx.lineTo(0, sprite.size * 0.5);
                            ctx.lineTo(sprite.size, sprite.size);
                            ctx.closePath();
                            ctx.stroke();
                            break;

                        case 'bullet':
                            ctx.beginPath();
                            ctx.arc(0, 0, sprite.size, 0, Math.PI * 2);
                            ctx.fill();
                            break;

                        default:
                            ctx.fillRect(-sprite.size/2, -sprite.size/2, sprite.size, sprite.size);
                    }

                    ctx.restore();
                }
            }
        };

        // Collision System
        const CollisionSystem = {
            name: 'Collision',
            collisions: [],

            update(world, dt) {
                this.collisions = [];
                const entities = world.query(Components.Transform, Components.Collider);

                // Spatial hash for broad phase
                const cellSize = 100;
                const grid = new Map();

                for (const entityId of entities) {
                    const transform = world.getComponent(entityId, Components.Transform);
                    const collider = world.getComponent(entityId, Components.Collider);
                    if (!collider.active) continue;

                    const cellX = Math.floor(transform.x / cellSize);
                    const cellY = Math.floor(transform.y / cellSize);

                    // Check neighboring cells
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            const key = `${cellX + dx},${cellY + dy}`;
                            if (!grid.has(key)) grid.set(key, []);

                            // Check collisions with entities in this cell
                            for (const otherId of grid.get(key)) {
                                if (otherId === entityId) continue;

                                const otherTransform = world.getComponent(otherId, Components.Transform);
                                const otherCollider = world.getComponent(otherId, Components.Collider);

                                // Check masks
                                if (!collider.mask.includes(otherCollider.group) &&
                                    !otherCollider.mask.includes(collider.group)) continue;

                                // Circle collision
                                const dx2 = transform.x - otherTransform.x;
                                const dy2 = transform.y - otherTransform.y;
                                const dist = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                                const minDist = (collider.radius + otherCollider.radius) *
                                               transform.scale * otherTransform.scale;

                                if (dist < minDist) {
                                    this.collisions.push({
                                        entityA: entityId,
                                        entityB: otherId,
                                        overlap: minDist - dist
                                    });
                                }
                            }
                        }
                    }

                    // Add to grid
                    const key = `${cellX},${cellY}`;
                    if (!grid.has(key)) grid.set(key, []);
                    grid.get(key).push(entityId);
                }
            }
        };

        // Damage System
        const DamageSystem = {
            name: 'Damage',
            update(world, dt) {
                // Process collisions from collision system
                for (const collision of CollisionSystem.collisions) {
                    const { entityA, entityB } = collision;

                    // Player bullet hits enemy/asteroid
                    if (world.hasComponent(entityA, Components.Bullet) &&
                        world.getComponent(entityA, Components.Bullet).owner === 'player') {
                        if (world.hasComponent(entityB, Components.Enemy)) {
                            this.damageEntity(world, entityB, 50);
                            world.destroyEntity(entityA);
                            gameState.score += 100;
                        } else if (world.hasComponent(entityB, Components.Asteroid)) {
                            this.splitAsteroid(world, entityB);
                            world.destroyEntity(entityA);
                            gameState.score += 25;
                        }
                    }

                    // Same check for entityB being the bullet
                    if (world.hasComponent(entityB, Components.Bullet) &&
                        world.getComponent(entityB, Components.Bullet).owner === 'player') {
                        if (world.hasComponent(entityA, Components.Enemy)) {
                            this.damageEntity(world, entityA, 50);
                            world.destroyEntity(entityB);
                            gameState.score += 100;
                        } else if (world.hasComponent(entityA, Components.Asteroid)) {
                            this.splitAsteroid(world, entityA);
                            world.destroyEntity(entityB);
                            gameState.score += 25;
                        }
                    }

                    // Enemy bullet hits player
                    if (world.hasComponent(entityA, Components.Player) &&
                        world.hasComponent(entityB, Components.Bullet) &&
                        world.getComponent(entityB, Components.Bullet).owner === 'enemy') {
                        this.damagePlayer(world, entityA);
                        world.destroyEntity(entityB);
                    }
                    if (world.hasComponent(entityB, Components.Player) &&
                        world.hasComponent(entityA, Components.Bullet) &&
                        world.getComponent(entityA, Components.Bullet).owner === 'enemy') {
                        this.damagePlayer(world, entityB);
                        world.destroyEntity(entityA);
                    }

                    // Player hits asteroid/enemy
                    if (world.hasComponent(entityA, Components.Player)) {
                        if (world.hasComponent(entityB, Components.Asteroid) ||
                            world.hasComponent(entityB, Components.Enemy)) {
                            this.damagePlayer(world, entityA);
                        }
                    }
                    if (world.hasComponent(entityB, Components.Player)) {
                        if (world.hasComponent(entityA, Components.Asteroid) ||
                            world.hasComponent(entityA, Components.Enemy)) {
                            this.damagePlayer(world, entityB);
                        }
                    }
                }

                // Update invulnerability timers
                for (const entityId of world.query(Components.Health)) {
                    const health = world.getComponent(entityId, Components.Health);
                    if (health.invulnerable > 0) {
                        health.invulnerable -= dt;
                    }
                }
            },

            damageEntity(world, entityId, damage) {
                const health = world.getComponent(entityId, Components.Health);
                if (!health || health.invulnerable > 0) return;

                health.current -= damage;
                if (health.current <= 0) {
                    world.destroyEntity(entityId);
                    spawnExplosion(world, world.getComponent(entityId, Components.Transform));
                }
            },

            damagePlayer(world, entityId) {
                const health = world.getComponent(entityId, Components.Health);
                if (!health || health.invulnerable > 0) return;

                health.current -= 1;
                health.invulnerable = health.invulnerableTime;
                gameState.lives--;

                if (gameState.lives <= 0) {
                    gameState.gameOver = true;
                }
            },

            splitAsteroid(world, entityId) {
                const transform = world.getComponent(entityId, Components.Transform);
                const sprite = world.getComponent(entityId, Components.Sprite);

                // Spawn explosion
                spawnExplosion(world, transform);

                // Split into smaller asteroids if big enough
                if (sprite.size > 15) {
                    for (let i = 0; i < 2; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const speed = 50 + Math.random() * 100;
                        spawnAsteroid(world,
                            transform.x + Math.cos(angle) * 20,
                            transform.y + Math.sin(angle) * 20,
                            sprite.size * 0.5
                        );
                    }
                }

                world.destroyEntity(entityId);
            }
        };

        // AI System
        const AISystem = {
            name: 'AI',
            update(world, dt) {
                const player = world.query(Components.Player)[0];
                if (!player) return;

                const playerTransform = world.getComponent(player, Components.Transform);

                for (const entityId of world.query(Components.AI, Components.Transform, Components.Velocity)) {
                    const ai = world.getComponent(entityId, Components.AI);
                    const transform = world.getComponent(entityId, Components.Transform);
                    const velocity = world.getComponent(entityId, Components.Velocity);

                    switch (ai.type) {
                        case 'chase':
                            // Move towards player
                            const dx = playerTransform.x - transform.x;
                            const dy = playerTransform.y - transform.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            if (dist > 0) {
                                const speed = 80;
                                velocity.vx += (dx / dist) * speed * dt;
                                velocity.vy += (dy / dist) * speed * dt;

                                // Limit speed
                                const maxSpeed = 150;
                                const currentSpeed = Math.sqrt(velocity.vx ** 2 + velocity.vy ** 2);
                                if (currentSpeed > maxSpeed) {
                                    velocity.vx = (velocity.vx / currentSpeed) * maxSpeed;
                                    velocity.vy = (velocity.vy / currentSpeed) * maxSpeed;
                                }

                                // Face player
                                transform.rotation = Math.atan2(dy, dx) + Math.PI / 2;
                            }

                            // Shoot at player
                            ai.lastFire += dt;
                            if (ai.lastFire > ai.fireRate && dist < 400) {
                                ai.lastFire = 0;
                                spawnBullet(world, transform.x, transform.y,
                                    transform.rotation - Math.PI / 2, 'enemy');
                            }
                            break;

                        case 'wander':
                            // Random movement
                            if (Math.random() < dt * 0.5) {
                                velocity.vx += (Math.random() - 0.5) * 100;
                                velocity.vy += (Math.random() - 0.5) * 100;
                            }
                            break;
                    }
                }
            }
        };

        // Lifetime System
        const LifetimeSystem = {
            name: 'Lifetime',
            update(world, dt) {
                for (const entityId of world.query(Components.Lifetime)) {
                    const lifetime = world.getComponent(entityId, Components.Lifetime);
                    lifetime.remaining -= dt;

                    if (lifetime.remaining <= 0) {
                        world.destroyEntity(entityId);
                    }

                    // Fade out sprites
                    const sprite = world.getComponent(entityId, Components.Sprite);
                    if (sprite) {
                        const alpha = Math.max(0, lifetime.remaining / lifetime.initial);
                        const color = sprite.color;
                        if (color.startsWith('#')) {
                            // Keep color but we'd need rgba for actual fade
                        }
                    }
                }
            }
        };

        // Player Input System
        const PlayerInputSystem = {
            name: 'PlayerInput',
            update(world, dt) {
                const player = world.query(Components.Player)[0];
                if (!player || gameState.gameOver || gameState.paused) return;

                const transform = world.getComponent(player, Components.Transform);
                const velocity = world.getComponent(player, Components.Velocity);
                const playerComp = world.getComponent(player, Components.Player);

                const thrust = 400;
                const rotSpeed = 4;

                // Rotation
                if (keys['ArrowLeft'] || keys['KeyA']) {
                    transform.rotation -= rotSpeed * dt;
                }
                if (keys['ArrowRight'] || keys['KeyD']) {
                    transform.rotation += rotSpeed * dt;
                }

                // Thrust
                if (keys['ArrowUp'] || keys['KeyW']) {
                    velocity.vx += Math.sin(transform.rotation) * thrust * dt;
                    velocity.vy -= Math.cos(transform.rotation) * thrust * dt;
                }
                if (keys['ArrowDown'] || keys['KeyS']) {
                    velocity.vx -= Math.sin(transform.rotation) * thrust * dt * 0.5;
                    velocity.vy += Math.cos(transform.rotation) * thrust * dt * 0.5;
                }

                // Shooting
                playerComp.fireCooldown -= dt;
                if (keys['Space'] && playerComp.fireCooldown <= 0) {
                    playerComp.fireCooldown = 0.15;
                    spawnBullet(world,
                        transform.x + Math.sin(transform.rotation) * 20,
                        transform.y - Math.cos(transform.rotation) * 20,
                        transform.rotation, 'player');
                }

                // Speed limit
                const maxSpeed = 300;
                const speed = Math.sqrt(velocity.vx ** 2 + velocity.vy ** 2);
                if (speed > maxSpeed) {
                    velocity.vx = (velocity.vx / speed) * maxSpeed;
                    velocity.vy = (velocity.vy / speed) * maxSpeed;
                }
            }
        };

        // Wave System
        const WaveSystem = {
            name: 'Wave',
            waveTimer: 0,

            update(world, dt) {
                if (gameState.gameOver || gameState.paused) return;

                // Count enemies and asteroids
                const enemies = world.query(Components.Enemy).length;
                const asteroids = world.query(Components.Asteroid).length;

                if (enemies === 0 && asteroids === 0) {
                    this.waveTimer += dt;
                    if (this.waveTimer > 2) {
                        this.waveTimer = 0;
                        gameState.wave++;
                        this.spawnWave(world);
                    }
                }
            },

            spawnWave(world) {
                const numAsteroids = 5 + gameState.wave * 2;
                const numEnemies = Math.floor(gameState.wave / 2);

                for (let i = 0; i < numAsteroids; i++) {
                    const edge = Math.floor(Math.random() * 4);
                    let x, y;
                    switch (edge) {
                        case 0: x = Math.random() * canvas.width; y = -50; break;
                        case 1: x = canvas.width + 50; y = Math.random() * canvas.height; break;
                        case 2: x = Math.random() * canvas.width; y = canvas.height + 50; break;
                        case 3: x = -50; y = Math.random() * canvas.height; break;
                    }
                    spawnAsteroid(world, x, y, 30 + Math.random() * 20);
                }

                for (let i = 0; i < numEnemies; i++) {
                    const edge = Math.floor(Math.random() * 4);
                    let x, y;
                    switch (edge) {
                        case 0: x = Math.random() * canvas.width; y = -50; break;
                        case 1: x = canvas.width + 50; y = Math.random() * canvas.height; break;
                        case 2: x = Math.random() * canvas.width; y = canvas.height + 50; break;
                        case 3: x = -50; y = Math.random() * canvas.height; break;
                    }
                    spawnEnemy(world, x, y);
                }
            }
        };

        // ============================================
        // ENTITY SPAWNERS
        // ============================================

        function spawnPlayer(world) {
            const entity = world.createEntity();
            world.addComponent(entity, Components.Transform,
                createTransform(canvas.width / 2, canvas.height / 2, 0, 1));
            world.addComponent(entity, Components.Velocity,
                createVelocity(0, 0, 0, 0.5));
            world.addComponent(entity, Components.Sprite,
                createSprite('triangle', '#00ffcc', 15, 10));
            world.addComponent(entity, Components.Collider,
                createCollider(15, 'player', ['enemy', 'asteroid', 'enemyBullet']));
            world.addComponent(entity, Components.Health,
                createHealth(3, 2));
            world.addComponent(entity, Components.Player, { fireCooldown: 0 });
            world.addComponent(entity, Components.Tag, { tags: ['player'] });
            return entity;
        }

        function spawnAsteroid(world, x, y, size = 30) {
            const entity = world.createEntity();
            const angle = Math.random() * Math.PI * 2;
            const speed = 30 + Math.random() * 70;

            world.addComponent(entity, Components.Transform,
                createTransform(x, y, Math.random() * Math.PI * 2, 1));
            world.addComponent(entity, Components.Velocity,
                createVelocity(Math.cos(angle) * speed, Math.sin(angle) * speed,
                    (Math.random() - 0.5) * 2, 0));
            world.addComponent(entity, Components.Sprite,
                createSprite('asteroid', '#888899', size, 1));
            world.addComponent(entity, Components.Collider,
                createCollider(size, 'asteroid', ['player', 'playerBullet']));
            world.addComponent(entity, Components.Asteroid, { size });
            world.addComponent(entity, Components.Tag, { tags: ['asteroid'] });
            return entity;
        }

        function spawnEnemy(world, x, y) {
            const entity = world.createEntity();

            world.addComponent(entity, Components.Transform,
                createTransform(x, y, Math.random() * Math.PI * 2, 1));
            world.addComponent(entity, Components.Velocity,
                createVelocity(0, 0, 0, 0.8));
            world.addComponent(entity, Components.Sprite,
                createSprite('enemy', '#ff4466', 12, 5));
            world.addComponent(entity, Components.Collider,
                createCollider(12, 'enemy', ['player', 'playerBullet']));
            world.addComponent(entity, Components.Health,
                createHealth(50, 0));
            world.addComponent(entity, Components.AI,
                createAI('chase', null, 1.5 + Math.random(), 0));
            world.addComponent(entity, Components.Enemy, {});
            world.addComponent(entity, Components.Tag, { tags: ['enemy'] });
            return entity;
        }

        function spawnBullet(world, x, y, angle, owner) {
            const entity = world.createEntity();
            const speed = owner === 'player' ? 500 : 300;

            world.addComponent(entity, Components.Transform,
                createTransform(x, y, angle, 1));
            world.addComponent(entity, Components.Velocity,
                createVelocity(Math.sin(angle) * speed, -Math.cos(angle) * speed, 0, 0));
            world.addComponent(entity, Components.Sprite,
                createSprite('bullet', owner === 'player' ? '#ffff44' : '#ff6666', 3, 8));
            world.addComponent(entity, Components.Collider,
                createCollider(3, owner === 'player' ? 'playerBullet' : 'enemyBullet',
                    owner === 'player' ? ['enemy', 'asteroid'] : ['player']));
            world.addComponent(entity, Components.Bullet, { owner });
            world.addComponent(entity, Components.Lifetime, createLifetime(2));
            world.addComponent(entity, Components.Tag, { tags: ['bullet', owner] });
            return entity;
        }

        function spawnExplosion(world, transform) {
            // Spawn particles
            for (let i = 0; i < 8; i++) {
                const entity = world.createEntity();
                const angle = (i / 8) * Math.PI * 2;
                const speed = 50 + Math.random() * 100;

                world.addComponent(entity, Components.Transform,
                    createTransform(transform.x, transform.y, angle, 1));
                world.addComponent(entity, Components.Velocity,
                    createVelocity(Math.cos(angle) * speed, Math.sin(angle) * speed, 0, 2));
                world.addComponent(entity, Components.Sprite,
                    createSprite('bullet', '#ffaa44', 2 + Math.random() * 3, 9));
                world.addComponent(entity, Components.Lifetime,
                    createLifetime(0.3 + Math.random() * 0.3));
            }
        }

        // ============================================
        // GAME STATE & INITIALIZATION
        // ============================================

        let canvas, ctx;
        let world;
        let gameState = {
            score: 0,
            lives: 3,
            wave: 1,
            gameOver: false,
            paused: false
        };
        let keys = {};
        let selectedEntity = null;
        let lastTime = 0;
        let frameCount = 0;
        let fpsTime = 0;
        let currentFps = 60;

        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');

            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Input handling
            window.addEventListener('keydown', (e) => {
                keys[e.code] = true;
                if (e.code === 'KeyP') {
                    gameState.paused = !gameState.paused;
                }
                if (e.code === 'Space') {
                    e.preventDefault();
                }
            });
            window.addEventListener('keyup', (e) => {
                keys[e.code] = false;
            });

            setupWorld();
            requestAnimationFrame(gameLoop);
        }

        function resizeCanvas() {
            const wrapper = canvas.parentElement;
            canvas.width = wrapper.clientWidth;
            canvas.height = wrapper.clientHeight;
        }

        function setupWorld() {
            world = new World();

            // Add systems in order
            world.addSystem(PlayerInputSystem);
            world.addSystem(AISystem);
            world.addSystem(MovementSystem);
            world.addSystem(CollisionSystem);
            world.addSystem(DamageSystem);
            world.addSystem(LifetimeSystem);
            world.addSystem(WaveSystem);
            world.addSystem(RenderingSystem);

            // Spawn player
            spawnPlayer(world);

            // Initial wave
            WaveSystem.spawnWave(world);
        }

        function gameLoop(timestamp) {
            const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
            lastTime = timestamp;

            // FPS counter
            frameCount++;
            fpsTime += dt;
            if (fpsTime >= 1) {
                currentFps = frameCount;
                frameCount = 0;
                fpsTime = 0;
            }

            // Clear canvas
            ctx.fillStyle = '#000008';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw stars background
            drawStars();

            if (!gameState.paused) {
                // Update world
                world.update(dt);
            }

            // Update UI
            updateUI();
            updateInspector();

            requestAnimationFrame(gameLoop);
        }

        const stars = [];
        for (let i = 0; i < 100; i++) {
            stars.push({
                x: Math.random(),
                y: Math.random(),
                size: Math.random() * 1.5,
                alpha: 0.3 + Math.random() * 0.7
            });
        }

        function drawStars() {
            for (const star of stars) {
                ctx.fillStyle = `rgba(255, 255, 255, ${star.alpha})`;
                ctx.beginPath();
                ctx.arc(star.x * canvas.width, star.y * canvas.height, star.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function updateUI() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('lives').textContent = gameState.lives;
            document.getElementById('wave').textContent = gameState.wave;
            document.getElementById('entityCount').textContent = world.entityCount;

            const fpsEl = document.getElementById('fpsCounter');
            fpsEl.textContent = currentFps;
            fpsEl.className = 'stat-value ' + (currentFps >= 55 ? 'good' : currentFps >= 30 ? 'warn' : 'bad');

            const totalTime = Array.from(world.systemTimings.values()).reduce((a, b) => a + b, 0);
            document.getElementById('frameTime').textContent = totalTime.toFixed(2) + 'ms';

            // Game over screen
            const gameOverEl = document.getElementById('gameOver');
            if (gameState.gameOver) {
                gameOverEl.classList.add('active');
                document.getElementById('finalScore').textContent = gameState.score;
            } else {
                gameOverEl.classList.remove('active');
            }
        }

        function updateInspector() {
            // System timings
            const timingsEl = document.getElementById('systemTimings');
            let timingsHtml = '';
            const maxTime = 16.67; // Target 60fps

            for (const [name, time] of world.systemTimings) {
                const percent = Math.min(100, (time / maxTime) * 100);
                timingsHtml += `
                    <div class="timing-row">
                        <span class="timing-name">${name}</span>
                        <span>${time.toFixed(2)}ms</span>
                        <div class="timing-bar">
                            <div class="timing-fill" style="width:${percent}%;background:${percent > 80 ? 'var(--danger)' : percent > 50 ? 'var(--warning)' : 'var(--accent)'}"></div>
                        </div>
                    </div>
                `;
            }
            timingsEl.innerHTML = timingsHtml;

            const totalTime = Array.from(world.systemTimings.values()).reduce((a, b) => a + b, 0);
            document.getElementById('totalTime').textContent = totalTime.toFixed(2) + 'ms';

            // Entity list (show first 50)
            const entityListEl = document.getElementById('entityList');
            const entities = Array.from(world.entities).slice(0, 50);
            document.getElementById('entityListCount').textContent =
                `${Math.min(50, world.entityCount)}/${world.entityCount}`;

            let listHtml = '';
            for (const entityId of entities) {
                const tags = world.getComponent(entityId, Components.Tag);
                const tagHtml = tags ? tags.tags.map(t =>
                    `<span class="entity-tag ${t}">${t}</span>`
                ).join('') : '';

                listHtml += `
                    <div class="entity-item ${selectedEntity === entityId ? 'selected' : ''}"
                         onclick="selectEntity(${entityId})">
                        <span class="entity-id">#${entityId}</span>
                        <div class="entity-tags">${tagHtml}</div>
                    </div>
                `;
            }
            entityListEl.innerHTML = listHtml;

            // Component inspector
            if (selectedEntity !== null && world.entities.has(selectedEntity)) {
                updateComponentInspector(selectedEntity);
            }
        }

        function selectEntity(entityId) {
            selectedEntity = entityId;
            document.getElementById('selectedEntity').textContent = `#${entityId}`;
            updateComponentInspector(entityId);
        }

        function updateComponentInspector(entityId) {
            const inspectorEl = document.getElementById('componentInspector');
            let html = '';

            for (const [type, storage] of world.components) {
                if (storage.has(entityId)) {
                    const component = storage.get(entityId);
                    html += `
                        <div class="component-card">
                            <div class="component-header">${type}</div>
                            <div class="component-props">
                    `;

                    for (const [key, value] of Object.entries(component)) {
                        let displayValue = value;
                        if (typeof value === 'number') {
                            displayValue = Number.isInteger(value) ? value : value.toFixed(2);
                        } else if (typeof value === 'boolean') {
                            displayValue = value ? 'true' : 'false';
                        } else if (Array.isArray(value)) {
                            displayValue = value.join(', ');
                        }

                        html += `
                            <div class="prop-row">
                                <span class="prop-name">${key}</span>
                                <span class="prop-value">${displayValue}</span>
                            </div>
                        `;
                    }

                    html += '</div></div>';
                }
            }

            inspectorEl.innerHTML = html || '<p style="color:var(--text-secondary);padding:1rem;text-align:center;">No components</p>';
        }

        function restartGame() {
            gameState = {
                score: 0,
                lives: 3,
                wave: 1,
                gameOver: false,
                paused: false
            };
            nextEntityId = 0;
            setupWorld();
        }

        function spawn100Asteroids() {
            for (let i = 0; i < 100; i++) {
                spawnAsteroid(world,
                    Math.random() * canvas.width,
                    Math.random() * canvas.height,
                    10 + Math.random() * 30
                );
            }
        }

        function spawn100Enemies() {
            for (let i = 0; i < 100; i++) {
                spawnEnemy(world,
                    Math.random() * canvas.width,
                    Math.random() * canvas.height
                );
            }
        }

        function spawn1000Entities() {
            for (let i = 0; i < 500; i++) {
                spawnAsteroid(world,
                    Math.random() * canvas.width,
                    Math.random() * canvas.height,
                    5 + Math.random() * 20
                );
            }
            for (let i = 0; i < 500; i++) {
                spawnEnemy(world,
                    Math.random() * canvas.width,
                    Math.random() * canvas.height
                );
            }
        }

        function clearNonPlayer() {
            const toRemove = [];
            for (const entityId of world.entities) {
                if (!world.hasComponent(entityId, Components.Player)) {
                    toRemove.push(entityId);
                }
            }
            for (const entityId of toRemove) {
                world.destroyEntity(entityId);
            }
        }

        function toggleInspector() {
            const inspector = document.querySelector('.inspector');
            inspector.style.display = inspector.style.display === 'none' ? 'flex' : 'none';
        }

        // Start game
        init();
    </script>
</body>
</html>