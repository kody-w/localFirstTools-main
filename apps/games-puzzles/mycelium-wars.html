<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mycelium Wars - Fungal Network Strategy</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #1a1410;
            color: #d4c5a9;
            overflow: hidden;
            cursor: default;
        }

        #gameCanvas {
            display: block;
            margin: 0 auto;
            background: #2a1f16;
            cursor: crosshair;
            image-rendering: pixelated;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            pointer-events: none;
        }

        #hud {
            background: rgba(26, 20, 16, 0.95);
            padding: 15px;
            border-bottom: 2px solid #4a3a26;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            pointer-events: all;
        }

        .resource-panel {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .resource {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .resource-label {
            font-size: 10px;
            text-transform: uppercase;
            opacity: 0.7;
            letter-spacing: 1px;
        }

        .resource-value {
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 0 8px currentColor;
        }

        .carbon { color: #8b7355; }
        .nitrogen { color: #6b9b37; }
        .water { color: #4a7c9e; }
        .enzymes { color: #b88846; }

        .info-panel {
            display: flex;
            gap: 15px;
            font-size: 12px;
        }

        .info-item {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .info-label {
            opacity: 0.7;
            font-size: 10px;
        }

        .season {
            color: #d4c5a9;
            font-weight: bold;
        }

        #buildMenu {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(26, 20, 16, 0.95);
            border: 2px solid #4a3a26;
            border-radius: 8px;
            padding: 15px;
            display: none;
            pointer-events: all;
        }

        #buildMenu.active {
            display: block;
        }

        .build-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
        }

        .build-button {
            background: #3a2a16;
            border: 2px solid #5a4a36;
            color: #d4c5a9;
            padding: 12px;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            min-width: 120px;
        }

        .build-button:hover {
            background: #4a3a26;
            border-color: #7a6a56;
            box-shadow: 0 0 15px rgba(212, 197, 169, 0.3);
        }

        .build-button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .build-icon {
            font-size: 24px;
        }

        .build-name {
            font-size: 11px;
            font-weight: bold;
        }

        .build-cost {
            font-size: 9px;
            opacity: 0.8;
        }

        #titleScreen, #gameOver {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #1a1410 0%, #2a1f16 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: all;
        }

        #titleScreen.hidden, #gameOver.hidden {
            display: none;
        }

        h1 {
            font-size: 64px;
            color: #d4c5a9;
            text-shadow: 0 0 20px #8b7355, 0 0 40px #6b9b37;
            margin-bottom: 20px;
            letter-spacing: 4px;
        }

        .subtitle {
            font-size: 18px;
            opacity: 0.8;
            margin-bottom: 40px;
            letter-spacing: 2px;
        }

        button {
            background: #3a2a16;
            border: 2px solid #5a4a36;
            color: #d4c5a9;
            padding: 15px 40px;
            font-size: 16px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            border-radius: 8px;
            margin: 10px;
            transition: all 0.3s;
            pointer-events: all;
        }

        button:hover {
            background: #4a3a26;
            border-color: #7a6a56;
            box-shadow: 0 0 20px rgba(212, 197, 169, 0.4);
            transform: scale(1.05);
        }

        .instructions {
            max-width: 600px;
            margin: 30px;
            padding: 20px;
            background: rgba(26, 20, 16, 0.8);
            border: 1px solid #4a3a26;
            border-radius: 8px;
            font-size: 13px;
            line-height: 1.6;
        }

        .instructions h3 {
            color: #b88846;
            margin-bottom: 10px;
        }

        .instructions ul {
            margin-left: 20px;
            margin-top: 10px;
        }

        .instructions li {
            margin: 5px 0;
        }

        #pauseOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 50;
            pointer-events: all;
        }

        #pauseOverlay.active {
            display: flex;
        }

        .pause-menu {
            background: #2a1f16;
            border: 3px solid #4a3a26;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
        }

        .ending-text {
            max-width: 700px;
            padding: 30px;
            background: rgba(26, 20, 16, 0.9);
            border: 2px solid #4a3a26;
            border-radius: 12px;
            margin: 20px;
        }

        .ending-title {
            font-size: 36px;
            color: #b88846;
            margin-bottom: 20px;
            text-shadow: 0 0 15px currentColor;
        }

        .ending-description {
            font-size: 16px;
            line-height: 1.8;
            margin-bottom: 30px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 20px;
            font-size: 14px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            background: rgba(58, 42, 22, 0.5);
            border-radius: 4px;
        }

        .glow {
            animation: glow 2s ease-in-out infinite;
        }

        @keyframes glow {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }

        .tooltip {
            position: absolute;
            background: rgba(26, 20, 16, 0.98);
            border: 2px solid #4a3a26;
            border-radius: 6px;
            padding: 10px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            display: none;
            max-width: 250px;
        }

        .tooltip.active {
            display: block;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="ui">
        <div id="hud">
            <div class="resource-panel">
                <div class="resource carbon">
                    <div class="resource-label">Carbon</div>
                    <div class="resource-value" id="carbonValue">100</div>
                </div>
                <div class="resource nitrogen">
                    <div class="resource-label">Nitrogen</div>
                    <div class="resource-value" id="nitrogenValue">50</div>
                </div>
                <div class="resource water">
                    <div class="resource-label">Water</div>
                    <div class="resource-value" id="waterValue">75</div>
                </div>
                <div class="resource enzymes">
                    <div class="resource-label">Enzymes</div>
                    <div class="resource-value" id="enzymeValue">25</div>
                </div>
            </div>
            <div class="info-panel">
                <div class="info-item">
                    <div class="info-label">Season</div>
                    <div class="season" id="seasonValue">Spring</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Territory</div>
                    <div id="territoryValue">5%</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Networks</div>
                    <div id="networkValue">4</div>
                </div>
            </div>
        </div>

        <div id="buildMenu">
            <div class="build-grid">
                <button class="build-button" data-structure="fruiting">
                    <div class="build-icon">üçÑ</div>
                    <div class="build-name">Fruiting Body</div>
                    <div class="build-cost">C:30 N:20 E:15</div>
                </button>
                <button class="build-button" data-structure="mycorrhizal">
                    <div class="build-icon">üå≥</div>
                    <div class="build-name">Mycorrhizal Link</div>
                    <div class="build-cost">C:40 N:10 W:20</div>
                </button>
                <button class="build-button" data-structure="digestive">
                    <div class="build-icon">üíß</div>
                    <div class="build-name">Digestive Mat</div>
                    <div class="build-cost">C:25 E:30</div>
                </button>
                <button class="build-button" data-structure="cannon">
                    <div class="build-icon">üí•</div>
                    <div class="build-name">Spore Cannon</div>
                    <div class="build-cost">C:50 N:30 E:25</div>
                </button>
            </div>
        </div>
    </div>

    <div id="titleScreen">
        <h1>MYCELIUM WARS</h1>
        <div class="subtitle">Fungal Network Real-Time Strategy</div>
        <button id="startButton">Begin Growth</button>
        <button id="loadButton">Continue Network</button>
        <div class="instructions">
            <h3>How to Dominate the Underground</h3>
            <ul>
                <li><strong>Left Click:</strong> Extend hyphae and grow your network</li>
                <li><strong>Right Click:</strong> Open build menu for structures</li>
                <li><strong>Resources:</strong> Connect to nutrient sources (trees, compost, minerals)</li>
                <li><strong>Structures:</strong> Build fruiting bodies, mycorrhizal links, digestive mats, and spore cannons</li>
                <li><strong>Strategy:</strong> Form symbiotic alliances or wage chemical warfare</li>
                <li><strong>Victory:</strong> Achieve one of four endings through domination, symbiosis, expansion, or mass fruiting</li>
            </ul>
        </div>
    </div>

    <div id="gameOver" class="hidden">
        <div class="ending-text" id="endingText"></div>
        <div class="stats" id="endingStats"></div>
        <button id="restartButton">Germinate Again</button>
        <button id="menuButton">Return to Surface</button>
    </div>

    <div id="pauseOverlay">
        <div class="pause-menu">
            <h2>Network Dormant</h2>
            <button id="resumeButton">Resume Growth</button>
            <button id="saveButton">Save Network</button>
            <button id="quitButton">Abandon Colony</button>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        // ============================================
        // AUDIO SYSTEM
        // ============================================
        class AudioSystem {
            constructor() {
                this.ctx = null;
                this.masterGain = null;
                this.enabled = false;
                this.sounds = {};
            }

            init() {
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.ctx.createGain();
                    this.masterGain.gain.value = 0.3;
                    this.masterGain.connect(this.ctx.destination);
                    this.enabled = true;
                    this.startAmbience();
                } catch (e) {
                    console.warn('Audio not available');
                }
            }

            playGrowth() {
                if (!this.enabled) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.frequency.value = 80 + Math.random() * 40;
                osc.type = 'sine';
                gain.gain.setValueAtTime(0.05, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.1);
            }

            playBuild() {
                if (!this.enabled) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.frequency.value = 200;
                osc.type = 'square';
                gain.gain.setValueAtTime(0.08, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.15);
            }

            playSpore() {
                if (!this.enabled) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.frequency.value = 400;
                osc.type = 'sawtooth';
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.2);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.2);
            }

            startAmbience() {
                if (!this.enabled || this.ambienceNode) return;

                const createLayer = (freq, gainVal) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    const filter = this.ctx.createBiquadFilter();

                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    filter.type = 'lowpass';
                    filter.frequency.value = 200;
                    gain.gain.value = gainVal;

                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.masterGain);

                    osc.start();
                    return { osc, gain, filter };
                };

                this.ambienceNode = [
                    createLayer(55, 0.02),
                    createLayer(82.5, 0.015),
                    createLayer(110, 0.01)
                ];
            }

            stopAmbience() {
                if (this.ambienceNode) {
                    this.ambienceNode.forEach(node => node.osc.stop());
                    this.ambienceNode = null;
                }
            }
        }

        // ============================================
        // GAME STATE
        // ============================================
        const audio = new AudioSystem();

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let WIDTH = window.innerWidth;
        let HEIGHT = window.innerHeight - 80;
        canvas.width = WIDTH;
        canvas.height = HEIGHT;

        const GRID_SIZE = 20;
        const COLS = Math.floor(WIDTH / GRID_SIZE);
        const ROWS = Math.floor(HEIGHT / GRID_SIZE);

        // Terrain types
        const TERRAIN = {
            SOIL: 0,
            ROCK: 1,
            WATER: 2,
            CLAY: 3,
            ROOT: 4
        };

        // Cell states
        const CELL = {
            EMPTY: 0,
            PLAYER: 1,
            ENEMY1: 2,
            ENEMY2: 3,
            ENEMY3: 4,
            NUTRIENT_TREE: 10,
            NUTRIENT_COMPOST: 11,
            NUTRIENT_MINERAL: 12,
            STRUCTURE_FRUITING: 20,
            STRUCTURE_MYCORRHIZAL: 21,
            STRUCTURE_DIGESTIVE: 22,
            STRUCTURE_CANNON: 23
        };

        const SEASONS = ['Spring', 'Summer', 'Autumn', 'Winter'];
        const SEASON_DURATIONS = 1800; // frames per season

        let gameState = {
            running: false,
            paused: false,
            frame: 0,

            // Resources
            carbon: 100,
            nitrogen: 50,
            water: 75,
            enzymes: 25,

            // Season system
            season: 0,
            seasonTimer: 0,

            // Territory tracking
            playerCells: 0,
            enemyCells: [0, 0, 0],

            // Grid state
            grid: null,
            terrain: null,
            structures: [],
            nutrients: [],

            // Player network
            playerNodes: [],
            playerEdges: [],

            // Enemy networks
            enemies: [
                { color: '#8b2e2e', nodes: [], edges: [], ai: 'aggressive' },
                { color: '#2e5c8b', nodes: [], edges: [], ai: 'defensive' },
                { color: '#6b2e8b', nodes: [], edges: [], ai: 'symbiotic' }
            ],

            // Build mode
            buildMode: null,
            buildMenuOpen: false,

            // Mouse state
            mouseX: 0,
            mouseY: 0,
            mouseDown: false,

            // Game stats
            structuresBuilt: 0,
            enemiesDefeated: 0,
            symbiosisCount: 0,
            maxTerritory: 0
        };

        // ============================================
        // TERRAIN GENERATION
        // ============================================
        function generateTerrain() {
            const terrain = Array(ROWS).fill().map(() => Array(COLS).fill(TERRAIN.SOIL));

            // Add rock formations
            for (let i = 0; i < 15; i++) {
                const x = Math.floor(Math.random() * COLS);
                const y = Math.floor(Math.random() * ROWS);
                const size = 3 + Math.floor(Math.random() * 5);

                for (let dy = -size; dy <= size; dy++) {
                    for (let dx = -size; dx <= size; dx++) {
                        if (dx * dx + dy * dy <= size * size) {
                            const nx = x + dx;
                            const ny = y + dy;
                            if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS) {
                                terrain[ny][nx] = TERRAIN.ROCK;
                            }
                        }
                    }
                }
            }

            // Add water table layers
            for (let i = 0; i < 8; i++) {
                const y = Math.floor(ROWS * 0.3 + Math.random() * ROWS * 0.5);
                const x = Math.floor(Math.random() * COLS);
                const width = 10 + Math.floor(Math.random() * 20);

                for (let dx = 0; dx < width; dx++) {
                    const nx = x + dx;
                    if (nx < COLS && terrain[y][nx] === TERRAIN.SOIL) {
                        terrain[y][nx] = TERRAIN.WATER;
                    }
                }
            }

            // Add clay patches
            for (let i = 0; i < 20; i++) {
                const x = Math.floor(Math.random() * COLS);
                const y = Math.floor(Math.random() * ROWS);
                const size = 2 + Math.floor(Math.random() * 4);

                for (let dy = -size; dy <= size; dy++) {
                    for (let dx = -size; dx <= size; dx++) {
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS &&
                            terrain[ny][nx] === TERRAIN.SOIL && Math.random() < 0.6) {
                            terrain[ny][nx] = TERRAIN.CLAY;
                        }
                    }
                }
            }

            // Add root systems
            for (let i = 0; i < 25; i++) {
                const x = Math.floor(Math.random() * COLS);
                let y = Math.floor(Math.random() * ROWS * 0.3);

                for (let j = 0; j < 8 + Math.floor(Math.random() * 12); j++) {
                    if (y >= 0 && y < ROWS && terrain[y][x] === TERRAIN.SOIL) {
                        terrain[y][x] = TERRAIN.ROOT;
                    }
                    y++;
                    if (Math.random() < 0.3) {
                        x += Math.random() < 0.5 ? -1 : 1;
                    }
                    if (x < 0 || x >= COLS) break;
                }
            }

            return terrain;
        }

        function generateNutrients() {
            const nutrients = [];

            // Dead trees (top layer)
            for (let i = 0; i < 8; i++) {
                nutrients.push({
                    x: Math.floor(Math.random() * COLS),
                    y: Math.floor(Math.random() * ROWS * 0.2),
                    type: CELL.NUTRIENT_TREE,
                    yield: { carbon: 50, nitrogen: 20, water: 30 },
                    connected: []
                });
            }

            // Compost deposits
            for (let i = 0; i < 12; i++) {
                nutrients.push({
                    x: Math.floor(Math.random() * COLS),
                    y: Math.floor(Math.random() * ROWS),
                    type: CELL.NUTRIENT_COMPOST,
                    yield: { carbon: 30, nitrogen: 40, enzymes: 15 },
                    connected: []
                });
            }

            // Mineral deposits
            for (let i = 0; i < 10; i++) {
                nutrients.push({
                    x: Math.floor(Math.random() * COLS),
                    y: Math.floor(ROWS * 0.5 + Math.random() * ROWS * 0.5),
                    type: CELL.NUTRIENT_MINERAL,
                    yield: { nitrogen: 30, enzymes: 25, water: 20 },
                    connected: []
                });
            }

            return nutrients;
        }

        function initGame() {
            gameState.grid = Array(ROWS).fill().map(() => Array(COLS).fill(CELL.EMPTY));
            gameState.terrain = generateTerrain();
            gameState.nutrients = generateNutrients();
            gameState.structures = [];

            // Place nutrients on grid
            gameState.nutrients.forEach(n => {
                if (gameState.grid[n.y] && gameState.grid[n.y][n.x] !== undefined) {
                    gameState.grid[n.y][n.x] = n.type;
                }
            });

            // Initialize player network at bottom center
            const startX = Math.floor(COLS / 2);
            const startY = ROWS - 5;
            gameState.playerNodes = [{ x: startX, y: startY }];
            gameState.grid[startY][startX] = CELL.PLAYER;

            // Initialize enemy networks
            const enemyStarts = [
                { x: Math.floor(COLS * 0.2), y: Math.floor(ROWS * 0.3) },
                { x: Math.floor(COLS * 0.8), y: Math.floor(ROWS * 0.3) },
                { x: Math.floor(COLS * 0.5), y: Math.floor(ROWS * 0.1) }
            ];

            gameState.enemies.forEach((enemy, idx) => {
                const start = enemyStarts[idx];
                enemy.nodes = [start];
                if (gameState.grid[start.y] && gameState.grid[start.y][start.x] !== undefined) {
                    gameState.grid[start.y][start.x] = CELL.ENEMY1 + idx;
                }
            });

            gameState.frame = 0;
            gameState.season = 0;
            gameState.seasonTimer = 0;
            gameState.running = true;
            gameState.paused = false;

            updateResourceDisplay();
            updateInfoDisplay();
        }

        // ============================================
        // RESOURCE MANAGEMENT
        // ============================================
        function harvestResources() {
            if (gameState.frame % 60 !== 0) return; // Once per second

            const seasonMult = [1.2, 1.5, 1.0, 0.5][gameState.season];

            gameState.nutrients.forEach(nutrient => {
                nutrient.connected.forEach(owner => {
                    if (owner === CELL.PLAYER) {
                        Object.entries(nutrient.yield).forEach(([resource, amount]) => {
                            gameState[resource] += Math.floor(amount * seasonMult * 0.1);
                        });
                    }
                });
            });

            // Natural enzyme production from network size
            gameState.enzymes += Math.floor(gameState.playerNodes.length * 0.05);

            // Water evaporation in summer
            if (gameState.season === 1 && gameState.frame % 120 === 0) {
                gameState.water = Math.max(0, gameState.water - 5);
            }

            updateResourceDisplay();
        }

        function canAfford(costs) {
            return Object.entries(costs).every(([resource, cost]) => gameState[resource] >= cost);
        }

        function deductResources(costs) {
            Object.entries(costs).forEach(([resource, cost]) => {
                gameState[resource] -= cost;
            });
            updateResourceDisplay();
        }

        function updateResourceDisplay() {
            document.getElementById('carbonValue').textContent = Math.floor(gameState.carbon);
            document.getElementById('nitrogenValue').textContent = Math.floor(gameState.nitrogen);
            document.getElementById('waterValue').textContent = Math.floor(gameState.water);
            document.getElementById('enzymeValue').textContent = Math.floor(gameState.enzymes);
        }

        function updateInfoDisplay() {
            document.getElementById('seasonValue').textContent = SEASONS[gameState.season];

            const totalCells = ROWS * COLS;
            const territory = (gameState.playerCells / totalCells * 100).toFixed(1);
            document.getElementById('territoryValue').textContent = territory + '%';

            const aliveEnemies = gameState.enemies.filter(e => e.nodes.length > 0).length;
            document.getElementById('networkValue').textContent = aliveEnemies + 1;
        }

        // ============================================
        // GROWTH SYSTEM
        // ============================================
        function growNetwork(x, y) {
            const gridX = Math.floor(x / GRID_SIZE);
            const gridY = Math.floor(y / GRID_SIZE);

            if (gridX < 0 || gridX >= COLS || gridY < 0 || gridY >= ROWS) return;

            const cell = gameState.grid[gridY][gridX];
            const terrain = gameState.terrain[gridY][gridX];

            // Cannot grow on rocks or existing networks
            if (terrain === TERRAIN.ROCK) return;
            if (cell >= CELL.PLAYER && cell <= CELL.ENEMY3) return;
            if (cell >= CELL.STRUCTURE_FRUITING) return;

            // Must be adjacent to existing network
            const adjacent = [
                [gridX - 1, gridY], [gridX + 1, gridY],
                [gridX, gridY - 1], [gridX, gridY + 1]
            ];

            const hasAdjacent = adjacent.some(([ax, ay]) => {
                if (ax < 0 || ax >= COLS || ay < 0 || ay >= ROWS) return false;
                return gameState.grid[ay][ax] === CELL.PLAYER;
            });

            if (!hasAdjacent) return;

            // Resource costs based on terrain
            let cost = { carbon: 5, water: 3 };

            if (terrain === TERRAIN.CLAY) {
                cost.carbon += 5;
                cost.enzymes = 5;
            } else if (terrain === TERRAIN.WATER) {
                cost.nitrogen = 3;
            } else if (terrain === TERRAIN.ROOT) {
                cost.carbon += 3;
            }

            if (!canAfford(cost)) return;

            deductResources(cost);
            gameState.grid[gridY][gridX] = CELL.PLAYER;
            gameState.playerNodes.push({ x: gridX, y: gridY });

            // Check for nutrient connection
            const nutrient = gameState.nutrients.find(n => n.x === gridX && n.y === gridY);
            if (nutrient && !nutrient.connected.includes(CELL.PLAYER)) {
                nutrient.connected.push(CELL.PLAYER);
            }

            audio.playGrowth();
        }

        // ============================================
        // STRUCTURE BUILDING
        // ============================================
        const STRUCTURE_COSTS = {
            fruiting: { carbon: 30, nitrogen: 20, enzymes: 15 },
            mycorrhizal: { carbon: 40, nitrogen: 10, water: 20 },
            digestive: { carbon: 25, enzymes: 30 },
            cannon: { carbon: 50, nitrogen: 30, enzymes: 25 }
        };

        function buildStructure(type, x, y) {
            const gridX = Math.floor(x / GRID_SIZE);
            const gridY = Math.floor(y / GRID_SIZE);

            if (gridX < 0 || gridX >= COLS || gridY < 0 || gridY >= ROWS) return false;
            if (gameState.grid[gridY][gridX] !== CELL.PLAYER) return false;

            const costs = STRUCTURE_COSTS[type];
            if (!canAfford(costs)) return false;

            let structureType;
            switch (type) {
                case 'fruiting': structureType = CELL.STRUCTURE_FRUITING; break;
                case 'mycorrhizal': structureType = CELL.STRUCTURE_MYCORRHIZAL; break;
                case 'digestive': structureType = CELL.STRUCTURE_DIGESTIVE; break;
                case 'cannon': structureType = CELL.STRUCTURE_CANNON; break;
                default: return false;
            }

            deductResources(costs);
            gameState.grid[gridY][gridX] = structureType;
            gameState.structures.push({
                type: structureType,
                x: gridX,
                y: gridY,
                age: 0,
                cooldown: 0
            });

            gameState.structuresBuilt++;
            audio.playBuild();
            return true;
        }

        function updateStructures() {
            gameState.structures.forEach(structure => {
                structure.age++;
                if (structure.cooldown > 0) structure.cooldown--;

                switch (structure.type) {
                    case CELL.STRUCTURE_FRUITING:
                        if (structure.age % 180 === 0) {
                            releaseSpores(structure.x, structure.y, 3);
                        }
                        break;

                    case CELL.STRUCTURE_MYCORRHIZAL:
                        if (structure.age % 120 === 0) {
                            // Find nearby root systems
                            for (let dy = -3; dy <= 3; dy++) {
                                for (let dx = -3; dx <= 3; dx++) {
                                    const nx = structure.x + dx;
                                    const ny = structure.y + dy;
                                    if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS) {
                                        if (gameState.terrain[ny][nx] === TERRAIN.ROOT) {
                                            gameState.carbon += 10;
                                            gameState.water += 5;
                                            gameState.symbiosisCount++;
                                        }
                                    }
                                }
                            }
                        }
                        break;

                    case CELL.STRUCTURE_DIGESTIVE:
                        if (structure.age % 90 === 0) {
                            digestEnemies(structure.x, structure.y, 2);
                        }
                        break;

                    case CELL.STRUCTURE_CANNON:
                        if (structure.cooldown === 0) {
                            const target = findNearestEnemy(structure.x, structure.y);
                            if (target && distance(structure.x, structure.y, target.x, target.y) < 8) {
                                fireSpore(structure.x, structure.y, target.x, target.y);
                                structure.cooldown = 120;
                            }
                        }
                        break;
                }
            });
        }

        function releaseSpores(x, y, count) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = 2 + Math.floor(Math.random() * 4);
                const tx = x + Math.floor(Math.cos(angle) * dist);
                const ty = y + Math.floor(Math.sin(angle) * dist);

                if (tx >= 0 && tx < COLS && ty >= 0 && ty < ROWS) {
                    const cell = gameState.grid[ty][tx];
                    if (cell >= CELL.ENEMY1 && cell <= CELL.ENEMY3) {
                        gameState.grid[ty][tx] = CELL.PLAYER;
                        removeEnemyNode(cell - CELL.ENEMY1, tx, ty);
                        audio.playSpore();
                    }
                }
            }
        }

        function digestEnemies(x, y, radius) {
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    if (dx * dx + dy * dy > radius * radius) continue;

                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS) {
                        const cell = gameState.grid[ny][nx];
                        if (cell >= CELL.ENEMY1 && cell <= CELL.ENEMY3) {
                            gameState.grid[ny][nx] = CELL.EMPTY;
                            removeEnemyNode(cell - CELL.ENEMY1, nx, ny);
                            gameState.enzymes += 5;
                        }
                    }
                }
            }
        }

        function fireSpore(x, y, tx, ty) {
            const dx = tx - x;
            const dy = ty - y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const steps = Math.floor(dist);

            for (let i = 1; i <= steps; i++) {
                const px = Math.floor(x + (dx / dist) * i);
                const py = Math.floor(y + (dy / dist) * i);

                if (px >= 0 && px < COLS && py >= 0 && py < ROWS) {
                    const cell = gameState.grid[py][px];
                    if (cell >= CELL.ENEMY1 && cell <= CELL.ENEMY3) {
                        gameState.grid[py][px] = CELL.EMPTY;
                        removeEnemyNode(cell - CELL.ENEMY1, px, py);
                        audio.playSpore();
                        break;
                    }
                }
            }
        }

        function findNearestEnemy(x, y) {
            let nearest = null;
            let minDist = Infinity;

            gameState.enemies.forEach((enemy, idx) => {
                enemy.nodes.forEach(node => {
                    const d = distance(x, y, node.x, node.y);
                    if (d < minDist) {
                        minDist = d;
                        nearest = node;
                    }
                });
            });

            return nearest;
        }

        function removeEnemyNode(enemyIdx, x, y) {
            const enemy = gameState.enemies[enemyIdx];
            enemy.nodes = enemy.nodes.filter(n => !(n.x === x && n.y === y));

            if (enemy.nodes.length === 0) {
                gameState.enemiesDefeated++;
            }
        }

        function distance(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }

        // ============================================
        // ENEMY AI
        // ============================================
        function updateEnemies() {
            if (gameState.frame % 30 !== 0) return; // Update every 30 frames

            gameState.enemies.forEach((enemy, idx) => {
                if (enemy.nodes.length === 0) return;

                switch (enemy.ai) {
                    case 'aggressive':
                        aggressiveAI(enemy, idx);
                        break;
                    case 'defensive':
                        defensiveAI(enemy, idx);
                        break;
                    case 'symbiotic':
                        symbioticAI(enemy, idx);
                        break;
                }
            });
        }

        function aggressiveAI(enemy, idx) {
            const cellType = CELL.ENEMY1 + idx;

            // Find edge nodes
            const edgeNodes = enemy.nodes.filter(node => {
                const adjacent = [
                    [node.x - 1, node.y], [node.x + 1, node.y],
                    [node.x, node.y - 1], [node.x, node.y + 1]
                ];
                return adjacent.some(([ax, ay]) => {
                    if (ax < 0 || ax >= COLS || ay < 0 || ay >= ROWS) return false;
                    const cell = gameState.grid[ay][ax];
                    return cell === CELL.EMPTY || cell === CELL.PLAYER;
                });
            });

            // Expand toward player
            if (edgeNodes.length > 0 && Math.random() < 0.4) {
                const node = edgeNodes[Math.floor(Math.random() * edgeNodes.length)];
                const playerNode = gameState.playerNodes[0];

                let bestDir = null;
                let bestScore = Infinity;

                [[1, 0], [-1, 0], [0, 1], [0, -1]].forEach(([dx, dy]) => {
                    const nx = node.x + dx;
                    const ny = node.y + dy;

                    if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS) {
                        const cell = gameState.grid[ny][nx];
                        const terrain = gameState.terrain[ny][nx];

                        if (terrain !== TERRAIN.ROCK && (cell === CELL.EMPTY || cell === CELL.PLAYER)) {
                            const dist = distance(nx, ny, playerNode.x, playerNode.y);
                            if (dist < bestScore) {
                                bestScore = dist;
                                bestDir = [nx, ny];
                            }
                        }
                    }
                });

                if (bestDir) {
                    const [nx, ny] = bestDir;
                    const prevCell = gameState.grid[ny][nx];
                    gameState.grid[ny][nx] = cellType;
                    enemy.nodes.push({ x: nx, y: ny });

                    if (prevCell === CELL.PLAYER) {
                        gameState.playerNodes = gameState.playerNodes.filter(n => !(n.x === nx && n.y === ny));
                    }
                }
            }
        }

        function defensiveAI(enemy, idx) {
            const cellType = CELL.ENEMY1 + idx;

            // Build defensive perimeter
            if (Math.random() < 0.3) {
                const edgeNodes = enemy.nodes.filter(node => {
                    const adjacent = [
                        [node.x - 1, node.y], [node.x + 1, node.y],
                        [node.x, node.y - 1], [node.x, node.y + 1]
                    ];
                    return adjacent.some(([ax, ay]) => {
                        if (ax < 0 || ax >= COLS || ay < 0 || ay >= ROWS) return false;
                        return gameState.grid[ay][ax] === CELL.EMPTY;
                    });
                });

                if (edgeNodes.length > 0) {
                    const node = edgeNodes[Math.floor(Math.random() * edgeNodes.length)];
                    const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]];
                    const dir = dirs[Math.floor(Math.random() * dirs.length)];
                    const nx = node.x + dir[0];
                    const ny = node.y + dir[1];

                    if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS) {
                        if (gameState.grid[ny][nx] === CELL.EMPTY &&
                            gameState.terrain[ny][nx] !== TERRAIN.ROCK) {
                            gameState.grid[ny][nx] = cellType;
                            enemy.nodes.push({ x: nx, y: ny });
                        }
                    }
                }
            }
        }

        function symbioticAI(enemy, idx) {
            const cellType = CELL.ENEMY1 + idx;

            // Seek nutrient sources
            if (Math.random() < 0.5) {
                const edgeNodes = enemy.nodes.filter(node => {
                    const adjacent = [
                        [node.x - 1, node.y], [node.x + 1, node.y],
                        [node.x, node.y - 1], [node.x, node.y + 1]
                    ];
                    return adjacent.some(([ax, ay]) => {
                        if (ax < 0 || ax >= COLS || ay < 0 || ay >= ROWS) return false;
                        return gameState.grid[ay][ax] === CELL.EMPTY;
                    });
                });

                if (edgeNodes.length > 0) {
                    const node = edgeNodes[Math.floor(Math.random() * edgeNodes.length)];

                    // Find nearest nutrient
                    let nearest = null;
                    let minDist = Infinity;

                    gameState.nutrients.forEach(nutrient => {
                        const d = distance(node.x, node.y, nutrient.x, nutrient.y);
                        if (d < minDist && !nutrient.connected.includes(cellType)) {
                            minDist = d;
                            nearest = nutrient;
                        }
                    });

                    if (nearest) {
                        const dx = Math.sign(nearest.x - node.x);
                        const dy = Math.sign(nearest.y - node.y);

                        const nx = node.x + (Math.abs(dx) > Math.abs(dy) ? dx : 0);
                        const ny = node.y + (Math.abs(dy) >= Math.abs(dx) ? dy : 0);

                        if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS) {
                            if (gameState.grid[ny][nx] === CELL.EMPTY &&
                                gameState.terrain[ny][nx] !== TERRAIN.ROCK) {
                                gameState.grid[ny][nx] = cellType;
                                enemy.nodes.push({ x: nx, y: ny });
                            }
                        }
                    }
                }
            }
        }

        // ============================================
        // SEASON SYSTEM
        // ============================================
        function updateSeason() {
            gameState.seasonTimer++;
            if (gameState.seasonTimer >= SEASON_DURATIONS) {
                gameState.season = (gameState.season + 1) % 4;
                gameState.seasonTimer = 0;
                updateInfoDisplay();
            }
        }

        // ============================================
        // WIN CONDITIONS
        // ============================================
        function checkWinConditions() {
            if (gameState.frame < 600) return null; // Minimum game time

            // Count territories
            let playerCells = 0;
            let enemyCells = [0, 0, 0];

            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    const cell = gameState.grid[y][x];
                    if (cell === CELL.PLAYER) playerCells++;
                    else if (cell >= CELL.ENEMY1 && cell <= CELL.ENEMY3) {
                        enemyCells[cell - CELL.ENEMY1]++;
                    }
                }
            }

            gameState.playerCells = playerCells;
            gameState.enemyCells = enemyCells;
            gameState.maxTerritory = Math.max(gameState.maxTerritory, playerCells);

            updateInfoDisplay();

            const totalCells = ROWS * COLS;
            const territoryPercent = playerCells / totalCells;

            // Ecosystem Dominance - control 60% of map
            if (territoryPercent >= 0.6) {
                return {
                    title: 'Ecosystem Dominance',
                    description: 'Your mycelial network has spread across the entire underground ecosystem, becoming the dominant decomposer and nutrient cycler. All other fungal networks have been outcompeted or absorbed. The forest above thrives on your tireless work breaking down organic matter and distributing nutrients.'
                };
            }

            // Symbiotic Forest - 30+ mycorrhizal links
            const mycorrhizalCount = gameState.structures.filter(
                s => s.type === CELL.STRUCTURE_MYCORRHIZAL
            ).length;
            if (mycorrhizalCount >= 30) {
                return {
                    title: 'Symbiotic Forest',
                    description: 'Your network has formed extensive mycorrhizal partnerships with the tree roots above. Through these mutually beneficial exchanges, you have created a thriving wood wide web that shares resources across species. The forest is healthier and more resilient thanks to your cooperation.'
                };
            }

            // Underground Empire - 50+ structures
            if (gameState.structuresBuilt >= 50) {
                return {
                    title: 'Underground Empire',
                    description: 'Your network has evolved into a sophisticated underground civilization, with specialized structures for every function. Fruiting bodies release spores to distant territories. Digestive mats break down the toughest materials. Spore cannons defend your domain. You have built an empire beneath the soil.'
                };
            }

            // The Great Fruiting - survive all 4 seasons with 40% territory
            if (gameState.frame >= SEASON_DURATIONS * 4 && territoryPercent >= 0.4) {
                return {
                    title: 'The Great Fruiting',
                    description: 'Your network has endured through all four seasons, adapting to each challenge. As autumn arrives once more, your fruiting bodies emerge across the forest floor in a spectacular display. Millions of spores drift on the wind, carrying your genetic legacy to new territories. The cycle continues.'
                };
            }

            // Game over - player eliminated
            if (playerCells === 0) {
                return {
                    title: 'Network Collapsed',
                    description: 'Your mycelial network has been overwhelmed by rival fungi. The underground ecosystem continues without you, as other networks claim your former territory and resources.'
                };
            }

            return null;
        }

        // ============================================
        // RENDERING
        // ============================================
        function render() {
            ctx.fillStyle = '#2a1f16';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            // Render terrain
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    const terrain = gameState.terrain[y][x];
                    let color;

                    switch (terrain) {
                        case TERRAIN.ROCK:
                            color = '#3a3230';
                            break;
                        case TERRAIN.WATER:
                            color = '#2a3a4a';
                            break;
                        case TERRAIN.CLAY:
                            color = '#4a3a2a';
                            break;
                        case TERRAIN.ROOT:
                            color = '#3a2a1a';
                            break;
                        default:
                            continue;
                    }

                    ctx.fillStyle = color;
                    ctx.fillRect(x * GRID_SIZE, y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                }
            }

            // Render networks
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    const cell = gameState.grid[y][x];
                    let color = null;

                    if (cell === CELL.PLAYER) {
                        color = '#8b7355';
                    } else if (cell >= CELL.ENEMY1 && cell <= CELL.ENEMY3) {
                        color = gameState.enemies[cell - CELL.ENEMY1].color;
                    } else if (cell >= CELL.NUTRIENT_TREE && cell <= CELL.NUTRIENT_MINERAL) {
                        // Nutrients
                        if (cell === CELL.NUTRIENT_TREE) color = '#6b4423';
                        else if (cell === CELL.NUTRIENT_COMPOST) color = '#5a4a2a';
                        else if (cell === CELL.NUTRIENT_MINERAL) color = '#7a7a6a';

                        ctx.fillStyle = color;
                        ctx.fillRect(x * GRID_SIZE, y * GRID_SIZE, GRID_SIZE, GRID_SIZE);

                        // Glow effect
                        const nutrient = gameState.nutrients.find(n => n.x === x && n.y === y);
                        if (nutrient && nutrient.connected.includes(CELL.PLAYER)) {
                            const pulse = Math.sin(gameState.frame * 0.05) * 0.3 + 0.7;
                            ctx.fillStyle = `rgba(107, 155, 55, ${pulse * 0.4})`;
                            ctx.fillRect(x * GRID_SIZE, y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                        }
                        continue;
                    } else if (cell >= CELL.STRUCTURE_FRUITING && cell <= CELL.STRUCTURE_CANNON) {
                        // Structures
                        const structure = gameState.structures.find(s => s.x === x && s.y === y);
                        if (structure) {
                            ctx.fillStyle = '#8b7355';
                            ctx.fillRect(x * GRID_SIZE, y * GRID_SIZE, GRID_SIZE, GRID_SIZE);

                            // Structure icon
                            ctx.fillStyle = '#d4c5a9';
                            ctx.font = `${GRID_SIZE * 0.8}px Arial`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';

                            let icon = '';
                            if (cell === CELL.STRUCTURE_FRUITING) icon = 'üçÑ';
                            else if (cell === CELL.STRUCTURE_MYCORRHIZAL) icon = 'üå≥';
                            else if (cell === CELL.STRUCTURE_DIGESTIVE) icon = 'üíß';
                            else if (cell === CELL.STRUCTURE_CANNON) icon = 'üí•';

                            ctx.fillText(icon, x * GRID_SIZE + GRID_SIZE / 2, y * GRID_SIZE + GRID_SIZE / 2);
                        }
                        continue;
                    }

                    if (color) {
                        // Network cell with glow
                        const pulse = Math.sin(gameState.frame * 0.03 + x + y) * 0.2 + 0.8;
                        ctx.fillStyle = color;
                        ctx.globalAlpha = pulse;
                        ctx.fillRect(x * GRID_SIZE, y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                        ctx.globalAlpha = 1;

                        // Hyphae connections
                        const adjacent = [
                            [x + 1, y], [x, y + 1]
                        ];

                        adjacent.forEach(([ax, ay]) => {
                            if (ax < COLS && ay < ROWS && gameState.grid[ay][ax] === cell) {
                                ctx.strokeStyle = color;
                                ctx.lineWidth = 2;
                                ctx.beginPath();
                                ctx.moveTo(x * GRID_SIZE + GRID_SIZE / 2, y * GRID_SIZE + GRID_SIZE / 2);
                                ctx.lineTo(ax * GRID_SIZE + GRID_SIZE / 2, ay * GRID_SIZE + GRID_SIZE / 2);
                                ctx.stroke();
                            }
                        });
                    }
                }
            }

            // Render growth preview
            if (!gameState.buildMenuOpen && gameState.mouseX > 0 && gameState.mouseY > 0) {
                const gridX = Math.floor(gameState.mouseX / GRID_SIZE);
                const gridY = Math.floor(gameState.mouseY / GRID_SIZE);

                if (gridX >= 0 && gridX < COLS && gridY >= 0 && gridY < ROWS) {
                    ctx.strokeStyle = 'rgba(139, 115, 85, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(gridX * GRID_SIZE, gridY * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                }
            }
        }

        // ============================================
        // GAME LOOP
        // ============================================
        function gameLoop() {
            if (!gameState.running) return;

            if (!gameState.paused) {
                gameState.frame++;

                updateSeason();
                harvestResources();
                updateStructures();
                updateEnemies();

                const ending = checkWinConditions();
                if (ending) {
                    endGame(ending);
                }

                // Auto-grow while mouse held
                if (gameState.mouseDown && !gameState.buildMenuOpen) {
                    growNetwork(gameState.mouseX, gameState.mouseY);
                }
            }

            render();
            requestAnimationFrame(gameLoop);
        }

        // ============================================
        // INPUT HANDLING
        // ============================================
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            gameState.mouseX = e.clientX - rect.left;
            gameState.mouseY = e.clientY - rect.top;
            gameState.mouseDown = true;

            if (e.button === 0 && !gameState.buildMenuOpen) {
                growNetwork(gameState.mouseX, gameState.mouseY);
            }
        });

        canvas.addEventListener('mouseup', () => {
            gameState.mouseDown = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            gameState.mouseX = e.clientX - rect.left;
            gameState.mouseY = e.clientY - rect.top;
        });

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const gridX = Math.floor(x / GRID_SIZE);
            const gridY = Math.floor(y / GRID_SIZE);

            if (gridX >= 0 && gridX < COLS && gridY >= 0 && gridY < ROWS) {
                if (gameState.grid[gridY][gridX] === CELL.PLAYER) {
                    gameState.buildMenuOpen = !gameState.buildMenuOpen;
                    document.getElementById('buildMenu').classList.toggle('active', gameState.buildMenuOpen);

                    if (gameState.buildMenuOpen) {
                        gameState.buildX = x;
                        gameState.buildY = y;
                        updateBuildButtons();
                    }
                }
            }
        });

        document.querySelectorAll('.build-button').forEach(btn => {
            btn.addEventListener('click', () => {
                const type = btn.dataset.structure;
                if (buildStructure(type, gameState.buildX, gameState.buildY)) {
                    gameState.buildMenuOpen = false;
                    document.getElementById('buildMenu').classList.remove('active');
                }
            });
        });

        function updateBuildButtons() {
            document.querySelectorAll('.build-button').forEach(btn => {
                const type = btn.dataset.structure;
                const costs = STRUCTURE_COSTS[type];
                btn.disabled = !canAfford(costs);
            });
        }

        // ============================================
        // UI CONTROLS
        // ============================================
        document.getElementById('startButton').addEventListener('click', () => {
            document.getElementById('titleScreen').classList.add('hidden');
            audio.init();
            initGame();
            gameLoop();
        });

        document.getElementById('loadButton').addEventListener('click', () => {
            if (loadGame()) {
                document.getElementById('titleScreen').classList.add('hidden');
                audio.init();
                gameLoop();
            } else {
                alert('No saved game found');
            }
        });

        document.getElementById('resumeButton').addEventListener('click', () => {
            gameState.paused = false;
            document.getElementById('pauseOverlay').classList.remove('active');
        });

        document.getElementById('saveButton').addEventListener('click', () => {
            saveGame();
            alert('Network saved successfully');
        });

        document.getElementById('quitButton').addEventListener('click', () => {
            gameState.running = false;
            gameState.paused = false;
            document.getElementById('pauseOverlay').classList.remove('active');
            document.getElementById('titleScreen').classList.remove('hidden');
        });

        document.getElementById('restartButton').addEventListener('click', () => {
            document.getElementById('gameOver').classList.add('hidden');
            initGame();
        });

        document.getElementById('menuButton').addEventListener('click', () => {
            gameState.running = false;
            document.getElementById('gameOver').classList.add('hidden');
            document.getElementById('titleScreen').classList.remove('hidden');
        });

        window.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (gameState.buildMenuOpen) {
                    gameState.buildMenuOpen = false;
                    document.getElementById('buildMenu').classList.remove('active');
                } else if (gameState.running && !document.getElementById('gameOver').classList.contains('hidden')) {
                    // Do nothing during game over
                } else if (gameState.running) {
                    gameState.paused = !gameState.paused;
                    document.getElementById('pauseOverlay').classList.toggle('active', gameState.paused);
                }
            }
        });

        // ============================================
        // SAVE/LOAD SYSTEM
        // ============================================
        function saveGame() {
            const saveData = {
                frame: gameState.frame,
                carbon: gameState.carbon,
                nitrogen: gameState.nitrogen,
                water: gameState.water,
                enzymes: gameState.enzymes,
                season: gameState.season,
                seasonTimer: gameState.seasonTimer,
                grid: gameState.grid,
                terrain: gameState.terrain,
                nutrients: gameState.nutrients,
                structures: gameState.structures,
                playerNodes: gameState.playerNodes,
                enemies: gameState.enemies.map(e => ({
                    color: e.color,
                    nodes: e.nodes,
                    ai: e.ai
                })),
                stats: {
                    structuresBuilt: gameState.structuresBuilt,
                    enemiesDefeated: gameState.enemiesDefeated,
                    symbiosisCount: gameState.symbiosisCount,
                    maxTerritory: gameState.maxTerritory
                }
            };

            try {
                localStorage.setItem('myceliumWars_save', JSON.stringify(saveData));
                return true;
            } catch (e) {
                console.error('Save failed:', e);
                return false;
            }
        }

        function loadGame() {
            try {
                const saveData = JSON.parse(localStorage.getItem('myceliumWars_save'));
                if (!saveData) return false;

                gameState.frame = saveData.frame;
                gameState.carbon = saveData.carbon;
                gameState.nitrogen = saveData.nitrogen;
                gameState.water = saveData.water;
                gameState.enzymes = saveData.enzymes;
                gameState.season = saveData.season;
                gameState.seasonTimer = saveData.seasonTimer;
                gameState.grid = saveData.grid;
                gameState.terrain = saveData.terrain;
                gameState.nutrients = saveData.nutrients;
                gameState.structures = saveData.structures;
                gameState.playerNodes = saveData.playerNodes;
                gameState.enemies = saveData.enemies.map(e => ({
                    color: e.color,
                    nodes: e.nodes,
                    edges: [],
                    ai: e.ai
                }));

                if (saveData.stats) {
                    gameState.structuresBuilt = saveData.stats.structuresBuilt;
                    gameState.enemiesDefeated = saveData.stats.enemiesDefeated;
                    gameState.symbiosisCount = saveData.stats.symbiosisCount;
                    gameState.maxTerritory = saveData.stats.maxTerritory;
                }

                gameState.running = true;
                gameState.paused = false;

                updateResourceDisplay();
                updateInfoDisplay();

                return true;
            } catch (e) {
                console.error('Load failed:', e);
                return false;
            }
        }

        function endGame(ending) {
            gameState.running = false;

            const endingText = document.getElementById('endingText');
            endingText.innerHTML = `
                <div class="ending-title">${ending.title}</div>
                <div class="ending-description">${ending.description}</div>
            `;

            const stats = document.getElementById('endingStats');
            stats.innerHTML = `
                <div class="stat-item">
                    <span>Structures Built:</span>
                    <span>${gameState.structuresBuilt}</span>
                </div>
                <div class="stat-item">
                    <span>Rivals Defeated:</span>
                    <span>${gameState.enemiesDefeated}</span>
                </div>
                <div class="stat-item">
                    <span>Symbiotic Links:</span>
                    <span>${gameState.symbiosisCount}</span>
                </div>
                <div class="stat-item">
                    <span>Max Territory:</span>
                    <span>${(gameState.maxTerritory / (ROWS * COLS) * 100).toFixed(1)}%</span>
                </div>
                <div class="stat-item">
                    <span>Seasons Survived:</span>
                    <span>${Math.floor(gameState.frame / SEASON_DURATIONS)}</span>
                </div>
                <div class="stat-item">
                    <span>Final Resources:</span>
                    <span>C:${Math.floor(gameState.carbon)} N:${Math.floor(gameState.nitrogen)} W:${Math.floor(gameState.water)} E:${Math.floor(gameState.enzymes)}</span>
                </div>
            `;

            document.getElementById('gameOver').classList.remove('hidden');
            audio.stopAmbience();
        }

        // ============================================
        // WINDOW RESIZE
        // ============================================
        window.addEventListener('resize', () => {
            WIDTH = window.innerWidth;
            HEIGHT = window.innerHeight - 80;
            canvas.width = WIDTH;
            canvas.height = HEIGHT;
        });

        // Check for saved game on load
        if (localStorage.getItem('myceliumWars_save')) {
            document.getElementById('loadButton').style.display = 'inline-block';
        }
    </script>
</body>
</html>