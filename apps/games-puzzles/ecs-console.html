<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="ECS Game Console - Load cartridge games into a browser-based Entity-Component-System game engine">
    <meta name="theme-color" content="#05050a">
    <title>ECS Game Console</title>
    <!-- game, console, ecs, cartridge, arcade, retro -->
    <style>
        :root {
            --bg-darkest: #05050a;
            --bg-dark: #0a0a12;
            --bg-medium: #12121f;
            --bg-light: #1a1a2e;
            --bg-lighter: #252540;
            --text-primary: #e8e8f0;
            --text-secondary: #8888a0;
            --text-dim: #555566;
            --accent: #00d4ff;
            --accent-glow: rgba(0, 212, 255, 0.3);
            --secondary: #ff00aa;
            --tertiary: #00ff88;
            --warning: #ffaa00;
            --danger: #ff4466;
            --success: #44ff88;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Mono', 'Consolas', 'Monaco', monospace;
            background: var(--bg-darkest);
            color: var(--text-primary);
            min-height: 100vh;
            overflow: hidden;
        }

        /* ============================================
           LAUNCHER SCREEN
           ============================================ */
        .launcher {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            background: var(--bg-darkest);
            z-index: 100;
            transition: opacity 0.5s, visibility 0.5s;
        }

        .launcher.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        .launcher-header {
            padding: 2rem;
            text-align: center;
            background: linear-gradient(180deg, var(--bg-medium) 0%, var(--bg-darkest) 100%);
            border-bottom: 1px solid var(--bg-light);
        }

        .console-logo {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 0.5rem;
        }

        .console-logo svg {
            width: 48px;
            height: 48px;
            filter: drop-shadow(0 0 20px var(--accent-glow));
        }

        .console-logo h1 {
            font-size: 2.5rem;
            font-weight: 300;
            letter-spacing: 0.2em;
            background: linear-gradient(135deg, var(--accent) 0%, var(--secondary) 50%, var(--tertiary) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .console-tagline {
            color: var(--text-secondary);
            font-size: 0.875rem;
            letter-spacing: 0.3em;
            text-transform: uppercase;
        }

        .launcher-content {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .cartridge-library {
            flex: 1;
            padding: 2rem;
            overflow-y: auto;
        }

        .library-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .library-title {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            color: var(--text-secondary);
        }

        .library-actions {
            display: flex;
            gap: 0.5rem;
        }

        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-ghost {
            background: transparent;
            color: var(--text-secondary);
            border: 1px solid var(--bg-lighter);
        }

        .btn-ghost:hover {
            background: var(--bg-light);
            color: var(--text-primary);
            border-color: var(--accent);
        }

        .btn-primary {
            background: var(--accent);
            color: var(--bg-darkest);
        }

        .btn-primary:hover {
            background: var(--tertiary);
            transform: scale(1.02);
        }

        .btn:focus-visible {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
        }

        .cartridge-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 1.5rem;
        }

        .cartridge-card {
            background: var(--bg-dark);
            border: 1px solid var(--bg-light);
            border-radius: 12px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }

        .cartridge-card:hover {
            transform: translateY(-4px);
            border-color: var(--accent);
            box-shadow: 0 10px 40px rgba(0, 212, 255, 0.2);
        }

        .cartridge-card.selected {
            border-color: var(--accent);
            box-shadow: 0 0 0 2px var(--accent-glow);
        }

        .cartridge-preview {
            height: 160px;
            background: var(--bg-medium);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .cartridge-preview canvas {
            width: 100%;
            height: 100%;
        }

        .cartridge-genre {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            padding: 0.25rem 0.5rem;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 4px;
            font-size: 0.625rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--accent);
        }

        .cartridge-info {
            padding: 1rem;
        }

        .cartridge-title {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .cartridge-description {
            font-size: 0.75rem;
            color: var(--text-secondary);
            line-height: 1.5;
            margin-bottom: 0.75rem;
        }

        .cartridge-meta {
            display: flex;
            gap: 1rem;
            font-size: 0.625rem;
            color: var(--text-dim);
        }

        .cartridge-meta span {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        /* Selected cartridge detail panel */
        .cartridge-detail {
            width: 350px;
            background: var(--bg-dark);
            border-left: 1px solid var(--bg-light);
            padding: 2rem;
            display: flex;
            flex-direction: column;
        }

        .detail-preview {
            aspect-ratio: 16/10;
            background: var(--bg-medium);
            border-radius: 8px;
            margin-bottom: 1.5rem;
            overflow: hidden;
        }

        .detail-title {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
        }

        .detail-description {
            color: var(--text-secondary);
            font-size: 0.875rem;
            line-height: 1.6;
            margin-bottom: 1.5rem;
        }

        .detail-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .stat-box {
            background: var(--bg-medium);
            padding: 0.75rem;
            border-radius: 6px;
        }

        .stat-label {
            font-size: 0.625rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-dim);
            margin-bottom: 0.25rem;
        }

        .stat-value {
            font-size: 0.875rem;
            color: var(--text-primary);
        }

        .detail-controls {
            margin-bottom: 1.5rem;
        }

        .controls-title {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-secondary);
            margin-bottom: 0.75rem;
        }

        .control-list {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .control-item {
            display: flex;
            justify-content: space-between;
            padding: 0.375rem 0;
            border-bottom: 1px solid var(--bg-light);
        }

        .control-key {
            color: var(--accent);
        }

        .detail-actions {
            margin-top: auto;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .btn-play {
            padding: 1rem;
            font-size: 1rem;
            justify-content: center;
            background: linear-gradient(135deg, var(--accent) 0%, var(--tertiary) 100%);
        }

        .btn-play:hover {
            transform: scale(1.02);
            box-shadow: 0 5px 20px var(--accent-glow);
        }

        /* ============================================
           GAME SCREEN
           ============================================ */
        .game-screen {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            background: var(--bg-darkest);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s, visibility 0.5s;
        }

        .game-screen.active {
            opacity: 1;
            visibility: visible;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            background: var(--bg-dark);
            border-bottom: 1px solid var(--bg-light);
        }

        .game-info {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .game-title-bar {
            font-size: 0.875rem;
            font-weight: 600;
        }

        .game-stats {
            display: flex;
            gap: 1.5rem;
            font-size: 0.75rem;
        }

        .game-stat {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .game-stat-label {
            color: var(--text-secondary);
        }

        .game-stat-value {
            font-weight: 600;
            min-width: 60px;
        }

        .game-controls {
            display: flex;
            gap: 0.5rem;
        }

        .game-canvas-wrapper {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-darkest);
            position: relative;
        }

        #gameCanvas {
            background: #000;
            border-radius: 4px;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
        }

        .game-hud {
            position: absolute;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 2rem;
            font-size: 1.25rem;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
            pointer-events: none;
        }

        .hud-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .hud-label {
            color: var(--text-secondary);
            font-size: 0.75rem;
            text-transform: uppercase;
        }

        .hud-value {
            font-weight: 600;
            color: var(--accent);
        }

        /* Pause/Game Over Overlay */
        .game-overlay {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.85);
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
        }

        .game-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .overlay-title {
            font-size: 3rem;
            font-weight: 300;
            letter-spacing: 0.2em;
            margin-bottom: 1rem;
        }

        .overlay-title.win {
            color: var(--success);
        }

        .overlay-title.lose {
            color: var(--danger);
        }

        .overlay-subtitle {
            font-size: 1.25rem;
            color: var(--text-secondary);
            margin-bottom: 2rem;
        }

        .overlay-buttons {
            display: flex;
            gap: 1rem;
        }

        /* Import Modal */
        .modal {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.8);
            z-index: 200;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
        }

        .modal.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background: var(--bg-dark);
            border: 1px solid var(--bg-light);
            border-radius: 12px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
        }

        .modal-title {
            font-size: 1.25rem;
            margin-bottom: 1rem;
        }

        .modal-body {
            margin-bottom: 1.5rem;
        }

        .modal-body textarea {
            width: 100%;
            height: 200px;
            background: var(--bg-medium);
            border: 1px solid var(--bg-light);
            border-radius: 6px;
            padding: 1rem;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 0.75rem;
            resize: vertical;
        }

        .modal-body textarea:focus {
            outline: none;
            border-color: var(--accent);
        }

        .drop-zone {
            border: 2px dashed var(--bg-lighter);
            border-radius: 8px;
            padding: 2rem;
            text-align: center;
            color: var(--text-secondary);
            transition: all 0.3s;
            cursor: pointer;
        }

        .drop-zone:hover, .drop-zone.dragover {
            border-color: var(--accent);
            background: rgba(0, 212, 255, 0.05);
        }

        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
        }

        /* Hidden file input */
        .hidden {
            display: none;
        }

        /* Stars background */
        .stars-bg {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: -1;
        }

        /* Scanlines effect */
        .scanlines {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 1000;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.1) 0px,
                rgba(0, 0, 0, 0.1) 1px,
                transparent 1px,
                transparent 2px
            );
            opacity: 0.3;
        }

        /* Loading spinner */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            color: var(--text-secondary);
        }

        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid var(--bg-lighter);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <canvas class="stars-bg" id="starsBg" aria-hidden="true"></canvas>
    <div class="scanlines" aria-hidden="true"></div>

    <!-- LAUNCHER SCREEN -->
    <div class="launcher" id="launcher">
        <div class="launcher-header">
            <div class="console-logo">
                <svg viewBox="0 0 48 48" fill="none">
                    <polygon points="24,4 44,40 4,40" stroke="url(#grad1)" stroke-width="2" fill="none"/>
                    <polygon points="24,14 36,36 12,36" stroke="url(#grad1)" stroke-width="2" fill="none"/>
                    <circle cx="24" cy="28" r="4" fill="url(#grad1)"/>
                    <defs>
                        <linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:#00d4ff"/>
                            <stop offset="50%" style="stop-color:#ff00aa"/>
                            <stop offset="100%" style="stop-color:#00ff88"/>
                        </linearGradient>
                    </defs>
                </svg>
                <h1>ECS CONSOLE</h1>
            </div>
            <div class="console-tagline">Entity Component System Game Engine</div>
        </div>

        <div class="launcher-content">
            <div class="cartridge-library">
                <div class="library-header">
                    <span class="library-title">Game Library</span>
                    <div class="library-actions">
                        <button class="btn btn-ghost" onclick="showImportModal()">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                                <polyline points="17 8 12 3 7 8"/>
                                <line x1="12" y1="3" x2="12" y2="15"/>
                            </svg>
                            Import Cartridge
                        </button>
                    </div>
                </div>
                <div class="cartridge-grid" id="cartridgeGrid"></div>
            </div>

            <div class="cartridge-detail" id="cartridgeDetail">
                <div class="detail-preview" id="detailPreview"></div>
                <h2 class="detail-title" id="detailTitle">Select a Game</h2>
                <p class="detail-description" id="detailDescription">
                    Choose a cartridge from the library to see details and play.
                </p>
                <div class="detail-stats" id="detailStats"></div>
                <div class="detail-controls" id="detailControls"></div>
                <div class="detail-actions">
                    <button class="btn btn-primary btn-play" id="playButton" disabled onclick="startGame()">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                            <polygon points="5,3 19,12 5,21"/>
                        </svg>
                        INSERT CARTRIDGE
                    </button>
                    <button class="btn btn-ghost" id="exportButton" disabled onclick="exportSelectedCartridge()">
                        Export Cartridge JSON
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- GAME SCREEN -->
    <div class="game-screen" id="gameScreen">
        <div class="game-header">
            <div class="game-info">
                <button class="btn btn-ghost" onclick="exitToLauncher()">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M19 12H5M12 19l-7-7 7-7"/>
                    </svg>
                    Eject
                </button>
                <span class="game-title-bar" id="gameTitleBar">Game</span>
            </div>
            <div class="game-stats">
                <div class="game-stat">
                    <span class="game-stat-label">Entities:</span>
                    <span class="game-stat-value" id="entityCount">0</span>
                </div>
                <div class="game-stat">
                    <span class="game-stat-label">FPS:</span>
                    <span class="game-stat-value" id="fpsDisplay">60</span>
                </div>
            </div>
            <div class="game-controls">
                <button class="btn btn-ghost" onclick="togglePause()">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor" id="pauseIcon">
                        <rect x="6" y="4" width="4" height="16"/>
                        <rect x="14" y="4" width="4" height="16"/>
                    </svg>
                    Pause
                </button>
                <button class="btn btn-ghost" onclick="restartGame()">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M1 4v6h6"/>
                        <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/>
                    </svg>
                    Restart
                </button>
            </div>
        </div>

        <div class="game-canvas-wrapper">
            <canvas id="gameCanvas"></canvas>
            <div class="game-hud" id="gameHud"></div>

            <div class="game-overlay" id="pauseOverlay">
                <h2 class="overlay-title">PAUSED</h2>
                <div class="overlay-buttons">
                    <button class="btn btn-primary" onclick="togglePause()">Resume</button>
                    <button class="btn btn-ghost" onclick="exitToLauncher()">Exit to Menu</button>
                </div>
            </div>

            <div class="game-overlay" id="gameOverOverlay">
                <h2 class="overlay-title lose" id="gameOverTitle">GAME OVER</h2>
                <p class="overlay-subtitle" id="gameOverScore">Score: 0</p>
                <div class="overlay-buttons">
                    <button class="btn btn-primary" onclick="restartGame()">Play Again</button>
                    <button class="btn btn-ghost" onclick="exitToLauncher()">Exit to Menu</button>
                </div>
            </div>
        </div>
    </div>

    <!-- IMPORT MODAL -->
    <div class="modal" id="importModal">
        <div class="modal-content">
            <h3 class="modal-title">Import Cartridge</h3>
            <div class="modal-body">
                <div class="drop-zone" id="dropZone" onclick="document.getElementById('fileInput').click()">
                    <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="var(--text-secondary)" stroke-width="1">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                        <polyline points="17 8 12 3 7 8"/>
                        <line x1="12" y1="3" x2="12" y2="15"/>
                    </svg>
                    <p>Drop a .json cartridge file here<br>or click to browse</p>
                </div>
                <input type="file" id="fileInput" class="hidden" accept=".json" onchange="handleFileImport(event)">
            </div>
            <div class="modal-actions">
                <button class="btn btn-ghost" onclick="hideImportModal()">Cancel</button>
            </div>
        </div>
    </div>

    <script>
    // ============================================
    // ECS CORE ENGINE
    // ============================================

    let nextEntityId = 0;
    const createEntityId = () => nextEntityId++;

    class ComponentStorage {
        constructor() {
            this.dense = [];
            this.sparse = [];
            this.entities = [];
        }

        has(entityId) {
            return this.sparse[entityId] !== undefined &&
                   this.entities[this.sparse[entityId]] === entityId;
        }

        get(entityId) {
            if (!this.has(entityId)) return undefined;
            return this.dense[this.sparse[entityId]];
        }

        set(entityId, component) {
            if (this.has(entityId)) {
                this.dense[this.sparse[entityId]] = component;
            } else {
                const index = this.dense.length;
                this.dense.push(component);
                this.entities.push(entityId);
                this.sparse[entityId] = index;
            }
        }

        remove(entityId) {
            if (!this.has(entityId)) return;
            const index = this.sparse[entityId];
            const lastIndex = this.dense.length - 1;
            const lastEntity = this.entities[lastIndex];
            this.dense[index] = this.dense[lastIndex];
            this.entities[index] = lastEntity;
            this.sparse[lastEntity] = index;
            this.dense.pop();
            this.entities.pop();
            delete this.sparse[entityId];
        }

        *[Symbol.iterator]() {
            for (let i = 0; i < this.dense.length; i++) {
                yield [this.entities[i], this.dense[i]];
            }
        }

        get count() { return this.dense.length; }
    }

    class World {
        constructor() {
            this.entities = new Set();
            this.components = new Map();
            this.systems = [];
            this.toDestroy = [];
            this.events = [];
        }

        createEntity() {
            const id = createEntityId();
            this.entities.add(id);
            return id;
        }

        destroyEntity(entityId) {
            this.toDestroy.push(entityId);
        }

        _destroyEntity(entityId) {
            for (const storage of this.components.values()) {
                storage.remove(entityId);
            }
            this.entities.delete(entityId);
        }

        addComponent(entityId, type, data) {
            if (!this.components.has(type)) {
                this.components.set(type, new ComponentStorage());
            }
            this.components.get(type).set(entityId, { ...data });
        }

        getComponent(entityId, type) {
            const storage = this.components.get(type);
            return storage ? storage.get(entityId) : undefined;
        }

        hasComponent(entityId, type) {
            const storage = this.components.get(type);
            return storage ? storage.has(entityId) : false;
        }

        removeComponent(entityId, type) {
            const storage = this.components.get(type);
            if (storage) storage.remove(entityId);
        }

        query(...types) {
            const results = [];
            const storages = types.map(t => this.components.get(t));
            if (storages.some(s => !s)) return results;

            let smallest = storages[0];
            for (const s of storages) if (s.count < smallest.count) smallest = s;

            for (const [entityId] of smallest) {
                if (types.every(t => this.hasComponent(entityId, t))) {
                    results.push(entityId);
                }
            }
            return results;
        }

        emit(event, data) {
            this.events.push({ event, data });
        }

        getEvents(event) {
            return this.events.filter(e => e.event === event).map(e => e.data);
        }

        update(dt) {
            this.events = [];
            for (const system of this.systems) {
                system.update(this, dt, gameState);
            }
            for (const entityId of this.toDestroy) {
                this._destroyEntity(entityId);
            }
            this.toDestroy = [];
        }

        get entityCount() { return this.entities.size; }
    }

    // ============================================
    // BASE SYSTEMS
    // ============================================

    const Systems = {
        Movement: {
            name: 'Movement',
            update(world, dt, state) {
                const config = state.cartridge?.config || {};
                for (const id of world.query('Transform', 'Velocity')) {
                    const t = world.getComponent(id, 'Transform');
                    const v = world.getComponent(id, 'Velocity');

                    t.x += v.vx * dt;
                    t.y += v.vy * dt;
                    t.rotation += (v.angularVel || 0) * dt;

                    if (v.drag) {
                        const factor = Math.pow(1 - v.drag, dt * 60);
                        v.vx *= factor;
                        v.vy *= factor;
                    }

                    if (config.gravity) {
                        v.vy += config.gravity * dt;
                    }

                    if (config.screenWrap !== false) {
                        const m = 50;
                        if (t.x < -m) t.x = canvas.width + m;
                        if (t.x > canvas.width + m) t.x = -m;
                        if (t.y < -m) t.y = canvas.height + m;
                        if (t.y > canvas.height + m) t.y = -m;
                    }
                }
            }
        },

        Rendering: {
            name: 'Rendering',
            update(world, dt, state) {
                const entities = world.query('Transform', 'Sprite');
                const sorted = entities.map(id => ({
                    id,
                    t: world.getComponent(id, 'Transform'),
                    s: world.getComponent(id, 'Sprite')
                })).sort((a, b) => (a.s.layer || 0) - (b.s.layer || 0));

                for (const { id, t, s } of sorted) {
                    if (s.visible === false) continue;

                    ctx.save();
                    ctx.translate(t.x, t.y);
                    ctx.rotate(t.rotation || 0);
                    ctx.scale(t.scale || 1, t.scale || 1);

                    const health = world.getComponent(id, 'Health');
                    if (health?.invulnerable > 0 && Math.floor(health.invulnerable * 10) % 2 === 0) {
                        ctx.globalAlpha = 0.3;
                    }

                    ctx.fillStyle = s.color || '#fff';
                    ctx.strokeStyle = s.color || '#fff';
                    ctx.lineWidth = s.lineWidth || 2;

                    this.drawShape(ctx, s, id);
                    ctx.restore();
                }
            },

            drawShape(ctx, s, id) {
                const size = s.size || 10;
                switch (s.shape) {
                    case 'triangle':
                        ctx.beginPath();
                        ctx.moveTo(0, -size);
                        ctx.lineTo(-size * 0.7, size * 0.7);
                        ctx.lineTo(size * 0.7, size * 0.7);
                        ctx.closePath();
                        s.fill ? ctx.fill() : ctx.stroke();
                        break;
                    case 'circle':
                        ctx.beginPath();
                        ctx.arc(0, 0, size, 0, Math.PI * 2);
                        s.fill ? ctx.fill() : ctx.stroke();
                        break;
                    case 'square':
                        s.fill ? ctx.fillRect(-size, -size, size * 2, size * 2)
                               : ctx.strokeRect(-size, -size, size * 2, size * 2);
                        break;
                    case 'diamond':
                        ctx.beginPath();
                        ctx.moveTo(0, -size);
                        ctx.lineTo(size, 0);
                        ctx.lineTo(0, size);
                        ctx.lineTo(-size, 0);
                        ctx.closePath();
                        s.fill ? ctx.fill() : ctx.stroke();
                        break;
                    case 'asteroid':
                        ctx.beginPath();
                        const points = 8;
                        for (let i = 0; i < points; i++) {
                            const angle = (i / points) * Math.PI * 2;
                            const variance = 0.7 + Math.sin(id * 1000 + i * 1.5) * 0.3;
                            const r = size * variance;
                            if (i === 0) ctx.moveTo(Math.cos(angle) * r, Math.sin(angle) * r);
                            else ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
                        }
                        ctx.closePath();
                        ctx.stroke();
                        break;
                    case 'invader':
                        ctx.beginPath();
                        ctx.moveTo(-size, -size * 0.5);
                        ctx.lineTo(-size * 0.6, -size);
                        ctx.lineTo(-size * 0.3, -size * 0.5);
                        ctx.lineTo(size * 0.3, -size * 0.5);
                        ctx.lineTo(size * 0.6, -size);
                        ctx.lineTo(size, -size * 0.5);
                        ctx.lineTo(size, size * 0.5);
                        ctx.lineTo(size * 0.6, size);
                        ctx.lineTo(-size * 0.6, size);
                        ctx.lineTo(-size, size * 0.5);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case 'paddle':
                        const w = s.width || size * 4;
                        const h = s.height || size;
                        ctx.fillRect(-w/2, -h/2, w, h);
                        break;
                    case 'brick':
                        const bw = s.width || size * 2;
                        const bh = s.height || size;
                        ctx.fillRect(-bw/2, -bh/2, bw, bh);
                        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                        ctx.strokeRect(-bw/2, -bh/2, bw, bh);
                        break;
                    default:
                        ctx.beginPath();
                        ctx.arc(0, 0, size, 0, Math.PI * 2);
                        ctx.fill();
                }
            }
        },

        Collision: {
            name: 'Collision',
            collisions: [],
            update(world, dt, state) {
                this.collisions = [];
                const entities = world.query('Transform', 'Collider');
                const cellSize = 100;
                const grid = new Map();

                for (const id of entities) {
                    const t = world.getComponent(id, 'Transform');
                    const c = world.getComponent(id, 'Collider');
                    if (!c.active) continue;

                    const cellX = Math.floor(t.x / cellSize);
                    const cellY = Math.floor(t.y / cellSize);

                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            const key = `${cellX + dx},${cellY + dy}`;
                            if (!grid.has(key)) grid.set(key, []);

                            for (const otherId of grid.get(key)) {
                                if (otherId === id) continue;
                                const ot = world.getComponent(otherId, 'Transform');
                                const oc = world.getComponent(otherId, 'Collider');

                                if (!c.mask?.includes(oc.group) && !oc.mask?.includes(c.group)) continue;

                                const dx2 = t.x - ot.x;
                                const dy2 = t.y - ot.y;
                                const dist = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                                const minDist = ((c.radius || 10) + (oc.radius || 10)) * (t.scale || 1);

                                if (dist < minDist) {
                                    this.collisions.push({ a: id, b: otherId, overlap: minDist - dist });
                                    world.emit('collision', { a: id, b: otherId });
                                }
                            }
                        }
                    }

                    const key = `${cellX},${cellY}`;
                    if (!grid.has(key)) grid.set(key, []);
                    grid.get(key).push(id);
                }
            }
        },

        Lifetime: {
            name: 'Lifetime',
            update(world, dt) {
                for (const id of world.query('Lifetime')) {
                    const l = world.getComponent(id, 'Lifetime');
                    l.remaining -= dt;
                    if (l.remaining <= 0) world.destroyEntity(id);

                    const s = world.getComponent(id, 'Sprite');
                    if (s && l.initial) {
                        s.opacity = Math.max(0, l.remaining / l.initial);
                    }
                }
            }
        },

        HealthRegen: {
            name: 'HealthRegen',
            update(world, dt) {
                for (const id of world.query('Health')) {
                    const h = world.getComponent(id, 'Health');
                    if (h.invulnerable > 0) h.invulnerable -= dt;
                }
            }
        }
    };

    // ============================================
    // GAME-SPECIFIC SYSTEMS
    // ============================================

    const GameSystems = {
        PlayerShip: {
            name: 'PlayerShip',
            update(world, dt, state) {
                const player = world.query('Player')[0];
                if (!player || state.gameOver || state.paused) return;

                const t = world.getComponent(player, 'Transform');
                const v = world.getComponent(player, 'Velocity');
                const p = world.getComponent(player, 'Player');
                const config = p.config || {};

                const thrust = config.thrust || 400;
                const rotSpeed = config.rotSpeed || 4;

                if (keys['ArrowLeft'] || keys['KeyA']) t.rotation -= rotSpeed * dt;
                if (keys['ArrowRight'] || keys['KeyD']) t.rotation += rotSpeed * dt;

                if (keys['ArrowUp'] || keys['KeyW']) {
                    v.vx += Math.sin(t.rotation) * thrust * dt;
                    v.vy -= Math.cos(t.rotation) * thrust * dt;
                }

                const maxSpeed = config.maxSpeed || 300;
                const speed = Math.sqrt(v.vx ** 2 + v.vy ** 2);
                if (speed > maxSpeed) {
                    v.vx = (v.vx / speed) * maxSpeed;
                    v.vy = (v.vy / speed) * maxSpeed;
                }

                p.fireCooldown = (p.fireCooldown || 0) - dt;
                if (keys['Space'] && p.fireCooldown <= 0) {
                    p.fireCooldown = config.fireRate || 0.15;
                    spawnBullet(world, t.x + Math.sin(t.rotation) * 20,
                        t.y - Math.cos(t.rotation) * 20, t.rotation, 'player', state);
                }
            }
        },

        PlayerPaddle: {
            name: 'PlayerPaddle',
            update(world, dt, state) {
                const player = world.query('Player')[0];
                if (!player || state.gameOver || state.paused) return;

                const t = world.getComponent(player, 'Transform');
                const p = world.getComponent(player, 'Player');
                const speed = p.config?.speed || 500;
                const bounds = p.config?.bounds || { min: 50, max: canvas.width - 50 };

                if (keys['ArrowLeft'] || keys['KeyA']) t.x -= speed * dt;
                if (keys['ArrowRight'] || keys['KeyD']) t.x += speed * dt;

                t.x = Math.max(bounds.min, Math.min(bounds.max, t.x));
            }
        },

        PlayerSnake: {
            name: 'PlayerSnake',
            update(world, dt, state) {
                const head = world.query('SnakeHead')[0];
                if (!head || state.gameOver || state.paused) return;

                const snake = world.getComponent(head, 'SnakeHead');
                const t = world.getComponent(head, 'Transform');

                // Direction input
                if ((keys['ArrowUp'] || keys['KeyW']) && snake.dir !== 'down') snake.nextDir = 'up';
                if ((keys['ArrowDown'] || keys['KeyS']) && snake.dir !== 'up') snake.nextDir = 'down';
                if ((keys['ArrowLeft'] || keys['KeyA']) && snake.dir !== 'right') snake.nextDir = 'left';
                if ((keys['ArrowRight'] || keys['KeyD']) && snake.dir !== 'left') snake.nextDir = 'right';

                snake.moveTimer = (snake.moveTimer || 0) + dt;
                if (snake.moveTimer >= (snake.moveInterval || 0.1)) {
                    snake.moveTimer = 0;
                    snake.dir = snake.nextDir || snake.dir;

                    // Store previous position
                    const prevX = t.x, prevY = t.y;

                    // Move head
                    const step = snake.gridSize || 20;
                    switch (snake.dir) {
                        case 'up': t.y -= step; break;
                        case 'down': t.y += step; break;
                        case 'left': t.x -= step; break;
                        case 'right': t.x += step; break;
                    }

                    // Check wall collision
                    if (t.x < 0 || t.x >= canvas.width || t.y < 0 || t.y >= canvas.height) {
                        state.gameOver = true;
                        return;
                    }

                    // Move body segments
                    const segments = world.query('SnakeBody').sort((a, b) => {
                        return world.getComponent(a, 'SnakeBody').index -
                               world.getComponent(b, 'SnakeBody').index;
                    });

                    let px = prevX, py = prevY;
                    for (const seg of segments) {
                        const st = world.getComponent(seg, 'Transform');
                        const spx = st.x, spy = st.y;
                        st.x = px;
                        st.y = py;
                        px = spx;
                        py = spy;

                        // Self collision
                        if (st.x === t.x && st.y === t.y) {
                            state.gameOver = true;
                            return;
                        }
                    }

                    // Check food collision
                    for (const food of world.query('Food')) {
                        const ft = world.getComponent(food, 'Transform');
                        if (Math.abs(ft.x - t.x) < step/2 && Math.abs(ft.y - t.y) < step/2) {
                            world.destroyEntity(food);
                            state.score += 10;
                            snake.length = (snake.length || 3) + 1;

                            // Add new body segment
                            const newSeg = world.createEntity();
                            world.addComponent(newSeg, 'Transform', { x: px, y: py });
                            world.addComponent(newSeg, 'Sprite', {
                                shape: 'square', color: '#00dd66', size: step/2 - 2, fill: true
                            });
                            world.addComponent(newSeg, 'SnakeBody', { index: segments.length });

                            // Spawn new food
                            spawnFood(world, state);
                        }
                    }
                }
            }
        },

        EnemyAI: {
            name: 'EnemyAI',
            update(world, dt, state) {
                const player = world.query('Player')[0];
                if (!player) return;
                const pt = world.getComponent(player, 'Transform');

                for (const id of world.query('Enemy', 'Transform', 'Velocity')) {
                    const ai = world.getComponent(id, 'Enemy');
                    const t = world.getComponent(id, 'Transform');
                    const v = world.getComponent(id, 'Velocity');

                    if (ai.type === 'chase') {
                        const dx = pt.x - t.x;
                        const dy = pt.y - t.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const speed = ai.speed || 80;

                        if (dist > 0) {
                            v.vx += (dx / dist) * speed * dt;
                            v.vy += (dy / dist) * speed * dt;
                            t.rotation = Math.atan2(dy, dx) + Math.PI / 2;
                        }

                        // Shooting
                        ai.fireCooldown = (ai.fireCooldown || 0) - dt;
                        if (ai.fireCooldown <= 0 && dist < 400) {
                            ai.fireCooldown = ai.fireRate || 2;
                            spawnBullet(world, t.x, t.y, t.rotation, 'enemy', state);
                        }
                    } else if (ai.type === 'invader') {
                        // Space invaders movement handled by formation
                    }
                }
            }
        },

        InvaderFormation: {
            name: 'InvaderFormation',
            update(world, dt, state) {
                if (!state.formation) return;
                const f = state.formation;

                f.timer = (f.timer || 0) + dt;
                if (f.timer >= f.moveInterval) {
                    f.timer = 0;

                    const invaders = world.query('Invader');
                    let hitEdge = false;

                    // Check edges
                    for (const id of invaders) {
                        const t = world.getComponent(id, 'Transform');
                        if ((f.dir > 0 && t.x > canvas.width - 50) ||
                            (f.dir < 0 && t.x < 50)) {
                            hitEdge = true;
                            break;
                        }
                    }

                    // Move invaders
                    for (const id of invaders) {
                        const t = world.getComponent(id, 'Transform');
                        if (hitEdge) {
                            t.y += f.dropAmount || 20;
                        } else {
                            t.x += f.dir * (f.stepSize || 20);
                        }
                    }

                    if (hitEdge) {
                        f.dir *= -1;
                        f.moveInterval = Math.max(0.1, f.moveInterval * 0.95);
                    }

                    // Random shooting
                    if (Math.random() < 0.3 && invaders.length > 0) {
                        const shooter = invaders[Math.floor(Math.random() * invaders.length)];
                        const t = world.getComponent(shooter, 'Transform');
                        spawnBullet(world, t.x, t.y + 15, Math.PI, 'enemy', state);
                    }
                }
            }
        },

        BallPhysics: {
            name: 'BallPhysics',
            update(world, dt, state) {
                for (const id of world.query('Ball', 'Transform', 'Velocity')) {
                    const t = world.getComponent(id, 'Transform');
                    const v = world.getComponent(id, 'Velocity');
                    const ball = world.getComponent(id, 'Ball');

                    // Wall bouncing
                    if (t.x < 10 || t.x > canvas.width - 10) {
                        v.vx *= -1;
                        t.x = Math.max(10, Math.min(canvas.width - 10, t.x));
                    }
                    if (t.y < 10) {
                        v.vy *= -1;
                        t.y = 10;
                    }

                    // Bottom - lose life
                    if (t.y > canvas.height + 20) {
                        state.lives--;
                        if (state.lives <= 0) {
                            state.gameOver = true;
                        } else {
                            // Reset ball
                            t.x = canvas.width / 2;
                            t.y = canvas.height - 100;
                            v.vx = (Math.random() - 0.5) * 200;
                            v.vy = -300;
                        }
                    }

                    // Paddle collision
                    const paddle = world.query('Player')[0];
                    if (paddle) {
                        const pt = world.getComponent(paddle, 'Transform');
                        const ps = world.getComponent(paddle, 'Sprite');
                        const pw = ps.width || 80;
                        const ph = ps.height || 15;

                        if (t.y > pt.y - ph && t.y < pt.y + ph &&
                            t.x > pt.x - pw/2 && t.x < pt.x + pw/2 && v.vy > 0) {
                            v.vy *= -1;
                            // Angle based on hit position
                            const offset = (t.x - pt.x) / (pw / 2);
                            v.vx = offset * 300;
                            t.y = pt.y - ph;
                        }
                    }

                    // Brick collision
                    for (const brick of world.query('Brick')) {
                        const bt = world.getComponent(brick, 'Transform');
                        const bs = world.getComponent(brick, 'Sprite');
                        const bw = bs.width || 60;
                        const bh = bs.height || 20;

                        if (t.x > bt.x - bw/2 - 5 && t.x < bt.x + bw/2 + 5 &&
                            t.y > bt.y - bh/2 - 5 && t.y < bt.y + bh/2 + 5) {

                            // Determine collision side
                            const overlapLeft = (t.x + 5) - (bt.x - bw/2);
                            const overlapRight = (bt.x + bw/2) - (t.x - 5);
                            const overlapTop = (t.y + 5) - (bt.y - bh/2);
                            const overlapBottom = (bt.y + bh/2) - (t.y - 5);

                            const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

                            if (minOverlap === overlapLeft || minOverlap === overlapRight) {
                                v.vx *= -1;
                            } else {
                                v.vy *= -1;
                            }

                            world.destroyEntity(brick);
                            state.score += 10;

                            // Check win
                            if (world.query('Brick').length <= 1) {
                                state.win = true;
                                state.gameOver = true;
                            }
                            break;
                        }
                    }
                }
            }
        },

        AsteroidSpawner: {
            name: 'AsteroidSpawner',
            update(world, dt, state) {
                const asteroids = world.query('Asteroid');
                const enemies = world.query('Enemy');

                if (asteroids.length === 0 && enemies.length === 0 && !state.gameOver) {
                    state.waveTimer = (state.waveTimer || 0) + dt;
                    if (state.waveTimer > 2) {
                        state.waveTimer = 0;
                        state.wave = (state.wave || 1) + 1;
                        spawnWave(world, state);
                    }
                }
            }
        },

        GeometrySpawner: {
            name: 'GeometrySpawner',
            update(world, dt, state) {
                if (state.gameOver || state.paused) return;

                state.spawnTimer = (state.spawnTimer || 0) + dt;
                const spawnRate = Math.max(0.2, 2 - state.score / 500);

                if (state.spawnTimer >= spawnRate) {
                    state.spawnTimer = 0;
                    spawnGeometryEnemy(world, state);
                }
            }
        },

        TwinStickPlayer: {
            name: 'TwinStickPlayer',
            update(world, dt, state) {
                const player = world.query('Player')[0];
                if (!player || state.gameOver || state.paused) return;

                const t = world.getComponent(player, 'Transform');
                const v = world.getComponent(player, 'Velocity');
                const p = world.getComponent(player, 'Player');
                const speed = p.config?.speed || 250;

                // Movement
                v.vx = 0; v.vy = 0;
                if (keys['ArrowUp'] || keys['KeyW']) v.vy = -speed;
                if (keys['ArrowDown'] || keys['KeyS']) v.vy = speed;
                if (keys['ArrowLeft'] || keys['KeyA']) v.vx = -speed;
                if (keys['ArrowRight'] || keys['KeyD']) v.vx = speed;

                // Bounds
                t.x = Math.max(20, Math.min(canvas.width - 20, t.x));
                t.y = Math.max(20, Math.min(canvas.height - 20, t.y));

                // Auto-fire towards nearest enemy
                p.fireCooldown = (p.fireCooldown || 0) - dt;
                if (p.fireCooldown <= 0) {
                    const enemies = world.query('Enemy');
                    if (enemies.length > 0) {
                        let nearest = null, minDist = Infinity;
                        for (const e of enemies) {
                            const et = world.getComponent(e, 'Transform');
                            const d = Math.hypot(et.x - t.x, et.y - t.y);
                            if (d < minDist) { minDist = d; nearest = et; }
                        }
                        if (nearest) {
                            p.fireCooldown = p.config?.fireRate || 0.1;
                            const angle = Math.atan2(nearest.y - t.y, nearest.x - t.x);
                            spawnBullet(world, t.x, t.y, angle + Math.PI/2, 'player', state);
                        }
                    }
                }
            }
        },

        MissileDefense: {
            name: 'MissileDefense',
            update(world, dt, state) {
                if (state.gameOver || state.paused) return;

                // Spawn missiles
                state.missileTimer = (state.missileTimer || 0) + dt;
                const rate = Math.max(0.5, 3 - (state.wave || 1) * 0.3);
                if (state.missileTimer >= rate) {
                    state.missileTimer = 0;
                    spawnMissile(world, state);
                }

                // Process missiles hitting cities
                for (const missile of world.query('Missile')) {
                    const t = world.getComponent(missile, 'Transform');
                    if (t.y >= canvas.height - 60) {
                        // Check if hit city
                        for (const city of world.query('City')) {
                            const ct = world.getComponent(city, 'Transform');
                            if (Math.abs(t.x - ct.x) < 40) {
                                world.destroyEntity(city);
                                state.cities = (state.cities || 6) - 1;
                                if (state.cities <= 0) state.gameOver = true;
                            }
                        }
                        spawnExplosion(world, t, '#ff6644');
                        world.destroyEntity(missile);
                    }
                }

                // Click to fire interceptor
                if (state.pendingClick) {
                    const { x, y } = state.pendingClick;
                    state.pendingClick = null;
                    spawnInterceptor(world, x, y, state);
                }
            }
        },

        DamageProcessor: {
            name: 'DamageProcessor',
            update(world, dt, state) {
                for (const { a, b } of Systems.Collision.collisions) {
                    // Player bullet hits enemy/asteroid
                    const aBullet = world.getComponent(a, 'Bullet');
                    const bBullet = world.getComponent(b, 'Bullet');

                    if (aBullet?.owner === 'player') {
                        if (world.hasComponent(b, 'Enemy') || world.hasComponent(b, 'Asteroid') || world.hasComponent(b, 'Invader')) {
                            this.handleHit(world, b, a, state);
                        }
                    }
                    if (bBullet?.owner === 'player') {
                        if (world.hasComponent(a, 'Enemy') || world.hasComponent(a, 'Asteroid') || world.hasComponent(a, 'Invader')) {
                            this.handleHit(world, a, b, state);
                        }
                    }

                    // Enemy bullet hits player
                    if (aBullet?.owner === 'enemy' && world.hasComponent(b, 'Player')) {
                        this.damagePlayer(world, b, state);
                        world.destroyEntity(a);
                    }
                    if (bBullet?.owner === 'enemy' && world.hasComponent(a, 'Player')) {
                        this.damagePlayer(world, a, state);
                        world.destroyEntity(b);
                    }

                    // Player touches enemy/asteroid
                    if (world.hasComponent(a, 'Player') && (world.hasComponent(b, 'Enemy') || world.hasComponent(b, 'Asteroid'))) {
                        this.damagePlayer(world, a, state);
                    }
                    if (world.hasComponent(b, 'Player') && (world.hasComponent(a, 'Enemy') || world.hasComponent(a, 'Asteroid'))) {
                        this.damagePlayer(world, b, state);
                    }
                }
            },

            handleHit(world, target, bullet, state) {
                const sprite = world.getComponent(target, 'Sprite');
                const transform = world.getComponent(target, 'Transform');

                if (world.hasComponent(target, 'Asteroid')) {
                    // Split asteroid
                    if (sprite.size > 15) {
                        for (let i = 0; i < 2; i++) {
                            spawnAsteroid(world, transform.x, transform.y, sprite.size * 0.5, state);
                        }
                    }
                    state.score = (state.score || 0) + 25;
                } else {
                    state.score = (state.score || 0) + 100;
                }

                spawnExplosion(world, transform, sprite.color);
                world.destroyEntity(target);
                world.destroyEntity(bullet);
            },

            damagePlayer(world, player, state) {
                const health = world.getComponent(player, 'Health');
                if (!health || health.invulnerable > 0) return;

                health.invulnerable = health.invulnerableTime || 2;
                state.lives = (state.lives || 3) - 1;
                if (state.lives <= 0) state.gameOver = true;
            }
        }
    };

    // ============================================
    // SPAWNER HELPERS
    // ============================================

    function spawnBullet(world, x, y, angle, owner, state) {
        const config = state.cartridge?.config || {};
        const id = world.createEntity();
        const speed = owner === 'player' ? (config.playerBulletSpeed || 500) : (config.enemyBulletSpeed || 300);

        world.addComponent(id, 'Transform', { x, y, rotation: angle });
        world.addComponent(id, 'Velocity', {
            vx: Math.sin(angle) * speed,
            vy: -Math.cos(angle) * speed
        });
        world.addComponent(id, 'Sprite', {
            shape: 'circle', size: 3, fill: true,
            color: owner === 'player' ? '#ffff44' : '#ff6666'
        });
        world.addComponent(id, 'Collider', {
            radius: 3,
            group: owner + 'Bullet',
            mask: owner === 'player' ? ['enemy', 'asteroid', 'invader'] : ['player'],
            active: true
        });
        world.addComponent(id, 'Bullet', { owner });
        world.addComponent(id, 'Lifetime', { remaining: 2, initial: 2 });
    }

    function spawnExplosion(world, transform, color = '#ffaa44') {
        for (let i = 0; i < 8; i++) {
            const id = world.createEntity();
            const angle = (i / 8) * Math.PI * 2;
            const speed = 50 + Math.random() * 100;

            world.addComponent(id, 'Transform', { x: transform.x, y: transform.y });
            world.addComponent(id, 'Velocity', {
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                drag: 2
            });
            world.addComponent(id, 'Sprite', {
                shape: 'circle', size: 2 + Math.random() * 3,
                color, fill: true
            });
            world.addComponent(id, 'Lifetime', { remaining: 0.3 + Math.random() * 0.3, initial: 0.5 });
        }
    }

    function spawnAsteroid(world, x, y, size, state) {
        const id = world.createEntity();
        const angle = Math.random() * Math.PI * 2;
        const speed = 30 + Math.random() * 70;

        world.addComponent(id, 'Transform', { x, y, rotation: Math.random() * Math.PI * 2 });
        world.addComponent(id, 'Velocity', {
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            angularVel: (Math.random() - 0.5) * 2
        });
        world.addComponent(id, 'Sprite', { shape: 'asteroid', color: '#888899', size });
        world.addComponent(id, 'Collider', {
            radius: size, group: 'asteroid',
            mask: ['player', 'playerBullet'], active: true
        });
        world.addComponent(id, 'Asteroid', { size });
    }

    function spawnWave(world, state) {
        const wave = state.wave || 1;
        const numAsteroids = 5 + wave * 2;
        const numEnemies = Math.floor(wave / 2);

        for (let i = 0; i < numAsteroids; i++) {
            const edge = Math.floor(Math.random() * 4);
            let x, y;
            switch (edge) {
                case 0: x = Math.random() * canvas.width; y = -50; break;
                case 1: x = canvas.width + 50; y = Math.random() * canvas.height; break;
                case 2: x = Math.random() * canvas.width; y = canvas.height + 50; break;
                default: x = -50; y = Math.random() * canvas.height;
            }
            spawnAsteroid(world, x, y, 30 + Math.random() * 20, state);
        }

        for (let i = 0; i < numEnemies; i++) {
            const x = Math.random() * canvas.width;
            const y = -50;
            const id = world.createEntity();
            world.addComponent(id, 'Transform', { x, y, rotation: Math.PI });
            world.addComponent(id, 'Velocity', { vx: 0, vy: 0, drag: 0.8 });
            world.addComponent(id, 'Sprite', { shape: 'diamond', color: '#ff4466', size: 12 });
            world.addComponent(id, 'Collider', { radius: 12, group: 'enemy', mask: ['player', 'playerBullet'], active: true });
            world.addComponent(id, 'Enemy', { type: 'chase', speed: 80, fireRate: 1.5 + Math.random() });
            world.addComponent(id, 'Health', { current: 50, max: 50, invulnerable: 0 });
        }
    }

    function spawnFood(world, state) {
        const gridSize = 20;
        const x = Math.floor(Math.random() * (canvas.width / gridSize)) * gridSize + gridSize / 2;
        const y = Math.floor(Math.random() * (canvas.height / gridSize)) * gridSize + gridSize / 2;

        const id = world.createEntity();
        world.addComponent(id, 'Transform', { x, y });
        world.addComponent(id, 'Sprite', { shape: 'circle', color: '#ff4444', size: 6, fill: true });
        world.addComponent(id, 'Food', {});
    }

    function spawnGeometryEnemy(world, state) {
        const edge = Math.floor(Math.random() * 4);
        let x, y, vx, vy;
        const speed = 50 + Math.random() * 100;

        switch (edge) {
            case 0: x = Math.random() * canvas.width; y = -20; vx = 0; vy = speed; break;
            case 1: x = canvas.width + 20; y = Math.random() * canvas.height; vx = -speed; vy = 0; break;
            case 2: x = Math.random() * canvas.width; y = canvas.height + 20; vx = 0; vy = -speed; break;
            default: x = -20; y = Math.random() * canvas.height; vx = speed; vy = 0;
        }

        const shapes = ['diamond', 'square', 'triangle'];
        const colors = ['#ff4466', '#ff8844', '#ffaa00', '#aa44ff'];

        const id = world.createEntity();
        world.addComponent(id, 'Transform', { x, y, rotation: Math.random() * Math.PI * 2 });
        world.addComponent(id, 'Velocity', { vx, vy, angularVel: (Math.random() - 0.5) * 3 });
        world.addComponent(id, 'Sprite', {
            shape: shapes[Math.floor(Math.random() * shapes.length)],
            color: colors[Math.floor(Math.random() * colors.length)],
            size: 10 + Math.random() * 10,
            fill: true
        });
        world.addComponent(id, 'Collider', { radius: 12, group: 'enemy', mask: ['player', 'playerBullet'], active: true });
        world.addComponent(id, 'Enemy', { type: 'linear' });
        world.addComponent(id, 'Lifetime', { remaining: 15, initial: 15 });
    }

    function spawnMissile(world, state) {
        const x = Math.random() * canvas.width;
        const targetX = 50 + Math.random() * (canvas.width - 100);
        const speed = 50 + (state.wave || 1) * 10;

        const id = world.createEntity();
        const angle = Math.atan2(canvas.height - 60, targetX - x);
        world.addComponent(id, 'Transform', { x, y: 0, rotation: angle + Math.PI/2 });
        world.addComponent(id, 'Velocity', {
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed
        });
        world.addComponent(id, 'Sprite', { shape: 'triangle', color: '#ff4444', size: 8 });
        world.addComponent(id, 'Collider', { radius: 8, group: 'missile', mask: ['interceptor'], active: true });
        world.addComponent(id, 'Missile', { targetX });
    }

    function spawnInterceptor(world, targetX, targetY, state) {
        const startX = canvas.width / 2;
        const startY = canvas.height - 30;
        const dx = targetX - startX;
        const dy = targetY - startY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const speed = 400;

        const id = world.createEntity();
        world.addComponent(id, 'Transform', { x: startX, y: startY });
        world.addComponent(id, 'Velocity', { vx: (dx / dist) * speed, vy: (dy / dist) * speed });
        world.addComponent(id, 'Sprite', { shape: 'circle', color: '#44ff44', size: 4, fill: true });
        world.addComponent(id, 'Collider', { radius: 20, group: 'interceptor', mask: ['missile'], active: true });
        world.addComponent(id, 'Interceptor', { targetX, targetY, explodeRadius: 40 });

        // Check when reaches target
        const checkId = world.createEntity();
        world.addComponent(checkId, 'InterceptorCheck', { interceptor: id, targetX, targetY });
    }

    // ============================================
    // CARTRIDGE LIBRARY
    // ============================================

    const CARTRIDGE_LIBRARY = [
        {
            meta: {
                id: 'asteroid-blaster',
                title: 'Asteroid Blaster',
                description: 'Classic asteroid shooter with enemies. Destroy asteroids and hostile ships to survive!',
                genre: 'Shooter',
                author: 'ECS Console',
                version: '1.0',
                difficulty: 'Medium'
            },
            config: {
                screenWrap: true,
                playerBulletSpeed: 500,
                enemyBulletSpeed: 300
            },
            controls: {
                'W / ': 'Thrust',
                'A / ': 'Rotate Left',
                'D / ': 'Rotate Right',
                'Space': 'Fire'
            },
            hud: ['score', 'lives', 'wave'],
            systems: ['PlayerShip', 'EnemyAI', 'AsteroidSpawner', 'DamageProcessor'],
            setup(world, state) {
                state.score = 0;
                state.lives = 3;
                state.wave = 1;

                // Player
                const player = world.createEntity();
                world.addComponent(player, 'Transform', { x: canvas.width/2, y: canvas.height/2, rotation: 0 });
                world.addComponent(player, 'Velocity', { vx: 0, vy: 0, drag: 0.5 });
                world.addComponent(player, 'Sprite', { shape: 'triangle', color: '#00ffcc', size: 15 });
                world.addComponent(player, 'Collider', { radius: 15, group: 'player', mask: ['enemy', 'asteroid', 'enemyBullet'], active: true });
                world.addComponent(player, 'Health', { current: 3, max: 3, invulnerable: 0, invulnerableTime: 2 });
                world.addComponent(player, 'Player', { config: { thrust: 400, rotSpeed: 4, fireRate: 0.15 } });

                spawnWave(world, state);
            },
            preview: { bg: '#000', shapes: [
                { type: 'triangle', x: 0.5, y: 0.5, size: 20, color: '#00ffcc', rotation: 0 },
                { type: 'asteroid', x: 0.3, y: 0.3, size: 25, color: '#888' },
                { type: 'asteroid', x: 0.7, y: 0.6, size: 18, color: '#888' },
                { type: 'diamond', x: 0.8, y: 0.2, size: 12, color: '#ff4466' }
            ]}
        },
        {
            meta: {
                id: 'neon-invaders',
                title: 'Neon Invaders',
                description: 'Retro space invaders with a neon twist. Stop the alien invasion!',
                genre: 'Arcade',
                author: 'ECS Console',
                version: '1.0',
                difficulty: 'Easy'
            },
            config: {
                screenWrap: false,
                playerBulletSpeed: 600
            },
            controls: {
                'A / ': 'Move Left',
                'D / ': 'Move Right',
                'Space': 'Fire'
            },
            hud: ['score', 'lives'],
            systems: ['PlayerShip', 'InvaderFormation', 'DamageProcessor'],
            setup(world, state) {
                state.score = 0;
                state.lives = 3;
                state.formation = { dir: 1, moveInterval: 0.8, stepSize: 15, dropAmount: 20, timer: 0 };

                // Player
                const player = world.createEntity();
                world.addComponent(player, 'Transform', { x: canvas.width/2, y: canvas.height - 50 });
                world.addComponent(player, 'Velocity', { vx: 0, vy: 0 });
                world.addComponent(player, 'Sprite', { shape: 'triangle', color: '#00ffcc', size: 15 });
                world.addComponent(player, 'Collider', { radius: 15, group: 'player', mask: ['enemyBullet'], active: true });
                world.addComponent(player, 'Health', { current: 3, max: 3, invulnerable: 0, invulnerableTime: 2 });
                world.addComponent(player, 'Player', { config: { thrust: 0, rotSpeed: 0, fireRate: 0.3 } });

                // Invaders
                const colors = ['#ff4466', '#ff8844', '#ffaa00', '#44ff88', '#4488ff'];
                for (let row = 0; row < 5; row++) {
                    for (let col = 0; col < 11; col++) {
                        const id = world.createEntity();
                        world.addComponent(id, 'Transform', {
                            x: 80 + col * 55,
                            y: 80 + row * 45
                        });
                        world.addComponent(id, 'Sprite', {
                            shape: 'invader', color: colors[row], size: 15, fill: true
                        });
                        world.addComponent(id, 'Collider', {
                            radius: 15, group: 'invader', mask: ['playerBullet'], active: true
                        });
                        world.addComponent(id, 'Invader', { row, col });
                    }
                }
            },
            preview: { bg: '#000', shapes: [
                { type: 'invader', x: 0.3, y: 0.25, size: 15, color: '#ff4466' },
                { type: 'invader', x: 0.5, y: 0.25, size: 15, color: '#ff4466' },
                { type: 'invader', x: 0.7, y: 0.25, size: 15, color: '#ff4466' },
                { type: 'invader', x: 0.4, y: 0.4, size: 15, color: '#ffaa00' },
                { type: 'invader', x: 0.6, y: 0.4, size: 15, color: '#ffaa00' },
                { type: 'triangle', x: 0.5, y: 0.85, size: 15, color: '#00ffcc' }
            ]}
        },
        {
            meta: {
                id: 'snake-overflow',
                title: 'Snake Overflow',
                description: 'Classic snake game. Eat food to grow, but don\'t hit yourself!',
                genre: 'Puzzle',
                author: 'ECS Console',
                version: '1.0',
                difficulty: 'Easy'
            },
            config: { screenWrap: false },
            controls: {
                'W / ': 'Move Up',
                'S / ': 'Move Down',
                'A / ': 'Move Left',
                'D / ': 'Move Right'
            },
            hud: ['score'],
            systems: ['PlayerSnake'],
            setup(world, state) {
                state.score = 0;
                const gridSize = 20;
                const startX = Math.floor(canvas.width / 2 / gridSize) * gridSize + gridSize/2;
                const startY = Math.floor(canvas.height / 2 / gridSize) * gridSize + gridSize/2;

                // Head
                const head = world.createEntity();
                world.addComponent(head, 'Transform', { x: startX, y: startY });
                world.addComponent(head, 'Sprite', { shape: 'square', color: '#00ff88', size: gridSize/2 - 2, fill: true });
                world.addComponent(head, 'SnakeHead', {
                    dir: 'right', nextDir: 'right', length: 3,
                    gridSize, moveInterval: 0.12, moveTimer: 0
                });

                // Initial body
                for (let i = 1; i <= 2; i++) {
                    const seg = world.createEntity();
                    world.addComponent(seg, 'Transform', { x: startX - i * gridSize, y: startY });
                    world.addComponent(seg, 'Sprite', { shape: 'square', color: '#00dd66', size: gridSize/2 - 2, fill: true });
                    world.addComponent(seg, 'SnakeBody', { index: i - 1 });
                }

                spawnFood(world, state);
            },
            preview: { bg: '#001100', shapes: [
                { type: 'square', x: 0.5, y: 0.5, size: 8, color: '#00ff88', fill: true },
                { type: 'square', x: 0.45, y: 0.5, size: 8, color: '#00dd66', fill: true },
                { type: 'square', x: 0.4, y: 0.5, size: 8, color: '#00dd66', fill: true },
                { type: 'square', x: 0.35, y: 0.5, size: 8, color: '#00dd66', fill: true },
                { type: 'circle', x: 0.7, y: 0.4, size: 6, color: '#ff4444', fill: true }
            ]}
        },
        {
            meta: {
                id: 'brick-breaker',
                title: 'Brick Breaker',
                description: 'Break all the bricks with your paddle and ball!',
                genre: 'Arcade',
                author: 'ECS Console',
                version: '1.0',
                difficulty: 'Medium'
            },
            config: { screenWrap: false },
            controls: {
                'A / ': 'Move Left',
                'D / ': 'Move Right'
            },
            hud: ['score', 'lives'],
            systems: ['PlayerPaddle', 'BallPhysics'],
            setup(world, state) {
                state.score = 0;
                state.lives = 3;

                // Paddle
                const paddle = world.createEntity();
                world.addComponent(paddle, 'Transform', { x: canvas.width/2, y: canvas.height - 40 });
                world.addComponent(paddle, 'Velocity', { vx: 0, vy: 0 });
                world.addComponent(paddle, 'Sprite', { shape: 'paddle', color: '#00ffcc', size: 10, width: 80, height: 15, fill: true });
                world.addComponent(paddle, 'Player', { config: { speed: 500, bounds: { min: 50, max: canvas.width - 50 } } });

                // Ball
                const ball = world.createEntity();
                world.addComponent(ball, 'Transform', { x: canvas.width/2, y: canvas.height - 100 });
                world.addComponent(ball, 'Velocity', { vx: 150, vy: -300 });
                world.addComponent(ball, 'Sprite', { shape: 'circle', color: '#ffffff', size: 8, fill: true });
                world.addComponent(ball, 'Ball', {});

                // Bricks
                const colors = ['#ff4466', '#ff8844', '#ffaa00', '#44ff88', '#4488ff', '#aa44ff'];
                const brickW = 60, brickH = 20, padding = 5;
                const cols = Math.floor((canvas.width - 100) / (brickW + padding));
                const startX = (canvas.width - cols * (brickW + padding)) / 2 + brickW/2;

                for (let row = 0; row < 6; row++) {
                    for (let col = 0; col < cols; col++) {
                        const brick = world.createEntity();
                        world.addComponent(brick, 'Transform', {
                            x: startX + col * (brickW + padding),
                            y: 60 + row * (brickH + padding)
                        });
                        world.addComponent(brick, 'Sprite', {
                            shape: 'brick', color: colors[row], size: 10,
                            width: brickW, height: brickH, fill: true
                        });
                        world.addComponent(brick, 'Brick', { row, col });
                    }
                }
            },
            preview: { bg: '#000', shapes: [
                { type: 'brick', x: 0.3, y: 0.2, size: 10, color: '#ff4466', fill: true },
                { type: 'brick', x: 0.5, y: 0.2, size: 10, color: '#ff4466', fill: true },
                { type: 'brick', x: 0.7, y: 0.2, size: 10, color: '#ff4466', fill: true },
                { type: 'brick', x: 0.4, y: 0.3, size: 10, color: '#ffaa00', fill: true },
                { type: 'brick', x: 0.6, y: 0.3, size: 10, color: '#ffaa00', fill: true },
                { type: 'circle', x: 0.5, y: 0.6, size: 8, color: '#fff', fill: true },
                { type: 'paddle', x: 0.5, y: 0.9, size: 10, color: '#00ffcc', fill: true }
            ]}
        },
        {
            meta: {
                id: 'geometry-swarm',
                title: 'Geometry Swarm',
                description: 'Twin-stick survival shooter. How long can you survive the geometric onslaught?',
                genre: 'Shooter',
                author: 'ECS Console',
                version: '1.0',
                difficulty: 'Hard'
            },
            config: { screenWrap: false },
            controls: {
                'WASD': 'Move',
                'Auto': 'Fire at nearest enemy'
            },
            hud: ['score', 'lives'],
            systems: ['TwinStickPlayer', 'GeometrySpawner', 'DamageProcessor'],
            setup(world, state) {
                state.score = 0;
                state.lives = 3;
                state.spawnTimer = 0;

                // Player
                const player = world.createEntity();
                world.addComponent(player, 'Transform', { x: canvas.width/2, y: canvas.height/2 });
                world.addComponent(player, 'Velocity', { vx: 0, vy: 0 });
                world.addComponent(player, 'Sprite', { shape: 'diamond', color: '#00ffcc', size: 12, fill: true });
                world.addComponent(player, 'Collider', { radius: 12, group: 'player', mask: ['enemy'], active: true });
                world.addComponent(player, 'Health', { current: 3, max: 3, invulnerable: 0, invulnerableTime: 2 });
                world.addComponent(player, 'Player', { config: { speed: 250, fireRate: 0.1 } });
            },
            preview: { bg: '#0a0010', shapes: [
                { type: 'diamond', x: 0.5, y: 0.5, size: 15, color: '#00ffcc', fill: true },
                { type: 'diamond', x: 0.2, y: 0.3, size: 12, color: '#ff4466', fill: true },
                { type: 'square', x: 0.8, y: 0.4, size: 10, color: '#ffaa00', fill: true },
                { type: 'triangle', x: 0.3, y: 0.7, size: 10, color: '#aa44ff', fill: true },
                { type: 'diamond', x: 0.7, y: 0.8, size: 10, color: '#ff8844', fill: true }
            ]}
        },
        {
            meta: {
                id: 'missile-defense',
                title: 'Missile Defense',
                description: 'Protect your cities from incoming missiles! Click to launch interceptors.',
                genre: 'Strategy',
                author: 'ECS Console',
                version: '1.0',
                difficulty: 'Medium'
            },
            config: { screenWrap: false },
            controls: {
                'Click': 'Launch interceptor'
            },
            hud: ['score', 'cities', 'wave'],
            systems: ['MissileDefense'],
            setup(world, state) {
                state.score = 0;
                state.cities = 6;
                state.wave = 1;
                state.missileTimer = 0;

                // Cities
                const cityPositions = [0.15, 0.3, 0.45, 0.55, 0.7, 0.85];
                for (const xp of cityPositions) {
                    const city = world.createEntity();
                    world.addComponent(city, 'Transform', { x: canvas.width * xp, y: canvas.height - 30 });
                    world.addComponent(city, 'Sprite', { shape: 'triangle', color: '#44ff88', size: 20, fill: true });
                    world.addComponent(city, 'City', {});
                }

                // Launcher
                const launcher = world.createEntity();
                world.addComponent(launcher, 'Transform', { x: canvas.width/2, y: canvas.height - 20 });
                world.addComponent(launcher, 'Sprite', { shape: 'square', color: '#4488ff', size: 15, fill: true });
            },
            preview: { bg: '#000008', shapes: [
                { type: 'triangle', x: 0.2, y: 0.9, size: 15, color: '#44ff88', fill: true },
                { type: 'triangle', x: 0.5, y: 0.9, size: 15, color: '#44ff88', fill: true },
                { type: 'triangle', x: 0.8, y: 0.9, size: 15, color: '#44ff88', fill: true },
                { type: 'triangle', x: 0.3, y: 0.2, size: 8, color: '#ff4444', rotation: Math.PI },
                { type: 'triangle', x: 0.6, y: 0.35, size: 8, color: '#ff4444', rotation: Math.PI * 0.8 },
                { type: 'circle', x: 0.4, y: 0.5, size: 20, color: '#ff6644', fill: false }
            ]}
        }
    ];

    // ============================================
    // GAME STATE & GLOBALS
    // ============================================

    let canvas, ctx;
    let world = null;
    let gameState = {
        cartridge: null,
        paused: false,
        gameOver: false,
        score: 0,
        lives: 3,
        wave: 1
    };
    let keys = {};
    let selectedCartridge = null;
    let lastTime = 0;
    let frameCount = 0, fpsTime = 0, currentFps = 60;
    let customCartridges = [];

    // ============================================
    // INITIALIZATION
    // ============================================

    function init() {
        canvas = document.getElementById('gameCanvas');
        ctx = canvas.getContext('2d');

        loadCustomCartridges();
        renderCartridgeLibrary();
        initStarsBackground();

        window.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (e.code === 'KeyP' && gameState.cartridge) togglePause();
            if (e.code === 'Escape' && gameState.cartridge) exitToLauncher();
            if (e.code === 'Space') e.preventDefault();
        });
        window.addEventListener('keyup', (e) => keys[e.code] = false);

        canvas.addEventListener('click', (e) => {
            if (gameState.cartridge?.meta.id === 'missile-defense' && !gameState.paused && !gameState.gameOver) {
                const rect = canvas.getBoundingClientRect();
                gameState.pendingClick = {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }
        });

        // Drag and drop for import
        const dropZone = document.getElementById('dropZone');
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });
        dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file) importCartridgeFile(file);
        });

        requestAnimationFrame(gameLoop);
    }

    function initStarsBackground() {
        const starCanvas = document.getElementById('starsBg');
        const starCtx = starCanvas.getContext('2d');
        starCanvas.width = window.innerWidth;
        starCanvas.height = window.innerHeight;

        for (let i = 0; i < 200; i++) {
            const x = Math.random() * starCanvas.width;
            const y = Math.random() * starCanvas.height;
            const size = Math.random() * 1.5;
            const alpha = 0.3 + Math.random() * 0.7;
            starCtx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
            starCtx.beginPath();
            starCtx.arc(x, y, size, 0, Math.PI * 2);
            starCtx.fill();
        }
    }

    // ============================================
    // CARTRIDGE LIBRARY UI
    // ============================================

    function renderCartridgeLibrary() {
        const grid = document.getElementById('cartridgeGrid');
        const allCartridges = [...CARTRIDGE_LIBRARY, ...customCartridges];

        grid.innerHTML = allCartridges.map(cart => `
            <div class="cartridge-card" data-id="${cart.meta.id}" onclick="selectCartridge('${cart.meta.id}')">
                <div class="cartridge-preview">
                    <canvas id="preview-${cart.meta.id}" width="280" height="160"></canvas>
                    <span class="cartridge-genre">${cart.meta.genre}</span>
                </div>
                <div class="cartridge-info">
                    <h3 class="cartridge-title">${cart.meta.title}</h3>
                    <p class="cartridge-description">${cart.meta.description}</p>
                    <div class="cartridge-meta">
                        <span>v${cart.meta.version}</span>
                        <span>${cart.meta.difficulty}</span>
                    </div>
                </div>
            </div>
        `).join('');

        // Render previews
        setTimeout(() => {
            allCartridges.forEach(cart => renderCartridgePreview(cart));
        }, 100);
    }

    function renderCartridgePreview(cart) {
        const previewCanvas = document.getElementById(`preview-${cart.meta.id}`);
        if (!previewCanvas) return;

        const pctx = previewCanvas.getContext('2d');
        const w = previewCanvas.width;
        const h = previewCanvas.height;

        pctx.fillStyle = cart.preview?.bg || '#000';
        pctx.fillRect(0, 0, w, h);

        if (cart.preview?.shapes) {
            for (const shape of cart.preview.shapes) {
                pctx.save();
                pctx.translate(shape.x * w, shape.y * h);
                pctx.rotate(shape.rotation || 0);
                pctx.fillStyle = shape.color;
                pctx.strokeStyle = shape.color;
                pctx.lineWidth = 2;

                const size = shape.size || 10;
                switch (shape.type) {
                    case 'triangle':
                        pctx.beginPath();
                        pctx.moveTo(0, -size);
                        pctx.lineTo(-size * 0.7, size * 0.7);
                        pctx.lineTo(size * 0.7, size * 0.7);
                        pctx.closePath();
                        shape.fill ? pctx.fill() : pctx.stroke();
                        break;
                    case 'circle':
                        pctx.beginPath();
                        pctx.arc(0, 0, size, 0, Math.PI * 2);
                        shape.fill ? pctx.fill() : pctx.stroke();
                        break;
                    case 'square':
                        shape.fill ? pctx.fillRect(-size, -size, size*2, size*2)
                                   : pctx.strokeRect(-size, -size, size*2, size*2);
                        break;
                    case 'diamond':
                        pctx.beginPath();
                        pctx.moveTo(0, -size);
                        pctx.lineTo(size, 0);
                        pctx.lineTo(0, size);
                        pctx.lineTo(-size, 0);
                        pctx.closePath();
                        shape.fill ? pctx.fill() : pctx.stroke();
                        break;
                    case 'asteroid':
                        pctx.beginPath();
                        for (let i = 0; i < 8; i++) {
                            const angle = (i / 8) * Math.PI * 2;
                            const r = size * (0.7 + Math.sin(i * 1.5) * 0.3);
                            if (i === 0) pctx.moveTo(Math.cos(angle) * r, Math.sin(angle) * r);
                            else pctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
                        }
                        pctx.closePath();
                        pctx.stroke();
                        break;
                    case 'invader':
                        pctx.beginPath();
                        pctx.moveTo(-size, -size * 0.5);
                        pctx.lineTo(-size * 0.6, -size);
                        pctx.lineTo(-size * 0.3, -size * 0.5);
                        pctx.lineTo(size * 0.3, -size * 0.5);
                        pctx.lineTo(size * 0.6, -size);
                        pctx.lineTo(size, -size * 0.5);
                        pctx.lineTo(size, size * 0.5);
                        pctx.lineTo(size * 0.6, size);
                        pctx.lineTo(-size * 0.6, size);
                        pctx.lineTo(-size, size * 0.5);
                        pctx.closePath();
                        pctx.fill();
                        break;
                    case 'paddle':
                        pctx.fillRect(-30, -5, 60, 10);
                        break;
                    case 'brick':
                        pctx.fillRect(-25, -8, 50, 16);
                        break;
                }
                pctx.restore();
            }
        }
    }

    function selectCartridge(id) {
        const allCartridges = [...CARTRIDGE_LIBRARY, ...customCartridges];
        selectedCartridge = allCartridges.find(c => c.meta.id === id);

        // Update UI
        document.querySelectorAll('.cartridge-card').forEach(card => {
            card.classList.toggle('selected', card.dataset.id === id);
        });

        if (selectedCartridge) {
            document.getElementById('detailTitle').textContent = selectedCartridge.meta.title;
            document.getElementById('detailDescription').textContent = selectedCartridge.meta.description;

            document.getElementById('detailStats').innerHTML = `
                <div class="stat-box">
                    <div class="stat-label">Genre</div>
                    <div class="stat-value">${selectedCartridge.meta.genre}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Difficulty</div>
                    <div class="stat-value">${selectedCartridge.meta.difficulty}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Version</div>
                    <div class="stat-value">${selectedCartridge.meta.version}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Author</div>
                    <div class="stat-value">${selectedCartridge.meta.author}</div>
                </div>
            `;

            const controlsHtml = Object.entries(selectedCartridge.controls || {})
                .map(([key, action]) => `
                    <div class="control-item">
                        <span class="control-key">${key}</span>
                        <span>${action}</span>
                    </div>
                `).join('');

            document.getElementById('detailControls').innerHTML = `
                <div class="controls-title">Controls</div>
                <div class="control-list">${controlsHtml}</div>
            `;

            document.getElementById('playButton').disabled = false;
            document.getElementById('playButton').innerHTML = `
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                    <polygon points="5,3 19,12 5,21"/>
                </svg>
                PLAY ${selectedCartridge.meta.title.toUpperCase()}
            `;
            document.getElementById('exportButton').disabled = false;
        }
    }

    // ============================================
    // GAME LOOP
    // ============================================

    function gameLoop(timestamp) {
        const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
        lastTime = timestamp;

        frameCount++;
        fpsTime += dt;
        if (fpsTime >= 1) {
            currentFps = frameCount;
            frameCount = 0;
            fpsTime = 0;
        }

        if (gameState.cartridge && !gameState.paused && !gameState.gameOver) {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            world.update(dt);
            updateHUD();
        }

        document.getElementById('entityCount').textContent = world?.entityCount || 0;
        document.getElementById('fpsDisplay').textContent = currentFps;

        requestAnimationFrame(gameLoop);
    }

    function updateHUD() {
        const hud = document.getElementById('gameHud');
        const hudItems = gameState.cartridge.hud || [];
        let html = '';

        if (hudItems.includes('score')) {
            html += `<div class="hud-item"><span class="hud-label">Score</span><span class="hud-value">${gameState.score}</span></div>`;
        }
        if (hudItems.includes('lives')) {
            html += `<div class="hud-item"><span class="hud-label">Lives</span><span class="hud-value">${gameState.lives}</span></div>`;
        }
        if (hudItems.includes('wave')) {
            html += `<div class="hud-item"><span class="hud-label">Wave</span><span class="hud-value">${gameState.wave}</span></div>`;
        }
        if (hudItems.includes('cities')) {
            html += `<div class="hud-item"><span class="hud-label">Cities</span><span class="hud-value">${gameState.cities}</span></div>`;
        }

        hud.innerHTML = html;

        // Check game over
        if (gameState.gameOver) {
            const overlay = document.getElementById('gameOverOverlay');
            overlay.classList.add('active');
            document.getElementById('gameOverTitle').textContent = gameState.win ? 'YOU WIN!' : 'GAME OVER';
            document.getElementById('gameOverTitle').className = 'overlay-title ' + (gameState.win ? 'win' : 'lose');
            document.getElementById('gameOverScore').textContent = `Score: ${gameState.score}`;
        }
    }

    // ============================================
    // GAME CONTROLS
    // ============================================

    function startGame() {
        if (!selectedCartridge) return;

        gameState = {
            cartridge: selectedCartridge,
            paused: false,
            gameOver: false,
            win: false,
            score: 0,
            lives: 3,
            wave: 1
        };

        // Setup canvas
        canvas.width = 800;
        canvas.height = 600;

        // Create world with systems
        world = new World();
        nextEntityId = 0;

        // Add base systems
        world.systems.push(Systems.Movement);
        world.systems.push(Systems.Collision);
        world.systems.push(Systems.Lifetime);
        world.systems.push(Systems.HealthRegen);

        // Add game-specific systems
        for (const sysName of selectedCartridge.systems || []) {
            if (GameSystems[sysName]) {
                world.systems.push(GameSystems[sysName]);
            }
        }

        // Always add rendering last
        world.systems.push(Systems.Rendering);

        // Run setup
        if (selectedCartridge.setup) {
            selectedCartridge.setup(world, gameState);
        }

        // Show game screen
        document.getElementById('launcher').classList.add('hidden');
        document.getElementById('gameScreen').classList.add('active');
        document.getElementById('gameTitleBar').textContent = selectedCartridge.meta.title;

        // Reset overlays
        document.getElementById('pauseOverlay').classList.remove('active');
        document.getElementById('gameOverOverlay').classList.remove('active');
    }

    function restartGame() {
        document.getElementById('gameOverOverlay').classList.remove('active');
        document.getElementById('pauseOverlay').classList.remove('active');
        startGame();
    }

    function togglePause() {
        gameState.paused = !gameState.paused;
        document.getElementById('pauseOverlay').classList.toggle('active', gameState.paused);
    }

    function exitToLauncher() {
        gameState.cartridge = null;
        gameState.paused = false;
        gameState.gameOver = false;
        world = null;

        document.getElementById('gameScreen').classList.remove('active');
        document.getElementById('launcher').classList.remove('hidden');
        document.getElementById('pauseOverlay').classList.remove('active');
        document.getElementById('gameOverOverlay').classList.remove('active');
    }

    // ============================================
    // IMPORT / EXPORT
    // ============================================

    function showImportModal() {
        document.getElementById('importModal').classList.add('active');
    }

    function hideImportModal() {
        document.getElementById('importModal').classList.remove('active');
    }

    function handleFileImport(event) {
        const file = event.target.files[0];
        if (file) importCartridgeFile(file);
        event.target.value = '';
    }

    function importCartridgeFile(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const cartridge = JSON.parse(e.target.result);
                if (!cartridge.meta?.id || !cartridge.meta?.title) {
                    throw new Error('Invalid cartridge format');
                }

                // Check for duplicates
                if (customCartridges.some(c => c.meta.id === cartridge.meta.id)) {
                    cartridge.meta.id += '-' + Date.now();
                }

                customCartridges.push(cartridge);
                saveCustomCartridges();
                renderCartridgeLibrary();
                hideImportModal();
            } catch (err) {
                alert('Failed to import cartridge: ' + err.message);
            }
        };
        reader.readAsText(file);
    }

    function exportSelectedCartridge() {
        if (!selectedCartridge) return;

        // Create exportable version (remove functions)
        const exportable = {
            meta: selectedCartridge.meta,
            config: selectedCartridge.config,
            controls: selectedCartridge.controls,
            hud: selectedCartridge.hud,
            systems: selectedCartridge.systems,
            preview: selectedCartridge.preview
        };

        const blob = new Blob([JSON.stringify(exportable, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${selectedCartridge.meta.id}.cartridge.json`;
        a.click();
        URL.revokeObjectURL(url);
    }

    function loadCustomCartridges() {
        try {
            const stored = localStorage.getItem('ecs-console-cartridges');
            if (stored) customCartridges = JSON.parse(stored);
        } catch (e) {
            customCartridges = [];
        }
    }

    function saveCustomCartridges() {
        localStorage.setItem('ecs-console-cartridges', JSON.stringify(customCartridges));
    }

    // Start
    init();
    </script>
</body>
</html>