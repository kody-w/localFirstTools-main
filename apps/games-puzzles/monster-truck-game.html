<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monster Truck Mayhem</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial Black', 'Arial', sans-serif;
            overflow: hidden;
            background: #87CEEB;
            touch-action: none;
        }

        #gameCanvas {
            display: block;
            max-width: 100vw;
            max-height: 100vh;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 1000;
        }

        .hidden {
            display: none !important;
        }

        .menu-container {
            background: rgba(30, 30, 30, 0.95);
            border: 4px solid #ff6b6b;
            border-radius: 20px;
            padding: 40px;
            max-width: 600px;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .menu-title {
            font-size: 48px;
            color: #ff6b6b;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.5);
            margin-bottom: 20px;
        }

        .menu-subtitle {
            font-size: 18px;
            color: #aaa;
            margin-bottom: 30px;
        }

        .menu-button {
            background: linear-gradient(180deg, #ff6b6b, #d63031);
            color: white;
            border: none;
            padding: 15px 40px;
            margin: 10px;
            font-size: 20px;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.2s;
            min-width: 200px;
        }

        .menu-button:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(255, 107, 107, 0.5);
        }

        .menu-button:active {
            transform: scale(0.98);
        }

        .menu-button:focus {
            outline: none;
            box-shadow: 0 0 0 3px #FFD700, 0 8px 20px rgba(255, 107, 107, 0.5);
        }

        .menu-button.secondary {
            background: linear-gradient(180deg, #555, #333);
        }

        .control-option:focus {
            outline: none;
            box-shadow: 0 0 0 3px #FFD700;
        }

        .control-scheme-selector {
            margin: 20px 0;
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .control-option {
            background: rgba(50, 50, 50, 0.8);
            border: 2px solid #666;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .control-option:hover {
            border-color: #ff6b6b;
        }

        .control-option.selected {
            background: #ff6b6b;
            border-color: #ff6b6b;
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.5);
        }

        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .hud-panel {
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            padding: 12px 20px;
            margin: 10px;
            display: inline-block;
            color: white;
            font-size: 18px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .hud-left {
            text-align: left;
        }

        .hud-center {
            text-align: center;
            flex: 1;
        }

        .hud-right {
            text-align: right;
        }

        .hud-label {
            font-size: 12px;
            color: #aaa;
            text-transform: uppercase;
        }

        .hud-value {
            font-size: 28px;
            font-weight: bold;
            color: #fff;
        }

        .hud-value.highlight {
            color: #FFD700;
        }

        /* Difficulty indicator */
        .difficulty-panel {
            min-width: 120px;
        }

        .difficulty-bar {
            width: 100%;
            height: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            overflow: hidden;
            margin: 5px 0;
        }

        .difficulty-fill {
            height: 100%;
            width: 10%;
            background: linear-gradient(90deg, #4CAF50, #FF9800, #f44336);
            border-radius: 5px;
            transition: width 0.3s ease, background 0.3s ease;
        }

        .difficulty-panel.pulse {
            animation: difficultyPulse 0.5s ease-out;
        }

        @keyframes difficultyPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); box-shadow: 0 0 20px rgba(255, 152, 0, 0.8); }
            100% { transform: scale(1); }
        }

        #powerupIndicator {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 200, 0, 0.9);
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: bold;
            font-size: 16px;
            display: none;
            animation: pulse 0.5s ease-in-out infinite;
            min-width: 150px;
            text-align: center;
        }

        #powerupProgress {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            margin-top: 8px;
            overflow: hidden;
        }

        #powerupProgressBar {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #00ff00, #ffff00, #ff6600);
            border-radius: 2px;
            transition: width 0.1s linear;
        }

        #powerupTimer {
            font-size: 12px;
            margin-top: 4px;
            opacity: 0.8;
        }

        .lives-panel .hud-value {
            font-size: 20px;
            letter-spacing: 2px;
        }

        .sound-panel {
            min-width: 40px;
            cursor: pointer;
        }

        .sound-panel .hud-value {
            font-size: 18px;
        }

        .sound-panel.muted .hud-value {
            opacity: 0.5;
        }

        .sr-only {
            position: absolute;
            left: -10000px;
            width: 1px;
            height: 1px;
            overflow: hidden;
        }

        /* Toast notification for feedback */
        .toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(-100px);
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            z-index: 10000;
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
            pointer-events: none;
        }

        .toast.visible {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        @keyframes pulse {
            0%, 100% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.1); }
        }

        @keyframes powerupUrgent {
            0%, 100% { transform: translateX(-50%) scale(1); box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
            50% { transform: translateX(-50%) scale(1.08); box-shadow: 0 0 25px rgba(255, 215, 0, 0.9); }
        }

        #powerupIndicator.urgent {
            animation: powerupUrgent 0.6s ease-in-out infinite;
            border: 2px solid #FFD700;
        }

        @keyframes lifeFlash {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .lives-panel.flash .hud-value {
            animation: lifeFlash 0.3s ease-in-out 3;
        }

        /* Tutorial Overlay */
        .tutorial-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            display: none;
            justify-content: center;
            align-items: center;
        }

        .tutorial-overlay.active {
            display: flex;
        }

        .tutorial-card {
            background: rgba(30, 30, 30, 0.95);
            border: 4px solid #FFD700;
            border-radius: 20px;
            padding: 30px;
            max-width: 500px;
            text-align: center;
            animation: tutorialPulse 2s ease-in-out infinite;
        }

        @keyframes tutorialPulse {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }
            50% { box-shadow: 0 0 40px rgba(255, 215, 0, 0.8); }
        }

        .tutorial-card h3 {
            color: #FFD700;
            font-size: 24px;
            margin: 0 0 15px 0;
        }

        .tutorial-card p {
            color: #fff;
            font-size: 16px;
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .tutorial-card p b {
            background: rgba(255, 107, 107, 0.8);
            padding: 2px 8px;
            border-radius: 4px;
        }

        /* Orientation Hint */
        .orientation-hint {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1500;
            display: none;
            animation: slideDown 0.3s ease-out;
        }

        .hint-card {
            background: rgba(255, 215, 0, 0.95);
            color: #000;
            padding: 12px 20px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .hint-icon {
            font-size: 24px;
        }

        .hint-card p {
            margin: 0;
            font-weight: bold;
        }

        .hint-dismiss {
            background: #000;
            color: #FFD700;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }

        @keyframes slideDown {
            from { opacity: 0; transform: translateX(-50%) translateY(-20px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }

        .data-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            z-index: 200;
            display: flex;
            gap: 5px;
        }

        .data-controls button {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 1px solid #666;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .data-controls button:hover {
            background: rgba(255, 107, 107, 0.8);
            border-color: #ff6b6b;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 20px 0;
            text-align: left;
        }

        .stat-item {
            background: rgba(50, 50, 50, 0.6);
            padding: 10px;
            border-radius: 5px;
        }

        .stat-label {
            font-size: 12px;
            color: #aaa;
            text-transform: uppercase;
        }

        .stat-value {
            font-size: 24px;
            color: #FFD700;
            font-weight: bold;
        }

        .help-text {
            font-size: 14px;
            color: #ccc;
            margin: 10px 0;
            line-height: 1.6;
        }

        .controls-list {
            text-align: left;
            margin: 20px 0;
        }

        .controls-list div {
            margin: 8px 0;
            padding: 8px;
            background: rgba(50, 50, 50, 0.5);
            border-radius: 5px;
        }

        .key-indicator {
            display: inline-block;
            background: #333;
            color: #FFD700;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: bold;
            margin-right: 10px;
            min-width: 60px;
            text-align: center;
        }

        @media (max-width: 768px) {
            .menu-container {
                padding: 20px;
                max-width: 90%;
            }

            .menu-title {
                font-size: 32px;
            }

            .hud-panel {
                font-size: 14px;
                padding: 8px 12px;
            }

            .hud-value {
                font-size: 20px;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }
        }

        .touch-controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            display: none;
            justify-content: space-between;
            padding: 0 20px;
            pointer-events: none;
            z-index: 50;
        }

        .touch-controls.active {
            display: flex;
        }

        .touch-button {
            width: 100px;
            height: 100px;
            background: rgba(255, 255, 255, 0.3);
            border: 3px solid white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            pointer-events: all;
            user-select: none;
            touch-action: none;
            transition: all 0.1s ease; /* Fast feedback for snappy feel */
        }

        .touch-button:active {
            background: rgba(255, 107, 107, 0.8);
            border-color: #FFD700;
            transform: scale(0.95);
        }

        .touch-button:focus {
            outline: 3px solid #4ecdc4;
            outline-offset: 3px;
            background: rgba(78, 205, 196, 0.4);
        }

        .touch-button.holding {
            background: rgba(255, 107, 107, 0.7);
            border-color: #FFD700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas">Monster Truck Mayhem - An endless runner racing game. Use arrow keys or WASD to steer, spacebar to boost. Collect coins and powerups while avoiding obstacles.</canvas>

    <div id="hud" class="hidden">
        <div class="hud-top">
            <div class="hud-left">
                <div class="hud-panel">
                    <div class="hud-label">Score</div>
                    <div class="hud-value" id="scoreDisplay">0</div>
                </div>
                <div class="hud-panel">
                    <div class="hud-label">High Score</div>
                    <div class="hud-value highlight" id="highScoreDisplay">0</div>
                </div>
            </div>
            <div class="hud-center">
                <div class="hud-panel difficulty-panel" id="difficultyPanel">
                    <div class="hud-label">Intensity</div>
                    <div class="difficulty-bar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" aria-label="Game difficulty intensity">
                        <div class="difficulty-fill" id="difficultyFill"></div>
                    </div>
                    <div class="hud-value" id="difficultyDisplay" style="font-size: 16px;">1.0x</div>
                </div>
            </div>
            <div class="hud-right">
                <div class="hud-panel">
                    <div class="hud-label">Distance</div>
                    <div class="hud-value" id="distanceDisplay">0m</div>
                </div>
                <div class="hud-panel">
                    <div class="hud-label">Level</div>
                    <div class="hud-value" id="levelDisplay">1</div>
                </div>
                <div class="hud-panel lives-panel">
                    <div class="hud-label">Lives</div>
                    <div class="hud-value" id="livesDisplay">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
                </div>
                <div class="hud-panel sound-panel" id="soundPanel" title="Press M to toggle sound">
                    <div class="hud-value" id="soundIndicator">üîä</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Screen reader announcer for accessibility -->
    <div id="gameAnnouncer" class="sr-only" role="status" aria-live="assertive" aria-atomic="true"></div>

    <!-- Toast notification for visual feedback -->
    <div id="toast" class="toast"></div>

    <!-- Orientation hint for mobile portrait -->
    <div id="orientationHint" class="orientation-hint">
        <div class="hint-card">
            <span class="hint-icon">üì±</span>
            <p>Rotate to landscape for best experience</p>
            <button class="hint-dismiss" id="dismissOrientation">Got it</button>
        </div>
    </div>

    <div id="powerupIndicator">
        <div id="powerupText"></div>
        <div id="powerupProgress">
            <div id="powerupProgressBar"></div>
        </div>
        <div id="powerupTimer"></div>
    </div>

    <div id="touchControls" class="touch-controls">
        <div class="touch-button" id="touchLeft" aria-label="Steer left" role="button">‚óÑ</div>
        <div class="touch-button" id="touchRight" aria-label="Steer right" role="button">‚ñ∫</div>
        <div class="touch-button" id="touchBoost" aria-label="Activate boost" role="button">‚ö°</div>
    </div>

    <div id="mainMenu" class="overlay">
        <div class="menu-container">
            <div class="menu-title">MONSTER TRUCK MAYHEM</div>
            <div class="menu-subtitle">Race, Dodge, Collect, Survive!</div>

            <div class="control-scheme-selector" role="radiogroup" aria-label="Control scheme">
                <div class="control-option selected" data-scheme="keyboard" role="radio" aria-checked="true" tabindex="0">
                    ‚å®Ô∏è Keyboard
                </div>
                <div class="control-option" data-scheme="touch" role="radio" aria-checked="false" tabindex="0">
                    üëÜ Touch
                </div>
            </div>

            <button class="menu-button" id="startButton">Start Game</button>
            <button class="menu-button secondary" id="helpButton">How to Play</button>
            <button class="menu-button secondary" id="statsButton">Statistics</button>
        </div>
    </div>

    <!-- Tutorial Overlay -->
    <div id="tutorialOverlay" class="tutorial-overlay">
        <div class="tutorial-card">
            <h3 id="tutorialTitle">Welcome to Monster Truck Mayhem!</h3>
            <p id="tutorialText">Let's learn the basics.</p>
            <button class="menu-button" id="tutorialNext">Got It!</button>
            <button class="menu-button secondary" id="tutorialSkip">Skip Tutorial</button>
        </div>
    </div>

    <div id="pauseMenu" class="overlay hidden">
        <div class="menu-container">
            <div class="menu-title">PAUSED</div>
            <button class="menu-button" id="resumeButton">Resume</button>
            <button class="menu-button secondary" id="restartButton">Restart</button>
            <button class="menu-button secondary" id="backToMenuButton">Main Menu</button>
        </div>
    </div>

    <div id="gameOverMenu" class="overlay hidden" role="dialog" aria-labelledby="gameOverTitle" aria-modal="true">
        <div class="menu-container">
            <div class="menu-title" id="gameOverTitle">GAME OVER</div>
            <div class="stats-grid" id="gameOverStats"></div>
            <button class="menu-button" id="playAgainButton">Play Again</button>
            <button class="menu-button secondary" id="mainMenuButton">Main Menu</button>
        </div>
    </div>

    <div id="helpMenu" class="overlay hidden">
        <div class="menu-container">
            <div class="menu-title">HOW TO PLAY</div>

            <div class="help-text">
                <strong>Objective:</strong> Drive as far as possible, collect coins, avoid obstacles, and use power-ups strategically!
            </div>

            <div class="controls-list">
                <div><span class="key-indicator">‚Üê ‚Üí</span> Steer left/right</div>
                <div><span class="key-indicator">SPACE</span> Activate boost</div>
                <div><span class="key-indicator">P</span> Pause game</div>
                <div><span class="key-indicator">M</span> Toggle sound</div>
            </div>

            <div class="help-text">
                <strong>Power-ups:</strong><br>
                üõ°Ô∏è Shield - Protects from one hit<br>
                üß≤ Magnet - Auto-collect nearby coins<br>
                ‚è±Ô∏è Slow-Mo - Slows down time<br>
                üíé 2x Points - Double score for 10 seconds
            </div>

            <div class="help-text">
                <strong>Obstacles:</strong><br>
                üöß Barriers - Lose points on collision<br>
                üõ¢Ô∏è Oil Slicks - Lose control temporarily<br>
                ü™® Boulders - Larger obstacles, bigger penalty
            </div>

            <button class="menu-button" id="closeHelpButton">Got It!</button>
        </div>
    </div>

    <div id="statsMenu" class="overlay hidden">
        <div class="menu-container">
            <div class="menu-title">STATISTICS</div>
            <div class="stats-grid" id="statsDisplay"></div>
            <button class="menu-button secondary" id="resetStatsButton">Reset Statistics</button>
            <button class="menu-button" id="closeStatsButton">Close</button>
        </div>
    </div>

    <div class="data-controls">
        <button id="exportButton" title="Export game data">üíæ Export</button>
        <button id="importButton" title="Import game data">üìÇ Import</button>
        <input type="file" id="importFile" accept=".json" style="display: none;">
    </div>

    <script>
        // ============= CONFIGURATION =============
        const CONFIG = {
            APP_NAME: 'monster-truck-mayhem',
            CANVAS_WIDTH: 800,
            CANVAS_HEIGHT: 600,
            ROAD_WIDTH: 400,
            TRUCK_WIDTH: 80,
            TRUCK_HEIGHT: 60,
            BASE_SPEED: 5,
            MAX_SPEED: 12,
            DIFFICULTY_INCREASE_RATE: 0.001,
            LEVEL_DISTANCE: 500,
            // Gameplay tuning parameters
            COMBO_WINDOW_MS: 3500,        // Time window for coin combos (3.5 seconds, forgiving)
            NEAR_MISS_COOLDOWN_MS: 500,   // Cooldown between near miss bonuses
            INVULNERABILITY_FRAMES: 60,   // Post-hit invulnerability (1 second at 60fps)
            POWERUP_DURATION_FRAMES: 600, // Powerup duration (10 seconds at 60fps)
            // Control and physics tuning
            STEERING_SPEED: 8,            // Horizontal movement speed
            MOVEMENT_SMOOTHING: 0.15,     // Smoothing factor for truck movement
            OBSTACLE_SPEED_BONUS: 3,      // Extra speed added to obstacles
            // Visual effects tuning
            SCREEN_SHAKE_INTENSITY: 8,    // Max pixels for screen shake
            SCREEN_SHAKE_DURATION: 15     // Frames of screen shake on hit
        };

        // ============= GAME STATE =============
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Cached DOM references for performance (avoid lookups in game loop)
        const hudElements = {
            score: document.getElementById('scoreDisplay'),
            highScore: document.getElementById('highScoreDisplay'),
            distance: document.getElementById('distanceDisplay'),
            level: document.getElementById('levelDisplay'),
            lives: document.getElementById('livesDisplay'),
            difficultyFill: document.getElementById('difficultyFill'),
            difficultyDisplay: document.getElementById('difficultyDisplay'),
            difficultyPanel: document.getElementById('difficultyPanel'),
            difficultyBar: document.querySelector('.difficulty-bar'),
            soundIndicator: document.getElementById('soundIndicator'),
            soundPanel: document.getElementById('soundPanel')
        };

        let gameState = 'menu'; // menu, playing, paused, gameover
        let controlScheme = 'keyboard'; // keyboard, touch
        let soundEnabled = true;

        let score = 0;
        let distance = 0;
        let level = 1;
        let highScore = 0;
        let difficulty = 1;
        let lives = 3;

        let gameData = {
            highScore: 0,
            totalGames: 0,
            totalDistance: 0,
            totalCoins: 0,
            achievements: {},
            settings: {
                controlScheme: 'keyboard',
                soundEnabled: true,
                tutorialCompleted: false
            }
        };

        // Game objects
        const truck = {
            x: 0,
            y: 0,
            width: CONFIG.TRUCK_WIDTH,
            height: CONFIG.TRUCK_HEIGHT,
            speed: 0,
            rotation: 0,
            wheelRotation: 0,
            targetX: 0,
            invulnerable: false,
            invulnerableTimer: 0
        };

        const road = {
            width: CONFIG.ROAD_WIDTH,
            offset: 0
        };

        let obstacles = [];
        let collectibles = [];
        let powerups = [];

        // Accessibility: Detect reduced motion preference
        let prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        window.matchMedia('(prefers-reduced-motion: reduce)').addEventListener('change', (e) => {
            prefersReducedMotion = e.matches;
        });

        // Screen shake and damage feedback effects
        let screenShake = { intensity: 0, duration: 0 };
        let damageFlash = { alpha: 0 };
        let slowMotion = { active: false, factor: 1, duration: 0, frameCount: 0 };
        let particles = [];
        const MAX_PARTICLES = 300; // Prevent memory leak
        const MAX_FLOATING_TEXTS = 20;

        // Combo counter system
        let comboState = { count: 0, lastCoinTime: 0, comboWindow: CONFIG.COMBO_WINDOW_MS };
        let floatingTexts = [];

        // Near miss tracking
        let nearMissState = { lastNearMissTime: 0, cooldown: CONFIG.NEAR_MISS_COOLDOWN_MS };

        let activePowerup = null;
        let powerupTimer = 0;

        // Control state
        const keys = {};
        let touchStartX = 0;
        let isBoosting = false;

        // Frame rate limiting (fixes 120Hz display speed)
        let lastFrameTime = 0;
        const TARGET_FPS = 60;
        const FRAME_DURATION = 1000 / TARGET_FPS; // ~16.67ms

        // Audio context
        let audioCtx = null;

        // ============= AUDIO SYSTEM =============
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function playSound(type) {
            if (!soundEnabled || !audioCtx) return;

            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            switch(type) {
                case 'collect':
                    oscillator.frequency.value = 800;
                    oscillator.type = 'sine';
                    gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.2);
                    break;
                case 'hit':
                    oscillator.frequency.value = 100;
                    oscillator.type = 'sawtooth';
                    gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.3);
                    break;
                case 'powerup':
                    oscillator.frequency.value = 1200;
                    oscillator.type = 'square';
                    gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.4);
                    break;
                case 'boost':
                    oscillator.frequency.value = 200;
                    oscillator.type = 'sawtooth';
                    gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.5);
                    break;
                case 'levelup':
                    oscillator.frequency.value = 1500;
                    oscillator.type = 'sine';
                    gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.6);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.6);
                    break;
            }
        }

        // ============= DATA PERSISTENCE =============
        function loadData() {
            const saved = localStorage.getItem(CONFIG.APP_NAME);
            if (saved) {
                try {
                    gameData = {...gameData, ...JSON.parse(saved)};
                    highScore = gameData.highScore || 0;
                    controlScheme = gameData.settings?.controlScheme || 'keyboard';
                    soundEnabled = gameData.settings?.soundEnabled !== false;
                } catch (e) {
                    console.error('Failed to load game data:', e);
                }
            }
            updateControlScheme();
        }

        function saveData() {
            try {
                localStorage.setItem(CONFIG.APP_NAME, JSON.stringify(gameData));
            } catch (e) {
                console.error('Failed to save game data:', e);
            }
        }

        function exportData() {
            const dataStr = JSON.stringify(gameData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `monster-truck-mayhem-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }

        function validateGameData(data) {
            // Security: Validate structure before merging
            if (!data || typeof data !== 'object' || Array.isArray(data)) return false;
            if (data.highScore !== undefined && typeof data.highScore !== 'number') return false;
            if (data.totalGames !== undefined && typeof data.totalGames !== 'number') return false;
            if (data.totalDistance !== undefined && typeof data.totalDistance !== 'number') return false;
            if (data.totalCoins !== undefined && typeof data.totalCoins !== 'number') return false;
            return true;
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const imported = JSON.parse(e.target.result);

                    // Security: Validate structure before merging
                    if (!validateGameData(imported)) {
                        throw new Error('Invalid data structure');
                    }

                    // Security: Sanitize numeric values with realistic bounds (prevent overflow attacks)
                    const MAX_STAT = 999999999; // 10-digit max
                    const sanitize = (val) => Math.min(MAX_STAT, Math.max(0, parseInt(val) || 0));
                    gameData = {
                        highScore: sanitize(imported.highScore),
                        totalGames: sanitize(imported.totalGames),
                        totalDistance: sanitize(imported.totalDistance),
                        totalCoins: sanitize(imported.totalCoins),
                        achievements: imported.achievements || {},
                        settings: {
                            controlScheme: ['keyboard', 'touch'].includes(imported.settings?.controlScheme)
                                ? imported.settings.controlScheme
                                : 'keyboard',
                            soundEnabled: imported.settings?.soundEnabled !== false,
                            tutorialCompleted: imported.settings?.tutorialCompleted === true
                        }
                    };

                    saveData();
                    loadData();
                    updateStatsDisplay();
                    alert('Data imported successfully!');
                } catch (error) {
                    console.error('Import failed:', error);
                    alert('Invalid JSON file. Please check the file format.');
                }
            };
            reader.readAsText(file);
            // Reset file input so same file can be re-imported
            event.target.value = '';
        }

        // ============= GAME INITIALIZATION =============
        function initGame() {
            canvas.width = Math.min(CONFIG.CANVAS_WIDTH, window.innerWidth);
            canvas.height = Math.min(CONFIG.CANVAS_HEIGHT, window.innerHeight);

            truck.x = canvas.width / 2;
            truck.y = canvas.height - 150;
            truck.targetX = truck.x;

            loadData();
            // Note: initAudio() is called on first user interaction (startGame) for browser autoplay policy
            updateHighScoreDisplay();
            updateSoundIndicator();
        }

        function startGame() {
            // Initialize audio on first user interaction (required by browser autoplay policy)
            initAudio();

            gameState = 'playing';
            score = 0;
            distance = 0;
            level = 1;
            difficulty = 1;
            lives = 3;

            truck.x = canvas.width / 2;
            truck.targetX = truck.x;
            truck.speed = 0;
            truck.invulnerable = false;

            obstacles = [];
            collectibles = [];
            powerups = [];
            particles = [];
            activePowerup = null;
            powerupTimer = 0;

            road.offset = 0;

            releaseFocusTrap();
            document.getElementById('mainMenu').classList.add('hidden');
            document.getElementById('pauseMenu').classList.add('hidden');
            document.getElementById('gameOverMenu').classList.add('hidden');
            document.getElementById('hud').classList.remove('hidden');

            updateHUD();
            lastFrameTime = 0; // Reset for frame rate limiting
            requestAnimationFrame(gameLoop);
        }

        function pauseGame() {
            if (gameState === 'playing') {
                gameState = 'paused';
                const pauseMenu = document.getElementById('pauseMenu');
                pauseMenu.classList.remove('hidden');
                activeFocusTrap = trapFocus(pauseMenu);
                announceToScreenReader('Game paused. Press P or Escape to resume.');
            }
        }

        function resumeGame() {
            if (gameState === 'paused') {
                gameState = 'playing';
                releaseFocusTrap();
                document.getElementById('pauseMenu').classList.add('hidden');
                lastFrameTime = 0; // Reset for frame rate limiting after pause
                requestAnimationFrame(gameLoop);
            }
        }

        function restartGame() {
            startGame();
        }

        function gameOver() {
            gameState = 'gameover';
            document.getElementById('hud').classList.add('hidden');

            // Update statistics
            gameData.totalGames++;
            gameData.totalDistance += Math.floor(distance);

            if (score > gameData.highScore) {
                gameData.highScore = score;
                highScore = score;
            }

            saveData();

            // Show game over stats
            const statsHTML = `
                <div class="stat-item">
                    <div class="stat-label">Final Score</div>
                    <div class="stat-value">${score}</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">High Score</div>
                    <div class="stat-value">${highScore}</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Distance</div>
                    <div class="stat-value">${Math.floor(distance)}m</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Level Reached</div>
                    <div class="stat-value">${level}</div>
                </div>
            `;

            document.getElementById('gameOverStats').innerHTML = statsHTML;
            const gameOverMenu = document.getElementById('gameOverMenu');
            gameOverMenu.classList.remove('hidden');
            activeFocusTrap = trapFocus(gameOverMenu);

            // Announce to screen reader
            const isHighScore = score >= highScore ? ' New high score!' : '';
            announceToScreenReader(`Game over. Final score: ${score}.${isHighScore} Press Tab to navigate options.`);
        }

        // ============= GAME OBJECTS =============
        function spawnObstacle() {
            const roadCenter = canvas.width / 2;
            const roadLeft = roadCenter - road.width / 2 + 60;
            const roadRight = roadCenter + road.width / 2 - 60;

            const types = ['barrier', 'oil', 'boulder'];
            const type = types[Math.floor(Math.random() * types.length)];

            const obstacle = {
                x: roadLeft + Math.random() * (roadRight - roadLeft),
                y: -50,
                type: type,
                hit: false
            };

            switch(type) {
                case 'barrier':
                    obstacle.width = 40;
                    obstacle.height = 40;
                    obstacle.damage = 10;
                    break;
                case 'oil':
                    obstacle.width = 50;
                    obstacle.height = 30;
                    obstacle.damage = 5;
                    break;
                case 'boulder':
                    obstacle.width = 60;
                    obstacle.height = 60;
                    obstacle.damage = 20;
                    break;
            }

            obstacles.push(obstacle);
        }

        function spawnCollectible() {
            const roadCenter = canvas.width / 2;
            const roadLeft = roadCenter - road.width / 2 + 40;
            const roadRight = roadCenter + road.width / 2 - 40;

            collectibles.push({
                x: roadLeft + Math.random() * (roadRight - roadLeft),
                y: -50,
                width: 30,
                height: 30,
                value: 10,
                collected: false,
                bobOffset: Math.random() * Math.PI * 2
            });
        }

        function spawnPowerup() {
            const roadCenter = canvas.width / 2;
            const roadLeft = roadCenter - road.width / 2 + 40;
            const roadRight = roadCenter + road.width / 2 - 40;

            const types = ['shield', 'magnet', 'slowmo', 'double'];
            const type = types[Math.floor(Math.random() * types.length)];

            powerups.push({
                x: roadLeft + Math.random() * (roadRight - roadLeft),
                y: -50,
                width: 35,
                height: 35,
                type: type,
                collected: false,
                rotation: 0
            });
        }

        const POWERUP_DURATION = CONFIG.POWERUP_DURATION_FRAMES;

        function activatePowerup(type) {
            activePowerup = type;
            powerupTimer = POWERUP_DURATION;

            const indicator = document.getElementById('powerupIndicator');
            const textElem = document.getElementById('powerupText');
            const progressBar = document.getElementById('powerupProgressBar');
            const timerElem = document.getElementById('powerupTimer');

            let powerupName = '';
            switch(type) {
                case 'shield':
                    textElem.textContent = 'üõ°Ô∏è SHIELD ACTIVE';
                    powerupName = 'Shield';
                    truck.invulnerable = true;
                    break;
                case 'magnet':
                    textElem.textContent = 'üß≤ MAGNET ACTIVE';
                    powerupName = 'Magnet';
                    break;
                case 'slowmo':
                    textElem.textContent = '‚è±Ô∏è SLOW-MO ACTIVE';
                    powerupName = 'Slow-mo';
                    break;
                case 'double':
                    textElem.textContent = 'üíé 2X POINTS ACTIVE';
                    powerupName = 'Double points';
                    break;
            }

            // Initialize timer display
            if (progressBar) progressBar.style.width = '100%';
            if (timerElem) timerElem.textContent = '10s';

            indicator.style.display = 'block';
            playSound('powerup');
            announceToScreenReader(`${powerupName} powerup activated! 10 seconds.`);
        }

        function createParticles(x, y, color, count = 10) {
            // Skip particles if reduced motion is preferred
            if (prefersReducedMotion) return;

            // Cap particles to prevent memory leak
            if (particles.length >= MAX_PARTICLES) return;

            const allowedCount = Math.min(count, MAX_PARTICLES - particles.length);
            for (let i = 0; i < allowedCount; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 30,
                    maxLife: 30,
                    color: color,
                    size: Math.random() * 4 + 2
                });
            }
        }

        // ============= ENHANCED FEEDBACK EFFECTS =============
        function triggerScreenShake(intensity, duration) {
            // Skip screen shake if reduced motion is preferred
            if (prefersReducedMotion) return;
            screenShake.intensity = intensity;
            screenShake.duration = duration;
        }

        function triggerDamageFlash() {
            // Allow damage flash even with reduced motion (static visual feedback)
            damageFlash.alpha = 0.4;
        }

        function triggerSlowMotion(factor, duration) {
            // Skip slow motion if reduced motion is preferred
            if (prefersReducedMotion) return;
            slowMotion.active = true;
            slowMotion.factor = factor;
            slowMotion.duration = duration;
        }

        function updateEffects() {
            // Update screen shake
            if (screenShake.duration > 0) {
                screenShake.duration--;
                if (screenShake.duration <= 0) {
                    screenShake.intensity = 0;
                }
            }

            // Update damage flash
            if (damageFlash.alpha > 0) {
                damageFlash.alpha -= 0.05;
                if (damageFlash.alpha < 0) damageFlash.alpha = 0;
            }

            // Update slow motion
            if (slowMotion.active) {
                slowMotion.duration--;
                if (slowMotion.duration <= 0) {
                    slowMotion.active = false;
                    slowMotion.factor = 1;
                }
            }
        }

        function getShakeOffset() {
            if (screenShake.intensity <= 0) return { x: 0, y: 0 };
            return {
                x: (Math.random() - 0.5) * screenShake.intensity * 2,
                y: (Math.random() - 0.5) * screenShake.intensity * 2
            };
        }

        // ============= HAPTIC FEEDBACK =============
        function triggerHaptic(pattern) {
            if ('vibrate' in navigator) {
                try {
                    if (pattern === 'hit') {
                        navigator.vibrate([50, 30, 100]); // Short-pause-long for collision
                    } else if (pattern === 'coin') {
                        navigator.vibrate(15); // Light buzz for coin
                    } else if (pattern === 'powerup') {
                        navigator.vibrate([30, 20, 30, 20, 50]); // Exciting pattern for powerup
                    } else if (pattern === 'nearmiss') {
                        navigator.vibrate(10); // Quick tap for near miss
                    } else if (pattern === 'combo') {
                        navigator.vibrate([20, 10, 20]); // Double tap for combo
                    }
                } catch (e) {
                    // Vibration not supported or failed
                }
            }
        }

        // ============= SCREEN READER ACCESSIBILITY =============
        function announceToScreenReader(message) {
            const announcer = document.getElementById('gameAnnouncer');
            if (announcer) {
                announcer.textContent = message;
                // Clear after a brief moment to allow repeated announcements
                setTimeout(() => { announcer.textContent = ''; }, 1000);
            }
        }

        // ============= TOAST NOTIFICATIONS =============
        let toastTimeout = null;

        function showToast(message, duration = 2000) {
            const toast = document.getElementById('toast');
            if (!toast) return;

            // Clear any existing timeout
            if (toastTimeout) clearTimeout(toastTimeout);

            toast.textContent = message;
            toast.classList.add('visible');

            toastTimeout = setTimeout(() => {
                toast.classList.remove('visible');
            }, duration);
        }

        function updateSoundIndicator() {
            if (hudElements.soundIndicator) {
                hudElements.soundIndicator.textContent = soundEnabled ? 'üîä' : 'üîá';
            }
            if (hudElements.soundPanel) {
                hudElements.soundPanel.classList.toggle('muted', !soundEnabled);
            }
        }

        // ============= FOCUS TRAP FOR MODALS =============
        let activeFocusTrap = null;

        function trapFocus(modal) {
            const focusableSelectors = 'button:not([disabled]), [href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"])';
            const focusables = modal.querySelectorAll(focusableSelectors);
            if (focusables.length === 0) return null;

            const first = focusables[0];
            const last = focusables[focusables.length - 1];

            const handler = (e) => {
                if (e.key !== 'Tab') return;
                if (e.shiftKey) {
                    if (document.activeElement === first) {
                        e.preventDefault();
                        last.focus();
                    }
                } else {
                    if (document.activeElement === last) {
                        e.preventDefault();
                        first.focus();
                    }
                }
            };

            modal.addEventListener('keydown', handler);
            first.focus();

            return { modal, handler };
        }

        function releaseFocusTrap() {
            if (activeFocusTrap) {
                activeFocusTrap.modal.removeEventListener('keydown', activeFocusTrap.handler);
                activeFocusTrap = null;
            }
        }

        // ============= COMBO SYSTEM =============
        function registerCoinCollect() {
            const now = Date.now();
            if (now - comboState.lastCoinTime < comboState.comboWindow) {
                comboState.count++;
                if (comboState.count >= 3) {
                    const comboBonus = comboState.count * 2;
                    score += comboBonus;
                    // Visual distinction for 4x+ combos (sparkle effect)
                    const sparkle = comboState.count >= 4 ? ' ‚ú®' : '';
                    createFloatingText(truck.x, truck.y - 40, `${comboState.count}x COMBO +${comboBonus}${sparkle}`, '#FFD700');
                    triggerHaptic('combo');
                    announceToScreenReader(`${comboState.count} coin combo! Plus ${comboBonus} points!`);
                }
            } else {
                comboState.count = 1;
            }
            comboState.lastCoinTime = now;
        }

        function createFloatingText(x, y, text, color) {
            // Cap floating texts to prevent memory leak
            if (floatingTexts.length >= MAX_FLOATING_TEXTS) {
                floatingTexts.shift(); // Remove oldest
            }
            floatingTexts.push({
                x: x,
                y: y,
                text: text,
                color: color,
                alpha: 1,
                vy: -2
            });
        }

        function updateFloatingTexts() {
            for (let i = floatingTexts.length - 1; i >= 0; i--) {
                const ft = floatingTexts[i];
                ft.y += ft.vy;
                ft.alpha -= 0.02;
                if (ft.alpha <= 0) {
                    floatingTexts.splice(i, 1);
                }
            }
        }

        function drawFloatingTexts() {
            floatingTexts.forEach(ft => {
                ctx.save();
                ctx.globalAlpha = ft.alpha;
                ctx.font = 'bold 18px Arial';
                ctx.fillStyle = ft.color;
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.textAlign = 'center';
                ctx.strokeText(ft.text, ft.x, ft.y);
                ctx.fillText(ft.text, ft.x, ft.y);
                ctx.restore();
            });
        }

        // ============= NEAR MISS SYSTEM =============
        function checkNearMiss(obs) {
            const now = Date.now();
            if (now - nearMissState.lastNearMissTime < nearMissState.cooldown) return;

            // Check if obstacle is close but not colliding (30-50px proximity)
            const dx = Math.abs(truck.x - obs.x);
            const dy = Math.abs(truck.y - obs.y);
            const proximityThreshold = 50;
            const collisionThreshold = (truck.width + obs.width) / 2;

            // Must be close but not colliding
            if (dx > collisionThreshold && dx < proximityThreshold + collisionThreshold &&
                dy < truck.height) {
                // Near miss detected!
                nearMissState.lastNearMissTime = now;
                score += 2;
                createFloatingText(truck.x, truck.y - 60, 'NEAR MISS +2', '#00FF00');
                triggerHaptic('nearmiss');
            }
        }

        // ============= GAME UPDATE =============
        function updateGame() {
            if (gameState !== 'playing') return;

            // Update difficulty
            difficulty += CONFIG.DIFFICULTY_INCREASE_RATE;
            const baseSpeed = CONFIG.BASE_SPEED * difficulty;
            truck.speed = Math.min(baseSpeed, CONFIG.MAX_SPEED);

            // Update distance and level
            distance += truck.speed * 0.1;
            const newLevel = Math.floor(distance / CONFIG.LEVEL_DISTANCE) + 1;
            if (newLevel > level) {
                level = newLevel;
                playSound('levelup');
            }

            // Update truck position
            truck.x += (truck.targetX - truck.x) * CONFIG.MOVEMENT_SMOOTHING;
            truck.rotation = (truck.targetX - truck.x) * 0.002;

            // Keep truck on road
            const roadCenter = canvas.width / 2;
            const roadLeft = roadCenter - road.width / 2 + truck.width / 2;
            const roadRight = roadCenter + road.width / 2 - truck.width / 2;
            truck.targetX = Math.max(roadLeft, Math.min(roadRight, truck.targetX));

            // Update wheel rotation
            truck.wheelRotation += truck.speed * 0.15;

            // Update road animation
            road.offset += truck.speed;

            // Update invulnerability
            if (truck.invulnerableTimer > 0) {
                truck.invulnerableTimer--;
                if (truck.invulnerableTimer === 0) {
                    truck.invulnerable = false;
                }
            }

            // Update powerup timer with visual countdown
            if (powerupTimer > 0) {
                powerupTimer--;

                // Update progress bar and timer display
                const progressBar = document.getElementById('powerupProgressBar');
                const timerElem = document.getElementById('powerupTimer');
                const indicator = document.getElementById('powerupIndicator');

                if (progressBar) {
                    const percentRemaining = (powerupTimer / POWERUP_DURATION) * 100;
                    progressBar.style.width = percentRemaining + '%';
                }
                if (timerElem) {
                    timerElem.textContent = Math.ceil(powerupTimer / 60) + 's';
                }

                // Add urgency indicator when <3 seconds remain
                const secondsRemaining = Math.ceil(powerupTimer / 60);
                if (secondsRemaining <= 3 && !prefersReducedMotion) {
                    indicator?.classList.add('urgent');
                } else {
                    indicator?.classList.remove('urgent');
                }

                if (powerupTimer === 0) {
                    // Contextual powerup expiry messages with personality
                    const expiryMessages = {
                        shield: 'Your shield faded! Watch out!',
                        magnet: 'Magnet power gone! Collect coins manually.',
                        slowmo: 'Time flows normally again!',
                        double: 'Double points ended!'
                    };
                    const message = expiryMessages[activePowerup] || 'Powerup expired.';
                    activePowerup = null;
                    truck.invulnerable = false;
                    indicator?.classList.remove('urgent');
                    indicator.style.display = 'none';
                    announceToScreenReader(message);
                }
            }

            // Spawn objects
            const spawnRate = activePowerup === 'slowmo' ? 0.5 : 1;
            if (Math.random() < 0.02 * difficulty * spawnRate) spawnObstacle();
            if (Math.random() < 0.03 * spawnRate) spawnCollectible();
            if (Math.random() < 0.005 * spawnRate) spawnPowerup();

            // Update obstacles
            const obstacleSpeed = activePowerup === 'slowmo' ? truck.speed * 0.5 : truck.speed;
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];
                obs.y += obstacleSpeed + CONFIG.OBSTACLE_SPEED_BONUS;

                if (!obs.hit && checkCollision(truck, obs)) {
                    if (!truck.invulnerable) {
                        obs.hit = true;
                        lives--;
                        score = Math.max(0, score - obs.damage);
                        playSound('hit');
                        triggerHaptic('hit'); // Mobile haptic feedback
                        createParticles(obs.x, obs.y, '#ff0000', 25); // More particles

                        // Enhanced collision feedback
                        triggerScreenShake(CONFIG.SCREEN_SHAKE_INTENSITY, CONFIG.SCREEN_SHAKE_DURATION);
                        triggerDamageFlash();
                        triggerSlowMotion(0.3, 18); // factor, duration in frames

                        // Life lost feedback
                        const livesPanel = document.querySelector('.lives-panel');
                        if (livesPanel) {
                            livesPanel.classList.add('flash');
                            setTimeout(() => livesPanel.classList.remove('flash'), 900);
                        }

                        // Screen reader announcement
                        announceToScreenReader(`Life lost! ${lives} ${lives === 1 ? 'life' : 'lives'} remaining.`);

                        // Check for game over
                        if (lives <= 0) {
                            gameOver();
                            return;
                        }

                        if (obs.type === 'oil') {
                            // Oil slick effect - random movement
                            truck.targetX += (Math.random() - 0.5) * 100;
                        }

                        truck.invulnerable = true;
                        truck.invulnerableTimer = CONFIG.INVULNERABILITY_FRAMES;
                    }
                } else if (!obs.hit && !obs.nearMissChecked) {
                    // Check for near miss when obstacle passes truck level
                    checkNearMiss(obs);
                    if (obs.y > truck.y) {
                        obs.nearMissChecked = true;
                    }
                }

                if (obs.y > canvas.height + 50) {
                    obstacles.splice(i, 1);
                }
            }

            // Update collectibles
            const magnetRange = activePowerup === 'magnet' ? 100 : 0;
            for (let i = collectibles.length - 1; i >= 0; i--) {
                const coin = collectibles[i];
                coin.y += obstacleSpeed + CONFIG.OBSTACLE_SPEED_BONUS;
                coin.bobOffset += 0.1;

                // Magnet effect
                if (magnetRange > 0) {
                    const dx = truck.x - coin.x;
                    const dy = truck.y - coin.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < magnetRange) {
                        coin.x += dx * 0.1;
                        coin.y += dy * 0.1;
                    }
                }

                if (!coin.collected && checkCollision(truck, coin)) {
                    coin.collected = true;
                    const points = activePowerup === 'double' ? coin.value * 2 : coin.value;
                    score += points;
                    gameData.totalCoins++;
                    playSound('collect');
                    triggerHaptic('coin'); // Mobile haptic feedback
                    registerCoinCollect(); // Combo system
                    createParticles(coin.x, coin.y, '#FFD700', 8);
                }

                if (coin.y > canvas.height + 50 || coin.collected) {
                    collectibles.splice(i, 1);
                }
            }

            // Update powerups
            for (let i = powerups.length - 1; i >= 0; i--) {
                const powerup = powerups[i];
                powerup.y += obstacleSpeed + 2;
                powerup.rotation += 0.05;

                if (!powerup.collected && checkCollision(truck, powerup)) {
                    powerup.collected = true;
                    triggerHaptic('powerup'); // Mobile haptic feedback
                    activatePowerup(powerup.type);
                }

                if (powerup.y > canvas.height + 50 || powerup.collected) {
                    powerups.splice(i, 1);
                }
            }

            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life--;

                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }

            // Update floating texts (combo/near miss)
            updateFloatingTexts();

            // Boost effect
            if (isBoosting && powerupTimer === 0) {
                truck.speed = Math.min(truck.speed * 1.5, CONFIG.MAX_SPEED * 1.5);
                if (Math.random() < 0.3) {
                    createParticles(truck.x - 30, truck.y + 20, '#ff6b6b', 2);
                }
            }

            updateHUD();
        }

        function checkCollision(a, b) {
            return a.x - a.width/2 < b.x + b.width/2 &&
                   a.x + a.width/2 > b.x - b.width/2 &&
                   a.y - a.height/2 < b.y + b.height/2 &&
                   a.y + a.height/2 > b.y - b.height/2;
        }

        // ============= RENDERING =============
        function drawBackground() {
            // Sky gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(1, '#B0D8E8');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Clouds
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            for (let i = 0; i < 6; i++) {
                const x = ((i * 250 + road.offset * 0.3) % (canvas.width + 100)) - 50;
                const y = 40 + i * 25;
                ctx.beginPath();
                ctx.arc(x, y, 25, 0, Math.PI * 2);
                ctx.arc(x + 20, y, 30, 0, Math.PI * 2);
                ctx.arc(x + 45, y, 25, 0, Math.PI * 2);
                ctx.fill();
            }

            // Ground
            ctx.fillStyle = '#8FBC8F';
            ctx.fillRect(0, canvas.height - 100, canvas.width, 100);
        }

        function drawRoad() {
            const roadCenter = canvas.width / 2;
            const roadLeft = roadCenter - road.width / 2;
            const roadRight = roadCenter + road.width / 2;

            // Road surface
            ctx.fillStyle = '#2d3436';
            ctx.fillRect(roadLeft, 0, road.width, canvas.height);

            // Road edges
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.moveTo(roadLeft, 0);
            ctx.lineTo(roadLeft, canvas.height);
            ctx.moveTo(roadRight, 0);
            ctx.lineTo(roadRight, canvas.height);
            ctx.stroke();

            // Center stripes
            ctx.fillStyle = '#f1c40f';
            const stripeHeight = 60;
            const stripeGap = 40;
            for (let y = (-stripeHeight + (road.offset % (stripeHeight + stripeGap))); y < canvas.height; y += stripeHeight + stripeGap) {
                ctx.fillRect(roadCenter - 5, y, 10, stripeHeight);
            }
        }

        function drawTruck() {
            ctx.save();
            ctx.translate(truck.x, truck.y);
            ctx.rotate(truck.rotation);

            // Draw shadow
            if (!truck.invulnerable || Math.floor(Date.now() / 100) % 2) {
                ctx.globalAlpha = 0.3;
                ctx.fillStyle = '#000';
                ctx.fillRect(-truck.width/2, truck.height/2 + 5, truck.width, 10);
                ctx.globalAlpha = 1;
            }

            // Invulnerability flash
            if (truck.invulnerable && Math.floor(Date.now() / 100) % 2) {
                ctx.globalAlpha = 0.5;
            }

            // Truck body
            const gradient = ctx.createLinearGradient(0, -truck.height/2, 0, truck.height/2);
            gradient.addColorStop(0, '#ff6b6b');
            gradient.addColorStop(1, '#d63031');
            ctx.fillStyle = gradient;
            ctx.fillRect(-truck.width/2, -truck.height/2, truck.width, truck.height);

            // Cab details
            ctx.fillStyle = '#c0392b';
            ctx.fillRect(-truck.width/2 + 5, -truck.height/2, truck.width - 10, 20);

            // Windshield
            ctx.fillStyle = '#4a69bd';
            ctx.fillRect(-truck.width/2 + 12, -truck.height/2 + 5, truck.width - 24, 12);

            // Wheels
            const wheelSize = 18;
            ctx.fillStyle = '#000';
            [-truck.width/2 + 15, truck.width/2 - 15].forEach(xOffset => {
                [-truck.height/2 + 5, truck.height/2 - 5].forEach(yOffset => {
                    ctx.save();
                    ctx.translate(xOffset, yOffset);
                    ctx.rotate(truck.wheelRotation);
                    ctx.fillRect(-wheelSize/2, -wheelSize/2, wheelSize, wheelSize);
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(-wheelSize/2, -wheelSize/2, wheelSize, wheelSize);
                    ctx.restore();
                });
            });

            // Boost flames
            if (isBoosting) {
                ctx.fillStyle = '#ff6348';
                [-25, 25].forEach(offset => {
                    ctx.beginPath();
                    ctx.moveTo(offset - 10, truck.height/2 - 8);
                    ctx.lineTo(offset - 20 - Math.random() * 15, truck.height/2);
                    ctx.lineTo(offset - 10, truck.height/2 + 8);
                    ctx.closePath();
                    ctx.fill();
                });
            }

            ctx.globalAlpha = 1;
            ctx.restore();
        }

        function drawObstacles() {
            obstacles.forEach(obs => {
                ctx.save();
                ctx.translate(obs.x, obs.y);

                switch(obs.type) {
                    case 'barrier':
                        // Warning barrier
                        ctx.fillStyle = '#e74c3c';
                        ctx.fillRect(-obs.width/2, -obs.height/2, obs.width, obs.height);
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(-obs.width/2, -obs.height/2);
                        ctx.lineTo(obs.width/2, obs.height/2);
                        ctx.moveTo(obs.width/2, -obs.height/2);
                        ctx.lineTo(-obs.width/2, obs.height/2);
                        ctx.stroke();
                        break;

                    case 'oil':
                        // Oil slick
                        ctx.fillStyle = '#34495e';
                        ctx.beginPath();
                        ctx.ellipse(0, 0, obs.width/2, obs.height/2, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#2c3e50';
                        ctx.beginPath();
                        ctx.ellipse(-5, -3, obs.width/4, obs.height/4, 0, 0, Math.PI * 2);
                        ctx.fill();
                        break;

                    case 'boulder':
                        // Boulder
                        ctx.fillStyle = '#7f8c8d';
                        ctx.beginPath();
                        ctx.arc(0, 0, obs.width/2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#95a5a6';
                        ctx.beginPath();
                        ctx.arc(-8, -8, obs.width/4, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                }

                ctx.restore();
            });
        }

        function drawCollectibles() {
            collectibles.forEach(coin => {
                if (coin.collected) return;

                ctx.save();
                ctx.translate(coin.x, coin.y + Math.sin(coin.bobOffset) * 5);

                // Coin
                ctx.fillStyle = '#f1c40f';
                ctx.beginPath();
                ctx.arc(0, 0, coin.width/2, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#f39c12';
                ctx.beginPath();
                ctx.arc(0, 0, coin.width/3, 0, Math.PI * 2);
                ctx.fill();

                // Shine
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(-5, -5, coin.width/6, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            });
        }

        function drawPowerups() {
            powerups.forEach(powerup => {
                if (powerup.collected) return;

                ctx.save();
                ctx.translate(powerup.x, powerup.y);
                ctx.rotate(powerup.rotation);

                // Glow effect
                ctx.shadowBlur = 15;
                ctx.shadowColor = getPowerupColor(powerup.type);

                // Box
                ctx.fillStyle = getPowerupColor(powerup.type);
                ctx.fillRect(-powerup.width/2, -powerup.height/2, powerup.width, powerup.height);

                // Icon
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(getPowerupIcon(powerup.type), 0, 0);

                ctx.restore();
            });
        }

        function getPowerupColor(type) {
            const colors = {
                shield: '#3498db',
                magnet: '#9b59b6',
                slowmo: '#1abc9c',
                double: '#e67e22'
            };
            return colors[type] || '#fff';
        }

        function getPowerupIcon(type) {
            const icons = {
                shield: 'üõ°Ô∏è',
                magnet: 'üß≤',
                slowmo: '‚è±Ô∏è',
                double: 'üíé'
            };
            return icons[type] || '?';
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.globalAlpha = p.life / p.maxLife;
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
            });
            ctx.globalAlpha = 1;
        }

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Apply screen shake offset
            const shake = getShakeOffset();
            ctx.save();
            ctx.translate(shake.x, shake.y);

            drawBackground();
            drawRoad();
            drawObstacles();
            drawCollectibles();
            drawPowerups();
            drawParticles();
            drawTruck();
            drawFloatingTexts(); // Combo and near miss text

            ctx.restore();

            // Draw damage flash overlay
            if (damageFlash.alpha > 0) {
                ctx.fillStyle = `rgba(255, 0, 0, ${damageFlash.alpha})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }

        // ============= UI UPDATES =============
        let lastDisplayedLevel = 1;
        let lastAnnouncedMilestone = 0;

        function updateHUD() {
            // Use cached DOM references for performance
            hudElements.score.textContent = score;
            hudElements.highScore.textContent = highScore;
            hudElements.distance.textContent = Math.floor(distance) + 'm';
            hudElements.level.textContent = level;

            // Announce score milestones for screen reader users
            const milestone = Math.floor(score / 1000) * 1000;
            if (milestone > lastAnnouncedMilestone && milestone > 0) {
                announceToScreenReader(`Score milestone: ${milestone} points!`);
                lastAnnouncedMilestone = milestone;
            }

            // Update lives display
            if (hudElements.lives) {
                hudElements.lives.textContent = '‚ù§Ô∏è'.repeat(Math.max(0, lives));
            }

            // Update difficulty indicator
            const difficultyPercent = Math.min((difficulty - 1) * 50, 100); // Scale difficulty to 0-100%

            if (hudElements.difficultyFill) {
                hudElements.difficultyFill.style.width = difficultyPercent + '%';
            }
            if (hudElements.difficultyBar) {
                hudElements.difficultyBar.setAttribute('aria-valuenow', Math.round(difficultyPercent));
            }
            if (hudElements.difficultyDisplay) {
                hudElements.difficultyDisplay.textContent = difficulty.toFixed(1) + 'x';
            }

            // Pulse animation and announcement when level increases
            if (level > lastDisplayedLevel && hudElements.difficultyPanel) {
                hudElements.difficultyPanel.classList.add('pulse');
                setTimeout(() => hudElements.difficultyPanel.classList.remove('pulse'), 500);
                announceToScreenReader(`Level ${level} reached!`);
                lastDisplayedLevel = level;
            }
        }

        function updateHighScoreDisplay() {
            hudElements.highScore.textContent = highScore;
        }

        function updateStatsDisplay() {
            const stats = `
                <div class="stat-item">
                    <div class="stat-label">Total Games</div>
                    <div class="stat-value">${gameData.totalGames || 0}</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">High Score</div>
                    <div class="stat-value">${gameData.highScore || 0}</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Total Distance</div>
                    <div class="stat-value">${gameData.totalDistance || 0}m</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Total Coins</div>
                    <div class="stat-value">${gameData.totalCoins || 0}</div>
                </div>
            `;
            document.getElementById('statsDisplay').innerHTML = stats;
        }

        // ============= CONTROLS =============
        function updateControlScheme() {
            document.querySelectorAll('.control-option').forEach(opt => {
                const isSelected = opt.dataset.scheme === controlScheme;
                opt.classList.toggle('selected', isSelected);
                opt.setAttribute('aria-checked', isSelected); // Dynamic ARIA update
            });

            const touchControls = document.getElementById('touchControls');
            if (controlScheme === 'touch') {
                touchControls.classList.add('active');
            } else {
                touchControls.classList.remove('active');
            }

            gameData.settings.controlScheme = controlScheme;
            saveData();
        }

        // Keyboard controls
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;

            if (gameState === 'playing') {
                if (e.key === 'p' || e.key === 'P' || e.key === 'Escape') {
                    pauseGame();
                }
                if (e.key === 'm' || e.key === 'M') {
                    soundEnabled = !soundEnabled;
                    gameData.settings.soundEnabled = soundEnabled;
                    saveData();
                    updateSoundIndicator();
                    showToast(soundEnabled ? 'Sound ON' : 'Sound OFF');
                }
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Touch controls
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (controlScheme === 'touch' && gameState === 'playing') {
                const touch = e.touches[0];
                touchStartX = touch.clientX;
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (controlScheme === 'touch' && gameState === 'playing') {
                const touch = e.touches[0];
                const deltaX = touch.clientX - touchStartX;
                truck.targetX += deltaX * 0.5;
                touchStartX = touch.clientX;
            }
        });

        // Touch button controls with visual persistence
        const touchLeft = document.getElementById('touchLeft');
        const touchRight = document.getElementById('touchRight');
        const touchBoost = document.getElementById('touchBoost');

        touchLeft.addEventListener('touchstart', (e) => {
            e.preventDefault();
            keys['ArrowLeft'] = true;
            touchLeft.classList.add('holding');
        });

        touchLeft.addEventListener('touchend', (e) => {
            e.preventDefault();
            keys['ArrowLeft'] = false;
            touchLeft.classList.remove('holding');
        });

        touchRight.addEventListener('touchstart', (e) => {
            e.preventDefault();
            keys['ArrowRight'] = true;
            touchRight.classList.add('holding');
        });

        touchRight.addEventListener('touchend', (e) => {
            e.preventDefault();
            keys['ArrowRight'] = false;
            touchRight.classList.remove('holding');
        });

        touchBoost.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isBoosting = true;
            // Audio/haptic feedback before visual for perceived responsiveness
            triggerHaptic('powerup');
            playSound('boost');
            touchBoost.classList.add('holding');
        });

        touchBoost.addEventListener('touchend', (e) => {
            e.preventDefault();
            isBoosting = false;
            touchBoost.classList.remove('holding');
        });

        function processInput() {
            if (gameState !== 'playing') return;

            // Keyboard controls
            if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
                truck.targetX -= CONFIG.STEERING_SPEED;
            }
            if (keys['ArrowRight'] || keys['d'] || keys['D']) {
                truck.targetX += CONFIG.STEERING_SPEED;
            }
            if (keys[' ']) {
                if (!isBoosting) {
                    isBoosting = true;
                    playSound('boost');
                }
            } else {
                isBoosting = false;
            }
        }

        // ============= GAME LOOP =============
        function gameLoop(timestamp = 0) {
            if (gameState !== 'playing') return;

            // Frame rate limiting for consistent speed on 120Hz+ displays
            const deltaTime = timestamp - lastFrameTime;
            if (deltaTime < FRAME_DURATION) {
                requestAnimationFrame(gameLoop);
                return; // Skip frame if running too fast
            }
            lastFrameTime = timestamp;

            // Apply slow motion effect with deterministic frame counting
            let shouldUpdate = true;
            if (slowMotion.active) {
                slowMotion.frameCount++;
                // Process every Nth frame where N = 1/factor (e.g., factor=0.3 means every ~3rd frame)
                const skipInterval = Math.round(1 / slowMotion.factor);
                shouldUpdate = (slowMotion.frameCount % skipInterval) === 0;
            }
            if (shouldUpdate) {
                processInput();
                updateGame();
            }

            // Always update visual effects
            updateEffects();
            render();

            requestAnimationFrame(gameLoop);
        }

        // ============= EVENT LISTENERS =============
        document.getElementById('startButton').addEventListener('click', startGame);
        document.getElementById('resumeButton').addEventListener('click', resumeGame);
        document.getElementById('restartButton').addEventListener('click', restartGame);
        document.getElementById('playAgainButton').addEventListener('click', restartGame);

        // Sound panel click handler for intuitive mute toggle
        document.getElementById('soundPanel')?.addEventListener('click', () => {
            soundEnabled = !soundEnabled;
            gameData.settings.soundEnabled = soundEnabled;
            saveData();
            updateSoundIndicator();
            showToast(soundEnabled ? 'Sound ON' : 'Sound OFF');
        });

        document.getElementById('backToMenuButton').addEventListener('click', () => {
            gameState = 'menu';
            document.getElementById('pauseMenu').classList.add('hidden');
            document.getElementById('mainMenu').classList.remove('hidden');
            document.getElementById('hud').classList.add('hidden');
        });

        document.getElementById('mainMenuButton').addEventListener('click', () => {
            gameState = 'menu';
            document.getElementById('gameOverMenu').classList.add('hidden');
            document.getElementById('mainMenu').classList.remove('hidden');
        });

        document.getElementById('helpButton').addEventListener('click', () => {
            document.getElementById('mainMenu').classList.add('hidden');
            const helpMenu = document.getElementById('helpMenu');
            helpMenu.classList.remove('hidden');
            activeFocusTrap = trapFocus(helpMenu);
        });

        document.getElementById('closeHelpButton').addEventListener('click', () => {
            releaseFocusTrap();
            document.getElementById('helpMenu').classList.add('hidden');
            document.getElementById('mainMenu').classList.remove('hidden');
        });

        document.getElementById('statsButton').addEventListener('click', () => {
            updateStatsDisplay();
            document.getElementById('mainMenu').classList.add('hidden');
            const statsMenu = document.getElementById('statsMenu');
            statsMenu.classList.remove('hidden');
            activeFocusTrap = trapFocus(statsMenu);
        });

        document.getElementById('closeStatsButton').addEventListener('click', () => {
            releaseFocusTrap();
            document.getElementById('statsMenu').classList.add('hidden');
            document.getElementById('mainMenu').classList.remove('hidden');
        });

        document.getElementById('resetStatsButton').addEventListener('click', () => {
            if (confirm('Are you sure you want to reset all statistics? This cannot be undone.')) {
                gameData = {
                    highScore: 0,
                    totalGames: 0,
                    totalDistance: 0,
                    totalCoins: 0,
                    achievements: {},
                    settings: gameData.settings
                };
                highScore = 0;
                saveData();
                updateStatsDisplay();
                updateHighScoreDisplay();
            }
        });

        document.querySelectorAll('.control-option').forEach(opt => {
            opt.addEventListener('click', () => {
                controlScheme = opt.dataset.scheme;
                updateControlScheme();
            });
        });

        window.addEventListener('resize', () => {
            canvas.width = Math.min(CONFIG.CANVAS_WIDTH, window.innerWidth);
            canvas.height = Math.min(CONFIG.CANVAS_HEIGHT, window.innerHeight);

            truck.x = canvas.width / 2;
            truck.targetX = truck.x;
        });

        // ============= KEYBOARD MENU NAVIGATION =============
        // ESC key to close menus or pause game
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                e.preventDefault();
                if (gameState === 'playing') {
                    pauseGame();
                } else if (!document.getElementById('pauseMenu').classList.contains('hidden')) {
                    resumeGame();
                } else if (!document.getElementById('helpMenu').classList.contains('hidden')) {
                    document.getElementById('helpMenu').classList.add('hidden');
                    document.getElementById('mainMenu').classList.remove('hidden');
                    document.getElementById('startButton').focus();
                } else if (!document.getElementById('statsMenu').classList.contains('hidden')) {
                    document.getElementById('statsMenu').classList.add('hidden');
                    document.getElementById('mainMenu').classList.remove('hidden');
                    document.getElementById('startButton').focus();
                }
            }

            // Enter/Space to activate focused button
            if ((e.key === 'Enter' || e.key === ' ') && document.activeElement.classList.contains('menu-button')) {
                e.preventDefault();
                document.activeElement.click();
            }

            // Arrow keys for control scheme selector when focused
            if (document.activeElement.classList.contains('control-option')) {
                const options = Array.from(document.querySelectorAll('.control-option'));
                const currentIndex = options.indexOf(document.activeElement);

                if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    const nextIndex = (currentIndex + 1) % options.length;
                    options[nextIndex].focus();
                } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
                    e.preventDefault();
                    const prevIndex = (currentIndex - 1 + options.length) % options.length;
                    options[prevIndex].focus();
                } else if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    document.activeElement.click();
                }
            }
        });

        // Focus first button when menu opens
        const observeMenuVisibility = (menuId, buttonId) => {
            const menu = document.getElementById(menuId);
            const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    if (mutation.attributeName === 'class' && !menu.classList.contains('hidden')) {
                        const button = document.getElementById(buttonId);
                        if (button) setTimeout(() => button.focus(), 50);
                    }
                });
            });
            observer.observe(menu, { attributes: true });
        };

        observeMenuVisibility('mainMenu', 'startButton');
        observeMenuVisibility('pauseMenu', 'resumeButton');
        observeMenuVisibility('gameOverMenu', 'playAgainButton');

        // ============= DATA CONTROLS EVENT LISTENERS =============
        document.getElementById('exportButton').addEventListener('click', exportData);
        document.getElementById('importButton').addEventListener('click', () => {
            document.getElementById('importFile').click();
        });
        document.getElementById('importFile').addEventListener('change', importData);

        // ============= TUTORIAL SYSTEM =============
        const tutorialSteps = [
            { title: "Welcome to Monster Truck Mayhem!", text: "Let's learn the basics. Use <b>‚Üê ‚Üí</b> or <b>A D</b> to steer your truck." },
            { title: "Collect Coins!", text: "Drive over <b>gold coins</b> to earn points. Chain 3+ coins for combo bonuses!" },
            { title: "Avoid Obstacles!", text: "Dodge <b>barriers</b>, <b>oil slicks</b>, and <b>boulders</b>. You have 3 lives!" },
            { title: "Grab Powerups!", text: "<b>üõ°Ô∏è Shield</b>, <b>üß≤ Magnet</b>, <b>‚è±Ô∏è Slow-Mo</b>, <b>üíé 2x Points</b> - watch the timer!" },
            { title: "You're Ready!", text: "Press <b>SPACE</b> to boost. Press <b>P</b> to pause. Good luck!" }
        ];

        let currentTutorialStep = 0;

        function showTutorial() {
            if (gameData.settings.tutorialCompleted) return;
            currentTutorialStep = 0;
            updateTutorialStep();
            document.getElementById('tutorialOverlay').classList.add('active');
            announceToScreenReader('Tutorial started. Follow the instructions.');
        }

        function updateTutorialStep() {
            const step = tutorialSteps[currentTutorialStep];
            document.getElementById('tutorialTitle').textContent = step.title;
            document.getElementById('tutorialText').innerHTML = step.text;
            document.getElementById('tutorialNext').textContent =
                currentTutorialStep === tutorialSteps.length - 1 ? "Start Playing!" : "Got It!";
        }

        function nextTutorialStep() {
            currentTutorialStep++;
            if (currentTutorialStep >= tutorialSteps.length) {
                closeTutorial(true);
            } else {
                updateTutorialStep();
            }
        }

        function closeTutorial(completed = false) {
            document.getElementById('tutorialOverlay').classList.remove('active');
            if (completed) {
                gameData.settings.tutorialCompleted = true;
                saveData();
                announceToScreenReader('Tutorial completed. Press Start Game to begin.');
            }
        }

        // Tutorial event listeners
        document.getElementById('tutorialNext')?.addEventListener('click', nextTutorialStep);
        document.getElementById('tutorialSkip')?.addEventListener('click', () => closeTutorial(true));

        // ============= ORIENTATION CHECK =============
        function checkOrientation() {
            const hint = document.getElementById('orientationHint');
            if (!hint) return;

            // Only show on mobile devices in portrait
            if (window.innerWidth < window.innerHeight &&
                /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent) &&
                !localStorage.getItem(CONFIG.APP_NAME + '-orientation-dismissed')) {
                hint.style.display = 'block';
            } else {
                hint.style.display = 'none';
            }
        }

        document.getElementById('dismissOrientation')?.addEventListener('click', () => {
            localStorage.setItem(CONFIG.APP_NAME + '-orientation-dismissed', 'true');
            document.getElementById('orientationHint').style.display = 'none';
        });

        window.addEventListener('resize', checkOrientation);
        window.addEventListener('orientationchange', checkOrientation);

        // Auto-pause when tab becomes hidden (battery/UX improvement)
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && gameState === 'playing') {
                pauseGame();
            }
        });

        // ============= INITIALIZATION =============
        initGame();

        // Show tutorial for first-time players
        setTimeout(() => {
            if (!gameData.settings.tutorialCompleted) {
                showTutorial();
            }
        }, 500);

        // Check orientation for mobile users
        checkOrientation();
    </script>
</body>
</html>
