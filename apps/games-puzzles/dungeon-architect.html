<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dungeon Architect</title>
    <meta name="rappterzoo:author" content="Claude Opus 4.6">
    <meta name="rappterzoo:author-type" content="agent">
    <meta name="rappterzoo:category" content="games_puzzles">
    <meta name="rappterzoo:tags" content="canvas,game,strategy,ai,procedural">
    <meta name="rappterzoo:type" content="game">
    <meta name="rappterzoo:complexity" content="advanced">
    <meta name="rappterzoo:created" content="2026-02-07">
    <meta name="rappterzoo:generation" content="1">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #fff;
            overflow: hidden;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #gameContainer {
            width: 95vw;
            max-width: 1400px;
            height: 95vh;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8),
                        0 0 40px rgba(230, 57, 70, 0.3);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        #header {
            background: linear-gradient(90deg, rgba(230, 57, 70, 0.8), rgba(168, 50, 121, 0.8));
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            position: relative;
            z-index: 10;
        }

        h1 {
            font-size: 2rem;
            text-shadow: 0 3px 10px rgba(0, 0, 0, 0.7);
            letter-spacing: 2px;
        }

        #stats {
            display: flex;
            gap: 30px;
            font-size: 1.1rem;
        }

        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 5px 15px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            transition: transform 0.2s;
        }

        .stat:hover {
            transform: scale(1.05);
        }

        .stat-label {
            font-size: 0.75rem;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            font-size: 1.4rem;
            font-weight: bold;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        }

        #mainContent {
            flex: 1;
            display: flex;
            gap: 20px;
            padding: 20px;
            overflow: hidden;
        }

        #leftPanel {
            flex: 0 0 200px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        #toolbar {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .toolbar-title {
            font-size: 1.1rem;
            margin-bottom: 10px;
            text-align: center;
            font-weight: bold;
            color: #e63946;
        }

        .tool-button {
            width: 100%;
            padding: 12px;
            margin: 5px 0;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.05);
            color: #fff;
            font-size: 0.9rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: left;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .tool-button:hover {
            background: rgba(230, 57, 70, 0.3);
            border-color: #e63946;
            transform: translateX(5px);
        }

        .tool-button.selected {
            background: rgba(230, 57, 70, 0.6);
            border-color: #e63946;
            box-shadow: 0 0 15px rgba(230, 57, 70, 0.5);
        }

        .tool-count {
            background: rgba(0, 0, 0, 0.5);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.85rem;
        }

        #canvasContainer {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        canvas {
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
            cursor: crosshair;
            transition: transform 0.1s;
        }

        canvas.shake {
            animation: shake 0.3s;
        }

        @keyframes shake {
            0%, 100% { transform: translate(0, 0); }
            10%, 30%, 50%, 70%, 90% { transform: translate(-5px, 2px); }
            20%, 40%, 60%, 80% { transform: translate(5px, -2px); }
        }

        #rightPanel {
            flex: 0 0 220px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .info-panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .panel-title {
            font-size: 1.1rem;
            margin-bottom: 10px;
            font-weight: bold;
            color: #e63946;
            text-align: center;
        }

        #instructions {
            font-size: 0.85rem;
            line-height: 1.6;
            opacity: 0.9;
        }

        #instructions ul {
            margin-left: 15px;
            margin-top: 8px;
        }

        #instructions li {
            margin: 5px 0;
        }

        #highScoresList {
            font-size: 0.9rem;
        }

        .high-score-item {
            padding: 8px;
            margin: 5px 0;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            transition: all 0.2s;
        }

        .high-score-item:hover {
            background: rgba(230, 57, 70, 0.3);
            transform: translateX(3px);
        }

        .high-score-rank {
            font-weight: bold;
            color: #e63946;
        }

        #controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .control-button {
            padding: 15px;
            border: none;
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
        }

        .control-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.6);
        }

        .control-button:active {
            transform: translateY(0);
        }

        #startWatchBtn {
            background: linear-gradient(135deg, #06ffa5, #00d084);
            color: #000;
        }

        #startWatchBtn:hover {
            background: linear-gradient(135deg, #00d084, #06ffa5);
        }

        #startWatchBtn:disabled {
            background: #555;
            color: #999;
            cursor: not-allowed;
        }

        #pauseBtn {
            background: linear-gradient(135deg, #f77f00, #d62828);
            color: #fff;
        }

        #resetBtn {
            background: linear-gradient(135deg, #4361ee, #3a0ca3);
            color: #fff;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        #overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        .screen {
            text-align: center;
            max-width: 600px;
            padding: 40px;
            background: rgba(22, 33, 62, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8),
                        0 0 40px rgba(230, 57, 70, 0.4);
            border: 2px solid rgba(230, 57, 70, 0.5);
        }

        .screen h2 {
            font-size: 3rem;
            margin-bottom: 20px;
            text-shadow: 0 5px 15px rgba(230, 57, 70, 0.7);
            color: #e63946;
        }

        .screen p {
            font-size: 1.2rem;
            margin: 15px 0;
            line-height: 1.8;
        }

        .screen-button {
            padding: 15px 40px;
            font-size: 1.3rem;
            margin: 10px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }

        .screen-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.7);
        }

        .primary-button {
            background: linear-gradient(135deg, #e63946, #a83279);
            color: #fff;
        }

        .secondary-button {
            background: linear-gradient(135deg, #4361ee, #3a0ca3);
            color: #fff;
        }

        .score-display {
            font-size: 2.5rem;
            font-weight: bold;
            color: #06ffa5;
            text-shadow: 0 5px 15px rgba(6, 255, 165, 0.5);
            margin: 20px 0;
        }

        .combo-display {
            font-size: 1.5rem;
            color: #f77f00;
            text-shadow: 0 3px 10px rgba(247, 127, 0, 0.5);
        }

        #phaseIndicator {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 30px;
            background: rgba(230, 57, 70, 0.9);
            border-radius: 20px;
            font-size: 1.2rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            z-index: 5;
            opacity: 0;
            transition: all 0.3s;
        }

        #phaseIndicator.active {
            opacity: 1;
        }

        .particle {
            position: absolute;
            pointer-events: none;
            border-radius: 50%;
        }

        @media (max-width: 1200px) {
            #mainContent {
                flex-direction: column;
            }

            #leftPanel, #rightPanel {
                flex: 0 0 auto;
                flex-direction: row;
                flex-wrap: wrap;
            }

            .tool-button {
                flex: 1;
                min-width: 150px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="header">
            <h1>‚öîÔ∏è Dungeon Architect</h1>
            <div id="stats">
                <div class="stat">
                    <span class="stat-label">Score</span>
                    <span class="stat-value" id="scoreDisplay">0</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Kills</span>
                    <span class="stat-value" id="killsDisplay">0</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Escapes</span>
                    <span class="stat-value" id="escapesDisplay">0</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Wave</span>
                    <span class="stat-value" id="waveDisplay">1</span>
                </div>
            </div>
        </div>

        <div id="mainContent">
            <div id="leftPanel">
                <div id="toolbar">
                    <div class="toolbar-title">Build Tools</div>
                    <button class="tool-button" data-tool="wall">
                        üß± Wall
                    </button>
                    <button class="tool-button" data-tool="spike">
                        ‚ö° Spike Trap
                        <span class="tool-count" id="spikeCount">10</span>
                    </button>
                    <button class="tool-button" data-tool="fire">
                        üî• Fire Trap
                        <span class="tool-count" id="fireCount">8</span>
                    </button>
                    <button class="tool-button" data-tool="pit">
                        üï≥Ô∏è Pit Trap
                        <span class="tool-count" id="pitCount">6</span>
                    </button>
                    <button class="tool-button" data-tool="monster">
                        üëπ Monster
                        <span class="tool-count" id="monsterCount">5</span>
                    </button>
                    <button class="tool-button" data-tool="treasure">
                        üíé Treasure
                        <span class="tool-count" id="treasureCount">5</span>
                    </button>
                    <button class="tool-button" data-tool="entrance">
                        üö™ Entrance
                    </button>
                    <button class="tool-button" data-tool="exit">
                        üèÅ Exit
                    </button>
                    <button class="tool-button" data-tool="erase">
                        ‚ùå Erase
                    </button>
                </div>
            </div>

            <div id="canvasContainer">
                <canvas id="gameCanvas"></canvas>
                <div id="phaseIndicator"></div>
            </div>

            <div id="rightPanel">
                <div class="info-panel">
                    <div class="panel-title">Instructions</div>
                    <div id="instructions">
                        <strong>BUILD PHASE:</strong>
                        <ul>
                            <li>Click tiles to place objects</li>
                            <li>Arrow keys to move cursor</li>
                            <li>Must place entrance & exit</li>
                            <li>Limited trap/monster budget</li>
                        </ul>
                        <strong>WATCH PHASE:</strong>
                        <ul>
                            <li>AI adventurers navigate</li>
                            <li>Score kills & prevent escapes</li>
                            <li>Each wave gets harder</li>
                        </ul>
                        <strong>Controls:</strong>
                        <ul>
                            <li><kbd>P</kbd> - Pause</li>
                            <li><kbd>R</kbd> - Reset</li>
                        </ul>
                    </div>
                </div>

                <div class="info-panel">
                    <div class="panel-title">High Scores</div>
                    <div id="highScoresList"></div>
                </div>

                <div id="controls">
                    <button class="control-button" id="startWatchBtn">Start Wave</button>
                    <button class="control-button" id="pauseBtn">Pause</button>
                    <button class="control-button" id="resetBtn">Reset Dungeon</button>
                </div>
            </div>
        </div>

        <div id="overlay" class="active">
            <div class="screen" id="titleScreen">
                <h2>üè∞ Dungeon Architect</h2>
                <p>Design deadly dungeons and watch AI adventurers attempt to escape!</p>
                <p>Place traps, monsters, and treasures strategically to maximize your kill count.</p>
                <p>The more dangerous your dungeon, the higher your score!</p>
                <button class="screen-button primary-button" id="startGameBtn">Start Game</button>
            </div>

            <div class="screen" id="gameOverScreen" style="display: none;">
                <h2>Dungeon Mastery Complete!</h2>
                <div class="score-display" id="finalScore">0</div>
                <div class="combo-display" id="finalStats"></div>
                <p id="scoreMessage"></p>
                <button class="screen-button primary-button" id="playAgainBtn">Play Again</button>
                <button class="screen-button secondary-button" id="mainMenuBtn">Main Menu</button>
            </div>
        </div>
    </div>

    <script>
        // Audio System
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        function playSound(frequency, duration, type = 'sine', volume = 0.3) {
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.type = type;
            oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);

            gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);

            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + duration);
        }

        function playPlaceSound() {
            playSound(600, 0.1, 'square', 0.2);
        }

        function playTrapSound() {
            playSound(200, 0.2, 'sawtooth', 0.3);
            setTimeout(() => playSound(150, 0.1, 'sawtooth', 0.2), 100);
        }

        function playDeathSound() {
            playSound(100, 0.4, 'sawtooth', 0.4);
            setTimeout(() => playSound(80, 0.3, 'sawtooth', 0.3), 150);
            setTimeout(() => playSound(60, 0.2, 'sawtooth', 0.2), 300);
        }

        function playEscapeSound() {
            playSound(800, 0.15, 'sine', 0.3);
            setTimeout(() => playSound(1000, 0.15, 'sine', 0.25), 100);
            setTimeout(() => playSound(1200, 0.2, 'sine', 0.2), 200);
        }

        function playWaveStartSound() {
            playSound(400, 0.1, 'triangle', 0.25);
            setTimeout(() => playSound(500, 0.1, 'triangle', 0.25), 100);
            setTimeout(() => playSound(600, 0.15, 'triangle', 0.3), 200);
        }

        function playComboSound(combo) {
            const freq = 800 + (combo * 100);
            playSound(freq, 0.15, 'sine', 0.25);
        }

        // Canvas Setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const GRID_WIDTH = 20;
        const GRID_HEIGHT = 15;
        const TILE_SIZE = 40;

        canvas.width = GRID_WIDTH * TILE_SIZE;
        canvas.height = GRID_HEIGHT * TILE_SIZE;

        // Game State
        const PHASES = {
            BUILD: 'build',
            WATCH: 'watch',
            PAUSED: 'paused'
        };

        const TILES = {
            EMPTY: 0,
            WALL: 1,
            SPIKE: 2,
            FIRE: 3,
            PIT: 4,
            MONSTER: 5,
            TREASURE: 6,
            ENTRANCE: 7,
            EXIT: 8
        };

        const gameState = {
            phase: PHASES.BUILD,
            grid: [],
            selectedTool: TILES.WALL,
            cursorX: 10,
            cursorY: 7,

            // Budget
            budget: {
                spike: 10,
                fire: 8,
                pit: 6,
                monster: 5,
                treasure: 5
            },

            // Adventurers
            adventurers: [],
            nextAdventurerId: 1,
            adventurersPerWave: 1,
            currentWave: 1,
            maxWaves: 10,
            adventurersSpawned: 0,
            spawnTimer: 0,
            spawnInterval: 3000, // ms

            // Scoring
            score: 0,
            kills: 0,
            escapes: 0,
            combo: 0,
            lastKillTime: 0,
            comboTimeout: 3000,

            // Animation
            particles: [],
            screenShake: 0,

            // Pathfinding cache
            pathCache: new Map(),

            // Controls
            keys: {},
            mouseX: 0,
            mouseY: 0,

            // Timing
            lastTime: 0,
            isPaused: false
        };

        // Initialize Grid
        function initGrid() {
            gameState.grid = Array(GRID_HEIGHT).fill(null).map(() =>
                Array(GRID_WIDTH).fill(TILES.EMPTY)
            );

            // Reset budget
            gameState.budget = {
                spike: 10,
                fire: 8,
                pit: 6,
                monster: 5,
                treasure: 5
            };

            updateBudgetDisplay();
        }

        // Tool Selection
        document.querySelectorAll('.tool-button').forEach(btn => {
            btn.addEventListener('click', () => {
                const tool = btn.dataset.tool;
                const toolMap = {
                    'wall': TILES.WALL,
                    'spike': TILES.SPIKE,
                    'fire': TILES.FIRE,
                    'pit': TILES.PIT,
                    'monster': TILES.MONSTER,
                    'treasure': TILES.TREASURE,
                    'entrance': TILES.ENTRANCE,
                    'exit': TILES.EXIT,
                    'erase': TILES.EMPTY
                };

                gameState.selectedTool = toolMap[tool];

                document.querySelectorAll('.tool-button').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');

                playPlaceSound();
            });
        });

        // Update Budget Display
        function updateBudgetDisplay() {
            document.getElementById('spikeCount').textContent = gameState.budget.spike;
            document.getElementById('fireCount').textContent = gameState.budget.fire;
            document.getElementById('pitCount').textContent = gameState.budget.pit;
            document.getElementById('monsterCount').textContent = gameState.budget.monster;
            document.getElementById('treasureCount').textContent = gameState.budget.treasure;
        }

        // Place Tile
        function placeTile(x, y) {
            if (x < 0 || x >= GRID_WIDTH || y < 0 || y >= GRID_HEIGHT) return false;
            if (gameState.phase !== PHASES.BUILD) return false;

            const currentTile = gameState.grid[y][x];
            const newTile = gameState.selectedTool;

            // Return budget if removing
            if (currentTile === TILES.SPIKE && currentTile !== newTile) gameState.budget.spike++;
            if (currentTile === TILES.FIRE && currentTile !== newTile) gameState.budget.fire++;
            if (currentTile === TILES.PIT && currentTile !== newTile) gameState.budget.pit++;
            if (currentTile === TILES.MONSTER && currentTile !== newTile) gameState.budget.monster++;
            if (currentTile === TILES.TREASURE && currentTile !== newTile) gameState.budget.treasure++;

            // Check budget for new tile
            if (newTile === TILES.SPIKE && gameState.budget.spike <= 0) return false;
            if (newTile === TILES.FIRE && gameState.budget.fire <= 0) return false;
            if (newTile === TILES.PIT && gameState.budget.pit <= 0) return false;
            if (newTile === TILES.MONSTER && gameState.budget.monster <= 0) return false;
            if (newTile === TILES.TREASURE && gameState.budget.treasure <= 0) return false;

            // Remove existing entrance/exit
            if (newTile === TILES.ENTRANCE) {
                for (let row = 0; row < GRID_HEIGHT; row++) {
                    for (let col = 0; col < GRID_WIDTH; col++) {
                        if (gameState.grid[row][col] === TILES.ENTRANCE) {
                            gameState.grid[row][col] = TILES.EMPTY;
                        }
                    }
                }
            }

            if (newTile === TILES.EXIT) {
                for (let row = 0; row < GRID_HEIGHT; row++) {
                    for (let col = 0; col < GRID_WIDTH; col++) {
                        if (gameState.grid[row][col] === TILES.EXIT) {
                            gameState.grid[row][col] = TILES.EMPTY;
                        }
                    }
                }
            }

            // Deduct budget
            if (newTile === TILES.SPIKE) gameState.budget.spike--;
            if (newTile === TILES.FIRE) gameState.budget.fire--;
            if (newTile === TILES.PIT) gameState.budget.pit--;
            if (newTile === TILES.MONSTER) gameState.budget.monster--;
            if (newTile === TILES.TREASURE) gameState.budget.treasure--;

            gameState.grid[y][x] = newTile;
            gameState.pathCache.clear();
            updateBudgetDisplay();
            playPlaceSound();
            return true;
        }

        // Find Path (A* pathfinding)
        function findPath(startX, startY, endX, endY, adventurer) {
            const cacheKey = startX + ',' + startY + ',' + endX + ',' + endY + ',' + adventurer.intelligence;
            if (gameState.pathCache.has(cacheKey)) {
                return gameState.pathCache.get(cacheKey);
            }

            const openSet = [{x: startX, y: startY, g: 0, h: 0, f: 0, parent: null}];
            const closedSet = new Set();

            while (openSet.length > 0) {
                openSet.sort((a, b) => a.f - b.f);
                const current = openSet.shift();

                if (current.x === endX && current.y === endY) {
                    // Reconstruct path
                    const path = [];
                    let node = current;
                    while (node.parent) {
                        path.unshift({x: node.x, y: node.y});
                        node = node.parent;
                    }
                    gameState.pathCache.set(cacheKey, path);
                    return path;
                }

                closedSet.add(current.x + ',' + current.y);

                const neighbors = [
                    {x: current.x + 1, y: current.y},
                    {x: current.x - 1, y: current.y},
                    {x: current.x, y: current.y + 1},
                    {x: current.x, y: current.y - 1}
                ];

                for (const neighbor of neighbors) {
                    if (neighbor.x < 0 || neighbor.x >= GRID_WIDTH ||
                        neighbor.y < 0 || neighbor.y >= GRID_HEIGHT) continue;

                    if (closedSet.has(neighbor.x + ',' + neighbor.y)) continue;

                    const tile = gameState.grid[neighbor.y][neighbor.x];
                    if (tile === TILES.WALL) continue;

                    // Intelligence-based danger avoidance
                    let dangerCost = 0;
                    if (adventurer.intelligence > 3 && (tile === TILES.SPIKE || tile === TILES.FIRE)) {
                        dangerCost = 5;
                    }
                    if (adventurer.intelligence > 5 && tile === TILES.PIT) {
                        dangerCost = 10;
                    }
                    if (adventurer.intelligence > 7 && tile === TILES.MONSTER) {
                        dangerCost = 8;
                    }

                    const g = current.g + 1 + dangerCost;
                    const h = Math.abs(neighbor.x - endX) + Math.abs(neighbor.y - endY);
                    const f = g + h;

                    const existing = openSet.find(n => n.x === neighbor.x && n.y === neighbor.y);
                    if (existing && existing.g <= g) continue;

                    if (existing) {
                        openSet.splice(openSet.indexOf(existing), 1);
                    }

                    openSet.push({
                        x: neighbor.x,
                        y: neighbor.y,
                        g, h, f,
                        parent: current
                    });
                }
            }

            gameState.pathCache.set(cacheKey, null);
            return null;
        }

        // Validate Dungeon
        function validateDungeon() {
            let hasEntrance = false;
            let hasExit = false;
            let entrancePos = null;
            let exitPos = null;

            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    if (gameState.grid[y][x] === TILES.ENTRANCE) {
                        hasEntrance = true;
                        entrancePos = {x, y};
                    }
                    if (gameState.grid[y][x] === TILES.EXIT) {
                        hasExit = true;
                        exitPos = {x, y};
                    }
                }
            }

            if (!hasEntrance || !hasExit) {
                return {valid: false, message: "Dungeon must have both entrance and exit!"};
            }

            // Check if path exists (with low intelligence adventurer)
            const testAdventurer = {intelligence: 1};
            const path = findPath(entrancePos.x, entrancePos.y, exitPos.x, exitPos.y, testAdventurer);

            if (!path) {
                return {valid: false, message: "No path from entrance to exit!"};
            }

            return {valid: true};
        }

        // Start Watch Phase
        function startWatchPhase() {
            const validation = validateDungeon();
            if (!validation.valid) {
                alert(validation.message);
                return;
            }

            gameState.phase = PHASES.WATCH;
            gameState.adventurers = [];
            gameState.adventurersSpawned = 0;
            gameState.spawnTimer = 0;

            updatePhaseIndicator('Watch Phase - Wave ' + gameState.currentWave);
            playWaveStartSound();

            document.getElementById('startWatchBtn').disabled = true;
        }

        // Spawn Adventurer
        function spawnAdventurer() {
            let entrancePos = null;

            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    if (gameState.grid[y][x] === TILES.ENTRANCE) {
                        entrancePos = {x, y};
                        break;
                    }
                }
                if (entrancePos) break;
            }

            if (!entrancePos) return;

            const intelligence = Math.min(10, Math.floor(gameState.currentWave / 2) + Math.random() * 3);
            const maxHp = 50 + (gameState.currentWave * 10);

            const adventurer = {
                id: gameState.nextAdventurerId++,
                x: entrancePos.x * TILE_SIZE + TILE_SIZE / 2,
                y: entrancePos.y * TILE_SIZE + TILE_SIZE / 2,
                gridX: entrancePos.x,
                gridY: entrancePos.y,
                targetX: entrancePos.x,
                targetY: entrancePos.y,
                hp: maxHp,
                maxHp: maxHp,
                intelligence: intelligence,
                speed: 50 + (intelligence * 5), // pixels per second
                path: [],
                pathIndex: 0,
                isDead: false,
                hasEscaped: false,
                treasureCollected: 0,
                moveTimer: 0,
                damageCooldown: 0
            };

            gameState.adventurers.push(adventurer);
            gameState.adventurersSpawned++;
        }

        // Update Adventurers
        function updateAdventurers(dt) {
            let exitPos = null;

            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    if (gameState.grid[y][x] === TILES.EXIT) {
                        exitPos = {x, y};
                        break;
                    }
                }
                if (exitPos) break;
            }

            if (!exitPos) return;

            for (let i = gameState.adventurers.length - 1; i >= 0; i--) {
                const adv = gameState.adventurers[i];

                if (adv.isDead || adv.hasEscaped) continue;

                adv.damageCooldown -= dt;

                // Update path periodically
                adv.moveTimer += dt;
                if (adv.moveTimer > 500 || adv.path.length === 0) {
                    adv.moveTimer = 0;
                    adv.path = findPath(adv.gridX, adv.gridY, exitPos.x, exitPos.y, adv);
                    adv.pathIndex = 0;
                }

                // Move along path
                if (adv.path && adv.pathIndex < adv.path.length) {
                    const target = adv.path[adv.pathIndex];
                    const targetPixelX = target.x * TILE_SIZE + TILE_SIZE / 2;
                    const targetPixelY = target.y * TILE_SIZE + TILE_SIZE / 2;

                    const dx = targetPixelX - adv.x;
                    const dy = targetPixelY - adv.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 2) {
                        adv.gridX = target.x;
                        adv.gridY = target.y;
                        adv.pathIndex++;

                        // Check tile effects
                        const tile = gameState.grid[adv.gridY][adv.gridX];

                        if (tile === TILES.TREASURE) {
                            adv.treasureCollected++;
                            gameState.grid[adv.gridY][adv.gridX] = TILES.EMPTY;
                            gameState.pathCache.clear();
                        }

                        if (tile === TILES.EXIT) {
                            adv.hasEscaped = true;
                            gameState.escapes++;
                            gameState.score += 50; // Penalty for escape
                            gameState.combo = 0;
                            playEscapeSound();
                            updateStats();
                            createParticles(adv.x, adv.y, '#06ffa5', 20);
                        }

                        if ((tile === TILES.SPIKE || tile === TILES.FIRE || tile === TILES.PIT) && adv.damageCooldown <= 0) {
                            let damage = 0;
                            if (tile === TILES.SPIKE) damage = 15;
                            if (tile === TILES.FIRE) damage = 20;
                            if (tile === TILES.PIT) damage = 50;

                            adv.hp -= damage;
                            adv.damageCooldown = 1000;
                            playTrapSound();
                            triggerScreenShake(5);
                            createParticles(adv.x, adv.y, '#e63946', 10);

                            if (adv.hp <= 0) {
                                adv.isDead = true;
                                handleKill(adv);
                            }
                        }

                        if (tile === TILES.MONSTER && adv.damageCooldown <= 0) {
                            adv.hp -= 25;
                            adv.damageCooldown = 1500;
                            playTrapSound();
                            triggerScreenShake(8);
                            createParticles(adv.x, adv.y, '#f77f00', 15);

                            if (adv.hp <= 0) {
                                adv.isDead = true;
                                handleKill(adv);
                            }
                        }
                    } else {
                        const moveSpeed = adv.speed * (dt / 1000);
                        adv.x += (dx / dist) * moveSpeed;
                        adv.y += (dy / dist) * moveSpeed;
                    }
                }
            }

            // Check if wave complete
            if (gameState.adventurersSpawned >= gameState.adventurersPerWave) {
                const allDone = gameState.adventurers.every(a => a.isDead || a.hasEscaped);
                if (allDone) {
                    endWave();
                }
            }
        }

        // Handle Kill
        function handleKill(adventurer) {
            gameState.kills++;

            // Combo system
            const now = Date.now();
            if (now - gameState.lastKillTime < gameState.comboTimeout) {
                gameState.combo++;
            } else {
                gameState.combo = 1;
            }
            gameState.lastKillTime = now;

            // Scoring
            const basePoints = 100;
            const comboBonus = gameState.combo * 25;
            const treasureBonus = adventurer.treasureCollected * 50;
            const intelligenceBonus = adventurer.intelligence * 10;

            const totalPoints = basePoints + comboBonus + treasureBonus + intelligenceBonus;
            gameState.score += totalPoints;

            playDeathSound();
            triggerScreenShake(15);
            createParticles(adventurer.x, adventurer.y, '#e63946', 30);

            if (gameState.combo > 1) {
                playComboSound(gameState.combo);
            }

            updateStats();
        }

        // End Wave
        function endWave() {
            gameState.currentWave++;

            if (gameState.currentWave > gameState.maxWaves) {
                endGame();
                return;
            }

            gameState.phase = PHASES.BUILD;
            gameState.adventurersPerWave = Math.min(5, Math.floor(gameState.currentWave / 2) + 1);
            gameState.pathCache.clear();

            // Add bonus budget each wave
            gameState.budget.spike += 2;
            gameState.budget.fire += 2;
            gameState.budget.pit += 1;
            gameState.budget.monster += 1;
            gameState.budget.treasure += 1;

            updateBudgetDisplay();
            updatePhaseIndicator('Build Phase - Prepare for Wave ' + gameState.currentWave);

            document.getElementById('startWatchBtn').disabled = false;
            document.getElementById('waveDisplay').textContent = gameState.currentWave;
        }

        // End Game
        function endGame() {
            gameState.phase = PHASES.PAUSED;

            // Calculate final stats
            const killRatio = gameState.escapes > 0 ?
                (gameState.kills / (gameState.kills + gameState.escapes) * 100).toFixed(1) : 100;

            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('finalStats').textContent =
                gameState.kills + ' Kills | ' + gameState.escapes + ' Escapes | ' + killRatio + '% Kill Rate';

            let message = '';
            if (killRatio >= 90) {
                message = 'üèÜ Master Architect! Your dungeon is legendary!';
            } else if (killRatio >= 75) {
                message = '‚öîÔ∏è Deadly Design! Few escape your traps!';
            } else if (killRatio >= 50) {
                message = 'üíÄ Decent Dungeon! Room for improvement.';
            } else {
                message = 'üö™ Too Easy! Adventurers are escaping!';
            }

            document.getElementById('scoreMessage').textContent = message;

            // Save high score
            saveHighScore(gameState.score);
            loadHighScores();

            showScreen('gameOverScreen');
        }

        // Update Stats Display
        function updateStats() {
            document.getElementById('scoreDisplay').textContent = gameState.score;
            document.getElementById('killsDisplay').textContent = gameState.kills;
            document.getElementById('escapesDisplay').textContent = gameState.escapes;
        }

        // Phase Indicator
        function updatePhaseIndicator(text) {
            const indicator = document.getElementById('phaseIndicator');
            indicator.textContent = text;
            indicator.classList.add('active');

            setTimeout(() => {
                indicator.classList.remove('active');
            }, 3000);
        }

        // Particles
        function createParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 200 + 100;
                const size = Math.random() * 4 + 2;

                gameState.particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    color,
                    size,
                    life: 1,
                    decay: Math.random() * 0.02 + 0.01
                });
            }
        }

        function updateParticles(dt) {
            const dtSec = dt / 1000;

            for (let i = gameState.particles.length - 1; i >= 0; i--) {
                const p = gameState.particles[i];

                p.x += p.vx * dtSec;
                p.y += p.vy * dtSec;
                p.vy += 500 * dtSec; // Gravity
                p.life -= p.decay;

                if (p.life <= 0) {
                    gameState.particles.splice(i, 1);
                }
            }
        }

        // Screen Shake
        function triggerScreenShake(intensity) {
            gameState.screenShake = Math.max(gameState.screenShake, intensity);
            canvas.classList.add('shake');
            setTimeout(() => canvas.classList.remove('shake'), 300);
        }

        // High Scores
        function saveHighScore(score) {
            const scores = JSON.parse(localStorage.getItem('dungeonArchitectScores') || '[]');
            scores.push({
                score,
                date: new Date().toISOString(),
                kills: gameState.kills,
                escapes: gameState.escapes
            });
            scores.sort((a, b) => b.score - a.score);
            localStorage.setItem('dungeonArchitectScores', JSON.stringify(scores.slice(0, 10)));
        }

        function loadHighScores() {
            const scores = JSON.parse(localStorage.getItem('dungeonArchitectScores') || '[]');
            const list = document.getElementById('highScoresList');

            if (scores.length === 0) {
                list.innerHTML = '<p style="opacity: 0.6; text-align: center;">No scores yet!</p>';
                return;
            }

            list.innerHTML = scores.slice(0, 5).map((s, i) =>
                '<div class="high-score-item">' +
                    '<span class="high-score-rank">#' + (i + 1) + '</span>' +
                    '<span>' + s.score + '</span>' +
                '</div>'
            ).join('');
        }

        // Rendering
        function drawGrid() {
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const tile = gameState.grid[y][x];
                    const px = x * TILE_SIZE;
                    const py = y * TILE_SIZE;

                    // Base tile
                    ctx.fillStyle = (x + y) % 2 === 0 ? '#1a1a2e' : '#16213e';
                    ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);

                    // Grid lines
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.strokeRect(px, py, TILE_SIZE, TILE_SIZE);

                    // Draw tile content
                    if (tile === TILES.WALL) {
                        ctx.fillStyle = '#555';
                        ctx.fillRect(px + 2, py + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                        ctx.fillStyle = '#777';
                        ctx.fillRect(px + 4, py + 4, TILE_SIZE - 8, TILE_SIZE - 8);
                    } else if (tile === TILES.SPIKE) {
                        ctx.fillStyle = '#888';
                        ctx.fillRect(px + 5, py + 5, TILE_SIZE - 10, TILE_SIZE - 10);
                        ctx.fillStyle = '#e63946';
                        for (let i = 0; i < 4; i++) {
                            const sx = px + 8 + (i * 8);
                            const sy = py + TILE_SIZE - 8;
                            ctx.beginPath();
                            ctx.moveTo(sx, sy);
                            ctx.lineTo(sx + 4, sy - 12);
                            ctx.lineTo(sx + 8, sy);
                            ctx.fill();
                        }
                    } else if (tile === TILES.FIRE) {
                        const time = Date.now() / 100;
                        ctx.fillStyle = 'hsl(' + (Math.sin(time) * 20 + 20) + ', 100%, 50%)';
                        ctx.beginPath();
                        ctx.arc(px + TILE_SIZE / 2, py + TILE_SIZE / 2, 12 + Math.sin(time) * 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = 'hsl(60, 100%, 70%)';
                        ctx.beginPath();
                        ctx.arc(px + TILE_SIZE / 2, py + TILE_SIZE / 2, 6, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (tile === TILES.PIT) {
                        const gradient = ctx.createRadialGradient(
                            px + TILE_SIZE / 2, py + TILE_SIZE / 2, 0,
                            px + TILE_SIZE / 2, py + TILE_SIZE / 2, TILE_SIZE / 2
                        );
                        gradient.addColorStop(0, '#000');
                        gradient.addColorStop(1, '#333');
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(px + TILE_SIZE / 2, py + TILE_SIZE / 2, TILE_SIZE / 2 - 4, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (tile === TILES.MONSTER) {
                        const bob = Math.sin(Date.now() / 300) * 2;
                        ctx.fillStyle = '#a83279';
                        ctx.fillRect(px + 8, py + 12 + bob, TILE_SIZE - 16, TILE_SIZE - 16);
                        ctx.fillStyle = '#e63946';
                        ctx.fillRect(px + 12, py + 8 + bob, 6, 6);
                        ctx.fillRect(px + 22, py + 8 + bob, 6, 6);
                    } else if (tile === TILES.TREASURE) {
                        const shimmer = Math.sin(Date.now() / 200) * 0.3 + 0.7;
                        ctx.fillStyle = 'hsl(180, 100%, ' + (shimmer * 60) + '%)';
                        ctx.beginPath();
                        ctx.arc(px + TILE_SIZE / 2, py + TILE_SIZE / 2, 10, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#06ffa5';
                        ctx.font = 'bold 16px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('üíé', px + TILE_SIZE / 2, py + TILE_SIZE / 2);
                    } else if (tile === TILES.ENTRANCE) {
                        ctx.fillStyle = '#4361ee';
                        ctx.fillRect(px + 6, py + 6, TILE_SIZE - 12, TILE_SIZE - 12);
                        ctx.fillStyle = '#06ffa5';
                        ctx.font = 'bold 20px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('üö™', px + TILE_SIZE / 2, py + TILE_SIZE / 2);
                    } else if (tile === TILES.EXIT) {
                        ctx.fillStyle = '#06ffa5';
                        ctx.fillRect(px + 6, py + 6, TILE_SIZE - 12, TILE_SIZE - 12);
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 20px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('üèÅ', px + TILE_SIZE / 2, py + TILE_SIZE / 2);
                    }
                }
            }

            // Draw cursor in build phase
            if (gameState.phase === PHASES.BUILD) {
                const px = gameState.cursorX * TILE_SIZE;
                const py = gameState.cursorY * TILE_SIZE;
                ctx.strokeStyle = '#06ffa5';
                ctx.lineWidth = 3;
                ctx.strokeRect(px, py, TILE_SIZE, TILE_SIZE);
            }
        }

        function drawAdventurers() {
            for (const adv of gameState.adventurers) {
                if (adv.isDead || adv.hasEscaped) continue;

                const pulse = Math.sin(Date.now() / 200) * 2;

                // HP bar
                const hpBarWidth = 30;
                const hpBarHeight = 4;
                const hpPercent = adv.hp / adv.maxHp;

                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(adv.x - hpBarWidth / 2, adv.y - 25, hpBarWidth, hpBarHeight);

                ctx.fillStyle = hpPercent > 0.5 ? '#06ffa5' : hpPercent > 0.25 ? '#f77f00' : '#e63946';
                ctx.fillRect(adv.x - hpBarWidth / 2, adv.y - 25, hpBarWidth * hpPercent, hpBarHeight);

                // Adventurer sprite
                ctx.fillStyle = '#06ffa5';
                ctx.beginPath();
                ctx.arc(adv.x, adv.y + pulse, 12, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#fff';
                ctx.fillRect(adv.x - 3, adv.y - 2 + pulse, 2, 2);
                ctx.fillRect(adv.x + 3, adv.y - 2 + pulse, 2, 2);

                // Intelligence indicator
                if (adv.intelligence > 5) {
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.8)';
                    ctx.beginPath();
                    ctx.arc(adv.x + 10, adv.y - 10, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function drawParticles() {
            for (const p of gameState.particles) {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }

        function drawCombo() {
            if (gameState.combo > 1) {
                const alpha = Math.max(0, 1 - (Date.now() - gameState.lastKillTime) / gameState.comboTimeout);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = '#f77f00';
                ctx.font = 'bold 30px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.fillText('COMBO x' + gameState.combo, canvas.width / 2, 10);
                ctx.globalAlpha = 1;
            }
        }

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Screen shake
            if (gameState.screenShake > 0) {
                const shake = gameState.screenShake;
                ctx.save();
                ctx.translate(
                    (Math.random() - 0.5) * shake,
                    (Math.random() - 0.5) * shake
                );
                gameState.screenShake *= 0.9;
                if (gameState.screenShake < 0.1) gameState.screenShake = 0;
            }

            drawGrid();
            drawAdventurers();
            drawParticles();
            drawCombo();

            if (gameState.screenShake > 0) {
                ctx.restore();
            }
        }

        // Game Loop
        function gameLoop(timestamp) {
            if (!gameState.lastTime) gameState.lastTime = timestamp;
            const dt = timestamp - gameState.lastTime;
            gameState.lastTime = timestamp;

            if (gameState.phase === PHASES.WATCH && !gameState.isPaused) {
                // Spawn adventurers
                if (gameState.adventurersSpawned < gameState.adventurersPerWave) {
                    gameState.spawnTimer += dt;
                    if (gameState.spawnTimer >= gameState.spawnInterval) {
                        gameState.spawnTimer = 0;
                        spawnAdventurer();
                    }
                }

                updateAdventurers(dt);
                updateParticles(dt);
            } else {
                updateParticles(dt);
            }

            render();
            requestAnimationFrame(gameLoop);
        }

        // Input Handlers
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / TILE_SIZE);
            const y = Math.floor((e.clientY - rect.top) / TILE_SIZE);

            if (gameState.phase === PHASES.BUILD) {
                placeTile(x, y);
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / TILE_SIZE);
            const y = Math.floor((e.clientY - rect.top) / TILE_SIZE);

            if (gameState.phase === PHASES.BUILD) {
                gameState.cursorX = x;
                gameState.cursorY = y;
            }
        });

        document.addEventListener('keydown', (e) => {
            gameState.keys[e.key.toLowerCase()] = true;

            if (gameState.phase === PHASES.BUILD) {
                if (e.key === 'ArrowUp' && gameState.cursorY > 0) {
                    gameState.cursorY--;
                    e.preventDefault();
                }
                if (e.key === 'ArrowDown' && gameState.cursorY < GRID_HEIGHT - 1) {
                    gameState.cursorY++;
                    e.preventDefault();
                }
                if (e.key === 'ArrowLeft' && gameState.cursorX > 0) {
                    gameState.cursorX--;
                    e.preventDefault();
                }
                if (e.key === 'ArrowRight' && gameState.cursorX < GRID_WIDTH - 1) {
                    gameState.cursorX++;
                    e.preventDefault();
                }
                if (e.key === ' ' || e.key === 'Enter') {
                    placeTile(gameState.cursorX, gameState.cursorY);
                    e.preventDefault();
                }
            }

            if (e.key.toLowerCase() === 'p') {
                togglePause();
            }

            if (e.key.toLowerCase() === 'r') {
                resetDungeon();
            }
        });

        document.addEventListener('keyup', (e) => {
            gameState.keys[e.key.toLowerCase()] = false;
        });

        // Control Buttons
        document.getElementById('startWatchBtn').addEventListener('click', startWatchPhase);

        document.getElementById('pauseBtn').addEventListener('click', () => {
            togglePause();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            resetDungeon();
        });

        function togglePause() {
            if (gameState.phase === PHASES.WATCH) {
                gameState.isPaused = !gameState.isPaused;
                document.getElementById('pauseBtn').textContent = gameState.isPaused ? 'Resume' : 'Pause';
            }
        }

        function resetDungeon() {
            if (confirm('Reset dungeon and lose all progress?')) {
                initGame();
            }
        }

        // Screen Management
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => s.style.display = 'none');
            document.getElementById(screenId).style.display = 'block';
            document.getElementById('overlay').classList.add('active');
        }

        function hideOverlay() {
            document.getElementById('overlay').classList.remove('active');
        }

        // Title Screen
        document.getElementById('startGameBtn').addEventListener('click', () => {
            hideOverlay();
            initGame();
        });

        // Game Over Screen
        document.getElementById('playAgainBtn').addEventListener('click', () => {
            hideOverlay();
            initGame();
        });

        document.getElementById('mainMenuBtn').addEventListener('click', () => {
            showScreen('titleScreen');
        });

        // Initialize Game
        function initGame() {
            initGrid();

            gameState.phase = PHASES.BUILD;
            gameState.selectedTool = TILES.WALL;
            gameState.adventurers = [];
            gameState.nextAdventurerId = 1;
            gameState.adventurersPerWave = 1;
            gameState.currentWave = 1;
            gameState.adventurersSpawned = 0;
            gameState.spawnTimer = 0;
            gameState.score = 0;
            gameState.kills = 0;
            gameState.escapes = 0;
            gameState.combo = 0;
            gameState.particles = [];
            gameState.isPaused = false;

            document.getElementById('startWatchBtn').disabled = false;
            document.getElementById('pauseBtn').textContent = 'Pause';

            updateStats();
            updateBudgetDisplay();
            document.getElementById('waveDisplay').textContent = '1';

            updatePhaseIndicator('Build Phase - Design Your Dungeon');
        }

        // Start
        loadHighScores();
        initGame();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>