<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>DOTA 3: LEGACY</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;800&family=Rajdhani:wght@500;700&display=swap');

        :root {
            /* Design Tokens */
            --color-bg-dark: #050508;
            --color-glass: rgba(10, 15, 25, 0.85);
            --color-glass-light: rgba(20, 30, 45, 0.7);
            --color-border: rgba(255, 255, 255, 0.1);
            --color-border-hover: rgba(255, 255, 255, 0.3);

            --accent-radiant: #00ff88;
            --accent-radiant-glow: rgba(0, 255, 136, 0.4);
            --accent-dire: #ff3c3c;
            --accent-dire-glow: rgba(255, 60, 60, 0.4);

            --text-main: #ffffff;
            --text-muted: #8899aa;

            --font-main: 'Outfit', sans-serif;
            --font-display: 'Rajdhani', sans-serif;

            --z-ui-base: 100;
            --z-ui-overlay: 200;
            --z-tooltip: 300;
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-user-drag: none;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: var(--color-bg-dark);
            color: var(--text-main);
            font-family: var(--font-main);
        }

        #game-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }

        /* --- UI OVERLAYS --- */

        /* Top Bar */
        .top-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.9), transparent);
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            z-index: var(--z-ui-base);
        }

        .score-board {
            display: flex;
            align-items: center;
            gap: 40px;
            font-family: var(--font-display);
            font-size: 28px;
            font-weight: 700;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.8);
        }

        .score-radiant {
            color: var(--accent-radiant);
        }

        .score-dire {
            color: var(--accent-dire);
        }

        .game-time {
            color: #fff;
            font-variant-numeric: tabular-nums;
            background: rgba(0, 0, 0, 0.6);
            padding: 4px 12px;
            border-radius: 4px;
            border: 1px solid var(--color-border);
            font-size: 20px;
        }

        /* Bottom HUD */
        .hud-container {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 140px;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            padding: 20px;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.95) 20%, transparent);
            z-index: var(--z-ui-base);
            pointer-events: none;
            /* Let clicks pass through empty space */
        }

        /* Portrait & Stats (Left) */
        .character-panel {
            width: 300px;
            height: 110px;
            display: flex;
            background: var(--color-glass);
            border: 1px solid var(--color-border);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            pointer-events: auto;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            transition: transform 0.2s;
        }

        .character-panel:hover {
            transform: translateY(-2px);
            border-color: var(--color-border-hover);
        }

        .portrait {
            width: 90px;
            background: #111;
            position: relative;
            overflow: hidden;
        }

        .portrait canvas {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .stats-area {
            flex: 1;
            padding: 10px 15px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .unit-name {
            font-family: var(--font-display);
            font-size: 18px;
            font-weight: 700;
            letter-spacing: 1px;
            color: #fff;
            text-transform: uppercase;
        }

        .unit-level {
            font-size: 12px;
            color: #ffd700;
            margin-left: 8px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: var(--text-muted);
        }

        .stat-val {
            color: #fff;
            font-weight: 600;
        }

        /* Center Skills & Health */
        .center-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            pointer-events: auto;
            margin-bottom: 10px;
        }

        .bars-container {
            width: 400px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .bar-wrap {
            width: 100%;
            height: 16px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            position: relative;
        }

        .bar-fill {
            height: 100%;
            transition: width 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .hp-fill {
            background: linear-gradient(90deg, #2ecc71, #27ae60);
            box-shadow: 0 0 10px rgba(46, 204, 113, 0.4);
        }

        .mp-fill {
            background: linear-gradient(90deg, #3498db, #2980b9);
            box-shadow: 0 0 10px rgba(52, 152, 219, 0.4);
        }

        .bar-text {
            position: absolute;
            width: 100%;
            top: 0;
            text-align: center;
            font-size: 10px;
            font-weight: 700;
            line-height: 14px;
            text-shadow: 0 1px 2px #000;
            opacity: 0.8;
        }

        .ability-bar {
            display: flex;
            gap: 8px;
        }

        .ability-slot {
            width: 64px;
            height: 64px;
            background: rgba(20, 20, 30, 0.8);
            border: 1px solid var(--color-border);
            border-radius: 8px;
            position: relative;
            cursor: pointer;
            transition: all 0.1s;
            overflow: hidden;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        .ability-slot:hover {
            border-color: #fff;
            transform: translateY(-2px);
        }

        .ability-slot:active {
            transform: scale(0.95);
        }

        .ability-icon {
            font-size: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }

        .hotkey {
            position: absolute;
            top: 2px;
            left: 4px;
            font-size: 10px;
            font-weight: 800;
            color: #fff;
            text-shadow: 0 1px 2px #000;
        }

        .mana-cost {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 10px;
            color: #3498db;
            font-weight: 700;
        }

        .cooldown-mask {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 0%;
            background: rgba(0, 0, 0, 0.85);
            transition: height linear;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-weight: bold;
            font-size: 14px;
        }

        /* Minimap (Right) */
        .right-panel {
            width: 220px;
            height: 220px;
            background: #000;
            border: 2px solid #333;
            border-radius: 4px;
            position: relative;
            pointer-events: auto;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        .right-panel canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Floating Combat Text */
        .damage-number {
            position: absolute;
            font-family: var(--font-display);
            font-weight: 800;
            font-size: 24px;
            pointer-events: none;
            text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
            animation: floatUp 1s ease-out forwards;
            z-index: var(--z-ui-overlay);
        }

        @keyframes floatUp {
            0% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }

            50% {
                transform: translateY(-30px) scale(1.2);
                opacity: 1;
            }

            100% {
                transform: translateY(-60px) scale(0.8);
                opacity: 0;
            }
        }

        .dmg-crit {
            color: #ff3c3c;
            font-size: 32px;
        }

        .dmg-physical {
            color: #ffffff;
        }

        .dmg-magic {
            color: #a450ff;
        }

        /* Notification Toast */
        .notification-toast {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid var(--accent-radiant);
            padding: 10px 30px;
            border-radius: 4px;
            color: #fff;
            font-family: var(--font-display);
            font-size: 24px;
            text-transform: uppercase;
            letter-spacing: 2px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .notification-toast.visible {
            opacity: 1;
        }
    </style>
</head>

<body>
    <div id="game-container"></div>

    <!-- UI Layer -->
    <div class="top-bar">
        <div class="score-board">
            <span class="score-radiant" id="score-radiant">0</span>
            <span class="game-time" id="game-time">00:00</span>
            <span class="score-dire" id="score-dire">0</span>
        </div>
    </div>

    <!-- Central Notification -->
    <div id="notification" class="notification-toast">WELCOME TO DOTA 3 LEGACY</div>

    <div class="hud-container">
        <!-- Character Stats -->
        <div class="character-panel">
            <div class="portrait" id="portrait-container">
                <!-- 3D Portrait Canvas appended here -->
            </div>
            <div class="stats-area">
                <div>
                    <span class="unit-name">Void Walker</span><span class="unit-level">Lvl 1</span>
                </div>
                <div style="margin-top: 8px;">
                    <div class="stat-row"><span>Damage</span><span class="stat-val" id="stat-dmg">45</span></div>
                    <div class="stat-row"><span>Armor</span><span class="stat-val" id="stat-armor">3</span></div>
                    <div class="stat-row"><span>Speed</span><span class="stat-val" id="stat-speed">300</span></div>
                </div>
            </div>
        </div>

        <!-- Skills -->
        <div class="center-panel">
            <div class="bars-container">
                <div class="bar-wrap">
                    <div class="bar-fill hp-fill" id="hp-bar" style="width: 100%"></div>
                    <div class="bar-text" id="hp-text">1200 / 1200</div>
                </div>
                <div class="bar-wrap">
                    <div class="bar-fill mp-fill" id="mp-bar" style="width: 100%"></div>
                    <div class="bar-text" id="mp-text">600 / 600</div>
                </div>
            </div>

            <div class="ability-bar">
                <div class="ability-slot" id="ab-q">
                    <span class="hotkey">Q</span>
                    <div class="ability-icon">üåÄ</div>
                    <span class="mana-cost">60</span>
                    <div class="cooldown-mask"></div>
                </div>
                <div class="ability-slot" id="ab-w">
                    <span class="hotkey">W</span>
                    <div class="ability-icon">‚ö°</div>
                    <span class="mana-cost">40</span>
                    <div class="cooldown-mask"></div>
                </div>
                <div class="ability-slot" id="ab-e">
                    <span class="hotkey">E</span>
                    <div class="ability-icon">üõ°Ô∏è</div>
                    <span class="mana-cost">80</span>
                    <div class="cooldown-mask"></div>
                </div>
                <div class="ability-slot" id="ab-r">
                    <span class="hotkey">R</span>
                    <div class="ability-icon">‚òÑÔ∏è</div>
                    <span class="mana-cost">150</span>
                    <div class="cooldown-mask"></div>
                </div>
            </div>
        </div>

        <!-- Minimap -->
        <div class="right-panel">
            <canvas id="minimap-canvas"></canvas>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>

    <script>
        // --- GAME ENGINE ---

        // Constants
        const TEAM_RADIANT = 'radiant';
        const TEAM_DIRE = 'dire';
        const COLOR_RADIANT = 0x00ff88;
        const COLOR_DIRE = 0xff3c3c;

        // Globals
        let scene, camera, renderer, composer;
        let clock = new THREE.Clock();
        let entities = [];
        let player = null;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let gameTime = 0;
        let score = { radiant: 0, dire: 0 };
        let portraitScene, portraitCamera, portraitRenderer, portraitMesh;

        // Visuals
        let floatingTexts = [];

        // --- CLASSES ---

        class FloatingText {
            constructor(text, x, y, z, color) {
                this.element = document.createElement('div');
                this.element.textContent = text;
                this.element.className = 'damage-number';
                this.element.style.color = color;
                document.body.appendChild(this.element);

                // Project 3D pos to 2D
                this.pos = new THREE.Vector3(x, y + 2, z);
                this.updatePosition();

                // Cleanup
                setTimeout(() => {
                    if (this.element.parentNode) this.element.parentNode.removeChild(this.element);
                    const index = floatingTexts.indexOf(this);
                    if (index > -1) floatingTexts.splice(index, 1);
                }, 1000);
            }

            updatePosition() {
                const tempV = this.pos.clone();
                tempV.project(camera);
                const x = (tempV.x * .5 + .5) * window.innerWidth;
                const y = (tempV.y * -.5 + .5) * window.innerHeight;
                this.element.style.left = `${x}px`;
                this.element.style.top = `${y}px`;
            }
        }

        class GameEntity {
            constructor(x, z, team, color) {
                this.team = team;
                this.color = color;
                this.hp = 100;
                this.maxHp = 100;
                this.dead = false;

                // Mesh
                this.mesh = new THREE.Group();
                this.mesh.position.set(x, 0, z);
                scene.add(this.mesh);

                // Physics
                this.targetPos = new THREE.Vector3(x, 0, z);
                this.speed = 0.1;
                this.radius = 0.5;
            }

            update(dt) {
                if (this.dead) return;

                // Movement
                const dist = this.mesh.position.distanceTo(this.targetPos);
                if (dist > 0.1) {
                    const dir = this.targetPos.clone().sub(this.mesh.position).normalize();
                    this.mesh.position.add(dir.multiplyScalar(this.speed));
                    this.mesh.lookAt(this.targetPos);

                    // Walk wobble
                    if (this.bodyMesh) {
                        this.bodyMesh.position.y = 0.5 + Math.sin(clock.getElapsedTime() * 10) * 0.05;
                    }
                }
            }

            takeDamage(amt, type = 'physical') {
                this.hp -= amt;
                spawnFloatingText(amt, this.mesh.position, type === 'crit' ? '#ff3c3c' : '#fff');

                // Flash
                if (this.bodyMesh) {
                    const oldInfo = this.bodyMesh.material.emissive.getHex();
                    this.bodyMesh.material.emissive.setHex(0xffffff);
                    setTimeout(() => {
                        if (this.bodyMesh) this.bodyMesh.material.emissive.setHex(oldInfo);
                    }, 100);
                }

                if (this.hp <= 0 && !this.dead) {
                    this.die();
                }
            }

            die() {
                this.dead = true;
                scene.remove(this.mesh);

                if (this.team === TEAM_RADIANT) score.dire++;
                else score.radiant++;
                updateScoreBoard();
            }
        }

        class Hero extends GameEntity {
            constructor(x, z, team) {
                super(x, z, team, COLOR_RADIANT);
                this.hp = 1200; this.maxHp = 1200;
                this.mp = 600; this.maxMp = 600;
                this.speed = 0.25;

                // Detailed Model
                const geo = new THREE.CylinderGeometry(0.5, 0.5, 2, 8);
                const mat = new THREE.MeshStandardMaterial({
                    color: 0x00ff88, roughness: 0.3, metalness: 0.8,
                    emissive: 0x004422, emissiveIntensity: 0.5
                });
                this.bodyMesh = new THREE.Mesh(geo, mat);
                this.bodyMesh.position.y = 1;
                this.mesh.add(this.bodyMesh);

                // Weapon
                const weaponGeo = new THREE.BoxGeometry(0.1, 0.1, 1.2);
                const weaponMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
                this.weapon = new THREE.Mesh(weaponGeo, weaponMat);
                this.weapon.position.set(0.4, 1, 0.3);
                this.mesh.add(this.weapon);

                // Pointer Ring
                const ringGeo = new THREE.RingGeometry(0.8, 0.9, 32);
                const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
                this.ring = new THREE.Mesh(ringGeo, ringMat);
                this.ring.rotation.x = -Math.PI / 2;
                this.ring.position.y = 0.05;
                this.mesh.add(this.ring);

                // Setup abilities
                this.abilities = {
                    q: { cd: 2, currentCd: 0, cost: 60 },
                    w: { cd: 5, currentCd: 0, cost: 40 },
                    e: { cd: 12, currentCd: 0, cost: 80 },
                    r: { cd: 40, currentCd: 0, cost: 150 }
                };
            }

            update(dt) {
                super.update(dt);
                // Mana regen
                if (this.mp < this.maxMp) this.mp += 0.2;

                // Update CD
                for (let key in this.abilities) {
                    if (this.abilities[key].currentCd > 0) {
                        this.abilities[key].currentCd -= dt;
                        updateCooldownUI(key, this.abilities[key].currentCd, this.abilities[key].cd);
                    }
                }

                updateHeroUI();

                // Update Floating Portrait
                if (portraitMesh) {
                    portraitMesh.rotation.y += 0.01;
                }
            }

            cast(key) {
                const ab = this.abilities[key];
                if (ab.currentCd > 0 || this.mp < ab.cost) return;

                this.mp -= ab.cost;
                ab.currentCd = ab.cd;

                // FX
                if (key === 'q') createProjectile(this.mesh.position, mouse);
                if (key === 'w') {
                    // Dash
                    const dir = this.targetPos.clone().sub(this.mesh.position).normalize();
                    this.mesh.position.add(dir.multiplyScalar(5));
                    this.targetPos.copy(this.mesh.position);
                    createExplosion(this.mesh.position, 0xffff00, 20);
                }
                if (key === 'e') createShield(this);
                if (key === 'r') createUlt(this.mesh.position);
            }
        }

        class Creep extends GameEntity {
            constructor(x, z, team) {
                const color = team === TEAM_RADIANT ? COLOR_RADIANT : COLOR_DIRE;
                super(x, z, team, color);
                this.hp = 300;
                this.damage = 15;
                this.speed = 0.12;
                this.lastAttack = 0;

                const geo = team === TEAM_RADIANT ? new THREE.SphereGeometry(0.4) : new THREE.BoxGeometry(0.6, 0.6, 0.6);
                const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.7 });
                this.bodyMesh = new THREE.Mesh(geo, mat);
                this.bodyMesh.position.y = 0.5;
                this.mesh.add(this.bodyMesh);
            }

            update(dt) {
                if (this.dead) return;

                // AI
                let target = null;
                let minDist = 8;
                entities.forEach(e => {
                    if (e.team !== this.team && !e.dead) {
                        const d = this.mesh.position.distanceTo(e.mesh.position);
                        if (d < minDist) {
                            minDist = d;
                            target = e;
                        }
                    }
                });

                if (target) {
                    if (minDist < 2) {
                        // Attack
                        if (clock.getElapsedTime() - this.lastAttack > 1.5) {
                            target.takeDamage(this.damage);
                            this.lastAttack = clock.getElapsedTime();
                            // Bump animation
                            const dir = target.mesh.position.clone().sub(this.mesh.position).normalize();
                            this.mesh.position.add(dir.multiplyScalar(0.5));
                            setTimeout(() => this.mesh.position.sub(dir.multiplyScalar(0.5)), 100);
                        }
                    } else {
                        // Chase
                        this.targetPos.copy(target.mesh.position);
                        super.update(dt);
                    }
                } else {
                    // Lane logic
                    const dest = this.team === TEAM_RADIANT ? new THREE.Vector3(50, 0, 50) : new THREE.Vector3(-50, 0, -50);
                    this.targetPos.copy(dest);
                    super.update(dt);
                }
            }
        }

        class Structure extends GameEntity {
            constructor(x, z, type, team) {
                const color = team === TEAM_RADIANT ? COLOR_RADIANT : COLOR_DIRE;
                super(x, z, team, color);
                this.type = type;
                this.maxHp = type === 'base' ? 2500 : 1500;
                this.hp = this.maxHp;
                this.damage = 40;
                this.range = 10;
                this.lastAttack = 0;

                // Model
                let geo;
                if (type === 'base') geo = new THREE.ConeGeometry(3, 8, 6);
                else geo = new THREE.CylinderGeometry(0.8, 1.2, 5, 8);

                const mat = new THREE.MeshStandardMaterial({
                    color: color, roughness: 0.4,
                    emissive: color, emissiveIntensity: 0.4
                });
                this.bodyMesh = new THREE.Mesh(geo, mat);
                this.bodyMesh.position.y = type === 'base' ? 4 : 2.5;
                this.mesh.add(this.bodyMesh);

                // Base Ring
                const ring = new THREE.Mesh(new THREE.TorusGeometry(2, 0.2, 8, 16), new THREE.MeshBasicMaterial({ color: color }));
                ring.rotation.x = -Math.PI / 2;
                this.mesh.add(ring);
            }

            update(dt) {
                if (this.dead) return;

                // Tower AI
                if (clock.getElapsedTime() - this.lastAttack > 1.0) {
                    let target = null;
                    let minD = this.range;

                    entities.forEach(e => {
                        if (e.team !== this.team && !e.dead) {
                            const d = this.mesh.position.distanceTo(e.mesh.position);
                            if (d < minD) {
                                minD = d;
                                target = e;
                            }
                        }
                    });

                    if (target) {
                        target.takeDamage(this.damage, 'physical');
                        this.lastAttack = clock.getElapsedTime();
                        // Laser shot
                        const laser = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, minD), new THREE.MeshBasicMaterial({ color: this.color }));
                        laser.geometry.rotateX(-Math.PI / 2);
                        laser.position.copy(this.mesh.position).add(new THREE.Vector3(0, 4, 0));
                        laser.lookAt(target.mesh.position);
                        laser.position.lerp(target.mesh.position, 0.5); // Center it
                        scene.add(laser);
                        setTimeout(() => scene.remove(laser), 100);
                    }
                }
            }
        }

        // --- FX SYSTEMS ---
        function createProjectile(start, info) {
            // Shoots towards mouse
            const sphere = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshBasicMaterial({ color: 0x00ffff }));
            sphere.position.copy(start);
            sphere.position.y = 1;
            scene.add(sphere);

            // Raycast for direction
            raycaster.setFromCamera(info, camera);
            const intersects = raycaster.intersectObjects(scene.children);
            let targetPoint = new THREE.Vector3(info.x * 50, 0, info.y * 50); // Fallback
            for (let i of intersects) {
                if (i.object.geometry && i.object.geometry.type === 'PlaneGeometry') {
                    targetPoint = i.point;
                    break;
                }
            }

            const dir = targetPoint.sub(start).normalize();

            const update = () => {
                sphere.position.add(dir.multiplyScalar(0.8));
                if (sphere.position.length() > 60) {
                    scene.remove(sphere);
                } else {
                    // Hit detection?
                    requestAnimationFrame(update);
                }
            };
            update();
        }

        function createExplosion(pos, color, count) {
            const geom = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            const velocities = [];

            for (let i = 0; i < count; i++) {
                positions[i * 3] = pos.x;
                positions[i * 3 + 1] = pos.y;
                positions[i * 3 + 2] = pos.z;
                velocities.push({
                    x: (Math.random() - 0.5),
                    y: (Math.random() - 0.5) + 1,
                    z: (Math.random() - 0.5)
                });
            }

            geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const mat = new THREE.PointsMaterial({ color: color, size: 0.4, transparent: true });
            const points = new THREE.Points(geom, mat);
            scene.add(points);

            let frame = 0;
            const anim = () => {
                frame++;
                const posAttr = points.geometry.attributes.position;
                for (let i = 0; i < count; i++) {
                    posAttr.setXYZ(i,
                        posAttr.getX(i) + velocities[i].x * 0.2,
                        posAttr.getY(i) + velocities[i].y * 0.2,
                        posAttr.getZ(i) + velocities[i].z * 0.2
                    );
                    velocities[i].y -= 0.05; // Gravity
                }
                posAttr.needsUpdate = true;
                mat.opacity -= 0.02;
                if (frame < 50) requestAnimationFrame(anim);
                else scene.remove(points);
            }
            anim();
        }

        function createShield(entity) {
            const s = new THREE.Mesh(new THREE.SphereGeometry(1.2, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true, transparent: true, opacity: 0.5 }));
            entity.mesh.add(s);
            setTimeout(() => entity.mesh.remove(s), 3000);
        }

        function createUlt(pos) {
            // Big Boom
            createExplosion(pos, 0xff00ff, 100);
            // AOE Damage
            entities.forEach(e => {
                if (e.team !== player.team && e.mesh.position.distanceTo(pos) < 10) {
                    e.takeDamage(400, 'crit');
                }
            });
        }

        function spawnFloatingText(amt, pos, color) {
            new FloatingText(Math.round(amt), pos.x, pos.y, pos.z, color);
        }

        // --- CORE FUNCTIONS ---

        function init() {
            // Setup Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x050508, 20, 80); // Distance fog for atmosphere

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(20, 30, 20);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // Shadows ON
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('game-container').appendChild(renderer.domElement);

            // Post Processing
            const renderPass = new THREE.RenderPass(scene, camera);
            const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.2;
            bloomPass.strength = 1.2;
            bloomPass.radius = 0.5;

            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);

            // Lighting
            const ambient = new THREE.AmbientLight(0x404060, 0.6); // Blue-ish ambient
            scene.add(ambient);

            const sun = new THREE.DirectionalLight(0xffffff, 1);
            sun.position.set(50, 100, 50);
            sun.castShadow = true;
            sun.shadow.camera.left = -50;
            sun.shadow.camera.right = 50;
            sun.shadow.camera.top = 50;
            sun.shadow.camera.bottom = -50;
            sun.shadow.mapSize.width = 2048;
            sun.shadow.mapSize.height = 2048;
            scene.add(sun);

            // Environment
            const gridHelper = new THREE.GridHelper(200, 50, 0x333333, 0x111111);
            scene.add(gridHelper);

            const planeGeo = new THREE.PlaneGeometry(200, 200);
            const planeMat = new THREE.MeshStandardMaterial({ color: 0x080808, roughness: 0.8 });
            const ground = new THREE.Mesh(planeGeo, planeMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Init Player
            player = new Hero(0, 0, TEAM_RADIANT);
            entities.push(player);
            initPortrait();

            // Structures
            entities.push(new Structure(-45, -45, 'base', TEAM_RADIANT));
            entities.push(new Structure(45, 45, 'base', TEAM_DIRE));
            entities.push(new Structure(-20, -20, 'tower', TEAM_RADIANT));
            entities.push(new Structure(20, 20, 'tower', TEAM_DIRE));

            // Inputs
            window.addEventListener('mousedown', onMouseDown);
            window.addEventListener('keydown', e => {
                if (['q', 'w', 'e', 'r'].includes(e.key.toLowerCase())) player.cast(e.key.toLowerCase());
            });
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });

            // Start Loop
            spawnWave();
            setInterval(spawnWave, 30000);
            animate();

            // Welcome msg
            setTimeout(() => document.getElementById('notification').classList.add('visible'), 500);
            setTimeout(() => document.getElementById('notification').classList.remove('visible'), 3000);
        }

        function updateMinimap() {
            const c = document.getElementById('minimap-canvas');
            const ctx = c.getContext('2d');
            c.width = 220; c.height = 220;
            ctx.fillStyle = '#050505';
            ctx.fillRect(0, 0, 220, 220);

            // Map Size 100x100 (-50 to 50) maps to 0-220
            const mapToScreen = (val) => (val + 50) * 2.2;

            entities.forEach(e => {
                if (e.dead) return;
                const x = mapToScreen(e.mesh.position.x);
                const z = mapToScreen(e.mesh.position.z);

                ctx.fillStyle = e.team === TEAM_RADIANT ? '#00ff88' : '#ff3c3c';
                const size = (e instanceof Structure) ? 6 : (e instanceof Hero ? 4 : 2);

                ctx.beginPath();
                ctx.arc(x, z, size, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function spawnWave() {
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    entities.push(new Creep(-40, -40, TEAM_RADIANT));
                    entities.push(new Creep(40, 40, TEAM_DIRE));
                }, i * 800);
            }
            showMessage("Creeps Spawning");
        }

        function showMessage(text) {
            const n = document.getElementById('notification');
            n.textContent = text;
            n.classList.add('visible');
            setTimeout(() => n.classList.remove('visible'), 2000);
        }

        function onMouseDown(e) {
            if (e.button === 2) { // Right Click
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(scene.children);
                for (let i of intersects) {
                    if (i.object.geometry && i.object.geometry.type === 'PlaneGeometry') { // Ground
                        player.targetPos.copy(i.point);

                        // Click Effect
                        const r = new THREE.Mesh(new THREE.RingGeometry(0.2, 0.3), new THREE.MeshBasicMaterial({ color: 0x00ff88 }));
                        r.rotation.x = -Math.PI / 2;
                        r.position.copy(i.point); r.position.y = 0.1;
                        scene.add(r);
                        setTimeout(() => scene.remove(r), 500);
                        break;
                    }
                }
            }
        }

        function updateHeroUI() {
            const hpPct = (player.hp / player.maxHp) * 100;
            const mpPct = (player.mp / player.maxMp) * 100;
            document.getElementById('hp-bar').style.width = hpPct + '%';
            document.getElementById('hp-text').textContent = Math.floor(player.hp) + ' / ' + player.maxHp;
            document.getElementById('mp-bar').style.width = mpPct + '%';
            document.getElementById('mp-text').textContent = Math.floor(player.mp) + ' / ' + player.maxMp;
        }

        function updateCooldownUI(key, current, max) {
            const el = document.querySelector(`#ab-${key} .cooldown-mask`);
            if (el) {
                const pct = (current / max) * 100;
                el.style.height = pct + '%';
                el.textContent = current > 0 ? Math.ceil(current) : '';
            }
        }

        function updateScoreBoard() {
            document.getElementById('score-radiant').textContent = score.radiant;
            document.getElementById('score-dire').textContent = score.dire;
        }

        function initPortrait() {
            // Tiny separate scene for the 3D portrait
            const container = document.getElementById('portrait-container');
            if (!container) return;

            portraitScene = new THREE.Scene();
            portraitScene.background = new THREE.Color(0x111111);

            portraitCamera = new THREE.PerspectiveCamera(50, 90 / 110, 0.1, 100);
            portraitCamera.position.set(0, 0, 3);

            portraitRenderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            portraitRenderer.setSize(90, 110);
            container.appendChild(portraitRenderer.domElement);

            const light = new THREE.DirectionalLight(0xffffff, 2);
            light.position.set(1, 1, 1);
            portraitScene.add(light);
            portraitScene.add(new THREE.AmbientLight(0x404040));

            // Copy hero mesh layout roughly
            const geo = new THREE.CapsuleGeometry(0.6, 1.2, 4, 8);
            const mat = new THREE.MeshStandardMaterial({ color: 0x00ff88, roughness: 0.2 });
            portraitMesh = new THREE.Mesh(geo, mat);
            portraitScene.add(portraitMesh);
        }

        function animate() {
            requestAnimationFrame(animate);

            const dt = clock.getDelta();
            gameTime += dt;

            // Camera Follow
            if (player && !player.dead) {
                const targetPos = player.mesh.position.clone().add(new THREE.Vector3(0, 25, 20)); // Isometric offset
                camera.position.lerp(targetPos, 0.1);
                camera.lookAt(player.mesh.position);
            }

            // Entities
            entities.forEach(e => e.update(dt));
            floatingTexts.forEach(t => t.updatePosition());

            updateMinimap();
            composer.render();

            // Portrait Render
            if (portraitRenderer) {
                portraitRenderer.render(portraitScene, portraitCamera);
            }

            // Time
            const mins = Math.floor(gameTime / 60).toString().padStart(2, '0');
            const secs = Math.floor(gameTime % 60).toString().padStart(2, '0');
            document.getElementById('game-time').textContent = `${mins}:${secs}`;
        }

        init();
    </script>
</body>

</html>