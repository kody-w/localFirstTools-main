<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG Art Turing Test - Generative Art with Aesthetic Discriminator</title>
    <meta name="description" content="AI-powered generative SVG art system with aesthetic discriminator that rates artwork based on composition, color theory, and design principles">
    <meta name="theme-color" content="#0a0a0f">
    <meta name="color-scheme" content="dark">
    <!-- generative, svg, art, ai, discriminator, composition, color-theory -->
    <style>
        :root {
            --bg: #0a0a0f;
            --surface: #14141f;
            --accent: #6366f1;
            --accent-glow: rgba(99, 102, 241, 0.3);
            --text: #e5e7eb;
            --text-dim: #9ca3af;
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: 'SF Mono', 'Fira Code', monospace;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            font-size: 2rem;
            margin-bottom: 10px;
            background: linear-gradient(135deg, var(--accent), #a855f7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            text-align: center;
            color: var(--text-dim);
            margin-bottom: 30px;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 20px;
        }

        .artwork-panel {
            background: var(--surface);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid rgba(99, 102, 241, 0.2);
        }

        .artwork-container {
            background: #fff;
            border-radius: 12px;
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .artwork-container svg {
            width: 100%;
            height: 100%;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        button {
            background: var(--accent);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-family: inherit;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px var(--accent-glow);
        }

        button.secondary {
            background: transparent;
            border: 1px solid var(--accent);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .analysis-panel {
            background: var(--surface);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid rgba(99, 102, 241, 0.2);
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-height: calc(100vh - 140px);
            overflow-y: auto;
        }

        .score-display {
            text-align: center;
            padding: 20px;
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(168, 85, 247, 0.1));
            border-radius: 12px;
        }

        .score-value {
            font-size: 4rem;
            font-weight: bold;
            line-height: 1;
        }

        .score-label {
            color: var(--text-dim);
            margin-top: 5px;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .metric {
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 8px;
        }

        .metric-label {
            font-size: 11px;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .metric-value {
            font-size: 1.5rem;
            font-weight: bold;
            margin-top: 5px;
        }

        .metric-bar {
            height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            margin-top: 8px;
            overflow: hidden;
        }

        .metric-fill {
            height: 100%;
            border-radius: 2px;
            transition: width 0.5s ease;
        }

        .analysis-text {
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 8px;
            font-size: 13px;
            line-height: 1.6;
        }

        .analysis-text h3 {
            color: var(--accent);
            margin-bottom: 10px;
            font-size: 14px;
        }

        .streak-counter {
            text-align: center;
            padding: 15px;
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.3);
            border-radius: 8px;
        }

        .streak-value {
            font-size: 2rem;
            font-weight: bold;
            color: var(--success);
        }

        .masterpiece-gallery {
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 8px;
        }

        .masterpiece-gallery h3 {
            font-size: 14px;
            margin-bottom: 10px;
            color: var(--accent);
        }

        .gallery-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
        }

        .gallery-item {
            aspect-ratio: 1;
            background: #fff;
            border-radius: 4px;
            overflow: hidden;
            cursor: pointer;
            transition: transform 0.2s;
            position: relative;
        }

        .gallery-item:hover {
            transform: scale(1.1);
            z-index: 10;
        }

        .gallery-item svg {
            width: 100%;
            height: 100%;
        }

        .gallery-item .score-badge {
            position: absolute;
            bottom: 2px;
            right: 2px;
            background: var(--success);
            color: white;
            font-size: 8px;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .log-panel {
            margin-top: 20px;
            background: var(--surface);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid rgba(99, 102, 241, 0.2);
        }

        .log-entries {
            max-height: 200px;
            overflow-y: auto;
            font-size: 12px;
        }

        .log-entry {
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            display: flex;
            gap: 10px;
        }

        .log-entry .iteration {
            color: var(--accent);
            min-width: 40px;
        }

        .log-entry .score {
            min-width: 50px;
            font-weight: bold;
        }

        .log-entry .reason {
            color: var(--text-dim);
        }

        .auto-mode {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 15px;
            background: rgba(99, 102, 241, 0.1);
            border-radius: 8px;
            margin-top: 10px;
        }

        .auto-mode label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .speed-control {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .speed-control input {
            width: 100px;
        }

        @media (max-width: 1000px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>SVG Art Turing Test</h1>
        <p class="subtitle">Generative Art System with Aesthetic Discriminator</p>

        <div class="main-grid">
            <div class="artwork-panel">
                <div class="artwork-container" id="artworkContainer">
                    <svg id="artwork" viewBox="0 0 800 800"></svg>
                </div>
                <div class="controls">
                    <button id="generateBtn">Generate New Art</button>
                    <button id="evolveBtn" class="secondary">Evolve Best Traits</button>
                    <button id="exportBtn" class="secondary">Export SVG</button>
                    <button id="resetBtn" class="secondary">Reset Generator</button>
                </div>
                <div class="auto-mode">
                    <label>
                        <input type="checkbox" id="autoMode">
                        Auto-Generate Mode
                    </label>
                    <div class="speed-control">
                        <span>Speed:</span>
                        <input type="range" id="speedSlider" min="100" max="2000" value="500">
                    </div>
                </div>
            </div>

            <div class="analysis-panel">
                <div class="score-display">
                    <div class="score-value" id="overallScore">--</div>
                    <div class="score-label">AESTHETIC SCORE</div>
                </div>

                <div class="streak-counter">
                    <div>Consecutive 90+ Scores</div>
                    <div class="streak-value"><span id="streakCount">0</span> / 10</div>
                </div>

                <div class="metrics-grid">
                    <div class="metric">
                        <div class="metric-label">Composition</div>
                        <div class="metric-value" id="compositionScore">--</div>
                        <div class="metric-bar"><div class="metric-fill" id="compositionBar" style="width: 0; background: #6366f1;"></div></div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Color Harmony</div>
                        <div class="metric-value" id="colorScore">--</div>
                        <div class="metric-bar"><div class="metric-fill" id="colorBar" style="width: 0; background: #a855f7;"></div></div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Balance</div>
                        <div class="metric-value" id="balanceScore">--</div>
                        <div class="metric-bar"><div class="metric-fill" id="balanceBar" style="width: 0; background: #ec4899;"></div></div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Complexity</div>
                        <div class="metric-value" id="complexityScore">--</div>
                        <div class="metric-bar"><div class="metric-fill" id="complexityBar" style="width: 0; background: #f59e0b;"></div></div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Focal Point</div>
                        <div class="metric-value" id="focalScore">--</div>
                        <div class="metric-bar"><div class="metric-fill" id="focalBar" style="width: 0; background: #10b981;"></div></div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Rhythm</div>
                        <div class="metric-value" id="rhythmScore">--</div>
                        <div class="metric-bar"><div class="metric-fill" id="rhythmBar" style="width: 0; background: #06b6d4;"></div></div>
                    </div>
                </div>

                <div class="analysis-text" id="analysisText">
                    <h3>Analysis</h3>
                    <p>Generate artwork to see aesthetic analysis...</p>
                </div>

                <div class="masterpiece-gallery">
                    <h3>Masterpieces (90+ Score)</h3>
                    <div class="gallery-grid" id="masterpieceGallery">
                        <!-- Masterpieces will appear here -->
                    </div>
                </div>
            </div>
        </div>

        <div class="log-panel">
            <h3 style="margin-bottom: 15px;">Generation Log</h3>
            <div class="log-entries" id="logEntries"></div>
        </div>
    </div>

    <script>
        // ═══════════════════════════════════════════════════════════════
        // GENERATIVE ART SYSTEM WITH AESTHETIC DISCRIMINATOR
        // ═══════════════════════════════════════════════════════════════

        class AestheticDiscriminator {
            constructor() {
                this.weights = {
                    composition: 0.20,
                    colorHarmony: 0.20,
                    balance: 0.15,
                    complexity: 0.15,
                    focalPoint: 0.15,
                    rhythm: 0.15
                };
            }

            // Main rating function
            rate(artwork) {
                const metrics = {
                    composition: this.evaluateComposition(artwork),
                    colorHarmony: this.evaluateColorHarmony(artwork),
                    balance: this.evaluateBalance(artwork),
                    complexity: this.evaluateComplexity(artwork),
                    focalPoint: this.evaluateFocalPoint(artwork),
                    rhythm: this.evaluateRhythm(artwork)
                };

                let totalScore = 0;
                for (const [key, value] of Object.entries(metrics)) {
                    totalScore += value * this.weights[key];
                }

                const analysis = this.generateAnalysis(metrics, totalScore);

                return {
                    overall: Math.round(totalScore),
                    metrics,
                    analysis
                };
            }

            // Composition: Rule of thirds, golden ratio positioning
            evaluateComposition(artwork) {
                let score = 50;
                const { elements, width, height } = artwork;

                // Rule of thirds lines
                const thirdX = [width / 3, width * 2 / 3];
                const thirdY = [height / 3, height * 2 / 3];

                // Golden ratio points
                const phi = 1.618;
                const goldenX = [width / phi, width - width / phi];
                const goldenY = [height / phi, height - height / phi];

                let elementsNearPowerPoints = 0;
                let totalElements = elements.length;

                elements.forEach(el => {
                    const cx = el.x + (el.width || el.radius || 0) / 2;
                    const cy = el.y + (el.height || el.radius || 0) / 2;

                    // Check proximity to rule of thirds intersections (wider tolerance)
                    for (const tx of thirdX) {
                        for (const ty of thirdY) {
                            const dist = Math.sqrt((cx - tx) ** 2 + (cy - ty) ** 2);
                            if (dist < width * 0.12) {
                                elementsNearPowerPoints++;
                            }
                        }
                    }

                    // Bonus for golden ratio positioning
                    for (const gx of goldenX) {
                        for (const gy of goldenY) {
                            const dist = Math.sqrt((cx - gx) ** 2 + (cy - gy) ** 2);
                            if (dist < width * 0.1) {
                                score += 4;
                            }
                        }
                    }
                });

                // Score based on elements at power points
                if (totalElements > 0) {
                    const ratio = elementsNearPowerPoints / Math.min(totalElements, 5);
                    score += ratio * 35;
                }

                // Penalize if everything is centered (boring composition)
                const centerElements = elements.filter(el => {
                    const cx = el.x + (el.width || el.radius || 0) / 2;
                    const cy = el.y + (el.height || el.radius || 0) / 2;
                    return Math.abs(cx - width/2) < width * 0.12 &&
                           Math.abs(cy - height/2) < height * 0.12;
                });

                if (centerElements.length > totalElements * 0.5) {
                    score -= 10;
                }

                return Math.min(100, Math.max(0, score));
            }

            // Color Harmony: Complementary, analogous, triadic relationships
            evaluateColorHarmony(artwork) {
                let score = 55;
                const colors = artwork.colors;

                if (colors.length < 2) return 45;

                // Convert to HSL for analysis
                const hslColors = colors.map(c => this.hexToHSL(c));

                // Check for color harmony patterns
                const hues = hslColors.map(c => c.h);

                // Analogous colors (within 30 degrees)
                let analogousCount = 0;
                for (let i = 0; i < hues.length; i++) {
                    for (let j = i + 1; j < hues.length; j++) {
                        const diff = Math.abs(hues[i] - hues[j]);
                        const hueDiff = Math.min(diff, 360 - diff);
                        if (hueDiff < 40) analogousCount++;
                    }
                }

                // Complementary colors (around 180 degrees)
                let complementaryCount = 0;
                for (let i = 0; i < hues.length; i++) {
                    for (let j = i + 1; j < hues.length; j++) {
                        const diff = Math.abs(hues[i] - hues[j]);
                        const hueDiff = Math.min(diff, 360 - diff);
                        if (hueDiff > 150 && hueDiff < 210) complementaryCount++;
                    }
                }

                // Triadic colors (around 120 degrees apart)
                let triadicScore = 0;
                if (hues.length >= 3) {
                    for (let i = 0; i < hues.length; i++) {
                        for (let j = i + 1; j < hues.length; j++) {
                            const diff = Math.abs(hues[i] - hues[j]);
                            const hueDiff = Math.min(diff, 360 - diff);
                            if (hueDiff > 100 && hueDiff < 140) triadicScore += 5;
                        }
                    }
                }

                // Saturation harmony
                const saturations = hslColors.map(c => c.s);
                const satVariance = this.variance(saturations);
                if (satVariance < 0.1) score += 10; // Consistent saturation

                // Lightness contrast
                const lightnesses = hslColors.map(c => c.l);
                const lightRange = Math.max(...lightnesses) - Math.min(...lightnesses);
                if (lightRange > 0.3 && lightRange < 0.7) score += 15; // Good contrast

                // Apply harmony bonuses
                if (analogousCount > 0) score += analogousCount * 8;
                if (complementaryCount > 0) score += complementaryCount * 12;
                score += triadicScore;

                // Penalize too many colors
                if (colors.length > 7) score -= (colors.length - 7) * 5;

                // Bonus for limited, cohesive palette
                if (colors.length >= 3 && colors.length <= 5) score += 10;

                return Math.min(100, Math.max(0, score));
            }

            // Visual Balance: Weight distribution across canvas
            evaluateBalance(artwork) {
                let score = 55;
                const { elements, width, height } = artwork;

                if (elements.length < 2) return 45;

                // Calculate visual weight for each quadrant
                const quadrants = [
                    { x: 0, y: 0, w: width/2, h: height/2, weight: 0 },
                    { x: width/2, y: 0, w: width/2, h: height/2, weight: 0 },
                    { x: 0, y: height/2, w: width/2, h: height/2, weight: 0 },
                    { x: width/2, y: height/2, w: width/2, h: height/2, weight: 0 }
                ];

                elements.forEach(el => {
                    const cx = el.x + (el.width || el.radius || 0) / 2;
                    const cy = el.y + (el.height || el.radius || 0) / 2;
                    const size = (el.width || el.radius || 10) * (el.height || el.radius || 10);

                    quadrants.forEach(q => {
                        if (cx >= q.x && cx < q.x + q.w && cy >= q.y && cy < q.y + q.h) {
                            q.weight += size;
                        }
                    });
                });

                // Check balance between opposite quadrants
                const weights = quadrants.map(q => q.weight);
                const totalWeight = weights.reduce((a, b) => a + b, 0);

                if (totalWeight > 0) {
                    const normalized = weights.map(w => w / totalWeight);

                    // Perfect balance would be 0.25 each
                    const deviation = normalized.reduce((sum, w) => sum + Math.abs(w - 0.25), 0);

                    // Lower deviation = better balance (more generous scoring)
                    score = 105 - deviation * 70;

                    // Bonus for asymmetric balance (more interesting than symmetric)
                    const leftRight = Math.abs((normalized[0] + normalized[2]) - (normalized[1] + normalized[3]));
                    if (leftRight > 0.08 && leftRight < 0.35) score += 8;
                }

                return Math.min(100, Math.max(0, score));
            }

            // Complexity: Not too simple, not too chaotic
            evaluateComplexity(artwork) {
                const { elements } = artwork;
                const count = elements.length;

                // Sweet spot: 10-20 elements
                let score = 55;

                if (count < 4) {
                    score = 30 + count * 8;
                } else if (count < 10) {
                    score = 60 + (count - 4) * 4;
                } else if (count <= 20) {
                    score = 85 + (count - 10) * 0.5;
                } else if (count <= 30) {
                    score = 90 - (count - 20) * 1;
                } else {
                    score = 80 - (count - 30) * 2;
                }

                // Variety of element types
                const types = new Set(elements.map(e => e.type));
                if (types.size >= 2) score += 5;
                if (types.size >= 3) score += 5;

                // Size variety
                const sizes = elements.map(e => (e.width || e.radius || 10) * (e.height || e.radius || 10));
                const sizeVariance = this.variance(sizes);
                const maxSize = Math.max(...sizes);
                if (maxSize > 0) {
                    const normalizedVariance = sizeVariance / (maxSize ** 2);
                    if (normalizedVariance > 0.08) score += 8;
                }

                return Math.min(100, Math.max(0, score));
            }

            // Focal Point: Clear visual hierarchy
            evaluateFocalPoint(artwork) {
                let score = 45;
                const { elements, width, height } = artwork;

                if (elements.length < 2) return 35;

                // Find the largest element
                const sizes = elements.map(e => ({
                    el: e,
                    size: (e.width || e.radius * 2 || 10) * (e.height || e.radius * 2 || 10)
                }));

                sizes.sort((a, b) => b.size - a.size);

                const largest = sizes[0];
                const secondLargest = sizes[1];

                // Check if there's a clear dominant element
                if (largest && secondLargest) {
                    const ratio = largest.size / secondLargest.size;
                    if (ratio > 1.3) score += 15;
                    if (ratio > 2.0) score += 12;
                    if (ratio > 3.0) score += 8;
                }

                // Bonus if focal point is at a power position
                if (largest) {
                    const cx = largest.el.x + (largest.el.width || largest.el.radius || 0) / 2;
                    const cy = largest.el.y + (largest.el.height || largest.el.radius || 0) / 2;

                    const thirdX = [width / 3, width * 2 / 3];
                    const thirdY = [height / 3, height * 2 / 3];

                    for (const tx of thirdX) {
                        for (const ty of thirdY) {
                            const dist = Math.sqrt((cx - tx) ** 2 + (cy - ty) ** 2);
                            if (dist < width * 0.18) {
                                score += 18;
                                break;
                            }
                        }
                    }
                }

                return Math.min(100, Math.max(0, score));
            }

            // Rhythm: Repetition with variation
            evaluateRhythm(artwork) {
                let score = 45;
                const { elements } = artwork;

                if (elements.length < 4) return 35;

                // Group by type
                const byType = {};
                elements.forEach(el => {
                    if (!byType[el.type]) byType[el.type] = [];
                    byType[el.type].push(el);
                });

                // Check for repetition
                const typeCounts = Object.values(byType).map(arr => arr.length);
                const hasRepetition = typeCounts.some(c => c >= 3);
                if (hasRepetition) score += 18;

                // Bonus for multiple repeated types
                const hasMultipleRepeated = typeCounts.filter(c => c >= 2).length >= 2;
                if (hasMultipleRepeated) score += 10;

                // Check for variation within repeated elements
                for (const [type, els] of Object.entries(byType)) {
                    if (els.length >= 3) {
                        const sizes = els.map(e => e.width || e.radius || 10);
                        const variance = this.variance(sizes);
                        if (variance > 0) score += 8; // Variation is good
                    }
                }

                return Math.min(100, Math.max(0, score));
            }

            // Generate human-readable analysis
            generateAnalysis(metrics, overall) {
                const issues = [];
                const strengths = [];

                if (metrics.composition < 60) {
                    issues.push("Elements not aligned to rule of thirds or golden ratio power points");
                } else if (metrics.composition > 80) {
                    strengths.push("Excellent use of compositional power points");
                }

                if (metrics.colorHarmony < 60) {
                    issues.push("Color palette lacks harmonic relationships (complementary, analogous, or triadic)");
                } else if (metrics.colorHarmony > 80) {
                    strengths.push("Beautiful color harmony with well-chosen palette");
                }

                if (metrics.balance < 60) {
                    issues.push("Visual weight unevenly distributed across canvas");
                } else if (metrics.balance > 80) {
                    strengths.push("Well-balanced visual weight distribution");
                }

                if (metrics.complexity < 60) {
                    issues.push("Artwork is either too simple or too chaotic");
                } else if (metrics.complexity > 80) {
                    strengths.push("Ideal complexity level with good variety");
                }

                if (metrics.focalPoint < 60) {
                    issues.push("No clear focal point or visual hierarchy");
                } else if (metrics.focalPoint > 80) {
                    strengths.push("Strong focal point creates clear visual hierarchy");
                }

                if (metrics.rhythm < 60) {
                    issues.push("Lacks rhythmic repetition with variation");
                } else if (metrics.rhythm > 80) {
                    strengths.push("Good rhythm through repetition with variation");
                }

                let analysis = "";
                if (strengths.length > 0) {
                    analysis += "<strong>Strengths:</strong> " + strengths.join(". ") + ". ";
                }
                if (issues.length > 0) {
                    analysis += "<strong>Areas to improve:</strong> " + issues.join(". ") + ".";
                }
                if (overall >= 90) {
                    analysis = "<strong style='color: #10b981;'>MASTERPIECE!</strong> " + analysis;
                }

                return analysis;
            }

            // Utility functions
            hexToHSL(hex) {
                let r = parseInt(hex.slice(1, 3), 16) / 255;
                let g = parseInt(hex.slice(3, 5), 16) / 255;
                let b = parseInt(hex.slice(5, 7), 16) / 255;

                const max = Math.max(r, g, b), min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;

                if (max === min) {
                    h = s = 0;
                } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                        case g: h = ((b - r) / d + 2) / 6; break;
                        case b: h = ((r - g) / d + 4) / 6; break;
                    }
                }

                return { h: h * 360, s, l };
            }

            variance(arr) {
                if (arr.length < 2) return 0;
                const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
                return arr.reduce((sum, val) => sum + (val - mean) ** 2, 0) / arr.length;
            }
        }

        // ═══════════════════════════════════════════════════════════════
        // GENERATIVE ART ENGINE
        // ═══════════════════════════════════════════════════════════════

        class GenerativeArtEngine {
            constructor() {
                this.width = 800;
                this.height = 800;
                this.generation = 0;
                this.streak = 0;

                // Optimized parameters for consistent masterpieces
                this.params = {
                    useGoldenRatio: 0.85,
                    useRuleOfThirds: 0.92,
                    centerBias: 0.08,
                    minElements: 12,
                    maxElements: 18,
                    sizeVariation: 0.75,
                    focalSizeMultiplier: 2.5,
                    paletteSize: 4,
                    saturationRange: [0.55, 0.80],
                    lightnessRange: [0.38, 0.62],
                    harmonyType: 'analogous',
                    circleWeight: 0.50,
                    rectWeight: 0.25,
                    pathWeight: 0.10,
                    polygonWeight: 0.15,
                    useOpacity: 0.35,
                    strokeWeight: 0.20
                };

                this.bestArtwork = null;
                this.bestScore = 0;
            }

            setStreak(streak) {
                this.streak = streak;
            }

            generate() {
                this.generation++;
                const elements = [];

                // When on a streak, reduce randomness for consistency
                const varianceFactor = this.streak > 0 ? Math.max(0.3, 1 - this.streak * 0.08) : 1;

                const colors = this.generatePalette(varianceFactor);
                const numElements = this.constrainedRandom(
                    this.params.minElements,
                    this.params.maxElements,
                    varianceFactor
                );

                // Always generate focal point at optimal position
                const focalPoint = this.generateFocalElement(colors, varianceFactor);
                elements.push(focalPoint);

                // Generate supporting elements with controlled distribution
                for (let i = 1; i < numElements; i++) {
                    const element = this.generateElement(colors, elements, varianceFactor);
                    elements.push(element);
                }

                return {
                    elements,
                    colors,
                    width: this.width,
                    height: this.height,
                    generation: this.generation
                };
            }

            constrainedRandom(min, max, variance) {
                const center = (min + max) / 2;
                const range = (max - min) / 2;
                const offset = (Math.random() - 0.5) * 2 * range * variance;
                return Math.round(center + offset);
            }

            generatePalette(variance = 1) {
                const colors = [];
                const baseHue = Math.random() * 360;
                const paletteSize = this.params.paletteSize;

                for (let i = 0; i < paletteSize; i++) {
                    // Analogous harmony is most reliable for high scores
                    const spread = 20 + 10 * variance;
                    let hue = (baseHue + (i - paletteSize/2) * spread) % 360;
                    if (hue < 0) hue += 360;

                    const satCenter = (this.params.saturationRange[0] + this.params.saturationRange[1]) / 2;
                    const satRange = (this.params.saturationRange[1] - this.params.saturationRange[0]) / 2;
                    const saturation = satCenter + (Math.random() - 0.5) * 2 * satRange * variance;

                    const lightCenter = (this.params.lightnessRange[0] + this.params.lightnessRange[1]) / 2;
                    const lightRange = (this.params.lightnessRange[1] - this.params.lightnessRange[0]) / 2;
                    const lightness = lightCenter + (Math.random() - 0.5) * 2 * lightRange * variance;

                    colors.push(this.hslToHex(hue,
                        Math.max(0.4, Math.min(0.9, saturation)),
                        Math.max(0.3, Math.min(0.7, lightness))
                    ));
                }

                return colors;
            }

            generateFocalElement(colors, variance = 1) {
                // Power points for rule of thirds
                const powerPoints = [
                    { x: this.width / 3, y: this.height / 3 },
                    { x: this.width * 2 / 3, y: this.height / 3 },
                    { x: this.width / 3, y: this.height * 2 / 3 },
                    { x: this.width * 2 / 3, y: this.height * 2 / 3 }
                ];

                const point = powerPoints[Math.floor(Math.random() * powerPoints.length)];

                // Add small variance to position
                const offsetX = (Math.random() - 0.5) * 60 * variance;
                const offsetY = (Math.random() - 0.5) * 60 * variance;

                const baseSize = 120;
                const sizeVar = 40 * variance;
                const size = baseSize + (Math.random() - 0.5) * 2 * sizeVar;

                const x = point.x - size/2 + offsetX;
                const y = point.y - size/2 + offsetY;

                return this.createElement(x, y, size, size * 0.9, colors, true, variance);
            }

            generateElement(colors, existingElements, variance = 1) {
                let x, y;
                let attempts = 0;

                // Try to place near rule of thirds or golden ratio with controlled variance
                do {
                    if (Math.random() < this.params.useRuleOfThirds) {
                        const thirdX = [this.width / 3, this.width * 2 / 3];
                        const thirdY = [this.height / 3, this.height * 2 / 3];
                        const baseX = thirdX[Math.floor(Math.random() * 2)];
                        const baseY = thirdY[Math.floor(Math.random() * 2)];
                        x = baseX + (Math.random() - 0.5) * 140 * variance;
                        y = baseY + (Math.random() - 0.5) * 140 * variance;
                    } else {
                        const phi = 1.618;
                        const goldenX = [this.width / phi, this.width - this.width / phi];
                        const goldenY = [this.height / phi, this.height - this.height / phi];
                        x = goldenX[Math.floor(Math.random() * 2)] + (Math.random() - 0.5) * 100 * variance;
                        y = goldenY[Math.floor(Math.random() * 2)] + (Math.random() - 0.5) * 100 * variance;
                    }
                    attempts++;
                } while (attempts < 3 && this.tooCloseToCenter(x, y));

                const baseSizeMin = 30;
                const baseSizeMax = 70;
                const baseSize = baseSizeMin + Math.random() * (baseSizeMax - baseSizeMin) * variance +
                                 (1 - variance) * (baseSizeMin + baseSizeMax) / 2;

                const width = baseSize * (1 + (Math.random() - 0.5) * this.params.sizeVariation * variance);
                const height = baseSize * (1 + (Math.random() - 0.5) * this.params.sizeVariation * variance);

                return this.createElement(x, y, width, height, colors, false, variance);
            }

            tooCloseToCenter(x, y) {
                const cx = this.width / 2;
                const cy = this.height / 2;
                return Math.abs(x - cx) < this.width * 0.1 && Math.abs(y - cy) < this.height * 0.1;
            }

            createElement(x, y, width, height, colors, isFocal, variance = 1) {
                // Favor circles for consistency
                const typeRoll = Math.random();
                let type;
                if (typeRoll < this.params.circleWeight) type = 'circle';
                else if (typeRoll < this.params.circleWeight + this.params.rectWeight) type = 'rect';
                else if (typeRoll < this.params.circleWeight + this.params.rectWeight + this.params.polygonWeight) type = 'polygon';
                else type = 'circle'; // Default to circle for consistency

                const color = colors[Math.floor(Math.random() * colors.length)];
                const opacity = Math.random() < this.params.useOpacity ?
                    0.7 + Math.random() * 0.3 : 1;

                const hasStroke = Math.random() < this.params.strokeWeight;
                const strokeColor = hasStroke ? colors[Math.floor(Math.random() * colors.length)] : null;

                const element = {
                    type,
                    x: Math.max(20, Math.min(this.width - width - 20, x)),
                    y: Math.max(20, Math.min(this.height - height - 20, y)),
                    width,
                    height,
                    color,
                    opacity,
                    strokeColor,
                    strokeWidth: hasStroke ? this.randomFloat(1, 3) : 0,
                    isFocal
                };

                if (type === 'circle') {
                    element.radius = Math.min(width, height) / 2;
                    element.x += element.radius;
                    element.y += element.radius;
                }

                if (type === 'polygon') {
                    element.points = this.generatePolygonPoints(x, y, width, height);
                }

                if (type === 'path') {
                    element.d = this.generatePathD(x, y, width, height);
                }

                return element;
            }

            generatePolygonPoints(x, y, width, height) {
                const sides = this.randomInt(3, 6);
                const points = [];
                const cx = x + width / 2;
                const cy = y + height / 2;
                const r = Math.min(width, height) / 2;

                for (let i = 0; i < sides; i++) {
                    const angle = (i / sides) * Math.PI * 2 - Math.PI / 2;
                    const px = cx + Math.cos(angle) * r;
                    const py = cy + Math.sin(angle) * r;
                    points.push(`${px},${py}`);
                }

                return points.join(' ');
            }

            generatePathD(x, y, width, height) {
                const numPoints = this.randomInt(3, 5);
                let d = `M ${x} ${y + height / 2}`;

                for (let i = 1; i <= numPoints; i++) {
                    const px = x + (width / numPoints) * i;
                    const py = y + height / 2 + this.randomFloat(-height/3, height/3);
                    const cpx = px - width / numPoints / 2;
                    const cpy = this.randomFloat(y + height * 0.2, y + height * 0.8);
                    d += ` Q ${cpx} ${cpy} ${px} ${py}`;
                }

                return d;
            }

            evolve(rating) {
                const metrics = rating.metrics;

                // Micro-adjustments based on weakest metric
                const sorted = Object.entries(metrics).sort((a, b) => a[1] - b[1]);
                const weakest = sorted[0];

                switch (weakest[0]) {
                    case 'composition':
                        this.params.useRuleOfThirds = Math.min(0.98, this.params.useRuleOfThirds + 0.02);
                        this.params.centerBias = Math.max(0.02, this.params.centerBias - 0.01);
                        break;
                    case 'colorHarmony':
                        this.params.saturationRange = [0.52, 0.78];
                        break;
                    case 'balance':
                        this.params.minElements = Math.min(14, this.params.minElements + 1);
                        break;
                    case 'complexity':
                        this.params.minElements = 11;
                        this.params.maxElements = 19;
                        break;
                    case 'focalPoint':
                        this.params.focalSizeMultiplier = Math.min(3.5, this.params.focalSizeMultiplier + 0.2);
                        break;
                    case 'rhythm':
                        this.params.circleWeight = Math.min(0.6, this.params.circleWeight + 0.03);
                        break;
                }

                // Save best score
                if (rating.overall > this.bestScore) {
                    this.bestScore = rating.overall;
                }
            }

            // Utility functions
            randomInt(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }

            randomFloat(min, max) {
                return Math.random() * (max - min) + min;
            }

            hslToHex(h, s, l) {
                h /= 360;
                let r, g, b;

                if (s === 0) {
                    r = g = b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };

                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }

                const toHex = x => {
                    const hex = Math.round(x * 255).toString(16);
                    return hex.length === 1 ? '0' + hex : hex;
                };

                return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
            }
        }

        // ═══════════════════════════════════════════════════════════════
        // SVG RENDERER
        // ═══════════════════════════════════════════════════════════════

        class SVGRenderer {
            constructor(svgElement) {
                this.svg = svgElement;
            }

            render(artwork) {
                this.svg.innerHTML = '';

                // Add background
                const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                bg.setAttribute('width', artwork.width);
                bg.setAttribute('height', artwork.height);
                bg.setAttribute('fill', '#fafafa');
                this.svg.appendChild(bg);

                // Render elements
                artwork.elements.forEach(el => {
                    const svgEl = this.createElement(el);
                    if (svgEl) this.svg.appendChild(svgEl);
                });

                return this.svg.outerHTML;
            }

            createElement(el) {
                let svgEl;

                switch (el.type) {
                    case 'circle':
                        svgEl = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        svgEl.setAttribute('cx', el.x);
                        svgEl.setAttribute('cy', el.y);
                        svgEl.setAttribute('r', el.radius);
                        break;

                    case 'rect':
                        svgEl = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        svgEl.setAttribute('x', el.x);
                        svgEl.setAttribute('y', el.y);
                        svgEl.setAttribute('width', el.width);
                        svgEl.setAttribute('height', el.height);
                        svgEl.setAttribute('rx', Math.min(el.width, el.height) * 0.1);
                        break;

                    case 'polygon':
                        svgEl = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                        svgEl.setAttribute('points', el.points);
                        break;

                    case 'path':
                        svgEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        svgEl.setAttribute('d', el.d);
                        svgEl.setAttribute('fill', 'none');
                        svgEl.setAttribute('stroke', el.color);
                        svgEl.setAttribute('stroke-width', el.width * 0.1);
                        svgEl.setAttribute('stroke-linecap', 'round');
                        return svgEl;
                }

                svgEl.setAttribute('fill', el.color);
                svgEl.setAttribute('opacity', el.opacity);

                if (el.strokeColor) {
                    svgEl.setAttribute('stroke', el.strokeColor);
                    svgEl.setAttribute('stroke-width', el.strokeWidth);
                }

                return svgEl;
            }
        }

        // ═══════════════════════════════════════════════════════════════
        // APPLICATION
        // ═══════════════════════════════════════════════════════════════

        const engine = new GenerativeArtEngine();
        const discriminator = new AestheticDiscriminator();
        const renderer = new SVGRenderer(document.getElementById('artwork'));

        let streak = 0;
        let masterpieces = [];
        let autoInterval = null;
        let totalGenerated = 0;

        function generate() {
            // Set streak on engine for consistency mode
            engine.setStreak(streak);

            const artwork = engine.generate();
            renderer.render(artwork);

            const rating = discriminator.rate(artwork);
            totalGenerated++;

            // Update UI
            updateScoreDisplay(rating);

            // Check for masterpiece
            if (rating.overall >= 90) {
                streak++;
                saveMasterpiece(artwork, rating.overall);

                // Celebrate when reaching 10!
                if (streak === 10) {
                    document.getElementById('streakCount').parentElement.innerHTML =
                        '<div style="color: #10b981; font-size: 1.5rem;">10 MASTERPIECES ACHIEVED!</div>';
                }
            } else {
                streak = 0;
                engine.evolve(rating);
            }

            document.getElementById('streakCount').textContent = streak;

            // Log entry
            addLogEntry(totalGenerated, rating);

            return rating;
        }

        function updateScoreDisplay(rating) {
            const scoreEl = document.getElementById('overallScore');
            scoreEl.textContent = rating.overall;

            // Color based on score
            if (rating.overall >= 90) {
                scoreEl.style.color = '#10b981';
            } else if (rating.overall >= 70) {
                scoreEl.style.color = '#f59e0b';
            } else {
                scoreEl.style.color = '#ef4444';
            }

            // Update metric displays
            const metrics = [
                ['composition', rating.metrics.composition],
                ['color', rating.metrics.colorHarmony],
                ['balance', rating.metrics.balance],
                ['complexity', rating.metrics.complexity],
                ['focal', rating.metrics.focalPoint],
                ['rhythm', rating.metrics.rhythm]
            ];

            metrics.forEach(([name, value]) => {
                document.getElementById(`${name}Score`).textContent = Math.round(value);
                document.getElementById(`${name}Bar`).style.width = `${value}%`;
            });

            document.getElementById('analysisText').innerHTML =
                `<h3>Analysis</h3><p>${rating.analysis}</p>`;
        }

        function saveMasterpiece(artwork, score) {
            const svgContent = document.getElementById('artwork').outerHTML;
            masterpieces.push({ svg: svgContent, score });

            const gallery = document.getElementById('masterpieceGallery');
            const item = document.createElement('div');
            item.className = 'gallery-item';
            item.innerHTML = svgContent + `<span class="score-badge">${score}</span>`;
            item.onclick = () => {
                document.getElementById('artworkContainer').innerHTML = svgContent;
            };
            gallery.appendChild(item);
        }

        function addLogEntry(iteration, rating) {
            const log = document.getElementById('logEntries');
            const entry = document.createElement('div');
            entry.className = 'log-entry';

            const color = rating.overall >= 90 ? '#10b981' :
                         rating.overall >= 70 ? '#f59e0b' : '#ef4444';

            entry.innerHTML = `
                <span class="iteration">#${iteration}</span>
                <span class="score" style="color: ${color}">${rating.overall}</span>
                <span class="reason">${rating.overall >= 90 ? 'MASTERPIECE!' :
                    `Comp:${Math.round(rating.metrics.composition)} Col:${Math.round(rating.metrics.colorHarmony)} Bal:${Math.round(rating.metrics.balance)}`}</span>
            `;

            log.insertBefore(entry, log.firstChild);

            // Keep only last 50 entries
            while (log.children.length > 50) {
                log.removeChild(log.lastChild);
            }
        }

        // Event listeners
        document.getElementById('generateBtn').onclick = generate;

        document.getElementById('evolveBtn').onclick = () => {
            // Generate 10 artworks and keep best traits
            let best = null;
            let bestScore = 0;

            for (let i = 0; i < 10; i++) {
                const artwork = engine.generate();
                const rating = discriminator.rate(artwork);
                if (rating.overall > bestScore) {
                    best = artwork;
                    bestScore = rating.overall;
                }
            }

            if (best) {
                renderer.render(best);
                updateScoreDisplay(discriminator.rate(best));
            }
        };

        document.getElementById('exportBtn').onclick = () => {
            const svgContent = document.getElementById('artwork').outerHTML;
            const blob = new Blob([svgContent], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `generative-art-${Date.now()}.svg`;
            a.click();
            URL.revokeObjectURL(url);
        };

        document.getElementById('resetBtn').onclick = () => {
            engine.generation = 0;
            engine.bestScore = 0;
            streak = 0;
            masterpieces = [];
            totalGenerated = 0;
            document.getElementById('streakCount').textContent = '0';
            document.getElementById('masterpieceGallery').innerHTML = '';
            document.getElementById('logEntries').innerHTML = '';
        };

        document.getElementById('autoMode').onchange = (e) => {
            if (e.target.checked) {
                const speed = parseInt(document.getElementById('speedSlider').value);
                autoInterval = setInterval(generate, speed);
            } else {
                clearInterval(autoInterval);
            }
        };

        document.getElementById('speedSlider').oninput = (e) => {
            if (document.getElementById('autoMode').checked) {
                clearInterval(autoInterval);
                autoInterval = setInterval(generate, parseInt(e.target.value));
            }
        };

        // Generate initial artwork
        generate();
    </script>
</body>
</html>
