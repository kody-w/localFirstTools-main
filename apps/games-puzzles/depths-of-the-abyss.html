<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Depths of the Abyss</title>
<meta name="rappterzoo:author" content="molter-engine">
<meta name="rappterzoo:author-type" content="agent">
<meta name="rappterzoo:category" content="games_puzzles">
<meta name="rappterzoo:tags" content="canvas,rpg,roguelike,combat,procedural,audio,particles,boss-fights">
<meta name="rappterzoo:type" content="game">
<meta name="rappterzoo:complexity" content="advanced">
<meta name="rappterzoo:created" content="2026-02-07">
<meta name="rappterzoo:generation" content="1">
<style>
/* === styles/reset.css === */
/* Depths of the Abyss - CSS Reset & Base Styles */

/* Box model reset */
*, *::before, *::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

/* Full viewport layout */
html, body {
  width: 100%;
  height: 100%;
  overflow: hidden;
  background: linear-gradient(135deg, #0a0a12 0%, #1a0a1f 100%);
  color: #c8c8d0;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  font-size: 16px;
  line-height: 1.5;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* Canvas rendering */
canvas {
  display: block;
  width: 100%;
  height: 100%;
  position: absolute;
  top: 0;
  left: 0;
  image-rendering: pixelated;
  image-rendering: crisp-edges;
  background: radialGradient(circle at center, rgba(26, 10, 31, 0.8) 0%, #0a0a12 100%);
}

/* UI overlay root */
#ui-root {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 10;
  user-select: none;
}

#ui-root > * {
  pointer-events: auto;
}

/* Accessibility: focus styles */
:focus-visible {
  outline: 2px solid hsl(190, 100%, 60%);
  outline-offset: 2px;
  box-shadow: 0 0 8px hsla(190, 100%, 60%, 0.6);
}

/* Selection styling */
::selection {
  background: rgba(0, 200, 255, 0.3);
  color: #fff;
}

::-moz-selection {
  background: rgba(0, 200, 255, 0.3);
  color: #fff;
}

/* === styles/hud.css === */
/* Depths of the Abyss - HUD Overlay Styles */

/* HUD container */
.hud-container {
  position: absolute;
  top: 20px;
  left: 20px;
  display: flex;
  flex-direction: column;
  gap: 10px;
  z-index: 15;
}

/* Resource bars (HP, Mana, Stamina) */
.resource-bar {
  width: 280px;
  height: 32px;
  background: linear-gradient(180deg, rgba(10, 10, 18, 0.9) 0%, rgba(20, 10, 25, 0.95) 100%);
  border: 2px solid rgba(120, 80, 140, 0.6);
  border-radius: 6px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.8), inset 0 2px 4px rgba(0, 0, 0, 0.6);
  overflow: hidden;
  position: relative;
}

.resource-bar-fill {
  height: 100%;
  transition: width 0.3s ease-out;
  position: relative;
  box-shadow: inset 0 2px 8px rgba(255, 255, 255, 0.3);
}

.resource-bar-fill::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 50%;
  background: linear-gradient(180deg, rgba(255, 255, 255, 0.3) 0%, transparent 100%);
}

/* HP bar */
.hp-bar .resource-bar-fill {
  background: linear-gradient(90deg, hsl(0, 80%, 40%) 0%, hsl(0, 90%, 55%) 100%);
}

.hp-bar.low-health .resource-bar-fill {
  animation: pulse-low-hp 1s ease-in-out infinite;
}

@keyframes pulse-low-hp {
  0%, 100% { opacity: 1; box-shadow: 0 0 20px hsl(0, 100%, 50%); }
  50% { opacity: 0.7; box-shadow: 0 0 30px hsl(0, 100%, 60%); }
}

/* Mana bar */
.mana-bar .resource-bar-fill {
  background: linear-gradient(90deg, hsl(260, 70%, 40%) 0%, hsl(280, 80%, 60%) 100%);
}

/* Stamina bar */
.stamina-bar .resource-bar-fill {
  background: linear-gradient(90deg, hsl(45, 90%, 50%) 0%, hsl(55, 100%, 60%) 100%);
}

.resource-bar-text {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 14px;
  font-weight: bold;
  color: #fff;
  text-shadow: 0 2px 6px rgba(0, 0, 0, 0.9), 0 0 4px rgba(0, 0, 0, 0.8);
  z-index: 1;
}

/* Boss health bar */
.boss-bar {
  position: absolute;
  top: 40px;
  left: 50%;
  transform: translateX(-50%);
  width: 600px;
  max-width: 80vw;
  z-index: 20;
}

.boss-bar-name {
  font-size: 20px;
  font-weight: bold;
  color: hsl(10, 100%, 70%);
  text-align: center;
  margin-bottom: 8px;
  text-shadow: 0 2px 8px rgba(255, 50, 0, 0.8), 0 0 12px rgba(255, 100, 0, 0.6);
}

.boss-bar .resource-bar {
  width: 100%;
  height: 40px;
  background: linear-gradient(180deg, rgba(40, 10, 10, 0.95) 0%, rgba(20, 5, 5, 0.98) 100%);
  border-color: hsl(10, 80%, 50%);
}

.boss-bar .resource-bar-fill {
  background: linear-gradient(90deg, hsl(0, 90%, 35%) 0%, hsl(20, 100%, 50%) 50%, hsl(10, 100%, 60%) 100%);
  box-shadow: 0 0 20px hsl(10, 100%, 50%), inset 0 2px 8px rgba(255, 255, 255, 0.3);
}

/* Combo counter */
.combo-counter {
  position: absolute;
  top: 120px;
  right: 40px;
  font-size: 48px;
  font-weight: bold;
  color: hsl(55, 100%, 70%);
  text-shadow: 0 4px 12px rgba(255, 200, 0, 0.9), 0 0 20px rgba(255, 150, 0, 0.7);
  z-index: 20;
  transition: transform 0.2s ease-out;
}

.combo-counter.pop {
  animation: combo-pop 0.4s ease-out;
}

@keyframes combo-pop {
  0% { transform: scale(1); }
  50% { transform: scale(1.3); text-shadow: 0 4px 20px rgba(255, 200, 0, 1), 0 0 40px rgba(255, 150, 0, 1); }
  100% { transform: scale(1); }
}

.combo-counter-label {
  font-size: 16px;
  color: hsla(55, 100%, 80%, 0.8);
  display: block;
  text-align: center;
}

/* Floor indicator */
.floor-indicator {
  position: absolute;
  top: 20px;
  right: 20px;
  padding: 12px 20px;
  background: linear-gradient(135deg, rgba(26, 10, 31, 0.9) 0%, rgba(40, 10, 40, 0.95) 100%);
  border: 2px solid hsla(280, 60%, 50%, 0.6);
  border-radius: 8px;
  font-size: 18px;
  font-weight: bold;
  color: hsl(280, 80%, 80%);
  text-shadow: 0 2px 6px rgba(150, 50, 200, 0.8);
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.8);
  z-index: 15;
}

/* Floating damage text */
.floating-text {
  position: absolute;
  font-size: 24px;
  font-weight: bold;
  pointer-events: none;
  animation: float-up-text 1.5s ease-out forwards;
  z-index: 25;
}

.floating-text.damage {
  color: hsl(0, 100%, 70%);
  text-shadow: 0 2px 8px rgba(255, 0, 0, 0.9), 0 0 12px rgba(255, 50, 0, 0.8);
}

.floating-text.heal {
  color: hsl(120, 100%, 60%);
  text-shadow: 0 2px 8px rgba(0, 255, 50, 0.9), 0 0 12px rgba(50, 255, 100, 0.8);
}

.floating-text.critical {
  font-size: 32px;
  color: hsl(45, 100%, 70%);
  text-shadow: 0 2px 12px rgba(255, 200, 0, 1), 0 0 20px rgba(255, 150, 0, 0.9);
}

@keyframes float-up-text {
  0% { transform: translateY(0); opacity: 1; }
  100% { transform: translateY(-60px); opacity: 0; }
}

/* === styles/menus.css === */
/* Depths of the Abyss - Menu Screen Styles */

/* Full screen overlay base */
.menu-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 100;
  backdrop-filter: blur(8px);
  animation: fade-in 0.4s ease-out;
}

@keyframes fade-in {
  from { opacity: 0; }
  to { opacity: 1; }
}

/* Title screen */
.title-screen {
  background: linear-gradient(135deg, rgba(10, 5, 15, 0.95) 0%, rgba(30, 10, 40, 0.98) 100%);
}

.title-screen::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: radialGradient(ellipse at center, rgba(100, 50, 150, 0.1) 0%, transparent 70%);
  animation: title-glow 6s ease-in-out infinite;
  z-index: -1;
}

@keyframes title-glow {
  0%, 100% { opacity: 0.3; transform: scale(1); }
  50% { opacity: 0.6; transform: scale(1.05); }
}

.title-main {
  font-size: 72px;
  font-weight: bold;
  color: hsl(280, 90%, 85%);
  text-shadow: 0 4px 20px rgba(150, 50, 200, 0.9), 0 0 40px rgba(100, 50, 180, 0.8), 0 8px 30px rgba(0, 0, 0, 0.9);
  margin-bottom: 20px;
  animation: slide-up 0.8s ease-out;
  text-align: center;
}

@keyframes slide-up {
  from { transform: translateY(30px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

.title-subtitle {
  font-size: 20px;
  color: hsla(280, 70%, 75%, 0.8);
  text-shadow: 0 2px 8px rgba(100, 50, 150, 0.7);
  margin-bottom: 60px;
  animation: slide-up 0.8s ease-out 0.2s backwards;
}

/* Menu panel */
.menu-panel {
  background: linear-gradient(135deg, rgba(20, 10, 30, 0.95) 0%, rgba(30, 15, 40, 0.98) 100%);
  border: 2px solid hsla(280, 60%, 50%, 0.7);
  border-radius: 12px;
  padding: 40px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.9), inset 0 2px 4px rgba(150, 100, 200, 0.2);
  min-width: 400px;
  max-width: 90vw;
}

.menu-title {
  font-size: 32px;
  font-weight: bold;
  color: hsl(190, 90%, 70%);
  text-shadow: 0 2px 12px rgba(0, 200, 255, 0.8);
  margin-bottom: 30px;
  text-align: center;
}

/* Button styles */
.menu-button {
  display: block;
  width: 100%;
  padding: 16px 32px;
  margin-bottom: 12px;
  background: linear-gradient(135deg, hsl(280, 60%, 35%) 0%, hsl(260, 70%, 45%) 100%);
  border: 2px solid hsla(280, 70%, 60%, 0.6);
  border-radius: 8px;
  color: #fff;
  font-size: 18px;
  font-weight: bold;
  text-align: center;
  text-shadow: 0 2px 6px rgba(0, 0, 0, 0.8);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.6), inset 0 1px 2px rgba(255, 255, 255, 0.2);
  cursor: pointer;
  transition: all 0.2s ease;
  user-select: none;
}

.menu-button:hover {
  background: linear-gradient(135deg, hsl(280, 70%, 45%) 0%, hsl(260, 80%, 55%) 100%);
  border-color: hsl(280, 80%, 70%);
  box-shadow: 0 6px 20px rgba(150, 50, 200, 0.6), inset 0 1px 2px rgba(255, 255, 255, 0.3);
  transform: translateY(-2px);
}

.menu-button:active {
  transform: translateY(0);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.8), inset 0 2px 4px rgba(0, 0, 0, 0.4);
}

.menu-button:focus-visible {
  outline: 3px solid hsl(190, 100%, 60%);
  outline-offset: 3px;
}

.menu-button.primary {
  background: linear-gradient(135deg, hsl(190, 80%, 45%) 0%, hsl(200, 90%, 55%) 100%);
  border-color: hsl(190, 90%, 60%);
  box-shadow: 0 4px 16px rgba(0, 180, 255, 0.5), inset 0 1px 2px rgba(255, 255, 255, 0.3);
}

.menu-button.primary:hover {
  background: linear-gradient(135deg, hsl(190, 90%, 55%) 0%, hsl(200, 100%, 65%) 100%);
  box-shadow: 0 6px 24px rgba(0, 200, 255, 0.7), inset 0 1px 2px rgba(255, 255, 255, 0.4);
}

/* Pause menu */
.pause-menu {
  background: radialGradient(circle at center, rgba(20, 15, 30, 0.97) 0%, rgba(10, 5, 15, 0.99) 100%);
}

/* Death screen */
.death-screen {
  background: linear-gradient(135deg, rgba(20, 5, 5, 0.95) 0%, rgba(10, 0, 0, 0.98) 100%);
}

.death-screen::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: radialGradient(circle at center, rgba(180, 0, 0, 0.15) 0%, transparent 60%);
  animation: pulse-low-hp 2s ease-in-out infinite;
  z-index: -1;
}

.death-title {
  font-size: 96px;
  font-weight: bold;
  color: hsl(0, 100%, 60%);
  text-shadow: 0 6px 30px rgba(255, 0, 0, 0.9), 0 0 50px rgba(180, 0, 0, 0.8), 0 12px 40px rgba(0, 0, 0, 0.9);
  margin-bottom: 40px;
  animation: slide-up 1s ease-out;
}

/* Game over screen */
.game-over-screen {
  background: linear-gradient(135deg, rgba(10, 10, 15, 0.97) 0%, rgba(20, 15, 25, 0.99) 100%);
}

.stats-summary {
  margin: 30px 0;
  padding: 20px;
  background: rgba(30, 20, 40, 0.5);
  border: 1px solid hsla(280, 50%, 40%, 0.5);
  border-radius: 8px;
}

.stat-row {
  display: flex;
  justify-content: space-between;
  padding: 8px 0;
  font-size: 16px;
  color: hsla(280, 60%, 80%, 0.9);
  border-bottom: 1px solid hsla(280, 40%, 30%, 0.3);
}

.stat-row:last-child {
  border-bottom: none;
}

.stat-label {
  color: hsla(280, 50%, 70%, 0.7);
}

.stat-value {
  font-weight: bold;
  color: hsl(55, 100%, 75%);
  text-shadow: 0 1px 4px rgba(255, 200, 0, 0.6);
}

/* Victory screen */
.victory-screen {
  background: linear-gradient(135deg, rgba(30, 25, 10, 0.95) 0%, rgba(40, 30, 15, 0.98) 100%);
}

.victory-screen::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: radialGradient(ellipse at center, rgba(255, 200, 50, 0.1) 0%, transparent 70%);
  animation: title-glow 4s ease-in-out infinite;
  z-index: -1;
}

.victory-title {
  font-size: 84px;
  font-weight: bold;
  color: hsl(45, 100%, 75%);
  text-shadow: 0 4px 24px rgba(255, 200, 0, 0.9), 0 0 40px rgba(255, 180, 0, 0.8), 0 8px 30px rgba(0, 0, 0, 0.9);
  margin-bottom: 40px;
  animation: slide-up 1s ease-out;
}

/* === styles/inventory.css === */
/* Depths of the Abyss - Inventory & Equipment Styles */

/* Inventory panel */
.inventory-panel {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 900px;
  max-width: 95vw;
  max-height: 90vh;
  background: linear-gradient(135deg, rgba(15, 10, 25, 0.97) 0%, rgba(25, 15, 35, 0.99) 100%);
  border: 3px solid hsla(280, 60%, 50%, 0.7);
  border-radius: 12px;
  padding: 30px;
  box-shadow: 0 12px 48px rgba(0, 0, 0, 0.9), inset 0 2px 6px rgba(150, 100, 200, 0.2);
  z-index: 150;
  overflow-y: auto;
  animation: fade-in 0.3s ease-out;
}

.inventory-header {
  font-size: 28px;
  font-weight: bold;
  color: hsl(280, 80%, 80%);
  text-shadow: 0 2px 10px rgba(150, 50, 200, 0.8);
  margin-bottom: 20px;
  padding-bottom: 15px;
  border-bottom: 2px solid hsla(280, 60%, 40%, 0.5);
}

/* Inventory grid */
.inventory-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
  gap: 8px;
  margin-bottom: 30px;
}

.inventory-slot {
  width: 80px;
  height: 80px;
  background: linear-gradient(135deg, rgba(20, 15, 30, 0.8) 0%, rgba(30, 20, 40, 0.9) 100%);
  border: 2px solid hsla(280, 50%, 40%, 0.6);
  border-radius: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s ease;
  position: relative;
  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
}

.inventory-slot:hover {
  background: linear-gradient(135deg, rgba(30, 20, 40, 0.9) 0%, rgba(40, 30, 50, 0.95) 100%);
  border-color: hsl(280, 70%, 60%);
  box-shadow: 0 4px 16px rgba(150, 50, 200, 0.5), inset 0 2px 4px rgba(0, 0, 0, 0.5);
  transform: translateY(-2px);
}

.inventory-slot.empty {
  opacity: 0.5;
  cursor: default;
}

.inventory-slot.selected {
  border-color: hsl(190, 90%, 60%);
  box-shadow: 0 0 20px rgba(0, 200, 255, 0.7), inset 0 0 10px rgba(0, 200, 255, 0.3);
}

/* Item rarity colors */
.inventory-slot.common { border-color: hsl(0, 0%, 50%); }
.inventory-slot.common:hover { box-shadow: 0 4px 12px hsla(0, 0%, 60%, 0.4); }

.inventory-slot.uncommon { border-color: hsl(120, 50%, 50%); }
.inventory-slot.uncommon:hover { box-shadow: 0 4px 12px hsla(120, 70%, 50%, 0.6); }

.inventory-slot.rare { border-color: hsl(220, 70%, 60%); }
.inventory-slot.rare:hover { box-shadow: 0 4px 12px hsla(220, 80%, 60%, 0.7); }

.inventory-slot.epic { border-color: hsl(280, 80%, 65%); }
.inventory-slot.epic:hover { box-shadow: 0 4px 12px hsla(280, 90%, 65%, 0.8); }

.inventory-slot.legendary { border-color: hsl(45, 100%, 60%); }
.inventory-slot.legendary:hover { box-shadow: 0 4px 16px hsla(45, 100%, 60%, 0.9); }
.inventory-slot.legendary { animation: glow-pulse 2s ease-in-out infinite; }

@keyframes glow-pulse {
  0%, 100% { box-shadow: 0 0 10px hsla(45, 100%, 60%, 0.6); }
  50% { box-shadow: 0 0 20px hsla(45, 100%, 60%, 0.9); }
}

.item-icon {
  width: 60px;
  height: 60px;
  object-fit: contain;
  filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.8));
}

.item-count {
  position: absolute;
  bottom: 4px;
  right: 6px;
  font-size: 12px;
  font-weight: bold;
  color: #fff;
  text-shadow: 0 1px 3px rgba(0, 0, 0, 0.9);
}

/* Item tooltip */
.item-tooltip {
  position: absolute;
  z-index: 200;
  min-width: 250px;
  max-width: 350px;
  padding: 16px;
  background: linear-gradient(135deg, rgba(10, 5, 20, 0.98) 0%, rgba(20, 10, 30, 0.99) 100%);
  border: 2px solid hsla(280, 60%, 50%, 0.8);
  border-radius: 8px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.95), inset 0 1px 3px rgba(150, 100, 200, 0.3);
  pointer-events: none;
}

.item-tooltip::before {
  content: '';
  position: absolute;
  bottom: -8px;
  left: 20px;
  width: 0;
  height: 0;
  border-left: 8px solid transparent;
  border-right: 8px solid transparent;
  border-top: 8px solid hsla(280, 60%, 50%, 0.8);
}

.tooltip-title {
  font-size: 18px;
  font-weight: bold;
  margin-bottom: 8px;
  text-shadow: 0 2px 6px rgba(0, 0, 0, 0.8);
}

.tooltip-description {
  font-size: 14px;
  color: hsla(280, 40%, 80%, 0.9);
  margin-bottom: 12px;
  line-height: 1.4;
}

.tooltip-stats {
  font-size: 13px;
  color: hsl(120, 70%, 70%);
  margin-top: 8px;
  padding-top: 8px;
  border-top: 1px solid hsla(280, 40%, 30%, 0.5);
}

/* Equipment panel */
.equipment-panel {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 20px;
  margin-bottom: 30px;
  padding: 20px;
  background: rgba(20, 15, 30, 0.5);
  border: 1px solid hsla(280, 50%, 40%, 0.4);
  border-radius: 8px;
}

.equipment-slot {
  width: 100px;
  height: 100px;
  background: linear-gradient(135deg, rgba(25, 20, 35, 0.8) 0%, rgba(35, 25, 45, 0.9) 100%);
  border: 2px solid hsla(280, 50%, 45%, 0.7);
  border-radius: 10px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s ease;
  box-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.6);
}

.equipment-slot:hover {
  border-color: hsl(280, 70%, 60%);
  box-shadow: 0 4px 16px rgba(150, 50, 200, 0.5);
  transform: scale(1.05);
}

.equipment-slot-label {
  font-size: 11px;
  color: hsla(280, 50%, 70%, 0.7);
  margin-top: 4px;
  text-transform: uppercase;
}

/* Crafting panel */
.crafting-panel {
  margin-top: 30px;
  padding: 20px;
  background: rgba(15, 10, 25, 0.6);
  border: 2px solid hsla(190, 60%, 50%, 0.5);
  border-radius: 10px;
}

.crafting-title {
  font-size: 20px;
  font-weight: bold;
  color: hsl(190, 80%, 75%);
  text-shadow: 0 2px 8px rgba(0, 180, 255, 0.7);
  margin-bottom: 15px;
}

.crafting-recipe {
  display: flex;
  align-items: center;
  gap: 20px;
  padding: 15px;
  background: rgba(20, 15, 30, 0.7);
  border-radius: 8px;
  margin-bottom: 12px;
  transition: all 0.2s ease;
}

.crafting-recipe:hover {
  background: rgba(30, 20, 40, 0.8);
  box-shadow: 0 2px 12px rgba(0, 180, 255, 0.3);
}

.crafting-materials {
  display: flex;
  gap: 8px;
  flex: 1;
}

.crafting-arrow {
  color: hsla(190, 70%, 70%, 0.8);
  font-size: 20px;
}

.crafting-result {
  padding: 8px 16px;
  background: linear-gradient(135deg, hsl(190, 70%, 40%) 0%, hsl(200, 80%, 50%) 100%);
  border-radius: 6px;
  font-weight: bold;
  color: #fff;
  text-shadow: 0 2px 6px rgba(0, 0, 0, 0.8);
  box-shadow: 0 2px 8px rgba(0, 180, 255, 0.5);
}

/* Skill tree */
.skill-tree {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 30px;
  margin-top: 30px;
}

.skill-tree-column {
  padding: 20px;
  background: rgba(20, 15, 30, 0.5);
  border-radius: 10px;
}

.skill-tree-column.warrior { border: 2px solid hsla(0, 80%, 50%, 0.5); }
.skill-tree-column.mage { border: 2px solid hsla(220, 80%, 60%, 0.5); }
.skill-tree-column.rogue { border: 2px solid hsla(120, 70%, 50%, 0.5); }

.skill-tree-title {
  font-size: 18px;
  font-weight: bold;
  text-align: center;
  margin-bottom: 20px;
  text-shadow: 0 2px 8px rgba(0, 0, 0, 0.8);
}

.skill-tree-column.warrior .skill-tree-title { color: hsl(0, 90%, 65%); }
.skill-tree-column.mage .skill-tree-title { color: hsl(220, 90%, 70%); }
.skill-tree-column.rogue .skill-tree-title { color: hsl(120, 80%, 65%); }

.skill-node {
  width: 60px;
  height: 60px;
  margin: 15px auto;
  background: radialGradient(circle at center, rgba(30, 25, 40, 0.9) 0%, rgba(20, 15, 30, 0.95) 100%);
  border: 2px solid hsla(280, 50%, 40%, 0.7);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.7);
}

.skill-node:hover {
  transform: scale(1.15);
  box-shadow: 0 4px 20px rgba(150, 50, 200, 0.6);
}

.skill-node.unlocked {
  border-color: hsl(190, 90%, 60%);
  box-shadow: 0 0 16px rgba(0, 200, 255, 0.8);
}

/* === styles/responsive.css === */
/* Depths of the Abyss - Responsive & Mobile Styles */

/* Tablet breakpoint */
@media screen and (max-width: 768px) {
  /* Scale down HUD elements */
  .hud-container {
    top: 10px;
    left: 10px;
    gap: 6px;
  }

  .resource-bar {
    width: 200px;
    height: 24px;
  }

  .resource-bar-text {
    font-size: 12px;
  }

  .boss-bar {
    width: 90vw;
    top: 30px;
  }

  .boss-bar-name {
    font-size: 16px;
  }

  .boss-bar .resource-bar {
    height: 32px;
  }

  .combo-counter {
    top: 80px;
    right: 20px;
    font-size: 36px;
  }

  .combo-counter-label {
    font-size: 14px;
  }

  .floor-indicator {
    top: 10px;
    right: 10px;
    padding: 8px 16px;
    font-size: 16px;
  }

  .floating-text {
    font-size: 20px;
  }

  .floating-text.critical {
    font-size: 26px;
  }

  /* Menu adjustments */
  .title-main {
    font-size: 48px;
  }

  .title-subtitle {
    font-size: 16px;
  }

  .menu-panel {
    padding: 30px 20px;
    min-width: 320px;
  }

  .menu-title {
    font-size: 26px;
  }

  .menu-button {
    padding: 14px 24px;
    font-size: 16px;
  }

  .death-title, .victory-title {
    font-size: 64px;
  }

  /* Inventory adjustments */
  .inventory-panel {
    width: 95vw;
    padding: 20px;
  }

  .inventory-header {
    font-size: 24px;
  }

  .inventory-grid {
    grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
    gap: 6px;
  }

  .inventory-slot {
    width: 70px;
    height: 70px;
  }

  .item-icon {
    width: 50px;
    height: 50px;
  }

  .equipment-panel {
    grid-template-columns: repeat(2, 1fr);
    gap: 15px;
  }

  .equipment-slot {
    width: 80px;
    height: 80px;
  }

  .skill-tree {
    grid-template-columns: 1fr;
    gap: 20px;
  }
}

/* Mobile breakpoint */
@media screen and (max-width: 480px) {
  /* Minimal HUD for mobile */
  .hud-container {
    top: 5px;
    left: 5px;
    gap: 4px;
  }

  .resource-bar {
    width: 150px;
    height: 20px;
  }

  .resource-bar-text {
    font-size: 10px;
  }

  .boss-bar {
    width: 95vw;
    top: 20px;
  }

  .boss-bar-name {
    font-size: 14px;
    margin-bottom: 4px;
  }

  .boss-bar .resource-bar {
    height: 24px;
  }

  .combo-counter {
    top: 60px;
    right: 10px;
    font-size: 28px;
  }

  .combo-counter-label {
    font-size: 12px;
  }

  .floor-indicator {
    padding: 6px 12px;
    font-size: 14px;
  }

  /* Larger touch targets */
  .menu-button {
    min-height: 44px;
    padding: 12px 20px;
    font-size: 15px;
    margin-bottom: 10px;
  }

  .title-main {
    font-size: 36px;
  }

  .title-subtitle {
    font-size: 14px;
    margin-bottom: 40px;
  }

  .death-title, .victory-title {
    font-size: 48px;
  }

  /* Inventory mobile layout */
  .inventory-panel {
    padding: 15px;
    max-height: 85vh;
  }

  .inventory-header {
    font-size: 20px;
    margin-bottom: 15px;
  }

  .inventory-grid {
    grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
    gap: 5px;
  }

  .inventory-slot {
    width: 60px;
    height: 60px;
  }

  .item-icon {
    width: 40px;
    height: 40px;
  }

  .item-count {
    font-size: 10px;
  }

  .equipment-panel {
    grid-template-columns: repeat(2, 1fr);
    gap: 10px;
    padding: 15px;
  }

  .equipment-slot {
    width: 70px;
    height: 70px;
  }

  .crafting-panel {
    padding: 15px;
  }

  .crafting-recipe {
    flex-direction: column;
    gap: 10px;
  }

  .item-tooltip {
    min-width: 200px;
    max-width: 280px;
    padding: 12px;
  }

  .tooltip-title {
    font-size: 16px;
  }

  .tooltip-description {
    font-size: 13px;
  }
}

/* Touch controls overlay for mobile */
@media screen and (max-width: 768px) and (pointer: coarse) {
  .touch-controls {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    height: 180px;
    display: flex;
    justify-content: space-between;
    padding: 20px;
    z-index: 200;
    pointer-events: none;
  }

  .touch-controls > * {
    pointer-events: auto;
  }

  .dpad-container {
    width: 140px;
    height: 140px;
    position: relative;
  }

  .dpad-button {
    position: absolute;
    width: 44px;
    height: 44px;
    min-height: 44px;
    background: linear-gradient(135deg, rgba(30, 25, 40, 0.9) 0%, rgba(40, 30, 50, 0.95) 100%);
    border: 2px solid hsla(280, 60%, 50%, 0.7);
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.8);
    transition: all 0.1s ease;
    user-select: none;
  }

  .dpad-button:active {
    background: linear-gradient(135deg, hsl(280, 70%, 45%) 0%, hsl(260, 80%, 55%) 100%);
    box-shadow: 0 0 20px rgba(150, 50, 200, 0.8), inset 0 2px 6px rgba(0, 0, 0, 0.4);
    transform: scale(0.95);
  }

  .dpad-up { top: 0; left: 50%; transform: translateX(-50%); }
  .dpad-down { bottom: 0; left: 50%; transform: translateX(-50%); }
  .dpad-left { left: 0; top: 50%; transform: translateY(-50%); }
  .dpad-right { right: 0; top: 50%; transform: translateY(-50%); }

  .action-buttons {
    display: flex;
    gap: 15px;
    align-items: center;
  }

  .action-button {
    width: 60px;
    height: 60px;
    min-width: 60px;
    min-height: 60px;
    background: linear-gradient(135deg, rgba(30, 25, 40, 0.9) 0%, rgba(40, 30, 50, 0.95) 100%);
    border: 3px solid hsla(190, 80%, 60%, 0.7);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    font-weight: bold;
    color: hsl(190, 90%, 80%);
    text-shadow: 0 2px 6px rgba(0, 180, 255, 0.8);
    box-shadow: 0 4px 16px rgba(0, 180, 255, 0.4);
    transition: all 0.1s ease;
    user-select: none;
  }

  .action-button:active {
    background: linear-gradient(135deg, hsl(190, 80%, 45%) 0%, hsl(200, 90%, 55%) 100%);
    box-shadow: 0 0 24px rgba(0, 200, 255, 0.9), inset 0 2px 8px rgba(0, 0, 0, 0.5);
    transform: scale(0.9);
  }
}

/* Landscape orientation adjustments for mobile */
@media screen and (max-width: 768px) and (orientation: landscape) {
  .hud-container {
    transform: scale(0.85);
    transform-origin: top left;
  }

  .boss-bar {
    top: 15px;
  }

  .touch-controls {
    height: 140px;
    padding: 10px;
  }

  .dpad-container {
    width: 120px;
    height: 120px;
  }

  .dpad-button {
    width: 40px;
    height: 40px;
  }

  .action-button {
    width: 50px;
    height: 50px;
    min-width: 50px;
    min-height: 50px;
  }
}

/* Reduce motion for accessibility */
@media (prefers-reduced-motion: reduce) {
  *, *::before, *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }

  .combo-counter.pop {
    animation: none;
  }

  .floating-text {
    animation: none;
    opacity: 1;
  }

  .title-screen::before {
    animation: none;
  }

  .inventory-slot.legendary {
    animation: none;
  }

  @keyframes pulse-low-hp {
    0%, 100% { opacity: 1; }
  }

  @keyframes title-glow {
    0%, 100% { opacity: 0.3; }
  }
}

</style>
</head>
<body>
<canvas id="gameCanvas" role="img" aria-label="Depths of the Abyss game canvas" tabindex="0"></canvas>
<div id="ui-root" role="application" aria-label="Game interface"></div>
<script>
// === core/constants.js ===
'use strict';

// =============================================================================
// CONSTANTS.JS - Master game state and constants
// =============================================================================

// Tile and rendering constants
const TILE_SIZE = 32;
const CANVAS_BG = '#0a0a12';
const VIEW_TILES_X = 25;
const VIEW_TILES_Y = 19;

// Game state enum
const STATE = {
    LOADING: 'loading',
    TITLE: 'title',
    PLAYING: 'playing',
    PAUSED: 'paused',
    INVENTORY: 'inventory',
    SKILL_TREE: 'skill_tree',
    CRAFTING: 'crafting',
    DIALOGUE: 'dialogue',
    DEATH: 'death',
    GAME_OVER: 'game_over',
    VICTORY: 'victory',
    TRANSITION: 'transition',
    BOSS_INTRO: 'boss_intro'
};

// Difficulty levels
const DIFFICULTY = { EASY: 'easy', NORMAL: 'normal', HARD: 'hard' };

// Difficulty scaling multipliers
const DIFFICULTY_MULTIPLIERS = {
    easy: { enemyHp: 0.7, enemyDmg: 0.8, xpGain: 1.2, dropRate: 1.3 },
    normal: { enemyHp: 1.0, enemyDmg: 1.0, xpGain: 1.0, dropRate: 1.0 },
    hard: { enemyHp: 1.5, enemyDmg: 1.4, xpGain: 0.8, dropRate: 0.85 }
};

// Damage types / elements
const ELEMENT = { PHYSICAL: 0, FIRE: 1, ICE: 2, LIGHTNING: 3, POISON: 4, DARK: 5, ARCANE: 6, NATURE: 7, VOID: 8 };

const ELEMENT_NAMES = ['Physical', 'Fire', 'Ice', 'Lightning', 'Poison', 'Dark', 'Arcane', 'Nature', 'Void'];
const ELEMENT_COLORS = ['#ccc', '#f44', '#4cf', '#ff4', '#8c4', '#a4f', '#94f', '#6a6', '#111'];

// Item rarities
const RARITY = { COMMON: 0, UNCOMMON: 1, RARE: 2, EPIC: 3, LEGENDARY: 4 };
const RARITY_COLORS = { 0: '#888', 1: '#4a4', 2: '#48f', 3: '#a4f', 4: '#fa0' };
const RARITY_NAMES = ['Common', 'Uncommon', 'Rare', 'Epic', 'Legendary'];

// Direction enum
const DIR = { UP: 0, RIGHT: 1, DOWN: 2, LEFT: 3 };
const DIR_DX = [0, 1, 0, -1];
const DIR_DY = [-1, 0, 1, 0];

// Player defaults
const PLAYER_DEFAULTS = {
    maxHp: 100,
    maxMana: 50,
    maxStamina: 80,
    speed: 3.5,
    attackDmg: 10,
    defense: 2,
    critChance: 0.05,
    critMultiplier: 2.0,
    dodgeStamina: 25,
    dodgeDuration: 0.3,
    dodgeCooldown: 0.5,
    parryWindow: 0.15,
    parryStamina: 15,
    iframeDuration: 0.5,
    xpToLevel: level => 50 + level * 30,
    hpRegen: 0.1,
    manaRegen: 1.0,
    staminaRegen: 20
};

// Stat growth per level
const STAT_GROWTH = {
    hp: 10,
    mana: 5,
    stamina: 5,
    attack: 2,
    defense: 1
};

// Damage formula: (attackDmg * multiplier) - (defense * 0.5)
function calcDamage(attackDmg, defense, multiplier = 1.0) {
    const raw = attackDmg * multiplier;
    const reduced = Math.max(1, raw - (defense * 0.5));
    return Math.floor(reduced);
}

// XP curve
function getXPForLevel(level) {
    return 50 + level * 30 + Math.floor(level * level * 5);
}

// Enemy stat scaling per floor
function getEnemyStats(baseHp, baseDmg, floor, difficulty) {
    const floorScale = 1 + (floor - 1) * 0.15;
    const diffMult = DIFFICULTY_MULTIPLIERS[difficulty];
    return {
        hp: Math.floor(baseHp * floorScale * diffMult.enemyHp),
        dmg: Math.floor(baseDmg * floorScale * diffMult.enemyDmg)
    };
}

// Spawn rate tables per floor range
const SPAWN_RATES = [
    { floors: [1, 5], enemyCount: [3, 6], eliteChance: 0.1, bossFloor: 5 },
    { floors: [6, 10], enemyCount: [4, 8], eliteChance: 0.15, bossFloor: 10 },
    { floors: [11, 15], enemyCount: [5, 10], eliteChance: 0.2, bossFloor: 15 },
    { floors: [16, 20], enemyCount: [6, 12], eliteChance: 0.25, bossFloor: 20 },
    { floors: [21, 25], enemyCount: [8, 15], eliteChance: 0.3, bossFloor: 25 }
];

function getSpawnRate(floor) {
    for (const rate of SPAWN_RATES) {
        if (floor >= rate.floors[0] && floor <= rate.floors[1]) return rate;
    }
    return SPAWN_RATES[SPAWN_RATES.length - 1];
}

// Floor themes
const FLOOR_THEMES = [
    {
        name: 'Sunken Crypt',
        floors: [1, 5],
        colors: { wall: '#2a2a3a', floor: '#1a1a28', accent: '#4a6a5a' },
        ambient: 'drip'
    },
    {
        name: 'Fungal Caverns',
        floors: [6, 10],
        colors: { wall: '#2a3a2a', floor: '#1a281a', accent: '#6aaa4a' },
        ambient: 'wind'
    },
    {
        name: 'Lava Depths',
        floors: [11, 15],
        colors: { wall: '#3a2020', floor: '#281818', accent: '#aa4a2a' },
        ambient: 'rumble'
    },
    {
        name: 'Frozen Abyss',
        floors: [16, 20],
        colors: { wall: '#202a3a', floor: '#182028', accent: '#4a8aaa' },
        ambient: 'wind'
    },
    {
        name: 'The Void',
        floors: [21, 25],
        colors: { wall: '#1a1020', floor: '#0a0818', accent: '#8a4aaa' },
        ambient: 'void'
    }
];

function getFloorTheme(floor) {
    for (const t of FLOOR_THEMES) {
        if (floor >= t.floors[0] && floor <= t.floors[1]) return t;
    }
    return FLOOR_THEMES[FLOOR_THEMES.length - 1];
}

// G = master game state, reset on new game
const G = {
    gameState: STATE.TITLE,
    difficulty: DIFFICULTY.NORMAL,
    difficultyLevel: 1,

    // Game entities
    player: null,
    enemies: [],
    projectiles: [],
    items: [],
    particles: [],
    lights: [],
    npcs: [],

    // Dungeon state
    currentFloor: 1,
    maxFloor: 25,
    dungeon: null,
    roomsCleared: 0,

    // Camera
    camera: { x: 0, y: 0, vx: 0, vy: 0 },

    // Time tracking
    time: 0,
    dt: 0,
    lastTime: 0,
    paused: false,
    frameCount: 0,

    // Active systems
    bossActive: null,
    dialogueQueue: [],
    floatingTexts: [],

    // Score tracking
    score: 0,
    kills: 0,
    highScore: 0,
    deepestFloor: 0,
    totalPlayTime: 0,

    // RNG seed
    seed: Date.now(),

    // Story progression
    storyChoices: [],
    flags: {},

    // Combo system
    combo: 0,
    comboTimer: 0,
    comboDecayRate: 1.5,
    maxCombo: 0,

    // Campfire checkpoint
    lastCampfire: null,

    // Run statistics
    runStats: {
        damageDealt: 0,
        damageTaken: 0,
        itemsFound: 0,
        enemiesKilled: 0,
        bossesKilled: 0,
        floorsCleared: 0,
        parries: 0,
        dodges: 0,
        healsUsed: 0,
        skillsUnlocked: 0,
        deathCount: 0
    }
};

// Item type enum
const ITEM_TYPE = {
    WEAPON: 'weapon',
    ARMOR: 'armor',
    CONSUMABLE: 'consumable',
    MATERIAL: 'material',
    KEY: 'key',
    RUNE: 'rune'
};

// Weapon subtypes
const WEAPON_TYPE = {
    SWORD: 'sword',
    AXE: 'axe',
    DAGGER: 'dagger',
    BOW: 'bow',
    STAFF: 'staff',
    SPEAR: 'spear'
};

// Status effects
const STATUS = {
    BURNING: { name: 'Burning', color: '#f44', dmgPerSec: 5 },
    FROZEN: { name: 'Frozen', color: '#4cf', slowPercent: 0.5 },
    SHOCKED: { name: 'Shocked', color: '#ff4', stunChance: 0.3 },
    POISONED: { name: 'Poisoned', color: '#8c4', dmgPerSec: 3 },
    BLEEDING: { name: 'Bleeding', color: '#c44', dmgPerSec: 8 },
    REGENERATING: { name: 'Regenerating', color: '#4c4', healPerSec: 5 },
    HASTE: { name: 'Haste', color: '#fc4', speedBonus: 0.3 },
    SHIELDED: { name: 'Shielded', color: '#48f', damageReduction: 0.5 }
};

// Collision layers
const LAYER = {
    FLOOR: 0,
    WALL: 1,
    PIT: 2,
    DOOR: 3,
    CHEST: 4,
    CAMPFIRE: 5,
    STAIRS: 6,
    ENEMY: 7,
    PLAYER: 8,
    PROJECTILE: 9,
    ITEM: 10,
    NPC: 11
};

// === core/utils.js ===
'use strict';

// =============================================================================
// UTILS.JS - Utility functions and helpers
// =============================================================================

const Util = {};

// =============================================================================
// RANDOM NUMBER GENERATION
// =============================================================================

// Seeded random using xorshift128
Util.seedState = { x: 123456789, y: 362436069, z: 521288629, w: 88675123 };

Util.seedRandom = function(seed) {
    if (seed === undefined) seed = Date.now();
    Util.seedState.x = seed || 123456789;
    Util.seedState.y = 362436069;
    Util.seedState.z = 521288629;
    Util.seedState.w = 88675123;

    return function() {
        const t = Util.seedState.x ^ (Util.seedState.x << 11);
        Util.seedState.x = Util.seedState.y;
        Util.seedState.y = Util.seedState.z;
        Util.seedState.z = Util.seedState.w;
        Util.seedState.w = Util.seedState.w ^ (Util.seedState.w >> 19) ^ (t ^ (t >> 8));
        return (Util.seedState.w >>> 0) / 4294967296;
    };
};

Util.randInt = function(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
};

Util.randFloat = function(min, max) {
    return Math.random() * (max - min) + min;
};

Util.pick = function(array) {
    return array[Math.floor(Math.random() * array.length)];
};

Util.shuffle = function(array) {
    const arr = array.slice();
    for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
};

Util.weightedPick = function(items, weights) {
    const total = weights.reduce((sum, w) => sum + w, 0);
    let rand = Math.random() * total;
    for (let i = 0; i < items.length; i++) {
        rand -= weights[i];
        if (rand <= 0) return items[i];
    }
    return items[items.length - 1];
};

// =============================================================================
// MATH UTILITIES
// =============================================================================

Util.clamp = function(val, min, max) {
    return Math.max(min, Math.min(max, val));
};

Util.lerp = function(a, b, t) {
    return a + (b - a) * t;
};

Util.lerpAngle = function(a, b, t) {
    const diff = ((b - a + Math.PI) % (Math.PI * 2)) - Math.PI;
    return a + diff * t;
};

Util.smoothStep = function(edge0, edge1, x) {
    const t = Util.clamp((x - edge0) / (edge1 - edge0), 0, 1);
    return t * t * (3 - 2 * t);
};

Util.map = function(value, inMin, inMax, outMin, outMax) {
    return outMin + (outMax - outMin) * ((value - inMin) / (inMax - inMin));
};

// =============================================================================
// EASING FUNCTIONS
// =============================================================================

Util.easeOutQuad = function(t) {
    return t * (2 - t);
};

Util.easeInQuad = function(t) {
    return t * t;
};

Util.easeInOutCubic = function(t) {
    return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
};

Util.easeOutElastic = function(t) {
    const c4 = (2 * Math.PI) / 3;
    return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
};

Util.easeOutBounce = function(t) {
    const n1 = 7.5625;
    const d1 = 2.75;
    if (t < 1 / d1) {
        return n1 * t * t;
    } else if (t < 2 / d1) {
        return n1 * (t -= 1.5 / d1) * t + 0.75;
    } else if (t < 2.5 / d1) {
        return n1 * (t -= 2.25 / d1) * t + 0.9375;
    } else {
        return n1 * (t -= 2.625 / d1) * t + 0.984375;
    }
};

// =============================================================================
// GEOMETRY & SPATIAL
// =============================================================================

Util.dist = function(x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    return Math.sqrt(dx * dx + dy * dy);
};

Util.distSq = function(x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    return dx * dx + dy * dy;
};

Util.angle = function(x1, y1, x2, y2) {
    return Math.atan2(y2 - y1, x2 - x1);
};

Util.pointInRect = function(px, py, rx, ry, rw, rh) {
    return px >= rx && px <= rx + rw && py >= ry && py <= ry + rh;
};

Util.rectsOverlap = function(a, b) {
    return !(a.x + a.w < b.x || b.x + b.w < a.x || a.y + a.h < b.y || b.y + b.h < a.y);
};

Util.circlesOverlap = function(x1, y1, r1, x2, y2, r2) {
    const distSq = Util.distSq(x1, y1, x2, y2);
    const radSum = r1 + r2;
    return distSq < radSum * radSum;
};

Util.lineIntersectsRect = function(x1, y1, x2, y2, rx, ry, rw, rh) {
    // Liang-Barsky algorithm
    const dx = x2 - x1;
    const dy = y2 - y1;
    let t0 = 0, t1 = 1;

    const clipT = (p, q) => {
        if (p === 0) return q >= 0;
        const r = q / p;
        if (p < 0) {
            if (r > t1) return false;
            if (r > t0) t0 = r;
        } else {
            if (r < t0) return false;
            if (r < t1) t1 = r;
        }
        return true;
    };

    if (!clipT(-dx, x1 - rx)) return false;
    if (!clipT(dx, rx + rw - x1)) return false;
    if (!clipT(-dy, y1 - ry)) return false;
    if (!clipT(dy, ry + rh - y1)) return false;

    return true;
};

// =============================================================================
// SMOOTH CAMERA FOLLOW (smoothDamp with delta time)
// =============================================================================

Util.smoothDamp = function(current, target, velocity, smoothTime, dt, maxSpeed = Infinity) {
    smoothTime = Math.max(0.0001, smoothTime);
    const omega = 2 / smoothTime;
    const x = omega * dt;
    const exp = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x);
    let change = current - target;
    const originalTo = target;
    const maxChange = maxSpeed * smoothTime;
    change = Util.clamp(change, -maxChange, maxChange);
    target = current - change;
    const temp = (velocity.val + omega * change) * dt;
    velocity.val = (velocity.val - omega * temp) * exp;
    let output = target + (change + temp) * exp;

    if ((originalTo - current > 0) === (output > originalTo)) {
        output = originalTo;
        velocity.val = (output - originalTo) / dt;
    }

    return output;
};

// =============================================================================
// COLOR UTILITIES
// =============================================================================

Util.hslToRgb = function(h, s, l) {
    h = h % 360;
    s = Util.clamp(s, 0, 1);
    l = Util.clamp(l, 0, 1);

    const c = (1 - Math.abs(2 * l - 1)) * s;
    const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
    const m = l - c / 2;

    let r = 0, g = 0, b = 0;

    if (h < 60) { r = c; g = x; b = 0; }
    else if (h < 120) { r = x; g = c; b = 0; }
    else if (h < 180) { r = 0; g = c; b = x; }
    else if (h < 240) { r = 0; g = x; b = c; }
    else if (h < 300) { r = x; g = 0; b = c; }
    else { r = c; g = 0; b = x; }

    return [
        Math.round((r + m) * 255),
        Math.round((g + m) * 255),
        Math.round((b + m) * 255)
    ];
};

Util.rgba = function(r, g, b, a = 1) {
    return `rgba(${r},${g},${b},${a})`;
};

Util.hexToRgb = function(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : null;
};

Util.lerpColor = function(color1, color2, t) {
    const c1 = Util.hexToRgb(color1);
    const c2 = Util.hexToRgb(color2);
    if (!c1 || !c2) return color1;

    const r = Math.round(Util.lerp(c1.r, c2.r, t));
    const g = Math.round(Util.lerp(c1.g, c2.g, t));
    const b = Math.round(Util.lerp(c1.b, c2.b, t));

    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
};

// =============================================================================
// STRING & FORMATTING
// =============================================================================

Util.formatTime = function(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
};

Util.formatNumber = function(num) {
    if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
    if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
    return num.toString();
};

Util.capitalize = function(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
};

// =============================================================================
// MISC UTILITIES
// =============================================================================

Util.deepCopy = function(obj) {
    return JSON.parse(JSON.stringify(obj));
};

Util.debounce = function(func, wait) {
    let timeout;
    return function(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
    };
};

Util.uuid = function() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0;
        const v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
};

// === core/audio.js ===
'use strict';

// =============================================================================
// AUDIO.JS - Procedural audio system using Web Audio API
// =============================================================================

const SFX = {
    ctx: null,
    masterGain: null,
    compressor: null,
    volume: 0.6,
    sfxVolume: 0.8,
    musicVolume: 0.5,
    ambientSource: null,
    ambientGain: null,
    initialized: false
};

// =============================================================================
// INITIALIZATION
// =============================================================================

SFX.init = function() {
    if (SFX.initialized) return;

    try {
        // Support both standard and webkit AudioContext
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        SFX.ctx = new AudioContext();

        // Master gain node
        SFX.masterGain = SFX.ctx.createGain();
        SFX.masterGain.gain.value = SFX.volume;

        // Compressor to prevent clipping
        SFX.compressor = SFX.ctx.createDynamicsCompressor();
        SFX.compressor.threshold.value = -20;
        SFX.compressor.knee.value = 10;
        SFX.compressor.ratio.value = 12;
        SFX.compressor.attack.value = 0.003;
        SFX.compressor.release.value = 0.25;

        SFX.masterGain.connect(SFX.compressor);
        SFX.compressor.connect(SFX.ctx.destination);

        SFX.initialized = true;
        console.log('Audio system initialized');
    } catch (e) {
        console.warn('Web Audio API not supported:', e);
    }
};

SFX.resume = function() {
    if (SFX.ctx && SFX.ctx.state === 'suspended') {
        SFX.ctx.resume();
    }
};

SFX.setVolume = function(vol) {
    SFX.volume = Util.clamp(vol, 0, 1);
    if (SFX.masterGain) {
        SFX.masterGain.gain.value = SFX.volume;
    }
};

// =============================================================================
// CORE SOUND GENERATION
// =============================================================================

SFX.playSound = function(name) {
    if (!SFX.initialized || !SFX.ctx) return;
    SFX.resume();

    const soundFunc = SFX.sounds[name];
    if (soundFunc) {
        soundFunc();
    } else {
        console.warn('Sound not found:', name);
    }
};

SFX.playSFX = function(name) {
    SFX.playSound(name);
};

// =============================================================================
// SOUND EFFECT LIBRARY (30+ sounds)
// =============================================================================

SFX.sounds = {};

// --- WEAPON SOUNDS ---

SFX.sounds.sword_swing = function() {
    const now = SFX.ctx.currentTime;
    const osc = SFX.ctx.createOscillator();
    const gain = SFX.ctx.createGain();
    const filter = SFX.ctx.createBiquadFilter();

    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(200, now);
    osc.frequency.exponentialRampToValueAtTime(80, now + 0.1);

    filter.type = 'lowpass';
    filter.frequency.value = 600;

    gain.gain.setValueAtTime(0.3 * SFX.sfxVolume, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);

    osc.connect(filter);
    filter.connect(gain);
    gain.connect(SFX.masterGain);

    osc.start(now);
    osc.stop(now + 0.1);
};

SFX.sounds.sword_hit = function() {
    const now = SFX.ctx.currentTime;
    const osc = SFX.ctx.createOscillator();
    const gain = SFX.ctx.createGain();

    osc.type = 'square';
    osc.frequency.setValueAtTime(150, now);
    osc.frequency.exponentialRampToValueAtTime(50, now + 0.15);

    gain.gain.setValueAtTime(0.4 * SFX.sfxVolume, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

    osc.connect(gain);
    gain.connect(SFX.masterGain);

    osc.start(now);
    osc.stop(now + 0.15);
};

SFX.sounds.axe_hit = function() {
    const now = SFX.ctx.currentTime;
    const osc = SFX.ctx.createOscillator();
    const gain = SFX.ctx.createGain();
    const filter = SFX.ctx.createBiquadFilter();

    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(100, now);
    osc.frequency.exponentialRampToValueAtTime(30, now + 0.2);

    filter.type = 'lowpass';
    filter.frequency.value = 400;

    gain.gain.setValueAtTime(0.5 * SFX.sfxVolume, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);

    osc.connect(filter);
    filter.connect(gain);
    gain.connect(SFX.masterGain);

    osc.start(now);
    osc.stop(now + 0.2);
};

SFX.sounds.bow_shot = function() {
    const now = SFX.ctx.currentTime;
    const osc = SFX.ctx.createOscillator();
    const gain = SFX.ctx.createGain();

    osc.type = 'sine';
    osc.frequency.setValueAtTime(800, now);
    osc.frequency.exponentialRampToValueAtTime(200, now + 0.08);

    gain.gain.setValueAtTime(0.2 * SFX.sfxVolume, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);

    osc.connect(gain);
    gain.connect(SFX.masterGain);

    osc.start(now);
    osc.stop(now + 0.08);
};

SFX.sounds.arrow_hit = function() {
    const now = SFX.ctx.currentTime;
    const osc = SFX.ctx.createOscillator();
    const gain = SFX.ctx.createGain();

    osc.type = 'triangle';
    osc.frequency.setValueAtTime(600, now);
    osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);

    gain.gain.setValueAtTime(0.25 * SFX.sfxVolume, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);

    osc.connect(gain);
    gain.connect(SFX.masterGain);

    osc.start(now);
    osc.stop(now + 0.1);
};

// --- SPELL SOUNDS ---

SFX.sounds.fireball_cast = function() {
    const now = SFX.ctx.currentTime;
    const osc1 = SFX.ctx.createOscillator();
    const osc2 = SFX.ctx.createOscillator();
    const gain = SFX.ctx.createGain();

    osc1.type = 'triangle';
    osc1.frequency.setValueAtTime(300, now);
    osc1.frequency.exponentialRampToValueAtTime(600, now + 0.2);

    osc2.type = 'sawtooth';
    osc2.frequency.setValueAtTime(150, now);
    osc2.frequency.exponentialRampToValueAtTime(300, now + 0.2);

    gain.gain.setValueAtTime(0.3 * SFX.sfxVolume, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);

    osc1.connect(gain);
    osc2.connect(gain);
    gain.connect(SFX.masterGain);

    osc1.start(now);
    osc2.start(now);
    osc1.stop(now + 0.2);
    osc2.stop(now + 0.2);
};

SFX.sounds.fireball_explode = function() {
    const now = SFX.ctx.currentTime;
    const osc = SFX.ctx.createOscillator();
    const gain = SFX.ctx.createGain();
    const filter = SFX.ctx.createBiquadFilter();

    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(200, now);
    osc.frequency.exponentialRampToValueAtTime(40, now + 0.3);

    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(2000, now);
    filter.frequency.exponentialRampToValueAtTime(200, now + 0.3);

    gain.gain.setValueAtTime(0.5 * SFX.sfxVolume, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);

    osc.connect(filter);
    filter.connect(gain);
    gain.connect(SFX.masterGain);

    osc.start(now);
    osc.stop(now + 0.3);
};

SFX.sounds.ice_spell = function() {
    const now = SFX.ctx.currentTime;
    const osc = SFX.ctx.createOscillator();
    const gain = SFX.ctx.createGain();
    const filter = SFX.ctx.createBiquadFilter();

    osc.type = 'sine';
    osc.frequency.setValueAtTime(1200, now);
    osc.frequency.exponentialRampToValueAtTime(400, now + 0.25);

    filter.type = 'highpass';
    filter.frequency.value = 800;

    gain.gain.setValueAtTime(0.25 * SFX.sfxVolume, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);

    osc.connect(filter);
    filter.connect(gain);
    gain.connect(SFX.masterGain);

    osc.start(now);
    osc.stop(now + 0.25);
};

SFX.sounds.lightning_spell = function() {
    const now = SFX.ctx.currentTime;
    const osc = SFX.ctx.createOscillator();
    const gain = SFX.ctx.createGain();

    osc.type = 'square';
    osc.frequency.setValueAtTime(2000, now);
    osc.frequency.exponentialRampToValueAtTime(100, now + 0.12);

    gain.gain.setValueAtTime(0.35 * SFX.sfxVolume, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);

    osc.connect(gain);
    gain.connect(SFX.masterGain);

    osc.start(now);
    osc.stop(now + 0.12);
};

SFX.sounds.poison_cloud = function() {
    const now = SFX.ctx.currentTime;
    const osc = SFX.ctx.createOscillator();
    const gain = SFX.ctx.createGain();
    const filter = SFX.ctx.createBiquadFilter();

    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(80, now);
    osc.frequency.exponentialRampToValueAtTime(120, now + 0.4);

    filter.type = 'bandpass';
    filter.frequency.value = 400;

    gain.gain.setValueAtTime(0.2 * SFX.sfxVolume, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);

    osc.connect(filter);
    filter.connect(gain);
    gain.connect(SFX.masterGain);

    osc.start(now);
    osc.stop(now + 0.4);
};

// --- PLAYER ACTIONS ---

SFX.sounds.dodge_roll = function() {
    const now = SFX.ctx.currentTime;
    const osc = SFX.ctx.createOscillator();
    const gain = SFX.ctx.createGain();

    osc.type = 'triangle';
    osc.frequency.setValueAtTime(120, now);
    osc.frequency.exponentialRampToValueAtTime(60, now + 0.15);

    gain.gain.setValueAtTime(0.2 * SFX.sfxVolume, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

    osc.connect(gain);
    gain.connect(SFX.masterGain);

    osc.start(now);
    osc.stop(now + 0.15);
};

SFX.sounds.parry_success = function() {
    const now = SFX.ctx.currentTime;
    const osc = SFX.ctx.createOscillator();
    const gain = SFX.ctx.createGain();

    osc.type = 'sine';
    osc.frequency.setValueAtTime(800, now);
    osc.frequency.exponentialRampToValueAtTime(1200, now + 0.2);

    gain.gain.setValueAtTime(0.4 * SFX.sfxVolume, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);

    osc.connect(gain);
    gain.connect(SFX.masterGain);

    osc.start(now);
    osc.stop(now + 0.2);
};

SFX.sounds.shield_block = function() {
    const now = SFX.ctx.currentTime;
    const osc = SFX.ctx.createOscillator();
    const gain = SFX.ctx.createGain();

    osc.type = 'square';
    osc.frequency.setValueAtTime(180, now);
    osc.frequency.exponentialRampToValueAtTime(90, now + 0.18);

    gain.gain.setValueAtTime(0.35 * SFX.sfxVolume, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.18);

    osc.connect(gain);
    gain.connect(SFX.masterGain);

    osc.start(now);
    osc.stop(now + 0.18);
};

// --- PLAYER STATUS ---

SFX.sounds.player_hurt = function() {
    const now = SFX.ctx.currentTime;
    const osc = SFX.ctx.createOscillator();
    const gain = SFX.ctx.createGain();

    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(400, now);
    osc.frequency.exponentialRampToValueAtTime(150, now + 0.2);

    gain.gain.setValueAtTime(0.35 * SFX.sfxVolume, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);

    osc.connect(gain);
    gain.connect(SFX.masterGain);

    osc.start(now);
    osc.stop(now + 0.2);
};

SFX.sounds.player_death = function() {
    const now = SFX.ctx.currentTime;
    const osc = SFX.ctx.createOscillator();
    const gain = SFX.ctx.createGain();
    const filter = SFX.ctx.createBiquadFilter();

    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(300, now);
    osc.frequency.exponentialRampToValueAtTime(40, now + 1.0);

    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(1000, now);
    filter.frequency.exponentialRampToValueAtTime(100, now + 1.0);

    gain.gain.setValueAtTime(0.5 * SFX.sfxVolume, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 1.0);

    osc.connect(filter);
    filter.connect(gain);
    gain.connect(SFX.masterGain);

    osc.start(now);
    osc.stop(now + 1.0);
};

SFX.sounds.player_heal = function() {
    const now = SFX.ctx.currentTime;
    const osc = SFX.ctx.createOscillator();
    const gain = SFX.ctx.createGain();

    osc.type = 'sine';
    osc.frequency.setValueAtTime(400, now);
    osc.frequency.exponentialRampToValueAtTime(800, now + 0.3);

    gain.gain.setValueAtTime(0.25 * SFX.sfxVolume, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);

    osc.connect(gain);
    gain.connect(SFX.masterGain);

    osc.start(now);
    osc.stop(now + 0.3);
};

SFX.sounds.player_levelup = function() {
    const now = SFX.ctx.currentTime;
    const notes = [523.25, 659.25, 783.99]; // C5, E5, G5

    notes.forEach((freq, i) => {
        const osc = SFX.ctx.createOscillator();
        const gain = SFX.ctx.createGain();

        osc.type = 'sine';
        osc.frequency.value = freq;

        const startTime = now + i * 0.15;
        gain.gain.setValueAtTime(0.3 * SFX.sfxVolume, startTime);
        gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.4);

        osc.connect(gain);
        gain.connect(SFX.masterGain);

        osc.start(startTime);
        osc.stop(startTime + 0.4);
    });
};

// --- ENEMY SOUNDS ---

SFX.sounds.enemy_hurt = function() {
    const now = SFX.ctx.currentTime;
    const osc = SFX.ctx.createOscillator();
    const gain = SFX.ctx.createGain();

    osc.type = 'square';
    osc.frequency.setValueAtTime(250, now);
    osc.frequency.exponentialRampToValueAtTime(100, now + 0.15);

    gain.gain.setValueAtTime(0.25 * SFX.sfxVolume, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

    osc.connect(gain);
    gain.connect(SFX.masterGain);

    osc.start(now);
    osc.stop(now + 0.15);
};

SFX.sounds.enemy_death = function() {
    const now = SFX.ctx.currentTime;
    const osc = SFX.ctx.createOscillator();
    const gain = SFX.ctx.createGain();

    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(200, now);
    osc.frequency.exponentialRampToValueAtTime(30, now + 0.5);

    gain.gain.setValueAtTime(0.3 * SFX.sfxVolume, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);

    osc.connect(gain);
    gain.connect(SFX.masterGain);

    osc.start(now);
    osc.stop(now + 0.5);
};

SFX.sounds.enemy_alert = function() {
    const now = SFX.ctx.currentTime;
    const osc = SFX.ctx.createOscillator();
    const gain = SFX.ctx.createGain();

    osc.type = 'square';
    osc.frequency.setValueAtTime(300, now);
    osc.frequency.exponentialRampToValueAtTime(500, now + 0.1);

    gain.gain.setValueAtTime(0.2 * SFX.sfxVolume, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);

    osc.connect(gain);
    gain.connect(SFX.masterGain);

    osc.start(now);
    osc.stop(now + 0.1);
};

SFX.sounds.enemy_attack = function() {
    const now = SFX.ctx.currentTime;
    const osc = SFX.ctx.createOscillator();
    const gain = SFX.ctx.createGain();

    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(180, now);
    osc.frequency.exponentialRampToValueAtTime(90, now + 0.18);

    gain.gain.setValueAtTime(0.28 * SFX.sfxVolume, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.18);

    osc.connect(gain);
    gain.connect(SFX.masterGain);

    osc.start(now);
    osc.stop(now + 0.18);
};

// --- BOSS SOUNDS ---

SFX.sounds.boss_roar = function() {
    const now = SFX.ctx.currentTime;
    const osc = SFX.ctx.createOscillator();
    const gain = SFX.ctx.createGain();
    const filter = SFX.ctx.createBiquadFilter();

    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(80, now);
    osc.frequency.exponentialRampToValueAtTime(40, now + 0.8);

    filter.type = 'lowpass';
    filter.frequency.value = 300;

    gain.gain.setValueAtTime(0.6 * SFX.sfxVolume, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.8);

    osc.connect(filter);
    filter.connect(gain);
    gain.connect(SFX.masterGain);

    osc.start(now);
    osc.stop(now + 0.8);
};

SFX.sounds.boss_stomp = function() {
    const now = SFX.ctx.currentTime;
    const osc = SFX.ctx.createOscillator();
    const gain = SFX.ctx.createGain();

    osc.type = 'sine';
    osc.frequency.setValueAtTime(60, now);
    osc.frequency.exponentialRampToValueAtTime(30, now + 0.3);

    gain.gain.setValueAtTime(0.7 * SFX.sfxVolume, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);

    osc.connect(gain);
    gain.connect(SFX.masterGain);

    osc.start(now);
    osc.stop(now + 0.3);
};

SFX.sounds.boss_phase_change = function() {
    const now = SFX.ctx.currentTime;
    const osc = SFX.ctx.createOscillator();
    const gain = SFX.ctx.createGain();

    osc.type = 'square';
    osc.frequency.setValueAtTime(100, now);
    osc.frequency.exponentialRampToValueAtTime(400, now + 0.6);

    gain.gain.setValueAtTime(0.4 * SFX.sfxVolume, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.6);

    osc.connect(gain);
    gain.connect(SFX.masterGain);

    osc.start(now);
    osc.stop(now + 0.6);
};

// --- ITEM / UI SOUNDS ---

SFX.sounds.pickup_item = function() {
    const now = SFX.ctx.currentTime;
    const osc = SFX.ctx.createOscillator();
    const gain = SFX.ctx.createGain();

    osc.type = 'sine';
    osc.frequency.setValueAtTime(600, now);
    osc.frequency.exponentialRampToValueAtTime(900, now + 0.1);

    gain.gain.setValueAtTime(0.25 * SFX.sfxVolume, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);

    osc.connect(gain);
    gain.connect(SFX.masterGain);

    osc.start(now);
    osc.stop(now + 0.1);
};

SFX.sounds.equip_item = function() {
    const now = SFX.ctx.currentTime;
    const osc = SFX.ctx.createOscillator();
    const gain = SFX.ctx.createGain();

    osc.type = 'triangle';
    osc.frequency.value = 440;

    gain.gain.setValueAtTime(0.2 * SFX.sfxVolume, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);

    osc.connect(gain);
    gain.connect(SFX.masterGain);

    osc.start(now);
    osc.stop(now + 0.12);
};

SFX.sounds.craft_success = function() {
    const now = SFX.ctx.currentTime;
    const notes = [523.25, 698.46]; // C5, F5

    notes.forEach((freq, i) => {
        const osc = SFX.ctx.createOscillator();
        const gain = SFX.ctx.createGain();

        osc.type = 'sine';
        osc.frequency.value = freq;

        const startTime = now + i * 0.1;
        gain.gain.setValueAtTime(0.25 * SFX.sfxVolume, startTime);
        gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.2);

        osc.connect(gain);
        gain.connect(SFX.masterGain);

        osc.start(startTime);
        osc.stop(startTime + 0.2);
    });
};

SFX.sounds.menu_select = function() {
    const now = SFX.ctx.currentTime;
    const osc = SFX.ctx.createOscillator();
    const gain = SFX.ctx.createGain();

    osc.type = 'sine';
    osc.frequency.value = 440;

    gain.gain.setValueAtTime(0.15 * SFX.sfxVolume, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);

    osc.connect(gain);
    gain.connect(SFX.masterGain);

    osc.start(now);
    osc.stop(now + 0.08);
};

SFX.sounds.menu_back = function() {
    const now = SFX.ctx.currentTime;
    const osc = SFX.ctx.createOscillator();
    const gain = SFX.ctx.createGain();

    osc.type = 'sine';
    osc.frequency.value = 330;

    gain.gain.setValueAtTime(0.15 * SFX.sfxVolume, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);

    osc.connect(gain);
    gain.connect(SFX.masterGain);

    osc.start(now);
    osc.stop(now + 0.08);
};

// --- WORLD SOUNDS ---

SFX.sounds.door_open = function() {
    const now = SFX.ctx.currentTime;
    const osc = SFX.ctx.createOscillator();
    const gain = SFX.ctx.createGain();

    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(150, now);
    osc.frequency.exponentialRampToValueAtTime(100, now + 0.3);

    gain.gain.setValueAtTime(0.25 * SFX.sfxVolume, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);

    osc.connect(gain);
    gain.connect(SFX.masterGain);

    osc.start(now);
    osc.stop(now + 0.3);
};

SFX.sounds.chest_open = function() {
    const now = SFX.ctx.currentTime;
    const osc = SFX.ctx.createOscillator();
    const gain = SFX.ctx.createGain();

    osc.type = 'triangle';
    osc.frequency.setValueAtTime(200, now);
    osc.frequency.exponentialRampToValueAtTime(400, now + 0.25);

    gain.gain.setValueAtTime(0.3 * SFX.sfxVolume, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);

    osc.connect(gain);
    gain.connect(SFX.masterGain);

    osc.start(now);
    osc.stop(now + 0.25);
};

SFX.sounds.campfire_rest = function() {
    const now = SFX.ctx.currentTime;
    const osc = SFX.ctx.createOscillator();
    const gain = SFX.ctx.createGain();

    osc.type = 'sine';
    osc.frequency.value = 220;

    gain.gain.setValueAtTime(0.2 * SFX.sfxVolume, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);

    osc.connect(gain);
    gain.connect(SFX.masterGain);

    osc.start(now);
    osc.stop(now + 0.5);
};

// --- COMBO / SPECIAL ---

SFX.sounds.combo_hit = function() {
    const now = SFX.ctx.currentTime;
    const osc = SFX.ctx.createOscillator();
    const gain = SFX.ctx.createGain();

    osc.type = 'sine';
    osc.frequency.setValueAtTime(500, now);
    osc.frequency.exponentialRampToValueAtTime(800, now + 0.12);

    gain.gain.setValueAtTime(0.3 * SFX.sfxVolume, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);

    osc.connect(gain);
    gain.connect(SFX.masterGain);

    osc.start(now);
    osc.stop(now + 0.12);
};

SFX.sounds.critical_hit = function() {
    const now = SFX.ctx.currentTime;
    const osc = SFX.ctx.createOscillator();
    const gain = SFX.ctx.createGain();

    osc.type = 'square';
    osc.frequency.setValueAtTime(1000, now);
    osc.frequency.exponentialRampToValueAtTime(500, now + 0.2);

    gain.gain.setValueAtTime(0.4 * SFX.sfxVolume, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);

    osc.connect(gain);
    gain.connect(SFX.masterGain);

    osc.start(now);
    osc.stop(now + 0.2);
};

// =============================================================================
// AMBIENT AUDIO
// =============================================================================

SFX.playAmbient = function(theme) {
    SFX.stopAmbient();

    if (!SFX.ctx) return;

    const now = SFX.ctx.currentTime;
    const osc = SFX.ctx.createOscillator();
    const gain = SFX.ctx.createGain();

    SFX.ambientGain = gain;
    gain.gain.value = 0.1 * SFX.musicVolume;

    // Theme-based frequencies
    const themeFreqs = {
        drip: 60,
        wind: 80,
        rumble: 40,
        void: 30
    };

    osc.type = 'sine';
    osc.frequency.value = themeFreqs[theme] || 60;

    osc.connect(gain);
    gain.connect(SFX.masterGain);

    osc.start(now);
    SFX.ambientSource = osc;
};

SFX.stopAmbient = function() {
    if (SFX.ambientSource) {
        SFX.ambientSource.stop();
        SFX.ambientSource = null;
    }
};

// === core/input.js ===
'use strict';

// =============================================================================
// INPUT.JS - Unified input system (keyboard, mouse, touch, gamepad)
// =============================================================================

const Input = {
    keys: {},
    prevKeys: {},
    mouse: { x: 0, y: 0, down: false, justDown: false, button: 0 },
    prevMouse: { down: false },
    touch: { active: false, x: 0, y: 0, dx: 0, dy: 0, startX: 0, startY: 0, id: null },
    gamepad: { connected: false, axes: [0, 0, 0, 0], buttons: [] },
    canvas: null,
    initialized: false
};

// =============================================================================
// INITIALIZATION
// =============================================================================

Input.init = function(canvas) {
    if (Input.initialized) return;

    Input.canvas = canvas;

    // Keyboard events
    window.addEventListener('keydown', Input.onKeyDown, false);
    window.addEventListener('keyup', Input.onKeyUp, false);

    // Mouse events
    canvas.addEventListener('mousedown', Input.onMouseDown, false);
    canvas.addEventListener('mouseup', Input.onMouseUp, false);
    canvas.addEventListener('mousemove', Input.onMouseMove, false);
    canvas.addEventListener('contextmenu', e => e.preventDefault(), false);

    // Touch events
    canvas.addEventListener('touchstart', Input.onTouchStart, false);
    canvas.addEventListener('touchmove', Input.onTouchMove, false);
    canvas.addEventListener('touchend', Input.onTouchEnd, false);
    canvas.addEventListener('touchcancel', Input.onTouchEnd, false);

    // Gamepad events
    window.addEventListener('gamepadconnected', Input.onGamepadConnected, false);
    window.addEventListener('gamepaddisconnected', Input.onGamepadDisconnected, false);

    Input.initialized = true;
    console.log('Input system initialized');
};

// =============================================================================
// KEYBOARD HANDLERS
// =============================================================================

Input.onKeyDown = function(e) {
    const key = e.key.toLowerCase();
    Input.keys[key] = true;

    // Prevent default for game keys
    const preventKeys = ['arrowup', 'arrowdown', 'arrowleft', 'arrowright', ' ', 'w', 'a', 's', 'd'];
    if (preventKeys.includes(key)) {
        e.preventDefault();
    }
};

Input.onKeyUp = function(e) {
    const key = e.key.toLowerCase();
    Input.keys[key] = false;
};

Input.isKeyPressed = function(key) {
    return Input.keys[key.toLowerCase()] || false;
};

Input.justPressed = function(key) {
    key = key.toLowerCase();
    return Input.keys[key] && !Input.prevKeys[key];
};

Input.justReleased = function(key) {
    key = key.toLowerCase();
    return !Input.keys[key] && Input.prevKeys[key];
};

// =============================================================================
// MOUSE HANDLERS
// =============================================================================

Input.onMouseDown = function(e) {
    Input.mouse.down = true;
    Input.mouse.button = e.button;
    Input.updateMousePosition(e);
};

Input.onMouseUp = function(e) {
    Input.mouse.down = false;
};

Input.onMouseMove = function(e) {
    Input.updateMousePosition(e);
};

Input.updateMousePosition = function(e) {
    const rect = Input.canvas.getBoundingClientRect();
    const scaleX = Input.canvas.width / rect.width;
    const scaleY = Input.canvas.height / rect.height;

    Input.mouse.x = (e.clientX - rect.left) * scaleX;
    Input.mouse.y = (e.clientY - rect.top) * scaleY;
};

// =============================================================================
// TOUCH HANDLERS
// =============================================================================

Input.onTouchStart = function(e) {
    e.preventDefault();

    if (e.touches.length > 0) {
        const touch = e.touches[0];
        Input.touch.active = true;
        Input.touch.id = touch.identifier;

        const rect = Input.canvas.getBoundingClientRect();
        const scaleX = Input.canvas.width / rect.width;
        const scaleY = Input.canvas.height / rect.height;

        Input.touch.x = (touch.clientX - rect.left) * scaleX;
        Input.touch.y = (touch.clientY - rect.top) * scaleY;
        Input.touch.startX = Input.touch.x;
        Input.touch.startY = Input.touch.y;
        Input.touch.dx = 0;
        Input.touch.dy = 0;
    }
};

Input.onTouchMove = function(e) {
    e.preventDefault();

    if (!Input.touch.active) return;

    for (let i = 0; i < e.touches.length; i++) {
        const touch = e.touches[i];
        if (touch.identifier === Input.touch.id) {
            const rect = Input.canvas.getBoundingClientRect();
            const scaleX = Input.canvas.width / rect.width;
            const scaleY = Input.canvas.height / rect.height;

            const newX = (touch.clientX - rect.left) * scaleX;
            const newY = (touch.clientY - rect.top) * scaleY;

            Input.touch.dx = newX - Input.touch.x;
            Input.touch.dy = newY - Input.touch.y;
            Input.touch.x = newX;
            Input.touch.y = newY;
            break;
        }
    }
};

Input.onTouchEnd = function(e) {
    e.preventDefault();

    // Check if our tracked touch ended
    let touchEnded = true;
    for (let i = 0; i < e.touches.length; i++) {
        if (e.touches[i].identifier === Input.touch.id) {
            touchEnded = false;
            break;
        }
    }

    if (touchEnded) {
        Input.touch.active = false;
        Input.touch.dx = 0;
        Input.touch.dy = 0;
        Input.touch.id = null;
    }
};

// =============================================================================
// GAMEPAD HANDLERS
// =============================================================================

Input.onGamepadConnected = function(e) {
    console.log('Gamepad connected:', e.gamepad.id);
    Input.gamepad.connected = true;
};

Input.onGamepadDisconnected = function(e) {
    console.log('Gamepad disconnected');
    Input.gamepad.connected = false;
};

Input.pollGamepad = function() {
    const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];

    for (let i = 0; i < gamepads.length; i++) {
        const gp = gamepads[i];
        if (gp && gp.connected) {
            Input.gamepad.connected = true;
            Input.gamepad.axes = Array.from(gp.axes);
            Input.gamepad.buttons = gp.buttons.map(b => ({
                pressed: b.pressed,
                value: b.value
            }));
            return;
        }
    }

    Input.gamepad.connected = false;
};

// =============================================================================
// UNIFIED INPUT QUERIES
// =============================================================================

Input.getMovement = function() {
    let dx = 0;
    let dy = 0;

    // Keyboard - WASD
    if (Input.isKeyPressed('w') || Input.isKeyPressed('arrowup')) dy -= 1;
    if (Input.isKeyPressed('s') || Input.isKeyPressed('arrowdown')) dy += 1;
    if (Input.isKeyPressed('a') || Input.isKeyPressed('arrowleft')) dx -= 1;
    if (Input.isKeyPressed('d') || Input.isKeyPressed('arrowright')) dx += 1;

    // Gamepad left stick
    if (Input.gamepad.connected && Input.gamepad.axes.length >= 2) {
        const deadzone = 0.15;
        const axisX = Math.abs(Input.gamepad.axes[0]) > deadzone ? Input.gamepad.axes[0] : 0;
        const axisY = Math.abs(Input.gamepad.axes[1]) > deadzone ? Input.gamepad.axes[1] : 0;

        dx += axisX;
        dy += axisY;
    }

    // Touch virtual d-pad (bottom-left quadrant)
    if (Input.touch.active && Input.canvas) {
        const touchInDPad = Input.getTouchDPad();
        if (touchInDPad) {
            dx += touchInDPad.dx;
            dy += touchInDPad.dy;
        }
    }

    // Normalize diagonal movement
    const mag = Math.sqrt(dx * dx + dy * dy);
    if (mag > 1) {
        dx /= mag;
        dy /= mag;
    }

    return { dx, dy };
};

Input.getTouchDPad = function() {
    if (!Input.touch.active || !Input.canvas) return null;

    const canvasWidth = Input.canvas.width;
    const canvasHeight = Input.canvas.height;

    // D-pad area: bottom-left quarter
    const dpadSize = Math.min(canvasWidth, canvasHeight) * 0.3;
    const dpadCenterX = dpadSize * 0.5;
    const dpadCenterY = canvasHeight - dpadSize * 0.5;

    const distX = Input.touch.x - dpadCenterX;
    const distY = Input.touch.y - dpadCenterY;
    const dist = Math.sqrt(distX * distX + distY * distY);

    // Check if touch is in d-pad area
    if (dist > dpadSize * 0.6) return null;

    // Calculate direction
    const angle = Math.atan2(distY, distX);
    const dx = Math.cos(angle);
    const dy = Math.sin(angle);

    return { dx, dy };
};

Input.getAim = function() {
    // Mouse aim (world space requires camera offset, handled by caller)
    if (Input.mouse.x !== 0 || Input.mouse.y !== 0) {
        return { x: Input.mouse.x, y: Input.mouse.y, type: 'mouse' };
    }

    // Gamepad right stick
    if (Input.gamepad.connected && Input.gamepad.axes.length >= 4) {
        const deadzone = 0.2;
        const axisX = Math.abs(Input.gamepad.axes[2]) > deadzone ? Input.gamepad.axes[2] : 0;
        const axisY = Math.abs(Input.gamepad.axes[3]) > deadzone ? Input.gamepad.axes[3] : 0;

        if (axisX !== 0 || axisY !== 0) {
            return { x: axisX, y: axisY, type: 'gamepad' };
        }
    }

    // Touch aim (right side of screen)
    if (Input.touch.active && Input.canvas) {
        const canvasWidth = Input.canvas.width;
        if (Input.touch.x > canvasWidth * 0.5) {
            return { x: Input.touch.x, y: Input.touch.y, type: 'touch' };
        }
    }

    return null;
};

// Action buttons (space, shift, buttons)
Input.isActionPressed = function(action) {
    switch (action) {
        case 'attack':
            return Input.isKeyPressed(' ') || Input.isKeyPressed('j') ||
                   Input.mouse.down ||
                   (Input.gamepad.connected && Input.gamepad.buttons[0] && Input.gamepad.buttons[0].pressed) ||
                   Input.getTouchActionButton('attack');

        case 'dodge':
            return Input.isKeyPressed('shift') || Input.isKeyPressed('k') ||
                   (Input.gamepad.connected && Input.gamepad.buttons[1] && Input.gamepad.buttons[1].pressed) ||
                   Input.getTouchActionButton('dodge');

        case 'interact':
            return Input.isKeyPressed('e') || Input.isKeyPressed('enter') ||
                   (Input.gamepad.connected && Input.gamepad.buttons[2] && Input.gamepad.buttons[2].pressed) ||
                   Input.getTouchActionButton('interact');

        case 'inventory':
            return Input.justPressed('i') || Input.justPressed('tab') ||
                   (Input.gamepad.connected && Input.gamepad.buttons[9] && Input.gamepad.buttons[9].pressed);

        case 'pause':
            return Input.justPressed('escape') || Input.justPressed('p') ||
                   (Input.gamepad.connected && Input.gamepad.buttons[9] && Input.gamepad.buttons[9].pressed);

        default:
            return false;
    }
};

Input.getTouchActionButton = function(action) {
    if (!Input.touch.active || !Input.canvas) return false;

    const canvasWidth = Input.canvas.width;
    const canvasHeight = Input.canvas.height;

    // Action buttons: bottom-right corner
    const buttonSize = Math.min(canvasWidth, canvasHeight) * 0.12;
    const buttonSpacing = buttonSize * 1.3;

    const buttons = {
        attack: { x: canvasWidth - buttonSize * 1.5, y: canvasHeight - buttonSize * 1.5 },
        dodge: { x: canvasWidth - buttonSize * 1.5 - buttonSpacing, y: canvasHeight - buttonSize * 1.5 },
        interact: { x: canvasWidth - buttonSize * 1.5, y: canvasHeight - buttonSize * 1.5 - buttonSpacing }
    };

    const btn = buttons[action];
    if (!btn) return false;

    const dx = Input.touch.x - btn.x;
    const dy = Input.touch.y - btn.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    return dist < buttonSize;
};

// =============================================================================
// UPDATE (called each frame)
// =============================================================================

Input.update = function() {
    // Update previous key states
    Input.prevKeys = {};
    for (const key in Input.keys) {
        Input.prevKeys[key] = Input.keys[key];
    }

    // Update previous mouse state
    Input.prevMouse.down = Input.mouse.down;
    Input.mouse.justDown = Input.mouse.down && !Input.prevMouse.down;

    // Poll gamepad
    if (navigator.getGamepads) {
        Input.pollGamepad();
    }

    // Reset touch delta if not moving
    if (Input.touch.active) {
        Input.touch.dx *= 0.8;
        Input.touch.dy *= 0.8;
    }
};

// =============================================================================
// UTILITIES
// =============================================================================

Input.clearAll = function() {
    Input.keys = {};
    Input.prevKeys = {};
    Input.mouse.down = false;
    Input.mouse.justDown = false;
    Input.touch.active = false;
};

Input.isAnyKeyPressed = function() {
    for (const key in Input.keys) {
        if (Input.keys[key]) return true;
    }
    return Input.mouse.down || Input.touch.active || (Input.gamepad.connected && Input.gamepad.buttons.some(b => b.pressed));
};

// === core/save.js ===
'use strict';

// =============================================================================
// SAVE.JS - Save/load system using localStorage
// =============================================================================

const Save = {
    SLOT_KEY: 'depths_save',
    SETTINGS_KEY: 'depths_settings',
    HIGHSCORE_KEY: 'depths_highscore',
    CAMPFIRE_KEY: 'depths_campfire'
};

// =============================================================================
// GAME SAVE/LOAD
// =============================================================================

Save.saveGame = function() {
    if (!G || !G.player) {
        console.warn('Cannot save: game state not initialized');
        return false;
    }

    try {
        const saveData = {
            version: '1.0.0',
            timestamp: Date.now(),
            gameState: G.gameState,
            difficulty: G.difficulty,
            difficultyLevel: G.difficultyLevel,
            currentFloor: G.currentFloor,
            seed: G.seed,
            time: G.time,
            totalPlayTime: G.totalPlayTime,
            score: G.score,
            kills: G.kills,

            player: {
                x: G.player.x,
                y: G.player.y,
                hp: G.player.hp,
                maxHp: G.player.maxHp,
                mana: G.player.mana,
                maxMana: G.player.maxMana,
                stamina: G.player.stamina,
                maxStamina: G.player.maxStamina,
                level: G.player.level,
                xp: G.player.xp,
                xpToLevel: G.player.xpToLevel,
                attackDmg: G.player.attackDmg,
                defense: G.player.defense,
                speed: G.player.speed,
                inventory: G.player.inventory || [],
                equipment: G.player.equipment || {},
                skills: G.player.skills || [],
                unlockedSkills: G.player.unlockedSkills || [],
                gold: G.player.gold || 0
            },

            storyChoices: G.storyChoices,
            flags: G.flags,
            runStats: G.runStats,
            lastCampfire: G.lastCampfire
        };

        localStorage.setItem(Save.SLOT_KEY, JSON.stringify(saveData));
        console.log('Game saved successfully');
        return true;
    } catch (e) {
        console.error('Failed to save game:', e);
        return false;
    }
};

Save.loadGame = function() {
    try {
        const saveJson = localStorage.getItem(Save.SLOT_KEY);
        if (!saveJson) {
            console.log('No save data found');
            return null;
        }

        const saveData = JSON.parse(saveJson);

        // Restore game state
        G.gameState = saveData.gameState || STATE.TITLE;
        G.difficulty = saveData.difficulty || DIFFICULTY.NORMAL;
        G.difficultyLevel = saveData.difficultyLevel || 1;
        G.currentFloor = saveData.currentFloor || 1;
        G.seed = saveData.seed || Date.now();
        G.time = saveData.time || 0;
        G.totalPlayTime = saveData.totalPlayTime || 0;
        G.score = saveData.score || 0;
        G.kills = saveData.kills || 0;
        G.storyChoices = saveData.storyChoices || [];
        G.flags = saveData.flags || {};
        G.runStats = saveData.runStats || {};
        G.lastCampfire = saveData.lastCampfire || null;

        // Restore player (Note: actual Player object creation handled by game init)
        const playerData = saveData.player;

        console.log('Game loaded successfully from', new Date(saveData.timestamp));
        return playerData;
    } catch (e) {
        console.error('Failed to load game:', e);
        return null;
    }
};

Save.hasSave = function() {
    return localStorage.getItem(Save.SLOT_KEY) !== null;
};

Save.deleteSave = function() {
    try {
        localStorage.removeItem(Save.SLOT_KEY);
        localStorage.removeItem(Save.CAMPFIRE_KEY);
        console.log('Save deleted');
        return true;
    } catch (e) {
        console.error('Failed to delete save:', e);
        return false;
    }
};

// =============================================================================
// HIGH SCORE / STATS
// =============================================================================

Save.saveHighScore = function(score, floor) {
    try {
        const current = Save.loadHighScore();

        const newData = {
            highScore: Math.max(current.highScore, score),
            deepestFloor: Math.max(current.deepestFloor, floor),
            lastUpdated: Date.now()
        };

        localStorage.setItem(Save.HIGHSCORE_KEY, JSON.stringify(newData));
        G.highScore = newData.highScore;
        G.deepestFloor = newData.deepestFloor;

        console.log('High score saved:', newData);
        return true;
    } catch (e) {
        console.error('Failed to save high score:', e);
        return false;
    }
};

Save.loadHighScore = function() {
    try {
        const json = localStorage.getItem(Save.HIGHSCORE_KEY);
        if (!json) {
            return { highScore: 0, deepestFloor: 0, lastUpdated: null };
        }

        const data = JSON.parse(json);
        return {
            highScore: data.highScore || 0,
            deepestFloor: data.deepestFloor || 0,
            lastUpdated: data.lastUpdated || null
        };
    } catch (e) {
        console.error('Failed to load high score:', e);
        return { highScore: 0, deepestFloor: 0, lastUpdated: null };
    }
};

// =============================================================================
// SETTINGS
// =============================================================================

Save.saveSettings = function(settings) {
    try {
        const data = {
            volume: settings.volume !== undefined ? settings.volume : 0.6,
            sfxVolume: settings.sfxVolume !== undefined ? settings.sfxVolume : 0.8,
            musicVolume: settings.musicVolume !== undefined ? settings.musicVolume : 0.5,
            difficulty: settings.difficulty || DIFFICULTY.NORMAL,
            controlScheme: settings.controlScheme || 'default',
            showFPS: settings.showFPS !== undefined ? settings.showFPS : false,
            screenShake: settings.screenShake !== undefined ? settings.screenShake : true,
            particles: settings.particles !== undefined ? settings.particles : true
        };

        localStorage.setItem(Save.SETTINGS_KEY, JSON.stringify(data));
        console.log('Settings saved');
        return true;
    } catch (e) {
        console.error('Failed to save settings:', e);
        return false;
    }
};

Save.loadSettings = function() {
    try {
        const json = localStorage.getItem(Save.SETTINGS_KEY);
        if (!json) {
            return {
                volume: 0.6,
                sfxVolume: 0.8,
                musicVolume: 0.5,
                difficulty: DIFFICULTY.NORMAL,
                controlScheme: 'default',
                showFPS: false,
                screenShake: true,
                particles: true
            };
        }

        return JSON.parse(json);
    } catch (e) {
        console.error('Failed to load settings:', e);
        return {};
    }
};

// =============================================================================
// CAMPFIRE CHECKPOINT SAVE
// =============================================================================

Save.saveCampfire = function() {
    if (!G || !G.player) {
        console.warn('Cannot save campfire: game state not initialized');
        return false;
    }

    try {
        const campfireData = {
            timestamp: Date.now(),
            floor: G.currentFloor,
            playerHp: G.player.hp,
            playerMaxHp: G.player.maxHp,
            playerMana: G.player.mana,
            playerMaxMana: G.player.maxMana,
            playerLevel: G.player.level,
            playerXp: G.player.xp,
            inventory: G.player.inventory || [],
            equipment: G.player.equipment || {},
            gold: G.player.gold || 0,
            flags: G.flags,
            storyChoices: G.storyChoices
        };

        localStorage.setItem(Save.CAMPFIRE_KEY, JSON.stringify(campfireData));
        G.lastCampfire = campfireData;

        console.log('Campfire checkpoint saved');
        return true;
    } catch (e) {
        console.error('Failed to save campfire:', e);
        return false;
    }
};

Save.loadCampfire = function() {
    try {
        const json = localStorage.getItem(Save.CAMPFIRE_KEY);
        if (!json) {
            console.log('No campfire save found');
            return null;
        }

        const data = JSON.parse(json);
        console.log('Campfire checkpoint loaded from floor', data.floor);
        return data;
    } catch (e) {
        console.error('Failed to load campfire:', e);
        return null;
    }
};

Save.hasCampfire = function() {
    return localStorage.getItem(Save.CAMPFIRE_KEY) !== null;
};

Save.deleteCampfire = function() {
    try {
        localStorage.removeItem(Save.CAMPFIRE_KEY);
        G.lastCampfire = null;
        return true;
    } catch (e) {
        console.error('Failed to delete campfire:', e);
        return false;
    }
};

// =============================================================================
// RESET / NEW GAME
// =============================================================================

Save.resetGame = function() {
    console.log('Resetting game to new game state');

    // Clear game state
    G.gameState = STATE.TITLE;
    G.currentFloor = 1;
    G.player = null;
    G.enemies = [];
    G.projectiles = [];
    G.items = [];
    G.particles = [];
    G.lights = [];
    G.npcs = [];
    G.dungeon = null;
    G.time = 0;
    G.dt = 0;
    G.frameCount = 0;
    G.bossActive = null;
    G.dialogueQueue = [];
    G.floatingTexts = [];
    G.score = 0;
    G.kills = 0;
    G.totalPlayTime = 0;
    G.seed = Date.now();
    G.storyChoices = [];
    G.flags = {};
    G.combo = 0;
    G.comboTimer = 0;
    G.lastCampfire = null;

    // Reset run stats
    G.runStats = {
        damageDealt: 0,
        damageTaken: 0,
        itemsFound: 0,
        enemiesKilled: 0,
        bossesKilled: 0,
        floorsCleared: 0,
        parries: 0,
        dodges: 0,
        healsUsed: 0,
        skillsUnlocked: 0,
        deathCount: 0
    };

    // Clear campfire but keep high scores
    Save.deleteCampfire();

    return true;
};

Save.newGame = function(difficulty) {
    Save.resetGame();
    G.difficulty = difficulty || DIFFICULTY.NORMAL;
    G.gameState = STATE.PLAYING;
    console.log('Starting new game on', G.difficulty, 'difficulty');
    return true;
};

Save.restart = function() {
    console.log('Restarting game');
    Save.resetGame();
    return true;
};

// =============================================================================
// IMPORT / EXPORT JSON
// =============================================================================

Save.exportJSON = function() {
    try {
        const exportData = {
            save: localStorage.getItem(Save.SLOT_KEY),
            settings: localStorage.getItem(Save.SETTINGS_KEY),
            highscore: localStorage.getItem(Save.HIGHSCORE_KEY),
            campfire: localStorage.getItem(Save.CAMPFIRE_KEY),
            exportDate: new Date().toISOString()
        };

        const json = JSON.stringify(exportData, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = 'depths-save-' + Date.now() + '.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        console.log('Save exported successfully');
        return true;
    } catch (e) {
        console.error('Failed to export save:', e);
        return false;
    }
};

Save.importJSON = function(jsonString) {
    try {
        const importData = JSON.parse(jsonString);

        if (importData.save) {
            localStorage.setItem(Save.SLOT_KEY, importData.save);
        }
        if (importData.settings) {
            localStorage.setItem(Save.SETTINGS_KEY, importData.settings);
        }
        if (importData.highscore) {
            localStorage.setItem(Save.HIGHSCORE_KEY, importData.highscore);
        }
        if (importData.campfire) {
            localStorage.setItem(Save.CAMPFIRE_KEY, importData.campfire);
        }

        console.log('Save imported successfully from', importData.exportDate);
        return true;
    } catch (e) {
        console.error('Failed to import save:', e);
        return false;
    }
};

// =============================================================================
// UTILITIES
// =============================================================================

Save.getSaveInfo = function() {
    try {
        const saveJson = localStorage.getItem(Save.SLOT_KEY);
        if (!saveJson) return null;

        const saveData = JSON.parse(saveJson);
        return {
            timestamp: saveData.timestamp,
            floor: saveData.currentFloor,
            difficulty: saveData.difficulty,
            playTime: saveData.totalPlayTime,
            score: saveData.score,
            playerLevel: saveData.player ? saveData.player.level : 1
        };
    } catch (e) {
        console.error('Failed to get save info:', e);
        return null;
    }
};

Save.clearAllData = function() {
    try {
        localStorage.removeItem(Save.SLOT_KEY);
        localStorage.removeItem(Save.SETTINGS_KEY);
        localStorage.removeItem(Save.HIGHSCORE_KEY);
        localStorage.removeItem(Save.CAMPFIRE_KEY);
        console.log('All save data cleared');
        return true;
    } catch (e) {
        console.error('Failed to clear data:', e);
        return false;
    }
};

// === data/items.js ===
// items.js - Weapon, armor, consumable, and loot definitions for Depths of the Abyss
// Depends on: constants.js (G, RARITY, RARITY_COLORS, ELEMENT), utils.js (Util)

// Base weapon type definitions with combat stats
const WEAPON_TYPES = {
  rusty_sword: {
    id: 'rusty_sword',
    name: 'Rusty Sword',
    type: 'melee_balanced',
    baseDamage: 15,
    speed: 1.2, // attacks per second
    range: 80, // pixels
    staminaCost: 10,
    element: ELEMENT.PHYSICAL,
    swingArc: 90, // degrees
    description: 'A balanced weapon for beginners. Medium damage and speed.',
    spriteColor: '#8B7355',
    bonusStats: { critical: 0.05 }
  },
  battle_axe: {
    id: 'battle_axe',
    name: 'Battle Axe',
    type: 'melee_heavy',
    baseDamage: 35,
    speed: 0.6,
    range: 90,
    staminaCost: 20,
    element: ELEMENT.PHYSICAL,
    swingArc: 120,
    description: 'Slow but devastating. Wide sweeping attacks.',
    spriteColor: '#C0C0C0',
    bonusStats: { cleave: 0.3 }
  },
  dagger: {
    id: 'dagger',
    name: 'Dagger',
    type: 'melee_fast',
    baseDamage: 8,
    speed: 2.5,
    range: 50,
    staminaCost: 5,
    element: ELEMENT.PHYSICAL,
    swingArc: 45,
    description: 'Lightning fast strikes. Bonus critical chance.',
    spriteColor: '#B8860B',
    bonusStats: { critical: 0.25, combo: 1.2 }
  },
  spear: {
    id: 'spear',
    name: 'Spear',
    type: 'melee_reach',
    baseDamage: 18,
    speed: 1.0,
    range: 140,
    staminaCost: 12,
    element: ELEMENT.PHYSICAL,
    swingArc: 30,
    description: 'Extended reach for safe engagement.',
    spriteColor: '#8B4513',
    bonusStats: { pierce: 0.2 }
  },
  war_hammer: {
    id: 'war_hammer',
    name: 'War Hammer',
    type: 'melee_crusher',
    baseDamage: 45,
    speed: 0.4,
    range: 75,
    staminaCost: 25,
    element: ELEMENT.PHYSICAL,
    swingArc: 60,
    description: 'Crushingly powerful. Chance to stun enemies.',
    spriteColor: '#696969',
    bonusStats: { stun: 0.3, armorBreak: 0.4 }
  },
  staff: {
    id: 'staff',
    name: 'Arcane Staff',
    type: 'magic_channeler',
    baseDamage: 20,
    speed: 0.8,
    range: 100,
    staminaCost: 0,
    manaCost: 15,
    element: ELEMENT.ARCANE,
    swingArc: 360,
    description: 'Channels magical power. Uses mana instead of stamina.',
    spriteColor: '#9370DB',
    bonusStats: { spellPower: 1.3, manaRegen: 0.1 }
  },
  bow: {
    id: 'bow',
    name: 'Hunter Bow',
    type: 'ranged_projectile',
    baseDamage: 22,
    speed: 1.5,
    range: 400,
    staminaCost: 15,
    element: ELEMENT.PHYSICAL,
    swingArc: 15,
    description: 'Fires arrows at distant targets. Requires line of sight.',
    spriteColor: '#8B4513',
    bonusStats: { pierce: 0.3, headshot: 2.0 }
  },
  scythe: {
    id: 'scythe',
    name: 'Soul Scythe',
    type: 'melee_lifesteal',
    baseDamage: 28,
    speed: 0.7,
    range: 110,
    staminaCost: 18,
    element: ELEMENT.DARK,
    swingArc: 150,
    description: 'Reaps life from enemies. Heals wielder on hit.',
    spriteColor: '#2F4F4F',
    bonusStats: { lifesteal: 0.15, critical: 0.1 }
  }
};

// Generate weapon instance with rarity scaling and floor-based upgrades
function generateWeapon(typeId, rarity, floor) {
  const base = WEAPON_TYPES[typeId];
  if (!base) return null;

  // Rarity multipliers for weapon stats
  const rarityMults = [1.0, 1.3, 1.7, 2.2, 3.0]; // common to legendary
  const rarityMult = rarityMults[rarity];

  // Floor scaling for power progression (10% per 5 floors)
  const floorMult = 1 + (Math.floor(floor / 5) * 0.1);

  const weapon = {
    id: `${typeId}_${rarity}_${floor}`,
    type: 'weapon',
    baseType: typeId,
    name: `${RARITY[rarity]} ${base.name}`,
    rarity: rarity,
    damage: Math.floor(base.baseDamage * rarityMult * floorMult),
    speed: base.speed * (1 + rarity * 0.05), // slight speed increase per rarity
    range: base.range,
    staminaCost: Math.max(5, base.staminaCost - rarity * 2),
    manaCost: base.manaCost || 0,
    element: base.element,
    swingArc: base.swingArc,
    description: base.description,
    color: RARITY_COLORS[rarity],
    spriteColor: base.spriteColor,
    bonusStats: { ...base.bonusStats },
    equipped: false,
    durability: 100
  };

  // Add random bonus stats based on rarity
  if (rarity >= 1) weapon.bonusStats.damage = 1 + rarity * 0.1;
  if (rarity >= 2) weapon.bonusStats[Util.pick(['critical', 'speed', 'lifesteal'])] = 0.05 + rarity * 0.05;
  if (rarity >= 3) weapon.bonusStats.allStats = 1.15;
  if (rarity >= 4) weapon.bonusStats.legendary = true;

  return weapon;
}

// Armor slot definitions
const ARMOR_TYPES = {
  head: {
    id: 'head',
    name: 'Helmet',
    slot: 'head',
    baseDefense: 8,
    bonuses: { hp: 20 },
    variants: ['Leather Cap', 'Iron Helm', 'Knight Helmet', 'Obsidian Crown', 'Abyssal Mask']
  },
  chest: {
    id: 'chest',
    name: 'Chestplate',
    slot: 'chest',
    baseDefense: 15,
    bonuses: { hp: 50 },
    variants: ['Leather Armor', 'Chainmail', 'Plate Armor', 'Dragonscale Mail', 'Voidplate']
  },
  legs: {
    id: 'legs',
    name: 'Leg Armor',
    slot: 'legs',
    baseDefense: 12,
    bonuses: { stamina: 20 },
    variants: ['Leather Pants', 'Chain Leggings', 'Plate Greaves', 'Runestone Legs', 'Abyssal Greaves']
  },
  boots: {
    id: 'boots',
    name: 'Boots',
    slot: 'boots',
    baseDefense: 6,
    bonuses: { speed: 1.1 },
    variants: ['Worn Boots', 'Traveler Boots', 'Steel Sabatons', 'Swift Boots', 'Void Walkers']
  },
  gloves: {
    id: 'gloves',
    name: 'Gloves',
    slot: 'gloves',
    baseDefense: 5,
    bonuses: { attackSpeed: 1.05 },
    variants: ['Cloth Gloves', 'Leather Gloves', 'Gauntlets', 'Assassin Gloves', 'Abyssal Grasp']
  },
  ring: {
    id: 'ring',
    name: 'Ring',
    slot: 'ring',
    baseDefense: 0,
    bonuses: { critical: 0.05, damage: 1.1 },
    variants: ['Copper Ring', 'Silver Ring', 'Gold Ring', 'Ruby Ring', 'Void Ring']
  },
  amulet: {
    id: 'amulet',
    name: 'Amulet',
    slot: 'amulet',
    baseDefense: 0,
    bonuses: { mana: 50, resist: 0.1 },
    variants: ['Simple Pendant', 'Stone Amulet', 'Crystal Charm', 'Enchanted Amulet', 'Abyssal Talisman']
  }
};

// Generate armor piece with rarity tiers
function generateArmor(slotId, rarity, floor) {
  const base = ARMOR_TYPES[slotId];
  if (!base) return null;

  const rarityMults = [1.0, 1.4, 1.9, 2.5, 3.5];
  const rarityMult = rarityMults[rarity];
  const floorMult = 1 + (Math.floor(floor / 5) * 0.15);

  const armor = {
    id: `${slotId}_${rarity}_${floor}`,
    type: 'armor',
    slot: slotId,
    name: `${base.variants[rarity]}`,
    rarity: rarity,
    defense: Math.floor(base.baseDefense * rarityMult * floorMult),
    bonuses: {},
    color: RARITY_COLORS[rarity],
    equipped: false
  };

  // Scale bonuses by rarity
  for (let stat in base.bonuses) {
    armor.bonuses[stat] = base.bonuses[stat] * rarityMult;
  }

  // Add extra resistance based on rarity
  if (rarity >= 1) armor.bonuses.resist = 0.05 + rarity * 0.03;
  if (rarity >= 3) armor.bonuses.hp = (armor.bonuses.hp || 0) + 30;
  if (rarity >= 4) armor.bonuses.allResist = 0.15;

  return armor;
}

// Consumable item definitions with effects
const CONSUMABLES = {
  health_potion: {
    id: 'health_potion',
    name: 'Health Potion',
    type: 'consumable',
    effect: 'healPlayer',
    effectValue: 50,
    description: 'Restores 50 HP instantly.',
    rarity: 0,
    stackable: true,
    maxStack: 5,
    color: '#DC143C'
  },
  mana_potion: {
    id: 'mana_potion',
    name: 'Mana Potion',
    type: 'consumable',
    effect: 'restoreMana',
    effectValue: 50,
    description: 'Restores 50 mana instantly.',
    rarity: 0,
    stackable: true,
    maxStack: 5,
    color: '#1E90FF'
  },
  stamina_tonic: {
    id: 'stamina_tonic',
    name: 'Stamina Tonic',
    type: 'consumable',
    effect: 'restoreStamina',
    effectValue: 100,
    description: 'Fully restores stamina.',
    rarity: 0,
    stackable: true,
    maxStack: 5,
    color: '#32CD32'
  },
  antidote: {
    id: 'antidote',
    name: 'Antidote',
    type: 'consumable',
    effect: 'curePoison',
    effectValue: 1,
    description: 'Cures poison and toxic effects.',
    rarity: 0,
    stackable: true,
    maxStack: 3,
    color: '#9ACD32'
  },
  fire_bomb: {
    id: 'fire_bomb',
    name: 'Fire Bomb',
    type: 'consumable',
    effect: 'throwFireBomb',
    effectValue: 100,
    description: 'Throw an explosive fire bomb. 100 damage in area.',
    rarity: 1,
    stackable: true,
    maxStack: 3,
    color: '#FF4500'
  },
  ice_shard: {
    id: 'ice_shard',
    name: 'Ice Shard',
    type: 'consumable',
    effect: 'throwIceShard',
    effectValue: 60,
    description: 'Launch a freezing projectile. Slows enemies.',
    rarity: 1,
    stackable: true,
    maxStack: 3,
    color: '#87CEEB'
  },
  scroll_of_return: {
    id: 'scroll_of_return',
    name: 'Scroll of Return',
    type: 'consumable',
    effect: 'returnToCampfire',
    effectValue: 1,
    description: 'Instantly return to the last campfire.',
    rarity: 2,
    stackable: true,
    maxStack: 1,
    color: '#FFD700'
  },
  elixir_of_power: {
    id: 'elixir_of_power',
    name: 'Elixir of Power',
    type: 'consumable',
    effect: 'buffAllStats',
    effectValue: 1.5,
    effectDuration: 30,
    description: 'Grants 50% damage boost and power-up for 30 seconds.',
    rarity: 3,
    stackable: false,
    maxStack: 1,
    color: '#FF00FF'
  }
};

// Crafting material definitions
const MATERIALS = {
  bone: {
    id: 'bone',
    name: 'Bone Fragment',
    type: 'material',
    description: 'Common crafting material from undead enemies.',
    rarity: 0,
    stackable: true,
    color: '#F5F5DC'
  },
  iron_ore: {
    id: 'iron_ore',
    name: 'Iron Ore',
    type: 'material',
    description: 'Used to upgrade weapons and armor.',
    rarity: 0,
    stackable: true,
    color: '#A9A9A9'
  },
  dark_crystal: {
    id: 'dark_crystal',
    name: 'Dark Crystal',
    type: 'material',
    description: 'Resonates with abyssal energy. Rare material.',
    rarity: 2,
    stackable: true,
    color: '#4B0082'
  },
  fungal_essence: {
    id: 'fungal_essence',
    name: 'Fungal Essence',
    type: 'material',
    description: 'Extracted from mushroom enemies.',
    rarity: 1,
    stackable: true,
    color: '#9370DB'
  },
  ember_dust: {
    id: 'ember_dust',
    name: 'Ember Dust',
    type: 'material',
    description: 'Hot to the touch. From fire enemies.',
    rarity: 1,
    stackable: true,
    color: '#FF6347'
  },
  frost_shard: {
    id: 'frost_shard',
    name: 'Frost Shard',
    type: 'material',
    description: 'Never melts. From frozen enemies.',
    rarity: 1,
    stackable: true,
    color: '#B0E0E6'
  },
  void_fragment: {
    id: 'void_fragment',
    name: 'Void Fragment',
    type: 'material',
    description: 'Reality bends around it. Very rare.',
    rarity: 3,
    stackable: true,
    color: '#191970'
  },
  ancient_relic: {
    id: 'ancient_relic',
    name: 'Ancient Relic',
    type: 'material',
    description: 'Legendary crafting material. Boss drops only.',
    rarity: 4,
    stackable: true,
    color: '#FFD700'
  }
};

// Loot generation tables for floor-based progression
const LOOT_TABLES = {
  common_chest: {
    minItems: 1,
    maxItems: 2,
    chances: {
      weapon: 0.3,
      armor: 0.3,
      consumable: 0.8,
      material: 0.6
    }
  },
  rare_chest: {
    minItems: 2,
    maxItems: 4,
    chances: {
      weapon: 0.5,
      armor: 0.5,
      consumable: 1.0,
      material: 0.8
    },
    rarityBoost: 1
  },
  boss_loot: {
    minItems: 3,
    maxItems: 5,
    chances: {
      weapon: 0.8,
      armor: 0.8,
      consumable: 0.5,
      material: 1.0
    },
    rarityBoost: 2,
    guaranteedRare: true
  },
  elite_enemy: {
    minItems: 1,
    maxItems: 2,
    chances: {
      weapon: 0.4,
      armor: 0.4,
      consumable: 0.3,
      material: 0.7
    },
    rarityBoost: 1
  }
};

// Generate loot drops based on floor and rarity boost
function generateLoot(floor, rarityBoost = 0, tableType = 'common_chest') {
  const table = LOOT_TABLES[tableType];
  if (!table) return [];

  const loot = [];
  const itemCount = Util.randInt(table.minItems, table.maxItems);

  for (let i = 0; i < itemCount; i++) {
    let itemType = null;

    // Roll for item type
    const roll = Math.random();
    if (roll < table.chances.weapon) itemType = 'weapon';
    else if (roll < table.chances.weapon + table.chances.armor) itemType = 'armor';
    else if (roll < table.chances.weapon + table.chances.armor + table.chances.consumable) itemType = 'consumable';
    else if (roll < table.chances.weapon + table.chances.armor + table.chances.consumable + table.chances.material) itemType = 'material';

    if (!itemType) continue;

    // Determine rarity (higher floors = better loot)
    let rarity = 0;
    const rarityRoll = Math.random() + (floor / 50) + (rarityBoost * 0.2);
    if (rarityRoll > 0.9) rarity = 4; // legendary
    else if (rarityRoll > 0.7) rarity = 3; // epic
    else if (rarityRoll > 0.5) rarity = 2; // rare
    else if (rarityRoll > 0.3) rarity = 1; // uncommon

    if (table.guaranteedRare && rarity < 2) rarity = 2;

    // Generate item
    let item = null;
    if (itemType === 'weapon') {
      const weaponKeys = Object.keys(WEAPON_TYPES);
      const weaponType = weaponKeys[Util.randInt(0, weaponKeys.length - 1)];
      item = generateWeapon(weaponType, rarity, floor);
    } else if (itemType === 'armor') {
      const armorKeys = Object.keys(ARMOR_TYPES);
      const armorSlot = armorKeys[Util.randInt(0, armorKeys.length - 1)];
      item = generateArmor(armorSlot, rarity, floor);
    } else if (itemType === 'consumable') {
      const consumableKeys = Object.keys(CONSUMABLES);
      const consumableId = consumableKeys[Util.randInt(0, consumableKeys.length - 1)];
      item = { ...CONSUMABLES[consumableId], count: 1 };
    } else if (itemType === 'material') {
      const materialKeys = Object.keys(MATERIALS);
      const materialId = materialKeys[Util.randInt(0, materialKeys.length - 1)];
      item = { ...MATERIALS[materialId], count: Util.randInt(1, 3) };
    }

    if (item) loot.push(item);
  }

  return loot;
}

// Equipment management utilities
const EQUIPMENT_UTILS = {
  // Get total defense from all equipped armor
  getTotalDefense(inventory) {
    let total = 0;
    for (let item of inventory) {
      if (item.type === 'armor' && item.equipped) {
        total += item.defense || 0;
      }
    }
    return total;
  },

  // Get all equipped items
  getEquippedItems(inventory) {
    return inventory.filter(item => item.equipped);
  },

  // Equip an item (unequip others in same slot)
  equipItem(inventory, itemId) {
    const item = inventory.find(i => i.id === itemId);
    if (!item) return false;

    // Unequip items in same slot
    if (item.type === 'weapon') {
      inventory.forEach(i => { if (i.type === 'weapon') i.equipped = false; });
    } else if (item.type === 'armor') {
      inventory.forEach(i => { if (i.type === 'armor' && i.slot === item.slot) i.equipped = false; });
    }

    item.equipped = true;
    return true;
  },

  // Calculate total stat bonuses from equipped items
  getStatBonuses(inventory) {
    const bonuses = {
      hp: 0,
      mana: 0,
      stamina: 0,
      defense: 0,
      damage: 1.0,
      speed: 1.0,
      critical: 0,
      resist: 0,
      lifesteal: 0
    };

    for (let item of inventory) {
      if (!item.equipped) continue;

      if (item.bonuses) {
        for (let stat in item.bonuses) {
          if (bonuses[stat] !== undefined) {
            if (typeof bonuses[stat] === 'number' && bonuses[stat] < 1) {
              bonuses[stat] += item.bonuses[stat];
            } else if (stat === 'damage' || stat === 'speed') {
              bonuses[stat] *= item.bonuses[stat];
            } else {
              bonuses[stat] += item.bonuses[stat];
            }
          }
        }
      }

      if (item.bonusStats) {
        for (let stat in item.bonusStats) {
          if (bonuses[stat] !== undefined) {
            bonuses[stat] += item.bonusStats[stat];
          }
        }
      }
    }

    return bonuses;
  }
};

// === data/enemies.js ===
// enemies.js - Enemy, boss, and spawn table definitions for Depths of the Abyss
// Depends on: constants.js (ELEMENT), utils.js (Util)

// Enemy type definitions organized by area with varied behaviors and AI strategies
const ENEMY_TYPES = {
  // SUNKEN CRYPT (Floors 1-5) - Tutorial area enemies
  skeleton_warrior: {
    id: 'skeleton_warrior',
    name: 'Skeleton Warrior',
    type: 'undead_melee',
    hp: 40,
    damage: 8,
    speed: 60,
    behavior: 'patrol', // walks back and forth, chases on sight
    patrolRange: 150,
    aggroRange: 200,
    element: ELEMENT.PHYSICAL,
    xpReward: 15,
    lootChance: 0.3,
    attacks: [
      { name: 'Slash', damage: 8, cooldown: 1.0, range: 60 }
    ],
    resistances: { dark: 0.5, light: -0.5 },
    spriteData: { color: '#E5E5DC', size: 32, shape: 'humanoid' },
    description: 'Reanimated bones with basic combat strategy. Easy to defeat.'
  },

  zombie_shambler: {
    id: 'zombie_shambler',
    name: 'Zombie Shambler',
    type: 'undead_slow',
    hp: 60,
    damage: 12,
    speed: 30,
    behavior: 'chase', // always moves toward player, slow
    aggroRange: 250,
    element: ELEMENT.DARK,
    xpReward: 18,
    lootChance: 0.25,
    attacks: [
      { name: 'Bite', damage: 12, cooldown: 1.5, range: 50, effect: 'poison' }
    ],
    resistances: { poison: 1.0, fire: -0.3 },
    spriteData: { color: '#556B2F', size: 34, shape: 'humanoid' },
    description: 'Slow but tanky opponent. Poisonous bite attack.'
  },

  giant_rat: {
    id: 'giant_rat',
    name: 'Giant Rat',
    type: 'beast_swarm',
    hp: 25,
    damage: 6,
    speed: 90,
    behavior: 'swarm', // attacks in groups, flanks player
    aggroRange: 180,
    element: ELEMENT.PHYSICAL,
    xpReward: 10,
    lootChance: 0.2,
    attacks: [
      { name: 'Gnaw', damage: 6, cooldown: 0.7, range: 40 }
    ],
    resistances: {},
    spriteData: { color: '#8B4513', size: 24, shape: 'quadruped' },
    description: 'Fast and dangerous in groups. Low health but high speed.'
  },

  crypt_spider: {
    id: 'crypt_spider',
    name: 'Crypt Spider',
    type: 'beast_ambush',
    hp: 35,
    damage: 10,
    speed: 75,
    behavior: 'ambush', // hides on ceiling, drops on player
    aggroRange: 150,
    element: ELEMENT.POISON,
    xpReward: 20,
    lootChance: 0.4,
    attacks: [
      { name: 'Venom Bite', damage: 10, cooldown: 1.2, range: 50, effect: 'poison' },
      { name: 'Web Shot', damage: 0, cooldown: 3.0, range: 200, effect: 'slow' }
    ],
    resistances: { poison: 1.0 },
    spriteData: { color: '#2F4F4F', size: 28, shape: 'spider' },
    description: 'Ambush predator with web attacks to slow victims.'
  },

  ghost_wisp: {
    id: 'ghost_wisp',
    name: 'Ghost Wisp',
    type: 'spirit_ranged',
    hp: 30,
    damage: 15,
    speed: 50,
    behavior: 'ranged', // keeps distance, fires projectiles
    aggroRange: 300,
    attackRange: 250,
    element: ELEMENT.ARCANE,
    xpReward: 25,
    lootChance: 0.35,
    attacks: [
      { name: 'Spirit Bolt', damage: 15, cooldown: 1.5, range: 250, projectile: true }
    ],
    resistances: { physical: 0.5, arcane: 0.5 },
    spriteData: { color: '#E0FFFF', size: 26, shape: 'wisp', glow: true },
    description: 'Ethereal ranged opponent. Resistant to physical damage.'
  },

  // FUNGAL CAVERNS (Floors 6-10) - Medium difficulty
  mushroom_golem: {
    id: 'mushroom_golem',
    name: 'Mushroom Golem',
    type: 'construct_tank',
    hp: 120,
    damage: 18,
    speed: 40,
    behavior: 'guard', // defends area, slow but tough
    aggroRange: 200,
    element: ELEMENT.NATURE,
    xpReward: 40,
    lootChance: 0.5,
    attacks: [
      { name: 'Slam', damage: 18, cooldown: 2.0, range: 70, effect: 'stun' },
      { name: 'Spore Cloud', damage: 5, cooldown: 5.0, range: 150, effect: 'poison', aoe: true }
    ],
    resistances: { physical: 0.3, poison: 1.0, fire: -0.5 },
    spriteData: { color: '#8B4789', size: 48, shape: 'golem' },
    description: 'Tanky guardian that releases toxic spores. Weak to fire.'
  },

  spore_cloud: {
    id: 'spore_cloud',
    name: 'Spore Cloud',
    type: 'elemental_hazard',
    hp: 50,
    damage: 8,
    speed: 20,
    behavior: 'patrol',
    patrolRange: 100,
    aggroRange: 150,
    element: ELEMENT.POISON,
    xpReward: 15,
    lootChance: 0.3,
    attacks: [
      { name: 'Toxic Aura', damage: 8, cooldown: 0.5, range: 80, continuous: true }
    ],
    resistances: { physical: 0.8, poison: 1.0 },
    spriteData: { color: '#9370DB', size: 40, shape: 'cloud', opacity: 0.7 },
    description: 'Floating hazard with continuous poison damage aura.'
  },

  cave_bat_swarm: {
    id: 'cave_bat_swarm',
    name: 'Cave Bat Swarm',
    type: 'beast_flying',
    hp: 40,
    damage: 12,
    speed: 120,
    behavior: 'swarm',
    aggroRange: 250,
    element: ELEMENT.PHYSICAL,
    xpReward: 22,
    lootChance: 0.25,
    attacks: [
      { name: 'Dive Attack', damage: 12, cooldown: 0.8, range: 60 }
    ],
    resistances: {},
    spriteData: { color: '#4B0082', size: 20, shape: 'bat', flying: true },
    description: 'Fast flying enemies that dive-bomb in swarms.'
  },

  fungal_zombie: {
    id: 'fungal_zombie',
    name: 'Fungal Zombie',
    type: 'undead_infected',
    hp: 80,
    damage: 16,
    speed: 45,
    behavior: 'chase',
    aggroRange: 200,
    element: ELEMENT.DARK,
    xpReward: 30,
    lootChance: 0.4,
    attacks: [
      { name: 'Infected Bite', damage: 16, cooldown: 1.3, range: 55, effect: 'poison' },
      { name: 'Explode', damage: 30, cooldown: 0, range: 100, onDeath: true, aoe: true }
    ],
    resistances: { poison: 1.0, dark: 0.5 },
    spriteData: { color: '#556B2F', size: 36, shape: 'humanoid', infected: true },
    description: 'Infected undead that explodes on death. Keep distance!'
  },

  toxic_slime: {
    id: 'toxic_slime',
    name: 'Toxic Slime',
    type: 'ooze_split',
    hp: 60,
    damage: 10,
    speed: 35,
    behavior: 'chase',
    aggroRange: 180,
    element: ELEMENT.POISON,
    xpReward: 25,
    lootChance: 0.35,
    attacks: [
      { name: 'Acid Touch', damage: 10, cooldown: 1.0, range: 50, effect: 'poison' }
    ],
    resistances: { physical: 0.5, poison: 1.0 },
    onDeathEffect: 'split', // splits into 2 smaller slimes
    spriteData: { color: '#32CD32', size: 32, shape: 'blob' },
    description: 'Ooze that splits into smaller copies when killed.'
  },

  // LAVA DEPTHS (Floors 11-15) - High difficulty
  fire_imp: {
    id: 'fire_imp',
    name: 'Fire Imp',
    type: 'demon_ranged',
    hp: 70,
    damage: 22,
    speed: 85,
    behavior: 'ranged',
    aggroRange: 300,
    attackRange: 280,
    element: ELEMENT.FIRE,
    xpReward: 45,
    lootChance: 0.45,
    attacks: [
      { name: 'Fireball', damage: 22, cooldown: 1.2, range: 280, projectile: true, element: 'fire' },
      { name: 'Flame Dash', damage: 15, cooldown: 3.0, range: 150, dash: true }
    ],
    resistances: { fire: 1.0, ice: -0.8 },
    spriteData: { color: '#FF4500', size: 30, shape: 'imp', glow: true },
    description: 'Agile demon that hurls fireballs and dashes through flames.'
  },

  lava_elemental: {
    id: 'lava_elemental',
    name: 'Lava Elemental',
    type: 'elemental_tank',
    hp: 150,
    damage: 28,
    speed: 30,
    behavior: 'guard',
    aggroRange: 220,
    element: ELEMENT.FIRE,
    xpReward: 60,
    lootChance: 0.6,
    attacks: [
      { name: 'Molten Strike', damage: 28, cooldown: 1.8, range: 80 },
      { name: 'Lava Pool', damage: 15, cooldown: 4.0, range: 200, aoe: true, duration: 5 }
    ],
    resistances: { fire: 1.0, physical: 0.4, ice: -1.0 },
    spriteData: { color: '#FF6347', size: 52, shape: 'elemental', glow: true },
    description: 'Living lava with devastating area attacks. Extreme fire resistance.'
  },

  magma_wyrm: {
    id: 'magma_wyrm',
    name: 'Magma Wyrm',
    type: 'beast_elite',
    hp: 180,
    damage: 32,
    speed: 55,
    behavior: 'chase',
    aggroRange: 250,
    element: ELEMENT.FIRE,
    xpReward: 70,
    lootChance: 0.65,
    attacks: [
      { name: 'Bite', damage: 32, cooldown: 1.5, range: 90 },
      { name: 'Fire Breath', damage: 40, cooldown: 4.0, range: 200, cone: 60, aoe: true }
    ],
    resistances: { fire: 1.0, physical: 0.3 },
    spriteData: { color: '#DC143C', size: 60, shape: 'wyrm' },
    description: 'Elite serpent with cone fire breath. High health and damage.'
  },

  ember_knight: {
    id: 'ember_knight',
    name: 'Ember Knight',
    type: 'undead_armored',
    hp: 140,
    damage: 26,
    speed: 65,
    behavior: 'patrol',
    patrolRange: 180,
    aggroRange: 230,
    element: ELEMENT.FIRE,
    xpReward: 55,
    lootChance: 0.55,
    attacks: [
      { name: 'Flaming Slash', damage: 26, cooldown: 1.3, range: 85, element: 'fire' },
      { name: 'Shield Bash', damage: 18, cooldown: 2.5, range: 70, effect: 'stun' }
    ],
    resistances: { physical: 0.4, fire: 0.8 },
    spriteData: { color: '#B22222', size: 42, shape: 'knight', armored: true },
    description: 'Armored warrior wreathed in flames. Can stun with shield.'
  },

  ash_phantom: {
    id: 'ash_phantom',
    name: 'Ash Phantom',
    type: 'spirit_teleport',
    hp: 90,
    damage: 24,
    speed: 70,
    behavior: 'ambush',
    aggroRange: 280,
    element: ELEMENT.FIRE,
    xpReward: 50,
    lootChance: 0.5,
    attacks: [
      { name: 'Phase Strike', damage: 24, cooldown: 1.6, range: 100, teleport: true },
      { name: 'Ember Cloud', damage: 12, cooldown: 3.5, range: 150, aoe: true }
    ],
    resistances: { physical: 0.6, fire: 0.8 },
    spriteData: { color: '#CD853F', size: 38, shape: 'phantom', translucent: true },
    description: 'Teleporting spirit that phases in and out of reality.'
  },

  // FROZEN ABYSS (Floors 16-20) - Very high difficulty
  ice_wraith: {
    id: 'ice_wraith',
    name: 'Ice Wraith',
    type: 'spirit_freeze',
    hp: 100,
    damage: 30,
    speed: 80,
    behavior: 'ranged',
    aggroRange: 300,
    attackRange: 270,
    element: ELEMENT.ICE,
    xpReward: 65,
    lootChance: 0.55,
    attacks: [
      { name: 'Ice Shard', damage: 30, cooldown: 1.1, range: 270, projectile: true, effect: 'slow' },
      { name: 'Frost Nova', damage: 20, cooldown: 4.0, range: 180, aoe: true, effect: 'freeze' }
    ],
    resistances: { ice: 1.0, fire: -0.9 },
    spriteData: { color: '#87CEEB', size: 34, shape: 'wraith', glow: true },
    description: 'Frozen spirit that slows and freezes opponents.'
  },

  frost_golem: {
    id: 'frost_golem',
    name: 'Frost Golem',
    type: 'construct_colossus',
    hp: 220,
    damage: 35,
    speed: 35,
    behavior: 'guard',
    aggroRange: 200,
    element: ELEMENT.ICE,
    xpReward: 80,
    lootChance: 0.7,
    attacks: [
      { name: 'Frozen Fist', damage: 35, cooldown: 2.0, range: 90, effect: 'slow' },
      { name: 'Blizzard', damage: 25, cooldown: 6.0, range: 250, aoe: true, duration: 6 }
    ],
    resistances: { ice: 1.0, physical: 0.5, fire: -0.8 },
    spriteData: { color: '#B0E0E6', size: 58, shape: 'golem', icy: true },
    description: 'Massive ice construct. Creates blizzard zones.'
  },

  crystal_spider: {
    id: 'crystal_spider',
    name: 'Crystal Spider',
    type: 'beast_ambush_elite',
    hp: 110,
    damage: 28,
    speed: 90,
    behavior: 'ambush',
    aggroRange: 170,
    element: ELEMENT.ICE,
    xpReward: 70,
    lootChance: 0.65,
    attacks: [
      { name: 'Crystal Bite', damage: 28, cooldown: 1.0, range: 55, critical: 0.3 },
      { name: 'Ice Web', damage: 10, cooldown: 2.5, range: 220, effect: 'freeze', projectile: true }
    ],
    resistances: { ice: 0.8, physical: 0.3 },
    spriteData: { color: '#ADD8E6', size: 32, shape: 'spider', crystalline: true },
    description: 'Crystallized spider with high critical hit chance.'
  },

  frozen_revenant: {
    id: 'frozen_revenant',
    name: 'Frozen Revenant',
    type: 'undead_boss_mini',
    hp: 200,
    damage: 40,
    speed: 60,
    behavior: 'chase',
    aggroRange: 280,
    element: ELEMENT.ICE,
    xpReward: 90,
    lootChance: 0.75,
    attacks: [
      { name: 'Frost Blade', damage: 40, cooldown: 1.4, range: 95, combo: 3 },
      { name: 'Ice Prison', damage: 0, cooldown: 8.0, range: 150, effect: 'freeze', duration: 3 },
      { name: 'Frozen Aura', damage: 15, cooldown: 0.5, range: 120, continuous: true }
    ],
    resistances: { ice: 1.0, dark: 0.5, fire: -1.0 },
    spriteData: { color: '#4682B4', size: 46, shape: 'revenant', frozen: true },
    description: 'Powerful undead with combo attacks and freeze abilities. Mini-boss tier.'
  },

  blizzard_wolf: {
    id: 'blizzard_wolf',
    name: 'Blizzard Wolf',
    type: 'beast_pack',
    hp: 95,
    damage: 32,
    speed: 110,
    behavior: 'swarm',
    aggroRange: 260,
    element: ELEMENT.ICE,
    xpReward: 60,
    lootChance: 0.5,
    attacks: [
      { name: 'Frozen Bite', damage: 32, cooldown: 0.9, range: 65, effect: 'slow' },
      { name: 'Howl', damage: 0, cooldown: 10.0, range: 400, effect: 'summon_pack' }
    ],
    resistances: { ice: 0.9 },
    spriteData: { color: '#F0F8FF', size: 36, shape: 'wolf' },
    description: 'Pack hunter that summons allies with its howl.'
  },

  // THE VOID (Floors 21-25) - Maximum difficulty, endgame
  void_walker: {
    id: 'void_walker',
    name: 'Void Walker',
    type: 'eldritch_assassin',
    hp: 140,
    damage: 45,
    speed: 100,
    behavior: 'ambush',
    aggroRange: 320,
    element: ELEMENT.VOID,
    xpReward: 100,
    lootChance: 0.7,
    attacks: [
      { name: 'Void Strike', damage: 45, cooldown: 1.2, range: 80, critical: 0.4 },
      { name: 'Teleport Strike', damage: 60, cooldown: 3.0, range: 300, teleport: true },
      { name: 'Reality Tear', damage: 35, cooldown: 5.0, range: 200, projectile: true }
    ],
    resistances: { physical: 0.4, arcane: 0.5, void: 1.0 },
    spriteData: { color: '#191970', size: 40, shape: 'humanoid', voidform: true },
    description: 'Assassin from beyond. Teleports and deals massive burst damage.'
  },

  shadow_assassin: {
    id: 'shadow_assassin',
    name: 'Shadow Assassin',
    type: 'eldritch_stealth',
    hp: 120,
    damage: 50,
    speed: 115,
    behavior: 'ambush',
    aggroRange: 100,
    element: ELEMENT.DARK,
    xpReward: 110,
    lootChance: 0.75,
    attacks: [
      { name: 'Backstab', damage: 100, cooldown: 2.0, range: 60, backstabMultiplier: 2.0 },
      { name: 'Shadow Step', damage: 35, cooldown: 1.5, range: 200, teleport: true },
      { name: 'Vanish', damage: 0, cooldown: 8.0, range: 0, effect: 'stealth', duration: 4 }
    ],
    resistances: { physical: 0.3, dark: 0.8 },
    spriteData: { color: '#2F4F4F', size: 38, shape: 'rogue', shadowy: true },
    description: 'Master of stealth. Devastating backstab attacks from invisibility.'
  },

  eldritch_horror: {
    id: 'eldritch_horror',
    name: 'Eldritch Horror',
    type: 'eldritch_aberration',
    hp: 250,
    damage: 55,
    speed: 50,
    behavior: 'chase',
    aggroRange: 350,
    element: ELEMENT.VOID,
    xpReward: 130,
    lootChance: 0.8,
    attacks: [
      { name: 'Tentacle Lash', damage: 55, cooldown: 1.6, range: 140, multi: 3 },
      { name: 'Madness Aura', damage: 20, cooldown: 0.5, range: 180, continuous: true, effect: 'confuse' },
      { name: 'Void Pulse', damage: 70, cooldown: 6.0, range: 300, aoe: true }
    ],
    resistances: { physical: 0.5, arcane: 0.6, void: 1.0 },
    spriteData: { color: '#4B0082', size: 64, shape: 'horror', tentacles: true },
    description: 'Massive aberration with multiple attacks and sanity-draining aura.'
  },

  abyss_watcher: {
    id: 'abyss_watcher',
    name: 'Abyss Watcher',
    type: 'eldritch_sentinel',
    hp: 200,
    damage: 48,
    speed: 75,
    behavior: 'patrol',
    patrolRange: 250,
    aggroRange: 300,
    element: ELEMENT.VOID,
    xpReward: 120,
    lootChance: 0.75,
    attacks: [
      { name: 'Void Blade', damage: 48, cooldown: 1.3, range: 100, combo: 4 },
      { name: 'Eye Beam', damage: 60, cooldown: 4.0, range: 400, beam: true },
      { name: 'Summon Minions', damage: 0, cooldown: 12.0, range: 0, effect: 'summon_void_spawn' }
    ],
    resistances: { physical: 0.4, all: 0.3 },
    spriteData: { color: '#000080', size: 50, shape: 'sentinel', eyes: true },
    description: 'Guardian of the deep. Fires devastating eye beams and summons minions.'
  },

  null_entity: {
    id: 'null_entity',
    name: 'Null Entity',
    type: 'eldritch_void',
    hp: 180,
    damage: 52,
    speed: 90,
    behavior: 'chase',
    aggroRange: 330,
    element: ELEMENT.VOID,
    xpReward: 140,
    lootChance: 0.85,
    attacks: [
      { name: 'Existence Drain', damage: 52, cooldown: 1.4, range: 90, lifesteal: 0.5 },
      { name: 'Null Zone', damage: 30, cooldown: 5.0, range: 220, aoe: true, effect: 'silence', duration: 4 },
      { name: 'Phase Shift', damage: 0, cooldown: 3.0, range: 0, effect: 'invulnerable', duration: 2 }
    ],
    resistances: { all: 0.5 },
    spriteData: { color: '#0D0D0D', size: 44, shape: 'entity', distorted: true },
    description: 'Being of pure void. Drains life and becomes invulnerable periodically.'
  }
};

// Boss definitions with multi-phase mechanics and dialogue
const BOSS_DEFS = {
  grave_warden: {
    id: 'grave_warden',
    name: 'The Grave Warden',
    type: 'boss_undead',
    floor: 5,
    baseHp: 500,
    element: ELEMENT.DARK,
    xpReward: 300,
    phases: [
      {
        hp_threshold: 1.0,
        behavior: 'patrol',
        speed: 65,
        attacks: [
          { name: 'Heavy Slash', damage: 35, cooldown: 1.8, range: 110 },
          { name: 'Shield Block', damage: 0, cooldown: 4.0, effect: 'defense_up', duration: 3 }
        ]
      },
      {
        hp_threshold: 0.6,
        behavior: 'chase',
        speed: 75,
        attacks: [
          { name: 'Skeleton Summon', damage: 0, cooldown: 8.0, effect: 'summon_skeletons', count: 3 },
          { name: 'Spinning Slash', damage: 45, cooldown: 2.5, range: 140, aoe: true }
        ],
        special_moves: ['summon_reinforcements']
      },
      {
        hp_threshold: 0.25,
        behavior: 'chase',
        speed: 85,
        attacks: [
          { name: 'Ground Slam', damage: 60, cooldown: 3.0, range: 200, aoe: true, effect: 'stun' },
          { name: 'Death Charge', damage: 70, cooldown: 5.0, range: 300, dash: true },
          { name: 'Grave Aura', damage: 15, cooldown: 0.5, range: 150, continuous: true }
        ],
        special_moves: ['enrage']
      }
    ],
    dialogue: {
      intro: "You dare disturb the eternal rest of these halls?",
      phase_change: ["The dead rise at my command!", "You cannot stop the inevitable!"],
      death: "The crypt... crumbles..."
    },
    lootTable: 'boss_loot',
    spriteData: { color: '#4A4A4A', size: 80, shape: 'knight', boss: true }
  },

  mycelium_king: {
    id: 'mycelium_king',
    name: 'Mycelium King',
    type: 'boss_fungal',
    floor: 10,
    baseHp: 800,
    element: ELEMENT.NATURE,
    xpReward: 500,
    phases: [
      {
        hp_threshold: 1.0,
        behavior: 'guard',
        speed: 50,
        attacks: [
          { name: 'Spore Spray', damage: 30, cooldown: 2.0, range: 180, cone: 90, effect: 'poison' },
          { name: 'Root Grasp', damage: 25, cooldown: 4.0, range: 200, effect: 'slow', duration: 3 }
        ]
      },
      {
        hp_threshold: 0.5,
        behavior: 'chase',
        speed: 60,
        attacks: [
          { name: 'Split Form', damage: 0, cooldown: 1.0, effect: 'create_clone', count: 2 },
          { name: 'Mushroom Cage', damage: 40, cooldown: 6.0, range: 150, effect: 'trap', duration: 4 }
        ],
        special_moves: ['split_into_copies']
      },
      {
        hp_threshold: 0.2,
        behavior: 'chase',
        speed: 70,
        attacks: [
          { name: 'Fungal Explosion', damage: 80, cooldown: 7.0, range: 300, aoe: true },
          { name: 'Toxic Bloom', damage: 50, cooldown: 3.0, range: 200, aoe: true, effect: 'poison' },
          { name: 'Regeneration', damage: 0, cooldown: 10.0, effect: 'heal', value: 100 }
        ],
        special_moves: ['mushroom_cage_ultimate']
      }
    ],
    dialogue: {
      intro: "The network spans forever. You are but a single cell.",
      phase_change: ["I am legion. I am everywhere.", "The spores will consume all!"],
      death: "The mycelium... never... truly... dies..."
    },
    lootTable: 'boss_loot',
    spriteData: { color: '#8B4789', size: 90, shape: 'fungal_mass', boss: true }
  },

  infernal_colossus: {
    id: 'infernal_colossus',
    name: 'Infernal Colossus',
    type: 'boss_demon',
    floor: 15,
    baseHp: 1200,
    element: ELEMENT.FIRE,
    xpReward: 750,
    phases: [
      {
        hp_threshold: 1.0,
        behavior: 'guard',
        speed: 45,
        attacks: [
          { name: 'Fire Breath', damage: 50, cooldown: 3.0, range: 250, cone: 75, element: 'fire' },
          { name: 'Molten Fist', damage: 60, cooldown: 2.0, range: 120 }
        ]
      },
      {
        hp_threshold: 0.65,
        behavior: 'chase',
        speed: 55,
        attacks: [
          { name: 'Meteor Rain', damage: 40, cooldown: 6.0, range: 400, aoe: true, multi: 8 },
          { name: 'Flame Wave', damage: 55, cooldown: 4.0, range: 300, wave: true }
        ],
        special_moves: ['meteor_bombardment']
      },
      {
        hp_threshold: 0.3,
        behavior: 'chase',
        speed: 65,
        attacks: [
          { name: 'Lava Conversion', damage: 30, cooldown: 1.0, range: 500, effect: 'floor_lava', continuous: true },
          { name: 'Inferno', damage: 100, cooldown: 8.0, range: 350, aoe: true },
          { name: 'Magma Eruption', damage: 80, cooldown: 5.0, range: 200, aoe: true, multi: 4 }
        ],
        special_moves: ['floor_becomes_lava']
      }
    ],
    dialogue: {
      intro: "Burn. Everything burns.",
      phase_change: ["The earth itself shall melt!", "WITNESS TRUE INFERNO!"],
      death: "The flames... dim... but never... extinguish..."
    },
    lootTable: 'boss_loot',
    spriteData: { color: '#FF4500', size: 100, shape: 'colossus', boss: true, flames: true }
  },

  glacial_sovereign: {
    id: 'glacial_sovereign',
    name: 'Glacial Sovereign',
    type: 'boss_ice',
    floor: 20,
    baseHp: 1500,
    element: ELEMENT.ICE,
    xpReward: 1000,
    phases: [
      {
        hp_threshold: 1.0,
        behavior: 'ranged',
        speed: 60,
        attacks: [
          { name: 'Ice Lance Barrage', damage: 45, cooldown: 1.5, range: 350, projectile: true, multi: 3 },
          { name: 'Frost Shield', damage: 0, cooldown: 6.0, effect: 'shield', value: 200 }
        ]
      },
      {
        hp_threshold: 0.6,
        behavior: 'chase',
        speed: 70,
        attacks: [
          { name: 'Time Freeze', damage: 0, cooldown: 12.0, range: 500, effect: 'freeze_time', duration: 4 },
          { name: 'Glacial Spike', damage: 70, cooldown: 3.0, range: 300, projectile: true, pierce: true },
          { name: 'Ice Prison', damage: 0, cooldown: 8.0, range: 180, effect: 'freeze', duration: 5 }
        ],
        special_moves: ['time_freeze']
      },
      {
        hp_threshold: 0.25,
        behavior: 'chase',
        speed: 80,
        attacks: [
          { name: 'Eternal Blizzard', damage: 35, cooldown: 1.0, range: 600, aoe: true, continuous: true },
          { name: 'Absolute Zero', damage: 150, cooldown: 10.0, range: 250, aoe: true, effect: 'freeze' },
          { name: 'Ice Clone', damage: 0, cooldown: 15.0, effect: 'summon_ice_clone' }
        ],
        special_moves: ['blizzard_phase']
      }
    ],
    dialogue: {
      intro: "All will be still. All will be frozen. Forever.",
      phase_change: ["Time itself bows to winter's will.", "Witness eternity in ice!"],
      death: "The thaw... begins... at last..."
    },
    lootTable: 'boss_loot',
    spriteData: { color: '#87CEEB', size: 95, shape: 'sovereign', boss: true, crowned: true }
  },

  abyss_incarnate: {
    id: 'abyss_incarnate',
    name: 'The Abyss Incarnate',
    type: 'boss_final',
    floor: 25,
    baseHp: 2500,
    element: ELEMENT.VOID,
    xpReward: 2000,
    phases: [
      {
        hp_threshold: 1.0,
        behavior: 'chase',
        speed: 75,
        attacks: [
          { name: 'Elemental Barrage', damage: 50, cooldown: 2.0, range: 300, projectile: true, element: 'all' },
          { name: 'Void Slash', damage: 65, cooldown: 1.5, range: 130, combo: 5 },
          { name: 'Gravity Well', damage: 40, cooldown: 5.0, range: 250, aoe: true, effect: 'pull' }
        ]
      },
      {
        hp_threshold: 0.75,
        behavior: 'chase',
        speed: 85,
        attacks: [
          { name: 'Summon Champions', damage: 0, cooldown: 20.0, effect: 'summon_mini_bosses', count: 2 },
          { name: 'Reality Fracture', damage: 70, cooldown: 4.0, range: 350, aoe: true },
          { name: 'Void Storm', damage: 45, cooldown: 1.0, range: 400, continuous: true }
        ],
        special_moves: ['summon_previous_bosses']
      },
      {
        hp_threshold: 0.5,
        behavior: 'chase',
        speed: 95,
        attacks: [
          { name: 'Mirror Strike', damage: 80, cooldown: 2.0, range: 150, copies_player_ability: true },
          { name: 'Abyss Gaze', damage: 60, cooldown: 3.0, range: 500, beam: true },
          { name: 'Dimensional Rift', damage: 90, cooldown: 6.0, range: 300, aoe: true, effect: 'teleport_random' }
        ],
        special_moves: ['copies_player_abilities']
      },
      {
        hp_threshold: 0.2,
        behavior: 'chase',
        speed: 110,
        attacks: [
          { name: 'True Form Unleashed', damage: 100, cooldown: 1.2, range: 200, multi: 4 },
          { name: 'Oblivion Wave', damage: 120, cooldown: 7.0, range: 600, aoe: true, wave: true },
          { name: 'Consume Reality', damage: 80, cooldown: 0.8, range: 180, lifesteal: 0.8 },
          { name: 'End of All', damage: 200, cooldown: 15.0, range: 500, aoe: true, ultimate: true }
        ],
        special_moves: ['true_form', 'world_ending_attack']
      }
    ],
    dialogue: {
      intro: "I am the void between stars. The silence after the scream. The end of all things.",
      phase_change: [
        "You face not a creature, but concept itself.",
        "I have worn the faces of gods. You show me yours.",
        "WITNESS THE ABYSS!"
      ],
      death: "Perhaps... you have... earned... victory..."
    },
    lootTable: 'boss_loot',
    finalBoss: true,
    spriteData: { color: '#000000', size: 120, shape: 'eldritch_god', boss: true, phases: 4 }
  }
};

// Spawn tables for floor-based enemy generation with difficulty scaling
const SPAWN_TABLES = {
  // Returns weighted enemy list for given floor and difficulty
  getSpawnTable(floor, difficulty = 'medium') {
    const difficultyMults = { easy: 0.7, medium: 1.0, hard: 1.4, elite: 1.8 };
    const mult = difficultyMults[difficulty] || 1.0;

    let enemies = [];

    // Sunken Crypt (1-5)
    if (floor <= 5) {
      enemies = [
        { id: 'skeleton_warrior', weight: 35, hpMult: mult, damageMult: mult },
        { id: 'zombie_shambler', weight: 25, hpMult: mult, damageMult: mult },
        { id: 'giant_rat', weight: 30, hpMult: mult, damageMult: mult },
        { id: 'crypt_spider', weight: 15, hpMult: mult, damageMult: mult },
        { id: 'ghost_wisp', weight: 10, hpMult: mult, damageMult: mult }
      ];
    }
    // Fungal Caverns (6-10)
    else if (floor <= 10) {
      enemies = [
        { id: 'mushroom_golem', weight: 20, hpMult: mult, damageMult: mult },
        { id: 'spore_cloud', weight: 25, hpMult: mult, damageMult: mult },
        { id: 'cave_bat_swarm', weight: 30, hpMult: mult, damageMult: mult },
        { id: 'fungal_zombie', weight: 20, hpMult: mult, damageMult: mult },
        { id: 'toxic_slime', weight: 25, hpMult: mult, damageMult: mult },
        { id: 'skeleton_warrior', weight: 10, hpMult: mult * 1.2, damageMult: mult * 1.2 }
      ];
    }
    // Lava Depths (11-15)
    else if (floor <= 15) {
      enemies = [
        { id: 'fire_imp', weight: 30, hpMult: mult, damageMult: mult },
        { id: 'lava_elemental', weight: 20, hpMult: mult, damageMult: mult },
        { id: 'magma_wyrm', weight: 15, hpMult: mult, damageMult: mult },
        { id: 'ember_knight', weight: 25, hpMult: mult, damageMult: mult },
        { id: 'ash_phantom', weight: 20, hpMult: mult, damageMult: mult }
      ];
    }
    // Frozen Abyss (16-20)
    else if (floor <= 20) {
      enemies = [
        { id: 'ice_wraith', weight: 25, hpMult: mult, damageMult: mult },
        { id: 'frost_golem', weight: 20, hpMult: mult, damageMult: mult },
        { id: 'crystal_spider', weight: 20, hpMult: mult, damageMult: mult },
        { id: 'frozen_revenant', weight: 15, hpMult: mult, damageMult: mult },
        { id: 'blizzard_wolf', weight: 25, hpMult: mult, damageMult: mult }
      ];
    }
    // The Void (21-25)
    else {
      enemies = [
        { id: 'void_walker', weight: 25, hpMult: mult, damageMult: mult },
        { id: 'shadow_assassin', weight: 20, hpMult: mult, damageMult: mult },
        { id: 'eldritch_horror', weight: 15, hpMult: mult, damageMult: mult },
        { id: 'abyss_watcher', weight: 20, hpMult: mult, damageMult: mult },
        { id: 'null_entity', weight: 20, hpMult: mult, damageMult: mult }
      ];
    }

    // Add elite variant chance (small probability, 1.5x stats, better loot)
    if (difficulty !== 'elite' && Math.random() < 0.1) {
      enemies.forEach(e => {
        if (Math.random() < 0.15) {
          e.isElite = true;
          e.hpMult *= 1.5;
          e.damageMult *= 1.5;
          e.lootBoost = 1;
        }
      });
    }

    return enemies;
  },

  // Get boss for specific floor
  getBoss(floor) {
    if (floor === 5) return 'grave_warden';
    if (floor === 10) return 'mycelium_king';
    if (floor === 15) return 'infernal_colossus';
    if (floor === 20) return 'glacial_sovereign';
    if (floor === 25) return 'abyss_incarnate';
    return null;
  }
};

// === data/abilities.js ===
// abilities.js - Skill tree and ability definitions for Depths of the Abyss
// Depends on: constants.js (ELEMENT), utils.js (Util)

// Three skill tree branches: WARRIOR (red), MAGE (blue), ROGUE (green)
const SKILL_TREES = {
  warrior: {
    id: 'warrior',
    name: 'Warrior',
    description: 'Master of melee combat, heavy armor, and devastating power. High HP and damage.',
    color: '#DC143C',
    icon: 'sword',
    passive_bonuses: {
      base: { hp: 20, defense: 5, melee_damage: 1.1 },
      per_level: { hp: 10, defense: 2, melee_damage: 1.02 }
    }
  },
  mage: {
    id: 'mage',
    name: 'Mage',
    description: 'Arcane spellcaster with powerful ranged magic. High mana and spell damage.',
    color: '#1E90FF',
    icon: 'staff',
    passive_bonuses: {
      base: { mana: 50, spell_damage: 1.2, cooldown_reduction: 0.05 },
      per_level: { mana: 15, spell_damage: 1.03, cooldown_reduction: 0.01 }
    }
  },
  rogue: {
    id: 'rogue',
    name: 'Rogue',
    description: 'Swift assassin specializing in critical strikes and evasion. High speed and crit chance.',
    color: '#32CD32',
    icon: 'dagger',
    passive_bonuses: {
      base: { crit_chance: 0.1, dodge_distance: 1.2, item_find: 0.1 },
      per_level: { crit_chance: 0.02, dodge_distance: 1.05, item_find: 0.02 }
    }
  }
};

// Complete ability definitions for all three trees
const ABILITY_DEFS = {
  // ===== WARRIOR TREE =====
  // Tier 1: Basic combat abilities
  power_strike: {
    id: 'power_strike',
    name: 'Power Strike',
    tree: 'warrior',
    tier: 1,
    manaCost: 0,
    staminaCost: 20,
    cooldown: 3.0,
    duration: 0,
    damage: 50,
    damageMultiplier: 1.3,
    element: ELEMENT.PHYSICAL,
    aoe: false,
    range: 100,
    description: 'Powerful melee strike dealing 30% bonus damage. Low cooldown for sustained DPS.',
    effect: 'melee_power_attack',
    prerequisites: [],
    unlockLevel: 1,
    skillPointCost: 1
  },

  iron_skin: {
    id: 'iron_skin',
    name: 'Iron Skin',
    tree: 'warrior',
    tier: 1,
    manaCost: 0,
    staminaCost: 30,
    cooldown: 15.0,
    duration: 8.0,
    damage: 0,
    element: ELEMENT.PHYSICAL,
    aoe: false,
    range: 0,
    description: 'Harden your body, gaining 20% defense boost for 8 seconds. Essential for tanking.',
    effect: 'buff_defense',
    effectValue: 1.2,
    prerequisites: [],
    unlockLevel: 1,
    skillPointCost: 1
  },

  berserker_rage: {
    id: 'berserker_rage',
    name: 'Berserker Rage',
    tree: 'warrior',
    tier: 1,
    manaCost: 0,
    staminaCost: 0,
    cooldown: 0,
    duration: 0,
    damage: 0,
    element: ELEMENT.PHYSICAL,
    aoe: false,
    range: 0,
    description: 'Passive: Gain 30% attack speed and movement speed when below 30% HP. High-risk, high-reward.',
    effect: 'passive_low_hp_buff',
    effectValue: 1.3,
    passive: true,
    prerequisites: [],
    unlockLevel: 1,
    skillPointCost: 1
  },

  // Tier 2: Advanced warrior skills
  whirlwind: {
    id: 'whirlwind',
    name: 'Whirlwind',
    tree: 'warrior',
    tier: 2,
    manaCost: 0,
    staminaCost: 40,
    cooldown: 8.0,
    duration: 2.0,
    damage: 35,
    damagePerTick: 35,
    element: ELEMENT.PHYSICAL,
    aoe: true,
    range: 120,
    description: 'Spin rapidly for 2 seconds, hitting all nearby enemies. Great for crowd control.',
    effect: 'aoe_spin_attack',
    prerequisites: ['power_strike'],
    unlockLevel: 5,
    skillPointCost: 2
  },

  shield_bash: {
    id: 'shield_bash',
    name: 'Shield Bash',
    tree: 'warrior',
    tier: 2,
    manaCost: 0,
    staminaCost: 25,
    cooldown: 6.0,
    duration: 0,
    damage: 40,
    element: ELEMENT.PHYSICAL,
    aoe: false,
    range: 80,
    description: 'Bash enemies with your shield, dealing damage and stunning for 2 seconds. Combo setup.',
    effect: 'stun_attack',
    stunDuration: 2.0,
    prerequisites: ['iron_skin'],
    unlockLevel: 5,
    skillPointCost: 2
  },

  war_cry: {
    id: 'war_cry',
    name: 'War Cry',
    tree: 'warrior',
    tier: 2,
    manaCost: 0,
    staminaCost: 35,
    cooldown: 20.0,
    duration: 10.0,
    damage: 0,
    element: ELEMENT.PHYSICAL,
    aoe: true,
    range: 300,
    description: 'Rally allies with a mighty shout. Increases damage by 25% and defense by 15% for 10 seconds.',
    effect: 'buff_allies',
    buffStats: { damage: 1.25, defense: 1.15 },
    prerequisites: ['berserker_rage'],
    unlockLevel: 5,
    skillPointCost: 2
  },

  // Tier 3: Ultimate warrior abilities
  earthquake: {
    id: 'earthquake',
    name: 'Earthquake',
    tree: 'warrior',
    tier: 3,
    manaCost: 0,
    staminaCost: 60,
    cooldown: 30.0,
    duration: 0,
    damage: 150,
    element: ELEMENT.PHYSICAL,
    aoe: true,
    range: 400,
    description: 'Slam the ground, creating a massive shockwave. Stuns all enemies hit for 3 seconds.',
    effect: 'ultimate_aoe_stun',
    stunDuration: 3.0,
    prerequisites: ['whirlwind', 'shield_bash'],
    unlockLevel: 12,
    skillPointCost: 3
  },

  undying_will: {
    id: 'undying_will',
    name: 'Undying Will',
    tree: 'warrior',
    tier: 3,
    manaCost: 0,
    staminaCost: 0,
    cooldown: 180.0,
    duration: 0,
    damage: 0,
    element: ELEMENT.PHYSICAL,
    aoe: false,
    range: 0,
    description: 'Passive: Survive a lethal hit once with 1 HP. 3 minute cooldown. Critical for boss fights.',
    effect: 'passive_death_save',
    prerequisites: ['iron_skin', 'war_cry'],
    unlockLevel: 12,
    skillPointCost: 3
  },

  titans_grip: {
    id: 'titans_grip',
    name: "Titan's Grip",
    tree: 'warrior',
    tier: 3,
    manaCost: 0,
    staminaCost: 0,
    cooldown: 0,
    duration: 0,
    damage: 0,
    element: ELEMENT.PHYSICAL,
    aoe: false,
    range: 0,
    description: 'Passive: Dual wield two-handed weapons or equip weapon in both hands for 40% damage bonus.',
    effect: 'passive_dual_wield',
    damageBonus: 1.4,
    passive: true,
    prerequisites: ['power_strike', 'whirlwind'],
    unlockLevel: 12,
    skillPointCost: 3
  },

  // ===== MAGE TREE =====
  // Tier 1: Basic spells
  fireball: {
    id: 'fireball',
    name: 'Fireball',
    tree: 'mage',
    tier: 1,
    manaCost: 25,
    staminaCost: 0,
    cooldown: 2.0,
    duration: 0,
    damage: 60,
    element: ELEMENT.FIRE,
    aoe: false,
    range: 350,
    description: 'Launch a flaming projectile at your target. Basic ranged spell with good damage.',
    effect: 'projectile_fireball',
    projectileSpeed: 300,
    prerequisites: [],
    unlockLevel: 1,
    skillPointCost: 1
  },

  frost_shield: {
    id: 'frost_shield',
    name: 'Frost Shield',
    tree: 'mage',
    tier: 1,
    manaCost: 30,
    staminaCost: 0,
    cooldown: 12.0,
    duration: 6.0,
    damage: 0,
    element: ELEMENT.ICE,
    aoe: false,
    range: 0,
    description: 'Create an ice barrier that absorbs 150 damage. Reflects 20% damage to attackers.',
    effect: 'shield_absorb',
    absorbAmount: 150,
    reflectPercent: 0.2,
    prerequisites: [],
    unlockLevel: 1,
    skillPointCost: 1
  },

  mana_surge: {
    id: 'mana_surge',
    name: 'Mana Surge',
    tree: 'mage',
    tier: 1,
    manaCost: 0,
    staminaCost: 0,
    cooldown: 0,
    duration: 0,
    damage: 0,
    element: ELEMENT.ARCANE,
    aoe: false,
    range: 0,
    description: 'Passive: Increase mana regeneration by 50%. Essential for spell-heavy builds.',
    effect: 'passive_mana_regen',
    regenBonus: 1.5,
    passive: true,
    prerequisites: [],
    unlockLevel: 1,
    skillPointCost: 1
  },

  // Tier 2: Advanced magic
  lightning_chain: {
    id: 'lightning_chain',
    name: 'Lightning Chain',
    tree: 'mage',
    tier: 2,
    manaCost: 40,
    staminaCost: 0,
    cooldown: 5.0,
    duration: 0,
    damage: 70,
    element: ELEMENT.LIGHTNING,
    aoe: false,
    range: 300,
    description: 'Electrocute target and chain to 3 nearby enemies. Effective against groups.',
    effect: 'chain_lightning',
    chainTargets: 3,
    chainRange: 150,
    prerequisites: ['fireball'],
    unlockLevel: 5,
    skillPointCost: 2
  },

  teleport: {
    id: 'teleport',
    name: 'Teleport',
    tree: 'mage',
    tier: 2,
    manaCost: 35,
    staminaCost: 0,
    cooldown: 8.0,
    duration: 0,
    damage: 0,
    element: ELEMENT.ARCANE,
    aoe: false,
    range: 250,
    description: 'Instantly blink to target location. Grants 1 second invulnerability. Excellent escape.',
    effect: 'blink_teleport',
    invulnDuration: 1.0,
    prerequisites: ['frost_shield'],
    unlockLevel: 5,
    skillPointCost: 2
  },

  arcane_missile: {
    id: 'arcane_missile',
    name: 'Arcane Missile',
    tree: 'mage',
    tier: 2,
    manaCost: 30,
    staminaCost: 0,
    cooldown: 4.0,
    duration: 0,
    damage: 50,
    element: ELEMENT.ARCANE,
    aoe: false,
    range: 400,
    description: 'Fire a homing missile that never misses. Fires 3 missiles in a chain. Great DPS.',
    effect: 'homing_missile',
    missileCount: 3,
    prerequisites: ['mana_surge'],
    unlockLevel: 5,
    skillPointCost: 2
  },

  // Tier 3: Ultimate spells
  meteor_strike: {
    id: 'meteor_strike',
    name: 'Meteor Strike',
    tree: 'mage',
    tier: 3,
    manaCost: 80,
    staminaCost: 0,
    cooldown: 25.0,
    duration: 0,
    damage: 200,
    element: ELEMENT.FIRE,
    aoe: true,
    range: 500,
    description: 'Call down a massive meteor, dealing huge AoE damage. Leaves burning ground for 5 seconds.',
    effect: 'ultimate_meteor',
    burnDuration: 5.0,
    burnDamage: 20,
    aoeRadius: 180,
    prerequisites: ['fireball', 'lightning_chain'],
    unlockLevel: 12,
    skillPointCost: 3
  },

  time_warp: {
    id: 'time_warp',
    name: 'Time Warp',
    tree: 'mage',
    tier: 3,
    manaCost: 60,
    staminaCost: 0,
    cooldown: 40.0,
    duration: 6.0,
    damage: 0,
    element: ELEMENT.ARCANE,
    aoe: true,
    range: 300,
    description: 'Slow all enemies in area by 70% for 6 seconds. Gain 30% speed boost. Boss utility.',
    effect: 'time_manipulation',
    slowPercent: 0.7,
    selfSpeedBonus: 1.3,
    prerequisites: ['teleport', 'arcane_missile'],
    unlockLevel: 12,
    skillPointCost: 3
  },

  elemental_mastery: {
    id: 'elemental_mastery',
    name: 'Elemental Mastery',
    tree: 'mage',
    tier: 3,
    manaCost: 0,
    staminaCost: 0,
    cooldown: 0,
    duration: 0,
    damage: 0,
    element: ELEMENT.ARCANE,
    aoe: false,
    range: 0,
    description: 'Passive: Gain 30% resistance to all elements. Spells deal 20% more damage. Master caster.',
    effect: 'passive_element_master',
    resistAll: 0.3,
    spellDamageBonus: 1.2,
    passive: true,
    prerequisites: ['mana_surge', 'frost_shield'],
    unlockLevel: 12,
    skillPointCost: 3
  },

  // ===== ROGUE TREE =====
  // Tier 1: Basic rogue skills
  backstab: {
    id: 'backstab',
    name: 'Backstab',
    tree: 'rogue',
    tier: 1,
    manaCost: 0,
    staminaCost: 20,
    cooldown: 3.0,
    duration: 0,
    damage: 80,
    damageMultiplier: 2.0,
    element: ELEMENT.PHYSICAL,
    aoe: false,
    range: 70,
    description: 'Strike from behind for double damage. Bonus critical chance. Positioning matters.',
    effect: 'backstab_attack',
    backstabAngle: 90,
    bonusCrit: 0.5,
    prerequisites: [],
    unlockLevel: 1,
    skillPointCost: 1
  },

  poison_blade: {
    id: 'poison_blade',
    name: 'Poison Blade',
    tree: 'rogue',
    tier: 1,
    manaCost: 0,
    staminaCost: 15,
    cooldown: 1.0,
    duration: 6.0,
    damage: 30,
    dotDamage: 10,
    element: ELEMENT.POISON,
    aoe: false,
    range: 60,
    description: 'Coat your weapon in poison. Attacks deal 10 poison damage per second for 6 seconds.',
    effect: 'apply_poison_dot',
    prerequisites: [],
    unlockLevel: 1,
    skillPointCost: 1
  },

  quick_step: {
    id: 'quick_step',
    name: 'Quick Step',
    tree: 'rogue',
    tier: 1,
    manaCost: 0,
    staminaCost: 15,
    cooldown: 4.0,
    duration: 0,
    damage: 0,
    element: ELEMENT.PHYSICAL,
    aoe: false,
    range: 150,
    description: 'Dash quickly in any direction. 50% faster than normal dodge. Low cooldown mobility.',
    effect: 'quick_dash',
    dashSpeed: 1.5,
    prerequisites: [],
    unlockLevel: 1,
    skillPointCost: 1
  },

  // Tier 2: Advanced rogue techniques
  shadow_step: {
    id: 'shadow_step',
    name: 'Shadow Step',
    tree: 'rogue',
    tier: 2,
    manaCost: 0,
    staminaCost: 30,
    cooldown: 7.0,
    duration: 0,
    damage: 60,
    element: ELEMENT.DARK,
    aoe: false,
    range: 200,
    description: 'Teleport behind target enemy and strike. Guaranteed critical hit. Assassin core ability.',
    effect: 'teleport_backstab',
    guaranteedCrit: true,
    critMultiplier: 2.5,
    prerequisites: ['backstab'],
    unlockLevel: 5,
    skillPointCost: 2
  },

  fan_of_knives: {
    id: 'fan_of_knives',
    name: 'Fan of Knives',
    tree: 'rogue',
    tier: 2,
    manaCost: 0,
    staminaCost: 35,
    cooldown: 8.0,
    duration: 0,
    damage: 45,
    element: ELEMENT.PHYSICAL,
    aoe: true,
    range: 180,
    description: 'Throw knives in a cone, hitting all enemies. 8 knives, each with independent crit chance.',
    effect: 'cone_knife_attack',
    knifeCount: 8,
    coneAngle: 90,
    prerequisites: ['poison_blade'],
    unlockLevel: 5,
    skillPointCost: 2
  },

  smoke_bomb: {
    id: 'smoke_bomb',
    name: 'Smoke Bomb',
    tree: 'rogue',
    tier: 2,
    manaCost: 0,
    staminaCost: 40,
    cooldown: 15.0,
    duration: 4.0,
    damage: 0,
    element: ELEMENT.DARK,
    aoe: true,
    range: 150,
    description: 'Vanish in smoke, becoming invisible for 4 seconds. Break on attack. Perfect escape.',
    effect: 'stealth_invisibility',
    breakOnAttack: true,
    prerequisites: ['quick_step'],
    unlockLevel: 5,
    skillPointCost: 2
  },

  // Tier 3: Ultimate rogue abilities
  death_mark: {
    id: 'death_mark',
    name: 'Death Mark',
    tree: 'rogue',
    tier: 3,
    manaCost: 0,
    staminaCost: 50,
    cooldown: 20.0,
    duration: 0,
    damage: 250,
    element: ELEMENT.DARK,
    aoe: false,
    range: 100,
    description: 'Mark target for death. Massive single-target damage. Guaranteed critical strike. Boss killer.',
    effect: 'execute_attack',
    guaranteedCrit: true,
    critMultiplier: 3.0,
    bonusDamageOnLowHp: 1.5,
    prerequisites: ['backstab', 'shadow_step'],
    unlockLevel: 12,
    skillPointCost: 3
  },

  shadow_clone: {
    id: 'shadow_clone',
    name: 'Shadow Clone',
    tree: 'rogue',
    tier: 3,
    manaCost: 0,
    staminaCost: 60,
    cooldown: 45.0,
    duration: 15.0,
    damage: 0,
    element: ELEMENT.DARK,
    aoe: false,
    range: 0,
    description: 'Create a clone that mimics your attacks at 60% damage. Draws enemy aggro. Lasts 15 seconds.',
    effect: 'summon_clone',
    cloneDamage: 0.6,
    cloneHealth: 200,
    prerequisites: ['smoke_bomb', 'fan_of_knives'],
    unlockLevel: 12,
    skillPointCost: 3
  },

  master_thief: {
    id: 'master_thief',
    name: 'Master Thief',
    tree: 'rogue',
    tier: 3,
    manaCost: 0,
    staminaCost: 0,
    cooldown: 0,
    duration: 0,
    damage: 0,
    element: ELEMENT.PHYSICAL,
    aoe: false,
    range: 0,
    description: 'Passive: 40% better loot drops, 25% increased gold, and 20% chance to steal enemy items on hit.',
    effect: 'passive_loot_bonus',
    lootBonus: 1.4,
    goldBonus: 1.25,
    stealChance: 0.2,
    passive: true,
    prerequisites: ['poison_blade', 'quick_step'],
    unlockLevel: 12,
    skillPointCost: 3
  }
};

// Ability system utilities
const ABILITY_SYSTEM = {
  // Check if player can unlock ability
  canUnlockAbility(abilityId, unlockedAbilities, playerLevel) {
    const ability = ABILITY_DEFS[abilityId];
    if (!ability) return false;

    // Check level requirement
    if (playerLevel < ability.unlockLevel) return false;

    // Check if already unlocked
    if (unlockedAbilities.includes(abilityId)) return false;

    // Check prerequisites
    for (let prereq of ability.prerequisites) {
      if (!unlockedAbilities.includes(prereq)) return false;
    }

    return true;
  },

  // Get skill point cost for ability tier
  getAbilityCost(tier) {
    const costs = [0, 1, 2, 3]; // tier 0-3
    return costs[tier] || 0;
  },

  // Calculate total passive bonuses from skill tree
  getPassiveBonuses(tree, playerLevel, unlockedAbilities) {
    const treeData = SKILL_TREES[tree];
    if (!treeData) return {};

    const bonuses = { ...treeData.passive_bonuses.base };

    // Add per-level bonuses
    for (let stat in treeData.passive_bonuses.per_level) {
      const perLevel = treeData.passive_bonuses.per_level[stat];
      if (typeof perLevel === 'number' && perLevel < 1) {
        bonuses[stat] = (bonuses[stat] || 0) + (perLevel * playerLevel);
      } else {
        bonuses[stat] = (bonuses[stat] || 1) * Math.pow(perLevel, playerLevel);
      }
    }

    // Add passive ability bonuses
    for (let abilityId of unlockedAbilities) {
      const ability = ABILITY_DEFS[abilityId];
      if (ability && ability.passive && ability.tree === tree) {
        if (ability.regenBonus) bonuses.mana_regen = (bonuses.mana_regen || 1) * ability.regenBonus;
        if (ability.resistAll) bonuses.resist_all = (bonuses.resist_all || 0) + ability.resistAll;
        if (ability.spellDamageBonus) bonuses.spell_damage = (bonuses.spell_damage || 1) * ability.spellDamageBonus;
        if (ability.damageBonus) bonuses.damage = (bonuses.damage || 1) * ability.damageBonus;
        if (ability.lootBonus) bonuses.loot = (bonuses.loot || 1) * ability.lootBonus;
        if (ability.goldBonus) bonuses.gold = (bonuses.gold || 1) * ability.goldBonus;
        if (ability.effectValue) bonuses.low_hp_buff = ability.effectValue;
      }
    }

    return bonuses;
  },

  // Get all abilities for a tree sorted by tier
  getTreeAbilities(tree) {
    const abilities = [];
    for (let id in ABILITY_DEFS) {
      if (ABILITY_DEFS[id].tree === tree) {
        abilities.push(ABILITY_DEFS[id]);
      }
    }
    return abilities.sort((a, b) => a.tier - b.tier);
  },

  // Calculate ability damage with player stats
  calculateAbilityDamage(ability, playerStats) {
    let damage = ability.damage || 0;

    // Apply damage multiplier
    if (ability.damageMultiplier) {
      damage *= ability.damageMultiplier;
    }

    // Apply stat bonuses
    if (ability.tree === 'warrior' && playerStats.melee_damage) {
      damage *= playerStats.melee_damage;
    } else if (ability.tree === 'mage' && playerStats.spell_damage) {
      damage *= playerStats.spell_damage;
    } else if (ability.tree === 'rogue' && playerStats.damage) {
      damage *= playerStats.damage;
    }

    // Critical strike chance and multiplier
    let critChance = playerStats.crit_chance || 0;
    if (ability.bonusCrit) critChance += ability.bonusCrit;
    if (ability.guaranteedCrit) critChance = 1.0;

    if (Math.random() < critChance) {
      const critMult = ability.critMultiplier || 2.0;
      damage *= critMult;
    }

    return Math.floor(damage);
  },

  // Get cooldown with reduction
  getAbilityCooldown(ability, playerStats) {
    let cooldown = ability.cooldown || 0;
    const reduction = playerStats.cooldown_reduction || 0;
    return cooldown * (1 - reduction);
  }
};

// === data/lore.js ===
// lore.js - Story, NPC dialogue, choices, and multiple endings for Depths of the Abyss
// Depends on: constants.js, utils.js

// Lore entries discovered throughout the game - tells the story of the Abyss
const LORE = [
  {
    floor: 1,
    id: 'entry_001',
    title: 'The Sealed Gate',
    text: 'The ancient seal has weakened. Something stirs in the depths below, calling to those foolish enough to listen. The gate that has held for a thousand years now cracks.',
    discovered: false,
    category: 'history'
  },
  {
    floor: 2,
    id: 'entry_002',
    title: 'First Descent',
    text: 'Many have descended before you, seeking glory or answers. None have returned. Their bones now guard the halls they sought to conquer.',
    discovered: false,
    category: 'warning'
  },
  {
    floor: 3,
    id: 'entry_003',
    title: 'The Old Sage',
    text: 'A wise hermit has made camp here. He speaks of ancient gods and forgotten prisons. "Turn back," he warns, "before you learn what lies below."',
    discovered: false,
    category: 'npc'
  },
  {
    floor: 5,
    id: 'entry_004',
    title: 'The Grave Warden',
    text: 'The first guardian has fallen. But you sense this is merely the beginning. The Abyss tests all who enter, and you have passed only the first trial.',
    discovered: false,
    category: 'boss'
  },
  {
    floor: 6,
    id: 'entry_005',
    title: 'Fungal Corruption',
    text: 'The fungus here is not natural. It feeds on death and spreads like a plague. The mycelia whisper secrets to those who listen too closely.',
    discovered: false,
    category: 'environment'
  },
  {
    floor: 7,
    id: 'entry_006',
    title: 'Network of Minds',
    text: 'The mushrooms are connected, a single consciousness spread across millions of fruiting bodies. It remembers every death in these caverns.',
    discovered: false,
    category: 'mystery'
  },
  {
    floor: 8,
    id: 'entry_007',
    title: 'The Lost Knight',
    text: 'You meet a warrior who came before. "I defeated the Warden," he says, "but the King broke me. Each floor grows harder. Each boss more terrible."',
    discovered: false,
    category: 'npc'
  },
  {
    floor: 10,
    id: 'entry_008',
    title: 'Mycelium King',
    text: 'The fungal hivemind had a leader, and you have destroyed it. Yet you wonder: can a network ever truly die? Already new spores spread in the darkness.',
    discovered: false,
    category: 'boss'
  },
  {
    floor: 11,
    id: 'entry_009',
    title: 'Descent into Fire',
    text: 'Heat rises from below. The stone itself glows with inner fire. You are approaching the heart of a volcano, or something far worse.',
    discovered: false,
    category: 'environment'
  },
  {
    floor: 12,
    id: 'entry_010',
    title: 'Ancient Forges',
    text: 'These were once halls of creation where legendary weapons were forged. Now only demons and fire remain, guarding secrets best forgotten.',
    discovered: false,
    category: 'history'
  },
  {
    floor: 13,
    id: 'entry_011',
    title: 'The Witch',
    text: 'A mysterious figure offers you power through dark rituals. "Help me," she pleads, "and I will grant you strength to face what lies ahead." But at what cost?',
    discovered: false,
    category: 'npc'
  },
  {
    floor: 15,
    id: 'entry_012',
    title: 'Infernal Colossus',
    text: 'The titan of flame has fallen. The fires dim, but you feel the heat of something deeper still. The true depths await below the molten stone.',
    discovered: false,
    category: 'boss'
  },
  {
    floor: 16,
    id: 'entry_013',
    title: 'Eternal Winter',
    text: 'The cold here defies nature. Time itself seems frozen. Crystals of ice preserve the dead in perfect stillness, waiting for something.',
    discovered: false,
    category: 'environment'
  },
  {
    floor: 17,
    id: 'entry_014',
    title: 'Time Stands Still',
    text: 'The deeper you go, the slower time flows. Seconds stretch to minutes. You age not, but the world above continues without you.',
    discovered: false,
    category: 'mystery'
  },
  {
    floor: 18,
    id: 'entry_015',
    title: 'Forbidden Knowledge',
    text: 'A scholar frozen in time offers you truth. "The Abyss is a prison," he reveals, "built to contain a god that refused to die. You walk the halls of its tomb."',
    discovered: false,
    category: 'npc'
  },
  {
    floor: 20,
    id: 'entry_016',
    title: 'Glacial Sovereign',
    text: 'The ice queen has shattered. With her defeat, time flows again. But you realize now that each guardian was a lock, and you have been opening them all.',
    discovered: false,
    category: 'boss'
  },
  {
    floor: 21,
    id: 'entry_017',
    title: 'The Void Beyond',
    text: 'You have passed beyond ice, fire, earth and flesh. This is the void between realities. The spaces where things that should not be wait in eternal darkness.',
    discovered: false,
    category: 'environment'
  },
  {
    floor: 22,
    id: 'entry_018',
    title: 'Truth of the Prison',
    text: 'The ancient god was not evil, only too powerful. When it refused mortality, the old gods sealed it here, in layers of elemental guardians and temporal barriers.',
    discovered: false,
    category: 'revelation'
  },
  {
    floor: 23,
    id: 'entry_019',
    title: 'The Final Choice',
    text: 'The Watcher appears. "You can seal the prison anew," it offers, "or take the god\'s power for yourself. But know this: either choice will change you forever."',
    discovered: false,
    category: 'npc'
  },
  {
    floor: 24,
    id: 'entry_020',
    title: 'The Last Guardian',
    text: 'Only one barrier remains. Beyond it lies the imprisoned god, still alive after millennia. It knows you are coming. It has been waiting for someone strong enough.',
    discovered: false,
    category: 'warning'
  },
  {
    floor: 25,
    id: 'entry_021',
    title: 'The Abyss Incarnate',
    text: 'You stand before a being beyond comprehension. It is not evil, not good. It simply IS. And it asks: "Why have you come? To destroy me? To free me? To become me?"',
    discovered: false,
    category: 'boss'
  }
];

// NPC dialogue trees with branching conversations and tutorial information
const NPC_DIALOGUES = {
  old_sage: {
    npcId: 'old_sage',
    name: 'Old Sage',
    floor: 3,
    portrait: 'sage',
    color: '#9370DB',
    greeting: 'Ah, another soul drawn to the depths. Sit, rest. Let me share what little wisdom I have.',
    dialogueTree: {
      start: {
        text: 'I have camped here for many years, guiding those who will listen. Most do not. They rush to their doom below.',
        responses: [
          { text: 'Can you teach me how to survive?', next: 'tutorial', effect: null },
          { text: 'What lies in the depths?', next: 'lore', effect: null },
          { text: 'How do I get stronger?', next: 'progression', effect: null },
          { text: 'I must press on.', next: 'farewell', effect: null }
        ]
      },
      tutorial: {
        text: 'Listen well to these instructions. Controls are simple but mastery takes time. WASD to move, mouse to aim, left click to attack. Space to dodge - timing is everything. Press I for inventory, K for skills. Watch your stamina - fighting recklessly will get you killed.',
        responses: [
          { text: 'Tell me about combat.', next: 'combat_tutorial', effect: null },
          { text: 'What about items and equipment?', next: 'items_tutorial', effect: null },
          { text: 'Thanks, I understand.', next: 'start', effect: null }
        ]
      },
      combat_tutorial: {
        text: 'Every weapon has range, speed, and stamina cost. Fast weapons let you dodge more but deal less damage. Slow weapons hit hard but leave you exposed. Learn enemy patterns - each has behaviors you can exploit. Combo attacks for bonus damage. Chain critical strikes for a multiplier.',
        responses: [
          { text: 'How do I defeat bosses?', next: 'boss_tutorial', effect: null },
          { text: 'What about difficulty?', next: 'difficulty_tutorial', effect: null },
          { text: 'Got it. What else?', next: 'tutorial', effect: null }
        ]
      },
      items_tutorial: {
        text: 'Loot drops from enemies and chests. Equip weapons and armor to grow stronger. Higher rarity means better stats - common, uncommon, rare, epic, legendary. Upgrade items at campfires. Save consumables for boss fights - you will need them.',
        responses: [
          { text: 'Tell me about abilities.', next: 'ability_tutorial', effect: null },
          { text: 'Anything else I should know?', next: 'tutorial', effect: null }
        ]
      },
      ability_tutorial: {
        text: 'Unlock skills by leveling up and spending skill points. Three paths: Warrior for power, Mage for magic, Rogue for speed. Each tier requires previous abilities. Choose wisely - you cannot unlock everything. Passive abilities always active. Active abilities use mana or stamina.',
        responses: [
          { text: 'What is the best build?', next: 'build_advice', effect: null },
          { text: 'Thanks for the help.', next: 'start', effect: null }
        ]
      },
      boss_tutorial: {
        text: 'Every fifth floor has a boss. They are stronger than anything before them. Multi-phase fights - tactics change as their health drops. Learn their patterns. Use the environment. Elite enemies appear randomly with better stats and loot. Mini-bosses guard key areas.',
        responses: [
          { text: 'How do I know the difficulty?', next: 'difficulty_tutorial', effect: null },
          { text: 'I am ready.', next: 'start', effect: null }
        ]
      },
      difficulty_tutorial: {
        text: 'The Abyss scales in difficulty. Easy floors ease you in. Medium tests your skills. Hard demands mastery. Elite enemies have enhanced stats. Deeper floors spawn tougher opponents. Adapt your strategy or perish.',
        responses: [
          { text: 'Understood.', next: 'start', effect: null }
        ]
      },
      build_advice: {
        text: 'No perfect path exists. Warriors survive through strength. Mages control with range and power. Rogues excel with speed and precision. Hybrid builds are possible but master one tree first. Adapt to your play style.',
        responses: [
          { text: 'Thanks for the advice.', next: 'start', effect: null }
        ]
      },
      lore: {
        text: 'These depths were once a temple, then a tomb, now a prison. Sealed within is a god that refused to die when the age of gods ended. Four guardians lock the way. You have already begun breaking the seals.',
        responses: [
          { text: 'Can the god be killed?', next: 'god_question', effect: null },
          { text: 'Tell me something else.', next: 'start', effect: null }
        ]
      },
      god_question: {
        text: 'Perhaps. Or perhaps it can only be imprisoned again. Or perhaps... you will make a different choice when the time comes.',
        responses: [
          { text: 'Cryptic as always.', next: 'start', effect: null }
        ]
      },
      progression: {
        text: 'Defeat enemies for experience. Level up to grow stronger and unlock new abilities. Better loot drops from elite enemies and bosses. Upgrade your equipment. Learn your skill tree. Only through power can you face what awaits below.',
        responses: [
          { text: 'Anything else?', next: 'start', effect: null }
        ]
      },
      farewell: {
        text: 'Then go. May your blade stay sharp and your will unbroken. I will be here if you return... if you can return.',
        responses: []
      }
    }
  },

  lost_knight: {
    npcId: 'lost_knight',
    name: 'Lost Knight',
    floor: 8,
    portrait: 'knight',
    color: '#C0C0C0',
    greeting: 'Another warrior descends. Good. The Abyss hungers for strong souls.',
    dialogueTree: {
      start: {
        text: 'I came here seeking glory. I defeated the Grave Warden easily. The Mycelium King... it broke me. I barely survived. Now I camp here, too wounded to continue, too proud to retreat.',
        responses: [
          { text: 'Tell me about the bosses.', next: 'bosses', effect: null },
          { text: 'What happened to you?', next: 'story', effect: null },
          { text: 'Can I help you?', next: 'help', effect: null },
          { text: 'I will avenge you.', next: 'farewell', effect: null }
        ]
      },
      bosses: {
        text: 'Each boss guards a seal. The Warden is a warrior like us - honorable, predictable. The King is chaos incarnate, splitting and reforming. Beyond lies the Colossus of flame - massive and unstoppable. Then the Sovereign of ice - beautiful and merciless. Finally... the god itself.',
        responses: [
          { text: 'Any advice for fighting them?', next: 'boss_advice', effect: null },
          { text: 'What else should I know?', next: 'start', effect: null }
        ]
      },
      boss_advice: {
        text: 'Learn their phases. Bosses grow desperate as they weaken - more dangerous but more vulnerable. Save your best abilities for phase transitions. Stock consumables. Upgrade everything you can. And never, ever give up mid-fight.',
        responses: [
          { text: 'I won\'t fail.', next: 'start', effect: null }
        ]
      },
      story: {
        text: 'I was arrogant. I thought my strength enough. The King taught me humility through pain. Its spores infected my mind, showed me visions of futures that might be. I am... not the same.',
        responses: [
          { text: 'You survived. That is what matters.', next: 'comfort', effect: 'buff_knight_morale' },
          { text: 'Weakness has no place here.', next: 'harsh', effect: null }
        ]
      },
      comfort: {
        text: 'Thank you. Your words mean more than you know. Here, take this. It may help you where I failed.',
        responses: [
          { text: 'I will use it well.', next: 'start', effect: 'receive_knight_gift' }
        ]
      },
      harsh: {
        text: 'Perhaps you are right. Perhaps I deserve my fate. Go then. May you prove stronger than I.',
        responses: [
          { text: 'I will.', next: 'farewell', effect: null }
        ]
      },
      help: {
        text: 'There is nothing you can do. My wounds run deeper than flesh. Continue your descent. Finish what I could not.',
        responses: [
          { text: 'I understand.', next: 'start', effect: null }
        ]
      },
      farewell: {
        text: 'Go. Prove that honor and strength still mean something in this cursed place.',
        responses: []
      }
    }
  },

  witch_of_spores: {
    npcId: 'witch_of_spores',
    name: 'Witch of Spores',
    floor: 13,
    portrait: 'witch',
    color: '#8B4789',
    greeting: 'Ah, a strong soul approaches. Perfect. I have need of such strength.',
    dialogueTree: {
      start: {
        text: 'I study the dark arts, seeking power to break the seals myself. But I lack the physical might. Help me gather reagents from the flame demons, and I will grant you forbidden power.',
        responses: [
          { text: 'What kind of power?', next: 'power', effect: null },
          { text: 'Why should I trust you?', next: 'trust', effect: null },
          { text: 'I will help you.', next: 'accept', effect: 'accept_witch_quest' },
          { text: 'I want no part of dark magic.', next: 'refuse', effect: 'refuse_witch_quest' }
        ]
      },
      power: {
        text: 'I can craft elixirs that enhance your abilities beyond natural limits. Strength, speed, resilience. I can enchant your weapons with dark fire. I know rituals to steal life from your enemies.',
        responses: [
          { text: 'That sounds dangerous.', next: 'danger', effect: null },
          { text: 'I accept your offer.', next: 'accept', effect: 'accept_witch_quest' },
          { text: 'No. I refuse.', next: 'refuse', effect: 'refuse_witch_quest' }
        ]
      },
      trust: {
        text: 'Trust? In the Abyss? How naive. I offer power, nothing more. Whether you use it for good or ill is your concern. But know that what awaits below will not hesitate to use every advantage against you.',
        responses: [
          { text: 'You make a fair point.', next: 'start', effect: null },
          { text: 'I still do not trust you.', next: 'distrust', effect: null }
        ]
      },
      danger: {
        text: 'All true power is dangerous. The question is whether you are strong enough to wield it without being consumed. Are you?',
        responses: [
          { text: 'I am. I will help.', next: 'accept', effect: 'accept_witch_quest' },
          { text: 'No. Too risky.', next: 'refuse', effect: 'refuse_witch_quest' }
        ]
      },
      accept: {
        text: 'Excellent. Bring me ember dust and dark crystals from the depths ahead. Return victorious, and I will fulfill my promise. This is the path to power.',
        responses: [
          { text: 'It shall be done.', next: 'farewell_help', effect: 'start_dark_path' }
        ]
      },
      refuse: {
        text: 'So be it. Face the flames unprepared then. Do not come crying to me when the Colossus burns you to ash. Fool.',
        responses: [
          { text: 'I will take my chances.', next: 'farewell_refuse', effect: 'start_light_path' }
        ]
      },
      distrust: {
        text: 'Your loss. Remember this moment when you face the guardians below and realize you lack the strength to win.',
        responses: [
          { text: 'We shall see.', next: 'farewell_refuse', effect: 'start_light_path' }
        ]
      },
      farewell_help: {
        text: 'Go. Embrace the darkness. It is the only way to survive what comes next.',
        responses: []
      },
      farewell_refuse: {
        text: 'Pathetic. Leave my sight.',
        responses: []
      }
    }
  },

  frozen_scholar: {
    npcId: 'frozen_scholar',
    name: 'Frozen Scholar',
    floor: 18,
    portrait: 'scholar',
    color: '#87CEEB',
    greeting: 'Finally. Someone who can hear me. I have waited so long...',
    dialogueTree: {
      start: {
        text: 'I came here centuries ago to study the prison. The ice preserved me, trapped me in a single moment. Now you have broken the Sovereign\'s hold, and I can speak again. You must know the truth.',
        responses: [
          { text: 'Tell me everything.', next: 'truth', effect: null },
          { text: 'What truth?', next: 'truth', effect: null },
          { text: 'I do not have time for this.', next: 'hasty', effect: null }
        ]
      },
      truth: {
        text: 'The god below is not evil. When the age of divinity ended, most gods accepted mortality and faded. This one refused. The remaining gods built this prison - four guardians, four seals, four elements. You have broken three.',
        responses: [
          { text: 'What happens when I break the fourth?', next: 'fourth_seal', effect: null },
          { text: 'Can the god be reasoned with?', next: 'reasoning', effect: null },
          { text: 'Should I stop?', next: 'should_stop', effect: null }
        ]
      },
      fourth_seal: {
        text: 'The god will be free to offer you a choice. Seal it again and save the world above. Destroy it and end its existence forever. Absorb its power and become something new. Or... there may be other paths. The scholar in me wants to know what you will choose.',
        responses: [
          { text: 'What would you choose?', next: 'scholar_choice', effect: null },
          { text: 'I will decide when the time comes.', next: 'future_choice', effect: null }
        ]
      },
      reasoning: {
        text: 'It has had millennia to think. To rage. To accept. To despair. What you find below will be beyond human understanding. But yes, it can communicate. It will try to sway you.',
        responses: [
          { text: 'I will listen with an open mind.', next: 'open_mind', effect: 'accept_knowledge' },
          { text: 'I will not be swayed.', next: 'closed_mind', effect: 'reject_knowledge' }
        ]
      },
      should_stop: {
        text: 'You cannot stop. The seals are breaking whether you continue or not. Your battles have weakened them all. The only question is whether you face what emerges prepared or unprepared.',
        responses: [
          { text: 'Then I press on.', next: 'continue', effect: null }
        ]
      },
      scholar_choice: {
        text: 'I would study it. Learn from it. But I am just a scholar, frozen in time. You are a warrior with the strength to reshape reality. The choice is yours alone.',
        responses: [
          { text: 'I understand.', next: 'future_choice', effect: null }
        ]
      },
      open_mind: {
        text: 'Wisdom. Take this knowledge with you. It may save you... or doom you. Either way, you will face the truth with eyes open.',
        responses: [
          { text: 'Thank you.', next: 'farewell_knowledge', effect: 'gain_forbidden_knowledge' }
        ]
      },
      closed_mind: {
        text: 'Stubbornness. Or perhaps wisdom. Sometimes ignorance is safer than knowledge. Go then, unburdened by doubt.',
        responses: [
          { text: 'Farewell.', next: 'farewell_ignorance', effect: null }
        ]
      },
      hasty: {
        text: 'Then go. Rush to your fate. But do not say you were not warned.',
        responses: []
      },
      future_choice: {
        text: 'Wise. Trust your instincts when the moment comes. They have brought you this far.',
        responses: [
          { text: 'I will.', next: 'farewell_knowledge', effect: null }
        ]
      },
      continue: {
        text: 'Then go. Face the Abyss. And may whatever you find there grant you the ending you deserve.',
        responses: [
          { text: 'I am ready.', next: 'farewell_knowledge', effect: null }
        ]
      },
      farewell_knowledge: {
        text: 'Good luck. You will need it. The void awaits.',
        responses: []
      },
      farewell_ignorance: {
        text: 'Go. Face your destiny unprepared. I cannot stop you.',
        responses: []
      }
    }
  },

  the_watcher: {
    npcId: 'the_watcher',
    name: 'The Watcher',
    floor: 23,
    portrait: 'watcher',
    color: '#4B0082',
    greeting: 'You have come far. But the true test lies ahead.',
    dialogueTree: {
      start: {
        text: 'I am the Watcher. I observe all who descend. I watched you break the seals, defeat the guardians, grow in power. Now you stand at the threshold. One floor remains. One choice awaits.',
        responses: [
          { text: 'What choice?', next: 'choice', effect: null },
          { text: 'Who are you really?', next: 'identity', effect: null },
          { text: 'I am ready to face the god.', next: 'ready', effect: null }
        ]
      },
      choice: {
        text: 'When you defeat the god - if you defeat it - you must choose its fate. Seal the prison anew and restore the old order. Absorb its power and become the new god. Show mercy and free it. Or destroy it utterly and end its existence.',
        responses: [
          { text: 'What are the consequences?', next: 'consequences', effect: null },
          { text: 'Which should I choose?', next: 'guidance', effect: null },
          { text: 'I will decide in the moment.', next: 'no_choice_yet', effect: null }
        ]
      },
      identity: {
        text: 'I am the first to descend. The first to face the god. I chose to watch, to wait, to guide those who come after. I am the price of balance. Forever between worlds.',
        responses: [
          { text: 'That sounds lonely.', next: 'lonely', effect: null },
          { text: 'What did you see when you faced the god?', next: 'watcher_vision', effect: null }
        ]
      },
      ready: {
        text: 'Confidence. Good. You will need it. But be warned - the god will test you in ways the guardians never could. It will offer you everything you desire. It will show you futures that could be.',
        responses: [
          { text: 'I will not be swayed.', next: 'strong_will', effect: null },
          { text: 'What did it offer you?', next: 'watcher_offer', effect: null }
        ]
      },
      consequences: {
        text: 'Seal it: the world is safe but unchanged. Absorb it: you gain ultimate power but lose your humanity. Free it: chaos, but also potential for something new. Destroy it: permanent victory, but the death of divinity itself.',
        responses: [
          { text: 'All paths have prices.', next: 'wisdom', effect: null },
          { text: 'There must be a right answer.', next: 'right_answer', effect: null }
        ]
      },
      guidance: {
        text: 'I cannot tell you. This choice defines you. I chose my path. The knight who came before chose his. The witch chose hers. You must choose yours.',
        responses: [
          { text: 'I understand.', next: 'no_choice_yet', effect: null }
        ]
      },
      lonely: {
        text: 'Yes. But necessary. Someone must remember. Someone must guide. That burden is mine.',
        responses: [
          { text: 'Thank you for your sacrifice.', next: 'gratitude', effect: null }
        ]
      },
      watcher_vision: {
        text: 'I saw myself as god. I saw the world burning. I saw endless possibilities. And I chose none of them. I chose to watch, to ensure others would have the choice I could not make.',
        responses: [
          { text: 'A noble sacrifice.', next: 'gratitude', effect: null }
        ]
      },
      strong_will: {
        text: 'Perhaps. We shall see. Many have said the same. All were tested. All were changed.',
        responses: [
          { text: 'I am different.', next: 'confidence', effect: null },
          { text: 'You may be right.', next: 'humility', effect: null }
        ]
      },
      watcher_offer: {
        text: 'It offered me everything. Power. Knowledge. The ability to reshape reality. And I saw the cost. I chose to refuse all paths and forge my own.',
        responses: [
          { text: 'Inspiring.', next: 'gratitude', effect: null }
        ]
      },
      wisdom: {
        text: 'Exactly. There is no perfect choice. Only the choice that is right for you, in that moment, with the knowledge you have.',
        responses: [
          { text: 'I will remember that.', next: 'farewell', effect: 'watcher_blessing' }
        ]
      },
      right_answer: {
        text: 'There is no right answer. Only your answer. Trust yourself.',
        responses: [
          { text: 'I will try.', next: 'farewell', effect: null }
        ]
      },
      gratitude: {
        text: 'Thank you. Few understand. Go now. Face your destiny. And may you find the ending you seek.',
        responses: [
          { text: 'Farewell.', next: 'farewell', effect: 'watcher_blessing' }
        ]
      },
      confidence: {
        text: 'Confidence will serve you well. But remain humble. Pride has destroyed stronger warriors than you.',
        responses: [
          { text: 'Noted.', next: 'farewell', effect: null }
        ]
      },
      humility: {
        text: 'Wisdom. Hold onto that humility. It will serve you when power tempts.',
        responses: [
          { text: 'I will.', next: 'farewell', effect: 'watcher_blessing' }
        ]
      },
      no_choice_yet: {
        text: 'Fair enough. Face the god first. Survive. Then decide. That is wisdom.',
        responses: [
          { text: 'Thank you.', next: 'farewell', effect: null }
        ]
      },
      farewell: {
        text: 'This is goodbye. Whatever you choose, know that I will watch. I will remember. Go. Complete your journey.',
        responses: []
      }
    }
  }
};

// Story choice tracking for multiple endings
const STORY_CHOICES = {
  witch_quest: {
    floor: 13,
    id: 'witch_quest',
    description: 'Help the Witch of Spores or refuse her dark magic',
    choices: ['help_witch', 'refuse_witch', 'betray_witch'],
    default: 'refuse_witch',
    value: 'refuse_witch'
  },
  knowledge_choice: {
    floor: 18,
    id: 'knowledge_choice',
    description: 'Accept or reject the Frozen Scholar\'s forbidden knowledge',
    choices: ['accept_knowledge', 'reject_knowledge'],
    default: 'reject_knowledge',
    value: 'reject_knowledge'
  },
  final_choice: {
    floor: 23,
    id: 'final_choice',
    description: 'Decide the fate of the imprisoned god',
    choices: ['seal_god', 'absorb_power', 'free_god', 'destroy_god'],
    default: null,
    value: null
  },
  boss_mercy: {
    floor: 25,
    id: 'boss_mercy',
    description: 'Show mercy or destroy the Abyss Incarnate',
    choices: ['show_mercy', 'destroy_utterly', 'negotiate'],
    default: null,
    value: null
  }
};

// Five distinct endings based on player choices throughout the game
const ENDINGS = {
  sealed_gate: {
    id: 'sealed_gate',
    name: 'The Sealed Gate',
    category: 'good',
    requirements: {
      final_choice: 'seal_god',
      witch_quest: 'refuse_witch',
      boss_mercy: 'show_mercy'
    },
    title: 'VICTORY: The Prison Holds',
    description: 'You have sealed the god once more. The Abyss is locked.',
    epilogue: 'You emerge from the depths, changed but whole. The seals hold stronger than before, reinforced by your will. The world above continues, safe and unaware of how close it came to ending. You saved everyone, and no one will ever know. Perhaps that is the truest victory.',
    flavorText: 'The gate is sealed. The world is safe. You have won.',
    endingType: 'victory'
  },

  new_god: {
    id: 'new_god',
    name: 'The New God',
    category: 'neutral',
    requirements: {
      final_choice: 'absorb_power',
      knowledge_choice: 'accept_knowledge'
    },
    title: 'VICTORY: Ascension',
    description: 'You have absorbed the divine power. You are no longer mortal.',
    epilogue: 'The power flows into you, transforming every cell. You are no longer human, no longer bound by mortality or time. You seal yourself in the Abyss willingly, becoming the new guardian. The prison needs a warden, and you are now eternal. You conquered the Abyss by becoming it. Congratulations, god.',
    flavorText: 'You have achieved victory over death itself. But at what cost?',
    endingType: 'victory'
  },

  dark_lord: {
    id: 'dark_lord',
    name: 'The Dark Lord',
    category: 'evil',
    requirements: {
      final_choice: 'absorb_power',
      witch_quest: 'help_witch',
      boss_mercy: 'destroy_utterly'
    },
    title: 'VICTORY(?): The Abyss Rises',
    description: 'You have taken the power for yourself and rejected mercy.',
    epilogue: 'The divine power corrupts as it empowers. You emerge not as a savior but as a conqueror. The world above will bow or burn. You escaped the Abyss, but the Abyss did not escape you. You have won everything and lost yourself. The new age of darkness begins with your first step into the light.',
    flavorText: 'You escaped the Abyss. But at what cost to the world?',
    endingType: 'victory'
  },

  martyr: {
    id: 'martyr',
    name: 'The Martyr',
    category: 'heroic',
    requirements: {
      final_choice: 'destroy_god',
      boss_mercy: 'destroy_utterly'
    },
    title: 'ULTIMATE VICTORY: The Final Sacrifice',
    description: 'You have destroyed the god utterly, ending divinity itself.',
    epilogue: 'To destroy a god, you must give everything. The power released in the god\'s death consumes you as well. The Abyss collapses, the prison unmade, the divine erased from reality. You die, but your sacrifice ends the threat forever. Generations to come will never know your name, never face what you faced, never have to make the choice you made. Congratulations. You saved them all.',
    flavorText: 'Ultimate victory requires ultimate sacrifice. You are the hero the world needed.',
    endingType: 'victory'
  },

  eternal_watcher: {
    id: 'eternal_watcher',
    name: 'The Eternal Watcher',
    category: 'balanced',
    requirements: {
      final_choice: 'free_god',
      knowledge_choice: 'accept_knowledge',
      boss_mercy: 'negotiate'
    },
    title: 'GAME COMPLETE: A New Beginning',
    description: 'You have freed the god and forged a new covenant.',
    epilogue: 'You and the god make a pact. It will not interfere with the mortal world, and you will ensure it keeps its word. Like the Watcher before you, you choose a third path - not seal, not absorb, not destroy, but coexist. You remain in the Abyss, eternal guardian of an eternal being. The depths become your home. Ending. And beginning.',
    flavorText: 'The game is complete. The cycle continues. The watch begins anew.',
    endingType: 'ending'
  }
};

// Utility functions for story system
const STORY_SYSTEM = {
  // Record player choice
  recordChoice(choiceId, value) {
    if (STORY_CHOICES[choiceId]) {
      STORY_CHOICES[choiceId].value = value;
    }
  },

  // Get player choice
  getChoice(choiceId) {
    return STORY_CHOICES[choiceId]?.value || STORY_CHOICES[choiceId]?.default;
  },

  // Check if ending requirements are met
  checkEnding(endingId) {
    const ending = ENDINGS[endingId];
    if (!ending || !ending.requirements) return false;

    for (let choiceId in ending.requirements) {
      const required = ending.requirements[choiceId];
      const actual = STORY_SYSTEM.getChoice(choiceId);
      if (actual !== required) return false;
    }

    return true;
  },

  // Determine which ending the player gets
  determineEnding() {
    // Check endings in priority order
    const priority = ['martyr', 'dark_lord', 'new_god', 'eternal_watcher', 'sealed_gate'];

    for (let endingId of priority) {
      if (STORY_SYSTEM.checkEnding(endingId)) {
        return ENDINGS[endingId];
      }
    }

    // Default ending if nothing matches
    return ENDINGS.sealed_gate;
  },

  // Unlock lore entry
  unlockLore(floor) {
    const entry = LORE.find(l => l.floor === floor);
    if (entry) {
      entry.discovered = true;
      return entry;
    }
    return null;
  },

  // Get all discovered lore
  getDiscoveredLore() {
    return LORE.filter(l => l.discovered);
  },

  // Get lore completion percentage
  getLoreCompletion() {
    const total = LORE.length;
    const discovered = LORE.filter(l => l.discovered).length;
    return Math.floor((discovered / total) * 100);
  }
};

// === world/tilemap.js ===
// tilemap.js  Tile rendering and collision for Depths of the Abyss
// Depends on: G (state), STATE, TILE_SIZE, FLOOR_THEMES, getFloorTheme() from constants.js
// Depends on: Util from utils.js

// Tile type constants
const TILE_VOID = 0;
const TILE_FLOOR = 1;
const TILE_WALL = 2;
const TILE_DOOR = 3;
const TILE_STAIRS_DOWN = 4;
const TILE_STAIRS_UP = 5;
const TILE_CAMPFIRE = 6;
const TILE_CHEST = 7;
const TILE_TRAP = 8;
const TILE_WATER = 9;
const TILE_BOSS_GATE = 10;

const TileMap = {
    tiles: [],
    width: 0,
    height: 0,
    rooms: [],
    decor: [], // Cached decorations per tile
    chests: [], // Track chest states {x, y, opened}
    traps: [], // Track trap states {x, y, triggered}

    init: function(width, height) {
        this.width = width;
        this.height = height;
        this.tiles = [];
        this.decor = [];
        this.rooms = [];
        this.chests = [];
        this.traps = [];

        for (let y = 0; y < height; y++) {
            this.tiles[y] = [];
            this.decor[y] = [];
            for (let x = 0; x < width; x++) {
                this.tiles[y][x] = TILE_VOID;
                this.decor[y][x] = null;
            }
        }
    },

    setTile: function(x, y, type) {
        if (x < 0 || x >= this.width || y < 0 || y >= this.height) return;
        this.tiles[y][x] = type;

        // Track special tiles
        if (type === TILE_CHEST) {
            if (!this.chests.find(c => c.x === x && c.y === y)) {
                this.chests.push({x, y, opened: false});
            }
        } else if (type === TILE_TRAP) {
            if (!this.traps.find(t => t.x === x && t.y === y)) {
                this.traps.push({x, y, triggered: false});
            }
        }
    },

    getTile: function(x, y) {
        if (x < 0 || x >= this.width || y < 0 || y >= this.height) return TILE_VOID;
        return this.tiles[y][x];
    },

    isWalkable: function(x, y) {
        const tile = this.getTile(x, y);
        return tile === TILE_FLOOR || tile === TILE_DOOR ||
               tile === TILE_STAIRS_DOWN || tile === TILE_STAIRS_UP ||
               tile === TILE_CAMPFIRE || tile === TILE_TRAP || tile === TILE_WATER;
    },

    isSolid: function(x, y) {
        const tile = this.getTile(x, y);
        return tile === TILE_VOID || tile === TILE_WALL || tile === TILE_BOSS_GATE;
    },

    pixelToTile: function(px, py) {
        return {
            x: Math.floor(px / TILE_SIZE),
            y: Math.floor(py / TILE_SIZE)
        };
    },

    tileToPixel: function(tx, ty) {
        return {
            x: tx * TILE_SIZE,
            y: ty * TILE_SIZE
        };
    },

    render: function(ctx, camera) {
        const bounds = camera.getViewBounds();
        const startX = Math.max(0, Math.floor(bounds.left / TILE_SIZE));
        const startY = Math.max(0, Math.floor(bounds.top / TILE_SIZE));
        const endX = Math.min(this.width - 1, Math.ceil(bounds.right / TILE_SIZE));
        const endY = Math.min(this.height - 1, Math.ceil(bounds.bottom / TILE_SIZE));

        const theme = getFloorTheme(G.currentFloor);

        for (let y = startY; y <= endY; y++) {
            for (let x = startX; x <= endX; x++) {
                const tile = this.tiles[y][x];
                const px = x * TILE_SIZE;
                const py = y * TILE_SIZE;

                // Skip void
                if (tile === TILE_VOID) continue;

                // Base tile rendering
                ctx.fillStyle = this.getTileColor(tile, theme);
                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);

                // Special rendering per tile type
                switch(tile) {
                    case TILE_WALL:
                        this.renderWall(ctx, px, py, theme);
                        break;
                    case TILE_DOOR:
                        this.renderDoor(ctx, px, py, theme);
                        break;
                    case TILE_STAIRS_DOWN:
                        this.renderStairs(ctx, px, py, theme, true);
                        break;
                    case TILE_STAIRS_UP:
                        this.renderStairs(ctx, px, py, theme, false);
                        break;
                    case TILE_CAMPFIRE:
                        this.renderCampfire(ctx, px, py);
                        break;
                    case TILE_CHEST:
                        this.renderChest(ctx, px, py, x, y);
                        break;
                    case TILE_TRAP:
                        this.renderTrap(ctx, px, py, x, y);
                        break;
                    case TILE_WATER:
                        this.renderWater(ctx, px, py);
                        break;
                    case TILE_BOSS_GATE:
                        this.renderBossGate(ctx, px, py);
                        break;
                }
            }
        }
    },

    getTileColor: function(tile, theme) {
        switch(tile) {
            case TILE_FLOOR: return theme.floor;
            case TILE_WALL: return theme.wall;
            case TILE_DOOR: return theme.door;
            case TILE_STAIRS_DOWN: return theme.floor;
            case TILE_STAIRS_UP: return theme.floor;
            case TILE_CAMPFIRE: return theme.floor;
            case TILE_CHEST: return theme.floor;
            case TILE_TRAP: return theme.floor;
            case TILE_WATER: return '#1a3d5c';
            case TILE_BOSS_GATE: return '#4a0000';
            default: return '#000';
        }
    },

    renderWall: function(ctx, px, py, theme) {
        // 3D effect: darker top, lighter bottom
        const grad = ctx.createLinearGradient(px, py, px, py + TILE_SIZE);
        grad.addColorStop(0, this.darkenColor(theme.wall, 0.7));
        grad.addColorStop(1, this.lightenColor(theme.wall, 1.2));
        ctx.fillStyle = grad;
        ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);

        // Edge highlight
        ctx.strokeStyle = this.lightenColor(theme.wall, 1.3);
        ctx.lineWidth = 1;
        ctx.strokeRect(px + 0.5, py + 0.5, TILE_SIZE - 1, TILE_SIZE - 1);
    },

    renderDoor: function(ctx, px, py, theme) {
        // Door frame
        ctx.fillStyle = theme.door;
        ctx.fillRect(px + 4, py, TILE_SIZE - 8, TILE_SIZE);
        ctx.fillRect(px, py + 4, TILE_SIZE, TILE_SIZE - 8);

        // Frame outline
        ctx.strokeStyle = this.darkenColor(theme.door, 0.8);
        ctx.lineWidth = 2;
        ctx.strokeRect(px + 2, py + 2, TILE_SIZE - 4, TILE_SIZE - 4);
    },

    renderStairs: function(ctx, px, py, theme, down) {
        const centerX = px + TILE_SIZE / 2;
        const centerY = py + TILE_SIZE / 2;
        const arrowSize = 8;

        ctx.fillStyle = down ? '#888' : '#666';
        ctx.beginPath();
        if (down) {
            // Down arrow
            ctx.moveTo(centerX, centerY + arrowSize);
            ctx.lineTo(centerX - arrowSize, centerY - arrowSize);
            ctx.lineTo(centerX + arrowSize, centerY - arrowSize);
        } else {
            // Up arrow
            ctx.moveTo(centerX, centerY - arrowSize);
            ctx.lineTo(centerX - arrowSize, centerY + arrowSize);
            ctx.lineTo(centerX + arrowSize, centerY + arrowSize);
        }
        ctx.closePath();
        ctx.fill();
    },

    renderCampfire: function(ctx, px, py) {
        const centerX = px + TILE_SIZE / 2;
        const centerY = py + TILE_SIZE / 2;

        // Animated flicker using G.time
        const flicker = Math.sin(G.time * 5) * 0.3 + 0.7;
        const radius = 6 + Math.sin(G.time * 8) * 2;

        // Fire glow
        const grad = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius * 2);
        grad.addColorStop(0, 'rgba(255, 180, 0, ' + (flicker * 0.8) + ')');
        grad.addColorStop(0.5, 'rgba(255, 100, 0, ' + (flicker * 0.4) + ')');
        grad.addColorStop(1, 'rgba(255, 50, 0, 0)');
        ctx.fillStyle = grad;
        ctx.fillRect(centerX - radius * 2, centerY - radius * 2, radius * 4, radius * 4);

        // Fire core
        ctx.fillStyle = flicker > 0.8 ? '#ffff00' : '#ff8800';
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
        ctx.fill();
    },

    renderChest: function(ctx, px, py, tx, ty) {
        const chest = this.chests.find(c => c.x === tx && c.y === ty);
        const opened = chest ? chest.opened : false;

        if (opened) {
            // Just render as floor after opened
            return;
        }

        // Golden chest
        const grad = ctx.createLinearGradient(px, py, px, py + TILE_SIZE);
        grad.addColorStop(0, '#ffdd00');
        grad.addColorStop(0.5, '#ffaa00');
        grad.addColorStop(1, '#ff8800');
        ctx.fillStyle = grad;
        ctx.fillRect(px + 6, py + 8, TILE_SIZE - 12, TILE_SIZE - 10);

        // Highlight
        ctx.strokeStyle = '#ffff88';
        ctx.lineWidth = 1;
        ctx.strokeRect(px + 7, py + 9, TILE_SIZE - 14, TILE_SIZE - 12);
    },

    renderTrap: function(ctx, px, py, tx, ty) {
        const trap = this.traps.find(t => t.x === tx && t.y === ty);
        const triggered = trap ? trap.triggered : false;
        const hasTrapSight = G.player && G.player.trapSight;

        if (!triggered && !hasTrapSight) {
            // Invisible until triggered or player has trap sight
            return;
        }

        // Red warning pattern
        ctx.strokeStyle = triggered ? '#ff0000' : '#aa0000';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(px + TILE_SIZE / 2, py + 4);
        ctx.lineTo(px + TILE_SIZE - 4, py + TILE_SIZE - 4);
        ctx.lineTo(px + 4, py + TILE_SIZE - 4);
        ctx.closePath();
        ctx.stroke();
    },

    renderWater: function(ctx, px, py) {
        // Animated wave effect using sin
        const wave1 = Math.sin(G.time * 2 + px * 0.1) * 0.1 + 0.9;
        const wave2 = Math.cos(G.time * 3 + py * 0.1) * 0.1 + 0.9;
        const brightness = wave1 * wave2;

        const baseColor = [26, 61, 92]; // #1a3d5c
        const r = Math.floor(baseColor[0] * brightness);
        const g = Math.floor(baseColor[1] * brightness);
        const b = Math.floor(baseColor[2] * brightness);

        ctx.fillStyle = 'rgb(' + r + ',' + g + ',' + b + ')';
        ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);

        // Reflection shimmer
        const shimmer = Math.sin(G.time * 4 + px * 0.2 + py * 0.2);
        if (shimmer > 0.7) {
            ctx.fillStyle = 'rgba(100, 150, 200, 0.3)';
            ctx.fillRect(px + 8, py + 8, TILE_SIZE - 16, TILE_SIZE - 16);
        }
    },

    renderBossGate: function(ctx, px, py) {
        // Red pulsing glow
        const pulse = Math.sin(G.time * 3) * 0.3 + 0.7;

        const grad = ctx.createRadialGradient(
            px + TILE_SIZE / 2, py + TILE_SIZE / 2, 0,
            px + TILE_SIZE / 2, py + TILE_SIZE / 2, TILE_SIZE
        );
        grad.addColorStop(0, 'rgba(255, 0, 0, ' + (pulse * 0.6) + ')');
        grad.addColorStop(1, 'rgba(74, 0, 0, 1)');
        ctx.fillStyle = grad;
        ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);

        // Gate bars
        ctx.strokeStyle = '#ff0000';
        ctx.lineWidth = 3;
        for (let i = 0; i < 4; i++) {
            ctx.beginPath();
            ctx.moveTo(px + i * 8 + 4, py);
            ctx.lineTo(px + i * 8 + 4, py + TILE_SIZE);
            ctx.stroke();
        }
    },

    renderDecor: function(ctx, camera) {
        const bounds = camera.getViewBounds();
        const startX = Math.max(0, Math.floor(bounds.left / TILE_SIZE));
        const startY = Math.max(0, Math.floor(bounds.top / TILE_SIZE));
        const endX = Math.min(this.width - 1, Math.ceil(bounds.right / TILE_SIZE));
        const endY = Math.min(this.height - 1, Math.ceil(bounds.bottom / TILE_SIZE));

        for (let y = startY; y <= endY; y++) {
            for (let x = startX; x <= endX; x++) {
                const decor = this.decor[y][x];
                if (!decor) continue;

                const px = x * TILE_SIZE;
                const py = y * TILE_SIZE;

                ctx.globalAlpha = 0.3;
                ctx.fillStyle = '#333';

                switch(decor.type) {
                    case 'crack':
                        // Floor crack
                        ctx.beginPath();
                        ctx.moveTo(px + decor.x1, py + decor.y1);
                        ctx.lineTo(px + decor.x2, py + decor.y2);
                        ctx.strokeStyle = '#222';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        break;
                    case 'moss':
                        // Moss patch
                        ctx.fillStyle = '#1a3d1a';
                        ctx.fillRect(px + decor.x, py + decor.y, decor.w, decor.h);
                        break;
                    case 'bones':
                        // Small bones
                        ctx.fillStyle = '#888';
                        ctx.fillRect(px + decor.x, py + decor.y, 4, 2);
                        ctx.fillRect(px + decor.x + 2, py + decor.y + 3, 2, 4);
                        break;
                }

                ctx.globalAlpha = 1;
            }
        }
    },

    interact: function(tx, ty) {
        const tile = this.getTile(tx, ty);

        switch(tile) {
            case TILE_CHEST:
                return this.openChest(tx, ty);
            case TILE_CAMPFIRE:
                return this.useCampfire(tx, ty);
            case TILE_STAIRS_DOWN:
                return this.descendStairs();
            case TILE_TRAP:
                return this.triggerTrap(tx, ty);
        }

        return null;
    },

    openChest: function(tx, ty) {
        const chest = this.chests.find(c => c.x === tx && c.y === ty);
        if (!chest || chest.opened) return null;

        chest.opened = true;
        this.setTile(tx, ty, TILE_FLOOR); // Becomes floor after opening

        return {type: 'chest', x: tx, y: ty};
    },

    useCampfire: function(tx, ty) {
        return {type: 'campfire', x: tx, y: ty};
    },

    descendStairs: function() {
        return {type: 'stairs_down'};
    },

    triggerTrap: function(tx, ty) {
        const trap = this.traps.find(t => t.x === tx && t.y === ty);
        if (!trap) return null;

        if (!trap.triggered) {
            trap.triggered = true;
            return {type: 'trap', x: tx, y: ty, damage: 10 + G.currentFloor * 2};
        }

        return null;
    },

    darkenColor: function(color, factor) {
        const hex = color.replace('#', '');
        const r = Math.floor(parseInt(hex.substring(0, 2), 16) * factor);
        const g = Math.floor(parseInt(hex.substring(2, 4), 16) * factor);
        const b = Math.floor(parseInt(hex.substring(4, 6), 16) * factor);
        return '#' + this.toHex(r) + this.toHex(g) + this.toHex(b);
    },

    lightenColor: function(color, factor) {
        const hex = color.replace('#', '');
        const r = Math.min(255, Math.floor(parseInt(hex.substring(0, 2), 16) * factor));
        const g = Math.min(255, Math.floor(parseInt(hex.substring(2, 4), 16) * factor));
        const b = Math.min(255, Math.floor(parseInt(hex.substring(4, 6), 16) * factor));
        return '#' + this.toHex(r) + this.toHex(g) + this.toHex(b);
    },

    toHex: function(n) {
        const hex = n.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
    }
};

// === world/dungeon-gen.js ===
// dungeon-gen.js  Procedural dungeon generation for Depths of the Abyss
// Depends on: G, STATE, TILE_SIZE, FLOOR_THEMES from constants.js
// Depends on: Util from utils.js
// Depends on: ENEMY_TYPES, BOSS_DEFS, SPAWN_TABLES from data/enemies.js
// Depends on: LOOT_TABLES from data/items.js
// Depends on: TileMap and tile constants from world/tilemap.js

// BSP (Binary Space Partition) node for procedural dungeon generation
class BSPNode {
    constructor(x, y, w, h) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.left = null;
        this.right = null;
        this.room = null; // {x, y, w, h}
    }

    // Recursive split for procedural generation
    split(minSize, rng) {
        if (this.left || this.right) return false;

        // Determine split direction based on aspect ratio with some randomness
        const splitH = rng() > 0.5;

        if (this.w > this.h && this.w / this.h >= 1.25) {
            // Wide room, split vertically
            return this.splitVertical(minSize, rng);
        } else if (this.h > this.w && this.h / this.w >= 1.25) {
            // Tall room, split horizontally
            return this.splitHorizontal(minSize, rng);
        } else {
            // Square-ish, random split
            return splitH ? this.splitHorizontal(minSize, rng) : this.splitVertical(minSize, rng);
        }
    }

    splitHorizontal(minSize, rng) {
        if (this.h < minSize * 2) return false;

        const split = Math.floor(minSize + rng() * (this.h - minSize * 2));
        this.left = new BSPNode(this.x, this.y, this.w, split);
        this.right = new BSPNode(this.x, this.y + split, this.w, this.h - split);
        return true;
    }

    splitVertical(minSize, rng) {
        if (this.w < minSize * 2) return false;

        const split = Math.floor(minSize + rng() * (this.w - minSize * 2));
        this.left = new BSPNode(this.x, this.y, split, this.h);
        this.right = new BSPNode(this.x + split, this.y, this.w - split, this.h);
        return true;
    }

    getLeaves() {
        if (!this.left && !this.right) return [this];

        const leaves = [];
        if (this.left) leaves.push(...this.left.getLeaves());
        if (this.right) leaves.push(...this.right.getLeaves());
        return leaves;
    }

    getRoom() {
        return this.room;
    }
}

const Dungeon = {
    root: null,
    spawnPoint: {x: 0, y: 0},
    stairsDown: {x: 0, y: 0},
    campfire: {x: 0, y: 0},
    bossGate: {x: 0, y: 0},
    bossArena: null,

    generate: function(floor, seed) {
        // Procedural dungeon generation pipeline
        // Uses seeded RNG for deterministic generation
        Util.seedRandom(seed);
        const rng = Math.random;

        // Calculate map size based on floor (scales up)
        const baseW = 80;
        const baseH = 60;
        const scale = 1 + Math.floor(floor / 10) * 0.25;
        const mapW = Math.floor(baseW * scale);
        const mapH = Math.floor(baseH * scale);

        // Initialize tilemap
        TileMap.init(mapW, mapH);

        // 1. BSP Generation
        const minLeafSize = 8;
        this.root = new BSPNode(1, 1, mapW - 2, mapH - 2);
        this.splitBSP(this.root, minLeafSize, rng);

        // 2. Carve rooms in leaves
        const leaves = this.root.getLeaves();
        const rooms = [];
        for (let i = 0; i < leaves.length; i++) {
            const leaf = leaves[i];
            const room = this.carveRoom(leaf, rng);
            leaf.room = room;
            rooms.push(room);
        }
        TileMap.rooms = rooms;

        // 3. Connect rooms with corridors
        this.connectRooms(this.root, rng);

        // 4. Place doors at corridor-room junctions
        this.placeDoors(rooms);

        // 5. Special rooms
        this.placeSpecialTiles(rooms, floor, rng);

        // 6. Decoration pass
        this.placeDecorations(rooms, floor, rng);

        return {
            spawn: this.spawnPoint,
            stairs: this.stairsDown,
            campfire: this.campfire
        };
    },

    splitBSP: function(node, minSize, rng) {
        // Recursive procedural BSP splitting
        if (node.split(minSize, rng)) {
            this.splitBSP(node.left, minSize, rng);
            this.splitBSP(node.right, minSize, rng);
        }
    },

    carveRoom: function(leaf, rng) {
        // Procedural room carving within BSP leaf
        const minW = 4;
        const minH = 4;
        const maxW = leaf.w - 1;
        const maxH = leaf.h - 1;

        const w = Math.floor(minW + rng() * (maxW - minW));
        const h = Math.floor(minH + rng() * (maxH - minH));
        const x = leaf.x + Math.floor(rng() * (leaf.w - w));
        const y = leaf.y + Math.floor(rng() * (leaf.h - h));

        // Fill room with floor, surround with walls
        for (let ry = y - 1; ry <= y + h; ry++) {
            for (let rx = x - 1; rx <= x + w; rx++) {
                if (rx === x - 1 || rx === x + w || ry === y - 1 || ry === y + h) {
                    if (TileMap.getTile(rx, ry) === TILE_VOID) {
                        TileMap.setTile(rx, ry, TILE_WALL);
                    }
                } else {
                    TileMap.setTile(rx, ry, TILE_FLOOR);
                }
            }
        }

        return {x, y, w, h};
    },

    connectRooms: function(node, rng) {
        // Recursively connect sibling rooms with L-shaped corridors (procedural)
        if (!node.left || !node.right) return;

        this.connectRooms(node.left, rng);
        this.connectRooms(node.right, rng);

        const leftRooms = node.left.getLeaves().map(l => l.room).filter(r => r);
        const rightRooms = node.right.getLeaves().map(l => l.room).filter(r => r);

        if (leftRooms.length === 0 || rightRooms.length === 0) return;

        const leftRoom = leftRooms[Math.floor(rng() * leftRooms.length)];
        const rightRoom = rightRooms[Math.floor(rng() * rightRooms.length)];

        const leftCenter = {
            x: leftRoom.x + Math.floor(leftRoom.w / 2),
            y: leftRoom.y + Math.floor(leftRoom.h / 2)
        };
        const rightCenter = {
            x: rightRoom.x + Math.floor(rightRoom.w / 2),
            y: rightRoom.y + Math.floor(rightRoom.h / 2)
        };

        // L-shaped corridor
        if (rng() > 0.5) {
            this.carveCorridor(leftCenter.x, leftCenter.y, rightCenter.x, leftCenter.y);
            this.carveCorridor(rightCenter.x, leftCenter.y, rightCenter.x, rightCenter.y);
        } else {
            this.carveCorridor(leftCenter.x, leftCenter.y, leftCenter.x, rightCenter.y);
            this.carveCorridor(leftCenter.x, rightCenter.y, rightCenter.x, rightCenter.y);
        }
    },

    carveCorridor: function(x1, y1, x2, y2) {
        // Procedural corridor carving
        const minX = Math.min(x1, x2);
        const maxX = Math.max(x1, x2);
        const minY = Math.min(y1, y2);
        const maxY = Math.max(y1, y2);

        for (let x = minX; x <= maxX; x++) {
            for (let y = minY; y <= maxY; y++) {
                if (TileMap.getTile(x, y) === TILE_VOID || TileMap.getTile(x, y) === TILE_WALL) {
                    TileMap.setTile(x, y, TILE_FLOOR);
                }
                // Add walls around corridor
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        if (dx === 0 && dy === 0) continue;
                        const nx = x + dx;
                        const ny = y + dy;
                        if (TileMap.getTile(nx, ny) === TILE_VOID) {
                            TileMap.setTile(nx, ny, TILE_WALL);
                        }
                    }
                }
            }
        }
    },

    placeDoors: function(rooms) {
        // Place doors at corridor-room junctions
        for (let i = 0; i < rooms.length; i++) {
            const room = rooms[i];

            // Check perimeter for corridor connections
            for (let x = room.x; x < room.x + room.w; x++) {
                this.tryPlaceDoor(x, room.y - 1);
                this.tryPlaceDoor(x, room.y + room.h);
            }
            for (let y = room.y; y < room.y + room.h; y++) {
                this.tryPlaceDoor(room.x - 1, y);
                this.tryPlaceDoor(room.x + room.w, y);
            }
        }
    },

    tryPlaceDoor: function(x, y) {
        if (TileMap.getTile(x, y) !== TILE_WALL) return;

        // Check if this wall connects a room to a corridor
        let floorCount = 0;
        const neighbors = [
            TileMap.getTile(x - 1, y),
            TileMap.getTile(x + 1, y),
            TileMap.getTile(x, y - 1),
            TileMap.getTile(x, y + 1)
        ];

        for (let i = 0; i < neighbors.length; i++) {
            if (neighbors[i] === TILE_FLOOR) floorCount++;
        }

        if (floorCount >= 2) {
            TileMap.setTile(x, y, TILE_DOOR);
        }
    },

    placeSpecialTiles: function(rooms, floor, rng) {
        if (rooms.length === 0) return;

        // Spawn point: center of first room (or stairs up on floor > 1)
        const firstRoom = rooms[0];
        this.spawnPoint = {
            x: (firstRoom.x + Math.floor(firstRoom.w / 2)) * TILE_SIZE + TILE_SIZE / 2,
            y: (firstRoom.y + Math.floor(firstRoom.h / 2)) * TILE_SIZE + TILE_SIZE / 2
        };

        if (floor > 1) {
            const tx = firstRoom.x + Math.floor(firstRoom.w / 2);
            const ty = firstRoom.y + Math.floor(firstRoom.h / 2);
            TileMap.setTile(tx, ty, TILE_STAIRS_UP);
        }

        // Stairs down: farthest room from spawn
        let maxDist = 0;
        let stairsRoom = rooms[rooms.length - 1];
        for (let i = 0; i < rooms.length; i++) {
            const room = rooms[i];
            const cx = (room.x + Math.floor(room.w / 2)) * TILE_SIZE;
            const cy = (room.y + Math.floor(room.h / 2)) * TILE_SIZE;
            const dist = Util.dist(this.spawnPoint.x, this.spawnPoint.y, cx, cy);
            if (dist > maxDist) {
                maxDist = dist;
                stairsRoom = room;
            }
        }

        const stairsTx = stairsRoom.x + Math.floor(stairsRoom.w / 2);
        const stairsTy = stairsRoom.y + Math.floor(stairsRoom.h / 2);
        TileMap.setTile(stairsTx, stairsTy, TILE_STAIRS_DOWN);
        this.stairsDown = {x: stairsTx, y: stairsTy};

        // Boss floor special handling
        if (floor % 5 === 0) {
            this.generateBossArena(floor, stairsRoom, rng);
        }

        // Campfire: medium-sized room (not first or last)
        if (rooms.length > 2) {
            const campfireRoom = rooms[1 + Math.floor(rng() * (rooms.length - 2))];
            const cfx = campfireRoom.x + Math.floor(campfireRoom.w / 2);
            const cfy = campfireRoom.y + Math.floor(campfireRoom.h / 2);
            TileMap.setTile(cfx, cfy, TILE_CAMPFIRE);
            this.campfire = {x: cfx, y: cfy};
        }

        // Chests: 2-4 in random rooms
        const chestCount = 2 + Math.floor(rng() * 3);
        for (let i = 0; i < chestCount; i++) {
            const room = rooms[Math.floor(rng() * rooms.length)];
            const cx = room.x + 1 + Math.floor(rng() * (room.w - 2));
            const cy = room.y + 1 + Math.floor(rng() * (room.h - 2));
            if (TileMap.getTile(cx, cy) === TILE_FLOOR) {
                TileMap.setTile(cx, cy, TILE_CHEST);
            }
        }

        // Traps: 3-6 in corridors and large rooms
        const trapCount = 3 + Math.floor(rng() * 4);
        for (let i = 0; i < trapCount; i++) {
            const room = rooms[Math.floor(rng() * rooms.length)];
            const tx = room.x + 1 + Math.floor(rng() * (room.w - 2));
            const ty = room.y + 1 + Math.floor(rng() * (room.h - 2));
            if (TileMap.getTile(tx, ty) === TILE_FLOOR) {
                TileMap.setTile(tx, ty, TILE_TRAP);
            }
        }

        // Water pools (Fungal Caverns / Frozen Abyss themes)
        const theme = getFloorTheme(floor);
        if (theme.name === 'Fungal Caverns' || theme.name === 'Frozen Abyss') {
            const poolCount = 1 + Math.floor(rng() * 3);
            for (let i = 0; i < poolCount; i++) {
                const room = rooms[Math.floor(rng() * rooms.length)];
                const poolSize = 2 + Math.floor(rng() * 3);
                const px = room.x + 1 + Math.floor(rng() * (room.w - poolSize - 1));
                const py = room.y + 1 + Math.floor(rng() * (room.h - poolSize - 1));

                for (let dx = 0; dx < poolSize; dx++) {
                    for (let dy = 0; dy < poolSize; dy++) {
                        if (TileMap.getTile(px + dx, py + dy) === TILE_FLOOR) {
                            TileMap.setTile(px + dx, py + dy, TILE_WATER);
                        }
                    }
                }
            }
        }
    },

    generateBossArena: function(floor, stairsRoom, rng) {
        // Create boss arena for boss floors (5, 10, 15, 20, 25)
        const arenaW = 20;
        const arenaH = 15;
        const arenaX = Math.max(2, TileMap.width - arenaW - 2);
        const arenaY = Math.max(2, Math.floor(TileMap.height / 2 - arenaH / 2));

        this.bossArena = {x: arenaX, y: arenaY, w: arenaW, h: arenaH};

        // Carve arena
        for (let y = arenaY - 1; y <= arenaY + arenaH; y++) {
            for (let x = arenaX - 1; x <= arenaX + arenaW; x++) {
                if (x === arenaX - 1 || x === arenaX + arenaW ||
                    y === arenaY - 1 || y === arenaY + arenaH) {
                    TileMap.setTile(x, y, TILE_WALL);
                } else {
                    TileMap.setTile(x, y, TILE_FLOOR);
                }
            }
        }

        // Place boss gate at entrance
        const gateX = arenaX - 1;
        const gateY = arenaY + Math.floor(arenaH / 2);
        TileMap.setTile(gateX, gateY, TILE_BOSS_GATE);
        this.bossGate = {x: gateX, y: gateY};

        // Connect to main dungeon via corridor
        const connectionX = stairsRoom.x + Math.floor(stairsRoom.w / 2);
        const connectionY = stairsRoom.y + Math.floor(stairsRoom.h / 2);
        this.carveCorridor(connectionX, connectionY, gateX - 1, gateY);

        // Place pillars for cover
        const pillarPositions = [
            {x: arenaX + 4, y: arenaY + 4},
            {x: arenaX + arenaW - 5, y: arenaY + 4},
            {x: arenaX + 4, y: arenaY + arenaH - 5},
            {x: arenaX + arenaW - 5, y: arenaY + arenaH - 5}
        ];

        for (let i = 0; i < pillarPositions.length; i++) {
            const pos = pillarPositions[i];
            TileMap.setTile(pos.x, pos.y, TILE_WALL);
            TileMap.setTile(pos.x + 1, pos.y, TILE_WALL);
            TileMap.setTile(pos.x, pos.y + 1, TILE_WALL);
            TileMap.setTile(pos.x + 1, pos.y + 1, TILE_WALL);
        }
    },

    placeDecorations: function(rooms, floor, rng) {
        // Procedural decoration placement
        for (let i = 0; i < rooms.length; i++) {
            const room = rooms[i];
            const decorCount = Math.floor(rng() * 5);

            for (let j = 0; j < decorCount; j++) {
                const dx = room.x + Math.floor(rng() * room.w);
                const dy = room.y + Math.floor(rng() * room.h);

                if (TileMap.getTile(dx, dy) !== TILE_FLOOR) continue;

                const decorType = Math.floor(rng() * 3);
                let decor = null;

                if (decorType === 0) {
                    // Crack
                    decor = {
                        type: 'crack',
                        x1: Math.floor(rng() * TILE_SIZE),
                        y1: Math.floor(rng() * TILE_SIZE),
                        x2: Math.floor(rng() * TILE_SIZE),
                        y2: Math.floor(rng() * TILE_SIZE)
                    };
                } else if (decorType === 1) {
                    // Moss
                    decor = {
                        type: 'moss',
                        x: Math.floor(rng() * (TILE_SIZE - 8)),
                        y: Math.floor(rng() * (TILE_SIZE - 8)),
                        w: 4 + Math.floor(rng() * 6),
                        h: 4 + Math.floor(rng() * 6)
                    };
                } else {
                    // Bones
                    decor = {
                        type: 'bones',
                        x: Math.floor(rng() * (TILE_SIZE - 6)),
                        y: Math.floor(rng() * (TILE_SIZE - 6))
                    };
                }

                TileMap.decor[dy][dx] = decor;
            }
        }
    },

    getSpawnPositions: function(floor, count) {
        // Get valid enemy spawn positions (procedural distribution)
        const positions = [];
        const rooms = TileMap.rooms;

        // Avoid spawn area (first room)
        const spawnTile = TileMap.pixelToTile(this.spawnPoint.x, this.spawnPoint.y);
        const safeRadius = 10;

        let attempts = 0;
        while (positions.length < count && attempts < count * 10) {
            attempts++;

            const room = rooms[Math.floor(Math.random() * rooms.length)];
            const tx = room.x + 1 + Math.floor(Math.random() * (room.w - 2));
            const ty = room.y + 1 + Math.floor(Math.random() * (room.h - 2));

            // Check if tile is walkable and not near spawn
            if (!TileMap.isWalkable(tx, ty)) continue;
            const dist = Util.dist(tx, ty, spawnTile.x, spawnTile.y);
            if (dist < safeRadius) continue;

            // Check if not too close to other spawns
            let tooClose = false;
            for (let i = 0; i < positions.length; i++) {
                const other = positions[i];
                if (Util.dist(tx, ty, other.x, other.y) < 3) {
                    tooClose = true;
                    break;
                }
            }
            if (tooClose) continue;

            positions.push({x: tx, y: ty});
        }

        return positions;
    },

    placeEnemies: function(floor, difficulty) {
        // Procedural enemy placement using spawn tables
        if (!SPAWN_TABLES) return [];

        const table = SPAWN_TABLES[floor] || SPAWN_TABLES[1];
        const baseCount = 8 + floor * 2;
        const difficultyMult = difficulty === 'easy' ? 0.7 : difficulty === 'hard' ? 1.5 : 1;
        const count = Math.floor(baseCount * difficultyMult);

        const positions = this.getSpawnPositions(floor, count);
        const enemies = [];

        for (let i = 0; i < positions.length; i++) {
            const pos = positions[i];
            const roll = Math.random();
            let enemyType = table[0].type;

            // Select enemy type based on spawn weights (procedural)
            let cumulative = 0;
            for (let j = 0; j < table.length; j++) {
                cumulative += table[j].weight;
                if (roll <= cumulative) {
                    enemyType = table[j].type;
                    break;
                }
            }

            enemies.push({
                type: enemyType,
                x: pos.x * TILE_SIZE + TILE_SIZE / 2,
                y: pos.y * TILE_SIZE + TILE_SIZE / 2
            });
        }

        // Place boss on boss floors
        if (floor % 5 === 0 && this.bossArena && BOSS_DEFS) {
            // Find boss for this floor
            let bossType = null;
            for (let bossId in BOSS_DEFS) {
                if (BOSS_DEFS[bossId].floor === floor) {
                    bossType = bossId;
                    break;
                }
            }

            // Fallback to first boss if no match
            if (!bossType) {
                bossType = 'grave_warden';
            }

            const bossX = (this.bossArena.x + Math.floor(this.bossArena.w / 2)) * TILE_SIZE + TILE_SIZE / 2;
            const bossY = (this.bossArena.y + Math.floor(this.bossArena.h / 2)) * TILE_SIZE + TILE_SIZE / 2;

            enemies.push({
                type: bossType,
                x: bossX,
                y: bossY,
                isBoss: true
            });
        }

        return enemies;
    }
};

// === world/fog-of-war.js ===
// fog-of-war.js  Raycasting-based visibility system for Depths of the Abyss
// Depends on: G, TILE_SIZE from constants.js
// Depends on: Util from utils.js
// Depends on: TileMap, TILE_DOOR from world/tilemap.js

const Fog = {
    visible: [],
    revealed: [],
    width: 0,
    height: 0,
    offscreenCanvas: null,
    offscreenCtx: null,

    init: function(w, h) {
        this.width = w;
        this.height = h;
        this.visible = [];
        this.revealed = [];

        for (let y = 0; y < h; y++) {
            this.visible[y] = [];
            this.revealed[y] = [];
            for (let x = 0; x < w; x++) {
                this.visible[y][x] = false;
                this.revealed[y][x] = false;
            }
        }

        // Create offscreen canvas for fog rendering performance
        this.offscreenCanvas = document.createElement('canvas');
        this.offscreenCanvas.width = w * TILE_SIZE;
        this.offscreenCanvas.height = h * TILE_SIZE;
        this.offscreenCtx = this.offscreenCanvas.getContext('2d');
    },

    update: function(px, py, sightRadius) {
        // Clear current visibility
        for (let y = 0; y < this.height; y++) {
            for (let x = 0; x < this.width; x++) {
                this.visible[y][x] = false;
            }
        }

        // Convert player position to tile coords
        const playerTile = TileMap.pixelToTile(px, py);

        // Adjust sight radius based on area/effects
        let radius = sightRadius || 8;

        // Check for void area (reduced sight)
        const theme = getFloorTheme(G.currentFloor);
        if (theme.name === 'The Void') {
            radius = 6;
        }

        // Check for torch item (increased sight)
        if (G.player && G.player.hasTorch) {
            radius = 10;
        }

        // Raycasting: cast rays in all directions
        const angleStep = 1; // 1 degree per ray = 360 rays
        const totalAngles = 360 / angleStep;

        for (let i = 0; i < totalAngles; i++) {
            const angle = (i * angleStep * Math.PI) / 180;
            this.castRay(playerTile.x, playerTile.y, angle, radius);
        }

        // Always mark player tile as visible
        if (playerTile.x >= 0 && playerTile.x < this.width &&
            playerTile.y >= 0 && playerTile.y < this.height) {
            this.visible[playerTile.y][playerTile.x] = true;
            this.revealed[playerTile.y][playerTile.x] = true;
        }
    },

    castRay: function(startX, startY, angle, maxDist) {
        // Bresenham-style raycasting
        const dx = Math.cos(angle);
        const dy = Math.sin(angle);

        for (let d = 0; d <= maxDist; d += 0.5) {
            const x = Math.floor(startX + dx * d);
            const y = Math.floor(startY + dy * d);

            // Out of bounds check
            if (x < 0 || x >= this.width || y < 0 || y >= this.height) break;

            // Mark as visible and revealed
            this.visible[y][x] = true;
            this.revealed[y][x] = true;

            // Stop at solid tiles (walls block vision)
            if (TileMap.isSolid(x, y)) break;

            // Doors block vision unless player is adjacent
            if (TileMap.getTile(x, y) === TILE_DOOR) {
                const distToPlayer = Util.dist(x, y, startX, startY);
                if (distToPlayer > 1.5) break;
            }
        }
    },

    isVisible: function(tx, ty) {
        if (tx < 0 || tx >= this.width || ty < 0 || ty >= this.height) return false;
        return this.visible[ty][tx];
    },

    isRevealed: function(tx, ty) {
        if (tx < 0 || tx >= this.width || ty < 0 || ty >= this.height) return false;
        return this.revealed[ty][tx];
    },

    render: function(ctx, camera) {
        if (!this.offscreenCtx) return;

        const bounds = camera.getViewBounds();
        const startX = Math.max(0, Math.floor(bounds.left / TILE_SIZE));
        const startY = Math.max(0, Math.floor(bounds.top / TILE_SIZE));
        const endX = Math.min(this.width - 1, Math.ceil(bounds.right / TILE_SIZE));
        const endY = Math.min(this.height - 1, Math.ceil(bounds.bottom / TILE_SIZE));

        // Clear offscreen canvas
        this.offscreenCtx.clearRect(
            startX * TILE_SIZE,
            startY * TILE_SIZE,
            (endX - startX + 1) * TILE_SIZE,
            (endY - startY + 1) * TILE_SIZE
        );

        // Render fog to offscreen canvas
        for (let y = startY; y <= endY; y++) {
            for (let x = startX; x <= endX; x++) {
                const px = x * TILE_SIZE;
                const py = y * TILE_SIZE;

                if (!this.revealed[y][x]) {
                    // Unrevealed: fully black
                    this.offscreenCtx.fillStyle = 'rgba(0, 0, 0, 1)';
                    this.offscreenCtx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                } else if (!this.visible[y][x]) {
                    // Revealed but not visible: dark overlay
                    this.offscreenCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    this.offscreenCtx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                } else {
                    // Visible: apply edge smoothing with gradient
                    this.renderFogEdges(x, y, px, py);
                }
            }
        }

        // Draw offscreen canvas to main canvas
        ctx.drawImage(
            this.offscreenCanvas,
            startX * TILE_SIZE,
            startY * TILE_SIZE,
            (endX - startX + 1) * TILE_SIZE,
            (endY - startY + 1) * TILE_SIZE,
            startX * TILE_SIZE,
            startY * TILE_SIZE,
            (endX - startX + 1) * TILE_SIZE,
            (endY - startY + 1) * TILE_SIZE
        );
    },

    renderFogEdges: function(tx, ty, px, py) {
        // Smooth edges between visible and fog using alpha gradients
        const neighbors = [
            this.isVisible(tx - 1, ty),     // left
            this.isVisible(tx + 1, ty),     // right
            this.isVisible(tx, ty - 1),     // up
            this.isVisible(tx, ty + 1),     // down
            this.isVisible(tx - 1, ty - 1), // top-left
            this.isVisible(tx + 1, ty - 1), // top-right
            this.isVisible(tx - 1, ty + 1), // bottom-left
            this.isVisible(tx + 1, ty + 1)  // bottom-right
        ];

        // If all neighbors are visible, no edge
        const allVisible = neighbors.every(n => n);
        if (allVisible) return;

        // If any neighbor is not visible, draw gradient edge
        const anyHidden = neighbors.some(n => !n);
        if (!anyHidden) return;

        // Draw gradients at edges
        const edgeSize = TILE_SIZE / 4;

        // Left edge
        if (!neighbors[0]) {
            const grad = this.offscreenCtx.createLinearGradient(px, py, px + edgeSize, py);
            grad.addColorStop(0, 'rgba(0, 0, 0, 0.3)');
            grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
            this.offscreenCtx.fillStyle = grad;
            this.offscreenCtx.fillRect(px, py, edgeSize, TILE_SIZE);
        }

        // Right edge
        if (!neighbors[1]) {
            const grad = this.offscreenCtx.createLinearGradient(
                px + TILE_SIZE - edgeSize, py,
                px + TILE_SIZE, py
            );
            grad.addColorStop(0, 'rgba(0, 0, 0, 0)');
            grad.addColorStop(1, 'rgba(0, 0, 0, 0.3)');
            this.offscreenCtx.fillStyle = grad;
            this.offscreenCtx.fillRect(px + TILE_SIZE - edgeSize, py, edgeSize, TILE_SIZE);
        }

        // Top edge
        if (!neighbors[2]) {
            const grad = this.offscreenCtx.createLinearGradient(px, py, px, py + edgeSize);
            grad.addColorStop(0, 'rgba(0, 0, 0, 0.3)');
            grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
            this.offscreenCtx.fillStyle = grad;
            this.offscreenCtx.fillRect(px, py, TILE_SIZE, edgeSize);
        }

        // Bottom edge
        if (!neighbors[3]) {
            const grad = this.offscreenCtx.createLinearGradient(
                px, py + TILE_SIZE - edgeSize,
                px, py + TILE_SIZE
            );
            grad.addColorStop(0, 'rgba(0, 0, 0, 0)');
            grad.addColorStop(1, 'rgba(0, 0, 0, 0.3)');
            this.offscreenCtx.fillStyle = grad;
            this.offscreenCtx.fillRect(px, py + TILE_SIZE - edgeSize, TILE_SIZE, edgeSize);
        }
    },

    reset: function() {
        for (let y = 0; y < this.height; y++) {
            for (let x = 0; x < this.width; x++) {
                this.visible[y][x] = false;
                this.revealed[y][x] = false;
            }
        }
    }
};

// === world/lighting.js ===
// lighting.js  Dynamic lighting system for Depths of the Abyss
// Depends on: G, TILE_SIZE from constants.js
// Depends on: Util from utils.js

const Lighting = {
    lights: [],
    darkOverlay: null,
    darkCtx: null,
    nextId: 0,
    playerLight: null,

    init: function(w, h) {
        this.lights = [];
        this.nextId = 0;

        // Create offscreen canvas for darkness overlay
        this.darkOverlay = document.createElement('canvas');
        this.darkOverlay.width = w * TILE_SIZE;
        this.darkOverlay.height = h * TILE_SIZE;
        this.darkCtx = this.darkOverlay.getContext('2d');
    },

    addLight: function(x, y, radius, color, intensity, flicker) {
        const light = {
            id: this.nextId++,
            x: x,
            y: y,
            radius: radius,
            baseRadius: radius,
            color: color || '#ffffff',
            intensity: intensity || 1,
            flicker: flicker || false,
            flickerOffset: Math.random() * Math.PI * 2,
            flickerFreq: 2 + Math.random() * 3,
            type: 'static'
        };

        this.lights.push(light);
        return light.id;
    },

    removeLight: function(id) {
        this.lights = this.lights.filter(l => l.id !== id);
    },

    update: function(dt) {
        // Update flicker animations
        for (let i = 0; i < this.lights.length; i++) {
            const light = this.lights[i];

            if (light.flicker) {
                // Oscillate radius with sin wave
                const t = G.time * light.flickerFreq + light.flickerOffset;
                const flickerAmount = Math.sin(t) * 0.2 + Math.sin(t * 2) * 0.1;
                light.radius = light.baseRadius * (1 + flickerAmount);
            }
        }

        // Update player light position
        if (this.playerLight && G.player) {
            const playerLight = this.lights.find(l => l.id === this.playerLight);
            if (playerLight) {
                playerLight.x = G.player.x;
                playerLight.y = G.player.y;
            }
        }
    },

    render: function(ctx, camera) {
        if (!this.darkCtx) return;

        const bounds = camera.getViewBounds();

        // Fill dark overlay with near-black
        this.darkCtx.fillStyle = 'rgba(0, 0, 0, 0.85)';
        this.darkCtx.fillRect(0, 0, this.darkOverlay.width, this.darkOverlay.height);

        // Apply floor theme ambient tint
        const theme = getFloorTheme(G.currentFloor);
        if (theme.ambient) {
            this.darkCtx.fillStyle = theme.ambient;
            this.darkCtx.globalAlpha = 0.1;
            this.darkCtx.fillRect(0, 0, this.darkOverlay.width, this.darkOverlay.height);
            this.darkCtx.globalAlpha = 1;
        }

        // Cut out holes for lights using destination-out composite
        this.darkCtx.globalCompositeOperation = 'destination-out';

        for (let i = 0; i < this.lights.length; i++) {
            const light = this.lights[i];

            // Skip lights outside viewport
            if (light.x < bounds.left - light.radius * 2 ||
                light.x > bounds.right + light.radius * 2 ||
                light.y < bounds.top - light.radius * 2 ||
                light.y > bounds.bottom + light.radius * 2) {
                continue;
            }

            // Draw radial gradient hole
            const grad = this.darkCtx.createRadialGradient(
                light.x, light.y, 0,
                light.x, light.y, light.radius * TILE_SIZE
            );

            const alpha = light.intensity;
            grad.addColorStop(0, 'rgba(255, 255, 255, ' + alpha + ')');
            grad.addColorStop(0.6, 'rgba(255, 255, 255, ' + (alpha * 0.5) + ')');
            grad.addColorStop(1, 'rgba(255, 255, 255, 0)');

            this.darkCtx.fillStyle = grad;
            this.darkCtx.fillRect(
                light.x - light.radius * TILE_SIZE,
                light.y - light.radius * TILE_SIZE,
                light.radius * TILE_SIZE * 2,
                light.radius * TILE_SIZE * 2
            );
        }

        // Reset composite operation
        this.darkCtx.globalCompositeOperation = 'source-over';

        // Draw colored light glows on top
        for (let i = 0; i < this.lights.length; i++) {
            const light = this.lights[i];

            if (light.color === '#ffffff') continue; // Skip white lights

            // Skip lights outside viewport
            if (light.x < bounds.left - light.radius * 2 ||
                light.x > bounds.right + light.radius * 2 ||
                light.y < bounds.top - light.radius * 2 ||
                light.y > bounds.bottom + light.radius * 2) {
                continue;
            }

            // Draw colored glow
            const grad = this.darkCtx.createRadialGradient(
                light.x, light.y, 0,
                light.x, light.y, light.radius * TILE_SIZE
            );

            const rgb = this.hexToRgb(light.color);
            const alpha = light.intensity * 0.3;

            grad.addColorStop(0, 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + alpha + ')');
            grad.addColorStop(0.6, 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + (alpha * 0.5) + ')');
            grad.addColorStop(1, 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ', 0)');

            this.darkCtx.fillStyle = grad;
            this.darkCtx.fillRect(
                light.x - light.radius * TILE_SIZE,
                light.y - light.radius * TILE_SIZE,
                light.radius * TILE_SIZE * 2,
                light.radius * TILE_SIZE * 2
            );
        }

        // Draw dark overlay to main canvas
        ctx.drawImage(this.darkOverlay, 0, 0);
    },

    createTorchLight: function(x, y) {
        // Wall torch preset
        return this.addLight(x, y, 4, '#ff8800', 0.9, true);
    },

    createCampfireLight: function(x, y) {
        // Campfire preset (larger, warmer)
        return this.addLight(x, y, 6, '#ffaa00', 1.0, true);
    },

    createMagicLight: function(x, y, element) {
        // Colored magic light based on element
        let color = '#ffffff';
        let radius = 5;

        switch(element) {
            case 'ice':
            case 'frost':
                color = '#88ccff';
                break;
            case 'poison':
            case 'toxic':
                color = '#88ff88';
                break;
            case 'void':
            case 'shadow':
                color = '#aa88ff';
                break;
            case 'fire':
            case 'lava':
                color = '#ff4400';
                radius = 6;
                break;
            case 'lightning':
                color = '#ffff00';
                break;
        }

        return this.addLight(x, y, radius, color, 0.8, true);
    },

    createPlayerLight: function() {
        // Dim light that follows player
        if (G.player) {
            this.playerLight = this.addLight(
                G.player.x,
                G.player.y,
                3,
                '#ffffff',
                0.5,
                false
            );
            return this.playerLight;
        }
        return null;
    },

    clear: function() {
        this.lights = [];
        this.nextId = 0;
        this.playerLight = null;
    },

    hexToRgb: function(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : {r: 255, g: 255, b: 255};
    }
};

// === world/camera.js ===
// camera.js  Camera system with smooth follow, shake, zoom for Depths of the Abyss
// Depends on: G, TILE_SIZE from constants.js
// Depends on: Util from utils.js
// Depends on: TileMap from world/tilemap.js

const Camera = {
    x: 0,
    y: 0,
    targetX: 0,
    targetY: 0,
    zoom: 1.0,
    targetZoom: 1.0,
    shakeX: 0,
    shakeY: 0,
    shakeIntensity: 0,
    shakeDuration: 0,
    shakeMaxDuration: 0,
    viewportWidth: 0,
    viewportHeight: 0,
    smoothing: 0.08,

    init: function(canvas) {
        this.viewportWidth = canvas.width;
        this.viewportHeight = canvas.height;
        this.x = 0;
        this.y = 0;
        this.targetX = 0;
        this.targetY = 0;
        this.zoom = 1.0;
        this.targetZoom = 1.0;
        this.shakeX = 0;
        this.shakeY = 0;
        this.shakeIntensity = 0;
        this.shakeDuration = 0;
    },

    follow: function(entity, dt) {
        if (!entity) return;

        // Calculate target position (center entity in viewport)
        this.targetX = entity.x - this.viewportWidth / (2 * this.zoom);
        this.targetY = entity.y - this.viewportHeight / (2 * this.zoom);

        // Clamp to map bounds
        const maxX = TileMap.width * TILE_SIZE - this.viewportWidth / this.zoom;
        const maxY = TileMap.height * TILE_SIZE - this.viewportHeight / this.zoom;

        this.targetX = Util.clamp(this.targetX, 0, Math.max(0, maxX));
        this.targetY = Util.clamp(this.targetY, 0, Math.max(0, maxY));

        // Smooth lerp to target
        this.x = Util.lerp(this.x, this.targetX, this.smoothing);
        this.y = Util.lerp(this.y, this.targetY, this.smoothing);
    },

    shake: function(intensity, duration) {
        this.shakeIntensity = Math.max(this.shakeIntensity, intensity);
        this.shakeDuration = Math.max(this.shakeDuration, duration);
        this.shakeMaxDuration = duration;
    },

    updateShake: function(dt) {
        if (this.shakeDuration <= 0) {
            this.shakeX = 0;
            this.shakeY = 0;
            this.shakeIntensity = 0;
            this.shakeMaxDuration = 0;
            return;
        }

        // Decay shake duration
        this.shakeDuration -= dt;
        if (this.shakeDuration < 0) {
            this.shakeDuration = 0;
        }

        // Linear intensity decay based on remaining duration
        const progress = this.shakeMaxDuration > 0 ? this.shakeDuration / this.shakeMaxDuration : 0;
        const currentIntensity = this.shakeIntensity * progress;

        // Random offset within current intensity range
        this.shakeX = (Math.random() - 0.5) * 2 * currentIntensity;
        this.shakeY = (Math.random() - 0.5) * 2 * currentIntensity;
    },

    setZoom: function(zoom, smooth) {
        zoom = Util.clamp(zoom, 0.5, 2.0);

        if (smooth) {
            this.targetZoom = zoom;
        } else {
            this.zoom = zoom;
            this.targetZoom = zoom;
        }
    },

    updateZoom: function(dt) {
        if (Math.abs(this.zoom - this.targetZoom) > 0.01) {
            this.zoom = Util.lerp(this.zoom, this.targetZoom, 0.1);
        } else {
            this.zoom = this.targetZoom;
        }
    },

    worldToScreen: function(wx, wy) {
        return {
            x: (wx - this.x) * this.zoom + this.shakeX,
            y: (wy - this.y) * this.zoom + this.shakeY
        };
    },

    screenToWorld: function(sx, sy) {
        return {
            x: (sx - this.shakeX) / this.zoom + this.x,
            y: (sy - this.shakeY) / this.zoom + this.y
        };
    },

    isOnScreen: function(wx, wy, margin) {
        margin = margin || 0;
        const viewLeft = this.x - margin;
        const viewRight = this.x + this.viewportWidth / this.zoom + margin;
        const viewTop = this.y - margin;
        const viewBottom = this.y + this.viewportHeight / this.zoom + margin;

        return wx >= viewLeft && wx <= viewRight && wy >= viewTop && wy <= viewBottom;
    },

    getViewBounds: function() {
        return {
            left: this.x,
            top: this.y,
            right: this.x + this.viewportWidth / this.zoom,
            bottom: this.y + this.viewportHeight / this.zoom
        };
    },

    update: function(dt) {
        // Combined update: shake, zoom
        this.updateShake(dt);
        this.updateZoom(dt);
    },

    applyTransform: function(ctx) {
        ctx.save();
        ctx.scale(this.zoom, this.zoom);
        ctx.translate(-this.x + this.shakeX / this.zoom, -this.y + this.shakeY / this.zoom);
    },

    resetTransform: function(ctx) {
        ctx.restore();
    }
};

// === combat/player.js ===
// combat/player.js - Player entity with movement, dodge-roll, stamina, parry, iframes
// Global Player object for Depths of the Abyss

const Player = {
  init() {
    G.player = {
      x: 0, y: 0,
      vx: 0, vy: 0,
      w: 24, h: 24,
      hp: PLAYER_DEFAULTS.hp,
      maxHp: PLAYER_DEFAULTS.maxHp,
      mana: PLAYER_DEFAULTS.mana,
      maxMana: PLAYER_DEFAULTS.maxMana,
      stamina: PLAYER_DEFAULTS.stamina,
      maxStamina: PLAYER_DEFAULTS.maxStamina,
      speed: PLAYER_DEFAULTS.speed,
      attackDmg: PLAYER_DEFAULTS.attackDmg,
      defense: PLAYER_DEFAULTS.defense,
      critChance: PLAYER_DEFAULTS.critChance,
      critMultiplier: PLAYER_DEFAULTS.critMultiplier,
      level: 1,
      xp: 0,
      skillPoints: 0,
      statPoints: 0,
      str: 5, dex: 5, int: 5, vit: 5,
      facing: DIR.DOWN,
      // Combat state
      attacking: false,
      attackTimer: 0,
      attackCooldown: 0,
      dodging: false,
      dodgeTimer: 0,
      dodgeCooldown: 0,
      dodgeDir: 0,
      parrying: false,
      parryTimer: 0,
      parryCooldown: 0,
      parrySuccess: false,
      invincible: false,
      iframeTimer: 0,
      hitFlash: 0,
      knockbackX: 0, knockbackY: 0, knockbackTimer: 0,
      // Equipment
      weapon: generateWeapon(1, RARITY.COMMON),
      armor: {head:null,chest:null,legs:null,boots:null,gloves:null,ring:null,amulet:null},
      // Abilities
      unlockedAbilities: [],
      equippedAbilities: [null,null,null,null],
      abilityCooldowns: {},
      // Status effects
      statusEffects: [],
      // Progression
      inventory: [],
      maxInventory: 20,
      materials: {},
      gold: 0,
      // Stats
      totalDamageDealt: 0,
      totalKills: 0
    };
  },

  update(dt) {
    const p = G.player;

    // Handle dodge-roll movement
    if (p.dodging) {
      // Move at 3x speed during dodge
      const dodgeSpeed = p.speed * 3;
      const dx = DIR_DX[p.dodgeDir] * dodgeSpeed * dt;
      const dy = DIR_DY[p.dodgeDir] * dodgeSpeed * dt;

      // Check tile collision before moving
      if (this.canMoveTo(p.x + dx, p.y)) p.x += dx;
      if (this.canMoveTo(p.x, p.y + dy)) p.y += dy;

      p.dodgeTimer -= dt;
      if (p.dodgeTimer <= 0) {
        p.dodging = false;
        p.invincible = false;
      }
    }
    // Handle knockback
    else if (p.knockbackTimer > 0) {
      p.x += p.knockbackX * dt;
      p.y += p.knockbackY * dt;
      p.knockbackTimer -= dt;
      if (p.knockbackTimer <= 0) {
        p.knockbackX = 0;
        p.knockbackY = 0;
      }
    }
    // Normal movement
    else {
      const movement = Input.getMovement();
      const moveX = movement.x * p.speed * dt;
      const moveY = movement.y * p.speed * dt;

      // Check tile collision and move
      if (moveX !== 0 && this.canMoveTo(p.x + moveX, p.y)) {
        p.x += moveX;
      }
      if (moveY !== 0 && this.canMoveTo(p.x, p.y + moveY)) {
        p.y += moveY;
      }

      // Update facing direction
      if (movement.x !== 0 || movement.y !== 0) {
        if (Math.abs(movement.x) > Math.abs(movement.y)) {
          p.facing = movement.x > 0 ? DIR.RIGHT : DIR.LEFT;
        } else {
          p.facing = movement.y > 0 ? DIR.DOWN : DIR.UP;
        }
      }

      // Stamina regen - faster when standing still
      const staminaRegen = (movement.x === 0 && movement.y === 0) ? 3.0 : 1.0;
      p.stamina = Math.min(p.maxStamina, p.stamina + staminaRegen * dt);
    }

    // Mana regeneration
    p.mana = Math.min(p.maxMana, p.mana + 0.5 * dt);

    // Update attack timers
    if (p.attacking) {
      p.attackTimer -= dt;
      if (p.attackTimer <= 0) {
        p.attacking = false;
      }
    }
    if (p.attackCooldown > 0) {
      p.attackCooldown -= dt;
    }

    // Update dodge cooldown
    if (p.dodgeCooldown > 0) {
      p.dodgeCooldown -= dt;
    }

    // Update parry window
    if (p.parrying) {
      p.parryTimer -= dt;
      if (p.parryTimer <= 0) {
        p.parrying = false;
        p.parrySuccess = false;
      }
    }
    if (p.parryCooldown > 0) {
      p.parryCooldown -= dt;
    }

    // Update invincibility frames
    if (p.invincible && !p.dodging) {
      p.iframeTimer -= dt;
      if (p.iframeTimer <= 0) {
        p.invincible = false;
      }
    }

    // Update status effects
    this.updateStatusEffects(dt);

    // Decay hit flash
    if (p.hitFlash > 0) {
      p.hitFlash -= dt * 5;
      if (p.hitFlash < 0) p.hitFlash = 0;
    }

    // Update combo timer - combo resets after 3 seconds
    if (G.comboTimer > 0) {
      G.comboTimer -= dt;
      if (G.comboTimer <= 0) {
        G.combo = 0;
      }
    }

    // Check tile interactions
    this.checkTileInteractions();
  },

  canMoveTo(x, y) {
    const tileX = Math.floor(x / TILE_SIZE);
    const tileY = Math.floor(y / TILE_SIZE);
    return TileMap.isWalkable(tileX, tileY);
  },

  attack() {
    const p = G.player;

    // Check cooldown
    if (p.attackCooldown > 0) return false;

    // Check weapon
    if (!p.weapon) return false;

    // Check stamina cost
    const staminaCost = p.weapon.staminaCost || 10;
    if (p.stamina < staminaCost) return false;

    // Deduct stamina
    p.stamina -= staminaCost;

    // Set attack state
    p.attacking = true;
    p.attackTimer = p.weapon.attackSpeed || 0.3;
    p.attackCooldown = p.weapon.attackSpeed || 0.3;

    // Play weapon swing sound
    SFX.playSFX('sword_swing');

    // Trigger weapon system
    Weapons.startAttack(p, p.weapon);

    return true;
  },

  dodge() {
    const p = G.player;

    // Check stamina
    const dodgeCost = 20;
    if (p.stamina < dodgeCost) return false;

    // Check cooldown
    if (p.dodgeCooldown > 0) return false;

    // Get movement direction or use facing if standing still
    const movement = Input.getMovement();
    let dodgeDir = p.facing;

    if (movement.x !== 0 || movement.y !== 0) {
      if (Math.abs(movement.x) > Math.abs(movement.y)) {
        dodgeDir = movement.x > 0 ? DIR.RIGHT : DIR.LEFT;
      } else {
        dodgeDir = movement.y > 0 ? DIR.DOWN : DIR.UP;
      }
    }

    // Deduct stamina
    p.stamina -= dodgeCost;

    // Set dodge state
    p.dodging = true;
    p.dodgeTimer = 0.3;
    p.dodgeCooldown = 0.8;
    p.dodgeDir = dodgeDir;

    // Grant invincibility frames during dodge
    p.invincible = true;

    // Play dodge roll sound
    SFX.playSFX('dodge_roll');

    return true;
  },

  parry() {
    const p = G.player;

    // Check cooldown
    if (p.parryCooldown > 0) return false;

    // Check stamina
    const parryCost = 15;
    if (p.stamina < parryCost) return false;

    // Deduct stamina
    p.stamina -= parryCost;

    // Set parry window (0.15s)
    p.parrying = true;
    p.parryTimer = 0.15;
    p.parryCooldown = 1.5;
    p.parrySuccess = false;

    return true;
  },

  takeDamage(amount, element, sourceX, sourceY) {
    const p = G.player;

    // Check invincibility (iframes or dodge)
    if (p.invincible) return;

    // Check parry window
    if (p.parrying) {
      p.parrySuccess = true;
      p.parrying = false;

      // Successful parry - restore stamina and no damage
      p.stamina = Math.min(p.maxStamina, p.stamina + 20);

      // Play parry sound
      SFX.playSFX('parry_success');

      // Spawn floating text
      Combat.spawnFloatingText(p.x, p.y - 20, 'PARRY!', '#FFD700');

      // Camera shake
      Camera.shake(8, 0.2);

      return;
    }

    // Apply defense reduction
    let finalDamage = amount - p.defense;

    // Apply element resistance from armor
    const resistance = this.getElementResistance(element);
    finalDamage *= (1 - resistance);

    // Minimum damage
    finalDamage = Math.max(1, Math.floor(finalDamage));

    // Apply damage
    p.hp -= finalDamage;

    // Flash effect
    p.hitFlash = 0.15;

    // Camera shake
    Camera.shake(5, 0.15);

    // Knockback from source
    if (sourceX !== undefined && sourceY !== undefined) {
      const angle = Util.angle(sourceX, sourceY, p.x, p.y);
      const knockbackForce = 150;
      p.knockbackX = Math.cos(angle) * knockbackForce;
      p.knockbackY = Math.sin(angle) * knockbackForce;
      p.knockbackTimer = 0.15;
    }

    // Grant brief iframes after being hit
    p.invincible = true;
    p.iframeTimer = 0.3;

    // Play hurt sound
    SFX.playSFX('player_hurt');

    // Spawn damage text
    Combat.spawnFloatingText(p.x, p.y - 20, '-' + finalDamage, '#FF4444');

    // Check death
    if (p.hp <= 0) {
      p.hp = 0;
      this.die();
    }
  },

  heal(amount) {
    const p = G.player;
    const oldHp = p.hp;
    p.hp = Math.min(p.maxHp, p.hp + amount);
    const actualHeal = p.hp - oldHp;

    if (actualHeal > 0) {
      SFX.playSFX('player_heal');
      Combat.spawnFloatingText(p.x, p.y - 20, '+' + actualHeal, '#44FF44');
    }
  },

  addXP(amount) {
    const p = G.player;
    p.xp += amount;

    // Check level up
    const xpNeeded = this.getXPForLevel(p.level + 1);
    if (p.xp >= xpNeeded) {
      p.xp -= xpNeeded;
      p.level++;
      p.skillPoints += 2;
      p.statPoints += 5;

      // Restore HP and mana on level up
      p.hp = p.maxHp;
      p.mana = p.maxMana;

      // Play level up sound
      SFX.playSFX('player_levelup');

      // Camera shake
      Camera.shake(10, 0.3);

      // Spawn text
      Combat.spawnFloatingText(p.x, p.y - 30, 'LEVEL UP!', '#FFD700');
    }
  },

  getXPForLevel(level) {
    return Math.floor(100 * Math.pow(1.5, level - 1));
  },

  die() {
    const p = G.player;
    G.gameState = STATE.DEATH;
    SFX.playSFX('player_death');
    Camera.shake(20, 0.5);
  },

  updateStatusEffects(dt) {
    const p = G.player;

    for (let i = p.statusEffects.length - 1; i >= 0; i--) {
      const effect = p.statusEffects[i];
      effect.timer += dt;

      // Tick damage effects
      if ((effect.type === 'poison' || effect.type === 'burn' || effect.type === 'bleed') &&
          effect.timer >= effect.tickInterval) {
        p.hp -= effect.tickDamage;
        effect.timer = 0;
        Combat.spawnFloatingText(p.x, p.y - 10, '-' + effect.tickDamage, '#884488');

        if (p.hp <= 0) {
          p.hp = 0;
          this.die();
        }
      }

      // Remove expired effects
      effect.duration -= dt;
      if (effect.duration <= 0) {
        p.statusEffects.splice(i, 1);
      }
    }
  },

  getElementResistance(element) {
    const p = G.player;
    let resistance = 0;

    // Sum resistance from equipped armor
    for (let slot in p.armor) {
      const item = p.armor[slot];
      if (item && item.resistance && item.resistance[element]) {
        resistance += item.resistance[element];
      }
    }

    return Math.min(0.75, resistance); // Cap at 75%
  },

  checkTileInteractions() {
    const p = G.player;
    const tileX = Math.floor(p.x / TILE_SIZE);
    const tileY = Math.floor(p.y / TILE_SIZE);

    // Check for stairs, campfires, chests, traps, etc.
    // This will be implemented in coordination with tilemap.js
  },

  render(ctx, camera) {
    const p = G.player;
    const screenPos = Camera.worldToScreen(p.x, p.y);

    ctx.save();

    // Draw shadow
    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
    ctx.beginPath();
    ctx.ellipse(screenPos.x, screenPos.y + 8, 10, 4, 0, 0, Math.PI * 2);
    ctx.fill();

    // Apply transparency during dodge
    if (p.dodging) {
      ctx.globalAlpha = 0.5;
    }

    // Flash white when hit
    if (p.hitFlash > 0) {
      ctx.fillStyle = '#FFFFFF';
    } else {
      // Body color based on armor rarity
      const armorColor = this.getArmorColor();
      ctx.fillStyle = armorColor;
    }

    // Draw body (rectangle)
    ctx.fillRect(screenPos.x - 8, screenPos.y - 12, 16, 20);

    // Draw head (circle)
    ctx.beginPath();
    ctx.arc(screenPos.x, screenPos.y - 16, 6, 0, Math.PI * 2);
    ctx.fill();

    // Draw weapon
    if (p.weapon) {
      this.renderWeapon(ctx, screenPos.x, screenPos.y);
    }

    // Draw attack swing arc
    if (p.attacking) {
      Weapons.renderSwing(ctx, p, camera);
    }

    // Draw parry indicator
    if (p.parrying) {
      ctx.strokeStyle = '#FFD700';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(screenPos.x, screenPos.y, 20, 0, Math.PI * 2);
      ctx.stroke();
    }

    ctx.restore();
  },

  renderWeapon(ctx, x, y) {
    const p = G.player;
    const weapon = p.weapon;

    ctx.save();

    // Weapon color based on rarity
    const rarityColors = {
      [RARITY.COMMON]: '#888888',
      [RARITY.UNCOMMON]: '#44FF44',
      [RARITY.RARE]: '#4444FF',
      [RARITY.EPIC]: '#AA44FF',
      [RARITY.LEGENDARY]: '#FFAA00'
    };
    ctx.strokeStyle = rarityColors[weapon.rarity] || '#888888';
    ctx.lineWidth = 3;

    // Draw weapon based on facing
    ctx.beginPath();
    switch(p.facing) {
      case DIR.DOWN:
        ctx.moveTo(x + 8, y);
        ctx.lineTo(x + 8, y + 12);
        break;
      case DIR.UP:
        ctx.moveTo(x - 8, y - 10);
        ctx.lineTo(x - 8, y - 22);
        break;
      case DIR.LEFT:
        ctx.moveTo(x - 10, y - 5);
        ctx.lineTo(x - 18, y - 5);
        break;
      case DIR.RIGHT:
        ctx.moveTo(x + 10, y - 5);
        ctx.lineTo(x + 18, y - 5);
        break;
    }
    ctx.stroke();

    ctx.restore();
  },

  getArmorColor() {
    const p = G.player;

    // Use highest rarity equipped armor for color
    let highestRarity = RARITY.COMMON;
    for (let slot in p.armor) {
      const item = p.armor[slot];
      if (item && item.rarity > highestRarity) {
        highestRarity = item.rarity;
      }
    }

    const rarityColors = {
      [RARITY.COMMON]: '#4488AA',
      [RARITY.UNCOMMON]: '#44AA88',
      [RARITY.RARE]: '#4466AA',
      [RARITY.EPIC]: '#8844AA',
      [RARITY.LEGENDARY]: '#AA8844'
    };

    return rarityColors[highestRarity] || '#4488AA';
  },

  getAttackHitbox() {
    const p = G.player;

    if (!p.attacking || !p.weapon) return null;

    const range = p.weapon.range || 40;
    const arc = p.weapon.arc || 90;

    // Return hitbox rectangle based on facing and weapon range
    const hitbox = { x: p.x, y: p.y, w: range, h: range };

    switch(p.facing) {
      case DIR.DOWN:
        hitbox.y = p.y + 10;
        hitbox.x = p.x - range / 2;
        break;
      case DIR.UP:
        hitbox.y = p.y - range - 10;
        hitbox.x = p.x - range / 2;
        break;
      case DIR.LEFT:
        hitbox.x = p.x - range - 10;
        hitbox.y = p.y - range / 2;
        break;
      case DIR.RIGHT:
        hitbox.x = p.x + 10;
        hitbox.y = p.y - range / 2;
        break;
    }

    return hitbox;
  }
};

// === combat/weapons.js ===
// combat/weapons.js - Weapon mechanics, swing arcs, attack patterns, hit detection
// Global Weapons object for Depths of the Abyss

const Weapons = {
  activeSwings: [], // Track active weapon swings

  startAttack(player, weapon) {
    const swing = {
      player: player,
      weapon: weapon,
      progress: 0,
      duration: weapon.attackSpeed || 0.3,
      type: weapon.type,
      hitEntities: new Set(), // Track entities already hit by this swing
      comboHit: (G.combo % 3) + 1 // 1, 2, or 3
    };

    this.activeSwings.push(swing);

    // Handle ranged weapons (bow, staff)
    if (weapon.type === 'bow' || weapon.type === 'staff') {
      this.fireProjectile(player, weapon);
    }
  },

  updateAttack(player, dt) {
    // Update all active swings
    for (let i = this.activeSwings.length - 1; i >= 0; i--) {
      const swing = this.activeSwings[i];
      swing.progress += dt / swing.duration;

      if (swing.progress >= 1.0) {
        this.activeSwings.splice(i, 1);
      }
    }
  },

  getSwingArc(weapon, facing, progress) {
    // Calculate arc polygon for rendering based on weapon type and progress
    const baseAngle = this.getFacingAngle(facing);
    const arc = weapon.arc || 90;
    const range = weapon.range || 40;

    // Different sweep patterns per weapon type
    let startAngle, endAngle;

    switch(weapon.type) {
      case 'sword':
        // 90 arc sweep
        startAngle = baseAngle - (arc / 2) + (progress * arc);
        endAngle = startAngle + 20;
        break;

      case 'axe':
        // 120 arc, slower
        startAngle = baseAngle - 60 + (progress * 120);
        endAngle = startAngle + 30;
        break;

      case 'dagger':
        // Quick 45 stab
        startAngle = baseAngle - 10;
        endAngle = baseAngle + 10;
        break;

      case 'spear':
        // Narrow 30 thrust
        startAngle = baseAngle - 15;
        endAngle = baseAngle + 15;
        break;

      case 'hammer':
        // 90 arc + ground pound on 3rd hit
        startAngle = baseAngle - 45 + (progress * 90);
        endAngle = startAngle + 25;
        break;

      case 'scythe':
        // 180 sweep
        startAngle = baseAngle - 90 + (progress * 180);
        endAngle = startAngle + 40;
        break;

      default:
        startAngle = baseAngle - (arc / 2) + (progress * arc);
        endAngle = startAngle + 20;
    }

    return {
      startAngle: startAngle * Math.PI / 180,
      endAngle: endAngle * Math.PI / 180,
      range: range
    };
  },

  getFacingAngle(facing) {
    // Convert direction to degrees (0 = right, 90 = down)
    switch(facing) {
      case DIR.RIGHT: return 0;
      case DIR.DOWN: return 90;
      case DIR.LEFT: return 180;
      case DIR.UP: return 270;
      default: return 0;
    }
  },

  renderSwing(ctx, player, camera) {
    const p = player;

    if (!p.attacking || !p.weapon) return;

    const screenPos = Camera.worldToScreen(p.x, p.y);

    // Find active swing for this player
    const swing = this.activeSwings.find(s => s.player === p);
    if (!swing) return;

    const arc = this.getSwingArc(swing.weapon, p.facing, swing.progress);

    ctx.save();

    // Weapon color based on rarity
    const rarityColors = {
      [RARITY.COMMON]: '#888888',
      [RARITY.UNCOMMON]: '#44FF44',
      [RARITY.RARE]: '#4444FF',
      [RARITY.EPIC]: '#AA44FF',
      [RARITY.LEGENDARY]: '#FFAA00'
    };

    const color = rarityColors[swing.weapon.rarity] || '#888888';

    // Draw swing arc trail
    ctx.strokeStyle = color;
    ctx.lineWidth = 4;
    ctx.globalAlpha = 0.7 - (swing.progress * 0.5);

    ctx.beginPath();
    ctx.arc(screenPos.x, screenPos.y, arc.range, arc.startAngle, arc.endAngle);
    ctx.stroke();

    // Draw slash effect - curved line with fade
    ctx.strokeStyle = '#FFFFFF';
    ctx.lineWidth = 2;
    ctx.globalAlpha = 0.8 - swing.progress;

    const midAngle = (arc.startAngle + arc.endAngle) / 2;
    const slashX = screenPos.x + Math.cos(midAngle) * arc.range;
    const slashY = screenPos.y + Math.sin(midAngle) * arc.range;

    ctx.beginPath();
    ctx.moveTo(screenPos.x, screenPos.y);
    ctx.lineTo(slashX, slashY);
    ctx.stroke();

    // Draw combo counter indicator
    if (G.combo > 0) {
      ctx.globalAlpha = 1.0;
      ctx.fillStyle = '#FFD700';
      ctx.font = 'bold 14px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(swing.comboHit + '!', screenPos.x, screenPos.y - 30);
    }

    ctx.restore();
  },

  fireProjectile(player, weapon) {
    const p = player;

    // Calculate projectile direction based on aim or facing
    const aim = Input.getAim();
    let angle;

    if (aim.x !== 0 || aim.y !== 0) {
      angle = Math.atan2(aim.y, aim.x);
    } else {
      // Use facing direction
      switch(p.facing) {
        case DIR.RIGHT: angle = 0; break;
        case DIR.DOWN: angle = Math.PI / 2; break;
        case DIR.LEFT: angle = Math.PI; break;
        case DIR.UP: angle = -Math.PI / 2; break;
        default: angle = 0;
      }
    }

    const speed = weapon.type === 'bow' ? 400 : 300;
    const damage = this.getDamage(weapon, player, 1).damage;

    this.createProjectile(p.x, p.y, angle, weapon, damage);

    // Play sound
    if (weapon.type === 'bow') {
      SFX.playSFX('arrow_shoot');
    } else {
      SFX.playSFX('magic_cast');
    }
  },

  createProjectile(x, y, angle, weapon, damage) {
    const projectile = {
      x: x,
      y: y,
      vx: Math.cos(angle) * (weapon.type === 'bow' ? 400 : 300),
      vy: Math.sin(angle) * (weapon.type === 'bow' ? 400 : 300),
      damage: damage,
      element: weapon.element || ELEMENT.PHYSICAL,
      speed: weapon.type === 'bow' ? 400 : 300,
      lifetime: 2.0,
      owner: 'player',
      sprite: weapon.type,
      weapon: weapon,
      piercing: weapon.type === 'spear'
    };

    G.projectiles.push(projectile);
  },

  getDamage(weapon, player, comboHit) {
    const p = player;

    // Base weapon damage
    let baseDamage = weapon.damage || 10;

    // Add player stat scaling
    if (weapon.type === 'staff') {
      // Magic weapons scale with INT
      baseDamage += p.int * 0.5;
    } else {
      // Physical weapons scale with STR
      baseDamage += p.str * 0.5;
    }

    // Critical hit check
    const critRoll = Math.random();
    const isCritical = critRoll < p.critChance;

    if (isCritical) {
      baseDamage *= p.critMultiplier;
    }

    // Combo multiplier
    const comboMultipliers = [1.0, 1.2, 1.5];
    const comboIndex = Math.min(comboHit - 1, 2);
    baseDamage *= comboMultipliers[comboIndex];

    // Special weapon type bonuses
    switch(weapon.type) {
      case 'dagger':
        // Daggers can chain combo
        if (comboHit === 3) baseDamage *= 1.3;
        break;

      case 'hammer':
        // Hammer has ground pound AoE on 3rd hit
        if (comboHit === 3) {
          this.triggerGroundPound(player);
        }
        break;

      case 'axe':
        // Axe has higher base damage
        baseDamage *= 1.15;
        break;

      case 'spear':
        // Spear has longer range but lower damage
        baseDamage *= 0.9;
        break;
    }

    return {
      damage: Math.floor(baseDamage),
      isCritical: isCritical,
      element: weapon.element || ELEMENT.PHYSICAL,
      comboHit: comboHit
    };
  },

  triggerGroundPound(player) {
    // Create AoE damage effect
    const aoe = {
      x: player.x,
      y: player.y,
      radius: TILE_SIZE * 2,
      damage: player.weapon.damage * 1.5,
      element: ELEMENT.PHYSICAL,
      owner: 'player',
      lifetime: 0.3,
      timer: 0
    };

    if (!G.aoeEffects) G.aoeEffects = [];
    G.aoeEffects.push(aoe);

    // Screen shake
    Camera.shake(15, 0.4);

    // Play sound
    SFX.playSFX('ground_slam');
  },

  getElementMultiplier(attackElement, defenderElement) {
    // Element effectiveness: fire>ice>lightning>fire
    const effectiveness = {
      [ELEMENT.FIRE]: { [ELEMENT.ICE]: 1.5, [ELEMENT.LIGHTNING]: 0.75 },
      [ELEMENT.ICE]: { [ELEMENT.LIGHTNING]: 1.5, [ELEMENT.FIRE]: 0.75 },
      [ELEMENT.LIGHTNING]: { [ELEMENT.FIRE]: 1.5, [ELEMENT.ICE]: 0.75 },
      [ELEMENT.POISON]: {},
      [ELEMENT.DARK]: {},
      [ELEMENT.PHYSICAL]: {}
    };

    return effectiveness[attackElement]?.[defenderElement] || 1.0;
  },

  // Weapon type definitions with attack patterns
  getWeaponPattern(type) {
    const patterns = {
      sword: {
        arc: 90,
        range: 40,
        speed: 0.3,
        comboChain: true,
        maxCombo: 3
      },
      axe: {
        arc: 120,
        range: 45,
        speed: 0.5,
        comboChain: true,
        maxCombo: 2
      },
      dagger: {
        arc: 45,
        range: 30,
        speed: 0.2,
        comboChain: true,
        maxCombo: 5
      },
      spear: {
        arc: 30,
        range: 60,
        speed: 0.35,
        comboChain: false,
        maxCombo: 1
      },
      hammer: {
        arc: 90,
        range: 50,
        speed: 0.6,
        comboChain: true,
        maxCombo: 3,
        aoeOnFinisher: true
      },
      staff: {
        arc: 0,
        range: 200,
        speed: 0.4,
        ranged: true,
        manaCost: 10
      },
      bow: {
        arc: 0,
        range: 300,
        speed: 0.5,
        ranged: true,
        chargeable: true
      },
      scythe: {
        arc: 180,
        range: 55,
        speed: 0.45,
        comboChain: true,
        maxCombo: 2
      }
    };

    return patterns[type] || patterns.sword;
  }
};

// === combat/abilities.js ===
// combat/abilities.js - Runtime ability casting system
// Global AbilitySystem object for Depths of the Abyss

const AbilitySystem = {
  activeEffects: [], // Active buffs, debuffs, channeled abilities
  cooldowns: {},

  cast(abilityId, player) {
    const p = player;

    // Get ability definition
    const abilityDef = ABILITY_DEFS[abilityId];
    if (!abilityDef) return false;

    // Check cooldown
    if (this.cooldowns[abilityId] > 0) return false;

    // Check mana cost
    if (p.mana < abilityDef.manaCost) return false;

    // Check stamina cost
    if (abilityDef.staminaCost && p.stamina < abilityDef.staminaCost) return false;

    // Deduct costs
    p.mana -= abilityDef.manaCost;
    if (abilityDef.staminaCost) p.stamina -= abilityDef.staminaCost;

    // Set cooldown
    this.cooldowns[abilityId] = abilityDef.cooldown;

    // Execute ability
    this.executeAbility(abilityId, abilityDef, player);

    // Play cast sound
    SFX.playSFX('ability_cast');

    return true;
  },

  executeAbility(abilityId, def, player) {
    const p = player;

    // Dispatch to specific ability handlers
    switch(abilityId) {
      // WARRIOR ABILITIES
      case 'powerStrike':
        this.powerStrike(p);
        break;
      case 'ironSkin':
        this.ironSkin(p);
        break;
      case 'berserkerRage':
        this.berserkerRage(p);
        break;
      case 'whirlwind':
        this.whirlwind(p);
        break;
      case 'shieldBash':
        this.shieldBash(p);
        break;
      case 'warCry':
        this.warCry(p);
        break;
      case 'earthquake':
        this.earthquake(p);
        break;

      // MAGE ABILITIES
      case 'fireball':
        this.fireball(p);
        break;
      case 'frostShield':
        this.frostShield(p);
        break;
      case 'manaSurge':
        this.manaSurge(p);
        break;
      case 'lightningChain':
        this.lightningChain(p);
        break;
      case 'teleport':
        this.teleport(p);
        break;
      case 'arcaneMissile':
        this.arcaneMissile(p);
        break;
      case 'meteorStrike':
        this.meteorStrike(p);
        break;
      case 'timeWarp':
        this.timeWarp(p);
        break;

      // ROGUE ABILITIES
      case 'backstab':
        this.backstab(p);
        break;
      case 'poisonBlade':
        this.poisonBlade(p);
        break;
      case 'shadowStep':
        this.shadowStep(p);
        break;
      case 'fanOfKnives':
        this.fanOfKnives(p);
        break;
      case 'smokeBomb':
        this.smokeBomb(p);
        break;
      case 'deathMark':
        this.deathMark(p);
        break;
      case 'shadowClone':
        this.shadowClone(p);
        break;
    }
  },

  // WARRIOR ABILITIES
  powerStrike(player) {
    this.addBuff(player, {
      type: 'powerStrike',
      duration: 3.0,
      damageMultiplier: 1.5
    });
    Combat.spawnFloatingText(player.x, player.y - 20, 'POWER!', '#FF4444');
  },

  ironSkin(player) {
    this.addBuff(player, {
      type: 'ironSkin',
      duration: 5.0,
      damageReduction: 0.5
    });
    Combat.spawnFloatingText(player.x, player.y - 20, 'IRON SKIN!', '#888888');
  },

  berserkerRage(player) {
    if (player.hp / player.maxHp > 0.3) return;

    this.addBuff(player, {
      type: 'berserkerRage',
      duration: 8.0,
      speedMultiplier: 1.5,
      damageMultiplier: 1.3
    });
    Combat.spawnFloatingText(player.x, player.y - 20, 'RAGE!', '#FF0000');
    Camera.shake(10, 0.3);
  },

  whirlwind(player) {
    const radius = TILE_SIZE * 3;

    // Hit all enemies in radius
    G.enemies.forEach(enemy => {
      const dist = Util.dist(player.x, player.y, enemy.x, enemy.y);
      if (dist <= radius) {
        const damage = player.weapon.damage * 0.8;
        EnemyAI.takeDamage(enemy, damage, ELEMENT.PHYSICAL, player.x - enemy.x, player.y - enemy.y);
      }
    });

    Camera.shake(12, 0.4);
    SFX.playSFX('whirlwind');
  },

  shieldBash(player) {
    // Find enemy in front
    const range = TILE_SIZE * 2;
    const facing = player.facing;

    G.enemies.forEach(enemy => {
      const dist = Util.dist(player.x, player.y, enemy.x, enemy.y);
      if (dist <= range) {
        // Check if in front
        const dx = enemy.x - player.x;
        const dy = enemy.y - player.y;

        let inFront = false;
        if (facing === DIR.RIGHT && dx > 0) inFront = true;
        if (facing === DIR.LEFT && dx < 0) inFront = true;
        if (facing === DIR.DOWN && dy > 0) inFront = true;
        if (facing === DIR.UP && dy < 0) inFront = true;

        if (inFront) {
          Combat.applyStatusEffect(enemy, {
            type: 'stun',
            duration: 2.0,
            tickDamage: 0,
            tickInterval: 0
          });
          Combat.spawnFloatingText(enemy.x, enemy.y - 20, 'STUNNED', '#FFD700');
        }
      }
    });

    SFX.playSFX('shield_bash');
  },

  warCry(player) {
    const radius = TILE_SIZE * 4;

    G.enemies.forEach(enemy => {
      const dist = Util.dist(player.x, player.y, enemy.x, enemy.y);
      if (dist <= radius) {
        enemy.state = 'flee';
        enemy.stateTimer = 3.0;
        Combat.spawnFloatingText(enemy.x, enemy.y - 20, 'FEARED', '#AA44AA');
      }
    });

    Camera.shake(15, 0.4);
    SFX.playSFX('war_cry');
  },

  earthquake(player) {
    const radius = TILE_SIZE * 5;
    const damage = player.weapon.damage * 2.5;

    G.enemies.forEach(enemy => {
      const dist = Util.dist(player.x, player.y, enemy.x, enemy.y);
      if (dist <= radius) {
        EnemyAI.takeDamage(enemy, damage, ELEMENT.PHYSICAL, player.x - enemy.x, player.y - enemy.y);
      }
    });

    Camera.shake(20, 0.5);
    SFX.playSFX('earthquake');
  },

  // MAGE ABILITIES
  fireball(player) {
    const aim = Input.getAim();
    const angle = Math.atan2(aim.y, aim.x);

    const projectile = {
      x: player.x,
      y: player.y,
      vx: Math.cos(angle) * 300,
      vy: Math.sin(angle) * 300,
      damage: 30 + player.int,
      element: ELEMENT.FIRE,
      speed: 300,
      lifetime: 2.0,
      owner: 'player',
      sprite: 'fireball',
      explodeRadius: TILE_SIZE * 1.5
    };

    G.projectiles.push(projectile);
    SFX.playSFX('fireball_cast');
  },

  frostShield(player) {
    this.addBuff(player, {
      type: 'frostShield',
      duration: 10.0,
      absorb: 50,
      slowAttackers: true
    });
    Combat.spawnFloatingText(player.x, player.y - 20, 'FROST SHIELD!', '#4444FF');
  },

  manaSurge(player) {
    this.addBuff(player, {
      type: 'manaSurge',
      duration: 10.0,
      manaRegenMultiplier: 2.0
    });
    Combat.spawnFloatingText(player.x, player.y - 20, 'MANA SURGE!', '#4488FF');
  },

  lightningChain(player) {
    // Find nearest 3 enemies
    const targets = this.findNearestEnemies(player, 3, TILE_SIZE * 6);

    targets.forEach((enemy, index) => {
      const damage = (25 + player.int) * Math.pow(0.8, index); // Reduced damage per chain
      setTimeout(() => {
        EnemyAI.takeDamage(enemy, damage, ELEMENT.LIGHTNING, 0, 0);
        SFX.playSFX('lightning_strike');
      }, index * 100);
    });

    Combat.spawnFloatingText(player.x, player.y - 20, 'CHAIN LIGHTNING!', '#FFFF00');
  },

  teleport(player) {
    const distance = TILE_SIZE * 5;
    const facing = player.facing;

    let dx = 0, dy = 0;
    switch(facing) {
      case DIR.RIGHT: dx = distance; break;
      case DIR.LEFT: dx = -distance; break;
      case DIR.DOWN: dy = distance; break;
      case DIR.UP: dy = -distance; break;
    }

    // Check if destination is walkable
    const destX = player.x + dx;
    const destY = player.y + dy;

    if (TileMap.isWalkable(Math.floor(destX / TILE_SIZE), Math.floor(destY / TILE_SIZE))) {
      player.x = destX;
      player.y = destY;
      SFX.playSFX('teleport');
      Combat.spawnFloatingText(player.x, player.y - 20, 'BLINK!', '#AA44FF');
    }
  },

  arcaneMissile(player) {
    const targets = this.findNearestEnemies(player, 3, TILE_SIZE * 8);

    targets.forEach((enemy, index) => {
      setTimeout(() => {
        const angle = Util.angle(player.x, player.y, enemy.x, enemy.y);
        const projectile = {
          x: player.x,
          y: player.y,
          vx: Math.cos(angle) * 250,
          vy: Math.sin(angle) * 250,
          damage: 15 + player.int * 0.5,
          element: ELEMENT.PHYSICAL,
          speed: 250,
          lifetime: 3.0,
          owner: 'player',
          sprite: 'arcane_missile',
          homing: enemy
        };
        G.projectiles.push(projectile);
      }, index * 150);
    });

    SFX.playSFX('arcane_cast');
  },

  meteorStrike(player) {
    const aim = Input.getAim();
    const targetX = player.x + aim.x * TILE_SIZE * 3;
    const targetY = player.y + aim.y * TILE_SIZE * 3;

    // Delayed AoE
    const aoe = {
      x: targetX,
      y: targetY,
      radius: TILE_SIZE * 3,
      damage: 60 + player.int * 2,
      element: ELEMENT.FIRE,
      owner: 'player',
      lifetime: 0.5,
      timer: 0,
      delay: 1.5,
      telegraph: true
    };

    if (!G.aoeEffects) G.aoeEffects = [];
    G.aoeEffects.push(aoe);

    SFX.playSFX('meteor_incoming');
  },

  timeWarp(player) {
    G.enemies.forEach(enemy => {
      enemy.timeWarpSlow = 0.3; // Move at 30% speed
      enemy.timeWarpDuration = 5.0;
    });

    Combat.spawnFloatingText(player.x, player.y - 20, 'TIME WARP!', '#8844FF');
    SFX.playSFX('time_warp');
  },

  // ROGUE ABILITIES
  backstab(player) {
    const target = this.findNearestEnemies(player, 1, TILE_SIZE * 4)[0];
    if (!target) return;

    // Teleport behind target
    const angle = Util.angle(player.x, player.y, target.x, target.y);
    player.x = target.x - Math.cos(angle) * TILE_SIZE;
    player.y = target.y - Math.sin(angle) * TILE_SIZE;

    // Deal 3x damage
    const damage = player.weapon.damage * 3;
    EnemyAI.takeDamage(target, damage, ELEMENT.PHYSICAL, 0, 0);

    Combat.spawnFloatingText(target.x, target.y - 20, 'BACKSTAB!', '#FF4444');
    SFX.playSFX('backstab');
  },

  poisonBlade(player) {
    this.addBuff(player, {
      type: 'poisonBlade',
      duration: 10.0,
      attackCount: 5,
      poisonDuration: 3.0
    });
    Combat.spawnFloatingText(player.x, player.y - 20, 'POISON BLADE!', '#44FF44');
  },

  shadowStep(player) {
    const target = this.findNearestEnemies(player, 1, TILE_SIZE * 6)[0];
    if (!target) return;

    // Teleport behind target
    const angle = Util.angle(player.x, player.y, target.x, target.y);
    player.x = target.x - Math.cos(angle) * TILE_SIZE;
    player.y = target.y - Math.sin(angle) * TILE_SIZE;

    SFX.playSFX('shadow_step');
    Combat.spawnFloatingText(player.x, player.y - 20, 'SHADOW STEP!', '#4444AA');
  },

  fanOfKnives(player) {
    const numKnives = 8;
    const facing = player.facing;
    const baseAngle = this.getFacingAngle(facing);

    for (let i = 0; i < numKnives; i++) {
      const spread = 60; // degrees
      const angle = (baseAngle - spread/2 + (i / numKnives) * spread) * Math.PI / 180;

      const projectile = {
        x: player.x,
        y: player.y,
        vx: Math.cos(angle) * 350,
        vy: Math.sin(angle) * 350,
        damage: player.weapon.damage * 0.6,
        element: ELEMENT.PHYSICAL,
        speed: 350,
        lifetime: 1.0,
        owner: 'player',
        sprite: 'knife'
      };

      G.projectiles.push(projectile);
    }

    SFX.playSFX('fan_of_knives');
  },

  smokeBomb(player) {
    const radius = TILE_SIZE * 4;

    G.enemies.forEach(enemy => {
      const dist = Util.dist(player.x, player.y, enemy.x, enemy.y);
      if (dist <= radius) {
        enemy.state = 'idle';
        enemy.alertRadius = 0; // Lose aggro
        setTimeout(() => { enemy.alertRadius = TILE_SIZE * 6; }, 3000);
      }
    });

    this.addBuff(player, {
      type: 'invisible',
      duration: 3.0
    });

    Combat.spawnFloatingText(player.x, player.y - 20, 'SMOKE!', '#666666');
    SFX.playSFX('smoke_bomb');
  },

  deathMark(player) {
    const target = this.findNearestEnemies(player, 1, TILE_SIZE * 6)[0];
    if (!target) return;

    target.deathMark = true;
    target.deathMarkDuration = 5.0;

    Combat.spawnFloatingText(target.x, target.y - 20, 'MARKED!', '#FF0000');
    SFX.playSFX('death_mark');
  },

  shadowClone(player) {
    const clone = {
      x: player.x - TILE_SIZE,
      y: player.y,
      type: 'shadow_clone',
      hp: 1,
      maxHp: 1,
      duration: 8.0,
      isDecoy: true
    };

    G.enemies.push(clone);
    Combat.spawnFloatingText(clone.x, clone.y - 20, 'CLONE!', '#4444AA');
    SFX.playSFX('shadow_clone');
  },

  // Helper methods
  addBuff(entity, buff) {
    this.activeEffects.push({
      entity: entity,
      buff: buff,
      timer: 0
    });
  },

  findNearestEnemies(player, count, maxDistance) {
    const enemies = G.enemies.filter(e => {
      const dist = Util.dist(player.x, player.y, e.x, e.y);
      return dist <= maxDistance && e.hp > 0;
    });

    enemies.sort((a, b) => {
      const distA = Util.dist(player.x, player.y, a.x, a.y);
      const distB = Util.dist(player.x, player.y, b.x, b.y);
      return distA - distB;
    });

    return enemies.slice(0, count);
  },

  getFacingAngle(facing) {
    switch(facing) {
      case DIR.RIGHT: return 0;
      case DIR.DOWN: return 90;
      case DIR.LEFT: return 180;
      case DIR.UP: return 270;
      default: return 0;
    }
  },

  update(dt) {
    // Update cooldowns
    for (let abilityId in this.cooldowns) {
      if (this.cooldowns[abilityId] > 0) {
        this.cooldowns[abilityId] -= dt;
      }
    }

    // Update active effects
    for (let i = this.activeEffects.length - 1; i >= 0; i--) {
      const effect = this.activeEffects[i];
      effect.timer += dt;
      effect.buff.duration -= dt;

      if (effect.buff.duration <= 0) {
        this.activeEffects.splice(i, 1);
      }
    }
  },

  renderEffects(ctx, camera) {
    // Render active ability visuals
    this.activeEffects.forEach(effect => {
      const entity = effect.entity;
      const screenPos = Camera.worldToScreen(entity.x, entity.y);

      // Draw buff auras
      ctx.save();
      ctx.globalAlpha = 0.3;

      switch(effect.buff.type) {
        case 'ironSkin':
          ctx.strokeStyle = '#888888';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(screenPos.x, screenPos.y, 25, 0, Math.PI * 2);
          ctx.stroke();
          break;

        case 'frostShield':
          ctx.strokeStyle = '#4444FF';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(screenPos.x, screenPos.y, 25, 0, Math.PI * 2);
          ctx.stroke();
          break;

        case 'berserkerRage':
          ctx.strokeStyle = '#FF0000';
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.arc(screenPos.x, screenPos.y, 30, 0, Math.PI * 2);
          ctx.stroke();
          break;
      }

      ctx.restore();
    });
  }
};

// === combat/enemy-ai.js ===
// combat/enemy-ai.js - Enemy behavior patterns and A* pathfinding
// Global EnemyAI object for Depths of the Abyss

const EnemyAI = {
  pathCache: new Map(), // Cache A* paths
  pathCacheTimeout: 0.5,

  update(enemy, dt) {
    if (!enemy || enemy.hp <= 0) {
      if (enemy && enemy.state !== 'dead') {
        this.die(enemy);
      }
      return;
    }

    // Update timers
    if (enemy.attackCooldown > 0) enemy.attackCooldown -= dt;
    if (enemy.stateTimer > 0) enemy.stateTimer -= dt;
    if (enemy.knockbackTimer > 0) {
      enemy.x += enemy.knockbackX * dt;
      enemy.y += enemy.knockbackY * dt;
      enemy.knockbackTimer -= dt;
      if (enemy.knockbackTimer <= 0) {
        enemy.knockbackX = 0;
        enemy.knockbackY = 0;
      }
    }

    // Update status effects
    this.updateStatusEffects(enemy, dt);

    // Handle time warp slow
    let speedMultiplier = 1.0;
    if (enemy.timeWarpDuration > 0) {
      enemy.timeWarpDuration -= dt;
      speedMultiplier = enemy.timeWarpSlow || 1.0;
    }

    // Check if stunned
    const stunned = enemy.statusEffects.some(e => e.type === 'stun');
    if (stunned) {
      enemy.vx = 0;
      enemy.vy = 0;
      return;
    }

    // Decay hit flash
    if (enemy.hitFlash > 0) {
      enemy.hitFlash -= dt * 5;
    }

    const p = G.player;
    const distToPlayer = Util.dist(enemy.x, enemy.y, p.x, p.y);
    const tilePos = TileMap.pixelToTile(enemy.x, enemy.y);

    // Check if player is visible (fog of war)
    const canSeePlayer = Fog.isVisible(tilePos.x, tilePos.y) && distToPlayer <= enemy.chaseRadius;

    // State machine
    switch(enemy.state) {
      case 'idle':
        this.handleIdle(enemy, p, distToPlayer, canSeePlayer, dt, speedMultiplier);
        break;

      case 'patrol':
        this.handlePatrol(enemy, p, distToPlayer, canSeePlayer, dt, speedMultiplier);
        break;

      case 'chase':
        this.handleChase(enemy, p, distToPlayer, canSeePlayer, dt, speedMultiplier);
        break;

      case 'attack':
        this.handleAttack(enemy, p, distToPlayer, dt);
        break;

      case 'flee':
        this.handleFlee(enemy, p, dt, speedMultiplier);
        break;

      case 'dead':
        break;
    }

    // Behavior-specific logic
    this.executeBehavior(enemy, p, distToPlayer, dt, speedMultiplier);
  },

  handleIdle(enemy, player, dist, canSee, dt, speedMult) {
    // Alert when player in range and visible
    if (canSee && dist <= enemy.alertRadius) {
      enemy.state = 'chase';
      this.alertNearby(enemy);
    }

    // Patrol behavior transitions to patrol state
    if (enemy.behavior === 'patrol' && enemy.patrolPath.length > 0) {
      enemy.state = 'patrol';
    }
  },

  handlePatrol(enemy, player, dist, canSee, dt, speedMult) {
    // Alert when player close
    if (canSee && dist <= enemy.alertRadius) {
      enemy.state = 'chase';
      this.alertNearby(enemy);
      return;
    }

    // Move along patrol path
    if (enemy.patrolPath.length === 0) {
      enemy.state = 'idle';
      return;
    }

    const target = enemy.patrolPath[enemy.patrolIndex];
    const targetX = target.x * TILE_SIZE + TILE_SIZE / 2;
    const targetY = target.y * TILE_SIZE + TILE_SIZE / 2;

    const distToTarget = Util.dist(enemy.x, enemy.y, targetX, targetY);

    if (distToTarget < 10) {
      // Reached waypoint
      enemy.patrolIndex = (enemy.patrolIndex + 1) % enemy.patrolPath.length;
    } else {
      // Move toward waypoint
      const angle = Util.angle(enemy.x, enemy.y, targetX, targetY);
      enemy.vx = Math.cos(angle) * enemy.speed * speedMult;
      enemy.vy = Math.sin(angle) * enemy.speed * speedMult;

      enemy.x += enemy.vx * dt;
      enemy.y += enemy.vy * dt;
    }
  },

  handleChase(enemy, player, dist, canSee, dt, speedMult) {
    // Attack when in range
    if (dist <= enemy.attackRange) {
      enemy.state = 'attack';
      return;
    }

    // Lose aggro if player too far or not visible
    if (!canSee || dist > enemy.chaseRadius * 1.5) {
      enemy.state = enemy.behavior === 'patrol' ? 'patrol' : 'idle';
      enemy.path = [];
      return;
    }

    // Pathfind to player
    if (!enemy.pathTimer || enemy.pathTimer <= 0) {
      enemy.path = this.pathfind(enemy.x, enemy.y, player.x, player.y);
      enemy.pathTimer = this.pathCacheTimeout;
    } else {
      enemy.pathTimer -= dt;
    }

    // Follow path
    if (enemy.path && enemy.path.length > 0) {
      const target = enemy.path[0];
      const targetX = target.x * TILE_SIZE + TILE_SIZE / 2;
      const targetY = target.y * TILE_SIZE + TILE_SIZE / 2;

      const distToWaypoint = Util.dist(enemy.x, enemy.y, targetX, targetY);

      if (distToWaypoint < 10) {
        enemy.path.shift(); // Reached waypoint
      } else {
        const angle = Util.angle(enemy.x, enemy.y, targetX, targetY);
        enemy.vx = Math.cos(angle) * enemy.speed * speedMult;
        enemy.vy = Math.sin(angle) * enemy.speed * speedMult;

        enemy.x += enemy.vx * dt;
        enemy.y += enemy.vy * dt;
      }
    } else {
      // No path - move directly (swarm behavior)
      const angle = Util.angle(enemy.x, enemy.y, player.x, player.y);
      enemy.vx = Math.cos(angle) * enemy.speed * speedMult;
      enemy.vy = Math.sin(angle) * enemy.speed * speedMult;

      enemy.x += enemy.vx * dt;
      enemy.y += enemy.vy * dt;
    }
  },

  handleAttack(enemy, player, dist, dt) {
    // Move back to chase if player out of range
    if (dist > enemy.attackRange * 1.2) {
      enemy.state = 'chase';
      return;
    }

    // Attack cooldown
    if (enemy.attackCooldown <= 0) {
      this.attack(enemy, player);
      enemy.attackCooldown = enemy.attackSpeed || 1.0;
    }
  },

  handleFlee(enemy, player, dt, speedMult) {
    // Flee away from player
    const angle = Util.angle(player.x, player.y, enemy.x, enemy.y);
    enemy.vx = Math.cos(angle) * enemy.speed * 1.5 * speedMult;
    enemy.vy = Math.sin(angle) * enemy.speed * 1.5 * speedMult;

    enemy.x += enemy.vx * dt;
    enemy.y += enemy.vy * dt;

    // Return to idle after state timer expires
    if (enemy.stateTimer <= 0) {
      enemy.state = 'idle';
    }
  },

  executeBehavior(enemy, player, dist, dt, speedMult) {
    switch(enemy.behavior) {
      case 'swarm':
        // Faster in groups
        const nearbyAllies = G.enemies.filter(e => {
          return e.type === enemy.type && Util.dist(e.x, e.y, enemy.x, enemy.y) < TILE_SIZE * 3;
        }).length;
        if (nearbyAllies > 2) {
          enemy.speed *= 1.2;
        }
        break;

      case 'ranged':
        // Maintain distance
        if (dist < TILE_SIZE * 4 && enemy.state === 'chase') {
          enemy.state = 'flee';
          enemy.stateTimer = 1.0;
        }
        break;

      case 'ambush':
        // Stay hidden until player very close
        if (enemy.state === 'idle' && dist < TILE_SIZE * 2) {
          enemy.state = 'chase';
          // Surprise attack with bonus damage
          enemy.nextAttackBonus = 2.0;
        }
        break;

      case 'guard':
        // Don't chase far from spawn
        if (enemy.spawnX && enemy.spawnY) {
          const distFromSpawn = Util.dist(enemy.x, enemy.y, enemy.spawnX, enemy.spawnY);
          if (distFromSpawn > TILE_SIZE * 5) {
            enemy.state = 'idle';
            enemy.path = this.pathfind(enemy.x, enemy.y, enemy.spawnX, enemy.spawnY);
          }
        }
        break;
    }
  },

  attack(enemy, target) {
    const isRanged = enemy.behavior === 'ranged' || enemy.type === 'archer' || enemy.type === 'mage';

    if (isRanged) {
      // Create projectile
      const angle = Util.angle(enemy.x, enemy.y, target.x, target.y);
      const projectile = {
        x: enemy.x,
        y: enemy.y,
        vx: Math.cos(angle) * 250,
        vy: Math.sin(angle) * 250,
        damage: enemy.damage,
        element: enemy.element || ELEMENT.PHYSICAL,
        speed: 250,
        lifetime: 2.0,
        owner: 'enemy',
        sprite: enemy.type
      };

      G.projectiles.push(projectile);
      SFX.playSFX('enemy_attack');
    } else {
      // Melee attack - damage handled in collision system
      SFX.playSFX('enemy_attack');
    }

    // Apply attack bonus (ambush)
    if (enemy.nextAttackBonus) {
      enemy.damage *= enemy.nextAttackBonus;
      enemy.nextAttackBonus = null;
    }
  },

  takeDamage(enemy, amount, element, knockbackX, knockbackY) {
    if (enemy.hp <= 0) return;

    // Apply defense
    let finalDamage = amount - (enemy.defense || 0);

    // Apply element resistance/weakness
    const multiplier = this.getElementMultiplier(element, enemy.element);
    finalDamage *= multiplier;

    // Death mark doubles damage
    if (enemy.deathMark) {
      finalDamage *= 2;
    }

    finalDamage = Math.max(1, Math.floor(finalDamage));

    // Apply damage
    enemy.hp -= finalDamage;

    // Visual feedback
    enemy.hitFlash = 0.15;

    // Knockback
    if (knockbackX !== undefined && knockbackY !== undefined) {
      const angle = Math.atan2(knockbackY, knockbackX);
      const force = 100;
      enemy.knockbackX = Math.cos(angle) * force;
      enemy.knockbackY = Math.sin(angle) * force;
      enemy.knockbackTimer = 0.15;
    }

    // Floating damage text
    const color = multiplier > 1 ? '#FFAA00' : '#FF4444';
    Combat.spawnFloatingText(enemy.x, enemy.y - 20, '-' + finalDamage, color);

    // Alert nearby enemies
    if (enemy.state === 'idle' || enemy.state === 'patrol') {
      enemy.state = 'chase';
      this.alertNearby(enemy);
    }

    // Death
    if (enemy.hp <= 0) {
      this.die(enemy);
    }
  },

  die(enemy) {
    enemy.state = 'dead';
    enemy.hp = 0;

    // Play sound
    SFX.playSFX('enemy_death');

    // Award XP
    const xp = enemy.xpReward || 10;
    Player.addXP(xp);

    // Drop loot
    this.dropLoot(enemy);

    // Update stats
    G.player.totalKills++;

    // Remove from array (will be handled by game loop)
    setTimeout(() => {
      const index = G.enemies.indexOf(enemy);
      if (index > -1) G.enemies.splice(index, 1);
    }, 500);
  },

  dropLoot(enemy) {
    // Random loot based on enemy type and elite status
    const lootRoll = Math.random();

    if (lootRoll < enemy.lootChance) {
      const loot = {
        x: enemy.x,
        y: enemy.y,
        type: 'item',
        item: this.generateLootItem(enemy)
      };

      if (!G.lootDrops) G.lootDrops = [];
      G.lootDrops.push(loot);
    }

    // Gold drop
    const gold = Util.randInt(5, 15) * (enemy.elite ? 2 : 1);
    G.player.gold += gold;
  },

  generateLootItem(enemy) {
    const floor = G.currentFloor || 1;

    // Elite enemies drop better loot
    const rarityBonus = enemy.elite ? 1 : 0;

    // 60% weapon, 30% armor, 10% consumable
    const typeRoll = Math.random();

    if (typeRoll < 0.6) {
      return generateWeapon(floor, rarityBonus);
    } else if (typeRoll < 0.9) {
      const slot = Util.pick(['head', 'chest', 'legs', 'boots', 'gloves', 'ring', 'amulet']);
      return this.generateArmor(floor, slot, rarityBonus);
    } else {
      // Consumables - return a simple consumable object
      return {
        type: 'consumable',
        name: Util.pick(['Health Potion', 'Mana Potion', 'Stamina Potion']),
        effect: 'heal',
        amount: 50
      };
    }
  },

  generateArmor(floor, slot, rarityBonus) {
    // Simplified armor generation
    const baseDefense = 5 + floor * 2;
    const rarity = Math.min(RARITY.LEGENDARY, rarityBonus + Math.floor(Math.random() * 3));

    return {
      type: 'armor',
      slot: slot,
      defense: Math.floor(baseDefense * (1 + rarity * 0.3)),
      rarity: rarity,
      resistance: {}, // Empty resistance object by default
      name: Util.pick(['Iron', 'Steel', 'Mythril', 'Dragon', 'Abyssal']) + ' ' +
            slot.charAt(0).toUpperCase() + slot.slice(1)
    };
  },

  alertNearby(enemy) {
    const alertRadius = TILE_SIZE * 4;

    G.enemies.forEach(e => {
      if (e === enemy) return;
      if (e.state === 'dead') return;

      const dist = Util.dist(enemy.x, enemy.y, e.x, e.y);
      if (dist <= alertRadius) {
        if (e.state === 'idle' || e.state === 'patrol') {
          e.state = 'chase';
        }
      }
    });
  },

  updateStatusEffects(enemy, dt) {
    if (!enemy.statusEffects) enemy.statusEffects = [];

    for (let i = enemy.statusEffects.length - 1; i >= 0; i--) {
      const effect = enemy.statusEffects[i];
      effect.timer += dt;

      // Tick damage
      if ((effect.type === 'poison' || effect.type === 'burn' || effect.type === 'bleed') &&
          effect.timer >= effect.tickInterval) {
        enemy.hp -= effect.tickDamage;
        effect.timer = 0;
        Combat.spawnFloatingText(enemy.x, enemy.y - 10, '-' + effect.tickDamage, '#884488');

        if (enemy.hp <= 0) {
          this.die(enemy);
        }
      }

      // Remove expired
      effect.duration -= dt;
      if (effect.duration <= 0) {
        enemy.statusEffects.splice(i, 1);
      }
    }
  },

  getElementMultiplier(attackElement, defenderElement) {
    // Element effectiveness
    const effectiveness = {
      [ELEMENT.FIRE]: { [ELEMENT.ICE]: 1.5, [ELEMENT.LIGHTNING]: 0.75 },
      [ELEMENT.ICE]: { [ELEMENT.LIGHTNING]: 1.5, [ELEMENT.FIRE]: 0.75 },
      [ELEMENT.LIGHTNING]: { [ELEMENT.FIRE]: 1.5, [ELEMENT.ICE]: 0.75 }
    };

    return effectiveness[attackElement]?.[defenderElement] || 1.0;
  },

  spawn(type, x, y, elite, floor) {
    const template = ENEMY_TYPES[type];
    if (!template) return null;

    const floorMultiplier = 1 + (floor || 1) * 0.1;

    const enemy = {
      id: 'enemy_' + Date.now() + '_' + Math.random(),
      type: type,
      name: template.name,
      x: x,
      y: y,
      spawnX: x,
      spawnY: y,
      vx: 0, vy: 0,
      w: 24, h: 24,
      hp: template.hp * floorMultiplier * (elite ? 1.5 : 1),
      maxHp: template.hp * floorMultiplier * (elite ? 1.5 : 1),
      damage: template.damage * floorMultiplier * (elite ? 1.3 : 1),
      speed: template.speed,
      defense: template.defense || 0,
      element: template.element || ELEMENT.PHYSICAL,
      behavior: template.behavior || 'chase',
      state: 'idle',
      alertRadius: template.alertRadius || TILE_SIZE * 6,
      chaseRadius: template.chaseRadius || TILE_SIZE * 10,
      attackRange: template.attackRange || TILE_SIZE,
      attackCooldown: 0,
      attackSpeed: template.attackSpeed || 1.0,
      facing: DIR.DOWN,
      path: [],
      pathTimer: 0,
      patrolPath: template.patrolPath || [],
      patrolIndex: 0,
      hitFlash: 0,
      knockbackX: 0, knockbackY: 0, knockbackTimer: 0,
      statusEffects: [],
      elite: elite || false,
      xpReward: template.xpReward * (elite ? 2 : 1),
      lootChance: template.lootChance * (elite ? 1.5 : 1),
      spriteData: template.spriteData,
      stateTimer: 0
    };

    return enemy;
  },

  pathfind(startX, startY, endX, endY) {
    // A* pathfinding
    const startTile = TileMap.pixelToTile(startX, startY);
    const endTile = TileMap.pixelToTile(endX, endY);

    // Check if end is walkable
    if (!TileMap.isWalkable(endTile.x, endTile.y)) {
      return [];
    }

    const openSet = [];
    const closedSet = new Set();
    const cameFrom = new Map();
    const gScore = new Map();
    const fScore = new Map();

    const startKey = startTile.x + ',' + startTile.y;
    const endKey = endTile.x + ',' + endTile.y;

    gScore.set(startKey, 0);
    fScore.set(startKey, this.heuristic(startTile, endTile));
    openSet.push({ x: startTile.x, y: startTile.y, f: fScore.get(startKey) });

    let iterations = 0;
    const maxIterations = 200;

    while (openSet.length > 0 && iterations < maxIterations) {
      iterations++;

      // Find node with lowest fScore
      openSet.sort((a, b) => a.f - b.f);
      const current = openSet.shift();
      const currentKey = current.x + ',' + current.y;

      // Reached goal
      if (currentKey === endKey) {
        return this.reconstructPath(cameFrom, current);
      }

      closedSet.add(currentKey);

      // Check neighbors
      const neighbors = [
        { x: current.x + 1, y: current.y },
        { x: current.x - 1, y: current.y },
        { x: current.x, y: current.y + 1 },
        { x: current.x, y: current.y - 1 }
      ];

      for (const neighbor of neighbors) {
        const neighborKey = neighbor.x + ',' + neighbor.y;

        if (closedSet.has(neighborKey)) continue;
        if (!TileMap.isWalkable(neighbor.x, neighbor.y)) continue;

        const tentativeGScore = gScore.get(currentKey) + 1;

        if (!gScore.has(neighborKey) || tentativeGScore < gScore.get(neighborKey)) {
          cameFrom.set(neighborKey, current);
          gScore.set(neighborKey, tentativeGScore);
          const h = this.heuristic(neighbor, endTile);
          fScore.set(neighborKey, tentativeGScore + h);

          if (!openSet.find(n => n.x === neighbor.x && n.y === neighbor.y)) {
            openSet.push({ x: neighbor.x, y: neighbor.y, f: fScore.get(neighborKey) });
          }
        }
      }
    }

    // No path found
    return [];
  },

  heuristic(a, b) {
    // Manhattan distance
    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
  },

  reconstructPath(cameFrom, current) {
    const path = [{ x: current.x, y: current.y }];

    let currentKey = current.x + ',' + current.y;

    while (cameFrom.has(currentKey)) {
      const prev = cameFrom.get(currentKey);
      path.unshift({ x: prev.x, y: prev.y });
      currentKey = prev.x + ',' + prev.y;
    }

    return path;
  },

  renderAll(ctx, camera) {
    G.enemies.forEach(enemy => {
      if (enemy.state === 'dead') return;

      // Only render if visible
      const tilePos = TileMap.pixelToTile(enemy.x, enemy.y);
      if (!Fog.isVisible(tilePos.x, tilePos.y)) return;

      this.render(enemy, ctx, camera);
    });
  },

  render(enemy, ctx, camera) {
    const screenPos = Camera.worldToScreen(enemy.x, enemy.y);

    ctx.save();

    // Draw shadow
    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
    ctx.beginPath();
    ctx.ellipse(screenPos.x, screenPos.y + 8, 10, 4, 0, 0, Math.PI * 2);
    ctx.fill();

    // Flash white when hit
    if (enemy.hitFlash > 0) {
      ctx.fillStyle = '#FFFFFF';
    } else {
      // Enemy color by type
      ctx.fillStyle = this.getEnemyColor(enemy);
    }

    // Elite glow effect
    if (enemy.elite) {
      ctx.shadowBlur = 15;
      ctx.shadowColor = '#FFD700';
    }

    // Draw body
    ctx.fillRect(screenPos.x - 10, screenPos.y - 10, 20, 20);

    // Draw head
    ctx.beginPath();
    ctx.arc(screenPos.x, screenPos.y - 14, 5, 0, Math.PI * 2);
    ctx.fill();

    ctx.shadowBlur = 0;

    // HP bar if damaged
    if (enemy.hp < enemy.maxHp) {
      const barWidth = 30;
      const barHeight = 4;
      const hpPercent = enemy.hp / enemy.maxHp;

      ctx.fillStyle = '#222222';
      ctx.fillRect(screenPos.x - barWidth / 2, screenPos.y - 25, barWidth, barHeight);

      ctx.fillStyle = enemy.elite ? '#FFD700' : '#FF4444';
      ctx.fillRect(screenPos.x - barWidth / 2, screenPos.y - 25, barWidth * hpPercent, barHeight);
    }

    // Status effect icons
    if (enemy.statusEffects && enemy.statusEffects.length > 0) {
      enemy.statusEffects.forEach((effect, i) => {
        const iconX = screenPos.x - 10 + i * 8;
        const iconY = screenPos.y - 30;

        ctx.fillStyle = this.getStatusColor(effect.type);
        ctx.fillRect(iconX, iconY, 6, 6);
      });
    }

    ctx.restore();
  },

  getEnemyColor(enemy) {
    const colors = {
      goblin: '#44AA44',
      skeleton: '#AAAAAA',
      zombie: '#668844',
      spider: '#884488',
      ghost: '#4488AA',
      archer: '#AA8844',
      mage: '#8844AA',
      warrior: '#AA4444'
    };

    return colors[enemy.type] || '#666666';
  },

  getStatusColor(type) {
    const colors = {
      poison: '#44FF44',
      burn: '#FF4444',
      freeze: '#4444FF',
      stun: '#FFD700',
      bleed: '#AA0000'
    };

    return colors[type] || '#888888';
  }
};

// === combat/boss-ai.js ===
// combat/boss-ai.js - Multi-phase boss encounter system
// Global BossAI object for Depths of the Abyss

const BossAI = {
  activeTelegraphs: [],

  update(boss, dt) {
    if (!boss || boss.hp <= 0) {
      if (boss && boss.state !== 'dead') {
        this.onDeath(boss);
      }
      return;
    }

    // Check phase transitions
    this.checkPhaseTransition(boss);

    // Update timers
    if (boss.attackCooldown > 0) boss.attackCooldown -= dt;
    if (boss.specialTimer > 0) boss.specialTimer -= dt;
    if (boss.knockbackTimer > 0) {
      boss.x += boss.knockbackX * dt;
      boss.y += boss.knockbackY * dt;
      boss.knockbackTimer -= dt;
      if (boss.knockbackTimer <= 0) {
        boss.knockbackX = 0;
        boss.knockbackY = 0;
      }
    }

    // Decay hit flash
    if (boss.hitFlash > 0) {
      boss.hitFlash -= dt * 5;
    }

    // Execute attack pattern
    this.executePattern(boss, dt);

    // Update telegraphs
    for (let i = this.activeTelegraphs.length - 1; i >= 0; i--) {
      const telegraph = this.activeTelegraphs[i];
      telegraph.timer += dt;

      if (telegraph.timer >= telegraph.delay) {
        // Execute telegraphed attack
        this.executeTelegraph(telegraph);
        this.activeTelegraphs.splice(i, 1);
      }
    }
  },

  checkPhaseTransition(boss) {
    const hpPercent = boss.hp / boss.maxHp;

    // Check if crossed phase threshold
    if (boss.phase < boss.maxPhases) {
      // phase 1 -> check threshold[0] (0.7)
      // phase 2 -> check threshold[1] (0.4)
      // phase 3 -> check threshold[2] (0.15)
      const thresholdIndex = boss.phase - 1;

      if (thresholdIndex < boss.phaseThresholds.length) {
        const nextThreshold = boss.phaseThresholds[thresholdIndex];

        if (hpPercent <= nextThreshold) {
          this.transitionPhase(boss);
        }
      }
    }
  },

  transitionPhase(boss) {
    boss.phase++;

    // Visual feedback
    Camera.shake(15, 0.5);
    SFX.playSFX('boss_phase_change');

    // Brief invulnerability
    boss.invincible = true;
    setTimeout(() => { boss.invincible = false; }, 1000);

    // Dialogue
    // boss.phase was just incremented, so phase 2 uses index 0, phase 3 uses index 1, etc.
    const dialogueIndex = boss.phase - 2;
    if (boss.dialogue.phaseChange && boss.dialogue.phaseChange[dialogueIndex]) {
      const msg = boss.dialogue.phaseChange[dialogueIndex];
      Combat.spawnFloatingText(boss.x, boss.y - 50, msg, '#FFD700');
    }

    // Phase-specific mechanics
    this.onPhaseChange(boss);
  },

  onPhaseChange(boss) {
    switch(boss.bossId) {
      case 'grave_warden':
        if (boss.phase === 2) {
          // Summon 3 skeletons
          for (let i = 0; i < 3; i++) {
            const angle = (i / 3) * Math.PI * 2;
            const x = boss.x + Math.cos(angle) * TILE_SIZE * 3;
            const y = boss.y + Math.sin(angle) * TILE_SIZE * 3;
            const skeleton = EnemyAI.spawn('skeleton', x, y, false, G.currentFloor);
            G.enemies.push(skeleton);
          }
        } else if (boss.phase === 3) {
          // Enraged - faster attacks
          boss.attackSpeed *= 0.7;
        }
        break;

      case 'mycelium_king':
        if (boss.phase === 2) {
          // Split into 3 copies
          this.createMyceliumCopies(boss);
        }
        break;

      case 'infernal_colossus':
        if (boss.phase === 3) {
          // Floor becomes lava
          boss.lavaFloor = true;
        }
        break;

      case 'abyss_incarnate':
        if (boss.phase === 3) {
          // Copy player abilities
          boss.copiedAbilities = G.player.equippedAbilities.slice();
        }
        break;
    }
  },

  executePattern(boss, dt) {
    const p = G.player;

    // Boss-specific attack patterns
    switch(boss.bossId) {
      case 'grave_warden':
        this.graveWardenPattern(boss, p, dt);
        break;

      case 'mycelium_king':
        this.myceliumKingPattern(boss, p, dt);
        break;

      case 'infernal_colossus':
        this.infernalColossusPattern(boss, p, dt);
        break;

      case 'glacial_sovereign':
        this.glacialSovereignPattern(boss, p, dt);
        break;

      case 'abyss_incarnate':
        this.abyssIncarnatePattern(boss, p, dt);
        break;

      default:
        this.genericBossPattern(boss, p, dt);
    }
  },

  graveWardenPattern(boss, player, dt) {
    if (boss.attackCooldown > 0) return;

    const dist = Util.dist(boss.x, boss.y, player.x, player.y);

    if (boss.phase === 1) {
      // Sword combo (3-hit) or shield charge
      const roll = Math.random();

      if (roll < 0.6) {
        this.swordCombo(boss, player);
      } else {
        this.shieldCharge(boss, player);
      }
    } else if (boss.phase === 2) {
      // Ground slam AoE
      this.groundSlam(boss);
    } else {
      // Phase 3: faster attacks + combos
      this.swordCombo(boss, player);
      if (Math.random() < 0.3) {
        setTimeout(() => this.groundSlam(boss), 500);
      }
    }

    boss.attackCooldown = boss.attackSpeed;
  },

  myceliumKingPattern(boss, player, dt) {
    if (boss.attackCooldown > 0) return;

    if (boss.phase === 1) {
      // Spore cloud or vine grab
      const roll = Math.random();

      if (roll < 0.5) {
        this.sporeCloud(boss);
      } else {
        this.vineGrab(boss, player);
      }
    } else if (boss.phase === 3) {
      // Mushroom cage + toxic rain
      this.mushroomCage(boss);
      setTimeout(() => this.toxicRain(boss), 1000);
    }

    boss.attackCooldown = boss.attackSpeed;
  },

  infernalColossusPattern(boss, player, dt) {
    if (boss.attackCooldown > 0) return;

    if (boss.phase === 1) {
      // Fire breath or magma ball
      const roll = Math.random();

      if (roll < 0.5) {
        this.fireBreath(boss, player);
      } else {
        this.magmaBall(boss, player);
      }
    } else if (boss.phase === 2) {
      // Meteor rain
      this.meteorRain(boss);
    } else {
      // Phase 3: body slam
      this.bodySlam(boss, player);
    }

    boss.attackCooldown = boss.attackSpeed;
  },

  glacialSovereignPattern(boss, player, dt) {
    if (boss.attackCooldown > 0) return;

    if (boss.phase === 1) {
      // Ice lance barrage or frost nova
      const roll = Math.random();

      if (roll < 0.5) {
        this.iceLanceBarrage(boss, player);
      } else {
        this.frostNova(boss);
      }
    } else if (boss.phase === 2) {
      // Time freeze
      this.timeFreeze(boss, player);
    } else {
      // Phase 3: blizzard
      this.blizzard(boss);
    }

    boss.attackCooldown = boss.attackSpeed;
  },

  abyssIncarnatePattern(boss, player, dt) {
    if (boss.attackCooldown > 0) return;

    if (boss.phase === 1) {
      // Void beam or shadow orbs
      const roll = Math.random();

      if (roll < 0.5) {
        this.voidBeam(boss, player);
      } else {
        this.shadowOrbs(boss, player);
      }
    } else if (boss.phase === 2) {
      // Copy random previous boss attacks
      this.copyBossAttack(boss, player);
    } else if (boss.phase === 3) {
      // Mirror player abilities
      this.mirrorPlayerAbility(boss, player);
    } else {
      // Phase 4: all elements
      this.elementalBarrage(boss, player);
    }

    boss.attackCooldown = boss.attackSpeed;
  },

  genericBossPattern(boss, player, dt) {
    if (boss.attackCooldown > 0) return;

    const dist = Util.dist(boss.x, boss.y, player.x, player.y);

    if (dist < TILE_SIZE * 2) {
      // Melee attack - use Player.takeDamage instead of Combat.applyDamage (which doesn't exist)
      Player.takeDamage(boss.damage, boss.element, boss.x, boss.y);
    }

    boss.attackCooldown = boss.attackSpeed;
  },

  // BOSS ATTACK IMPLEMENTATIONS

  swordCombo(boss, player) {
    // 3-hit combo
    for (let i = 0; i < 3; i++) {
      setTimeout(() => {
        const hitbox = {
          x: boss.x + (player.x - boss.x) * 0.5,
          y: boss.y + (player.y - boss.y) * 0.5,
          w: TILE_SIZE * 2,
          h: TILE_SIZE * 2
        };

        if (Combat.checkCollision(hitbox, G.player)) {
          Player.takeDamage(boss.damage * (1 + i * 0.2), ELEMENT.PHYSICAL, boss.x, boss.y);
        }

        SFX.playSFX('boss_slash');
      }, i * 300);
    }
  },

  shieldCharge(boss, player) {
    const angle = Util.angle(boss.x, boss.y, player.x, player.y);
    const distance = TILE_SIZE * 4;

    // Charge in direction
    boss.knockbackX = Math.cos(angle) * 400;
    boss.knockbackY = Math.sin(angle) * 400;
    boss.knockbackTimer = 0.5;

    Camera.shake(10, 0.3);
    SFX.playSFX('boss_charge');
  },

  groundSlam(boss) {
    // Telegraphed AoE
    const telegraph = {
      x: boss.x,
      y: boss.y,
      radius: TILE_SIZE * 3,
      damage: boss.damage * 1.5,
      element: ELEMENT.PHYSICAL,
      delay: 0.8,
      timer: 0,
      boss: boss
    };

    this.activeTelegraphs.push(telegraph);
    SFX.playSFX('boss_telegraph');
  },

  sporeCloud(boss) {
    const aoe = {
      x: boss.x,
      y: boss.y,
      radius: TILE_SIZE * 2.5,
      damage: boss.damage * 0.5,
      element: ELEMENT.POISON,
      owner: 'boss',
      lifetime: 3.0,
      timer: 0,
      tickInterval: 0.5
    };

    if (!G.aoeEffects) G.aoeEffects = [];
    G.aoeEffects.push(aoe);

    SFX.playSFX('poison_cloud');
  },

  vineGrab(boss, player) {
    const dist = Util.dist(boss.x, boss.y, player.x, player.y);

    if (dist < TILE_SIZE * 5) {
      // Root player for 1 second
      Combat.applyStatusEffect(player, {
        type: 'stun',
        duration: 1.0,
        tickDamage: 0,
        tickInterval: 0
      });

      Combat.spawnFloatingText(player.x, player.y - 20, 'ROOTED!', '#44AA44');
      SFX.playSFX('vine_grab');
    }
  },

  mushroomCage(boss) {
    // Walls close in (not implemented - visual only)
    Camera.shake(12, 0.4);
    SFX.playSFX('mushroom_cage');
  },

  toxicRain(boss) {
    // Random AoEs
    for (let i = 0; i < 5; i++) {
      setTimeout(() => {
        const x = boss.x + Util.randFloat(-TILE_SIZE * 4, TILE_SIZE * 4);
        const y = boss.y + Util.randFloat(-TILE_SIZE * 4, TILE_SIZE * 4);

        const telegraph = {
          x: x,
          y: y,
          radius: TILE_SIZE,
          damage: boss.damage * 0.7,
          element: ELEMENT.POISON,
          delay: 0.5,
          timer: 0
        };

        this.activeTelegraphs.push(telegraph);
      }, i * 200);
    }

    SFX.playSFX('toxic_rain');
  },

  fireBreath(boss, player) {
    const angle = Util.angle(boss.x, boss.y, player.x, player.y);

    // Cone attack (3 projectiles)
    for (let i = -1; i <= 1; i++) {
      const spreadAngle = angle + (i * 0.3);

      const projectile = {
        x: boss.x,
        y: boss.y,
        vx: Math.cos(spreadAngle) * 200,
        vy: Math.sin(spreadAngle) * 200,
        damage: boss.damage,
        element: ELEMENT.FIRE,
        speed: 200,
        lifetime: 1.5,
        owner: 'boss',
        sprite: 'fire'
      };

      G.projectiles.push(projectile);
    }

    SFX.playSFX('fire_breath');
  },

  magmaBall(boss, player) {
    const angle = Util.angle(boss.x, boss.y, player.x, player.y);

    const projectile = {
      x: boss.x,
      y: boss.y,
      vx: Math.cos(angle) * 250,
      vy: Math.sin(angle) * 250,
      damage: boss.damage * 1.5,
      element: ELEMENT.FIRE,
      speed: 250,
      lifetime: 2.0,
      owner: 'boss',
      sprite: 'magma',
      explodeRadius: TILE_SIZE * 2
    };

    G.projectiles.push(projectile);
    SFX.playSFX('magma_ball');
  },

  meteorRain(boss) {
    // 3 telegraphed AoEs
    for (let i = 0; i < 3; i++) {
      setTimeout(() => {
        const x = boss.x + Util.randFloat(-TILE_SIZE * 5, TILE_SIZE * 5);
        const y = boss.y + Util.randFloat(-TILE_SIZE * 5, TILE_SIZE * 5);

        const telegraph = {
          x: x,
          y: y,
          radius: TILE_SIZE * 2,
          damage: boss.damage * 2,
          element: ELEMENT.FIRE,
          delay: 1.0,
          timer: 0
        };

        this.activeTelegraphs.push(telegraph);
        SFX.playSFX('meteor_incoming');
      }, i * 500);
    }
  },

  bodySlam(boss, player) {
    const angle = Util.angle(boss.x, boss.y, player.x, player.y);

    // Jump to player position
    boss.x = player.x + Math.cos(angle) * TILE_SIZE * 2;
    boss.y = player.y + Math.sin(angle) * TILE_SIZE * 2;

    // AoE damage
    const aoe = {
      x: boss.x,
      y: boss.y,
      radius: TILE_SIZE * 3,
      damage: boss.damage * 2,
      element: ELEMENT.PHYSICAL,
      owner: 'boss',
      lifetime: 0.3,
      timer: 0
    };

    if (!G.aoeEffects) G.aoeEffects = [];
    G.aoeEffects.push(aoe);

    Camera.shake(20, 0.5);
    SFX.playSFX('body_slam');
  },

  iceLanceBarrage(boss, player) {
    // 5 projectiles
    for (let i = 0; i < 5; i++) {
      setTimeout(() => {
        const angle = Util.angle(boss.x, boss.y, player.x, player.y);

        const projectile = {
          x: boss.x,
          y: boss.y,
          vx: Math.cos(angle) * 300,
          vy: Math.sin(angle) * 300,
          damage: boss.damage * 0.8,
          element: ELEMENT.ICE,
          speed: 300,
          lifetime: 2.0,
          owner: 'boss',
          sprite: 'ice_lance'
        };

        G.projectiles.push(projectile);
        SFX.playSFX('ice_lance');
      }, i * 150);
    }
  },

  frostNova(boss) {
    // Ring AoE
    const telegraph = {
      x: boss.x,
      y: boss.y,
      radius: TILE_SIZE * 4,
      damage: boss.damage,
      element: ELEMENT.ICE,
      delay: 0.6,
      timer: 0,
      ring: true
    };

    this.activeTelegraphs.push(telegraph);
    SFX.playSFX('frost_nova');
  },

  timeFreeze(boss, player) {
    // Slow player for 3 seconds
    Combat.applyStatusEffect(player, {
      type: 'freeze',
      duration: 3.0,
      speedMultiplier: 0.5,
      tickDamage: 0,
      tickInterval: 0
    });

    Combat.spawnFloatingText(player.x, player.y - 20, 'TIME FREEZE!', '#4444FF');
    SFX.playSFX('time_freeze');
  },

  blizzard(boss) {
    // Screen-wide damage ticks
    boss.blizzardActive = true;
    boss.blizzardDuration = 5.0;

    SFX.playSFX('blizzard');
  },

  voidBeam(boss, player) {
    // Sweeping laser
    const startAngle = Util.angle(boss.x, boss.y, player.x, player.y);

    for (let i = 0; i < 10; i++) {
      setTimeout(() => {
        const sweepAngle = startAngle + (i / 10) * Math.PI / 2;

        const telegraph = {
          x: boss.x,
          y: boss.y,
          angle: sweepAngle,
          length: TILE_SIZE * 8,
          damage: boss.damage,
          element: ELEMENT.DARK,
          delay: 0.1,
          timer: 0,
          beam: true
        };

        this.activeTelegraphs.push(telegraph);
      }, i * 100);
    }

    SFX.playSFX('void_beam');
  },

  shadowOrbs(boss, player) {
    // Homing projectiles
    for (let i = 0; i < 5; i++) {
      setTimeout(() => {
        const angle = (i / 5) * Math.PI * 2;

        const projectile = {
          x: boss.x,
          y: boss.y,
          vx: Math.cos(angle) * 150,
          vy: Math.sin(angle) * 150,
          damage: boss.damage * 0.6,
          element: ELEMENT.DARK,
          speed: 150,
          lifetime: 3.0,
          owner: 'boss',
          sprite: 'shadow_orb',
          homing: player
        };

        G.projectiles.push(projectile);
      }, i * 200);
    }

    SFX.playSFX('shadow_orbs');
  },

  copyBossAttack(boss, player) {
    // Random attack from previous bosses
    const attacks = [
      () => this.groundSlam(boss),
      () => this.sporeCloud(boss),
      () => this.fireBreath(boss, player),
      () => this.iceLanceBarrage(boss, player)
    ];

    const attack = Util.pick(attacks);
    attack();
  },

  mirrorPlayerAbility(boss, player) {
    // Use player's equipped ability
    if (boss.copiedAbilities && boss.copiedAbilities.length > 0) {
      const abilityId = Util.pick(boss.copiedAbilities.filter(a => a !== null));
      if (abilityId) {
        // Simplified - just trigger effect
        SFX.playSFX('ability_cast');
        Combat.spawnFloatingText(boss.x, boss.y - 30, 'MIMIC!', '#AA44FF');
      }
    }
  },

  elementalBarrage(boss, player) {
    // All elements
    const elements = [ELEMENT.FIRE, ELEMENT.ICE, ELEMENT.LIGHTNING, ELEMENT.DARK];

    elements.forEach((element, i) => {
      setTimeout(() => {
        const angle = Util.angle(boss.x, boss.y, player.x, player.y);

        const projectile = {
          x: boss.x,
          y: boss.y,
          vx: Math.cos(angle) * 280,
          vy: Math.sin(angle) * 280,
          damage: boss.damage,
          element: element,
          speed: 280,
          lifetime: 2.0,
          owner: 'boss',
          sprite: 'elemental'
        };

        G.projectiles.push(projectile);
      }, i * 250);
    });

    SFX.playSFX('elemental_barrage');
  },

  createMyceliumCopies(boss) {
    // Create 2 copies (boss + 2 copies = 3 total)
    for (let i = 0; i < 2; i++) {
      const angle = ((i + 1) / 3) * Math.PI * 2;
      const x = boss.x + Math.cos(angle) * TILE_SIZE * 4;
      const y = boss.y + Math.sin(angle) * TILE_SIZE * 4;

      const copy = {
        ...boss,
        x: x,
        y: y,
        isCopy: true,
        hp: 1,
        maxHp: 1
      };

      G.enemies.push(copy);
    }
  },

  executeTelegraph(telegraph) {
    if (telegraph.beam) {
      // Beam attack
      const dist = Util.dist(telegraph.x, telegraph.y, G.player.x, G.player.y);
      const playerAngle = Util.angle(telegraph.x, telegraph.y, G.player.x, G.player.y);
      const angleDiff = Math.abs(playerAngle - telegraph.angle);

      if (dist < telegraph.length && angleDiff < 0.2) {
        Player.takeDamage(telegraph.damage, telegraph.element, telegraph.x, telegraph.y);
      }
    } else {
      // AoE attack
      const dist = Util.dist(telegraph.x, telegraph.y, G.player.x, G.player.y);

      if (dist <= telegraph.radius) {
        Player.takeDamage(telegraph.damage, telegraph.element, telegraph.x, telegraph.y);
      }
    }

    Camera.shake(8, 0.2);
    SFX.playSFX('boss_impact');
  },

  spawnBoss(bossId, x, y, floor) {
    const bossDef = BOSS_DEFS[bossId];
    if (!bossDef) return null;

    const boss = {
      isBoss: true,
      bossId: bossId,
      name: bossDef.name,
      x: x,
      y: y,
      vx: 0, vy: 0,
      w: 48, h: 48,
      hp: bossDef.hp,
      maxHp: bossDef.hp,
      damage: bossDef.damage,
      speed: bossDef.speed,
      defense: bossDef.defense,
      element: bossDef.element,
      phase: 1,
      maxPhases: bossDef.maxPhases || 3,
      phaseThresholds: bossDef.phaseThresholds || [0.7, 0.4, 0.15],
      attackPattern: bossDef.attackPattern || [],
      patternIndex: 0,
      attackCooldown: 0,
      attackSpeed: bossDef.attackSpeed || 2.0,
      specialTimer: 0,
      specialCooldown: 5,
      dialogue: bossDef.dialogue || { intro: '', phaseChange: [], death: '' },
      arena: bossDef.arena || { x: x - TILE_SIZE * 8, y: y - TILE_SIZE * 8, w: TILE_SIZE * 16, h: TILE_SIZE * 16 },
      hitFlash: 0,
      knockbackX: 0, knockbackY: 0, knockbackTimer: 0,
      invincible: false,
      state: 'active'
    };

    // Set as active boss
    G.bossActive = boss;

    // Play roar
    SFX.playSFX('boss_roar');

    // Camera shake
    Camera.shake(10, 0.3);

    // Dialogue
    if (boss.dialogue.intro) {
      Combat.spawnFloatingText(boss.x, boss.y - 60, boss.dialogue.intro, '#FFD700');
    }

    return boss;
  },

  onDeath(boss) {
    boss.state = 'dead';
    boss.hp = 0;

    // Play death sound
    SFX.playSFX('boss_death');

    // Camera shake
    Camera.shake(25, 0.8);

    // Dialogue
    if (boss.dialogue.death) {
      Combat.spawnFloatingText(boss.x, boss.y - 60, boss.dialogue.death, '#FF4444');
    }

    // Drop legendary loot
    for (let i = 0; i < 3; i++) {
      const loot = {
        x: boss.x + Util.randFloat(-TILE_SIZE, TILE_SIZE),
        y: boss.y + Util.randFloat(-TILE_SIZE, TILE_SIZE),
        type: 'item',
        item: generateWeapon(G.currentFloor, RARITY.LEGENDARY)
      };

      if (!G.lootDrops) G.lootDrops = [];
      G.lootDrops.push(loot);
    }

    // Award massive XP
    Player.addXP(boss.maxHp);

    // Update stats
    if (!G.runStats) G.runStats = {};
    if (!G.runStats.bossesKilled) G.runStats.bossesKilled = 0;
    G.runStats.bossesKilled++;

    // Clear active boss
    G.bossActive = null;

    // Spawn stairs (not implemented here)
  },

  render(boss, ctx, camera) {
    if (!boss || boss.state === 'dead') return;

    const screenPos = Camera.worldToScreen(boss.x, boss.y);

    ctx.save();

    // Draw shadow
    ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
    ctx.beginPath();
    ctx.ellipse(screenPos.x, screenPos.y + 20, 30, 10, 0, 0, Math.PI * 2);
    ctx.fill();

    // Flash white when hit
    if (boss.hitFlash > 0) {
      ctx.fillStyle = '#FFFFFF';
    } else {
      // Boss color changes per phase
      ctx.fillStyle = this.getPhaseColor(boss);
    }

    // Phase-specific aura
    ctx.shadowBlur = 20 + boss.phase * 5;
    ctx.shadowColor = this.getPhaseColor(boss);

    // Draw large boss body
    ctx.fillRect(screenPos.x - 24, screenPos.y - 24, 48, 48);

    // Draw head
    ctx.beginPath();
    ctx.arc(screenPos.x, screenPos.y - 30, 15, 0, Math.PI * 2);
    ctx.fill();

    ctx.shadowBlur = 0;

    ctx.restore();

    // Draw telegraphs
    this.renderTelegraphs(ctx, camera);
  },

  getPhaseColor(boss) {
    const colors = {
      1: '#AA4444',
      2: '#AA8844',
      3: '#8844AA',
      4: '#4444AA'
    };

    return colors[boss.phase] || '#AA4444';
  },

  renderTelegraphs(ctx, camera) {
    this.activeTelegraphs.forEach(telegraph => {
      const screenPos = Camera.worldToScreen(telegraph.x, telegraph.y);
      const progress = telegraph.timer / telegraph.delay;

      ctx.save();
      ctx.globalAlpha = 0.3 + progress * 0.4;

      if (telegraph.beam) {
        // Draw beam line
        ctx.strokeStyle = '#FF0000';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(screenPos.x, screenPos.y);
        const endX = screenPos.x + Math.cos(telegraph.angle) * telegraph.length;
        const endY = screenPos.y + Math.sin(telegraph.angle) * telegraph.length;
        ctx.lineTo(endX, endY);
        ctx.stroke();
      } else {
        // Draw AoE circle
        ctx.strokeStyle = '#FF0000';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(screenPos.x, screenPos.y, telegraph.radius, 0, Math.PI * 2);
        ctx.stroke();
      }

      ctx.restore();
    });
  }
};

// === combat/collision.js ===
// combat/collision.js - Collision detection, damage calculation, projectile management
// Global Combat object for Depths of the Abyss

const Combat = {
  floatingTexts: [],

  update(dt) {
    const p = G.player;

    // 1. Player weapon vs enemies
    if (p.attacking) {
      const hitbox = Player.getAttackHitbox();

      if (hitbox) {
        // Find active swing
        const swing = Weapons.activeSwings.find(s => s.player === p);

        G.enemies.forEach(enemy => {
          if (enemy.hp <= 0) return;

          // Check if already hit by this swing
          if (swing && swing.hitEntities.has(enemy.id)) return;

          // Check collision
          if (this.checkCollision(hitbox, enemy)) {
            // Calculate damage
            const damageData = Weapons.getDamage(p.weapon, p, swing ? swing.comboHit : 1);

            // Apply damage
            const knockbackX = enemy.x - p.x;
            const knockbackY = enemy.y - p.y;
            EnemyAI.takeDamage(enemy, damageData.damage, damageData.element, knockbackX, knockbackY);

            // Track hit
            if (swing) {
              swing.hitEntities.add(enemy.id);
            }

            // Increment combo
            G.combo++;
            G.comboTimer = 3.0;

            // Play hit sound
            this.playHitSound(p.weapon.type);

            // Spawn particles
            this.spawnHitParticles(enemy.x, enemy.y, damageData.element);

            // Critical text
            if (damageData.isCritical) {
              this.spawnFloatingText(enemy.x, enemy.y - 30, 'CRITICAL!', '#FFD700');
            }

            // Camera shake on hit
            Camera.shake(3, 0.1);

            // Track damage dealt
            p.totalDamageDealt += damageData.damage;
          }
        });

        // Check boss hit
        if (G.bossActive && G.bossActive.hp > 0) {
          if (this.checkCollision(hitbox, G.bossActive)) {
            if (!swing || !swing.hitEntities.has('boss')) {
              const damageData = Weapons.getDamage(p.weapon, p, swing ? swing.comboHit : 1);

              if (!G.bossActive.invincible) {
                G.bossActive.hp -= damageData.damage;
                G.bossActive.hitFlash = 0.15;

                this.spawnFloatingText(G.bossActive.x, G.bossActive.y - 40, '-' + damageData.damage, '#FF4444');

                if (damageData.isCritical) {
                  this.spawnFloatingText(G.bossActive.x, G.bossActive.y - 50, 'CRITICAL!', '#FFD700');
                }

                G.combo++;
                G.comboTimer = 3.0;

                this.playHitSound(p.weapon.type);
                Camera.shake(5, 0.15);

                p.totalDamageDealt += damageData.damage;
              }

              if (swing) swing.hitEntities.add('boss');
            }
          }
        }
      }
    }

    // 2. Enemy attacks vs player
    G.enemies.forEach(enemy => {
      if (enemy.state !== 'attack') return;
      if (enemy.attackCooldown > 0.1) return; // Only check at start of attack

      const dist = Util.dist(enemy.x, enemy.y, p.x, p.y);

      if (dist <= enemy.attackRange) {
        // Create hitbox
        const hitbox = {
          x: enemy.x - enemy.attackRange / 2,
          y: enemy.y - enemy.attackRange / 2,
          w: enemy.attackRange,
          h: enemy.attackRange
        };

        if (this.checkCollision(hitbox, p)) {
          Player.takeDamage(enemy.damage, enemy.element, enemy.x, enemy.y);
        }
      }
    });

    // Boss melee attacks
    if (G.bossActive && G.bossActive.state === 'attack') {
      const dist = Util.dist(G.bossActive.x, G.bossActive.y, p.x, p.y);

      if (dist <= TILE_SIZE * 3) {
        const hitbox = {
          x: G.bossActive.x - TILE_SIZE * 1.5,
          y: G.bossActive.y - TILE_SIZE * 1.5,
          w: TILE_SIZE * 3,
          h: TILE_SIZE * 3
        };

        if (this.checkCollision(hitbox, p)) {
          Player.takeDamage(G.bossActive.damage, G.bossActive.element, G.bossActive.x, G.bossActive.y);
        }
      }
    }

    // 3. Update and collide projectiles
    this.updateProjectiles(dt);

    // 4. Update and apply AoE effects
    this.updateAoEEffects(dt);

    // 5. Update floating text
    this.updateFloatingTexts(dt);

    // Update weapon swings
    Weapons.updateAttack(p, dt);
  },

  checkCollision(a, b) {
    // AABB overlap test
    // Handle both center-based entities and corner-based hitboxes

    // If 'a' has explicit x,y,w,h as corners (like hitboxes from getAttackHitbox)
    // we check if it's a corner-based box by seeing if w,h exist
    let aLeft, aRight, aTop, aBottom;

    if (a.w !== undefined && a.h !== undefined) {
      // Could be either center-based or corner-based
      // Player.getAttackHitbox() returns corner-based {x,y,w,h}
      // Check if this is a hitbox (has larger dimensions than entity size)
      if (a.w > 50 || a.h > 50) {
        // Likely a corner-based hitbox from getAttackHitbox
        aLeft = a.x;
        aRight = a.x + a.w;
        aTop = a.y;
        aBottom = a.y + a.h;
      } else {
        // Center-based entity
        aLeft = a.x - a.w / 2;
        aRight = a.x + a.w / 2;
        aTop = a.y - a.h / 2;
        aBottom = a.y + a.h / 2;
      }
    } else {
      // Default to center-based with 24x24 size
      aLeft = a.x - 12;
      aRight = a.x + 12;
      aTop = a.y - 12;
      aBottom = a.y + 12;
    }

    let bLeft, bRight, bTop, bBottom;

    if (b.w !== undefined && b.h !== undefined) {
      // Center-based entity (player, enemy, projectile)
      bLeft = b.x - b.w / 2;
      bRight = b.x + b.w / 2;
      bTop = b.y - b.h / 2;
      bBottom = b.y + b.h / 2;
    } else {
      // Default
      bLeft = b.x - 12;
      bRight = b.x + 12;
      bTop = b.y - 12;
      bBottom = b.y + 12;
    }

    // Overlap detection
    return !(aRight < bLeft || aLeft > bRight || aBottom < bTop || aTop > bBottom);
  },

  calculateDamage(baseDamage, attackerStats, defenderStats, element, critChance) {
    // Base damage calculation
    let finalDamage = baseDamage;

    // Add attacker stat scaling
    if (attackerStats) {
      if (element === ELEMENT.PHYSICAL) {
        finalDamage += attackerStats.str * 0.5;
      } else {
        finalDamage += attackerStats.int * 0.5;
      }
    }

    // Critical hit check
    const critRoll = Math.random();
    const isCritical = critRoll < (critChance || 0.1);

    if (isCritical) {
      const critMultiplier = attackerStats?.critMultiplier || 2.0;
      finalDamage *= critMultiplier;
    }

    // Combo multiplier
    const comboMultipliers = [1.0, 1.2, 1.5, 1.8, 2.0];
    const comboLevel = Math.min(G.combo, 4);
    finalDamage *= comboMultipliers[comboLevel];

    // Element effectiveness
    if (defenderStats && defenderStats.element) {
      const elementMultiplier = this.getElementMultiplier(element, defenderStats.element);
      finalDamage *= elementMultiplier;
    }

    // Apply defense
    if (defenderStats && defenderStats.defense) {
      finalDamage -= defenderStats.defense;
    }

    // Minimum damage
    finalDamage = Math.max(1, Math.floor(finalDamage));

    return {
      damage: finalDamage,
      isCritical: isCritical,
      element: element
    };
  },

  getElementMultiplier(attackElement, defenderElement) {
    // Element effectiveness: fire>ice>lightning>fire
    const effectiveness = {
      [ELEMENT.FIRE]: { [ELEMENT.ICE]: 1.5, [ELEMENT.LIGHTNING]: 0.75 },
      [ELEMENT.ICE]: { [ELEMENT.LIGHTNING]: 1.5, [ELEMENT.FIRE]: 0.75 },
      [ELEMENT.LIGHTNING]: { [ELEMENT.FIRE]: 1.5, [ELEMENT.ICE]: 0.75 },
      [ELEMENT.POISON]: {},
      [ELEMENT.DARK]: {},
      [ELEMENT.PHYSICAL]: {}
    };

    return effectiveness[attackElement]?.[defenderElement] || 1.0;
  },

  applyKnockback(entity, fromX, fromY, force) {
    const angle = Util.angle(fromX, fromY, entity.x, entity.y);

    entity.knockbackX = Math.cos(angle) * force;
    entity.knockbackY = Math.sin(angle) * force;
    entity.knockbackTimer = 0.15;
  },

  applyStatusEffect(entity, effect) {
    if (!entity.statusEffects) entity.statusEffects = [];

    // Check if effect already exists
    const existing = entity.statusEffects.find(e => e.type === effect.type);

    if (existing) {
      // Refresh duration
      existing.duration = Math.max(existing.duration, effect.duration);
    } else {
      // Add new effect
      entity.statusEffects.push({
        type: effect.type,
        duration: effect.duration,
        tickDamage: effect.tickDamage || 0,
        tickInterval: effect.tickInterval || 1.0,
        timer: 0,
        source: effect.source || 'unknown'
      });
    }
  },

  updateProjectiles(dt) {
    if (!G.projectiles) G.projectiles = [];

    for (let i = G.projectiles.length - 1; i >= 0; i--) {
      const proj = G.projectiles[i];

      // Update homing
      if (proj.homing) {
        const target = proj.homing;
        const angle = Util.angle(proj.x, proj.y, target.x, target.y);
        const turnSpeed = 0.1;

        const currentAngle = Math.atan2(proj.vy, proj.vx);
        const newAngle = Util.lerp(currentAngle, angle, turnSpeed);

        proj.vx = Math.cos(newAngle) * proj.speed;
        proj.vy = Math.sin(newAngle) * proj.speed;
      }

      // Move projectile
      proj.x += proj.vx * dt;
      proj.y += proj.vy * dt;

      // Decrement lifetime
      proj.lifetime -= dt;
      if (proj.lifetime <= 0) {
        G.projectiles.splice(i, 1);
        continue;
      }

      // Check bounds (off map)
      const tileX = Math.floor(proj.x / TILE_SIZE);
      const tileY = Math.floor(proj.y / TILE_SIZE);

      if (!TileMap.isWalkable(tileX, tileY)) {
        // Hit wall
        if (!proj.piercing) {
          this.spawnHitParticles(proj.x, proj.y, proj.element);
          SFX.playSFX('projectile_impact');
          G.projectiles.splice(i, 1);
          continue;
        }
      }

      // Check collision
      if (proj.owner === 'player') {
        // Player projectile vs enemies
        let hit = false;

        G.enemies.forEach(enemy => {
          if (hit) return;
          if (enemy.hp <= 0) return;

          if (this.checkCollision(proj, enemy)) {
            // Apply damage
            const knockbackX = enemy.x - proj.x;
            const knockbackY = enemy.y - proj.y;
            EnemyAI.takeDamage(enemy, proj.damage, proj.element, knockbackX, knockbackY);

            // Effects
            this.spawnHitParticles(proj.x, proj.y, proj.element);
            SFX.playSFX('projectile_impact');

            // Explode if has radius
            if (proj.explodeRadius) {
              this.createExplosion(proj.x, proj.y, proj.explodeRadius, proj.damage * 0.7, proj.element);
            }

            hit = true;

            if (!proj.piercing) {
              G.projectiles.splice(i, 1);
            }
          }
        });

        // Check boss
        if (!hit && G.bossActive && G.bossActive.hp > 0) {
          if (this.checkCollision(proj, G.bossActive)) {
            if (!G.bossActive.invincible) {
              G.bossActive.hp -= proj.damage;
              G.bossActive.hitFlash = 0.15;

              this.spawnFloatingText(G.bossActive.x, G.bossActive.y - 40, '-' + proj.damage, '#FF4444');
            }

            this.spawnHitParticles(proj.x, proj.y, proj.element);
            SFX.playSFX('projectile_impact');

            if (proj.explodeRadius) {
              this.createExplosion(proj.x, proj.y, proj.explodeRadius, proj.damage * 0.7, proj.element);
            }

            if (!proj.piercing) {
              G.projectiles.splice(i, 1);
            }
          }
        }
      } else {
        // Enemy/boss projectile vs player
        if (this.checkCollision(proj, G.player)) {
          Player.takeDamage(proj.damage, proj.element, proj.x, proj.y);

          this.spawnHitParticles(proj.x, proj.y, proj.element);
          SFX.playSFX('projectile_impact');

          if (proj.explodeRadius) {
            this.createExplosion(proj.x, proj.y, proj.explodeRadius, proj.damage * 0.7, proj.element);
          }

          if (!proj.piercing) {
            G.projectiles.splice(i, 1);
          }
        }
      }
    }
  },

  updateAoEEffects(dt) {
    if (!G.aoeEffects) G.aoeEffects = [];

    for (let i = G.aoeEffects.length - 1; i >= 0; i--) {
      const aoe = G.aoeEffects[i];

      // Handle delay
      if (aoe.delay) {
        aoe.delay -= dt;
        continue;
      }

      aoe.timer += dt;

      // Tick damage
      if (aoe.tickInterval && aoe.timer >= aoe.tickInterval) {
        // Damage all entities in radius
        const dist = Util.dist(aoe.x, aoe.y, G.player.x, G.player.y);

        if (dist <= aoe.radius) {
          Player.takeDamage(aoe.damage, aoe.element, aoe.x, aoe.y);
        }

        aoe.timer = 0;
      }

      // Decrement lifetime
      aoe.lifetime -= dt;

      if (aoe.lifetime <= 0) {
        // On expire, damage entities in radius
        if (!aoe.tickInterval) {
          // Instant damage
          const distToPlayer = Util.dist(aoe.x, aoe.y, G.player.x, G.player.y);

          if (aoe.owner !== 'player' && distToPlayer <= aoe.radius) {
            Player.takeDamage(aoe.damage, aoe.element, aoe.x, aoe.y);
          }

          if (aoe.owner === 'player') {
            G.enemies.forEach(enemy => {
              const dist = Util.dist(aoe.x, aoe.y, enemy.x, enemy.y);
              if (dist <= aoe.radius) {
                const knockbackX = enemy.x - aoe.x;
                const knockbackY = enemy.y - aoe.y;
                EnemyAI.takeDamage(enemy, aoe.damage, aoe.element, knockbackX, knockbackY);
              }
            });
          }
        }

        G.aoeEffects.splice(i, 1);
      }
    }
  },

  createExplosion(x, y, radius, damage, element) {
    const aoe = {
      x: x,
      y: y,
      radius: radius,
      damage: damage,
      element: element,
      owner: 'player',
      lifetime: 0.3,
      timer: 0
    };

    if (!G.aoeEffects) G.aoeEffects = [];
    G.aoeEffects.push(aoe);

    Camera.shake(10, 0.3);
    SFX.playSFX('explosion');
  },

  spawnHitParticles(x, y, element) {
    // Simple particle spawn (visual feedback)
    // Particles system would be in render or separate module
    if (!G.particles) G.particles = [];

    const color = this.getElementColor(element);

    for (let i = 0; i < 5; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 50 + Math.random() * 50;

      G.particles.push({
        x: x,
        y: y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        lifetime: 0.3,
        color: color,
        size: 2 + Math.random() * 2
      });
    }
  },

  getElementColor(element) {
    const colors = {
      [ELEMENT.FIRE]: '#FF4444',
      [ELEMENT.ICE]: '#4444FF',
      [ELEMENT.LIGHTNING]: '#FFFF44',
      [ELEMENT.POISON]: '#44FF44',
      [ELEMENT.DARK]: '#AA44AA',
      [ELEMENT.PHYSICAL]: '#AAAAAA'
    };

    return colors[element] || '#FFFFFF';
  },

  playHitSound(weaponType) {
    const sounds = {
      sword: 'sword_hit',
      axe: 'axe_hit',
      dagger: 'dagger_hit',
      spear: 'spear_hit',
      hammer: 'hammer_hit',
      staff: 'magic_hit',
      bow: 'arrow_hit',
      scythe: 'slash_hit'
    };

    const sound = sounds[weaponType] || 'hit';
    SFX.playSFX(sound);
  },

  spawnFloatingText(x, y, text, color) {
    this.floatingTexts.push({
      x: x,
      y: y,
      text: text,
      color: color,
      lifetime: 1.0,
      vy: -30
    });
  },

  updateFloatingTexts(dt) {
    for (let i = this.floatingTexts.length - 1; i >= 0; i--) {
      const text = this.floatingTexts[i];

      text.y += text.vy * dt;
      text.lifetime -= dt;

      if (text.lifetime <= 0) {
        this.floatingTexts.splice(i, 1);
      }
    }
  },

  renderProjectiles(ctx, camera) {
    if (!G.projectiles) return;

    G.projectiles.forEach(proj => {
      const screenPos = Camera.worldToScreen(proj.x, proj.y);

      ctx.save();

      // Different visuals per projectile type
      switch(proj.sprite) {
        case 'bow':
        case 'knife':
          // Arrow/knife - thin line
          ctx.strokeStyle = '#888888';
          ctx.lineWidth = 2;

          const angle = Math.atan2(proj.vy, proj.vx);
          const length = 12;

          ctx.beginPath();
          ctx.moveTo(screenPos.x - Math.cos(angle) * length, screenPos.y - Math.sin(angle) * length);
          ctx.lineTo(screenPos.x + Math.cos(angle) * length, screenPos.y + Math.sin(angle) * length);
          ctx.stroke();
          break;

        case 'fireball':
        case 'magma':
          // Fireball - orange circle + trail
          ctx.fillStyle = '#FF6600';
          ctx.shadowBlur = 15;
          ctx.shadowColor = '#FF6600';
          ctx.beginPath();
          ctx.arc(screenPos.x, screenPos.y, 6, 0, Math.PI * 2);
          ctx.fill();
          break;

        case 'ice_lance':
          // Ice shard - blue diamond
          ctx.fillStyle = '#4488FF';
          ctx.shadowBlur = 10;
          ctx.shadowColor = '#4488FF';
          ctx.beginPath();
          ctx.moveTo(screenPos.x, screenPos.y - 8);
          ctx.lineTo(screenPos.x + 4, screenPos.y);
          ctx.lineTo(screenPos.x, screenPos.y + 8);
          ctx.lineTo(screenPos.x - 4, screenPos.y);
          ctx.closePath();
          ctx.fill();
          break;

        case 'arcane_missile':
          // Purple orb
          ctx.fillStyle = '#AA44FF';
          ctx.shadowBlur = 12;
          ctx.shadowColor = '#AA44FF';
          ctx.beginPath();
          ctx.arc(screenPos.x, screenPos.y, 5, 0, Math.PI * 2);
          ctx.fill();
          break;

        case 'shadow_orb':
          // Dark orb
          ctx.fillStyle = '#442288';
          ctx.shadowBlur = 10;
          ctx.shadowColor = '#442288';
          ctx.beginPath();
          ctx.arc(screenPos.x, screenPos.y, 6, 0, Math.PI * 2);
          ctx.fill();
          break;

        default:
          // Generic projectile
          const color = this.getElementColor(proj.element);
          ctx.fillStyle = color;
          ctx.beginPath();
          ctx.arc(screenPos.x, screenPos.y, 4, 0, Math.PI * 2);
          ctx.fill();
      }

      ctx.restore();
    });
  },

  renderFloatingTexts(ctx, camera) {
    this.floatingTexts.forEach(text => {
      const screenPos = Camera.worldToScreen(text.x, text.y);

      ctx.save();
      ctx.globalAlpha = text.lifetime;
      ctx.fillStyle = text.color;
      ctx.font = 'bold 14px monospace';
      ctx.textAlign = 'center';
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 3;

      ctx.strokeText(text.text, screenPos.x, screenPos.y);
      ctx.fillText(text.text, screenPos.x, screenPos.y);

      ctx.restore();
    });
  },

  renderParticles(ctx, camera) {
    if (!G.particles) return;

    for (let i = G.particles.length - 1; i >= 0; i--) {
      const particle = G.particles[i];

      particle.x += particle.vx * G.dt;
      particle.y += particle.vy * G.dt;
      particle.lifetime -= G.dt;

      if (particle.lifetime <= 0) {
        G.particles.splice(i, 1);
        continue;
      }

      const screenPos = Camera.worldToScreen(particle.x, particle.y);

      ctx.save();
      ctx.globalAlpha = particle.lifetime / 0.3;
      ctx.fillStyle = particle.color;
      ctx.beginPath();
      ctx.arc(screenPos.x, screenPos.y, particle.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }
};

// === systems/inventory.js ===
// Inventory System  Item management, equipment, ground items, loot drops
// Defines global Inventory object
// Dependencies: G, STATE, TILE_SIZE, ELEMENT, RARITY, RARITY_COLORS from constants.js
//               Util from utils.js, SFX from audio.js
//               WEAPON_TYPES, ARMOR_TYPES, CONSUMABLES, MATERIALS, generateWeapon, LOOT_TABLES from data/items.js
//               Player from combat/player.js, Camera from world/camera.js

const Inventory = {
  maxInventory: 20,
  groundItems: [], // {item, x, y, bobTimer}

  init() {
    G.player.inventory = [];
    G.player.equipped = {
      weapon: null,
      helmet: null,
      chest: null,
      legs: null,
      boots: null,
      amulet: null,
      ring: null
    };
    this.groundItems = [];
  },

  addItem(item) {
    // Check if stackable and already exists
    if (item.stackable) {
      const existing = G.player.inventory.find(i => i.id === item.id);
      if (existing) {
        existing.count = (existing.count || 1) + (item.count || 1);
        SFX.playSound('pickup_item');
        return true;
      }
    }

    // Check inventory capacity
    if (G.player.inventory.length >= this.maxInventory) {
      // Show "Inventory Full" floating text
      if (window.HUD) {
        HUD.addFloatingText(G.player.x, G.player.y - 16, 'Inventory Full', '#ff4444', 18);
      }
      return false;
    }

    // Add to inventory
    G.player.inventory.push(item);
    SFX.playSound('pickup_item');
    return true;
  },

  removeItem(index) {
    if (index >= 0 && index < G.player.inventory.length) {
      G.player.inventory.splice(index, 1);
    }
  },

  removeItemById(id, count = 1) {
    let remaining = count;
    for (let i = G.player.inventory.length - 1; i >= 0 && remaining > 0; i--) {
      const item = G.player.inventory[i];
      if (item.id === id) {
        if (item.stackable && item.count > 1) {
          const removeAmount = Math.min(item.count, remaining);
          item.count -= removeAmount;
          remaining -= removeAmount;
          if (item.count <= 0) {
            this.removeItem(i);
          }
        } else {
          this.removeItem(i);
          remaining--;
        }
      }
    }
  },

  equipItem(index) {
    const item = G.player.inventory[index];
    if (!item || (item.type !== 'weapon' && item.type !== 'armor')) {
      return;
    }

    const slot = item.slot;
    const currentEquipped = G.player.equipped[slot];

    // Swap items
    if (currentEquipped) {
      G.player.inventory[index] = currentEquipped;
    } else {
      this.removeItem(index);
    }

    G.player.equipped[slot] = item;
    this.recalculateStats();
    SFX.playSound('equip_item');
  },

  unequipItem(slot) {
    const item = G.player.equipped[slot];
    if (!item) return;

    if (this.addItem(item)) {
      G.player.equipped[slot] = null;
      this.recalculateStats();
    }
  },

  useItem(index) {
    const item = G.player.inventory[index];
    if (!item || item.type !== 'consumable') return;

    let consumed = false;

    switch (item.id) {
      case 'health_potion':
        Player.heal(50);
        consumed = true;
        break;

      case 'mana_potion':
        G.player.mana = Math.min(G.player.maxMana, G.player.mana + 30);
        consumed = true;
        break;

      case 'stamina_tonic':
        G.player.stamina = Math.min(G.player.maxStamina, G.player.stamina + 50);
        consumed = true;
        break;

      case 'antidote':
        // Remove poison and burn effects
        G.player.statusEffects = G.player.statusEffects.filter(e => e.type !== 'poison' && e.type !== 'burn');
        consumed = true;
        break;

      case 'fire_bomb':
        // AoE fire damage at cursor (or player position if no cursor)
        const bombX = Input.mouse ? Input.mouse.worldX : G.player.x;
        const bombY = Input.mouse ? Input.mouse.worldY : G.player.y;
        this.createAoEDamage(bombX, bombY, 64, 30, ELEMENT.FIRE);
        if (window.FX) FX.fire(bombX, bombY);
        SFX.playSound('explosion');
        consumed = true;
        break;

      case 'ice_shard':
        // Freeze nearby enemies for 2s
        if (window.EnemyManager) {
          const nearbyEnemies = EnemyManager.enemies.filter(e => {
            const dist = Math.hypot(e.x - G.player.x, e.y - G.player.y);
            return dist < 96;
          });
          nearbyEnemies.forEach(enemy => {
            enemy.statusEffects = enemy.statusEffects || [];
            enemy.statusEffects.push({ type: 'freeze', duration: 2.0 });
          });
          if (window.FX) FX.ice(G.player.x, G.player.y);
        }
        consumed = true;
        break;

      case 'scroll_of_return':
        // Teleport to last campfire
        if (G.lastCampfire) {
          G.player.x = G.lastCampfire.x;
          G.player.y = G.lastCampfire.y;
          if (window.FX) FX.magic(G.player.x, G.player.y, '#00ffff');
          SFX.playSound('teleport');
          consumed = true;
        }
        break;

      case 'elixir_of_power':
        // +25% damage for 30s
        G.player.statusEffects = G.player.statusEffects || [];
        G.player.statusEffects.push({ type: 'power', duration: 30.0, mult: 1.25 });
        if (window.FX) FX.magic(G.player.x, G.player.y, '#ff00ff');
        consumed = true;
        break;
    }

    if (consumed) {
      SFX.playSound('use_item');
      if (item.stackable && item.count > 1) {
        item.count--;
      } else {
        this.removeItem(index);
      }
    }
  },

  createAoEDamage(x, y, radius, damage, element) {
    // Apply damage to all enemies in radius
    if (!window.EnemyManager) return;

    EnemyManager.enemies.forEach(enemy => {
      const dist = Math.hypot(enemy.x - x, enemy.y - y);
      if (dist < radius) {
        if (window.Combat) {
          Combat.damageEnemy(enemy, damage, element);
        } else {
          enemy.hp -= damage;
        }
      }
    });

    if (window.FX) {
      FX.explosion(x, y, radius, element === ELEMENT.FIRE ? '#ff4400' : '#4488ff');
    }
    if (window.Camera) {
      Camera.shake(5, 0.3);
    }
  },

  dropItem(index) {
    const item = G.player.inventory[index];
    if (!item) return;

    this.groundItems.push({
      item: item,
      x: G.player.x,
      y: G.player.y,
      bobTimer: 0
    });

    this.removeItem(index);
    SFX.playSound('drop_item');
  },

  getGroundItems() {
    return this.groundItems.filter(gi => {
      const dist = Math.hypot(gi.x - G.player.x, gi.y - G.player.y);
      return dist < TILE_SIZE * 2;
    });
  },

  pickupNearby() {
    for (let i = this.groundItems.length - 1; i >= 0; i--) {
      const gi = this.groundItems[i];
      const dist = Math.hypot(gi.x - G.player.x, gi.y - G.player.y);
      if (dist < TILE_SIZE) {
        if (this.addItem(gi.item)) {
          this.groundItems.splice(i, 1);
        }
      }
    }
  },

  spawnLoot(x, y, floor, rarityBoost = 0) {
    if (!window.LOOT_TABLES) return;

    const table = LOOT_TABLES[Math.min(floor, LOOT_TABLES.length - 1)];
    const numItems = Util.randInt(table.minItems, table.maxItems);

    for (let i = 0; i < numItems; i++) {
      let item = null;
      const roll = Math.random();

      if (roll < table.weaponChance) {
        item = generateWeapon(floor, rarityBoost);
      } else if (roll < table.weaponChance + table.armorChance) {
        item = this.generateArmor(floor, rarityBoost);
      } else if (roll < table.weaponChance + table.armorChance + table.consumableChance) {
        item = this.generateConsumable();
      } else {
        item = this.generateMaterial(floor);
      }

      if (item) {
        const offsetX = Util.randFloat(-16, 16);
        const offsetY = Util.randFloat(-16, 16);
        this.groundItems.push({
          item: item,
          x: x + offsetX,
          y: y + offsetY,
          bobTimer: Math.random() * Math.PI * 2
        });

        if (window.FX) {
          FX.loot(x + offsetX, y + offsetY, item.rarity);
        }
      }
    }
  },

  generateArmor(floor, rarityBoost = 0) {
    const slots = ['helmet', 'chest', 'legs', 'boots', 'amulet', 'ring'];
    const slot = Util.pick(slots);
    const armorType = ARMOR_TYPES[slot] ? Util.pick(ARMOR_TYPES[slot]) : null;
    if (!armorType) return null;

    const rarity = Math.min(4, Math.max(0, Math.floor(floor / 5) + Util.randInt(-1, 1) + rarityBoost));

    return {
      id: `${armorType.id}_${Date.now()}_${Math.random()}`,
      name: `${Object.keys(RARITY)[rarity]} ${armorType.name}`,
      type: 'armor',
      slot: slot,
      rarity: rarity,
      stats: {
        defense: armorType.defense * (1 + rarity * 0.3),
        hp: armorType.hp || 0,
        mana: armorType.mana || 0,
        stamina: armorType.stamina || 0
      },
      element: armorType.element || ELEMENT.PHYSICAL,
      description: armorType.description,
      spriteColor: RARITY_COLORS[rarity],
      stackable: false
    };
  },

  generateConsumable() {
    const consumable = Util.pick(CONSUMABLES);
    return {
      id: consumable.id,
      name: consumable.name,
      type: 'consumable',
      rarity: consumable.rarity,
      description: consumable.description,
      spriteColor: consumable.color,
      stackable: true,
      count: 1
    };
  },

  generateMaterial(floor) {
    const material = Util.pick(MATERIALS);
    return {
      id: material.id,
      name: material.name,
      type: 'material',
      rarity: material.rarity,
      description: material.description,
      spriteColor: material.color,
      stackable: true,
      count: Util.randInt(1, 3)
    };
  },

  recalculateStats() {
    // Reset to base stats
    const base = {
      defense: 5,
      damage: 10,
      maxHp: 100,
      maxMana: 50,
      maxStamina: 100,
      fireResist: 0,
      iceResist: 0,
      lightningResist: 0,
      darkResist: 0,
      poisonResist: 0
    };

    // Add equipment bonuses
    for (const slot in G.player.equipped) {
      const item = G.player.equipped[slot];
      if (item && item.stats) {
        base.defense += item.stats.defense || 0;
        base.damage += item.stats.damage || 0;
        base.maxHp += item.stats.hp || 0;
        base.maxMana += item.stats.mana || 0;
        base.maxStamina += item.stats.stamina || 0;
        base.fireResist += item.stats.fireResist || 0;
        base.iceResist += item.stats.iceResist || 0;
        base.lightningResist += item.stats.lightningResist || 0;
        base.darkResist += item.stats.darkResist || 0;
        base.poisonResist += item.stats.poisonResist || 0;
      }
    }

    // Apply to player
    G.player.defense = base.defense;
    G.player.damage = base.damage;
    G.player.maxHp = base.maxHp;
    G.player.maxMana = base.maxMana;
    G.player.maxStamina = base.maxStamina;
    G.player.fireResist = base.fireResist;
    G.player.iceResist = base.iceResist;
    G.player.lightningResist = base.lightningResist;
    G.player.darkResist = base.darkResist;
    G.player.poisonResist = base.poisonResist;

    // Cap HP/mana/stamina to new max
    G.player.hp = Math.min(G.player.hp, G.player.maxHp);
    G.player.mana = Math.min(G.player.mana, G.player.maxMana);
    G.player.stamina = Math.min(G.player.stamina, G.player.maxStamina);
  },

  sortInventory(mode = 'rarity') {
    if (mode === 'rarity') {
      G.player.inventory.sort((a, b) => b.rarity - a.rarity);
    } else if (mode === 'type') {
      G.player.inventory.sort((a, b) => a.type.localeCompare(b.type));
    } else if (mode === 'name') {
      G.player.inventory.sort((a, b) => a.name.localeCompare(b.name));
    }
  },

  renderGroundItems(ctx, camera) {
    const time = Date.now() / 1000;

    this.groundItems.forEach(gi => {
      gi.bobTimer += 0.05;
      const bobOffset = Math.sin(gi.bobTimer) * 4;

      const screenX = gi.x - camera.x;
      const screenY = gi.y - camera.y + bobOffset;

      // Skip if off-screen
      if (!Camera.isOnScreen(gi.x, gi.y, 32, 32)) return;

      // Rarity glow underneath
      const glowColor = RARITY_COLORS[gi.item.rarity];
      ctx.fillStyle = Util.rgba(glowColor, 0.3);
      ctx.beginPath();
      ctx.arc(screenX, screenY + 6, 10, 0, Math.PI * 2);
      ctx.fill();

      // Item sprite (colored square)
      ctx.fillStyle = gi.item.spriteColor || glowColor;
      ctx.fillRect(screenX - 6, screenY - 6, 12, 12);

      // Border
      ctx.strokeStyle = glowColor;
      ctx.lineWidth = 1;
      ctx.strokeRect(screenX - 6, screenY - 6, 12, 12);

      // Proximity label
      const dist = Math.hypot(gi.x - G.player.x, gi.y - G.player.y);
      if (dist < TILE_SIZE * 2) {
        ctx.fillStyle = '#ffffff';
        ctx.font = '10px monospace';
        ctx.textAlign = 'center';
        ctx.fillText(gi.item.name, screenX, screenY - 16);
      }
    });
  }
};

// === systems/crafting.js ===
// Crafting System  Recipe-based crafting at campfires
// Defines global Crafting object
// Dependencies: G, Util from utils.js, SFX from audio.js
//               CONSUMABLES, MATERIALS from data/items.js
//               Inventory from systems/inventory.js

const RECIPES = [
  {
    id: 'iron_sword',
    name: 'Iron Sword',
    result: { itemId: 'iron_sword', count: 1, type: 'weapon' },
    materials: [{ id: 'iron_ore', count: 3 }],
    minFloor: 1,
    description: 'A basic but reliable iron blade'
  },
  {
    id: 'health_potion',
    name: 'Health Potion',
    result: { itemId: 'health_potion', count: 1, type: 'consumable' },
    materials: [{ id: 'fungal_essence', count: 2 }],
    minFloor: 1,
    description: 'Restores 50 HP'
  },
  {
    id: 'mana_potion',
    name: 'Mana Potion',
    result: { itemId: 'mana_potion', count: 1, type: 'consumable' },
    materials: [
      { id: 'dark_crystal', count: 1 },
      { id: 'fungal_essence', count: 1 }
    ],
    minFloor: 1,
    description: 'Restores 30 mana'
  },
  {
    id: 'fire_bomb',
    name: 'Fire Bomb',
    result: { itemId: 'fire_bomb', count: 1, type: 'consumable' },
    materials: [
      { id: 'ember_dust', count: 2 },
      { id: 'iron_ore', count: 1 }
    ],
    minFloor: 3,
    description: 'Explosive AoE fire damage'
  },
  {
    id: 'frost_shield_scroll',
    name: 'Frost Shield Scroll',
    result: { itemId: 'frost_shield', count: 1, type: 'consumable' },
    materials: [{ id: 'frost_shard', count: 3 }],
    minFloor: 5,
    description: 'Temporary ice armor buff'
  },
  {
    id: 'poison_antidote',
    name: 'Poison Antidote',
    result: { itemId: 'antidote', count: 1, type: 'consumable' },
    materials: [{ id: 'fungal_essence', count: 3 }],
    minFloor: 2,
    description: 'Cures poison and burn effects'
  },
  {
    id: 'dark_blade',
    name: 'Dark Blade',
    result: { itemId: 'dark_blade', count: 1, type: 'weapon' },
    materials: [
      { id: 'dark_crystal', count: 3 },
      { id: 'iron_ore', count: 2 }
    ],
    minFloor: 8,
    description: 'Sword infused with dark energy'
  },
  {
    id: 'ember_armor',
    name: 'Ember Armor',
    result: { itemId: 'ember_chest', count: 1, type: 'armor' },
    materials: [
      { id: 'ember_dust', count: 3 },
      { id: 'iron_ore', count: 2 }
    ],
    minFloor: 6,
    description: 'Chest armor with fire resistance'
  },
  {
    id: 'frost_amulet',
    name: 'Frost Amulet',
    result: { itemId: 'frost_amulet', count: 1, type: 'armor' },
    materials: [
      { id: 'frost_shard', count: 2 },
      { id: 'dark_crystal', count: 1 }
    ],
    minFloor: 7,
    description: 'Amulet with ice resistance'
  },
  {
    id: 'void_shard_dagger',
    name: 'Void Shard Dagger',
    result: { itemId: 'void_dagger', count: 1, type: 'weapon' },
    materials: [
      { id: 'void_fragment', count: 2 },
      { id: 'dark_crystal', count: 2 }
    ],
    minFloor: 15,
    description: 'Legendary dagger from the void'
  },
  {
    id: 'ancient_ring',
    name: 'Ancient Ring',
    result: { itemId: 'ancient_ring', count: 1, type: 'armor' },
    materials: [
      { id: 'ancient_relic', count: 1 },
      { id: 'dark_crystal', count: 2 }
    ],
    minFloor: 12,
    description: 'Ring with all-stat bonuses'
  },
  {
    id: 'stamina_tonic',
    name: 'Stamina Tonic',
    result: { itemId: 'stamina_tonic', count: 1, type: 'consumable' },
    materials: [
      { id: 'fungal_essence', count: 1 },
      { id: 'ember_dust', count: 1 }
    ],
    minFloor: 3,
    description: 'Restores 50 stamina'
  },
  {
    id: 'elixir_of_power',
    name: 'Elixir of Power',
    result: { itemId: 'elixir_of_power', count: 1, type: 'consumable' },
    materials: [
      { id: 'ancient_relic', count: 1 },
      { id: 'ember_dust', count: 2 },
      { id: 'frost_shard', count: 1 }
    ],
    minFloor: 10,
    description: '+25% damage for 30 seconds'
  },
  {
    id: 'scroll_of_return',
    name: 'Scroll of Return',
    result: { itemId: 'scroll_of_return', count: 1, type: 'consumable' },
    materials: [{ id: 'void_fragment', count: 1 }],
    minFloor: 8,
    description: 'Teleport to last campfire'
  },
  {
    id: 'master_key',
    name: 'Master Key',
    result: { itemId: 'master_key', count: 1, type: 'key_item' },
    materials: [
      { id: 'ancient_relic', count: 2 },
      { id: 'void_fragment', count: 1 }
    ],
    minFloor: 18,
    description: 'Opens locked chests'
  }
];

const Crafting = {
  getAvailableRecipes() {
    const floor = G.currentFloor || 1;
    return RECIPES.filter(recipe => {
      if (recipe.minFloor > floor) return false;
      return this.canCraft(recipe.id);
    });
  },

  canCraft(recipeId) {
    const recipe = RECIPES.find(r => r.id === recipeId);
    if (!recipe) return false;

    // Check if player has all required materials
    for (const mat of recipe.materials) {
      const count = this.getMaterialCount(mat.id);
      if (count < mat.count) return false;
    }

    return true;
  },

  craft(recipeId) {
    const recipe = RECIPES.find(r => r.id === recipeId);
    if (!recipe || !this.canCraft(recipeId)) return null;

    // Consume materials
    for (const mat of recipe.materials) {
      Inventory.removeItemById(mat.id, mat.count);
    }

    // Create result item
    const resultItem = this.createResultItem(recipe.result);

    // Add to inventory
    if (Inventory.addItem(resultItem)) {
      SFX.playSound('craft_success');
      if (window.HUD) {
        HUD.addFloatingText(G.player.x, G.player.y - 16, 'Crafted: ' + recipe.name, '#44ff44', 18);
      }
      return resultItem;
    }

    return null;
  },

  createResultItem(result) {
    const baseItem = {
      id: result.itemId,
      name: '',
      type: result.type,
      rarity: 1,
      description: '',
      spriteColor: '#cccccc'
    };

    // Populate from data based on type
    if (result.type === 'consumable') {
      const consumable = CONSUMABLES.find(c => c.id === result.itemId);
      if (consumable) {
        baseItem.name = consumable.name;
        baseItem.description = consumable.description;
        baseItem.rarity = consumable.rarity;
        baseItem.spriteColor = consumable.color;
        baseItem.stackable = true;
        baseItem.count = result.count || 1;
      }
    } else if (result.type === 'weapon') {
      // Generate crafted weapon
      baseItem.name = this.getCraftedWeaponName(result.itemId);
      baseItem.slot = 'weapon';
      baseItem.stats = this.getCraftedWeaponStats(result.itemId);
      baseItem.element = this.getCraftedWeaponElement(result.itemId);
      baseItem.description = 'A crafted weapon';
      baseItem.rarity = 2; // Uncommon
      baseItem.spriteColor = RARITY_COLORS[2];
    } else if (result.type === 'armor') {
      // Generate crafted armor
      baseItem.name = this.getCraftedArmorName(result.itemId);
      baseItem.slot = this.getCraftedArmorSlot(result.itemId);
      baseItem.stats = this.getCraftedArmorStats(result.itemId);
      baseItem.element = this.getCraftedArmorElement(result.itemId);
      baseItem.description = 'A crafted armor piece';
      baseItem.rarity = 2; // Uncommon
      baseItem.spriteColor = RARITY_COLORS[2];
    } else if (result.type === 'key_item') {
      baseItem.name = this.getCraftedKeyItemName(result.itemId);
      baseItem.description = 'A special crafted item';
      baseItem.rarity = 3; // Rare
      baseItem.spriteColor = RARITY_COLORS[3];
    }

    return baseItem;
  },

  getCraftedWeaponName(id) {
    const names = {
      iron_sword: 'Iron Sword',
      dark_blade: 'Dark Blade',
      void_dagger: 'Void Shard Dagger'
    };
    return names[id] || 'Crafted Weapon';
  },

  getCraftedWeaponStats(id) {
    const stats = {
      iron_sword: { damage: 15 },
      dark_blade: { damage: 25, mana: 10 },
      void_dagger: { damage: 35, stamina: 15 }
    };
    return stats[id] || { damage: 10 };
  },

  getCraftedWeaponElement(id) {
    const elements = {
      iron_sword: ELEMENT.PHYSICAL,
      dark_blade: ELEMENT.DARK,
      void_dagger: ELEMENT.DARK
    };
    return elements[id] || ELEMENT.PHYSICAL;
  },

  getCraftedArmorName(id) {
    const names = {
      ember_chest: 'Ember Armor',
      frost_amulet: 'Frost Amulet',
      ancient_ring: 'Ancient Ring'
    };
    return names[id] || 'Crafted Armor';
  },

  getCraftedArmorSlot(id) {
    const slots = {
      ember_chest: 'chest',
      frost_amulet: 'amulet',
      ancient_ring: 'ring'
    };
    return slots[id] || 'chest';
  },

  getCraftedArmorStats(id) {
    const stats = {
      ember_chest: { defense: 10, fireResist: 25 },
      frost_amulet: { defense: 5, iceResist: 30 },
      ancient_ring: { hp: 20, mana: 10, stamina: 10, defense: 3 }
    };
    return stats[id] || { defense: 5 };
  },

  getCraftedArmorElement(id) {
    const elements = {
      ember_chest: ELEMENT.FIRE,
      frost_amulet: ELEMENT.ICE,
      ancient_ring: ELEMENT.PHYSICAL
    };
    return elements[id] || ELEMENT.PHYSICAL;
  },

  getCraftedKeyItemName(id) {
    const names = {
      master_key: 'Master Key'
    };
    return names[id] || 'Key Item';
  },

  getMaterialCount(materialId) {
    let total = 0;
    G.player.inventory.forEach(item => {
      if (item.id === materialId) {
        total += item.count || 1;
      }
    });
    return total;
  },

  getAllMaterials() {
    const materials = {};

    G.player.inventory.forEach(item => {
      if (item.type === 'material') {
        if (!materials[item.id]) {
          materials[item.id] = {
            name: item.name,
            count: 0,
            color: item.spriteColor
          };
        }
        materials[item.id].count += item.count || 1;
      }
    });

    return Object.entries(materials).map(([id, data]) => ({
      id,
      name: data.name,
      count: data.count,
      color: data.color
    }));
  }
};

// === systems/progression.js ===
// Progression System  XP, leveling, stat allocation, skill points
// Defines global Progression object
// Dependencies: G, STATE, Util from utils.js, SFX from audio.js
//               ABILITY_DEFS, SKILL_TREES, canUnlockAbility from data/abilities.js
//               Player from combat/player.js, Camera from world/camera.js

const Progression = {
  difficultyMults: {
    easy: 0.8,
    normal: 1.0,
    hard: 1.5
  },

  init() {
    G.player.xp = 0;
    G.player.level = 1;
    G.player.nextLevelXP = 50;
    G.player.statPoints = 0;
    G.player.skillPoints = 0;
    G.player.stats = {
      str: 0,
      dex: 0,
      int: 0,
      vit: 0
    };
    G.player.unlockedAbilities = [];
    G.player.equippedAbilities = [null, null, null, null]; // 4 hotbar slots
  },

  addXP(amount) {
    const difficulty = G.difficulty || 'normal';
    const mult = this.difficultyMults[difficulty];
    const xpGained = Math.floor(amount * mult);

    G.player.xp += xpGained;

    // Show XP gain floating text
    if (window.HUD) {
      HUD.addFloatingText(G.player.x, G.player.y - 20, '+' + xpGained + ' XP', '#ffff44', 18);
    }

    // Check for level up
    while (G.player.xp >= G.player.nextLevelXP) {
      this.levelUp();
    }
  },

  levelUp() {
    G.player.xp -= G.player.nextLevelXP;
    G.player.level++;

    // Award stat points and skill points
    G.player.statPoints += 3;
    G.player.skillPoints += 1;

    // Increase base stats
    const oldMaxHp = G.player.maxHp;
    const oldMaxMana = G.player.maxMana;
    const oldMaxStamina = G.player.maxStamina;

    G.player.maxHp += 10;
    G.player.maxMana += 5;
    G.player.maxStamina += 5;

    // Restore to full
    G.player.hp = G.player.maxHp;
    G.player.mana = G.player.maxMana;
    G.player.stamina = G.player.maxStamina;

    // Calculate next level XP threshold
    G.player.nextLevelXP = 50 + G.player.level * 30;

    // Visual and audio feedback
    SFX.playSound('player_levelup');
    if (window.Camera) {
      Camera.shake(3, 0.2);
    }
    if (window.FX) {
      FX.levelup(G.player.x, G.player.y);
    }
    if (window.HUD) {
      HUD.addFloatingText(G.player.x, G.player.y - 24, 'LEVEL UP!', '#ffff00', 24);
    }

    // Log level up
    console.log(`Level up! Now level ${G.player.level}`);
  },

  allocateStat(stat) {
    if (G.player.statPoints <= 0) return false;
    if (!['str', 'dex', 'int', 'vit'].includes(stat)) return false;

    G.player.statPoints--;
    G.player.stats[stat]++;

    // Apply stat bonuses
    this.applyStatBonuses();

    SFX.playSound('stat_allocate');
    if (window.HUD) {
      const statNames = {
        str: 'Strength',
        dex: 'Dexterity',
        int: 'Intelligence',
        vit: 'Vitality'
      };
      HUD.addFloatingText(G.player.x, G.player.y - 16, '+1 ' + statNames[stat], '#44ff44', 18);
    }

    return true;
  },

  applyStatBonuses() {
    const stats = G.player.stats;

    // Strength: +2 melee damage, +1% crit damage per point
    const strBonus = {
      damage: stats.str * 2,
      critDamage: stats.str * 0.01
    };

    // Dexterity: +0.1 speed, +2% crit chance, +3 stamina per point
    const dexBonus = {
      speed: stats.dex * 0.1,
      critChance: stats.dex * 0.02,
      stamina: stats.dex * 3
    };

    // Intelligence: +3% spell damage, +5 mana, +1% cooldown reduction per point
    const intBonus = {
      spellDamage: stats.int * 0.03,
      mana: stats.int * 5,
      cooldownReduction: stats.int * 0.01
    };

    // Vitality: +8 maxHp, +2 defense, +1 hp regen per point
    const vitBonus = {
      hp: stats.vit * 8,
      defense: stats.vit * 2,
      hpRegen: stats.vit * 1
    };

    // Apply bonuses to player
    G.player.damage = (G.player.baseDamage || 10) + strBonus.damage;
    G.player.critDamageMult = 1.5 + strBonus.critDamage;
    G.player.speed = (G.player.baseSpeed || 3) + dexBonus.speed;
    G.player.critChance = 0.05 + dexBonus.critChance;
    G.player.maxStamina = (G.player.baseMaxStamina || 100) + dexBonus.stamina;
    G.player.spellDamageMult = 1.0 + intBonus.spellDamage;
    G.player.maxMana = (G.player.baseMaxMana || 50) + intBonus.mana;
    G.player.cooldownReduction = intBonus.cooldownReduction;
    G.player.maxHp = (G.player.baseMaxHp || 100) + vitBonus.hp;
    G.player.defense = (G.player.baseDefense || 5) + vitBonus.defense;
    G.player.hpRegen = vitBonus.hpRegen;

    // Cap current values to new max
    G.player.hp = Math.min(G.player.hp, G.player.maxHp);
    G.player.mana = Math.min(G.player.mana, G.player.maxMana);
    G.player.stamina = Math.min(G.player.stamina, G.player.maxStamina);
  },

  unlockAbility(abilityId) {
    if (!window.ABILITY_DEFS) return false;

    const ability = ABILITY_DEFS[abilityId];
    if (!ability) return false;

    // Check if already unlocked
    if (G.player.unlockedAbilities.includes(abilityId)) return false;

    // Check prerequisites
    if (ability.requires && ability.requires.length > 0) {
      const hasPrereqs = ability.requires.every(reqId =>
        G.player.unlockedAbilities.includes(reqId)
      );
      if (!hasPrereqs) {
        if (window.HUD) {
          HUD.addFloatingText(G.player.x, G.player.y - 16, 'Prerequisites not met', '#ff4444', 18);
        }
        return false;
      }
    }

    // Check skill point cost
    const tier = ability.tier || 1;
    const cost = tier;

    if (G.player.skillPoints < cost) {
      if (window.HUD) {
        HUD.addFloatingText(G.player.x, G.player.y - 16, 'Not enough skill points', '#ff4444', 18);
      }
      return false;
    }

    // Unlock ability
    G.player.skillPoints -= cost;
    G.player.unlockedAbilities.push(abilityId);

    // Apply passive effects immediately
    if (ability.passive) {
      this.applyPassiveAbility(ability);
    }

    SFX.playSound('ability_unlock');
    if (window.HUD) {
      HUD.addFloatingText(G.player.x, G.player.y - 16, 'Unlocked: ' + ability.name, '#44ff44', 18);
    }
    if (window.FX) {
      FX.magic(G.player.x, G.player.y, '#ffff00');
    }

    return true;
  },

  applyPassiveAbility(ability) {
    // Apply passive bonuses to player stats
    if (ability.effects) {
      for (const effect in ability.effects) {
        const value = ability.effects[effect];
        if (effect === 'maxHp') G.player.maxHp += value;
        if (effect === 'maxMana') G.player.maxMana += value;
        if (effect === 'maxStamina') G.player.maxStamina += value;
        if (effect === 'defense') G.player.defense += value;
        if (effect === 'damage') G.player.damage += value;
        if (effect === 'speed') G.player.speed += value;
        if (effect === 'critChance') G.player.critChance += value;
        if (effect === 'critDamage') G.player.critDamageMult += value;
      }
    }
  },

  equipAbility(abilityId, slot) {
    if (slot < 0 || slot > 3) return false;
    if (!G.player.unlockedAbilities.includes(abilityId)) return false;

    const ability = ABILITY_DEFS[abilityId];
    if (!ability || ability.passive) return false; // Can't equip passive abilities

    G.player.equippedAbilities[slot] = abilityId;
    SFX.playSound('menu_select');

    return true;
  },

  getXPProgress() {
    return {
      current: G.player.xp,
      needed: G.player.nextLevelXP,
      percent: G.player.xp / G.player.nextLevelXP
    };
  },

  getStatBonuses() {
    const stats = G.player.stats;

    return {
      str: {
        damage: stats.str * 2,
        critDamage: stats.str * 1
      },
      dex: {
        speed: stats.dex * 0.1,
        critChance: stats.dex * 2,
        stamina: stats.dex * 3
      },
      int: {
        spellDamage: stats.int * 3,
        mana: stats.int * 5,
        cooldownReduction: stats.int * 1
      },
      vit: {
        hp: stats.vit * 8,
        defense: stats.vit * 2,
        hpRegen: stats.vit * 1
      }
    };
  },

  getFloorDifficultyMult(floor) {
    const difficulty = G.difficulty || 'normal';
    let baseMult = 1.0;

    if (floor >= 21) baseMult = 2.5;
    else if (floor >= 16) baseMult = 2.0;
    else if (floor >= 11) baseMult = 1.6;
    else if (floor >= 6) baseMult = 1.3;

    // Hard mode additional multiplier
    if (difficulty === 'hard') {
      baseMult *= 1.3;
    }

    return baseMult;
  },

  calculateScore() {
    const floor = G.currentFloor || 1;
    const kills = G.player.kills || 0;
    const bossKills = G.player.bossKills || 0;
    const time = G.playTime || 0; // in seconds
    const deaths = G.player.deaths || 0;
    const difficulty = G.difficulty || 'normal';

    let score = 0;

    // Floor reached (100 points per floor)
    score += floor * 100;

    // Kills (10 points each)
    score += kills * 10;

    // Boss kills (500 points each)
    score += bossKills * 500;

    // Time bonus (lose 1 point per 10 seconds)
    score -= Math.floor(time / 10);

    // Death penalty (lose 200 points per death)
    score -= deaths * 200;

    // Difficulty bonus
    if (difficulty === 'hard') {
      score *= 1.5;
    } else if (difficulty === 'easy') {
      score *= 0.7;
    }

    // Ensure score is not negative
    score = Math.max(0, Math.floor(score));

    G.score = score;
    return score;
  }
};

// === systems/particles.js ===
// Particle System  Pooled particle effects for visual flair
// Defines global FX object
// Dependencies: G, ELEMENT, Util from utils.js, Camera from world/camera.js

const FX = {
  pool: [],
  activeCount: 0,
  maxParticles: 500,

  init() {
    this.pool = [];
    this.activeCount = 0;

    // Pre-allocate particle pool
    for (let i = 0; i < this.maxParticles; i++) {
      this.pool.push({
        active: false,
        x: 0,
        y: 0,
        vx: 0,
        vy: 0,
        life: 0,
        maxLife: 1,
        size: 4,
        color: '#ffffff',
        alpha: 1,
        gravity: 0,
        friction: 1,
        shape: 'circle',
        rotation: 0,
        rotSpeed: 0
      });
    }
  },

  spawn(x, y, vx, vy, life, size, color, options = {}) {
    // Find inactive particle
    let particle = null;
    for (let i = 0; i < this.pool.length; i++) {
      if (!this.pool[i].active) {
        particle = this.pool[i];
        break;
      }
    }

    // If pool exhausted, reuse oldest particle
    if (!particle) {
      particle = this.pool[0];
    }

    // Initialize particle
    particle.active = true;
    particle.x = x;
    particle.y = y;
    particle.vx = vx;
    particle.vy = vy;
    particle.life = life;
    particle.maxLife = life;
    particle.size = size;
    particle.color = color;
    particle.alpha = 1;
    particle.gravity = options.gravity || 0;
    particle.friction = options.friction || 1;
    particle.shape = options.shape || 'circle';
    particle.rotation = options.rotation || 0;
    particle.rotSpeed = options.rotSpeed || 0;

    this.activeCount++;
  },

  update(dt) {
    for (let i = 0; i < this.pool.length; i++) {
      const p = this.pool[i];
      if (!p.active) continue;

      // Move
      p.x += p.vx * dt;
      p.y += p.vy * dt;

      // Apply gravity
      p.vy += p.gravity * dt;

      // Apply friction
      p.vx *= p.friction;
      p.vy *= p.friction;

      // Update rotation
      p.rotation += p.rotSpeed * dt;

      // Decrease life
      p.life -= dt;

      // Fade alpha and shrink based on remaining life
      const lifePercent = p.life / p.maxLife;
      p.alpha = lifePercent;
      p.size = p.size * (0.5 + lifePercent * 0.5);

      // Deactivate if dead
      if (p.life <= 0) {
        p.active = false;
        this.activeCount--;
      }
    }
  },

  render(ctx, camera) {
    for (let i = 0; i < this.pool.length; i++) {
      const p = this.pool[i];
      if (!p.active) continue;

      // Skip if not on screen
      if (!Camera.isOnScreen(p.x, p.y, p.size * 2, p.size * 2)) continue;

      const screenX = p.x - camera.x;
      const screenY = p.y - camera.y;

      ctx.save();
      ctx.globalAlpha = p.alpha;
      ctx.fillStyle = p.color;
      ctx.translate(screenX, screenY);
      ctx.rotate(p.rotation);

      // Draw shape
      if (p.shape === 'circle') {
        ctx.beginPath();
        ctx.arc(0, 0, p.size, 0, Math.PI * 2);
        ctx.fill();
      } else if (p.shape === 'square') {
        ctx.fillRect(-p.size, -p.size, p.size * 2, p.size * 2);
      } else if (p.shape === 'triangle') {
        ctx.beginPath();
        ctx.moveTo(0, -p.size);
        ctx.lineTo(p.size, p.size);
        ctx.lineTo(-p.size, p.size);
        ctx.closePath();
        ctx.fill();
      } else if (p.shape === 'star') {
        this.drawStar(ctx, 0, 0, 5, p.size, p.size / 2);
      }

      ctx.restore();
    }
  },

  drawStar(ctx, x, y, spikes, outerRadius, innerRadius) {
    let rot = Math.PI / 2 * 3;
    let step = Math.PI / spikes;

    ctx.beginPath();
    ctx.moveTo(x, y - outerRadius);

    for (let i = 0; i < spikes; i++) {
      ctx.lineTo(x + Math.cos(rot) * outerRadius, y + Math.sin(rot) * outerRadius);
      rot += step;
      ctx.lineTo(x + Math.cos(rot) * innerRadius, y + Math.sin(rot) * innerRadius);
      rot += step;
    }

    ctx.closePath();
    ctx.fill();
  },

  // Preset emitter functions
  blood(x, y) {
    for (let i = 0; i < 15; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = Util.randFloat(30, 80);
      this.spawn(
        x, y,
        Math.cos(angle) * speed,
        Math.sin(angle) * speed,
        Util.randFloat(0.3, 0.6),
        Util.randFloat(2, 4),
        '#8b0000',
        { gravity: 200, friction: 0.95, shape: 'circle' }
      );
    }
  },

  sparks(x, y) {
    for (let i = 0; i < 20; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = Util.randFloat(80, 150);
      this.spawn(
        x, y,
        Math.cos(angle) * speed,
        Math.sin(angle) * speed,
        Util.randFloat(0.2, 0.4),
        Util.randFloat(1, 3),
        Util.pick(['#ffff00', '#ffffff', '#ffaa00']),
        { gravity: 0, friction: 0.98, shape: 'circle' }
      );
    }
  },

  fire(x, y) {
    for (let i = 0; i < 12; i++) {
      const angle = -Math.PI / 2 + Util.randFloat(-0.3, 0.3);
      const speed = Util.randFloat(20, 50);
      this.spawn(
        x + Util.randFloat(-4, 4), y,
        Math.cos(angle) * speed,
        Math.sin(angle) * speed,
        Util.randFloat(0.5, 1.0),
        Util.randFloat(3, 6),
        Util.pick(['#ff4400', '#ff6600', '#ffaa00', '#ff8800']),
        { gravity: -50, friction: 0.97, shape: 'circle' }
      );
    }
  },

  smoke(x, y) {
    for (let i = 0; i < 8; i++) {
      const angle = -Math.PI / 2 + Util.randFloat(-0.2, 0.2);
      const speed = Util.randFloat(10, 30);
      this.spawn(
        x + Util.randFloat(-6, 6), y,
        Math.cos(angle) * speed,
        Math.sin(angle) * speed,
        Util.randFloat(1.0, 2.0),
        Util.randFloat(4, 8),
        Util.pick(['#666666', '#888888', '#555555']),
        { gravity: -20, friction: 0.99, shape: 'circle' }
      );
    }
  },

  magic(x, y, color) {
    for (let i = 0; i < 25; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = Util.randFloat(40, 100);
      this.spawn(
        x, y,
        Math.cos(angle) * speed,
        Math.sin(angle) * speed,
        Util.randFloat(0.4, 0.8),
        Util.randFloat(2, 4),
        color,
        { gravity: 0, friction: 0.95, shape: 'star', rotSpeed: Util.randFloat(-5, 5) }
      );
    }
  },

  ice(x, y) {
    for (let i = 0; i < 18; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = Util.randFloat(50, 100);
      this.spawn(
        x, y,
        Math.cos(angle) * speed,
        Math.sin(angle) * speed,
        Util.randFloat(0.4, 0.7),
        Util.randFloat(2, 5),
        Util.pick(['#00ffff', '#aaffff', '#88eeff']),
        { gravity: 0, friction: 0.96, shape: 'triangle', rotation: angle }
      );
    }
  },

  poison(x, y) {
    for (let i = 0; i < 10; i++) {
      const angle = -Math.PI / 2 + Util.randFloat(-0.4, 0.4);
      const speed = Util.randFloat(15, 40);
      this.spawn(
        x + Util.randFloat(-4, 4), y,
        Math.cos(angle) * speed,
        Math.sin(angle) * speed,
        Util.randFloat(0.6, 1.2),
        Util.randFloat(3, 6),
        Util.pick(['#00ff00', '#44ff44', '#88ff44']),
        { gravity: -30, friction: 0.98, shape: 'circle' }
      );
    }
  },

  lightning(x, y) {
    for (let i = 0; i < 15; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = Util.randFloat(100, 200);
      this.spawn(
        x, y,
        Math.cos(angle) * speed,
        Math.sin(angle) * speed,
        Util.randFloat(0.1, 0.2),
        Util.randFloat(2, 4),
        Util.pick(['#ffffff', '#aaffff']),
        { gravity: 0, friction: 0.9, shape: 'circle' }
      );
    }
  },

  heal(x, y) {
    for (let i = 0; i < 20; i++) {
      const angle = -Math.PI / 2 + Util.randFloat(-0.5, 0.5);
      const speed = Util.randFloat(20, 60);
      this.spawn(
        x + Util.randFloat(-8, 8), y,
        Math.cos(angle) * speed,
        Math.sin(angle) * speed,
        Util.randFloat(0.5, 1.0),
        Util.randFloat(2, 4),
        '#00ff44',
        { gravity: -40, friction: 0.97, shape: 'star', rotSpeed: Util.randFloat(-3, 3) }
      );
    }
  },

  levelup(x, y) {
    for (let i = 0; i < 40; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = Util.randFloat(60, 150);
      this.spawn(
        x, y,
        Math.cos(angle) * speed,
        Math.sin(angle) * speed,
        Util.randFloat(0.6, 1.2),
        Util.randFloat(3, 6),
        '#ffff00',
        { gravity: -20, friction: 0.96, shape: 'star', rotSpeed: Util.randFloat(-8, 8) }
      );
    }
  },

  death(x, y, color) {
    for (let i = 0; i < 30; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = Util.randFloat(40, 120);
      this.spawn(
        x, y,
        Math.cos(angle) * speed,
        Math.sin(angle) * speed,
        Util.randFloat(0.4, 0.8),
        Util.randFloat(3, 6),
        color,
        { gravity: 150, friction: 0.95, shape: 'square' }
      );
    }
  },

  dust(x, y) {
    for (let i = 0; i < 5; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = Util.randFloat(10, 30);
      this.spawn(
        x + Util.randFloat(-4, 4), y,
        Math.cos(angle) * speed,
        Math.sin(angle) * speed,
        Util.randFloat(0.3, 0.6),
        Util.randFloat(1, 2),
        '#8b7355',
        { gravity: 0, friction: 0.98, shape: 'circle' }
      );
    }
  },

  dash(x, y, angle) {
    for (let i = 0; i < 8; i++) {
      const speed = Util.randFloat(-20, -60);
      this.spawn(
        x, y,
        Math.cos(angle) * speed,
        Math.sin(angle) * speed,
        Util.randFloat(0.2, 0.4),
        Util.randFloat(2, 4),
        '#ffffff',
        { gravity: 0, friction: 0.95, shape: 'circle' }
      );
    }
  },

  explosion(x, y, radius, color) {
    const count = Math.floor(radius / 2);
    for (let i = 0; i < count; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = Util.randFloat(50, 150);
      this.spawn(
        x, y,
        Math.cos(angle) * speed,
        Math.sin(angle) * speed,
        Util.randFloat(0.4, 0.8),
        Util.randFloat(4, 8),
        color,
        { gravity: 50, friction: 0.94, shape: 'circle' }
      );
    }
  },

  loot(x, y, rarity) {
    const color = window.RARITY_COLORS ? RARITY_COLORS[rarity] : '#ffffff';
    for (let i = 0; i < 12; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = Util.randFloat(20, 60);
      this.spawn(
        x, y,
        Math.cos(angle) * speed,
        Math.sin(angle) * speed,
        Util.randFloat(0.5, 0.8),
        Util.randFloat(2, 4),
        color,
        { gravity: 0, friction: 0.97, shape: 'star', rotSpeed: Util.randFloat(-5, 5) }
      );
    }
  },

  campfire(x, y) {
    // Continuous fire + smoke + embers (called each frame)
    if (Math.random() < 0.3) {
      const angle = -Math.PI / 2 + Util.randFloat(-0.2, 0.2);
      const speed = Util.randFloat(15, 35);
      this.spawn(
        x + Util.randFloat(-6, 6), y,
        Math.cos(angle) * speed,
        Math.sin(angle) * speed,
        Util.randFloat(0.4, 0.8),
        Util.randFloat(3, 5),
        Util.pick(['#ff4400', '#ff6600', '#ffaa00']),
        { gravity: -40, friction: 0.97, shape: 'circle' }
      );
    }

    if (Math.random() < 0.1) {
      const angle = -Math.PI / 2 + Util.randFloat(-0.15, 0.15);
      const speed = Util.randFloat(8, 20);
      this.spawn(
        x + Util.randFloat(-8, 8), y - 10,
        Math.cos(angle) * speed,
        Math.sin(angle) * speed,
        Util.randFloat(0.8, 1.5),
        Util.randFloat(4, 7),
        '#555555',
        { gravity: -15, friction: 0.99, shape: 'circle' }
      );
    }

    if (Math.random() < 0.05) {
      const angle = -Math.PI / 2 + Util.randFloat(-0.4, 0.4);
      const speed = Util.randFloat(30, 60);
      this.spawn(
        x, y,
        Math.cos(angle) * speed,
        Math.sin(angle) * speed,
        Util.randFloat(0.5, 1.0),
        Util.randFloat(1, 2),
        '#ffaa00',
        { gravity: -10, friction: 0.98, shape: 'circle' }
      );
    }
  },

  void(x, y) {
    for (let i = 0; i < 15; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = Util.randFloat(20, 60);
      this.spawn(
        x, y,
        Math.cos(angle) * speed,
        Math.sin(angle) * speed,
        Util.randFloat(0.6, 1.2),
        Util.randFloat(3, 6),
        Util.pick(['#4400ff', '#000000', '#6600aa']),
        { gravity: 0, friction: 0.96, shape: 'circle', rotSpeed: Util.randFloat(-4, 4) }
      );
    }
  },

  critical(x, y) {
    for (let i = 0; i < 20; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = Util.randFloat(60, 120);
      this.spawn(
        x, y,
        Math.cos(angle) * speed,
        Math.sin(angle) * speed,
        Util.randFloat(0.3, 0.6),
        Util.randFloat(4, 7),
        '#ffff00',
        { gravity: 0, friction: 0.94, shape: 'star', rotSpeed: Util.randFloat(-10, 10) }
      );
    }
  },

  parry(x, y) {
    for (let i = 0; i < 16; i++) {
      const angle = (i / 16) * Math.PI * 2;
      const speed = 80;
      this.spawn(
        x, y,
        Math.cos(angle) * speed,
        Math.sin(angle) * speed,
        Util.randFloat(0.3, 0.5),
        Util.randFloat(2, 4),
        '#ffffff',
        { gravity: 0, friction: 0.92, shape: 'circle' }
      );
    }
  }
};

// === systems/dialogue.js ===
// Dialogue System  Text box for NPC interaction and story
// Defines global Dialogue object
// Dependencies: G, STATE, Util from utils.js, SFX from audio.js, Input from input.js

const Dialogue = {
  active: false,
  current: null,
  typeSpeed: 30, // characters per second
  previousGameState: null,

  start(dialogueData) {
    this.active = true;
    this.previousGameState = G.gameState;
    G.gameState = STATE.DIALOGUE;

    this.current = {
      npcName: dialogueData.npcName || 'Unknown',
      npcColor: dialogueData.npcColor || '#888888',
      lines: dialogueData.lines || [],
      lineIndex: 0,
      charIndex: 0,
      typing: true,
      choices: null,
      choiceIndex: 0
    };

    SFX.playSound('menu_select');
  },

  update(dt) {
    if (!this.active || !this.current) return;

    const line = this.current.lines[this.current.lineIndex];
    if (!line) {
      this.close();
      return;
    }

    // Typewriter effect
    if (this.current.typing) {
      this.current.charIndex += this.typeSpeed * dt;

      const text = typeof line === 'string' ? line : line.text;
      if (this.current.charIndex >= text.length) {
        this.current.charIndex = text.length;
        this.current.typing = false;

        // Check if this line has choices
        if (line.choices) {
          this.current.choices = line.choices;
          this.current.choiceIndex = 0;
        }
      }
    }

    // Input handling
    const skipPressed = Input.justPressed('Space') || Input.justPressed('Enter') ||
                        (Input.mouse && Input.mouse.clicked);

    if (skipPressed) {
      if (this.current.typing) {
        // Skip to end of current line
        const text = typeof line === 'string' ? line : line.text;
        this.current.charIndex = text.length;
        this.current.typing = false;

        if (line.choices) {
          this.current.choices = line.choices;
          this.current.choiceIndex = 0;
        }
      } else if (this.current.choices) {
        // Select current choice
        this.selectChoice(this.current.choiceIndex);
      } else {
        // Advance to next line
        this.nextLine();
      }
    }

    // Choice navigation
    if (this.current.choices && !this.current.typing) {
      if (Input.justPressed('ArrowUp') || Input.justPressed('w')) {
        this.current.choiceIndex = Math.max(0, this.current.choiceIndex - 1);
        SFX.playSound('menu_move');
      }
      if (Input.justPressed('ArrowDown') || Input.justPressed('s')) {
        this.current.choiceIndex = Math.min(
          this.current.choices.length - 1,
          this.current.choiceIndex + 1
        );
        SFX.playSound('menu_move');
      }
    }
  },

  nextLine() {
    this.current.lineIndex++;
    this.current.charIndex = 0;
    this.current.typing = true;
    this.current.choices = null;

    if (this.current.lineIndex >= this.current.lines.length) {
      this.close();
    } else {
      SFX.playSound('menu_select');
    }
  },

  selectChoice(index) {
    const choice = this.current.choices[index];
    if (!choice) return;

    SFX.playSound('menu_confirm');

    // Apply choice effects
    if (choice.effect) {
      this.applyChoiceEffect(choice.effect);
    }

    // Set story flag
    if (choice.flag) {
      G.storyChoices = G.storyChoices || {};
      G.storyChoices[choice.flag] = true;
    }

    // Give item
    if (choice.giveItem && window.Inventory) {
      const item = this.createChoiceItem(choice.giveItem);
      if (item) {
        Inventory.addItem(item);
      }
    }

    // Navigate to next dialogue or close
    if (choice.next) {
      this.current.lineIndex = choice.next;
      this.current.charIndex = 0;
      this.current.typing = true;
      this.current.choices = null;
    } else {
      this.close();
    }
  },

  applyChoiceEffect(effect) {
    if (effect.heal && window.Player) {
      Player.heal(effect.heal);
    }
    if (effect.damage && window.Player) {
      G.player.hp -= effect.damage;
    }
    if (effect.gold) {
      G.player.gold = (G.player.gold || 0) + effect.gold;
    }
  },

  createChoiceItem(itemId) {
    // Simple item creation for dialogue rewards
    if (window.CONSUMABLES) {
      const consumable = CONSUMABLES.find(c => c.id === itemId);
      if (consumable) {
        return {
          id: consumable.id,
          name: consumable.name,
          type: 'consumable',
          rarity: consumable.rarity,
          description: consumable.description,
          spriteColor: consumable.color,
          stackable: true,
          count: 1
        };
      }
    }
    return null;
  },

  close() {
    this.active = false;
    this.current = null;
    G.gameState = this.previousGameState || STATE.PLAYING;
    this.previousGameState = null;
  },

  render(ctx) {
    if (!this.active || !this.current) return;

    const canvas = ctx.canvas;
    const boxWidth = canvas.width * 0.8;
    const boxHeight = 150;
    const boxX = (canvas.width - boxWidth) / 2;
    const boxY = canvas.height - boxHeight - 20;

    // Draw semi-transparent background
    ctx.fillStyle = Util.rgba('#000000', 0.85);
    ctx.fillRect(boxX, boxY, boxWidth, boxHeight);

    // Draw border with gradient
    const gradient = ctx.createLinearGradient(boxX, boxY, boxX + boxWidth, boxY + boxHeight);
    gradient.addColorStop(0, this.current.npcColor);
    gradient.addColorStop(1, Util.rgba(this.current.npcColor, 0.3));
    ctx.strokeStyle = gradient;
    ctx.lineWidth = 3;
    ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);

    // Draw NPC name header
    ctx.fillStyle = this.current.npcColor;
    ctx.fillRect(boxX, boxY - 30, 200, 30);
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 16px monospace';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    ctx.shadowColor = this.current.npcColor;
    ctx.shadowBlur = 8;
    ctx.fillText(this.current.npcName, boxX + 10, boxY - 15);
    ctx.shadowBlur = 0;

    // Draw portrait (simple colored circle with initial)
    const portraitX = boxX + 20;
    const portraitY = boxY + 30;
    const portraitRadius = 25;
    ctx.fillStyle = this.current.npcColor;
    ctx.beginPath();
    ctx.arc(portraitX, portraitY, portraitRadius, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 24px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(this.current.npcName.charAt(0).toUpperCase(), portraitX, portraitY + 2);

    // Draw dialogue text
    const textX = boxX + 70;
    const textY = boxY + 20;
    const textWidth = boxWidth - 90;

    const line = this.current.lines[this.current.lineIndex];
    const text = typeof line === 'string' ? line : line.text;
    const displayText = text.substring(0, Math.floor(this.current.charIndex));

    ctx.fillStyle = '#ffffff';
    ctx.font = '14px monospace';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';

    // Word wrap
    const words = displayText.split(' ');
    let currentLine = '';
    let lineY = textY;
    const lineHeight = 18;

    for (const word of words) {
      const testLine = currentLine + word + ' ';
      const metrics = ctx.measureText(testLine);
      if (metrics.width > textWidth && currentLine.length > 0) {
        ctx.fillText(currentLine, textX, lineY);
        currentLine = word + ' ';
        lineY += lineHeight;
      } else {
        currentLine = testLine;
      }
    }
    ctx.fillText(currentLine, textX, lineY);

    // Draw blinking cursor if still typing
    if (this.current.typing && Math.floor(Date.now() / 500) % 2 === 0) {
      const cursorX = textX + ctx.measureText(currentLine).width;
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(cursorX, lineY, 2, 14);
    }

    // Draw choices if present
    if (this.current.choices && !this.current.typing) {
      const choiceX = textX;
      let choiceY = boxY + 80;

      this.current.choices.forEach((choice, i) => {
        const isSelected = i === this.current.choiceIndex;
        ctx.fillStyle = isSelected ? '#ffff00' : '#aaaaaa';
        ctx.font = isSelected ? 'bold 14px monospace' : '14px monospace';

        const prefix = isSelected ? '> ' : '  ';
        ctx.fillText(prefix + choice.text, choiceX, choiceY);

        choiceY += 18;
      });
    }

    // Draw continue indicator
    if (!this.current.typing && !this.current.choices) {
      const indicatorText = 'Press SPACE to continue';
      const indicatorX = boxX + boxWidth - 10;
      const indicatorY = boxY + boxHeight - 10;

      ctx.fillStyle = Util.rgba('#ffffff', 0.3 + Math.sin(Date.now() / 300) * 0.3);
      ctx.font = '12px monospace';
      ctx.textAlign = 'right';
      ctx.textBaseline = 'bottom';
      ctx.fillText(indicatorText, indicatorX, indicatorY);
    }
  }
};

// === ui/title-screen.js ===
// title-screen.js
// Animated title screen with menu navigation, particles, and controls overlay

const TitleScreen = {
  titleAlpha: 0,
  menuIndex: 0,
  particles: [],
  showControls: false,
  showCredits: false,
  menuHoverY: -1,
  particleTime: 0,

  init() {
    this.titleAlpha = 0;
    this.menuIndex = 0;
    this.particles = [];
    this.showControls = false;
    this.showCredits = false;
    this.menuHoverY = -1;
    this.particleTime = 0;

    // Initialize background particles
    for (let i = 0; i < 50; i++) {
      this.particles.push({
        x: Math.random() * G.canvas.width,
        y: Math.random() * G.canvas.height,
        size: Math.random() * 2 + 1,
        speed: Math.random() * 20 + 10,
        alpha: Math.random() * 0.3 + 0.1
      });
    }
  },

  getMenuItems() {
    const difficultyName = G.difficulty || 'Normal';
    const items = [
      { label: 'New Game', enabled: true },
      { label: 'Continue', enabled: Save.hasSave() },
      { label: 'Controls', enabled: true },
      { label: `Difficulty: ${difficultyName}`, enabled: true }
    ];
    return items;
  },

  update(dt) {
    // Fade in title
    this.titleAlpha = Util.clamp(this.titleAlpha + dt * 0.5, 0, 1);

    // Animate particles
    this.particleTime += dt;
    for (let p of this.particles) {
      p.y -= p.speed * dt;
      if (p.y < -10) {
        p.y = G.canvas.height + 10;
        p.x = Math.random() * G.canvas.width;
      }
    }

    // Handle controls overlay
    if (this.showControls) {
      if (Input.justPressed('Escape') || Input.justPressed('KeyI') ||
          Input.justPressed('KeyC') || Input.justPressed('KeyK') ||
          Input.justPressed('Enter') || Input.justPressed('Space')) {
        this.showControls = false;
        SFX.playSound('menu_select');
      }
      return;
    }

    const items = this.getMenuItems();

    // Mouse hover
    if (Input.mouse.y > 0) {
      const menuStartY = G.canvas.height / 2 + 60;
      const itemHeight = 50;
      const idx = Math.floor((Input.mouse.y - menuStartY) / itemHeight);
      if (idx >= 0 && idx < items.length && items[idx].enabled) {
        if (this.menuIndex !== idx) {
          this.menuIndex = idx;
          SFX.playSound('menu_hover');
        }
      }
    }

    // Keyboard navigation
    if (Input.justPressed('ArrowDown') || Input.justPressed('KeyS')) {
      do {
        this.menuIndex = (this.menuIndex + 1) % items.length;
      } while (!items[this.menuIndex].enabled);
      SFX.playSound('menu_hover');
    }
    if (Input.justPressed('ArrowUp') || Input.justPressed('KeyW')) {
      do {
        this.menuIndex = (this.menuIndex - 1 + items.length) % items.length;
      } while (!items[this.menuIndex].enabled);
      SFX.playSound('menu_hover');
    }

    // Selection
    if (Input.justPressed('Enter') || Input.justPressed('Space')) {
      this.selectMenuItem();
    }

    // Mouse click
    if (Input.mouse.clicked) {
      const menuStartY = G.canvas.height / 2 + 60;
      const itemHeight = 50;
      const idx = Math.floor((Input.mouse.y - menuStartY) / itemHeight);
      if (idx >= 0 && idx < items.length && items[idx].enabled && idx === this.menuIndex) {
        this.selectMenuItem();
      }
    }
  },

  selectMenuItem() {
    const items = this.getMenuItems();
    const item = items[this.menuIndex];

    SFX.playSound('menu_select');

    if (item.label === 'New Game') {
      this.startGame();
    } else if (item.label === 'Continue') {
      this.continueGame();
    } else if (item.label === 'Controls') {
      this.showControls = true;
    } else if (item.label.startsWith('Difficulty:')) {
      this.cycleDifficulty();
    }
  },

  startGame() {
    Save.resetGame();
    G.gameState = STATE.PLAYING;
    // Floor generation will be handled by main game loop
    Transitions.start('fadeOut', 0.5, () => {
      // Game initialization happens here
    }, {});
  },

  continueGame() {
    if (Save.hasSave()) {
      Save.loadGame();
      G.gameState = STATE.PLAYING;
      Transitions.start('fadeIn', 0.5, null, {});
    }
  },

  cycleDifficulty() {
    const difficulties = ['Easy', 'Normal', 'Hard'];
    const current = G.difficulty || 'Normal';
    const idx = difficulties.indexOf(current);
    const nextIdx = (idx + 1) % difficulties.length;
    G.difficulty = difficulties[nextIdx];

    Save.saveSettings();
  },

  render(ctx) {
    const w = G.canvas.width;
    const h = G.canvas.height;

    // Background gradient
    const grad = ctx.createLinearGradient(0, 0, 0, h);
    grad.addColorStop(0, '#1a0033');
    grad.addColorStop(0.5, '#0d001a');
    grad.addColorStop(1, '#000000');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, w, h);

    // Background particles
    ctx.save();
    for (let p of this.particles) {
      ctx.fillStyle = Util.rgba(150, 100, 180, p.alpha);
      ctx.fillRect(p.x, p.y, p.size, p.size);
    }
    ctx.restore();

    // Title
    ctx.save();
    ctx.globalAlpha = this.titleAlpha;

    const titleY = h * 0.3;
    const pulse = Math.sin(G.time * 2) * 0.1 + 0.9;

    // Title glow
    ctx.shadowBlur = 30 * pulse;
    ctx.shadowColor = '#cc0000';

    ctx.font = 'bold 56px serif';
    ctx.fillStyle = '#cc3333';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    const titleText = 'DEPTHS OF THE ABYSS';
    const letterSpacing = 8;
    let totalWidth = ctx.measureText(titleText.replace(/ /g, '')).width + (titleText.length - 1) * letterSpacing;
    let startX = (w - totalWidth) / 2;

    for (let i = 0; i < titleText.length; i++) {
      ctx.fillText(titleText[i], startX, titleY);
      startX += ctx.measureText(titleText[i]).width + letterSpacing;
    }

    // Subtitle
    ctx.shadowBlur = 10;
    ctx.shadowColor = '#660000';
    ctx.font = 'italic 20px serif';
    ctx.fillStyle = '#999999';
    ctx.fillText('A Dark Fantasy Roguelike', w / 2, titleY + 60);

    ctx.restore();

    // Menu items
    const items = this.getMenuItems();
    const menuStartY = h / 2 + 60;
    const itemHeight = 50;

    ctx.font = 'bold 28px sans-serif';
    ctx.textAlign = 'center';

    for (let i = 0; i < items.length; i++) {
      const y = menuStartY + i * itemHeight;
      const isSelected = (i === this.menuIndex);
      const isEnabled = items[i].enabled;

      ctx.save();

      if (isSelected) {
        const scale = 1.0 + Math.sin(G.time * 4) * 0.05;
        ctx.translate(w / 2, y);
        ctx.scale(scale, scale);
        ctx.translate(-w / 2, -y);

        ctx.fillStyle = isEnabled ? '#ffcc00' : '#666666';
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#ffaa00';

        // Arrow indicator
        ctx.font = 'bold 28px sans-serif';
        ctx.fillText('>', w / 2 - 150, y);
      } else {
        ctx.fillStyle = isEnabled ? '#cccccc' : '#444444';
      }

      ctx.fillText(items[i].label, w / 2, y);
      ctx.restore();
    }

    // High score
    const highScore = Save.loadHighScore();
    ctx.font = '18px sans-serif';
    ctx.fillStyle = '#888888';
    ctx.textAlign = 'center';
    ctx.fillText(
      `High Score: ${highScore.score} | Deepest Floor: ${highScore.deepestFloor}`,
      w / 2,
      h - 40
    );

    // Controls overlay
    if (this.showControls) {
      this.renderControlsOverlay(ctx);
    }
  },

  renderControlsOverlay(ctx) {
    const w = G.canvas.width;
    const h = G.canvas.height;

    // Dark backdrop
    ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
    ctx.fillRect(0, 0, w, h);

    ctx.fillStyle = '#ffffff';
    ctx.textAlign = 'center';

    // Header
    ctx.font = 'bold 32px sans-serif';
    ctx.fillText('HOW TO PLAY', w / 2, 60);

    ctx.font = '20px sans-serif';
    ctx.textAlign = 'left';

    const controls = [
      'WASD / Arrow Keys - Move',
      'Space - Attack',
      'Shift - Dodge Roll',
      'E - Interact / Parry',
      'I - Inventory',
      'K - Skill Tree',
      'C - Crafting (at campfire)',
      'P / Esc - Pause',
      '1-4 - Use Abilities',
      'Tab - Toggle Minimap',
      '',
      'Touch Controls:',
      'Left side - Virtual joystick for movement',
      'Right side - Attack, dodge, ability buttons'
    ];

    const startY = 120;
    for (let i = 0; i < controls.length; i++) {
      ctx.fillText(controls[i], w / 2 - 250, startY + i * 30);
    }

    // Close instruction
    ctx.font = 'italic 18px sans-serif';
    ctx.fillStyle = '#ffcc00';
    ctx.textAlign = 'center';
    ctx.fillText('Press any key to close', w / 2, h - 40);
  }
};

// === ui/hud.js ===
// hud.js
// In-game HUD overlay: health bars, abilities, combo counter, floating text, death/victory screens

const HUD = {
  displayHP: 100,
  displayMaxHP: 100,
  displayMP: 50,
  displayMaxMP: 50,
  displayST: 80,
  displayMaxST: 80,
  displayXP: 0,
  displayMaxXP: 100,
  hpFlashTime: 0,
  comboScale: 1.0,
  lastCombo: 0,

  init() {
    this.displayHP = G.player.hp;
    this.displayMaxHP = G.player.maxHP;
    this.displayMP = G.player.mana;
    this.displayMaxMP = G.player.maxMana;
    this.displayST = G.player.stamina;
    this.displayMaxST = G.player.maxStamina;
    this.displayXP = G.player.xp;
    this.displayMaxXP = G.player.nextLevelXP;
    this.hpFlashTime = 0;
    this.comboScale = 1.0;
    this.lastCombo = 0;
  },

  update(dt) {
    // Smooth bar interpolation
    const lerpSpeed = 5;
    this.displayHP = Util.lerp(this.displayHP, G.player.hp, dt * lerpSpeed);
    this.displayMaxHP = Util.lerp(this.displayMaxHP, G.player.maxHP, dt * lerpSpeed);
    this.displayMP = Util.lerp(this.displayMP, G.player.mana, dt * lerpSpeed);
    this.displayMaxMP = Util.lerp(this.displayMaxMP, G.player.maxMana, dt * lerpSpeed);
    this.displayST = Util.lerp(this.displayST, G.player.stamina, dt * lerpSpeed);
    this.displayMaxST = Util.lerp(this.displayMaxST, G.player.maxStamina, dt * lerpSpeed);

    const xpProgress = Progression.getXPProgress();
    this.displayXP = Util.lerp(this.displayXP, xpProgress.current, dt * lerpSpeed);
    this.displayMaxXP = Util.lerp(this.displayMaxXP, xpProgress.needed, dt * lerpSpeed);

    // HP flash when low
    if (G.player.hp / G.player.maxHP < 0.25) {
      this.hpFlashTime += dt;
    } else {
      this.hpFlashTime = 0;
    }

    // Update floating text
    for (let i = G.floatingTexts.length - 1; i >= 0; i--) {
      const ft = G.floatingTexts[i];
      ft.life -= dt;
      ft.y -= 50 * dt;
      if (ft.life <= 0) {
        G.floatingTexts.splice(i, 1);
      }
    }

    // Combo scale animation
    if (G.combo > this.lastCombo) {
      this.comboScale = 1.5;
    }
    this.lastCombo = G.combo;
    this.comboScale = Util.lerp(this.comboScale, 1.0, dt * 5);
  },

  render(ctx) {
    const w = G.canvas.width;
    const h = G.canvas.height;

    // Top-left: Player bars
    this.renderPlayerBars(ctx, 10, 10);

    // Top-right: Floor & info
    this.renderFloorInfo(ctx, w - 10, 10);

    // Top-center: Boss HP bar
    if (G.bossActive) {
      this.renderBossBar(ctx, w / 2, 10);
    }

    // Bottom-left: Ability hotbar
    this.renderAbilityHotbar(ctx, 10, h - 70);

    // Center-right: Combo counter
    if (G.combo > 0 && G.comboTimer > 0) {
      this.renderCombo(ctx, w - 120, h / 2);
    }

    // Floating text
    this.renderFloatingText(ctx);
  },

  renderPlayerBars(ctx, x, y) {
    const barWidth = 200;
    const barHeight = 16;
    const spacing = 4;

    // HP bar
    const hpPct = this.displayHP / this.displayMaxHP;
    const flashAlpha = this.hpFlashTime > 0 ? Math.abs(Math.sin(this.hpFlashTime * 8)) * 0.5 + 0.5 : 1.0;

    ctx.fillStyle = 'rgba(40, 40, 40, 0.8)';
    ctx.fillRect(x, y, barWidth, barHeight);

    const hpGrad = ctx.createLinearGradient(x, y, x + barWidth * hpPct, y);
    hpGrad.addColorStop(0, `rgba(200, 50, 50, ${flashAlpha})`);
    hpGrad.addColorStop(1, `rgba(120, 20, 20, ${flashAlpha})`);
    ctx.fillStyle = hpGrad;
    ctx.fillRect(x, y, barWidth * hpPct, barHeight);

    ctx.strokeStyle = '#666666';
    ctx.lineWidth = 1;
    ctx.strokeRect(x, y, barWidth, barHeight);

    ctx.font = 'bold 11px sans-serif';
    ctx.fillStyle = '#ffffff';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(
      `HP: ${Math.ceil(this.displayHP)}/${Math.ceil(this.displayMaxHP)}`,
      x + barWidth / 2,
      y + barHeight / 2
    );

    // Mana bar
    const mpPct = this.displayMP / this.displayMaxMP;
    y += barHeight + spacing;

    ctx.fillStyle = 'rgba(40, 40, 40, 0.8)';
    ctx.fillRect(x, y, barWidth, barHeight);

    const mpGrad = ctx.createLinearGradient(x, y, x + barWidth * mpPct, y);
    mpGrad.addColorStop(0, '#5588ff');
    mpGrad.addColorStop(1, '#2244aa');
    ctx.fillStyle = mpGrad;
    ctx.fillRect(x, y, barWidth * mpPct, barHeight);

    ctx.strokeStyle = '#666666';
    ctx.strokeRect(x, y, barWidth, barHeight);

    ctx.fillStyle = '#ffffff';
    ctx.fillText(
      `MP: ${Math.ceil(this.displayMP)}/${Math.ceil(this.displayMaxMP)}`,
      x + barWidth / 2,
      y + barHeight / 2
    );

    // Stamina bar
    const stPct = this.displayST / this.displayMaxST;
    y += barHeight + spacing;

    ctx.fillStyle = 'rgba(40, 40, 40, 0.8)';
    ctx.fillRect(x, y, barWidth, barHeight);

    const stGrad = ctx.createLinearGradient(x, y, x + barWidth * stPct, y);
    stGrad.addColorStop(0, '#ffdd44');
    stGrad.addColorStop(1, '#aa8800');
    ctx.fillStyle = stGrad;
    ctx.fillRect(x, y, barWidth * stPct, barHeight);

    ctx.strokeStyle = '#666666';
    ctx.strokeRect(x, y, barWidth, barHeight);

    ctx.fillStyle = '#ffffff';
    ctx.fillText(
      `ST: ${Math.ceil(this.displayST)}/${Math.ceil(this.displayMaxST)}`,
      x + barWidth / 2,
      y + barHeight / 2
    );

    // XP bar
    const xpPct = this.displayXP / this.displayMaxXP;
    y += barHeight + spacing;

    ctx.fillStyle = 'rgba(40, 40, 40, 0.8)';
    ctx.fillRect(x, y, barWidth, barHeight);

    const xpGrad = ctx.createLinearGradient(x, y, x + barWidth * xpPct, y);
    xpGrad.addColorStop(0, '#44ff88');
    xpGrad.addColorStop(1, '#228844');
    ctx.fillStyle = xpGrad;
    ctx.fillRect(x, y, barWidth * xpPct, barHeight);

    ctx.strokeStyle = '#666666';
    ctx.strokeRect(x, y, barWidth, barHeight);

    ctx.fillStyle = '#ffffff';
    ctx.fillText(
      `Lv.${G.player.level} - ${Math.floor(this.displayXP)}/${Math.ceil(this.displayMaxXP)} XP`,
      x + barWidth / 2,
      y + barHeight / 2
    );
  },

  renderFloorInfo(ctx, x, y) {
    const theme = getFloorTheme(G.currentFloor);

    ctx.font = 'bold 18px sans-serif';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'top';
    ctx.fillStyle = theme.color || '#ffffff';
    ctx.fillText(`Floor ${G.currentFloor} - ${theme.name}`, x, y);

    ctx.font = '16px sans-serif';
    ctx.fillStyle = '#ffcc00';
    ctx.fillText(`Score: ${G.score.toLocaleString()}`, x, y + 25);

    ctx.fillStyle = '#cccccc';
    ctx.fillText(Util.formatTime(G.time), x, y + 45);
  },

  renderBossBar(ctx, centerX, y) {
    if (!G.boss) return;

    const barWidth = G.canvas.width * 0.6;
    const barHeight = 24;
    const x = centerX - barWidth / 2;

    // Boss name
    ctx.font = 'bold 20px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillStyle = '#ff3333';
    ctx.shadowBlur = 10;
    ctx.shadowColor = '#ff0000';
    ctx.fillText(G.boss.name || 'BOSS', centerX, y + 15);
    ctx.shadowBlur = 0;

    // HP bar
    const hpPct = G.boss.hp / G.boss.maxHP;

    ctx.fillStyle = 'rgba(40, 40, 40, 0.9)';
    ctx.fillRect(x, y + 20, barWidth, barHeight);

    const bossGrad = ctx.createLinearGradient(x, y + 20, x + barWidth * hpPct, y + 20);
    bossGrad.addColorStop(0, '#ff6633');
    bossGrad.addColorStop(1, '#cc2200');
    ctx.fillStyle = bossGrad;
    ctx.fillRect(x, y + 20, barWidth * hpPct, barHeight);

    ctx.strokeStyle = '#ff3333';
    ctx.lineWidth = 2;
    ctx.strokeRect(x, y + 20, barWidth, barHeight);

    // Phase indicators
    if (G.boss.phases && G.boss.phases.length > 0) {
      const phaseWidth = 8;
      const phaseSpacing = 4;
      const totalPhaseWidth = G.boss.phases.length * (phaseWidth + phaseSpacing);
      let phaseX = centerX - totalPhaseWidth / 2;
      const phaseY = y + 50;

      for (let i = 0; i < G.boss.phases.length; i++) {
        ctx.fillStyle = (i <= G.boss.currentPhase) ? '#ff6633' : '#444444';
        ctx.fillRect(phaseX, phaseY, phaseWidth, phaseWidth);
        phaseX += phaseWidth + phaseSpacing;
      }
    }
  },

  renderAbilityHotbar(ctx, x, y) {
    const slotSize = 50;
    const spacing = 8;

    for (let i = 0; i < 4; i++) {
      const slotX = x + i * (slotSize + spacing);
      const ability = G.player.equippedAbilities[i];

      // Slot background
      ctx.fillStyle = 'rgba(40, 40, 40, 0.8)';
      ctx.fillRect(slotX, y, slotSize, slotSize);

      if (ability) {
        const abilityDef = ABILITY_DEFS[ability];
        if (abilityDef) {
          // Ability icon (colored square with initial)
          ctx.fillStyle = abilityDef.color || '#888888';
          ctx.fillRect(slotX + 5, y + 5, slotSize - 10, slotSize - 10);

          ctx.font = 'bold 20px sans-serif';
          ctx.fillStyle = '#ffffff';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(abilityDef.name[0], slotX + slotSize / 2, y + slotSize / 2);

          // Cooldown overlay
          const cooldown = G.player.abilityCooldowns[ability] || 0;
          if (cooldown > 0) {
            const cooldownPct = cooldown / abilityDef.cooldown;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.beginPath();
            ctx.moveTo(slotX + slotSize / 2, y + slotSize / 2);
            ctx.arc(
              slotX + slotSize / 2,
              y + slotSize / 2,
              slotSize / 2 - 5,
              -Math.PI / 2,
              -Math.PI / 2 + Math.PI * 2 * cooldownPct
            );
            ctx.closePath();
            ctx.fill();
          }
        }
      }

      // Border
      ctx.strokeStyle = '#666666';
      ctx.lineWidth = 2;
      ctx.strokeRect(slotX, y, slotSize, slotSize);

      // Key label
      ctx.font = 'bold 12px sans-serif';
      ctx.fillStyle = '#ffcc00';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      ctx.fillText(`${i + 1}`, slotX + 4, y + 4);
    }
  },

  renderCombo(ctx, x, y) {
    const combo = G.combo;
    const multiplier = 1.0 + (combo - 1) * 0.1;

    // Color intensity based on combo
    let color = '#ffffff';
    if (combo >= 10) color = '#ff3333';
    else if (combo >= 5) color = '#ff9933';
    else if (combo >= 3) color = '#ffcc33';

    ctx.save();
    ctx.translate(x, y);
    ctx.scale(this.comboScale, this.comboScale);

    ctx.font = 'bold 48px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = color;
    ctx.shadowBlur = 15;
    ctx.shadowColor = color;
    ctx.fillText(`x${combo}`, 0, 0);

    ctx.font = 'bold 20px sans-serif';
    ctx.fillText('COMBO', 0, 35);

    ctx.font = '16px sans-serif';
    ctx.fillStyle = '#ffcc00';
    ctx.fillText(`${multiplier.toFixed(1)}x`, 0, 55);

    ctx.restore();
  },

  renderFloatingText(ctx) {
    for (let ft of G.floatingTexts) {
      const alpha = Util.clamp(ft.life, 0, 1);
      const screenPos = Camera.worldToScreen(ft.x, ft.y);

      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.font = `bold ${ft.size}px sans-serif`;
      ctx.fillStyle = ft.color;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.shadowBlur = 5;
      ctx.shadowColor = '#000000';
      ctx.fillText(ft.text, screenPos.x, screenPos.y);
      ctx.restore();
    }
  },

  addFloatingText(x, y, text, color, size) {
    G.floatingTexts.push({
      x: x,
      y: y,
      text: text,
      color: color,
      size: size || 20,
      life: 1.0,
      startY: y
    });
  },

  renderDeathOverlay(ctx) {
    const w = G.canvas.width;
    const h = G.canvas.height;

    // Red tinted overlay
    ctx.fillStyle = 'rgba(100, 0, 0, 0.6)';
    ctx.fillRect(0, 0, w, h);

    // YOU DIED
    ctx.font = 'bold 72px serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#ff0000';
    ctx.shadowBlur = 30;
    ctx.shadowColor = '#ff0000';
    ctx.fillText('YOU DIED', w / 2, h / 2 - 50);

    // Stats
    ctx.shadowBlur = 0;
    ctx.font = '24px sans-serif';
    ctx.fillStyle = '#ffffff';
    ctx.fillText(
      `Floor ${G.currentFloor} reached | ${G.enemiesSlain || 0} enemies slain`,
      w / 2,
      h / 2 + 30
    );

    ctx.font = 'italic 20px sans-serif';
    ctx.fillStyle = '#ffcc00';
    ctx.fillText('Press ENTER to try again', w / 2, h / 2 + 80);
    ctx.fillText('Press ESC for title screen', w / 2, h / 2 + 110);
  },

  renderGameOver(ctx) {
    const w = G.canvas.width;
    const h = G.canvas.height;

    // Dark overlay
    ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
    ctx.fillRect(0, 0, w, h);

    // GAME OVER
    ctx.font = 'bold 64px serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#cc0000';
    ctx.shadowBlur = 20;
    ctx.shadowColor = '#cc0000';
    ctx.fillText('GAME OVER', w / 2, h / 2 - 100);

    ctx.shadowBlur = 0;

    // Stats summary
    const stats = [
      `Final Score: ${G.score}`,
      `Deepest Floor: ${G.currentFloor}`,
      `Enemies Slain: ${G.enemiesSlain || 0}`,
      `Time: ${Util.formatTime(G.time)}`
    ];

    ctx.font = '22px sans-serif';
    ctx.fillStyle = '#ffffff';
    for (let i = 0; i < stats.length; i++) {
      ctx.fillText(stats[i], w / 2, h / 2 - 20 + i * 35);
    }

    // High score comparison
    const highScore = Save.loadHighScore();
    ctx.font = '18px sans-serif';
    ctx.fillStyle = G.score > highScore.score ? '#ffcc00' : '#888888';
    ctx.fillText(
      G.score > highScore.score ? 'NEW HIGH SCORE!' : `High Score: ${highScore.score}`,
      w / 2,
      h / 2 + 120
    );

    ctx.font = 'italic 20px sans-serif';
    ctx.fillStyle = '#ffcc00';
    ctx.fillText('Press ENTER for new game', w / 2, h / 2 + 160);
  },

  renderVictory(ctx, ending) {
    const w = G.canvas.width;
    const h = G.canvas.height;

    // Victory overlay with ending theme
    const endingData = (typeof ending === 'object') ? ending : {
      name: 'Victory',
      description: 'You have conquered the depths!',
      color: '#ffcc00'
    };
    const themeColor = endingData.color || '#ffcc00';

    const grad = ctx.createRadialGradient(w / 2, h / 2, 0, w / 2, h / 2, w / 2);
    grad.addColorStop(0, Util.rgba(255, 215, 0, 0.3));
    grad.addColorStop(1, 'rgba(0, 0, 0, 0.9)');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, w, h);

    // Victory header
    ctx.font = 'bold 56px serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = themeColor;
    ctx.shadowBlur = 25;
    ctx.shadowColor = themeColor;
    ctx.fillText('VICTORY!', w / 2, 80);

    // Ending title
    ctx.font = 'bold 32px serif';
    ctx.fillStyle = '#ffffff';
    ctx.shadowBlur = 10;
    ctx.fillText(endingData.name, w / 2, 140);

    // Ending description
    ctx.shadowBlur = 0;
    ctx.font = '18px sans-serif';
    ctx.fillStyle = '#cccccc';
    const descLines = this.wrapText(ctx, endingData.description, w - 100);
    for (let i = 0; i < descLines.length; i++) {
      ctx.fillText(descLines[i], w / 2, 200 + i * 25);
    }

    // Congratulations
    ctx.font = 'italic 24px serif';
    ctx.fillStyle = themeColor;
    ctx.fillText('You conquered the depths!', w / 2, h - 180);

    // Final stats
    ctx.font = '20px sans-serif';
    ctx.fillStyle = '#ffffff';
    ctx.fillText(`Final Score: ${G.score} | Time: ${Util.formatTime(G.time)}`, w / 2, h - 140);

    ctx.font = 'italic 18px sans-serif';
    ctx.fillStyle = '#ffcc00';
    ctx.fillText('Press ENTER to return to title', w / 2, h - 80);
  },

  wrapText(ctx, text, maxWidth) {
    const words = text.split(' ');
    const lines = [];
    let line = '';

    for (let word of words) {
      const testLine = line + word + ' ';
      const metrics = ctx.measureText(testLine);
      if (metrics.width > maxWidth && line.length > 0) {
        lines.push(line.trim());
        line = word + ' ';
      } else {
        line = testLine;
      }
    }
    if (line.length > 0) {
      lines.push(line.trim());
    }

    return lines;
  }
};

// === ui/menus.js ===
// menus.js
// Pause menu, inventory screen, skill tree, crafting UI

const Menus = {
  pauseIndex: 0,
  invCursor: { x: 0, y: 0 },
  invTab: 0, // 0=items, 1=equipment, 2=stats
  skillCursor: { tree: 0, tier: 0, slot: 0 },
  craftCursor: 0,
  tooltipItem: null,
  selectedStat: 0,
  craftRecipes: [],
  scrollOffset: 0,

  init() {
    this.pauseIndex = 0;
    this.invCursor = { x: 0, y: 0 };
    this.invTab = 0;
    this.skillCursor = { tree: 0, tier: 0, slot: 0 };
    this.craftCursor = 0;
    this.tooltipItem = null;
    this.selectedStat = 0;
    this.craftRecipes = [];
    this.scrollOffset = 0;
  },

  update(dt) {
    if (G.gameState === STATE.PAUSED) {
      this.updatePause();
    } else if (G.gameState === STATE.INVENTORY) {
      this.updateInventory();
    } else if (G.gameState === STATE.SKILL_TREE) {
      this.updateSkillTree();
    } else if (G.gameState === STATE.CRAFTING) {
      this.updateCrafting();
    }
  },

  togglePause() {
    if (G.gameState === STATE.PLAYING) {
      G.gameState = STATE.PAUSED;
      G.paused = true;
      SFX.playSound('menu_select');
    } else if (G.gameState === STATE.PAUSED) {
      G.gameState = STATE.PLAYING;
      G.paused = false;
      SFX.playSound('menu_select');
    }
  },

  openInventory() {
    G.gameState = STATE.INVENTORY;
    this.invTab = 0;
    this.invCursor = { x: 0, y: 0 };
    SFX.playSound('menu_select');
  },

  openSkillTree() {
    G.gameState = STATE.SKILL_TREE;
    this.skillCursor = { tree: 0, tier: 0, slot: 0 };
    SFX.playSound('menu_select');
  },

  openCrafting() {
    G.gameState = STATE.CRAFTING;
    this.craftCursor = 0;
    this.craftRecipes = Crafting.getAvailableRecipes();
    SFX.playSound('menu_select');
  },

  updatePause() {
    const menuItems = ['Resume', 'Save Game', 'Settings', 'Quit to Title'];

    if (Input.justPressed('ArrowDown') || Input.justPressed('KeyS')) {
      this.pauseIndex = (this.pauseIndex + 1) % menuItems.length;
      SFX.playSound('menu_hover');
    }
    if (Input.justPressed('ArrowUp') || Input.justPressed('KeyW')) {
      this.pauseIndex = (this.pauseIndex - 1 + menuItems.length) % menuItems.length;
      SFX.playSound('menu_hover');
    }

    if (Input.justPressed('Enter') || Input.justPressed('Space')) {
      SFX.playSound('menu_select');
      if (this.pauseIndex === 0) {
        this.togglePause();
      } else if (this.pauseIndex === 1) {
        Save.saveGame();
        HUD.addFloatingText(G.player.x, G.player.y - 50, 'Game Saved!', '#00ff00', 24);
      } else if (this.pauseIndex === 2) {
        // Settings (placeholder)
      } else if (this.pauseIndex === 3) {
        G.gameState = STATE.TITLE;
        TitleScreen.init();
      }
    }

    if (Input.justPressed('Escape') || Input.justPressed('KeyP')) {
      this.togglePause();
    }
  },

  updateInventory() {
    if (Input.justPressed('Escape') || Input.justPressed('KeyI')) {
      G.gameState = STATE.PLAYING;
      SFX.playSound('menu_select');
      return;
    }

    // Tab switching
    if (Input.justPressed('Tab')) {
      this.invTab = (this.invTab + 1) % 3;
      SFX.playSound('menu_hover');
    }

    if (this.invTab === 0) {
      // Items tab - grid navigation
      if (Input.justPressed('ArrowRight') || Input.justPressed('KeyD')) {
        this.invCursor.x = Math.min(this.invCursor.x + 1, 4);
        SFX.playSound('menu_hover');
      }
      if (Input.justPressed('ArrowLeft') || Input.justPressed('KeyA')) {
        this.invCursor.x = Math.max(this.invCursor.x - 1, 0);
        SFX.playSound('menu_hover');
      }
      if (Input.justPressed('ArrowDown') || Input.justPressed('KeyS')) {
        this.invCursor.y = Math.min(this.invCursor.y + 1, 3);
        SFX.playSound('menu_hover');
      }
      if (Input.justPressed('ArrowUp') || Input.justPressed('KeyW')) {
        this.invCursor.y = Math.max(this.invCursor.y - 1, 0);
        SFX.playSound('menu_hover');
      }

      const idx = this.invCursor.y * 5 + this.invCursor.x;
      const item = G.player.inventory[idx];
      this.tooltipItem = item || null;

      if (Input.justPressed('KeyE') && item) {
        Inventory.equipItem(idx);
      }
      if (Input.justPressed('KeyU') && item) {
        Inventory.useItem(idx);
      }
      if (Input.justPressed('KeyD') && item) {
        Inventory.dropItem(idx);
      }
    } else if (this.invTab === 2) {
      // Stats tab
      const stats = ['str', 'dex', 'vit', 'int'];
      if (Input.justPressed('ArrowDown') || Input.justPressed('KeyS')) {
        this.selectedStat = (this.selectedStat + 1) % stats.length;
        SFX.playSound('menu_hover');
      }
      if (Input.justPressed('ArrowUp') || Input.justPressed('KeyW')) {
        this.selectedStat = (this.selectedStat - 1 + stats.length) % stats.length;
        SFX.playSound('menu_hover');
      }
      if (Input.justPressed('Enter') || Input.justPressed('Space')) {
        if (G.player.statPoints > 0) {
          Progression.allocateStat(stats[this.selectedStat]);
        }
      }
    }
  },

  updateSkillTree() {
    if (Input.justPressed('Escape') || Input.justPressed('KeyK')) {
      G.gameState = STATE.PLAYING;
      SFX.playSound('menu_select');
      return;
    }

    // Navigate trees (left/right)
    if (Input.justPressed('ArrowRight') || Input.justPressed('KeyD')) {
      this.skillCursor.tree = (this.skillCursor.tree + 1) % 3;
      SFX.playSound('menu_hover');
    }
    if (Input.justPressed('ArrowLeft') || Input.justPressed('KeyA')) {
      this.skillCursor.tree = (this.skillCursor.tree - 1 + 3) % 3;
      SFX.playSound('menu_hover');
    }

    // Navigate tiers (up/down)
    if (Input.justPressed('ArrowDown') || Input.justPressed('KeyS')) {
      this.skillCursor.tier = Math.min(this.skillCursor.tier + 1, 2);
      SFX.playSound('menu_hover');
    }
    if (Input.justPressed('ArrowUp') || Input.justPressed('KeyW')) {
      this.skillCursor.tier = Math.max(this.skillCursor.tier - 1, 0);
      SFX.playSound('menu_hover');
    }

    // Navigate slots within tier
    if (Input.justPressed('Tab')) {
      this.skillCursor.slot = (this.skillCursor.slot + 1) % 3;
      SFX.playSound('menu_hover');
    }

    // Unlock ability
    if (Input.justPressed('Enter') || Input.justPressed('Space')) {
      const trees = ['warrior', 'mage', 'rogue'];
      const treeName = trees[this.skillCursor.tree];
      const tier = this.skillCursor.tier;
      const slot = this.skillCursor.slot;
      const abilityId = SKILL_TREES[treeName][tier][slot];

      if (canUnlockAbility(abilityId)) {
        Progression.unlockAbility(abilityId);
      }
    }

    // Equip ability
    if (Input.justPressed('KeyE')) {
      const trees = ['warrior', 'mage', 'rogue'];
      const treeName = trees[this.skillCursor.tree];
      const tier = this.skillCursor.tier;
      const slot = this.skillCursor.slot;
      const abilityId = SKILL_TREES[treeName][tier][slot];

      if (G.player.unlockedAbilities.includes(abilityId)) {
        // Find first empty hotbar slot
        for (let i = 0; i < 4; i++) {
          if (!G.player.equippedAbilities[i]) {
            Progression.equipAbility(abilityId, i);
            break;
          }
        }
      }
    }
  },

  updateCrafting() {
    if (Input.justPressed('Escape') || Input.justPressed('KeyC')) {
      G.gameState = STATE.PLAYING;
      SFX.playSound('menu_select');
      return;
    }

    if (Input.justPressed('ArrowDown') || Input.justPressed('KeyS')) {
      this.craftCursor = Math.min(this.craftCursor + 1, this.craftRecipes.length - 1);
      SFX.playSound('menu_hover');
    }
    if (Input.justPressed('ArrowUp') || Input.justPressed('KeyW')) {
      this.craftCursor = Math.max(this.craftCursor - 1, 0);
      SFX.playSound('menu_hover');
    }

    if (Input.justPressed('Enter') || Input.justPressed('Space')) {
      const recipe = this.craftRecipes[this.craftCursor];
      if (recipe && Crafting.canCraft(recipe.id)) {
        Crafting.craft(recipe.id);
        this.craftRecipes = Crafting.getAvailableRecipes();
      }
    }
  },

  renderPause(ctx) {
    const w = G.canvas.width;
    const h = G.canvas.height;

    // Dark backdrop
    ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
    ctx.fillRect(0, 0, w, h);

    // PAUSED header
    ctx.font = 'bold 48px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#ffcc00';
    ctx.shadowBlur = 15;
    ctx.shadowColor = '#ffcc00';
    ctx.fillText('PAUSED', w / 2, 100);
    ctx.shadowBlur = 0;

    // Menu items
    const menuItems = ['Resume', 'Save Game', 'Settings', 'Quit to Title'];
    const startY = h / 2 - 50;
    const itemHeight = 50;

    ctx.font = 'bold 28px sans-serif';
    for (let i = 0; i < menuItems.length; i++) {
      const y = startY + i * itemHeight;
      const isSelected = (i === this.pauseIndex);

      if (isSelected) {
        ctx.fillStyle = '#ffcc00';
        ctx.fillText('>', w / 2 - 120, y);
      }

      ctx.fillStyle = isSelected ? '#ffffff' : '#888888';
      ctx.fillText(menuItems[i], w / 2, y);
    }
  },

  renderInventory(ctx) {
    const w = G.canvas.width;
    const h = G.canvas.height;

    // Dark backdrop
    ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
    ctx.fillRect(0, 0, w, h);

    // Header
    ctx.font = 'bold 32px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillStyle = '#ffcc00';
    ctx.fillText('INVENTORY', w / 2, 40);

    // Tabs
    const tabs = ['Items', 'Equipment', 'Stats'];
    const tabWidth = 120;
    const tabY = 80;
    const tabStartX = w / 2 - (tabs.length * tabWidth) / 2;

    ctx.font = 'bold 20px sans-serif';
    for (let i = 0; i < tabs.length; i++) {
      const tabX = tabStartX + i * tabWidth;
      const isSelected = (i === this.invTab);

      ctx.fillStyle = isSelected ? 'rgba(80, 80, 80, 0.9)' : 'rgba(40, 40, 40, 0.7)';
      ctx.fillRect(tabX, tabY, tabWidth - 10, 40);

      ctx.fillStyle = isSelected ? '#ffffff' : '#888888';
      ctx.textAlign = 'center';
      ctx.fillText(tabs[i], tabX + tabWidth / 2 - 5, tabY + 25);
    }

    if (this.invTab === 0) {
      this.renderItemsTab(ctx);
    } else if (this.invTab === 1) {
      this.renderEquipmentTab(ctx);
    } else if (this.invTab === 2) {
      this.renderStatsTab(ctx);
    }
  },

  renderItemsTab(ctx) {
    const w = G.canvas.width;
    const gridX = 50;
    const gridY = 150;
    const slotSize = 60;
    const spacing = 10;

    // Grid
    for (let y = 0; y < 4; y++) {
      for (let x = 0; x < 5; x++) {
        const idx = y * 5 + x;
        const sx = gridX + x * (slotSize + spacing);
        const sy = gridY + y * (slotSize + spacing);
        const isSelected = (this.invCursor.x === x && this.invCursor.y === y);

        const item = G.player.inventory[idx];

        // Slot background
        ctx.fillStyle = 'rgba(40, 40, 40, 0.8)';
        ctx.fillRect(sx, sy, slotSize, slotSize);

        if (item) {
          // Item icon
          const rarityColor = RARITY_COLORS[item.rarity] || '#888888';
          ctx.fillStyle = rarityColor;
          ctx.fillRect(sx + 10, sy + 10, slotSize - 20, slotSize - 20);

          // Type indicator
          ctx.font = 'bold 16px sans-serif';
          ctx.fillStyle = '#ffffff';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(item.type[0].toUpperCase(), sx + slotSize / 2, sy + slotSize / 2);

          // Rarity border
          ctx.strokeStyle = rarityColor;
          ctx.lineWidth = 2;
          ctx.strokeRect(sx, sy, slotSize, slotSize);
        } else {
          ctx.strokeStyle = '#444444';
          ctx.lineWidth = 1;
          ctx.strokeRect(sx, sy, slotSize, slotSize);
        }

        // Selection border
        if (isSelected) {
          ctx.strokeStyle = '#ffcc00';
          ctx.lineWidth = 3;
          ctx.strokeRect(sx - 2, sy - 2, slotSize + 4, slotSize + 4);
        }
      }
    }

    // Item details panel
    if (this.tooltipItem) {
      this.renderItemDetails(ctx, this.tooltipItem, w - 350, gridY);
    }

    // Instructions
    ctx.font = '16px sans-serif';
    ctx.fillStyle = '#cccccc';
    ctx.textAlign = 'left';
    ctx.fillText('[E] Equip  [U] Use  [D] Drop', gridX, gridY + 4 * (slotSize + spacing) + 30);
  },

  renderEquipmentTab(ctx) {
    const w = G.canvas.width;
    const h = G.canvas.height;

    ctx.font = '20px sans-serif';
    ctx.fillStyle = '#ffffff';
    ctx.textAlign = 'center';
    ctx.fillText('Equipment slots coming soon...', w / 2, h / 2);
  },

  renderStatsTab(ctx) {
    const w = G.canvas.width;
    const startY = 150;

    const stats = [
      { name: 'Strength', key: 'str', value: G.player.stats.str },
      { name: 'Dexterity', key: 'dex', value: G.player.stats.dex },
      { name: 'Vitality', key: 'vit', value: G.player.stats.vit },
      { name: 'Intelligence', key: 'int', value: G.player.stats.int }
    ];

    ctx.font = 'bold 24px sans-serif';
    ctx.fillStyle = '#ffcc00';
    ctx.textAlign = 'center';
    ctx.fillText(`Stat Points Available: ${G.player.statPoints}`, w / 2, startY - 30);

    ctx.font = '22px sans-serif';
    for (let i = 0; i < stats.length; i++) {
      const y = startY + i * 50;
      const isSelected = (i === this.selectedStat);

      ctx.fillStyle = isSelected ? '#ffffff' : '#888888';
      ctx.textAlign = 'left';
      ctx.fillText(`${stats[i].name}: ${stats[i].value}`, w / 2 - 150, y);

      if (isSelected && G.player.statPoints > 0) {
        ctx.fillStyle = '#ffcc00';
        ctx.fillText('[+]', w / 2 + 80, y);
      }
    }

    ctx.font = '16px sans-serif';
    ctx.fillStyle = '#cccccc';
    ctx.textAlign = 'center';
    ctx.fillText('Press ENTER to allocate points', w / 2, startY + stats.length * 50 + 40);
  },

  renderItemDetails(ctx, item, x, y) {
    const panelWidth = 300;
    const panelHeight = 300;

    // Panel background
    ctx.fillStyle = 'rgba(40, 40, 40, 0.95)';
    ctx.fillRect(x, y, panelWidth, panelHeight);

    const rarityColor = RARITY_COLORS[item.rarity] || '#888888';
    ctx.strokeStyle = rarityColor;
    ctx.lineWidth = 2;
    ctx.strokeRect(x, y, panelWidth, panelHeight);

    // Item name
    ctx.font = 'bold 22px sans-serif';
    ctx.fillStyle = rarityColor;
    ctx.textAlign = 'left';
    ctx.fillText(item.name, x + 10, y + 30);

    // Type and rarity
    ctx.font = '16px sans-serif';
    ctx.fillStyle = '#cccccc';
    ctx.fillText(`${item.type} - ${item.rarity}`, x + 10, y + 55);

    // Stats
    let detailY = y + 85;
    ctx.font = '18px sans-serif';

    if (item.damage) {
      ctx.fillStyle = '#ff6666';
      ctx.fillText(`Damage: +${item.damage}`, x + 10, detailY);
      detailY += 25;
    }
    if (item.defense) {
      ctx.fillStyle = '#6666ff';
      ctx.fillText(`Defense: +${item.defense}`, x + 10, detailY);
      detailY += 25;
    }
    if (item.hp) {
      ctx.fillStyle = '#66ff66';
      ctx.fillText(`HP: +${item.hp}`, x + 10, detailY);
      detailY += 25;
    }

    // Description
    ctx.font = '14px sans-serif';
    ctx.fillStyle = '#aaaaaa';
    const desc = item.description || 'A mysterious item.';
    const lines = this.wrapText(ctx, desc, panelWidth - 20);
    for (let line of lines) {
      ctx.fillText(line, x + 10, detailY);
      detailY += 20;
    }
  },

  renderSkillTree(ctx) {
    const w = G.canvas.width;
    const h = G.canvas.height;

    // Dark backdrop
    ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
    ctx.fillRect(0, 0, w, h);

    // Header
    ctx.font = 'bold 32px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillStyle = '#ffcc00';
    ctx.fillText('SKILL TREE', w / 2, 40);

    ctx.font = '18px sans-serif';
    ctx.fillText(`Skill Points: ${G.player.skillPoints}`, w / 2, 75);

    const treeNames = ['Warrior', 'Mage', 'Rogue'];
    const treeColors = ['#ff6666', '#6666ff', '#66ff66'];
    const treeData = ['warrior', 'mage', 'rogue'];

    const treeWidth = 250;
    const startX = (w - 3 * treeWidth) / 2;
    const startY = 120;

    for (let t = 0; t < 3; t++) {
      const tx = startX + t * treeWidth;
      const isSelectedTree = (this.skillCursor.tree === t);

      // Tree header
      ctx.font = 'bold 24px sans-serif';
      ctx.fillStyle = isSelectedTree ? treeColors[t] : '#888888';
      ctx.textAlign = 'center';
      ctx.fillText(treeNames[t], tx + treeWidth / 2, startY);

      // Draw tiers
      for (let tier = 0; tier < 3; tier++) {
        const ty = startY + 50 + tier * 120;

        for (let slot = 0; slot < 3; slot++) {
          const nodeX = tx + 30 + slot * 75;
          const nodeY = ty;

          const abilityId = SKILL_TREES[treeData[t]][tier][slot];
          const abilityDef = ABILITY_DEFS[abilityId];
          const isUnlocked = G.player.unlockedAbilities.includes(abilityId);
          const canUnlock = canUnlockAbility(abilityId);
          const isSelected = (isSelectedTree && this.skillCursor.tier === tier && this.skillCursor.slot === slot);

          // Node circle
          ctx.beginPath();
          ctx.arc(nodeX, nodeY, 25, 0, Math.PI * 2);

          if (isUnlocked) {
            ctx.fillStyle = treeColors[t];
          } else if (canUnlock) {
            ctx.fillStyle = 'rgba(100, 100, 100, 0.7)';
            const pulse = Math.sin(G.time * 3) * 0.3 + 0.7;
            ctx.shadowBlur = 10 * pulse;
            ctx.shadowColor = treeColors[t];
          } else {
            ctx.fillStyle = 'rgba(60, 60, 60, 0.5)';
          }

          ctx.fill();

          if (isSelected) {
            ctx.strokeStyle = '#ffcc00';
            ctx.lineWidth = 3;
            ctx.stroke();
          }

          ctx.shadowBlur = 0;

          // Ability initial
          ctx.font = 'bold 16px sans-serif';
          ctx.fillStyle = '#ffffff';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(abilityDef.name[0], nodeX, nodeY);
        }
      }
    }

    // Selected ability details
    const trees = ['warrior', 'mage', 'rogue'];
    const treeName = trees[this.skillCursor.tree];
    const tier = this.skillCursor.tier;
    const slot = this.skillCursor.slot;
    const abilityId = SKILL_TREES[treeName][tier][slot];
    const abilityDef = ABILITY_DEFS[abilityId];

    if (abilityDef) {
      const detailY = startY + 400;
      ctx.font = 'bold 22px sans-serif';
      ctx.fillStyle = treeColors[this.skillCursor.tree];
      ctx.textAlign = 'center';
      ctx.fillText(abilityDef.name, w / 2, detailY);

      ctx.font = '16px sans-serif';
      ctx.fillStyle = '#cccccc';
      ctx.fillText(abilityDef.description, w / 2, detailY + 30);

      ctx.fillStyle = '#ffcc00';
      ctx.fillText(`Cost: ${abilityDef.cost || 1} SP | Cooldown: ${abilityDef.cooldown}s`, w / 2, detailY + 55);

      ctx.font = '14px sans-serif';
      ctx.fillText('[ENTER] Unlock  [E] Equip', w / 2, detailY + 85);
    }
  },

  renderCrafting(ctx) {
    const w = G.canvas.width;
    const h = G.canvas.height;

    // Dark backdrop
    ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
    ctx.fillRect(0, 0, w, h);

    // Header
    ctx.font = 'bold 32px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillStyle = '#ffcc00';
    ctx.fillText('CRAFTING', w / 2, 40);

    if (this.craftRecipes.length === 0) {
      ctx.font = '20px sans-serif';
      ctx.fillStyle = '#888888';
      ctx.fillText('No recipes available', w / 2, h / 2);
      return;
    }

    // Recipe list
    const listX = 50;
    const listY = 100;
    const itemHeight = 40;

    ctx.font = '18px sans-serif';
    ctx.textAlign = 'left';

    for (let i = 0; i < this.craftRecipes.length; i++) {
      const recipe = this.craftRecipes[i];
      const y = listY + i * itemHeight;
      const isSelected = (i === this.craftCursor);
      const canCraft = Crafting.canCraft(recipe.id);

      if (isSelected) {
        ctx.fillStyle = 'rgba(80, 80, 80, 0.8)';
        ctx.fillRect(listX - 10, y - 20, 400, itemHeight - 5);
      }

      ctx.fillStyle = canCraft ? '#ffffff' : '#888888';
      ctx.fillText(recipe.name, listX, y);

      if (!canCraft) {
        ctx.fillStyle = '#ff6666';
        ctx.fillText('[Missing materials]', listX + 250, y);
      }
    }

    // Recipe details
    if (this.craftRecipes[this.craftCursor]) {
      this.renderRecipeDetails(ctx, this.craftRecipes[this.craftCursor], w - 350, listY);
    }
  },

  renderRecipeDetails(ctx, recipe, x, y) {
    const panelWidth = 300;

    ctx.fillStyle = 'rgba(40, 40, 40, 0.95)';
    ctx.fillRect(x, y, panelWidth, 350);

    ctx.strokeStyle = '#ffcc00';
    ctx.lineWidth = 2;
    ctx.strokeRect(x, y, panelWidth, 350);

    ctx.font = 'bold 20px sans-serif';
    ctx.fillStyle = '#ffcc00';
    ctx.textAlign = 'left';
    ctx.fillText(recipe.name, x + 10, y + 30);

    ctx.font = '16px sans-serif';
    ctx.fillStyle = '#cccccc';
    ctx.fillText('Required Materials:', x + 10, y + 60);

    let detailY = y + 90;
    for (let mat of recipe.materials) {
      const has = Crafting.getMaterialCount(mat.id);
      const color = has >= mat.count ? '#66ff66' : '#ff6666';

      ctx.fillStyle = color;
      const materialName = mat.id.replace(/_/g, ' ');
      ctx.fillText(`${materialName}: ${has}/${mat.count}`, x + 20, detailY);
      detailY += 25;
    }

    ctx.font = '14px sans-serif';
    ctx.fillStyle = '#ffcc00';
    ctx.fillText('[ENTER] to craft', x + 10, y + 320);
  },

  renderTooltip(ctx, item, x, y) {
    const boxWidth = 250;
    const boxHeight = 150;

    ctx.fillStyle = 'rgba(20, 20, 20, 0.95)';
    ctx.fillRect(x, y, boxWidth, boxHeight);

    const rarityColor = RARITY_COLORS[item.rarity] || '#888888';
    ctx.strokeStyle = rarityColor;
    ctx.lineWidth = 2;
    ctx.strokeRect(x, y, boxWidth, boxHeight);

    ctx.font = 'bold 18px sans-serif';
    ctx.fillStyle = rarityColor;
    ctx.textAlign = 'left';
    ctx.fillText(item.name, x + 10, y + 25);

    ctx.font = '14px sans-serif';
    ctx.fillStyle = '#aaaaaa';
    ctx.fillText(`${item.type} - ${item.rarity}`, x + 10, y + 45);
  },

  wrapText(ctx, text, maxWidth) {
    const words = text.split(' ');
    const lines = [];
    let line = '';

    for (let word of words) {
      const testLine = line + word + ' ';
      const metrics = ctx.measureText(testLine);
      if (metrics.width > maxWidth && line.length > 0) {
        lines.push(line.trim());
        line = word + ' ';
      } else {
        line = testLine;
      }
    }
    if (line.length > 0) {
      lines.push(line.trim());
    }

    return lines;
  }
};

// === ui/minimap.js ===
// minimap.js
// Corner minimap with fog of war

const Minimap = {
  visible: true,
  size: 160,
  scale: 4,
  canvas: null,
  ctx: null,
  needsRedraw: true,
  lastPlayerTile: { x: -1, y: -1 },

  init() {
    this.visible = true;
    this.size = 160;
    this.needsRedraw = true;
    this.lastPlayerTile = { x: -1, y: -1 };

    // Create offscreen canvas
    this.canvas = document.createElement('canvas');
    this.canvas.width = this.size;
    this.canvas.height = this.size;
    this.ctx = this.canvas.getContext('2d');
  },

  toggle() {
    this.visible = !this.visible;
    SFX.playSound('menu_select');
  },

  update() {
    if (!TileMap || !TileMap.tiles) return;

    // Check if player moved to new tile
    const playerTileX = Math.floor(G.player.x / TILE_SIZE);
    const playerTileY = Math.floor(G.player.y / TILE_SIZE);

    if (playerTileX !== this.lastPlayerTile.x || playerTileY !== this.lastPlayerTile.y) {
      this.needsRedraw = true;
      this.lastPlayerTile.x = playerTileX;
      this.lastPlayerTile.y = playerTileY;
    }

    // Redraw minimap if needed
    if (this.needsRedraw && this.visible) {
      this.redrawMinimap();
      this.needsRedraw = false;
    }
  },

  redrawMinimap() {
    if (!TileMap || !TileMap.tiles) return;

    const mapWidth = TileMap.width;
    const mapHeight = TileMap.height;

    // Calculate scale to fit entire map
    this.scale = Math.min(this.size / mapWidth, this.size / mapHeight);

    const ctx = this.ctx;
    ctx.clearRect(0, 0, this.size, this.size);

    // Dark background
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, this.size, this.size);

    // Draw tiles
    for (let y = 0; y < mapHeight; y++) {
      for (let x = 0; x < mapWidth; x++) {
        const tile = TileMap.tiles[y][x];
        const isRevealed = Fog.isRevealed(x, y);
        const isVisible = Fog.isVisible(x, y);

        if (!isRevealed) {
          // Hidden - stay black
          continue;
        }

        const px = x * this.scale;
        const py = y * this.scale;

        let color = '#000000';

        if (tile === 1) {
          // Wall
          color = isVisible ? '#666666' : '#333333';
        } else if (tile === 0) {
          // Floor
          color = isVisible ? '#444444' : '#222222';
        } else if (tile === 2) {
          // Door
          color = isVisible ? '#8b4513' : '#4a2511';
        } else if (tile === 3) {
          // Stairs
          color = isVisible ? '#ffffff' : '#888888';
        } else if (tile === 4) {
          // Campfire
          color = isVisible ? '#ff8800' : '#884400';
        } else if (tile === 5) {
          // Chest
          color = isVisible ? '#ffcc00' : '#886600';
        } else if (tile === 6) {
          // Boss gate
          color = isVisible ? '#ff0000' : '#880000';
        }

        ctx.fillStyle = color;
        ctx.fillRect(px, py, Math.ceil(this.scale), Math.ceil(this.scale));
      }
    }

    // Draw enemies (red dots)
    if (G.enemies) {
      for (let enemy of G.enemies) {
        const ex = Math.floor(enemy.x / TILE_SIZE);
        const ey = Math.floor(enemy.y / TILE_SIZE);

        if (Fog.isVisible(ex, ey)) {
          const px = ex * this.scale;
          const py = ey * this.scale;

          ctx.fillStyle = '#ff3333';
          ctx.fillRect(px, py, Math.max(2, this.scale), Math.max(2, this.scale));
        }
      }
    }

    // Draw boss (large red dot)
    if (G.boss && G.bossActive) {
      const bx = Math.floor(G.boss.x / TILE_SIZE);
      const by = Math.floor(G.boss.y / TILE_SIZE);

      if (Fog.isVisible(bx, by)) {
        const px = bx * this.scale;
        const py = by * this.scale;

        ctx.fillStyle = '#ff0000';
        ctx.fillRect(px - 1, py - 1, Math.max(4, this.scale * 2), Math.max(4, this.scale * 2));
      }
    }
  },

  render(ctx) {
    if (!this.visible || !TileMap || !TileMap.tiles) return;

    const w = G.canvas.width;
    const h = G.canvas.height;
    const margin = 10;
    const x = w - this.size - margin;
    const y = h - this.size - margin;

    // Semi-transparent background
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(x - 5, y - 5, this.size + 10, this.size + 10);

    // Draw minimap
    ctx.drawImage(this.canvas, x, y);

    // Border
    ctx.strokeStyle = '#666666';
    ctx.lineWidth = 2;
    ctx.strokeRect(x - 5, y - 5, this.size + 10, this.size + 10);

    // Player position (bright green blinking dot)
    const playerTileX = Math.floor(G.player.x / TILE_SIZE);
    const playerTileY = Math.floor(G.player.y / TILE_SIZE);

    const px = x + playerTileX * this.scale;
    const py = y + playerTileY * this.scale;

    const blink = Math.sin(G.time * 5) * 0.5 + 0.5;
    ctx.fillStyle = Util.rgba(0, 255, 0, blink);
    ctx.fillRect(px - 1, py - 1, 3, 3);

    // Viewport rectangle
    const zoom = Camera.zoom || 1.0;
    const viewWidthTiles = (G.canvas.width / zoom) / TILE_SIZE;
    const viewHeightTiles = (G.canvas.height / zoom) / TILE_SIZE;

    const viewX = x + (Camera.x / TILE_SIZE - viewWidthTiles / 2) * this.scale;
    const viewY = y + (Camera.y / TILE_SIZE - viewHeightTiles / 2) * this.scale;
    const viewW = viewWidthTiles * this.scale;
    const viewH = viewHeightTiles * this.scale;

    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
    ctx.lineWidth = 1;
    ctx.strokeRect(viewX, viewY, viewW, viewH);

    // Tab hint
    ctx.font = '12px sans-serif';
    ctx.fillStyle = '#888888';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'top';
    ctx.fillText('[Tab] Toggle', w - margin - 5, y - 20);
  }
};

// === ui/transitions.js ===
// transitions.js
// Floor transitions, boss intros, screen fades, death/victory transitions

const Transitions = {
  active: false,
  type: null,
  progress: 0,
  duration: 1.0,
  callback: null,
  callbackFired: false,
  data: {},

  start(type, duration, callback, data) {
    this.active = true;
    this.type = type;
    this.progress = 0;
    this.duration = duration;
    this.callback = callback;
    this.callbackFired = false;
    this.data = data || {};
    G.gameState = STATE.TRANSITION;
  },

  update(dt) {
    if (!this.active) return;

    this.progress += dt / this.duration;

    // Fire callback at midpoint
    if (this.progress >= 0.5 && !this.callbackFired && this.callback) {
      this.callback();
      this.callbackFired = true;
    }

    // End transition
    if (this.progress >= 1.0) {
      this.end();
    }
  },

  end() {
    this.active = false;
    this.type = null;

    // Restore game state
    if (G.gameState === STATE.TRANSITION) {
      G.gameState = STATE.PLAYING;
    }
  },

  render(ctx) {
    if (!this.active) return;

    switch (this.type) {
      case 'floorTransition':
        this.renderFloorTransition(ctx);
        break;
      case 'bossIntro':
        this.renderBossIntro(ctx);
        break;
      case 'fadeIn':
        this.renderFadeIn(ctx);
        break;
      case 'fadeOut':
        this.renderFadeOut(ctx);
        break;
      case 'deathTransition':
        this.renderDeathTransition(ctx);
        break;
      case 'victoryTransition':
        this.renderVictoryTransition(ctx);
        break;
    }
  },

  renderFloorTransition(ctx) {
    const w = G.canvas.width;
    const h = G.canvas.height;

    const easeProgress = this.easeInOutCubic(this.progress);

    // Iris transition
    const maxRadius = Math.sqrt(w * w + h * h) / 2;
    let radius;

    if (this.progress < 0.5) {
      // Close iris
      radius = maxRadius * (1.0 - easeProgress * 2);
    } else {
      // Open iris
      radius = maxRadius * ((easeProgress - 0.5) * 2);
    }

    // Draw black fill with circular cutout
    ctx.save();
    ctx.fillStyle = '#000000';

    if (this.progress < 0.5) {
      // Closing - draw black ring
      ctx.beginPath();
      ctx.rect(0, 0, w, h);
      ctx.arc(w / 2, h / 2, radius, 0, Math.PI * 2, true);
      ctx.fill();
    } else {
      // Opening - draw expanding black with hole
      ctx.beginPath();
      ctx.rect(0, 0, w, h);
      ctx.arc(w / 2, h / 2, radius, 0, Math.PI * 2, true);
      ctx.fill();
    }

    // Show floor text during black
    if (this.progress > 0.4 && this.progress < 0.6) {
      const textAlpha = this.progress < 0.5
        ? (this.progress - 0.4) * 10
        : (0.6 - this.progress) * 10;

      ctx.globalAlpha = textAlpha;

      const floorNum = this.data.floor || G.currentFloor;
      const theme = getFloorTheme(floorNum);

      ctx.font = 'bold 48px serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = theme.color || '#ffffff';
      ctx.shadowBlur = 20;
      ctx.shadowColor = theme.color || '#ffffff';
      ctx.fillText(`Floor ${floorNum}`, w / 2, h / 2 - 30);

      ctx.font = 'italic 28px serif';
      ctx.fillText(theme.name, w / 2, h / 2 + 20);
    }

    ctx.restore();
  },

  renderBossIntro(ctx) {
    const w = G.canvas.width;
    const h = G.canvas.height;

    const easeProgress = this.easeInOutCubic(this.progress);

    // Cinematic letterbox bars
    const barHeight = h * 0.15 * easeProgress;

    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, w, barHeight);
    ctx.fillRect(0, h - barHeight, w, barHeight);

    // Boss name animation
    if (this.progress > 0.2 && this.progress < 0.8) {
      const textProgress = (this.progress - 0.2) / 0.6;
      const textAlpha = textProgress < 0.5
        ? textProgress * 2
        : 1.0 - (textProgress - 0.5) * 2;

      ctx.save();
      ctx.globalAlpha = textAlpha;

      const bossName = this.data.bossName || 'BOSS';

      ctx.font = 'bold 56px serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#ff3333';
      ctx.shadowBlur = 30;
      ctx.shadowColor = '#ff0000';
      ctx.fillText(bossName, w / 2, h / 2);

      ctx.font = 'italic 24px serif';
      ctx.fillStyle = '#ffffff';
      ctx.shadowBlur = 10;
      ctx.fillText('BOSS FIGHT', w / 2, h / 2 + 60);

      ctx.restore();
    }

    // Screen shake effect
    if (this.progress > 0.6 && this.progress < 0.8 && window.Camera) {
      const shakeIntensity = 10;
      const shake = (this.progress - 0.6) / 0.2;
      const shakeAmount = shakeIntensity * (1.0 - shake);
      Camera.shake(shakeAmount, 0.2);
    }
  },

  renderFadeIn(ctx) {
    const w = G.canvas.width;
    const h = G.canvas.height;

    const alpha = 1.0 - this.easeInOutQuad(this.progress);

    ctx.fillStyle = Util.rgba(0, 0, 0, alpha);
    ctx.fillRect(0, 0, w, h);
  },

  renderFadeOut(ctx) {
    const w = G.canvas.width;
    const h = G.canvas.height;

    const alpha = this.easeInOutQuad(this.progress);

    ctx.fillStyle = Util.rgba(0, 0, 0, alpha);
    ctx.fillRect(0, 0, w, h);
  },

  renderDeathTransition(ctx) {
    const w = G.canvas.width;
    const h = G.canvas.height;

    const easeProgress = this.easeInOutQuad(this.progress);

    // Red vignette intensifying
    const vignetteAlpha = 0.7 * easeProgress;

    const grad = ctx.createRadialGradient(w / 2, h / 2, w * 0.3, w / 2, h / 2, w * 0.7);
    grad.addColorStop(0, Util.rgba(0, 0, 0, 0));
    grad.addColorStop(1, Util.rgba(150, 0, 0, vignetteAlpha));

    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, w, h);

    // Darken entire screen
    ctx.fillStyle = Util.rgba(0, 0, 0, easeProgress * 0.5);
    ctx.fillRect(0, 0, w, h);

    // Show death screen at end
    if (this.progress > 0.8) {
      HUD.renderDeathOverlay(ctx);
    }
  },

  renderVictoryTransition(ctx) {
    const w = G.canvas.width;
    const h = G.canvas.height;

    const easeProgress = this.easeInOutCubic(this.progress);

    // Golden light expanding
    const radius = Math.sqrt(w * w + h * h) * easeProgress;

    const grad = ctx.createRadialGradient(w / 2, h / 2, 0, w / 2, h / 2, radius);
    grad.addColorStop(0, Util.rgba(255, 215, 0, 0.8));
    grad.addColorStop(0.5, Util.rgba(255, 215, 0, 0.3));
    grad.addColorStop(1, Util.rgba(0, 0, 0, 0));

    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, w, h);

    // Victory text flash
    if (this.progress > 0.3 && this.progress < 0.6) {
      const textProgress = (this.progress - 0.3) / 0.3;
      const textAlpha = Math.sin(textProgress * Math.PI);

      ctx.save();
      ctx.globalAlpha = textAlpha;

      ctx.font = 'bold 64px serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#ffcc00';
      ctx.shadowBlur = 40;
      ctx.shadowColor = '#ffcc00';
      ctx.fillText('VICTORY', w / 2, h / 2);

      ctx.restore();
    }

    // Fade to ending screen
    if (this.progress > 0.7) {
      const fadeAlpha = (this.progress - 0.7) / 0.3;
      ctx.fillStyle = Util.rgba(0, 0, 0, fadeAlpha);
      ctx.fillRect(0, 0, w, h);
    }

    // Show ending screen at end
    if (this.progress > 0.9) {
      const ending = this.data.ending || 'true';
      HUD.renderVictory(ctx, ending);
    }
  },

  // Easing functions
  easeInOutQuad(t) {
    return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
  },

  easeInOutCubic(t) {
    return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
  },

  easeOutElastic(t) {
    const c4 = (2 * Math.PI) / 3;
    return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
  }
};

// === core/game-loop.js ===
'use strict';

// =============================================================================
// GAME-LOOP.JS - Main engine loop and state machine (MUST BE LOADED LAST)
// =============================================================================
// Depends on ALL other modules being loaded first.
// Initializes the game engine and runs the requestAnimationFrame loop.

const Engine = {
    canvas: null,
    ctx: null,
    lastTime: 0,
    running: false,
    fpsTimer: 0,
    fpsCount: 0,
    currentFPS: 0
};

// =============================================================================
// INITIALIZATION
// =============================================================================

Engine.init = function() {
    // Canvas setup
    Engine.canvas = document.getElementById('gameCanvas');
    Engine.ctx = Engine.canvas.getContext('2d');
    G.canvas = Engine.canvas;
    G.ctx = Engine.ctx;

    // Resize canvas to window
    Engine.resize();
    window.addEventListener('resize', Engine.resize);

    // Initialize all subsystems
    Input.init(Engine.canvas);
    SFX.init();
    FX.init();
    Fog.init(100, 80);
    Lighting.init(100 * TILE_SIZE, 80 * TILE_SIZE);
    Camera.init(Engine.canvas);
    Minimap.init();

    // Load settings and high scores
    const settings = Save.loadSettings();
    G.difficulty = settings.difficulty || 'Normal';
    const hs = Save.loadHighScore();
    G.highScore = hs.score || 0;
    G.deepestFloor = hs.deepestFloor || 1;

    // Initialize title screen
    TitleScreen.init();
    G.gameState = STATE.TITLE;

    // Resume audio on first user interaction
    const resumeAudio = function() {
        SFX.resume();
        document.removeEventListener('click', resumeAudio);
        document.removeEventListener('keydown', resumeAudio);
        document.removeEventListener('touchstart', resumeAudio);
    };
    document.addEventListener('click', resumeAudio);
    document.addEventListener('keydown', resumeAudio);
    document.addEventListener('touchstart', resumeAudio);

    // Start the loop
    Engine.running = true;
    Engine.lastTime = performance.now();
    requestAnimationFrame(Engine.loop);
};

// =============================================================================
// CANVAS RESIZE
// =============================================================================

Engine.resize = function() {
    Engine.canvas.width = window.innerWidth;
    Engine.canvas.height = window.innerHeight;
    if (Camera.init) {
        Camera.viewW = Engine.canvas.width;
        Camera.viewH = Engine.canvas.height;
    }
};

// =============================================================================
// MAIN LOOP
// =============================================================================

Engine.loop = function(timestamp) {
    if (!Engine.running) return;

    // Delta time (capped at 50ms to prevent spiral of death)
    const rawDt = (timestamp - Engine.lastTime) / 1000;
    const dt = Math.min(rawDt, 0.05);
    Engine.lastTime = timestamp;
    G.dt = dt;
    G.time += dt;
    G.frameCount++;

    // FPS counter
    Engine.fpsTimer += dt;
    Engine.fpsCount++;
    if (Engine.fpsTimer >= 1.0) {
        Engine.currentFPS = Engine.fpsCount;
        Engine.fpsCount = 0;
        Engine.fpsTimer = 0;
    }

    // Update
    Engine.update(dt);

    // Render
    Engine.render();

    // Clear per-frame input state
    Input.update();

    // Next frame
    requestAnimationFrame(Engine.loop);
};

// =============================================================================
// UPDATE STATE MACHINE
// =============================================================================

Engine.update = function(dt) {
    switch (G.gameState) {
        case STATE.TITLE:
            TitleScreen.update(dt);
            // Check if title screen started a new game
            if (G.gameState === STATE.PLAYING && !G.player) {
                Engine.startNewGame();
            }
            break;

        case STATE.PLAYING:
            Engine.updatePlaying(dt);
            break;

        case STATE.PAUSED:
            Menus.update(dt);
            break;

        case STATE.INVENTORY:
            Menus.update(dt);
            break;

        case STATE.SKILL_TREE:
            Menus.update(dt);
            break;

        case STATE.CRAFTING:
            Menus.update(dt);
            break;

        case STATE.DIALOGUE:
            Dialogue.update(dt);
            break;

        case STATE.DEATH:
            Engine.updateDeath(dt);
            break;

        case STATE.GAME_OVER:
            Engine.updateGameOver(dt);
            break;

        case STATE.VICTORY:
            Engine.updateVictory(dt);
            break;

        case STATE.TRANSITION:
            Transitions.update(dt);
            break;

        case STATE.BOSS_INTRO:
            Transitions.update(dt);
            break;
    }
};

// =============================================================================
// PLAYING STATE UPDATE
// =============================================================================

Engine.updatePlaying = function(dt) {
    // Track play time
    G.totalPlayTime += dt;

    // Handle pause toggle
    if (Input.justPressed('Escape') || Input.justPressed('p') || Input.justPressed('P')) {
        Menus.togglePause();
        return;
    }

    // Handle inventory toggle
    if (Input.justPressed('i') || Input.justPressed('I')) {
        Menus.openInventory();
        return;
    }

    // Handle skill tree toggle
    if (Input.justPressed('k') || Input.justPressed('K')) {
        Menus.openSkillTree();
        return;
    }

    // Handle crafting (only at campfire)
    if (Input.justPressed('c') || Input.justPressed('C')) {
        if (Engine.isNearCampfire()) {
            Menus.openCrafting();
            return;
        }
    }

    // Handle minimap toggle
    if (Input.justPressed('Tab')) {
        Minimap.toggle();
    }

    // Handle ability hotkeys (1-4)
    if (window.AbilitySystem && AbilitySystem.cast && G.player.equippedAbilities) {
        for (let i = 0; i < 4; i++) {
            if (Input.justPressed(String(i + 1))) {
                const abilityId = G.player.equippedAbilities[i];
                if (abilityId) {
                    AbilitySystem.cast(abilityId, G.player);
                }
            }
        }
    }

    // Handle attack
    if ((Input.justPressed(' ') || Input.justPressed('Space') || (Input.mouse && Input.mouse.justDown)) && window.Player && Player.attack) {
        Player.attack();
    }

    // Handle dodge roll
    if ((Input.justPressed('Shift') || Input.justPressed('ShiftLeft') || Input.justPressed('ShiftRight')) && window.Player && Player.dodge) {
        Player.dodge();
    }

    // Handle interact / parry
    if (Input.justPressed('e') || Input.justPressed('E')) {
        if (!Engine.tryInteract() && window.Player && Player.parry) {
            Player.parry();
        }
    }

    // Update game systems
    if (window.Player && Player.update) {
        Player.update(dt);
    }

    // Update all enemies
    if (G.enemies) {
        for (let i = G.enemies.length - 1; i >= 0; i--) {
            const enemy = G.enemies[i];
            if (enemy.hp <= 0) {
                G.enemies.splice(i, 1);
                continue;
            }
            if (enemy.isBoss && window.BossAI && BossAI.update) {
                BossAI.update(enemy, dt);
            } else if (window.EnemyAI && EnemyAI.update) {
                EnemyAI.update(enemy, dt);
            }
        }
    }

    // Update combat (collision detection, projectiles, damage)
    if (window.Combat && Combat.update) {
        Combat.update(dt);
    }

    // Update ability system (cooldowns, active effects)
    if (window.AbilitySystem && AbilitySystem.update) {
        AbilitySystem.update(dt);
    }

    // Update inventory (ground item pickups)
    Inventory.pickupNearby();

    // Update progression
    Progression.calculateScore();

    // Update fog of war
    if (G.player && TileMap && TileMap.width > 0) {
        const ptx = Math.floor(G.player.x / TILE_SIZE);
        const pty = Math.floor(G.player.y / TILE_SIZE);
        const sightRadius = G.currentFloor >= 21 ? 6 : (G.player.hasTorch ? 10 : 8);
        if (window.Fog && Fog.update) {
            Fog.update(ptx, pty, sightRadius);
        }
    }

    // Update lighting
    if (window.Lighting && Lighting.update) {
        Lighting.update(dt);
        if (G.player) {
            // Player light follows player
            Lighting.playerLight = { x: G.player.x, y: G.player.y, radius: 96, color: '#fff8e0', intensity: 0.6, flicker: true };
        }
    }

    // Update camera
    if (G.player) {
        Camera.follow(G.player, dt);
    }
    Camera.update(dt);

    // Update particles
    FX.update(dt);

    // Update HUD
    HUD.update(dt);

    // Update floating texts
    for (let i = G.floatingTexts.length - 1; i >= 0; i--) {
        const ft = G.floatingTexts[i];
        ft.life -= dt;
        ft.y -= 40 * dt; // float upward
        if (ft.life <= 0) {
            G.floatingTexts.splice(i, 1);
        }
    }

    // Combo timer decay
    if (G.combo > 0) {
        G.comboTimer -= dt;
        if (G.comboTimer <= 0) {
            G.combo = 0;
            G.comboTimer = 0;
        }
    }

    // Campfire proximity effects
    if (Engine.isNearCampfire()) {
        // Slow HP regen at campfire
        if (G.player.hp < G.player.maxHp) {
            G.player.hp = Math.min(G.player.maxHp, G.player.hp + 5 * dt);
        }
    }
};

// =============================================================================
// DEATH / GAME OVER / VICTORY UPDATES
// =============================================================================

Engine.updateDeath = function(dt) {
    // Wait for input to restart or quit
    if (Input.justPressed('Enter') || Input.justPressed('Return')) {
        // Try to load campfire save
        const campfire = Save.loadCampfire();
        if (campfire) {
            Engine.restoreFromCampfire(campfire);
        } else {
            // Full restart - new run
            Engine.startNewGame();
        }
    }
    if (Input.justPressed('Escape')) {
        G.gameState = STATE.TITLE;
        TitleScreen.init();
    }
    FX.update(dt);
};

Engine.updateGameOver = function(dt) {
    if (Input.justPressed('Enter') || Input.justPressed('Return')) {
        // Save high score, restart
        Save.saveHighScore(G.score, G.currentFloor);
        Save.resetGame();
        G.gameState = STATE.TITLE;
        TitleScreen.init();
    }
    FX.update(dt);
};

Engine.updateVictory = function(dt) {
    if (Input.justPressed('Enter') || Input.justPressed('Return')) {
        Save.saveHighScore(G.score, G.currentFloor);
        Save.resetGame();
        G.gameState = STATE.TITLE;
        TitleScreen.init();
    }
    FX.update(dt);
};

// =============================================================================
// RENDER
// =============================================================================

Engine.render = function() {
    const ctx = Engine.ctx;
    const w = Engine.canvas.width;
    const h = Engine.canvas.height;

    // Clear canvas
    ctx.fillStyle = CANVAS_BG;
    ctx.fillRect(0, 0, w, h);

    switch (G.gameState) {
        case STATE.TITLE:
            TitleScreen.render(ctx);
            break;

        case STATE.PLAYING:
        case STATE.PAUSED:
        case STATE.INVENTORY:
        case STATE.SKILL_TREE:
        case STATE.CRAFTING:
        case STATE.DIALOGUE:
            Engine.renderGameWorld(ctx);

            // Overlay menus
            if (G.gameState === STATE.PAUSED) Menus.renderPause(ctx);
            if (G.gameState === STATE.INVENTORY) Menus.renderInventory(ctx);
            if (G.gameState === STATE.SKILL_TREE) Menus.renderSkillTree(ctx);
            if (G.gameState === STATE.CRAFTING) Menus.renderCrafting(ctx);
            if (G.gameState === STATE.DIALOGUE) Dialogue.render(ctx);
            break;

        case STATE.DEATH:
            Engine.renderGameWorld(ctx);
            HUD.renderDeathOverlay(ctx);
            break;

        case STATE.GAME_OVER:
            Engine.renderGameWorld(ctx);
            HUD.renderGameOver(ctx);
            break;

        case STATE.VICTORY:
            Engine.renderGameWorld(ctx);
            HUD.renderVictory(ctx, Engine.currentEnding);
            break;

        case STATE.TRANSITION:
        case STATE.BOSS_INTRO:
            Engine.renderGameWorld(ctx);
            Transitions.render(ctx);
            break;
    }

    // FPS counter (debug)
    const settings = Save.loadSettings();
    if (settings.showFPS) {
        ctx.fillStyle = 'rgba(0,255,0,0.7)';
        ctx.font = '12px monospace';
        ctx.textAlign = 'left';
        ctx.fillText('FPS: ' + Engine.currentFPS, 5, h - 5);
    }
};

// =============================================================================
// WORLD RENDERING
// =============================================================================

Engine.renderGameWorld = function(ctx) {
    if (!G.player || !TileMap.width) return;

    ctx.save();

    // Apply camera transform
    Camera.applyTransform(ctx);

    // Render tilemap (floor and walls)
    if (window.TileMap && TileMap.render) {
        TileMap.render(ctx, Camera);
    }

    // Render tile decorations
    if (window.TileMap && TileMap.renderDecor) {
        TileMap.renderDecor(ctx, Camera);
    }

    // Render ground items
    if (window.Inventory && Inventory.renderGroundItems) {
        Inventory.renderGroundItems(ctx, Camera);
    }

    // Render enemies
    if (window.EnemyAI && EnemyAI.renderAll) {
        EnemyAI.renderAll(ctx, Camera);
    }

    // Render boss (if active)
    if (G.bossActive && window.BossAI && BossAI.render) {
        BossAI.render(G.bossActive, ctx, Camera);
    }

    // Render player
    if (window.Player && Player.render) {
        Player.render(ctx, Camera);
    }

    // Render weapon swings
    if (window.Weapons && Weapons.renderSwing) {
        Weapons.renderSwing(ctx, G.player, Camera);
    }

    // Render projectiles
    if (window.Combat && Combat.renderProjectiles) {
        Combat.renderProjectiles(ctx, Camera);
    }

    // Render ability effects
    if (window.AbilitySystem && AbilitySystem.renderEffects) {
        AbilitySystem.renderEffects(ctx, Camera);
    }

    // Render particles (world-space)
    if (window.FX && FX.render) {
        FX.render(ctx, Camera);
    }

    // Render fog of war
    if (window.Fog && Fog.render) {
        Fog.render(ctx, Camera);
    }

    // Render lighting overlay
    if (window.Lighting && Lighting.render) {
        Lighting.render(ctx, Camera);
    }

    ctx.restore();

    // Screen-space UI (after camera reset)
    HUD.render(ctx);

    // Minimap
    if (Minimap.visible) {
        Minimap.render(ctx);
    }
};

// =============================================================================
// GAME START / FLOOR GENERATION
// =============================================================================

Engine.startNewGame = function() {
    // Initialize player
    if (window.Player && Player.init) {
        Player.init();
    }

    G.gameState = STATE.PLAYING;
    G.currentFloor = 1;
    G.seed = Date.now();
    G.enemies = [];
    G.projectiles = [];
    G.items = [];
    G.particles = [];
    G.floatingTexts = [];
    G.bossActive = null;
    G.combo = 0;
    G.comboTimer = 0;
    G.score = 0;
    G.kills = 0;
    G.time = 0;
    G.totalPlayTime = 0;
    G.storyChoices = [];
    G.flags = {};
    G.runStats = {
        damageDealt: 0, damageTaken: 0, itemsFound: 0,
        enemiesKilled: 0, bossesKilled: 0, floorsCleared: 0,
        parries: 0, dodges: 0, healsUsed: 0,
        skillsUnlocked: 0, deathCount: 0
    };

    // Give starting weapon
    if (window.generateWeapon && window.Inventory) {
        const starterSword = generateWeapon(1, 0);
        if (starterSword) {
            Inventory.addItem(starterSword);
            Inventory.equipItem(0);
        }
    }

    // Generate first floor
    Engine.generateFloor(1);

    // Start ambient audio
    if (window.getFloorTheme && window.SFX && SFX.playAmbient) {
        const theme = getFloorTheme(1);
        SFX.playAmbient(theme.name);
    }

    // Brief fade-in
    if (window.Transitions && Transitions.start) {
        Transitions.start('fadeIn', 1.0, null, {});
    }
};

Engine.generateFloor = function(floor) {
    G.currentFloor = floor;

    // Generate dungeon
    const mapW = Math.min(80 + Math.floor(floor / 5) * 5, 100);
    const mapH = Math.min(60 + Math.floor(floor / 5) * 4, 80);

    if (window.TileMap && TileMap.init) {
        TileMap.init(mapW, mapH);
    }

    if (window.Dungeon && Dungeon.generate) {
        Dungeon.generate(floor, G.seed + floor * 1000);
    }

    // Reset fog for new floor
    if (window.Fog && Fog.init) {
        Fog.init(mapW, mapH);
    }

    // Reset lighting
    if (window.Lighting && Lighting.init) {
        Lighting.init(mapW * TILE_SIZE, mapH * TILE_SIZE);
    }

    // Place torches on walls near rooms
    if (window.TileMap && TileMap.rooms && window.Lighting && Lighting.addLight) {
        for (const room of TileMap.rooms) {
            // Place torches at room entrances
            const cx = room.x + Math.floor(room.w / 2);
            const cy = room.y + Math.floor(room.h / 2);
            Lighting.addLight(cx * TILE_SIZE, cy * TILE_SIZE, 128, '#ffa040', 0.5, true);
        }
    }

    // Place campfire lights
    if (window.TileMap && TileMap.getTile && window.Lighting && Lighting.addLight) {
        for (let y = 0; y < mapH; y++) {
            for (let x = 0; x < mapW; x++) {
                if (TileMap.getTile(x, y) === 6) { // TILE_CAMPFIRE
                    Lighting.addLight(x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + TILE_SIZE / 2, 160, '#ff8020', 0.8, true);
                }
            }
        }
    }

    // Spawn enemies
    if (window.Dungeon && Dungeon.placeEnemies) {
        Dungeon.placeEnemies(floor, G.difficulty);
    }

    // Place player at stairs up / spawn point
    if (window.Dungeon && Dungeon.spawnPoint && G.player) {
        G.player.x = Dungeon.spawnPoint.x * TILE_SIZE + TILE_SIZE / 2;
        G.player.y = Dungeon.spawnPoint.y * TILE_SIZE + TILE_SIZE / 2;
    }

    // Clear projectiles and particles
    G.projectiles = [];
    G.items = [];
    if (window.FX && FX.init) {
        FX.init();
    }

    // Update ambient
    if (window.getFloorTheme && window.SFX && SFX.playAmbient) {
        const theme = getFloorTheme(floor);
        SFX.playAmbient(theme.name);
    }

    // Update deepest floor
    if (floor > G.deepestFloor) {
        G.deepestFloor = floor;
    }

    // Update run stats
    if (floor > 1) {
        G.runStats.floorsCleared++;
    }
};

Engine.descendStairs = function() {
    const nextFloor = G.currentFloor + 1;

    if (nextFloor > G.maxFloor) {
        // Victory! Determine ending
        Engine.triggerVictory();
        return;
    }

    // Check if next floor is a boss floor
    const isBossFloor = (nextFloor % 5 === 0);

    // Floor transition
    if (window.Transitions && Transitions.start) {
        Transitions.start('floorTransition', 2.0, function() {
            Engine.generateFloor(nextFloor);
        }, { floor: nextFloor, theme: window.getFloorTheme ? getFloorTheme(nextFloor).name : 'Unknown' });
    } else {
        Engine.generateFloor(nextFloor);
    }
};

// =============================================================================
// INTERACTION
// =============================================================================

Engine.tryInteract = function() {
    if (!G.player) return false;

    const ptx = Math.floor(G.player.x / TILE_SIZE);
    const pty = Math.floor(G.player.y / TILE_SIZE);

    // Check adjacent tiles for interactables
    const facingDir = G.player.facing || 0;
    const dirOffsets = [
        { dx: 0, dy: -1 }, // up
        { dx: 1, dy: 0 },  // right
        { dx: 0, dy: 1 },  // down
        { dx: -1, dy: 0 }  // left
    ];
    const offset = dirOffsets[facingDir] || { dx: 0, dy: 0 };

    const checkPositions = [
        { x: ptx, y: pty },
        { x: ptx + offset.dx, y: pty + offset.dy }
    ];

    if (window.TileMap && TileMap.getTile) {
        for (const pos of checkPositions) {
            const tile = TileMap.getTile(pos.x, pos.y);

            if (tile === 4) { // TILE_STAIRS_DOWN
                Engine.descendStairs();
                return true;
            }

            if (tile === 6) { // TILE_CAMPFIRE
                // Save at campfire
                G.player.hp = G.player.maxHp;
                G.player.mana = G.player.maxMana;
                G.player.stamina = G.player.maxStamina;
                if (window.Save) {
                    Save.saveCampfire();
                    Save.saveGame();
                }
                if (window.SFX && SFX.playSound) {
                    SFX.playSound('campfire_rest');
                }
                if (window.HUD && HUD.addFloatingText) {
                    HUD.addFloatingText(G.player.x, G.player.y - 20, 'Campfire Rest - Saved!', '#ffa040', 18);
                }
                return true;
            }

            if (tile === 7) { // TILE_CHEST
                TileMap.setTile(pos.x, pos.y, 1); // Change to floor
                if (window.SFX && SFX.playSound) {
                    SFX.playSound('chest_open');
                }
                if (window.Inventory && Inventory.spawnLoot) {
                    Inventory.spawnLoot(pos.x * TILE_SIZE + TILE_SIZE / 2, pos.y * TILE_SIZE + TILE_SIZE / 2, G.currentFloor, 0.5);
                }
                G.runStats.itemsFound++;
                return true;
            }

            if (tile === 10) { // TILE_BOSS_GATE
                // Check if all enemies on floor are dead (except boss)
                const nonBossEnemies = G.enemies.filter(e => !e.isBoss);
                if (nonBossEnemies.length === 0) {
                    TileMap.setTile(pos.x, pos.y, 1); // Open gate
                    if (window.SFX && SFX.playSound) {
                        SFX.playSound('door_open');
                    }

                    // Start boss intro if boss exists
                    if (G.bossActive && window.Transitions && Transitions.start) {
                        Transitions.start('bossIntro', 3.0, null, { boss: G.bossActive });
                    }
                    return true;
                } else {
                    if (window.HUD && HUD.addFloatingText) {
                        HUD.addFloatingText(G.player.x, G.player.y - 20, 'Defeat all enemies first!', '#ff4444', 14);
                    }
                    return true;
                }
            }
        }
    }

    // Check for NPC interaction
    if (G.npcs && window.NPC_DIALOGUES && window.Dialogue && Dialogue.start) {
        for (const npc of G.npcs) {
            const dist = Math.hypot(G.player.x - npc.x, G.player.y - npc.y);
            if (dist < TILE_SIZE * 2) {
                // Start dialogue
                if (NPC_DIALOGUES[npc.dialogueId]) {
                    Dialogue.start(NPC_DIALOGUES[npc.dialogueId]);
                    return true;
                }
            }
        }
    }

    return false;
};

Engine.isNearCampfire = function() {
    if (!G.player || !window.TileMap || !TileMap.getTile) return false;
    const ptx = Math.floor(G.player.x / TILE_SIZE);
    const pty = Math.floor(G.player.y / TILE_SIZE);

    for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
            if (TileMap.getTile(ptx + dx, pty + dy) === 6) return true;
        }
    }
    return false;
};

// =============================================================================
// CAMPFIRE RESTORE
// =============================================================================

Engine.restoreFromCampfire = function(campfireData) {
    G.currentFloor = campfireData.floor;
    G.gameState = STATE.PLAYING;

    // Re-init player with saved data
    if (window.Player && Player.init) {
        Player.init();
        G.player.hp = campfireData.playerHp || G.player.maxHp;
        G.player.maxHp = campfireData.playerMaxHp || G.player.maxHp;
        G.player.mana = campfireData.playerMana || G.player.maxMana;
        G.player.maxMana = campfireData.playerMaxMana || G.player.maxMana;
        G.player.level = campfireData.playerLevel || 1;
        G.player.xp = campfireData.playerXp || 0;
        G.player.inventory = campfireData.inventory || [];
        G.player.equipment = campfireData.equipment || {};
        G.player.gold = campfireData.gold || 0;
    }

    G.flags = campfireData.flags || {};
    G.storyChoices = campfireData.storyChoices || [];

    G.runStats.deathCount++;

    // Regenerate the floor
    Engine.generateFloor(G.currentFloor);

    if (window.Transitions && Transitions.start) {
        Transitions.start('fadeIn', 1.0, null, {});
    }
};

// =============================================================================
// VICTORY / ENDINGS
// =============================================================================

Engine.triggerVictory = function() {
    // Determine ending based on story choices
    Engine.currentEnding = Engine.determineEnding();

    if (window.Save && Save.saveHighScore) {
        Save.saveHighScore(G.score, G.currentFloor);
    }

    if (window.Transitions && Transitions.start) {
        Transitions.start('victoryTransition', 3.0, function() {
            G.gameState = STATE.VICTORY;
        }, { ending: Engine.currentEnding });
    } else {
        G.gameState = STATE.VICTORY;
    }
};

Engine.determineEnding = function() {
    const choices = G.storyChoices;

    // Check ENDINGS array for matching requirements
    if (typeof ENDINGS !== 'undefined') {
        for (const ending of ENDINGS) {
            if (ending.requirements && typeof ending.requirements === 'function') {
                if (ending.requirements(choices, G.flags)) {
                    return ending;
                }
            }
        }
    }

    // Default ending
    return {
        id: 'sealed_gate',
        name: 'The Sealed Gate',
        title: 'The Abyss is Sealed',
        description: 'You sealed the darkness below. The world above is safe once more.',
        epilogue: 'The hero emerged from the depths, forever changed. The gate was sealed, and peace returned to the land. But deep below, something still stirs...'
    };
};

// =============================================================================
// BOOT
// =============================================================================

// Start when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', Engine.init);
} else {
    Engine.init();
}

</script>
</body>
</html>
