<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Loom of the Void</title>
    <meta name="description" content="Weave gravitational threads across the cosmos to trap dark matter entities while birthing stars at thread intersections. A cosmic tower defense puzzle.">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #020208;
            min-height: 100vh;
            font-family: 'Georgia', serif;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            color: #8080c0;
        }
        canvas { display: block; }
        #hud {
            position: fixed; top: 0; left: 0; right: 0;
            padding: 10px 15px;
            display: none; justify-content: space-between; align-items: center;
            pointer-events: none; z-index: 100;
            background: linear-gradient(to bottom, rgba(2,2,12,0.8), transparent);
        }
        .hud-section { display: flex; flex-direction: column; gap: 3px; }
        .hud-label { font-size: 9px; color: rgba(130,130,200,0.6); text-transform: uppercase; letter-spacing: 1px; }
        .hud-value { font-size: 15px; color: #a0a0e0; font-weight: bold; }
        .bar-container { width: 110px; height: 7px; background: rgba(255,255,255,0.08); border-radius: 4px; overflow: hidden; }
        .bar-fill { height: 100%; border-radius: 4px; transition: width 0.3s; }
        .essence-bar { background: linear-gradient(to right, #6644cc, #aa88ff); }
        .void-bar { background: linear-gradient(to right, #cc4466, #ff6688); }
        .combo-display { font-size: 14px; color: #ffcc44; text-shadow: 0 0 8px rgba(255,200,0,0.4); }
        #toolbar {
            position: fixed; bottom: 12px; left: 50%; transform: translateX(-50%);
            display: none; gap: 8px; z-index: 100; pointer-events: auto;
        }
        .tool-btn {
            width: 54px; height: 54px; border-radius: 10px;
            border: 2px solid rgba(100,100,200,0.4);
            background: rgba(10,10,30,0.9); color: #a0a0d0; font-size: 9px;
            cursor: pointer; display: flex; flex-direction: column; align-items: center;
            justify-content: center; gap: 2px; transition: all 0.2s; position: relative;
        }
        .tool-btn:hover { border-color: #a0a0e0; background: rgba(30,20,60,0.9); transform: translateY(-2px); }
        .tool-btn.active { border-color: #ffcc44; box-shadow: 0 0 10px rgba(255,200,0,0.3); }
        .tool-btn.cooldown { opacity: 0.35; pointer-events: none; }
        .tool-icon { font-size: 18px; }
        .tool-key { font-size: 8px; opacity: 0.5; }
        .cd-overlay {
            position: absolute; bottom: 0; left: 0; right: 0;
            background: rgba(0,0,0,0.7); border-radius: 0 0 8px 8px;
            transition: height 0.1s;
        }
        #menu-screen {
            position: fixed; inset: 0; z-index: 200;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: radial-gradient(ellipse at 50% 40%, #0a0820, #020208);
        }
        #menu-screen h1 {
            font-size: 52px; color: #b0a0e0; margin-bottom: 8px;
            text-shadow: 0 0 30px rgba(140,100,255,0.5);
            animation: cosmicPulse 4s ease-in-out infinite;
        }
        @keyframes cosmicPulse {
            0%, 100% { text-shadow: 0 0 20px rgba(140,100,255,0.3); }
            50% { text-shadow: 0 0 50px rgba(140,100,255,0.6), 0 0 80px rgba(100,60,200,0.2); }
        }
        .subtitle { color: rgba(150,140,200,0.5); font-style: italic; margin-bottom: 35px; font-size: 15px; }
        .menu-btn {
            width: 220px; padding: 13px; margin: 5px;
            background: rgba(30,20,60,0.6); border: 1px solid rgba(120,100,200,0.3);
            color: #a0a0d0; font-size: 15px; font-family: inherit; cursor: pointer;
            border-radius: 8px; transition: all 0.3s;
        }
        .menu-btn:hover { background: rgba(50,30,100,0.8); border-color: #a0a0e0; transform: scale(1.04); }
        .diff-label { font-size: 10px; opacity: 0.5; display: block; margin-top: 3px; }
        .high-scores { margin-top: 25px; text-align: center; }
        .high-scores h3 { color: rgba(150,140,200,0.4); font-size: 12px; margin-bottom: 6px; }
        .high-scores p { color: rgba(150,140,200,0.3); font-size: 11px; }
        #pause-overlay {
            position: fixed; inset: 0; z-index: 200;
            display: none; flex-direction: column; align-items: center; justify-content: center;
            background: rgba(2,2,12,0.85);
        }
        #pause-overlay h2 { color: #a0a0e0; font-size: 36px; margin-bottom: 25px; }
        #gameover-screen {
            position: fixed; inset: 0; z-index: 200;
            display: none; flex-direction: column; align-items: center; justify-content: center;
            background: rgba(2,2,12,0.9);
        }
        #gameover-screen h2 { font-size: 40px; margin-bottom: 8px; }
        .stat-row { color: rgba(150,140,200,0.6); font-size: 13px; margin: 3px 0; }
        .ending-text { color: #ffcc44; font-size: 17px; margin: 12px 0; font-style: italic; max-width: 380px; text-align: center; }
    </style>
</head>
<body>
    <canvas id="c"></canvas>

    <div id="hud">
        <div class="hud-section">
            <span class="hud-label">Epoch</span>
            <span class="hud-value" id="epoch-val">1</span>
        </div>
        <div class="hud-section">
            <span class="hud-label">Essence</span>
            <div class="bar-container"><div class="bar-fill essence-bar" id="essence-bar" style="width:100%"></div></div>
        </div>
        <div class="hud-section">
            <span class="hud-label">Void Pressure</span>
            <div class="bar-container"><div class="bar-fill void-bar" id="void-bar" style="width:0%"></div></div>
        </div>
        <div class="hud-section">
            <span class="hud-label">Score</span>
            <span class="hud-value" id="score-val">0</span>
        </div>
        <div class="hud-section">
            <span class="combo-display" id="combo-val"></span>
        </div>
        <div class="hud-section">
            <span class="hud-label">Stars</span>
            <span class="hud-value" id="stars-val">0</span>
        </div>
    </div>

    <div id="toolbar">
        <button class="tool-btn" id="tool-weave" onclick="setTool('weave')">
            <span class="tool-icon">&#10033;</span><span>Weave</span><span class="tool-key">1</span>
            <div class="cd-overlay" style="height:0"></div>
        </button>
        <button class="tool-btn" id="tool-pluck" onclick="useTool('pluck')">
            <span class="tool-icon">&#127926;</span><span>Pluck</span><span class="tool-key">2</span>
            <div class="cd-overlay" style="height:0"></div>
        </button>
        <button class="tool-btn" id="tool-nova" onclick="useTool('nova')">
            <span class="tool-icon">&#9733;</span><span>Nova</span><span class="tool-key">3</span>
            <div class="cd-overlay" style="height:0"></div>
        </button>
        <button class="tool-btn" id="tool-anchor" onclick="useTool('anchor')">
            <span class="tool-icon">&#9875;</span><span>Anchor</span><span class="tool-key">4</span>
            <div class="cd-overlay" style="height:0"></div>
        </button>
    </div>

    <div id="menu-screen">
        <h1>Loom of the Void</h1>
        <p class="subtitle">Weave threads of gravity to trap the darkness</p>
        <button class="menu-btn" onclick="startGame('easy')">Starweaver<span class="diff-label">Slow void expansion, weak entities</span></button>
        <button class="menu-btn" onclick="startGame('normal')">Cosmic Loom<span class="diff-label">Standard difficulty</span></button>
        <button class="menu-btn" onclick="startGame('hard')">Entropy Storm<span class="diff-label">Rapid void, relentless dark matter</span></button>
        <div class="high-scores" id="high-scores"></div>
    </div>

    <div id="pause-overlay">
        <h2>Paused</h2>
        <button class="menu-btn" onclick="resumeGame()">Resume</button>
        <button class="menu-btn" onclick="quitToMenu()">Quit to Menu</button>
    </div>

    <div id="gameover-screen">
        <h2 id="go-title" style="color:#a0a0e0;">The Void Consumes</h2>
        <p class="ending-text" id="go-ending"></p>
        <div id="go-stats"></div>
        <button class="menu-btn" style="margin-top:18px;" onclick="startGame(G.difficulty)">Try Again (R)</button>
        <button class="menu-btn" onclick="quitToMenu()">Menu</button>
    </div>

    <script>
    // ========== AUDIO ==========
    const AC = window.AudioContext || window.webkitAudioContext;
    let ac = null;
    function initAudio() { if (!ac) ac = new AC(); }
    function snd(type, freq, dur, vol) {
        if (!ac) return;
        const o = ac.createOscillator(), g = ac.createGain();
        o.connect(g); g.connect(ac.destination);
        o.type = type; o.frequency.setValueAtTime(freq, ac.currentTime);
        g.gain.setValueAtTime(vol || 0.12, ac.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, ac.currentTime + dur);
        o.start(); o.stop(ac.currentTime + dur);
    }
    function sfxWeave() { snd('sine', 400, 0.15, 0.08); snd('triangle', 600, 0.1, 0.06); }
    function sfxStar() { snd('sine', 800, 0.2, 0.1); setTimeout(() => snd('sine', 1000, 0.15, 0.08), 60); setTimeout(() => snd('sine', 1200, 0.12, 0.06), 120); }
    function sfxTrap() { snd('triangle', 500, 0.15, 0.1); snd('sine', 700, 0.1, 0.08); }
    function sfxHit() { snd('sawtooth', 100, 0.2, 0.12); snd('square', 60, 0.15, 0.1); }
    function sfxPluck() { snd('sine', 300, 0.3, 0.1); snd('triangle', 500, 0.2, 0.08); snd('sine', 700, 0.15, 0.06); }
    function sfxNova() { snd('sawtooth', 200, 0.5, 0.15); snd('sine', 400, 0.4, 0.1); snd('sine', 800, 0.3, 0.08); }
    function sfxBoss() { snd('sawtooth', 40, 0.6, 0.18); snd('square', 55, 0.5, 0.14); }
    function sfxMenu() { snd('sine', 440, 0.1, 0.06); }
    function sfxWin() { [440,554,659,880].forEach((f,i) => setTimeout(() => snd('sine', f, 0.35, 0.1), i*100)); }
    function sfxAnchor() { snd('triangle', 350, 0.25, 0.09); snd('sine', 500, 0.3, 0.07); }
    function sfxBreak() { snd('square', 80, 0.15, 0.1); snd('sawtooth', 50, 0.2, 0.08); }

    // ========== CANVAS ==========
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    let W, H;
    function resize() { W = canvas.width = innerWidth; H = canvas.height = innerHeight; }
    resize(); window.addEventListener('resize', resize);

    // ========== GAME STATE ==========
    const G = {
        state: 'menu',
        difficulty: 'normal',
        score: 0, combo: 0, comboTimer: 0, maxCombo: 0,
        essence: 100, maxEssence: 100,
        voidPressure: 0, maxVoid: 100,
        epoch: 1, starsCreated: 0,
        entitiesKilled: 0, bossesDefeated: 0,
        threadsWoven: 0,
        threads: [], stars: [], entities: [], particles: [], floatingTexts: [],
        dust: [],
        shakeX: 0, shakeY: 0, shakeMag: 0,
        time: 0, lastTime: 0,
        currentTool: 'weave',
        drawingThread: null,
        anchoredThreads: [],
        waveTimer: 0, waveInterval: 12,
        waveNumber: 0,
        tools: {
            weave: { cooldown: 0, maxCooldown: 0.3 },
            pluck: { cooldown: 0, maxCooldown: 8 },
            nova:  { cooldown: 0, maxCooldown: 15 },
            anchor:{ cooldown: 0, maxCooldown: 10 }
        },
        diffSettings: {
            easy:   { voidRate: 0.03, spawnRate: 0.8, entitySpeed: 0.7, bossHP: 30, essenceRegen: 0.15 },
            normal: { voidRate: 0.06, spawnRate: 1.0, entitySpeed: 1.0, bossHP: 50, essenceRegen: 0.08 },
            hard:   { voidRate: 0.12, spawnRate: 1.4, entitySpeed: 1.4, bossHP: 80, essenceRegen: 0.03 }
        },
        settings: null,
        bgStars: []
    };

    // Background stars (static)
    function initBgStars() {
        G.bgStars = [];
        for (let i = 0; i < 200; i++) {
            G.bgStars.push({
                x: Math.random() * 2000, y: Math.random() * 2000,
                size: Math.random() * 1.5, brightness: 0.2 + Math.random() * 0.5,
                twinkleSpeed: 0.5 + Math.random() * 2
            });
        }
    }
    initBgStars();

    // ========== INPUT ==========
    const keys = {};
    let mouseX = 0, mouseY = 0, mouseDown = false;
    document.addEventListener('keydown', e => {
        keys[e.key.toLowerCase()] = true;
        if (e.key === 'Escape') {
            if (G.state === 'playing') pauseGame();
            else if (G.state === 'paused') resumeGame();
            e.preventDefault();
        }
        if (e.key === 'r' && G.state === 'gameover') startGame(G.difficulty);
        if (G.state === 'playing') {
            if (e.key === '1') setTool('weave');
            if (e.key === '2') useTool('pluck');
            if (e.key === '3') useTool('nova');
            if (e.key === '4') useTool('anchor');
        }
    });
    document.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

    canvas.addEventListener('mousemove', e => { mouseX = e.clientX; mouseY = e.clientY; if (G.drawingThread) G.drawingThread.x2 = mouseX; if (G.drawingThread) G.drawingThread.y2 = mouseY; });
    canvas.addEventListener('mousedown', e => {
        mouseDown = true; initAudio();
        if (G.state === 'playing' && G.currentTool === 'weave') startWeaving(e.clientX, e.clientY);
    });
    canvas.addEventListener('mouseup', e => {
        mouseDown = false;
        if (G.drawingThread) finishWeaving(e.clientX, e.clientY);
    });
    canvas.addEventListener('touchstart', e => {
        e.preventDefault(); initAudio();
        const t = e.touches[0]; mouseX = t.clientX; mouseY = t.clientY; mouseDown = true;
        if (G.state === 'playing' && G.currentTool === 'weave') startWeaving(t.clientX, t.clientY);
    }, { passive: false });
    canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        const t = e.touches[0]; mouseX = t.clientX; mouseY = t.clientY;
        if (G.drawingThread) { G.drawingThread.x2 = mouseX; G.drawingThread.y2 = mouseY; }
    }, { passive: false });
    canvas.addEventListener('touchend', e => {
        e.preventDefault(); mouseDown = false;
        if (G.drawingThread) finishWeaving(mouseX, mouseY);
    }, { passive: false });

    // ========== THREAD CLASS ==========
    class Thread {
        constructor(x1, y1) {
            this.x1 = x1; this.y1 = y1;
            this.x2 = x1; this.y2 = y1;
            this.age = 0;
            this.hue = 240 + Math.random() * 80;
            this.tension = 0.5 + Math.random() * 0.5;
            this.vibration = 0;
            this.hp = 3;
            this.maxHp = 3;
            this.anchored = false;
            this.fadeOut = 0;
        }
        length() { return Math.hypot(this.x2 - this.x1, this.y2 - this.y1); }
        midX() { return (this.x1 + this.x2) / 2; }
        midY() { return (this.y1 + this.y2) / 2; }
        update(dt) {
            this.age += dt;
            this.vibration *= 0.94;
            if (!this.anchored) {
                this.hp -= dt * 0.05 * (1 + G.epoch * 0.02);
                if (this.hp <= 0) { this.fadeOut = 1; }
            }
            if (this.fadeOut > 0) this.fadeOut -= dt * 2;
        }
        pluck() { this.vibration = 1; sfxPluck(); }
        draw() {
            const len = this.length();
            if (len < 10) return;
            const mx = this.midX(), my = this.midY();
            const wave = Math.sin(G.time * 3 + this.age) * this.vibration * 25;
            const perpX = -(this.y2 - this.y1) / len;
            const perpY = (this.x2 - this.x1) / len;
            const alpha = this.fadeOut > 0 ? this.fadeOut : Math.min(1, this.age * 2);

            // Glow
            ctx.beginPath();
            ctx.moveTo(this.x1, this.y1);
            ctx.quadraticCurveTo(mx + perpX * wave, my + perpY * wave, this.x2, this.y2);
            ctx.strokeStyle = 'hsla(' + this.hue + ', 100%, 75%, ' + (alpha * 0.15) + ')';
            ctx.lineWidth = 10 + this.vibration * 8;
            ctx.stroke();

            // Core
            const grad = ctx.createLinearGradient(this.x1, this.y1, this.x2, this.y2);
            grad.addColorStop(0, 'hsla(' + this.hue + ', 80%, 60%, ' + (alpha * 0.2) + ')');
            grad.addColorStop(0.5, 'hsla(' + (this.hue + 20) + ', 90%, 70%, ' + (alpha * 0.9) + ')');
            grad.addColorStop(1, 'hsla(' + this.hue + ', 80%, 60%, ' + (alpha * 0.2) + ')');
            ctx.beginPath();
            ctx.moveTo(this.x1, this.y1);
            ctx.quadraticCurveTo(mx + perpX * wave, my + perpY * wave, this.x2, this.y2);
            ctx.strokeStyle = grad;
            ctx.lineWidth = 2 + this.tension * 2;
            ctx.stroke();

            // Anchor indicator
            if (this.anchored) {
                ctx.fillStyle = 'rgba(100,255,200,0.3)';
                ctx.beginPath(); ctx.arc(this.x1, this.y1, 5, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(this.x2, this.y2, 5, 0, Math.PI * 2); ctx.fill();
            }

            // HP indicator
            if (this.hp < this.maxHp && !this.anchored) {
                const barX = mx - 15, barY = my - 8;
                ctx.fillStyle = 'rgba(0,0,0,0.4)';
                ctx.fillRect(barX, barY, 30, 3);
                ctx.fillStyle = this.hp > 1 ? '#6688ff' : '#ff4466';
                ctx.fillRect(barX, barY, 30 * (this.hp / this.maxHp), 3);
            }
        }
    }

    // ========== STAR CLASS ==========
    class Star {
        constructor(x, y, threadCount) {
            this.x = x; this.y = y;
            this.size = 4 + threadCount * 3;
            this.type = threadCount >= 3 ? 'supergiant' : threadCount >= 2 ? 'star' : 'dwarf';
            this.hue = this.type === 'supergiant' ? 30 : this.type === 'star' ? 50 : 200;
            this.age = 0;
            this.pulse = Math.random() * Math.PI * 2;
            this.damageAura = this.type === 'supergiant' ? 80 : this.type === 'star' ? 50 : 25;
            this.dps = this.type === 'supergiant' ? 3 : this.type === 'star' ? 2 : 1;
        }
        update(dt) {
            this.age += dt;
            this.pulse += dt * 2;
        }
        draw() {
            const p = 1 + Math.sin(this.pulse) * 0.12;
            const sz = this.size * p;

            // Aura
            const auraGrad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.damageAura);
            auraGrad.addColorStop(0, 'hsla(' + this.hue + ', 100%, 90%, 0.08)');
            auraGrad.addColorStop(0.5, 'hsla(' + this.hue + ', 80%, 70%, 0.03)');
            auraGrad.addColorStop(1, 'transparent');
            ctx.fillStyle = auraGrad;
            ctx.fillRect(this.x - this.damageAura, this.y - this.damageAura, this.damageAura * 2, this.damageAura * 2);

            // Glow
            const glowGrad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, sz * 3);
            glowGrad.addColorStop(0, 'hsla(' + this.hue + ', 100%, 95%, 1)');
            glowGrad.addColorStop(0.3, 'hsla(' + this.hue + ', 90%, 75%, 0.5)');
            glowGrad.addColorStop(1, 'transparent');
            ctx.fillStyle = glowGrad;
            ctx.fillRect(this.x - sz * 3, this.y - sz * 3, sz * 6, sz * 6);

            // Core
            ctx.fillStyle = 'hsl(' + this.hue + ', 100%, 90%)';
            ctx.beginPath();
            ctx.arc(this.x, this.y, sz, 0, Math.PI * 2);
            ctx.fill();

            // Cross-rays for larger stars
            if (this.type !== 'dwarf') {
                ctx.strokeStyle = 'hsla(' + this.hue + ', 100%, 85%, 0.3)';
                ctx.lineWidth = 1;
                const rayLen = sz * (this.type === 'supergiant' ? 4 : 2.5);
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2 + G.time * 0.3;
                    ctx.beginPath();
                    ctx.moveTo(this.x - Math.cos(angle) * rayLen, this.y - Math.sin(angle) * rayLen);
                    ctx.lineTo(this.x + Math.cos(angle) * rayLen, this.y + Math.sin(angle) * rayLen);
                    ctx.stroke();
                }
            }
        }
    }

    // ========== ENTITY TYPES ==========
    const ENTITY_TYPES = [
        { name: 'Wisp',    color: '#cc44aa', speed: 1.0, hp: 2,  size: 8,  behavior: 'drift',  damage: 3,  voidAdd: 2 },
        { name: 'Shade',   color: '#6644cc', speed: 0.7, hp: 4,  size: 12, behavior: 'phase',  damage: 5,  voidAdd: 3 },
        { name: 'Devourer',color: '#cc6644', speed: 1.3, hp: 2,  size: 10, behavior: 'seek',   damage: 4,  voidAdd: 4 },
        { name: 'Entropy', color: '#44ccaa', speed: 0.5, hp: 6,  size: 15, behavior: 'erode',  damage: 2,  voidAdd: 5 },
        { name: 'Phantom', color: '#aaaaff', speed: 1.5, hp: 1,  size: 7,  behavior: 'teleport', damage: 6, voidAdd: 2 },
        { name: 'Rift',    color: '#ff4488', speed: 0.3, hp: 8,  size: 20, behavior: 'expand', damage: 8,  voidAdd: 8 }
    ];

    function spawnEntity(isBoss) {
        const typeIdx = Math.floor(Math.random() * ENTITY_TYPES.length);
        const type = ENTITY_TYPES[typeIdx];
        const speedMul = G.settings.entitySpeed * (1 + G.epoch * 0.03);

        // Spawn from edges
        const side = Math.floor(Math.random() * 4);
        let x, y;
        if (side === 0) { x = Math.random() * W; y = -20; }
        else if (side === 1) { x = Math.random() * W; y = H + 20; }
        else if (side === 2) { x = -20; y = Math.random() * H; }
        else { x = W + 20; y = Math.random() * H; }

        // Target: move toward center or a star
        let tx = W / 2 + (Math.random() - 0.5) * W * 0.6;
        let ty = H / 2 + (Math.random() - 0.5) * H * 0.6;

        G.entities.push({
            x, y, vx: 0, vy: 0,
            tx, ty,
            type: type.name, color: isBoss ? '#ff2244' : type.color,
            speed: isBoss ? type.speed * speedMul * 0.6 : type.speed * speedMul,
            hp: isBoss ? G.settings.bossHP : type.hp * (1 + Math.floor(G.epoch / 4)),
            maxHp: isBoss ? G.settings.bossHP : type.hp * (1 + Math.floor(G.epoch / 4)),
            size: isBoss ? 35 : type.size,
            behavior: isBoss ? 'boss' : type.behavior,
            damage: isBoss ? 12 : type.damage,
            voidAdd: isBoss ? 15 : type.voidAdd,
            isBoss,
            phase: Math.random() * Math.PI * 2,
            flash: 0,
            teleportTimer: 2 + Math.random() * 3,
            expandSize: 0,
            trapped: false, trapTimer: 0
        });

        if (isBoss) sfxBoss();
    }

    // ========== THREAD WEAVING ==========
    function startWeaving(x, y) {
        if (G.essence < 5) return;
        G.drawingThread = new Thread(x, y);
    }

    function finishWeaving(x, y) {
        if (!G.drawingThread) return;
        G.drawingThread.x2 = x;
        G.drawingThread.y2 = y;

        const len = G.drawingThread.length();
        if (len > 30 && len < 500) {
            const cost = Math.floor(len / 30);
            if (G.essence >= cost) {
                G.essence -= cost;
                G.threads.push(G.drawingThread);
                G.threadsWoven++;
                sfxWeave();

                // Check intersections for star birth
                checkIntersections(G.drawingThread);

                // Check if any entities are trapped
                checkTraps();
            }
        }
        G.drawingThread = null;
    }

    function checkIntersections(newThread) {
        for (let i = 0; i < G.threads.length - 1; i++) {
            const t = G.threads[i];
            if (t === newThread || t.fadeOut > 0) continue;
            const inter = lineIntersect(
                newThread.x1, newThread.y1, newThread.x2, newThread.y2,
                t.x1, t.y1, t.x2, t.y2
            );
            if (inter) {
                // Check if a star already exists nearby
                const existing = G.stars.find(s => Math.hypot(s.x - inter.x, s.y - inter.y) < 40);
                if (!existing) {
                    // Count nearby threads for star size
                    let threadCount = 2;
                    G.threads.forEach(th => {
                        if (th !== newThread && th !== t && th.fadeOut <= 0) {
                            const dist = pointToLine(inter.x, inter.y, th.x1, th.y1, th.x2, th.y2);
                            if (dist < 30) threadCount++;
                        }
                    });
                    const star = new Star(inter.x, inter.y, threadCount);
                    G.stars.push(star);
                    G.starsCreated++;
                    G.combo++;
                    G.comboTimer = 4;
                    if (G.combo > G.maxCombo) G.maxCombo = G.combo;
                    const pts = 50 * Math.max(1, G.combo) * threadCount;
                    G.score += pts;
                    sfxStar();
                    addFloat(inter.x, inter.y - 15, '+' + pts + ' STAR!' + (G.combo > 1 ? ' x' + G.combo : ''), '#ffcc44', 1.5);
                    spawnStarParticles(inter.x, inter.y, star.hue);
                    document.getElementById('stars-val').textContent = G.starsCreated;
                }
            }
        }
    }

    function checkTraps() {
        // An entity is trapped if it's inside a polygon formed by 3+ threads
        G.entities.forEach(e => {
            if (e.trapped) return;
            let nearbyThreads = G.threads.filter(t => t.fadeOut <= 0 && pointToLine(e.x, e.y, t.x1, t.y1, t.x2, t.y2) < e.size + 20);
            if (nearbyThreads.length >= 3) {
                e.trapped = true;
                e.trapTimer = 3;
                e.speed *= 0.2;
                sfxTrap();
                addFloat(e.x, e.y - 15, 'TRAPPED!', '#44ffaa', 1);
                G.score += 30;
            }
        });
    }

    function lineIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
        const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
        if (Math.abs(denom) < 0.001) return null;
        const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
        const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;
        if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
            return { x: x1 + t * (x2 - x1), y: y1 + t * (y2 - y1) };
        }
        return null;
    }

    function pointToLine(px, py, x1, y1, x2, y2) {
        const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
        const dot = A * C + B * D, lenSq = C * C + D * D;
        let param = lenSq !== 0 ? dot / lenSq : -1;
        let xx, yy;
        if (param < 0) { xx = x1; yy = y1; }
        else if (param > 1) { xx = x2; yy = y2; }
        else { xx = x1 + param * C; yy = y1 + param * D; }
        return Math.hypot(px - xx, py - yy);
    }

    // ========== TOOLS ==========
    function setTool(name) {
        G.currentTool = name;
        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
        document.getElementById('tool-' + name).classList.add('active');
    }

    function useTool(name) {
        if (G.state !== 'playing') return;
        const tool = G.tools[name];
        if (tool.cooldown > 0) return;
        initAudio();

        if (name === 'pluck') {
            // Pluck all threads — damages nearby entities, restores some essence
            G.threads.forEach(t => { if (t.fadeOut <= 0) t.pluck(); });
            let hit = 0;
            G.entities.forEach(e => {
                G.threads.forEach(t => {
                    if (t.fadeOut <= 0) {
                        const dist = pointToLine(e.x, e.y, t.x1, t.y1, t.x2, t.y2);
                        if (dist < 40) {
                            e.hp -= 2;
                            e.flash = 1;
                            hit++;
                        }
                    }
                });
            });
            G.essence = Math.min(G.maxEssence, G.essence + hit * 3);
            tool.cooldown = tool.maxCooldown;
            G.shakeMag = 5;
            addFloat(W / 2, H / 2, 'PLUCK x' + hit, '#aa88ff', 1);
        }
        else if (name === 'nova') {
            // Supernova: sacrifice nearest star to damage all entities nearby
            if (G.stars.length === 0) { addFloat(W / 2, H / 2, 'No stars!', '#ff6644', 1); return; }
            // Find star closest to mouse
            let closest = null, closestDist = Infinity;
            G.stars.forEach(s => {
                const d = Math.hypot(s.x - mouseX, s.y - mouseY);
                if (d < closestDist) { closestDist = d; closest = s; }
            });
            if (closest) {
                // Explode the star
                const range = closest.damageAura * 3;
                const dmg = closest.type === 'supergiant' ? 20 : closest.type === 'star' ? 12 : 6;
                let killed = 0;
                G.entities.forEach(e => {
                    const d = Math.hypot(e.x - closest.x, e.y - closest.y);
                    if (d < range) {
                        e.hp -= dmg;
                        e.flash = 1;
                        if (e.hp <= 0) killed++;
                    }
                });
                G.stars = G.stars.filter(s => s !== closest);
                G.score += killed * 40;
                G.entitiesKilled += killed;
                sfxNova();
                G.shakeMag = 15;
                // Nova explosion particles
                for (let i = 0; i < 50; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 2 + Math.random() * 6;
                    G.particles.push({
                        x: closest.x, y: closest.y,
                        vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
                        life: 1.5, maxLife: 1.5,
                        size: 2 + Math.random() * 4,
                        color: 'hsl(' + closest.hue + ', 100%, ' + (60 + Math.random() * 30) + '%)'
                    });
                }
                addFloat(closest.x, closest.y, 'NOVA! -' + killed + ' entities', '#ffaa44', 2);
                tool.cooldown = tool.maxCooldown;
            }
        }
        else if (name === 'anchor') {
            // Make all current threads permanent (no decay)
            let anchored = 0;
            G.threads.forEach(t => {
                if (!t.anchored && t.fadeOut <= 0) {
                    t.anchored = true;
                    t.hp = t.maxHp;
                    anchored++;
                }
            });
            tool.cooldown = tool.maxCooldown;
            sfxAnchor();
            addFloat(W / 2, H / 2, 'ANCHORED x' + anchored, '#44ffaa', 1.5);
        }
        updateToolUI();
    }

    function updateToolUI() {
        ['weave', 'pluck', 'nova', 'anchor'].forEach(name => {
            const btn = document.getElementById('tool-' + name);
            const tool = G.tools[name];
            const overlay = btn.querySelector('.cd-overlay');
            if (tool.cooldown > 0) {
                btn.classList.add('cooldown');
                overlay.style.height = (tool.cooldown / tool.maxCooldown * 100) + '%';
            } else {
                btn.classList.remove('cooldown');
                overlay.style.height = '0';
            }
        });
    }

    // ========== PARTICLES & EFFECTS ==========
    function spawnStarParticles(x, y, hue) {
        for (let i = 0; i < 20; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 1 + Math.random() * 3;
            G.particles.push({
                x, y,
                vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
                life: 1, maxLife: 1,
                size: 1 + Math.random() * 3,
                color: 'hsl(' + hue + ', 100%, ' + (60 + Math.random() * 30) + '%)'
            });
        }
    }

    function spawnDeathParticles(x, y, color) {
        for (let i = 0; i < 10; i++) {
            const angle = Math.random() * Math.PI * 2;
            G.particles.push({
                x, y,
                vx: Math.cos(angle) * (1 + Math.random() * 3),
                vy: Math.sin(angle) * (1 + Math.random() * 3),
                life: 0.8, maxLife: 0.8,
                size: 2 + Math.random() * 2,
                color
            });
        }
    }

    function addFloat(x, y, text, color, dur) {
        G.floatingTexts.push({ x, y, text, color, life: dur, maxLife: dur });
    }

    // ========== GAME FLOW ==========
    function startGame(diff) {
        initAudio(); sfxMenu();
        G.difficulty = diff;
        G.settings = G.diffSettings[diff];
        G.state = 'playing';
        G.score = 0; G.combo = 0; G.comboTimer = 0; G.maxCombo = 0;
        G.essence = 100; G.voidPressure = 0;
        G.epoch = 1; G.starsCreated = 0; G.entitiesKilled = 0; G.bossesDefeated = 0; G.threadsWoven = 0;
        G.threads = []; G.stars = []; G.entities = []; G.particles = []; G.floatingTexts = [];
        G.shakeMag = 0; G.time = 0;
        G.drawingThread = null;
        G.waveTimer = 5; G.waveNumber = 0;
        G.currentTool = 'weave';
        Object.values(G.tools).forEach(t => t.cooldown = 0);

        // Init dust
        G.dust = [];
        for (let i = 0; i < 60; i++) {
            G.dust.push({
                x: Math.random() * W, y: Math.random() * H,
                vx: (Math.random() - 0.5) * 0.3, vy: (Math.random() - 0.5) * 0.3,
                size: 0.5 + Math.random() * 1.5
            });
        }

        document.getElementById('menu-screen').style.display = 'none';
        document.getElementById('gameover-screen').style.display = 'none';
        document.getElementById('pause-overlay').style.display = 'none';
        document.getElementById('hud').style.display = 'flex';
        document.getElementById('toolbar').style.display = 'flex';
        setTool('weave');
        updateToolUI();
    }

    function pauseGame() { G.state = 'paused'; document.getElementById('pause-overlay').style.display = 'flex'; sfxMenu(); }
    function resumeGame() { G.state = 'playing'; document.getElementById('pause-overlay').style.display = 'none'; G.lastTime = performance.now(); sfxMenu(); }
    function quitToMenu() {
        G.state = 'menu';
        document.getElementById('menu-screen').style.display = 'flex';
        document.getElementById('pause-overlay').style.display = 'none';
        document.getElementById('gameover-screen').style.display = 'none';
        document.getElementById('hud').style.display = 'none';
        document.getElementById('toolbar').style.display = 'none';
        displayHighScores();
    }

    function gameOver(ending) {
        G.state = 'gameover';
        document.getElementById('gameover-screen').style.display = 'flex';
        document.getElementById('toolbar').style.display = 'none';

        const endings = {
            void: { title: 'The Void Consumes', text: 'The darkness overwhelmed the cosmic loom. Your threads dissolved into entropy, and the stars you birthed flickered out one by one.' },
            master: { title: 'Master Weaver', text: 'You wove a tapestry of light across 10 epochs. The void itself recoiled from the brilliance of your cosmic design.' },
            starforger: { title: 'Starforger', text: 'Your supernovae lit the darkness ablaze. The void entities fled from the overwhelming radiance of your stellar arsenal.' }
        };

        const e = endings[ending] || endings.void;
        document.getElementById('go-title').textContent = e.title;
        document.getElementById('go-title').style.color = ending === 'void' ? '#cc4466' : '#44ffaa';
        document.getElementById('go-ending').textContent = e.text;

        let html = '';
        html += '<p class="stat-row">Score: ' + G.score + '</p>';
        html += '<p class="stat-row">Epoch reached: ' + G.epoch + '</p>';
        html += '<p class="stat-row">Stars created: ' + G.starsCreated + '</p>';
        html += '<p class="stat-row">Threads woven: ' + G.threadsWoven + '</p>';
        html += '<p class="stat-row">Entities destroyed: ' + G.entitiesKilled + '</p>';
        html += '<p class="stat-row">Max combo: ' + G.maxCombo + 'x</p>';
        html += '<p class="stat-row">Bosses defeated: ' + G.bossesDefeated + '</p>';
        html += '<p class="stat-row">Difficulty: ' + G.difficulty + '</p>';
        document.getElementById('go-stats').innerHTML = html;

        saveHighScore(G.score, G.epoch, ending);
    }

    // ========== LOCALSTORAGE ==========
    function saveHighScore(score, epoch, ending) {
        try {
            let scores = JSON.parse(localStorage.getItem('loom-scores') || '[]');
            scores.push({ score, epoch, ending, date: new Date().toISOString(), difficulty: G.difficulty });
            scores.sort((a, b) => b.score - a.score);
            scores = scores.slice(0, 10);
            localStorage.setItem('loom-scores', JSON.stringify(scores));
        } catch(e) {}
    }

    function displayHighScores() {
        try {
            const scores = JSON.parse(localStorage.getItem('loom-scores') || '[]');
            const el = document.getElementById('high-scores');
            if (scores.length === 0) {
                el.innerHTML = '<h3>High Scores</h3><p>No scores yet</p>';
            } else {
                let html = '<h3>High Scores</h3>';
                scores.slice(0, 5).forEach((s, i) => {
                    html += '<p>' + (i + 1) + '. ' + s.score + ' pts (Epoch ' + s.epoch + ', ' + s.difficulty + ')</p>';
                });
                el.innerHTML = html;
            }
        } catch(e) {}
    }

    // ========== UPDATE ==========
    function update(dt) {
        if (G.state !== 'playing') return;
        G.time += dt;

        // Essence regen
        G.essence = Math.min(G.maxEssence, G.essence + G.settings.essenceRegen * dt * 60);

        // Void pressure from entities alive
        G.entities.forEach(e => {
            if (e.x > 0 && e.x < W && e.y > 0 && e.y < H) {
                G.voidPressure += e.voidAdd * dt * 0.1 * G.settings.voidRate;
            }
        });
        G.voidPressure = Math.min(G.maxVoid, G.voidPressure);
        if (G.voidPressure >= G.maxVoid) { gameOver('void'); return; }

        // Void decay from stars
        G.stars.forEach(s => {
            G.voidPressure -= s.dps * dt * 0.5;
        });
        G.voidPressure = Math.max(0, G.voidPressure);

        // Combo timer
        if (G.combo > 0) {
            G.comboTimer -= dt;
            if (G.comboTimer <= 0) G.combo = 0;
        }

        // Tool cooldowns
        Object.values(G.tools).forEach(t => {
            if (t.cooldown > 0) t.cooldown = Math.max(0, t.cooldown - dt);
        });
        updateToolUI();

        // Wave spawning
        G.waveTimer -= dt;
        if (G.waveTimer <= 0) {
            G.waveNumber++;
            const count = Math.floor(2 + G.epoch * 0.5 + G.waveNumber * 0.3) * G.settings.spawnRate;
            for (let i = 0; i < Math.floor(count); i++) spawnEntity(false);

            // Boss every 3 waves
            if (G.waveNumber % 3 === 0) spawnEntity(true);

            G.waveInterval = Math.max(5, 12 - G.epoch * 0.3);
            G.waveTimer = G.waveInterval;
            addFloat(W / 2, 40, 'WAVE ' + G.waveNumber, '#aa88ff', 1.5);
        }

        // Epoch progression
        if (G.waveNumber > 0 && G.waveNumber % 5 === 0 && G.waveTimer > G.waveInterval - 0.1) {
            G.epoch++;
            G.essence = Math.min(G.maxEssence, G.essence + 30);
            document.getElementById('epoch-val').textContent = G.epoch;
            addFloat(W / 2, H / 2, 'EPOCH ' + G.epoch, '#ffcc44', 2);
            sfxWin();
            G.shakeMag = 8;
            if (G.epoch >= 10) { gameOver('master'); return; }
        }

        // Update threads
        G.threads.forEach(t => t.update(dt));
        G.threads = G.threads.filter(t => t.fadeOut > -0.1 && t.hp > -1);

        // Update stars
        G.stars.forEach(s => s.update(dt));

        // Star damage to entities
        G.stars.forEach(s => {
            G.entities.forEach(e => {
                const d = Math.hypot(e.x - s.x, e.y - s.y);
                if (d < s.damageAura) {
                    e.hp -= s.dps * dt;
                    if (Math.random() < 0.05) e.flash = 0.3;
                }
            });
        });

        // Update entities
        G.entities.forEach(e => {
            e.phase += dt * 2;
            e.flash = Math.max(0, e.flash - dt * 4);

            if (e.trapped) {
                e.trapTimer -= dt;
                if (e.trapTimer <= 0) { e.trapped = false; e.speed *= 5; } // Restore speed
            }

            // Thread collision — entities damage threads they pass through
            G.threads.forEach(t => {
                if (t.fadeOut > 0 || t.anchored) return;
                const dist = pointToLine(e.x, e.y, t.x1, t.y1, t.x2, t.y2);
                if (dist < e.size + 3) {
                    t.hp -= e.damage * dt * 0.3;
                    t.vibration = Math.max(t.vibration, 0.3);
                    if (t.hp <= 0 && t.fadeOut <= 0) {
                        t.fadeOut = 1;
                        sfxBreak();
                    }
                }
            });

            switch (e.behavior) {
                case 'drift':
                    e.vx += (Math.cos(e.phase * 0.3) * e.speed - e.vx) * 0.02;
                    e.vy += (Math.sin(e.phase * 0.4) * e.speed - e.vy) * 0.02;
                    // Drift toward center
                    e.vx += (W / 2 - e.x) * 0.00005 * e.speed;
                    e.vy += (H / 2 - e.y) * 0.00005 * e.speed;
                    break;
                case 'phase':
                    // Phase in and out
                    const phasing = Math.sin(e.phase) > 0.3;
                    if (phasing) {
                        e.vx += ((e.tx - e.x) * 0.005) * e.speed;
                        e.vy += ((e.ty - e.y) * 0.005) * e.speed;
                    }
                    e.vx *= 0.98; e.vy *= 0.98;
                    break;
                case 'seek': {
                    // Seek nearest star or center
                    let target = { x: W / 2, y: H / 2 };
                    let minD = Infinity;
                    G.stars.forEach(s => {
                        const d = Math.hypot(s.x - e.x, s.y - e.y);
                        if (d < minD) { minD = d; target = s; }
                    });
                    const dx = target.x - e.x, dy = target.y - e.y;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                    e.vx += (dx / dist) * e.speed * 0.05;
                    e.vy += (dy / dist) * e.speed * 0.05;
                    e.vx *= 0.97; e.vy *= 0.97;
                    break;
                }
                case 'erode':
                    // Slow but erodes threads faster (handled in thread collision)
                    e.vx += (e.tx - e.x) * 0.002 * e.speed;
                    e.vy += (e.ty - e.y) * 0.002 * e.speed;
                    e.vx *= 0.99; e.vy *= 0.99;
                    break;
                case 'teleport':
                    e.teleportTimer -= dt;
                    if (e.teleportTimer <= 0) {
                        e.x = 50 + Math.random() * (W - 100);
                        e.y = 50 + Math.random() * (H - 100);
                        e.teleportTimer = 2 + Math.random() * 3;
                        // Teleport particles
                        for (let i = 0; i < 6; i++) {
                            G.particles.push({
                                x: e.x, y: e.y,
                                vx: (Math.random() - 0.5) * 4, vy: (Math.random() - 0.5) * 4,
                                life: 0.5, maxLife: 0.5, size: 2, color: e.color
                            });
                        }
                    }
                    e.vx = Math.cos(e.phase) * e.speed * 0.5;
                    e.vy = Math.sin(e.phase) * e.speed * 0.5;
                    break;
                case 'expand':
                    // Grows slowly, stationary mostly
                    e.expandSize = Math.min(30, (e.expandSize || 0) + dt * 2);
                    e.vx *= 0.95; e.vy *= 0.95;
                    e.vx += (W / 2 - e.x) * 0.0001;
                    e.vy += (H / 2 - e.y) * 0.0001;
                    break;
                case 'boss':
                    // Aggressive: seek, periodic dash, spawn minions
                    e.vx += (W / 2 - e.x) * 0.0003 * e.speed;
                    e.vy += (H / 2 - e.y) * 0.0003 * e.speed;
                    e.teleportTimer -= dt;
                    if (e.teleportTimer <= 0) {
                        // Dash toward center
                        const tdx = W / 2 - e.x, tdy = H / 2 - e.y;
                        const tdist = Math.sqrt(tdx * tdx + tdy * tdy) || 1;
                        e.vx = (tdx / tdist) * e.speed * 5;
                        e.vy = (tdy / tdist) * e.speed * 5;
                        e.teleportTimer = 4;
                        if (Math.random() > 0.5 && G.entities.length < 15) spawnEntity(false);
                    }
                    e.vx *= 0.97; e.vy *= 0.97;
                    break;
            }

            e.x += e.vx * dt * 60;
            e.y += e.vy * dt * 60;

            // Boundary wrap
            if (e.x < -50) e.x = W + 50;
            if (e.x > W + 50) e.x = -50;
            if (e.y < -50) e.y = H + 50;
            if (e.y > H + 50) e.y = -50;
        });

        // Remove dead entities
        const beforeCount = G.entities.length;
        G.entities = G.entities.filter(e => {
            if (e.hp <= 0) {
                G.entitiesKilled++;
                G.score += e.isBoss ? 150 : 20;
                G.voidPressure = Math.max(0, G.voidPressure - e.voidAdd * 0.5);
                spawnDeathParticles(e.x, e.y, e.color);
                if (e.isBoss) {
                    G.bossesDefeated++;
                    addFloat(e.x, e.y, 'BOSS DESTROYED!', '#ffcc44', 2);
                    sfxWin();
                    G.shakeMag = 12;
                    if (G.bossesDefeated >= 5) { gameOver('starforger'); }
                }
                return false;
            }
            return true;
        });

        // Update dust
        G.dust.forEach(p => {
            G.threads.forEach(t => {
                if (t.fadeOut > 0) return;
                const mx = t.midX(), my = t.midY();
                const dx = mx - p.x, dy = my - p.y;
                const dist = Math.hypot(dx, dy);
                if (dist < 150 && dist > 5) {
                    p.vx += (dx / dist) * 0.008 * t.tension;
                    p.vy += (dy / dist) * 0.008 * t.tension;
                }
            });
            p.vx *= 0.99; p.vy *= 0.99;
            p.x += p.vx; p.y += p.vy;
            if (p.x < 0) p.x = W; if (p.x > W) p.x = 0;
            if (p.y < 0) p.y = H; if (p.y > H) p.y = 0;
        });

        // Particles
        G.particles.forEach(pt => {
            pt.x += pt.vx; pt.y += pt.vy;
            pt.vy += 0.02;
            pt.vx *= 0.99; pt.vy *= 0.99;
            pt.life -= dt;
        });
        G.particles = G.particles.filter(pt => pt.life > 0);

        // Floating texts
        G.floatingTexts.forEach(ft => { ft.y -= 25 * dt; ft.life -= dt; });
        G.floatingTexts = G.floatingTexts.filter(ft => ft.life > 0);

        // Shake decay
        G.shakeMag *= 0.9;
        G.shakeX = (Math.random() - 0.5) * G.shakeMag;
        G.shakeY = (Math.random() - 0.5) * G.shakeMag;

        // HUD
        document.getElementById('essence-bar').style.width = (G.essence / G.maxEssence * 100) + '%';
        document.getElementById('void-bar').style.width = (G.voidPressure / G.maxVoid * 100) + '%';
        document.getElementById('score-val').textContent = G.score;
        document.getElementById('combo-val').textContent = G.combo > 1 ? G.combo + 'x COMBO' : '';
    }

    // ========== RENDERING ==========
    function draw() {
        ctx.save();
        ctx.translate(G.shakeX, G.shakeY);

        // Background
        ctx.fillStyle = '#020208';
        ctx.fillRect(-10, -10, W + 20, H + 20);

        // Background stars
        G.bgStars.forEach(s => {
            const twinkle = Math.sin(G.time * s.twinkleSpeed) * 0.3 + 0.7;
            ctx.fillStyle = 'rgba(200,200,255,' + (s.brightness * twinkle * 0.3) + ')';
            ctx.beginPath();
            ctx.arc(s.x % W, s.y % H, s.size, 0, Math.PI * 2);
            ctx.fill();
        });

        if (G.state === 'menu') { ctx.restore(); return; }
        if (G.state !== 'playing' && G.state !== 'paused') { ctx.restore(); return; }

        // Dust
        G.dust.forEach(p => {
            ctx.fillStyle = 'rgba(140,120,200,0.25)';
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
        });

        // Draw threads
        G.threads.forEach(t => t.draw());

        // Drawing thread preview
        if (G.drawingThread) {
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = 'rgba(160,140,255,0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(G.drawingThread.x1, G.drawingThread.y1);
            ctx.lineTo(G.drawingThread.x2, G.drawingThread.y2);
            ctx.stroke();
            ctx.setLineDash([]);

            // Essence cost preview
            const len = G.drawingThread.length();
            if (len > 30) {
                const cost = Math.floor(len / 30);
                ctx.fillStyle = G.essence >= cost ? 'rgba(100,200,150,0.6)' : 'rgba(255,100,100,0.6)';
                ctx.font = '11px Georgia';
                ctx.textAlign = 'center';
                ctx.fillText('-' + cost + ' essence', (G.drawingThread.x1 + G.drawingThread.x2) / 2, (G.drawingThread.y1 + G.drawingThread.y2) / 2 - 10);
            }
        }

        // Draw stars
        G.stars.forEach(s => s.draw());

        // Draw entities
        G.entities.forEach(e => {
            const pulse = 1 + Math.sin(e.phase) * 0.1;
            const sz = (e.size + (e.expandSize || 0)) * pulse;

            // Entity aura
            if (e.isBoss) {
                const bGrad = ctx.createRadialGradient(e.x, e.y, 0, e.x, e.y, sz * 2.5);
                bGrad.addColorStop(0, 'rgba(255,30,50,0.12)');
                bGrad.addColorStop(1, 'transparent');
                ctx.fillStyle = bGrad;
                ctx.fillRect(e.x - sz * 2.5, e.y - sz * 2.5, sz * 5, sz * 5);
            }

            // Trapped effect
            if (e.trapped) {
                ctx.strokeStyle = 'rgba(68,255,170,0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.arc(e.x, e.y, sz + 8, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Body
            ctx.fillStyle = e.flash > 0 ? '#ffffff' : e.color;
            ctx.beginPath();
            // Irregular shape
            const sides = e.isBoss ? 7 : 5;
            for (let i = 0; i < sides; i++) {
                const angle = (i / sides) * Math.PI * 2 + e.phase * 0.3;
                const r = sz * (0.6 + Math.sin(G.time * 3 + i * 1.7) * 0.4);
                const px = e.x + Math.cos(angle) * r;
                const py = e.y + Math.sin(angle) * r;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();

            // Inner void
            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            ctx.beginPath();
            ctx.arc(e.x, e.y, sz * 0.4, 0, Math.PI * 2);
            ctx.fill();

            // HP bar
            if (e.hp < e.maxHp) {
                const barW = e.isBoss ? 60 : 30;
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(e.x - barW / 2, e.y - sz - 10, barW, 4);
                ctx.fillStyle = e.hp / e.maxHp > 0.5 ? '#6688ff' : '#ff4466';
                ctx.fillRect(e.x - barW / 2, e.y - sz - 10, barW * (e.hp / e.maxHp), 4);
            }
        });

        // Particles
        G.particles.forEach(pt => {
            ctx.globalAlpha = pt.life / pt.maxLife;
            ctx.fillStyle = pt.color;
            ctx.beginPath();
            ctx.arc(pt.x, pt.y, pt.size * (pt.life / pt.maxLife), 0, Math.PI * 2);
            ctx.fill();
        });
        ctx.globalAlpha = 1;

        // Floating texts
        G.floatingTexts.forEach(ft => {
            ctx.globalAlpha = ft.life / ft.maxLife;
            ctx.fillStyle = ft.color;
            ctx.font = 'bold 14px Georgia';
            ctx.textAlign = 'center';
            ctx.fillText(ft.text, ft.x, ft.y);
        });
        ctx.globalAlpha = 1;

        // Void pressure visual — screen edges glow red
        if (G.voidPressure > 30) {
            const intensity = (G.voidPressure - 30) / 70;
            // Edge vignette
            const edgeGrad = ctx.createRadialGradient(W / 2, H / 2, Math.min(W, H) * 0.4, W / 2, H / 2, Math.max(W, H) * 0.7);
            edgeGrad.addColorStop(0, 'transparent');
            edgeGrad.addColorStop(1, 'rgba(150,20,50,' + (intensity * 0.25) + ')');
            ctx.fillStyle = edgeGrad;
            ctx.fillRect(-10, -10, W + 20, H + 20);
        }

        // High void — screen static
        if (G.voidPressure > 70) {
            const intensity = (G.voidPressure - 70) / 30;
            for (let i = 0; i < Math.floor(intensity * 20); i++) {
                ctx.fillStyle = 'rgba(200,100,150,' + (Math.random() * intensity * 0.06) + ')';
                ctx.fillRect(Math.random() * W, Math.random() * H, Math.random() * 20, 1);
            }
        }

        // Wave timer indicator
        if (G.waveTimer < 3) {
            ctx.fillStyle = 'rgba(170,100,255,' + (0.3 + Math.sin(G.time * 6) * 0.2) + ')';
            ctx.font = '12px Georgia';
            ctx.textAlign = 'center';
            ctx.fillText('Next wave in ' + Math.ceil(G.waveTimer) + 's', W / 2, H - 80);
        }

        // Cursor (crosshair)
        if (G.currentTool === 'weave') {
            ctx.strokeStyle = 'rgba(160,140,255,0.4)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(mouseX - 10, mouseY); ctx.lineTo(mouseX + 10, mouseY);
            ctx.moveTo(mouseX, mouseY - 10); ctx.lineTo(mouseX, mouseY + 10);
            ctx.stroke();
        }

        ctx.restore();
    }

    // ========== MAIN LOOP ==========
    function loop(now) {
        if (!G.lastTime) G.lastTime = now;
        const dt = Math.min((now - G.lastTime) / 1000, 0.05);
        G.lastTime = now;

        if (G.state === 'playing') update(dt);
        draw();
        requestAnimationFrame(loop);
    }

    // ========== INIT ==========
    displayHighScores();
    requestAnimationFrame(loop);
    </script>
</body>
</html>
