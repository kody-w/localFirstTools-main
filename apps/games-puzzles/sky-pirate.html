<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sky Realms: Phantom Drift</title>
    <meta name="description" content="A high-octane 2.5D platformer where you phase between physical and spirit realms. Master the Ghost State to traverse impossible geometry and evade sky-patrols.">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #050510;
            overflow: hidden;
            font-family: 'Orbitron', sans-serif;
            user-select: none;
            touch-action: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .energy-bar-container {
            width: 300px;
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #444;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
            transform: skewX(-20deg);
        }

        .energy-bar-fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #00ffff, #0088ff);
            box-shadow: 0 0 10px #00ffff;
            transition: width 0.1s linear;
        }

        .energy-label {
            position: absolute;
            top: -25px;
            left: 0;
            color: #00ffff;
            font-size: 14px;
            text-shadow: 0 0 5px #00ffff;
            letter-spacing: 2px;
        }

        .score-container {
            text-align: right;
            color: #ffd700;
            text-shadow: 0 0 10px #ff8800;
        }

        .score-value {
            font-size: 32px;
            font-weight: 900;
        }

        .score-label {
            font-size: 12px;
            color: #aaa;
            letter-spacing: 2px;
        }

        #tutorial-overlay {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: rgba(255, 255, 255, 0.8);
            font-size: 18px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
            transition: opacity 0.5s;
        }

        .key {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 4px;
            padding: 2px 8px;
            margin: 0 4px;
            font-weight: bold;
            color: #fff;
        }

        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 5, 16, 0.85);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 100;
        }

        .hidden {
            display: none !important;
        }

        h1 {
            font-size: 64px;
            margin: 0 0 20px 0;
            background: linear-gradient(180deg, #fff, #888);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 10px 20px rgba(0,0,0,0.5);
            text-transform: uppercase;
            letter-spacing: 10px;
        }

        .subtitle {
            font-size: 24px;
            color: #00ffff;
            margin-bottom: 60px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            letter-spacing: 5px;
        }

        .btn {
            background: transparent;
            border: 2px solid #00ffff;
            color: #00ffff;
            padding: 15px 40px;
            font-size: 24px;
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 3px;
            position: relative;
            overflow: hidden;
            transform: skewX(-20deg);
        }

        .btn:hover {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 20px #00ffff;
        }

        .btn:active {
            transform: skewX(-20deg) scale(0.95);
        }

        .controls-hint {
            margin-top: 40px;
            color: #888;
            font-size: 14px;
            line-height: 1.6;
            text-align: center;
        }

        /* Scanline effect */
        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.1) 50%,
                rgba(0,0,0,0.1)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 50;
        }

        .vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 60%, rgba(0,0,0,0.8) 100%);
            pointer-events: none;
            z-index: 51;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div class="scanlines"></div>
        <div class="vignette"></div>

        <div id="ui-layer">
            <div class="hud-top">
                <div class="energy-bar-container">
                    <div class="energy-label">PHASE ENERGY</div>
                    <div class="energy-bar-fill" id="energy-bar"></div>
                </div>
                <div class="score-container">
                    <div class="score-label">DATA FRAGMENTS</div>
                    <div class="score-value" id="score-display">0</div>
                </div>
            </div>
            <div id="tutorial-overlay">
                Hold <span class="key">SHIFT</span> or <span class="key">K</span> to PHASE SHIFT<br>
                Pass through blue walls. Invisible to enemies.
            </div>
        </div>

        <div id="start-screen">
            <h1>Sky Realms</h1>
            <div class="subtitle">PHANTOM DRIFT</div>
            <button class="btn" id="start-btn">INITIATE LINK</button>
            <div class="controls-hint">
                <span class="key">W</span> / <span class="key">SPACE</span> Jump<br>
                <span class="key">A</span> <span class="key">D</span> Move<br>
                <span class="key">SHIFT</span> / <span class="key">K</span> Phase Shift
            </div>
        </div>

        <div id="game-over-screen" class="hidden">
            <h1 style="color: #ff4444; -webkit-text-fill-color: #ff4444;">SIGNAL LOST</h1>
            <div class="subtitle" id="final-score">FRAGMENTS: 0</div>
            <button class="btn" id="restart-btn">RE-SYNC</button>
        </div>
    </div>

    <script>
        // --- ENGINE & CONFIG ---
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d', { alpha: false }); // Optimize for no transparency on base
        
        let width, height;
        
        const CONFIG = {
            gravity: 0.6,
            friction: 0.85,
            moveSpeed: 0.8,
            maxSpeed: 8,
            jumpForce: 14,
            doubleJumpForce: 10,
            phaseDrainRate: 0.8,
            phaseRechargeRate: 0.3,
            cameraLerp: 0.1,
            coyoteTime: 100, // ms
            jumpBuffer: 100 // ms
        };

        // --- GAME STATE ---
        let gameState = {
            running: false,
            score: 0,
            time: 0,
            camera: { x: 0, y: 0, shake: 0 },
            particles: [],
            platforms: [],
            enemies: [],
            collectibles: [],
            backgroundStars: [],
            clouds: []
        };

        let player = {
            x: 100,
            y: 100,
            vx: 0,
            vy: 0,
            width: 30,
            height: 50,
            isGrounded: false,
            isPhasing: false,
            phaseEnergy: 100,
            facingRight: true,
            canDoubleJump: false,
            lastGroundedTime: 0,
            jumpBufferTime: 0,
            animationFrame: 0,
            trail: []
        };

        let keys = {
            w: false, a: false, s: false, d: false,
            space: false, shift: false, k: false
        };

        // --- INPUT HANDLING ---
        window.addEventListener('keydown', e => {
            const key = e.key.toLowerCase();
            if (key === ' ') keys.space = true;
            if (key === 'shift') keys.shift = true;
            if (keys.hasOwnProperty(key)) keys[key] = true;
            
            if ((key === ' ' || key === 'w') && gameState.running) {
                player.jumpBufferTime = Date.now();
            }
        });

        window.addEventListener('keyup', e => {
            const key = e.key.toLowerCase();
            if (key === ' ') keys.space = false;
            if (key === 'shift') keys.shift = false;
            if (keys.hasOwnProperty(key)) keys[key] = false;
        });

        document.getElementById('start-btn').addEventListener('click', startGame);
        document.getElementById('restart-btn').addEventListener('click', startGame);

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            ctx.imageSmoothingEnabled = false;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- GAME LOOP ---
        function startGame() {
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');
            
            // Reset State
            gameState.running = true;
            gameState.score = 0;
            gameState.time = 0;
            gameState.camera = { x: 0, y: 0, shake: 0 };
            gameState.particles = [];
            gameState.platforms = [];
            gameState.enemies = [];
            gameState.collectibles = [];
            
            // Reset Player
            player = {
                x: 100,
                y: 0,
                vx: 0,
                vy: 0,
                width: 30,
                height: 50,
                isGrounded: false,
                isPhasing: false,
                phaseEnergy: 100,
                facingRight: true,
                canDoubleJump: false,
                lastGroundedTime: 0,
                jumpBufferTime: 0,
                animationFrame: 0,
                trail: []
            };

            // Generate Initial Level
            generateLevel(0, 2000);
            generateBackground();

            requestAnimationFrame(loop);
        }

        function loop() {
            if (!gameState.running) return;

            update();
            render();
            requestAnimationFrame(loop);
        }

        function update() {
            gameState.time++;

            // --- PLAYER PHYSICS ---
            // Horizontal Movement
            if (keys.a) {
                player.vx -= CONFIG.moveSpeed;
                player.facingRight = false;
            }
            if (keys.d) {
                player.vx += CONFIG.moveSpeed;
                player.facingRight = true;
            }

            player.vx *= CONFIG.friction;
            player.vx = Math.max(Math.min(player.vx, CONFIG.maxSpeed), -CONFIG.maxSpeed);
            player.x += player.vx;

            // Phasing Logic
            const wantsToPhase = keys.shift || keys.k;
            if (wantsToPhase && player.phaseEnergy > 0) {
                if (!player.isPhasing) {
                    // Just started phasing
                    createBurstParticles(player.x + player.width/2, player.y + player.height/2, '#00ffff', 10);
                    gameState.camera.shake = 5;
                }
                player.isPhasing = true;
                player.phaseEnergy -= CONFIG.phaseDrainRate;
            } else {
                if (player.isPhasing) {
                    // Just stopped phasing
                    createBurstParticles(player.x + player.width/2, player.y + player.height/2, '#ffffff', 5);
                }
                player.isPhasing = false;
                player.phaseEnergy = Math.min(player.phaseEnergy + CONFIG.phaseRechargeRate, 100);
            }

            // Vertical Movement & Gravity
            player.vy += CONFIG.gravity;
            // Float effect when phasing
            if (player.isPhasing && player.vy > 0) {
                player.vy *= 0.8; // Fall slower
            }
            player.y += player.vy;

            // Ground Detection & Collision
            player.isGrounded = false;
            
            // Floor collision (death plane)
            if (player.y > height + 500) {
                gameOver();
            }

            // Platform Collision
            for (let plat of gameState.platforms) {
                // Phase platforms (blue) are permeable when phasing
                if (plat.type === 'phase' && player.isPhasing) continue;

                // Simple AABB collision
                if (player.x < plat.x + plat.w &&
                    player.x + player.width > plat.x &&
                    player.y < plat.y + plat.h &&
                    player.y + player.height > plat.y) {
                    
                    // Resolve Collision
                    // Check previous position to determine side
                    const prevY = player.y - player.vy;
                    
                    // Landing on top
                    if (prevY + player.height <= plat.y) {
                        player.y = plat.y - player.height;
                        player.vy = 0;
                        player.isGrounded = true;
                        player.canDoubleJump = true;
                        player.lastGroundedTime = Date.now();
                    }
                    // Hitting head
                    else if (prevY >= plat.y + plat.h) {
                        player.y = plat.y + plat.h;
                        player.vy = 0;
                    }
                    // Side collision
                    else {
                        if (player.x + player.width/2 < plat.x + plat.w/2) {
                            player.x = plat.x - player.width;
                            player.vx = 0;
                        } else {
                            player.x = plat.x + plat.w;
                            player.vx = 0;
                        }
                    }
                }
            }

            // Jump Logic
            const coyoteValid = Date.now() - player.lastGroundedTime < CONFIG.coyoteTime;
            const bufferValid = Date.now() - player.jumpBufferTime < CONFIG.jumpBuffer;

            if (bufferValid) {
                if (player.isGrounded || coyoteValid) {
                    player.vy = -CONFIG.jumpForce;
                    player.jumpBufferTime = 0;
                    player.isGrounded = false;
                    createBurstParticles(player.x + player.width/2, player.y + player.height, '#fff', 5);
                } else if (player.canDoubleJump) {
                    player.vy = -CONFIG.doubleJumpForce;
                    player.canDoubleJump = false;
                    player.jumpBufferTime = 0;
                    createBurstParticles(player.x + player.width/2, player.y + player.height, '#00ffff', 8);
                }
            }

            // --- ENTITIES ---
            // Collectibles
            for (let i = gameState.collectibles.length - 1; i >= 0; i--) {
                let c = gameState.collectibles[i];
                // Float animation
                c.y = c.baseY + Math.sin(gameState.time * 0.05) * 5;
                
                if (checkOverlap(player, {x: c.x, y: c.y, width: c.size, height: c.size})) {
                    gameState.score += 10;
                    createBurstParticles(c.x, c.y, '#ffd700', 15);
                    gameState.collectibles.splice(i, 1);
                }
            }

            // Enemies
            for (let enemy of gameState.enemies) {
                // Patrol logic
                enemy.x += enemy.speed * enemy.dir;
                if (enemy.x > enemy.maxX || enemy.x < enemy.minX) {
                    enemy.dir *= -1;
                }

                // Collision with player
                if (!player.isPhasing) { // Invisible when phasing
                    if (checkOverlap(player, {x: enemy.x, y: enemy.y, width: enemy.size, height: enemy.size})) {
                        gameOver();
                    }
                }
            }

            // --- CAMERA ---
            // Target is player position, slightly ahead
            let targetX = player.x - width * 0.3;
            let targetY = player.y - height * 0.6;
            
            // Look ahead
            targetX += player.vx * 20;

            gameState.camera.x += (targetX - gameState.camera.x) * CONFIG.cameraLerp;
            gameState.camera.y += (targetY - gameState.camera.y) * CONFIG.cameraLerp;

            // Shake decay
            if (gameState.camera.shake > 0) {
                gameState.camera.x += (Math.random() - 0.5) * gameState.camera.shake;
                gameState.camera.y += (Math.random() - 0.5) * gameState.camera.shake;
                gameState.camera.shake *= 0.9;
                if (gameState.camera.shake < 0.5) gameState.camera.shake = 0;
            }

            // --- LEVEL GENERATION ---
            // Infinite generation as we move right
            const rightEdge = gameState.camera.x + width;
            const lastPlatform = gameState.platforms[gameState.platforms.length - 1];
            if (lastPlatform && lastPlatform.x < rightEdge + 500) {
                generateLevel(lastPlatform.x + lastPlatform.w, 1000);
            }

            // Cleanup
            if (gameState.platforms.length > 50) {
                gameState.platforms.shift(); // Remove old platforms
            }

            // --- PARTICLES ---
            updateParticles();
            
            // Player Trail
            if (Math.abs(player.vx) > 1 || player.isPhasing) {
                player.trail.push({
                    x: player.x,
                    y: player.y,
                    alpha: 0.5,
                    color: player.isPhasing ? '#00ffff' : '#ff00ff'
                });
            }
            
            // Update UI
            document.getElementById('energy-bar').style.width = player.phaseEnergy + '%';
            document.getElementById('score-display').innerText = gameState.score;
        }

        function render() {
            // Clear
            ctx.fillStyle = '#050510';
            ctx.fillRect(0, 0, width, height);

            ctx.save();
            
            // Camera Transform
            ctx.translate(-gameState.camera.x, -gameState.camera.y);

            // --- BACKGROUND ---
            renderBackground();

            // --- PLATFORMS ---
            for (let plat of gameState.platforms) {
                if (plat.type === 'normal') {
                    // Industrial style
                    ctx.fillStyle = '#2a2a35';
                    ctx.fillRect(plat.x, plat.y, plat.w, plat.h);
                    
                    // Detail lines
                    ctx.strokeStyle = '#444';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(plat.x, plat.y, plat.w, plat.h);
                    
                    // Hazard stripes
                    ctx.fillStyle = '#333';
                    for(let i=0; i<plat.w; i+=20) {
                        ctx.fillRect(plat.x + i, plat.y, 5, plat.h);
                    }
                } else if (plat.type === 'phase') {
                    // Holographic style
                    ctx.fillStyle = `rgba(0, 255, 255, ${player.isPhasing ? 0.1 : 0.3})`;
                    ctx.fillRect(plat.x, plat.y, plat.w, plat.h);
                    
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(plat.x, plat.y, plat.w, plat.h);
                    
                    // Glitch effect
                    if (Math.random() > 0.9) {
                        ctx.fillStyle = '#fff';
                        ctx.fillRect(plat.x + Math.random()*plat.w, plat.y, Math.random()*10, plat.h);
                    }
                }
            }

            // --- COLLECTIBLES ---
            for (let c of gameState.collectibles) {
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ffd700';
                ctx.fillStyle = '#ffd700';
                
                // Diamond shape
                ctx.beginPath();
                ctx.moveTo(c.x, c.y - c.size/2);
                ctx.lineTo(c.x + c.size/2, c.y);
                ctx.lineTo(c.x, c.y + c.size/2);
                ctx.lineTo(c.x - c.size/2, c.y);
                ctx.fill();
                
                ctx.shadowBlur = 0;
            }

            // --- ENEMIES ---
            for (let e of gameState.enemies) {
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ff0000';
                ctx.fillStyle = '#ff0000';
                
                // Drone body
                ctx.beginPath();
                ctx.arc(e.x + e.size/2, e.y + e.size/2, e.size/2, 0, Math.PI*2);
                ctx.fill();
                
                // Eye
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(e.x + e.size/2 + (e.dir*5), e.y + e.size/2, 5, 0, Math.PI*2);
                ctx.fill();
                
                // Vision cone (if not phasing)
                if (!player.isPhasing) {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.1)';
                    ctx.beginPath();
                    ctx.moveTo(e.x + e.size/2, e.y + e.size/2);
                    ctx.lineTo(e.x + e.size/2 + (e.dir * 150), e.y - 50);
                    ctx.lineTo(e.x + e.size/2 + (e.dir * 150), e.y + 50 + e.size);
                    ctx.fill();
                }
                
                ctx.shadowBlur = 0;
            }

            // --- PLAYER ---
            // Trail
            for (let i = 0; i < player.trail.length; i++) {
                let t = player.trail[i];
                ctx.fillStyle = t.color;
                ctx.globalAlpha = t.alpha;
                ctx.fillRect(t.x, t.y, player.width, player.height);
                t.alpha -= 0.05;
                if (t.alpha <= 0) player.trail.splice(i, 1);
            }
            ctx.globalAlpha = 1;

            // Player Body
            ctx.save();
            ctx.translate(player.x + player.width/2, player.y + player.height/2);
            
            // Lean into movement
            ctx.rotate(player.vx * 0.05);

            if (player.isPhasing) {
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#00ffff';
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 2;
                ctx.strokeRect(-player.width/2, -player.height/2, player.width, player.height);
                
                // Inner core
                ctx.fillStyle = 'rgba(0, 255, 255, 0.3)';
                ctx.fillRect(-player.width/2, -player.height/2, player.width, player.height);
            } else {
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ff00ff';
                ctx.fillStyle = '#ff00ff';
                ctx.fillRect(-player.width/2, -player.height/2, player.width, player.height);
                
                // Scarf/Cape
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.moveTo(-5, -15);
                ctx.lineTo(-20 - Math.abs(player.vx)*2, -10 + Math.sin(gameState.time*0.5)*5);
                ctx.lineTo(-5, -5);
                ctx.fill();
            }

            // Eyes
            ctx.fillStyle = '#fff';
            const eyeOffset = player.facingRight ? 5 : -5;
            ctx.fillRect(eyeOffset - 2, -10, 4, 4);

            ctx.restore();

            // --- PARTICLES ---
            for (let p of gameState.particles) {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            ctx.restore();
        }

        // --- HELPERS ---
        function generateBackground() {
            // Stars
            for(let i=0; i<100; i++) {
                gameState.backgroundStars.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    size: Math.random() * 2,
                    speed: Math.random() * 0.2
                });
            }
            // Clouds
            for(let i=0; i<10; i++) {
                gameState.clouds.push({
                    x: Math.random() * width * 2,
                    y: Math.random() * height,
                    w: 100 + Math.random() * 200,
                    h: 40 + Math.random() * 40,
                    speed: 0.5 + Math.random() * 0.5
                });
            }
        }

        function renderBackground() {
            // Parallax Stars
            ctx.fillStyle = '#fff';
            for(let s of gameState.backgroundStars) {
                let x = (s.x + gameState.camera.x * (1 - s.speed)) % (width + 200); // Wrap relative to camera
                // Simple wrap logic for infinite scroll illusion
                let screenX = (s.x - gameState.camera.x * s.speed) % width;
                if (screenX < 0) screenX += width;
                
                ctx.globalAlpha = Math.random() * 0.5 + 0.5;
                ctx.fillRect(gameState.camera.x + screenX, s.y, s.size, s.size);
            }
            
            // Parallax Clouds
            ctx.fillStyle = 'rgba(20, 20, 40, 0.5)';
            for(let c of gameState.clouds) {
                let screenX = (c.x - gameState.camera.x * 0.2) % (width * 2);
                if (screenX < -c.w) screenX += width * 2;
                
                // Draw relative to camera so they stick to background
                ctx.fillRect(gameState.camera.x + screenX, c.y, c.w, c.h);
            }
            ctx.globalAlpha = 1;
        }

        function generateLevel(startX, length) {
            let currentX = startX;
            let currentY = height - 150;
            
            // Ensure first platform is safe
            if (gameState.platforms.length === 0) {
                gameState.platforms.push({
                    x: 50, y: height - 150, w: 400, h: 40, type: 'normal'
                });
                currentX = 450;
            }

            while (currentX < startX + length) {
                const gap = 100 + Math.random() * 150;
                const w = 100 + Math.random() * 200;
                const h = 40;
                
                // Height variation
                currentY += (Math.random() - 0.5) * 200;
                currentY = Math.max(200, Math.min(height - 100, currentY));

                const type = Math.random() > 0.7 ? 'phase' : 'normal';
                
                gameState.platforms.push({
                    x: currentX + gap,
                    y: currentY,
                    w: w,
                    h: h,
                    type: type
                });

                // Add Collectible
                if (Math.random() > 0.3) {
                    gameState.collectibles.push({
                        x: currentX + gap + w/2,
                        y: currentY - 50,
                        baseY: currentY - 50,
                        size: 20
                    });
                }

                // Add Enemy
                if (Math.random() > 0.6 && w > 150 && type === 'normal') {
                    gameState.enemies.push({
                        x: currentX + gap + 20,
                        y: currentY - 30,
                        minX: currentX + gap,
                        maxX: currentX + gap + w - 30,
                        size: 30,
                        speed: 2,
                        dir: 1
                    });
                }

                currentX += gap + w;
            }
        }

        function createBurstParticles(x, y, color, count) {
            for(let i=0; i<count; i++) {
                gameState.particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 1,
                    color: color,
                    size: Math.random() * 3 + 1
                });
            }
        }

        function updateParticles() {
            for (let i = gameState.particles.length - 1; i >= 0; i--) {
                let p = gameState.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.05;
                p.size *= 0.95;
                
                if (p.life <= 0) {
                    gameState.particles.splice(i, 1);
                }
            }
        }

        function checkOverlap(rect1, rect2) {
            return (rect1.x < rect2.x + rect2.width &&
                    rect1.x + rect1.width > rect2.x &&
                    rect1.y < rect2.y + rect2.height &&
                    rect1.y + rect1.height > rect2.y);
        }

        function gameOver() {
            gameState.running = false;
            document.getElementById('final-score').innerText = `FRAGMENTS: ${gameState.score}`;
            document.getElementById('game-over-screen').classList.remove('hidden');
        }

    </script>
</body>
</html>
