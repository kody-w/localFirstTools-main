<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FLESH MACHINE - Biological Factory Management</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: radial-gradient(circle at center, #1a0a0f, #0a0506);
            color: #ffccdd;
            overflow: hidden;
            user-select: none;
        }

        #gameCanvas {
            display: block;
            cursor: crosshair;
            image-rendering: crisp-edges;
        }

        #ui {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }

        #ui > * {
            pointer-events: auto;
        }

        .organic-panel {
            background: radial-gradient(ellipse at top, rgba(80, 20, 40, 0.95), rgba(40, 10, 20, 0.98));
            border: 3px solid #aa4466;
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(170, 68, 102, 0.4), inset 0 0 30px rgba(0, 0, 0, 0.5);
            padding: 12px;
            position: relative;
        }

        .organic-panel::before {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            bottom: 2px;
            border: 1px solid rgba(255, 100, 150, 0.2);
            border-radius: 12px;
            pointer-events: none;
        }

        #topBar {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .resource-display {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 15px;
            font-size: 14px;
            font-weight: bold;
        }

        .resource-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
        }

        #buildMenu {
            position: absolute;
            left: 10px;
            top: 80px;
            width: 220px;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
        }

        .build-category {
            margin-bottom: 10px;
        }

        .category-header {
            background: rgba(170, 68, 102, 0.6);
            padding: 8px;
            cursor: pointer;
            border-radius: 5px;
            font-weight: bold;
            text-align: center;
            border: 2px solid #ff6688;
        }

        .category-header:hover {
            background: rgba(200, 80, 120, 0.7);
        }

        .category-items {
            margin-top: 5px;
        }

        .build-item {
            padding: 10px;
            margin: 5px 0;
            cursor: pointer;
            border-radius: 8px;
            border: 2px solid transparent;
            background: rgba(60, 20, 35, 0.8);
            transition: all 0.2s;
        }

        .build-item:hover {
            background: rgba(100, 40, 60, 0.9);
            border-color: #ff8899;
            transform: translateX(5px);
        }

        .build-item.selected {
            background: rgba(150, 60, 90, 1);
            border-color: #ffaa66;
            box-shadow: 0 0 15px rgba(255, 170, 102, 0.5);
        }

        .build-item-name {
            font-weight: bold;
            margin-bottom: 3px;
        }

        .build-item-cost {
            font-size: 11px;
            opacity: 0.8;
        }

        #contractPanel {
            position: absolute;
            right: 10px;
            top: 80px;
            width: 280px;
            max-height: 400px;
            overflow-y: auto;
        }

        .contract {
            background: rgba(40, 20, 30, 0.9);
            padding: 12px;
            margin: 8px 0;
            border-radius: 8px;
            border: 2px solid #886644;
        }

        .contract-client {
            font-weight: bold;
            color: #ffdd88;
            margin-bottom: 5px;
        }

        .contract-desc {
            font-size: 12px;
            margin: 5px 0;
            color: #ffccbb;
        }

        .contract-reward {
            color: #88ff88;
            font-weight: bold;
            margin-top: 5px;
        }

        .contract-timer {
            color: #ff8888;
            font-size: 11px;
        }

        .contract-btn {
            margin-top: 8px;
            padding: 6px 12px;
            background: #aa6644;
            border: 2px solid #ffaa88;
            border-radius: 5px;
            cursor: pointer;
            color: #fff;
            font-weight: bold;
            width: 100%;
        }

        .contract-btn:hover {
            background: #cc8866;
        }

        #alertPanel {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 350px;
            max-height: 200px;
            overflow-y: auto;
        }

        .alert {
            padding: 10px;
            margin: 5px 0;
            border-radius: 8px;
            border-left: 4px solid;
            background: rgba(40, 10, 20, 0.95);
            animation: alertSlide 0.3s ease-out;
        }

        @keyframes alertSlide {
            from { transform: translateX(-100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .alert.danger {
            border-color: #ff4444;
            color: #ffaaaa;
        }

        .alert.warning {
            border-color: #ffaa44;
            color: #ffddaa;
        }

        .alert.info {
            border-color: #4488ff;
            color: #aaccff;
        }

        #designerModal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 700px;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        #designerModal.active {
            display: block;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 999;
            display: none;
        }

        .modal-overlay.active {
            display: block;
        }

        .designer-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 15px 0;
        }

        .component-slot {
            aspect-ratio: 1;
            background: rgba(20, 10, 15, 0.8);
            border: 2px dashed #aa4466;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
        }

        .component-slot:hover {
            background: rgba(40, 20, 30, 0.9);
            border-color: #ff6688;
        }

        .component-slot.filled {
            border-style: solid;
            border-color: #ffaa66;
        }

        .stat-display {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            background: rgba(20, 10, 15, 0.6);
            margin: 5px 0;
            border-radius: 5px;
        }

        .btn {
            padding: 10px 20px;
            background: #aa4466;
            border: 2px solid #ff6688;
            border-radius: 8px;
            color: #fff;
            font-weight: bold;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.2s;
        }

        .btn:hover {
            background: #cc5577;
            box-shadow: 0 0 15px rgba(255, 102, 136, 0.5);
        }

        .btn:active {
            transform: scale(0.95);
        }

        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        #researchPanel {
            position: absolute;
            right: 10px;
            bottom: 10px;
            width: 200px;
        }

        .research-item {
            padding: 10px;
            margin: 5px 0;
            background: rgba(40, 20, 60, 0.8);
            border: 2px solid #6644aa;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
        }

        .research-item:hover {
            background: rgba(60, 30, 80, 0.9);
        }

        .research-item.completed {
            opacity: 0.5;
            cursor: default;
        }

        .tooltip {
            position: fixed;
            background: rgba(20, 10, 15, 0.98);
            border: 2px solid #ff6688;
            padding: 10px;
            border-radius: 8px;
            pointer-events: none;
            z-index: 10000;
            display: none;
            max-width: 300px;
            font-size: 12px;
        }

        .tooltip.active {
            display: block;
        }

        scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(20, 10, 15, 0.5);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: #aa4466;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #cc5577;
        }

        .pause-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 500;
        }

        .pause-overlay.active {
            display: flex;
        }

        .pause-menu {
            width: 400px;
            text-align: center;
        }

        .pause-menu h2 {
            margin-bottom: 20px;
            color: #ff6688;
            font-size: 32px;
        }

        .menu-btn {
            width: 100%;
            margin: 10px 0;
        }

        #gameTitle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 10000;
            display: none;
        }

        #gameTitle.active {
            display: block;
        }

        #gameTitle h1 {
            font-size: 72px;
            color: #ff6688;
            text-shadow: 0 0 30px rgba(255, 102, 136, 0.8), 0 0 60px rgba(170, 68, 102, 0.6);
            margin-bottom: 20px;
            letter-spacing: 8px;
        }

        #gameTitle p {
            font-size: 18px;
            color: #ffccdd;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="ui">
        <div id="topBar">
            <div class="organic-panel resource-display">
                <div class="resource-icon" style="background: #ff4466;"></div>
                <span>Muscle: <span id="muscleCount">0</span></span>
            </div>
            <div class="organic-panel resource-display">
                <div class="resource-icon" style="background: #eeeeee;"></div>
                <span>Bone: <span id="boneCount">0</span></span>
            </div>
            <div class="organic-panel resource-display">
                <div class="resource-icon" style="background: #ffdd44;"></div>
                <span>Nerve: <span id="nerveCount">0</span></span>
            </div>
            <div class="organic-panel resource-display">
                <div class="resource-icon" style="background: #ffaacc;"></div>
                <span>Skin: <span id="skinCount">0</span></span>
            </div>
            <div class="organic-panel resource-display">
                <div class="resource-icon" style="background: #aa66cc;"></div>
                <span>Organ: <span id="organCount">0</span></span>
            </div>
            <div class="organic-panel resource-display">
                <div class="resource-icon" style="background: #88ff88;"></div>
                <span>Credits: <span id="creditsCount">500</span></span>
            </div>
            <div class="organic-panel resource-display">
                <div class="resource-icon" style="background: #4488ff;"></div>
                <span>Reputation: <span id="reputationCount">0</span></span>
            </div>
        </div>

        <div id="buildMenu" class="organic-panel">
            <div style="text-align: center; margin-bottom: 10px; font-weight: bold; color: #ff6688;">BUILD MENU</div>
            <div class="build-category">
                <div class="category-header">PRODUCTION</div>
                <div class="category-items">
                    <div class="build-item" data-building="growthVat">
                        <div class="build-item-name">Growth Vat</div>
                        <div class="build-item-cost">Cost: 50¢</div>
                    </div>
                    <div class="build-item" data-building="fusionChamber">
                        <div class="build-item-name">Fusion Chamber</div>
                        <div class="build-item-cost">Cost: 100¢</div>
                    </div>
                    <div class="build-item" data-building="incubator">
                        <div class="build-item-name">Incubator</div>
                        <div class="build-item-cost">Cost: 150¢</div>
                    </div>
                </div>
            </div>
            <div class="build-category">
                <div class="category-header">LOGISTICS</div>
                <div class="category-items">
                    <div class="build-item" data-building="artery">
                        <div class="build-item-name">Artery</div>
                        <div class="build-item-cost">Cost: 10¢</div>
                    </div>
                    <div class="build-item" data-building="nerveHub">
                        <div class="build-item-name">Nerve Hub</div>
                        <div class="build-item-cost">Cost: 80¢</div>
                    </div>
                </div>
            </div>
            <div class="build-category">
                <div class="category-header">DEFENSE</div>
                <div class="category-items">
                    <div class="build-item" data-building="immuneTower">
                        <div class="build-item-name">Immune Tower</div>
                        <div class="build-item-cost">Cost: 120¢</div>
                    </div>
                    <div class="build-item" data-building="containmentPod">
                        <div class="build-item-name">Containment Pod</div>
                        <div class="build-item-cost">Cost: 200¢</div>
                    </div>
                </div>
            </div>
        </div>

        <div id="contractPanel" class="organic-panel">
            <div style="text-align: center; margin-bottom: 10px; font-weight: bold; color: #ff6688;">CONTRACTS</div>
            <div id="contractList"></div>
        </div>

        <div id="alertPanel" class="organic-panel">
            <div id="alertList"></div>
        </div>

        <div id="researchPanel" class="organic-panel">
            <div style="text-align: center; margin-bottom: 10px; font-weight: bold; color: #6644aa;">RESEARCH</div>
            <div id="researchList"></div>
        </div>
    </div>

    <div class="modal-overlay" id="modalOverlay"></div>
    <div id="designerModal" class="organic-panel">
        <div style="text-align: center; font-weight: bold; color: #ff6688; font-size: 20px; margin-bottom: 15px;">
            ORGANISM DESIGNER
        </div>
        <div>
            <label style="display: block; margin: 10px 0;">
                Body Plan:
                <select id="bodyPlanSelect" style="margin-left: 10px; padding: 5px; background: #2a1520; color: #ffccdd; border: 2px solid #aa4466; border-radius: 5px;">
                    <option value="bipedal">Bipedal</option>
                    <option value="quadruped">Quadruped</option>
                    <option value="serpentine">Serpentine</option>
                    <option value="amorphous">Amorphous</option>
                    <option value="winged">Winged</option>
                    <option value="aquatic">Aquatic</option>
                </select>
            </label>
        </div>
        <div style="margin: 15px 0;">
            <div style="font-weight: bold; margin-bottom: 10px;">Components (click slot to add):</div>
            <div class="designer-grid" id="componentGrid"></div>
        </div>
        <div style="margin: 15px 0;">
            <div style="font-weight: bold; margin-bottom: 10px;">Statistics:</div>
            <div class="stat-display">
                <span>Strength:</span>
                <span id="designStrength">0</span>
            </div>
            <div class="stat-display">
                <span>Flexibility:</span>
                <span id="designFlexibility">0</span>
            </div>
            <div class="stat-display">
                <span>Intelligence:</span>
                <span id="designIntelligence">0</span>
            </div>
            <div class="stat-display">
                <span>Durability:</span>
                <span id="designDurability">0</span>
            </div>
            <div class="stat-display">
                <span>Viability:</span>
                <span id="designViability" style="font-weight: bold; color: #88ff88;">0%</span>
            </div>
        </div>
        <div class="btn-group">
            <button class="btn" id="buildOrganismBtn">BUILD ORGANISM</button>
            <button class="btn" id="cancelDesignBtn">CANCEL</button>
        </div>
    </div>

    <div class="pause-overlay" id="pauseOverlay">
        <div class="pause-menu organic-panel">
            <h2>PAUSED</h2>
            <button class="btn menu-btn" id="resumeBtn">RESUME</button>
            <button class="btn menu-btn" id="saveBtn">SAVE GAME</button>
            <button class="btn menu-btn" id="loadBtn">LOAD GAME</button>
            <button class="btn menu-btn" id="resetBtn">RESET FACTORY</button>
        </div>
    </div>

    <div id="gameTitle" class="active">
        <h1>FLESH MACHINE</h1>
        <p>BIOLOGICAL FACTORY MANAGEMENT</p>
        <p style="margin-top: 30px;">Click anywhere to begin</p>
        <p style="font-size: 12px; margin-top: 20px; opacity: 0.7;">WASD to pan | Scroll to zoom | ESC to pause | Space to open organism designer</p>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        // ==============================================
        // GAME STATE & CONSTANTS
        // ==============================================

        const GRID_SIZE = 64;
        const TILE_SIZE = 48;

        const TISSUE_TYPES = {
            muscle: { name: 'Muscle', color: '#ff4466', strength: 10, flexibility: 3, conductivity: 1, durability: 5, reactivity: 4 },
            bone: { name: 'Bone', color: '#eeeeee', strength: 7, flexibility: 1, conductivity: 0, durability: 10, reactivity: 1 },
            nerve: { name: 'Nerve', color: '#ffdd44', strength: 1, flexibility: 5, conductivity: 10, durability: 2, reactivity: 7 },
            skin: { name: 'Skin', color: '#ffaacc', strength: 3, flexibility: 8, conductivity: 2, durability: 6, reactivity: 3 },
            organ: { name: 'Organ', color: '#aa66cc', strength: 4, flexibility: 4, conductivity: 5, durability: 4, reactivity: 8 }
        };

        const FUSION_RECIPES = {
            exoskeleton: { inputs: ['muscle', 'bone'], strength: 15, durability: 12, cost: 50 },
            brainCore: { inputs: ['nerve', 'organ'], intelligence: 20, conductivity: 15, cost: 80 },
            flexArmor: { inputs: ['skin', 'muscle'], strength: 10, flexibility: 12, cost: 60 },
            sensoryArray: { inputs: ['bone', 'nerve'], intelligence: 12, conductivity: 12, cost: 70 },
            filterMembrane: { inputs: ['organ', 'skin'], flexibility: 10, reactivity: 10, cost: 65 },
            powerCore: { inputs: ['muscle', 'organ'], strength: 12, conductivity: 10, cost: 75 },
            nerveCluster: { inputs: ['nerve', 'nerve'], intelligence: 15, conductivity: 18, cost: 90 },
            bonePlate: { inputs: ['bone', 'bone'], durability: 20, strength: 10, cost: 80 }
        };

        const BUILDING_TYPES = {
            growthVat: {
                name: 'Growth Vat',
                cost: 50,
                color: '#ff4466',
                produces: 'muscle',
                rate: 1,
                size: 1
            },
            fusionChamber: {
                name: 'Fusion Chamber',
                cost: 100,
                color: '#aa66cc',
                size: 1
            },
            incubator: {
                name: 'Incubator',
                cost: 150,
                color: '#ffaa66',
                size: 2
            },
            artery: {
                name: 'Artery',
                cost: 10,
                color: '#cc3344',
                size: 1
            },
            nerveHub: {
                name: 'Nerve Hub',
                cost: 80,
                color: '#ffdd44',
                size: 1
            },
            immuneTower: {
                name: 'Immune Tower',
                cost: 120,
                color: '#44ff88',
                size: 1
            },
            containmentPod: {
                name: 'Containment Pod',
                cost: 200,
                color: '#6688ff',
                size: 2
            }
        };

        const CLIENT_TYPES = ['Military', 'Medical', 'Agricultural', 'Entertainment', 'Black Market'];

        const gameState = {
            paused: false,
            started: false,
            resources: {
                muscle: 0,
                bone: 0,
                nerve: 0,
                skin: 0,
                organ: 0,
                credits: 500,
                reputation: 0
            },
            buildings: [],
            organisms: [],
            contracts: [],
            alerts: [],
            research: {
                unlocked: ['muscle', 'bone'],
                available: ['nerve', 'skin', 'organ']
            },
            camera: { x: 0, y: 0, zoom: 1 },
            selectedBuilding: null,
            buildingPlacement: null,
            time: 0,
            nextContractTime: 5000,
            nextHazardCheck: 10000,
            designer: {
                active: false,
                bodyPlan: 'bipedal',
                components: []
            }
        };

        // ==============================================
        // CANVAS & RENDERING
        // ==============================================

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        function worldToScreen(x, y) {
            return {
                x: (x - gameState.camera.x) * gameState.camera.zoom + canvas.width / 2,
                y: (y - gameState.camera.y) * gameState.camera.zoom + canvas.height / 2
            };
        }

        function screenToWorld(x, y) {
            return {
                x: (x - canvas.width / 2) / gameState.camera.zoom + gameState.camera.x,
                y: (y - canvas.height / 2) / gameState.camera.zoom + gameState.camera.y
            };
        }

        function drawGrid() {
            const startX = Math.floor((gameState.camera.x - canvas.width / 2 / gameState.camera.zoom) / TILE_SIZE) * TILE_SIZE;
            const startY = Math.floor((gameState.camera.y - canvas.height / 2 / gameState.camera.zoom) / TILE_SIZE) * TILE_SIZE;
            const endX = startX + canvas.width / gameState.camera.zoom + TILE_SIZE * 2;
            const endY = startY + canvas.height / gameState.camera.zoom + TILE_SIZE * 2;

            ctx.strokeStyle = 'rgba(170, 68, 102, 0.15)';
            ctx.lineWidth = 1;

            for (let x = startX; x < endX; x += TILE_SIZE) {
                const screen = worldToScreen(x, startY);
                const screenEnd = worldToScreen(x, endY);
                ctx.beginPath();
                ctx.moveTo(screen.x, screen.y);
                ctx.lineTo(screenEnd.x, screenEnd.y);
                ctx.stroke();
            }

            for (let y = startY; y < endY; y += TILE_SIZE) {
                const screen = worldToScreen(startX, y);
                const screenEnd = worldToScreen(endX, y);
                ctx.beginPath();
                ctx.moveTo(screen.x, screen.y);
                ctx.lineTo(screenEnd.x, screenEnd.y);
                ctx.stroke();
            }
        }

        function drawBackground() {
            const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
            gradient.addColorStop(0, '#1a0a0f');
            gradient.addColorStop(1, '#0a0506');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Organic pulsing effect
            const pulse = Math.sin(gameState.time / 500) * 0.5 + 0.5;
            ctx.fillStyle = `rgba(80, 20, 40, ${0.02 + pulse * 0.03})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function drawBuilding(building) {
            const type = BUILDING_TYPES[building.type];
            const size = type.size * TILE_SIZE;
            const screen = worldToScreen(building.x, building.y);

            // Pulsing effect
            const pulse = Math.sin(gameState.time / 300 + building.x + building.y) * 0.1 + 0.9;

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(screen.x + 4, screen.y + 4, size * gameState.camera.zoom, size * gameState.camera.zoom);

            // Main body with gradient
            const gradient = ctx.createRadialGradient(
                screen.x + size * gameState.camera.zoom / 2,
                screen.y + size * gameState.camera.zoom / 2,
                0,
                screen.x + size * gameState.camera.zoom / 2,
                screen.y + size * gameState.camera.zoom / 2,
                size * gameState.camera.zoom / 2
            );
            gradient.addColorStop(0, type.color);
            gradient.addColorStop(1, shadeColor(type.color, -30));
            ctx.fillStyle = gradient;
            ctx.globalAlpha = pulse;
            ctx.fillRect(screen.x, screen.y, size * gameState.camera.zoom, size * gameState.camera.zoom);
            ctx.globalAlpha = 1;

            // Border
            ctx.strokeStyle = shadeColor(type.color, 30);
            ctx.lineWidth = 2;
            ctx.strokeRect(screen.x, screen.y, size * gameState.camera.zoom, size * gameState.camera.zoom);

            // Veiny texture
            if (gameState.camera.zoom > 0.5) {
                ctx.strokeStyle = `rgba(255, 255, 255, ${0.1 * pulse})`;
                ctx.lineWidth = 1;
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.moveTo(screen.x + Math.random() * size * gameState.camera.zoom, screen.y);
                    ctx.quadraticCurveTo(
                        screen.x + Math.random() * size * gameState.camera.zoom,
                        screen.y + Math.random() * size * gameState.camera.zoom,
                        screen.x + Math.random() * size * gameState.camera.zoom,
                        screen.y + size * gameState.camera.zoom
                    );
                    ctx.stroke();
                }
            }

            // Type-specific details
            if (building.type === 'growthVat' && building.progress !== undefined) {
                const barHeight = 6;
                const barWidth = size * gameState.camera.zoom - 8;
                const barX = screen.x + 4;
                const barY = screen.y + size * gameState.camera.zoom - 10;

                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(barX, barY, barWidth, barHeight);

                ctx.fillStyle = type.color;
                ctx.fillRect(barX, barY, barWidth * (building.progress / 100), barHeight);
            }

            if (building.type === 'artery') {
                // Flowing particles
                const flowOffset = (gameState.time / 100) % 1;
                for (let i = 0; i < 3; i++) {
                    const particlePos = (i / 3 + flowOffset) % 1;
                    const px = screen.x + particlePos * size * gameState.camera.zoom;
                    const py = screen.y + size * gameState.camera.zoom / 2;

                    ctx.fillStyle = 'rgba(255, 200, 200, 0.6)';
                    ctx.beginPath();
                    ctx.arc(px, py, 2 * gameState.camera.zoom, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function drawPlacementGhost(type, x, y) {
            const buildType = BUILDING_TYPES[type];
            const size = buildType.size * TILE_SIZE;
            const screen = worldToScreen(x, y);

            const canPlace = checkCanPlace(x, y, buildType.size);

            ctx.fillStyle = canPlace ? 'rgba(100, 255, 100, 0.3)' : 'rgba(255, 100, 100, 0.3)';
            ctx.fillRect(screen.x, screen.y, size * gameState.camera.zoom, size * gameState.camera.zoom);

            ctx.strokeStyle = canPlace ? '#66ff66' : '#ff6666';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(screen.x, screen.y, size * gameState.camera.zoom, size * gameState.camera.zoom);
            ctx.setLineDash([]);
        }

        function checkCanPlace(x, y, size) {
            const tileSize = size * TILE_SIZE;
            for (let building of gameState.buildings) {
                const buildingSize = BUILDING_TYPES[building.type].size * TILE_SIZE;
                if (!(x + tileSize <= building.x ||
                      x >= building.x + buildingSize ||
                      y + tileSize <= building.y ||
                      y >= building.y + buildingSize)) {
                    return false;
                }
            }
            return true;
        }

        function shadeColor(color, percent) {
            const num = parseInt(color.replace("#", ""), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.min(255, Math.max(0, (num >> 16) + amt));
            const G = Math.min(255, Math.max(0, (num >> 8 & 0x00FF) + amt));
            const B = Math.min(255, Math.max(0, (num & 0x0000FF) + amt));
            return "#" + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }

        // ==============================================
        // GAME LOGIC
        // ==============================================

        function updateProduction(deltaTime) {
            for (let building of gameState.buildings) {
                if (building.type === 'growthVat') {
                    if (!building.progress) building.progress = 0;
                    if (!building.producing) building.producing = 'muscle';

                    building.progress += deltaTime / 30; // ~3 seconds per unit

                    if (building.progress >= 100) {
                        building.progress = 0;
                        gameState.resources[building.producing]++;
                        updateResourceDisplay();
                    }
                }
            }
        }

        function generateContract() {
            const client = CLIENT_TYPES[Math.floor(Math.random() * CLIENT_TYPES.length)];
            const tier = Math.min(5, Math.floor(gameState.resources.reputation / 100) + 1);

            const reqStrength = Math.floor(Math.random() * 200 * tier) + 100;
            const reqDurability = Math.floor(Math.random() * 150 * tier) + 50;
            const reward = Math.floor((reqStrength + reqDurability) * 2.5);
            const time = 120000 + Math.random() * 180000; // 2-5 minutes

            const descriptions = {
                'Military': 'Combat organism for field deployment',
                'Medical': 'Bioengineered organ replacement system',
                'Agricultural': 'Labor organism for industrial farming',
                'Entertainment': 'Exotic creature for private collection',
                'Black Market': 'Custom organism - no questions asked'
            };

            const contract = {
                id: Date.now(),
                client,
                description: descriptions[client],
                requirements: {
                    strength: reqStrength,
                    durability: reqDurability
                },
                reward,
                timeLimit: time,
                timeRemaining: time
            };

            gameState.contracts.push(contract);
            renderContracts();
            addAlert(`New contract from ${client}`, 'info');
        }

        function completeContract(contract) {
            gameState.resources.credits += contract.reward;
            gameState.resources.reputation += 10;
            gameState.contracts = gameState.contracts.filter(c => c.id !== contract.id);
            renderContracts();
            updateResourceDisplay();
            addAlert(`Contract completed! +${contract.reward} credits`, 'info');
        }

        function updateContracts(deltaTime) {
            for (let contract of gameState.contracts) {
                contract.timeRemaining -= deltaTime;
                if (contract.timeRemaining <= 0) {
                    gameState.contracts = gameState.contracts.filter(c => c.id !== contract.id);
                    gameState.resources.reputation = Math.max(0, gameState.resources.reputation - 20);
                    addAlert(`Contract expired! -20 reputation`, 'danger');
                }
            }
            renderContracts();
        }

        function checkHazards() {
            // Random mutation chance
            if (Math.random() < 0.05) {
                addAlert('Mutation detected in growth chamber!', 'warning');
            }

            // Infection spread
            if (gameState.buildings.length > 10 && Math.random() < 0.03) {
                addAlert('Contamination spreading through artery network!', 'danger');
            }

            // Rogue organism
            if (gameState.organisms.length > 5 && Math.random() < 0.02) {
                addAlert('CONTAINMENT BREACH! Organism escaped!', 'danger');
                // Could spawn a hazard entity here
            }
        }

        function openOrganismDesigner() {
            gameState.designer.active = true;
            gameState.designer.components = [];
            document.getElementById('designerModal').classList.add('active');
            document.getElementById('modalOverlay').classList.add('active');
            renderDesigner();
        }

        function closeOrganismDesigner() {
            gameState.designer.active = false;
            document.getElementById('designerModal').classList.remove('active');
            document.getElementById('modalOverlay').classList.remove('active');
        }

        function renderDesigner() {
            const grid = document.getElementById('componentGrid');
            grid.innerHTML = '';

            const bodyPlan = gameState.designer.bodyPlan;
            const slotCount = bodyPlan === 'serpentine' ? 6 : bodyPlan === 'amorphous' ? 4 : 9;

            for (let i = 0; i < slotCount; i++) {
                const slot = document.createElement('div');
                slot.className = 'component-slot';

                if (gameState.designer.components[i]) {
                    slot.classList.add('filled');
                    slot.textContent = gameState.designer.components[i];
                } else {
                    slot.textContent = '+';
                }

                slot.addEventListener('click', () => {
                    // Simple component selector - cycle through available
                    const available = Object.keys(FUSION_RECIPES);
                    const current = gameState.designer.components[i];
                    const currentIndex = available.indexOf(current);
                    const next = available[(currentIndex + 1) % available.length];
                    gameState.designer.components[i] = next;
                    renderDesigner();
                    updateDesignerStats();
                });

                grid.appendChild(slot);
            }

            updateDesignerStats();
        }

        function updateDesignerStats() {
            let strength = 0, flexibility = 0, intelligence = 0, durability = 0;

            for (let component of gameState.designer.components) {
                if (component && FUSION_RECIPES[component]) {
                    const recipe = FUSION_RECIPES[component];
                    strength += recipe.strength || 0;
                    flexibility += recipe.flexibility || 0;
                    intelligence += recipe.intelligence || 0;
                    durability += recipe.durability || 0;
                }
            }

            // Body plan modifiers
            const bodyPlan = gameState.designer.bodyPlan;
            if (bodyPlan === 'bipedal') strength *= 1.2;
            if (bodyPlan === 'quadruped') durability *= 1.2;
            if (bodyPlan === 'winged') flexibility *= 1.3;
            if (bodyPlan === 'serpentine') flexibility *= 1.4;

            // Viability calculation
            const componentCount = gameState.designer.components.filter(c => c).length;
            const viability = Math.min(100, (componentCount / 9) * 100 + (intelligence > 0 ? 20 : 0));

            document.getElementById('designStrength').textContent = Math.floor(strength);
            document.getElementById('designFlexibility').textContent = Math.floor(flexibility);
            document.getElementById('designIntelligence').textContent = Math.floor(intelligence);
            document.getElementById('designDurability').textContent = Math.floor(durability);
            document.getElementById('designViability').textContent = Math.floor(viability) + '%';
        }

        function buildOrganism() {
            const stats = {
                strength: parseInt(document.getElementById('designStrength').textContent),
                durability: parseInt(document.getElementById('designDurability').textContent),
                intelligence: parseInt(document.getElementById('designIntelligence').textContent),
                viability: parseInt(document.getElementById('designViability').textContent)
            };

            if (stats.viability < 30) {
                addAlert('Organism viability too low to build!', 'warning');
                return;
            }

            // Check if this fulfills any contract
            let fulfilled = false;
            for (let contract of gameState.contracts) {
                if (stats.strength >= contract.requirements.strength &&
                    stats.durability >= contract.requirements.durability) {
                    completeContract(contract);
                    fulfilled = true;
                    break;
                }
            }

            if (!fulfilled) {
                addAlert('Organism created but does not fulfill any contract', 'info');
            }

            gameState.organisms.push({
                id: Date.now(),
                bodyPlan: gameState.designer.bodyPlan,
                components: [...gameState.designer.components],
                stats
            });

            closeOrganismDesigner();
        }

        // ==============================================
        // UI UPDATES
        // ==============================================

        function updateResourceDisplay() {
            document.getElementById('muscleCount').textContent = gameState.resources.muscle;
            document.getElementById('boneCount').textContent = gameState.resources.bone;
            document.getElementById('nerveCount').textContent = gameState.resources.nerve;
            document.getElementById('skinCount').textContent = gameState.resources.skin;
            document.getElementById('organCount').textContent = gameState.resources.organ;
            document.getElementById('creditsCount').textContent = gameState.resources.credits;
            document.getElementById('reputationCount').textContent = gameState.resources.reputation;
        }

        function renderContracts() {
            const list = document.getElementById('contractList');
            list.innerHTML = '';

            for (let contract of gameState.contracts) {
                const div = document.createElement('div');
                div.className = 'contract';

                const timeLeft = Math.floor(contract.timeRemaining / 1000);
                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;

                div.innerHTML = `
                    <div class="contract-client">${contract.client}</div>
                    <div class="contract-desc">${contract.description}</div>
                    <div class="contract-desc">Requires: ${contract.requirements.strength} strength, ${contract.requirements.durability} durability</div>
                    <div class="contract-reward">Reward: ${contract.reward} credits</div>
                    <div class="contract-timer">Time: ${minutes}:${seconds.toString().padStart(2, '0')}</div>
                    <button class="contract-btn" onclick="openOrganismDesigner()">DESIGN ORGANISM</button>
                `;

                list.appendChild(div);
            }

            if (gameState.contracts.length === 0) {
                list.innerHTML = '<div style="text-align: center; opacity: 0.5; padding: 20px;">No active contracts</div>';
            }
        }

        function addAlert(message, type = 'info') {
            const alert = { message, type, id: Date.now() };
            gameState.alerts.unshift(alert);

            if (gameState.alerts.length > 5) {
                gameState.alerts = gameState.alerts.slice(0, 5);
            }

            renderAlerts();

            // Auto-remove after 5 seconds
            setTimeout(() => {
                gameState.alerts = gameState.alerts.filter(a => a.id !== alert.id);
                renderAlerts();
            }, 5000);
        }

        function renderAlerts() {
            const list = document.getElementById('alertList');
            list.innerHTML = '';

            for (let alert of gameState.alerts) {
                const div = document.createElement('div');
                div.className = `alert ${alert.type}`;
                div.textContent = alert.message;
                list.appendChild(div);
            }
        }

        // ==============================================
        // INPUT HANDLING
        // ==============================================

        const keys = {};
        let mouseX = 0, mouseY = 0;

        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;

            if (e.key === 'Escape') {
                if (gameState.designer.active) {
                    closeOrganismDesigner();
                } else {
                    gameState.paused = !gameState.paused;
                    document.getElementById('pauseOverlay').classList.toggle('active', gameState.paused);
                }
            }

            if (e.key === ' ') {
                e.preventDefault();
                if (!gameState.designer.active && gameState.started) {
                    openOrganismDesigner();
                }
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        canvas.addEventListener('click', (e) => {
            if (!gameState.started) {
                gameState.started = true;
                document.getElementById('gameTitle').classList.remove('active');
                addAlert('Welcome to FLESH MACHINE. Begin building your foundry.', 'info');
                return;
            }

            if (gameState.buildingPlacement) {
                const world = screenToWorld(e.clientX, e.clientY);
                const gridX = Math.floor(world.x / TILE_SIZE) * TILE_SIZE;
                const gridY = Math.floor(world.y / TILE_SIZE) * TILE_SIZE;

                const type = BUILDING_TYPES[gameState.buildingPlacement];

                if (checkCanPlace(gridX, gridY, type.size)) {
                    if (gameState.resources.credits >= type.cost) {
                        gameState.buildings.push({
                            type: gameState.buildingPlacement,
                            x: gridX,
                            y: gridY,
                            progress: 0
                        });
                        gameState.resources.credits -= type.cost;
                        updateResourceDisplay();
                        addAlert(`${type.name} built`, 'info');
                    } else {
                        addAlert('Not enough credits!', 'warning');
                    }
                }
            }
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            gameState.camera.zoom = Math.max(0.3, Math.min(2, gameState.camera.zoom * zoomFactor));
        });

        // Build menu interaction
        document.querySelectorAll('.build-item').forEach(item => {
            item.addEventListener('click', () => {
                const building = item.dataset.building;

                // Deselect all
                document.querySelectorAll('.build-item').forEach(i => i.classList.remove('selected'));

                if (gameState.buildingPlacement === building) {
                    gameState.buildingPlacement = null;
                } else {
                    item.classList.add('selected');
                    gameState.buildingPlacement = building;
                }
            });
        });

        // Designer controls
        document.getElementById('bodyPlanSelect').addEventListener('change', (e) => {
            gameState.designer.bodyPlan = e.target.value;
            renderDesigner();
        });

        document.getElementById('buildOrganismBtn').addEventListener('click', buildOrganism);
        document.getElementById('cancelDesignBtn').addEventListener('click', closeOrganismDesigner);

        // Pause menu
        document.getElementById('resumeBtn').addEventListener('click', () => {
            gameState.paused = false;
            document.getElementById('pauseOverlay').classList.remove('active');
        });

        document.getElementById('saveBtn').addEventListener('click', () => {
            try {
                localStorage.setItem('fleshMachineSave', JSON.stringify(gameState));
                addAlert('Game saved!', 'info');
            } catch (e) {
                addAlert('Failed to save game', 'danger');
            }
        });

        document.getElementById('loadBtn').addEventListener('click', () => {
            try {
                const save = localStorage.getItem('fleshMachineSave');
                if (save) {
                    const loaded = JSON.parse(save);
                    Object.assign(gameState, loaded);
                    gameState.paused = false;
                    gameState.started = true;
                    document.getElementById('pauseOverlay').classList.remove('active');
                    document.getElementById('gameTitle').classList.remove('active');
                    updateResourceDisplay();
                    renderContracts();
                    addAlert('Game loaded!', 'info');
                } else {
                    addAlert('No save found', 'warning');
                }
            } catch (e) {
                addAlert('Failed to load game', 'danger');
            }
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            if (confirm('Reset entire factory? This cannot be undone!')) {
                localStorage.removeItem('fleshMachineSave');
                location.reload();
            }
        });

        // ==============================================
        // GAME LOOP
        // ==============================================

        let lastTime = Date.now();

        function gameLoop() {
            const now = Date.now();
            const deltaTime = Math.min(now - lastTime, 100);
            lastTime = now;

            if (!gameState.paused && gameState.started) {
                gameState.time += deltaTime;

                // Camera movement
                const cameraSpeed = 5;
                if (keys['w'] || keys['arrowup']) gameState.camera.y -= cameraSpeed;
                if (keys['s'] || keys['arrowdown']) gameState.camera.y += cameraSpeed;
                if (keys['a'] || keys['arrowleft']) gameState.camera.x -= cameraSpeed;
                if (keys['d'] || keys['arrowright']) gameState.camera.x += cameraSpeed;

                // Game updates
                updateProduction(deltaTime);
                updateContracts(deltaTime);

                // Generate new contracts
                if (gameState.time > gameState.nextContractTime) {
                    generateContract();
                    gameState.nextContractTime = gameState.time + 20000 + Math.random() * 30000;
                }

                // Hazard checks
                if (gameState.time > gameState.nextHazardCheck) {
                    checkHazards();
                    gameState.nextHazardCheck = gameState.time + 15000 + Math.random() * 20000;
                }

                // Auto-save every 30 seconds
                if (Math.floor(gameState.time / 30000) > Math.floor((gameState.time - deltaTime) / 30000)) {
                    try {
                        localStorage.setItem('fleshMachineSave', JSON.stringify(gameState));
                    } catch (e) {}
                }
            }

            // Render
            drawBackground();
            drawGrid();

            for (let building of gameState.buildings) {
                drawBuilding(building);
            }

            // Draw placement ghost
            if (gameState.buildingPlacement) {
                const world = screenToWorld(mouseX, mouseY);
                const gridX = Math.floor(world.x / TILE_SIZE) * TILE_SIZE;
                const gridY = Math.floor(world.y / TILE_SIZE) * TILE_SIZE;
                drawPlacementGhost(gameState.buildingPlacement, gridX, gridY);
            }

            requestAnimationFrame(gameLoop);
        }

        // ==============================================
        // AUDIO SYSTEM
        // ==============================================

        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        function playPulseSound() {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();

            osc.connect(gain);
            gain.connect(audioContext.destination);

            osc.frequency.value = 60 + Math.random() * 20;
            osc.type = 'sine';

            gain.gain.setValueAtTime(0.05, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);

            osc.start();
            osc.stop(audioContext.currentTime + 0.5);
        }

        // Ambient pulse every few seconds
        setInterval(() => {
            if (gameState.started && !gameState.paused && Math.random() < 0.3) {
                playPulseSound();
            }
        }, 3000);

        // ==============================================
        // INITIALIZATION
        // ==============================================

        updateResourceDisplay();
        renderContracts();
        renderAlerts();
        gameLoop();

        // Initial buildings for tutorial
        setTimeout(() => {
            if (gameState.started && gameState.buildings.length === 0) {
                addAlert('Build a Growth Vat to start producing tissue', 'info');
            }
        }, 3000);
    </script>
</body>
</html>