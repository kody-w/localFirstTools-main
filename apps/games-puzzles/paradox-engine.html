<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PARADOX ENGINE - Create Time Paradoxes to Break Reality</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #fff;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        #gameCanvas {
            display: block;
            margin: 0 auto;
            background: #0a0a0a;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        .screen {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .screen.active {
            display: flex;
        }

        .title {
            font-size: 48px;
            font-weight: bold;
            margin-bottom: 20px;
            text-align: center;
            background: linear-gradient(45deg, #00f, #f0f, #f00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: shimmer 3s infinite;
        }

        @keyframes shimmer {
            0%, 100% { filter: hue-rotate(0deg); }
            50% { filter: hue-rotate(90deg); }
        }

        .subtitle {
            font-size: 18px;
            margin-bottom: 40px;
            color: #aaa;
            text-align: center;
            max-width: 600px;
        }

        .button {
            padding: 15px 40px;
            font-size: 20px;
            font-family: 'Courier New', monospace;
            background: #222;
            color: #fff;
            border: 2px solid #666;
            cursor: pointer;
            margin: 10px;
            transition: all 0.2s;
        }

        .button:hover {
            background: #444;
            border-color: #0ff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        .level-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 20px;
            max-width: 800px;
            padding: 20px;
        }

        .level-button {
            padding: 20px;
            font-size: 16px;
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #666;
            border: 2px solid #333;
            cursor: not-allowed;
            position: relative;
            transition: all 0.2s;
        }

        .level-button.unlocked {
            color: #fff;
            border-color: #666;
            cursor: pointer;
        }

        .level-button.unlocked:hover {
            background: #333;
            border-color: #0ff;
        }

        .level-button.completed {
            border-color: #0f0;
            background: #1a3a1a;
        }

        .stars {
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 12px;
            color: gold;
        }

        .info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border: 2px solid #444;
            font-size: 14px;
            max-width: 300px;
        }

        .info-panel h3 {
            margin-bottom: 10px;
            color: #0ff;
        }

        .controls-help {
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border: 2px solid #666;
            max-width: 500px;
            text-align: left;
        }

        .controls-help h3 {
            color: #0ff;
            margin-bottom: 10px;
        }

        .controls-help p {
            margin: 5px 0;
            font-size: 14px;
        }

        .reality-crack {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background:
                linear-gradient(90deg, transparent 48%, rgba(255,0,0,0.3) 49%, rgba(255,0,0,0.3) 51%, transparent 52%),
                linear-gradient(45deg, transparent 48%, rgba(255,0,0,0.2) 49%, rgba(255,0,0,0.2) 51%, transparent 52%);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .reality-crack.active {
            opacity: 1;
            animation: crack-pulse 1s infinite;
        }

        @keyframes crack-pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="menuScreen" class="screen active">
        <h1 class="title">PARADOX ENGINE</h1>
        <p class="subtitle">Create Time Paradoxes to Break Reality</p>
        <button class="button" onclick="game.showLevelSelect()">START</button>
        <button class="button" onclick="game.showControls()">CONTROLS</button>
        <button class="button" onclick="game.resetProgress()">RESET PROGRESS</button>
    </div>

    <div id="levelSelectScreen" class="screen">
        <h2 class="title" style="font-size: 36px;">SELECT LEVEL</h2>
        <div class="level-grid" id="levelGrid"></div>
        <button class="button" onclick="game.showMenu()">BACK</button>
    </div>

    <div id="controlsScreen" class="screen">
        <div class="controls-help">
            <h3>CONTROLS</h3>
            <p><strong>WASD / Arrow Keys</strong> - Move</p>
            <p><strong>E</strong> - Interact with objects</p>
            <p><strong>Q</strong> - Use selected item</p>
            <p><strong>1-6</strong> - Select inventory item</p>
            <p><strong>R</strong> - Restart level</p>
            <p><strong>ESC</strong> - Pause / Menu</p>
            <h3 style="margin-top: 20px;">OBJECTIVE</h3>
            <p>Each level is a time loop. Your past actions replay as echoes (blue). Create the correct paradox to shatter reality and complete the level.</p>
            <p style="margin-top: 10px; color: #f00;">Wrong paradoxes tear reality open - avoid the red zones!</p>
        </div>
        <button class="button" onclick="game.showMenu()">BACK</button>
    </div>

    <div id="gameScreen" class="screen">
        <canvas id="gameCanvas"></canvas>
        <div class="reality-crack" id="realityCrack"></div>
    </div>

    <script>
        // ===== AUDIO SYSTEM =====
        class AudioSystem {
            constructor() {
                this.ctx = null;
                this.sounds = {};
                this.enabled = true;
                this.masterGain = null;
                this.init();
            }

            init() {
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.ctx.createGain();
                    this.masterGain.gain.value = 0.3;
                    this.masterGain.connect(this.ctx.destination);
                } catch (e) {
                    console.warn('Web Audio API not supported');
                    this.enabled = false;
                }
            }

            playTick() {
                if (!this.enabled) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.frequency.value = 800;
                gain.gain.value = 0.05;
                osc.start();
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.05);
                osc.stop(this.ctx.currentTime + 0.05);
            }

            playRewind() {
                if (!this.enabled) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.frequency.value = 200;
                osc.frequency.exponentialRampToValueAtTime(50, this.ctx.currentTime + 0.3);
                gain.gain.value = 0.2;
                osc.start();
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);
                osc.stop(this.ctx.currentTime + 0.3);
            }

            playFriction() {
                if (!this.enabled) return;
                const noise = this.ctx.createBufferSource();
                const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.1, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                noise.buffer = buffer;
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.value = 2000;
                const gain = this.ctx.createGain();
                gain.gain.value = 0.1;
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                noise.start();
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1);
            }

            playParadox() {
                if (!this.enabled) return;
                // Deep bass boom
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.frequency.value = 60;
                gain.gain.value = 0.5;
                osc.start();
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1);
                osc.stop(this.ctx.currentTime + 1);

                // Glass shatter
                setTimeout(() => {
                    const noise = this.ctx.createBufferSource();
                    const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.5, this.ctx.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let i = 0; i < data.length; i++) {
                        data[i] = (Math.random() * 2 - 1) * Math.exp(-i / data.length * 5);
                    }
                    noise.buffer = buffer;
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'highpass';
                    filter.frequency.value = 1000;
                    const gain2 = this.ctx.createGain();
                    gain2.gain.value = 0.3;
                    noise.connect(filter);
                    filter.connect(gain2);
                    gain2.connect(this.masterGain);
                    noise.start();
                }, 200);
            }

            playSuccess() {
                if (!this.enabled) return;
                const freqs = [261.63, 329.63, 392.00, 523.25]; // C E G C
                freqs.forEach((freq, i) => {
                    setTimeout(() => {
                        const osc = this.ctx.createOscillator();
                        const gain = this.ctx.createGain();
                        osc.connect(gain);
                        gain.connect(this.masterGain);
                        osc.frequency.value = freq;
                        gain.gain.value = 0.2;
                        osc.start();
                        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.5);
                        osc.stop(this.ctx.currentTime + 0.5);
                    }, i * 150);
                });
            }

            playAmbient() {
                if (!this.enabled) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const lfo = this.ctx.createOscillator();
                const lfoGain = this.ctx.createGain();

                lfo.frequency.value = 0.2;
                lfoGain.gain.value = 30;
                lfo.connect(lfoGain);
                lfoGain.connect(osc.frequency);

                osc.type = 'sine';
                osc.frequency.value = 100;
                gain.gain.value = 0.05;

                osc.connect(gain);
                gain.connect(this.masterGain);

                lfo.start();
                osc.start();

                this.ambientOsc = osc;
                this.ambientLfo = lfo;
            }

            stopAmbient() {
                if (this.ambientOsc) {
                    this.ambientOsc.stop();
                    this.ambientLfo.stop();
                }
            }
        }

        // ===== LEVEL DEFINITIONS =====
        const LEVELS = [
            {
                id: 1,
                name: "The Door",
                description: "Past you opens a door. Stand in the doorway to create a paradox.",
                loopDuration: 30,
                width: 10,
                height: 10,
                objects: [
                    { type: 'door', x: 5, y: 3, state: 'closed' },
                    { type: 'button', x: 7, y: 5, target: 'door' }
                ],
                goal: { type: 'door_paradox', check: (level) => {
                    const door = level.objects.find(o => o.type === 'door');
                    const player = level.player;
                    return door.state === 'open' &&
                           Math.abs(player.x - door.x) < 0.5 &&
                           Math.abs(player.y - door.y) < 0.5 &&
                           level.iteration > 1;
                }}
            },
            {
                id: 2,
                name: "The Key",
                description: "Bootstrap paradox: Give past self the key that past self gives you.",
                loopDuration: 40,
                width: 12,
                height: 10,
                objects: [
                    { type: 'key', x: 2, y: 5, collected: false },
                    { type: 'slot', x: 10, y: 5 }
                ],
                goal: { type: 'bootstrap', check: (level) => {
                    return level.iteration > 2 && level.bootstrapAchieved;
                }}
            },
            {
                id: 3,
                name: "The Observer",
                description: "Two plates must be pressed simultaneously. Observer paradox.",
                loopDuration: 35,
                width: 12,
                height: 8,
                objects: [
                    { type: 'plate', x: 3, y: 4, pressed: false, id: 'plate1' },
                    { type: 'plate', x: 9, y: 4, pressed: false, id: 'plate2' }
                ],
                goal: { type: 'simultaneous', check: (level) => {
                    const plate1 = level.objects.find(o => o.id === 'plate1');
                    const plate2 = level.objects.find(o => o.id === 'plate2');
                    return plate1.pressed && plate2.pressed && level.iteration > 1;
                }}
            },
            {
                id: 4,
                name: "Grandfather's Clock",
                description: "Stop the clock before it strikes, but the strike warns you.",
                loopDuration: 45,
                width: 14,
                height: 10,
                objects: [
                    { type: 'clock', x: 7, y: 3, strikeTime: 35, stopped: false },
                    { type: 'lever', x: 7, y: 7, target: 'clock' }
                ],
                goal: { type: 'grandfather', check: (level) => {
                    const clock = level.objects.find(o => o.type === 'clock');
                    return level.iteration > 1 && clock.stopped && level.paradoxTriggered;
                }}
            },
            {
                id: 5,
                name: "The Letter",
                description: "Read a letter that tells you to destroy it before reading.",
                loopDuration: 50,
                width: 12,
                height: 12,
                objects: [
                    { type: 'letter', x: 6, y: 3, read: false, destroyed: false },
                    { type: 'incinerator', x: 6, y: 9 }
                ],
                goal: { type: 'letter_paradox', check: (level) => {
                    const letter = level.objects.find(o => o.type === 'letter');
                    return letter.read && letter.destroyed && level.iteration > 1;
                }}
            },
            {
                id: 6,
                name: "Split Path",
                description: "Two corridors. You must go left AND right simultaneously.",
                loopDuration: 40,
                width: 16,
                height: 10,
                objects: [
                    { type: 'detector', x: 4, y: 5, id: 'left', detected: false },
                    { type: 'detector', x: 12, y: 5, id: 'right', detected: false }
                ],
                goal: { type: 'split_path', check: (level) => {
                    const left = level.objects.find(o => o.id === 'left');
                    const right = level.objects.find(o => o.id === 'right');
                    return left.detected && right.detected && level.iteration > 1;
                }}
            },
            {
                id: 7,
                name: "The Alarm",
                description: "Disable the alarm, but future you's alarm alerts you to it.",
                loopDuration: 55,
                width: 14,
                height: 10,
                objects: [
                    { type: 'alarm', x: 7, y: 3, triggerTime: 40, disabled: false },
                    { type: 'panel', x: 7, y: 7, target: 'alarm' }
                ],
                goal: { type: 'alarm_paradox', check: (level) => {
                    const alarm = level.objects.find(o => o.type === 'alarm');
                    return level.iteration > 1 && alarm.disabled && level.paradoxTriggered;
                }}
            },
            {
                id: 8,
                name: "Echo Chamber",
                description: "Four switches need four people. You must be all four.",
                loopDuration: 60,
                width: 16,
                height: 16,
                objects: [
                    { type: 'switch', x: 4, y: 4, held: false, id: 's1' },
                    { type: 'switch', x: 12, y: 4, held: false, id: 's2' },
                    { type: 'switch', x: 4, y: 12, held: false, id: 's3' },
                    { type: 'switch', x: 12, y: 12, held: false, id: 's4' }
                ],
                goal: { type: 'four_switches', check: (level) => {
                    const switches = level.objects.filter(o => o.type === 'switch');
                    return switches.every(s => s.held) && level.iteration >= 3;
                }}
            },
            {
                id: 9,
                name: "Causality Chain",
                description: "Break a 5-iteration cause-effect chain.",
                loopDuration: 50,
                width: 20,
                height: 10,
                objects: [
                    { type: 'chain_link', x: 4, y: 5, stage: 1, activated: false },
                    { type: 'chain_link', x: 8, y: 5, stage: 2, activated: false },
                    { type: 'chain_link', x: 12, y: 5, stage: 3, activated: false },
                    { type: 'chain_link', x: 16, y: 5, stage: 4, activated: false },
                    { type: 'chain_breaker', x: 10, y: 8 }
                ],
                goal: { type: 'chain_break', check: (level) => {
                    return level.iteration >= 5 && level.chainBroken;
                }}
            },
            {
                id: 10,
                name: "The Witness",
                description: "Observe an event that only happens if unobserved.",
                loopDuration: 45,
                width: 14,
                height: 12,
                objects: [
                    { type: 'quantum_box', x: 7, y: 6, observed: false, state: 'superposition' },
                    { type: 'camera', x: 7, y: 3 }
                ],
                goal: { type: 'observer_paradox', check: (level) => {
                    const box = level.objects.find(o => o.type === 'quantum_box');
                    return box.observed && box.state === 'unobserved_state' && level.iteration > 1;
                }}
            },
            {
                id: 11,
                name: "Time Bomb",
                description: "Defuse using instructions from future you who watched you defuse it.",
                loopDuration: 60,
                width: 12,
                height: 12,
                objects: [
                    { type: 'bomb', x: 6, y: 6, code: [3, 1, 4, 1], defused: false },
                    { type: 'note', x: 6, y: 9, hasCode: false }
                ],
                goal: { type: 'time_bomb', check: (level) => {
                    const bomb = level.objects.find(o => o.type === 'bomb');
                    return bomb.defused && level.iteration > 1 && level.bootstrapAchieved;
                }}
            },
            {
                id: 12,
                name: "The Meeting",
                description: "All 5 versions of you in the same room simultaneously.",
                loopDuration: 70,
                width: 18,
                height: 14,
                objects: [
                    { type: 'meeting_zone', x: 9, y: 7, radius: 3, count: 0 }
                ],
                goal: { type: 'meeting', check: (level) => {
                    const zone = level.objects.find(o => o.type === 'meeting_zone');
                    return zone.count >= 5 && level.iteration >= 4;
                }}
            },
            {
                id: 13,
                name: "Entropy",
                description: "An object decays to dust. Make it new without reversing time.",
                loopDuration: 60,
                width: 14,
                height: 10,
                objects: [
                    { type: 'decaying_object', x: 7, y: 5, age: 0, maxAge: 50 },
                    { type: 'entropy_eraser', x: 3, y: 5, charges: 1 }
                ],
                goal: { type: 'entropy', check: (level) => {
                    const obj = level.objects.find(o => o.type === 'decaying_object');
                    return obj.age > 40 && level.entropyReversed && level.iteration > 1;
                }}
            },
            {
                id: 14,
                name: "The Promise",
                description: "Promise past self something, then break it. Trust paradox.",
                loopDuration: 55,
                width: 12,
                height: 12,
                objects: [
                    { type: 'promise_point', x: 6, y: 4, promised: false },
                    { type: 'betrayal_point', x: 6, y: 8, betrayed: false }
                ],
                goal: { type: 'promise', check: (level) => {
                    const promise = level.objects.find(o => o.type === 'promise_point');
                    const betrayal = level.objects.find(o => o.type === 'betrayal_point');
                    return promise.promised && betrayal.betrayed && level.iteration > 2;
                }}
            },
            {
                id: 15,
                name: "Recursion",
                description: "A loop within a loop. Inner resets every 10 seconds.",
                loopDuration: 60,
                width: 16,
                height: 16,
                innerLoop: 10,
                objects: [
                    { type: 'inner_zone', x: 8, y: 8, radius: 4 },
                    { type: 'sync_point', x: 8, y: 8 }
                ],
                goal: { type: 'recursion', check: (level) => {
                    return level.iteration > 2 && level.recursionParadox;
                }}
            },
            {
                id: 16,
                name: "The Machine",
                description: "Build a machine across iterations. Final part was the first.",
                loopDuration: 70,
                width: 18,
                height: 12,
                objects: [
                    { type: 'machine_base', x: 9, y: 6, parts: [] },
                    { type: 'part', x: 4, y: 6, id: 'part1', placed: false },
                    { type: 'part', x: 14, y: 6, id: 'part2', placed: false },
                    { type: 'part', x: 9, y: 3, id: 'part3', placed: false },
                    { type: 'part', x: 9, y: 9, id: 'part4', placed: false }
                ],
                goal: { type: 'machine', check: (level) => {
                    const machine = level.objects.find(o => o.type === 'machine_base');
                    return machine.parts.length === 4 && level.bootstrapAchieved && level.iteration >= 4;
                }}
            },
            {
                id: 17,
                name: "Free Will",
                description: "Future ghost shows your every move. Do what it doesn't predict.",
                loopDuration: 50,
                width: 16,
                height: 12,
                objects: [
                    { type: 'prediction_zone', x: 8, y: 6, radius: 5 }
                ],
                goal: { type: 'free_will', check: (level) => {
                    return level.iteration > 1 && level.freeWillBroken;
                }}
            },
            {
                id: 18,
                name: "Schrödinger's Room",
                description: "Room is destroyed AND intact. Collapse while both are observed.",
                loopDuration: 60,
                width: 16,
                height: 16,
                objects: [
                    { type: 'quantum_room', x: 8, y: 8, state: 'both', observed: false },
                    { type: 'observer_a', x: 4, y: 8, watching: false },
                    { type: 'observer_b', x: 12, y: 8, watching: false }
                ],
                goal: { type: 'schrodinger', check: (level) => {
                    const room = level.objects.find(o => o.type === 'quantum_room');
                    const obsA = level.objects.find(o => o.type === 'observer_a');
                    const obsB = level.objects.find(o => o.type === 'observer_b');
                    return obsA.watching && obsB.watching && room.state !== 'both' && level.iteration > 1;
                }}
            },
            {
                id: 19,
                name: "The Engine",
                description: "You ARE the paradox engine. Create a self-sustaining paradox.",
                loopDuration: 80,
                width: 20,
                height: 20,
                objects: [
                    { type: 'paradox_core', x: 10, y: 10, energy: 0 },
                    { type: 'feedback_loop', x: 6, y: 6, active: false },
                    { type: 'feedback_loop', x: 14, y: 6, active: false },
                    { type: 'feedback_loop', x: 6, y: 14, active: false },
                    { type: 'feedback_loop', x: 14, y: 14, active: false }
                ],
                goal: { type: 'engine', check: (level) => {
                    const core = level.objects.find(o => o.type === 'paradox_core');
                    const loops = level.objects.filter(o => o.type === 'feedback_loop');
                    return core.energy >= 100 && loops.every(l => l.active) && level.iteration >= 5;
                }}
            },
            {
                id: 20,
                name: "Exit",
                description: "The game can only end if it never started. Break the meta-loop.",
                loopDuration: 90,
                width: 24,
                height: 20,
                objects: [
                    { type: 'start_point', x: 12, y: 18, exists: true },
                    { type: 'end_point', x: 12, y: 2, exists: true },
                    { type: 'meta_eraser', x: 12, y: 10 }
                ],
                goal: { type: 'meta', check: (level) => {
                    const start = level.objects.find(o => o.type === 'start_point');
                    const end = level.objects.find(o => o.type === 'end_point');
                    return !start.exists && end.exists && level.iteration > 1;
                }}
            }
        ];

        // ===== GAME ENGINE =====
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.audio = new AudioSystem();

                this.screens = {
                    menu: document.getElementById('menuScreen'),
                    levelSelect: document.getElementById('levelSelectScreen'),
                    controls: document.getElementById('controlsScreen'),
                    game: document.getElementById('gameScreen')
                };

                this.currentLevel = null;
                this.levelState = null;
                this.keys = {};
                this.paused = false;
                this.realityCrack = document.getElementById('realityCrack');

                this.loadProgress();
                this.setupCanvas();
                this.setupInput();
                this.populateLevelGrid();

                this.lastFrameTime = 0;
                this.requestId = null;
            }

            setupCanvas() {
                const size = Math.min(window.innerWidth, window.innerHeight) - 20;
                this.canvas.width = size;
                this.canvas.height = size;
            }

            setupInput() {
                window.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;

                    if (e.key === 'Escape') {
                        if (this.currentLevel) {
                            this.showMenu();
                        }
                    }

                    if (e.key.toLowerCase() === 'r' && this.currentLevel) {
                        this.restartLevel();
                    }
                });

                window.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });
            }

            loadProgress() {
                const saved = localStorage.getItem('paradoxEngineProgress');
                if (saved) {
                    this.progress = JSON.parse(saved);
                } else {
                    this.progress = {
                        unlockedLevels: 1,
                        completedLevels: {},
                        stars: {}
                    };
                }
            }

            saveProgress() {
                localStorage.setItem('paradoxEngineProgress', JSON.stringify(this.progress));
            }

            resetProgress() {
                if (confirm('Reset all progress? This cannot be undone.')) {
                    localStorage.removeItem('paradoxEngineProgress');
                    this.progress = {
                        unlockedLevels: 1,
                        completedLevels: {},
                        stars: {}
                    };
                    this.populateLevelGrid();
                }
            }

            populateLevelGrid() {
                const grid = document.getElementById('levelGrid');
                grid.innerHTML = '';

                LEVELS.forEach((level, idx) => {
                    const btn = document.createElement('button');
                    btn.className = 'level-button';
                    btn.textContent = `${level.id}\n${level.name}`;

                    const unlocked = level.id <= this.progress.unlockedLevels;
                    const completed = this.progress.completedLevels[level.id];
                    const stars = this.progress.stars[level.id] || 0;

                    if (unlocked) {
                        btn.classList.add('unlocked');
                        btn.onclick = () => this.startLevel(level.id);
                    }

                    if (completed) {
                        btn.classList.add('completed');
                    }

                    if (stars > 0) {
                        const starDiv = document.createElement('div');
                        starDiv.className = 'stars';
                        starDiv.textContent = '★'.repeat(stars);
                        btn.appendChild(starDiv);
                    }

                    grid.appendChild(btn);
                });
            }

            showScreen(name) {
                Object.values(this.screens).forEach(s => s.classList.remove('active'));
                this.screens[name].classList.add('active');
            }

            showMenu() {
                this.showScreen('menu');
                if (this.requestId) {
                    cancelAnimationFrame(this.requestId);
                }
                this.audio.stopAmbient();
            }

            showLevelSelect() {
                this.showScreen('levelSelect');
            }

            showControls() {
                this.showScreen('controls');
            }

            startLevel(levelId) {
                const levelDef = LEVELS.find(l => l.id === levelId);
                if (!levelDef) return;

                this.currentLevel = levelDef;
                this.levelState = new LevelState(levelDef);
                this.showScreen('game');
                this.audio.playAmbient();
                this.gameLoop();
            }

            restartLevel() {
                if (this.currentLevel) {
                    this.levelState = new LevelState(this.currentLevel);
                    this.audio.playRewind();
                }
            }

            completeLevel(stars) {
                this.progress.completedLevels[this.currentLevel.id] = true;
                this.progress.stars[this.currentLevel.id] = Math.max(
                    this.progress.stars[this.currentLevel.id] || 0,
                    stars
                );
                this.progress.unlockedLevels = Math.max(
                    this.progress.unlockedLevels,
                    this.currentLevel.id + 1
                );
                this.saveProgress();
                this.audio.playSuccess();

                setTimeout(() => {
                    this.showLevelSelect();
                    this.populateLevelGrid();
                }, 2000);
            }

            gameLoop(timestamp = 0) {
                const dt = Math.min((timestamp - this.lastFrameTime) / 1000, 0.1);
                this.lastFrameTime = timestamp;

                if (!this.paused && this.levelState) {
                    this.levelState.update(dt, this.keys, this.audio);
                    this.levelState.render(this.ctx, this.canvas.width, this.canvas.height);

                    if (this.levelState.realityHealth < 0.5) {
                        this.realityCrack.classList.add('active');
                    } else {
                        this.realityCrack.classList.remove('active');
                    }

                    if (this.levelState.completed) {
                        const stars = this.levelState.calculateStars();
                        this.completeLevel(stars);
                        return;
                    }
                }

                this.requestId = requestAnimationFrame((t) => this.gameLoop(t));
            }
        }

        // ===== LEVEL STATE =====
        class LevelState {
            constructor(levelDef) {
                this.def = levelDef;
                this.iteration = 0;
                this.loopTime = 0;
                this.maxLoopTime = levelDef.loopDuration;

                this.player = {
                    x: levelDef.width / 2,
                    y: levelDef.height - 2,
                    vx: 0,
                    vy: 0,
                    speed: 3,
                    radius: 0.3,
                    inventory: []
                };

                this.objects = JSON.parse(JSON.stringify(levelDef.objects));
                this.echoes = [];
                this.recording = [];
                this.completed = false;
                this.realityHealth = 1.0;
                this.paradoxTriggered = false;
                this.bootstrapAchieved = false;
                this.chainBroken = false;
                this.entropyReversed = false;
                this.recursionParadox = false;
                this.freeWillBroken = false;

                this.particles = [];
                this.lastTickTime = 0;
            }

            update(dt, keys, audio) {
                this.loopTime += dt;

                // Tick sound
                if (this.loopTime - this.lastTickTime > 1) {
                    audio.playTick();
                    this.lastTickTime = this.loopTime;
                }

                // Loop reset
                if (this.loopTime >= this.maxLoopTime) {
                    this.resetLoop(audio);
                }

                // Update player movement
                this.player.vx = 0;
                this.player.vy = 0;

                if (keys['w'] || keys['arrowup']) this.player.vy = -1;
                if (keys['s'] || keys['arrowdown']) this.player.vy = 1;
                if (keys['a'] || keys['arrowleft']) this.player.vx = -1;
                if (keys['d'] || keys['arrowright']) this.player.vx = 1;

                const len = Math.sqrt(this.player.vx ** 2 + this.player.vy ** 2);
                if (len > 0) {
                    this.player.vx /= len;
                    this.player.vy /= len;
                }

                this.player.x += this.player.vx * this.player.speed * dt;
                this.player.y += this.player.vy * this.player.speed * dt;

                // Clamp to bounds
                this.player.x = Math.max(this.player.radius, Math.min(this.def.width - this.player.radius, this.player.x));
                this.player.y = Math.max(this.player.radius, Math.min(this.def.height - this.player.radius, this.player.y));

                // Record position
                this.recording.push({
                    x: this.player.x,
                    y: this.player.y,
                    time: this.loopTime
                });

                // Update echoes
                this.echoes.forEach(echo => {
                    const frame = echo.recording.find(f => Math.abs(f.time - this.loopTime) < dt);
                    if (frame) {
                        echo.x = frame.x;
                        echo.y = frame.y;

                        // Check collision with player (temporal friction)
                        const dist = Math.sqrt((echo.x - this.player.x) ** 2 + (echo.y - this.player.y) ** 2);
                        if (dist < this.player.radius * 2) {
                            audio.playFriction();
                            this.addParticles(this.player.x, this.player.y, '#0ff', 5);
                        }
                    }
                });

                // Update objects and check interactions
                this.updateObjects(keys, audio);

                // Check goal
                if (this.def.goal.check(this)) {
                    this.triggerParadox(audio);
                }

                // Update particles
                this.particles = this.particles.filter(p => {
                    p.vx *= 0.98;
                    p.vy *= 0.98;
                    p.x += p.vx * dt;
                    p.y += p.vy * dt;
                    p.life -= dt;
                    return p.life > 0;
                });
            }

            updateObjects(keys, audio) {
                const interactKey = keys['e'];

                this.objects.forEach(obj => {
                    const dist = Math.sqrt((obj.x - this.player.x) ** 2 + (obj.y - this.player.y) ** 2);

                    // Type-specific logic
                    switch (obj.type) {
                        case 'button':
                            if (dist < 0.8 && interactKey) {
                                const door = this.objects.find(o => o.type === 'door');
                                if (door) door.state = door.state === 'open' ? 'closed' : 'open';
                            }
                            break;

                        case 'plate':
                            obj.pressed = dist < 0.6;
                            this.echoes.forEach(echo => {
                                const eDist = Math.sqrt((obj.x - echo.x) ** 2 + (obj.y - echo.y) ** 2);
                                if (eDist < 0.6) obj.pressed = true;
                            });
                            break;

                        case 'key':
                            if (!obj.collected && dist < 0.6) {
                                obj.collected = true;
                                this.player.inventory.push('key');
                            }
                            break;

                        case 'slot':
                            if (dist < 0.8 && interactKey && this.player.inventory.includes('key')) {
                                this.bootstrapAchieved = true;
                            }
                            break;

                        case 'clock':
                            if (this.loopTime >= obj.strikeTime && !obj.stopped) {
                                this.paradoxTriggered = true;
                            }
                            break;

                        case 'lever':
                            if (dist < 0.8 && interactKey) {
                                const clock = this.objects.find(o => o.type === 'clock');
                                if (clock) clock.stopped = true;
                            }
                            break;

                        case 'switch':
                            obj.held = dist < 0.6;
                            this.echoes.forEach(echo => {
                                const eDist = Math.sqrt((obj.x - echo.x) ** 2 + (obj.y - echo.y) ** 2);
                                if (eDist < 0.6) obj.held = true;
                            });
                            break;

                        case 'meeting_zone':
                            obj.count = 0;
                            if (dist < obj.radius) obj.count++;
                            this.echoes.forEach(echo => {
                                const eDist = Math.sqrt((obj.x - echo.x) ** 2 + (obj.y - echo.y) ** 2);
                                if (eDist < obj.radius) obj.count++;
                            });
                            break;

                        case 'decaying_object':
                            obj.age = this.loopTime;
                            break;

                        case 'entropy_eraser':
                            if (dist < 0.8 && interactKey && obj.charges > 0) {
                                const decaying = this.objects.find(o => o.type === 'decaying_object');
                                if (decaying) {
                                    this.entropyReversed = true;
                                    obj.charges--;
                                }
                            }
                            break;
                    }
                });
            }

            resetLoop(audio) {
                audio.playRewind();
                this.iteration++;
                this.loopTime = 0;
                this.lastTickTime = 0;

                // Save current recording as echo
                if (this.recording.length > 0) {
                    this.echoes.push({
                        recording: [...this.recording],
                        x: this.recording[0].x,
                        y: this.recording[0].y,
                        iteration: this.iteration - 1
                    });
                }

                // Keep only last 5 echoes
                if (this.echoes.length > 5) {
                    this.echoes.shift();
                }

                this.recording = [];

                // Reset player position
                this.player.x = this.def.width / 2;
                this.player.y = this.def.height - 2;

                // Reset some object states (depends on type)
                this.objects.forEach(obj => {
                    if (obj.type === 'plate') obj.pressed = false;
                    if (obj.type === 'switch') obj.held = false;
                });
            }

            triggerParadox(audio) {
                if (this.completed) return;

                audio.playParadox();
                this.completed = true;

                // Reality fracture effect
                for (let i = 0; i < 100; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 5 + 2;
                    this.particles.push({
                        x: this.player.x,
                        y: this.player.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        color: `hsl(${Math.random() * 360}, 100%, 50%)`,
                        life: 2
                    });
                }
            }

            addParticles(x, y, color, count) {
                for (let i = 0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 2 + 0.5;
                    this.particles.push({
                        x, y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        color,
                        life: 0.5
                    });
                }
            }

            calculateStars() {
                // 1 star: completed
                // 2 stars: completed in optimal iterations
                // 3 stars: completed in optimal iterations with no wrong paradoxes
                let stars = 1;

                const optimalIterations = {
                    1: 2, 2: 3, 3: 2, 4: 2, 5: 2,
                    6: 2, 7: 2, 8: 4, 9: 5, 10: 2,
                    11: 2, 12: 5, 13: 2, 14: 3, 15: 3,
                    16: 5, 17: 2, 18: 2, 19: 6, 20: 2
                };

                if (this.iteration <= optimalIterations[this.def.id]) {
                    stars = 2;
                }

                if (this.realityHealth > 0.8) {
                    stars = 3;
                }

                return stars;
            }

            render(ctx, canvasWidth, canvasHeight) {
                ctx.fillStyle = '#0a0a0a';
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);

                const cellSize = Math.min(
                    canvasWidth / this.def.width,
                    (canvasHeight - 100) / this.def.height
                );

                const offsetX = (canvasWidth - this.def.width * cellSize) / 2;
                const offsetY = 80;

                // Grid
                ctx.strokeStyle = '#1a1a1a';
                ctx.lineWidth = 1;
                for (let x = 0; x <= this.def.width; x++) {
                    ctx.beginPath();
                    ctx.moveTo(offsetX + x * cellSize, offsetY);
                    ctx.lineTo(offsetX + x * cellSize, offsetY + this.def.height * cellSize);
                    ctx.stroke();
                }
                for (let y = 0; y <= this.def.height; y++) {
                    ctx.beginPath();
                    ctx.moveTo(offsetX, offsetY + y * cellSize);
                    ctx.lineTo(offsetX + this.def.width * cellSize, offsetY + y * cellSize);
                    ctx.stroke();
                }

                // Objects
                this.objects.forEach(obj => {
                    const x = offsetX + obj.x * cellSize;
                    const y = offsetY + obj.y * cellSize;

                    switch (obj.type) {
                        case 'door':
                            ctx.fillStyle = obj.state === 'open' ? '#0a0a0a' : '#666';
                            ctx.fillRect(x - cellSize * 0.4, y - cellSize * 0.6, cellSize * 0.8, cellSize * 1.2);
                            break;

                        case 'button':
                            ctx.fillStyle = '#f00';
                            ctx.beginPath();
                            ctx.arc(x, y, cellSize * 0.2, 0, Math.PI * 2);
                            ctx.fill();
                            break;

                        case 'plate':
                            ctx.fillStyle = obj.pressed ? '#0f0' : '#444';
                            ctx.fillRect(x - cellSize * 0.4, y - cellSize * 0.4, cellSize * 0.8, cellSize * 0.8);
                            break;

                        case 'key':
                            if (!obj.collected) {
                                ctx.fillStyle = '#ff0';
                                ctx.fillRect(x - cellSize * 0.2, y - cellSize * 0.2, cellSize * 0.4, cellSize * 0.4);
                            }
                            break;

                        case 'slot':
                            ctx.strokeStyle = '#ff0';
                            ctx.lineWidth = 2;
                            ctx.strokeRect(x - cellSize * 0.3, y - cellSize * 0.3, cellSize * 0.6, cellSize * 0.6);
                            break;

                        case 'clock':
                            ctx.fillStyle = obj.stopped ? '#666' : '#fff';
                            ctx.beginPath();
                            ctx.arc(x, y, cellSize * 0.4, 0, Math.PI * 2);
                            ctx.fill();
                            break;

                        case 'lever':
                            ctx.fillStyle = '#f80';
                            ctx.fillRect(x - cellSize * 0.1, y - cellSize * 0.5, cellSize * 0.2, cellSize);
                            break;

                        case 'switch':
                            ctx.fillStyle = obj.held ? '#0f0' : '#444';
                            ctx.beginPath();
                            ctx.arc(x, y, cellSize * 0.3, 0, Math.PI * 2);
                            ctx.fill();
                            break;

                        case 'meeting_zone':
                            ctx.strokeStyle = '#f0f';
                            ctx.lineWidth = 2;
                            ctx.setLineDash([5, 5]);
                            ctx.beginPath();
                            ctx.arc(x, y, obj.radius * cellSize, 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.setLineDash([]);
                            break;

                        case 'decaying_object':
                            const decay = obj.age / obj.maxAge;
                            ctx.fillStyle = `rgba(255, 255, 255, ${1 - decay})`;
                            ctx.fillRect(x - cellSize * 0.3, y - cellSize * 0.3, cellSize * 0.6, cellSize * 0.6);
                            break;

                        default:
                            ctx.fillStyle = '#888';
                            ctx.fillRect(x - cellSize * 0.3, y - cellSize * 0.3, cellSize * 0.6, cellSize * 0.6);
                    }
                });

                // Echoes (past selves)
                this.echoes.forEach((echo, idx) => {
                    const alpha = 1 - (idx / this.echoes.length) * 0.5;
                    const blue = 255 - (idx * 40);
                    ctx.fillStyle = `rgba(0, ${blue}, 255, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(
                        offsetX + echo.x * cellSize,
                        offsetY + echo.y * cellSize,
                        this.player.radius * cellSize,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();

                    // Label
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.5})`;
                    ctx.font = '10px monospace';
                    ctx.fillText(
                        `T-${this.echoes.length - idx}`,
                        offsetX + echo.x * cellSize - 12,
                        offsetY + echo.y * cellSize - this.player.radius * cellSize - 5
                    );
                });

                // Player
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(
                    offsetX + this.player.x * cellSize,
                    offsetY + this.player.y * cellSize,
                    this.player.radius * cellSize,
                    0,
                    Math.PI * 2
                );
                ctx.fill();

                // Particles
                this.particles.forEach(p => {
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.life / 2;
                    ctx.beginPath();
                    ctx.arc(
                        offsetX + p.x * cellSize,
                        offsetY + p.y * cellSize,
                        3,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                });
                ctx.globalAlpha = 1;

                // Timeline bar
                const timelineY = 20;
                const timelineWidth = canvasWidth - 40;
                const progress = this.loopTime / this.maxLoopTime;

                ctx.fillStyle = '#222';
                ctx.fillRect(20, timelineY, timelineWidth, 30);
                ctx.fillStyle = '#0ff';
                ctx.fillRect(20, timelineY, timelineWidth * progress, 30);

                ctx.strokeStyle = '#666';
                ctx.lineWidth = 2;
                ctx.strokeRect(20, timelineY, timelineWidth, 30);

                ctx.fillStyle = '#fff';
                ctx.font = '14px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(
                    `${this.loopTime.toFixed(1)}s / ${this.maxLoopTime}s`,
                    canvasWidth / 2,
                    timelineY + 20
                );

                // Info
                ctx.textAlign = 'left';
                ctx.fillText(`Level ${this.def.id}: ${this.def.name}`, 20, canvasHeight - 60);
                ctx.fillText(`Iteration: ${this.iteration}`, 20, canvasHeight - 40);
                ctx.fillText(`Echoes: ${this.echoes.length}`, 20, canvasHeight - 20);

                ctx.textAlign = 'right';
                ctx.fillText(this.def.description, canvasWidth - 20, canvasHeight - 40);

                // Reality health
                const healthColor = this.realityHealth > 0.5 ? '#0f0' : '#f00';
                ctx.fillStyle = healthColor;
                ctx.fillText(`Reality: ${(this.realityHealth * 100).toFixed(0)}%`, canvasWidth - 20, canvasHeight - 20);

                // Completion effect
                if (this.completed) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(0, 0, canvasWidth, canvasHeight);

                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 48px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('REALITY FRACTURED', canvasWidth / 2, canvasHeight / 2);

                    ctx.font = '24px monospace';
                    ctx.fillText('PARADOX SUCCESSFUL', canvasWidth / 2, canvasHeight / 2 + 50);
                }
            }
        }

        // ===== INITIALIZE =====
        const game = new Game();
    </script>
</body>
</html>