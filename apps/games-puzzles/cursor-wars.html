<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CURSOR WARS - Cross-Tab Battle Arena</title>
    <meta name="description" content="Your mouse cursor IS your character. Battle enemies across browser tabs. Open multiple instances for the full experience.">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            cursor: none !important;
        }

        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #16213e 100%);
            user-select: none;
        }

        #game-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .hud {
            position: fixed;
            z-index: 100;
            color: #fff;
            font-size: 14px;
            pointer-events: none;
        }

        #stats {
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            padding: 15px 20px;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        #stats h2 {
            font-size: 18px;
            margin-bottom: 10px;
            color: #00ff88;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #stats .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            gap: 20px;
        }

        #stats .label {
            color: #888;
        }

        #stats .value {
            font-weight: bold;
            font-family: monospace;
        }

        .health-bar {
            width: 150px;
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 5px;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ff8844, #44ff88);
            transition: width 0.3s;
        }

        #tab-indicator {
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            padding: 10px 15px;
            border-radius: 8px;
            border: 2px solid;
            text-align: center;
        }

        #instructions {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 15px 25px;
            border-radius: 10px;
            text-align: center;
            max-width: 600px;
        }

        #instructions h3 {
            color: #00ff88;
            margin-bottom: 10px;
        }

        #instructions p {
            color: #aaa;
            line-height: 1.5;
        }

        #instructions kbd {
            background: #333;
            padding: 2px 8px;
            border-radius: 4px;
            margin: 0 3px;
        }

        #death-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(100,0,0,0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            cursor: default !important;
        }

        #death-screen h1 {
            font-size: 72px;
            color: #ff0000;
            text-shadow: 0 0 30px #ff0000;
            margin-bottom: 20px;
        }

        #death-screen p {
            color: #fff;
            font-size: 24px;
            margin-bottom: 30px;
        }

        #death-screen button {
            padding: 15px 40px;
            font-size: 18px;
            background: #ff4444;
            border: none;
            color: white;
            border-radius: 8px;
            cursor: pointer !important;
            transition: transform 0.2s, background 0.2s;
        }

        #death-screen button:hover {
            transform: scale(1.1);
            background: #ff6666;
        }

        #multiplayer-indicator {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,200,100,0.2);
            border: 1px solid #00ff88;
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .particle {
            position: fixed;
            pointer-events: none;
            border-radius: 50%;
            animation: particle-fade 0.5s ease-out forwards;
        }

        @keyframes particle-fade {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(0); }
        }

        .damage-flash {
            animation: damage 0.2s;
        }

        @keyframes damage {
            0%, 100% { filter: none; }
            50% { filter: brightness(3) saturate(0.5); }
        }
    </style>
</head>
<body>
    <canvas id="game-canvas"></canvas>

    <div id="stats" class="hud">
        <h2>CURSOR WARS</h2>
        <div class="stat-row">
            <span class="label">Health</span>
            <span class="value" id="health-value">100</span>
        </div>
        <div class="health-bar">
            <div class="health-fill" id="health-bar" style="width: 100%"></div>
        </div>
        <div class="stat-row">
            <span class="label">Score</span>
            <span class="value" id="score-value">0</span>
        </div>
        <div class="stat-row">
            <span class="label">Kills</span>
            <span class="value" id="kills-value">0</span>
        </div>
        <div class="stat-row">
            <span class="label">Level</span>
            <span class="value" id="level-value">1</span>
        </div>
    </div>

    <div id="tab-indicator" class="hud">
        <div id="biome-name">VOID REALM</div>
        <div id="tab-count" style="font-size: 11px; color: #888; margin-top: 5px;">Tab 1 of 1</div>
    </div>

    <div id="multiplayer-indicator" class="hud" style="display: none;">
        <span id="connected-tabs">0</span> TABS CONNECTED
    </div>

    <div id="instructions" class="hud">
        <h3>Your Cursor Is Your Warrior</h3>
        <p>
            <kbd>CLICK</kbd> to attack enemies | <kbd>HOLD</kbd> for shield |
            Move cursor to <strong>screen edge</strong> to teleport between tabs<br>
            <em style="color: #ff8844;">Open multiple tabs of this page for the full cross-dimensional experience!</em>
        </p>
    </div>

    <div id="death-screen">
        <h1>YOU DIED</h1>
        <p>Your cursor has fallen across all dimensions</p>
        <p id="final-stats"></p>
        <button onclick="resurrect()">RESURRECT (New Run)</button>
    </div>

    <script>
        // ========== CROSS-TAB COMMUNICATION ==========
        const CHANNEL_NAME = 'cursor-wars-multiverse';
        const channel = new BroadcastChannel(CHANNEL_NAME);
        const tabId = Math.random().toString(36).substr(2, 9);
        let connectedTabs = new Set([tabId]);
        let lastPing = Date.now();

        // Tab biomes - each tab instance gets a random one
        const BIOMES = [
            { name: 'VOID REALM', bg: ['#0a0a0f', '#1a1a2e', '#16213e'], enemy: '#ff4488', border: '#ff4488' },
            { name: 'NEON GRID', bg: ['#0f0a1a', '#1a0a2e', '#2e1a3e'], enemy: '#00ffff', border: '#00ffff' },
            { name: 'BLOOD DIMENSION', bg: ['#1a0505', '#2e0a0a', '#3e1010'], enemy: '#ff0000', border: '#ff0000' },
            { name: 'TOXIC ZONE', bg: ['#051a0a', '#0a2e0f', '#103e16'], enemy: '#00ff44', border: '#00ff44' },
            { name: 'SHADOW PLANE', bg: ['#050505', '#0a0a0a', '#151515'], enemy: '#aaaaaa', border: '#ffffff' },
            { name: 'PLASMA CORE', bg: ['#1a0a1a', '#2e0a2e', '#3e103e'], enemy: '#ff00ff', border: '#ff00ff' },
            { name: 'QUANTUM FIELD', bg: ['#0a0a1a', '#0a1a2e', '#103050'], enemy: '#4488ff', border: '#4488ff' },
            { name: 'EMBER WASTES', bg: ['#1a0f05', '#2e1a0a', '#3e2010'], enemy: '#ff8800', border: '#ff8800' }
        ];

        const currentBiome = BIOMES[Math.floor(Math.random() * BIOMES.length)];
        document.body.style.background = `linear-gradient(135deg, ${currentBiome.bg.join(', ')})`;
        document.getElementById('tab-indicator').style.borderColor = currentBiome.border;
        document.getElementById('biome-name').textContent = currentBiome.name;
        document.getElementById('biome-name').style.color = currentBiome.border;

        // ========== GAME STATE ==========
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');

        let gameState = JSON.parse(localStorage.getItem('cursorWarsState')) || {
            health: 100,
            maxHealth: 100,
            score: 0,
            kills: 0,
            level: 1,
            xp: 0,
            isDead: false,
            attackPower: 10,
            defense: 0
        };

        // ========== COMBO SYSTEM (Consensus Feature #2) ==========
        let combo = {
            count: 0,
            timer: 0,
            maxTimer: 90, // 1.5 seconds at 60fps
            multiplier: 1,
            bestCombo: 0
        };

        // ========== HITSTOP SYSTEM (Cycle 3 Consensus #1) ==========
        let hitstop = {
            active: false,
            duration: 0,
            maxDuration: 0,
            intensity: 0, // Visual intensity scale
            color: '#ffffff'
        };

        function triggerHitstop(frames, intensity = 1, color = '#ffffff') {
            hitstop.active = true;
            hitstop.duration = frames;
            hitstop.maxDuration = frames;
            hitstop.intensity = intensity;
            hitstop.color = color;
        }

        function updateHitstop() {
            if (hitstop.active) {
                hitstop.duration--;
                if (hitstop.duration <= 0) {
                    hitstop.active = false;
                }
                return true; // Game should freeze
            }
            return false; // Game runs normally
        }

        // ========== CURSOR TRAIL SYSTEM (Cycle 3 Consensus #2) ==========
        let cursorTrail = [];
        const MAX_TRAIL_LENGTH = 20;
        let lastCursorPos = { x: 0, y: 0 };
        let cursorVelocity = 0;

        function updateCursorTrail() {
            // Calculate velocity
            const dx = player.x - lastCursorPos.x;
            const dy = player.y - lastCursorPos.y;
            cursorVelocity = Math.sqrt(dx * dx + dy * dy);

            lastCursorPos.x = player.x;
            lastCursorPos.y = player.y;

            // Only add trail points when moving
            if (cursorVelocity > 2) {
                cursorTrail.push({
                    x: player.x,
                    y: player.y,
                    velocity: cursorVelocity,
                    life: MAX_TRAIL_LENGTH
                });
            }

            // Decay trail
            for (let i = cursorTrail.length - 1; i >= 0; i--) {
                cursorTrail[i].life--;
                if (cursorTrail[i].life <= 0) {
                    cursorTrail.splice(i, 1);
                }
            }
        }

        function getVelocityColor(velocity) {
            // Color based on speed: green (slow) -> yellow -> orange -> red (fast)
            const normalizedVel = Math.min(velocity / 30, 1);
            if (normalizedVel < 0.33) {
                return '#00ff88'; // Green for slow
            } else if (normalizedVel < 0.66) {
                return '#ffff00'; // Yellow for medium
            } else {
                return '#ff4400'; // Orange/red for fast
            }
        }

        function renderCursorTrail() {
            if (cursorTrail.length < 2) return;

            ctx.save();
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            for (let i = 1; i < cursorTrail.length; i++) {
                const prev = cursorTrail[i - 1];
                const curr = cursorTrail[i];
                const progress = curr.life / MAX_TRAIL_LENGTH;

                ctx.beginPath();
                ctx.moveTo(prev.x, prev.y);
                ctx.lineTo(curr.x, curr.y);

                const color = getVelocityColor(curr.velocity);
                ctx.strokeStyle = color;
                ctx.lineWidth = 4 * progress + (curr.velocity / 15);
                ctx.globalAlpha = progress * 0.8;
                ctx.shadowColor = color;
                ctx.shadowBlur = 10 * progress;
                ctx.stroke();
            }

            ctx.restore();
        }

        // ========== LAST STAND SYSTEM (Cycle 3 Consensus #3) ==========
        let lastStand = {
            active: false,
            timer: 0,
            maxTimer: 180, // 3 seconds at 60fps
            killsNeeded: 3,
            killsGotten: 0,
            usedThisLife: false
        };

        function triggerLastStand() {
            if (lastStand.usedThisLife) return false; // Only once per life

            lastStand.active = true;
            lastStand.timer = lastStand.maxTimer;
            lastStand.killsNeeded = Math.max(2, Math.floor(gameState.level / 2) + 1);
            lastStand.killsGotten = 0;
            lastStand.usedThisLife = true;

            gameState.health = 1; // Survive with 1 HP
            player.invulnerable = 30;

            showNotification('LAST STAND! Kill to survive!', '#ff0000');
            triggerShake(20);
            playLastStandActivate();

            return true;
        }

        function updateLastStand() {
            if (!lastStand.active) return;

            lastStand.timer--;

            if (lastStand.killsGotten >= lastStand.killsNeeded) {
                // Survived! Reward health
                lastStand.active = false;
                gameState.health = Math.min(gameState.health + 30, gameState.maxHealth);
                showNotification('SURVIVED! +30 HP', '#00ff88');
                triggerShake(15);
                playLastStandSuccess();
                createShockwave(player.x, player.y, '#00ff88');
            } else if (lastStand.timer <= 0) {
                // Failed - actually die
                lastStand.active = false;
                gameState.health = 0;
                die();
            }
        }

        function lastStandKill() {
            if (!lastStand.active) return;
            lastStand.killsGotten++;

            const remaining = lastStand.killsNeeded - lastStand.killsGotten;
            if (remaining > 0) {
                showFloatingText(player.x, player.y - 50, `${remaining} MORE!`, '#ff8800');
            }
        }

        function playLastStandActivate() {
            if (!audioCtx) return;

            // Dramatic low rumble
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.5);
            gain.gain.setValueAtTime(0.4, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.6);
            osc.connect(gain);
            gain.connect(masterGain);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.7);
        }

        function playLastStandSuccess() {
            if (!audioCtx) return;

            // Triumphant rising chord
            const notes = [261.63, 329.63, 392.00, 523.25];
            notes.forEach((freq, i) => {
                setTimeout(() => {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                    osc.connect(gain);
                    gain.connect(masterGain);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.6);
                }, i * 80);
            });
        }

        function updateCombo() {
            if (combo.timer > 0) {
                combo.timer--;
                if (combo.timer <= 0) {
                    // Combo broken!
                    if (combo.count > 5) {
                        showNotification(`COMBO BROKEN! x${combo.count}`, '#ff4444');
                        playComboBreak();
                    }
                    combo.count = 0;
                    combo.multiplier = 1;
                }
            }
        }

        function addComboKill(enemyType = 'chaser') {
            combo.count++;
            combo.timer = combo.maxTimer;
            combo.multiplier = Math.min(combo.count, 10);
            combo.bestCombo = Math.max(combo.bestCombo, combo.count);

            // Play musical note for combo
            playComboNote(combo.count, enemyType);

            // Screen shake scales with combo
            triggerShake(2 + combo.count * 0.5);

            // Milestone celebrations with audio and BIG shake
            if (combo.count === 5) {
                showNotification('5x COMBO!', '#ffff00');
                playComboMilestone(5);
                triggerShake(10);
            } else if (combo.count === 10) {
                showNotification('10x MEGA COMBO!', '#ff8800');
                playComboMilestone(10);
                triggerShake(15);
            } else if (combo.count === 25) {
                showNotification('25x ULTRA COMBO!!!', '#ff00ff');
                playComboMilestone(25);
                triggerShake(20);
            } else if (combo.count === 50) {
                showNotification('50x LEGENDARY!!!', '#00ffff');
                playComboMilestone(50);
                triggerShake(30);
            }
        }

        let player = {
            x: window.innerWidth / 2,
            y: window.innerHeight / 2,
            radius: 12,
            isShielding: false,
            isAttacking: false,
            attackCooldown: 0,
            invulnerable: 0
        };

        // ========== SCREEN SHAKE SYSTEM (Cycle 2 Consensus #1) ==========
        let screenShake = {
            intensity: 0,
            decay: 0.9,
            offsetX: 0,
            offsetY: 0
        };

        function triggerShake(intensity, duration = 10) {
            screenShake.intensity = Math.max(screenShake.intensity, intensity);
        }

        function updateShake() {
            if (screenShake.intensity > 0.5) {
                screenShake.offsetX = (Math.random() - 0.5) * screenShake.intensity * 2;
                screenShake.offsetY = (Math.random() - 0.5) * screenShake.intensity * 2;
                screenShake.intensity *= screenShake.decay;
            } else {
                screenShake.offsetX = 0;
                screenShake.offsetY = 0;
                screenShake.intensity = 0;
            }
        }

        // ========== WEB AUDIO - MUSICAL COMBO SYSTEM (Cycle 2 Consensus #2) ==========
        let audioCtx = null;
        let masterGain = null;

        // Pentatonic scale notes (always sounds good)
        const PENTATONIC = [261.63, 293.66, 329.63, 392.00, 440.00, 523.25, 587.33, 659.25];

        function initAudio() {
            if (audioCtx) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            masterGain = audioCtx.createGain();
            masterGain.gain.value = 0.3;
            masterGain.connect(audioCtx.destination);
        }

        function playComboNote(comboCount, enemyType = 'chaser') {
            if (!audioCtx) return;

            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();

            // Wave type based on enemy
            const waveTypes = { chaser: 'sine', circler: 'triangle', shooter: 'sawtooth', boss: 'square' };
            osc.type = waveTypes[enemyType] || 'sine';

            // Rising pitch with combo (wrap around pentatonic scale)
            const noteIndex = (comboCount - 1) % PENTATONIC.length;
            const octaveBoost = Math.floor((comboCount - 1) / PENTATONIC.length);
            osc.frequency.value = PENTATONIC[noteIndex] * Math.pow(2, octaveBoost * 0.5);

            // ADSR envelope
            const now = audioCtx.currentTime;
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(0.4, now + 0.02); // Attack
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3); // Decay

            osc.connect(gain);
            gain.connect(masterGain);

            osc.start(now);
            osc.stop(now + 0.35);
        }

        function playComboMilestone(milestone) {
            if (!audioCtx) return;

            // Play a chord at milestones
            const chordNotes = milestone >= 25 ? [0, 2, 4, 7] : milestone >= 10 ? [0, 2, 4] : [0, 4];
            const baseFreq = milestone >= 50 ? 523.25 : milestone >= 25 ? 440 : milestone >= 10 ? 392 : 329.63;

            chordNotes.forEach((interval, i) => {
                setTimeout(() => {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = baseFreq * Math.pow(2, interval / 12);

                    const now = audioCtx.currentTime;
                    gain.gain.setValueAtTime(0.3, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);

                    osc.connect(gain);
                    gain.connect(masterGain);
                    osc.start(now);
                    osc.stop(now + 0.6);
                }, i * 50);
            });
        }

        function playComboBreak() {
            if (!audioCtx) return;

            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(400, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.3);

            gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);

            osc.connect(gain);
            gain.connect(masterGain);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.35);
        }

        function playLevelUpFanfare() {
            if (!audioCtx) return;

            const notes = [523.25, 659.25, 783.99, 1046.50]; // C E G C (octave)
            notes.forEach((freq, i) => {
                setTimeout(() => {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = freq;

                    const now = audioCtx.currentTime;
                    gain.gain.setValueAtTime(0.4, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);

                    osc.connect(gain);
                    gain.connect(masterGain);
                    osc.start(now);
                    osc.stop(now + 0.5);
                }, i * 100);
            });
        }

        function playBossPhaseChange() {
            if (!audioCtx) return;

            // Dramatic low rumble + high screech
            const bassOsc = audioCtx.createOscillator();
            const bassGain = audioCtx.createGain();
            bassOsc.type = 'sawtooth';
            bassOsc.frequency.value = 55;
            bassGain.gain.setValueAtTime(0.5, audioCtx.currentTime);
            bassGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.8);
            bassOsc.connect(bassGain);
            bassGain.connect(masterGain);
            bassOsc.start();
            bassOsc.stop(audioCtx.currentTime + 0.9);

            // High screech
            setTimeout(() => {
                const highOsc = audioCtx.createOscillator();
                const highGain = audioCtx.createGain();
                highOsc.type = 'square';
                highOsc.frequency.setValueAtTime(800, audioCtx.currentTime);
                highOsc.frequency.exponentialRampToValueAtTime(1600, audioCtx.currentTime + 0.2);
                highGain.gain.setValueAtTime(0.15, audioCtx.currentTime);
                highGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                highOsc.connect(highGain);
                highGain.connect(masterGain);
                highOsc.start();
                highOsc.stop(audioCtx.currentTime + 0.35);
            }, 200);
        }

        let enemies = [];
        let particles = [];
        let crossTabEnemies = []; // Enemies from other tabs
        let otherPlayers = new Map(); // Other tab cursors

        // ========== CANVAS SETUP ==========
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ========== CROSS-TAB MESSAGING ==========
        channel.onmessage = (event) => {
            const { type, data, sender } = event.data;
            if (sender === tabId) return;

            switch (type) {
                case 'ping':
                    connectedTabs.add(sender);
                    channel.postMessage({ type: 'pong', sender: tabId, data: { biome: currentBiome.name } });
                    updateTabCount();
                    break;

                case 'pong':
                    connectedTabs.add(sender);
                    updateTabCount();
                    break;

                case 'cursor_position':
                    otherPlayers.set(sender, { ...data, lastSeen: Date.now() });
                    break;

                case 'enemy_teleport':
                    // An enemy from another tab is arriving!
                    const newEnemy = createEnemy();
                    newEnemy.x = data.entryPoint.x;
                    newEnemy.y = data.entryPoint.y;
                    newEnemy.fromTab = sender;
                    newEnemy.isTeleported = true;
                    newEnemy.speed *= 1.5; // Teleported enemies are faster!
                    enemies.push(newEnemy);
                    showNotification(`ENEMY INVADED FROM ${data.fromBiome}!`, '#ff4444');
                    break;

                case 'player_death':
                    // Another tab's player died - we feel the shockwave
                    createShockwave(canvas.width / 2, canvas.height / 2, '#ff0000');
                    break;

                case 'state_sync':
                    // Sync health/score across tabs
                    if (data.health < gameState.health) {
                        gameState.health = data.health;
                        updateUI();
                    }
                    break;

                case 'disconnect':
                    connectedTabs.delete(sender);
                    otherPlayers.delete(sender);
                    updateTabCount();
                    break;
            }
        };

        // Ping other tabs on load
        channel.postMessage({ type: 'ping', sender: tabId, data: { biome: currentBiome.name } });

        // Clean up on close
        window.addEventListener('beforeunload', () => {
            channel.postMessage({ type: 'disconnect', sender: tabId });
        });

        function updateTabCount() {
            const count = connectedTabs.size;
            document.getElementById('tab-count').textContent = `Tab ${tabId.substr(0, 4)} of ${count}`;
            const indicator = document.getElementById('multiplayer-indicator');
            if (count > 1) {
                indicator.style.display = 'block';
                document.getElementById('connected-tabs').textContent = count;
            } else {
                indicator.style.display = 'none';
            }
        }

        // Periodic ping to maintain connections
        setInterval(() => {
            channel.postMessage({ type: 'ping', sender: tabId, data: { biome: currentBiome.name } });
            // Clean up old connections
            const now = Date.now();
            for (const [id, data] of otherPlayers) {
                if (now - data.lastSeen > 3000) {
                    otherPlayers.delete(id);
                    connectedTabs.delete(id);
                }
            }
            updateTabCount();
        }, 1000);

        // ========== ENEMY SYSTEM ==========
        function createEnemy() {
            const side = Math.floor(Math.random() * 4);
            let x, y;
            switch (side) {
                case 0: x = Math.random() * canvas.width; y = -30; break;
                case 1: x = canvas.width + 30; y = Math.random() * canvas.height; break;
                case 2: x = Math.random() * canvas.width; y = canvas.height + 30; break;
                case 3: x = -30; y = Math.random() * canvas.height; break;
            }

            const types = ['chaser', 'circler', 'shooter', 'boss'];
            const weights = [0.5, 0.3, 0.15, 0.05];
            let type = 'chaser';
            const rand = Math.random();
            let cumulative = 0;
            for (let i = 0; i < types.length; i++) {
                cumulative += weights[i];
                if (rand < cumulative) {
                    type = types[i];
                    break;
                }
            }

            const baseStats = {
                chaser: { radius: 10, speed: 2, health: 20, damage: 10, color: currentBiome.enemy, points: 10 },
                circler: { radius: 8, speed: 3, health: 15, damage: 8, color: '#00ffff', points: 15 },
                shooter: { radius: 12, speed: 1.5, health: 30, damage: 5, color: '#ffff00', points: 25 },
                boss: { radius: 25, speed: 1, health: 150, damage: 20, color: '#ff00ff', points: 200 }
            };

            const stats = baseStats[type];
            const levelMult = 1 + (gameState.level - 1) * 0.2;

            const enemy = {
                x, y,
                vx: 0, vy: 0,
                radius: stats.radius,
                speed: stats.speed * levelMult,
                health: stats.health * levelMult,
                maxHealth: stats.health * levelMult,
                damage: stats.damage * levelMult,
                color: stats.color,
                baseColor: stats.color,
                points: stats.points,
                type,
                angle: 0,
                shootCooldown: 0
            };

            // ========== MULTI-PHASE BOSS SYSTEM (Cycle 2 Consensus #3) ==========
            if (type === 'boss') {
                enemy.phase = 1;
                enemy.phaseColors = ['#ff00ff', '#ff8800', '#ff0000']; // Purple -> Orange -> Red
                enemy.chargeTimer = 0;
                enemy.isCharging = false;
                enemy.chargeTarget = { x: 0, y: 0 };
                enemy.attackCooldown = 0;
                enemy.telegraphTimer = 0;
                enemy.currentAttack = null;
            }

            return enemy;
        }

        // Boss phase check and transition
        function updateBossPhase(boss) {
            const healthPercent = boss.health / boss.maxHealth;
            let newPhase = 1;

            if (healthPercent <= 0.33) newPhase = 3;
            else if (healthPercent <= 0.66) newPhase = 2;

            if (newPhase > boss.phase) {
                boss.phase = newPhase;
                boss.color = boss.phaseColors[newPhase - 1];

                // Phase transition effects!
                playBossPhaseChange();
                triggerShake(25);
                createShockwave(boss.x, boss.y, boss.color);

                if (newPhase === 2) {
                    showNotification('BOSS ENRAGED!', '#ff8800');
                    boss.speed *= 1.5;
                } else if (newPhase === 3) {
                    showNotification('BOSS FURY MODE!!!', '#ff0000');
                    boss.speed *= 1.3;
                    boss.damage *= 1.5;
                }
            }
        }

        function spawnEnemies() {
            const targetCount = 3 + gameState.level * 2;
            while (enemies.length < targetCount) {
                enemies.push(createEnemy());
            }
        }

        // ========== BOID FLOCKING SYSTEM (Consensus Feature #1) ==========
        function calculateFlockingForces(e, enemies) {
            let separationX = 0, separationY = 0;
            let alignmentX = 0, alignmentY = 0;
            let cohesionX = 0, cohesionY = 0;
            let neighborCount = 0;

            const SEPARATION_RADIUS = 50;
            const ALIGNMENT_RADIUS = 100;
            const COHESION_RADIUS = 150;

            for (const other of enemies) {
                if (other === e) continue;

                const dx = other.x - e.x;
                const dy = other.y - e.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Separation - avoid crowding neighbors
                if (dist < SEPARATION_RADIUS && dist > 0) {
                    separationX -= (dx / dist) / dist;
                    separationY -= (dy / dist) / dist;
                }

                // Alignment - steer toward average heading
                if (dist < ALIGNMENT_RADIUS) {
                    alignmentX += other.vx;
                    alignmentY += other.vy;
                    neighborCount++;
                }

                // Cohesion - steer toward center of mass
                if (dist < COHESION_RADIUS) {
                    cohesionX += other.x;
                    cohesionY += other.y;
                }
            }

            if (neighborCount > 0) {
                alignmentX /= neighborCount;
                alignmentY /= neighborCount;
                cohesionX = (cohesionX / neighborCount) - e.x;
                cohesionY = (cohesionY / neighborCount) - e.y;
            }

            // Normalize and weight forces
            const sepMag = Math.sqrt(separationX * separationX + separationY * separationY);
            if (sepMag > 0) { separationX /= sepMag; separationY /= sepMag; }

            const aliMag = Math.sqrt(alignmentX * alignmentX + alignmentY * alignmentY);
            if (aliMag > 0) { alignmentX /= aliMag; alignmentY /= aliMag; }

            const cohMag = Math.sqrt(cohesionX * cohesionX + cohesionY * cohesionY);
            if (cohMag > 0) { cohesionX /= cohMag; cohesionY /= cohMag; }

            return {
                sx: separationX * 0.15,
                sy: separationY * 0.15,
                ax: alignmentX * 0.08,
                ay: alignmentY * 0.08,
                cx: cohesionX * 0.05,
                cy: cohesionY * 0.05
            };
        }

        function updateEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                const dx = player.x - e.x;
                const dy = player.y - e.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Apply BOID flocking forces to chasers
                const flock = calculateFlockingForces(e, enemies);

                switch (e.type) {
                    case 'chaser':
                        // Base chase behavior + flocking
                        e.vx = (dx / dist) * e.speed * 0.7 + flock.sx + flock.ax + flock.cx;
                        e.vy = (dy / dist) * e.speed * 0.7 + flock.sy + flock.ay + flock.cy;
                        break;

                    case 'circler':
                        e.angle += 0.05;
                        const orbitDist = 150;
                        const targetX = player.x + Math.cos(e.angle) * orbitDist;
                        const targetY = player.y + Math.sin(e.angle) * orbitDist;
                        e.vx += (targetX - e.x) * 0.02;
                        e.vy += (targetY - e.y) * 0.02;
                        e.vx *= 0.95;
                        e.vy *= 0.95;
                        break;

                    case 'shooter':
                        if (dist > 200) {
                            e.vx = (dx / dist) * e.speed;
                            e.vy = (dy / dist) * e.speed;
                        } else {
                            e.vx *= 0.9;
                            e.vy *= 0.9;
                        }
                        // Shoot projectiles
                        e.shootCooldown--;
                        if (e.shootCooldown <= 0 && dist < 400) {
                            createProjectile(e.x, e.y, dx / dist * 5, dy / dist * 5, e.damage);
                            e.shootCooldown = 60;
                        }
                        break;

                    case 'boss':
                        // Update boss phase
                        updateBossPhase(e);

                        // Phase-specific behavior
                        if (e.phase === 1) {
                            // Phase 1: Slow stalker, spawns minions
                            e.vx = (dx / dist) * e.speed;
                            e.vy = (dy / dist) * e.speed;
                            if (Math.random() < 0.008) {
                                const minion = createEnemy();
                                minion.type = 'chaser';
                                minion.x = e.x + (Math.random() - 0.5) * 50;
                                minion.y = e.y + (Math.random() - 0.5) * 50;
                                minion.radius = 6;
                                enemies.push(minion);
                            }
                        } else if (e.phase === 2) {
                            // Phase 2: Aggressive chaser with charge attacks
                            e.attackCooldown--;
                            if (e.isCharging) {
                                e.chargeTimer--;
                                if (e.chargeTimer <= 0) {
                                    // Execute charge!
                                    const chargeDx = e.chargeTarget.x - e.x;
                                    const chargeDy = e.chargeTarget.y - e.y;
                                    const chargeDist = Math.sqrt(chargeDx * chargeDx + chargeDy * chargeDy);
                                    e.vx = (chargeDx / chargeDist) * e.speed * 4;
                                    e.vy = (chargeDy / chargeDist) * e.speed * 4;
                                    e.isCharging = false;
                                    triggerShake(8);
                                }
                            } else if (e.attackCooldown <= 0 && dist < 300) {
                                // Telegraph charge attack
                                e.isCharging = true;
                                e.chargeTimer = 45; // 0.75 seconds telegraph
                                e.chargeTarget = { x: player.x, y: player.y };
                                e.attackCooldown = 180;
                                e.vx *= 0.1;
                                e.vy *= 0.1;
                            } else if (!e.isCharging) {
                                e.vx = (dx / dist) * e.speed;
                                e.vy = (dy / dist) * e.speed;
                            }
                        } else if (e.phase === 3) {
                            // Phase 3: Erratic teleportation + orbital shots
                            if (Math.random() < 0.01) {
                                // Teleport to random position
                                e.x = Math.random() * (canvas.width - 100) + 50;
                                e.y = Math.random() * (canvas.height - 100) + 50;
                                createShockwave(e.x, e.y, '#ff0000');
                                triggerShake(12);
                            }
                            e.vx = (dx / dist) * e.speed;
                            e.vy = (dy / dist) * e.speed;

                            // Orbital projectile burst
                            e.shootCooldown--;
                            if (e.shootCooldown <= 0) {
                                for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 4) {
                                    createProjectile(e.x, e.y, Math.cos(angle) * 4, Math.sin(angle) * 4, e.damage * 0.5);
                                }
                                e.shootCooldown = 90;
                                triggerShake(6);
                            }
                        }
                        break;
                }

                e.x += e.vx;
                e.y += e.vy;

                // Check collision with player
                if (dist < player.radius + e.radius) {
                    if (!player.isShielding && player.invulnerable <= 0) {
                        takeDamage(e.damage);
                        player.invulnerable = 30;
                        // Knockback
                        e.x -= dx / dist * 50;
                        e.y -= dy / dist * 50;
                    } else if (player.isShielding) {
                        // Reflect damage
                        e.health -= 5;
                        e.x -= dx / dist * 30;
                        e.y -= dy / dist * 30;
                    }
                }

                // Check if enemy should teleport to another tab
                if (connectedTabs.size > 1) {
                    if (e.x < -50 || e.x > canvas.width + 50 || e.y < -50 || e.y > canvas.height + 50) {
                        if (!e.isTeleported && Math.random() < 0.7) {
                            // Teleport to another tab!
                            const entryPoint = {
                                x: e.x < 0 ? canvas.width - 50 : e.x > canvas.width ? 50 : e.x,
                                y: e.y < 0 ? canvas.height - 50 : e.y > canvas.height ? 50 : e.y
                            };
                            channel.postMessage({
                                type: 'enemy_teleport',
                                sender: tabId,
                                data: { entryPoint, fromBiome: currentBiome.name }
                            });
                            enemies.splice(i, 1);
                            continue;
                        }
                    }
                }

                // Enemy death with COMBO system
                if (e.health <= 0) {
                    addComboKill(e.type);
                    const comboPoints = Math.floor(e.points * combo.multiplier);
                    gameState.score += comboPoints;
                    gameState.kills++;
                    gameState.xp += comboPoints;
                    createExplosion(e.x, e.y, e.color);

                    // LAST STAND kill tracking
                    lastStandKill();

                    // HITSTOP on impactful kills
                    if (e.type === 'boss') {
                        triggerHitstop(12, 2, e.color); // Long freeze for boss
                        triggerShake(35);
                        showNotification('BOSS DEFEATED!', '#00ff88');
                    } else if (combo.count >= 10) {
                        triggerHitstop(6, 1.5, '#ffff00'); // Medium freeze for big combos
                    } else if (combo.count >= 5) {
                        triggerHitstop(3, 1, '#ffffff'); // Quick freeze for combos
                    }

                    // Show combo damage number
                    if (combo.count > 1) {
                        showFloatingText(e.x, e.y - 20, `+${comboPoints} x${combo.count}`, combo.count > 5 ? '#ffff00' : '#ffffff');
                    }

                    enemies.splice(i, 1);
                    checkLevelUp();
                    updateUI();
                }
            }
        }

        // ========== PROJECTILES ==========
        let projectiles = [];

        function createProjectile(x, y, vx, vy, damage) {
            projectiles.push({ x, y, vx, vy, damage, radius: 5, color: '#ffff00' });
        }

        function updateProjectiles() {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.x += p.vx;
                p.y += p.vy;

                // Check collision with player
                const dx = player.x - p.x;
                const dy = player.y - p.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < player.radius + p.radius) {
                    if (!player.isShielding && player.invulnerable <= 0) {
                        takeDamage(p.damage);
                        player.invulnerable = 20;
                    }
                    projectiles.splice(i, 1);
                    continue;
                }

                // Remove if off screen
                if (p.x < -50 || p.x > canvas.width + 50 || p.y < -50 || p.y > canvas.height + 50) {
                    projectiles.splice(i, 1);
                }
            }
        }

        // ========== PLAYER ACTIONS ==========
        function takeDamage(amount) {
            const actualDamage = Math.max(1, amount - gameState.defense);
            gameState.health -= actualDamage;
            document.body.classList.add('damage-flash');
            setTimeout(() => document.body.classList.remove('damage-flash'), 200);

            // Sync damage across tabs
            channel.postMessage({
                type: 'state_sync',
                sender: tabId,
                data: { health: gameState.health }
            });

            if (gameState.health <= 0) {
                // LAST STAND - second chance!
                if (triggerLastStand()) {
                    // Survived via last stand
                } else {
                    die();
                }
            }
            saveState();
            updateUI();
        }

        function attack() {
            if (player.attackCooldown > 0) return;
            player.isAttacking = true;
            player.attackCooldown = 15;

            const attackRange = 80;
            for (const e of enemies) {
                const dx = e.x - player.x;
                const dy = e.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < attackRange + e.radius) {
                    e.health -= gameState.attackPower;
                    e.x += dx / dist * 20;
                    e.y += dy / dist * 20;
                    createParticles(e.x, e.y, e.color, 5);
                }
            }

            setTimeout(() => player.isAttacking = false, 100);
        }

        function die() {
            gameState.isDead = true;
            channel.postMessage({ type: 'player_death', sender: tabId });
            document.getElementById('death-screen').style.display = 'flex';
            document.getElementById('final-stats').textContent =
                `Score: ${gameState.score} | Kills: ${gameState.kills} | Level: ${gameState.level}`;
            saveState();
        }

        function resurrect() {
            gameState = {
                health: 100,
                maxHealth: 100,
                score: 0,
                kills: 0,
                level: 1,
                xp: 0,
                isDead: false,
                attackPower: 10,
                defense: 0
            };
            enemies = [];
            projectiles = [];
            // Reset last stand for new run
            lastStand.usedThisLife = false;
            lastStand.active = false;
            combo.count = 0;
            combo.bestCombo = 0;
            cursorTrail = [];
            document.getElementById('death-screen').style.display = 'none';
            saveState();
            updateUI();
        }

        function checkLevelUp() {
            const xpNeeded = gameState.level * 100;
            if (gameState.xp >= xpNeeded) {
                gameState.level++;
                gameState.xp -= xpNeeded;
                gameState.maxHealth += 10;
                gameState.health = Math.min(gameState.health + 20, gameState.maxHealth);
                gameState.attackPower += 2;
                gameState.defense += 1;
                showNotification(`LEVEL UP! Now Level ${gameState.level}`, '#00ff88');
                createShockwave(player.x, player.y, '#00ff88');
                playLevelUpFanfare();
                triggerShake(20);
            }
        }

        // ========== EFFECTS ==========
        function createParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    radius: Math.random() * 4 + 2,
                    color,
                    life: 30
                });
            }
        }

        function createExplosion(x, y, color) {
            createParticles(x, y, color, 20);
        }

        // Floating damage/combo text
        let floatingTexts = [];
        function showFloatingText(x, y, text, color) {
            floatingTexts.push({ x, y, text, color, life: 60, vy: -2 });
        }

        function updateFloatingTexts() {
            for (let i = floatingTexts.length - 1; i >= 0; i--) {
                const ft = floatingTexts[i];
                ft.y += ft.vy;
                ft.life--;
                if (ft.life <= 0) floatingTexts.splice(i, 1);
            }
        }

        function renderFloatingTexts() {
            for (const ft of floatingTexts) {
                ctx.save();
                ctx.globalAlpha = ft.life / 60;
                ctx.fillStyle = ft.color;
                ctx.font = 'bold 16px Segoe UI';
                ctx.textAlign = 'center';
                ctx.fillText(ft.text, ft.x, ft.y);
                ctx.restore();
            }
        }

        function createShockwave(x, y, color) {
            // Visual shockwave effect
            const wave = document.createElement('div');
            wave.style.cssText = `
                position: fixed; left: ${x}px; top: ${y}px;
                width: 10px; height: 10px; border-radius: 50%;
                border: 3px solid ${color}; pointer-events: none;
                transform: translate(-50%, -50%);
                animation: shockwave 0.5s ease-out forwards;
            `;
            document.body.appendChild(wave);
            setTimeout(() => wave.remove(), 500);
        }

        // Add shockwave animation
        const style = document.createElement('style');
        style.textContent = `
            @keyframes shockwave {
                0% { width: 10px; height: 10px; opacity: 1; }
                100% { width: 300px; height: 300px; opacity: 0; }
            }
        `;
        document.head.appendChild(style);

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.95;
                p.vy *= 0.95;
                p.life--;
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        let notification = null;
        function showNotification(text, color) {
            if (notification) notification.remove();
            notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed; top: 50%; left: 50%;
                transform: translate(-50%, -50%);
                background: ${color}22; border: 2px solid ${color};
                padding: 15px 30px; border-radius: 10px;
                color: ${color}; font-size: 24px; font-weight: bold;
                pointer-events: none; z-index: 500;
                animation: notif 1s ease-out forwards;
            `;
            notification.textContent = text;
            document.body.appendChild(notification);
            setTimeout(() => notification?.remove(), 1000);
        }
        style.textContent += `
            @keyframes notif {
                0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                100% { opacity: 0; transform: translate(-50%, -80%) scale(1.2); }
            }
        `;

        // ========== INPUT HANDLING ==========
        document.addEventListener('mousemove', (e) => {
            player.x = e.clientX;
            player.y = e.clientY;

            // Broadcast position to other tabs
            channel.postMessage({
                type: 'cursor_position',
                sender: tabId,
                data: { x: player.x, y: player.y, biome: currentBiome.name }
            });
        });

        document.addEventListener('mousedown', (e) => {
            if (e.button === 0) {
                attack();
            } else if (e.button === 2) {
                player.isShielding = true;
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (e.button === 2) {
                player.isShielding = false;
            }
        });

        document.addEventListener('contextmenu', (e) => e.preventDefault());

        // ========== RENDERING ==========
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ========== HITSTOP VISUAL EFFECT ==========
            if (hitstop.active) {
                // Flash effect at start of hitstop
                const flashProgress = hitstop.duration / hitstop.maxDuration;
                if (flashProgress > 0.7) {
                    ctx.save();
                    ctx.fillStyle = hitstop.color;
                    ctx.globalAlpha = (flashProgress - 0.7) * 2 * 0.3 * hitstop.intensity;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.restore();
                }
            }

            // Apply screen shake
            ctx.save();
            ctx.translate(screenShake.offsetX, screenShake.offsetY);

            // Draw grid
            ctx.strokeStyle = 'rgba(255,255,255,0.05)';
            ctx.lineWidth = 1;
            const gridSize = 50;
            for (let x = 0; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Draw edge indicators (teleport zones)
            if (connectedTabs.size > 1) {
                ctx.fillStyle = 'rgba(255,255,255,0.1)';
                ctx.fillRect(0, 0, 20, canvas.height); // Left
                ctx.fillRect(canvas.width - 20, 0, 20, canvas.height); // Right
                ctx.fillRect(0, 0, canvas.width, 20); // Top
                ctx.fillRect(0, canvas.height - 20, canvas.width, 20); // Bottom
            }

            // ========== CURSOR TRAIL RENDERING ==========
            renderCursorTrail();

            // ========== LAST STAND VIGNETTE EFFECT ==========
            if (lastStand.active) {
                const pulse = Math.sin(Date.now() / 100) * 0.5 + 0.5;
                const intensity = 0.3 + pulse * 0.2;

                // Red vignette
                const gradient = ctx.createRadialGradient(
                    canvas.width / 2, canvas.height / 2, canvas.width * 0.3,
                    canvas.width / 2, canvas.height / 2, canvas.width * 0.8
                );
                gradient.addColorStop(0, 'rgba(255, 0, 0, 0)');
                gradient.addColorStop(1, `rgba(255, 0, 0, ${intensity})`);
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Timer bar at top of screen
                const timerProgress = lastStand.timer / lastStand.maxTimer;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(canvas.width * 0.2, 80, canvas.width * 0.6, 15);
                ctx.fillStyle = timerProgress > 0.3 ? '#ff4444' : '#ff0000';
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 10;
                ctx.fillRect(canvas.width * 0.2, 80, canvas.width * 0.6 * timerProgress, 15);
                ctx.shadowBlur = 0;

                // Kill counter
                ctx.font = 'bold 24px Segoe UI';
                ctx.textAlign = 'center';
                ctx.fillStyle = '#ffffff';
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 15;
                ctx.fillText(`KILLS: ${lastStand.killsGotten} / ${lastStand.killsNeeded}`, canvas.width / 2, 115);
                ctx.shadowBlur = 0;
            }

            // Draw other tab players (ghost cursors)
            for (const [id, data] of otherPlayers) {
                ctx.save();
                ctx.globalAlpha = 0.3;
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(data.x, data.y, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            // Draw projectiles
            for (const p of projectiles) {
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw enemies
            for (const e of enemies) {
                ctx.save();

                // Enemy glow
                ctx.shadowColor = e.color;
                ctx.shadowBlur = 15;

                ctx.fillStyle = e.color;
                ctx.beginPath();
                ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
                ctx.fill();

                // Health bar for non-full health
                if (e.health < e.maxHealth) {
                    ctx.shadowBlur = 0;
                    const barWidth = e.radius * 2;
                    const barHeight = 4;
                    ctx.fillStyle = '#333';
                    ctx.fillRect(e.x - barWidth / 2, e.y - e.radius - 10, barWidth, barHeight);
                    ctx.fillStyle = '#ff4444';
                    ctx.fillRect(e.x - barWidth / 2, e.y - e.radius - 10, barWidth * (e.health / e.maxHealth), barHeight);
                }

                // Teleported enemy indicator
                if (e.isTeleported) {
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, e.radius + 5, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // ========== BOSS PHASE VISUALS ==========
                if (e.type === 'boss') {
                    // Phase indicator rings
                    const phaseRings = e.phase || 1;
                    for (let ring = 0; ring < phaseRings; ring++) {
                        ctx.strokeStyle = e.color;
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 0.5 - ring * 0.15;
                        ctx.beginPath();
                        ctx.arc(e.x, e.y, e.radius + 10 + ring * 8, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    ctx.globalAlpha = 1;

                    // Charge attack telegraph - warning line
                    if (e.isCharging && e.chargeTarget) {
                        ctx.strokeStyle = '#ff0000';
                        ctx.lineWidth = 3 + Math.sin(Date.now() / 50) * 2;
                        ctx.shadowColor = '#ff0000';
                        ctx.shadowBlur = 20;
                        ctx.setLineDash([10, 10]);
                        ctx.beginPath();
                        ctx.moveTo(e.x, e.y);
                        ctx.lineTo(e.chargeTarget.x, e.chargeTarget.y);
                        ctx.stroke();
                        ctx.setLineDash([]);

                        // Warning circle at target
                        ctx.beginPath();
                        ctx.arc(e.chargeTarget.x, e.chargeTarget.y, 30 + Math.sin(Date.now() / 100) * 10, 0, Math.PI * 2);
                        ctx.stroke();
                    }

                    // Phase 3 fury aura
                    if (e.phase === 3) {
                        const auraSize = e.radius + 20 + Math.sin(Date.now() / 80) * 10;
                        const gradient = ctx.createRadialGradient(e.x, e.y, e.radius, e.x, e.y, auraSize);
                        gradient.addColorStop(0, 'rgba(255, 0, 0, 0.3)');
                        gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(e.x, e.y, auraSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                ctx.restore();
            }

            // Draw particles
            for (const p of particles) {
                ctx.globalAlpha = p.life / 30;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            // Draw player cursor
            ctx.save();

            // Shield effect
            if (player.isShielding) {
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 3;
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.radius + 15, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Attack effect
            if (player.isAttacking) {
                ctx.strokeStyle = '#ff8844';
                ctx.lineWidth = 2;
                ctx.shadowColor = '#ff8844';
                ctx.shadowBlur = 30;
                ctx.beginPath();
                ctx.arc(player.x, player.y, 80, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Invulnerability flash
            if (player.invulnerable > 0 && Math.floor(player.invulnerable / 3) % 2 === 0) {
                ctx.globalAlpha = 0.5;
            }

            // Cursor glow
            ctx.shadowColor = '#00ff88';
            ctx.shadowBlur = 20;

            // Draw cursor as arrow
            ctx.fillStyle = '#00ff88';
            ctx.beginPath();
            ctx.moveTo(player.x, player.y);
            ctx.lineTo(player.x + 20, player.y + 15);
            ctx.lineTo(player.x + 10, player.y + 15);
            ctx.lineTo(player.x + 15, player.y + 25);
            ctx.lineTo(player.x + 8, player.y + 27);
            ctx.lineTo(player.x + 5, player.y + 18);
            ctx.lineTo(player.x, player.y + 22);
            ctx.closePath();
            ctx.fill();

            ctx.restore();

            // ========== XP PROGRESS RING (Consensus Feature #3) ==========
            const xpNeeded = gameState.level * 100;
            const xpProgress = gameState.xp / xpNeeded;
            const ringRadius = 25;

            ctx.save();
            // Background ring
            ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(player.x + 10, player.y + 12, ringRadius, 0, Math.PI * 2);
            ctx.stroke();

            // Progress ring with color gradient based on progress
            const progressColor = xpProgress > 0.8 ? '#ffff00' : xpProgress > 0.5 ? '#88ff88' : '#00ff88';
            ctx.strokeStyle = progressColor;
            ctx.lineWidth = xpProgress > 0.8 ? 4 + Math.sin(Date.now() / 100) * 2 : 4;
            ctx.shadowColor = progressColor;
            ctx.shadowBlur = xpProgress > 0.8 ? 15 + Math.sin(Date.now() / 80) * 10 : 5;
            ctx.beginPath();
            ctx.arc(player.x + 10, player.y + 12, ringRadius, -Math.PI / 2, -Math.PI / 2 + xpProgress * Math.PI * 2);
            ctx.stroke();

            // Near level-up glow effect
            if (xpProgress > 0.9) {
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.shadowBlur = 30;
                ctx.shadowColor = '#ffffff';
                ctx.beginPath();
                ctx.arc(player.x + 10, player.y + 12, ringRadius + 5, 0, Math.PI * 2);
                ctx.stroke();
            }
            ctx.restore();

            // ========== COMBO COUNTER DISPLAY ==========
            if (combo.count > 1) {
                ctx.save();
                const comboScale = 1 + Math.sin(Date.now() / 100) * 0.1;
                ctx.font = `bold ${Math.min(24 + combo.count, 48) * comboScale}px Segoe UI`;
                ctx.textAlign = 'center';
                ctx.fillStyle = combo.count >= 10 ? '#ff8800' : combo.count >= 5 ? '#ffff00' : '#ffffff';
                ctx.shadowColor = ctx.fillStyle;
                ctx.shadowBlur = 15;
                ctx.fillText(`x${combo.count}`, player.x + 10, player.y - 30);

                // Combo timer bar
                const timerWidth = 50;
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.fillRect(player.x - timerWidth/2 + 10, player.y - 45, timerWidth, 4);
                ctx.fillStyle = combo.count >= 5 ? '#ffff00' : '#ffffff';
                ctx.fillRect(player.x - timerWidth/2 + 10, player.y - 45, timerWidth * (combo.timer / combo.maxTimer), 4);
                ctx.restore();
            }

            // Render floating texts
            renderFloatingTexts();

            // End screen shake transform
            ctx.restore();
        }

        // ========== UI ==========
        function updateUI() {
            document.getElementById('health-value').textContent = Math.max(0, Math.round(gameState.health));
            document.getElementById('health-bar').style.width = `${(gameState.health / gameState.maxHealth) * 100}%`;
            document.getElementById('score-value').textContent = gameState.score;
            document.getElementById('kills-value').textContent = gameState.kills;
            document.getElementById('level-value').textContent = gameState.level;
        }

        function saveState() {
            localStorage.setItem('cursorWarsState', JSON.stringify(gameState));
        }

        // ========== GAME LOOP ==========
        function gameLoop() {
            if (!gameState.isDead) {
                // Check for hitstop freeze - only update cursor trail during freeze
                const frozen = updateHitstop();

                // Cursor trail always updates (even during freeze for visual feedback)
                updateCursorTrail();

                if (!frozen) {
                    player.attackCooldown = Math.max(0, player.attackCooldown - 1);
                    player.invulnerable = Math.max(0, player.invulnerable - 1);

                    spawnEnemies();
                    updateEnemies();
                    updateProjectiles();
                    updateParticles();
                    updateCombo();
                    updateFloatingTexts();
                    updateShake();
                    updateLastStand();
                }
            }

            render();
            requestAnimationFrame(gameLoop);
        }

        // ========== INIT ==========
        if (gameState.isDead) {
            document.getElementById('death-screen').style.display = 'flex';
            document.getElementById('final-stats').textContent =
                `Score: ${gameState.score} | Kills: ${gameState.kills} | Level: ${gameState.level}`;
        }
        updateUI();
        gameLoop();

        // Auto-save periodically
        setInterval(saveState, 5000);

        // Hide instructions after first interaction and init audio
        document.addEventListener('click', () => {
            initAudio();
            document.getElementById('instructions').style.opacity = '0';
            setTimeout(() => document.getElementById('instructions').style.display = 'none', 500);
        }, { once: true });
    </script>
</body>
</html>
