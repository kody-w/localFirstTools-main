<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TAB HYDRA - Spawn Head</title>
    <meta name="description" content="A creature lives in your browser tabs. Feed it by opening new tabs, and battle as heads fight for dominance across your tab bar.">
    <!-- tags: game, experimental, broadcast-channel, cross-tab, meta-game, canvas -->
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #0f0f1a 100%);
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            color: #e0e0e0;
            overflow: hidden;
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
            text-align: center;
        }

        h1 {
            font-size: 3em;
            background: linear-gradient(45deg, #ff6b6b, #feca57, #48dbfb, #ff9ff3);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradient 3s ease infinite;
            text-shadow: 0 0 30px rgba(255, 107, 107, 0.3);
            margin-bottom: 10px;
        }

        @keyframes gradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .subtitle {
            color: #888;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .head-display {
            width: 300px;
            height: 300px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #2a2a4a, #1a1a2e);
            border: 4px solid #444;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 20px;
            position: relative;
            box-shadow: 0 0 50px rgba(100, 100, 200, 0.3);
            transition: all 0.3s ease;
        }

        .head-display.attacking {
            animation: attack 0.5s ease;
            border-color: #ff4444;
            box-shadow: 0 0 80px rgba(255, 50, 50, 0.6);
        }

        .head-display.damaged {
            animation: damage 0.3s ease;
            border-color: #ff8800;
        }

        @keyframes attack {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        @keyframes damage {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        .head-face {
            font-size: 100px;
            text-shadow: 0 0 20px currentColor;
            transition: all 0.3s ease;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin: 20px 0;
            width: 100%;
            max-width: 400px;
        }

        .stat {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-label {
            font-size: 0.8em;
            color: #888;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
        }

        .health-bar {
            width: 100%;
            max-width: 400px;
            height: 30px;
            background: #222;
            border-radius: 15px;
            overflow: hidden;
            margin: 20px 0;
            border: 2px solid #444;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ff8800, #44ff44);
            background-size: 300% 100%;
            transition: width 0.3s ease;
            border-radius: 15px;
        }

        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            margin: 20px 0;
        }

        button {
            padding: 15px 30px;
            font-size: 1em;
            font-family: inherit;
            background: linear-gradient(135deg, #4a4a6a, #3a3a5a);
            color: #fff;
            border: 2px solid #666;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        button:hover {
            background: linear-gradient(135deg, #5a5a7a, #4a4a6a);
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(100, 100, 200, 0.3);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .spawn-btn {
            background: linear-gradient(135deg, #44aa44, #338833);
            border-color: #55cc55;
        }

        .attack-btn {
            background: linear-gradient(135deg, #aa4444, #883333);
            border-color: #cc5555;
        }

        .merge-btn {
            background: linear-gradient(135deg, #aa44aa, #883388);
            border-color: #cc55cc;
        }

        .hydra-network {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            width: 100%;
            max-width: 600px;
        }

        .network-title {
            margin-bottom: 15px;
            color: #aaa;
        }

        .heads-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        .head-chip {
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 15px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid transparent;
        }

        .head-chip:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .head-chip.self {
            border-color: #44ff44;
            background: rgba(68, 255, 68, 0.1);
        }

        .head-chip.attacking {
            border-color: #ff4444;
            animation: pulse 0.5s ease infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .head-emoji {
            font-size: 1.2em;
        }

        .combat-log {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            width: 100%;
            max-width: 500px;
            height: 150px;
            overflow-y: auto;
            text-align: left;
            font-size: 0.85em;
        }

        .log-entry {
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .log-attack { color: #ff6b6b; }
        .log-spawn { color: #44ff44; }
        .log-death { color: #888; }
        .log-merge { color: #ff9ff3; }
        .log-info { color: #48dbfb; }

        .instructions {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            max-width: 500px;
            text-align: left;
            font-size: 0.9em;
            line-height: 1.6;
        }

        .instructions h3 {
            margin-bottom: 10px;
            color: #feca57;
        }

        .instructions ul {
            padding-left: 20px;
        }

        .dead-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            display: none;
        }

        .dead-overlay.visible {
            display: flex;
        }

        .dead-title {
            font-size: 4em;
            color: #ff4444;
            margin-bottom: 20px;
        }

        .respawn-timer {
            font-size: 2em;
            color: #888;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>TAB HYDRA</h1>
        <p class="subtitle">A creature lives in your browser tabs</p>

        <div class="head-display" id="headDisplay">
            <span class="head-face" id="headFace">üêâ</span>
        </div>

        <div class="health-bar">
            <div class="health-fill" id="healthFill" style="width: 100%"></div>
        </div>

        <div class="stats">
            <div class="stat">
                <div class="stat-label">HEALTH</div>
                <div class="stat-value" id="healthValue">100</div>
            </div>
            <div class="stat">
                <div class="stat-label">POWER</div>
                <div class="stat-value" id="powerValue">10</div>
            </div>
            <div class="stat">
                <div class="stat-label">KILLS</div>
                <div class="stat-value" id="killsValue">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">GENERATION</div>
                <div class="stat-value" id="genValue">1</div>
            </div>
        </div>

        <div class="controls">
            <button class="spawn-btn" id="spawnBtn">ü•ö SPAWN NEW HEAD</button>
            <button class="attack-btn" id="attackBtn">‚öîÔ∏è ATTACK RANDOM</button>
            <button class="merge-btn" id="mergeBtn">üîÆ ABSORB WEAKEST</button>
        </div>

        <div class="hydra-network">
            <div class="network-title">üêç HYDRA NETWORK - Active Heads</div>
            <div class="heads-list" id="headsList"></div>
        </div>

        <div class="combat-log" id="combatLog"></div>

        <div class="instructions">
            <h3>How to Play</h3>
            <ul>
                <li><strong>SPAWN:</strong> Opens a new tab with a new Hydra head</li>
                <li><strong>ATTACK:</strong> Attacks a random other head for damage</li>
                <li><strong>ABSORB:</strong> Consumes the weakest head to gain its power</li>
                <li>Heads fight autonomously every few seconds</li>
                <li>When a head dies, TWO new ones spawn (like the myth!)</li>
                <li>Tab titles show health. Tab icons show emotions.</li>
                <li>Last head standing becomes the ALPHA!</li>
            </ul>
        </div>
    </div>

    <div class="dead-overlay" id="deadOverlay">
        <div class="dead-title">HEAD SEVERED!</div>
        <div class="respawn-timer" id="respawnTimer">Spawning 2 new heads...</div>
    </div>

    <script>
        // Unique ID for this head
        const HEAD_ID = Date.now().toString(36) + Math.random().toString(36).substr(2, 5);

        // Head state
        const state = {
            id: HEAD_ID,
            health: 100,
            maxHealth: 100,
            power: 10,
            kills: 0,
            generation: 1,
            emotion: 'neutral',
            isAlive: true,
            lastAttackTime: 0
        };

        // All known heads in the network
        const heads = new Map();
        heads.set(HEAD_ID, state);

        // BroadcastChannel for cross-tab communication
        const channel = new BroadcastChannel('hydra-network');

        // Emoji faces for different states
        const faces = {
            neutral: 'üêâ',
            happy: 'üòä',
            angry: 'üò†',
            attacking: 'üî•',
            damaged: 'üòµ',
            powerful: 'üëë',
            weak: 'üò∞',
            dead: 'üíÄ'
        };

        // DOM Elements
        const headDisplay = document.getElementById('headDisplay');
        const headFace = document.getElementById('headFace');
        const healthFill = document.getElementById('healthFill');
        const healthValue = document.getElementById('healthValue');
        const powerValue = document.getElementById('powerValue');
        const killsValue = document.getElementById('killsValue');
        const genValue = document.getElementById('genValue');
        const headsList = document.getElementById('headsList');
        const combatLog = document.getElementById('combatLog');
        const deadOverlay = document.getElementById('deadOverlay');
        const respawnTimer = document.getElementById('respawnTimer');
        const spawnBtn = document.getElementById('spawnBtn');
        const attackBtn = document.getElementById('attackBtn');
        const mergeBtn = document.getElementById('mergeBtn');

        // Initialize from localStorage if exists
        function loadState() {
            const saved = localStorage.getItem('hydra-state-' + HEAD_ID);
            if (saved) {
                const parsed = JSON.parse(saved);
                Object.assign(state, parsed);
            }

            // Check URL params for generation
            const params = new URLSearchParams(window.location.search);
            if (params.has('gen')) {
                state.generation = parseInt(params.get('gen')) || 1;
            }
            if (params.has('power')) {
                state.power = parseInt(params.get('power')) || 10;
            }
        }

        // Save state
        function saveState() {
            localStorage.setItem('hydra-state-' + HEAD_ID, JSON.stringify(state));
        }

        // Update UI
        function updateUI() {
            const healthPercent = (state.health / state.maxHealth) * 100;
            healthFill.style.width = `${healthPercent}%`;

            // Color based on health
            if (healthPercent > 66) {
                healthFill.style.backgroundPosition = '100% 0';
            } else if (healthPercent > 33) {
                healthFill.style.backgroundPosition = '50% 0';
            } else {
                healthFill.style.backgroundPosition = '0% 0';
            }

            healthValue.textContent = Math.max(0, Math.round(state.health));
            powerValue.textContent = state.power;
            killsValue.textContent = state.kills;
            genValue.textContent = state.generation;

            // Update emotion based on state
            if (!state.isAlive) {
                state.emotion = 'dead';
            } else if (state.health < 20) {
                state.emotion = 'weak';
            } else if (state.kills >= 5) {
                state.emotion = 'powerful';
            } else {
                state.emotion = 'neutral';
            }

            headFace.textContent = faces[state.emotion];

            // Update tab title with health bar
            const bars = '‚ñà'.repeat(Math.ceil(healthPercent / 10)) + '‚ñë'.repeat(10 - Math.ceil(healthPercent / 10));
            document.title = `[${bars}] HEAD ${HEAD_ID.substr(0, 4)}`;

            // Update favicon
            updateFavicon();

            saveState();
        }

        // Generate favicon from emoji
        function updateFavicon() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');

            // Background based on health
            const healthPercent = state.health / state.maxHealth;
            if (healthPercent > 0.66) {
                ctx.fillStyle = '#2a4a2a';
            } else if (healthPercent > 0.33) {
                ctx.fillStyle = '#4a4a2a';
            } else {
                ctx.fillStyle = '#4a2a2a';
            }
            ctx.fillRect(0, 0, 32, 32);

            // Draw emoji
            ctx.font = '24px serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(faces[state.emotion], 16, 18);

            // Update favicon
            let favicon = document.querySelector("link[rel*='icon']");
            if (!favicon) {
                favicon = document.createElement('link');
                favicon.rel = 'icon';
                document.head.appendChild(favicon);
            }
            favicon.href = canvas.toDataURL();
        }

        // Update heads list display
        function updateHeadsList() {
            headsList.innerHTML = '';

            const sortedHeads = Array.from(heads.values())
                .filter(h => h.isAlive)
                .sort((a, b) => b.power - a.power);

            sortedHeads.forEach(head => {
                const chip = document.createElement('div');
                chip.className = 'head-chip' + (head.id === HEAD_ID ? ' self' : '');
                chip.innerHTML = `
                    <span class="head-emoji">${faces[head.emotion] || faces.neutral}</span>
                    <span>${head.id.substr(0, 4)}</span>
                    <span>‚ù§Ô∏è${Math.round(head.health)}</span>
                    <span>‚öîÔ∏è${head.power}</span>
                `;

                // Click to attack specific head
                if (head.id !== HEAD_ID) {
                    chip.onclick = () => attackHead(head.id);
                    chip.title = 'Click to attack this head';
                }

                headsList.appendChild(chip);
            });

            // Update button states
            const otherHeads = sortedHeads.filter(h => h.id !== HEAD_ID);
            attackBtn.disabled = otherHeads.length === 0 || !state.isAlive;
            mergeBtn.disabled = otherHeads.length === 0 || !state.isAlive;
        }

        // Add combat log entry
        function addLog(message, type = 'info') {
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            combatLog.insertBefore(entry, combatLog.firstChild);

            // Keep only last 50 entries
            while (combatLog.children.length > 50) {
                combatLog.removeChild(combatLog.lastChild);
            }
        }

        // Broadcast state to all heads
        function broadcastState() {
            channel.postMessage({
                type: 'state',
                head: { ...state }
            });
        }

        // Spawn new head (open new tab)
        function spawnHead() {
            const newGen = state.generation;
            const inheritedPower = Math.floor(state.power * 0.5);
            const url = `${window.location.pathname}?gen=${newGen}&power=${Math.max(10, inheritedPower)}`;
            window.open(url, '_blank');
            addLog('Spawned a new head!', 'spawn');
        }

        // Attack a specific head
        function attackHead(targetId) {
            if (!state.isAlive) return;
            if (Date.now() - state.lastAttackTime < 1000) return; // Cooldown

            const target = heads.get(targetId);
            if (!target || !target.isAlive) {
                addLog('Target not found or already dead!', 'info');
                return;
            }

            state.lastAttackTime = Date.now();

            // Calculate damage with some randomness
            const damage = state.power + Math.floor(Math.random() * 5);

            // Visual feedback
            headDisplay.classList.add('attacking');
            state.emotion = 'attacking';
            headFace.textContent = faces.attacking;

            setTimeout(() => {
                headDisplay.classList.remove('attacking');
                state.emotion = 'neutral';
                updateUI();
            }, 500);

            // Send attack message
            channel.postMessage({
                type: 'attack',
                from: HEAD_ID,
                to: targetId,
                damage: damage
            });

            addLog(`Attacked ${targetId.substr(0, 4)} for ${damage} damage!`, 'attack');
        }

        // Attack random head
        function attackRandom() {
            const otherHeads = Array.from(heads.values())
                .filter(h => h.id !== HEAD_ID && h.isAlive);

            if (otherHeads.length === 0) {
                addLog('No other heads to attack!', 'info');
                return;
            }

            const target = otherHeads[Math.floor(Math.random() * otherHeads.length)];
            attackHead(target.id);
        }

        // Absorb weakest head
        function absorbWeakest() {
            const otherHeads = Array.from(heads.values())
                .filter(h => h.id !== HEAD_ID && h.isAlive)
                .sort((a, b) => a.health - b.health);

            if (otherHeads.length === 0) {
                addLog('No heads to absorb!', 'info');
                return;
            }

            const weakest = otherHeads[0];

            // Only absorb if we're stronger
            if (state.power <= weakest.power) {
                addLog('You are not powerful enough to absorb!', 'info');
                return;
            }

            channel.postMessage({
                type: 'absorb',
                from: HEAD_ID,
                to: weakest.id
            });

            addLog(`Attempting to absorb ${weakest.id.substr(0, 4)}...`, 'merge');
        }

        // Handle incoming attack
        function receiveAttack(fromId, damage) {
            if (!state.isAlive) return;

            state.health -= damage;

            // Visual feedback
            headDisplay.classList.add('damaged');
            state.emotion = 'damaged';
            headFace.textContent = faces.damaged;

            setTimeout(() => {
                headDisplay.classList.remove('damaged');
                updateUI();
            }, 300);

            addLog(`Hit by ${fromId.substr(0, 4)} for ${damage} damage!`, 'attack');

            if (state.health <= 0) {
                die(fromId);
            } else {
                // Counter-attack sometimes
                if (Math.random() < 0.3) {
                    setTimeout(() => attackHead(fromId), 500);
                }
            }

            updateUI();
            broadcastState();
        }

        // Handle being absorbed
        function beAbsorbed(byId) {
            if (!state.isAlive) return;

            addLog(`Being absorbed by ${byId.substr(0, 4)}!`, 'merge');

            // Transfer power to absorber
            channel.postMessage({
                type: 'absorb-complete',
                from: HEAD_ID,
                to: byId,
                power: state.power
            });

            die(byId, false); // Don't spawn new heads when absorbed
        }

        // Complete absorption (gain power)
        function completeAbsorption(power) {
            state.power += Math.floor(power * 0.75);
            state.health = Math.min(state.maxHealth, state.health + 20);
            addLog(`Absorbed head! Gained ${Math.floor(power * 0.75)} power!`, 'merge');
            updateUI();
            broadcastState();
        }

        // Die and potentially spawn new heads
        function die(killerId, spawnNew = true) {
            state.isAlive = false;
            state.health = 0;
            state.emotion = 'dead';

            // Notify killer
            channel.postMessage({
                type: 'kill-confirmed',
                killer: killerId,
                victim: HEAD_ID
            });

            // Broadcast death
            channel.postMessage({
                type: 'death',
                head: HEAD_ID
            });

            addLog('THIS HEAD HAS BEEN SEVERED!', 'death');

            // Show death overlay
            deadOverlay.classList.add('visible');

            // Hydra mechanic: spawn 2 new heads!
            if (spawnNew) {
                respawnTimer.textContent = 'Spawning 2 new heads in 3...';

                setTimeout(() => {
                    respawnTimer.textContent = 'Spawning 2 new heads in 2...';
                }, 1000);

                setTimeout(() => {
                    respawnTimer.textContent = 'Spawning 2 new heads in 1...';
                }, 2000);

                setTimeout(() => {
                    // Spawn 2 new heads with inherited traits
                    const newGen = state.generation + 1;
                    const inheritedPower = Math.floor(state.power * 0.7);

                    const url = `${window.location.pathname}?gen=${newGen}&power=${Math.max(10, inheritedPower)}`;
                    window.open(url, '_blank');
                    window.open(url, '_blank');

                    respawnTimer.textContent = 'This head has closed. The Hydra lives on!';

                    // Close this tab after a moment
                    setTimeout(() => {
                        window.close();
                    }, 2000);
                }, 3000);
            } else {
                respawnTimer.textContent = 'Absorbed into another head...';
                setTimeout(() => {
                    window.close();
                }, 2000);
            }

            updateUI();
        }

        // Handle messages from other heads
        channel.onmessage = (event) => {
            const msg = event.data;

            switch (msg.type) {
                case 'state':
                    // Update our record of this head
                    heads.set(msg.head.id, msg.head);
                    updateHeadsList();
                    break;

                case 'ping':
                    // Respond with our state
                    broadcastState();
                    break;

                case 'attack':
                    if (msg.to === HEAD_ID) {
                        receiveAttack(msg.from, msg.damage);
                    }
                    break;

                case 'absorb':
                    if (msg.to === HEAD_ID) {
                        beAbsorbed(msg.from);
                    }
                    break;

                case 'absorb-complete':
                    if (msg.to === HEAD_ID) {
                        completeAbsorption(msg.power);
                    }
                    break;

                case 'kill-confirmed':
                    if (msg.killer === HEAD_ID) {
                        state.kills++;
                        state.power += 2; // Bonus power for kills
                        addLog(`Kill confirmed! +2 power!`, 'attack');
                        updateUI();
                        broadcastState();
                    }
                    break;

                case 'death':
                    const deadHead = heads.get(msg.head);
                    if (deadHead) {
                        deadHead.isAlive = false;
                        addLog(`${msg.head.substr(0, 4)} has been severed!`, 'death');
                    }
                    updateHeadsList();
                    break;
            }
        };

        // Autonomous behavior - heads fight on their own!
        function autonomousBehavior() {
            if (!state.isAlive) return;

            const otherHeads = Array.from(heads.values())
                .filter(h => h.id !== HEAD_ID && h.isAlive);

            if (otherHeads.length === 0) return;

            // Random chance to attack
            if (Math.random() < 0.2) {
                const target = otherHeads[Math.floor(Math.random() * otherHeads.length)];
                attackHead(target.id);
            }

            // Regenerate a tiny bit
            if (state.health < state.maxHealth) {
                state.health = Math.min(state.maxHealth, state.health + 1);
                updateUI();
            }
        }

        // Cleanup old heads that stopped responding
        function cleanupHeads() {
            const now = Date.now();
            // Request state from all heads
            channel.postMessage({ type: 'ping' });
        }

        // Button handlers
        spawnBtn.onclick = spawnHead;
        attackBtn.onclick = attackRandom;
        mergeBtn.onclick = absorbWeakest;

        // Initialize
        loadState();
        updateUI();
        broadcastState();

        // Ping for other heads
        channel.postMessage({ type: 'ping' });

        addLog(`Head ${HEAD_ID.substr(0, 4)} has awakened! Generation ${state.generation}`, 'spawn');

        // Intervals
        setInterval(broadcastState, 2000);
        setInterval(autonomousBehavior, 3000 + Math.random() * 2000);
        setInterval(cleanupHeads, 10000);
        setInterval(updateHeadsList, 1000);

        // Handle tab visibility
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible') {
                // Bonus for being viewed
                if (state.isAlive) {
                    state.health = Math.min(state.maxHealth, state.health + 5);
                    addLog('Attention bonus! +5 health', 'info');
                    updateUI();
                    broadcastState();
                }
            }
        });

        // Prevent accidental close
        window.onbeforeunload = (e) => {
            if (state.isAlive && heads.size > 1) {
                e.preventDefault();
                e.returnValue = 'This head is still alive! Closing will kill it.';
                return e.returnValue;
            }
        };
    </script>
</body>
</html>
