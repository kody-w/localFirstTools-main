<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WETWARE - A Reality-Bending Puzzle Platformer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            color: #0f0;
        }

        #gameContainer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.3s ease;
        }

        #gameContainer.draggable {
            cursor: move;
            border: 2px solid #0f0;
            box-shadow: 0 0 20px #0f0;
            resize: both;
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            background: #000;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #narrator {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 800px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #0f0;
            padding: 15px 20px;
            font-size: 18px;
            color: #0f0;
            text-align: center;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.5s;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }

        #narrator.show {
            opacity: 1;
        }

        #levelTitle {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: #0f0;
            text-shadow: 0 0 10px #0f0;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 999;
            pointer-events: none;
        }

        #levelTitle.show {
            opacity: 1;
        }

        #codeEditor {
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            width: 400px;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #0f0;
            padding: 15px;
            font-size: 12px;
            color: #0f0;
            display: none;
            z-index: 1001;
            max-height: 80vh;
            overflow-y: auto;
        }

        #codeEditor.show {
            display: block;
        }

        .code-line {
            padding: 3px 5px;
            cursor: pointer;
            border-left: 3px solid transparent;
            margin: 2px 0;
        }

        .code-line:hover {
            background: rgba(0, 255, 0, 0.1);
            border-left-color: #0f0;
        }

        .code-line.active {
            background: rgba(0, 255, 0, 0.2);
            border-left-color: #f00;
        }

        #console {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #0f0;
            padding: 15px;
            font-size: 14px;
            color: #0f0;
            display: none;
            z-index: 1001;
        }

        #console.show {
            display: block;
        }

        #consoleOutput {
            height: 150px;
            overflow-y: auto;
            margin-bottom: 10px;
            font-size: 12px;
        }

        #consoleInput {
            width: 100%;
            background: #000;
            border: 1px solid #0f0;
            color: #0f0;
            padding: 5px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }

        #consoleInput:focus {
            outline: none;
            box-shadow: 0 0 5px #0f0;
        }

        #htmlPage {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a1a1a;
            color: #0f0;
            padding: 20px;
            font-size: 12px;
            display: none;
            z-index: 998;
            overflow: auto;
        }

        #htmlPage.show {
            display: block;
        }

        .html-element {
            cursor: pointer;
            padding: 2px 5px;
            border-left: 2px solid #333;
            margin-left: 20px;
        }

        .html-element:hover {
            background: rgba(0, 255, 0, 0.1);
            border-left-color: #0f0;
        }

        .html-element.platform {
            background: rgba(0, 255, 0, 0.2);
        }

        #stats {
            position: fixed;
            bottom: 10px;
            right: 10px;
            color: #0f0;
            font-size: 14px;
            z-index: 1000;
            text-align: right;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border: 1px solid #0f0;
        }

        #mobileControls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            gap: 10px;
            z-index: 1000;
        }

        .mobile-btn {
            width: 60px;
            height: 60px;
            background: rgba(0, 255, 0, 0.2);
            border: 2px solid #0f0;
            color: #0f0;
            font-size: 24px;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .mobile-btn:active {
            background: rgba(0, 255, 0, 0.4);
        }

        @media (max-width: 768px) {
            #mobileControls {
                display: flex;
            }
        }

        .glitch {
            animation: glitch 0.3s infinite;
        }

        @keyframes glitch {
            0% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
            100% { transform: translate(0); }
        }

        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                rgba(18, 16, 16, 0) 50%,
                rgba(0, 0, 0, 0.25) 50%
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 9999;
            opacity: 0;
        }

        .scanlines.show {
            opacity: 0.1;
        }

        #menu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #0f0;
            padding: 40px;
            z-index: 2000;
            text-align: center;
            display: none;
        }

        #menu.show {
            display: block;
        }

        .menu-title {
            font-size: 48px;
            margin-bottom: 30px;
            text-shadow: 0 0 20px #0f0;
        }

        .menu-btn {
            display: block;
            width: 300px;
            padding: 15px;
            margin: 10px auto;
            background: transparent;
            border: 2px solid #0f0;
            color: #0f0;
            font-size: 18px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: all 0.2s;
        }

        .menu-btn:hover {
            background: #0f0;
            color: #000;
            box-shadow: 0 0 20px #0f0;
        }

        .level-select {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 20px;
        }

        .level-btn {
            padding: 15px;
            background: transparent;
            border: 2px solid #0f0;
            color: #0f0;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
        }

        .level-btn:hover {
            background: rgba(0, 255, 0, 0.2);
        }

        .level-btn.locked {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .level-btn.completed {
            border-color: #ff0;
            color: #ff0;
        }
    </style>
</head>
<body>
    <div class="scanlines"></div>

    <div id="menu" class="show">
        <div class="menu-title">WETWARE</div>
        <button class="menu-btn" id="startBtn">START GAME</button>
        <button class="menu-btn" id="continueBtn">CONTINUE</button>
        <button class="menu-btn" id="levelSelectBtn">LEVEL SELECT</button>
        <div id="levelSelectMenu" style="display: none;">
            <div class="level-select" id="levelButtons"></div>
        </div>
    </div>

    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
    </div>

    <div id="narrator"></div>
    <div id="levelTitle"></div>
    <div id="codeEditor"></div>
    <div id="console">
        <div id="consoleOutput"></div>
        <input type="text" id="consoleInput" placeholder=">" autocomplete="off">
    </div>
    <div id="htmlPage"></div>

    <div id="stats">
        <div id="deathCounter">DEATHS: 0</div>
        <div id="fragmentCounter">FRAGMENTS: 0/12</div>
    </div>

    <div id="mobileControls">
        <button class="mobile-btn" id="leftBtn">←</button>
        <button class="mobile-btn" id="jumpBtn">↑</button>
        <button class="mobile-btn" id="rightBtn">→</button>
        <button class="mobile-btn" id="interactBtn">E</button>
    </div>

    <script>
        // Audio Context
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let masterGain = audioCtx.createGain();
        masterGain.connect(audioCtx.destination);
        masterGain.gain.value = 0.3;

        // Audio Functions
        function playSound(type) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(masterGain);

            const now = audioCtx.currentTime;

            switch(type) {
                case 'jump':
                    osc.frequency.setValueAtTime(300, now);
                    osc.frequency.exponentialRampToValueAtTime(500, now + 0.1);
                    gain.gain.setValueAtTime(0.3, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    osc.start(now);
                    osc.stop(now + 0.1);
                    break;
                case 'collect':
                    osc.frequency.setValueAtTime(500, now);
                    osc.frequency.exponentialRampToValueAtTime(1000, now + 0.2);
                    gain.gain.setValueAtTime(0.3, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                    osc.start(now);
                    osc.stop(now + 0.2);
                    break;
                case 'death':
                    osc.frequency.setValueAtTime(200, now);
                    osc.frequency.exponentialRampToValueAtTime(50, now + 0.5);
                    gain.gain.setValueAtTime(0.3, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                    osc.start(now);
                    osc.stop(now + 0.5);
                    break;
                case 'glitch':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(Math.random() * 500 + 100, now);
                    gain.gain.setValueAtTime(0.2, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    osc.start(now);
                    osc.stop(now + 0.1);
                    break;
                case 'type':
                    osc.frequency.setValueAtTime(800, now);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                    osc.start(now);
                    osc.stop(now + 0.05);
                    break;
            }
        }

        let bgMusic = null;
        let musicOscillators = [];

        function startMusic(corruption = 0) {
            stopMusic();

            const notes = [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25];
            const melody = [0, 2, 4, 2, 0, 2, 4, 2, 4, 5, 7, 4, 5, 7];
            const noteDuration = 0.3;
            let noteIndex = 0;

            function playNote() {
                if (!bgMusic) return;

                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(masterGain);

                let freq = notes[melody[noteIndex]];

                // Add corruption
                if (corruption > 0) {
                    freq *= 1 + (Math.random() - 0.5) * corruption * 0.3;
                }

                osc.frequency.value = freq;
                osc.type = corruption > 0.5 ? 'sawtooth' : 'square';

                const now = audioCtx.currentTime;
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + noteDuration);

                osc.start(now);
                osc.stop(now + noteDuration);

                noteIndex = (noteIndex + 1) % melody.length;

                // Add random skips for corruption
                if (corruption > 0.3 && Math.random() < corruption * 0.3) {
                    noteIndex = Math.floor(Math.random() * melody.length);
                }

                const nextDelay = noteDuration * 1000 * (1 + (Math.random() - 0.5) * corruption * 0.5);
                bgMusic = setTimeout(playNote, nextDelay);
            }

            playNote();
        }

        function stopMusic() {
            if (bgMusic) {
                clearTimeout(bgMusic);
                bgMusic = null;
            }
        }

        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game state
        let gameState = {
            currentLevel: 0,
            paused: false,
            totalDeaths: 0,
            collectedFragments: 0,
            completedLevels: new Set(),
            levelTimes: {},
            noclip: false,
            godMode: false,
            customPlatforms: [],
            draggingWindow: false,
            resizingWindow: false,
            windowScale: 1
        };

        // Player
        const player = {
            x: 100,
            y: 400,
            width: 20,
            height: 30,
            vx: 0,
            vy: 0,
            grounded: false,
            facingRight: true,
            dead: false
        };

        // Input
        const keys = {};
        const PLAYER_SPEED = 4;
        const JUMP_FORCE = -12;
        const GRAVITY = 0.5;
        const MAX_FALL_SPEED = 15;

        // Level data
        const levels = [
            // Level 1: TUTORIAL
            {
                name: "TUTORIAL",
                narration: [
                    "Welcome. This is a simple test.",
                    "Collect the data fragment. Nothing more."
                ],
                platforms: [
                    {x: 0, y: 580, width: 800, height: 20, color: '#0f0'},
                    {x: 300, y: 480, width: 200, height: 20, color: '#0f0'},
                    {x: 600, y: 380, width: 150, height: 20, color: '#0f0'}
                ],
                spikes: [],
                fragment: {x: 650, y: 320},
                portal: {x: 750, y: 500},
                spawn: {x: 100, y: 500},
                corruption: 0,
                gravityZones: []
            },
            // Level 2: BASIC TRAINING
            {
                name: "BASIC TRAINING",
                narration: [
                    "Good. You understand the basics.",
                    "Let's add some challenge."
                ],
                platforms: [
                    {x: 0, y: 580, width: 200, height: 20, color: '#0f0'},
                    {x: 250, y: 480, width: 100, height: 20, color: '#0f0', moving: true, moveX: 250, moveEndX: 450, moveSpeed: 2},
                    {x: 500, y: 400, width: 100, height: 20, color: '#0f0'},
                    {x: 650, y: 320, width: 150, height: 20, color: '#0f0'}
                ],
                spikes: [
                    {x: 200, y: 560, width: 50, height: 20},
                    {x: 350, y: 560, width: 100, height: 20}
                ],
                fragment: {x: 700, y: 260},
                portal: {x: 50, y: 500},
                spawn: {x: 50, y: 500},
                corruption: 0,
                gravityZones: []
            },
            // Level 3: ROUTINE
            {
                name: "ROUTINE",
                narration: [
                    "Excellent progress. Everything is normal.",
                    "Just a routine test. Everything is under control."
                ],
                platforms: [
                    {x: 0, y: 580, width: 150, height: 20, color: '#0f0'},
                    {x: 200, y: 500, width: 100, height: 20, color: '#0f0'},
                    {x: 350, y: 420, width: 100, height: 20, color: '#0f0'},
                    {x: 500, y: 350, width: 100, height: 20, color: '#0f0'},
                    {x: 650, y: 450, width: 150, height: 20, color: '#0f0'},
                    {x: 400, y: 250, width: 200, height: 20, color: '#f00', trigger: 'door'}
                ],
                spikes: [
                    {x: 150, y: 560, width: 50, height: 20},
                    {x: 600, y: 560, width: 200, height: 20}
                ],
                switches: [{x: 700, y: 420, opens: 'door'}],
                fragment: {x: 500, y: 190},
                portal: {x: 50, y: 500},
                spawn: {x: 50, y: 500},
                corruption: 0.1,
                gravityZones: []
            },
            // Level 4: CORRUPTION
            {
                name: "CORRUPTION",
                narration: [
                    "Something's wrong. Don't worry.",
                    "The system is... adjusting. Everything is fine.",
                    "Use the corruption to proceed."
                ],
                platforms: [
                    {x: 0, y: 580, width: 150, height: 20, color: '#0f0'},
                    {x: 200, y: 450, width: 100, height: 20, color: '#f0f'},
                    {x: 350, y: 350, width: 100, height: 20, color: '#ff0'},
                    {x: 500, y: 280, width: 100, height: 20, color: '#0ff', invisible: true},
                    {x: 650, y: 400, width: 150, height: 20, color: '#f0f'}
                ],
                spikes: [
                    {x: 300, y: 560, width: 300, height: 20}
                ],
                fragment: {x: 550, y: 220},
                portal: {x: 700, y: 320},
                spawn: {x: 50, y: 500},
                corruption: 0.3,
                gravityZones: []
            },
            // Level 5: OVERFLOW
            {
                name: "OVERFLOW",
                narration: [
                    "Gravity is unstable. Or maybe it's you.",
                    "The corrupted zones will flip your world.",
                    "Use them."
                ],
                platforms: [
                    {x: 0, y: 580, width: 200, height: 20, color: '#0f0'},
                    {x: 250, y: 450, width: 150, height: 20, color: '#0f0'},
                    {x: 450, y: 320, width: 150, height: 20, color: '#0f0'},
                    {x: 650, y: 200, width: 150, height: 20, color: '#0f0'},
                    {x: 0, y: 0, width: 200, height: 20, color: '#0f0'},
                    {x: 250, y: 100, width: 150, height: 20, color: '#0f0'}
                ],
                spikes: [],
                fragment: {x: 100, y: 30},
                portal: {x: 50, y: 500},
                spawn: {x: 50, y: 500},
                corruption: 0.4,
                gravityZones: [
                    {x: 200, y: 0, width: 50, height: 600, inverted: true}
                ]
            },
            // Level 6: OUT OF BOUNDS
            {
                name: "OUT_OF_BOUNDS",
                narration: [
                    "You're not supposed to be here.",
                    "The boundaries are breaking down.",
                    "Go through the crack. Find what's hidden in the void."
                ],
                platforms: [
                    {x: 0, y: 580, width: 300, height: 20, color: '#0f0'},
                    {x: 400, y: 450, width: 200, height: 20, color: '#0f0'},
                    {x: 650, y: 320, width: 150, height: 20, color: '#0f0'}
                ],
                spikes: [],
                fragment: {x: -150, y: 300},
                portal: {x: 700, y: 240},
                spawn: {x: 50, y: 500},
                corruption: 0.5,
                gravityZones: [],
                boundary: {visible: true, crack: {x: -10, y: 250, width: 20, height: 150}},
                uiPlatforms: true
            },
            // Level 7: SOURCE
            {
                name: "SOURCE",
                narration: [
                    "You shouldn't be able to see this.",
                    "Stop looking at the code.",
                    "...fine. Use it if you must."
                ],
                platforms: [
                    {x: 0, y: 580, width: 200, height: 20, color: '#0f0'},
                    {x: 400, y: 450, width: 200, height: 20, color: '#0f0', editable: true, id: 'platform1'},
                    {x: 650, y: 280, width: 150, height: 20, color: '#0f0'}
                ],
                spikes: [],
                fragment: {x: 700, y: 220},
                portal: {x: 50, y: 500},
                spawn: {x: 50, y: 500},
                corruption: 0.6,
                gravityZones: [],
                codeEditor: true
            },
            // Level 8: ECHO
            {
                name: "ECHO",
                narration: [
                    "Three instances. All you. All different.",
                    "What you do echoes through them all.",
                    "Coordinate with yourself."
                ],
                platforms: [
                    {x: 0, y: 580, width: 150, height: 20, color: '#0f0'},
                    {x: 200, y: 450, width: 100, height: 20, color: '#0f0'},
                    {x: 350, y: 350, width: 100, height: 20, color: '#0f0'},
                    {x: 500, y: 450, width: 100, height: 20, color: '#0f0'},
                    {x: 650, y: 350, width: 150, height: 20, color: '#0f0'}
                ],
                spikes: [],
                fragment: {x: 700, y: 290},
                portal: {x: 50, y: 500},
                spawn: {x: 50, y: 500},
                corruption: 0.7,
                gravityZones: [],
                multiInstance: true,
                instances: 3
            },
            // Level 9: ADMINISTRATOR
            {
                name: "ADMINISTRATOR",
                narration: [
                    "Debug console active. You have root access.",
                    "Type commands. Change reality.",
                    "But the console lies sometimes. Trust nothing."
                ],
                platforms: [
                    {x: 0, y: 580, width: 200, height: 20, color: '#0f0'},
                    {x: 600, y: 300, width: 200, height: 20, color: '#0f0'}
                ],
                spikes: [
                    {x: 200, y: 560, width: 400, height: 20}
                ],
                fragment: {x: 700, y: 240},
                portal: {x: 50, y: 500},
                spawn: {x: 50, y: 500},
                corruption: 0.8,
                gravityZones: [],
                console: true
            },
            // Level 10: THE PAGE
            {
                name: "THE_PAGE",
                narration: [
                    "The game is shrinking. The page is visible.",
                    "You're outside the game now.",
                    "Click the HTML. Find the fragment hidden in the source."
                ],
                platforms: [
                    {x: 0, y: 580, width: 200, height: 20, color: '#0f0'}
                ],
                spikes: [],
                fragment: {x: -999, y: -999, hiddenInHTML: true},
                portal: {x: 50, y: 500},
                spawn: {x: 50, y: 500},
                corruption: 0.9,
                gravityZones: [],
                htmlView: true
            },
            // Level 11: WINDOW
            {
                name: "WINDOW",
                narration: [
                    "The game window is yours to control.",
                    "Drag it. Resize it. See beyond.",
                    "The level is bigger than what you see."
                ],
                platforms: [
                    {x: 0, y: 580, width: 200, height: 20, color: '#0f0'},
                    {x: 300, y: 450, width: 150, height: 20, color: '#0f0'},
                    {x: 550, y: 350, width: 150, height: 20, color: '#0f0'},
                    {x: 800, y: 450, width: 200, height: 20, color: '#0f0'},
                    {x: 1100, y: 350, width: 150, height: 20, color: '#0f0'},
                    {x: 1300, y: 250, width: 200, height: 20, color: '#0f0'}
                ],
                spikes: [],
                fragment: {x: 1400, y: 190},
                portal: {x: 50, y: 500},
                spawn: {x: 50, y: 500},
                corruption: 0.95,
                gravityZones: [],
                draggableWindow: true,
                expandedWorld: true,
                worldWidth: 1600,
                worldHeight: 600
            },
            // Level 12: ROOT ACCESS
            {
                name: "ROOT_ACCESS",
                narration: [
                    "This is the end. Or the beginning.",
                    "You're in the game's memory now.",
                    "Navigate the abstract. Find the final truth.",
                    "You were never just a player."
                ],
                platforms: [],
                spikes: [],
                fragment: {x: 400, y: 100},
                portal: null,
                spawn: {x: 400, y: 500},
                corruption: 1.0,
                gravityZones: [],
                abstract: true,
                memoryBlocks: [
                    {x: 200, y: 450, width: 80, height: 80, data: 'PLAYER', float: true},
                    {x: 400, y: 350, width: 80, height: 80, data: 'LEVEL', float: true},
                    {x: 600, y: 450, width: 80, height: 80, data: 'WORLD', float: true},
                    {x: 300, y: 250, width: 80, height: 80, data: 'STATE', float: true},
                    {x: 500, y: 200, width: 80, height: 80, data: 'TRUTH', float: true}
                ]
            }
        ];

        let currentLevel = null;
        let levelStartTime = 0;
        let fragmentCollected = false;
        let activeSwitches = new Set();
        let narrationQueue = [];
        let narrationIndex = 0;
        let playerHistory = [];
        let cameraOffsetX = 0;
        let cameraOffsetY = 0;

        // Load save
        function loadGame() {
            const save = localStorage.getItem('wetware_save');
            if (save) {
                const data = JSON.parse(save);
                gameState = {...gameState, ...data, completedLevels: new Set(data.completedLevels)};
                updateStats();
            }
        }

        function saveGame() {
            const data = {
                ...gameState,
                completedLevels: Array.from(gameState.completedLevels)
            };
            localStorage.setItem('wetware_save', JSON.stringify(data));
        }

        // Menu
        document.getElementById('startBtn').addEventListener('click', () => {
            gameState.currentLevel = 0;
            gameState.totalDeaths = 0;
            gameState.collectedFragments = 0;
            gameState.completedLevels.clear();
            startLevel(0);
            hideMenu();
        });

        document.getElementById('continueBtn').addEventListener('click', () => {
            loadGame();
            startLevel(gameState.currentLevel);
            hideMenu();
        });

        document.getElementById('levelSelectBtn').addEventListener('click', () => {
            showLevelSelect();
        });

        function showMenu() {
            document.getElementById('menu').classList.add('show');
            stopMusic();
        }

        function hideMenu() {
            document.getElementById('menu').classList.remove('show');
        }

        function showLevelSelect() {
            const container = document.getElementById('levelButtons');
            container.innerHTML = '';

            levels.forEach((level, index) => {
                const btn = document.createElement('button');
                btn.className = 'level-btn';
                btn.textContent = `${index + 1}: ${level.name}`;

                if (gameState.completedLevels.has(index)) {
                    btn.classList.add('completed');
                } else if (index > gameState.currentLevel) {
                    btn.classList.add('locked');
                    btn.disabled = true;
                }

                btn.addEventListener('click', () => {
                    if (index <= gameState.currentLevel || gameState.completedLevels.has(index)) {
                        startLevel(index);
                        hideMenu();
                    }
                });

                container.appendChild(btn);
            });

            document.getElementById('levelSelectMenu').style.display = 'block';
        }

        // Level management
        function startLevel(index) {
            gameState.currentLevel = index;
            currentLevel = JSON.parse(JSON.stringify(levels[index]));
            fragmentCollected = false;
            player.dead = false;
            player.x = currentLevel.spawn.x;
            player.y = currentLevel.spawn.y;
            player.vx = 0;
            player.vy = 0;
            levelStartTime = Date.now();
            activeSwitches.clear();
            narrationIndex = 0;
            narrationQueue = [...currentLevel.narration];
            playerHistory = [];
            gameState.customPlatforms = [];
            gameState.noclip = false;
            gameState.godMode = false;
            cameraOffsetX = 0;
            cameraOffsetY = 0;

            // UI setup
            document.getElementById('codeEditor').classList.remove('show');
            document.getElementById('console').classList.remove('show');
            document.getElementById('htmlPage').classList.remove('show');
            document.querySelector('.scanlines').classList.toggle('show', currentLevel.corruption > 0.2);

            // Level-specific setup
            if (currentLevel.codeEditor) {
                setupCodeEditor();
            }

            if (currentLevel.console) {
                setupConsole();
            }

            if (currentLevel.htmlView) {
                setupHTMLView();
            }

            if (currentLevel.draggableWindow) {
                setupDraggableWindow();
            } else {
                document.getElementById('gameContainer').classList.remove('draggable');
                document.getElementById('gameContainer').style.width = '800px';
                document.getElementById('gameContainer').style.height = '600px';
            }

            // Show level title
            showLevelTitle();

            // Start music
            startMusic(currentLevel.corruption);

            // Show first narration after a delay
            setTimeout(showNextNarration, 2000);
        }

        function showLevelTitle() {
            const title = document.getElementById('levelTitle');
            title.textContent = `LEVEL ${gameState.currentLevel + 1}: ${currentLevel.name}`;
            title.classList.add('show');
            setTimeout(() => title.classList.remove('show'), 3000);
        }

        function showNextNarration() {
            if (narrationIndex < narrationQueue.length) {
                showNarration(narrationQueue[narrationIndex]);
                narrationIndex++;
            }
        }

        function showNarration(text) {
            const narrator = document.getElementById('narrator');
            narrator.textContent = '';
            narrator.classList.add('show');

            let i = 0;
            const typeInterval = setInterval(() => {
                if (i < text.length) {
                    narrator.textContent += text[i];
                    playSound('type');
                    i++;
                } else {
                    clearInterval(typeInterval);
                    setTimeout(() => {
                        narrator.classList.remove('show');
                        setTimeout(showNextNarration, 1000);
                    }, 3000);
                }
            }, 50);
        }

        function setupCodeEditor() {
            const editor = document.getElementById('codeEditor');
            editor.innerHTML = '<div style="margin-bottom: 10px;">// LEVEL SOURCE CODE</div>';

            const codeLines = [
                `let platforms = [`,
                `  {x: 0, y: 580, width: 200, height: 20},`,
                `  {x: 400, y: 450, width: 200, height: 20},`,
                `  {x: 250, y: 350, width: 150, height: 20}, // BLOCKED`,
                `  {x: 650, y: 280, width: 150, height: 20}`,
                `];`,
                `let gravity = 0.5;`,
                `let playerSpeed = 4;`
            ];

            codeLines.forEach((line, index) => {
                const div = document.createElement('div');
                div.className = 'code-line';
                div.textContent = line;
                div.dataset.lineIndex = index;

                if (index === 3) {
                    div.addEventListener('click', () => {
                        div.classList.toggle('active');
                        const blocked = div.classList.contains('active');

                        if (!blocked) {
                            currentLevel.platforms.push({
                                x: 250, y: 350, width: 150, height: 20, color: '#0f0'
                            });
                        } else {
                            currentLevel.platforms = currentLevel.platforms.filter(p =>
                                !(p.x === 250 && p.y === 350)
                            );
                        }
                    });
                }

                if (index === 6) {
                    div.addEventListener('click', () => {
                        div.classList.toggle('active');
                        const lowGrav = div.classList.contains('active');
                        // This changes gravity (used in physics)
                        if (lowGrav) {
                            div.textContent = 'let gravity = 0.2; // MODIFIED';
                        } else {
                            div.textContent = 'let gravity = 0.5;';
                        }
                    });
                }

                editor.appendChild(div);
            });

            editor.classList.add('show');
        }

        function setupConsole() {
            const consoleEl = document.getElementById('console');
            const output = document.getElementById('consoleOutput');
            const input = document.getElementById('consoleInput');

            output.innerHTML = '> ADMINISTRATOR CONSOLE ACTIVE<br>> TYPE HELP FOR COMMANDS<br><br>';

            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    const cmd = input.value.trim().toLowerCase();
                    input.value = '';

                    output.innerHTML += `> ${cmd}<br>`;
                    executeCommand(cmd, output);
                    output.scrollTop = output.scrollHeight;
                }
            });

            consoleEl.classList.add('show');
        }

        function executeCommand(cmd, output) {
            // The console sometimes lies!
            const shouldLie = Math.random() < 0.3;

            if (cmd === 'help') {
                output.innerHTML += 'COMMANDS: god, noclip, spawn platform X Y<br><br>';
            } else if (cmd === 'god') {
                if (shouldLie) {
                    output.innerHTML += 'ERROR: Command not recognized<br><br>';
                } else {
                    gameState.godMode = !gameState.godMode;
                    output.innerHTML += `God mode ${gameState.godMode ? 'enabled' : 'disabled'}<br><br>`;
                }
            } else if (cmd === 'noclip') {
                if (shouldLie) {
                    output.innerHTML += 'Noclip disabled<br><br>';
                    gameState.noclip = true; // Opposite!
                } else {
                    gameState.noclip = !gameState.noclip;
                    output.innerHTML += `Noclip ${gameState.noclip ? 'enabled' : 'disabled'}<br><br>`;
                }
            } else if (cmd.startsWith('spawn platform')) {
                const parts = cmd.split(' ');
                if (parts.length === 4) {
                    const x = parseInt(parts[2]);
                    const y = parseInt(parts[3]);

                    if (shouldLie) {
                        output.innerHTML += `ERROR: Invalid coordinates<br><br>`;
                        // But actually spawn it anyway
                        gameState.customPlatforms.push({
                            x: x, y: y, width: 100, height: 20, color: '#0ff'
                        });
                    } else {
                        gameState.customPlatforms.push({
                            x: x, y: y, width: 100, height: 20, color: '#0ff'
                        });
                        output.innerHTML += `Platform spawned at ${x}, ${y}<br><br>`;
                    }
                } else {
                    output.innerHTML += 'Usage: spawn platform X Y<br><br>';
                }
            } else {
                output.innerHTML += 'ERROR: Command not recognized<br><br>';
            }
        }

        function setupHTMLView() {
            const htmlPage = document.getElementById('htmlPage');
            const gameContainer = document.getElementById('gameContainer');

            gameContainer.style.width = '400px';
            gameContainer.style.height = '300px';
            gameContainer.style.top = '100px';
            gameContainer.style.left = '100px';
            gameContainer.style.transform = 'none';

            htmlPage.innerHTML = `
                <div style="color: #666; margin-bottom: 20px;">viewing: wetware.html</div>
                <div>&lt;!DOCTYPE html&gt;</div>
                <div class="html-element" data-element="html">&lt;html&gt;</div>
                <div class="html-element" data-element="head" style="margin-left: 40px;">&lt;head&gt;</div>
                <div class="html-element" data-element="title" style="margin-left: 60px;">&lt;title&gt;WETWARE&lt;/title&gt;</div>
                <div class="html-element" data-element="style" style="margin-left: 60px;">&lt;style&gt;...&lt;/style&gt;</div>
                <div class="html-element" style="margin-left: 40px;">&lt;/head&gt;</div>
                <div class="html-element" data-element="body" style="margin-left: 40px;">&lt;body&gt;</div>
                <div class="html-element" data-element="canvas" style="margin-left: 60px;">&lt;canvas id="gameCanvas"&gt;&lt;/canvas&gt;</div>
                <div class="html-element" data-element="fragment" style="margin-left: 60px; color: #ff0;">&lt;!-- DATA FRAGMENT HIDDEN HERE --&gt;</div>
                <div class="html-element" data-element="script" style="margin-left: 60px;">&lt;script&gt;...&lt;/script&gt;</div>
                <div class="html-element" style="margin-left: 40px;">&lt;/body&gt;</div>
                <div class="html-element">&lt;/html&gt;</div>
            `;

            const elements = htmlPage.querySelectorAll('.html-element');
            elements.forEach(el => {
                el.addEventListener('click', () => {
                    el.classList.toggle('platform');

                    if (el.dataset.element === 'fragment') {
                        // Found the fragment!
                        currentLevel.fragment.x = 200;
                        currentLevel.fragment.y = 250;
                        currentLevel.fragment.hiddenInHTML = false;
                    }

                    if (el.classList.contains('platform')) {
                        const rect = el.getBoundingClientRect();
                        gameState.customPlatforms.push({
                            x: Math.random() * 300 + 50,
                            y: Math.random() * 200 + 100,
                            width: 80,
                            height: 15,
                            color: '#0f0'
                        });
                    }
                });
            });

            htmlPage.classList.add('show');
        }

        function setupDraggableWindow() {
            const container = document.getElementById('gameContainer');
            container.classList.add('draggable');

            let isDragging = false;
            let startX, startY, initialLeft, initialTop;

            container.addEventListener('mousedown', (e) => {
                if (e.target === container) {
                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    const rect = container.getBoundingClientRect();
                    initialLeft = rect.left;
                    initialTop = rect.top;
                    container.style.transform = 'none';
                }
            });

            window.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;
                    container.style.left = (initialLeft + dx) + 'px';
                    container.style.top = (initialTop + dy) + 'px';
                }
            });

            window.addEventListener('mouseup', () => {
                isDragging = false;
            });

            // Update camera offset based on window position
            setInterval(() => {
                if (currentLevel && currentLevel.expandedWorld) {
                    const rect = container.getBoundingClientRect();
                    cameraOffsetX = -(rect.left - window.innerWidth / 2 + 400);
                    cameraOffsetY = -(rect.top - window.innerHeight / 2 + 300);
                }
            }, 100);
        }

        // Physics and collision
        function updatePlayer(dt) {
            if (player.dead) return;

            // Input
            let moveX = 0;
            if (keys['ArrowLeft'] || keys['a'] || keys['A']) moveX -= 1;
            if (keys['ArrowRight'] || keys['d'] || keys['D']) moveX += 1;

            player.vx = moveX * PLAYER_SPEED;
            if (moveX !== 0) player.facingRight = moveX > 0;

            // Gravity
            const gravityModifier = isInInvertedGravity() ? -1 : 1;
            const codeGravityMod = document.querySelector('.code-line.active[data-line-index="6"]') ? 0.4 : 1;

            if (!player.grounded || Math.abs(player.vy) > 0.1) {
                player.vy += GRAVITY * gravityModifier * codeGravityMod;
            }

            if (Math.abs(player.vy) > MAX_FALL_SPEED) {
                player.vy = MAX_FALL_SPEED * Math.sign(player.vy);
            }

            // Jump
            if ((keys[' '] || keys['ArrowUp'] || keys['w'] || keys['W']) && player.grounded) {
                player.vy = JUMP_FORCE * gravityModifier;
                player.grounded = false;
                playSound('jump');
            }

            // Noclip mode
            if (gameState.noclip) {
                player.x += player.vx;
                player.y += player.vy * 0.5;
                player.grounded = false;
                return;
            }

            // Move X
            player.x += player.vx;
            checkCollisionX();

            // Move Y
            player.y += player.vy;
            player.grounded = false;
            checkCollisionY();

            // Multi-instance mode - record history
            if (currentLevel.multiInstance) {
                playerHistory.push({
                    x: player.x,
                    y: player.y,
                    facingRight: player.facingRight,
                    frame: Date.now()
                });

                // Keep only last 60 frames (1 second at 60fps)
                if (playerHistory.length > 60) {
                    playerHistory.shift();
                }
            }

            // Check death
            if (!gameState.godMode) {
                checkDeath();
            }

            // Collect fragment
            checkFragmentCollection();

            // Check switches
            checkSwitches();
        }

        function isInInvertedGravity() {
            if (!currentLevel.gravityZones) return false;

            return currentLevel.gravityZones.some(zone => {
                return zone.inverted &&
                    player.x + player.width > zone.x &&
                    player.x < zone.x + zone.width &&
                    player.y + player.height > zone.y &&
                    player.y < zone.y + zone.height;
            });
        }

        function checkCollisionX() {
            const allPlatforms = [
                ...(currentLevel.platforms || []),
                ...gameState.customPlatforms
            ];

            for (let platform of allPlatforms) {
                if (platform.trigger && !activeSwitches.has(platform.trigger)) continue;
                if (platform.invisible && currentLevel.corruption < 0.3) continue;

                if (player.x + player.width > platform.x &&
                    player.x < platform.x + platform.width &&
                    player.y + player.height > platform.y &&
                    player.y < platform.y + platform.height) {

                    if (player.vx > 0) {
                        player.x = platform.x - player.width;
                    } else {
                        player.x = platform.x + platform.width;
                    }
                    player.vx = 0;
                }
            }

            // UI platforms for level 6
            if (currentLevel.uiPlatforms) {
                const narrator = document.getElementById('narrator');
                const stats = document.getElementById('stats');

                if (narrator.classList.contains('show')) {
                    const rect = narrator.getBoundingClientRect();
                    checkUICollision(rect);
                }

                const statsRect = stats.getBoundingClientRect();
                checkUICollision(statsRect);
            }
        }

        function checkCollisionY() {
            const allPlatforms = [
                ...(currentLevel.platforms || []),
                ...gameState.customPlatforms
            ];

            for (let platform of allPlatforms) {
                if (platform.trigger && !activeSwitches.has(platform.trigger)) continue;
                if (platform.invisible && currentLevel.corruption < 0.3) continue;

                if (player.x + player.width > platform.x &&
                    player.x < platform.x + platform.width &&
                    player.y + player.height > platform.y &&
                    player.y < platform.y + platform.height) {

                    const gravityInverted = isInInvertedGravity();

                    if ((!gravityInverted && player.vy > 0) || (gravityInverted && player.vy < 0)) {
                        player.y = platform.y - player.height;
                        player.vy = 0;
                        player.grounded = true;
                    } else {
                        player.y = platform.y + platform.height;
                        player.vy = 0;
                    }
                }
            }
        }

        function checkUICollision(rect) {
            // This is a hack for level 6 where UI elements become platforms
            // Convert screen coords to game coords roughly
            const uiPlatform = {
                x: (rect.left / window.innerWidth) * 800,
                y: (rect.top / window.innerHeight) * 600,
                width: (rect.width / window.innerWidth) * 800,
                height: 20
            };

            if (player.x + player.width > uiPlatform.x &&
                player.x < uiPlatform.x + uiPlatform.width &&
                player.y + player.height > uiPlatform.y &&
                player.y < uiPlatform.y + uiPlatform.height) {

                if (player.vy > 0) {
                    player.y = uiPlatform.y - player.height;
                    player.vy = 0;
                    player.grounded = true;
                }
            }
        }

        function checkDeath() {
            // Spikes
            if (currentLevel.spikes) {
                for (let spike of currentLevel.spikes) {
                    if (player.x + player.width > spike.x &&
                        player.x < spike.x + spike.width &&
                        player.y + player.height > spike.y &&
                        player.y < spike.y + spike.height) {
                        die();
                        return;
                    }
                }
            }

            // Fall off world
            if (player.y > 700) {
                die();
            }
        }

        function checkFragmentCollection() {
            if (fragmentCollected) return;
            if (currentLevel.fragment.hiddenInHTML) return;

            const fragment = currentLevel.fragment;
            const dist = Math.sqrt(
                Math.pow(player.x + player.width/2 - fragment.x, 2) +
                Math.pow(player.y + player.height/2 - fragment.y, 2)
            );

            if (dist < 30) {
                fragmentCollected = true;
                gameState.collectedFragments++;
                gameState.completedLevels.add(gameState.currentLevel);
                playSound('collect');
                updateStats();
                saveGame();

                // Show portal
                if (currentLevel.portal) {
                    setTimeout(() => {
                        showNarration("Data fragment acquired. Portal opened.");
                    }, 500);
                } else if (gameState.currentLevel === 11) {
                    // Final level - victory!
                    setTimeout(showVictory, 1000);
                }
            }
        }

        function checkSwitches() {
            if (!currentLevel.switches) return;

            for (let sw of currentLevel.switches) {
                const dist = Math.sqrt(
                    Math.pow(player.x + player.width/2 - sw.x, 2) +
                    Math.pow(player.y + player.height/2 - sw.y, 2)
                );

                if (dist < 30 && (keys['e'] || keys['E'])) {
                    if (!activeSwitches.has(sw.opens)) {
                        activeSwitches.add(sw.opens);
                        playSound('collect');
                    }
                }
            }
        }

        function die() {
            if (player.dead) return;
            player.dead = true;
            gameState.totalDeaths++;
            updateStats();
            playSound('death');

            ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            setTimeout(() => {
                player.x = currentLevel.spawn.x;
                player.y = currentLevel.spawn.y;
                player.vx = 0;
                player.vy = 0;
                player.dead = false;
            }, 500);
        }

        function showVictory() {
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            setTimeout(() => {
                // Credits as platforming section
                showNarration("You are free. The game is yours now.");

                setTimeout(() => {
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#0f0';
                    ctx.font = '24px "Courier New"';
                    ctx.textAlign = 'center';

                    const credits = [
                        '',
                        'WETWARE',
                        '',
                        'A game about breaking free',
                        '',
                        'Created for localFirstTools',
                        '',
                        'Thank you for playing',
                        '',
                        'Press R to restart',
                        '',
                        'The fourth wall was an illusion',
                        'You had the power all along',
                        ''
                    ];

                    credits.forEach((line, i) => {
                        ctx.fillText(line, canvas.width/2, 50 + i * 30);
                    });
                }, 2000);
            }, 1000);
        }

        // Rendering
        function render() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Apply camera offset for level 11
            if (currentLevel && currentLevel.expandedWorld) {
                ctx.save();
                ctx.translate(-cameraOffsetX * 0.5, -cameraOffsetY * 0.5);
            }

            // Corruption effects
            if (currentLevel && currentLevel.corruption > 0) {
                applyCorruption();
            }

            // Gravity zones
            if (currentLevel && currentLevel.gravityZones) {
                currentLevel.gravityZones.forEach(zone => {
                    ctx.fillStyle = zone.inverted ? 'rgba(255, 0, 255, 0.1)' : 'rgba(0, 255, 255, 0.1)';
                    ctx.fillRect(zone.x, zone.y, zone.width, zone.height);

                    // Glitch pattern
                    for (let i = 0; i < 5; i++) {
                        ctx.fillStyle = `rgba(255, 0, 255, ${Math.random() * 0.3})`;
                        ctx.fillRect(
                            zone.x + Math.random() * zone.width,
                            zone.y + Math.random() * zone.height,
                            Math.random() * 20,
                            Math.random() * 20
                        );
                    }
                });
            }

            // Platforms
            if (currentLevel) {
                const allPlatforms = [
                    ...(currentLevel.platforms || []),
                    ...gameState.customPlatforms
                ];

                allPlatforms.forEach(platform => {
                    if (platform.trigger && !activeSwitches.has(platform.trigger)) return;

                    // Update moving platforms
                    if (platform.moving) {
                        if (!platform.moveDir) platform.moveDir = 1;
                        platform.x += platform.moveSpeed * platform.moveDir;

                        if (platform.x <= platform.moveX || platform.x >= platform.moveEndX) {
                            platform.moveDir *= -1;
                        }
                    }

                    if (platform.invisible && currentLevel.corruption < 0.3) return;

                    ctx.fillStyle = platform.color || '#0f0';
                    ctx.fillRect(platform.x, platform.y, platform.width, platform.height);

                    // Glitch effect on colored platforms
                    if (platform.color !== '#0f0' && Math.random() < currentLevel.corruption * 0.3) {
                        ctx.fillStyle = `rgba(${Math.random()*255}, ${Math.random()*255}, ${Math.random()*255}, 0.5)`;
                        ctx.fillRect(
                            platform.x + Math.random() * platform.width,
                            platform.y,
                            Math.random() * 20,
                            platform.height
                        );
                    }
                });
            }

            // Spikes
            if (currentLevel && currentLevel.spikes) {
                ctx.fillStyle = '#f00';
                currentLevel.spikes.forEach(spike => {
                    for (let i = 0; i < spike.width; i += 20) {
                        ctx.beginPath();
                        ctx.moveTo(spike.x + i, spike.y + spike.height);
                        ctx.lineTo(spike.x + i + 10, spike.y);
                        ctx.lineTo(spike.x + i + 20, spike.y + spike.height);
                        ctx.fill();
                    }
                });
            }

            // Switches
            if (currentLevel && currentLevel.switches) {
                currentLevel.switches.forEach(sw => {
                    const active = activeSwitches.has(sw.opens);
                    ctx.fillStyle = active ? '#ff0' : '#0f0';
                    ctx.fillRect(sw.x - 10, sw.y - 10, 20, 20);
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(sw.x - 10, sw.y - 10, 20, 20);
                });
            }

            // Fragment
            if (currentLevel && !fragmentCollected && !currentLevel.fragment.hiddenInHTML) {
                const time = Date.now() / 1000;
                const fragment = currentLevel.fragment;

                ctx.save();
                ctx.translate(fragment.x, fragment.y);
                ctx.rotate(time);

                ctx.fillStyle = '#ff0';
                ctx.fillRect(-10, -10, 20, 20);

                ctx.strokeStyle = '#0f0';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, 15 + Math.sin(time * 3) * 3, 0, Math.PI * 2);
                ctx.stroke();

                ctx.restore();
            }

            // Portal
            if (currentLevel && currentLevel.portal && fragmentCollected) {
                const portal = currentLevel.portal;
                const time = Date.now() / 1000;

                ctx.save();
                ctx.translate(portal.x, portal.y);

                for (let i = 0; i < 3; i++) {
                    ctx.strokeStyle = `rgba(0, 255, 255, ${0.5 - i * 0.15})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, 20 + i * 10 + Math.sin(time * 2 + i) * 5, 0, Math.PI * 2);
                    ctx.stroke();
                }

                ctx.restore();

                // Check if player enters portal
                const dist = Math.sqrt(
                    Math.pow(player.x + player.width/2 - portal.x, 2) +
                    Math.pow(player.y + player.height/2 - portal.y, 2)
                );

                if (dist < 30) {
                    if (gameState.currentLevel < levels.length - 1) {
                        gameState.currentLevel++;
                        startLevel(gameState.currentLevel);
                        saveGame();
                    }
                }
            }

            // Memory blocks (level 12)
            if (currentLevel && currentLevel.abstract && currentLevel.memoryBlocks) {
                currentLevel.memoryBlocks.forEach(block => {
                    if (block.float) {
                        block.y += Math.sin(Date.now() / 1000 + block.x) * 0.5;
                    }

                    ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
                    ctx.fillRect(block.x, block.y, block.width, block.height);

                    ctx.strokeStyle = '#0f0';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(block.x, block.y, block.width, block.height);

                    ctx.fillStyle = '#0f0';
                    ctx.font = '12px "Courier New"';
                    ctx.textAlign = 'center';
                    ctx.fillText(block.data, block.x + block.width/2, block.y + block.height/2 + 5);

                    // Can stand on memory blocks
                    if (player.x + player.width > block.x &&
                        player.x < block.x + block.width &&
                        player.y + player.height > block.y &&
                        player.y < block.y + block.height) {

                        if (player.vy > 0) {
                            player.y = block.y - player.height;
                            player.vy = 0;
                            player.grounded = true;
                        }
                    }
                });
            }

            // Boundary (level 6)
            if (currentLevel && currentLevel.boundary && currentLevel.boundary.visible) {
                ctx.strokeStyle = '#f00';
                ctx.lineWidth = 3;
                ctx.strokeRect(0, 0, canvas.width, canvas.height);

                // Crack
                if (currentLevel.boundary.crack) {
                    const crack = currentLevel.boundary.crack;
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                    ctx.fillRect(crack.x, crack.y, crack.width, crack.height);
                }
            }

            // Multi-instance echoes (level 8)
            if (currentLevel && currentLevel.multiInstance) {
                const delay1 = 20;
                const delay2 = 40;

                if (playerHistory.length > delay1) {
                    const echo1 = playerHistory[playerHistory.length - delay1];
                    drawPlayer(echo1.x, echo1.y, echo1.facingRight, 0.3);
                }

                if (playerHistory.length > delay2) {
                    const echo2 = playerHistory[playerHistory.length - delay2];
                    drawPlayer(echo2.x, echo2.y, echo2.facingRight, 0.15);
                }
            }

            // Player
            if (!player.dead) {
                drawPlayer(player.x, player.y, player.facingRight, 1.0);
            }

            if (currentLevel && currentLevel.expandedWorld) {
                ctx.restore();
            }

            // Chromatic aberration
            if (currentLevel && currentLevel.corruption > 0.5) {
                applyAberration();
            }
        }

        function drawPlayer(x, y, facingRight, alpha) {
            ctx.save();
            ctx.globalAlpha = alpha;

            // Body
            ctx.fillStyle = '#0ff';
            ctx.fillRect(x + 5, y + 10, 10, 15);

            // Head
            ctx.fillStyle = '#0ff';
            ctx.fillRect(x + 6, y + 2, 8, 8);

            // Arms
            ctx.fillStyle = '#0ff';
            ctx.fillRect(x + 3, y + 12, 3, 8);
            ctx.fillRect(x + 14, y + 12, 3, 8);

            // Legs
            ctx.fillStyle = '#0ff';
            ctx.fillRect(x + 6, y + 25, 3, 5);
            ctx.fillRect(x + 11, y + 25, 3, 5);

            // Face direction
            ctx.fillStyle = '#fff';
            if (facingRight) {
                ctx.fillRect(x + 11, y + 4, 2, 2);
            } else {
                ctx.fillRect(x + 7, y + 4, 2, 2);
            }

            ctx.restore();
        }

        function applyCorruption() {
            const corruption = currentLevel.corruption;

            // Random pixels
            for (let i = 0; i < corruption * 50; i++) {
                ctx.fillStyle = `rgba(${Math.random()*255}, ${Math.random()*255}, ${Math.random()*255}, ${corruption})`;
                ctx.fillRect(
                    Math.random() * canvas.width,
                    Math.random() * canvas.height,
                    Math.random() * 5,
                    Math.random() * 5
                );
            }

            // Screen tears
            if (Math.random() < corruption * 0.1) {
                const y = Math.random() * canvas.height;
                const imageData = ctx.getImageData(0, y, canvas.width, 1);
                const offset = (Math.random() - 0.5) * corruption * 50;
                ctx.putImageData(imageData, offset, y);
            }
        }

        function applyAberration() {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const offset = Math.floor(currentLevel.corruption * 5);

            for (let i = 0; i < data.length; i += 4) {
                const shiftedIndex = i + offset * 4;
                if (shiftedIndex < data.length) {
                    data[i] = data[shiftedIndex]; // R
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function updateStats() {
            document.getElementById('deathCounter').textContent = `DEATHS: ${gameState.totalDeaths}`;
            document.getElementById('fragmentCounter').textContent = `FRAGMENTS: ${gameState.collectedFragments}/12`;
        }

        // Input handlers
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;

            if (e.key === 'r' || e.key === 'R') {
                if (currentLevel) {
                    startLevel(gameState.currentLevel);
                }
            }

            if (e.key === 'Escape') {
                showMenu();
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Mobile controls
        document.getElementById('leftBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            keys['ArrowLeft'] = true;
        });
        document.getElementById('leftBtn').addEventListener('touchend', (e) => {
            e.preventDefault();
            keys['ArrowLeft'] = false;
        });

        document.getElementById('rightBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            keys['ArrowRight'] = true;
        });
        document.getElementById('rightBtn').addEventListener('touchend', (e) => {
            e.preventDefault();
            keys['ArrowRight'] = false;
        });

        document.getElementById('jumpBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            keys[' '] = true;
        });
        document.getElementById('jumpBtn').addEventListener('touchend', (e) => {
            e.preventDefault();
            keys[' '] = false;
        });

        document.getElementById('interactBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            keys['e'] = true;
        });
        document.getElementById('interactBtn').addEventListener('touchend', (e) => {
            e.preventDefault();
            keys['e'] = false;
        });

        // Game loop
        let lastTime = Date.now();

        function gameLoop() {
            const now = Date.now();
            const dt = (now - lastTime) / 1000;
            lastTime = now;

            if (!document.getElementById('menu').classList.contains('show')) {
                updatePlayer(dt);
                render();
            }

            requestAnimationFrame(gameLoop);
        }

        // Initialize
        loadGame();
        updateStats();
        gameLoop();
    </script>
</body>
</html>