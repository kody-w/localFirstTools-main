<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memory Palace - Navigate Your Corrupting Mind</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #fff;
            overflow: hidden;
            cursor: none;
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
            image-rendering: pixelated;
        }

        #ui {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
        }

        .hud-item {
            margin-bottom: 8px;
            transition: all 0.3s ease;
        }

        #corruptionBar {
            width: 200px;
            height: 20px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #fff;
            position: relative;
            overflow: hidden;
        }

        #corruptionFill {
            height: 100%;
            background: linear-gradient(90deg, #0f0, #ff0, #f00);
            transition: width 0.5s ease, background 0.5s ease;
        }

        #clarityBar {
            width: 200px;
            height: 20px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #fff;
            position: relative;
            overflow: hidden;
            margin-top: 5px;
        }

        #clarityFill {
            height: 100%;
            background: #4af;
            transition: width 0.3s ease;
        }

        #inventory {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
        }

        .inventory-slot {
            width: 50px;
            height: 50px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            position: relative;
        }

        .inventory-count {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 12px;
            background: rgba(0,0,0,0.8);
            padding: 2px 4px;
        }

        #minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background: rgba(0,0,0,0.8);
            border: 2px solid #fff;
        }

        #messageLog {
            position: absolute;
            bottom: 80px;
            left: 20px;
            width: 400px;
            max-height: 150px;
            overflow: hidden;
        }

        .message {
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            margin-bottom: 5px;
            border-left: 3px solid #4af;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        #menu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            border: 3px solid #fff;
            padding: 40px;
            pointer-events: all;
            display: none;
            min-width: 400px;
        }

        #menu.active {
            display: block;
        }

        .menu-title {
            font-size: 32px;
            text-align: center;
            margin-bottom: 30px;
            letter-spacing: 4px;
        }

        .menu-button {
            display: block;
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            background: rgba(255,255,255,0.1);
            border: 2px solid #fff;
            color: #fff;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            pointer-events: all;
        }

        .menu-button:hover {
            background: rgba(255,255,255,0.3);
            transform: translateX(10px);
        }

        #reconstructionPuzzle {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            border: 3px solid #fff;
            padding: 30px;
            pointer-events: all;
            display: none;
            max-width: 600px;
        }

        #reconstructionPuzzle.active {
            display: block;
        }

        .fragment-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 20px 0;
        }

        .fragment {
            padding: 20px;
            background: rgba(255,255,255,0.1);
            border: 2px solid #fff;
            cursor: pointer;
            transition: all 0.2s ease;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: 14px;
        }

        .fragment:hover {
            background: rgba(255,255,255,0.2);
        }

        .fragment.selected {
            background: rgba(68,170,255,0.3);
            border-color: #4af;
        }

        .fragment.correct {
            background: rgba(0,255,0,0.3);
            border-color: #0f0;
        }

        .fragment.wrong {
            background: rgba(255,0,0,0.3);
            border-color: #f00;
            animation: shake 0.3s ease;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        .sequence-display {
            display: flex;
            gap: 5px;
            margin: 20px 0;
            min-height: 40px;
        }

        .sequence-slot {
            flex: 1;
            padding: 10px;
            background: rgba(0,0,0,0.5);
            border: 2px dashed #666;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .sequence-slot.filled {
            border-style: solid;
            border-color: #4af;
        }

        #cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            border: 2px solid #fff;
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            transition: all 0.1s ease;
        }

        #cursor.interact {
            background: rgba(255,255,255,0.3);
            transform: scale(1.5);
        }

        .glitch {
            animation: glitch 0.3s infinite;
        }

        @keyframes glitch {
            0% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
            100% { transform: translate(0); }
        }

        .corrupt-text {
            animation: corruptText 2s infinite;
        }

        @keyframes corruptText {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        #deathScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 1000;
        }

        #deathScreen.active {
            display: flex;
            animation: fadeIn 2s ease;
        }

        .death-title {
            font-size: 48px;
            margin-bottom: 20px;
            animation: glitch 0.5s infinite;
        }

        .death-message {
            font-size: 18px;
            text-align: center;
            max-width: 600px;
            line-height: 1.6;
            margin-bottom: 30px;
        }

        #victoryScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #000, #003);
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 1000;
        }

        #victoryScreen.active {
            display: flex;
            animation: fadeIn 2s ease;
        }

        .victory-title {
            font-size: 48px;
            margin-bottom: 20px;
            color: #4af;
        }

        .stats-container {
            margin-top: 20px;
            text-align: center;
        }

        .stat-line {
            font-size: 16px;
            margin: 5px 0;
        }

        #interactPrompt {
            position: absolute;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 10px 20px;
            border: 2px solid #fff;
            display: none;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .floor-transition {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 999;
            font-size: 36px;
            letter-spacing: 4px;
        }

        .floor-transition.active {
            display: flex;
            animation: fadeInOut 3s ease;
        }

        @keyframes fadeInOut {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="ui">
        <div id="hud">
            <div class="hud-item" id="floorDisplay">Floor: 1 - SURFACE MEMORIES</div>
            <div class="hud-item" id="roomDisplay">Room: Childhood Bedroom</div>
            <div class="hud-item">Corruption:</div>
            <div id="corruptionBar"><div id="corruptionFill"></div></div>
            <div class="hud-item">Clarity:</div>
            <div id="clarityBar"><div id="clarityFill"></div></div>
            <div class="hud-item" id="shardsDisplay">Memory Shards: 0</div>
        </div>

        <canvas id="minimap"></canvas>

        <div id="inventory">
            <div class="inventory-slot" data-item="shards">
                <span>üíé</span>
                <div class="inventory-count" id="shardCount">0</div>
            </div>
            <div class="inventory-slot" data-item="clarity">
                <span>‚≠ê</span>
                <div class="inventory-count" id="clarityCount">0</div>
            </div>
            <div class="inventory-slot" data-item="anchors">
                <span>‚öì</span>
                <div class="inventory-count" id="anchorCount">0</div>
            </div>
            <div class="inventory-slot" data-item="identity">
                <span>üîÆ</span>
                <div class="inventory-count" id="identityCount">0</div>
            </div>
        </div>

        <div id="messageLog"></div>
        <div id="interactPrompt">[E] Interact</div>
    </div>

    <div id="menu" class="active">
        <div class="menu-title">MEMORY PALACE</div>
        <p style="text-align: center; margin-bottom: 20px;">Navigate your corrupting mind before it dissolves completely.</p>
        <button class="menu-button" id="startBtn">START NEW GAME</button>
        <button class="menu-button" id="continueBtn" style="display: none;">CONTINUE</button>
        <button class="menu-button" id="instructionsBtn">INSTRUCTIONS</button>
    </div>

    <div id="reconstructionPuzzle">
        <h2 style="text-align: center; margin-bottom: 20px;">RECONSTRUCT MEMORY</h2>
        <p id="puzzleDescription" style="margin-bottom: 20px;"></p>
        <div class="sequence-display" id="sequenceDisplay"></div>
        <div class="fragment-container" id="fragmentContainer"></div>
        <div style="display: flex; gap: 10px; margin-top: 20px;">
            <button class="menu-button" id="submitSequence" style="flex: 1;">SUBMIT</button>
            <button class="menu-button" id="cancelPuzzle" style="flex: 1;">CANCEL</button>
        </div>
    </div>

    <div id="deathScreen">
        <div class="death-title">DISSOLUTION</div>
        <div class="death-message">
            Your mind has completely fragmented. The memories are scattered beyond recovery.
            You no longer remember who you were. You are no one. You are nowhere.
            You are nothing.
        </div>
        <button class="menu-button" style="width: 200px;" onclick="location.reload()">TRY AGAIN</button>
    </div>

    <div id="victoryScreen">
        <div class="victory-title">RECONSTRUCTED</div>
        <div class="death-message" style="color: #4af;">
            You have accepted all parts of yourself. The good and the bad. The light and the shadow.
            Your memory palace is whole. Your identity is intact. You remember who you are.
        </div>
        <div class="stats-container" id="victoryStats"></div>
        <button class="menu-button" style="width: 200px; margin-top: 20px;" onclick="location.reload()">PLAY AGAIN</button>
    </div>

    <div class="floor-transition" id="floorTransition"></div>

    <div id="cursor"></div>

    <script>
        // ===== CORE GAME STATE =====
        const game = {
            canvas: null,
            ctx: null,
            width: 0,
            height: 0,
            running: false,
            paused: false,

            // Player state
            player: {
                x: 0,
                y: 1.5,
                z: 0,
                angle: 0,
                pitch: 0,
                speed: 0.05,
                turnSpeed: 0.002,
                health: 100,
                clarity: 100,
                corruption: 0,
                floor: 1,
                currentRoom: 'childhood_bedroom'
            },

            // Input state
            input: {
                forward: false,
                backward: false,
                left: false,
                right: false,
                mouseX: 0,
                mouseY: 0,
                mouseMovementX: 0,
                mouseMovementY: 0,
                interact: false
            },

            // Inventory
            inventory: {
                shards: 0,
                clarityTokens: 3,
                anchors: 2,
                identityFragments: 0
            },

            // World state
            world: {
                rooms: [],
                corridors: [],
                objects: [],
                enemies: [],
                particles: []
            },

            // Corruption effects
            corruptionEffects: {
                uiLies: false,
                controlSwap: false,
                visualGlitch: false,
                timeskip: false,
                identityCrisis: false
            },

            // Game stats
            stats: {
                startTime: Date.now(),
                memoriesReconstructed: 0,
                deathCount: 0,
                corruptionPeakLevel: 0
            },

            // Reconstruction puzzle
            currentPuzzle: null,
            puzzleActive: false
        };

        // ===== ROOM DEFINITIONS =====
        const ROOM_LIBRARY = {
            // FLOOR 1: SURFACE MEMORIES (Childhood)
            childhood_bedroom: {
                name: "Childhood Bedroom",
                floor: 1,
                color: '#ffd700',
                walls: [
                    {x1: -5, z1: -5, x2: 5, z2: -5, color: '#ffb6c1'},
                    {x1: 5, z1: -5, x2: 5, z2: 5, color: '#ffb6c1'},
                    {x1: 5, z1: 5, x2: -5, z2: 5, color: '#ffb6c1'},
                    {x1: -5, z1: 5, x2: -5, z2: -5, color: '#ffb6c1'}
                ],
                objects: [
                    {type: 'bed', x: 3, z: 3, size: 1, color: '#8b4513'},
                    {type: 'toybox', x: -3, z: -3, size: 0.8, color: '#ff6347'},
                    {type: 'shard', x: 0, z: 0, size: 0.3, color: '#ffd700', collectible: true}
                ],
                exits: [
                    {x: 0, z: 5, targetRoom: 'backyard', direction: 'south'}
                ],
                memory: {
                    id: 'bedroom',
                    description: "Where you first learned to dream",
                    fragments: [
                        "The warm glow of the nightlight",
                        "Mom tucking you in",
                        "Reading stories under the covers",
                        "The creaking of the old floorboards",
                        "Your favorite stuffed animal"
                    ]
                }
            },

            backyard: {
                name: "Backyard",
                floor: 1,
                color: '#90ee90',
                walls: [
                    {x1: -6, z1: -6, x2: 6, z2: -6, color: '#228b22'},
                    {x1: 6, z1: -6, x2: 6, z2: 6, color: '#228b22'},
                    {x1: 6, z1: 6, x2: -6, z2: 6, color: '#228b22'},
                    {x1: -6, z1: 6, x2: -6, z2: -6, color: '#228b22'}
                ],
                objects: [
                    {type: 'tree', x: 2, z: 2, size: 1.5, color: '#8b4513'},
                    {type: 'swing', x: -2, z: -2, size: 1, color: '#cd853f'},
                    {type: 'shard', x: 4, z: -4, size: 0.3, color: '#ffd700', collectible: true}
                ],
                exits: [
                    {x: 0, z: -6, targetRoom: 'childhood_bedroom', direction: 'north'},
                    {x: 6, z: 0, targetRoom: 'school_classroom', direction: 'east'}
                ],
                memory: {
                    id: 'backyard',
                    description: "Summer days that never ended",
                    fragments: [
                        "Grass stains on your knees",
                        "The old oak tree you climbed",
                        "Dad pushing you on the swing",
                        "Fireflies in the evening",
                        "The fence you weren't supposed to jump over"
                    ]
                }
            },

            school_classroom: {
                name: "School Classroom",
                floor: 1,
                color: '#f0e68c',
                walls: [
                    {x1: -7, z1: -7, x2: 7, z2: -7, color: '#daa520'},
                    {x1: 7, z1: -7, x2: 7, z2: 7, color: '#daa520'},
                    {x1: 7, z1: 7, x2: -7, z2: 7, color: '#daa520'},
                    {x1: -7, z1: 7, x2: -7, z2: -7, color: '#daa520'}
                ],
                objects: [
                    {type: 'desk', x: 0, z: 0, size: 1, color: '#8b4513'},
                    {type: 'chalkboard', x: 0, z: -6, size: 2, color: '#2f4f4f'},
                    {type: 'shard', x: -5, z: 5, size: 0.3, color: '#ffd700', collectible: true},
                    {type: 'stairs_down', x: 0, z: 6, size: 1, color: '#696969', special: 'floor2'}
                ],
                exits: [
                    {x: -7, z: 0, targetRoom: 'backyard', direction: 'west'}
                ],
                memory: {
                    id: 'school',
                    description: "Learning who you were supposed to become",
                    fragments: [
                        "The smell of chalk dust",
                        "Your first best friend",
                        "Getting called on when you didn't know the answer",
                        "Recess bells",
                        "Gold stars on your homework"
                    ]
                }
            },

            // FLOOR 2: FORMATIVE YEARS (Adolescence)
            high_school_hallway: {
                name: "High School Hallway",
                floor: 2,
                color: '#778899',
                walls: [
                    {x1: -8, z1: -3, x2: 8, z2: -3, color: '#708090'},
                    {x1: 8, z1: -3, x2: 8, z2: 3, color: '#708090'},
                    {x1: 8, z1: 3, x2: -8, z2: 3, color: '#708090'},
                    {x1: -8, z1: 3, x2: -8, z2: -3, color: '#708090'}
                ],
                objects: [
                    {type: 'lockers', x: -6, z: 0, size: 1, color: '#4682b4'},
                    {type: 'lockers', x: 6, z: 0, size: 1, color: '#4682b4'},
                    {type: 'shard', x: 0, z: 0, size: 0.3, color: '#ffd700', collectible: true},
                    {type: 'stairs_up', x: -7, z: 0, size: 1, color: '#696969', special: 'floor1'}
                ],
                exits: [
                    {x: 8, z: 0, targetRoom: 'first_car', direction: 'east'},
                    {x: 0, z: 3, targetRoom: 'best_friend_house', direction: 'south'}
                ],
                memory: {
                    id: 'hallway',
                    description: "The anxiety of fitting in",
                    fragments: [
                        "The weight of your backpack",
                        "Avoiding eye contact",
                        "The crush you never talked to",
                        "Locker combinations you've forgotten",
                        "Walking alone between classes"
                    ]
                }
            },

            first_car: {
                name: "Your First Car",
                floor: 2,
                color: '#cd5c5c',
                walls: [
                    {x1: -3, z1: -5, x2: 3, z2: -5, color: '#8b0000'},
                    {x1: 3, z1: -5, x2: 3, z2: 5, color: '#8b0000'},
                    {x1: 3, z1: 5, x2: -3, z2: 5, color: '#8b0000'},
                    {x1: -3, z1: 5, x2: -3, z2: -5, color: '#8b0000'}
                ],
                objects: [
                    {type: 'steering_wheel', x: 0, z: -2, size: 0.5, color: '#000'},
                    {type: 'shard', x: 0, z: 2, size: 0.3, color: '#ffd700', collectible: true},
                    {type: 'identity', x: 2, z: 0, size: 0.4, color: '#9370db', collectible: true}
                ],
                exits: [
                    {x: -3, z: 0, targetRoom: 'high_school_hallway', direction: 'west'}
                ],
                memory: {
                    id: 'car',
                    description: "Freedom and responsibility",
                    fragments: [
                        "The smell of old leather",
                        "Your favorite mixtape",
                        "Late night drives to nowhere",
                        "Learning to parallel park",
                        "The independence it represented"
                    ]
                }
            },

            best_friend_house: {
                name: "Best Friend's House",
                floor: 2,
                color: '#dda0dd',
                walls: [
                    {x1: -5, z1: -5, x2: 5, z2: -5, color: '#9370db'},
                    {x1: 5, z1: -5, x2: 5, z2: 5, color: '#9370db'},
                    {x1: 5, z1: 5, x2: -5, z2: 5, color: '#9370db'},
                    {x1: -5, z1: 5, x2: -5, z2: -5, color: '#9370db'}
                ],
                objects: [
                    {type: 'couch', x: 0, z: 3, size: 1.5, color: '#6a5acd'},
                    {type: 'tv', x: 0, z: -4, size: 1, color: '#191970'},
                    {type: 'shard', x: -3, z: -3, size: 0.3, color: '#ffd700', collectible: true},
                    {type: 'stairs_down', x: 4, z: 4, size: 1, color: '#696969', special: 'floor3'}
                ],
                exits: [
                    {x: 0, z: -5, targetRoom: 'high_school_hallway', direction: 'north'}
                ],
                memory: {
                    id: 'friend',
                    description: "The person who understood",
                    fragments: [
                        "All-night gaming sessions",
                        "Conversations about everything",
                        "Inside jokes no one else got",
                        "The fight you never fully resolved",
                        "Growing apart without meaning to"
                    ]
                }
            },

            // FLOOR 3: THE MIDDLE (Adulthood)
            office_cubicle: {
                name: "Office Cubicle",
                floor: 3,
                color: '#c0c0c0',
                walls: [
                    {x1: -3, z1: -3, x2: 3, z2: -3, color: '#a9a9a9'},
                    {x1: 3, z1: -3, x2: 3, z2: 3, color: '#a9a9a9'},
                    {x1: 3, z1: 3, x2: -3, z2: 3, color: '#a9a9a9'},
                    {x1: -3, z1: 3, x2: -3, z2: -3, color: '#a9a9a9'}
                ],
                objects: [
                    {type: 'desk', x: 0, z: -2, size: 1, color: '#808080'},
                    {type: 'computer', x: 0, z: -2, size: 0.5, color: '#000'},
                    {type: 'shard', x: 2, z: 2, size: 0.3, color: '#ffd700', collectible: true},
                    {type: 'stairs_up', x: -2, z: -2, size: 1, color: '#696969', special: 'floor2'}
                ],
                exits: [
                    {x: 3, z: 0, targetRoom: 'apartment', direction: 'east'}
                ],
                memory: {
                    id: 'cubicle',
                    description: "The compromise you made",
                    fragments: [
                        "Fluorescent lights that never changed",
                        "The same coffee every morning",
                        "Emails that could have been nothing",
                        "Dreams deferred to next quarter",
                        "The person you became for a paycheck"
                    ]
                }
            },

            apartment: {
                name: "Your Apartment",
                floor: 3,
                color: '#f5deb3',
                walls: [
                    {x1: -6, z1: -6, x2: 6, z2: -6, color: '#d2b48c'},
                    {x1: 6, z1: -6, x2: 6, z2: 6, color: '#d2b48c'},
                    {x1: 6, z1: 6, x2: -6, z2: 6, color: '#d2b48c'},
                    {x1: -6, z1: 6, x2: -6, z2: -6, color: '#d2b48c'}
                ],
                objects: [
                    {type: 'bed', x: 4, z: 4, size: 1.5, color: '#8b7355'},
                    {type: 'table', x: -3, z: -3, size: 1, color: '#a0522d'},
                    {type: 'shard', x: 0, z: 0, size: 0.3, color: '#ffd700', collectible: true},
                    {type: 'identity', x: -4, z: 4, size: 0.4, color: '#9370db', collectible: true}
                ],
                exits: [
                    {x: -6, z: 0, targetRoom: 'office_cubicle', direction: 'west'},
                    {x: 0, z: 6, targetRoom: 'hospital_waiting', direction: 'south'}
                ],
                memory: {
                    id: 'apartment',
                    description: "A place that never felt like home",
                    fragments: [
                        "Unpacked boxes in the closet",
                        "Walls you weren't allowed to paint",
                        "The neighbor's arguments through thin walls",
                        "Eating dinner alone again",
                        "Waiting for life to start"
                    ]
                }
            },

            hospital_waiting: {
                name: "Hospital Waiting Room",
                floor: 3,
                color: '#e0ffff',
                walls: [
                    {x1: -7, z1: -4, x2: 7, z2: -4, color: '#b0e0e6'},
                    {x1: 7, z1: -4, x2: 7, z2: 4, color: '#b0e0e6'},
                    {x1: 7, z1: 4, x2: -7, z2: 4, color: '#b0e0e6'},
                    {x1: -7, z1: 4, x2: -7, z2: -4, color: '#b0e0e6'}
                ],
                objects: [
                    {type: 'chairs', x: -4, z: 0, size: 1, color: '#87ceeb'},
                    {type: 'chairs', x: 4, z: 0, size: 1, color: '#87ceeb'},
                    {type: 'shard', x: 0, z: -2, size: 0.3, color: '#ffd700', collectible: true},
                    {type: 'stairs_down', x: 0, z: 3, size: 1, color: '#696969', special: 'floor4'}
                ],
                exits: [
                    {x: 0, z: -4, targetRoom: 'apartment', direction: 'north'}
                ],
                memory: {
                    id: 'hospital',
                    description: "When everything changed",
                    fragments: [
                        "The antiseptic smell",
                        "Uncomfortable plastic chairs",
                        "The doctor's careful words",
                        "Time moving too slowly",
                        "Realizing mortality is real"
                    ]
                }
            },

            // FLOOR 4: THE DEEP (Trauma/Repressed)
            void_chamber: {
                name: "???",
                floor: 4,
                color: '#1a1a1a',
                walls: [
                    {x1: -10, z1: -10, x2: 10, z2: -10, color: '#0a0a0a'},
                    {x1: 10, z1: -10, x2: 10, z2: 10, color: '#0a0a0a'},
                    {x1: 10, z1: 10, x2: -10, z2: 10, color: '#0a0a0a'},
                    {x1: -10, z1: 10, x2: -10, z2: -10, color: '#0a0a0a'}
                ],
                objects: [
                    {type: 'void', x: 0, z: 0, size: 2, color: '#000'},
                    {type: 'shard', x: -7, z: 7, size: 0.3, color: '#ffd700', collectible: true},
                    {type: 'shard', x: 7, z: -7, size: 0.3, color: '#ffd700', collectible: true},
                    {type: 'identity', x: -7, z: -7, size: 0.4, color: '#9370db', collectible: true},
                    {type: 'stairs_up', x: 9, z: 9, size: 1, color: '#696969', special: 'floor3'}
                ],
                exits: [
                    {x: 0, z: 10, targetRoom: 'regret_hall', direction: 'south'}
                ],
                memory: {
                    id: 'void',
                    description: "What you buried deepest",
                    fragments: [
                        "The words you can't take back",
                        "The choice you regret most",
                        "What you lost and can't recover",
                        "The person you hurt",
                        "The part of yourself you killed"
                    ]
                }
            },

            regret_hall: {
                name: "Hall of Regrets",
                floor: 4,
                color: '#2f1f1f',
                walls: [
                    {x1: -15, z1: -2, x2: 15, z2: -2, color: '#1f0f0f'},
                    {x1: 15, z1: -2, x2: 15, z2: 2, color: '#1f0f0f'},
                    {x1: 15, z1: 2, x2: -15, z2: 2, color: '#1f0f0f'},
                    {x1: -15, z1: 2, x2: -15, z2: -2, color: '#1f0f0f'}
                ],
                objects: [
                    {type: 'mirror', x: -10, z: 0, size: 1, color: '#4a4a4a'},
                    {type: 'mirror', x: -5, z: 0, size: 1, color: '#4a4a4a'},
                    {type: 'mirror', x: 0, z: 0, size: 1, color: '#4a4a4a'},
                    {type: 'mirror', x: 5, z: 0, size: 1, color: '#4a4a4a'},
                    {type: 'mirror', x: 10, z: 0, size: 1, color: '#4a4a4a'},
                    {type: 'shard', x: 12, z: 0, size: 0.3, color: '#ffd700', collectible: true},
                    {type: 'stairs_down', x: 14, z: 0, size: 1, color: '#696969', special: 'floor5'}
                ],
                exits: [
                    {x: 0, z: -2, targetRoom: 'void_chamber', direction: 'north'}
                ],
                memory: {
                    id: 'regret',
                    description: "All the versions of you that could have been",
                    fragments: [
                        "The path not taken",
                        "What you should have said",
                        "The relationship you sabotaged",
                        "The dream you gave up on",
                        "Who you could have become"
                    ]
                }
            },

            // FLOOR 5: THE CORE (Identity)
            core_chamber: {
                name: "The Core",
                floor: 5,
                color: '#1a1a2e',
                walls: [
                    {x1: -20, z1: -20, x2: 20, z2: -20, color: '#16213e'},
                    {x1: 20, z1: -20, x2: 20, z2: 20, color: '#16213e'},
                    {x1: 20, z1: 20, x2: -20, z2: 20, color: '#16213e'},
                    {x1: -20, z1: 20, x2: -20, z2: -20, color: '#16213e'}
                ],
                objects: [
                    {type: 'core', x: 0, z: 0, size: 3, color: '#4af', pulsing: true},
                    {type: 'identity', x: -10, z: -10, size: 0.4, color: '#9370db', collectible: true},
                    {type: 'identity', x: 10, z: -10, size: 0.4, color: '#9370db', collectible: true},
                    {type: 'identity', x: -10, z: 10, size: 0.4, color: '#9370db', collectible: true},
                    {type: 'identity', x: 10, z: 10, size: 0.4, color: '#9370db', collectible: true},
                    {type: 'final_puzzle', x: 0, z: 0, size: 0.5, color: '#ffd700', special: 'final'}
                ],
                exits: [
                    {x: 0, z: -20, targetRoom: 'regret_hall', direction: 'north'}
                ],
                memory: {
                    id: 'core',
                    description: "Everything you are",
                    fragments: [
                        "Every joy and sorrow",
                        "Every triumph and failure",
                        "Every person you've been",
                        "Every choice that shaped you",
                        "The truth of who you are"
                    ]
                }
            }
        };

        // ===== MEMORY PUZZLES =====
        const MEMORY_PUZZLES = {
            bedroom: {
                correctSequence: [0, 1, 2, 3, 4],
                decoyFragments: [
                    "The smell of breakfast from downstairs",
                    "Homework you forgot to do"
                ]
            },
            backyard: {
                correctSequence: [1, 3, 0, 4, 2],
                decoyFragments: [
                    "Your neighbor's dog barking",
                    "The sprinkler on summer days"
                ]
            },
            school: {
                correctSequence: [4, 0, 1, 3, 2],
                decoyFragments: [
                    "The cafeteria food",
                    "Pop quiz anxiety"
                ]
            },
            hallway: {
                correctSequence: [2, 0, 4, 3, 1],
                decoyFragments: [
                    "Failing a test you studied for",
                    "The school mascot costume",
                    "Detention for talking"
                ]
            },
            car: {
                correctSequence: [3, 1, 2, 0, 4],
                decoyFragments: [
                    "The speeding ticket",
                    "Running out of gas"
                ]
            },
            friend: {
                correctSequence: [1, 0, 2, 4, 3],
                decoyFragments: [
                    "The party you both got in trouble at",
                    "Borrowing money you never paid back",
                    "Meeting their parents"
                ]
            },
            cubicle: {
                correctSequence: [4, 2, 0, 3, 1],
                decoyFragments: [
                    "The promotion you didn't get",
                    "Pretending to be busy",
                    "Happy hour to complain about work"
                ]
            },
            apartment: {
                correctSequence: [1, 3, 4, 0, 2],
                decoyFragments: [
                    "The rent increase notice",
                    "Forgetting to water the plants",
                    "Packages stolen from the doorstep"
                ]
            },
            hospital: {
                correctSequence: [0, 2, 3, 1, 4],
                decoyFragments: [
                    "The parking garage",
                    "Magazines from three years ago",
                    "Vending machine coffee"
                ]
            },
            void: {
                correctSequence: [4, 3, 1, 0, 2],
                decoyFragments: [
                    "The apology you never made",
                    "Running away instead of facing it",
                    "Pretending it never happened",
                    "Blaming someone else"
                ]
            },
            regret: {
                correctSequence: [3, 1, 4, 2, 0],
                decoyFragments: [
                    "Wondering 'what if'",
                    "Jealousy of others' lives",
                    "Bitterness at opportunities lost",
                    "Replaying it differently in your mind"
                ]
            },
            core: {
                correctSequence: [0, 1, 2, 3, 4],
                decoyFragments: []
            }
        };

        // ===== INITIALIZATION =====
        function init() {
            game.canvas = document.getElementById('gameCanvas');
            game.ctx = game.canvas.getContext('2d');

            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            setupInput();
            setupUI();

            // Check for saved game
            const saved = localStorage.getItem('memoryPalaceSave');
            if (saved) {
                document.getElementById('continueBtn').style.display = 'block';
            }

            // Start button handlers
            document.getElementById('startBtn').addEventListener('click', startNewGame);
            document.getElementById('continueBtn').addEventListener('click', continueGame);
            document.getElementById('instructionsBtn').addEventListener('click', showInstructions);

            // Puzzle handlers
            document.getElementById('submitSequence').addEventListener('click', submitPuzzle);
            document.getElementById('cancelPuzzle').addEventListener('click', closePuzzle);

            // Start ambient sound
            initAudio();
        }

        function resizeCanvas() {
            game.canvas.width = window.innerWidth;
            game.canvas.height = window.innerHeight;
            game.width = game.canvas.width;
            game.height = game.canvas.height;
        }

        function setupInput() {
            // Keyboard
            document.addEventListener('keydown', (e) => {
                if (game.puzzleActive) return;

                switch(e.key.toLowerCase()) {
                    case 'w': game.input.forward = true; break;
                    case 's': game.input.backward = true; break;
                    case 'a': game.input.left = true; break;
                    case 'd': game.input.right = true; break;
                    case 'e': game.input.interact = true; break;
                    case 'escape':
                        if (game.running && !game.paused) {
                            pauseGame();
                        }
                        break;
                }
            });

            document.addEventListener('keyup', (e) => {
                switch(e.key.toLowerCase()) {
                    case 'w': game.input.forward = false; break;
                    case 's': game.input.backward = false; break;
                    case 'a': game.input.left = false; break;
                    case 'd': game.input.right = false; break;
                    case 'e': game.input.interact = false; break;
                }
            });

            // Mouse movement
            document.addEventListener('mousemove', (e) => {
                const cursor = document.getElementById('cursor');
                cursor.style.left = e.clientX + 'px';
                cursor.style.top = e.clientY + 'px';

                if (game.running && !game.paused && !game.puzzleActive) {
                    game.input.mouseMovementX = e.movementX || 0;
                    game.input.mouseMovementY = e.movementY || 0;
                }
            });

            // Lock pointer on click (for better mouse look)
            game.canvas.addEventListener('click', () => {
                if (game.running && !game.paused && !game.puzzleActive) {
                    game.canvas.requestPointerLock();
                }
            });
        }

        function setupUI() {
            updateCorruptionBar();
            updateClarityBar();
            updateInventoryDisplay();
        }

        // ===== GAME LOOP =====
        function startNewGame() {
            // Reset player
            game.player = {
                x: 0,
                y: 1.5,
                z: 0,
                angle: 0,
                pitch: 0,
                speed: 0.05,
                turnSpeed: 0.002,
                health: 100,
                clarity: 100,
                corruption: 0,
                floor: 1,
                currentRoom: 'childhood_bedroom'
            };

            // Reset inventory
            game.inventory = {
                shards: 0,
                clarityTokens: 3,
                anchors: 2,
                identityFragments: 0
            };

            // Reset stats
            game.stats = {
                startTime: Date.now(),
                memoriesReconstructed: 0,
                deathCount: 0,
                corruptionPeakLevel: 0
            };

            // Initialize world
            initWorld();

            // Clear save
            localStorage.removeItem('memoryPalaceSave');

            // Start game
            document.getElementById('menu').classList.remove('active');
            game.running = true;
            game.paused = false;

            gameLoop();

            showMessage("You wake inside your memory palace. Something is wrong.");
            setTimeout(() => showMessage("The walls are breathing. The floors shift beneath your feet."), 2000);
            setTimeout(() => showMessage("Find your memories before your mind dissolves completely."), 4000);
        }

        function continueGame() {
            const saved = localStorage.getItem('memoryPalaceSave');
            if (!saved) {
                startNewGame();
                return;
            }

            const data = JSON.parse(saved);
            game.player = data.player;
            game.inventory = data.inventory;
            game.stats = data.stats;

            initWorld();

            document.getElementById('menu').classList.remove('active');
            game.running = true;
            game.paused = false;

            gameLoop();

            showMessage("Your fragmented mind reassembles...");
        }

        function showInstructions() {
            showMessage("WASD - Move | Mouse - Look | E - Interact");
            setTimeout(() => showMessage("Collect Memory Shards. Reconstruct memories. Survive."), 2000);
            setTimeout(() => showMessage("The deeper you go, the less you can trust your interface."), 4000);
        }

        function pauseGame() {
            game.paused = true;
            document.getElementById('menu').classList.add('active');
            document.getElementById('startBtn').textContent = 'RESUME';
            document.getElementById('startBtn').onclick = resumeGame;
        }

        function resumeGame() {
            game.paused = false;
            document.getElementById('menu').classList.remove('active');
            document.getElementById('startBtn').textContent = 'START NEW GAME';
            document.getElementById('startBtn').onclick = startNewGame;
        }

        function gameLoop() {
            if (!game.running) return;

            if (!game.paused && !game.puzzleActive) {
                update();
                applyCorruptionEffects();
            }

            render();

            requestAnimationFrame(gameLoop);
        }

        // ===== UPDATE =====
        function update() {
            updatePlayer();
            updateEnemies();
            updateParticles();
            checkInteractions();
            checkCorruptionLevel();
            updateHUD();

            // Drain clarity slowly
            game.player.clarity = Math.max(0, game.player.clarity - 0.01);

            // Random corruption increase when low clarity
            if (game.player.clarity < 20 && Math.random() < 0.001) {
                adjustCorruption(0.5);
            }
        }

        function updatePlayer() {
            let moveX = 0;
            let moveZ = 0;

            // Apply control swap corruption
            let forward = game.input.forward;
            let backward = game.input.backward;
            let left = game.input.left;
            let right = game.input.right;

            if (game.corruptionEffects.controlSwap) {
                if (Math.random() < 0.01) {
                    // Randomly swap controls
                    [forward, backward] = [backward, forward];
                    [left, right] = [right, left];
                }
            }

            // Calculate movement
            if (forward) {
                moveX += Math.sin(game.player.angle) * game.player.speed;
                moveZ += Math.cos(game.player.angle) * game.player.speed;
            }
            if (backward) {
                moveX -= Math.sin(game.player.angle) * game.player.speed;
                moveZ -= Math.cos(game.player.angle) * game.player.speed;
            }
            if (left) {
                moveX -= Math.cos(game.player.angle) * game.player.speed;
                moveZ += Math.sin(game.player.angle) * game.player.speed;
            }
            if (right) {
                moveX += Math.cos(game.player.angle) * game.player.speed;
                moveZ -= Math.sin(game.player.angle) * game.player.speed;
            }

            // Collision detection
            const newX = game.player.x + moveX;
            const newZ = game.player.z + moveZ;

            if (!checkCollision(newX, game.player.z)) {
                game.player.x = newX;
            }
            if (!checkCollision(game.player.x, newZ)) {
                game.player.z = newZ;
            }

            // Mouse look
            let turnSpeed = game.player.turnSpeed;
            if (game.corruptionEffects.controlSwap && Math.random() < 0.1) {
                turnSpeed *= -1; // Inverted look
            }

            game.player.angle -= game.input.mouseMovementX * turnSpeed;
            game.player.pitch -= game.input.mouseMovementY * turnSpeed * 0.5;
            game.player.pitch = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, game.player.pitch));

            game.input.mouseMovementX = 0;
            game.input.mouseMovementY = 0;

            // Check for floor transitions
            checkFloorTransition();
        }

        function checkCollision(x, z) {
            const room = ROOM_LIBRARY[game.player.currentRoom];
            if (!room) return false;

            const buffer = 0.5;

            // Check wall collisions
            for (const wall of room.walls) {
                // Simple AABB collision
                const minX = Math.min(wall.x1, wall.x2) - buffer;
                const maxX = Math.max(wall.x1, wall.x2) + buffer;
                const minZ = Math.min(wall.z1, wall.z2) - buffer;
                const maxZ = Math.max(wall.z1, wall.z2) + buffer;

                if (x >= minX && x <= maxX && z >= minZ && z <= maxZ) {
                    // Check if actually near the wall line
                    const distToWall = pointToLineDistance(x, z, wall.x1, wall.z1, wall.x2, wall.z2);
                    if (distToWall < buffer) {
                        return true;
                    }
                }
            }

            // Check object collisions
            for (const obj of room.objects) {
                if (obj.collectible) continue;
                const dist = Math.sqrt((x - obj.x) ** 2 + (z - obj.z) ** 2);
                if (dist < obj.size + buffer) {
                    return true;
                }
            }

            return false;
        }

        function pointToLineDistance(px, pz, x1, z1, x2, z2) {
            const A = px - x1;
            const B = pz - z1;
            const C = x2 - x1;
            const D = z2 - z1;

            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            const param = lenSq !== 0 ? dot / lenSq : -1;

            let xx, zz;

            if (param < 0) {
                xx = x1;
                zz = z1;
            } else if (param > 1) {
                xx = x2;
                zz = z2;
            } else {
                xx = x1 + param * C;
                zz = z1 + param * D;
            }

            const dx = px - xx;
            const dz = pz - zz;
            return Math.sqrt(dx * dx + dz * dz);
        }

        function checkFloorTransition() {
            const room = ROOM_LIBRARY[game.player.currentRoom];
            if (!room) return;

            for (const obj of room.objects) {
                if (obj.special && obj.special.startsWith('floor')) {
                    const dist = Math.sqrt((game.player.x - obj.x) ** 2 + (game.player.z - obj.z) ** 2);
                    if (dist < 1.5 && game.input.interact) {
                        const targetFloor = parseInt(obj.special.replace('floor', ''));
                        transitionToFloor(targetFloor);
                    }
                }

                if (obj.special === 'final') {
                    const dist = Math.sqrt((game.player.x - obj.x) ** 2 + (game.player.z - obj.z) ** 2);
                    if (dist < 2 && game.input.interact) {
                        if (game.inventory.identityFragments >= 5) {
                            startFinalPuzzle();
                        } else {
                            showMessage("You need all 5 Identity Fragments to access the core.");
                        }
                    }
                }
            }
        }

        function transitionToFloor(targetFloor) {
            if (targetFloor === game.player.floor) return;

            const floorNames = {
                1: "SURFACE MEMORIES",
                2: "FORMATIVE YEARS",
                3: "THE MIDDLE",
                4: "THE DEEP",
                5: "THE CORE"
            };

            const transition = document.getElementById('floorTransition');
            transition.textContent = `FLOOR ${targetFloor}: ${floorNames[targetFloor]}`;
            transition.classList.add('active');

            playSound('transition', 0.5);

            setTimeout(() => {
                game.player.floor = targetFloor;

                // Move to appropriate room
                const roomsByFloor = {
                    1: 'childhood_bedroom',
                    2: 'high_school_hallway',
                    3: 'office_cubicle',
                    4: 'void_chamber',
                    5: 'core_chamber'
                };

                game.player.currentRoom = roomsByFloor[targetFloor];
                game.player.x = 0;
                game.player.z = 0;

                // Increase corruption when going deeper
                if (targetFloor > game.player.floor) {
                    adjustCorruption(10);
                    showMessage("You descend deeper into your mind. The corruption spreads.");
                } else {
                    showMessage("You return to a higher floor. A moment of clarity.");
                    adjustCorruption(-5);
                }

                updateHUD();
                transition.classList.remove('active');
            }, 2000);
        }

        function updateEnemies() {
            // Simple enemy AI - enemies chase player
            for (const enemy of game.world.enemies) {
                const dx = game.player.x - enemy.x;
                const dz = game.player.z - enemy.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist > 0.1) {
                    enemy.x += (dx / dist) * enemy.speed;
                    enemy.z += (dz / dist) * enemy.speed;
                }

                // Damage player if close
                if (dist < 1) {
                    game.player.clarity -= 0.5;
                    adjustCorruption(0.1);

                    if (Math.random() < 0.01) {
                        showMessage("The memory ghost tears at your sanity!");
                    }
                }
            }
        }

        function updateParticles() {
            game.world.particles = game.world.particles.filter(p => {
                p.life -= 0.01;
                p.y += p.vy;
                p.vy -= 0.001; // Gravity
                return p.life > 0;
            });
        }

        function checkInteractions() {
            const room = ROOM_LIBRARY[game.player.currentRoom];
            if (!room) return;

            let nearestInteractable = null;
            let nearestDist = Infinity;

            for (let i = 0; i < room.objects.length; i++) {
                const obj = room.objects[i];
                const dist = Math.sqrt((game.player.x - obj.x) ** 2 + (game.player.z - obj.z) ** 2);

                if (dist < 2 && dist < nearestDist) {
                    if (obj.collectible || obj.special === 'final') {
                        nearestInteractable = {obj, index: i, dist};
                        nearestDist = dist;
                    }
                }
            }

            if (nearestInteractable) {
                document.getElementById('interactPrompt').style.display = 'block';
                document.getElementById('cursor').classList.add('interact');

                if (game.input.interact) {
                    interact(nearestInteractable.obj, nearestInteractable.index);
                }
            } else {
                document.getElementById('interactPrompt').style.display = 'none';
                document.getElementById('cursor').classList.remove('interact');
            }
        }

        function interact(obj, index) {
            if (obj.type === 'shard') {
                collectShard(obj, index);
            } else if (obj.type === 'identity') {
                collectIdentity(obj, index);
            } else if (obj.type === 'clarity') {
                collectClarity(obj, index);
            } else if (obj.special === 'final') {
                // Handled in checkFloorTransition
            } else {
                // Trigger memory reconstruction puzzle
                const room = ROOM_LIBRARY[game.player.currentRoom];
                if (room.memory && !room.memory.reconstructed) {
                    startMemoryPuzzle(room.memory.id);
                }
            }
        }

        function collectShard(obj, index) {
            game.inventory.shards++;
            playSound('collect', 0.3);
            showMessage("Memory shard collected.");

            // Remove from room
            const room = ROOM_LIBRARY[game.player.currentRoom];
            room.objects.splice(index, 1);

            // Spawn particles
            spawnParticles(obj.x, 1, obj.z, '#ffd700', 20);

            updateInventoryDisplay();

            // Small clarity boost
            game.player.clarity = Math.min(100, game.player.clarity + 5);
        }

        function collectIdentity(obj, index) {
            game.inventory.identityFragments++;
            playSound('collect', 0.5);
            showMessage("Identity fragment collected. You remember a piece of yourself.");

            const room = ROOM_LIBRARY[game.player.currentRoom];
            room.objects.splice(index, 1);

            spawnParticles(obj.x, 1, obj.z, '#9370db', 30);

            updateInventoryDisplay();

            // Significant corruption reduction
            adjustCorruption(-10);
            game.player.clarity = Math.min(100, game.player.clarity + 20);
        }

        function collectClarity(obj, index) {
            game.inventory.clarityTokens++;
            playSound('collect', 0.4);
            showMessage("Clarity token collected.");

            const room = ROOM_LIBRARY[game.player.currentRoom];
            room.objects.splice(index, 1);

            updateInventoryDisplay();
        }

        function spawnParticles(x, y, z, color, count) {
            for (let i = 0; i < count; i++) {
                game.world.particles.push({
                    x: x + (Math.random() - 0.5) * 0.5,
                    y: y + (Math.random() - 0.5) * 0.5,
                    z: z + (Math.random() - 0.5) * 0.5,
                    vy: Math.random() * 0.05,
                    color: color,
                    life: 1,
                    size: Math.random() * 3 + 2
                });
            }
        }

        function checkCorruptionLevel() {
            const c = game.player.corruption;

            // Update peak
            if (c > game.stats.corruptionPeakLevel) {
                game.stats.corruptionPeakLevel = c;
            }

            // Enable corruption effects at thresholds
            game.corruptionEffects.uiLies = c > 20;
            game.corruptionEffects.controlSwap = c > 40;
            game.corruptionEffects.visualGlitch = c > 60;
            game.corruptionEffects.timeskip = c > 80;
            game.corruptionEffects.identityCrisis = c > 90;

            // Death at 100%
            if (c >= 100) {
                gameover();
            }

            // Spawn enemies based on corruption
            if (c > 30 && Math.random() < 0.0005 * (c / 100)) {
                spawnEnemy();
            }
        }

        function spawnEnemy() {
            // Spawn enemy in random location around player
            const angle = Math.random() * Math.PI * 2;
            const dist = 10 + Math.random() * 5;

            game.world.enemies.push({
                x: game.player.x + Math.cos(angle) * dist,
                z: game.player.z + Math.sin(angle) * dist,
                y: 1.5,
                speed: 0.02 + Math.random() * 0.02,
                type: ['ghost', 'void', 'regret'][Math.floor(Math.random() * 3)]
            });

            playSound('enemy_spawn', 0.2);
        }

        function adjustCorruption(amount) {
            game.player.corruption = Math.max(0, Math.min(100, game.player.corruption + amount));
            updateCorruptionBar();

            if (amount > 0 && amount > 5) {
                playSound('corrupt', 0.3);
            }
        }

        // ===== MEMORY PUZZLE =====
        function startMemoryPuzzle(memoryId) {
            const room = ROOM_LIBRARY[game.player.currentRoom];
            if (!room || !room.memory) return;

            const puzzle = MEMORY_PUZZLES[memoryId];
            if (!puzzle) return;

            game.currentPuzzle = {
                memoryId: memoryId,
                correctSequence: puzzle.correctSequence,
                playerSequence: [],
                fragments: [...room.memory.fragments],
                decoys: puzzle.decoyFragments
            };

            // Mix in decoys
            const allFragments = [...game.currentPuzzle.fragments, ...game.currentPuzzle.decoys];

            // Shuffle
            for (let i = allFragments.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [allFragments[i], allFragments[j]] = [allFragments[j], allFragments[i]];
            }

            game.currentPuzzle.shuffledFragments = allFragments;

            // Show UI
            document.getElementById('puzzleDescription').textContent = room.memory.description;

            const container = document.getElementById('fragmentContainer');
            container.innerHTML = '';

            allFragments.forEach((fragment, index) => {
                const div = document.createElement('div');
                div.className = 'fragment';
                div.textContent = fragment;
                div.dataset.index = index;
                div.addEventListener('click', () => selectFragment(index));
                container.appendChild(div);
            });

            updateSequenceDisplay();

            document.getElementById('reconstructionPuzzle').classList.add('active');
            game.puzzleActive = true;
        }

        function selectFragment(index) {
            const fragment = game.currentPuzzle.shuffledFragments[index];

            // Check if it's a real fragment (not decoy)
            const originalIndex = game.currentPuzzle.fragments.indexOf(fragment);

            if (originalIndex === -1) {
                // It's a decoy
                showMessage("That doesn't belong to this memory.");
                adjustCorruption(2);

                // Visual feedback
                const elements = document.querySelectorAll('.fragment');
                elements[index].classList.add('wrong');
                setTimeout(() => elements[index].classList.remove('wrong'), 300);

                playSound('wrong', 0.3);
                return;
            }

            // Add to sequence
            game.currentPuzzle.playerSequence.push(originalIndex);

            // Visual feedback
            const elements = document.querySelectorAll('.fragment');
            elements[index].classList.add('selected');
            elements[index].style.pointerEvents = 'none';

            updateSequenceDisplay();
            playSound('select', 0.2);
        }

        function updateSequenceDisplay() {
            const display = document.getElementById('sequenceDisplay');
            display.innerHTML = '';

            for (let i = 0; i < game.currentPuzzle.fragments.length; i++) {
                const slot = document.createElement('div');
                slot.className = 'sequence-slot';

                if (i < game.currentPuzzle.playerSequence.length) {
                    const fragIndex = game.currentPuzzle.playerSequence[i];
                    slot.textContent = game.currentPuzzle.fragments[fragIndex];
                    slot.classList.add('filled');
                } else {
                    slot.textContent = `${i + 1}`;
                }

                display.appendChild(slot);
            }
        }

        function submitPuzzle() {
            const correct = arraysEqual(
                game.currentPuzzle.playerSequence,
                game.currentPuzzle.correctSequence
            );

            if (correct) {
                // Success!
                showMessage("Memory reconstructed successfully!");
                playSound('success', 0.5);

                // Mark memory as reconstructed
                const room = ROOM_LIBRARY[game.player.currentRoom];
                room.memory.reconstructed = true;

                // Rewards
                adjustCorruption(-15);
                game.player.clarity = Math.min(100, game.player.clarity + 30);
                game.stats.memoriesReconstructed++;

                // Spawn identity fragment if special memory
                if (game.player.floor >= 3 && Math.random() < 0.3) {
                    room.objects.push({
                        type: 'identity',
                        x: Math.random() * 4 - 2,
                        z: Math.random() * 4 - 2,
                        size: 0.4,
                        color: '#9370db',
                        collectible: true
                    });
                    showMessage("An identity fragment materialized!");
                }

                closePuzzle();
            } else {
                // Failure
                showMessage("The memory fragments don't fit. The corruption spreads.");
                playSound('wrong', 0.4);

                adjustCorruption(10);

                // Spawn enemy
                spawnEnemy();

                // Visual feedback
                const slots = document.querySelectorAll('.sequence-slot.filled');
                slots.forEach(slot => {
                    slot.style.background = 'rgba(255,0,0,0.3)';
                    slot.style.borderColor = '#f00';
                });

                setTimeout(() => {
                    closePuzzle();
                }, 2000);
            }
        }

        function closePuzzle() {
            document.getElementById('reconstructionPuzzle').classList.remove('active');
            game.puzzleActive = false;
            game.currentPuzzle = null;
        }

        function arraysEqual(a, b) {
            if (a.length !== b.length) return false;
            for (let i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) return false;
            }
            return true;
        }

        // ===== FINAL PUZZLE =====
        function startFinalPuzzle() {
            showMessage("You reach for the core of your identity...");

            // Create a mega-puzzle combining all memories
            const allMemoryIds = Object.keys(MEMORY_PUZZLES).filter(id => id !== 'core');
            const selectedMemories = allMemoryIds.slice(0, 5);

            const finalFragments = selectedMemories.map(id => {
                const room = Object.values(ROOM_LIBRARY).find(r => r.memory && r.memory.id === id);
                return room ? room.memory.fragments[0] : "A lost memory";
            });

            game.currentPuzzle = {
                memoryId: 'core',
                correctSequence: [0, 1, 2, 3, 4],
                playerSequence: [],
                fragments: finalFragments,
                decoys: []
            };

            // Shuffle
            const shuffled = [...finalFragments];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }

            game.currentPuzzle.shuffledFragments = shuffled;

            document.getElementById('puzzleDescription').textContent = "Arrange the fragments of your identity in the order you experienced them.";

            const container = document.getElementById('fragmentContainer');
            container.innerHTML = '';

            shuffled.forEach((fragment, index) => {
                const div = document.createElement('div');
                div.className = 'fragment';
                div.textContent = fragment;
                div.dataset.index = index;
                div.addEventListener('click', () => selectFinalFragment(index));
                container.appendChild(div);
            });

            updateSequenceDisplay();

            document.getElementById('reconstructionPuzzle').classList.add('active');
            game.puzzleActive = true;
        }

        function selectFinalFragment(index) {
            const fragment = game.currentPuzzle.shuffledFragments[index];
            const originalIndex = game.currentPuzzle.fragments.indexOf(fragment);

            game.currentPuzzle.playerSequence.push(originalIndex);

            const elements = document.querySelectorAll('.fragment');
            elements[index].classList.add('selected');
            elements[index].style.pointerEvents = 'none';

            updateSequenceDisplay();
            playSound('select', 0.2);

            // Auto-submit when complete
            if (game.currentPuzzle.playerSequence.length === game.currentPuzzle.fragments.length) {
                setTimeout(submitFinalPuzzle, 500);
            }
        }

        function submitFinalPuzzle() {
            const correct = arraysEqual(
                game.currentPuzzle.playerSequence,
                game.currentPuzzle.correctSequence
            );

            if (correct) {
                victory();
            } else {
                showMessage("Not quite right. Try again.");
                playSound('wrong', 0.4);

                // Reset puzzle
                game.currentPuzzle.playerSequence = [];
                const elements = document.querySelectorAll('.fragment');
                elements.forEach(el => {
                    el.classList.remove('selected');
                    el.style.pointerEvents = 'auto';
                });
                updateSequenceDisplay();
            }
        }

        // ===== GAME END =====
        function gameover() {
            game.running = false;
            game.stats.deathCount++;

            playSound('death', 0.6);

            document.getElementById('deathScreen').classList.add('active');
        }

        function victory() {
            game.running = false;

            playSound('victory', 0.7);

            const timePlayed = Math.floor((Date.now() - game.stats.startTime) / 1000);
            const minutes = Math.floor(timePlayed / 60);
            const seconds = timePlayed % 60;

            const stats = document.getElementById('victoryStats');
            stats.innerHTML = `
                <div class="stat-line">Time: ${minutes}m ${seconds}s</div>
                <div class="stat-line">Memories Reconstructed: ${game.stats.memoriesReconstructed}</div>
                <div class="stat-line">Peak Corruption: ${Math.floor(game.stats.corruptionPeakLevel)}%</div>
                <div class="stat-line">Identity Fragments Collected: ${game.inventory.identityFragments}/5</div>
            `;

            document.getElementById('victoryScreen').classList.add('active');

            // Clear save
            localStorage.removeItem('memoryPalaceSave');
        }

        // ===== RENDER =====
        function render() {
            const ctx = game.ctx;
            const w = game.width;
            const h = game.height;

            // Clear with floor-dependent color
            const bgColors = ['#ffeaa7', '#dfe6e9', '#b2bec3', '#2d3436', '#0a0a0a'];
            let bgColor = bgColors[Math.min(game.player.floor - 1, 4)];

            // Apply visual glitch
            if (game.corruptionEffects.visualGlitch) {
                const shift = Math.floor(Math.random() * 3) - 1;
                bgColor = shiftColor(bgColor, shift);
            }

            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, w, h);

            // Render 3D view
            render3D();

            // Corruption visual effects
            if (game.player.corruption > 40) {
                renderCorruptionOverlay();
            }
        }

        function render3D() {
            const room = ROOM_LIBRARY[game.player.currentRoom];
            if (!room) return;

            const ctx = game.ctx;
            const w = game.width;
            const h = game.height;

            // Simple 3D projection
            const fov = 60 * Math.PI / 180;
            const screenDist = (w / 2) / Math.tan(fov / 2);

            // Render floor
            ctx.fillStyle = darken(room.color, 0.5);
            ctx.fillRect(0, h / 2, w, h / 2);

            // Render ceiling
            ctx.fillStyle = darken(room.color, 0.7);
            ctx.fillRect(0, 0, w, h / 2);

            // Render walls
            for (const wall of room.walls) {
                renderWall(wall, screenDist);
            }

            // Render objects
            for (const obj of room.objects) {
                renderObject(obj, screenDist);
            }

            // Render enemies
            for (const enemy of game.world.enemies) {
                renderEnemy(enemy, screenDist);
            }

            // Render particles
            for (const particle of game.world.particles) {
                renderParticle(particle, screenDist);
            }
        }

        function renderWall(wall, screenDist) {
            const ctx = game.ctx;
            const w = game.width;
            const h = game.height;

            // Transform wall points to view space
            const p1 = worldToView(wall.x1, 0, wall.z1);
            const p2 = worldToView(wall.x2, 0, wall.z2);
            const p3 = worldToView(wall.x2, 3, wall.z2);
            const p4 = worldToView(wall.x1, 3, wall.z1);

            // Project to screen
            const s1 = project(p1, screenDist);
            const s2 = project(p2, screenDist);
            const s3 = project(p3, screenDist);
            const s4 = project(p4, screenDist);

            if (!s1 || !s2 || !s3 || !s4) return;

            // Draw wall quad
            ctx.fillStyle = wall.color;
            ctx.beginPath();
            ctx.moveTo(s1.x, s1.y);
            ctx.lineTo(s2.x, s2.y);
            ctx.lineTo(s3.x, s3.y);
            ctx.lineTo(s4.x, s4.y);
            ctx.closePath();
            ctx.fill();

            // Outline
            ctx.strokeStyle = darken(wall.color, 0.3);
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function renderObject(obj, screenDist) {
            const ctx = game.ctx;

            const viewPos = worldToView(obj.x, obj.size / 2, obj.z);
            const screenPos = project(viewPos, screenDist);

            if (!screenPos) return;

            // Draw as circle (billboard)
            const scale = screenDist / Math.max(viewPos.z, 0.1);
            const radius = obj.size * scale * 20;

            let color = obj.color;

            // Pulsing effect for special objects
            if (obj.pulsing) {
                const pulse = Math.sin(Date.now() / 500) * 0.3 + 0.7;
                ctx.globalAlpha = pulse;
            }

            // Collectible glow
            if (obj.collectible) {
                ctx.shadowColor = color;
                ctx.shadowBlur = 20;
            }

            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(screenPos.x, screenPos.y, radius, 0, Math.PI * 2);
            ctx.fill();

            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;

            // Icon for object type
            if (obj.type === 'shard') {
                ctx.fillStyle = '#fff';
                ctx.font = `${radius}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('üíé', screenPos.x, screenPos.y);
            } else if (obj.type === 'identity') {
                ctx.fillText('üîÆ', screenPos.x, screenPos.y);
            }
        }

        function renderEnemy(enemy, screenDist) {
            const ctx = game.ctx;

            const viewPos = worldToView(enemy.x, enemy.y, enemy.z);
            const screenPos = project(viewPos, screenDist);

            if (!screenPos) return;

            const scale = screenDist / Math.max(viewPos.z, 0.1);
            const size = scale * 30;

            // Shadowy, glitchy appearance
            ctx.save();
            ctx.globalAlpha = 0.7;

            // Random offset for glitch effect
            const glitchX = (Math.random() - 0.5) * 10 * (game.player.corruption / 100);
            const glitchY = (Math.random() - 0.5) * 10 * (game.player.corruption / 100);

            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(screenPos.x + glitchX, screenPos.y + glitchY, size, 0, Math.PI * 2);
            ctx.fill();

            // Red eyes
            ctx.fillStyle = '#f00';
            ctx.beginPath();
            ctx.arc(screenPos.x - size / 3, screenPos.y - size / 3, size / 5, 0, Math.PI * 2);
            ctx.arc(screenPos.x + size / 3, screenPos.y - size / 3, size / 5, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function renderParticle(particle, screenDist) {
            const ctx = game.ctx;

            const viewPos = worldToView(particle.x, particle.y, particle.z);
            const screenPos = project(viewPos, screenDist);

            if (!screenPos) return;

            ctx.globalAlpha = particle.life;
            ctx.fillStyle = particle.color;
            ctx.beginPath();
            ctx.arc(screenPos.x, screenPos.y, particle.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }

        function worldToView(x, y, z) {
            // Translate to player position
            const dx = x - game.player.x;
            const dy = y - game.player.y;
            const dz = z - game.player.z;

            // Rotate around Y axis (yaw)
            const cos = Math.cos(-game.player.angle);
            const sin = Math.sin(-game.player.angle);

            const vx = dx * cos - dz * sin;
            const vz = dx * sin + dz * cos;

            // Apply pitch (simplified)
            const vy = dy - game.player.pitch * vz * 0.3;

            return {x: vx, y: vy, z: vz};
        }

        function project(viewPos, screenDist) {
            if (viewPos.z <= 0.1) return null; // Behind camera

            const scale = screenDist / viewPos.z;

            return {
                x: game.width / 2 + viewPos.x * scale,
                y: game.height / 2 - viewPos.y * scale
            };
        }

        function renderCorruptionOverlay() {
            const ctx = game.ctx;
            const w = game.width;
            const h = game.height;

            // Scanlines
            if (game.player.corruption > 50) {
                ctx.globalAlpha = 0.1;
                for (let y = 0; y < h; y += 4) {
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, y, w, 2);
                }
                ctx.globalAlpha = 1;
            }

            // Color shift
            if (game.corruptionEffects.visualGlitch) {
                const shift = Math.random() * 5 - 2.5;
                ctx.globalCompositeOperation = 'screen';
                ctx.fillStyle = `rgba(${Math.floor(Math.random() * 255)}, 0, 0, 0.05)`;
                ctx.fillRect(0, 0, w, h);
                ctx.globalCompositeOperation = 'source-over';
            }

            // Vignette
            const gradient = ctx.createRadialGradient(w / 2, h / 2, 0, w / 2, h / 2, Math.max(w, h) / 2);
            gradient.addColorStop(0, 'rgba(0,0,0,0)');
            gradient.addColorStop(1, `rgba(0,0,0,${game.player.corruption / 200})`);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, w, h);
        }

        // ===== UI UPDATES =====
        function updateHUD() {
            // Floor display
            const floorNames = {
                1: "SURFACE MEMORIES",
                2: "FORMATIVE YEARS",
                3: "THE MIDDLE",
                4: "THE DEEP",
                5: "THE CORE"
            };

            const floorDisplay = document.getElementById('floorDisplay');
            floorDisplay.textContent = `Floor: ${game.player.floor} - ${floorNames[game.player.floor]}`;

            // Apply corruption to text
            if (game.corruptionEffects.identityCrisis && Math.random() < 0.1) {
                floorDisplay.textContent = scrambleText(floorDisplay.textContent);
            }

            // Room display
            const room = ROOM_LIBRARY[game.player.currentRoom];
            const roomDisplay = document.getElementById('roomDisplay');
            roomDisplay.textContent = `Room: ${room ? room.name : '???'}`;

            if (game.corruptionEffects.uiLies && Math.random() < 0.05) {
                const fakeRooms = ["The Void", "Nowhere", "Error", "Forgotten Space", "NULL"];
                roomDisplay.textContent = `Room: ${fakeRooms[Math.floor(Math.random() * fakeRooms.length)]}`;
            }

            // Shards display
            const shardsDisplay = document.getElementById('shardsDisplay');
            let shardCount = game.inventory.shards;

            if (game.corruptionEffects.uiLies && Math.random() < 0.1) {
                shardCount = Math.floor(Math.random() * 99);
            }

            shardsDisplay.textContent = `Memory Shards: ${shardCount}`;

            // Apply glitch class randomly
            if (game.player.corruption > 60 && Math.random() < 0.05) {
                document.getElementById('hud').classList.add('glitch');
                setTimeout(() => document.getElementById('hud').classList.remove('glitch'), 200);
            }

            updateMinimap();
        }

        function updateCorruptionBar() {
            const fill = document.getElementById('corruptionFill');
            let displayValue = game.player.corruption;

            // UI lies
            if (game.corruptionEffects.uiLies && Math.random() < 0.2) {
                displayValue = Math.random() * 100;
            }

            fill.style.width = displayValue + '%';

            // Change color based on level
            if (displayValue > 80) {
                fill.style.background = '#f00';
            } else if (displayValue > 60) {
                fill.style.background = 'linear-gradient(90deg, #ff0, #f00)';
            } else if (displayValue > 40) {
                fill.style.background = 'linear-gradient(90deg, #0f0, #ff0)';
            } else {
                fill.style.background = 'linear-gradient(90deg, #0f0, #ff0, #f00)';
            }
        }

        function updateClarityBar() {
            const fill = document.getElementById('clarityFill');
            fill.style.width = game.player.clarity + '%';
        }

        function updateInventoryDisplay() {
            document.getElementById('shardCount').textContent = game.inventory.shards;
            document.getElementById('clarityCount').textContent = game.inventory.clarityTokens;
            document.getElementById('anchorCount').textContent = game.inventory.anchors;
            document.getElementById('identityCount').textContent = game.inventory.identityFragments;

            // Randomly swap icons if corrupted
            if (game.corruptionEffects.uiLies && Math.random() < 0.01) {
                const slots = document.querySelectorAll('.inventory-slot span');
                const icons = Array.from(slots).map(s => s.textContent);
                slots.forEach((slot, i) => {
                    slot.textContent = icons[(i + 1) % icons.length];
                });
            }
        }

        function updateMinimap() {
            const canvas = document.getElementById('minimap');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);

            const room = ROOM_LIBRARY[game.player.currentRoom];
            if (!room) return;

            // Scale factor
            const scale = 5;
            const centerX = w / 2;
            const centerY = h / 2;

            // Draw walls
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;

            for (const wall of room.walls) {
                // Apply lies - wrong shapes
                let x1 = centerX + (wall.x1 - game.player.x) * scale;
                let y1 = centerY + (wall.z1 - game.player.z) * scale;
                let x2 = centerX + (wall.x2 - game.player.x) * scale;
                let y2 = centerY + (wall.z2 - game.player.z) * scale;

                if (game.corruptionEffects.uiLies && Math.random() < 0.3) {
                    x1 += (Math.random() - 0.5) * 20;
                    y1 += (Math.random() - 0.5) * 20;
                    x2 += (Math.random() - 0.5) * 20;
                    y2 += (Math.random() - 0.5) * 20;
                }

                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }

            // Draw player
            ctx.fillStyle = '#0f0';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 3, 0, Math.PI * 2);
            ctx.fill();

            // Draw player direction
            ctx.strokeStyle = '#0f0';
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(
                centerX + Math.sin(game.player.angle) * 10,
                centerY + Math.cos(game.player.angle) * 10
            );
            ctx.stroke();

            // Draw objects
            for (const obj of room.objects) {
                if (obj.collectible) {
                    const x = centerX + (obj.x - game.player.x) * scale;
                    const y = centerY + (obj.z - game.player.z) * scale;

                    ctx.fillStyle = obj.color;
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw enemies
            ctx.fillStyle = '#f00';
            for (const enemy of game.world.enemies) {
                const x = centerX + (enemy.x - game.player.x) * scale;
                const y = centerY + (enemy.z - game.player.z) * scale;

                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function showMessage(text) {
            const log = document.getElementById('messageLog');

            // Apply corruption to messages
            if (game.corruptionEffects.identityCrisis && Math.random() < 0.3) {
                text = scrambleText(text);
            }

            const msg = document.createElement('div');
            msg.className = 'message';
            msg.textContent = text;

            log.insertBefore(msg, log.firstChild);

            // Keep only last 5 messages
            while (log.children.length > 5) {
                log.removeChild(log.lastChild);
            }

            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (msg.parentNode) {
                    msg.remove();
                }
            }, 5000);
        }

        // ===== CORRUPTION EFFECTS =====
        function applyCorruptionEffects() {
            // Random UI scrambling
            if (game.corruptionEffects.identityCrisis && Math.random() < 0.01) {
                const elements = document.querySelectorAll('.hud-item, .menu-button');
                elements.forEach(el => {
                    if (Math.random() < 0.3) {
                        el.classList.add('corrupt-text');
                        setTimeout(() => el.classList.remove('corrupt-text'), 500);
                    }
                });
            }

            // Time skip
            if (game.corruptionEffects.timeskip && Math.random() < 0.001) {
                showMessage("[TIME SKIP DETECTED]");
                game.player.x += (Math.random() - 0.5) * 5;
                game.player.z += (Math.random() - 0.5) * 5;
            }
        }

        // ===== WORLD GENERATION =====
        function initWorld() {
            game.world = {
                rooms: [],
                corridors: [],
                objects: [],
                enemies: []
            };
        }

        // ===== AUDIO =====
        let audioCtx = null;
        let masterGain = null;

        function initAudio() {
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                masterGain = audioCtx.createGain();
                masterGain.gain.value = 0.3;
                masterGain.connect(audioCtx.destination);

                // Start heartbeat
                playHeartbeat();
            } catch (e) {
                console.log('Audio not available');
            }
        }

        function playSound(type, volume = 1) {
            if (!audioCtx) return;

            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();

            osc.connect(gain);
            gain.connect(masterGain);

            gain.gain.value = volume * 0.1;

            switch(type) {
                case 'collect':
                    osc.frequency.value = 800;
                    osc.type = 'sine';
                    gain.gain.setValueAtTime(volume * 0.1, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.2);
                    break;

                case 'corrupt':
                    osc.frequency.value = 100;
                    osc.type = 'sawtooth';
                    gain.gain.setValueAtTime(volume * 0.15, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.5);
                    break;

                case 'select':
                    osc.frequency.value = 400;
                    osc.type = 'square';
                    gain.gain.value = volume * 0.05;
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.1);
                    break;

                case 'wrong':
                    osc.frequency.value = 150;
                    osc.type = 'sawtooth';
                    gain.gain.value = volume * 0.1;
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.3);
                    break;

                case 'success':
                    osc.frequency.value = 600;
                    osc.type = 'sine';
                    gain.gain.setValueAtTime(volume * 0.1, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.8);
                    osc.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.8);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.8);
                    break;

                case 'death':
                    osc.frequency.value = 800;
                    osc.type = 'sawtooth';
                    gain.gain.setValueAtTime(volume * 0.2, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 2);
                    osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 2);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 2);
                    break;

                case 'victory':
                    // Ascending arpeggio
                    [0, 0.15, 0.3, 0.45].forEach((time, i) => {
                        const freq = 400 * Math.pow(2, i / 4);
                        const o = audioCtx.createOscillator();
                        const g = audioCtx.createGain();
                        o.connect(g);
                        g.connect(masterGain);
                        o.frequency.value = freq;
                        o.type = 'sine';
                        g.gain.value = volume * 0.08;
                        o.start(audioCtx.currentTime + time);
                        o.stop(audioCtx.currentTime + time + 0.5);
                    });
                    break;

                case 'transition':
                    osc.frequency.value = 200;
                    osc.type = 'triangle';
                    gain.gain.setValueAtTime(volume * 0.1, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 1);
                    osc.frequency.exponentialRampToValueAtTime(400, audioCtx.currentTime + 1);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 1);
                    break;

                case 'enemy_spawn':
                    osc.frequency.value = 50;
                    osc.type = 'sawtooth';
                    gain.gain.value = volume * 0.15;
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.2);
                    break;
            }
        }

        function playHeartbeat() {
            if (!audioCtx || !game.running) {
                setTimeout(playHeartbeat, 1000);
                return;
            }

            const rate = 1000 - (game.player.corruption * 5); // Faster when corrupted

            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();

            osc.connect(gain);
            gain.connect(masterGain);

            osc.frequency.value = 60;
            osc.type = 'sine';
            gain.gain.value = 0.05 + (game.player.corruption / 100) * 0.1;

            osc.start();
            osc.stop(audioCtx.currentTime + 0.1);

            setTimeout(playHeartbeat, rate);
        }

        // ===== UTILITY FUNCTIONS =====
        function darken(color, amount) {
            const hex = color.replace('#', '');
            const r = Math.max(0, parseInt(hex.substr(0, 2), 16) - amount * 255);
            const g = Math.max(0, parseInt(hex.substr(2, 2), 16) - amount * 255);
            const b = Math.max(0, parseInt(hex.substr(4, 2), 16) - amount * 255);
            return `rgb(${r}, ${g}, ${b})`;
        }

        function shiftColor(color, amount) {
            const hex = color.replace('#', '');
            let r = parseInt(hex.substr(0, 2), 16) + amount * 30;
            let g = parseInt(hex.substr(2, 2), 16) + amount * 30;
            let b = parseInt(hex.substr(4, 2), 16) + amount * 30;
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));
            return `rgb(${r}, ${g}, ${b})`;
        }

        function scrambleText(text) {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()';
            return text.split('').map(c => {
                if (c === ' ') return ' ';
                return Math.random() < 0.3 ? chars[Math.floor(Math.random() * chars.length)] : c;
            }).join('');
        }

        // ===== START =====
        window.addEventListener('load', init);
    </script>
</body>
</html>