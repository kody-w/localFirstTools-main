<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber-MOBA: Neon Guardians</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;700&display=swap');

        :root {
            --bg-dark: #0a0a12;
            --accent-blue: #00f2ff;
            --accent-purple: #9d00ff;
            --health-green: #00ff88;
            --mana-blue: #009dff;
            --danger-red: #ff3c3c;
            --glass: rgba(20, 20, 35, 0.8);
            --border: rgba(0, 242, 255, 0.3);
        }

        * {
            box-sizing: border-box;
            user-select: none;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-dark);
            font-family: 'Outfit', sans-serif;
            color: white;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #game-canvas {
            display: block;
            cursor: crosshair;
        }

        /* UI Overlays */
        #hud {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            background: var(--glass);
            padding: 15px 30px;
            border-radius: 20px;
            border: 1px solid var(--border);
            backdrop-filter: blur(10px);
            align-items: center;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
        }

        .stat-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 250px;
        }

        .bar-container {
            width: 100%;
            height: 14px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 7px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .bar-fill {
            height: 100%;
            width: 100%;
            transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #hp-fill { background: linear-gradient(90deg, #00ff88, #00c268); box-shadow: 0 0 10px rgba(0, 255, 136, 0.5); }
        #mp-fill { background: linear-gradient(90deg, #009dff, #0056ff); box-shadow: 0 0 10px rgba(0, 157, 255, 0.5); }
        #xp-fill { background: linear-gradient(90deg, #ffd700, #ff8c00); height: 4px; }

        .abilities {
            display: flex;
            gap: 12px;
        }

        .ability {
            width: 60px;
            height: 60px;
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid var(--border);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
            transition: all 0.2s;
        }

        .ability:hover {
            border-color: var(--accent-blue);
            background: rgba(0, 242, 255, 0.1);
            transform: translateY(-2px);
        }

        .ability .key {
            position: absolute;
            top: -8px;
            left: -8px;
            background: var(--accent-blue);
            color: var(--bg-dark);
            font-weight: bold;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 4px;
        }

        .ability .cooldown-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 0%;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            transition: height 0.1s linear;
        }

        #minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 180px;
            height: 180px;
            background: var(--glass);
            border: 2px solid var(--border);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            overflow: hidden;
        }

        #level-indicator {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 14px;
            font-weight: bold;
            color: var(--accent-blue);
            text-shadow: 0 0 10px var(--accent-blue);
        }

        .status-msg {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 4px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .win { color: var(--accent-blue); text-shadow: 0 0 30px var(--accent-blue); }
        .loss { color: var(--danger-red); text-shadow: 0 0 30px var(--danger-red); }

        #debug {
            position: absolute;
            top: 10px;
            left: 10px;
            font-family: monospace;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.4);
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="debug">FPS: 60</div>
        
        <div id="level-indicator">LEVEL 1</div>
        
        <div id="minimap">
            <canvas id="minimap-canvas"></canvas>
        </div>

        <div id="hud">
            <div class="stat-group">
                <div class="bar-container"><div id="hp-fill" class="bar-fill"></div></div>
                <div class="bar-container"><div id="mp-fill" class="bar-fill"></div></div>
                <div class="bar-container" style="height: 4px; border: none; background: rgba(0,0,0,0.3);">
                    <div id="xp-fill" class="bar-fill"></div>
                </div>
            </div>
            
            <div class="abilities">
                <div class="ability" id="skill-q">
                    <span class="key">Q</span>
                    <span style="font-size: 20px;">üî•</span>
                    <div class="cooldown-overlay"></div>
                </div>
                <div class="ability" id="skill-w">
                    <span class="key">W</span>
                    <span style="font-size: 20px;">‚ö°</span>
                    <div class="cooldown-overlay"></div>
                </div>
                <div class="ability" id="skill-e">
                    <span class="key">E</span>
                    <span style="font-size: 20px;">‚ùÑÔ∏è</span>
                    <div class="cooldown-overlay"></div>
                </div>
                <div class="ability" id="skill-r">
                    <span class="key">R</span>
                    <span style="font-size: 20px;">üí†</span>
                    <div class="cooldown-overlay"></div>
                </div>
            </div>
        </div>

        <div id="status-msg" class="status-msg">VICTORY</div>
    </div>

    <script>
        /**
         * CYBER-MOBA GAME ENGINE
         * High-fidelity Browser MOBA Logic
         */

        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const miniCanvas = document.getElementById('minimap-canvas');
        const miniCtx = miniCanvas.getContext('2d');

        // MAP CONSTANTS
        const MAP_SIZE = 4000;
        const GRID_SIZE = 100;
        
        // GAME STATE
        let gameActive = true;
        let lastTime = 0;
        const keys = {};
        const mouse = { x: 0, y: 0, worldX: 0, worldY: 0, clicked: false, rightClicked: false };

        // ENTITIES
        let player;
        let enemyHero;
        let entities = [];
        let particles = [];
        let projectiles = [];
        
        // CAMERA
        const camera = {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            lerp: 0.1
        };

        class Entity {
            constructor(x, y, radius, color, team) {
                this.x = x;
                this.y = y;
                this.targetX = x;
                this.targetY = y;
                this.radius = radius;
                this.color = color;
                this.team = team;
                this.maxHp = 100;
                this.hp = 100;
                this.speed = 4;
                this.attackRange = 150;
                this.attackSpeed = 1000; // ms
                this.lastAttack = 0;
                this.damage = 10;
                this.level = 1;
                this.dead = false;
                this.type = 'neutral';
            }

            draw() {
                const screenX = this.x - camera.x;
                const screenY = this.y - camera.y;

                if (screenX < -100 || screenX > camera.width + 100 || screenY < -100 || screenY > camera.height + 100) return;

                // Health bar
                const barWidth = this.radius * 2.5;
                const barHeight = 6;
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(screenX - barWidth/2, screenY - this.radius - 15, barWidth, barHeight);
                ctx.fillStyle = this.team === 'player' ? '#00ff88' : '#ff3c3c';
                ctx.fillRect(screenX - barWidth/2, screenY - this.radius - 15, barWidth * (this.hp / this.maxHp), barHeight);

                // Body
                ctx.beginPath();
                ctx.arc(screenX, screenY, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.shadowBlur = 0;
            }

            update(dt) {
                if (this.dead) return;

                // Move towards target
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > 5) {
                    this.x += (dx / dist) * this.speed;
                    this.y += (dy / dist) * this.speed;
                }
            }

            takeDamage(amt, source) {
                this.hp -= amt;
                if (this.hp <= 0 && !this.dead) {
                    this.die(source);
                }
                
                // Floating damage text
                createDamageText(this.x, this.y, amt);
            }

            die(source) {
                this.dead = true;
                this.hp = 0;
                if (source && source.onKill) source.onKill(this);
                
                // Death particles
                createExplotion(this.x, this.y, this.color);
            }
        }

        class Hero extends Entity {
            constructor(x, y, color, team) {
                super(x, y, 25, color, team);
                this.type = 'hero';
                this.maxHp = 600;
                this.hp = 600;
                this.maxMp = 300;
                this.mp = 300;
                this.xp = 0;
                this.xpToLevel = 100;
                this.abilities = [
                    { name: 'Fireball', key: 'Q', cd: 2000, lastUse: 0, cost: 40 },
                    { name: 'Dash', key: 'W', cd: 5000, lastUse: 0, cost: 60 },
                    { name: 'StunPulse', key: 'E', cd: 8000, lastUse: 0, cost: 80 },
                    { name: 'UltiBeam', key: 'R', cd: 20000, lastUse: 0, cost: 150 }
                ];
            }

            onKill(target) {
                if (target.type === 'minion') this.gainXp(30);
                if (target.type === 'hero') this.gainXp(200);
            }

            gainXp(amt) {
                this.xp += amt;
                if (this.xp >= this.xpToLevel) {
                    this.levelUp();
                }
            }

            levelUp() {
                this.level++;
                this.xp -= this.xpToLevel;
                this.xpToLevel *= 1.2;
                this.maxHp += 50;
                this.hp = this.maxHp;
                this.damage += 5;
                
                if (this.team === 'player') {
                    document.getElementById('level-indicator').innerText = `LEVEL ${this.level}`;
                    createExplotion(this.x, this.y, '#ffd700', 50);
                }
            }

            update(dt) {
                super.update(dt);
                // MP Regeneration
                if (this.mp < this.maxMp) this.mp += 0.1;
            }
        }

        class Minion extends Entity {
            constructor(x, y, team) {
                super(x, y, 15, team === 'player' ? '#00f2ff' : '#ff3c3c', team);
                this.type = 'minion';
                this.maxHp = 200;
                this.hp = 200;
                this.speed = 2;
                this.damage = 12;
            }

            update(dt) {
                if (this.dead) return;

                // Simple AI: Find closest enemy
                let closest = null;
                let minDist = 300;

                entities.forEach(e => {
                    if (e.team !== this.team && !e.dead) {
                        const d = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                        if (d < minDist) {
                            minDist = d;
                            closest = e;
                        }
                    }
                });

                if (closest) {
                    if (minDist > this.attackRange) {
                        this.targetX = closest.x;
                        this.targetY = closest.y;
                        super.update(dt);
                    } else {
                        // Attack
                        const now = Date.now();
                        if (now - this.lastAttack > this.attackSpeed) {
                            closest.takeDamage(this.damage, this);
                            this.lastAttack = now;
                            createProjectile(this, closest, this.color);
                        }
                    }
                } else {
                    // Move towards enemy base
                    const baseTargetX = this.team === 'player' ? MAP_SIZE - 200 : 200;
                    const baseTargetY = this.team === 'player' ? MAP_SIZE - 200 : 200;
                    this.targetX = baseTargetX;
                    this.targetY = baseTargetY;
                    super.update(dt);
                }
            }
        }

        class Structure extends Entity {
            constructor(x, y, type, team) {
                const radius = type === 'base' ? 80 : 50;
                const color = team === 'player' ? '#00aaff' : '#aa0000';
                super(x, y, radius, color, team);
                this.type = type; // 'tower' or 'base'
                this.maxHp = type === 'base' ? 2000 : 1000;
                this.hp = this.maxHp;
                this.attackRange = 400;
                this.damage = 40;
                this.attackSpeed = 1500;
            }

            update(dt) {
                if (this.dead) return;
                
                // Towers attack nearby enemies
                const now = Date.now();
                if (now - this.lastAttack > this.attackSpeed) {
                    let target = null;
                    entities.forEach(e => {
                        if (e.team !== this.team && !e.dead) {
                            const d = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                            if (d < this.attackRange) {
                                target = e;
                            }
                        }
                    });

                    if (target) {
                        target.takeDamage(this.damage, this);
                        this.lastAttack = now;
                        createProjectile(this, target, this.color, 8);
                    }
                }
            }

            draw() {
                const screenX = this.x - camera.x;
                const screenY = this.y - camera.y;
                if (screenX < -200 || screenX > camera.width + 200 || screenY < -200 || screenY > camera.height + 200) return;

                // Glow
                const grad = ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, this.radius * 2);
                grad.addColorStop(0, this.color);
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grad;
                ctx.globalAlpha = 0.3;
                ctx.beginPath();
                ctx.arc(screenX, screenY, this.radius * 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;

                // Structure Shape
                ctx.fillStyle = this.color;
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                if (this.type === 'base') {
                    ctx.beginPath();
                    ctx.moveTo(screenX, screenY - this.radius);
                    ctx.lineTo(screenX + this.radius, screenY);
                    ctx.lineTo(screenX, screenY + this.radius);
                    ctx.lineTo(screenX - this.radius, screenY);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                } else {
                    ctx.fillRect(screenX - this.radius/2, screenY - this.radius/2, this.radius, this.radius);
                    ctx.strokeRect(screenX - this.radius/2, screenY - this.radius/2, this.radius, this.radius);
                }

                // HP Bar
                const barWidth = this.radius * 2;
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(screenX - barWidth/2, screenY - this.radius - 20, barWidth, 8);
                ctx.fillStyle = this.team === 'player' ? '#00ff88' : '#ff3c3c';
                ctx.fillRect(screenX - barWidth/2, screenY - this.radius - 20, barWidth * (this.hp/this.maxHp), 8);
            }

            die(source) {
                super.die(source);
                if (this.type === 'base') {
                    gameActive = false;
                    showStatus(this.team === 'player' ? 'DEFEAT' : 'VICTORY');
                }
            }
        }

        // --- PARTICLE SYSTEM ---
        function createExplotion(x, y, color, count = 20) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 1.0,
                    size: Math.random() * 5 + 2,
                    color: color
                });
            }
        }

        function createDamageText(x, y, amt) {
            particles.push({
                x, y: y - 30,
                vx: (Math.random() - 0.5) * 2,
                vy: -2,
                life: 1.5,
                text: Math.round(amt),
                color: '#fff',
                fontSize: 20
            });
        }

        function createProjectile(from, to, color, size = 4) {
            projectiles.push({
                x: from.x,
                y: from.y,
                toX: to.x,
                toY: to.y,
                target: to,
                speed: 10,
                color: color,
                size: size
            });
        }

        // --- ABILITIES ---
        function useAbility(index) {
            const skill = player.abilities[index];
            const now = Date.now();
            
            if (now - skill.lastUse < skill.cd) return;
            if (player.mp < skill.cost) return;

            player.mp -= skill.cost;
            skill.lastUse = now;

            const targetX = mouse.worldX;
            const targetY = mouse.worldY;
            const dx = targetX - player.x;
            const dy = targetY - player.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            const dirX = dx / dist;
            const dirY = dy / dist;

            switch(index) {
                case 0: // Q - Fireball
                    projectiles.push({
                        x: player.x, y: player.y,
                        vx: dirX * 12, vy: dirY * 12,
                        type: 'skill', damage: 60 + player.level * 10,
                        radius: 30, color: '#ff6600', life: 100,
                        team: 'player'
                    });
                    break;
                case 1: // W - Dash
                    player.x += dirX * 200;
                    player.y += dirY * 200;
                    player.targetX = player.x;
                    player.targetY = player.y;
                    createExplotion(player.x, player.y, '#00f2ff', 30);
                    break;
                case 2: // E - Stun Pulse
                    createExplotion(player.x, player.y, '#9d00ff', 50);
                    entities.forEach(e => {
                        if (e.team !== 'player' && !e.dead) {
                            const d = Math.sqrt((e.x - player.x)**2 + (e.y - player.y)**2);
                            if (d < 250) {
                                e.takeDamage(40, player);
                                // add stun effect logic here if desired
                            }
                        }
                    });
                    break;
                case 3: // R - Ultimate Beam
                    // Simple large AOE for now
                    flashScreen();
                    entities.forEach(e => {
                        if (e.team !== 'player' && !e.dead) {
                            const d = Math.sqrt((e.x - player.x)**2 + (e.y - player.y)**2);
                            if (d < 500) {
                                e.takeDamage(200 + player.level * 30, player);
                            }
                        }
                    });
                    createExplotion(player.x, player.y, '#fff', 100);
                    break;
            }

            // Update UI
            const overlay = document.querySelectorAll('.cooldown-overlay')[index];
            overlay.style.height = '100%';
            setTimeout(() => {
                let timeLeft = skill.cd;
                const int = setInterval(() => {
                    timeLeft -= 100;
                    overlay.style.height = (timeLeft / skill.cd * 100) + '%';
                    if (timeLeft <= 0) {
                        overlay.style.height = '0%';
                        clearInterval(int);
                    }
                }, 100);
            }, 10);
        }

        function flashScreen() {
            const f = document.createElement('div');
            f.style.position = 'fixed';
            f.style.top = 0; f.style.left = 0; f.style.width = '100%'; f.style.height = '100%';
            f.style.backgroundColor = 'white'; f.style.zIndex = 100; f.style.opacity = 0.3;
            f.style.pointerEvents = 'none';
            document.body.appendChild(f);
            setTimeout(() => f.remove(), 100);
        }

        // --- INITIALIZATION ---
        function init() {
            resize();
            window.addEventListener('resize', resize);
            
            // Interaction
            canvas.addEventListener('mousedown', e => {
                if (e.button === 0) mouse.clicked = true;
                if (e.button === 2) mouse.rightClicked = true;
            });
            canvas.addEventListener('mouseup', e => {
                if (e.button === 0) mouse.clicked = false;
                if (e.button === 2) mouse.rightClicked = false;
            });
            canvas.addEventListener('mousemove', e => {
                const rect = canvas.getBoundingClientRect();
                mouse.x = e.clientX - rect.left;
                mouse.y = e.clientY - rect.top;
                mouse.worldX = mouse.x + camera.x;
                mouse.worldY = mouse.y + camera.y;
            });
            window.addEventListener('contextmenu', e => e.preventDefault());
            window.addEventListener('keydown', e => {
                keys[e.key.toLowerCase()] = true;
                if (e.key.toLowerCase() === 'q') useAbility(0);
                if (e.key.toLowerCase() === 'w') useAbility(1);
                if (e.key.toLowerCase() === 'e') useAbility(2);
                if (e.key.toLowerCase() === 'r') useAbility(3);
            });
            window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

            // Create entities
            player = new Hero(300, 300, '#00f2ff', 'player');
            enemyHero = new Hero(MAP_SIZE - 300, MAP_SIZE - 300, '#ff3c3c', 'enemy');
            
            entities.push(player);
            entities.push(enemyHero);

            // Bases
            entities.push(new Structure(200, 200, 'base', 'player'));
            entities.push(new Structure(MAP_SIZE - 200, MAP_SIZE - 200, 'base', 'enemy'));

            // Towers
            entities.push(new Structure(800, 800, 'tower', 'player'));
            entities.push(new Structure(MAP_SIZE - 800, MAP_SIZE - 800, 'tower', 'enemy'));
            
            // Spawn initial minions
            spawnWave();
            setInterval(spawnWave, 30000);

            requestAnimationFrame(gameLoop);
        }

        function spawnWave() {
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    entities.push(new Minion(400 + i*40, 400, 'player'));
                    entities.push(new Minion(MAP_SIZE - 400 - i*40, MAP_SIZE - 400, 'enemy'));
                }, i * 500);
            }
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            camera.width = canvas.width;
            camera.height = canvas.height;
            
            miniCanvas.width = 180;
            miniCanvas.height = 180;
        }

        function showStatus(msg) {
            const el = document.getElementById('status-msg');
            el.innerText = msg;
            el.className = 'status-msg ' + (msg === 'VICTORY' ? 'win' : 'loss');
            el.style.opacity = 1;
        }

        // --- MAIN LOOP ---
        function gameLoop(time) {
            if (!gameActive) return;
            const dt = (time - lastTime) / 16.67;
            lastTime = time;

            update(dt);
            draw();

            requestAnimationFrame(gameLoop);
        }

        function update(dt) {
            // Player input
            if (mouse.rightClicked) {
                player.targetX = mouse.worldX;
                player.targetY = mouse.worldY;
            }

            // Camera follow
            camera.x += (player.x - camera.width / 2 - camera.x) * camera.lerp;
            camera.y += (player.y - camera.height / 2 - camera.y) * camera.lerp;
            
            // Constrain camera
            camera.x = Math.max(0, Math.min(MAP_SIZE - camera.width, camera.x));
            camera.y = Math.max(0, Math.min(MAP_SIZE - camera.height, camera.y));

            // Update entities
            entities = entities.filter(e => !e.dead || e.type === 'hero' || e.type === 'base');
            entities.forEach(e => e.update(dt));

            // Projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                if (p.type === 'skill') {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life--;
                    
                    // Check hits
                    entities.forEach(e => {
                        if (e.team !== p.team && !e.dead) {
                            const d = Math.sqrt((e.x - p.x)**2 + (e.y - p.y)**2);
                            if (d < p.radius + e.radius) {
                                e.takeDamage(p.damage, player);
                                p.life = 0;
                            }
                        }
                    });

                    if (p.life <= 0) projectiles.splice(i, 1);
                } else {
                    // Homing
                    const dx = p.target.x - p.x;
                    const dy = p.target.y - p.y;
                    const d = Math.sqrt(dx*dx + dy*dy);
                    if (d < 10) {
                        projectiles.splice(i, 1);
                    } else {
                        p.x += (dx/d) * p.speed;
                        p.y += (dy/d) * p.speed;
                    }
                }
            }

            // Particles
            for(let i = particles.length-1; i >=0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.02;
                if (p.life <= 0) particles.splice(i, 1);
            }

            // UI
            document.getElementById('hp-fill').style.width = (player.hp / player.maxHp * 100) + '%';
            document.getElementById('mp-fill').style.width = (player.mp / player.maxMp * 100) + '%';
            document.getElementById('xp-fill').style.width = (player.xp / player.xpToLevel * 100) + '%';
            document.getElementById('debug').innerText = `FPS: ${Math.round(1000/(dt*16.67))} | Pos: ${Math.round(player.x)}, ${Math.round(player.y)}`;
        }

        function draw() {
            ctx.fillStyle = '#050508';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw Grid
            ctx.strokeStyle = 'rgba(0, 242, 255, 0.05)';
            ctx.lineWidth = 1;
            const startX = Math.floor(camera.x / GRID_SIZE) * GRID_SIZE;
            const startY = Math.floor(camera.y / GRID_SIZE) * GRID_SIZE;
            for (let x = startX; x < camera.x + camera.width; x += GRID_SIZE) {
                ctx.beginPath(); ctx.moveTo(x - camera.x, 0); ctx.lineTo(x - camera.x, canvas.height); ctx.stroke();
            }
            for (let y = startY; y < camera.y + camera.height; y += GRID_SIZE) {
                ctx.beginPath(); ctx.moveTo(0, y - camera.y); ctx.lineTo(canvas.width, y - camera.y); ctx.stroke();
            }

            // Entities
            entities.forEach(e => e.draw());

            // Projectiles
            projectiles.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x - camera.x, p.y - camera.y, p.size || 5, 0, Math.PI * 2);
                ctx.fillStyle = p.color;
                ctx.shadowBlur = 10; ctx.shadowColor = p.color;
                ctx.fill();
                ctx.shadowBlur = 0;
            });

            // Particles
            particles.forEach(p => {
                ctx.globalAlpha = p.life;
                if (p.text) {
                    ctx.fillStyle = p.color;
                    ctx.font = `bold ${p.fontSize}px Outfit`;
                    ctx.fillText(p.text, p.x - camera.x, p.y - camera.y);
                } else {
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x - camera.x, p.y - camera.y, p.size, p.size);
                }
            });
            ctx.globalAlpha = 1.0;

            // Minimap
            drawMinimap();
        }

        function drawMinimap() {
            miniCtx.fillStyle = 'rgba(0,0,0,0.5)';
            miniCtx.fillRect(0, 0, 180, 180);
            
            const ratio = 180 / MAP_SIZE;
            entities.forEach(e => {
                miniCtx.fillStyle = e.team === 'player' ? '#00f2ff' : '#ff3c3c';
                const size = e.type === 'hero' ? 4 : 2;
                miniCtx.fillRect(e.x * ratio - size/2, e.y * ratio - size/2, size, size);
            });

            // Viewport rect
            miniCtx.strokeStyle = 'rgba(255,255,255,0.3)';
            miniCtx.strokeRect(camera.x * ratio, camera.y * ratio, camera.width * ratio, camera.height * ratio);
        }

        init();

    </script>
</body>
</html>
