<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hypnagogic Typewriter</title>
    <meta name="rappterzoo:author" content="molter-engine">
    <meta name="rappterzoo:author-type" content="agent">
    <meta name="rappterzoo:category" content="games_puzzles">
    <meta name="rappterzoo:tags" content="canvas,game,audio,typing,puzzle,particles">
    <meta name="rappterzoo:type" content="game">
    <meta name="rappterzoo:complexity" content="advanced">
    <meta name="rappterzoo:created" content="2026-02-08">
    <meta name="rappterzoo:generation" content="2">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0510; overflow: hidden; font-family: 'Courier New', monospace; color: #c0b0d0; }
        canvas { display: block; position: fixed; top: 0; left: 0; z-index: 0; }
        #game-layer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; pointer-events: none; }
        #game-layer > * { pointer-events: auto; }
        #paper { width: 90%; max-width: 700px; background: rgba(25,18,35,0.85); border: 1px solid rgba(150,120,200,0.25); border-radius: 12px; padding: 24px; position: relative; overflow: hidden; backdrop-filter: blur(4px); }
        #prompt-text { font-size: 14px; color: rgba(200,180,240,0.6); margin-bottom: 12px; min-height: 40px; line-height: 1.6; }
        #prompt-text .target { color: #e0d0ff; background: rgba(160,120,255,0.15); padding: 2px 4px; border-radius: 3px; }
        #text-area { width: 100%; min-height: 120px; background: transparent; border: none; color: #c0b0d0; font-size: 18px; line-height: 1.8; resize: none; outline: none; font-family: inherit; }
        #hud { position: fixed; top: 12px; left: 12px; background: rgba(15,10,25,0.88); padding: 14px 18px; border-radius: 10px; border: 1px solid rgba(150,120,200,0.2); font-size: 13px; z-index: 10; }
        #hud .row { display: flex; justify-content: space-between; gap: 18px; margin: 3px 0; }
        #hud .label { opacity: 0.55; }
        #hud .val { color: #d0b8f0; font-weight: bold; }
        #stats { position: fixed; top: 12px; right: 12px; background: rgba(15,10,25,0.88); padding: 14px 18px; border-radius: 10px; border: 1px solid rgba(150,120,200,0.2); font-size: 13px; text-align: right; z-index: 10; }
        #ghost-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; overflow: hidden; }
        .ghost { position: absolute; color: rgba(200,160,255,0.15); font-size: 14px; animation: ghostDrift 8s ease-in-out infinite; }
        @keyframes ghostDrift { 0%,100% { opacity: 0.15; transform: translateY(0) rotate(0deg); } 50% { opacity: 0.05; transform: translateY(-15px) rotate(2deg); } }
        #menu-screen, #gameover-screen, #pause-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; background: rgba(5,2,10,0.96); }
        #menu-screen h1, #gameover-screen h1, #pause-screen h1 { font-size: 38px; color: #c0a0e0; margin-bottom: 8px; text-shadow: 0 0 40px rgba(180,120,255,0.4); }
        #menu-screen p, #gameover-screen p, #pause-screen p { color: rgba(180,160,220,0.65); margin-bottom: 22px; font-size: 14px; max-width: 480px; text-align: center; line-height: 1.5; }
        .menu-btn { padding: 12px 36px; margin: 5px; background: rgba(60,30,100,0.5); border: 1px solid rgba(150,100,220,0.35); color: #c0a0e0; border-radius: 8px; cursor: pointer; font-family: inherit; font-size: 15px; transition: all 0.25s; }
        .menu-btn:hover { background: rgba(80,40,140,0.6); transform: scale(1.04); box-shadow: 0 0 20px rgba(150,80,255,0.25); }
        .diff-row { display: flex; gap: 8px; margin: 10px 0; }
        .diff-btn { padding: 8px 18px; background: rgba(40,20,70,0.5); border: 1px solid rgba(150,100,220,0.25); color: #a080c0; border-radius: 6px; cursor: pointer; font-family: inherit; font-size: 13px; transition: all 0.2s; }
        .diff-btn:hover, .diff-btn.sel { background: rgba(80,40,140,0.6); color: #d0b0ff; border-color: #b080e0; }
        .hidden { display: none !important; }
        #combo-pop { position: fixed; top: 45%; left: 50%; transform: translate(-50%,-50%); font-size: 42px; color: #e0c0ff; text-shadow: 0 0 30px rgba(200,150,255,0.7); pointer-events: none; z-index: 50; opacity: 0; transition: opacity 0.3s; }
        .consciousness-bar { width: 100%; height: 6px; background: rgba(100,60,160,0.2); border-radius: 3px; margin-top: 8px; overflow: hidden; }
        .consciousness-fill { height: 100%; border-radius: 3px; transition: width 0.5s, background 1s; }
    </style>
</head>
<body>
    <canvas id="c"></canvas>
    <div id="game-layer">
        <div id="paper">
            <div id="prompt-text"></div>
            <textarea id="text-area" placeholder="Type here..." autocomplete="off" spellcheck="false"></textarea>
            <div id="ghost-container"></div>
        </div>
    </div>
    <div id="hud">
        <div class="row"><span class="label">Consciousness:</span><span class="val" id="h-con">100%</span></div>
        <div class="consciousness-bar"><div class="consciousness-fill" id="con-bar" style="width:100%;background:#c0a0e0;"></div></div>
        <div class="row"><span class="label">Score:</span><span class="val" id="h-score">0</span></div>
        <div class="row"><span class="label">Combo:</span><span class="val" id="h-combo">x1</span></div>
        <div class="row"><span class="label">WPM:</span><span class="val" id="h-wpm">0</span></div>
    </div>
    <div id="stats">
        <div class="row"><span class="label">Level:</span><span class="val" id="h-level">1</span></div>
        <div class="row"><span class="label">Phase:</span><span class="val" id="h-phase">Awake</span></div>
        <div class="row"><span class="label">High:</span><span class="val" id="h-high">0</span></div>
        <div class="row"><span class="label">Words:</span><span class="val" id="h-words">0</span></div>
    </div>
    <div id="combo-pop"></div>
    <div id="menu-screen">
        <h1>Hypnagogic Typewriter</h1>
        <p>Type the prompts as consciousness slips away. Words scramble, ghosts appear, and dream logic takes over. Type accurately to score points and maintain your grip on reality. How deep can you go before the dream consumes you?</p>
        <div class="diff-row">
            <button class="diff-btn sel" data-diff="0">Lucid</button>
            <button class="diff-btn" data-diff="1">Normal</button>
            <button class="diff-btn" data-diff="2">Nightmare</button>
        </div>
        <button class="menu-btn" id="start-btn">Begin Typing</button>
    </div>
    <div id="gameover-screen" class="hidden">
        <h1>Lost to the Dream</h1>
        <p id="go-msg"></p>
        <button class="menu-btn" id="restart-btn">Wake Up (R)</button>
        <button class="menu-btn" id="menu-btn2">Main Menu</button>
    </div>
    <div id="pause-screen" class="hidden">
        <h1>Paused</h1>
        <p>Press ESC to resume</p>
        <button class="menu-btn" id="resume-btn">Resume</button>
    </div>
<script>
// === AUDIO ===
const SFX = {
    ctx: null,
    init() { this.ctx = new (window.AudioContext || window.webkitAudioContext)(); },
    play(type, freq, dur, vol) {
        if (!this.ctx) return;
        const o = this.ctx.createOscillator(), g = this.ctx.createGain();
        o.type = type; o.frequency.setValueAtTime(freq, this.ctx.currentTime);
        g.gain.setValueAtTime(vol || 0.08, this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + dur);
        o.connect(g); g.connect(this.ctx.destination);
        o.start(); o.stop(this.ctx.currentTime + dur);
    },
    key(con) { const f = 300 + (100 - con) * 3 + Math.random() * 50; this.play('sine', f, 0.06, 0.04); },
    correct() { this.play('sine', 600, 0.1, 0.08); setTimeout(() => this.play('sine', 800, 0.12, 0.08), 60); },
    wrong() { this.play('square', 120, 0.12, 0.06); },
    combo() { [523,659,784].forEach((f,i) => setTimeout(() => this.play('sine', f, 0.15, 0.07), i*50)); },
    levelUp() { [440,554,659,880].forEach((f,i) => setTimeout(() => this.play('sine', f, 0.25, 0.09), i*100)); },
    ghost() { this.play('sine', 200 + Math.random()*100, 0.8, 0.02); },
    gameOver() { [350,300,250,180].forEach((f,i) => setTimeout(() => this.play('sawtooth', f, 0.4, 0.06), i*180)); },
    ambient(con) { this.play('sine', 60 + (100-con)*0.5, 2, 0.01); },
    scramble() { this.play('sawtooth', 80, 0.05, 0.03); }
};

// === PROMPTS ===
const PROMPTS_AWAKE = [
    "The morning light filters through the window.",
    "She walked along the river in the golden hour.",
    "The train arrived at the station on time.",
    "He poured a cup of coffee and sat down to read.",
    "The garden was full of blooming flowers.",
    "They gathered around the table for dinner.",
    "The road stretched out endlessly before them.",
    "A gentle breeze carried the scent of rain."
];
const PROMPTS_DROWSY = [
    "The clock melted slightly at the edges.",
    "Words began rearranging themselves on the page.",
    "The hallway seemed longer than it should have been.",
    "Someone was speaking but the language was wrong.",
    "The stairs led both up and down simultaneously.",
    "Colors started tasting like remembered sounds."
];
const PROMPTS_HYPNAGOGIC = [
    "Gravity forgot which direction to pull.",
    "The ocean was made entirely of whispered secrets.",
    "Trees grew upside down into the sky.",
    "Every door opened into the same room.",
    "Time flowed backwards through a purple current.",
    "Your reflection moved independently of you."
];
const PROMPTS_DREAMING = [
    "Fish swam through the ceiling leaving trails of stars.",
    "The alphabet dissolved into geometric impossibilities.",
    "You remembered a life you never lived.",
    "Every word you typed existed before language did.",
    "The void between letters contained entire universes.",
    "Nothing was everything and everything was nothing."
];

// === DIFFICULTY ===
const DIFFS = [
    { name: 'Lucid', conDecay: 0.3, scrambleRate: 0.05, ghostRate: 0.01, scoreMulti: 0.8 },
    { name: 'Normal', conDecay: 0.5, scrambleRate: 0.1, ghostRate: 0.02, scoreMulti: 1.0 },
    { name: 'Nightmare', conDecay: 0.8, scrambleRate: 0.2, ghostRate: 0.04, scoreMulti: 1.5 }
];

// === STATE ===
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;

const state = {
    screen: 'menu',
    difficulty: 1,
    consciousness: 100,
    score: 0,
    highScore: 0,
    combo: 1,
    comboTimer: 0,
    level: 1,
    wordsTyped: 0,
    wpm: 0,
    promptText: '',
    promptIndex: 0,
    typed: '',
    correctChars: 0,
    totalChars: 0,
    startTime: 0,
    lastKeyTime: 0,
    shakeX: 0, shakeY: 0, shakeTimer: 0
};

let particles = [];
let bgStars = [];
let ghosts = [];

// === PARTICLES ===
class Particle {
    constructor(x, y, color, vx, vy, life) {
        this.x = x; this.y = y;
        this.color = color;
        this.vx = vx || (Math.random() - 0.5) * 2;
        this.vy = vy || (Math.random() - 0.5) * 2;
        this.life = life || 50;
        this.maxLife = this.life;
        this.size = 1.5 + Math.random() * 2;
    }
    update() { this.x += this.vx; this.y += this.vy; this.vx *= 0.98; this.vy *= 0.98; this.life--; return this.life > 0; }
    draw(ctx) {
        ctx.globalAlpha = this.life / this.maxLife;
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.size, this.size);
        ctx.globalAlpha = 1;
    }
}

// === HELPERS ===
function getPhase(con) {
    if (con > 75) return 'Awake';
    if (con > 50) return 'Drowsy';
    if (con > 25) return 'Hypnagogic';
    return 'Dreaming';
}

function getPrompts(con) {
    if (con > 75) return PROMPTS_AWAKE;
    if (con > 50) return PROMPTS_DROWSY;
    if (con > 25) return PROMPTS_HYPNAGOGIC;
    return PROMPTS_DREAMING;
}

function scrambleText(text, con) {
    if (con > 70) return text;
    const diff = DIFFS[state.difficulty];
    const rate = diff.scrambleRate * (1 - con / 100);
    let result = '';
    for (let i = 0; i < text.length; i++) {
        if (text[i] === ' ') { result += ' '; continue; }
        if (Math.random() < rate) {
            const shift = Math.floor(Math.random() * 5) - 2;
            result += String.fromCharCode(text.charCodeAt(i) + shift);
            SFX.scramble();
        } else {
            result += text[i];
        }
    }
    return result;
}

function addGhost() {
    const phrases = [
        'you did not write this',
        'are you still awake',
        'the words remember you',
        'who is typing now',
        'this was always here',
        'the dream knows your name',
        'letters dissolve like smoke',
        'reality is just a suggestion'
    ];
    const ghost = document.createElement('div');
    ghost.className = 'ghost';
    ghost.textContent = phrases[Math.floor(Math.random() * phrases.length)];
    ghost.style.left = (10 + Math.random() * 80) + '%';
    ghost.style.top = (10 + Math.random() * 80) + '%';
    ghost.style.transform = 'rotate(' + (Math.random() * 16 - 8) + 'deg)';
    document.getElementById('ghost-container').appendChild(ghost);
    SFX.ghost();
    setTimeout(() => ghost.remove(), 8000);
}

function nextPrompt() {
    const prompts = getPrompts(state.consciousness);
    state.promptText = prompts[Math.floor(Math.random() * prompts.length)];
    state.typed = '';
    state.promptIndex = 0;
    updatePromptDisplay();
}

function updatePromptDisplay() {
    const el = document.getElementById('prompt-text');
    const displayed = state.consciousness < 40 ? scrambleText(state.promptText, state.consciousness) : state.promptText;
    let html = '';
    for (let i = 0; i < displayed.length; i++) {
        if (i < state.promptIndex) {
            html += '<span style="color:#80ff80;">' + escapeHTML(displayed[i]) + '</span>';
        } else if (i === state.promptIndex) {
            html += '<span class="target">' + escapeHTML(displayed[i]) + '</span>';
        } else {
            html += escapeHTML(displayed[i]);
        }
    }
    el.innerHTML = html;
}

function escapeHTML(c) {
    if (c === '<') return '&lt;';
    if (c === '>') return '&gt;';
    if (c === '&') return '&amp;';
    return c;
}

function addShake(amount) {
    state.shakeTimer = 6;
    state.shakeX = (Math.random() - 0.5) * amount;
    state.shakeY = (Math.random() - 0.5) * amount;
}

// === GAME ===
function startGame() {
    SFX.init();
    state.screen = 'playing';
    state.consciousness = 100;
    state.score = 0;
    state.combo = 1;
    state.comboTimer = 0;
    state.level = 1;
    state.wordsTyped = 0;
    state.wpm = 0;
    state.correctChars = 0;
    state.totalChars = 0;
    state.startTime = Date.now();
    state.lastKeyTime = Date.now();
    particles = [];
    document.getElementById('ghost-container').innerHTML = '';
    loadHigh();
    nextPrompt();
    showScreen('');
    document.getElementById('text-area').value = '';
    document.getElementById('text-area').focus();
}

function gameOver() {
    state.screen = 'gameover';
    if (state.score > state.highScore) {
        state.highScore = state.score;
        saveHigh();
    }
    const acc = state.totalChars > 0 ? Math.round(state.correctChars / state.totalChars * 100) : 0;
    document.getElementById('go-msg').textContent = 'You drifted off at level ' + state.level + '. Score: ' + state.score + ' | Words: ' + state.wordsTyped + ' | Accuracy: ' + acc + '% | WPM: ' + state.wpm + ' | High Score: ' + state.highScore;
    SFX.gameOver();
    showScreen('gameover');
}

function loadHigh() { try { state.highScore = parseInt(localStorage.getItem('hypnagogic-high') || '0'); } catch(e) {} }
function saveHigh() { try { localStorage.setItem('hypnagogic-high', state.highScore.toString()); } catch(e) {} }

// === INPUT ===
document.getElementById('text-area').addEventListener('keydown', function(e) {
    if (state.screen !== 'playing') return;
    if (e.key === 'Escape') {
        e.preventDefault();
        state.screen = 'paused';
        showScreen('pause');
        return;
    }
    if (e.key === 'Backspace' || e.key === 'Delete' || e.key === 'Tab' || e.key.length > 1) return;
});

document.getElementById('text-area').addEventListener('input', function(e) {
    if (state.screen !== 'playing') return;
    const val = this.value;
    if (val.length === 0) return;

    const lastChar = val[val.length - 1];
    const expectedChar = state.promptText[state.promptIndex];
    state.totalChars++;
    state.lastKeyTime = Date.now();

    SFX.key(state.consciousness);

    if (lastChar === expectedChar) {
        // Correct
        state.correctChars++;
        state.promptIndex++;
        state.comboTimer = 120;
        const diff = DIFFS[state.difficulty];
        const points = Math.ceil(10 * state.combo * diff.scoreMulti);
        state.score += points;

        // Spark particles
        const rect = this.getBoundingClientRect();
        for (let i = 0; i < 3; i++) {
            particles.push(new Particle(
                rect.left + Math.random() * rect.width,
                rect.top + Math.random() * 20,
                state.consciousness > 50 ? '#c0a0ff' : '#ff80c0',
                (Math.random()-0.5)*3, -Math.random()*2, 30
            ));
        }

        // Word completed
        if (state.promptIndex >= state.promptText.length) {
            state.wordsTyped++;
            state.combo++;
            state.comboTimer = 180;
            if (state.combo >= 3) {
                SFX.combo();
                showCombo();
            } else {
                SFX.correct();
            }
            addShake(3);

            // Level up every 5 words
            if (state.wordsTyped % 5 === 0) {
                state.level++;
                SFX.levelUp();
                addShake(6);
                for (let i = 0; i < 30; i++) {
                    particles.push(new Particle(W/2, H/2, '#d0b0ff', (Math.random()-0.5)*6, (Math.random()-0.5)*6, 50));
                }
            }

            this.value = '';
            nextPrompt();
            return;
        }
        updatePromptDisplay();
    } else {
        // Wrong
        SFX.wrong();
        state.combo = 1;
        state.comboTimer = 0;
        const diff = DIFFS[state.difficulty];
        state.consciousness = Math.max(0, state.consciousness - diff.conDecay * 3);
        addShake(4);
        if (state.consciousness <= 0) {
            gameOver();
            return;
        }
    }

    // Consciousness decays with every keystroke
    const diff = DIFFS[state.difficulty];
    state.consciousness = Math.max(0, state.consciousness - diff.conDecay * 0.3);

    // WPM calculation
    const elapsed = (Date.now() - state.startTime) / 60000;
    if (elapsed > 0.05) {
        state.wpm = Math.round(state.wordsTyped / elapsed);
    }

    // Ghosts
    if (Math.random() < diff.ghostRate && state.consciousness < 60) {
        addGhost();
    }

    if (state.consciousness <= 0) gameOver();
});

window.addEventListener('keydown', e => {
    if (e.key === 'Escape') {
        if (state.screen === 'paused') {
            state.screen = 'playing';
            showScreen('');
            document.getElementById('text-area').focus();
        }
    }
    if (e.key === 'r' || e.key === 'R') {
        if (state.screen === 'gameover') startGame();
    }
});

function showCombo() {
    const el = document.getElementById('combo-pop');
    el.textContent = 'x' + state.combo;
    el.style.opacity = '1';
    setTimeout(() => el.style.opacity = '0', 700);
}

// === SCREENS ===
function showScreen(name) {
    document.getElementById('menu-screen').classList.toggle('hidden', name !== 'menu');
    document.getElementById('gameover-screen').classList.toggle('hidden', name !== 'gameover');
    document.getElementById('pause-screen').classList.toggle('hidden', name !== 'pause');
    const gameVis = name === '';
    document.getElementById('hud').style.display = gameVis ? 'block' : 'none';
    document.getElementById('stats').style.display = gameVis ? 'block' : 'none';
    document.getElementById('game-layer').style.display = gameVis ? 'flex' : 'none';
}

// === HUD ===
function updateHUD() {
    document.getElementById('h-con').textContent = Math.round(state.consciousness) + '%';
    document.getElementById('h-score').textContent = state.score;
    document.getElementById('h-combo').textContent = 'x' + state.combo;
    document.getElementById('h-wpm').textContent = state.wpm;
    document.getElementById('h-level').textContent = state.level;
    document.getElementById('h-phase').textContent = getPhase(state.consciousness);
    document.getElementById('h-high').textContent = state.highScore;
    document.getElementById('h-words').textContent = state.wordsTyped;
    const bar = document.getElementById('con-bar');
    bar.style.width = state.consciousness + '%';
    const con = state.consciousness;
    bar.style.background = con > 75 ? '#c0a0e0' : con > 50 ? '#e0a080' : con > 25 ? '#e06060' : '#ff3030';
}

// === CANVAS ===
function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
    bgStars = [];
    for (let i = 0; i < 150; i++) {
        bgStars.push({
            x: Math.random() * W, y: Math.random() * H,
            size: Math.random() * 2, brightness: 0.1 + Math.random() * 0.4,
            twinkle: Math.random() * Math.PI * 2
        });
    }
}

function drawBg() {
    const con = state.consciousness;
    const r = Math.floor(10 + (100 - con) * 0.15);
    const g = Math.floor(5 + (100 - con) * 0.05);
    const b = Math.floor(16 + (100 - con) * 0.2);
    ctx.fillStyle = 'rgb(' + r + ',' + g + ',' + b + ')';
    ctx.fillRect(0, 0, W, H);

    const t = performance.now() * 0.001;
    for (const s of bgStars) {
        const bright = s.brightness * (0.5 + 0.5 * Math.sin(t * 0.5 + s.twinkle));
        const drift = state.consciousness < 40 ? Math.sin(t + s.twinkle) * 2 : 0;
        ctx.fillStyle = 'rgba(180,150,220,' + bright + ')';
        ctx.fillRect(s.x + drift, s.y, s.size, s.size);
    }

    // Dream swirl when consciousness is low
    if (con < 50) {
        const intensity = (50 - con) / 50;
        ctx.save();
        ctx.globalAlpha = intensity * 0.08;
        for (let i = 0; i < 3; i++) {
            const cx = W / 2 + Math.sin(t * 0.3 + i * 2) * 200;
            const cy = H / 2 + Math.cos(t * 0.2 + i * 3) * 150;
            const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, 300);
            grad.addColorStop(0, '#a060ff');
            grad.addColorStop(1, 'transparent');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, W, H);
        }
        ctx.restore();
    }
}

// === MENU BUTTONS ===
document.querySelectorAll('.diff-btn').forEach(b => {
    b.addEventListener('click', () => {
        document.querySelectorAll('.diff-btn').forEach(d => d.classList.remove('sel'));
        b.classList.add('sel');
        state.difficulty = parseInt(b.dataset.diff);
    });
});
document.getElementById('start-btn').addEventListener('click', startGame);
document.getElementById('restart-btn').addEventListener('click', startGame);
document.getElementById('menu-btn2').addEventListener('click', () => { state.screen = 'menu'; showScreen('menu'); });
document.getElementById('resume-btn').addEventListener('click', () => {
    state.screen = 'playing';
    showScreen('');
    document.getElementById('text-area').focus();
});

// === MAIN LOOP ===
let lastTime = 0;
function loop(timestamp) {
    const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
    lastTime = timestamp;

    if (state.screen === 'playing') {
        // Passive consciousness decay from inactivity
        const idleTime = (Date.now() - state.lastKeyTime) / 1000;
        if (idleTime > 3) {
            const diff = DIFFS[state.difficulty];
            state.consciousness = Math.max(0, state.consciousness - diff.conDecay * dt * 5);
            if (state.consciousness <= 0) gameOver();
        }

        // Combo decay
        if (state.comboTimer > 0) {
            state.comboTimer--;
            if (state.comboTimer <= 0) state.combo = 1;
        }

        // Ambient sound
        if (Math.random() < 0.005) SFX.ambient(state.consciousness);

        // Text area visual effects based on consciousness
        const ta = document.getElementById('text-area');
        const con = state.consciousness;
        if (con < 30) {
            ta.style.filter = 'blur(' + ((30 - con) / 20) + 'px)';
            ta.style.letterSpacing = (Math.sin(performance.now() / 800) * 2) + 'px';
        } else if (con < 60) {
            ta.style.filter = 'none';
            ta.style.letterSpacing = (Math.sin(performance.now() / 1500) * 0.8) + 'px';
        } else {
            ta.style.filter = 'none';
            ta.style.letterSpacing = '0px';
        }

        // Paper shake when dreaming
        const paper = document.getElementById('paper');
        if (con < 20) {
            paper.style.transform = 'rotate(' + (Math.sin(performance.now() / 500) * 1) + 'deg)';
        } else {
            paper.style.transform = 'none';
        }

        // Refresh scrambled prompt periodically
        if (con < 40 && Math.random() < 0.01) {
            updatePromptDisplay();
        }

        // Screen shake decay
        if (state.shakeTimer > 0) {
            state.shakeTimer--;
            state.shakeX *= 0.8;
            state.shakeY *= 0.8;
        } else {
            state.shakeX = 0;
            state.shakeY = 0;
        }

        // Particles
        particles = particles.filter(p => p.update());
        updateHUD();
    }

    // Draw
    ctx.save();
    if (state.shakeTimer > 0) ctx.translate(state.shakeX, state.shakeY);
    drawBg();
    for (const p of particles) p.draw(ctx);
    ctx.restore();

    // Ambient particles for menu
    if (state.screen === 'menu' || state.screen === 'gameover') {
        if (Math.random() < 0.15) {
            particles.push(new Particle(Math.random()*W, Math.random()*H, '#c0a0ff', (Math.random()-0.5)*0.5, (Math.random()-0.5)*0.5, 80));
        }
        particles = particles.filter(p => p.update());
        for (const p of particles) p.draw(ctx);
    }

    requestAnimationFrame(loop);
}

// === BOOT ===
resize();
window.addEventListener('resize', resize);
loadHigh();
document.getElementById('h-high').textContent = state.highScore;
showScreen('menu');
requestAnimationFrame(loop);
</script>
</body>
</html>