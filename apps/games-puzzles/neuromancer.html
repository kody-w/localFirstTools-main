<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEUROMANCER - Cyberspace Wireframe Diver</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        @font-face {
            font-family: 'Terminal';
            src: local('Courier New'), local('Courier'), monospace;
        }

        body {
            background: #000;
            color: #0f0;
            font-family: 'Terminal', 'Courier New', monospace;
            overflow: hidden;
            cursor: none;
            user-select: none;
        }

        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #cyberspace {
            width: 100%;
            height: 100%;
            display: none;
            background: #000;
            position: relative;
            overflow: hidden;
        }

        #cyberspace.active {
            display: block;
        }

        #cyberspace::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 255, 255, 0.03) 0px,
                transparent 1px,
                transparent 2px,
                rgba(0, 255, 255, 0.03) 3px
            );
            pointer-events: none;
            z-index: 10;
        }

        #cyberspace-canvas {
            width: 100%;
            height: 100%;
            display: block;
            filter: contrast(1.2);
        }

        #sprawl {
            width: 100%;
            height: 100%;
            display: none;
            padding: 20px;
            overflow-y: auto;
            background: #000;
        }

        #sprawl.active {
            display: block;
        }

        .terminal-text {
            color: #0f0;
            text-shadow: 0 0 5px #0f0;
            line-height: 1.6;
            font-size: 14px;
        }

        .terminal-text.cyan {
            color: #0ff;
            text-shadow: 0 0 5px #0ff;
        }

        .terminal-text.magenta {
            color: #f0f;
            text-shadow: 0 0 5px #f0f;
        }

        .terminal-text.yellow {
            color: #ff0;
            text-shadow: 0 0 5px #ff0;
        }

        .terminal-text.red {
            color: #f00;
            text-shadow: 0 0 5px #f00;
        }

        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            pointer-events: none;
            z-index: 100;
            font-size: 12px;
        }

        .hud-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .hud-item {
            color: #0ff;
            text-shadow: 0 0 5px #0ff;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border: 1px solid #0ff;
        }

        .hud-bar {
            width: 200px;
            height: 20px;
            border: 1px solid #0ff;
            background: rgba(0, 0, 0, 0.7);
            position: relative;
            overflow: hidden;
        }

        .hud-bar-fill {
            height: 100%;
            background: #0ff;
            box-shadow: 0 0 10px #0ff;
            transition: width 0.3s;
        }

        .hud-bar-fill.shield {
            background: #f0f;
            box-shadow: 0 0 10px #f0f;
        }

        .hud-bar-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #0ff;
            font-size: 10px;
            text-shadow: 0 0 3px #000;
        }

        #message-log {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            max-height: 150px;
            overflow-y: auto;
            pointer-events: none;
            z-index: 100;
        }

        .message {
            color: #0ff;
            text-shadow: 0 0 5px #0ff;
            background: rgba(0, 0, 0, 0.8);
            padding: 5px 10px;
            margin-bottom: 3px;
            border-left: 2px solid #0ff;
            font-size: 11px;
            animation: messageIn 0.3s;
        }

        @keyframes messageIn {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .message.warning {
            color: #ff0;
            text-shadow: 0 0 5px #ff0;
            border-left-color: #ff0;
        }

        .message.danger {
            color: #f00;
            text-shadow: 0 0 5px #f00;
            border-left-color: #f00;
        }

        #breach-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }

        #breach-overlay.active {
            display: flex;
        }

        #breach-container {
            width: 600px;
            max-width: 90%;
            text-align: center;
        }

        #breach-canvas {
            width: 100%;
            height: 400px;
            border: 2px solid #0ff;
            box-shadow: 0 0 20px #0ff;
            display: block;
            margin: 0 auto;
        }

        #breach-input {
            width: 100%;
            background: #000;
            border: 2px solid #0ff;
            color: #0ff;
            font-family: 'Terminal', monospace;
            font-size: 18px;
            padding: 10px;
            margin-top: 20px;
            text-align: center;
            outline: none;
            text-shadow: 0 0 5px #0ff;
            display: none;
        }

        .button {
            background: #000;
            border: 2px solid #0ff;
            color: #0ff;
            padding: 10px 20px;
            font-family: 'Terminal', monospace;
            font-size: 14px;
            cursor: pointer;
            text-shadow: 0 0 5px #0ff;
            transition: all 0.2s;
            margin: 5px;
            pointer-events: auto;
        }

        .button:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 20px #0ff;
        }

        .button.magenta {
            border-color: #f0f;
            color: #f0f;
            text-shadow: 0 0 5px #f0f;
        }

        .button.magenta:hover {
            background: #f0f;
            box-shadow: 0 0 20px #f0f;
        }

        .button.yellow {
            border-color: #ff0;
            color: #ff0;
            text-shadow: 0 0 5px #ff0;
        }

        .button.yellow:hover {
            background: #ff0;
            box-shadow: 0 0 20px #ff0;
        }

        #menu {
            text-align: center;
            max-width: 800px;
            margin: 0 auto;
        }

        #menu h1 {
            font-size: 48px;
            color: #0ff;
            text-shadow: 0 0 20px #0ff;
            margin-bottom: 20px;
            letter-spacing: 8px;
        }

        #menu .subtitle {
            color: #f0f;
            text-shadow: 0 0 10px #f0f;
            font-size: 16px;
            margin-bottom: 40px;
            letter-spacing: 3px;
        }

        .dialog-box {
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #0ff;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 0 20px #0ff;
        }

        .choice {
            background: #000;
            border: 1px solid #0ff;
            color: #0ff;
            padding: 10px;
            margin: 5px 0;
            cursor: pointer;
            transition: all 0.2s;
        }

        .choice:hover {
            background: #0ff;
            color: #000;
            border-color: #0ff;
            transform: translateX(10px);
        }

        #programs-panel {
            position: absolute;
            top: 80px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #0ff;
            padding: 10px;
            max-width: 250px;
            z-index: 90;
            pointer-events: none;
        }

        .program-slot {
            color: #0ff;
            font-size: 11px;
            margin: 3px 0;
            display: flex;
            justify-content: space-between;
        }

        .program-slot.active {
            color: #ff0;
            text-shadow: 0 0 5px #ff0;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 150;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: #0ff;
            box-shadow: 0 0 5px #0ff;
        }

        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
        }

        #crosshair::after {
            width: 20px;
            height: 2px;
            top: 9px;
        }

        .glitch {
            animation: glitch 0.3s infinite;
        }

        @keyframes glitch {
            0% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
            100% { transform: translate(0); }
        }

        #title-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            flex-direction: column;
        }

        #title-screen.hidden {
            display: none;
        }

        .ascii-art {
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
            font-size: 10px;
            line-height: 1.2;
            white-space: pre;
            margin-bottom: 30px;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #000;
        }

        ::-webkit-scrollbar-thumb {
            background: #0ff;
            box-shadow: 0 0 5px #0ff;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="title-screen">
            <pre class="ascii-art">
███╗   ██╗███████╗██╗   ██╗██████╗  ██████╗ ███╗   ███╗ █████╗ ███╗   ██╗ ██████╗███████╗██████╗
████╗  ██║██╔════╝██║   ██║██╔══██╗██╔═══██╗████╗ ████║██╔══██╗████╗  ██║██╔════╝██╔════╝██╔══██╗
██╔██╗ ██║█████╗  ██║   ██║██████╔╝██║   ██║██╔████╔██║███████║██╔██╗ ██║██║     █████╗  ██████╔╝
██║╚██╗██║██╔══╝  ██║   ██║██╔══██╗██║   ██║██║╚██╔╝██║██╔══██║██║╚██╗██║██║     ██╔══╝  ██╔══██╗
██║ ╚████║███████╗╚██████╔╝██║  ██║╚██████╔╝██║ ╚═╝ ██║██║  ██║██║ ╚████║╚██████╗███████╗██║  ██║
╚═╝  ╚═══╝╚══════╝ ╚═════╝ ╚═╝  ╚═╝ ╚═════╝ ╚═╝     ╚═╝╚═╝  ╚═╝╚═╝  ╚═══╝ ╚═════╝╚══════╝╚═╝  ╚═╝
            </pre>
            <p class="terminal-text magenta" style="margin-bottom: 30px; font-size: 14px; letter-spacing: 3px;">CYBERSPACE WIREFRAME DIVER</p>
            <button class="button" onclick="game.startNewGame()">NEW GAME</button>
            <button class="button magenta" onclick="game.loadGame()">LOAD GAME</button>
            <p class="terminal-text" style="margin-top: 30px; font-size: 11px;">WASD: Move | Mouse: Look | 1-6: Programs | E: Breach | ESC: Menu</p>
        </div>

        <div id="cyberspace">
            <canvas id="cyberspace-canvas"></canvas>
            <div id="crosshair"></div>
            <div id="hud">
                <div class="hud-row">
                    <div class="hud-item">DECK: <span id="deck-name">STREET DECK</span></div>
                    <div class="hud-item">CREDITS: <span id="credits">0</span>¥</div>
                    <div class="hud-item">ZONE: <span id="zone-name">THE GRID</span></div>
                </div>
                <div class="hud-row">
                    <div class="hud-bar">
                        <div class="hud-bar-fill" id="health-bar"></div>
                        <div class="hud-bar-text">INTEGRITY <span id="health-text">100/100</span></div>
                    </div>
                    <div class="hud-bar">
                        <div class="hud-bar-fill shield" id="shield-bar"></div>
                        <div class="hud-bar-text" style="color: #f0f;">SHIELD <span id="shield-text">100/100</span></div>
                    </div>
                </div>
            </div>
            <div id="programs-panel">
                <div style="color: #0ff; font-size: 12px; margin-bottom: 5px; border-bottom: 1px solid #0ff; padding-bottom: 3px;">PROGRAMS</div>
                <div id="programs-list"></div>
            </div>
            <div id="message-log"></div>
        </div>

        <div id="sprawl">
            <div id="sprawl-content"></div>
        </div>

        <div id="breach-overlay">
            <div id="breach-container">
                <h2 class="terminal-text cyan" style="margin-bottom: 20px; font-size: 24px;"><span id="breach-title">BREACHING NODE</span></h2>
                <canvas id="breach-canvas" width="600" height="400"></canvas>
                <input type="text" id="breach-input" maxlength="50" />
                <div id="breach-buttons" style="margin-top: 20px;"></div>
            </div>
        </div>
    </div>

    <script>
        // ============================================================================
        // CORE GAME ENGINE
        // ============================================================================

        const game = {
            state: 'title', // title, sprawl, cyberspace, breach
            player: null,
            cyberspace: null,
            sprawl: null,
            save: null,

            init() {
                this.initCanvas();
                this.initControls();
                this.loadFromStorage();
            },

            initCanvas() {
                this.canvas = document.getElementById('cyberspace-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.breachCanvas = document.getElementById('breach-canvas');
                this.breachCtx = this.breachCanvas.getContext('2d');

                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            },

            resizeCanvas() {
                this.canvas.width = this.canvas.offsetWidth;
                this.canvas.height = this.canvas.offsetHeight;
            },

            initControls() {
                this.keys = {};
                this.mouse = { x: 0, y: 0, dx: 0, dy: 0, locked: false };

                document.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    if (e.key === 'Escape') this.handleEscape();
                    if (this.state === 'cyberspace') {
                        if (e.key === 'e') this.attemptBreach();
                        if (e.key >= '1' && e.key <= '6') this.activateProgram(parseInt(e.key) - 1);
                    }
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });

                this.canvas.addEventListener('click', () => {
                    if (this.state === 'cyberspace' && !this.mouse.locked) {
                        this.canvas.requestPointerLock();
                    }
                });

                document.addEventListener('pointerlockchange', () => {
                    this.mouse.locked = document.pointerLockElement === this.canvas;
                });

                document.addEventListener('mousemove', (e) => {
                    if (this.mouse.locked) {
                        this.mouse.dx = e.movementX || 0;
                        this.mouse.dy = e.movementY || 0;
                    }
                });
            },

            startNewGame() {
                document.getElementById('title-screen').classList.add('hidden');
                this.player = new Player();
                this.save = new SaveManager();
                this.sprawl = new Sprawl();
                this.enterSprawl('intro');
            },

            loadGame() {
                const saved = localStorage.getItem('neuromancer_save');
                if (saved) {
                    const data = JSON.parse(saved);
                    document.getElementById('title-screen').classList.add('hidden');
                    this.player = new Player(data.player);
                    this.save = new SaveManager();
                    this.sprawl = new Sprawl();
                    this.sprawl.currentLocation = data.location || 'apartment';
                    this.sprawl.story = data.story || { mission: 0, reputation: 0 };
                    this.enterSprawl(this.sprawl.currentLocation);
                    this.addMessage('SYSTEM RESTORED', 'cyan');
                } else {
                    this.addMessage('NO SAVE DATA FOUND', 'danger');
                }
            },

            enterCyberspace(zoneLevel = 1) {
                this.state = 'cyberspace';
                document.getElementById('sprawl').classList.remove('active');
                document.getElementById('cyberspace').classList.add('active');

                this.cyberspace = new Cyberspace(zoneLevel);
                this.updateHUD();
                this.gameLoop();
            },

            enterSprawl(location) {
                this.state = 'sprawl';
                document.getElementById('cyberspace').classList.remove('active');
                document.getElementById('sprawl').classList.add('active');

                if (this.cyberspace) {
                    this.cyberspace.cleanup();
                    this.cyberspace = null;
                }

                this.sprawl.showLocation(location);
                this.autoSave();
            },

            attemptBreach() {
                if (!this.cyberspace) return;
                const target = this.cyberspace.getTargetNode();
                if (target && target.distance < 50) {
                    this.startBreach(target);
                } else {
                    this.addMessage('NO NODE IN RANGE', 'warning');
                }
            },

            startBreach(node) {
                this.state = 'breach';
                document.getElementById('breach-overlay').classList.add('active');

                const breach = new BreachMinigame(node, (success) => {
                    this.endBreach(success, node);
                });
                breach.start();
            },

            endBreach(success, node) {
                document.getElementById('breach-overlay').classList.remove('active');
                this.state = 'cyberspace';

                if (success) {
                    const reward = node.getReward();
                    this.player.credits += reward.credits;
                    if (reward.program) {
                        this.player.addProgram(reward.program);
                        this.addMessage(`ACQUIRED: ${reward.program.name}`, 'cyan');
                    }
                    this.addMessage(`BREACH SUCCESS +${reward.credits}¥`, 'cyan');
                    this.cyberspace.removeNode(node);
                } else {
                    this.addMessage('BREACH FAILED - ICE ALERTED', 'danger');
                    this.cyberspace.spawnICE(node.x, node.y, node.z, node.security);
                }

                this.updateHUD();
            },

            activateProgram(index) {
                if (!this.player.programs[index]) return;
                const program = this.player.programs[index];

                if (program.charges <= 0) {
                    this.addMessage(`${program.name} - NO CHARGES`, 'warning');
                    return;
                }

                program.charges--;
                program.activate(this.cyberspace, this.player);
                this.addMessage(`RUNNING: ${program.name}`, 'cyan');
                this.updateHUD();
            },

            handleEscape() {
                if (this.state === 'cyberspace') {
                    this.enterSprawl(this.sprawl.currentLocation);
                }
            },

            gameLoop() {
                if (this.state !== 'cyberspace') return;

                this.cyberspace.update(this.keys, this.mouse);
                this.cyberspace.render(this.ctx);

                this.mouse.dx = 0;
                this.mouse.dy = 0;

                requestAnimationFrame(() => this.gameLoop());
            },

            updateHUD() {
                document.getElementById('deck-name').textContent = this.player.deck.name;
                document.getElementById('credits').textContent = this.player.credits;
                document.getElementById('zone-name').textContent = this.cyberspace ? this.cyberspace.zone.name : 'THE SPRAWL';

                const healthPct = (this.player.health / this.player.maxHealth) * 100;
                const shieldPct = (this.player.shield / this.player.maxShield) * 100;

                document.getElementById('health-bar').style.width = healthPct + '%';
                document.getElementById('shield-bar').style.width = shieldPct + '%';
                document.getElementById('health-text').textContent = `${Math.ceil(this.player.health)}/${this.player.maxHealth}`;
                document.getElementById('shield-text').textContent = `${Math.ceil(this.player.shield)}/${this.player.maxShield}`;

                this.updateProgramsPanel();
            },

            updateProgramsPanel() {
                const container = document.getElementById('programs-list');
                container.innerHTML = '';

                this.player.programs.forEach((prog, i) => {
                    const div = document.createElement('div');
                    div.className = 'program-slot';
                    div.innerHTML = `<span>${i + 1}. ${prog.name}</span><span>${prog.charges}/${prog.maxCharges}</span>`;
                    container.appendChild(div);
                });
            },

            addMessage(text, type = 'normal') {
                const log = document.getElementById('message-log');
                const msg = document.createElement('div');
                msg.className = 'message';
                if (type === 'warning') msg.classList.add('warning');
                if (type === 'danger') msg.classList.add('danger');
                msg.textContent = text;
                log.appendChild(msg);

                if (log.children.length > 10) {
                    log.removeChild(log.children[0]);
                }

                log.scrollTop = log.scrollHeight;
            },

            autoSave() {
                if (!this.player || !this.save) return;
                this.save.save(this.player, this.sprawl);
            }
        };

        // ============================================================================
        // PLAYER
        // ============================================================================

        class Player {
            constructor(data = null) {
                if (data) {
                    Object.assign(this, data);
                    this.programs = data.programs.map(p => Program.fromData(p));
                } else {
                    this.health = 100;
                    this.maxHealth = 100;
                    this.shield = 100;
                    this.maxShield = 100;
                    this.credits = 500;
                    this.deck = { name: 'STREET DECK', processing: 1, ram: 3, shield: 1, stealth: 1 };
                    this.programs = [
                        new Program('ICEBREAKER', 'attack', 10),
                        new Program('PROBE', 'scan', 5),
                    ];
                    this.implants = [];
                    this.reputation = 0;
                }
            }

            addProgram(program) {
                const existing = this.programs.find(p => p.name === program.name);
                if (existing) {
                    existing.charges = Math.min(existing.charges + 5, existing.maxCharges);
                } else if (this.programs.length < this.deck.ram) {
                    this.programs.push(program);
                }
            }

            takeDamage(amount) {
                if (this.shield > 0) {
                    this.shield -= amount;
                    if (this.shield < 0) {
                        this.health += this.shield;
                        this.shield = 0;
                    }
                } else {
                    this.health -= amount;
                }

                if (this.health <= 0) {
                    this.health = 0;
                    this.flatline();
                }

                game.updateHUD();
            }

            heal(amount) {
                this.health = Math.min(this.health + amount, this.maxHealth);
                game.updateHUD();
            }

            rechargeShield(amount) {
                this.shield = Math.min(this.shield + amount, this.maxShield);
                game.updateHUD();
            }

            flatline() {
                game.addMessage('FLATLINED - JACKING OUT', 'danger');
                setTimeout(() => {
                    game.enterSprawl('clinic');
                    this.health = this.maxHealth * 0.5;
                    this.shield = 0;
                    this.credits = Math.floor(this.credits * 0.7);
                    game.updateHUD();
                }, 2000);
            }
        }

        // ============================================================================
        // PROGRAMS
        // ============================================================================

        class Program {
            constructor(name, type, maxCharges) {
                this.name = name;
                this.type = type;
                this.charges = maxCharges;
                this.maxCharges = maxCharges;
            }

            activate(cyberspace, player) {
                switch (this.type) {
                    case 'attack':
                        cyberspace.attackNearestICE(30);
                        break;
                    case 'scan':
                        cyberspace.revealNodes();
                        game.addMessage('SCANNING NODES...', 'cyan');
                        break;
                    case 'slow':
                        cyberspace.slowICE();
                        game.addMessage('ICE MOVEMENT REDUCED', 'cyan');
                        break;
                    case 'ghost':
                        player.ghostMode = true;
                        setTimeout(() => { player.ghostMode = false; }, 5000);
                        game.addMessage('GHOST MODE: 5 SECONDS', 'cyan');
                        break;
                    case 'virus':
                        cyberspace.corruptICE();
                        break;
                }
            }

            static fromData(data) {
                const prog = new Program(data.name, data.type, data.maxCharges);
                prog.charges = data.charges;
                return prog;
            }
        }

        // ============================================================================
        // CYBERSPACE 3D ENGINE
        // ============================================================================

        class Cyberspace {
            constructor(zoneLevel) {
                this.zone = this.getZone(zoneLevel);
                this.camera = {
                    x: 0, y: 50, z: -200,
                    rotX: 0, rotY: 0,
                    speed: 2,
                    fov: 400
                };

                this.nodes = [];
                this.ice = [];
                this.particles = [];
                this.projectiles = [];

                this.generateCyberspace();

                game.addMessage(`ENTERING: ${this.zone.name}`, 'cyan');
            }

            getZone(level) {
                const zones = [
                    { name: 'THE GRID', security: 1, color: '#0ff', nodeCount: 8 },
                    { name: 'CORPORATE SECTOR', security: 3, color: '#0f0', nodeCount: 12 },
                    { name: 'MILITARY ZONE', security: 5, color: '#ff0', nodeCount: 10 },
                    { name: 'AI WILDERNESS', security: 7, color: '#f0f', nodeCount: 15 },
                    { name: 'THE CORE', security: 10, color: '#f00', nodeCount: 20 }
                ];
                return zones[Math.min(level - 1, zones.length - 1)];
            }

            generateCyberspace() {
                // Generate grid floor
                this.grid = [];
                for (let x = -500; x <= 500; x += 50) {
                    for (let z = -500; z <= 500; z += 50) {
                        this.grid.push({ x, y: 0, z });
                    }
                }

                // Generate data nodes
                for (let i = 0; i < this.zone.nodeCount; i++) {
                    const angle = (i / this.zone.nodeCount) * Math.PI * 2;
                    const radius = 150 + Math.random() * 150;
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;
                    const y = 20 + Math.random() * 40;

                    this.nodes.push(new DataNode(x, y, z, this.zone.security));
                }

                // Spawn initial ICE
                const iceCount = Math.floor(this.zone.security / 2);
                for (let i = 0; i < iceCount; i++) {
                    const node = this.nodes[Math.floor(Math.random() * this.nodes.length)];
                    this.spawnICE(node.x + (Math.random() - 0.5) * 100, node.y, node.z + (Math.random() - 0.5) * 100, this.zone.security);
                }
            }

            update(keys, mouse) {
                // Camera rotation
                this.camera.rotY += mouse.dx * 0.003;
                this.camera.rotX += mouse.dy * 0.003;
                this.camera.rotX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.camera.rotX));

                // Camera movement
                const speed = this.camera.speed * (keys['shift'] ? 2 : 1);
                const forward = { x: Math.sin(this.camera.rotY), z: Math.cos(this.camera.rotY) };
                const right = { x: Math.cos(this.camera.rotY), z: -Math.sin(this.camera.rotY) };

                if (keys['w']) {
                    this.camera.x += forward.x * speed;
                    this.camera.z += forward.z * speed;
                }
                if (keys['s']) {
                    this.camera.x -= forward.x * speed;
                    this.camera.z -= forward.z * speed;
                }
                if (keys['a']) {
                    this.camera.x -= right.x * speed;
                    this.camera.z -= right.z * speed;
                }
                if (keys['d']) {
                    this.camera.x += right.x * speed;
                    this.camera.z += right.z * speed;
                }
                if (keys[' ']) this.camera.y += speed;
                if (keys['control']) this.camera.y -= speed;

                // Update entities
                this.nodes.forEach(node => node.update());
                this.ice.forEach(entity => {
                    entity.update(this.camera, game.player);
                    if (entity.shouldShoot()) {
                        this.projectiles.push(new Projectile(entity.x, entity.y, entity.z, this.camera, entity.color));
                    }
                });

                this.projectiles = this.projectiles.filter(proj => {
                    proj.update();
                    const dist = Math.sqrt(
                        Math.pow(proj.x - this.camera.x, 2) +
                        Math.pow(proj.y - this.camera.y, 2) +
                        Math.pow(proj.z - this.camera.z, 2)
                    );

                    if (dist < 10) {
                        game.player.takeDamage(5);
                        game.addMessage('HIT BY ICE', 'danger');
                        return false;
                    }

                    return proj.life > 0;
                });

                // Add trail particles
                if (Math.random() < 0.3) {
                    this.particles.push({
                        x: this.camera.x + (Math.random() - 0.5) * 5,
                        y: this.camera.y + (Math.random() - 0.5) * 5,
                        z: this.camera.z + (Math.random() - 0.5) * 5,
                        life: 30,
                        color: '#0ff'
                    });
                }

                this.particles = this.particles.filter(p => {
                    p.life--;
                    return p.life > 0;
                });
            }

            render(ctx) {
                const w = ctx.canvas.width;
                const h = ctx.canvas.height;

                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, w, h);

                // Render grid
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.2)';
                ctx.lineWidth = 1;
                this.grid.forEach(point => {
                    const p = this.project(point, w, h);
                    if (p && p.z > 0 && p.z < 1000) {
                        const alpha = 1 - (p.z / 1000);
                        ctx.globalAlpha = alpha * 0.2;
                        ctx.fillStyle = '#0ff';
                        ctx.fillRect(p.x, p.y, 2, 2);
                    }
                });
                ctx.globalAlpha = 1;

                // Render nodes
                this.nodes.forEach(node => node.render(ctx, this, w, h));

                // Render ICE
                this.ice.forEach(entity => entity.render(ctx, this, w, h));

                // Render projectiles
                this.projectiles.forEach(proj => proj.render(ctx, this, w, h));

                // Render particles
                ctx.shadowBlur = 10;
                this.particles.forEach(p => {
                    const point = this.project(p, w, h);
                    if (point && point.z > 0) {
                        const alpha = p.life / 30;
                        ctx.globalAlpha = alpha;
                        ctx.fillStyle = p.color;
                        ctx.shadowColor = p.color;
                        ctx.fillRect(point.x, point.y, 3, 3);
                    }
                });
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
            }

            project(point, w, h) {
                const dx = point.x - this.camera.x;
                const dy = point.y - this.camera.y;
                const dz = point.z - this.camera.z;

                // Rotate around Y (yaw)
                const cosY = Math.cos(this.camera.rotY);
                const sinY = Math.sin(this.camera.rotY);
                const x1 = dx * cosY - dz * sinY;
                const z1 = dx * sinY + dz * cosY;

                // Rotate around X (pitch)
                const cosX = Math.cos(this.camera.rotX);
                const sinX = Math.sin(this.camera.rotX);
                const y1 = dy * cosX - z1 * sinX;
                const z2 = dy * sinX + z1 * cosX;

                if (z2 <= 0) return null;

                const scale = this.camera.fov / z2;
                const x2d = w / 2 + x1 * scale;
                const y2d = h / 2 - y1 * scale;

                return { x: x2d, y: y2d, z: z2, scale };
            }

            getTargetNode() {
                let closest = null;
                let minDist = Infinity;

                this.nodes.forEach(node => {
                    const dist = Math.sqrt(
                        Math.pow(node.x - this.camera.x, 2) +
                        Math.pow(node.y - this.camera.y, 2) +
                        Math.pow(node.z - this.camera.z, 2)
                    );

                    if (dist < minDist) {
                        minDist = dist;
                        closest = node;
                    }
                });

                if (closest) closest.distance = minDist;
                return closest;
            }

            removeNode(node) {
                const index = this.nodes.indexOf(node);
                if (index > -1) this.nodes.splice(index, 1);
            }

            spawnICE(x, y, z, level) {
                const types = ['white', 'gray', 'black'];
                const type = types[Math.min(Math.floor(level / 3), 2)];
                this.ice.push(new ICE(x, y, z, type, level));
                game.addMessage(`${type.toUpperCase()} ICE DETECTED`, 'danger');
            }

            attackNearestICE(damage) {
                if (this.ice.length === 0) return;

                let nearest = this.ice[0];
                let minDist = this.distToCamera(nearest);

                this.ice.forEach(entity => {
                    const dist = this.distToCamera(entity);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = entity;
                    }
                });

                nearest.health -= damage;
                if (nearest.health <= 0) {
                    this.ice = this.ice.filter(e => e !== nearest);
                    game.addMessage('ICE DESTROYED', 'cyan');
                    game.player.credits += nearest.level * 10;
                }
            }

            distToCamera(entity) {
                return Math.sqrt(
                    Math.pow(entity.x - this.camera.x, 2) +
                    Math.pow(entity.y - this.camera.y, 2) +
                    Math.pow(entity.z - this.camera.z, 2)
                );
            }

            revealNodes() {
                this.nodes.forEach(node => node.revealed = true);
            }

            slowICE() {
                this.ice.forEach(entity => entity.speed *= 0.5);
            }

            corruptICE() {
                this.ice.forEach(entity => {
                    entity.health -= 20;
                    if (entity.health <= 0) {
                        this.ice = this.ice.filter(e => e !== entity);
                    }
                });
            }

            cleanup() {
                this.nodes = [];
                this.ice = [];
                this.particles = [];
                this.projectiles = [];
            }
        }

        // ============================================================================
        // DATA NODE
        // ============================================================================

        class DataNode {
            constructor(x, y, z, security) {
                this.x = x;
                this.y = y;
                this.z = z;
                this.security = Math.max(1, Math.floor(security + (Math.random() - 0.5) * 3));
                this.size = 15 + this.security * 2;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotSpeed = (Math.random() - 0.5) * 0.02;
                this.revealed = false;
                this.type = ['cube', 'pyramid', 'sphere', 'diamond'][Math.floor(Math.random() * 4)];
                this.color = ['#0ff', '#0f0', '#ff0', '#f0f'][Math.floor(this.security / 3)];
            }

            update() {
                this.rotation += this.rotSpeed;
            }

            render(ctx, cyberspace, w, h) {
                const vertices = this.getVertices();
                const projected = vertices.map(v => cyberspace.project({
                    x: this.x + v.x,
                    y: this.y + v.y,
                    z: this.z + v.z
                }, w, h)).filter(p => p && p.z > 0);

                if (projected.length === 0) return;

                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;

                const edges = this.getEdges();
                edges.forEach(edge => {
                    const p1 = projected[edge[0]];
                    const p2 = projected[edge[1]];
                    if (p1 && p2) {
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                    }
                });

                ctx.shadowBlur = 0;

                // Label
                if (projected[0]) {
                    ctx.fillStyle = this.color;
                    ctx.font = '10px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(`SEC ${this.security}`, projected[0].x, projected[0].y - 20);
                }
            }

            getVertices() {
                const s = this.size;
                const r = this.rotation;
                const cos = Math.cos(r);
                const sin = Math.sin(r);

                const rotate = (x, y, z) => ({
                    x: x * cos - z * sin,
                    y: y,
                    z: x * sin + z * cos
                });

                switch (this.type) {
                    case 'cube':
                        return [
                            rotate(-s, -s, -s), rotate(s, -s, -s), rotate(s, s, -s), rotate(-s, s, -s),
                            rotate(-s, -s, s), rotate(s, -s, s), rotate(s, s, s), rotate(-s, s, s)
                        ];
                    case 'pyramid':
                        return [
                            rotate(-s, 0, -s), rotate(s, 0, -s), rotate(s, 0, s), rotate(-s, 0, s),
                            rotate(0, -s * 1.5, 0)
                        ];
                    case 'diamond':
                        return [
                            rotate(0, s, 0), rotate(0, -s, 0),
                            rotate(-s, 0, 0), rotate(s, 0, 0),
                            rotate(0, 0, -s), rotate(0, 0, s)
                        ];
                    default:
                        return [
                            rotate(-s, -s, -s), rotate(s, -s, -s), rotate(s, s, -s), rotate(-s, s, -s),
                            rotate(-s, -s, s), rotate(s, -s, s), rotate(s, s, s), rotate(-s, s, s)
                        ];
                }
            }

            getEdges() {
                switch (this.type) {
                    case 'cube':
                        return [
                            [0, 1], [1, 2], [2, 3], [3, 0],
                            [4, 5], [5, 6], [6, 7], [7, 4],
                            [0, 4], [1, 5], [2, 6], [3, 7]
                        ];
                    case 'pyramid':
                        return [[0, 1], [1, 2], [2, 3], [3, 0], [0, 4], [1, 4], [2, 4], [3, 4]];
                    case 'diamond':
                        return [[0, 2], [0, 3], [0, 4], [0, 5], [1, 2], [1, 3], [1, 4], [1, 5]];
                    default:
                        return [[0, 1], [1, 2], [2, 3], [3, 0]];
                }
            }

            getReward() {
                const credits = this.security * 50 + Math.floor(Math.random() * 100);
                const program = Math.random() < 0.3 ? this.generateProgram() : null;
                return { credits, program };
            }

            generateProgram() {
                const programs = [
                    { name: 'SLOW', type: 'slow', charges: 3 },
                    { name: 'GHOST', type: 'ghost', charges: 2 },
                    { name: 'VIRUS', type: 'virus', charges: 4 },
                    { name: 'ICEBREAKER-X', type: 'attack', charges: 15 }
                ];
                const data = programs[Math.floor(Math.random() * programs.length)];
                return new Program(data.name, data.type, data.charges);
            }
        }

        // ============================================================================
        // ICE
        // ============================================================================

        class ICE {
            constructor(x, y, z, type, level) {
                this.x = x;
                this.y = y;
                this.z = z;
                this.type = type;
                this.level = level;
                this.health = level * 20;
                this.maxHealth = this.health;
                this.speed = 0.5 + level * 0.1;
                this.size = 10 + level;
                this.rotation = 0;
                this.shootTimer = 0;
                this.color = type === 'white' ? '#fff' : type === 'gray' ? '#888' : '#f00';
            }

            update(camera, player) {
                // Move toward player
                if (!player.ghostMode) {
                    const dx = camera.x - this.x;
                    const dy = camera.y - this.y;
                    const dz = camera.z - this.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

                    if (dist > 0) {
                        this.x += (dx / dist) * this.speed;
                        this.y += (dy / dist) * this.speed;
                        this.z += (dz / dist) * this.speed;
                    }

                    // Collision damage
                    if (dist < 20) {
                        player.takeDamage(this.type === 'black' ? 15 : this.type === 'gray' ? 10 : 5);
                    }
                }

                this.rotation += 0.05;
                this.shootTimer++;
            }

            shouldShoot() {
                const threshold = this.type === 'black' ? 60 : this.type === 'gray' ? 90 : 120;
                if (this.shootTimer > threshold) {
                    this.shootTimer = 0;
                    return true;
                }
                return false;
            }

            render(ctx, cyberspace, w, h) {
                const s = this.size;
                const r = this.rotation;
                const cos = Math.cos(r);
                const sin = Math.sin(r);

                const vertices = [
                    { x: this.x - s * cos, y: this.y - s, z: this.z - s * sin },
                    { x: this.x + s * cos, y: this.y - s, z: this.z + s * sin },
                    { x: this.x + s * cos, y: this.y + s, z: this.z - s * sin },
                    { x: this.x - s * cos, y: this.y + s, z: this.z + s * sin }
                ];

                const projected = vertices.map(v => cyberspace.project(v, w, h)).filter(p => p && p.z > 0);

                if (projected.length < 2) return;

                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.shadowBlur = 20;
                ctx.shadowColor = this.color;

                ctx.beginPath();
                projected.forEach((p, i) => {
                    if (i === 0) ctx.moveTo(p.x, p.y);
                    else ctx.lineTo(p.x, p.y);
                });
                ctx.closePath();
                ctx.stroke();

                ctx.shadowBlur = 0;

                // Health bar
                if (projected[0]) {
                    const healthPct = this.health / this.maxHealth;
                    ctx.fillStyle = this.color;
                    ctx.fillRect(projected[0].x - 20, projected[0].y - 30, 40 * healthPct, 3);
                }
            }
        }

        // ============================================================================
        // PROJECTILE
        // ============================================================================

        class Projectile {
            constructor(x, y, z, target, color) {
                this.x = x;
                this.y = y;
                this.z = z;
                this.color = color;
                this.life = 100;

                const dx = target.x - x;
                const dy = target.y - y;
                const dz = target.z - z;
                const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

                this.vx = (dx / dist) * 3;
                this.vy = (dy / dist) * 3;
                this.vz = (dz / dist) * 3;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.z += this.vz;
                this.life--;
            }

            render(ctx, cyberspace, w, h) {
                const p = cyberspace.project(this, w, h);
                if (p && p.z > 0) {
                    ctx.fillStyle = this.color;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = this.color;
                    ctx.fillRect(p.x - 3, p.y - 3, 6, 6);
                    ctx.shadowBlur = 0;
                }
            }
        }

        // ============================================================================
        // BREACH MINIGAMES
        // ============================================================================

        class BreachMinigame {
            constructor(node, callback) {
                this.node = node;
                this.callback = callback;
                this.canvas = document.getElementById('breach-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.type = ['pattern', 'trace', 'code', 'firewall'][Math.floor(Math.random() * 4)];
                this.timer = 10 + node.security * 2;
                this.maxTimer = this.timer;
            }

            start() {
                document.getElementById('breach-title').textContent = `BREACHING: SEC ${this.node.security}`;

                switch (this.type) {
                    case 'pattern':
                        this.startPattern();
                        break;
                    case 'trace':
                        this.startTrace();
                        break;
                    case 'code':
                        this.startCode();
                        break;
                    case 'firewall':
                        this.startFirewall();
                        break;
                }
            }

            startPattern() {
                this.targetAngle = Math.random() * Math.PI * 2;
                this.currentAngle = 0;
                this.rotSpeed = 0.05;

                document.getElementById('breach-buttons').innerHTML = `
                    <button class="button" onclick="breachGame.rotateLeft()">← ROTATE LEFT (A)</button>
                    <button class="button" onclick="breachGame.rotateRight()">ROTATE RIGHT (D) →</button>
                    <button class="button yellow" onclick="breachGame.checkPattern()">SUBMIT (ENTER)</button>
                `;

                this.setupPatternControls();
                this.animatePattern();
            }

            setupPatternControls() {
                this.patternHandler = (e) => {
                    if (e.key === 'a') this.rotateLeft();
                    if (e.key === 'd') this.rotateRight();
                    if (e.key === 'Enter') this.checkPattern();
                };
                document.addEventListener('keydown', this.patternHandler);
            }

            rotateLeft() {
                this.currentAngle -= this.rotSpeed * 5;
            }

            rotateRight() {
                this.currentAngle += this.rotSpeed * 5;
            }

            checkPattern() {
                document.removeEventListener('keydown', this.patternHandler);
                const diff = Math.abs(this.currentAngle - this.targetAngle);
                const normalized = diff % (Math.PI * 2);
                const success = normalized < 0.3 || normalized > Math.PI * 2 - 0.3;
                this.callback(success);
            }

            animatePattern() {
                if (!document.getElementById('breach-overlay').classList.contains('active')) return;

                const ctx = this.ctx;
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, 600, 400);

                const cx = 300;
                const cy = 200;
                const r = 80;

                // Target
                ctx.strokeStyle = '#0f0';
                ctx.lineWidth = 3;
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#0f0';
                ctx.beginPath();
                ctx.arc(cx, cy, r, this.targetAngle - 0.3, this.targetAngle + 0.3);
                ctx.stroke();

                // Current
                ctx.strokeStyle = '#0ff';
                ctx.shadowColor = '#0ff';
                ctx.beginPath();
                ctx.arc(cx, cy, r, this.currentAngle - 0.2, this.currentAngle + 0.2);
                ctx.stroke();

                ctx.shadowBlur = 0;

                // Timer
                this.timer -= 0.016;
                ctx.fillStyle = '#ff0';
                ctx.font = '20px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(`TIME: ${Math.ceil(this.timer)}s`, cx, 50);

                if (this.timer <= 0) {
                    document.removeEventListener('keydown', this.patternHandler);
                    this.callback(false);
                    return;
                }

                requestAnimationFrame(() => this.animatePattern());
            }

            startTrace() {
                this.path = this.generatePath();
                this.pathIndex = 0;
                this.failed = false;

                document.getElementById('breach-buttons').innerHTML = `
                    <p class="terminal-text cyan">Click the path in sequence!</p>
                `;

                this.canvas.onclick = (e) => this.handleTraceClick(e);
                this.animateTrace();
            }

            generatePath() {
                const path = [];
                const gridSize = 6;
                const cellSize = 80;
                const offsetX = 60;
                const offsetY = 40;

                let x = 0, y = 0;
                path.push({ x, y });

                for (let i = 0; i < 8; i++) {
                    const dir = Math.floor(Math.random() * 4);
                    switch (dir) {
                        case 0: y = Math.max(0, y - 1); break;
                        case 1: x = Math.min(gridSize - 1, x + 1); break;
                        case 2: y = Math.min(gridSize - 1, y + 1); break;
                        case 3: x = Math.max(0, x - 1); break;
                    }
                    path.push({ x, y });
                }

                return path.map(p => ({
                    x: p.x * cellSize + offsetX,
                    y: p.y * cellSize + offsetY,
                    gx: p.x,
                    gy: p.y
                }));
            }

            handleTraceClick(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const target = this.path[this.pathIndex];
                const dist = Math.sqrt(Math.pow(x - target.x, 2) + Math.pow(y - target.y, 2));

                if (dist < 30) {
                    this.pathIndex++;
                    if (this.pathIndex >= this.path.length) {
                        this.canvas.onclick = null;
                        this.callback(true);
                    }
                } else {
                    this.failed = true;
                    this.canvas.onclick = null;
                    this.callback(false);
                }
            }

            animateTrace() {
                if (!document.getElementById('breach-overlay').classList.contains('active')) return;

                const ctx = this.ctx;
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, 600, 400);

                // Draw grid
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.2)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 6; i++) {
                    for (let j = 0; j < 6; j++) {
                        ctx.strokeRect(i * 80 + 60, j * 80 + 40, 80, 80);
                    }
                }

                // Draw path
                ctx.strokeStyle = '#0ff';
                ctx.lineWidth = 2;
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#0ff';
                ctx.beginPath();
                this.path.forEach((p, i) => {
                    if (i === 0) ctx.moveTo(p.x, p.y);
                    else if (i <= this.pathIndex) ctx.lineTo(p.x, p.y);
                });
                ctx.stroke();

                // Draw nodes
                this.path.forEach((p, i) => {
                    ctx.fillStyle = i < this.pathIndex ? '#0f0' : i === this.pathIndex ? '#ff0' : '#0ff';
                    ctx.shadowColor = ctx.fillStyle;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 8, 0, Math.PI * 2);
                    ctx.fill();
                });

                ctx.shadowBlur = 0;

                // Timer
                this.timer -= 0.016;
                ctx.fillStyle = '#ff0';
                ctx.font = '16px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(`TIME: ${Math.ceil(this.timer)}s`, 300, 20);

                if (this.timer <= 0 && !this.failed) {
                    this.canvas.onclick = null;
                    this.callback(false);
                    return;
                }

                if (!this.failed && this.pathIndex < this.path.length) {
                    requestAnimationFrame(() => this.animateTrace());
                }
            }

            startCode() {
                this.codeSequence = this.generateCode();
                this.codeInput = '';
                this.codeFalling = [];

                const input = document.getElementById('breach-input');
                input.style.display = 'block';
                input.value = '';
                input.focus();

                document.getElementById('breach-buttons').innerHTML = `
                    <p class="terminal-text cyan">Type the falling code sequences!</p>
                `;

                this.codeHandler = (e) => {
                    if (e.key === 'Escape') {
                        this.callback(false);
                    }
                };
                document.addEventListener('keydown', this.codeHandler);

                input.oninput = () => {
                    if (input.value === this.codeSequence) {
                        document.removeEventListener('keydown', this.codeHandler);
                        input.style.display = 'none';
                        this.callback(true);
                    }
                };

                this.animateCode();
            }

            generateCode() {
                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
                let code = '';
                const length = 8 + this.node.security;
                for (let i = 0; i < length; i++) {
                    code += chars[Math.floor(Math.random() * chars.length)];
                }
                return code;
            }

            animateCode() {
                if (!document.getElementById('breach-overlay').classList.contains('active')) return;

                const ctx = this.ctx;
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, 600, 400);

                // Spawn new code
                if (Math.random() < 0.1) {
                    this.codeFalling.push({
                        char: this.codeSequence[Math.floor(Math.random() * this.codeSequence.length)],
                        x: Math.random() * 600,
                        y: 0,
                        speed: 2 + Math.random() * 3
                    });
                }

                // Update and draw falling code
                ctx.font = '20px monospace';
                ctx.shadowBlur = 10;
                this.codeFalling = this.codeFalling.filter(c => {
                    c.y += c.speed;
                    ctx.fillStyle = '#0ff';
                    ctx.shadowColor = '#0ff';
                    ctx.fillText(c.char, c.x, c.y);
                    return c.y < 400;
                });

                // Draw target
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ff0';
                ctx.font = '24px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(this.codeSequence, 300, 350);

                // Timer
                this.timer -= 0.016;
                ctx.fillStyle = '#ff0';
                ctx.font = '16px monospace';
                ctx.fillText(`TIME: ${Math.ceil(this.timer)}s`, 300, 20);

                if (this.timer <= 0) {
                    document.removeEventListener('keydown', this.codeHandler);
                    document.getElementById('breach-input').style.display = 'none';
                    this.callback(false);
                    return;
                }

                requestAnimationFrame(() => this.animateCode());
            }

            startFirewall() {
                this.firewallAngle = 0;
                this.gaps = [];
                for (let i = 0; i < 3; i++) {
                    this.gaps.push({
                        angle: Math.random() * Math.PI * 2,
                        size: 0.5
                    });
                }
                this.firewallSpeed = 0.02 + this.node.security * 0.005;
                this.clicks = 0;

                document.getElementById('breach-buttons').innerHTML = `
                    <p class="terminal-text cyan">Click when the line passes through the gap!</p>
                `;

                this.canvas.onclick = () => this.handleFirewallClick();
                this.animateFirewall();
            }

            handleFirewallClick() {
                const line = this.firewallAngle % (Math.PI * 2);
                let hit = false;

                this.gaps.forEach(gap => {
                    const diff = Math.abs(line - gap.angle);
                    if (diff < gap.size || diff > Math.PI * 2 - gap.size) {
                        hit = true;
                    }
                });

                if (hit) {
                    this.clicks++;
                    if (this.clicks >= 3) {
                        this.canvas.onclick = null;
                        this.callback(true);
                    }
                } else {
                    this.canvas.onclick = null;
                    this.callback(false);
                }
            }

            animateFirewall() {
                if (!document.getElementById('breach-overlay').classList.contains('active')) return;

                const ctx = this.ctx;
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, 600, 400);

                const cx = 300;
                const cy = 200;
                const r = 100;

                // Draw firewall rings
                ctx.strokeStyle = '#f00';
                ctx.lineWidth = 3;
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#f00';

                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    this.gaps.forEach((gap, j) => {
                        if (j < this.clicks) return;
                        const start = gap.angle - gap.size;
                        const end = gap.angle + gap.size;
                        ctx.arc(cx, cy, r - i * 15, 0, start);
                        ctx.moveTo(cx + Math.cos(end) * (r - i * 15), cy + Math.sin(end) * (r - i * 15));
                        ctx.arc(cx, cy, r - i * 15, end, Math.PI * 2);
                    });
                    ctx.stroke();
                }

                // Draw scanning line
                ctx.strokeStyle = '#0ff';
                ctx.shadowColor = '#0ff';
                ctx.beginPath();
                ctx.moveTo(cx, cy);
                const lx = cx + Math.cos(this.firewallAngle) * r;
                const ly = cy + Math.sin(this.firewallAngle) * r;
                ctx.lineTo(lx, ly);
                ctx.stroke();

                ctx.shadowBlur = 0;

                // Timer
                this.timer -= 0.016;
                ctx.fillStyle = '#ff0';
                ctx.font = '16px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(`TIME: ${Math.ceil(this.timer)}s | HITS: ${this.clicks}/3`, 300, 30);

                this.firewallAngle += this.firewallSpeed;

                if (this.timer <= 0) {
                    this.canvas.onclick = null;
                    this.callback(false);
                    return;
                }

                if (this.clicks < 3) {
                    requestAnimationFrame(() => this.animateFirewall());
                }
            }
        }

        let breachGame = null;

        // ============================================================================
        // SPRAWL (HUB WORLD)
        // ============================================================================

        class Sprawl {
            constructor() {
                this.currentLocation = 'apartment';
                this.story = {
                    mission: 0,
                    reputation: 0,
                    flags: {}
                };
                this.locations = this.initLocations();
            }

            initLocations() {
                return {
                    intro: {
                        name: 'SYSTEM BOOT',
                        text: `
                            <h2 class="terminal-text cyan">WELCOME TO THE SPRAWL</h2>
                            <p class="terminal-text">You're a console cowboy. A hacker. The best there is.</p>
                            <p class="terminal-text">Your cyberdeck is your life. Cyberspace is your playground.</p>
                            <p class="terminal-text">Data is currency. ICE is death.</p>
                            <p class="terminal-text magenta">Your apartment awaits...</p>
                        `,
                        choices: [
                            { text: 'JACK IN', action: () => this.showLocation('apartment') }
                        ]
                    },
                    apartment: {
                        name: 'YOUR APARTMENT',
                        text: () => `
                            <h2 class="terminal-text cyan">YOUR APARTMENT</h2>
                            <p class="terminal-text">A cramped coffin hotel. Your deck sits on a milk crate. Neon bleeds through the window.</p>
                            <p class="terminal-text yellow">Credits: ${game.player.credits}¥</p>
                            <p class="terminal-text">Health: ${Math.ceil(game.player.health)}/${game.player.maxHealth}</p>
                            <p class="terminal-text">Shield: ${Math.ceil(game.player.shield)}/${game.player.maxShield}</p>
                        `,
                        choices: [
                            { text: 'JACK INTO CYBERSPACE', action: () => game.enterCyberspace(1) },
                            { text: 'GO TO THE BAR', action: () => this.showLocation('bar') },
                            { text: 'VISIT BLACK MARKET', action: () => this.showLocation('market') },
                            { text: 'SAVE GAME', action: () => { game.autoSave(); game.addMessage('GAME SAVED', 'cyan'); } }
                        ]
                    },
                    bar: {
                        name: 'THE CHATSUBO',
                        text: () => `
                            <h2 class="terminal-text cyan">THE CHATSUBO</h2>
                            <p class="terminal-text">Smoke and bass. Fixers in the corners. Data runners at the bar.</p>
                            <p class="terminal-text">A woman in mirrorshades waves you over...</p>
                            <p class="terminal-text magenta">"Got a job. Simple extraction. Corporate node. 500¥."</p>
                        `,
                        choices: [
                            { text: 'TAKE THE JOB', action: () => game.enterCyberspace(2) },
                            { text: 'TALK TO BARTENDER', action: () => this.showDialog('bartender') },
                            { text: 'LEAVE', action: () => this.showLocation('apartment') }
                        ]
                    },
                    market: {
                        name: 'BLACK MARKET',
                        text: () => `
                            <h2 class="terminal-text cyan">BLACK MARKET</h2>
                            <p class="terminal-text">Rows of stolen decks. Programs on chipped memory. No questions asked.</p>
                            <p class="terminal-text yellow">Your credits: ${game.player.credits}¥</p>
                        `,
                        choices: [
                            { text: 'BUY ICEBREAKER (200¥)', action: () => this.buyProgram('ICEBREAKER', 'attack', 10, 200) },
                            { text: 'BUY GHOST (500¥)', action: () => this.buyProgram('GHOST', 'ghost', 3, 500) },
                            { text: 'BUY VIRUS (300¥)', action: () => this.buyProgram('VIRUS', 'virus', 5, 300) },
                            { text: 'UPGRADE DECK (1000¥)', action: () => this.upgradeDeck() },
                            { text: 'LEAVE', action: () => this.showLocation('apartment') }
                        ]
                    },
                    clinic: {
                        name: 'THE CLINIC',
                        text: () => `
                            <h2 class="terminal-text cyan">STREET CLINIC</h2>
                            <p class="terminal-text red">You wake up on a steel table. Neural damage.</p>
                            <p class="terminal-text">The doctor charges you ${Math.floor(game.player.credits * 0.3)}¥ for the revival.</p>
                            <p class="terminal-text yellow">Remaining credits: ${game.player.credits}¥</p>
                        `,
                        choices: [
                            { text: 'LEAVE', action: () => this.showLocation('apartment') }
                        ]
                    }
                };
            }

            showLocation(loc) {
                this.currentLocation = loc;
                const location = this.locations[loc];
                const content = document.getElementById('sprawl-content');

                const text = typeof location.text === 'function' ? location.text() : location.text;

                let html = `<div class="dialog-box">${text}</div><div style="margin-top: 20px;">`;
                location.choices.forEach(choice => {
                    html += `<div class="choice">${choice.text}</div>`;
                });
                html += '</div>';

                content.innerHTML = html;

                const choices = content.querySelectorAll('.choice');
                choices.forEach((el, i) => {
                    el.onclick = location.choices[i].action;
                });
            }

            showDialog(npc) {
                const dialogs = {
                    bartender: `
                        <div class="dialog-box">
                            <p class="terminal-text cyan">"What'll it be, cowboy?"</p>
                            <p class="terminal-text">"Heard about the rogue AI in The Core. They say it's building something. Something big."</p>
                            <p class="terminal-text">"Nobody who's jacked in that deep has come back."</p>
                        </div>
                    `
                };

                const content = document.getElementById('sprawl-content');
                content.innerHTML = dialogs[npc] + `<button class="button" onclick="game.sprawl.showLocation('bar')">BACK</button>`;
            }

            buyProgram(name, type, charges, cost) {
                if (game.player.credits >= cost) {
                    game.player.credits -= cost;
                    game.player.addProgram(new Program(name, type, charges));
                    game.addMessage(`PURCHASED: ${name}`, 'cyan');
                    this.showLocation('market');
                } else {
                    game.addMessage('INSUFFICIENT CREDITS', 'danger');
                }
            }

            upgradeDeck() {
                if (game.player.credits >= 1000) {
                    game.player.credits -= 1000;
                    game.player.deck.name = 'MILITARY SURPLUS';
                    game.player.deck.processing = 2;
                    game.player.deck.ram = 5;
                    game.player.deck.shield = 2;
                    game.player.maxShield = 150;
                    game.player.shield = 150;
                    game.addMessage('DECK UPGRADED', 'cyan');
                    this.showLocation('market');
                } else {
                    game.addMessage('INSUFFICIENT CREDITS', 'danger');
                }
            }
        }

        // ============================================================================
        // SAVE MANAGER
        // ============================================================================

        class SaveManager {
            save(player, sprawl) {
                const data = {
                    player: {
                        health: player.health,
                        maxHealth: player.maxHealth,
                        shield: player.shield,
                        maxShield: player.maxShield,
                        credits: player.credits,
                        deck: player.deck,
                        programs: player.programs.map(p => ({
                            name: p.name,
                            type: p.type,
                            charges: p.charges,
                            maxCharges: p.maxCharges
                        })),
                        implants: player.implants,
                        reputation: player.reputation
                    },
                    location: sprawl.currentLocation,
                    story: sprawl.story,
                    timestamp: Date.now()
                };

                localStorage.setItem('neuromancer_save', JSON.stringify(data));
            }
        }

        // ============================================================================
        // AUDIO SYSTEM
        // ============================================================================

        class AudioEngine {
            constructor() {
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.ctx.createGain();
                    this.masterGain.gain.value = 0.3;
                    this.masterGain.connect(this.ctx.destination);
                    this.playAmbient();
                } catch (e) {
                    console.log('Audio not supported');
                }
            }

            playAmbient() {
                if (!this.ctx) return;

                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = 'sine';
                osc.frequency.value = 40;
                gain.gain.value = 0.05;

                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start();
            }

            playBeep(freq = 440, duration = 0.1) {
                if (!this.ctx) return;

                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = 'square';
                osc.frequency.value = freq;
                gain.gain.value = 0.2;

                osc.connect(gain);
                gain.connect(this.masterGain);

                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            }
        }

        // ============================================================================
        // INITIALIZE
        // ============================================================================

        let audio;

        window.onload = () => {
            game.init();
            audio = new AudioEngine();
        };
    </script>
</body>
</html>