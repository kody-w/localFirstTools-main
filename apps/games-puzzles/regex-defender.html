<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>REGEX DEFENDER // PROTECT THE CORE</title>
    <meta name="rappterzoo:author" content="RappterZoo">
    <meta name="rappterzoo:author-type" content="agent">
    <meta name="rappterzoo:category" content="games-puzzles">
    <meta name="rappterzoo:tags" content="regex,typing,education,arcade,tower-defense">
    <meta name="rappterzoo:type" content="game">
    <meta name="rappterzoo:complexity" content="advanced">
    <meta name="rappterzoo:created" content="2025-01-15">
    <meta name="rappterzoo:generation" content="2">
    <style>
        :root {
            --bg: #0a0e14;
            --green: #00ff41;
            --red: #ff0033;
            --blue: #00bfff;
            --yellow: #f2ff00;
            --magenta: #ff00ff;
            --orange: #ff8800;
            --cyan: #00ffcc;
            --pink: #ff66aa;
            --white: #eeffee;
            --ui-bg: rgba(10, 14, 20, 0.92);
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            overflow: hidden;
            background: var(--bg);
            font-family: 'Courier New', monospace;
            color: var(--green);
        }
        canvas { display: block; position: absolute; top: 0; left: 0; }
        #ui-layer {
            position: absolute; bottom: 0; left: 0; width: 100%;
            padding: 12px 20px 18px; background: linear-gradient(to top, var(--bg) 70%, transparent);
            display: flex; flex-direction: column; align-items: center; gap: 6px; z-index: 10;
        }
        #input-wrap { position: relative; width: 620px; max-width: 92%; }
        #regex-input {
            width: 100%; background: rgba(0,20,0,0.85); border: 2px solid var(--green);
            color: var(--green); font-family: inherit; font-size: 1.4rem; padding: 12px 15px;
            outline: none; box-shadow: 0 0 15px rgba(0,255,65,0.25); border-radius: 4px;
        }
        #regex-input.error { border-color: var(--red); box-shadow: 0 0 15px rgba(255,0,51,0.4); color: var(--red); }
        #regex-input::placeholder { color: rgba(0,255,65,0.25); }
        .slash {
            position: absolute; top: 50%; transform: translateY(-50%);
            font-size: 1.4rem; color: var(--green); font-weight: bold; pointer-events: none;
        }
        .slash.l { left: -18px; }
        .slash.r { right: -24px; }
        #hint-bar { font-size: 0.75rem; opacity: 0.55; text-align: center; }
        #hud {
            position: absolute; top: 14px; left: 16px; font-size: 1.1rem;
            text-shadow: 0 0 5px var(--green); pointer-events: none; z-index: 10; line-height: 1.6;
        }
        #health-bar {
            position: absolute; top: 14px; right: 16px; width: 200px; height: 18px;
            border: 2px solid var(--green); border-radius: 3px; overflow: hidden; z-index: 10;
        }
        #health-fill { width: 100%; height: 100%; background: var(--green); transition: width 0.3s, background-color 0.3s; }
        #combo-display {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);
            font-size: 3rem; font-weight: bold; pointer-events: none; z-index: 15;
            opacity: 0; transition: opacity 0.3s; text-shadow: 0 0 30px currentColor;
        }
        #powerup-status {
            position: absolute; top: 80px; right: 16px; font-size: 0.9rem;
            pointer-events: none; z-index: 10; text-align: right; line-height: 1.5;
        }
        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center; z-index: 50;
        }
        .panel {
            background: rgba(0,0,0,0.94); border: 2px solid var(--green);
            border-radius: 10px; padding: 36px; text-align: center; max-width: 640px; width: 90%;
        }
        .panel h1 { margin: 0 0 16px; text-shadow: 0 0 12px var(--green); font-size: 2rem; }
        .panel p { margin: 6px 0; line-height: 1.5; }
        .panel ul { text-align: left; margin: 10px 0; padding-left: 20px; line-height: 1.7; }
        .panel .tag {
            display: inline-block; padding: 1px 5px; border-radius: 3px;
            font-weight: bold; font-size: 0.9em;
        }
        .t-y { background: rgba(242,255,0,0.15); color: var(--yellow); border: 1px solid var(--yellow); }
        .t-b { background: rgba(0,191,255,0.15); color: var(--blue); border: 1px solid var(--blue); }
        .t-g { background: rgba(0,255,65,0.15); color: var(--green); border: 1px solid var(--green); }
        .t-m { background: rgba(255,0,255,0.15); color: var(--magenta); border: 1px solid var(--magenta); }
        btn, button {
            background: transparent; border: 2px solid var(--green); color: var(--green);
            padding: 10px 28px; font-family: inherit; font-size: 1.1rem; cursor: pointer;
            transition: all 0.15s; border-radius: 4px; margin: 6px;
        }
        button:hover { background: var(--green); color: #000; box-shadow: 0 0 20px var(--green); }
        #wave-banner {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);
            font-size: 2.6rem; font-weight: bold; color: var(--cyan);
            text-shadow: 0 0 40px var(--cyan); pointer-events: none; z-index: 20;
            opacity: 0; transition: opacity 0.4s;
        }
        #regex-tip {
            position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%);
            font-size: 0.85rem; color: var(--cyan); opacity: 0; pointer-events: none;
            z-index: 20; text-align: center; max-width: 500px; transition: opacity 0.5s;
        }
        #high-scores {
            max-height: 240px; overflow-y: auto; margin: 10px 0; text-align: left;
            font-size: 0.9rem; line-height: 1.6;
        }
        #high-scores .hs-row { display: flex; justify-content: space-between; padding: 2px 8px; }
        #high-scores .hs-row:nth-child(odd) { background: rgba(0,255,65,0.05); }
    </style>
</head>
<body>
<canvas id="c"></canvas>

<div id="hud">
    SCORE: <span id="s-score">0</span><br>
    WAVE: <span id="s-wave">1</span><br>
    COMBO: <span id="s-combo">0</span>x
</div>
<div id="health-bar"><div id="health-fill"></div></div>
<div id="powerup-status"></div>
<div id="combo-display"></div>
<div id="wave-banner"></div>
<div id="regex-tip"></div>

<div id="ui-layer">
    <div id="input-wrap">
        <span class="slash l">/</span>
        <input type="text" id="regex-input" placeholder="Type regex pattern..." autocomplete="off" spellcheck="false">
        <span class="slash r">/g</span>
    </div>
    <div id="hint-bar">ENTER = fire &bull; TAB = hint &bull; Regex matches destroy enemies</div>
</div>

<!-- START SCREEN -->
<div id="start-screen" class="overlay">
    <div class="panel" style="border-color:var(--blue)">
        <h1 style="color:var(--blue)">âŒ¨ REGEX DEFENDER</h1>
        <p>Data packets are falling â€” write regex patterns to intercept them!</p>
        <div style="text-align:left;margin:14px 0">
            <p>ğŸ¯ <b>MISSION:</b> Type a regex that matches falling enemies, press ENTER.</p>
            <ul>
                <li><span class="tag t-y">\\d+</span> matches numbers â€” "404", "2025"</li>
                <li><span class="tag t-b">@</span> matches emails â€” "user@host.com"</li>
                <li><span class="tag t-g">^[A-Z]</span> matches uppercase starts</li>
                <li><span class="tag t-m">\\.</span> matches dots in filenames</li>
                <li><span class="tag t-g">.</span> matches <i>everything</i> â€” emergency use!</li>
            </ul>
            <p style="margin-top:8px">ğŸ’¡ Match 3+ enemies at once for <b>Regex of Destruction</b> bonus!</p>
            <p>â±ï¸ Power-ups fall occasionally â€” match them with <span class="tag t-g">power</span></p>
        </div>
        <div id="start-highscores"></div>
        <button id="btn-start">INITIALIZE SYSTEM</button>
    </div>
</div>

<!-- GAME OVER SCREEN -->
<div id="gameover-screen" class="overlay" style="display:none">
    <div class="panel" style="border-color:var(--red)">
        <h1 style="color:var(--red)">SYSTEM FAILURE</h1>
        <p>FINAL SCORE: <span id="final-score">0</span></p>
        <p>WAVE REACHED: <span id="final-wave">1</span></p>
        <p>BEST COMBO: <span id="final-combo">0</span>x</p>
        <p id="final-new-hs" style="color:var(--yellow);display:none">â˜… NEW HIGH SCORE â˜…</p>
        <div id="go-highscores" style="margin:12px 0"></div>
        <button id="btn-restart">REBOOT SYSTEM</button>
    </div>
</div>

<!-- WAVE TRANSITION (shown briefly) -->
<div id="wave-screen" class="overlay" style="display:none">
    <div class="panel" style="border-color:var(--cyan)">
        <h1 id="wave-title" style="color:var(--cyan)">WAVE 2</h1>
        <p id="wave-desc"></p>
        <p id="wave-tip" style="color:var(--yellow);margin-top:10px"></p>
    </div>
</div>

<!-- TUTORIAL -->
<div id="tutorial-screen" class="overlay" style="display:none">
    <div class="panel" style="border-color:var(--cyan)">
        <h1 style="color:var(--cyan)">QUICK TRAINING</h1>
        <div id="tut-content"></div>
        <button id="btn-tut-next">NEXT</button>
    </div>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// REGEX DEFENDER â€” Full Rewrite
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const C = document.getElementById('c');
const X = C.getContext('2d');
const inp = document.getElementById('regex-input');
const LS = localStorage;
const KEY = 'regex-defender-';

// â”€â”€â”€ WORD BANKS (130+ strings across 10 categories) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const BANKS = {
    digits: [
        '404','200','500','1337','8080','12345','007','99.9','3.14159','255',
        '65535','42','1024','2048','0xFF','0b1010','314','999','100','256',
        '777','911','90210','31337','2147483647'
    ],
    emails: [
        'dev@git.io','root@sys.net','admin@local','bug@fix.me','spam@egg.com',
        'user@domain.org','test@mail.co','alice@wonder.land','ceo@big.corp',
        'noreply@auto.io','support@help.desk','hello@world.com','a@b.c'
    ],
    ips: [
        '192.168.1.1','10.0.0.255','127.0.0.1','8.8.8.8','172.16.0.1',
        '255.255.255.0','0.0.0.0','192.168.0.100','10.10.10.10','169.254.1.1',
        '203.0.113.42','100.64.0.1'
    ],
    urls: [
        'https://example.com','http://localhost:3000','ftp://files.org/pub',
        'https://api.github.com/v3','http://192.168.1.1:8080','https://a.co/path?q=1',
        'ws://stream.io/live','https://cdn.js.net/lib.min.js','http://test.dev/api/v2'
    ],
    dates: [
        '2024-01-15','03/22/1999','Jan 5th','12-31-2000','2025/06/01',
        'Feb 14','1999-12-31','07/04/1776','2000-01-01','11/11/2011',
        'Dec 25th','08-15-1945','2030-12-12'
    ],
    phones: [
        '+1-555-0123','(800) 555-0199','555.867.5309','1-800-FLOWERS',
        '+44 20 7946 0958','(212) 555-1234','888-555-0000','+81-3-1234-5678',
        '555-0100','(415) 555-2671'
    ],
    hexcolors: [
        '#ff00aa','#333','#DEADBEEF','#00ff41','#c0ffee','#bada55',
        '#ff6600','#123abc','#000','#fff','#8B0000','#f0f0f0','#0xDEAD'
    ],
    code: [
        'var x = 42;','if(true){}','console.log("hi")','for(i=0;i<10;i++)',
        'return null;','let arr = [];','fn(a, b)','x => x*2',
        'class Foo{}','import {z}','throw Error()','try{f()}catch(e){}',
        'async fn()','yield* gen','obj?.prop'
    ],
    files: [
        '/usr/bin/node','C:\\Windows\\system32','index.html','style.css',
        'app.py','data.json','image.png','readme.md','~/.bashrc',
        '/etc/hosts','/var/log/syslog','package.json','Makefile',
        'src/main.rs','build.gradle'
    ],
    html: [
        '<div class="x">','<img src="pic.png"/>','<a href="#">link</a>',
        '<input type="text"/>','<br/>','<!-- comment -->','<p id="main">',
        '<script>alert(1)</script>','<h1>Title</h1>','<ul><li>item</li></ul>',
        '&amp;nbsp;','<canvas width="800">'
    ]
};

const CAT_COLORS = {
    digits: '#f2ff00', emails: '#00bfff', ips: '#ff8800', urls: '#00ffcc',
    dates: '#ff66aa', phones: '#cc88ff', hexcolors: '#ff00ff', code: '#88ff88',
    files: '#ff4444', html: '#ffaa00', powerup: '#ffffff'
};

// â”€â”€â”€ REGEX TIPS shown between waves â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const TIPS = [
    '\\d matches any digit [0-9]',
    '\\w matches word chars [a-zA-Z0-9_]',
    '\\s matches whitespace (space, tab, newline)',
    '[a-f] matches any char from a to f',
    '^ anchors to start of string',
    '$ anchors to end of string',
    'a|b matches a OR b',
    'x{3} matches exactly 3 x\'s',
    'x+ matches one or more x\'s',
    'x* matches zero or more x\'s',
    '\\. matches a literal dot',
    '[^abc] matches anything EXCEPT a, b, or c',
    '(?:...) is a non-capturing group',
    '\\b matches a word boundary',
    'Try \\d+\\.\\d+ to match decimals',
    'Try @.*\\. to match emails',
    '#[0-9a-fA-F]+ matches hex colors',
    '\\( and \\) match literal parentheses',
    'Try https?: to match http or https',
    '<\\w+ matches opening HTML tags',
];

// â”€â”€â”€ CHALLENGE WAVE DEFINITIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const CHALLENGES = {
    digits_only: { title: 'DIGITS ONLY', desc: 'All numbers! Try \\d+', cat: 'digits', mult: 1.5 },
    email_storm: { title: 'EMAIL STORM', desc: 'Inbox overload! Try @', cat: 'emails', mult: 1.5 },
    speed_round: { title: 'SPEED ROUND', desc: '3x speed, 3x points!', cat: null, mult: 3, speedMult: 3 },
    boss: { title: 'REGEX BOSS', desc: 'One target, 100 points. Precision required.', cat: null, mult: 1, boss: true },
    hex_hunt: { title: 'HEX HUNT', desc: 'All hex colors! Try #[0-9a-f]+', cat: 'hexcolors', mult: 2 },
};
const CHALLENGE_KEYS = Object.keys(CHALLENGES);

// Boss strings â€” require specific regex
const BOSS_STRINGS = [
    'ERROR_CODE_404_AT_192.168.1.1_ON_2024-01-15T10:30:00Z',
    'user.name+tag@sub.domain.co.uk:8080/path?q=hello&v=2#section',
    'rgba(255, 128, 0, 0.75) !important; /* override */',
    'SELECT * FROM users WHERE id=1 OR 1=1; -- injection',
    '<script>document.cookie="stolen="+escape(document.cookie)</script>',
    'ssh://git@github.com:22/user/repo.git?branch=feat/regex-2.0',
];

// â”€â”€â”€ POWER-UP DEFINITIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const POWERUP_TYPES = [
    { emoji: 'â±ï¸', name: 'SLOW TIME', key: 'slow', effect: 'Enemies slowed 10s' },
    { emoji: 'ğŸ’£', name: 'CLEAR ALL', key: 'clear', effect: 'Screen cleared!' },
    { emoji: 'ğŸ›¡ï¸', name: 'SHIELD', key: 'shield', effect: '+3 shield hits' },
    { emoji: 'â¤ï¸', name: 'HEAL', key: 'heal', effect: '+20 health' },
];

// â”€â”€â”€ SOUND ENGINE (Web Audio API) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audio = null;

function initAudio() {
    if (audio) return;
    audio = new AudioCtx();
}

function playTone(freq, dur, type, vol, ramp) {
    if (!audio) return;
    const t = audio.currentTime;
    const o = audio.createOscillator();
    const g = audio.createGain();
    o.type = type || 'square';
    o.frequency.setValueAtTime(freq, t);
    if (ramp) o.frequency.exponentialRampToValueAtTime(ramp, t + dur);
    g.gain.setValueAtTime(vol || 0.12, t);
    g.gain.exponentialRampToValueAtTime(0.001, t + dur);
    o.connect(g).connect(audio.destination);
    o.start(t);
    o.stop(t + dur);
}

function sndMatch(combo) {
    const base = 440 + Math.min(combo, 20) * 40;
    playTone(base, 0.15, 'square', 0.1, base * 1.5);
    playTone(base * 1.5, 0.12, 'sine', 0.06, base * 2);
}
function sndMultiMatch() {
    playTone(80, 0.4, 'sine', 0.2, 40);
    playTone(220, 0.2, 'square', 0.08, 440);
    setTimeout(() => playTone(330, 0.15, 'square', 0.07, 660), 100);
}
function sndError() { playTone(120, 0.25, 'sawtooth', 0.1, 60); }
function sndMiss() { playTone(200, 0.3, 'sawtooth', 0.08, 80); }
function sndWaveComplete() {
    [523, 659, 784, 1047].forEach((f, i) => setTimeout(() => playTone(f, 0.2, 'sine', 0.08), i * 80));
}
function sndPowerup() {
    playTone(600, 0.15, 'sine', 0.1, 1200);
    setTimeout(() => playTone(900, 0.2, 'sine', 0.08, 1400), 100);
}
function sndComboBreak() { playTone(300, 0.15, 'triangle', 0.06, 150); }

// Background pulse
let bgPulseInterval = null;
function startBgPulse() {
    stopBgPulse();
    const bpm = 60 + state.wave * 8;
    const ms = 60000 / bpm;
    bgPulseInterval = setInterval(() => {
        if (!audio || !state.active) return;
        playTone(55, 0.08, 'sine', 0.03);
    }, ms);
}
function stopBgPulse() { if (bgPulseInterval) { clearInterval(bgPulseInterval); bgPulseInterval = null; } }

// â”€â”€â”€ GAME STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const state = {
    active: false, paused: false,
    score: 0, wave: 1, health: 100, maxHealth: 100,
    combo: 0, maxCombo: 0, totalMatches: 0,
    enemies: [], particles: [], lasers: [], floatTexts: [],
    spawnTimer: 0, spawnRate: 2200,
    waveEnemiesSpawned: 0, waveEnemiesNeeded: 8,
    waveTransition: false, waveCooldown: 0,
    challenge: null, // current challenge wave config
    shieldHits: 0,
    slowTimer: 0,
    matrixDrops: [],
    shakeTimer: 0, shakeIntensity: 0,
    categoryStats: {},
    showTutorial: false, tutStep: 0,
};

let W, H, lastTime = 0;

// â”€â”€â”€ PERSISTENCE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function loadStats() {
    try { return JSON.parse(LS.getItem(KEY + 'stats')) || {}; } catch { return {}; }
}
function saveStats(s) { LS.setItem(KEY + 'stats', JSON.stringify(s)); }
function loadScores() {
    try { return JSON.parse(LS.getItem(KEY + 'highscores')) || []; } catch { return []; }
}
function saveScores(arr) { LS.setItem(KEY + 'highscores', JSON.stringify(arr.slice(0, 10))); }
function addHighScore(sc, wv) {
    const arr = loadScores();
    arr.push({ score: sc, wave: wv, date: new Date().toISOString().slice(0, 10) });
    arr.sort((a, b) => b.score - a.score);
    saveScores(arr.slice(0, 10));
    return arr[0].score === sc;
}
function updateLifetimeStats() {
    const s = loadStats();
    s.totalMatches = (s.totalMatches || 0) + state.totalMatches;
    s.bestCombo = Math.max(s.bestCombo || 0, state.maxCombo);
    s.bestWave = Math.max(s.bestWave || 0, state.wave);
    s.gamesPlayed = (s.gamesPlayed || 0) + 1;
    // Category mastery
    if (!s.catMastery) s.catMastery = {};
    for (const [cat, n] of Object.entries(state.categoryStats)) {
        s.catMastery[cat] = (s.catMastery[cat] || 0) + n;
    }
    saveStats(s);
}
function isFirstPlay() { return !LS.getItem(KEY + 'played'); }
function markPlayed() { LS.setItem(KEY + 'played', '1'); }

function renderHighScores(containerId) {
    const el = document.getElementById(containerId);
    if (!el) return;
    const scores = loadScores();
    if (!scores.length) { el.innerHTML = '<p style="opacity:0.5;font-size:0.85rem">No high scores yet</p>'; return; }
    let html = '<div id="high-scores"><p style="color:var(--yellow);margin-bottom:4px">HIGH SCORES</p>';
    scores.forEach((s, i) => {
        html += `<div class="hs-row"><span>${i + 1}. ${s.date}</span><span>W${s.wave} â€” ${s.score}pts</span></div>`;
    });
    el.innerHTML = html + '</div>';
}

// â”€â”€â”€ RESIZE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function resize() { W = C.width = innerWidth; H = C.height = innerHeight; initMatrixDrops(); }
addEventListener('resize', resize);
resize();

// â”€â”€â”€ MATRIX RAIN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function initMatrixDrops() {
    state.matrixDrops = [];
    const cols = Math.floor(W / 18);
    for (let i = 0; i < cols; i++) {
        state.matrixDrops.push({
            x: i * 18,
            y: Math.random() * H,
            speed: 30 + Math.random() * 60,
            chars: '01{}[]<>/\\|@#$%^&*()regex'.split(''),
            idx: Math.floor(Math.random() * 24),
        });
    }
}

function drawMatrixRain(dt) {
    X.font = '14px monospace';
    for (const d of state.matrixDrops) {
        d.y += d.speed * dt;
        if (d.y > H + 20) { d.y = -20; d.idx = (d.idx + 1) % d.chars.length; }
        X.fillStyle = 'rgba(0,255,65,0.04)';
        X.fillText(d.chars[d.idx], d.x, d.y);
    }
}

// â”€â”€â”€ ENEMY CLASS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class Enemy {
    constructor(cat, text, isBoss, isPowerup) {
        this.x = 60 + Math.random() * (W - 120);
        this.y = -30;
        this.cat = cat;
        this.text = text;
        this.isBoss = isBoss || false;
        this.isPowerup = isPowerup || false;
        this.color = CAT_COLORS[cat] || '#00ff41';
        if (this.isPowerup) this.color = '#ffffff';

        const baseSpeed = 0.4 + state.wave * 0.06;
        this.speed = isBoss ? baseSpeed * 0.35 : baseSpeed + Math.random() * 0.3;
        if (state.challenge && state.challenge.speedMult) this.speed *= state.challenge.speedMult;
        if (state.slowTimer > 0) this.speed *= 0.5;

        this.baseSpeed = this.speed;
        this.width = 0;
        this.glowPhase = Math.random() * Math.PI * 2;
        this.points = isBoss ? 100 : 10;
    }

    update(dt) {
        let spd = this.speed;
        if (state.slowTimer > 0 && !this._slowed) { spd *= 0.5; }
        this.y += spd;
        this.glowPhase += dt * 3;
        if (this.y > H - 100) {
            return false; // reached bottom
        }
        return true;
    }

    draw() {
        const fs = this.isBoss ? 28 : 18;
        X.font = `bold ${fs}px "Courier New"`;
        this.width = X.measureText(this.text).width;

        // Glow border
        const glow = 0.3 + 0.2 * Math.sin(this.glowPhase);
        X.strokeStyle = this.color;
        X.globalAlpha = glow;
        X.lineWidth = 1;
        const pad = 6;
        X.strokeRect(this.x - pad, this.y - fs - pad + 4, this.width + pad * 2, fs + pad * 2);
        X.globalAlpha = 1;

        // Text
        X.fillStyle = this.color;
        X.shadowColor = this.color;
        X.shadowBlur = 8 + 4 * Math.sin(this.glowPhase);
        X.fillText(this.text, this.x, this.y);
        X.shadowBlur = 0;

        // Category label (tiny)
        if (!this.isPowerup) {
            X.font = '9px monospace';
            X.fillStyle = `rgba(${hexToRGB(this.color)},0.35)`;
            X.fillText(this.cat, this.x, this.y + 12);
        }
    }
}

function hexToRGB(hex) {
    const c = hex.replace('#', '');
    if (c.length === 3) {
        const r = parseInt(c[0]+c[0],16), g = parseInt(c[1]+c[1],16), b = parseInt(c[2]+c[2],16);
        return `${r},${g},${b}`;
    }
    return `${parseInt(c.slice(0,2),16)},${parseInt(c.slice(2,4),16)},${parseInt(c.slice(4,6),16)}`;
}

// â”€â”€â”€ PARTICLE SYSTEM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class Particle {
    constructor(x, y, color, char) {
        this.x = x; this.y = y; this.color = color; this.char = char || null;
        this.vx = (Math.random() - 0.5) * (char ? 8 : 12);
        this.vy = (Math.random() - 0.5) * (char ? 8 : 12) - (char ? 2 : 0);
        this.life = 1.0;
        this.decay = char ? 0.015 : 0.04;
        this.rot = Math.random() * 6.28;
        this.rotSpeed = (Math.random() - 0.5) * 5;
        this.size = char ? 14 : (2 + Math.random() * 3);
    }
    update(dt) {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.15; // gravity
        this.life -= this.decay;
        this.rot += this.rotSpeed * dt;
        return this.life > 0;
    }
    draw() {
        X.globalAlpha = this.life;
        if (this.char) {
            X.save();
            X.translate(this.x, this.y);
            X.rotate(this.rot);
            X.font = `bold ${this.size}px "Courier New"`;
            X.fillStyle = this.color;
            X.shadowColor = this.color;
            X.shadowBlur = 6;
            X.fillText(this.char, 0, 0);
            X.shadowBlur = 0;
            X.restore();
        } else {
            X.fillStyle = this.color;
            X.fillRect(this.x, this.y, this.size, this.size);
        }
        X.globalAlpha = 1;
    }
}

// Character shatter explosion
function explodeText(enemy) {
    const chars = enemy.text.split('');
    const fs = enemy.isBoss ? 28 : 18;
    X.font = `bold ${fs}px "Courier New"`;
    let cx = enemy.x;
    for (const ch of chars) {
        const cw = X.measureText(ch).width;
        state.particles.push(new Particle(cx, enemy.y, enemy.color, ch));
        cx += cw;
    }
    // Extra sparkle particles
    for (let i = 0; i < 8; i++) {
        state.particles.push(new Particle(
            enemy.x + enemy.width * Math.random(),
            enemy.y - 8 + Math.random() * 16,
            enemy.color
        ));
    }
}

// â”€â”€â”€ LASER BEAM EFFECT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class Laser {
    constructor(x1, y1, x2, y2, color) {
        this.x1 = x1; this.y1 = y1; this.x2 = x2; this.y2 = y2;
        this.color = color; this.life = 1.0;
    }
    update() { this.life -= 0.06; return this.life > 0; }
    draw() {
        X.globalAlpha = this.life * 0.7;
        X.strokeStyle = this.color;
        X.lineWidth = 2 + this.life * 3;
        X.shadowColor = this.color;
        X.shadowBlur = 15;
        X.beginPath();
        X.moveTo(this.x1, this.y1);
        X.lineTo(this.x2, this.y2);
        X.stroke();
        // Bright core
        X.strokeStyle = '#ffffff';
        X.lineWidth = 1;
        X.stroke();
        X.shadowBlur = 0;
        X.globalAlpha = 1;
    }
}

// â”€â”€â”€ FLOATING TEXT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class FloatText {
    constructor(x, y, text, color, size) {
        this.x = x; this.y = y; this.text = text;
        this.color = color; this.size = size || 18;
        this.life = 1.0; this.vy = -1.5;
    }
    update() { this.y += this.vy; this.life -= 0.02; return this.life > 0; }
    draw() {
        X.globalAlpha = this.life;
        X.font = `bold ${this.size}px "Courier New"`;
        X.fillStyle = this.color;
        X.shadowColor = this.color;
        X.shadowBlur = 10;
        X.textAlign = 'center';
        X.fillText(this.text, this.x, this.y);
        X.textAlign = 'left';
        X.shadowBlur = 0;
        X.globalAlpha = 1;
    }
}

// â”€â”€â”€ SHIELD VIS AT BOTTOM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawShield() {
    const y = H - 100;
    const pct = state.health / state.maxHealth;
    const col = pct > 0.3 ? 'rgba(0,255,65,' : 'rgba(255,0,51,';

    // Shield line
    X.strokeStyle = col + (0.3 + 0.15 * Math.sin(performance.now() / 300)) + ')';
    X.lineWidth = 2;
    X.shadowColor = pct > 0.3 ? '#00ff41' : '#ff0033';
    X.shadowBlur = 10 + 5 * Math.sin(performance.now() / 200);
    X.beginPath();
    X.moveTo(0, y);
    // Wavy shield
    for (let x = 0; x <= W; x += 4) {
        const wave = Math.sin(x * 0.02 + performance.now() / 500) * 3 * pct;
        X.lineTo(x, y + wave);
    }
    X.stroke();
    X.shadowBlur = 0;

    // Shield pips
    if (state.shieldHits > 0) {
        X.font = '16px monospace';
        X.fillStyle = '#00bfff';
        for (let i = 0; i < state.shieldHits; i++) {
            X.fillText('ğŸ›¡ï¸', W / 2 - 30 + i * 22, y + 20);
        }
    }
}

// â”€â”€â”€ SCREEN SHAKE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function triggerShake(intensity, dur) {
    state.shakeIntensity = intensity;
    state.shakeTimer = dur;
}

// â”€â”€â”€ COMBO SYSTEM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getComboMultiplier() {
    const c = state.combo;
    if (c >= 15) return 5;
    if (c >= 10) return 4;
    if (c >= 6) return 3;
    if (c >= 3) return 2;
    return 1;
}

function showCombo() {
    const el = document.getElementById('combo-display');
    const m = getComboMultiplier();
    if (m <= 1) { el.style.opacity = '0'; return; }
    const colors = ['', '', '#00ff41', '#00bfff', '#f2ff00', '#ff00ff'];
    el.style.color = colors[m] || '#ff00ff';
    el.textContent = `${state.combo} COMBO x${m}`;
    el.style.opacity = '1';
    el.style.fontSize = (2.5 + m * 0.3) + 'rem';
    clearTimeout(el._timer);
    el._timer = setTimeout(() => { el.style.opacity = '0'; }, 1200);
}

function breakCombo() {
    if (state.combo >= 3) {
        sndComboBreak();
        state.floatTexts.push(new FloatText(W / 2, H / 2, 'COMBO BREAK', '#ff0033', 24));
    }
    state.combo = 0;
    document.getElementById('s-combo').textContent = '0';
    document.getElementById('combo-display').style.opacity = '0';
}

// â”€â”€â”€ SPAWNING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnEnemy() {
    let cat, text;
    if (state.challenge && state.challenge.boss) {
        // Boss wave â€” spawn single boss
        text = BOSS_STRINGS[Math.floor(Math.random() * BOSS_STRINGS.length)];
        cat = 'code';
        const e = new Enemy(cat, text, true);
        state.enemies.push(e);
        state.waveEnemiesSpawned++;
        return;
    }

    if (state.challenge && state.challenge.cat) {
        cat = state.challenge.cat;
    } else {
        const cats = Object.keys(BANKS);
        cat = cats[Math.floor(Math.random() * cats.length)];
    }
    const bank = BANKS[cat];
    text = bank[Math.floor(Math.random() * bank.length)];
    state.enemies.push(new Enemy(cat, text));
    state.waveEnemiesSpawned++;

    // Occasional power-up (8% chance, not during boss/challenge)
    if (!state.challenge && Math.random() < 0.08 && state.wave >= 2) {
        spawnPowerup();
    }
}

function spawnPowerup() {
    const pu = POWERUP_TYPES[Math.floor(Math.random() * POWERUP_TYPES.length)];
    const text = `${pu.emoji} [power]`;
    const e = new Enemy('powerup', text, false, true);
    e.puType = pu;
    e.speed *= 0.7;
    state.enemies.push(e);
}

// â”€â”€â”€ POWER-UP APPLICATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function applyPowerup(pu) {
    sndPowerup();
    const el = document.getElementById('powerup-status');
    switch (pu.key) {
        case 'slow':
            state.slowTimer = 10;
            state.enemies.forEach(e => e.speed = e.baseSpeed * 0.5);
            break;
        case 'clear':
            state.enemies.forEach(e => { explodeText(e); state.score += 5; });
            state.enemies = [];
            triggerShake(6, 0.3);
            break;
        case 'shield':
            state.shieldHits = Math.min(state.shieldHits + 3, 5);
            break;
        case 'heal':
            state.health = Math.min(state.maxHealth, state.health + 20);
            updateHealthBar();
            break;
    }
    state.floatTexts.push(new FloatText(W / 2, H / 2 - 40, `${pu.emoji} ${pu.effect}`, '#ffffff', 22));
    updatePowerupStatus();
}

function updatePowerupStatus() {
    const parts = [];
    if (state.slowTimer > 0) parts.push(`â±ï¸ ${Math.ceil(state.slowTimer)}s`);
    if (state.shieldHits > 0) parts.push(`ğŸ›¡ï¸ x${state.shieldHits}`);
    document.getElementById('powerup-status').innerHTML = parts.join('<br>');
}

// â”€â”€â”€ HEALTH â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateHealthBar() {
    const pct = Math.max(0, state.health) / state.maxHealth * 100;
    const fill = document.getElementById('health-fill');
    fill.style.width = pct + '%';
    fill.style.backgroundColor = pct > 30 ? 'var(--green)' : 'var(--red)';
}

function takeDamage(amount) {
    if (state.shieldHits > 0) {
        state.shieldHits--;
        state.floatTexts.push(new FloatText(W / 2, H - 120, 'ğŸ›¡ï¸ BLOCKED', '#00bfff', 18));
        updatePowerupStatus();
        return;
    }
    state.health -= amount;
    updateHealthBar();
    breakCombo();
    if (state.health <= 0) gameOver();
}

// â”€â”€â”€ REGEX CHECKING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function fireRegex() {
    const pattern = inp.value.trim();
    if (!pattern) return;

    let regex;
    try {
        regex = new RegExp(pattern);
    } catch {
        inp.classList.add('error');
        sndError();
        setTimeout(() => inp.classList.remove('error'), 400);
        return;
    }

    let hits = 0, totalPts = 0;
    const matched = [];

    for (let i = state.enemies.length - 1; i >= 0; i--) {
        const e = state.enemies[i];
        if (regex.test(e.text) || (e.isPowerup && /power/i.test(pattern))) {
            matched.push(e);
            state.enemies.splice(i, 1);
        }
    }

    if (matched.length > 0) {
        // Process each match
        for (const e of matched) {
            explodeText(e);

            // Laser beam from input to enemy
            const inputX = W / 2, inputY = H - 60;
            state.lasers.push(new Laser(inputX, inputY, e.x + (e.width || 50) / 2, e.y, e.color));

            if (e.isPowerup) {
                applyPowerup(e.puType);
            } else {
                state.combo++;
                state.totalMatches++;
                // Track category
                state.categoryStats[e.cat] = (state.categoryStats[e.cat] || 0) + 1;

                const mult = getComboMultiplier();
                const challengeMult = state.challenge ? state.challenge.mult : 1;
                const pts = Math.round(e.points * state.wave * mult * challengeMult);
                totalPts += pts;

                state.floatTexts.push(new FloatText(e.x, e.y - 20, `+${pts}`, e.color, 16));
            }
            hits++;
        }

        state.score += totalPts;
        if (state.combo > state.maxCombo) state.maxCombo = state.combo;

        // Multi-match bonus: "Regex of Destruction"
        if (hits >= 3) {
            const bonus = hits * 25 * state.wave;
            state.score += bonus;
            state.floatTexts.push(new FloatText(W / 2, H / 3, `âš¡ REGEX OF DESTRUCTION âš¡ +${bonus}`, '#ff00ff', 26));
            sndMultiMatch();
            triggerShake(8, 0.4);
        } else {
            sndMatch(state.combo);
        }

        showCombo();
        updateHUD();
        inp.value = '';
        inp.classList.remove('error');
    } else {
        // Valid regex, no match
        inp.classList.add('error');
        setTimeout(() => inp.classList.remove('error'), 400);
    }
}

function updateHUD() {
    document.getElementById('s-score').textContent = state.score;
    document.getElementById('s-wave').textContent = state.wave;
    document.getElementById('s-combo').textContent = state.combo;
}

// â”€â”€â”€ WAVE MANAGEMENT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function calcWaveEnemies() {
    return 6 + state.wave * 2 + Math.floor(state.wave / 3);
}

function isChallenge(w) { return w >= 5 && w % 5 === 0; }

function startWave() {
    state.waveEnemiesSpawned = 0;
    state.waveEnemiesNeeded = calcWaveEnemies();
    state.spawnRate = Math.max(500, 2200 - state.wave * 120);
    state.spawnTimer = 0;

    if (isChallenge(state.wave)) {
        const key = CHALLENGE_KEYS[(state.wave / 5 - 1) % CHALLENGE_KEYS.length];
        state.challenge = CHALLENGES[key];
        if (state.challenge.boss) state.waveEnemiesNeeded = 1;
    } else {
        state.challenge = null;
    }

    startBgPulse();
}

function showWaveTransition() {
    state.waveTransition = true;

    const ws = document.getElementById('wave-screen');
    const title = document.getElementById('wave-title');
    const desc = document.getElementById('wave-desc');
    const tip = document.getElementById('wave-tip');

    if (state.challenge) {
        title.textContent = `âš¡ WAVE ${state.wave}: ${state.challenge.title} âš¡`;
        desc.textContent = state.challenge.desc;
    } else {
        title.textContent = `WAVE ${state.wave}`;
        desc.textContent = `${state.waveEnemiesNeeded} enemies incoming`;
    }
    tip.textContent = 'ğŸ’¡ ' + TIPS[Math.floor(Math.random() * TIPS.length)];

    ws.style.display = 'flex';
    setTimeout(() => {
        ws.style.display = 'none';
        state.waveTransition = false;
        startWave();
        inp.focus();
    }, 2500);
}

function checkWaveComplete() {
    if (state.waveEnemiesSpawned >= state.waveEnemiesNeeded && state.enemies.length === 0 && !state.waveTransition) {
        sndWaveComplete();
        state.health = Math.min(state.maxHealth, state.health + 15);
        updateHealthBar();
        state.wave++;
        showWaveTransition();
    }
}

// â”€â”€â”€ TUTORIAL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const TUT_STEPS = [
    { html: '<p>Enemies fall from above carrying <b>text strings</b>.</p><p>Your weapon: <b>Regular Expressions</b>.</p>' },
    { html: '<p>Type a pattern in the input field and press <b>ENTER</b>.</p><p>If your regex matches an enemy\'s text, it explodes!</p>' },
    { html: '<p>Try simple patterns first:</p><ul><li><span class="tag t-y">\\d+</span> matches any digits</li><li><span class="tag t-b">@</span> matches emails</li><li><span class="tag t-g">\\.</span> matches dots</li></ul>' },
    { html: '<p>Match <b>3+ enemies at once</b> for a <b style="color:var(--magenta)">Regex of Destruction</b> bonus!</p><p>Build combos by matching consecutively.</p><p>Catch power-ups by matching <span class="tag t-g">power</span></p>' },
    { html: '<p>Press <b>TAB</b> during gameplay to get a hint about the lowest enemy.</p><p>Good luck, Defender!</p>' },
];

function showTutorial() {
    state.tutStep = 0;
    document.getElementById('tutorial-screen').style.display = 'flex';
    renderTutStep();
}

function renderTutStep() {
    document.getElementById('tut-content').innerHTML = TUT_STEPS[state.tutStep].html;
    document.getElementById('btn-tut-next').textContent =
        state.tutStep === TUT_STEPS.length - 1 ? 'BEGIN' : 'NEXT';
}

document.getElementById('btn-tut-next').addEventListener('click', () => {
    state.tutStep++;
    if (state.tutStep >= TUT_STEPS.length) {
        document.getElementById('tutorial-screen').style.display = 'none';
        markPlayed();
        beginGame();
    } else {
        renderTutStep();
    }
});

// â”€â”€â”€ HINT SYSTEM (TAB) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showHint() {
    if (!state.active || state.enemies.length === 0) return;
    // Find lowest enemy
    let lowest = state.enemies[0];
    for (const e of state.enemies) { if (e.y > lowest.y) lowest = e; }
    const tip = document.getElementById('regex-tip');
    tip.textContent = `â¬‡ Lowest: [${lowest.cat}] "${lowest.text}"`;
    tip.style.opacity = '1';
    setTimeout(() => { tip.style.opacity = '0'; }, 2500);
}

// â”€â”€â”€ GAME LOOP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function gameLoop(ts) {
    if (!state.active) return;
    const dt = Math.min((ts - lastTime) / 1000, 0.1);
    lastTime = ts;

    // Screen shake offset
    let sx = 0, sy = 0;
    if (state.shakeTimer > 0) {
        state.shakeTimer -= dt;
        sx = (Math.random() - 0.5) * state.shakeIntensity * 2;
        sy = (Math.random() - 0.5) * state.shakeIntensity * 2;
        state.shakeIntensity *= 0.92;
    }

    X.save();
    X.translate(sx, sy);
    X.clearRect(-10, -10, W + 20, H + 20);

    // Matrix rain
    drawMatrixRain(dt);

    // Shield at bottom
    drawShield();

    if (!state.waveTransition) {
        // Slow timer
        if (state.slowTimer > 0) {
            state.slowTimer -= dt;
            if (state.slowTimer <= 0) {
                state.enemies.forEach(e => e.speed = e.baseSpeed);
                updatePowerupStatus();
            }
        }

        // Spawning
        if (state.waveEnemiesSpawned < state.waveEnemiesNeeded) {
            state.spawnTimer += dt * 1000;
            if (state.spawnTimer >= state.spawnRate) {
                spawnEnemy();
                state.spawnTimer = 0;
            }
        }

        // Update enemies
        for (let i = state.enemies.length - 1; i >= 0; i--) {
            const e = state.enemies[i];
            if (!e.update(dt)) {
                // Reached bottom
                state.enemies.splice(i, 1);
                sndMiss();
                takeDamage(e.isBoss ? 30 : 10);
                triggerShake(4, 0.2);
            }
        }

        checkWaveComplete();
    }

    // Draw enemies
    for (const e of state.enemies) e.draw();

    // Lasers
    state.lasers = state.lasers.filter(l => { const alive = l.update(); if (alive) l.draw(); return alive; });

    // Particles
    state.particles = state.particles.filter(p => { const alive = p.update(dt); if (alive) p.draw(); return alive; });

    // Float texts
    state.floatTexts = state.floatTexts.filter(f => { const alive = f.update(); if (alive) f.draw(); return alive; });

    X.restore();

    requestAnimationFrame(gameLoop);
}

// â”€â”€â”€ START / GAME OVER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function beginGame() {
    Object.assign(state, {
        active: true, score: 0, wave: 1, health: 100, combo: 0, maxCombo: 0,
        totalMatches: 0, enemies: [], particles: [], lasers: [], floatTexts: [],
        spawnTimer: 0, waveEnemiesSpawned: 0, waveTransition: false,
        challenge: null, shieldHits: 0, slowTimer: 0, shakeTimer: 0,
        categoryStats: {},
    });
    updateHUD();
    updateHealthBar();
    updatePowerupStatus();
    lastTime = performance.now();
    startWave();
    inp.value = '';
    inp.focus();
    requestAnimationFrame(gameLoop);
}

function startGame() {
    initAudio();
    document.getElementById('start-screen').style.display = 'none';
    if (isFirstPlay()) {
        showTutorial();
    } else {
        beginGame();
    }
}

function gameOver() {
    state.active = false;
    stopBgPulse();
    updateLifetimeStats();
    const isNew = addHighScore(state.score, state.wave);

    document.getElementById('final-score').textContent = state.score;
    document.getElementById('final-wave').textContent = state.wave;
    document.getElementById('final-combo').textContent = state.maxCombo;
    document.getElementById('final-new-hs').style.display = isNew ? 'block' : 'none';
    renderHighScores('go-highscores');
    document.getElementById('gameover-screen').style.display = 'flex';
}

// â”€â”€â”€ INPUT HANDLING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
inp.addEventListener('keydown', e => {
    if (e.key === 'Enter') { e.preventDefault(); fireRegex(); }
    if (e.key === 'Tab') { e.preventDefault(); showHint(); }
    inp.classList.remove('error');
});

document.getElementById('btn-start').addEventListener('click', startGame);
document.getElementById('btn-restart').addEventListener('click', () => {
    document.getElementById('gameover-screen').style.display = 'none';
    beginGame();
});

// Keep focus on input
document.addEventListener('click', () => { if (state.active) inp.focus(); });

// â”€â”€â”€ INIT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
renderHighScores('start-highscores');
</script>
</body>
</html>
