<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Virtual Dealer Suite</title>
    <meta name="description" content="A comprehensive card game suite featuring a Virtual Dealer. Play War, Blackjack, and Texas Hold'em against an AI opponent that teaches and challenges you.">
    <meta name="theme-color" content="#1a3c26">
    <style>
        :root {
            --table-color: #2d5e3e;
            --table-dark: #1a3c26;
            --card-width: 100px;
            --card-height: 140px;
            --accent: #ffd700;
            --text-color: #ffffff;
            /* Cycle 19: Unified monospace font for data displays */
            --font-mono: 'Segoe UI Mono', 'Courier New', monospace;
        }

        * {
            box-sizing: border-box;
            user-select: none;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: radial-gradient(circle at center, var(--table-color), var(--table-dark));
            color: var(--text-color);
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* Header & Dealer Area */
        header {
            padding: 15px;
            background: rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .dealer-persona {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .dealer-avatar {
            width: 60px;
            height: 60px;
            background: #333;
            border-radius: 50%;
            border: 2px solid var(--accent);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="45" fill="%23444"/><circle cx="35" cy="40" r="5" fill="white"/><circle cx="65" cy="40" r="5" fill="white"/><path d="M 30 70 Q 50 80 70 70" stroke="white" stroke-width="3" fill="none"/></svg>');
        }

        .dealer-info h2 {
            margin: 0;
            font-size: 1.2rem;
            color: var(--accent);
        }

        .dealer-info p {
            margin: 5px 0 0;
            font-size: 0.9rem;
            opacity: 0.8;
            font-style: italic;
        }

        /* Cycle 4 Consensus: Header Controls & Volume */
        .header-controls {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(0,0,0,0.3);
            padding: 6px 10px;
            border-radius: 20px;
        }

        .volume-icon {
            font-size: 16px;
            cursor: pointer;
        }

        #volume-slider {
            width: 60px;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            cursor: pointer;
        }

        #volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.1s;
        }

        #volume-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        #volume-slider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            border: none;
            cursor: pointer;
        }

        @media (max-width: 600px) {
            .volume-control {
                display: none;
            }
        }

        /* Cycle 5 Consensus: Learn Mode Button */
        .learn-btn {
            padding: 6px 12px !important;
            font-size: 0.85rem !important;
            min-width: auto !important;
        }

        .learn-btn.active {
            background: rgba(76, 175, 80, 0.3);
            border-color: #4caf50;
            color: #4caf50;
        }

        /* Game Selection */
        #game-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.75);
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(3px);
        }

        /* Demo Mode - Background card animations */
        #demo-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 50;
            pointer-events: none;
            overflow: hidden;
        }

        .demo-card {
            position: absolute;
            width: 80px;
            height: 112px;
            background: white;
            border-radius: 6px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 6px;
            font-weight: bold;
            font-size: 18px;
            opacity: 0;
            transform-style: preserve-3d;
        }

        .demo-card.red { color: #d40000; }
        .demo-card.black { color: #000000; }

        .demo-card-corner {
            display: flex;
            flex-direction: column;
            align-items: center;
            line-height: 1;
            font-size: 14px;
        }

        .demo-card-corner.bottom {
            transform: rotate(180deg);
        }

        .demo-card-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 28px;
        }

        .demo-card-back {
            background: repeating-linear-gradient(
                45deg,
                #b71c1c,
                #b71c1c 8px,
                #c62828 8px,
                #c62828 16px
            );
            border: 4px solid white;
        }

        .demo-card-back * { display: none; }

        @keyframes demoCardDeal {
            0% { opacity: 0; transform: translateY(-100px) rotate(-20deg) scale(0.5); }
            20% { opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0; transform: translateY(100vh) rotate(20deg) scale(0.8); }
        }

        @keyframes demoCardFloat {
            0% { opacity: 0; transform: translateY(100vh) rotate(0deg); }
            10% { opacity: 0.9; }
            90% { opacity: 0.9; }
            100% { opacity: 0; transform: translateY(-100px) rotate(360deg); }
        }

        @keyframes demoCardBattle {
            0% { opacity: 0; transform: scale(0.3) rotate(-180deg); }
            30% { opacity: 1; transform: scale(1.1) rotate(0deg); }
            70% { opacity: 1; transform: scale(1) rotate(0deg); }
            100% { opacity: 0; transform: scale(0.5) translateY(50px); }
        }

        .demo-card.dealing {
            animation: demoCardDeal 3s ease-out forwards;
        }

        .demo-card.floating {
            animation: demoCardFloat 4s ease-in-out forwards;
        }

        .demo-card.battling {
            animation: demoCardBattle 2.5s ease-out forwards;
        }

        .menu-title {
            font-size: 3rem;
            margin-bottom: 40px;
            color: var(--accent);
            text-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }

        .game-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            max-width: 900px;
            width: 90%;
        }

        .game-card {
            background: linear-gradient(145deg, #333, #222);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s, border-color 0.2s;
            border: 2px solid transparent;
        }

        .game-card:hover {
            transform: translateY(-5px);
            border-color: var(--accent);
        }

        .game-card h3 {
            font-size: 1.5rem;
            margin-bottom: 10px;
        }

        .game-card p {
            color: #aaa;
            font-size: 0.9rem;
        }

        /* Game Area */
        #game-area {
            flex: 1;
            position: relative;
            display: flex;
            flex-direction: column;
            padding: 20px;
        }

        .table-center {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .hand-area {
            height: 180px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            padding: 10px;
        }

        .dealer-hand {
            align-items: flex-start;
        }

        .player-hand {
            align-items: flex-end;
        }

        /* Cards */
        .card {
            width: var(--card-width);
            height: var(--card-height);
            background: white;
            color: #000000; /* Default black text - prevents white-on-white */
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 10px;
            font-weight: bold;
            font-size: 24px;
            position: relative;
            transition: transform 0.3s, box-shadow 0.2s;
        }

        /* Cycle 5 Consensus: Card Hover Effects */
        .card:hover:not(.card-back) {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 12px 25px rgba(0,0,0,0.35), 0 4px 8px rgba(0,0,0,0.2);
            z-index: 10;
            cursor: pointer;
        }

        .card.red { color: #d40000; }
        .card.black { color: #000000; }

        .card-corner {
            display: flex;
            flex-direction: column;
            align-items: center;
            line-height: 1;
        }

        .card-corner.bottom {
            transform: rotate(180deg);
        }

        .card-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 40px;
        }

        .card-back {
            background: repeating-linear-gradient(
                45deg,
                #b71c1c,
                #b71c1c 10px,
                #c62828 10px,
                #c62828 20px
            );
            border: 5px solid white;
        }

        .card-back * { display: none; }

        /* Controls */
        #controls {
            height: 100px;
            background: rgba(0,0,0,0.2);
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            padding: 0 20px;
        }

        .btn {
            padding: 12px 30px;
            font-size: 1.1rem;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
            min-width: 120px;
        }

        .btn-primary {
            background: var(--accent);
            color: #000;
        }

        .btn-primary:hover {
            background: #ffed4a;
            transform: scale(1.05);
        }

        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .btn-secondary:hover {
            background: rgba(255,255,255,0.2);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Touch Feedback States (Cycle 2 Consensus: Mobile Experience) */
        .btn:active:not(:disabled) {
            transform: scale(0.95);
            filter: brightness(0.9);
        }
        .btn-primary:active:not(:disabled) {
            background: #e6c200;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
        }
        .btn-secondary:active:not(:disabled) {
            background: rgba(255,255,255,0.3);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }

        /* Cycle 17: Visible Focus Indicators (WCAG 2.4.7) */
        .btn:focus-visible,
        .game-card:focus-visible,
        button:focus-visible {
            outline: 3px solid var(--accent);
            outline-offset: 3px;
            box-shadow: 0 0 0 6px rgba(255, 215, 0, 0.3);
        }
        .card:focus-visible,
        .joker-card:focus-visible {
            outline: 3px solid var(--accent);
            outline-offset: 2px;
        }
        .game-card:focus-visible {
            transform: translateY(-5px);
        }

        .game-card:active {
            transform: translateY(-2px) scale(0.98);
            box-shadow: 0 2px 10px rgba(255,215,0,0.4);
        }
        .card:active {
            transform: scale(0.96);
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
        }
        .joker-card:active {
            transform: translateY(-2px) scale(0.97);
        }
        /* Prevent iOS tap highlight */
        * { -webkit-tap-highlight-color: transparent; }
        /* Smooth touch interactions */
        .btn, .game-card, .card, .joker-card {
            touch-action: manipulation;
        }

        .btn-autoplay-active {
            background: linear-gradient(45deg, #e74c3c, #c0392b) !important;
            color: white !important;
            border: 2px solid #ff6b6b !important;
            animation: autoplayPulse 1.5s ease-in-out infinite;
        }

        @keyframes autoplayPulse {
            0%, 100% { box-shadow: 0 0 5px #e74c3c; }
            50% { box-shadow: 0 0 20px #e74c3c, 0 0 30px #ff6b6b; }
        }

        /* Messages */
        #message-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            padding: 20px 40px;
            border-radius: 10px;
            text-align: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 50;
        }

        #message-overlay.visible {
            opacity: 1;
        }

        #message-overlay h2 {
            color: var(--accent);
            font-size: 2rem;
            margin: 0;
        }

        /* Chips */
        .chip-stack {
            position: absolute;
            bottom: 120px;
            right: 20px;
            text-align: right;
        }

        .chip-count {
            font-size: 1.5rem;
            color: var(--accent);
            font-family: var(--font-mono);
            font-weight: bold;
            transition: transform 0.2s, color 0.3s;
        }

        /* Chip Count Animation (Cycle 3 Consensus) */
        .chip-count.counting-up {
            color: #4caf50;
            animation: chipBounce 0.4s ease-out;
        }
        .chip-count.counting-down {
            color: #f44336;
            animation: chipShake 0.4s ease-out;
        }
        @keyframes chipBounce {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.3); }
        }
        @keyframes chipShake {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-4px); }
            40% { transform: translateX(4px); }
            60% { transform: translateX(-3px); }
            80% { transform: translateX(3px); }
        }

        /* Animations */
        @keyframes dealCard {
            from { transform: translateY(-200px) rotate(180deg); opacity: 0; }
            to { transform: translateY(0) rotate(0deg); opacity: 1; }
        }
        @keyframes winToPlayer {
            to { transform: translateY(400px) scale(0.5); opacity: 0; }
        }
        @keyframes winToDealer {
            to { transform: translateY(-400px) scale(0.5); opacity: 0; }
        }
        .dealing { animation: dealCard 0.5s ease-out forwards; }

        /* Staggered Deal Animation (Cycle 2 Consensus) */
        @keyframes staggerDeal {
            0% { transform: translateY(-150px) translateX(50px) rotate(15deg); opacity: 0; }
            60% { transform: translateY(5px) translateX(0) rotate(-3deg); opacity: 1; }
            80% { transform: translateY(-2px) translateX(0) rotate(1deg); }
            100% { transform: translateY(0) translateX(0) rotate(0deg); opacity: 1; }
        }
        .card.stagger-deal {
            animation: staggerDeal 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
            opacity: 0;
        }
        .card.stagger-deal-0 { animation-delay: 0ms; }
        .card.stagger-deal-1 { animation-delay: 80ms; }
        .card.stagger-deal-2 { animation-delay: 160ms; }
        .card.stagger-deal-3 { animation-delay: 240ms; }
        .card.stagger-deal-4 { animation-delay: 320ms; }
        .card.stagger-deal-5 { animation-delay: 400ms; }
        .card.stagger-deal-6 { animation-delay: 480ms; }
        .win-player { animation: winToPlayer 0.6s ease-in forwards; }
        .win-dealer { animation: winToDealer 0.6s ease-in forwards; }

        /* Card Flip Animation (Cycle 3 Consensus) */
        .card {
            transform-style: preserve-3d;
            perspective: 1000px;
        }
        /* Cycle 21: Dynamic shadow during flip for 3D lift effect */
        @keyframes cardFlipToFront {
            0% { transform: rotateY(180deg); box-shadow: 0 2px 10px rgba(0,0,0,0.3); }
            50% { transform: rotateY(90deg); box-shadow: 0 18px 40px rgba(0,0,0,0.25), 0 4px 12px rgba(0,0,0,0.15); }
            100% { transform: rotateY(0deg); box-shadow: 0 2px 10px rgba(0,0,0,0.3); }
        }
        @keyframes cardFlipToBack {
            0% { transform: rotateY(0deg); box-shadow: 0 2px 10px rgba(0,0,0,0.3); }
            50% { transform: rotateY(90deg); box-shadow: 0 18px 40px rgba(0,0,0,0.25), 0 4px 12px rgba(0,0,0,0.15); }
            100% { transform: rotateY(180deg); box-shadow: 0 2px 10px rgba(0,0,0,0.3); }
        }
        .card.flipping-to-front {
            animation: cardFlipToFront 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }
        .card.flipping-to-back {
            animation: cardFlipToBack 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }
        .card.card-back {
            transform: rotateY(180deg);
        }

        /* War Specific UI */
        .war-stats {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            right: 20px;
            text-align: right;
            font-family: var(--font-mono);
            color: var(--accent);
        }

        /* Score Tracker */
        .score-tracker {
            position: fixed;
            top: 80px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            padding: 15px 20px;
            border-radius: 10px;
            border: 1px solid rgba(255,215,0,0.3);
            font-family: var(--font-mono);
            z-index: 100;
            min-width: 150px;
        }
        .score-tracker h4 {
            margin: 0 0 10px 0;
            color: var(--accent);
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .score-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 1rem;
        }
        .score-player { color: #4caf50; }
        .score-dealer { color: #f44336; }
        .score-tie { color: #ffeb3b; }

        /* Tutor Explanation Panel - Right side, never blocks cards */
        .tutor-panel {
            position: fixed;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            background: linear-gradient(145deg, rgba(0,0,0,0.95), rgba(20,20,40,0.95));
            padding: 15px 20px;
            border-radius: 12px;
            border: 2px solid var(--accent);
            box-shadow: 0 0 20px rgba(255,215,0,0.2);
            z-index: 150;
            max-width: 280px;
            width: 280px;
            text-align: left;
            display: none;
            animation: tutorSlideIn 0.3s ease-out;
        }
        @keyframes tutorSlideIn {
            from { opacity: 0; transform: translateY(-50%) translateX(20px); }
            to { opacity: 1; transform: translateY(-50%) translateX(0); }
        }
        .tutor-panel.visible { display: block; }
        .tutor-panel.paused .tutor-progress-bar {
            animation-play-state: paused;
        }
        .tutor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .tutor-panel h3 {
            margin: 0;
            color: var(--accent);
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .tutor-close {
            background: none;
            border: none;
            color: #888;
            font-size: 1.2rem;
            cursor: pointer;
            padding: 0 5px;
            line-height: 1;
            transition: color 0.2s;
        }
        .tutor-close:hover { color: #fff; }
        .tutor-explanation {
            font-size: 0.95rem;
            line-height: 1.5;
            color: #eee;
            margin-bottom: 10px;
        }
        .tutor-explanation .highlight {
            color: var(--accent);
            font-weight: bold;
        }
        .tutor-explanation .win { color: #4caf50; font-weight: bold; }
        .tutor-explanation .lose { color: #f44336; font-weight: bold; }
        .tutor-explanation .tie { color: #ffeb3b; font-weight: bold; }
        .tutor-rule {
            font-size: 0.8rem;
            color: #aaa;
            font-style: italic;
            border-top: 1px solid rgba(255,255,255,0.1);
            padding-top: 8px;
            margin-top: 8px;
        }
        .tutor-progress {
            height: 3px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            margin-top: 10px;
            overflow: hidden;
        }
        .tutor-progress-bar {
            height: 100%;
            background: var(--accent);
            border-radius: 2px;
            animation: tutorProgress 3s linear forwards;
        }
        @keyframes tutorProgress {
            from { width: 100%; }
            to { width: 0%; }
        }

        /* ========== LIVING ART MODE ========== */

        /* Dealer Breathing Animation */
        @keyframes dealerBreathe {
            0%, 100% { transform: scale(1); box-shadow: 0 0 10px rgba(255,215,0,0.3); }
            50% { transform: scale(1.02); box-shadow: 0 0 20px rgba(255,215,0,0.5); }
        }

        @keyframes dealerBlink {
            0%, 90%, 100% { clip-path: inset(0 0 0 0); }
            95% { clip-path: inset(35% 0 55% 0); }
        }

        .living-art-mode .dealer-avatar {
            animation: dealerBreathe 4s ease-in-out infinite;
        }

        /* Particle Canvas */
        #particle-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            opacity: 0;
            transition: opacity 1s ease;
        }
        .living-art-mode #particle-canvas { opacity: 1; }

        /* Felt Breathing */
        @keyframes feltBreathe {
            0%, 100% { background-position: center center; }
            50% { background-position: center calc(50% + 5px); }
        }
        .living-art-mode body {
            animation: feltBreathe 8s ease-in-out infinite;
        }

        /* Light Ray Sweep */
        .light-ray {
            position: fixed;
            top: 0;
            left: -100%;
            width: 200px;
            height: 100%;
            background: linear-gradient(90deg,
                transparent,
                rgba(255,215,0,0.03),
                rgba(255,255,255,0.05),
                rgba(255,215,0,0.03),
                transparent
            );
            transform: skewX(-15deg);
            pointer-events: none;
            z-index: 4;
            opacity: 0;
            transition: opacity 1s;
        }
        .living-art-mode .light-ray {
            opacity: 1;
            animation: lightSweep 20s linear infinite;
        }
        @keyframes lightSweep {
            0% { left: -200px; }
            100% { left: calc(100% + 200px); }
        }

        /* Balatro Card Enhancements */
        .card.foil {
            background: linear-gradient(135deg, #fff 0%, #e8e8e8 25%, #fff 50%, #e8e8e8 75%, #fff 100%);
            box-shadow: 0 0 15px rgba(192, 192, 192, 0.6);
        }
        .card.holographic {
            background: linear-gradient(135deg,
                hsl(0, 100%, 95%) 0%,
                hsl(60, 100%, 95%) 20%,
                hsl(120, 100%, 95%) 40%,
                hsl(180, 100%, 95%) 60%,
                hsl(240, 100%, 95%) 80%,
                hsl(300, 100%, 95%) 100%);
            animation: holoShift 3s linear infinite;
        }
        @keyframes holoShift {
            0%, 100% { filter: hue-rotate(0deg); }
            50% { filter: hue-rotate(360deg); }
        }
        .card.polychrome {
            background: linear-gradient(135deg, #fff, #f0f0ff, #fff);
            box-shadow: 0 0 20px rgba(100, 100, 255, 0.4), inset 0 0 30px rgba(255, 255, 255, 0.8);
        }
        .card.bonus { border: 3px solid #3498db; }
        .card.mult { border: 3px solid #e74c3c; }
        .card.wild { border: 3px solid #9b59b6; }
        .card.glass { opacity: 0.7; background: rgba(255,255,255,0.5); }
        .card.steel { background: linear-gradient(145deg, #bdc3c7, #95a5a6); }
        .card.stone {
            background: linear-gradient(145deg, #7f8c8d, #566573);
            color: white;
        }
        .card.gold {
            background: linear-gradient(145deg, #f1c40f, #d4ac0d);
            box-shadow: 0 0 15px rgba(241, 196, 15, 0.5);
        }

        /* Joker Cards */
        .joker-card {
            width: 80px;
            height: 112px;
            background: linear-gradient(145deg, #9b59b6, #8e44ad);
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(155, 89, 182, 0.4);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 8px;
            color: white;
            font-size: 0.75rem;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .joker-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(155, 89, 182, 0.6);
        }
        .joker-card .joker-icon { font-size: 1.8rem; margin-bottom: 4px; }
        .joker-card .joker-name { font-weight: bold; font-size: 0.65rem; }
        .joker-card.common { background: linear-gradient(145deg, #3498db, #2980b9); }
        .joker-card.uncommon { background: linear-gradient(145deg, #2ecc71, #27ae60); }
        .joker-card.rare { background: linear-gradient(145deg, #e74c3c, #c0392b); }
        .joker-card.legendary {
            background: linear-gradient(145deg, #f39c12, #e67e22);
            animation: legendaryGlow 2s ease-in-out infinite;
        }
        @keyframes legendaryGlow {
            0%, 100% { box-shadow: 0 0 15px rgba(243, 156, 18, 0.5); }
            50% { box-shadow: 0 0 30px rgba(243, 156, 18, 0.8); }
        }

        /* Balatro UI Elements */
        .balatro-hud {
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(0,0,0,0.85);
            border-radius: 12px;
            padding: 15px;
            min-width: 180px;
            z-index: 50;
            border: 1px solid rgba(255,215,0,0.3);
        }
        .balatro-hud h4 {
            margin: 0 0 10px 0;
            color: var(--accent);
            font-size: 0.9rem;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 8px;
        }
        .balatro-stat {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 0.85rem;
        }
        .balatro-stat .label { color: #aaa; }
        .balatro-stat .value { color: #fff; font-weight: bold; }
        .balatro-stat .chips { color: #3498db; }
        .balatro-stat .mult { color: #e74c3c; }

        .joker-slots {
            display: flex;
            gap: 8px;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            margin-top: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .joker-slot-empty {
            width: 80px;
            height: 112px;
            border: 2px dashed rgba(255,255,255,0.2);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255,255,255,0.3);
            font-size: 0.7rem;
        }

        .hand-score-preview {
            position: absolute;
            top: -60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            padding: 8px 16px;
            border-radius: 8px;
            white-space: nowrap;
            font-size: 0.9rem;
            border: 1px solid var(--accent);
        }
        .hand-score-preview .chips { color: #3498db; }
        .hand-score-preview .mult { color: #e74c3c; }

        .card-roster {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.9);
            border-radius: 12px;
            padding: 10px;
            max-width: 400px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 45;
            border: 1px solid rgba(255,215,0,0.2);
            display: none;
        }
        .card-roster.visible { display: block; }
        .card-roster h5 { margin: 0 0 8px 0; color: var(--accent); font-size: 0.8rem; }
        .roster-grid {
            display: grid;
            grid-template-columns: repeat(13, 1fr);
            gap: 2px;
            font-size: 0.6rem;
        }
        .roster-cell {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            cursor: pointer;
        }
        .roster-cell.in-deck { background: rgba(46, 204, 113, 0.3); }
        .roster-cell.in-hand { background: rgba(52, 152, 219, 0.5); }
        .roster-cell.discarded { background: rgba(231, 76, 60, 0.3); opacity: 0.5; }
        .roster-cell.destroyed { background: rgba(0,0,0,0.5); text-decoration: line-through; opacity: 0.3; }
        .roster-cell.red { color: #ff6b6b; }
        .roster-cell.black { color: #fff; }

        /* Card Selection for Balatro */
        /* Cycle 20: Animation with anticipation, overshoot, and follow-through */
        @keyframes cardSelect {
            0% { transform: translateY(0) scale(1); }
            15% { transform: translateY(3px) scaleY(0.97) scaleX(1.02); }
            50% { transform: translateY(-28px) scale(1.02); }
            70% { transform: translateY(-17px) scale(1); }
            100% { transform: translateY(-20px) scale(1); }
        }
        .card.selected {
            animation: cardSelect 0.35s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
            box-shadow: 0 10px 30px rgba(255, 215, 0, 0.5);
            border: 2px solid var(--accent);
        }

        /* Cycle 17: Winning hand glow effect */
        .card.winning-hand {
            box-shadow: 0 0 20px 8px rgba(255, 215, 0, 0.6), 0 0 40px 16px rgba(255, 215, 0, 0.3);
            border: 2px solid #ffd700;
            animation: winningPulse 0.6s ease-in-out 2;
            z-index: 10;
        }
        @keyframes winningPulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 20px 8px rgba(255, 215, 0, 0.6); }
            50% { transform: scale(1.08); box-shadow: 0 0 30px 12px rgba(255, 215, 0, 0.8); }
        }

        /* Cycle 18: Swipe Gesture Feedback Animation */
        @keyframes swipeFade {
            0% { opacity: 1; transform: translateY(-50%) scale(1); }
            100% { opacity: 0; transform: translateY(-50%) scale(1.2); }
        }

        /* Living Art Mode Toggle Button */
        .living-art-toggle {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.6);
            border: 1px solid var(--accent);
            color: var(--accent);
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.85rem;
            z-index: 200;
            transition: all 0.3s;
        }
        .living-art-toggle:hover {
            background: rgba(255,215,0,0.2);
        }
        .living-art-toggle.active {
            background: var(--accent);
            color: #000;
        }

        /* Cycle 7: Focus Mode - Distraction-Free Play */
        .focus-mode header .dealer-persona,
        .focus-mode header .volume-control,
        .focus-mode .score-tracker,
        .focus-mode .tutor-panel,
        .focus-mode .card-roster,
        .focus-mode .balatro-hud,
        .focus-mode .advice-box,
        .focus-mode .living-art-toggle,
        .focus-mode .dealer-thought,
        .focus-mode .session-timer {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        .focus-mode header { background: transparent; border-bottom: none; }
        .focus-mode .score-tracker { opacity: 0.1; }
        .focus-mode .score-tracker:hover { opacity: 1; pointer-events: auto; }

        .focus-toggle {
            position: fixed;
            bottom: 20px;
            left: 80px;
            background: rgba(0,0,0,0.6);
            border: 1px solid #888;
            color: #888;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.85rem;
            z-index: 200;
            transition: all 0.3s;
        }
        .focus-toggle:hover { background: rgba(100,100,100,0.4); border-color: #aaa; }
        .focus-toggle.active { background: rgba(0,100,50,0.6); border-color: #4caf50; color: #4caf50; }

        /* Cycle 7: Session Timer */
        .session-timer {
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(0,0,0,0.3);
            padding: 6px 12px;
            border-radius: 20px;
            font-family: var(--font-mono);
            font-size: 0.9rem;
            color: var(--accent);
        }
        .session-timer .timer-icon { font-size: 14px; }
        .session-timer .timer-value { min-width: 50px; text-align: center; }

        /* Cycle 7: Color Blind Mode */
        .colorblind-mode .card[data-suit="‚ô•"] {
            background-image: repeating-linear-gradient(45deg, transparent, transparent 5px, rgba(200,0,0,0.08) 5px, rgba(200,0,0,0.08) 10px);
        }
        .colorblind-mode .card[data-suit="‚ô¶"] {
            background-image: repeating-linear-gradient(-45deg, transparent, transparent 5px, rgba(200,0,0,0.08) 5px, rgba(200,0,0,0.08) 10px);
        }
        .colorblind-mode .card[data-suit="‚ô£"] {
            background-image: radial-gradient(circle, transparent 3px, rgba(0,0,0,0.05) 3px, rgba(0,0,0,0.05) 5px, transparent 5px);
            background-size: 12px 12px;
        }
        .colorblind-mode .card[data-suit="‚ô†"] {
            background-image: linear-gradient(90deg, transparent 48%, rgba(0,0,0,0.05) 48%, rgba(0,0,0,0.05) 52%, transparent 52%);
            background-size: 8px 8px;
        }
        .colorblind-toggle { margin-left: 8px; }
        .colorblind-toggle.active { background: #9b59b6; color: #fff; }

        /* Cycle 9: Fullscreen Toggle Button */
        .fullscreen-btn {
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.2);
            color: var(--text-color);
            padding: 6px 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.2s;
        }
        .fullscreen-btn:hover { background: rgba(255,255,255,0.1); border-color: var(--accent); }
        .fullscreen-btn.active { background: rgba(100,200,100,0.3); border-color: #4caf50; }

        /* Cycle 10: Turbo Mode - Fast Animation Speed */
        .turbo-btn {
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.2);
            color: var(--text-color);
            padding: 6px 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
        }
        .turbo-btn:hover { background: rgba(255,255,255,0.1); border-color: #ff9800; }
        .turbo-btn.active { background: rgba(255,152,0,0.3); border-color: #ff9800; color: #ff9800; }

        /* Turbo mode animation overrides */
        .turbo-mode .dealing { animation-duration: 0.15s !important; }
        .turbo-mode .stagger-deal { animation-duration: 0.12s !important; }
        .turbo-mode .stagger-deal-1 { animation-delay: 20ms !important; }
        .turbo-mode .stagger-deal-2 { animation-delay: 40ms !important; }
        .turbo-mode .stagger-deal-3 { animation-delay: 60ms !important; }
        .turbo-mode .stagger-deal-4 { animation-delay: 80ms !important; }
        .turbo-mode .stagger-deal-5 { animation-delay: 100ms !important; }
        .turbo-mode .stagger-deal-6 { animation-delay: 120ms !important; }
        .turbo-mode .win-player, .turbo-mode .win-dealer { animation-duration: 0.2s !important; }
        .turbo-mode .card-flip-inner { transition-duration: 0.15s !important; }

        /* Cycle 10: Deck Count Indicator */
        .deck-indicator {
            display: none;
            align-items: center;
            gap: 6px;
            background: rgba(0,0,0,0.3);
            padding: 6px 12px;
            border-radius: 20px;
            font-family: var(--font-mono);
            font-size: 0.85rem;
        }
        .deck-indicator .deck-icon { font-size: 16px; }
        .deck-indicator .deck-count { min-width: 24px; text-align: center; font-weight: bold; }
        .deck-indicator .deck-count.low { color: #f44336; }
        .deck-indicator .deck-count.medium { color: #ff9800; }
        .deck-indicator .deck-count.high { color: var(--accent); }

        /* Cycle 11: Hi-Lo Running Count Display */
        .count-indicator {
            display: none;
            align-items: center;
            gap: 4px;
            background: rgba(0,0,0,0.4);
            padding: 4px 10px;
            border-radius: 15px;
            font-family: var(--font-mono);
            font-size: 0.8rem;
            border: 1px solid rgba(255,255,255,0.2);
        }
        .count-indicator .count-label { color: #888; font-size: 0.7rem; }
        .count-indicator .count-value { font-weight: bold; min-width: 20px; text-align: center; }
        .count-indicator .count-value.positive { color: #4caf50; }
        .count-indicator .count-value.negative { color: #f44336; }
        .count-indicator .count-value.neutral { color: var(--accent); }

        /* Cycle 15: Streak Indicator */
        .streak-indicator {
            display: flex;
            align-items: center;
            gap: 4px;
            background: rgba(0,0,0,0.4);
            padding: 4px 10px;
            border-radius: 15px;
            font-size: 0.85rem;
            border: 1px solid rgba(255,255,255,0.2);
            transition: all 0.3s ease;
        }
        .streak-indicator .streak-icon { font-size: 1rem; }
        .streak-indicator .streak-value { font-weight: bold; min-width: 24px; text-align: center; }
        .streak-indicator.streak-hot {
            background: rgba(255, 107, 53, 0.3);
            border-color: #ff6b35;
            box-shadow: 0 0 12px rgba(255, 107, 53, 0.5);
            animation: hotPulse 1.5s ease-in-out infinite;
        }
        .streak-indicator.streak-hot .streak-value { color: #ff6b35; }
        .streak-indicator.streak-cold {
            background: rgba(0, 212, 255, 0.2);
            border-color: #00d4ff;
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.4);
            animation: coldShimmer 2s ease-in-out infinite;
        }
        .streak-indicator.streak-cold .streak-value { color: #00d4ff; }
        .streak-indicator.streak-neutral .streak-value { color: #888; }
        @keyframes hotPulse {
            0%, 100% { box-shadow: 0 0 8px rgba(255, 107, 53, 0.4); }
            50% { box-shadow: 0 0 16px rgba(255, 107, 53, 0.7); }
        }
        @keyframes coldShimmer {
            0%, 100% { box-shadow: 0 0 6px rgba(0, 212, 255, 0.3); }
            50% { box-shadow: 0 0 12px rgba(0, 212, 255, 0.5); }
        }

        /* Cycle 16: Mistake Tracker Styles */
        .mistake-tracker {
            display: flex;
            align-items: center;
            gap: 4px;
            background: rgba(0,0,0,0.4);
            padding: 4px 10px;
            border-radius: 15px;
            font-size: 0.85rem;
            border: 1px solid rgba(255,255,255,0.2);
            transition: all 0.3s ease;
            cursor: help;
        }
        .mistake-tracker.excellent {
            background: rgba(76, 175, 80, 0.2);
            border-color: #4caf50;
        }
        .mistake-tracker.excellent .tracker-icon { color: #4caf50; }
        .mistake-tracker.excellent .tracker-value { color: #81c784; }
        .mistake-tracker.good {
            background: rgba(255, 193, 7, 0.2);
            border-color: #ffc107;
        }
        .mistake-tracker.good .tracker-icon { color: #ffc107; }
        .mistake-tracker.good .tracker-value { color: #ffd54f; }
        .mistake-tracker.needs-work {
            background: rgba(244, 67, 54, 0.2);
            border-color: #f44336;
        }
        .mistake-tracker.needs-work .tracker-icon { color: #f44336; }
        .mistake-tracker.needs-work .tracker-value { color: #e57373; }

        /* Idle Card Float Animation */
        @keyframes cardFloat {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            25% { transform: translateY(-5px) rotate(0.5deg); }
            75% { transform: translateY(-3px) rotate(-0.5deg); }
        }
        .living-art-mode .card.idle-float {
            animation: cardFloat 6s ease-in-out infinite;
        }

        /* Phantom Cat */
        .phantom-cat {
            position: fixed;
            bottom: 100px;
            left: -100px;
            width: 60px;
            height: 40px;
            z-index: 3;
            opacity: 0.7;
            pointer-events: none;
            font-size: 40px;
            transition: none;
        }
        @keyframes catWalk {
            0% { left: -100px; transform: scaleX(1); }
            45% { left: calc(50% - 30px); transform: scaleX(1); }
            50% { left: calc(50% - 30px); transform: scaleX(1); }
            55% { left: calc(50% - 30px); transform: scaleX(-1); }
            100% { left: calc(100% + 100px); transform: scaleX(-1); }
        }
        .phantom-cat.walking {
            animation: catWalk 12s linear forwards;
        }

        /* Dealer Meta Commentary */
        .dealer-thought {
            position: fixed;
            top: 90px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 10px 20px;
            border-radius: 10px;
            font-style: italic;
            color: #aaa;
            font-size: 0.9rem;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 50;
            max-width: 400px;
            text-align: center;
        }
        .dealer-thought.visible { opacity: 1; }

        .advice-box {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            width: 200px;
            background: rgba(0,0,0,0.6);
            padding: 10px;
            border-radius: 8px;
            border-left: 3px solid var(--accent);
            font-size: 0.9rem;
            display: none;
        }
        .advice-box.visible { display: block; }

        /* Responsive */
        @media (max-width: 768px) {
            :root {
                --card-width: 70px;
                --card-height: 100px;
            }
            
            .game-grid {
                grid-template-columns: 1fr;
            }

            .btn {
                padding: 10px 20px;
                font-size: 0.9rem;
                min-width: auto;
                min-height: 44px; /* Cycle 6: WCAG touch target minimum */
            }

            /* Cycle 21: Touch-friendly header control buttons */
            .fullscreen-btn,
            .turbo-btn,
            .learn-btn {
                min-height: 44px;
                min-width: 44px;
                padding: 8px 12px;
            }
        }

        /* Reduced Motion Support (Cycle 1 Consensus: Accessibility + Performance) */
        @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }

            .dealing,
            .win-player,
            .win-dealer,
            .living-art-mode .dealer-avatar,
            .living-art-mode .card.idle-float,
            .phantom-cat.walking,
            .light-ray,
            .card.holographic,
            .joker-card.legendary,
            .btn-autoplay-active,
            .card.stagger-deal {
                animation: none !important;
            }

            /* Ensure cards are visible when stagger animation is disabled */
            .card.stagger-deal {
                opacity: 1 !important;
            }

            #particle-canvas,
            #celebration-canvas {
                display: none !important;
            }
        }
    </style>
</head>
<body>

    <!-- Demo Mode Layer - Background card animations -->
    <div id="demo-layer" aria-hidden="true"></div>

    <header>
        <div class="dealer-persona">
            <div class="dealer-avatar"></div>
            <div class="dealer-info">
                <h2>The Dealer</h2>
                <p id="dealer-text" aria-live="polite" aria-atomic="true">"Select a game to begin."</p>
            </div>
        </div>
        <!-- Cycle 4 Consensus: Volume Control -->
        <div class="header-controls">
            <!-- Cycle 10: Deck Count Indicator -->
            <div class="deck-indicator" id="deck-indicator" title="Cards remaining in deck">
                <span class="deck-icon">üÉè</span>
                <span class="deck-count high" id="deck-count">52</span>
            </div>
            <!-- Cycle 11: Hi-Lo Running Count -->
            <div class="count-indicator" id="count-indicator" title="Hi-Lo Running Count">
                <span class="count-label">RC:</span>
                <span class="count-value neutral" id="running-count">0</span>
            </div>
            <!-- Cycle 7: Session Timer -->
            <div class="session-timer" id="session-timer" title="Session Duration">
                <span class="timer-icon">‚è±Ô∏è</span>
                <span class="timer-value" id="session-timer-value">00:00</span>
            </div>
            <div class="volume-control" title="Volume">
                <span class="volume-icon">üîä</span>
                <input type="range" id="volume-slider" min="0" max="1" step="0.1" value="0.3"
                    oninput="AudioEngine.setVolume(parseFloat(this.value))" />
            </div>
            <!-- Cycle 5 Consensus: Learn Mode Toggle -->
            <button id="learn-mode-btn" class="btn btn-secondary learn-btn" onclick="LearnMode.toggle()" title="Toggle strategy explanations">üìö Learn</button>
            <!-- Cycle 7: Color Blind Mode Toggle -->
            <button id="colorblind-btn" class="btn btn-secondary colorblind-toggle" onclick="ColorBlindMode.toggle()" title="Toggle suit patterns for color blindness">üëÅ CB</button>
            <!-- Cycle 9: Fullscreen Toggle -->
            <button id="fullscreen-btn" class="fullscreen-btn" onclick="FullscreenToggle.toggle()" title="Toggle fullscreen mode" aria-label="Toggle fullscreen mode">‚õ∂</button>
            <!-- Cycle 10: Turbo Mode Toggle -->
            <button id="turbo-btn" class="turbo-btn" onclick="TurboMode.toggle()" title="Toggle fast animations">‚ö° Turbo</button>
            <button class="btn btn-secondary" onclick="showMenu()">Menu</button>
        </div>
    </header>

    <div id="game-menu">
        <h1 class="menu-title">Virtual Dealer Suite</h1>
        <div class="game-grid" style="grid-template-columns: repeat(2, 1fr);">
            <div class="game-card" tabindex="0" role="button" onclick="startGame('war')" onkeydown="if(event.key==='Enter'||event.key===' '){event.preventDefault();startGame('war')}">
                <h3>War</h3>
                <p>The classic game of chance. High card wins.</p>
            </div>
            <div class="game-card" tabindex="0" role="button" onclick="startGame('blackjack')" onkeydown="if(event.key==='Enter'||event.key===' '){event.preventDefault();startGame('blackjack')}">
                <h3>Blackjack</h3>
                <p>Get closer to 21 than the dealer without going over.</p>
            </div>
            <div class="game-card" tabindex="0" role="button" onclick="startGame('poker')" onkeydown="if(event.key==='Enter'||event.key===' '){event.preventDefault();startGame('poker')}">
                <h3>Texas Hold'em</h3>
                <p>Heads-up poker. Best 5-card hand wins.</p>
            </div>
            <div class="game-card" tabindex="0" role="button" onclick="startGame('balatro')" onkeydown="if(event.key==='Enter'||event.key===' '){event.preventDefault();startGame('balatro')}" style="background: linear-gradient(145deg, #4a2c5f, #2d1b3d); border: 2px solid #9b59b6;">
                <h3 style="color: #e74c3c;">Balatro</h3>
                <p>Roguelike poker! Build hands, collect jokers, beat the blinds.</p>
            </div>
        </div>

        <div style="margin-top: 30px; width: 90%; max-width: 900px;">
            <button class="btn btn-primary" onclick="startTutorMode()" style="width: 100%; padding: 20px; font-size: 1.2rem; background: linear-gradient(45deg, #4a90e2, #003973); border: none;">
                üéì Physical Deck Tutor Mode
                <div style="font-size: 0.8rem; opacity: 0.8; margin-top: 5px; text-transform: none; font-weight: normal;">
                    Use your own real cards! I'll teach you how to play and give advice.
                </div>
            </button>
        </div>

        <div style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #333; text-align: center;">
            <h3 style="margin-bottom: 15px; color: #888;">Data Management</h3>
            <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                <button class="action-btn" onclick="DataManager.save()" style="width: auto; padding: 10px 20px;">Export Save</button>
                <button class="action-btn" onclick="document.getElementById('file-input').click()" style="width: auto; padding: 10px 20px;">Import Save</button>
                <input type="file" id="file-input" style="display: none" onchange="DataManager.load(this)" aria-label="Import save file">
                <!-- Cycle 9: Reset Chips Button -->
                <button class="action-btn" onclick="ChipsManager.reset()" style="width: auto; padding: 10px 20px; background: linear-gradient(145deg, #c0392b, #992d22);">Reset Chips</button>
            </div>
            <p style="margin-top: 10px; font-size: 12px; color: #666;">Progress is automatically saved to your browser.</p>
        </div>
    </div>

    <div id="game-area">
        <div class="hand-area dealer-hand" id="dealer-hand">
            <!-- Dealer cards go here -->
        </div>

        <div class="table-center" id="table-center">
            <div id="message-overlay" role="alert" aria-live="assertive" aria-atomic="true">
                <h2 id="overlay-text">Player Wins!</h2>
            </div>
            <div id="community-cards" class="hand-area" style="display:none;">
                <!-- Community cards for Poker -->
            </div>
        </div>

        <div class="hand-area player-hand" id="player-hand">
            <!-- Player cards go here -->
        </div>

        <div class="chip-stack" id="chip-display" style="display:none;">
            Chips: <span class="chip-count" id="chips">1000</span>
        </div>
    </div>

    <div id="controls">
        <!-- Dynamic controls -->
    </div>

    <!-- Tutor Interface -->
    <div id="tutor-overlay" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 200; flex-direction: column; padding: 20px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h2 style="color: var(--accent); margin: 0;">Physical Deck Tutor</h2>
            <button class="btn btn-secondary" onclick="closeTutor()">Exit Tutor</button>
        </div>
        
        <div id="tutor-menu" style="flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 20px;">
            <h3>Select a game to learn with your cards:</h3>
            <div class="game-grid" style="grid-template-columns: repeat(3, 1fr);">
                <div class="game-card" tabindex="0" role="button" onclick="startTutorGame('war')" onkeydown="if(event.key==='Enter'||event.key===' '){event.preventDefault();startTutorGame('war')}"><h3>War</h3></div>
                <div class="game-card" tabindex="0" role="button" onclick="startTutorGame('blackjack')" onkeydown="if(event.key==='Enter'||event.key===' '){event.preventDefault();startTutorGame('blackjack')}"><h3>Blackjack</h3></div>
                <div class="game-card" tabindex="0" role="button" onclick="startTutorGame('poker')" onkeydown="if(event.key==='Enter'||event.key===' '){event.preventDefault();startTutorGame('poker')}"><h3>Poker</h3></div>
            </div>
        </div>

        <div id="tutor-game" style="display: none; flex: 1; flex-direction: column;">
            <div id="tutor-instructions" style="text-align: center; margin-bottom: 20px; font-size: 1.2rem; color: #ddd;"></div>
            
            <div style="flex: 1; display: flex; gap: 20px;">
                <!-- Card Selector -->
                <div style="width: 300px; background: rgba(255,255,255,0.05); padding: 15px; border-radius: 10px; overflow-y: auto;">
                    <h4 style="margin-top: 0;">Select Card</h4>
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; margin-bottom: 15px;">
                        <button class="btn-suit" onclick="selectSuit('‚ô†')" style="color: white">‚ô†</button>
                        <button class="btn-suit" onclick="selectSuit('‚ô•')" style="color: red">‚ô•</button>
                        <button class="btn-suit" onclick="selectSuit('‚ô£')" style="color: white">‚ô£</button>
                        <button class="btn-suit" onclick="selectSuit('‚ô¶')" style="color: red">‚ô¶</button>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px;">
                        <!-- Ranks generated by JS -->
                        <div id="rank-buttons" style="display: contents;"></div>
                    </div>
                </div>

                <!-- Game State Display -->
                <div style="flex: 1; background: rgba(255,255,255,0.05); padding: 15px; border-radius: 10px; display: flex; flex-direction: column;">
                    <div id="tutor-table" style="flex: 1; display: flex; flex-direction: column; gap: 20px;">
                        <!-- Dynamic table content -->
                    </div>
                    <div id="tutor-advice" style="background: rgba(0,0,0,0.5); padding: 15px; border-radius: 5px; border-left: 4px solid var(--accent); margin-top: 20px;">
                        Waiting for input...
                    </div>
                </div>
            </div>
            
            <div style="margin-top: 20px; display: flex; justify-content: center; gap: 10px;">
                <button class="btn btn-secondary" onclick="resetTutorRound()">Reset Round</button>
                <button class="btn btn-primary" id="tutor-action-btn" onclick="evaluateTutor()">Get Advice</button>
            </div>
        </div>
    </div>

    <style>
        .btn-suit {
            background: #333; border: 1px solid #555; font-size: 1.5rem; padding: 10px; cursor: pointer; border-radius: 5px;
        }
        .btn-suit.selected { background: #555; border-color: var(--accent); }
        .btn-rank {
            background: #333; border: 1px solid #555; padding: 10px; cursor: pointer; border-radius: 5px; color: white;
        }
        .btn-rank.selected { background: var(--accent); color: black; }
        
        .tutor-slot {
            border: 2px dashed #555;
            min-height: 100px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        .tutor-slot:hover { border-color: var(--accent); background: rgba(255,255,255,0.05); }
        .tutor-slot.active { border-color: var(--accent); background: rgba(255,215,0,0.1); }
    </style>

    <script>
        // --- Tutor Mode Logic ---
        let TUTOR = {
            game: null,
            selectedSuit: null,
            selectedRank: null,
            activeSlot: null,
            slots: {}
        };

        function startTutorMode() {
            document.getElementById('tutor-overlay').style.display = 'flex';
            document.getElementById('tutor-menu').style.display = 'flex';
            document.getElementById('tutor-game').style.display = 'none';
            
            // Generate rank buttons
            const rankContainer = document.getElementById('rank-buttons');
            rankContainer.innerHTML = '';
            RANKS.forEach(r => {
                const btn = document.createElement('button');
                btn.className = 'btn-rank';
                btn.textContent = r;
                btn.onclick = () => selectRank(r, btn);
                rankContainer.appendChild(btn);
            });
        }

        function closeTutor() {
            document.getElementById('tutor-overlay').style.display = 'none';
        }

        function startTutorGame(game) {
            TUTOR.game = game;
            document.getElementById('tutor-menu').style.display = 'none';
            document.getElementById('tutor-game').style.display = 'flex';
            resetTutorRound();
        }

        function selectSuit(s) {
            TUTOR.selectedSuit = s;
            document.querySelectorAll('.btn-suit').forEach(b => b.classList.remove('selected'));
            event.target.classList.add('selected');
            checkCardSelection();
        }

        function selectRank(r, btn) {
            TUTOR.selectedRank = r;
            document.querySelectorAll('.btn-rank').forEach(b => b.classList.remove('selected'));
            btn.classList.add('selected');
            checkCardSelection();
        }

        function checkCardSelection() {
            if (TUTOR.selectedSuit && TUTOR.selectedRank && TUTOR.activeSlot) {
                // Create card and place in slot
                const card = new Card(TUTOR.selectedSuit, TUTOR.selectedRank);
                const slotId = TUTOR.activeSlot;
                
                // Store card data
                if (!TUTOR.slots[slotId]) TUTOR.slots[slotId] = [];
                
                // For single card slots, replace. For multi, push.
                const isMulti = slotId.includes('multi');
                if (isMulti) {
                    TUTOR.slots[slotId].push(card);
                } else {
                    TUTOR.slots[slotId] = [card];
                }

                renderTutorSlots();
                
                // Reset selection
                TUTOR.selectedSuit = null;
                TUTOR.selectedRank = null;
                document.querySelectorAll('.btn-suit').forEach(b => b.classList.remove('selected'));
                document.querySelectorAll('.btn-rank').forEach(b => b.classList.remove('selected'));
                
                // Auto-evaluate if enough cards
                evaluateTutor();
            }
        }

        function activateSlot(id) {
            TUTOR.activeSlot = id;
            document.querySelectorAll('.tutor-slot').forEach(s => s.classList.remove('active'));
            document.getElementById(id).classList.add('active');
            document.getElementById('tutor-advice').textContent = `Select a Suit and Rank for ${id.replace('-', ' ')}...`;
        }

        function renderTutorSlots() {
            // Re-render the visual state of slots based on TUTOR.slots
            for (let id in TUTOR.slots) {
                const container = document.getElementById(id);
                if (!container) continue;
                
                container.innerHTML = '';
                const cards = TUTOR.slots[id];
                
                if (cards.length === 0) {
                    container.textContent = `Tap to add ${id.replace('-', ' ')}`;
                } else {
                    cards.forEach(c => {
                        const el = c.render();
                        el.style.transform = 'scale(0.8)';
                        container.appendChild(el);
                    });
                }
            }
        }

        function resetTutorRound() {
            TUTOR.slots = {};
            TUTOR.selectedSuit = null;
            TUTOR.selectedRank = null;
            
            const table = document.getElementById('tutor-table');
            table.innerHTML = '';
            
            if (TUTOR.game === 'war') {
                document.getElementById('tutor-instructions').textContent = "War Tutor: Place both cards to see who wins.";
                table.innerHTML = `
                    <div style="display: flex; gap: 20px; justify-content: center;">
                        <div style="text-align: center;">
                            <h4>Your Card</h4>
                            <div id="player-card" class="tutor-slot" onclick="activateSlot('player-card')">Tap to add</div>
                        </div>
                        <div style="text-align: center;">
                            <h4>Dealer Card</h4>
                            <div id="dealer-card" class="tutor-slot" onclick="activateSlot('dealer-card')">Tap to add</div>
                        </div>
                    </div>
                `;
            } else if (TUTOR.game === 'blackjack') {
                document.getElementById('tutor-instructions').textContent = "Blackjack Tutor: Enter your hand and dealer's up card.";
                table.innerHTML = `
                    <div style="text-align: center;">
                        <h4>Dealer Up Card</h4>
                        <div id="dealer-up" class="tutor-slot" onclick="activateSlot('dealer-up')" style="width: 120px; margin: 0 auto;">Tap to add</div>
                    </div>
                    <div style="text-align: center; margin-top: 20px;">
                        <h4>Your Hand</h4>
                        <div id="player-hand-multi" class="tutor-slot" onclick="activateSlot('player-hand-multi')" style="min-height: 150px;">Tap to add cards</div>
                    </div>
                `;
            } else if (TUTOR.game === 'poker') {
                document.getElementById('tutor-instructions').textContent = "Poker Tutor: Enter your hole cards and community cards.";
                table.innerHTML = `
                    <div style="text-align: center;">
                        <h4>Community Cards</h4>
                        <div id="community-multi" class="tutor-slot" onclick="activateSlot('community-multi')" style="min-height: 120px;">Tap to add cards</div>
                    </div>
                    <div style="text-align: center; margin-top: 20px;">
                        <h4>Your Hole Cards</h4>
                        <div id="hole-cards-multi" class="tutor-slot" onclick="activateSlot('hole-cards-multi')" style="min-height: 150px;">Tap to add cards</div>
                    </div>
                `;
            }
            
            document.getElementById('tutor-advice').textContent = "Select a slot to begin inputting cards.";
        }

        function evaluateTutor() {
            const advice = document.getElementById('tutor-advice');
            
            if (TUTOR.game === 'war') {
                const p = TUTOR.slots['player-card']?.[0];
                const d = TUTOR.slots['dealer-card']?.[0];
                
                if (p && d) {
                    if (p.pokerValue > d.pokerValue) advice.innerHTML = "<span style='color:#4f4'>You Win!</span> Your card is higher.";
                    else if (d.pokerValue > p.pokerValue) advice.innerHTML = "<span style='color:#f44'>Dealer Wins.</span> Their card is higher.";
                    else advice.innerHTML = "<span style='color:#ff4'>It's a Tie!</span> Go to War!";
                }
            } else if (TUTOR.game === 'blackjack') {
                const pHand = TUTOR.slots['player-hand-multi'];
                const dCard = TUTOR.slots['dealer-up']?.[0];
                
                if (pHand && pHand.length >= 2 && dCard) {
                    const score = BlackjackGame.getScore(pHand);
                    const dVal = dCard.value;
                    
                    let msg = `Your score: ${score}. Dealer shows: ${dVal}.<br>`;
                    
                    if (score > 21) msg += "<strong>BUST!</strong> You went over 21.";
                    else if (score === 21) msg += "<strong>BLACKJACK!</strong> Stand and hope for a payout.";
                    else {
                        // Basic Strategy Simplified
                        if (score >= 17) msg += "<strong>STAND.</strong> You have a strong hand.";
                        else if (score <= 11) msg += "<strong>HIT.</strong> Always hit on 11 or less.";
                        else if (score >= 12 && score <= 16) {
                            if (dVal >= 7) msg += "<strong>HIT.</strong> Dealer has a strong up-card.";
                            else msg += "<strong>STAND.</strong> Dealer has a weak up-card, let them bust.";
                        }
                    }
                    advice.innerHTML = msg;
                }
            } else if (TUTOR.game === 'poker') {
                const hole = TUTOR.slots['hole-cards-multi'];
                const comm = TUTOR.slots['community-multi'] || [];
                
                if (hole && hole.length === 2) {
                    const score = PokerGame.evaluate(hole, comm);
                    let msg = "<strong>Hand Analysis:</strong><br>";
                    
                    // Simple pair check for advice
                    const all = [...hole, ...comm];
                    const ranks = all.map(c => c.rank);
                    const hasPair = ranks.some((r, i) => ranks.indexOf(r) !== i);
                    
                    if (hasPair) msg += "You have at least a Pair. Good start.";
                    else if (hole[0].pokerValue > 10 || hole[1].pokerValue > 10) msg += "You have high cards. Playable.";
                    else msg += "Low cards and no pair. Proceed with caution.";
                    
                    if (comm.length === 0) msg += "<br><em>Pre-flop advice: Raise if you have pairs or high cards.</em>";
                    else if (comm.length === 3) msg += "<br><em>Flop advice: Bet if you connected with the board.</em>";
                    
                    advice.innerHTML = msg;
                }
            }
        }

        // --- Timer Management System (Consensus: Performance + Code Quality) ---
        const TimerManager = {
            timers: new Map(),
            intervals: new Map(),

            setTimeout: (callback, delay, id = null) => {
                const timerId = setTimeout(() => {
                    TimerManager.timers.delete(id || timerId);
                    callback();
                }, delay);
                TimerManager.timers.set(id || timerId, timerId);
                return timerId;
            },

            setInterval: (callback, delay, id) => {
                const intervalId = setInterval(callback, delay);
                TimerManager.intervals.set(id, intervalId);
                return intervalId;
            },

            clearTimeout: (id) => {
                const timerId = TimerManager.timers.get(id);
                if (timerId) {
                    clearTimeout(timerId);
                    TimerManager.timers.delete(id);
                }
            },

            clearInterval: (id) => {
                const intervalId = TimerManager.intervals.get(id);
                if (intervalId) {
                    clearInterval(intervalId);
                    TimerManager.intervals.delete(id);
                }
            },

            clearAll: () => {
                TimerManager.timers.forEach((timerId) => clearTimeout(timerId));
                TimerManager.timers.clear();
                TimerManager.intervals.forEach((intervalId) => clearInterval(intervalId));
                TimerManager.intervals.clear();
            }
        };

        // --- Win Celebration System (Consensus: Visual Design) ---
        const WinCelebration = {
            canvas: null,
            ctx: null,
            particles: [],
            animating: false,

            init: () => {
                if (WinCelebration.canvas) return;
                WinCelebration.canvas = document.createElement('canvas');
                WinCelebration.canvas.id = 'celebration-canvas';
                WinCelebration.canvas.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                    pointer-events: none; z-index: 1000;
                `;
                document.body.appendChild(WinCelebration.canvas);
                WinCelebration.resize();
                window.addEventListener('resize', WinCelebration.resize);
            },

            resize: () => {
                if (WinCelebration.canvas) {
                    WinCelebration.canvas.width = window.innerWidth;
                    WinCelebration.canvas.height = window.innerHeight;
                    WinCelebration.ctx = WinCelebration.canvas.getContext('2d');
                }
            },

            burst: (x, y, count = 50) => {
                const colors = ['#ffd700', '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7', '#a29bfe'];
                for (let i = 0; i < count; i++) {
                    const angle = (Math.PI * 2 * i) / count + Math.random() * 0.5;
                    const velocity = 6 + Math.random() * 8;
                    WinCelebration.particles.push({
                        x, y,
                        vx: Math.cos(angle) * velocity,
                        vy: Math.sin(angle) * velocity - 4,
                        size: 3 + Math.random() * 5,
                        color: colors[Math.floor(Math.random() * colors.length)],
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.2,
                        life: 1.0,
                        decay: 0.012 + Math.random() * 0.008,
                        gravity: 0.25,
                        shape: Math.random() > 0.5 ? 'circle' : 'rect'
                    });
                }
                if (!WinCelebration.animating) {
                    WinCelebration.animating = true;
                    WinCelebration.animate();
                }
            },

            animate: () => {
                if (!WinCelebration.ctx) return;
                const ctx = WinCelebration.ctx;
                const w = WinCelebration.canvas.width;
                const h = WinCelebration.canvas.height;

                ctx.clearRect(0, 0, w, h);

                WinCelebration.particles = WinCelebration.particles.filter(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += p.gravity;
                    p.vx *= 0.99;
                    p.rotation += p.rotationSpeed;
                    p.life -= p.decay;

                    if (p.life <= 0) return false;

                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.rotation);
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = p.color;

                    if (p.shape === 'circle') {
                        ctx.beginPath();
                        ctx.arc(0, 0, p.size / 2, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        ctx.fillRect(-p.size / 2, -p.size / 4, p.size, p.size / 2);
                    }
                    ctx.restore();
                    return true;
                });

                if (WinCelebration.particles.length > 0) {
                    requestAnimationFrame(WinCelebration.animate);
                } else {
                    WinCelebration.animating = false;
                }
            },

            celebrate: () => {
                WinCelebration.init();
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 3;
                WinCelebration.burst(centerX, centerY, 60);
                setTimeout(() => {
                    WinCelebration.burst(centerX - 150, centerY + 50, 25);
                    WinCelebration.burst(centerX + 150, centerY + 50, 25);
                }, 100);
            },

            // Cycle 14: Push/tie visual - balanced yellow/gold particles rising and falling
            pushPulse: () => {
                WinCelebration.init();
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;
                const pushColors = ['#ffd700', '#ffeb3b', '#ffc107', '#fff8e1'];

                // Create balanced rising/falling particles
                for (let i = 0; i < 30; i++) {
                    const angle = (Math.PI * 2 * i) / 30;
                    const velocity = 3 + Math.random() * 4;
                    WinCelebration.particles.push({
                        x: centerX, y: centerY,
                        vx: Math.cos(angle) * velocity,
                        vy: Math.sin(angle) * velocity * 0.5, // Lower vertical spread
                        size: 4 + Math.random() * 4,
                        color: pushColors[Math.floor(Math.random() * pushColors.length)],
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.1,
                        life: 1.0,
                        decay: 0.015 + Math.random() * 0.01,
                        gravity: 0.08, // Low gravity for balanced feel
                        shape: 'circle'
                    });
                }
                if (!WinCelebration.animating) {
                    WinCelebration.animating = true;
                    WinCelebration.animate();
                }
            },

            // Cycle 14: Dealer bust celebration - triumphant burst from dealer area
            dealerBustCelebration: () => {
                WinCelebration.init();
                const centerX = window.innerWidth / 2;
                const dealerY = 150; // Near dealer area
                WinCelebration.burst(centerX, dealerY, 80);
                setTimeout(() => {
                    WinCelebration.burst(centerX - 100, dealerY + 30, 30);
                    WinCelebration.burst(centerX + 100, dealerY + 30, 30);
                }, 80);
            },

            // Cycle 16: Blackjack confetti - grand multi-wave explosion for natural 21
            blackjackConfetti: () => {
                WinCelebration.init();
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 3;
                const goldColors = ['#ffd700', '#ffdf00', '#f8d568', '#daa520', '#fff8dc', '#fffacd'];

                // Wave 1: Central explosion (100 particles)
                for (let i = 0; i < 100; i++) {
                    const angle = (Math.PI * 2 * i) / 100 + Math.random() * 0.3;
                    const velocity = 8 + Math.random() * 10;
                    WinCelebration.particles.push({
                        x: centerX, y: centerY,
                        vx: Math.cos(angle) * velocity,
                        vy: Math.sin(angle) * velocity - 5,
                        size: 4 + Math.random() * 6,
                        color: goldColors[Math.floor(Math.random() * goldColors.length)],
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.3,
                        life: 1.0, decay: 0.008 + Math.random() * 0.006,
                        gravity: 0.2, shape: Math.random() > 0.3 ? 'rect' : 'circle'
                    });
                }

                // Wave 2: Side bursts (delayed)
                setTimeout(() => {
                    WinCelebration.burst(centerX - 180, centerY + 60, 50);
                    WinCelebration.burst(centerX + 180, centerY + 60, 50);
                }, 100);

                // Wave 3: Upper fireworks
                setTimeout(() => {
                    WinCelebration.burst(centerX - 100, centerY - 80, 40);
                    WinCelebration.burst(centerX + 100, centerY - 80, 40);
                }, 200);

                if (!WinCelebration.animating) {
                    WinCelebration.animating = true;
                    WinCelebration.animate();
                }
            }
        };

        // --- Audio Engine (Cycle 2 Consensus: Sound Effects) ---
        const AudioEngine = {
            ctx: null,
            enabled: true,
            volume: 0.3,

            init: () => {
                if (AudioEngine.ctx) return;
                try {
                    AudioEngine.ctx = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn('Web Audio API not supported');
                    AudioEngine.enabled = false;
                }
            },

            resume: () => {
                if (AudioEngine.ctx && AudioEngine.ctx.state === 'suspended') {
                    AudioEngine.ctx.resume();
                }
            },

            // Generate a tone with envelope
            playTone: (frequency, duration, type = 'sine', attack = 0.01, decay = 0.1) => {
                if (!AudioEngine.enabled || !AudioEngine.ctx) return;
                AudioEngine.resume();

                const osc = AudioEngine.ctx.createOscillator();
                const gain = AudioEngine.ctx.createGain();
                const now = AudioEngine.ctx.currentTime;

                osc.type = type;
                osc.frequency.setValueAtTime(frequency, now);

                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(AudioEngine.volume, now + attack);
                gain.gain.exponentialRampToValueAtTime(0.001, now + duration);

                osc.connect(gain);
                gain.connect(AudioEngine.ctx.destination);
                osc.start(now);
                osc.stop(now + duration);
            },

            // Card flip/deal sound - quick whoosh with natural variation
            // Cycle 20: Randomized parameters for less robotic repetition
            cardDeal: () => {
                if (!AudioEngine.enabled || !AudioEngine.ctx) return;
                AudioEngine.resume();

                const ctx = AudioEngine.ctx;
                const now = ctx.currentTime;

                // Randomize parameters for natural variation
                const durationVariation = 0.06 + Math.random() * 0.04; // 0.06-0.10 seconds
                const filterVariation = 1800 + Math.random() * 400;    // 1800-2200 Hz
                const gainVariation = 0.35 + Math.random() * 0.1;      // 0.35-0.45 multiplier

                // White noise burst for card snap
                const bufferSize = ctx.sampleRate * durationVariation;
                const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 3);
                }

                const noise = ctx.createBufferSource();
                const filter = ctx.createBiquadFilter();
                const gain = ctx.createGain();

                noise.buffer = buffer;
                filter.type = 'highpass';
                filter.frequency.value = filterVariation;
                gain.gain.setValueAtTime(AudioEngine.volume * gainVariation, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + durationVariation);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(ctx.destination);
                noise.start(now);
            },

            // Chip/coin sound - Cycle 21: Randomized parameters for natural variation
            chipSound: () => {
                // Randomize pitch for natural chip stacking variation
                const basePitch1 = 750 + Math.random() * 100;    // 750-850 Hz
                const basePitch2 = 1100 + Math.random() * 200;   // 1100-1300 Hz
                const delayVariation = 25 + Math.random() * 15;  // 25-40ms between tones
                const dur1 = 0.08 + Math.random() * 0.04;        // 0.08-0.12s
                const dur2 = 0.06 + Math.random() * 0.04;        // 0.06-0.10s

                AudioEngine.playTone(basePitch1, dur1, 'sine', 0.005, 0.05);
                setTimeout(() => AudioEngine.playTone(basePitch2, dur2, 'sine', 0.005, 0.03), delayVariation);
            },

            // Button click feedback
            buttonClick: () => {
                AudioEngine.playTone(600, 0.05, 'square', 0.001, 0.02);
            },

            // Win fanfare - ascending tones
            winFanfare: () => {
                const notes = [523, 659, 784, 1047]; // C5, E5, G5, C6
                notes.forEach((freq, i) => {
                    setTimeout(() => AudioEngine.playTone(freq, 0.2, 'triangle', 0.01, 0.1), i * 100);
                });
            },

            // Lose sound - descending
            loseSound: () => {
                AudioEngine.playTone(330, 0.3, 'sawtooth', 0.01, 0.2);
                setTimeout(() => AudioEngine.playTone(262, 0.4, 'sawtooth', 0.01, 0.3), 150);
            },

            // Cycle 12: Bust sound - dramatic low thud for going over 21
            bustSound: () => {
                if (!AudioEngine.enabled || !AudioEngine.ctx) return;
                AudioEngine.resume();
                AudioEngine.playTone(120, 0.25, 'sine', 0.005, 0.15);
                setTimeout(() => AudioEngine.playTone(80, 0.3, 'triangle', 0.01, 0.2), 50);
            },

            // Cycle 14: Dealer bust fanfare - triumphant celebration when dealer busts
            dealerBustFanfare: () => {
                if (!AudioEngine.enabled || !AudioEngine.ctx) return;
                AudioEngine.resume();
                // Rising triumphant tones - G4, C5, E5, G5, C6
                const notes = [392, 523, 659, 784, 1047];
                notes.forEach((freq, i) => {
                    setTimeout(() => AudioEngine.playTone(freq, 0.25, 'triangle', 0.01, 0.12), i * 80);
                });
            },

            // Cycle 14: Push/tie chime - neutral balanced tone
            pushChime: () => {
                if (!AudioEngine.enabled || !AudioEngine.ctx) return;
                AudioEngine.resume();
                AudioEngine.playTone(440, 0.2, 'sine', 0.01, 0.1); // A4
                setTimeout(() => AudioEngine.playTone(440, 0.2, 'sine', 0.01, 0.1), 150);
            },

            // Cycle 16: Blackjack fanfare - extended triumphant celebration for natural 21
            blackjackFanfare: () => {
                if (!AudioEngine.enabled || !AudioEngine.ctx) return;
                AudioEngine.resume();
                // Grand ascending arpeggio: C5, E5, G5, C6, E6, G6
                const notes = [523, 659, 784, 1047, 1319, 1568];
                notes.forEach((freq, i) => {
                    setTimeout(() => AudioEngine.playTone(freq, 0.3, 'triangle', 0.01, 0.15), i * 70);
                });
                // Final sustained chord
                setTimeout(() => {
                    AudioEngine.playTone(1047, 0.5, 'sine', 0.02, 0.25); // C6
                    AudioEngine.playTone(1319, 0.5, 'sine', 0.02, 0.25); // E6
                    AudioEngine.playTone(1568, 0.5, 'sine', 0.02, 0.25); // G6
                }, 450);
            },

            // Shuffle sound - multiple rapid card sounds
            shuffleSound: () => {
                for (let i = 0; i < 8; i++) {
                    setTimeout(() => AudioEngine.cardDeal(), i * 40);
                }
            },

            // Cycle 17: War game sounds
            warBattle: () => {
                if (!AudioEngine.enabled || !AudioEngine.ctx) return;
                AudioEngine.resume();
                // Two competing tones representing card clash
                AudioEngine.playTone(440, 0.15, 'square', 0.005, 0.08);
                AudioEngine.playTone(554, 0.15, 'square', 0.005, 0.08);
            },
            warVictory: () => {
                if (!AudioEngine.enabled || !AudioEngine.ctx) return;
                AudioEngine.resume();
                // Quick triumphant burst - C5, E5, G5
                const notes = [523, 659, 784];
                notes.forEach((freq, i) => {
                    setTimeout(() => AudioEngine.playTone(freq, 0.15, 'triangle', 0.01, 0.08), i * 50);
                });
            },
            warDefeat: () => {
                if (!AudioEngine.enabled || !AudioEngine.ctx) return;
                AudioEngine.resume();
                // Short descending defeat - E4, C4
                AudioEngine.playTone(330, 0.2, 'sawtooth', 0.01, 0.12);
                setTimeout(() => AudioEngine.playTone(262, 0.25, 'sawtooth', 0.01, 0.15), 100);
            },
            warDeclaration: () => {
                if (!AudioEngine.enabled || !AudioEngine.ctx) return;
                AudioEngine.resume();
                // Dramatic tension-building for WAR! tie situation
                const notes = [220, 277, 330, 415, 523]; // A3, C#4, E4, G#4, C5
                notes.forEach((freq, i) => {
                    setTimeout(() => AudioEngine.playTone(freq, 0.12, 'square', 0.005, 0.06), i * 60);
                });
            },

            // Toggle audio on/off
            toggle: () => {
                AudioEngine.enabled = !AudioEngine.enabled;
                return AudioEngine.enabled;
            },

            // --- Cycle 4 Consensus: Volume Control ---
            setVolume: (newVolume) => {
                AudioEngine.volume = Math.max(0, Math.min(1, newVolume));
                const slider = document.getElementById('volume-slider');
                if (slider) slider.value = AudioEngine.volume;
                localStorage.setItem('vds_audioVolume', AudioEngine.volume);
            },

            loadVolume: () => {
                const saved = localStorage.getItem('vds_audioVolume');
                if (saved !== null) {
                    AudioEngine.volume = parseFloat(saved);
                }
            }
        };

        // Initialize audio on first user interaction
        document.addEventListener('click', () => AudioEngine.init(), { once: true });
        document.addEventListener('touchstart', () => AudioEngine.init(), { once: true });

        // --- Cycle 8: Haptic Feedback Engine (Mobile Vibration) ---
        const HapticEngine = {
            enabled: true,
            init: () => {
                if (!('vibrate' in navigator)) {
                    HapticEngine.enabled = false;
                }
            },
            vibrate: (pattern) => {
                if (!HapticEngine.enabled) return;
                try { navigator.vibrate(pattern); } catch (e) {}
            },
            cardDeal: () => HapticEngine.vibrate(15),
            winCelebration: () => HapticEngine.vibrate([50, 30, 100, 30, 150]),
            loseFeedback: () => HapticEngine.vibrate([100, 50, 100]),
            buttonPress: () => HapticEngine.vibrate(8),
            // Cycle 14: Dealer bust celebration pattern
            dealerBust: () => HapticEngine.vibrate([30, 20, 50, 20, 100, 30, 150]),
            // Cycle 14: Push/tie neutral pattern
            pushFeedback: () => HapticEngine.vibrate([40, 40, 40]),
            // Cycle 16: Blackjack celebration - triple pulse grand pattern
            blackjackCelebration: () => HapticEngine.vibrate([50, 30, 80, 30, 120, 50, 200])
        };
        document.addEventListener('touchstart', () => HapticEngine.init(), { once: true });

        // --- Cycle 18: Swipe-to-Action for Mobile Blackjack ---
        const SwipeGestures = {
            startX: 0,
            startY: 0,
            threshold: 50, // Minimum swipe distance
            maxVertical: 100, // Maximum vertical movement allowed
            enabled: true,
            currentContext: null,

            init: () => {
                const gameArea = document.getElementById('game-area');
                if (!gameArea) return;
                gameArea.addEventListener('touchstart', SwipeGestures.handleTouchStart, { passive: true });
                gameArea.addEventListener('touchend', SwipeGestures.handleTouchEnd, { passive: true });
            },

            setContext: (context) => {
                SwipeGestures.currentContext = context;
            },

            handleTouchStart: (e) => {
                if (!SwipeGestures.enabled || e.touches.length !== 1) return;
                SwipeGestures.startX = e.touches[0].clientX;
                SwipeGestures.startY = e.touches[0].clientY;
            },

            handleTouchEnd: (e) => {
                if (!SwipeGestures.enabled || SwipeGestures.currentContext !== 'blackjack-turn') return;

                const endX = e.changedTouches[0].clientX;
                const endY = e.changedTouches[0].clientY;
                const deltaX = endX - SwipeGestures.startX;
                const deltaY = Math.abs(endY - SwipeGestures.startY);

                // Only process horizontal swipes (vertical movement limited)
                if (deltaY > SwipeGestures.maxVertical) return;

                if (deltaX > SwipeGestures.threshold) {
                    // Swipe RIGHT = Hit (draw more cards)
                    SwipeGestures.executeAction('hit');
                } else if (deltaX < -SwipeGestures.threshold) {
                    // Swipe LEFT = Stand (stop drawing)
                    SwipeGestures.executeAction('stand');
                }
            },

            executeAction: (action) => {
                if (action === 'hit') {
                    const hitBtn = document.querySelector('.controls .btn');
                    if (hitBtn && hitBtn.textContent.toLowerCase().includes('hit')) {
                        HapticEngine.buttonPress();
                        hitBtn.click();
                        SwipeGestures.showFeedback('HIT ‚Üí', 'right');
                    }
                } else if (action === 'stand') {
                    const buttons = document.querySelectorAll('.controls .btn');
                    buttons.forEach(btn => {
                        if (btn.textContent.toLowerCase().includes('stand')) {
                            HapticEngine.buttonPress();
                            btn.click();
                            SwipeGestures.showFeedback('‚Üê STAND', 'left');
                        }
                    });
                }
            },

            showFeedback: (text, direction) => {
                const existing = document.querySelector('.swipe-feedback');
                if (existing) existing.remove();

                const feedback = document.createElement('div');
                feedback.className = 'swipe-feedback';
                feedback.textContent = text;
                feedback.style.cssText = `
                    position: fixed;
                    top: 50%;
                    ${direction === 'right' ? 'right: 20px' : 'left: 20px'};
                    transform: translateY(-50%);
                    background: var(--accent);
                    color: #000;
                    padding: 10px 20px;
                    border-radius: 8px;
                    font-weight: bold;
                    font-size: 1.2rem;
                    z-index: 1000;
                    animation: swipeFade 0.6s ease-out forwards;
                    pointer-events: none;
                `;
                document.body.appendChild(feedback);
                setTimeout(() => feedback.remove(), 600);
            }
        };

        // --- Cycle 4 Consensus: Keyboard Shortcuts ---
        const KeyboardShortcuts = {
            enabled: true,
            currentContext: null, // 'blackjack', 'war', 'poker', 'balatro', 'menu'

            init: () => {
                document.addEventListener('keydown', KeyboardShortcuts.handleKey);
            },

            setContext: (context) => {
                KeyboardShortcuts.currentContext = context;
            },

            handleKey: (e) => {
                if (!KeyboardShortcuts.enabled) return;
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                const key = e.key.toLowerCase();

                // Blackjack shortcuts (H=Hit, S=Stand)
                if (KeyboardShortcuts.currentContext === 'blackjack-turn') {
                    if (key === 'h') {
                        e.preventDefault();
                        const hitBtn = document.querySelector('.controls .btn-primary');
                        if (hitBtn && hitBtn.textContent.toLowerCase().includes('hit')) {
                            hitBtn.click();
                        }
                    } else if (key === 's') {
                        e.preventDefault();
                        const buttons = document.querySelectorAll('.controls .btn');
                        buttons.forEach(btn => {
                            if (btn.textContent.toLowerCase().includes('stand')) {
                                btn.click();
                            }
                        });
                    } else if (key === 'd') {
                        // Cycle 8: Double Down shortcut
                        e.preventDefault();
                        const buttons = document.querySelectorAll('.controls .btn');
                        buttons.forEach(btn => {
                            if (btn.textContent.toLowerCase().includes('double')) {
                                btn.click();
                            }
                        });
                    } else if (key === 'r') {
                        // Cycle 11: Repeat last bet / Cycle 16: Surrender shortcut
                        e.preventDefault();
                        const buttons = document.querySelectorAll('.controls .btn');
                        buttons.forEach(btn => {
                            const text = btn.textContent.toLowerCase();
                            if (text.includes('repeat') || text.includes('surrender')) {
                                btn.click();
                            }
                        });
                    }
                }

                // War shortcut (Space = Draw)
                if (KeyboardShortcuts.currentContext === 'war-draw') {
                    if (key === ' ' || key === 'd') {
                        e.preventDefault();
                        const drawBtn = document.querySelector('.controls .btn-primary');
                        if (drawBtn) drawBtn.click();
                    }
                }

                // Global shortcuts
                if (key === 'm') {
                    e.preventDefault();
                    showMenu();
                } else if (key === 'escape') {
                    showMenu();
                } else if (key === 'f') {
                    // Cycle 7: Focus Mode toggle
                    e.preventDefault();
                    FocusMode.toggle();
                }
            }
        };

        // Initialize keyboard shortcuts and preferences
        document.addEventListener('DOMContentLoaded', () => {
            KeyboardShortcuts.init();
            AudioEngine.loadVolume();
            LearnMode.load(); // Cycle 5: Load learn mode preference
            FocusMode.init(); // Cycle 7: Focus Mode
            ColorBlindMode.init(); // Cycle 7: Color Blind Mode
            FullscreenToggle.init(); // Cycle 9: Fullscreen Toggle
            TurboMode.init(); // Cycle 10: Turbo Mode
            Achievements.init(); // Cycle 10: Achievement System
            StreakBonus.init(); // Cycle 13: Lucky Streak Bonus
            SessionTimer.init(); // Cycle 14: Session Timer Persistence
            StreakIndicator.init(); // Cycle 15: Hot/Cold Streak Indicator
            RebuyManager.init(); // Cycle 15: Auto-Rebuy System
            SwipeGestures.init(); // Cycle 18: Mobile Swipe Gestures
            DeckIndicator.init(); // Cycle 10: Deck Count Indicator
            MistakeTracker.init(); // Cycle 16: Mistake Tracker
            WelcomeModal.init(); // Cycle 20: First-Time Welcome Modal
        });

        // --- Card Flip Animation System (Cycle 3 Consensus) ---
        const CardFlipper = {
            flip: (cardElement, toFaceUp, callback) => {
                if (!cardElement) return;

                const animClass = toFaceUp ? 'flipping-to-front' : 'flipping-to-back';
                cardElement.classList.add(animClass);

                // Play flip sound
                AudioEngine.cardDeal();

                // Update content at midpoint of animation
                setTimeout(() => {
                    if (toFaceUp) {
                        cardElement.classList.remove('card-back');
                    } else {
                        cardElement.classList.add('card-back');
                    }
                    if (callback) callback();
                }, 200);

                // Clean up animation class
                setTimeout(() => {
                    cardElement.classList.remove(animClass);
                }, 400);
            },

            flipById: (cardId, toFaceUp, callback) => {
                const el = document.querySelector(`[data-card-id="${cardId}"]`);
                CardFlipper.flip(el, toFaceUp, callback);
            }
        };

        // --- DOM Safety Helper (Cycle 3 Consensus) ---
        const safeElement = (id) => {
            const el = document.getElementById(id);
            if (!el) console.warn(`Element not found: ${id}`);
            return el;
        };

        const safeQuery = (selector) => {
            const el = document.querySelector(selector);
            if (!el) console.warn(`Element not found: ${selector}`);
            return el;
        };

        // --- Chip Animation System (Cycle 3 Consensus) ---
        const ChipAnimator = {
            lastValue: 0,

            init: () => {
                ChipAnimator.lastValue = STATE.chips;
            },

            animate: (newValue) => {
                const el = document.getElementById('chips');
                if (!el) return;

                const oldValue = ChipAnimator.lastValue;
                const diff = newValue - oldValue;
                if (diff === 0) {
                    el.textContent = newValue;
                    return;
                }

                const isGain = diff > 0;
                const steps = Math.min(Math.abs(diff), 15);
                const stepValue = diff / steps;
                const duration = 400;
                const stepTime = duration / steps;

                el.classList.remove('counting-up', 'counting-down');
                void el.offsetWidth; // Force reflow
                el.classList.add(isGain ? 'counting-up' : 'counting-down');

                let current = oldValue;
                let step = 0;

                const interval = setInterval(() => {
                    step++;
                    current += stepValue;
                    el.textContent = Math.round(current);

                    if (step >= steps) {
                        clearInterval(interval);
                        el.textContent = newValue;
                        AudioEngine.chipSound();
                        setTimeout(() => {
                            el.classList.remove('counting-up', 'counting-down');
                        }, 300);
                    }
                }, stepTime);

                ChipAnimator.lastValue = newValue;
            },

            update: () => {
                ChipAnimator.animate(STATE.chips);
            }
        };

        // --- Game State ---
        const STATE = {
            game: null,
            deck: [],
            playerHand: [],
            dealerHand: [],
            communityCards: [],
            chips: 1000,
            sessionStartChips: 1000, // Cycle 13: Session profit tracking
            sessionHigh: 1000, // Cycle 13: Session high watermark
            sessionLow: 1000, // Cycle 13: Session low watermark
            bet: 0,
            lastBet: 0, // Cycle 11: Track last bet for repeat button
            sideBet: 0, // Cycle 11: Perfect Pairs side bet
            phase: 'idle', // idle, dealing, playing, resolving
            messageTimer: null,
            autoplay: false,
            autoplayDelay: 1500, // ms between autoplay actions
            learnMode: false, // Cycle 5 Consensus: Learn Mode for manual tutoring
            scores: {
                player: 0,
                dealer: 0,
                ties: 0
            },
            // Cycle 14: Session timer persistence
            sessionStartTime: Date.now(),
            sessionElapsed: 0
        };

        // Cycle 5 Consensus: Learn Mode Toggle
        const LearnMode = {
            toggle: () => {
                STATE.learnMode = !STATE.learnMode;
                LearnMode.updateIndicator();
                localStorage.setItem('vds_learnMode', STATE.learnMode);
                if (STATE.learnMode) {
                    updateDealer("Learn Mode ON - I'll explain each decision.");
                } else {
                    updateDealer("Learn Mode OFF - Play at your own pace.");
                }
            },
            load: () => {
                const saved = localStorage.getItem('vds_learnMode');
                STATE.learnMode = saved === 'true';
                LearnMode.updateIndicator();
            },
            updateIndicator: () => {
                const btn = document.getElementById('learn-mode-btn');
                if (btn) {
                    btn.classList.toggle('active', STATE.learnMode);
                    btn.textContent = STATE.learnMode ? 'üìö Learn ON' : 'üìö Learn';
                }
            }
        };

        // --- Card Roster System ---
        // Tracks every card's location and state across all games
        const CardRoster = {
            cards: new Map(), // id -> Card object
            locations: {
                deck: [],
                playerHand: [],
                dealerHand: [],
                community: [],
                discarded: [],
                destroyed: [],
                played: []
            },

            init: () => {
                CardRoster.cards.clear();
                Object.keys(CardRoster.locations).forEach(k => CardRoster.locations[k] = []);
            },

            register: (card) => {
                CardRoster.cards.set(card.id, card);
                CardRoster.locations.deck.push(card.id);
                card.location = 'deck';
            },

            move: (cardId, from, to) => {
                const card = CardRoster.cards.get(cardId);
                if (!card) return;

                const fromArr = CardRoster.locations[from];
                const idx = fromArr.indexOf(cardId);
                if (idx > -1) fromArr.splice(idx, 1);

                CardRoster.locations[to].push(cardId);
                card.location = to;
            },

            getByLocation: (location) => {
                return CardRoster.locations[location].map(id => CardRoster.cards.get(id)).filter(Boolean);
            },

            getCard: (id) => CardRoster.cards.get(id),

            enhance: (cardId, enhancement) => {
                const card = CardRoster.cards.get(cardId);
                if (card) card.enhancement = enhancement;
            },

            destroy: (cardId) => {
                const card = CardRoster.cards.get(cardId);
                if (card) {
                    CardRoster.move(cardId, card.location, 'destroyed');
                }
            },

            renderUI: () => {
                let panel = document.getElementById('card-roster-panel');
                if (!panel) {
                    panel = document.createElement('div');
                    panel.id = 'card-roster-panel';
                    panel.className = 'card-roster';
                    panel.innerHTML = '<h5>Card Roster <button onclick="CardRoster.hide()" style="float:right;background:none;border:none;color:#fff;cursor:pointer;">√ó</button></h5><div class="roster-content"></div>';
                    document.body.appendChild(panel);
                }

                const content = panel.querySelector('.roster-content');
                let html = '';

                SUITS.forEach(suit => {
                    const isRed = suit === '‚ô•' || suit === '‚ô¶';
                    html += `<div style="margin-bottom:8px;"><strong style="color:${isRed ? '#ff6b6b' : '#fff'}">${suit}</strong><div class="roster-grid">`;
                    RANKS.forEach(rank => {
                        const id = `${suit}${rank}`;
                        const card = CardRoster.cards.get(id);
                        let cls = 'roster-cell ' + (isRed ? 'red' : 'black');
                        if (card) {
                            cls += ` ${card.location === 'deck' ? 'in-deck' : ''}`;
                            cls += ` ${card.location === 'playerHand' ? 'in-hand' : ''}`;
                            cls += ` ${card.location === 'discarded' ? 'discarded' : ''}`;
                            cls += ` ${card.location === 'destroyed' ? 'destroyed' : ''}`;
                        }
                        html += `<div class="${cls}" title="${rank}${suit} - ${card?.location || 'unknown'}">${rank}</div>`;
                    });
                    html += '</div></div>';
                });

                content.innerHTML = html;
            },

            show: () => {
                CardRoster.renderUI();
                document.getElementById('card-roster-panel')?.classList.add('visible');
            },

            hide: () => {
                document.getElementById('card-roster-panel')?.classList.remove('visible');
            },

            toggle: () => {
                const panel = document.getElementById('card-roster-panel');
                if (panel?.classList.contains('visible')) CardRoster.hide();
                else CardRoster.show();
            }
        };

        // --- Joker System for Balatro ---
        class Joker {
            constructor(config) {
                this.id = config.id;
                this.name = config.name;
                this.description = config.description;
                this.rarity = config.rarity || 'common'; // common, uncommon, rare, legendary
                this.effect = config.effect; // function(hand, score) => modifiedScore
                this.icon = config.icon || 'üÉè';
                this.cost = config.cost || 4;
                this.sellValue = Math.floor(this.cost / 2);
            }

            render() {
                const el = document.createElement('div');
                el.className = `joker-card ${this.rarity}`;
                el.innerHTML = `
                    <div class="joker-icon">${this.icon}</div>
                    <div class="joker-name">${this.name}</div>
                `;
                el.title = this.description;
                return el;
            }
        }

        // Joker Library
        const JOKER_LIBRARY = [
            new Joker({ id: 'joker', name: 'Joker', description: '+4 Mult', rarity: 'common', icon: 'üÉè',
                effect: (hand, score) => ({ chips: score.chips, mult: score.mult + 4 }) }),
            new Joker({ id: 'greedy', name: 'Greedy Joker', description: '+3 Mult for each ‚ô¶ played', rarity: 'common', icon: 'üíé',
                effect: (hand, score) => ({ chips: score.chips, mult: score.mult + hand.filter(c => c.suit === '‚ô¶').length * 3 }) }),
            new Joker({ id: 'lusty', name: 'Lusty Joker', description: '+3 Mult for each ‚ô• played', rarity: 'common', icon: '‚ù§Ô∏è',
                effect: (hand, score) => ({ chips: score.chips, mult: score.mult + hand.filter(c => c.suit === '‚ô•').length * 3 }) }),
            new Joker({ id: 'wrathful', name: 'Wrathful Joker', description: '+3 Mult for each ‚ô† played', rarity: 'common', icon: '‚öîÔ∏è',
                effect: (hand, score) => ({ chips: score.chips, mult: score.mult + hand.filter(c => c.suit === '‚ô†').length * 3 }) }),
            new Joker({ id: 'glutton', name: 'Gluttonous Joker', description: '+3 Mult for each ‚ô£ played', rarity: 'common', icon: 'üçÄ',
                effect: (hand, score) => ({ chips: score.chips, mult: score.mult + hand.filter(c => c.suit === '‚ô£').length * 3 }) }),
            new Joker({ id: 'banner', name: 'Banner', description: '+30 Chips for each discard remaining', rarity: 'common', icon: 'üö©',
                effect: (hand, score, state) => ({ chips: score.chips + (state.discardsLeft * 30), mult: score.mult }) }),
            new Joker({ id: 'mystic', name: 'Mystic Summit', description: '+15 Mult when 0 discards remain', rarity: 'common', icon: 'üèîÔ∏è',
                effect: (hand, score, state) => ({ chips: score.chips, mult: score.mult + (state.discardsLeft === 0 ? 15 : 0) }) }),
            new Joker({ id: 'fibonacci', name: 'Fibonacci', description: '+8 Mult for each 2,3,5,8,A played', rarity: 'uncommon', icon: 'üêö',
                effect: (hand, score) => {
                    const fibRanks = ['2','3','5','8','A'];
                    const count = hand.filter(c => fibRanks.includes(c.rank)).length;
                    return { chips: score.chips, mult: score.mult + count * 8 };
                }}),
            new Joker({ id: 'scholar', name: 'Scholar', description: '+20 Chips, +4 Mult for each Ace played', rarity: 'uncommon', icon: 'üìö',
                effect: (hand, score) => {
                    const aces = hand.filter(c => c.rank === 'A').length;
                    return { chips: score.chips + aces * 20, mult: score.mult + aces * 4 };
                }}),
            new Joker({ id: 'blueprint', name: 'Blueprint', description: 'Copies ability of Joker to the right', rarity: 'rare', icon: 'üìã',
                effect: (hand, score, state, jokers, idx) => {
                    if (idx < jokers.length - 1) {
                        return jokers[idx + 1].effect(hand, score, state, jokers, idx + 1);
                    }
                    return score;
                }}),
            new Joker({ id: 'dna', name: 'DNA', description: 'If first hand has only 1 card, copy it to hand', rarity: 'rare', icon: 'üß¨',
                effect: (hand, score) => score }),
            new Joker({ id: 'cavendish', name: 'Cavendish', description: 'x3 Mult. 1/1000 chance to be destroyed', rarity: 'legendary', icon: 'üçå',
                effect: (hand, score) => ({ chips: score.chips, mult: score.mult * 3 }), cost: 8 }),
        ];

        // Balatro Hand Types with base values
        const BALATRO_HANDS = {
            'High Card':      { chips: 5, mult: 1, level: 1 },
            'Pair':           { chips: 10, mult: 2, level: 1 },
            'Two Pair':       { chips: 20, mult: 2, level: 1 },
            'Three of a Kind':{ chips: 30, mult: 3, level: 1 },
            'Straight':       { chips: 30, mult: 4, level: 1 },
            'Flush':          { chips: 35, mult: 4, level: 1 },
            'Full House':     { chips: 40, mult: 4, level: 1 },
            'Four of a Kind': { chips: 60, mult: 7, level: 1 },
            'Straight Flush': { chips: 100, mult: 8, level: 1 },
            'Royal Flush':    { chips: 100, mult: 8, level: 1 },
            'Five of a Kind': { chips: 120, mult: 12, level: 1 },
            'Flush House':    { chips: 140, mult: 14, level: 1 },
            'Flush Five':     { chips: 160, mult: 16, level: 1 }
        };

        // --- Score Tracking System ---
        const ScoreTracker = {
            show: () => {
                let tracker = document.getElementById('score-tracker');
                if (!tracker) {
                    tracker = document.createElement('div');
                    tracker.id = 'score-tracker';
                    tracker.className = 'score-tracker';
                    document.body.appendChild(tracker);
                }
                tracker.style.display = 'block';
                ScoreTracker.update();
            },
            hide: () => {
                const tracker = document.getElementById('score-tracker');
                if (tracker) tracker.style.display = 'none';
            },
            update: () => {
                const tracker = document.getElementById('score-tracker');
                if (!tracker) return;
                // Cycle 9: Calculate win rate percentage
                const total = STATE.scores.player + STATE.scores.dealer + STATE.scores.ties;
                const winRate = total > 0 ? ((STATE.scores.player / total) * 100).toFixed(1) : '0.0';
                // Cycle 13: Session profit calculation
                const profit = STATE.chips - STATE.sessionStartChips;
                const profitColor = profit >= 0 ? '#4caf50' : '#f44336';
                const profitSign = profit >= 0 ? '+' : '';
                if (STATE.chips > STATE.sessionHigh) STATE.sessionHigh = STATE.chips;
                if (STATE.chips < STATE.sessionLow) STATE.sessionLow = STATE.chips;
                tracker.innerHTML = `
                    <h4>Session Score</h4>
                    <div class="score-row">
                        <span class="score-player">Player:</span>
                        <span class="score-player">${STATE.scores.player}</span>
                    </div>
                    <div class="score-row">
                        <span class="score-dealer">Dealer:</span>
                        <span class="score-dealer">${STATE.scores.dealer}</span>
                    </div>
                    <div class="score-row">
                        <span class="score-tie">Ties:</span>
                        <span class="score-tie">${STATE.scores.ties}</span>
                    </div>
                    <div class="score-row" style="margin-top: 8px; border-top: 1px solid rgba(255,255,255,0.2); padding-top: 8px;">
                        <span style="color: var(--accent);">Win Rate:</span>
                        <span style="color: var(--accent); font-weight: bold;">${winRate}%</span>
                    </div>
                    <div class="score-row">
                        <span style="color: #aaa;">Hands Played:</span>
                        <span style="color: #fff; font-weight: bold;">${total}</span>
                    </div>
                    <div class="score-row" style="margin-top: 8px; border-top: 1px solid rgba(255,255,255,0.2); padding-top: 8px;">
                        <span style="color: ${profitColor};">Session P/L:</span>
                        <span style="color: ${profitColor}; font-weight: bold;">${profitSign}${profit}</span>
                    </div>
                    <div class="score-row" style="color: #888; font-size: 0.85em;">
                        <span>High: ${STATE.sessionHigh}</span>
                        <span>Low: ${STATE.sessionLow}</span>
                    </div>
                    <div class="score-row" style="margin-top: 8px; border-top: 1px solid rgba(255,255,255,0.2); padding-top: 8px;">
                        <span style="color: #9e9e9e;">Session Time:</span>
                        <span style="color: #fff; font-weight: bold;">${SessionTimer.formatTime(STATE.sessionElapsed)}</span>
                    </div>
                `;
            },
            playerWin: () => {
                STATE.scores.player++;
                ScoreTracker.update();
                DataManager.autoSave();
                WinCelebration.celebrate(); // Cycle 1 consensus feature
                AudioEngine.winFanfare(); // Cycle 2 consensus feature
                HapticEngine.winCelebration(); // Cycle 8 haptic feedback
                Achievements.onWin(); // Cycle 10: Check achievement progress
                StreakBonus.checkAndAward(); // Cycle 13: Lucky streak bonus
            },
            dealerWin: () => {
                STATE.scores.dealer++;
                Achievements.onLoss(); // Cycle 10: Reset win streak
                ScoreTracker.update();
                DataManager.autoSave();
                AudioEngine.loseSound(); // Cycle 2 consensus feature
                HapticEngine.loseFeedback(); // Cycle 8 haptic feedback
            },
            tie: () => {
                STATE.scores.ties++;
                ScoreTracker.update();
                DataManager.autoSave();
            },
            reset: () => {
                STATE.scores = { player: 0, dealer: 0, ties: 0 };
                ScoreTracker.update();
                DataManager.autoSave();
            }
        };

        // --- Tutoring System ---
        const TutoringSystem = {
            explanationDuration: 3500, // How long to show each explanation
            currentTimer: null,
            currentResolve: null,
            isPaused: false,

            ensurePanel: () => {
                let panel = document.getElementById('tutor-panel');
                if (!panel) {
                    panel = document.createElement('div');
                    panel.id = 'tutor-panel';
                    panel.className = 'tutor-panel';
                    document.body.appendChild(panel);

                    // Pause on hover
                    panel.addEventListener('mouseenter', () => {
                        TutoringSystem.pause();
                    });

                    // Resume on mouse leave (if not manually closed)
                    panel.addEventListener('mouseleave', () => {
                        TutoringSystem.resume();
                    });
                }
                return panel;
            },

            show: (title, explanation, rule, duration = null) => {
                // Cycle 5: Also show tutoring in Learn Mode
                if (!STATE.autoplay && !STATE.learnMode) return Promise.resolve();

                // Clear any existing timer
                if (TutoringSystem.currentTimer) {
                    clearTimeout(TutoringSystem.currentTimer);
                    TutoringSystem.currentTimer = null;
                }

                const panel = TutoringSystem.ensurePanel();
                const dur = duration || TutoringSystem.explanationDuration;
                TutoringSystem.isPaused = false;
                panel.classList.remove('paused');

                panel.innerHTML = `
                    <div class="tutor-header">
                        <h3>${title}</h3>
                        <button class="tutor-close" onclick="TutoringSystem.close()">&times;</button>
                    </div>
                    <div class="tutor-explanation">${explanation}</div>
                    ${rule ? `<div class="tutor-rule">${rule}</div>` : ''}
                    <div class="tutor-progress">
                        <div class="tutor-progress-bar" style="animation-duration: ${dur}ms;"></div>
                    </div>
                `;
                panel.classList.add('visible');

                return new Promise(resolve => {
                    TutoringSystem.currentResolve = resolve;
                    TutoringSystem.currentTimer = setTimeout(() => {
                        if (!TutoringSystem.isPaused) {
                            panel.classList.remove('visible');
                            TutoringSystem.currentTimer = null;
                            TutoringSystem.currentResolve = null;
                            resolve();
                        }
                    }, dur);
                });
            },

            pause: () => {
                TutoringSystem.isPaused = true;
                const panel = document.getElementById('tutor-panel');
                if (panel) panel.classList.add('paused');
                if (TutoringSystem.currentTimer) {
                    clearTimeout(TutoringSystem.currentTimer);
                    TutoringSystem.currentTimer = null;
                }
            },

            resume: () => {
                if (!TutoringSystem.isPaused) return;
                TutoringSystem.isPaused = false;
                const panel = document.getElementById('tutor-panel');
                if (panel) panel.classList.remove('paused');
                // Auto-close after a short delay when mouse leaves
                TutoringSystem.currentTimer = setTimeout(() => {
                    TutoringSystem.close();
                }, 1000);
            },

            close: () => {
                TutoringSystem.isPaused = false;
                if (TutoringSystem.currentTimer) {
                    clearTimeout(TutoringSystem.currentTimer);
                    TutoringSystem.currentTimer = null;
                }
                const panel = document.getElementById('tutor-panel');
                if (panel) {
                    panel.classList.remove('visible');
                    panel.classList.remove('paused');
                }
                if (TutoringSystem.currentResolve) {
                    TutoringSystem.currentResolve();
                    TutoringSystem.currentResolve = null;
                }
            },

            hide: () => {
                TutoringSystem.close();
            }
        };

        // --- Living Art Mode System (Cycle 4: Lazy Loading) ---
        const LivingArtMode = {
            active: false,
            initialized: false, // Cycle 4: Track lazy init state
            particleCanvas: null,
            particleCtx: null,
            particles: [],
            animationFrame: null,
            blinkInterval: null,
            metaInterval: null,
            chaosInterval: null,

            // Dealer meta-commentary phrases
            metaPhrases: [
                "I wonder if the cards ever get tired of being shuffled...",
                "They say luck is just probability taken personally.",
                "In another timeline, that ace was yours.",
                "The felt remembers every hand ever played here.",
                "Sometimes I deal to ghosts. They're very patient.",
                "Every shuffle is the first time those cards have been in that order.",
                "I've been here longer than the building, you know.",
                "The chips have their own gravity. They always return to the house.",
                "Do you ever wonder what I do when you're not here?",
                "Time moves differently at the table. Always has.",
                "The old dealers used to say the cards can feel fear.",
                "I've seen fortunes made and lost on the turn of a single card.",
                "The house always wins... but sometimes it lets you borrow victory.",
            ],

            // Cycle 4 Consensus: Lazy init - only creates toggle button
            init: () => {
                // Create toggle button (lightweight - no canvas yet)
                const toggle = document.createElement('button');
                toggle.className = 'living-art-toggle';
                toggle.textContent = '‚ú® Living Art';
                toggle.onclick = LivingArtMode.toggle;
                document.body.appendChild(toggle);
            },

            // Cycle 4: Full initialization on first use
            initFull: () => {
                if (LivingArtMode.initialized) return;
                LivingArtMode.initialized = true;

                // Create particle canvas
                LivingArtMode.particleCanvas = document.createElement('canvas');
                LivingArtMode.particleCanvas.id = 'particle-canvas';
                document.body.appendChild(LivingArtMode.particleCanvas);

                // Create light ray
                const lightRay = document.createElement('div');
                lightRay.className = 'light-ray';
                document.body.appendChild(lightRay);

                // Create dealer thought bubble
                const thought = document.createElement('div');
                thought.className = 'dealer-thought';
                thought.id = 'dealer-thought';
                document.body.appendChild(thought);

                // Resize handler
                window.addEventListener('resize', LivingArtMode.resizeCanvas);
                LivingArtMode.resizeCanvas();
            },

            toggle: () => {
                // Cycle 4: Lazy load on first toggle
                LivingArtMode.initFull();

                LivingArtMode.active = !LivingArtMode.active;
                document.body.classList.toggle('living-art-mode', LivingArtMode.active);

                const btn = document.querySelector('.living-art-toggle');
                btn.classList.toggle('active', LivingArtMode.active);
                btn.textContent = LivingArtMode.active ? '‚ú® Living Art ON' : '‚ú® Living Art';

                if (LivingArtMode.active) {
                    LivingArtMode.start();
                } else {
                    LivingArtMode.stop();
                }
            },

            start: () => {
                // Initialize particles
                LivingArtMode.particles = [];
                for (let i = 0; i < 30; i++) {
                    LivingArtMode.particles.push(LivingArtMode.createParticle());
                }

                // Start animation loop
                LivingArtMode.animate();

                // Start dealer blink timer
                LivingArtMode.scheduleBlink();

                // Start meta commentary timer
                LivingArtMode.metaInterval = setInterval(() => {
                    if (Math.random() < 0.15) { // 15% chance every 30 seconds
                        LivingArtMode.showMetaThought();
                    }
                }, 30000);

                // Start chaos events timer
                LivingArtMode.chaosInterval = setInterval(() => {
                    LivingArtMode.maybeTriggerChaos();
                }, 45000);
            },

            stop: () => {
                if (LivingArtMode.animationFrame) {
                    cancelAnimationFrame(LivingArtMode.animationFrame);
                }
                if (LivingArtMode.blinkInterval) {
                    clearTimeout(LivingArtMode.blinkInterval);
                }
                if (LivingArtMode.metaInterval) {
                    clearInterval(LivingArtMode.metaInterval);
                }
                if (LivingArtMode.chaosInterval) {
                    clearInterval(LivingArtMode.chaosInterval);
                }
                LivingArtMode.particles = [];
                const thought = document.getElementById('dealer-thought');
                if (thought) thought.classList.remove('visible');
            },

            resizeCanvas: () => {
                if (LivingArtMode.particleCanvas) {
                    LivingArtMode.particleCanvas.width = window.innerWidth;
                    LivingArtMode.particleCanvas.height = window.innerHeight;
                    LivingArtMode.particleCtx = LivingArtMode.particleCanvas.getContext('2d');
                }
            },

            createParticle: () => ({
                x: Math.random() * window.innerWidth,
                y: Math.random() * window.innerHeight,
                size: Math.random() * 2 + 1,
                speedX: (Math.random() - 0.5) * 0.3,
                speedY: -Math.random() * 0.2 - 0.1,
                opacity: Math.random() * 0.5 + 0.2,
                twinkle: Math.random() * Math.PI * 2
            }),

            animate: () => {
                if (!LivingArtMode.active) return;

                const ctx = LivingArtMode.particleCtx;
                const w = LivingArtMode.particleCanvas.width;
                const h = LivingArtMode.particleCanvas.height;

                ctx.clearRect(0, 0, w, h);

                // Draw and update particles (dust motes)
                LivingArtMode.particles.forEach(p => {
                    p.x += p.speedX;
                    p.y += p.speedY;
                    p.twinkle += 0.02;

                    // Wrap around screen
                    if (p.y < -10) p.y = h + 10;
                    if (p.x < -10) p.x = w + 10;
                    if (p.x > w + 10) p.x = -10;

                    // Twinkle effect
                    const twinkleOpacity = p.opacity * (0.7 + 0.3 * Math.sin(p.twinkle));

                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 223, 150, ${twinkleOpacity})`;
                    ctx.fill();
                });

                LivingArtMode.animationFrame = requestAnimationFrame(LivingArtMode.animate);
            },

            scheduleBlink: () => {
                const nextBlink = 8000 + Math.random() * 6000; // 8-14 seconds
                LivingArtMode.blinkInterval = setTimeout(() => {
                    if (!LivingArtMode.active) return;
                    LivingArtMode.dealerBlink();
                    LivingArtMode.scheduleBlink();
                }, nextBlink);
            },

            dealerBlink: () => {
                const avatar = document.querySelector('.dealer-avatar');
                if (!avatar) return;

                // Quick blink animation
                avatar.style.transition = 'clip-path 0.1s';
                avatar.style.clipPath = 'inset(35% 0 55% 0)';
                setTimeout(() => {
                    avatar.style.clipPath = 'inset(0 0 0 0)';
                    setTimeout(() => {
                        avatar.style.transition = '';
                    }, 100);
                }, 100);
            },

            showMetaThought: () => {
                const thought = document.getElementById('dealer-thought');
                if (!thought) return;

                const phrase = LivingArtMode.metaPhrases[
                    Math.floor(Math.random() * LivingArtMode.metaPhrases.length)
                ];

                thought.textContent = `"${phrase}"`;
                thought.classList.add('visible');

                setTimeout(() => {
                    thought.classList.remove('visible');
                }, 8000);
            },

            maybeTriggerChaos: () => {
                if (!LivingArtMode.active) return;

                const roll = Math.random();

                if (roll < 0.05) { // 5% chance - Phantom Cat!
                    LivingArtMode.spawnCat();
                } else if (roll < 0.15) { // 10% chance - gravity glitch
                    LivingArtMode.gravityGlitch();
                }
            },

            spawnCat: () => {
                // Remove existing cat if any
                const existingCat = document.querySelector('.phantom-cat');
                if (existingCat) existingCat.remove();

                const cat = document.createElement('div');
                cat.className = 'phantom-cat';
                cat.textContent = 'üê±';
                document.body.appendChild(cat);

                // Trigger walk animation
                setTimeout(() => cat.classList.add('walking'), 50);

                // Remove after animation
                setTimeout(() => cat.remove(), 13000);
            },

            gravityGlitch: () => {
                // Only affect cards that are fully dealt, not currently animating
                const cards = document.querySelectorAll('.card.dealt:not(.dealing)');
                if (cards.length === 0) return;

                // Pick just one random card to float, not all of them
                const randomCard = cards[Math.floor(Math.random() * cards.length)];

                randomCard.style.transition = 'transform 1.5s ease-out';
                randomCard.style.transform = `translateY(-25px) rotate(${(Math.random()-0.5)*8}deg)`;

                setTimeout(() => {
                    randomCard.style.transition = 'transform 0.8s ease-in';
                    randomCard.style.transform = '';
                    setTimeout(() => {
                        randomCard.style.transition = '';
                    }, 800);
                }, 2000);
            }
        };

        // Initialize Living Art Mode on load
        document.addEventListener('DOMContentLoaded', () => {
            LivingArtMode.init();
        });

        // --- Tutoring System Explanations (continued) ---
        // War explanations
        TutoringSystem.explainWarBattle = (pCard, dCard) => {
                const pVal = pCard.pokerValue;
                const dVal = dCard.pokerValue;
                const pName = `${pCard.rank}${pCard.suit}`;
                const dName = `${dCard.rank}${dCard.suit}`;

                let explanation, outcome, rule;

                if (pVal > dVal) {
                    const diff = pVal - dVal;
                    explanation = `Your <span class="highlight">${pName}</span> (rank ${pVal}) beats the Dealer's <span class="highlight">${dName}</span> (rank ${dVal}).<br>` +
                        `<span class="win">You win this battle!</span> You collect both cards.`;
                    rule = `In War, face cards rank J=11, Q=12, K=13, A=14. Your card was ${diff} rank${diff > 1 ? 's' : ''} higher.`;
                } else if (dVal > pVal) {
                    const diff = dVal - pVal;
                    explanation = `Dealer's <span class="highlight">${dName}</span> (rank ${dVal}) beats your <span class="highlight">${pName}</span> (rank ${pVal}).<br>` +
                        `<span class="lose">Dealer wins this battle.</span> They collect both cards.`;
                    rule = `The Dealer's card was ${diff} rank${diff > 1 ? 's' : ''} higher. Keep playing - luck can change!`;
                } else {
                    explanation = `Both cards are <span class="highlight">${pCard.rank}s</span>! This is a <span class="tie">TIE</span>.<br>` +
                        `When cards match, we go to <span class="highlight">WAR</span>!`;
                    rule = `In War mode, each player places 3 cards face-down, then flips the 4th. Winner takes all 10 cards!`;
                }

                return TutoringSystem.show('Battle Result', explanation, rule);
            };

        TutoringSystem.explainWarOutcome = (potSize, winner) => {
                const explanation = winner === 'Player'
                    ? `<span class="win">Victory!</span> You collected <span class="highlight">${potSize} cards</span> from this battle.`
                    : `<span class="lose">Defeat.</span> The Dealer collected <span class="highlight">${potSize} cards</span>.`;
                const rule = `Current standings: You have ${WarGame.playerDeck.length} cards, Dealer has ${WarGame.dealerDeck.length} cards.`;
                return TutoringSystem.show('Cards Collected', explanation, rule, 2000);
            };

        // Blackjack explanations
        TutoringSystem.explainBlackjackAction = (action, score, dealerUp) => {
                let explanation, rule;
                const dVal = dealerUp.rank === 'A' ? 'Ace' : dealerUp.rank;

                if (action === 'hit') {
                    explanation = `With a score of <span class="highlight">${score}</span> against Dealer showing <span class="highlight">${dVal}</span>,` +
                        ` the AI chooses to <span class="win">HIT</span>.`;
                    if (score <= 11) {
                        rule = `With 11 or less, you cannot bust by taking one card. Always hit here.`;
                    } else {
                        rule = `Dealer's ${dVal} is strong (7+). With ${score}, the risk of busting is worth taking to improve your hand.`;
                    }
                } else {
                    explanation = `With a score of <span class="highlight">${score}</span> against Dealer showing <span class="highlight">${dVal}</span>,` +
                        ` the AI chooses to <span class="highlight">STAND</span>.`;
                    if (score >= 17) {
                        rule = `17+ is a strong hand. Standing avoids bust risk and lets the Dealer potentially bust.`;
                    } else {
                        rule = `Dealer shows weakness (${dVal}). Let them draw - they might bust trying to beat your ${score}.`;
                    }
                }
                return TutoringSystem.show('Strategy Decision', explanation, rule, 2500);
            };

        TutoringSystem.explainBlackjackResult = (pScore, dScore, result) => {
                let explanation, rule;

                if (result === 'bust') {
                    explanation = `Your score hit <span class="lose">${pScore}</span> - that's over 21!<br>` +
                        `<span class="lose">BUST!</span> The Dealer wins automatically.`;
                    rule = `Going over 21 is an instant loss. Consider standing earlier against weak Dealer cards.`;
                } else if (result === 'win') {
                    if (dScore > 21) {
                        explanation = `Dealer busted with <span class="lose">${dScore}</span>!<br>` +
                            `Your <span class="highlight">${pScore}</span> wins. <span class="win">You win!</span>`;
                        rule = `Dealers must hit until 17+. When they show weak cards (2-6), they often bust.`;
                    } else {
                        explanation = `Your <span class="highlight">${pScore}</span> beats Dealer's <span class="highlight">${dScore}</span>.<br>` +
                            `<span class="win">You win!</span>`;
                        rule = `Higher score under 21 wins. Your hand was ${pScore - dScore} points better.`;
                    }
                } else if (result === 'push') {
                    explanation = `Both hands total <span class="highlight">${pScore}</span>!<br>` +
                        `<span class="tie">PUSH</span> - your bet is returned.`;
                    rule = `Ties return your wager. Neither wins nor loses - try again!`;
                } else {
                    explanation = `Dealer's <span class="highlight">${dScore}</span> beats your <span class="highlight">${pScore}</span>.<br>` +
                        `<span class="lose">Dealer wins.</span>`;
                    rule = `The Dealer's hand was ${dScore - pScore} points better. Review basic strategy to improve!`;
                }
                return TutoringSystem.show('Hand Result', explanation, rule);
            };

        // Poker explanations
        TutoringSystem.explainPokerDecision = (action, reason, odds) => {
                let explanation = `The AI decides to <span class="highlight">${action.toUpperCase()}</span>.<br>`;
                explanation += reason;
                const rule = `Win probability: ${odds}%. ${parseFloat(odds) > 50 ? 'Favorable odds support aggression.' : 'Marginal odds suggest caution.'}`;
                return TutoringSystem.show('Poker Strategy', explanation, rule, 2500);
            };

        TutoringSystem.explainPokerResult = (pScore, dScore, pHand, dHand, result) => {
                const getHandName = (score) => {
                    if (score > 70000) return 'Four of a Kind';
                    if (score > 60000) return 'Full House';
                    if (score > 50000) return 'Flush';
                    if (score > 40000) return 'Straight';
                    if (score > 30000) return 'Three of a Kind';
                    if (score > 20000) return 'Two Pair';
                    if (score > 10000) return 'Pair';
                    return 'High Card';
                };

                const pHandName = getHandName(pScore);
                const dHandName = getHandName(dScore);
                let explanation, rule;

                if (result === 'win') {
                    explanation = `Your <span class="win">${pHandName}</span> beats Dealer's <span class="highlight">${dHandName}</span>!<br>` +
                        `<span class="win">You win the pot!</span>`;
                    rule = `Hand rankings: High Card < Pair < Two Pair < Three Kind < Straight < Flush < Full House < Four Kind`;
                } else if (result === 'tie') {
                    explanation = `Both have <span class="tie">${pHandName}</span>!<br>` +
                        `<span class="tie">Split pot.</span>`;
                    rule = `When hand types match, kickers (highest remaining cards) determine the winner.`;
                } else {
                    explanation = `Dealer's <span class="lose">${dHandName}</span> beats your <span class="highlight">${pHandName}</span>.<br>` +
                        `<span class="lose">Dealer takes the pot.</span>`;
                    rule = `${dHandName} outranks ${pHandName}. Position and reading opponents matter too!`;
                }
                return TutoringSystem.show('Showdown', explanation, rule);
            };

        // --- Autoplay System ---
        const Autoplay = {
            toggle: () => {
                STATE.autoplay = !STATE.autoplay;
                const status = STATE.autoplay ? "ON - Watching the AI play!" : "OFF";
                showOverlay(`Autoplay: ${status}`, 1500);

                // Update the autoplay indicator
                Autoplay.updateIndicator();

                // Show/hide score tracker with autoplay
                if (STATE.autoplay) {
                    ScoreTracker.show();
                } else {
                    ScoreTracker.hide();
                }

                // Refresh current game controls to update button state
                Autoplay.refreshControls();

                // If just turned on, trigger next action
                if (STATE.autoplay) {
                    Autoplay.scheduleNext();
                }
            },

            updateIndicator: () => {
                let indicator = document.getElementById('autoplay-indicator');
                if (!indicator) {
                    indicator = document.createElement('div');
                    indicator.id = 'autoplay-indicator';
                    indicator.style.cssText = 'position: fixed; top: 80px; right: 20px; background: linear-gradient(45deg, #e74c3c, #c0392b); color: white; padding: 8px 16px; border-radius: 20px; font-weight: bold; z-index: 1000; display: none; animation: autoplayPulse 1.5s ease-in-out infinite;';
                    document.body.appendChild(indicator);
                }
                indicator.textContent = 'AUTOPLAY';
                indicator.style.display = STATE.autoplay ? 'block' : 'none';
                // Move indicator to left side for Balatro (HUD is on right)
                if (STATE.game === 'balatro') {
                    indicator.style.right = 'auto';
                    indicator.style.left = '20px';
                } else {
                    indicator.style.left = 'auto';
                    indicator.style.right = '20px';
                }
            },

            refreshControls: () => {
                // Trigger control refresh for current game phase
                if (STATE.game === 'war') {
                    if (WarGame.playerDeck.length > 0 && WarGame.dealerDeck.length > 0) {
                        WarGame.nextRound();
                    }
                } else if (STATE.game === 'blackjack') {
                    if (STATE.playerHand.length >= 2) {
                        BlackjackGame.playerTurn();
                    } else {
                        BlackjackGame.bettingPhase();
                    }
                } else if (STATE.game === 'poker') {
                    // Poker has multiple phases - just update current controls
                    // The controls will update on next action
                } else if (STATE.game === 'balatro') {
                    BalatroGame.setControls();
                }
            },

            scheduleNext: () => {
                if (!STATE.autoplay) return;
                setTimeout(() => Autoplay.executeNext(), STATE.autoplayDelay);
            },

            executeNext: () => {
                if (!STATE.autoplay) return;

                if (STATE.game === 'war') {
                    Autoplay.playWar();
                } else if (STATE.game === 'blackjack') {
                    Autoplay.playBlackjack();
                } else if (STATE.game === 'poker') {
                    Autoplay.playPoker();
                } else if (STATE.game === 'balatro') {
                    Autoplay.playBalatro();
                }
            },

            playWar: () => {
                // War has simple decisions: Battle or Go to War
                if (WarGame.playerDeck.length === 0 || WarGame.dealerDeck.length === 0) {
                    return; // Game over
                }

                const controls = document.getElementById('controls');
                const buttons = controls.querySelectorAll('.btn');

                // Find Battle or Go to War button (text may include keyboard shortcuts)
                const battleBtn = Array.from(buttons).find(b =>
                    b.textContent.includes('Battle') || b.textContent.includes('Go to War')
                );

                if (battleBtn) {
                    battleBtn.click();
                    // Schedule next action after battle resolves
                    setTimeout(() => Autoplay.scheduleNext(), 2000);
                }
            },

            playBlackjack: async () => {
                // Check if player is bankrupt
                if (STATE.chips <= 0) {
                    STATE.autoplay = false;
                    Autoplay.updateIndicator();
                    showOverlay("BANKRUPT!", 3000);
                    return;
                }

                const controls = document.getElementById('controls');
                const buttons = controls.querySelectorAll('.btn');

                // Check what phase we're in (button text may include keyboard shortcuts like [H] or [S])
                const hitBtn = Array.from(buttons).find(b => b.textContent.includes('Hit'));
                const standBtn = Array.from(buttons).find(b => b.textContent.includes('Stand'));
                const doubleBtn = Array.from(buttons).find(b => b.textContent.includes('Double'));
                const betBtn = Array.from(buttons).find(b => b.textContent.includes('Bet'));
                const newRoundBtn = Array.from(buttons).find(b => b.textContent.includes('New Round') || b.textContent.includes('Play Again'));

                if (hitBtn && standBtn) {
                    // Playing phase - use basic strategy with tutoring
                    const action = Autoplay.getBlackjackAction();
                    const score = BlackjackGame.getScore(STATE.playerHand);
                    const dealerUp = STATE.dealerHand[0];

                    // Show tutoring explanation
                    await TutoringSystem.explainBlackjackAction(action, score, dealerUp);

                    if (action === 'double' && doubleBtn) {
                        doubleBtn.click();
                    } else if (action === 'hit') {
                        hitBtn.click();
                    } else {
                        standBtn.click();
                    }
                    // Blackjack game handles its own continuation
                    setTimeout(() => Autoplay.scheduleNext(), 1500);
                } else if (newRoundBtn) {
                    // End of round - start new round
                    newRoundBtn.click();
                    setTimeout(() => Autoplay.scheduleNext(), 1000);
                } else if (betBtn) {
                    // Betting phase - bet 10
                    betBtn.click();
                    setTimeout(() => Autoplay.scheduleNext(), 1500);
                }
            },

            getBlackjackAction: () => {
                const score = BlackjackGame.getScore(STATE.playerHand);
                const dealerUpCard = STATE.dealerHand[0];
                const dVal = dealerUpCard.rank === 'A' ? 11 : (['K','Q','J'].includes(dealerUpCard.rank) ? 10 : parseInt(dealerUpCard.rank));
                const canDouble = STATE.playerHand.length === 2;

                // Basic Strategy with Double Down
                // Double down on 11 always, 10 if dealer shows 2-9, 9 if dealer shows 3-6
                if (canDouble) {
                    if (score === 11) return 'double';
                    if (score === 10 && dVal >= 2 && dVal <= 9) return 'double';
                    if (score === 9 && dVal >= 3 && dVal <= 6) return 'double';
                }

                if (score >= 17) return 'stand';
                if (score <= 11) return 'hit';
                if (score >= 12 && score <= 16) {
                    if (dVal >= 7) return 'hit';
                    return 'stand';
                }
                return 'hit';
            },

            playPoker: async () => {
                // Check if player is bankrupt
                if (STATE.chips <= 0) {
                    STATE.autoplay = false;
                    Autoplay.updateIndicator();
                    showOverlay("BANKRUPT!", 3000);
                    return;
                }

                const controls = document.getElementById('controls');
                const buttons = controls.querySelectorAll('.btn');

                // Check what phase we're in (use includes for text that may have keyboard shortcuts)
                const anteBtn = Array.from(buttons).find(b => b.textContent.includes('Ante'));
                const callBtn = Array.from(buttons).find(b => b.textContent.includes('Call'));
                const checkBtn = Array.from(buttons).find(b => b.textContent.includes('Check'));
                const betBtn = Array.from(buttons).find(b => b.textContent.includes('Bet') && !b.textContent.includes('Toggle'));
                const foldBtn = Array.from(buttons).find(b => b.textContent.includes('Fold'));
                const newRoundBtn = Array.from(buttons).find(b => b.textContent.includes('New Round') || b.textContent.includes('Play Again'));

                if (newRoundBtn) {
                    // End of round - start new round
                    newRoundBtn.click();
                    setTimeout(() => Autoplay.scheduleNext(), 1000);
                } else if (anteBtn) {
                    // Pre-game - ante up
                    anteBtn.click();
                    setTimeout(() => Autoplay.scheduleNext(), 1500);
                } else if (callBtn && foldBtn) {
                    // Pre-flop decision with tutoring
                    const action = Autoplay.getPokerAction('preflop');
                    const odds = PokerGame.calculateOdds();
                    const r1 = STATE.playerHand[0], r2 = STATE.playerHand[1];
                    const isPair = r1.pokerValue === r2.pokerValue;
                    const hasHighCard = r1.pokerValue >= 11 || r2.pokerValue >= 11;

                    let reason = '';
                    if (action === 'call') {
                        if (isPair) reason = `Pocket pair (${r1.rank}s) - strong starting hand.`;
                        else if (hasHighCard) reason = `High cards (${r1.rank}, ${r2.rank}) - playable hand.`;
                        else reason = `Odds look favorable at ${odds}%.`;
                    } else {
                        reason = `Weak hand (${r1.rank}, ${r2.rank}) with only ${odds}% win chance.`;
                    }

                    await TutoringSystem.explainPokerDecision(action, reason, odds);

                    if (action === 'fold') {
                        foldBtn.click();
                    } else {
                        callBtn.click();
                    }
                    setTimeout(() => Autoplay.scheduleNext(), 1500);
                } else if (checkBtn && betBtn) {
                    // Post-flop decision with tutoring
                    const action = Autoplay.getPokerAction('postflop');
                    const odds = PokerGame.calculateOdds();
                    const score = PokerGame.evaluate(STATE.playerHand, STATE.communityCards);

                    let reason = '';
                    if (action === 'bet') {
                        if (score > 30000) reason = `Strong hand detected - betting for value.`;
                        else reason = `Good odds (${odds}%) justify aggression.`;
                    } else {
                        if (score > 10000) reason = `Decent hand, but checking to control pot size.`;
                        else reason = `Marginal hand - checking to see more cards cheaply.`;
                    }

                    await TutoringSystem.explainPokerDecision(action, reason, odds);

                    if (action === 'bet') {
                        betBtn.click();
                    } else {
                        checkBtn.click();
                    }
                    setTimeout(() => Autoplay.scheduleNext(), 1500);
                }
            },

            playBalatro: async () => {
                const bs = BalatroGame.state;

                // Check if game over
                if (bs.handsLeft <= 0 && bs.currentScore < bs.blindScore) {
                    STATE.autoplay = false;
                    Autoplay.updateIndicator();
                    return;
                }

                // Check if in shop phase
                const controls = document.getElementById('controls');
                const nextRoundBtn = Array.from(controls.querySelectorAll('.btn')).find(b => b.textContent.includes('Next Round'));
                if (nextRoundBtn) {
                    // In shop - buy jokers if affordable and beneficial
                    const dContainer = document.getElementById('dealer-hand');
                    const jokerEls = dContainer.querySelectorAll('.joker-card');

                    let bought = false;
                    jokerEls.forEach(el => {
                        if (!bought && bs.money >= 4 && bs.jokers.length < bs.maxJokers) {
                            el.click();
                            bought = true;
                        }
                    });

                    await TutoringSystem.show(
                        'Shop Phase',
                        bought ? 'Purchased a Joker to boost scoring potential.' : 'Saving money for future rounds.',
                        'Jokers multiply your score - prioritize them early!',
                        2000
                    );

                    setTimeout(() => {
                        nextRoundBtn.click();
                        Autoplay.scheduleNext();
                    }, 1500);
                    return;
                }

                // Find the best possible hand from current cards
                const bestPlay = Autoplay.findBestBalatroHand();

                if (bestPlay.shouldDiscard && bs.discardsLeft > 0) {
                    // Discard strategy - remove cards not in best potential hand
                    await TutoringSystem.show(
                        'Discard Strategy',
                        `Discarding ${bestPlay.discardCards.length} weak cards to improve hand.`,
                        `Looking for: ${bestPlay.targetHand}`,
                        2500
                    );

                    // Select cards to discard
                    STATE.playerHand.forEach(c => c.selected = false);
                    bestPlay.discardCards.forEach(c => c.selected = true);
                    BalatroGame.renderHand();

                    setTimeout(() => {
                        BalatroGame.discardCards();
                        Autoplay.scheduleNext();
                    }, 1500);
                } else {
                    // Play the best hand
                    const { handName, chips, mult } = bestPlay;
                    const totalScore = chips * mult;
                    const remaining = bs.blindScore - bs.currentScore;

                    await TutoringSystem.show(
                        `Playing: ${handName}`,
                        `${chips} chips √ó ${mult} mult = ${totalScore} points`,
                        remaining > totalScore && bs.handsLeft > 1
                            ? `Need ${remaining} more. ${bs.handsLeft} hands left.`
                            : totalScore >= remaining
                                ? 'This should beat the blind!'
                                : 'Every point counts!',
                        2500
                    );

                    // Select the cards to play
                    STATE.playerHand.forEach(c => c.selected = false);
                    bestPlay.cards.forEach(c => c.selected = true);
                    BalatroGame.renderHand();

                    setTimeout(() => {
                        BalatroGame.playHand();
                        setTimeout(() => Autoplay.scheduleNext(), 1000);
                    }, 1500);
                }
            },

            findBestBalatroHand: () => {
                const hand = STATE.playerHand;
                const bs = BalatroGame.state;
                let bestHand = { cards: [], handName: 'High Card', chips: 0, mult: 0, score: 0 };

                // Generate all combinations of 1-5 cards
                const combinations = [];
                for (let size = 1; size <= Math.min(5, hand.length); size++) {
                    Autoplay.getCombinations(hand, size).forEach(combo => combinations.push(combo));
                }

                // Evaluate each combination
                combinations.forEach(combo => {
                    const result = BalatroGame.evaluateHand(combo);
                    const score = result.chips * result.mult;
                    if (score > bestHand.score) {
                        bestHand = { cards: combo, ...result, score };
                    }
                });

                // Decide if we should discard to improve
                const remaining = bs.blindScore - bs.currentScore;
                const canWinNow = bestHand.score >= remaining;
                const shouldDiscard = !canWinNow && bs.discardsLeft > 0 && bs.handsLeft > 1;

                // Find cards to discard (ones not in our best potential hands)
                let discardCards = [];
                let targetHand = bestHand.handName;

                if (shouldDiscard) {
                    const cardsInBestHand = new Set(bestHand.cards);
                    const potentialDiscards = hand.filter(c => !cardsInBestHand.has(c));

                    // Keep cards that could form better hands
                    const suits = {};
                    const ranks = {};
                    hand.forEach(c => {
                        suits[c.suit] = (suits[c.suit] || 0) + 1;
                        ranks[c.rank] = (ranks[c.rank] || 0) + 1;
                    });

                    // Check for flush draws (4 of same suit)
                    const flushDraw = Object.entries(suits).find(([s, count]) => count >= 4);
                    if (flushDraw) {
                        targetHand = 'Flush';
                        discardCards = hand.filter(c => c.suit !== flushDraw[0]).slice(0, Math.min(3, bs.discardsLeft));
                    }
                    // Check for straight draws
                    else if (Autoplay.hasStraightDraw(hand)) {
                        targetHand = 'Straight';
                        discardCards = potentialDiscards.slice(0, Math.min(2, bs.discardsLeft));
                    }
                    // Check for pair upgrades (trips/quads)
                    else if (Object.values(ranks).some(c => c >= 2)) {
                        const pairRank = Object.entries(ranks).find(([r, c]) => c >= 2)?.[0];
                        targetHand = 'Three of a Kind';
                        discardCards = hand.filter(c => c.rank !== pairRank).slice(0, Math.min(3, bs.discardsLeft));
                    } else {
                        // Generic discard - keep high cards
                        const sorted = [...hand].sort((a, b) => b.pokerValue - a.pokerValue);
                        discardCards = sorted.slice(5).slice(0, Math.min(3, bs.discardsLeft));
                        targetHand = 'Pair';
                    }
                }

                return {
                    ...bestHand,
                    shouldDiscard: shouldDiscard && discardCards.length > 0,
                    discardCards,
                    targetHand
                };
            },

            getCombinations: (arr, size) => {
                const result = [];
                const combine = (start, combo) => {
                    if (combo.length === size) {
                        result.push([...combo]);
                        return;
                    }
                    for (let i = start; i < arr.length; i++) {
                        combo.push(arr[i]);
                        combine(i + 1, combo);
                        combo.pop();
                    }
                };
                combine(0, []);
                return result;
            },

            hasStraightDraw: (cards) => {
                const values = [...new Set(cards.map(c => c.pokerValue))].sort((a, b) => a - b);
                // Check for 4 consecutive cards
                for (let i = 0; i <= values.length - 4; i++) {
                    if (values[i + 3] - values[i] <= 4) return true;
                }
                // Check for A-2-3-4 or A-K-Q-J draws
                if (values.includes(14)) {
                    if (values.filter(v => v <= 5).length >= 3) return true;
                    if (values.filter(v => v >= 11).length >= 3) return true;
                }
                return false;
            },

            getPokerAction: (phase) => {
                const winProb = parseFloat(PokerGame.calculateOdds());
                const score = PokerGame.evaluate(STATE.playerHand, STATE.communityCards);

                if (phase === 'preflop') {
                    // Pre-flop: play with pairs, high cards, or good win probability
                    const r1 = STATE.playerHand[0].pokerValue;
                    const r2 = STATE.playerHand[1].pokerValue;
                    const isPair = r1 === r2;
                    const hasHighCard = r1 >= 11 || r2 >= 11;

                    if (isPair || hasHighCard || winProb > 45) return 'call';
                    if (winProb < 35) return 'fold';
                    return 'call'; // Slight aggression
                } else {
                    // Post-flop: bet with good hands, check with marginal
                    if (score > 20000 || winProb > 60) return 'bet';
                    if (score > 10000 || winProb > 50) return 'check'; // Pair or decent odds
                    if (winProb > 40) return 'check';
                    return 'check'; // Conservative
                }
            }
        };

        // --- Card System ---
        const SUITS = ['‚ô†', '‚ô•', '‚ô£', '‚ô¶'];
        const RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        
        class Card {
            constructor(suit, rank) {
                this.suit = suit;
                this.rank = rank;
                this.color = (suit === '‚ô•' || suit === '‚ô¶') ? 'red' : 'black';
                this.faceUp = true;
                this.id = `${suit}${rank}`; // Unique identifier
                // Balatro enhancements
                this.enhancement = null; // foil, holographic, polychrome, bonus, mult, wild, glass, steel, stone, gold
                this.seal = null; // gold, red, blue, purple
                this.edition = null; // foil, holo, poly
                this.bonusChips = 0;
                this.bonusMult = 0;
                this.selected = false;
                this.location = 'deck'; // deck, hand, played, discarded, destroyed
            }

            get value() {
                if (this.rank === 'A') return 14;
                if (['K', 'Q', 'J'].includes(this.rank)) return 10;
                return parseInt(this.rank) || 10;
            }

            get pokerValue() {
                const map = {'2':2, '3':3, '4':4, '5':5, '6':6, '7':7, '8':8, '9':9, '10':10, 'J':11, 'Q':12, 'K':13, 'A':14};
                return map[this.rank];
            }

            get balatroChips() {
                // Base chip value for scoring
                const baseChips = {'A':11, 'K':10, 'Q':10, 'J':10, '10':10, '9':9, '8':8, '7':7, '6':6, '5':5, '4':4, '3':3, '2':2};
                let chips = baseChips[this.rank] || 0;
                chips += this.bonusChips;
                if (this.enhancement === 'bonus') chips += 30;
                if (this.enhancement === 'stone') chips += 50;
                return chips;
            }

            clone() {
                const c = new Card(this.suit, this.rank);
                c.enhancement = this.enhancement;
                c.seal = this.seal;
                c.edition = this.edition;
                c.bonusChips = this.bonusChips;
                c.bonusMult = this.bonusMult;
                c.faceUp = this.faceUp;
                c.location = this.location;
                return c;
            }

            render(selectable = false) {
                const el = document.createElement('div');
                let classes = `card ${this.color}`;
                if (!this.faceUp) classes += ' card-back';
                if (this.enhancement) classes += ` ${this.enhancement}`;
                if (this.edition) classes += ` ${this.edition}`;
                if (this.selected) classes += ' selected';
                el.className = classes;
                el.dataset.cardId = this.id;
                el.dataset.suit = this.suit; // Cycle 7: For color blind mode CSS targeting

                if (selectable) {
                    el.style.cursor = 'pointer';
                    el.onclick = () => {
                        this.selected = !this.selected;
                        el.classList.toggle('selected');
                        if (typeof BalatroGame !== 'undefined') BalatroGame.updateHandPreview();
                    };
                }

                if (this.faceUp) {
                    el.innerHTML = `
                        <div class="card-corner top">
                            <div>${this.rank}</div>
                            <div>${this.suit}</div>
                        </div>
                        <div class="card-center">${this.suit}</div>
                        <div class="card-corner bottom">
                            <div>${this.rank}</div>
                            <div>${this.suit}</div>
                        </div>
                    `;
                    if (this.seal) {
                        const sealEl = document.createElement('div');
                        sealEl.className = 'card-seal';
                        sealEl.style.cssText = 'position:absolute;bottom:5px;right:5px;width:12px;height:12px;border-radius:50%;';
                        sealEl.style.background = this.seal;
                        el.appendChild(sealEl);
                    }
                }
                return el;
            }
        }

        function createDeck() {
            const deck = [];
            for (let s of SUITS) {
                for (let r of RANKS) {
                    deck.push(new Card(s, r));
                }
            }
            return shuffle(deck);
        }

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // --- UI Functions ---
        function showMenu() {
            TimerManager.clearAll(); // Cycle 1 - Clear all timers on game exit
            KeyboardShortcuts.setContext('menu'); // Cycle 4 - Reset keyboard context
            document.getElementById('game-menu').style.display = 'flex';
            STATE.game = null;
            STATE.autoplay = false;
            Autoplay.updateIndicator();
            ScoreTracker.hide();
            // Hide Balatro-specific UI
            const balatroHud = document.getElementById('balatro-hud');
            if (balatroHud) balatroHud.style.display = 'none';
            CardRoster.hide();
            updateDealer("Select a game to begin.");
            // Restart demo mode animations
            if (typeof DemoMode !== 'undefined') DemoMode.start();
        }
        const returnToMenu = showMenu; // Alias for convenience

        // --- Cycle 7: Focus Mode System ---
        const FocusMode = {
            enabled: false,
            init: () => {
                const toggle = document.createElement('button');
                toggle.id = 'focus-toggle';
                toggle.className = 'focus-toggle';
                toggle.innerHTML = 'üëÅ Focus';
                toggle.title = 'Toggle Focus Mode (F) - Hide UI for immersive play';
                toggle.onclick = FocusMode.toggle;
                document.body.appendChild(toggle);
                FocusMode.enabled = localStorage.getItem('vds_focusMode') === 'true';
                if (FocusMode.enabled) {
                    document.body.classList.add('focus-mode');
                    toggle.classList.add('active');
                    toggle.innerHTML = 'üëÅ Focus ON';
                }
            },
            toggle: () => {
                FocusMode.enabled = !FocusMode.enabled;
                document.body.classList.toggle('focus-mode', FocusMode.enabled);
                const toggle = document.getElementById('focus-toggle');
                toggle.classList.toggle('active', FocusMode.enabled);
                toggle.innerHTML = FocusMode.enabled ? 'üëÅ Focus ON' : 'üëÅ Focus';
                localStorage.setItem('vds_focusMode', FocusMode.enabled);
                if (FocusMode.enabled) showOverlay('Focus Mode ON', 1000);
            }
        };

        // --- Cycle 7: Color Blind Mode System ---
        const ColorBlindMode = {
            enabled: false,
            init: () => {
                ColorBlindMode.enabled = localStorage.getItem('vds_colorBlindMode') === 'true';
                if (ColorBlindMode.enabled) {
                    document.body.classList.add('colorblind-mode');
                    const btn = document.getElementById('colorblind-btn');
                    if (btn) btn.classList.add('active');
                }
            },
            toggle: () => {
                ColorBlindMode.enabled = !ColorBlindMode.enabled;
                document.body.classList.toggle('colorblind-mode', ColorBlindMode.enabled);
                const btn = document.getElementById('colorblind-btn');
                if (btn) btn.classList.toggle('active', ColorBlindMode.enabled);
                localStorage.setItem('vds_colorBlindMode', ColorBlindMode.enabled);
                if (ColorBlindMode.enabled) {
                    showOverlay('Color Blind Mode ON', 1000);
                    updateDealer('Suit patterns enabled for better visibility.');
                }
            }
        };

        // Cycle 20: First-Time Welcome Modal
        const WelcomeModal = {
            init: () => {
                // Only show for first-time visitors
                if (localStorage.getItem('vds_hasVisited')) return;
                localStorage.setItem('vds_hasVisited', 'true');

                // Auto-enable Learn Mode for new players
                if (!STATE.learnMode) {
                    STATE.learnMode = true;
                    localStorage.setItem('vds_learnMode', 'true');
                }

                // Show welcome modal after a brief delay
                setTimeout(() => WelcomeModal.show(), 500);
            },
            show: () => {
                const modal = document.createElement('div');
                modal.id = 'welcome-modal';
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.85);
                    backdrop-filter: blur(8px);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 300;
                `;
                modal.innerHTML = `
                    <div style="background: linear-gradient(145deg, #1a3c26, #2d5e3e); padding: 30px 40px; border-radius: 20px; border: 2px solid var(--accent); max-width: 450px; text-align: center; box-shadow: 0 20px 60px rgba(0,0,0,0.5);">
                        <div style="font-size: 3rem; margin-bottom: 10px;">üé∞</div>
                        <h2 style="color: var(--accent); margin: 0 0 15px 0; font-size: 1.6rem;">Welcome to the Virtual Dealer Suite!</h2>
                        <p style="color: #ddd; line-height: 1.6; margin: 0 0 15px 0;">I'm your virtual dealer. I'll teach you Blackjack, War, Poker, and Balatro while we play.</p>
                        <p style="color: #aaa; font-size: 0.9rem; margin: 0 0 20px 0;"><strong style="color: var(--accent);">Learn Mode</strong> is enabled - I'll explain optimal plays as you go.</p>
                        <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                            <button onclick="document.getElementById('welcome-modal').remove()" style="background: var(--accent); color: #000; border: none; padding: 12px 30px; border-radius: 25px; font-weight: bold; font-size: 1rem; cursor: pointer;">Let's Play!</button>
                        </div>
                        <p style="color: #666; font-size: 0.75rem; margin: 15px 0 0 0;">Press H for Hit, S for Stand, D to Double Down</p>
                    </div>
                `;
                document.body.appendChild(modal);
            }
        };

        // Cycle 9: Fullscreen Toggle
        const FullscreenToggle = {
            isFullscreen: false,
            toggle: () => {
                const btn = document.getElementById('fullscreen-btn');
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().then(() => {
                        FullscreenToggle.isFullscreen = true;
                        if (btn) btn.classList.add('active');
                        if (btn) btn.textContent = '‚õ∂';
                    }).catch(err => {
                        updateDealer('Fullscreen not available in this browser.');
                    });
                } else {
                    document.exitFullscreen().then(() => {
                        FullscreenToggle.isFullscreen = false;
                        if (btn) btn.classList.remove('active');
                        if (btn) btn.textContent = '‚õ∂';
                    });
                }
            },
            init: () => {
                document.addEventListener('fullscreenchange', () => {
                    const btn = document.getElementById('fullscreen-btn');
                    FullscreenToggle.isFullscreen = !!document.fullscreenElement;
                    if (btn) btn.classList.toggle('active', FullscreenToggle.isFullscreen);
                });
            }
        };

        // Cycle 9: Chips Manager - Reset Chips
        const ChipsManager = {
            reset: () => {
                if (confirm('Reset chips to 1000? This cannot be undone.')) {
                    STATE.chips = 1000;
                    DataManager.autoSave();
                    updateChips();
                    showOverlay('Chips Reset!', 1500);
                    updateDealer('Fresh stack of chips! Good luck.');
                    HapticEngine.buttonPress();
                }
            }
        };

        // Cycle 10: Achievement System - Win Streaks and Milestones
        const Achievements = {
            definitions: [
                { id: 'first_win', name: 'First Blood', icon: 'üéØ', condition: s => s.scores.player >= 1 },
                { id: 'win_5', name: 'Hot Hand', icon: 'üî•', condition: s => s.scores.player >= 5 },
                { id: 'win_10', name: 'On a Roll', icon: 'üé∞', condition: s => s.scores.player >= 10 },
                { id: 'win_25', name: 'Quarter Master', icon: 'üèÜ', condition: s => s.scores.player >= 25 },
                { id: 'win_50', name: 'Half Century', icon: '‚≠ê', condition: s => s.scores.player >= 50 },
                { id: 'win_100', name: 'Centurion', icon: 'üëë', condition: s => s.scores.player >= 100 },
                { id: 'streak_3', name: 'Triple Threat', icon: '3Ô∏è‚É£', condition: s => s.winStreak >= 3 },
                { id: 'streak_5', name: 'Fab Five', icon: '5Ô∏è‚É£', condition: s => s.winStreak >= 5 },
                { id: 'streak_10', name: 'Perfect Ten', icon: 'üîü', condition: s => s.winStreak >= 10 },
                { id: 'chips_2k', name: 'High Roller', icon: 'üí∞', condition: s => s.chips >= 2000 },
                { id: 'chips_5k', name: 'Big Spender', icon: 'üíé', condition: s => s.chips >= 5000 }
            ],
            unlocked: [],
            winStreak: 0,
            lossStreak: 0, // Cycle 15: Track loss streaks too
            init: () => {
                const saved = localStorage.getItem('vds_achievements');
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        Achievements.unlocked = data.unlocked || [];
                        Achievements.winStreak = data.winStreak || 0;
                        Achievements.lossStreak = data.lossStreak || 0;
                    } catch(e) {}
                }
            },
            save: () => {
                localStorage.setItem('vds_achievements', JSON.stringify({
                    unlocked: Achievements.unlocked,
                    winStreak: Achievements.winStreak,
                    lossStreak: Achievements.lossStreak
                }));
            },
            check: () => {
                const state = { ...STATE, winStreak: Achievements.winStreak };
                Achievements.definitions.forEach(a => {
                    if (!Achievements.unlocked.includes(a.id) && a.condition(state)) {
                        Achievements.unlocked.push(a.id);
                        Achievements.showUnlock(a);
                        Achievements.save();
                    }
                });
            },
            showUnlock: (achievement) => {
                showOverlay(`${achievement.icon} ${achievement.name} Unlocked!`, 2500);
                updateDealer(`Achievement unlocked: ${achievement.name}!`);
                HapticEngine.winCelebration();
            },
            onWin: () => {
                Achievements.winStreak++;
                Achievements.lossStreak = 0; // Cycle 15: Reset loss streak on win
                Achievements.check();
                Achievements.save();
                StreakIndicator.update(); // Cycle 15: Update streak indicator
            },
            onLoss: () => {
                Achievements.winStreak = 0;
                Achievements.lossStreak++; // Cycle 15: Increment loss streak
                Achievements.save();
                StreakBonus.reset(); // Cycle 13: Reset streak bonuses on loss
                StreakIndicator.update(); // Cycle 15: Update streak indicator
            }
        };

        // Cycle 15: Hot/Cold Streak Indicator
        const StreakIndicator = {
            threshold: 3, // Streaks of 3+ trigger visual effects
            currentState: 'neutral', // 'hot', 'cold', 'neutral'
            init: () => {
                // Create indicator element if not exists
                let indicator = document.getElementById('streak-indicator');
                if (!indicator) {
                    indicator = document.createElement('div');
                    indicator.id = 'streak-indicator';
                    indicator.className = 'streak-indicator';
                    indicator.innerHTML = `<span class="streak-icon" id="streak-icon">‚ûñ</span><span class="streak-value" id="streak-value">0</span>`;
                    indicator.title = 'Win/Loss Streak';
                    // Add to header controls
                    const headerControls = document.querySelector('.header-controls');
                    if (headerControls) {
                        headerControls.insertBefore(indicator, headerControls.firstChild);
                    }
                }
                StreakIndicator.update();
            },
            update: () => {
                const indicator = document.getElementById('streak-indicator');
                if (!indicator) return;

                const winStreak = Achievements.winStreak;
                const lossStreak = Achievements.lossStreak;
                const icon = document.getElementById('streak-icon');
                const value = document.getElementById('streak-value');

                if (winStreak >= StreakIndicator.threshold) {
                    StreakIndicator.setHot(winStreak);
                } else if (lossStreak >= StreakIndicator.threshold) {
                    StreakIndicator.setCold(lossStreak);
                } else {
                    StreakIndicator.setNeutral(winStreak > 0 ? winStreak : -lossStreak);
                }
            },
            setHot: (streak) => {
                const indicator = document.getElementById('streak-indicator');
                const icon = document.getElementById('streak-icon');
                const value = document.getElementById('streak-value');
                if (!indicator) return;

                indicator.className = 'streak-indicator streak-hot';
                icon.textContent = 'üî•';
                value.textContent = `+${streak}`;
                StreakIndicator.currentState = 'hot';

                // Fire particles
                if (streak >= 5) {
                    WinCelebration.burst(80, 50, Math.min(streak * 5, 40));
                }
            },
            setCold: (streak) => {
                const indicator = document.getElementById('streak-indicator');
                const icon = document.getElementById('streak-icon');
                const value = document.getElementById('streak-value');
                if (!indicator) return;

                indicator.className = 'streak-indicator streak-cold';
                icon.textContent = 'ü•∂';
                value.textContent = `-${streak}`;
                StreakIndicator.currentState = 'cold';
            },
            setNeutral: (value) => {
                const indicator = document.getElementById('streak-indicator');
                const icon = document.getElementById('streak-icon');
                const valueEl = document.getElementById('streak-value');
                if (!indicator) return;

                indicator.className = 'streak-indicator streak-neutral';
                icon.textContent = value > 0 ? 'üìà' : (value < 0 ? 'üìâ' : '‚ûñ');
                valueEl.textContent = value > 0 ? `+${value}` : (value < 0 ? `${value}` : '0');
                StreakIndicator.currentState = 'neutral';
            }
        };

        // Cycle 13: Lucky Streak Bonus System
        // Cycle 18: Extended Milestone Tiers with escalating rewards
        const StreakBonus = {
            milestones: { 3: 50, 5: 100, 7: 200, 10: 500, 15: 1000, 20: 2500 },
            awarded: new Set(),
            totalEarned: 0,
            init: () => {
                const saved = localStorage.getItem('vds_streakBonus');
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        StreakBonus.awarded = new Set(data.awarded || []);
                        StreakBonus.totalEarned = data.totalEarned || 0;
                    } catch(e) {}
                }
            },
            checkAndAward: () => {
                const streak = Achievements.winStreak;
                Object.entries(StreakBonus.milestones).forEach(([milestone, bonus]) => {
                    const m = parseInt(milestone);
                    if (streak === m && !StreakBonus.awarded.has(m)) {
                        StreakBonus.award(m, bonus);
                    }
                });
            },
            award: (milestone, chips) => {
                STATE.chips += chips;
                StreakBonus.awarded.add(milestone);
                StreakBonus.totalEarned += chips;
                ChipAnimator.update();
                showOverlay(`STREAK BONUS! +${chips}`, 2500);
                updateDealer(`${milestone}-win streak! +${chips} bonus chips!`);
                AudioEngine.winFanfare();
                WinCelebration.burst(window.innerWidth / 2, window.innerHeight / 3, 100);
                StreakBonus.save();
            },
            reset: () => {
                StreakBonus.awarded.clear();
                StreakBonus.save();
            },
            save: () => {
                localStorage.setItem('vds_streakBonus', JSON.stringify({
                    awarded: Array.from(StreakBonus.awarded),
                    totalEarned: StreakBonus.totalEarned
                }));
            }
        };

        // Cycle 14: Session Timer Persistence
        const SessionTimer = {
            intervalId: null,
            start: () => {}, // Legacy alias - timer starts automatically via init()
            init: () => {
                // Load previous session time if exists
                const saved = localStorage.getItem('vds_sessionTimer');
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        // Resume from last session if within 30 minutes
                        const timeSinceLast = Date.now() - (data.lastSave || 0);
                        if (timeSinceLast < 30 * 60 * 1000) {
                            STATE.sessionElapsed = data.elapsed || 0;
                            STATE.sessionStartTime = Date.now() - STATE.sessionElapsed;
                            // Cycle 19: Restore session profit tracking
                            if (data.sessionStartChips !== undefined) STATE.sessionStartChips = data.sessionStartChips;
                            if (data.sessionHigh !== undefined) STATE.sessionHigh = data.sessionHigh;
                            if (data.sessionLow !== undefined) STATE.sessionLow = data.sessionLow;
                        } else {
                            // Start fresh session
                            STATE.sessionElapsed = 0;
                            STATE.sessionStartTime = Date.now();
                        }
                    } catch(e) {
                        STATE.sessionElapsed = 0;
                        STATE.sessionStartTime = Date.now();
                    }
                }
                // Start interval to update and save timer
                if (SessionTimer.intervalId) clearInterval(SessionTimer.intervalId);
                SessionTimer.intervalId = setInterval(SessionTimer.tick, 1000);
            },
            tick: () => {
                STATE.sessionElapsed = Date.now() - STATE.sessionStartTime;
                SessionTimer.save();
                ScoreTracker.update();
            },
            formatTime: (ms) => {
                const totalSeconds = Math.floor(ms / 1000);
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                if (hours > 0) {
                    return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }
                return `${minutes}:${seconds.toString().padStart(2, '0')}`;
            },
            save: () => {
                localStorage.setItem('vds_sessionTimer', JSON.stringify({
                    elapsed: STATE.sessionElapsed,
                    lastSave: Date.now(),
                    // Cycle 19: Persist session profit tracking
                    sessionStartChips: STATE.sessionStartChips,
                    sessionHigh: STATE.sessionHigh,
                    sessionLow: STATE.sessionLow
                }));
            },
            reset: () => {
                STATE.sessionElapsed = 0;
                STATE.sessionStartTime = Date.now();
                SessionTimer.save();
            }
        };

        // Cycle 15: Auto-Rebuy System
        const RebuyManager = {
            rebuyAmount: 1000,
            threshold: 10, // Prompt when below minimum bet
            autoRebuyEnabled: false,
            init: () => {
                const saved = localStorage.getItem('vds_autoRebuy');
                if (saved === 'true') {
                    RebuyManager.autoRebuyEnabled = true;
                }
            },
            save: () => {
                localStorage.setItem('vds_autoRebuy', RebuyManager.autoRebuyEnabled);
            },
            checkLowChips: () => {
                return STATE.chips < RebuyManager.threshold;
            },
            promptRebuy: (callback) => {
                if (RebuyManager.autoRebuyEnabled) {
                    RebuyManager.executeRebuy();
                    if (callback) callback();
                    return;
                }
                // Show rebuy prompt
                updateDealer("Running low? I can refresh your stack.");
                setControls([
                    { text: `Rebuy ${RebuyManager.rebuyAmount}`, action: () => {
                        RebuyManager.executeRebuy();
                        if (callback) callback();
                    }, primary: true },
                    { text: 'Auto-Rebuy On', action: () => {
                        RebuyManager.autoRebuyEnabled = true;
                        RebuyManager.save();
                        RebuyManager.executeRebuy();
                        updateDealer("Auto-rebuy enabled. I'll keep you playing.");
                        if (callback) callback();
                    }, primary: false },
                    { text: 'End Session', action: () => {
                        showOverlay("Thanks for playing!", 2000);
                        setTimeout(() => startGame(null), 2000);
                    }, primary: false }
                ]);
            },
            executeRebuy: () => {
                STATE.chips += RebuyManager.rebuyAmount;
                // Don't reset session start chips - maintain accurate P/L
                ChipAnimator.update();
                AudioEngine.chipSound();
                HapticEngine.winCelebration();
                showOverlay(`+${RebuyManager.rebuyAmount} Chips!`, 1500);
                updateDealer("Fresh stack! Good luck.");
            },
            toggleAutoRebuy: () => {
                RebuyManager.autoRebuyEnabled = !RebuyManager.autoRebuyEnabled;
                RebuyManager.save();
                return RebuyManager.autoRebuyEnabled;
            }
        };

        // Cycle 11: Perfect Pairs Side Bet
        const PerfectPairs = {
            evaluate: (hand) => {
                if (hand.length < 2) return null;
                const c1 = hand[0], c2 = hand[1];
                if (c1.rank !== c2.rank) return null;

                // Perfect Pair: same rank and suit (30:1)
                if (c1.suit === c2.suit) {
                    return { type: 'Perfect Pair', payout: 30 };
                }
                // Colored Pair: same rank and color (10:1)
                const redSuits = ['‚ô•', '‚ô¶'];
                const c1Red = redSuits.includes(c1.suit);
                const c2Red = redSuits.includes(c2.suit);
                if (c1Red === c2Red) {
                    return { type: 'Colored Pair', payout: 10 };
                }
                // Mixed Pair: same rank, different color (5:1)
                return { type: 'Mixed Pair', payout: 5 };
            },
            placeBet: (amount) => {
                if (STATE.chips < amount) {
                    updateDealer("Not enough chips for side bet.");
                    return false;
                }
                STATE.sideBet = amount;
                STATE.chips -= amount;
                updateDealer(`Side bet: ${amount} on Perfect Pairs!`);
                HapticEngine.buttonPress();
                return true;
            },
            resolve: () => {
                if (STATE.sideBet === 0) return;

                const result = PerfectPairs.evaluate(STATE.playerHand);
                if (result) {
                    const winnings = STATE.sideBet * result.payout;
                    STATE.chips += winnings + STATE.sideBet;
                    showOverlay(`${result.type}! +${winnings}`, 2000);
                    updateDealer(`${result.type} wins ${result.payout}:1!`);
                    AudioEngine.winFanfare();
                    HapticEngine.winCelebration();
                }
                STATE.sideBet = 0;
            }
        };

        // Cycle 11: Hi-Lo Card Counter
        const CardCounter = {
            runningCount: 0,
            games: ['blackjack'],
            hiLoValue: (card) => {
                const rank = card.rank || card.value;
                if (['2','3','4','5','6'].includes(rank)) return 1;
                if (['10','J','Q','K','A'].includes(rank)) return -1;
                return 0; // 7, 8, 9 are neutral
            },
            updateCard: (card) => {
                if (!STATE.game || !CardCounter.games.includes(STATE.game)) return;
                CardCounter.runningCount += CardCounter.hiLoValue(card);
                CardCounter.updateDisplay();
            },
            updateDisplay: () => {
                const indicator = document.getElementById('count-indicator');
                const countEl = document.getElementById('running-count');
                if (!indicator || !countEl) return;

                if (STATE.game === 'blackjack') {
                    indicator.style.display = 'flex';
                    countEl.textContent = CardCounter.runningCount >= 0 ? `+${CardCounter.runningCount}` : CardCounter.runningCount;
                    countEl.className = 'count-value ' +
                        (CardCounter.runningCount > 0 ? 'positive' : CardCounter.runningCount < 0 ? 'negative' : 'neutral');
                } else {
                    indicator.style.display = 'none';
                }
            },
            reset: () => {
                CardCounter.runningCount = 0;
                CardCounter.updateDisplay();
            },
            getTrueCount: () => {
                const decksRemaining = STATE.deck.length / 52;
                return decksRemaining > 0 ? Math.round(CardCounter.runningCount / decksRemaining) : 0;
            }
        };

        // Cycle 15: Bet Spread Advisor (Kelly Criterion)
        const BetSpreadAdvisor = {
            baseUnit: 10,
            kellyFraction: 0.25, // Conservative 1/4 Kelly
            getEdge: (trueCount) => {
                // Edge only positive when true count > 1
                return Math.max(0, (trueCount - 1) * 0.005);
            },
            calculateOptimalBet: (bankroll, trueCount) => {
                const edge = BetSpreadAdvisor.getEdge(trueCount);
                if (edge <= 0) return BetSpreadAdvisor.baseUnit;
                // Kelly: bet = edge * bankroll / variance (~1.3 for blackjack)
                const kellyBet = (edge / 1.3) * bankroll * BetSpreadAdvisor.kellyFraction;
                // Round to nearest unit, minimum 1 unit
                const units = Math.max(1, Math.round(kellyBet / BetSpreadAdvisor.baseUnit));
                return Math.min(units * BetSpreadAdvisor.baseUnit, bankroll);
            },
            getSuggestedBet: () => {
                const trueCount = CardCounter.getTrueCount();
                return BetSpreadAdvisor.calculateOptimalBet(STATE.chips, trueCount);
            },
            getBetUnits: (trueCount) => {
                // Common 1-8 spread table
                if (trueCount <= 0) return 1;
                if (trueCount === 1) return 1;
                if (trueCount === 2) return 2;
                if (trueCount === 3) return 4;
                if (trueCount === 4) return 6;
                return 8; // 5+
            },
            getAdviceText: () => {
                const tc = CardCounter.getTrueCount();
                const suggested = BetSpreadAdvisor.getSuggestedBet();
                if (tc >= 2) {
                    return `<strong>Bet Advisor:</strong> True Count +${tc} = positive edge. Suggested: ${suggested}`;
                } else if (tc <= -2) {
                    return `<strong>Bet Advisor:</strong> True Count ${tc} = house edge. Minimum bet: ${BetSpreadAdvisor.baseUnit}`;
                }
                return `<strong>Bet Advisor:</strong> Neutral count. Suggested: ${suggested}`;
            }
        };

        // Cycle 16: Mistake Tracker - Tracks player strategy deviations
        const MistakeTracker = {
            mistakes: [],
            correctPlays: 0,
            totalDecisions: 0,
            enabled: true,
            init: () => {
                const saved = localStorage.getItem('vds_mistakeTracker');
                if (saved) {
                    const data = JSON.parse(saved);
                    MistakeTracker.mistakes = data.mistakes || [];
                    MistakeTracker.correctPlays = data.correctPlays || 0;
                    MistakeTracker.totalDecisions = data.totalDecisions || 0;
                }
            },
            save: () => {
                localStorage.setItem('vds_mistakeTracker', JSON.stringify({
                    mistakes: MistakeTracker.mistakes.slice(-50), // Keep last 50
                    correctPlays: MistakeTracker.correctPlays,
                    totalDecisions: MistakeTracker.totalDecisions
                }));
            },
            getOptimalPlay: (playerScore, dealerUp, isSoft, hasPair, pairRank) => {
                // Basic Strategy lookup
                if (hasPair) {
                    // Pair splitting rules
                    if (['A', '8'].includes(pairRank)) return 'split';
                    if (['10', 'J', 'Q', 'K', '5'].includes(pairRank)) return playerScore >= 17 ? 'stand' : 'hit';
                    if (pairRank === '9' && ![7, 10, 11].includes(dealerUp)) return 'split';
                    if (['2', '3', '6', '7'].includes(pairRank) && dealerUp >= 2 && dealerUp <= 7) return 'split';
                    if (pairRank === '4' && [5, 6].includes(dealerUp)) return 'split';
                }
                if (isSoft) {
                    // Soft hands
                    if (playerScore >= 19) return 'stand';
                    if (playerScore === 18) return dealerUp >= 9 ? 'hit' : 'stand';
                    return 'hit'; // Soft 17 or less
                }
                // Hard hands
                if (playerScore >= 17) return 'stand';
                if (playerScore <= 11) return 'hit';
                if (playerScore === 12) return (dealerUp >= 4 && dealerUp <= 6) ? 'stand' : 'hit';
                if (playerScore >= 13 && playerScore <= 16) return dealerUp <= 6 ? 'stand' : 'hit';
                return 'hit';
            },
            recordDecision: (action, playerScore, dealerUp, isSoft, hasPair, pairRank) => {
                if (!MistakeTracker.enabled) return;
                const optimal = MistakeTracker.getOptimalPlay(playerScore, dealerUp, isSoft, hasPair, pairRank);
                MistakeTracker.totalDecisions++;
                if (action === optimal) {
                    MistakeTracker.correctPlays++;
                } else {
                    MistakeTracker.mistakes.push({
                        timestamp: Date.now(),
                        playerScore, dealerUp, isSoft, hasPair, pairRank,
                        action, optimal
                    });
                }
                MistakeTracker.save();
                MistakeTracker.updateDisplay();
            },
            getAccuracy: () => {
                if (MistakeTracker.totalDecisions === 0) return 100;
                return Math.round((MistakeTracker.correctPlays / MistakeTracker.totalDecisions) * 100);
            },
            updateDisplay: () => {
                let display = document.getElementById('mistake-tracker');
                if (!display) {
                    display = document.createElement('div');
                    display.id = 'mistake-tracker';
                    display.className = 'mistake-tracker';
                    display.title = 'Strategy Accuracy';
                    const header = document.querySelector('.header-controls');
                    if (header) header.appendChild(display);
                }
                const accuracy = MistakeTracker.getAccuracy();
                const recentMistakes = MistakeTracker.mistakes.slice(-5).length;
                display.innerHTML = `<span class="tracker-icon">${accuracy >= 90 ? '‚úì' : accuracy >= 70 ? '‚ö†' : '‚úó'}</span><span class="tracker-value">${accuracy}%</span>`;
                display.className = `mistake-tracker ${accuracy >= 90 ? 'excellent' : accuracy >= 70 ? 'good' : 'needs-work'}`;
            },
            reset: () => {
                MistakeTracker.mistakes = [];
                MistakeTracker.correctPlays = 0;
                MistakeTracker.totalDecisions = 0;
                MistakeTracker.save();
                MistakeTracker.updateDisplay();
            }
        };

        // Cycle 10: Deck Count Indicator
        const DeckIndicator = {
            games: ['blackjack', 'poker', 'balatro'],
            init: () => {
                // Will show/hide based on game state
            },
            update: () => {
                const indicator = document.getElementById('deck-indicator');
                const countEl = document.getElementById('deck-count');
                if (!indicator || !countEl) return;

                // Only show for games that use a shared deck
                if (STATE.deck && DeckIndicator.games.includes(STATE.game)) {
                    indicator.style.display = 'flex';
                    const count = STATE.deck.length;
                    countEl.textContent = count;
                    countEl.className = 'deck-count ' +
                        (count < 15 ? 'low' : count < 30 ? 'medium' : 'high');
                } else {
                    indicator.style.display = 'none';
                }
            },
            show: () => {
                const indicator = document.getElementById('deck-indicator');
                if (indicator) indicator.style.display = 'flex';
                DeckIndicator.update();
            },
            hide: () => {
                const indicator = document.getElementById('deck-indicator');
                if (indicator) indicator.style.display = 'none';
            },
            onShuffle: () => {
                showOverlay('Shuffling Deck...', 1000);
                updateDealer('Fresh deck shuffled. Good luck!');
            }
        };

        // Cycle 10: Turbo Mode - Fast Animation Speed
        const TurboMode = {
            enabled: false,
            originalDelay: 1500,
            init: () => {
                TurboMode.enabled = localStorage.getItem('vds_turboMode') === 'true';
                if (TurboMode.enabled) {
                    document.body.classList.add('turbo-mode');
                    STATE.autoplayDelay = 500;
                    const btn = document.getElementById('turbo-btn');
                    if (btn) btn.classList.add('active');
                }
            },
            toggle: () => {
                TurboMode.enabled = !TurboMode.enabled;
                document.body.classList.toggle('turbo-mode', TurboMode.enabled);
                STATE.autoplayDelay = TurboMode.enabled ? 500 : 1500;
                const btn = document.getElementById('turbo-btn');
                if (btn) btn.classList.toggle('active', TurboMode.enabled);
                localStorage.setItem('vds_turboMode', TurboMode.enabled);
                showOverlay(TurboMode.enabled ? 'Turbo Mode ON' : 'Normal Speed', 1000);
                updateDealer(TurboMode.enabled ? 'Speed increased. Let\'s go fast!' : 'Back to normal pace.');
                HapticEngine.buttonPress();
            }
        };

        function updateDealer(msg) {
            document.getElementById('dealer-text').textContent = `"${msg}"`;
        }

        function showOverlay(msg, duration = 2000) {
            const el = document.getElementById('message-overlay');
            document.getElementById('overlay-text').textContent = msg;
            el.classList.add('visible');
            if (STATE.messageTimer) clearTimeout(STATE.messageTimer);
            if (duration > 0) {
                STATE.messageTimer = setTimeout(() => {
                    el.classList.remove('visible');
                }, duration);
            }
        }

        function renderHands() {
            // Cycle 3: DOM null checks for robustness
            const pContainer = safeElement('player-hand');
            const dContainer = safeElement('dealer-hand');
            const cContainer = safeElement('community-cards');

            if (!pContainer || !dContainer || !cContainer) {
                console.error('renderHands: Required DOM elements not found');
                return;
            }

            // Helper to render only new cards with staggered animation (Cycle 2 Consensus)
            const renderContainer = (container, cards, useStagger = true) => {
                const existingCount = container.children.length;
                const newCount = cards.length;

                // If fewer cards now, clear and re-render
                if (newCount < existingCount) {
                    container.innerHTML = '';
                    cards.forEach(c => {
                        const el = c.render();
                        el.classList.add('dealt'); // Already dealt, no animation
                        container.appendChild(el);
                    });
                } else {
                    // Update existing cards (for face-up changes)
                    for (let i = 0; i < existingCount; i++) {
                        const oldEl = container.children[i];
                        const newEl = cards[i].render();
                        // Keep dealt class, update content
                        newEl.classList.add('dealt');
                        container.replaceChild(newEl, oldEl);
                    }
                    // Add only NEW cards with staggered animation
                    for (let i = existingCount; i < newCount; i++) {
                        const el = cards[i].render();
                        if (useStagger && newCount - existingCount > 0) {
                            const staggerIndex = i - existingCount;
                            el.classList.add('stagger-deal', `stagger-deal-${Math.min(staggerIndex, 6)}`);
                            // Play card sound with stagger delay
                            setTimeout(() => AudioEngine.cardDeal(), staggerIndex * 80);
                            // Mark as dealt after animation completes
                            setTimeout(() => {
                                el.classList.remove('stagger-deal', `stagger-deal-${Math.min(staggerIndex, 6)}`);
                                el.classList.add('dealt');
                            }, 400 + staggerIndex * 80);
                        } else {
                            el.classList.add('dealt');
                        }
                        container.appendChild(el);
                    }
                }
            };

            renderContainer(pContainer, STATE.playerHand);
            renderContainer(dContainer, STATE.dealerHand);
            renderContainer(cContainer, STATE.communityCards);

            // Cycle 3: Use animated chip counter
            ChipAnimator.update();
            // Cycle 10: Update deck count display
            DeckIndicator.update();
        }

        function setControls(buttons) {
            const c = document.getElementById('controls');
            c.innerHTML = '';
            buttons.forEach(b => {
                const btn = document.createElement('button');
                let className = `btn ${b.primary ? 'btn-primary' : 'btn-secondary'}`;
                if (b.autoplay && STATE.autoplay) {
                    className += ' btn-autoplay-active';
                }
                btn.className = className;
                btn.textContent = b.text;
                btn.onclick = () => {
                    AudioEngine.buttonClick(); // Cycle 2 audio feedback
                    b.action();
                };
                if (b.disabled) btn.disabled = true;
                c.appendChild(btn);
            });
        }

        // --- Data Management ---
        const DataManager = {
            save: () => {
                const data = {
                    chips: STATE.chips,
                    stats: STATE.stats,
                    scores: STATE.scores,
                    timestamp: Date.now()
                };
                const json = JSON.stringify(data);
                const blob = new Blob([json], {type: "application/json"});
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = `virtual-dealer-save-${new Date().toISOString().slice(0,10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            },
            load: (inputElement) => {
                const file = inputElement.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        if (data.chips !== undefined) STATE.chips = data.chips;
                        if (data.stats) STATE.stats = data.stats;
                        if (data.scores) STATE.scores = data.scores;

                        DataManager.autoSave();
                        alert("Data loaded successfully!");
                        location.reload(); // Reload to ensure state is fresh
                    } catch (err) {
                        alert("Invalid save file");
                    }
                };
                reader.readAsText(file);
            },
            autoSave: () => {
                const data = {
                    chips: STATE.chips,
                    stats: STATE.stats,
                    scores: STATE.scores
                };
                localStorage.setItem('virtualDealerSave', JSON.stringify(data));
            },
            autoLoad: () => {
                const saved = localStorage.getItem('virtualDealerSave');
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        if (data.chips !== undefined) STATE.chips = data.chips;
                        if (data.stats) STATE.stats = data.stats;
                        if (data.scores) STATE.scores = data.scores;
                    } catch (e) { console.error(e); }
                }
            }
        };

        // --- Shared Helpers ---
        function ensureAdviceBox() {
            let box = document.getElementById('game-advice');
            if (!box) {
                const gameArea = document.getElementById('game-area');
                box = document.createElement('div');
                box.id = 'game-advice';
                box.className = 'advice-box visible';
                gameArea.appendChild(box);
            }
            box.style.display = 'block';
            return box;
        }

        function showGameAdvice(text, enabled) {
            const box = ensureAdviceBox();
            if (enabled) {
                box.style.display = 'block';
                box.innerHTML = text;
            } else {
                box.style.display = 'none';
            }
        }

        function animateDeal() {
            // Only animate cards that haven't been animated yet
            const newCards = document.querySelectorAll('.card:not(.dealt)');
            newCards.forEach(c => {
                c.classList.add('dealing');
                c.classList.add('dealt'); // Mark as already animated
            });

            // Remove the dealing class after animation completes
            setTimeout(() => {
                newCards.forEach(c => c.classList.remove('dealing'));
            }, 500);
        }

        function animateWin(winner) {
            const cls = winner === 'Player' ? 'win-player' : 'win-dealer';
            document.querySelectorAll('.card').forEach(c => c.classList.add(cls));
        }

        // --- Game Logic: WAR ---
        const WarGame = {
            deck: [],
            playerDeck: [],
            dealerDeck: [],
            pot: [],
            state: 'idle', // idle, war
            adviceEnabled: true,

            init: () => {
                // Create and split deck
                const fullDeck = createDeck();
                STATE.deck = []; // Not used in War, we use split decks
                WarGame.playerDeck = fullDeck.slice(0, 26);
                WarGame.dealerDeck = fullDeck.slice(26, 52);
                WarGame.pot = [];
                WarGame.state = 'idle';
                
                // Setup UI
                document.getElementById('community-cards').style.display = 'none';
                document.getElementById('chip-display').style.display = 'none';
                
                // Add War specific UI elements if not present
                if (!document.getElementById('war-stats')) {
                    const gameArea = document.getElementById('game-area');
                    const stats = document.createElement('div');
                    stats.id = 'war-stats';
                    stats.className = 'war-stats';
                    gameArea.appendChild(stats);
                }
                document.getElementById('war-stats').style.display = 'block';
                ensureAdviceBox();

                updateDealer("War. I have 26 cards, you have 26. Collect them all to become the Dealer.");
                WarGame.updateUI();
                WarGame.nextRound();
            },

            updateUI: () => {
                const stats = document.getElementById('war-stats');
                if (stats) {
                    stats.innerHTML = `
                        <div>Dealer Deck: ${WarGame.dealerDeck.length}</div>
                        <div style="margin-top:10px">Player Deck: ${WarGame.playerDeck.length}</div>
                        <div style="margin-top:10px; font-size:0.8em; opacity:0.7">Pot: ${WarGame.pot.length}</div>
                    `;
                }
            },

            nextRound: () => {
                if (WarGame.playerDeck.length === 0) {
                    WarGame.endGame('Dealer');
                    return;
                }
                if (WarGame.dealerDeck.length === 0) {
                    WarGame.endGame('Player');
                    return;
                }

                STATE.playerHand = [];
                STATE.dealerHand = [];
                renderHands();

                // Cycle 4 Consensus: Set keyboard context for shortcuts
                KeyboardShortcuts.setContext('war-draw');

                setControls([
                    { text: 'Battle [Space]', action: WarGame.battle, primary: true },
                    { text: STATE.autoplay ? 'Stop Auto' : 'Autoplay', action: Autoplay.toggle, primary: false, autoplay: true },
                    { text: 'Toggle Advice', action: WarGame.toggleAdvice, primary: false }
                ]);
            },

            toggleAdvice: () => {
                WarGame.adviceEnabled = !WarGame.adviceEnabled;
                showGameAdvice("Advice " + (WarGame.adviceEnabled ? "enabled." : "disabled."), WarGame.adviceEnabled);
            },

            showAdvice: (text) => {
                showGameAdvice(text, WarGame.adviceEnabled);
            },

            battle: () => {
                if (WarGame.playerDeck.length === 0 || WarGame.dealerDeck.length === 0) {
                    WarGame.nextRound(); // Trigger end game check
                    return;
                }

                const pCard = WarGame.playerDeck.shift();
                const dCard = WarGame.dealerDeck.shift();

                STATE.playerHand = [pCard];
                STATE.dealerHand = [dCard];

                renderHands();
                animateDeal();
                AudioEngine.warBattle(); // Cycle 17: Card clash sound

                WarGame.pot.push(pCard, dCard);
                WarGame.updateUI();

                const pVal = pCard.pokerValue;
                const dVal = dCard.pokerValue;

                // Delay before resolution to let cards be visible
                const initialDelay = STATE.autoplay ? 1000 : 600;

                setTimeout(async () => {
                    if (STATE.autoplay) {
                        // Show tutoring explanation first
                        await TutoringSystem.explainWarBattle(pCard, dCard);
                    }

                    if (pVal > dVal) {
                        WarGame.resolveRound('Player', pCard, dCard);
                    } else if (dVal > pVal) {
                        WarGame.resolveRound('Dealer', pCard, dCard);
                    } else {
                        WarGame.triggerWar(pCard, dCard);
                    }
                }, initialDelay);
            },

            resolveRound: async (winner, pCard, dCard) => {
                let msg = "";
                const potSize = WarGame.pot.length;

                if (winner === 'Player') {
                    msg = `You win! ${pCard.rank} beats ${dCard.rank}.`;
                    WarGame.showAdvice(`<strong>Nice!</strong> High card wins. You collect ${potSize} cards.`);
                    showOverlay("Round Won");
                    AudioEngine.warVictory(); // Cycle 17: War victory sound
                    ScoreTracker.playerWin();

                    // In autoplay, wait before animating cards away
                    if (STATE.autoplay) {
                        await TutoringSystem.explainWarOutcome(potSize, 'Player');
                    }

                    animateWin('Player');

                    setTimeout(() => {
                        WarGame.playerDeck.push(...WarGame.pot);
                        WarGame.pot = [];
                        WarGame.updateUI();
                        WarGame.nextRound();
                    }, STATE.autoplay ? 800 : 600);
                } else {
                    msg = `I win. ${dCard.rank} beats ${pCard.rank}.`;
                    WarGame.showAdvice(`<strong>Ouch.</strong> Dealer had the higher card. You lost the pot.`);
                    showOverlay("Round Lost");
                    AudioEngine.warDefeat(); // Cycle 17: War defeat sound
                    ScoreTracker.dealerWin();

                    // In autoplay, wait before animating cards away
                    if (STATE.autoplay) {
                        await TutoringSystem.explainWarOutcome(potSize, 'Dealer');
                    }

                    animateWin('Dealer');

                    setTimeout(() => {
                        WarGame.dealerDeck.push(...WarGame.pot);
                        WarGame.pot = [];
                        WarGame.updateUI();
                        WarGame.nextRound();
                    }, STATE.autoplay ? 800 : 600);
                }
                updateDealer(msg);
            },

            triggerWar: async (pCard, dCard) => {
                updateDealer("WAR! We tied. 3 cards down, 1 card up.");
                WarGame.showAdvice(`<strong>WAR!</strong> A tie on ${pCard.rank}s. The stakes just got higher.`);
                AudioEngine.warDeclaration(); // Cycle 17: Dramatic WAR! sound
                ScoreTracker.tie();

                if (STATE.autoplay) {
                    // Auto-proceed to war after explanation shows
                    setTimeout(() => {
                        if (STATE.autoplay) WarGame.executeWar();
                    }, 3500);
                }

                setControls([
                    { text: 'Go to War', action: WarGame.executeWar, primary: true }
                ]);
            },

            executeWar: () => {
                // Check if enough cards
                if (WarGame.playerDeck.length < 4 || WarGame.dealerDeck.length < 4) {
                    // Special case: not enough cards for full war
                    // Simplified: whoever runs out loses immediately in this version
                    if (WarGame.playerDeck.length < 1) WarGame.endGame('Dealer');
                    else if (WarGame.dealerDeck.length < 1) WarGame.endGame('Player');
                    else {
                        // Play what we have
                        WarGame.battle();
                    }
                    return;
                }

                // Burn 3 cards
                for(let i=0; i<3; i++) WarGame.pot.push(WarGame.playerDeck.shift());
                for(let i=0; i<3; i++) WarGame.pot.push(WarGame.dealerDeck.shift());
                
                WarGame.updateUI();
                WarGame.battle(); // Play the war card
            },

            endGame: (winner) => {
                STATE.autoplay = false;
                Autoplay.updateIndicator();

                if (winner === 'Player') {
                    updateDealer("Impossible... You have taken everything.");
                    showOverlay("YOU ARE THE DEALER NOW!", 5000);
                    WarGame.showAdvice("<strong>CONGRATULATIONS!</strong> You have collected the entire deck. You are now the master of the table.");
                } else {
                    updateDealer("The house always wins eventually.");
                    showOverlay("GAME OVER", 3000);
                    WarGame.showAdvice("<strong>Game Over.</strong> You ran out of cards. Try again!");
                }
                setControls([
                    { text: 'Play Again', action: WarGame.init, primary: true },
                    { text: 'Menu', action: showMenu, primary: false }
                ]);
            }
        };

        // --- Game Logic: BLACKJACK ---
        const BlackjackGame = {
            adviceEnabled: true,
            init: () => {
                STATE.deck = createDeck();
                document.getElementById('community-cards').style.display = 'none';
                document.getElementById('chip-display').style.display = 'block';
                if (document.getElementById('war-stats')) document.getElementById('war-stats').style.display = 'none';
                ensureAdviceBox();
                
                updateDealer("Blackjack. Place your bet.");
                BlackjackGame.bettingPhase();
            },
            toggleAdvice: () => {
                BlackjackGame.adviceEnabled = !BlackjackGame.adviceEnabled;
                showGameAdvice("Advice " + (BlackjackGame.adviceEnabled ? "enabled." : "disabled."), BlackjackGame.adviceEnabled);
            },
            showAdvice: (text) => {
                showGameAdvice(text, BlackjackGame.adviceEnabled);
            },
            bettingPhase: () => {
                STATE.playerHand = [];
                STATE.dealerHand = [];
                renderHands();
                // Cycle 15: Check for low chips and prompt rebuy
                if (RebuyManager.checkLowChips()) {
                    RebuyManager.promptRebuy(() => BlackjackGame.bettingPhase());
                    return;
                }
                // Cycle 15: Show bet spread advice based on card count
                const betAdvice = BetSpreadAdvisor.getAdviceText();
                BlackjackGame.showAdvice(betAdvice);
                // Cycle 11: Build controls with optional repeat bet and side bet
                const controls = [];
                // Cycle 15: Add suggested bet button if different from standard bets
                const suggestedBet = BetSpreadAdvisor.getSuggestedBet();
                const tc = CardCounter.getTrueCount();
                if (suggestedBet > 10 && suggestedBet !== 50 && STATE.chips >= suggestedBet) {
                    controls.push({
                        text: `Suggested ${suggestedBet}`,
                        action: () => BlackjackGame.deal(suggestedBet),
                        primary: tc >= 2 // Highlight when count is hot
                    });
                }
                if (STATE.lastBet > 0 && STATE.chips >= STATE.lastBet) {
                    controls.push({ text: `Repeat ${STATE.lastBet} [R]`, action: () => BlackjackGame.deal(STATE.lastBet), primary: true });
                }
                controls.push(
                    { text: 'Bet 10', action: () => BlackjackGame.deal(10), primary: true },
                    { text: 'Bet 50', action: () => BlackjackGame.deal(50), primary: true }
                );
                // Cycle 11: Perfect Pairs side bet toggle
                if (STATE.chips >= 5) {
                    controls.push({
                        text: STATE.sideBet > 0 ? `Pairs: ${STATE.sideBet}` : 'Pairs +5',
                        action: () => {
                            if (STATE.sideBet === 0) {
                                PerfectPairs.placeBet(5);
                            } else {
                                STATE.chips += STATE.sideBet;
                                STATE.sideBet = 0;
                                updateDealer('Side bet removed.');
                            }
                            BlackjackGame.bettingPhase(); // Refresh controls
                        },
                        primary: STATE.sideBet > 0
                    });
                }
                controls.push(
                    { text: STATE.autoplay ? 'Stop Auto' : 'Autoplay', action: Autoplay.toggle, primary: false, autoplay: true },
                    { text: 'Toggle Advice', action: BlackjackGame.toggleAdvice, primary: false },
                    // Cycle 18: Surface CardRoster UI toggle
                    { text: 'Cards', action: CardRoster.toggle, primary: false }
                );
                setControls(controls);
            },
            deal: (bet) => {
                if (STATE.chips < bet) {
                    updateDealer("Insufficient funds.");
                    return;
                }
                STATE.bet = bet;
                STATE.lastBet = bet; // Cycle 11: Save for repeat bet
                STATE.chips -= bet;
                
                if (STATE.deck.length < 10) {
                    STATE.deck = createDeck();
                    CardCounter.reset(); // Cycle 11: Reset count on shuffle
                }

                STATE.playerHand = [STATE.deck.pop(), STATE.deck.pop()];
                STATE.dealerHand = [STATE.deck.pop(), STATE.deck.pop()];
                STATE.dealerHand[1].faceUp = false; // Hide hole card

                // Cycle 11: Count dealt cards (face-up cards only initially)
                STATE.playerHand.forEach(c => CardCounter.updateCard(c));
                CardCounter.updateCard(STATE.dealerHand[0]); // Only upcard initially

                renderHands();
                animateDeal();
                PerfectPairs.resolve(); // Cycle 11: Check for pairs side bet
                BlackjackGame.checkBlackjack();
            },
            getScore: (hand) => {
                let score = 0;
                let aces = 0;
                for (let c of hand) {
                    let val = c.rank === 'A' ? 11 : (['K','Q','J'].includes(c.rank) ? 10 : parseInt(c.rank));
                    score += val;
                    if (c.rank === 'A') aces++;
                }
                while (score > 21 && aces > 0) {
                    score -= 10;
                    aces--;
                }
                return score;
            },
            // Cycle 13: Soft hand detection for improved advice
            isSoftHand: (hand) => {
                let score = 0;
                let aces = 0;
                let usableAces = 0;
                for (let c of hand) {
                    let val = c.rank === 'A' ? 11 : (['K','Q','J'].includes(c.rank) ? 10 : parseInt(c.rank));
                    score += val;
                    if (c.rank === 'A') aces++;
                }
                usableAces = aces;
                while (score > 21 && usableAces > 0) {
                    score -= 10;
                    usableAces--;
                }
                // Soft if at least one Ace is still being counted as 11
                return { score, isSoft: usableAces > 0 && aces > 0, aces };
            },
            checkBlackjack: () => {
                const pScore = BlackjackGame.getScore(STATE.playerHand);
                if (pScore === 21) {
                    BlackjackGame.resolve(true); // Player Blackjack
                } else {
                    BlackjackGame.playerTurn();
                }
            },
            playerTurn: () => {
                const score = BlackjackGame.getScore(STATE.playerHand);
                const dUp = STATE.dealerHand[0].value;
                // Cycle 13: Soft hand indication
                const softInfo = BlackjackGame.isSoftHand(STATE.playerHand);
                const scoreDisplay = softInfo.isSoft ?
                    `${score - 10}/${score} (soft ${score})` : `${score}`;
                updateDealer(`You have ${scoreDisplay}. Hit or Stand? [H/S]`);

                // Cycle 4 Consensus: Set keyboard context for shortcuts
                KeyboardShortcuts.setContext('blackjack-turn');
                // Cycle 18: Enable swipe gestures for mobile
                SwipeGestures.setContext('blackjack-turn');

                // Advice Logic
                let advice = "";

                // Cycle 13: Soft hand advice
                if (softInfo.isSoft && !STATE.playerHand.length === 2) {
                    if (score === 17) {
                        advice = "<strong>Hit!</strong> Soft 17 - safe to improve.";
                    } else if (score === 18) {
                        advice = dUp >= 9 ? "<strong>Hit.</strong> Soft 18 vs strong dealer." : "<strong>Stand.</strong> Soft 18 is decent.";
                    }
                }

                // Cycle 12: Split pair advice
                const hasPair = STATE.playerHand.length === 2 &&
                    STATE.playerHand[0].rank === STATE.playerHand[1].rank;
                if (hasPair) {
                    const pairRank = STATE.playerHand[0].rank;
                    // Basic strategy split recommendations
                    const alwaysSplit = ['A', '8'];
                    const neverSplit = ['10', 'J', 'Q', 'K', '5'];
                    const splitAgainstWeak = ['2', '3', '6', '7']; // Split vs dealer 2-7
                    const split9s = ['2', '3', '4', '5', '6', '8', '9']; // Split 9s except vs 7, 10, A

                    if (alwaysSplit.includes(pairRank)) {
                        advice = `<strong>Split!</strong> Always split ${pairRank}s for maximum value.`;
                    } else if (neverSplit.includes(pairRank)) {
                        advice = `<strong>Don't split ${pairRank}s.</strong> Keep your strong hand.`;
                    } else if (pairRank === '4' && (dUp === 5 || dUp === 6)) {
                        advice = `<strong>Split 4s</strong> against dealer ${dUp}.`;
                    } else if (pairRank === '9' && !['7', '10', 'A'].includes(String(dUp))) {
                        advice = `<strong>Split 9s</strong> against dealer ${dUp}.`;
                    } else if (splitAgainstWeak.includes(pairRank) && dUp >= 2 && dUp <= 7) {
                        advice = `<strong>Split ${pairRank}s</strong> against dealer's weak ${dUp}.`;
                    } else {
                        // Fallback to regular advice for pairs not worth splitting
                        advice = `Pair of ${pairRank}s - `;
                    }
                }

                // Regular advice (or append to pair advice)
                if (!hasPair || advice.endsWith(' - ')) {
                    const baseAdvice = score >= 17 ? "<strong>Stand.</strong> Strong hand." :
                        score <= 11 ? "<strong>Hit.</strong> No bust risk." :
                        dUp >= 7 ? `<strong>Hit.</strong> Dealer shows ${dUp}.` :
                        `<strong>Stand.</strong> Let dealer bust.`;
                    advice = advice.endsWith(' - ') ? advice + baseAdvice : baseAdvice;
                }

                BlackjackGame.showAdvice(advice);

                const controls = [
                    { text: 'Hit [H]', action: BlackjackGame.hit, primary: true },
                    { text: 'Stand [S]', action: BlackjackGame.stand, primary: false }
                ];
                // Cycle 8: Add Double Down option when available
                if (BlackjackGame.canDoubleDown()) {
                    controls.push({ text: 'Double [D]', action: BlackjackGame.doubleDown, primary: score >= 9 && score <= 11 });
                }
                // Cycle 16: Add Surrender option when available
                if (BlackjackGame.canSurrender()) {
                    // Surrender is recommended for hard 16 vs 9/10/A, hard 15 vs 10
                    const surrenderOptimal = (score === 16 && dUp >= 9) || (score === 15 && dUp === 10);
                    controls.push({ text: 'Surrender [R]', action: BlackjackGame.surrender, primary: false });
                }
                controls.push(
                    { text: STATE.autoplay ? 'Stop Auto' : 'Autoplay', action: Autoplay.toggle, primary: false, autoplay: true },
                    { text: 'Toggle Advice', action: BlackjackGame.toggleAdvice, primary: false },
                    // Cycle 18: Surface CardRoster UI toggle during play
                    { text: 'Cards', action: CardRoster.toggle, primary: false }
                );
                setControls(controls);
            },
            hit: async () => {
                // Cycle 16: Record decision before executing
                const preScore = BlackjackGame.getScore(STATE.playerHand);
                const dUp = STATE.dealerHand[0].value;
                const softInfo = BlackjackGame.isSoftHand(STATE.playerHand);
                const hasPair = STATE.playerHand.length === 2 && STATE.playerHand[0].rank === STATE.playerHand[1].rank;
                const pairRank = hasPair ? STATE.playerHand[0].rank : null;
                MistakeTracker.recordDecision('hit', preScore, dUp, softInfo.isSoft, hasPair, pairRank);

                const card = STATE.deck.pop();
                STATE.playerHand.push(card);
                CardCounter.updateCard(card); // Cycle 11: Count the hit card
                renderHands();
                animateDeal();
                const score = BlackjackGame.getScore(STATE.playerHand);
                if (score > 21) {
                    updateDealer("Bust! House wins.");
                    BlackjackGame.showAdvice("<strong>Bust!</strong> You went over 21.");
                    // Cycle 19: Show chip loss in overlay
                    showOverlay(`Bust! -${STATE.bet}`);
                    AudioEngine.bustSound(); // Cycle 12: Bust sound effect
                    ScoreTracker.dealerWin();

                    if (STATE.autoplay) {
                        await TutoringSystem.explainBlackjackResult(score, 0, 'bust');
                    }

                    animateWin('Dealer');
                    setTimeout(BlackjackGame.bettingPhase, STATE.autoplay ? 1500 : 2000);
                } else {
                    BlackjackGame.playerTurn();
                }
            },
            stand: () => {
                // Cycle 16: Record decision before executing
                const preScore = BlackjackGame.getScore(STATE.playerHand);
                const dUp = STATE.dealerHand[0].value;
                const softInfo = BlackjackGame.isSoftHand(STATE.playerHand);
                const hasPair = STATE.playerHand.length === 2 && STATE.playerHand[0].rank === STATE.playerHand[1].rank;
                const pairRank = hasPair ? STATE.playerHand[0].rank : null;
                MistakeTracker.recordDecision('stand', preScore, dUp, softInfo.isSoft, hasPair, pairRank);

                STATE.dealerHand[1].faceUp = true;
                CardCounter.updateCard(STATE.dealerHand[1]); // Cycle 11: Count hole card
                renderHands();
                BlackjackGame.dealerTurn();
            },
            // Cycle 8: Double Down - doubles bet, gets one card, must stand
            canDoubleDown: () => {
                return STATE.playerHand.length === 2 && STATE.chips >= STATE.bet;
            },
            doubleDown: () => {
                if (!BlackjackGame.canDoubleDown()) {
                    updateDealer("Insufficient chips to double down.");
                    return;
                }
                STATE.chips -= STATE.bet;
                STATE.bet *= 2;
                STATE.playerHand.push(STATE.deck.pop());
                renderHands();
                animateDeal();
                HapticEngine.cardDeal();
                const score = BlackjackGame.getScore(STATE.playerHand);
                if (score > 21) {
                    updateDealer("Bust! House wins.");
                    // Cycle 19: Show doubled bet loss in overlay
                    showOverlay(`Bust! -${STATE.bet}`);
                    AudioEngine.bustSound(); // Cycle 12: Bust sound effect
                    HapticEngine.loseFeedback();
                    ScoreTracker.dealerWin();
                    setTimeout(BlackjackGame.bettingPhase, STATE.autoplay ? 1500 : 2000);
                } else {
                    updateDealer(`Doubled! You have ${score}. Dealer's turn.`);
                    STATE.dealerHand[1].faceUp = true;
                    renderHands();
                    setTimeout(() => BlackjackGame.dealerTurn(), 1000);
                }
            },
            // Cycle 16: Late Surrender - forfeit half bet after dealer checks for blackjack
            canSurrender: () => {
                // Only available on first decision (2 cards), no natural blackjack
                if (STATE.playerHand.length !== 2) return false;
                const score = BlackjackGame.getScore(STATE.playerHand);
                if (score === 21) return false; // Can't surrender blackjack
                return true;
            },
            surrender: () => {
                if (!BlackjackGame.canSurrender()) {
                    updateDealer("Surrender not available.");
                    return;
                }
                // Return half the bet
                const halfBet = Math.floor(STATE.bet / 2);
                STATE.chips += halfBet;

                // Reveal dealer's hole card
                STATE.dealerHand[1].faceUp = true;
                renderHands();

                updateDealer(`You surrender. Half your bet (${halfBet}) returned.`);
                BlackjackGame.showAdvice("<strong>Surrendered.</strong> Strategic retreat - saved half your bet.");
                showOverlay("Surrender");
                AudioEngine.loseSound();
                HapticEngine.loseFeedback();
                ScoreTracker.dealerWin(); // Counts as a loss

                setTimeout(BlackjackGame.bettingPhase, 2000);
            },
            dealerTurn: () => {
                let dScore = BlackjackGame.getScore(STATE.dealerHand);

                const playDealer = () => {
                    if (dScore < 17) {
                        const card = STATE.deck.pop();
                        STATE.dealerHand.push(card);
                        CardCounter.updateCard(card); // Cycle 11: Count dealer hits
                        renderHands();
                        animateDeal();
                        dScore = BlackjackGame.getScore(STATE.dealerHand);
                        setTimeout(playDealer, 1000);
                    } else {
                        BlackjackGame.resolve();
                    }
                };
                playDealer();
            },
            resolve: async (playerBlackjack = false) => {
                const pScore = BlackjackGame.getScore(STATE.playerHand);
                const dScore = BlackjackGame.getScore(STATE.dealerHand);

                let win = false;
                let push = false;

                if (playerBlackjack) {
                    // Check if dealer also has blackjack
                    STATE.dealerHand[1].faceUp = true;
                    renderHands();
                    if (BlackjackGame.getScore(STATE.dealerHand) === 21) push = true;
                    else win = true;
                } else if (dScore > 21) {
                    win = true;
                    // Cycle 14: Dealer bust fanfare celebration
                    AudioEngine.dealerBustFanfare();
                    HapticEngine.dealerBust();
                    WinCelebration.dealerBustCelebration();
                    updateDealer("Dealer busts! You win!");
                } else if (pScore > dScore) {
                    win = true;
                } else if (pScore === dScore) {
                    push = true;
                }

                if (win) {
                    const payout = playerBlackjack ? 2.5 : 2;
                    STATE.chips += STATE.bet * payout;
                    updateDealer(playerBlackjack ? "Blackjack!" : "You win.");
                    BlackjackGame.showAdvice("<strong>Winner!</strong> " + (playerBlackjack ? "Blackjack pays 3:2." : "You beat the dealer."));

                    // Cycle 16: Special blackjack celebration for natural 21
                    // Cycle 19: Show chip delta in overlay
                    const winAmount = Math.floor(STATE.bet * payout) - STATE.bet;
                    if (playerBlackjack) {
                        showOverlay(`BLACKJACK! +${winAmount}`);
                        AudioEngine.blackjackFanfare();
                        HapticEngine.blackjackCelebration();
                        WinCelebration.blackjackConfetti();
                    } else {
                        showOverlay(`You Win! +${winAmount}`);
                    }
                    ScoreTracker.playerWin();

                    if (STATE.autoplay) {
                        await TutoringSystem.explainBlackjackResult(pScore, dScore, 'win');
                    }

                    // Cycle 17: Highlight winning hand before animation
                    const playerCards = document.querySelectorAll('#player-hand .card');
                    playerCards.forEach(card => card.classList.add('winning-hand'));

                    // Delay animation to show winning glow
                    await new Promise(resolve => setTimeout(resolve, 800));
                    playerCards.forEach(card => card.classList.remove('winning-hand'));

                    animateWin('Player');

                    // Win Condition
                    if (STATE.chips >= 5000) {
                        STATE.autoplay = false;
                        Autoplay.updateIndicator();
                        TutoringSystem.hide();
                        setTimeout(() => {
                            showOverlay("YOU BROKE THE BANK!", 5000);
                            updateDealer("You have cleaned me out. You are the Dealer now.");
                        }, 2000);
                        return;
                    }
                } else if (push) {
                    STATE.chips += STATE.bet;
                    updateDealer("Push.");
                    BlackjackGame.showAdvice("<strong>Push.</strong> Bets returned.");
                    // Cycle 19: Show bet returned in overlay
                    showOverlay(`Push (${STATE.bet} returned)`);
                    ScoreTracker.tie();
                    // Cycle 14: Push animation with yellow/gold particles and chime
                    AudioEngine.pushChime();
                    HapticEngine.pushFeedback();
                    WinCelebration.pushPulse();

                    if (STATE.autoplay) {
                        await TutoringSystem.explainBlackjackResult(pScore, dScore, 'push');
                    }
                } else {
                    updateDealer("House wins.");
                    BlackjackGame.showAdvice("<strong>Loss.</strong> Better luck next hand.");
                    // Cycle 19: Show chip loss in overlay
                    showOverlay(`Dealer Wins -${STATE.bet}`);
                    ScoreTracker.dealerWin();

                    if (STATE.autoplay) {
                        await TutoringSystem.explainBlackjackResult(pScore, dScore, 'lose');
                    }

                    animateWin('Dealer');
                }

                setTimeout(BlackjackGame.bettingPhase, STATE.autoplay ? 1500 : 3000);
            }
        };

        // --- Game Logic: POKER (Simplified Heads-Up) ---
        const PokerGame = {
            adviceEnabled: true,
            init: () => {
                STATE.deck = createDeck();
                document.getElementById('community-cards').style.display = 'flex';
                document.getElementById('chip-display').style.display = 'block';
                if (document.getElementById('war-stats')) document.getElementById('war-stats').style.display = 'none';
                ensureAdviceBox();
                
                updateDealer("Texas Hold'em. Ante up.");
                PokerGame.startRound();
            },
            toggleAdvice: () => {
                PokerGame.adviceEnabled = !PokerGame.adviceEnabled;
                showGameAdvice("Advice " + (PokerGame.adviceEnabled ? "enabled." : "disabled."), PokerGame.adviceEnabled);
                if (PokerGame.adviceEnabled && STATE.playerHand.length > 0) {
                    PokerGame.analyzeHand("Current");
                }
            },
            showAdvice: (text) => {
                showGameAdvice(text, PokerGame.adviceEnabled);
            },
            startRound: () => {
                STATE.playerHand = [];
                STATE.dealerHand = [];
                STATE.communityCards = [];
                renderHands();
                PokerGame.showAdvice("<strong>Ante Up:</strong> Pay the blind to see your cards.");
                setControls([
                    { text: 'Ante 20', action: () => PokerGame.deal(20), primary: true },
                    { text: STATE.autoplay ? 'Stop Auto' : 'Autoplay', action: Autoplay.toggle, primary: false, autoplay: true },
                    { text: 'Toggle Advice', action: PokerGame.toggleAdvice, primary: false }
                ]);
            },
            deal: (ante) => {
                if (STATE.chips < ante) return;
                STATE.bet = ante;
                STATE.chips -= ante;
                
                if (STATE.deck.length < 15) STATE.deck = createDeck();

                STATE.playerHand = [STATE.deck.pop(), STATE.deck.pop()];
                STATE.dealerHand = [STATE.deck.pop(), STATE.deck.pop()];
                STATE.dealerHand.forEach(c => c.faceUp = false);

                renderHands();
                animateDeal();
                updateDealer("Pre-flop. Call or Fold?");
                
                PokerGame.analyzeHand("Pre-flop");

                setControls([
                    { text: 'Call (20)', action: () => PokerGame.flop(20), primary: true },
                    { text: 'Fold', action: PokerGame.fold, primary: false },
                    { text: STATE.autoplay ? 'Stop Auto' : 'Autoplay', action: Autoplay.toggle, primary: false, autoplay: true },
                    { text: 'Toggle Advice', action: PokerGame.toggleAdvice, primary: false }
                ]);
            },
            flop: (bet) => {
                if (STATE.chips < bet) return;
                STATE.chips -= bet;
                STATE.bet += bet;

                STATE.communityCards.push(STATE.deck.pop(), STATE.deck.pop(), STATE.deck.pop());
                renderHands();
                animateDeal();
                updateDealer("The Flop. Check or Bet?");
                
                PokerGame.analyzeHand("Flop");

                setControls([
                    { text: 'Check', action: () => PokerGame.turn(0), primary: false },
                    { text: 'Bet 50', action: () => PokerGame.turn(50), primary: true },
                    { text: STATE.autoplay ? 'Stop Auto' : 'Autoplay', action: Autoplay.toggle, primary: false, autoplay: true },
                    { text: 'Toggle Advice', action: PokerGame.toggleAdvice, primary: false }
                ]);
            },
            turn: (bet) => {
                if (STATE.chips < bet) return;
                STATE.chips -= bet;
                STATE.bet += bet;

                STATE.communityCards.push(STATE.deck.pop());
                renderHands();
                animateDeal();
                updateDealer("The Turn.");
                
                PokerGame.analyzeHand("Turn");

                setControls([
                    { text: 'Check', action: () => PokerGame.river(0), primary: false },
                    { text: 'Bet 50', action: () => PokerGame.river(50), primary: true },
                    { text: STATE.autoplay ? 'Stop Auto' : 'Autoplay', action: Autoplay.toggle, primary: false, autoplay: true },
                    { text: 'Toggle Advice', action: PokerGame.toggleAdvice, primary: false }
                ]);
            },
            river: (bet) => {
                if (STATE.chips < bet) return;
                STATE.chips -= bet;
                STATE.bet += bet;

                STATE.communityCards.push(STATE.deck.pop());
                renderHands();
                animateDeal();
                updateDealer("The River. Final decision.");
                
                PokerGame.analyzeHand("River");

                setControls([
                    { text: 'Check', action: () => PokerGame.showdown(0), primary: false },
                    { text: 'Bet 100', action: () => PokerGame.showdown(100), primary: true },
                    { text: STATE.autoplay ? 'Stop Auto' : 'Autoplay', action: Autoplay.toggle, primary: false, autoplay: true },
                    { text: 'Toggle Advice', action: PokerGame.toggleAdvice, primary: false }
                ]);
            },
            analyzeHand: (stage) => {
                const score = PokerGame.evaluate(STATE.playerHand, STATE.communityCards);
                const winProb = PokerGame.calculateOdds();
                
                let advice = `<strong>${stage}:</strong> Win Probability: ${winProb}%<br>`;
                
                if (score > 60000) advice += "Full House or better! All in.";
                else if (score > 50000) advice += "Flush! Very strong.";
                else if (score > 40000) advice += "Straight! Strong hand.";
                else if (score > 30000) advice += "Three of a Kind. Good position.";
                else if (score > 20000) advice += "Two Pair. Strong.";
                else if (score > 10000) advice += "Pair. Decent.";
                else if (winProb > 60) advice += "High Card but good odds.";
                else advice += "Weak hand. Caution.";
                
                PokerGame.showAdvice(advice);
            },
            showdown: (bet) => {
                if (STATE.chips < bet) return;
                STATE.chips -= bet;
                STATE.bet += bet;

                STATE.dealerHand.forEach(c => c.faceUp = true);
                renderHands();

                const pScore = PokerGame.evaluate(STATE.playerHand, STATE.communityCards);
                const dScore = PokerGame.evaluate(STATE.dealerHand, STATE.communityCards);

                if (pScore > dScore) {
                    STATE.chips += STATE.bet * 2;
                    // Cycle 19: Show chip win in overlay
                    const winAmount = STATE.bet;
                    updateDealer("You have the better hand.");
                    showOverlay(`You Win! +${winAmount}`);
                    animateWin('Player');
                    PokerGame.showAdvice("<strong>Winner!</strong> Your hand was stronger.");
                    ScoreTracker.playerWin();

                    if (STATE.chips >= 5000) {
                        STATE.autoplay = false;
                        Autoplay.updateIndicator();
                        setTimeout(() => {
                            showOverlay("POKER CHAMPION!", 5000);
                            updateDealer("You cleaned me out. The table is yours.");
                        }, 2000);
                        return;
                    }
                } else if (pScore === dScore) {
                    STATE.chips += STATE.bet;
                    updateDealer("Split pot.");
                    // Cycle 19: Show bet returned in overlay
                    showOverlay(`Tie (${STATE.bet} returned)`);
                    PokerGame.showAdvice("<strong>Tie!</strong> Same hand strength.");
                    ScoreTracker.tie();
                } else {
                    updateDealer("My hand is stronger.");
                    // Cycle 19: Show chip loss in overlay
                    showOverlay(`Dealer Wins -${STATE.bet}`);
                    animateWin('Dealer');
                    PokerGame.showAdvice("<strong>Lost.</strong> Dealer had a better hand.");
                    ScoreTracker.dealerWin();
                }

                setTimeout(PokerGame.startRound, 4000);
            },
            fold: () => {
                updateDealer("Folded.");
                PokerGame.showAdvice("<strong>Folded.</strong> Saving chips for a better hand.");
                ScoreTracker.dealerWin();
                setTimeout(PokerGame.startRound, 1000);
            },
            evaluate: (hand, community) => {
                const all = [...hand, ...community];
                if (all.length === 0) return 0;
                
                // Sort by rank descending
                all.sort((a, b) => b.pokerValue - a.pokerValue);
                
                // Check Flush
                const suits = {};
                all.forEach(c => suits[c.suit] = (suits[c.suit] || 0) + 1);
                let flushSuit = null;
                for (let s in suits) if (suits[s] >= 5) flushSuit = s;
                
                let flushScore = 0;
                if (flushSuit) {
                    const flushCards = all.filter(c => c.suit === flushSuit);
                    flushScore = 50000 + flushCards[0].pokerValue;
                }

                // Check Straight
                let straightScore = 0;
                let uniqueRanks = [...new Set(all.map(c => c.pokerValue))];
                let streak = 0;
                let maxStraightRank = 0;
                for (let i = 0; i < uniqueRanks.length - 1; i++) {
                    if (uniqueRanks[i] - uniqueRanks[i+1] === 1) {
                        streak++;
                        if (streak >= 4) maxStraightRank = uniqueRanks[i - 3];
                    } else {
                        streak = 0;
                    }
                }
                // Wheel (A-5)
                if (!maxStraightRank && uniqueRanks.includes(14) && uniqueRanks.includes(5) && uniqueRanks.includes(4) && uniqueRanks.includes(3) && uniqueRanks.includes(2)) {
                    maxStraightRank = 5;
                }
                
                if (maxStraightRank) straightScore = 40000 + maxStraightRank;

                // Check Pairs/Trips/Quads
                const counts = {};
                all.forEach(c => counts[c.pokerValue] = (counts[c.pokerValue] || 0) + 1);
                
                let pairScore = 0;
                let four = 0, three = 0, pair1 = 0, pair2 = 0;
                
                for (let r in counts) {
                    const rank = parseInt(r);
                    const count = counts[r];
                    if (count === 4) four = rank;
                    else if (count === 3) {
                        if (three > 0) pair1 = three; // downgrade previous three to pair
                        three = rank;
                    }
                    else if (count === 2) {
                        if (pair1 > 0) pair2 = pair1;
                        pair1 = rank;
                    }
                }
                
                if (four) pairScore = 70000 + four;
                else if (three && pair1) pairScore = 60000 + three; // Full House
                else if (flushScore) return flushScore; // Flush beats straight
                else if (straightScore) return straightScore;
                else if (three) pairScore = 30000 + three;
                else if (pair1 && pair2) pairScore = 20000 + pair1;
                else if (pair1) pairScore = 10000 + pair1;
                else pairScore = all[0].pokerValue; // High card
                
                return pairScore;
            },
            calculateOdds: () => {
                // Monte Carlo Simulation
                const iterations = 500;
                let wins = 0;
                let ties = 0;
                
                // Known cards
                const knownCards = [...STATE.playerHand, ...STATE.communityCards];
                const knownIds = new Set(knownCards.map(c => c.suit + c.rank));
                
                // Create a deck of remaining cards
                const fullDeck = createDeck();
                const remainingDeck = fullDeck.filter(c => !knownIds.has(c.suit + c.rank));
                
                for (let i = 0; i < iterations; i++) {
                    // Shuffle remaining deck
                    const simDeck = [...remainingDeck];
                    for (let j = simDeck.length - 1; j > 0; j--) {
                        const k = Math.floor(Math.random() * (j + 1));
                        [simDeck[j], simDeck[k]] = [simDeck[k], simDeck[j]];
                    }
                    
                    // Deal opponent hand
                    const oppHand = [simDeck.pop(), simDeck.pop()];
                    
                    // Deal remaining community cards
                    const simCommunity = [...STATE.communityCards];
                    while (simCommunity.length < 5) {
                        simCommunity.push(simDeck.pop());
                    }
                    
                    const myScore = PokerGame.evaluate(STATE.playerHand, simCommunity);
                    const oppScore = PokerGame.evaluate(oppHand, simCommunity);
                    
                    if (myScore > oppScore) wins++;
                    else if (myScore === oppScore) ties++;
                }
                
                return ((wins + ties/2) / iterations * 100).toFixed(1);
            }
        };

        // --- Balatro Game ---
        const BalatroGame = {
            state: {
                ante: 1,
                round: 1,
                blind: 'small', // small, big, boss
                blindScore: 300,
                currentScore: 0,
                handsLeft: 4,
                discardsLeft: 3,
                jokers: [],
                handLevels: JSON.parse(JSON.stringify(BALATRO_HANDS)),
                money: 4,
                maxJokers: 5,
                handSize: 8,
                selectedCards: []
            },

            init: () => {
                // Reset Balatro state
                BalatroGame.state = {
                    ante: 1,
                    round: 1,
                    blind: 'small',
                    blindScore: 300,
                    currentScore: 0,
                    handsLeft: 4,
                    discardsLeft: 3,
                    jokers: [],
                    handLevels: JSON.parse(JSON.stringify(BALATRO_HANDS)),
                    money: 4,
                    maxJokers: 5,
                    handSize: 8,
                    selectedCards: []
                };

                // Initialize deck with roster tracking
                CardRoster.init();
                STATE.deck = [];
                for (let s of SUITS) {
                    for (let r of RANKS) {
                        const card = new Card(s, r);
                        STATE.deck.push(card);
                        CardRoster.register(card);
                    }
                }
                STATE.deck = shuffle(STATE.deck);

                // Give starting joker
                BalatroGame.state.jokers.push(JOKER_LIBRARY[0]); // Basic Joker

                document.getElementById('community-cards').style.display = 'none';
                document.getElementById('chip-display').style.display = 'none';
                updateDealer('"Balatro! Build poker hands, score chips, and beat the blinds."');

                BalatroGame.renderHUD();
                BalatroGame.startRound();
            },

            startRound: () => {
                // Calculate blind score requirement
                // Cycle 5 Consensus: Gentler scaling (1.3x instead of 1.5x) for better early game
                const bs = BalatroGame.state;
                const baseScores = { small: 300, big: 450, boss: 600 };
                bs.blindScore = Math.floor(baseScores[bs.blind] * Math.pow(1.3, bs.ante - 1));
                bs.currentScore = 0;
                bs.handsLeft = 4;
                bs.discardsLeft = 3;

                // Draw initial hand
                STATE.playerHand = [];
                for (let i = 0; i < bs.handSize && STATE.deck.length > 0; i++) {
                    const card = STATE.deck.pop();
                    card.location = 'playerHand';
                    CardRoster.move(card.id, 'deck', 'playerHand');
                    STATE.playerHand.push(card);
                }

                BalatroGame.renderHand();
                BalatroGame.setControls();
                BalatroGame.updateHUD();
            },

            renderHand: () => {
                const container = document.getElementById('player-hand');
                container.innerHTML = '';
                STATE.playerHand.forEach(card => {
                    card.faceUp = true;
                    const el = card.render(true); // selectable
                    if (card.selected) el.classList.add('selected');
                    el.style.transform = card.selected ? 'translateY(-15px)' : '';
                    el.onclick = () => {
                        card.selected = !card.selected;
                        BalatroGame.renderHand();
                        BalatroGame.updateHandPreview();
                    };
                    container.appendChild(el);
                });
                animateDeal();
            },

            renderHUD: () => {
                let hud = document.getElementById('balatro-hud');
                if (!hud) {
                    hud = document.createElement('div');
                    hud.id = 'balatro-hud';
                    hud.className = 'balatro-hud';
                    document.body.appendChild(hud);
                }
                hud.style.display = 'block';
            },

            updateHUD: () => {
                const bs = BalatroGame.state;
                const hud = document.getElementById('balatro-hud');
                if (!hud) return;

                hud.innerHTML = `
                    <h4>Ante ${bs.ante} - ${bs.blind.charAt(0).toUpperCase() + bs.blind.slice(1)} Blind</h4>
                    <div class="balatro-stat">
                        <span class="label">Score:</span>
                        <span class="value">${bs.currentScore} / ${bs.blindScore}</span>
                    </div>
                    <div class="balatro-stat">
                        <span class="label">Hands:</span>
                        <span class="value">${bs.handsLeft}</span>
                    </div>
                    <div class="balatro-stat">
                        <span class="label">Discards:</span>
                        <span class="value">${bs.discardsLeft}</span>
                    </div>
                    <div class="balatro-stat">
                        <span class="label">Money:</span>
                        <span class="value">$${bs.money}</span>
                    </div>
                    <div class="joker-slots">
                        ${bs.jokers.map(j => j.render().outerHTML).join('')}
                        ${bs.jokers.length < bs.maxJokers ? '<div class="joker-slot-empty">Empty</div>' : ''}
                    </div>
                    <button class="btn btn-secondary" onclick="CardRoster.toggle()" style="width:100%;margin-top:10px;padding:5px;">Card Roster</button>
                `;
            },

            updateHandPreview: () => {
                const selected = STATE.playerHand.filter(c => c.selected);
                let preview = document.getElementById('hand-preview');

                if (selected.length === 0) {
                    if (preview) preview.remove();
                    return;
                }

                const { handName, chips, mult } = BalatroGame.evaluateHand(selected);

                if (!preview) {
                    preview = document.createElement('div');
                    preview.id = 'hand-preview';
                    preview.className = 'hand-score-preview';
                    document.getElementById('player-hand').appendChild(preview);
                }

                preview.innerHTML = `${handName}: <span class="chips">${chips}</span> √ó <span class="mult">${mult}</span> = ${chips * mult}`;
            },

            evaluateHand: (cards) => {
                if (cards.length === 0) return { handName: 'None', chips: 0, mult: 0, scoringCards: [] };

                const ranks = cards.map(c => c.pokerValue).sort((a, b) => b - a);
                const suits = cards.map(c => c.suit);
                const rankCounts = {};
                ranks.forEach(r => rankCounts[r] = (rankCounts[r] || 0) + 1);
                const counts = Object.values(rankCounts).sort((a, b) => b - a);

                const isFlush = suits.every(s => s === suits[0]) && cards.length >= 5;
                const uniqueRanks = [...new Set(ranks)].sort((a, b) => a - b);
                const isStraight = uniqueRanks.length >= 5 &&
                    (uniqueRanks[uniqueRanks.length - 1] - uniqueRanks[0] === 4 ||
                     (uniqueRanks.includes(14) && uniqueRanks.includes(2) && uniqueRanks.includes(3) && uniqueRanks.includes(4) && uniqueRanks.includes(5)));

                let handName = 'High Card';
                let scoringCards = [cards[0]]; // Just highest card for high card

                if (counts[0] === 5) {
                    handName = isFlush ? 'Flush Five' : 'Five of a Kind';
                    scoringCards = cards;
                } else if (counts[0] === 4) {
                    handName = 'Four of a Kind';
                    const quadRank = Object.keys(rankCounts).find(r => rankCounts[r] === 4);
                    scoringCards = cards.filter(c => c.pokerValue == quadRank);
                } else if (counts[0] === 3 && counts[1] === 2) {
                    handName = isFlush ? 'Flush House' : 'Full House';
                    scoringCards = cards;
                } else if (isFlush && isStraight) {
                    const isRoyal = uniqueRanks.includes(14) && uniqueRanks.includes(13);
                    handName = isRoyal ? 'Royal Flush' : 'Straight Flush';
                    scoringCards = cards;
                } else if (isFlush) {
                    handName = 'Flush';
                    scoringCards = cards;
                } else if (isStraight) {
                    handName = 'Straight';
                    scoringCards = cards;
                } else if (counts[0] === 3) {
                    handName = 'Three of a Kind';
                    const tripRank = Object.keys(rankCounts).find(r => rankCounts[r] === 3);
                    scoringCards = cards.filter(c => c.pokerValue == tripRank);
                } else if (counts[0] === 2 && counts[1] === 2) {
                    handName = 'Two Pair';
                    const pairRanks = Object.keys(rankCounts).filter(r => rankCounts[r] === 2);
                    scoringCards = cards.filter(c => pairRanks.includes(String(c.pokerValue)));
                } else if (counts[0] === 2) {
                    handName = 'Pair';
                    const pairRank = Object.keys(rankCounts).find(r => rankCounts[r] === 2);
                    scoringCards = cards.filter(c => c.pokerValue == pairRank);
                }

                const handData = BalatroGame.state.handLevels[handName];
                let baseChips = handData.chips + (handData.level - 1) * 10;
                let baseMult = handData.mult + (handData.level - 1);

                // Add chip values from scoring cards
                scoringCards.forEach(c => {
                    baseChips += c.balatroChips;
                    if (c.enhancement === 'mult') baseMult += 4;
                });

                // Apply joker effects
                let score = { chips: baseChips, mult: baseMult };
                BalatroGame.state.jokers.forEach((joker, idx) => {
                    score = joker.effect(scoringCards, score, BalatroGame.state, BalatroGame.state.jokers, idx);
                });

                // Edition bonuses
                scoringCards.forEach(c => {
                    if (c.edition === 'foil') score.chips += 50;
                    if (c.edition === 'holo') score.mult += 10;
                    if (c.edition === 'poly') score.mult *= 1.5;
                });

                return { handName, chips: Math.floor(score.chips), mult: Math.floor(score.mult), scoringCards };
            },

            playHand: () => {
                const selected = STATE.playerHand.filter(c => c.selected);
                if (selected.length === 0 || selected.length > 5) {
                    showMessage('Select 1-5 cards to play');
                    return;
                }
                if (BalatroGame.state.handsLeft <= 0) {
                    showMessage('No hands remaining!');
                    return;
                }

                const { handName, chips, mult, scoringCards } = BalatroGame.evaluateHand(selected);
                const totalScore = chips * mult;
                BalatroGame.state.currentScore += totalScore;
                BalatroGame.state.handsLeft--;

                // Animate and show score
                showMessage(`${handName}! ${chips} √ó ${mult} = +${totalScore}`);
                updateDealer(`"${handName}! That's ${totalScore} points!"`);

                // Move played cards to discard
                selected.forEach(card => {
                    const idx = STATE.playerHand.indexOf(card);
                    if (idx > -1) STATE.playerHand.splice(idx, 1);
                    CardRoster.move(card.id, 'playerHand', 'discarded');
                    card.selected = false;
                });

                // Draw new cards
                const toDraw = Math.min(selected.length, STATE.deck.length);
                for (let i = 0; i < toDraw; i++) {
                    const card = STATE.deck.pop();
                    card.location = 'playerHand';
                    CardRoster.move(card.id, 'deck', 'playerHand');
                    STATE.playerHand.push(card);
                }

                BalatroGame.renderHand();
                BalatroGame.updateHUD();
                CardRoster.renderUI();

                // Check win/lose
                setTimeout(() => BalatroGame.checkRoundEnd(), 500);
            },

            discardCards: () => {
                const selected = STATE.playerHand.filter(c => c.selected);
                if (selected.length === 0 || selected.length > 5) {
                    showMessage('Select 1-5 cards to discard');
                    return;
                }
                if (BalatroGame.state.discardsLeft <= 0) {
                    showMessage('No discards remaining!');
                    return;
                }

                BalatroGame.state.discardsLeft--;

                // Move discarded cards
                selected.forEach(card => {
                    const idx = STATE.playerHand.indexOf(card);
                    if (idx > -1) STATE.playerHand.splice(idx, 1);
                    CardRoster.move(card.id, 'playerHand', 'discarded');
                    card.selected = false;
                });

                // Draw new cards
                const toDraw = Math.min(selected.length, STATE.deck.length);
                for (let i = 0; i < toDraw; i++) {
                    const card = STATE.deck.pop();
                    card.location = 'playerHand';
                    CardRoster.move(card.id, 'deck', 'playerHand');
                    STATE.playerHand.push(card);
                }

                showMessage(`Discarded ${selected.length} cards`);
                BalatroGame.renderHand();
                BalatroGame.updateHUD();
                CardRoster.renderUI();
            },

            checkRoundEnd: () => {
                const bs = BalatroGame.state;
                if (bs.currentScore >= bs.blindScore) {
                    // Won the blind!
                    ScoreTracker.playerWin();
                    const reward = bs.blind === 'small' ? 3 : bs.blind === 'big' ? 4 : 5;
                    bs.money += reward;
                    showMessage(`Blind defeated! +$${reward}`);
                    updateDealer(`"Excellent! You beat the ${bs.blind} blind!"`);

                    setTimeout(() => {
                        // Progress to next blind
                        if (bs.blind === 'small') {
                            bs.blind = 'big';
                        } else if (bs.blind === 'big') {
                            bs.blind = 'boss';
                        } else {
                            // Beat boss - next ante
                            bs.ante++;
                            bs.blind = 'small';
                            bs.money += 5; // Ante bonus
                            showMessage(`Ante ${bs.ante}! +$5 bonus`);
                        }
                        BalatroGame.openShop();
                    }, 1000);
                } else if (bs.handsLeft <= 0) {
                    // Lost the round
                    ScoreTracker.dealerWin();
                    showMessage('GAME OVER - No hands remaining');
                    updateDealer('"Tough luck. The blind got you this time."');
                    STATE.autoplay = false;
                    Autoplay.updateIndicator();
                    setControls([
                        { text: 'Try Again', action: () => BalatroGame.init(), primary: true },
                        { text: 'Menu', action: returnToMenu }
                    ]);
                }
            },

            openShop: () => {
                const bs = BalatroGame.state;
                updateDealer('"Welcome to the shop! Spend your earnings wisely."');

                // Generate shop items
                const shopJokers = [];
                for (let i = 0; i < 3; i++) {
                    const available = JOKER_LIBRARY.filter(j => !bs.jokers.some(owned => owned.id === j.id));
                    if (available.length > 0) {
                        shopJokers.push(available[Math.floor(Math.random() * available.length)]);
                    }
                }

                // Render shop in dealer hand area
                const dContainer = document.getElementById('dealer-hand');
                dContainer.innerHTML = '<div style="text-align:center;color:var(--accent);margin-bottom:10px;">SHOP</div>';

                shopJokers.forEach(joker => {
                    const el = joker.render();
                    el.innerHTML += `<div style="font-size:0.6rem;margin-top:4px;">$${joker.cost}</div>`;
                    el.onclick = () => {
                        if (bs.money >= joker.cost && bs.jokers.length < bs.maxJokers) {
                            bs.money -= joker.cost;
                            bs.jokers.push(joker);
                            el.remove();
                            BalatroGame.updateHUD();
                            showMessage(`Bought ${joker.name}!`);
                        } else if (bs.money < joker.cost) {
                            showMessage('Not enough money!');
                        } else {
                            showMessage('Joker slots full!');
                        }
                    };
                    dContainer.appendChild(el);
                });

                // Clear player hand
                document.getElementById('player-hand').innerHTML = '';

                setControls([
                    { text: 'Next Round', action: () => BalatroGame.nextRound(), primary: true },
                    { text: STATE.autoplay ? 'Stop Auto' : 'Autoplay', action: Autoplay.toggle, primary: false, autoplay: true }
                ]);
            },

            nextRound: () => {
                // Reshuffle deck
                CardRoster.init();
                STATE.deck = [];
                for (let s of SUITS) {
                    for (let r of RANKS) {
                        const card = new Card(s, r);
                        STATE.deck.push(card);
                        CardRoster.register(card);
                    }
                }
                STATE.deck = shuffle(STATE.deck);

                document.getElementById('dealer-hand').innerHTML = '';
                BalatroGame.startRound();
            },

            setControls: () => {
                const bs = BalatroGame.state;
                setControls([
                    { text: 'Play Hand', action: () => BalatroGame.playHand(), primary: true },
                    { text: `Discard (${bs.discardsLeft})`, action: () => BalatroGame.discardCards(), primary: false },
                    { text: STATE.autoplay ? 'Stop Auto' : 'Autoplay', action: Autoplay.toggle, primary: false, autoplay: true },
                    { text: 'Sort', action: () => BalatroGame.sortHand(), primary: false },
                    { text: 'Menu', action: returnToMenu }
                ]);
            },

            sortHand: () => {
                STATE.playerHand.sort((a, b) => b.pokerValue - a.pokerValue);
                BalatroGame.renderHand();
            }
        };

        // --- Demo Mode System - Animated card showcase on menu ---
        const DemoMode = {
            active: false,
            intervalId: null,
            layer: null,
            suits: ['‚ô†', '‚ô•', '‚ô£', '‚ô¶'],
            ranks: ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'],

            init: () => {
                DemoMode.layer = document.getElementById('demo-layer');
                if (!DemoMode.layer) return;
                DemoMode.start();
            },

            start: () => {
                if (DemoMode.active) return;
                DemoMode.active = true;
                DemoMode.layer.innerHTML = '';

                // Start spawning cards
                DemoMode.spawnBattle();
                DemoMode.intervalId = setInterval(() => {
                    if (DemoMode.active) {
                        DemoMode.spawnBattle();
                    }
                }, 2000);
            },

            stop: () => {
                DemoMode.active = false;
                if (DemoMode.intervalId) {
                    clearInterval(DemoMode.intervalId);
                    DemoMode.intervalId = null;
                }
                if (DemoMode.layer) {
                    DemoMode.layer.innerHTML = '';
                }
            },

            createDemoCard: (suit, rank, faceUp = true) => {
                const el = document.createElement('div');
                const isRed = suit === '‚ô•' || suit === '‚ô¶';
                el.className = `demo-card ${isRed ? 'red' : 'black'}${faceUp ? '' : ' demo-card-back'}`;

                if (faceUp) {
                    el.innerHTML = `
                        <div class="demo-card-corner">${rank}<br>${suit}</div>
                        <div class="demo-card-center">${suit}</div>
                        <div class="demo-card-corner bottom">${rank}<br>${suit}</div>
                    `;
                }
                return el;
            },

            randomCard: () => {
                const suit = DemoMode.suits[Math.floor(Math.random() * 4)];
                const rank = DemoMode.ranks[Math.floor(Math.random() * 13)];
                return { suit, rank };
            },

            spawnBattle: () => {
                if (!DemoMode.active || !DemoMode.layer) return;

                // Spawn a "battle" - two cards appearing side by side
                const card1 = DemoMode.randomCard();
                const card2 = DemoMode.randomCard();

                const el1 = DemoMode.createDemoCard(card1.suit, card1.rank);
                const el2 = DemoMode.createDemoCard(card2.suit, card2.rank);

                // Position cards in battle formation
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;

                el1.style.left = (centerX - 100) + 'px';
                el1.style.top = (centerY - 60) + 'px';
                el1.classList.add('battling');

                el2.style.left = (centerX + 20) + 'px';
                el2.style.top = (centerY - 60) + 'px';
                el2.style.animationDelay = '0.15s';
                el2.classList.add('battling');

                DemoMode.layer.appendChild(el1);
                DemoMode.layer.appendChild(el2);

                // Also spawn some floating cards around edges
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        if (!DemoMode.active) return;
                        DemoMode.spawnFloatingCard();
                    }, i * 400);
                }

                // Clean up after animation
                setTimeout(() => {
                    if (el1.parentNode) el1.remove();
                    if (el2.parentNode) el2.remove();
                }, 3000);
            },

            spawnFloatingCard: () => {
                if (!DemoMode.active || !DemoMode.layer) return;

                const card = DemoMode.randomCard();
                const faceUp = Math.random() > 0.3;
                const el = DemoMode.createDemoCard(card.suit, card.rank, faceUp);

                // Random position along bottom edge
                el.style.left = (Math.random() * (window.innerWidth - 100)) + 'px';
                el.style.top = window.innerHeight + 'px';
                el.classList.add('floating');
                el.style.animationDelay = (Math.random() * 0.5) + 's';
                el.style.animationDuration = (3 + Math.random() * 2) + 's';

                DemoMode.layer.appendChild(el);

                // Clean up after animation
                setTimeout(() => {
                    if (el.parentNode) el.remove();
                }, 6000);
            }
        };

        // --- Main ---
        function startGame(gameType) {
            // Stop demo mode when starting a game
            DemoMode.stop();

            document.getElementById('game-menu').style.display = 'none';
            STATE.game = gameType;
            SessionTimer.start(); // Cycle 7: Start session timer

            // Hide Balatro HUD when switching games
            const balatroHud = document.getElementById('balatro-hud');
            if (balatroHud) balatroHud.style.display = 'none';
            CardRoster.hide();

            if (gameType === 'war') WarGame.init();
            if (gameType === 'blackjack') BlackjackGame.init();
            if (gameType === 'poker') PokerGame.init();
            if (gameType === 'balatro') BalatroGame.init();
        }

        // Initialize
        DataManager.autoLoad();
        DemoMode.init(); // Start demo animations on menu
        
        // Auto-save on chip changes (simple hook)
        const originalUpdateDealer = updateDealer;
        updateDealer = (msg) => {
            originalUpdateDealer(msg);
            DataManager.autoSave();
        };


    </script>
</body>
</html>