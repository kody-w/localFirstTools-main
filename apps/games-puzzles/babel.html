<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BABEL - Tower to Heaven</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(to bottom, #1a1410 0%, #3d2817 100%);
            color: #f4e4c1;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        #gameContainer {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #topBar {
            height: 50px;
            background: rgba(20, 15, 10, 0.9);
            border-bottom: 2px solid #d4a574;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 100;
        }

        #stats {
            display: flex;
            gap: 30px;
            font-size: 14px;
        }

        .stat {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stat-value {
            font-weight: bold;
            color: #ffd700;
        }

        #controls {
            display: flex;
            gap: 10px;
        }

        button {
            background: linear-gradient(to bottom, #8b6f47 0%, #5d4a2f 100%);
            border: 2px solid #d4a574;
            color: #f4e4c1;
            padding: 6px 12px;
            cursor: pointer;
            font-family: 'Georgia', serif;
            font-size: 12px;
            transition: all 0.2s;
        }

        button:hover {
            background: linear-gradient(to bottom, #a58759 0%, #6d5639 100%);
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(1px);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #mainView {
            flex: 1;
            display: flex;
            position: relative;
            overflow: hidden;
        }

        #towerCanvas {
            flex: 1;
            background: linear-gradient(to bottom, #87ceeb 0%, #4a90a4 50%, #1a2332 100%);
            cursor: grab;
        }

        #towerCanvas:active {
            cursor: grabbing;
        }

        #sidePanel {
            width: 350px;
            background: rgba(30, 22, 15, 0.95);
            border-left: 2px solid #d4a574;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .panel-section {
            padding: 15px;
            border-bottom: 1px solid #5d4a2f;
        }

        .panel-section h3 {
            color: #ffd700;
            margin-bottom: 10px;
            font-size: 16px;
            border-bottom: 1px solid #5d4a2f;
            padding-bottom: 5px;
        }

        #constructionQueue {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .build-btn {
            padding: 10px;
            font-size: 13px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .build-cost {
            font-size: 11px;
            opacity: 0.8;
        }

        #dialectList {
            max-height: 200px;
            overflow-y: auto;
            font-size: 12px;
        }

        .dialect-item {
            padding: 8px;
            margin: 5px 0;
            background: rgba(139, 111, 71, 0.3);
            border-left: 3px solid #d4a574;
        }

        .dialect-name {
            font-weight: bold;
            color: #ffd700;
        }

        .dialect-speakers {
            font-size: 11px;
            opacity: 0.8;
        }

        #workerList {
            max-height: 250px;
            overflow-y: auto;
            font-size: 11px;
        }

        .worker-item {
            padding: 6px;
            margin: 3px 0;
            background: rgba(139, 111, 71, 0.2);
            display: flex;
            justify-content: space-between;
        }

        #languagePanel {
            max-height: 200px;
            overflow-y: auto;
            font-size: 11px;
        }

        .vocab-word {
            display: inline-block;
            padding: 3px 6px;
            margin: 2px;
            background: rgba(139, 111, 71, 0.4);
            border-radius: 3px;
        }

        #messageLog {
            position: absolute;
            top: 60px;
            left: 20px;
            max-width: 400px;
            pointer-events: none;
            z-index: 50;
        }

        .message {
            background: rgba(20, 15, 10, 0.9);
            border: 2px solid #d4a574;
            padding: 10px 15px;
            margin-bottom: 10px;
            animation: slideIn 0.3s ease-out;
        }

        .message.warning {
            border-color: #ff6b35;
        }

        .message.success {
            border-color: #4ecdc4;
        }

        @keyframes slideIn {
            from {
                transform: translateX(-100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        #modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        #modalContent {
            background: linear-gradient(to bottom, #3d2817 0%, #2a1a0f 100%);
            border: 3px solid #ffd700;
            padding: 30px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            text-align: center;
        }

        #modalContent h2 {
            color: #ffd700;
            margin-bottom: 20px;
            font-size: 28px;
        }

        #modalContent p {
            margin: 15px 0;
            line-height: 1.6;
        }

        .modal-btn {
            margin: 10px;
            padding: 10px 20px;
            font-size: 14px;
        }

        .speech-bubble {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            padding: 5px 10px;
            border-radius: 10px;
            font-size: 11px;
            pointer-events: none;
            max-width: 150px;
            word-wrap: break-word;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            z-index: 10;
        }

        .speech-bubble::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 20px;
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-top: 8px solid rgba(255, 255, 255, 0.95);
        }

        #tutorialOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .tutorial-content {
            background: linear-gradient(to bottom, #3d2817 0%, #2a1a0f 100%);
            border: 3px solid #ffd700;
            padding: 40px;
            max-width: 700px;
            text-align: center;
        }

        .tutorial-content h1 {
            color: #ffd700;
            font-size: 36px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .tutorial-content p {
            margin: 15px 0;
            line-height: 1.8;
            font-size: 16px;
        }

        .highlight {
            color: #ffd700;
            font-weight: bold;
        }

        #progressBar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: rgba(0, 0, 0, 0.3);
        }

        #progressFill {
            height: 100%;
            background: linear-gradient(to right, #ffd700, #ff6b35);
            width: 0%;
            transition: width 0.5s;
        }

        @media (max-width: 1200px) {
            #sidePanel {
                width: 300px;
            }
        }

        @media (max-width: 768px) {
            #sidePanel {
                position: absolute;
                right: -300px;
                transition: right 0.3s;
                z-index: 200;
            }

            #sidePanel.open {
                right: 0;
            }

            #togglePanel {
                display: block;
            }
        }

        .material-icon {
            display: inline-block;
            width: 12px;
            height: 12px;
            margin-right: 4px;
            vertical-align: middle;
        }

        .stone { background: #808080; }
        .wood { background: #8b4513; }
        .brick { background: #b22222; }
        .metal { background: #c0c0c0; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="topBar">
            <div id="stats">
                <div class="stat">
                    <span>Height:</span>
                    <span class="stat-value" id="heightDisplay">0m</span>
                </div>
                <div class="stat">
                    <span>Workers:</span>
                    <span class="stat-value" id="workerCount">10</span>
                </div>
                <div class="stat">
                    <span>Dialects:</span>
                    <span class="stat-value" id="dialectCount">1</span>
                </div>
                <div class="stat">
                    <span>Resources:</span>
                    <span class="stat-value" id="resourceCount">100</span>
                </div>
                <div class="stat">
                    <span>Stability:</span>
                    <span class="stat-value" id="stabilityDisplay">100%</span>
                </div>
            </div>
            <div id="controls">
                <button onclick="game.pause()">‚è∏ Pause</button>
                <button onclick="game.showLanguageModal()">üìñ Language</button>
                <button onclick="game.save()">üíæ Save</button>
                <button onclick="game.reset()">üîÑ Reset</button>
            </div>
        </div>

        <div id="mainView">
            <canvas id="towerCanvas"></canvas>

            <div id="sidePanel">
                <div class="panel-section">
                    <h3>Construction Orders</h3>
                    <div id="constructionQueue">
                        <button class="build-btn" onclick="game.queueConstruction('up', 'stone')">
                            <span><span class="material-icon stone"></span>Build Up (Stone)</span>
                            <span class="build-cost">Cost: 10</span>
                        </button>
                        <button class="build-btn" onclick="game.queueConstruction('up', 'wood')">
                            <span><span class="material-icon wood"></span>Build Up (Wood)</span>
                            <span class="build-cost">Cost: 5</span>
                        </button>
                        <button class="build-btn" onclick="game.queueConstruction('left', 'brick')">
                            <span><span class="material-icon brick"></span>Expand Left</span>
                            <span class="build-cost">Cost: 8</span>
                        </button>
                        <button class="build-btn" onclick="game.queueConstruction('right', 'brick')">
                            <span><span class="material-icon brick"></span>Expand Right</span>
                            <span class="build-cost">Cost: 8</span>
                        </button>
                        <button class="build-btn" onclick="game.reinforce()">
                            <span><span class="material-icon metal"></span>Reinforce</span>
                            <span class="build-cost">Cost: 15</span>
                        </button>
                        <button class="build-btn" onclick="game.buildSchool()">
                            <span>üè´ Build School</span>
                            <span class="build-cost">Cost: 50</span>
                        </button>
                    </div>
                </div>

                <div class="panel-section">
                    <h3>Active Dialects</h3>
                    <div id="dialectList"></div>
                </div>

                <div class="panel-section">
                    <h3>Workers</h3>
                    <div id="workerList"></div>
                </div>

                <div class="panel-section">
                    <h3>Vocabulary Sample</h3>
                    <div id="languagePanel"></div>
                </div>
            </div>
        </div>

        <div id="progressBar">
            <div id="progressFill"></div>
        </div>

        <div id="messageLog"></div>
    </div>

    <div id="modal">
        <div id="modalContent"></div>
    </div>

    <div id="tutorialOverlay">
        <div class="tutorial-content">
            <h1>BABEL</h1>
            <p>Build a tower to reach heaven itself.</p>
            <p>But beware: as your tower grows, your workers will develop <span class="highlight">different languages</span>.</p>
            <p>Workers who cannot understand each other will make <span class="highlight">mistakes</span>, cause <span class="highlight">accidents</span>, and may even <span class="highlight">fight</span>.</p>
            <p>Manage both your <span class="highlight">architecture</span> and your <span class="highlight">linguistics</span> to succeed.</p>
            <p><em>Can you unite humanity's voice, or will you scatter into confusion?</em></p>
            <button class="modal-btn" onclick="game.startGame()">Begin Construction</button>
        </div>
    </div>

    <script>
        // ============================================
        // LANGUAGE ENGINE - Core Innovation
        // ============================================

        class LanguageEngine {
            constructor() {
                this.baseWords = [
                    'one', 'two', 'three', 'four', 'five',
                    'up', 'down', 'left', 'right',
                    'stone', 'wood', 'brick', 'metal',
                    'build', 'carry', 'rest', 'danger',
                    'good', 'bad', 'yes', 'no'
                ];

                this.phonemes = ['ba', 'ka', 'ta', 'da', 'ma', 'na', 'pa', 'ra', 'sa', 'la', 'wa', 'zi', 'ki', 'ti', 'ni'];
                this.dialects = new Map();
                this.nextDialectId = 0;

                // Initialize base dialect
                this.createDialect('Proto');
            }

            createDialect(name, parentId = null) {
                const id = this.nextDialectId++;
                const dialect = {
                    id: id,
                    name: name || `Dialect-${id}`,
                    parentId: parentId,
                    vocabulary: new Map(),
                    grammar: {
                        wordOrder: 'SVO', // Subject-Verb-Object
                        compounding: true
                    },
                    createdAt: Date.now()
                };

                // Initialize vocabulary
                if (parentId === null) {
                    // Base dialect - map English to simple phonetic words
                    this.baseWords.forEach(word => {
                        dialect.vocabulary.set(word, this.generateWord(2));
                    });
                } else {
                    // Child dialect - inherit and modify parent vocabulary
                    const parent = this.dialects.get(parentId);
                    parent.vocabulary.forEach((translation, word) => {
                        // 30% chance to mutate the word
                        if (Math.random() < 0.3) {
                            dialect.vocabulary.set(word, this.mutateWord(translation));
                        } else {
                            dialect.vocabulary.set(word, translation);
                        }
                    });
                }

                this.dialects.set(id, dialect);
                return id;
            }

            generateWord(syllables = 2) {
                let word = '';
                for (let i = 0; i < syllables; i++) {
                    word += this.phonemes[Math.floor(Math.random() * this.phonemes.length)];
                }
                return word;
            }

            mutateWord(word) {
                const mutations = [
                    // Add syllable
                    () => word + this.phonemes[Math.floor(Math.random() * this.phonemes.length)],
                    // Remove syllable if long enough
                    () => word.length > 4 ? word.slice(0, -2) : word,
                    // Replace syllable
                    () => {
                        if (word.length < 4) return word;
                        const pos = Math.floor(Math.random() * (word.length - 2));
                        return word.slice(0, pos) + this.phonemes[Math.floor(Math.random() * this.phonemes.length)] + word.slice(pos + 2);
                    }
                ];

                return mutations[Math.floor(Math.random() * mutations.length)]();
            }

            translate(englishPhrase, dialectId) {
                const dialect = this.dialects.get(dialectId);
                if (!dialect) return englishPhrase;

                const words = englishPhrase.toLowerCase().split(' ');
                const translated = words.map(word => {
                    if (dialect.vocabulary.has(word)) {
                        return dialect.vocabulary.get(word);
                    }
                    // Unknown word - maybe a compound?
                    return word;
                });

                return translated.join(' ');
            }

            calculateMutualIntelligibility(dialectId1, dialectId2) {
                if (dialectId1 === dialectId2) return 1.0;

                const d1 = this.dialects.get(dialectId1);
                const d2 = this.dialects.get(dialectId2);

                if (!d1 || !d2) return 0;

                let sharedWords = 0;
                let totalWords = 0;

                d1.vocabulary.forEach((word1, key) => {
                    if (d2.vocabulary.has(key)) {
                        totalWords++;
                        const word2 = d2.vocabulary.get(key);
                        // Check similarity
                        if (word1 === word2) {
                            sharedWords++;
                        } else if (this.wordSimilarity(word1, word2) > 0.5) {
                            sharedWords += 0.5;
                        }
                    }
                });

                return totalWords > 0 ? sharedWords / totalWords : 0;
            }

            wordSimilarity(word1, word2) {
                // Simple Levenshtein-like similarity
                const maxLen = Math.max(word1.length, word2.length);
                if (maxLen === 0) return 1.0;

                let matches = 0;
                const minLen = Math.min(word1.length, word2.length);
                for (let i = 0; i < minLen; i++) {
                    if (word1[i] === word2[i]) matches++;
                }

                return matches / maxLen;
            }

            evolveDialect(dialectId, interactionMap) {
                // interactionMap: dialectId -> interaction count
                const dialect = this.dialects.get(dialectId);
                if (!dialect) return;

                // Chance to learn new compound words
                if (Math.random() < 0.1) {
                    const compounds = [
                        ['up', 'stone', 'capstone'],
                        ['down', 'danger', 'collapse'],
                        ['build', 'good', 'construct'],
                        ['carry', 'stone', 'haul']
                    ];

                    compounds.forEach(([w1, w2, result]) => {
                        if (dialect.vocabulary.has(w1) && dialect.vocabulary.has(w2) && !dialect.vocabulary.has(result)) {
                            const compound = dialect.vocabulary.get(w1) + dialect.vocabulary.get(w2);
                            dialect.vocabulary.set(result, compound);
                        }
                    });
                }
            }
        }

        // ============================================
        // WORKER SIMULATION
        // ============================================

        class Worker {
            constructor(x, y, dialectId) {
                this.x = x;
                this.y = y;
                this.targetX = x;
                this.targetY = y;
                this.dialectId = dialectId;
                this.role = this.randomRole();
                this.strength = 50 + Math.random() * 50;
                this.speed = 1 + Math.random() * 2;
                this.morale = 100;
                this.fatigue = 0;
                this.carrying = null;
                this.task = null;
                this.speechTimer = 0;
                this.speechText = '';
                this.interactionHistory = new Map(); // dialectId -> count
                this.id = Math.random().toString(36).substr(2, 9);
            }

            randomRole() {
                const roles = ['builder', 'carrier', 'engineer', 'teacher'];
                return roles[Math.floor(Math.random() * roles.length)];
            }

            update(deltaTime, tower, language) {
                // Fatigue management
                this.fatigue += deltaTime * 0.01;
                if (this.fatigue > 100) {
                    this.fatigue = 100;
                    this.morale -= deltaTime * 0.1;
                }

                // Rest when too tired
                if (this.fatigue > 80 && !this.task) {
                    this.rest(deltaTime);
                    return;
                }

                // Move toward target
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > 1) {
                    this.x += (dx / dist) * this.speed * deltaTime * 0.1;
                    this.y += (dy / dist) * this.speed * deltaTime * 0.1;
                }

                // Speech timer
                if (this.speechTimer > 0) {
                    this.speechTimer -= deltaTime;
                }
            }

            rest(deltaTime) {
                this.fatigue -= deltaTime * 0.05;
                if (this.fatigue < 0) this.fatigue = 0;
            }

            speak(phrase, language) {
                this.speechText = language.translate(phrase, this.dialectId);
                this.speechTimer = 2000; // 2 seconds
            }

            assignTask(task) {
                this.task = task;
                this.targetX = task.x;
                this.targetY = task.y;
            }

            interactWith(otherWorker, language) {
                // Record interaction
                const otherId = otherWorker.dialectId;
                this.interactionHistory.set(otherId, (this.interactionHistory.get(otherId) || 0) + 1);

                // Check mutual intelligibility
                const intelligibility = language.calculateMutualIntelligibility(this.dialectId, otherId);

                // Chance to adopt other dialect if lots of interaction
                if (intelligibility < 0.8 && this.interactionHistory.get(otherId) > 50) {
                    // Become bilingual or switch
                    if (Math.random() < 0.1) {
                        this.dialectId = otherId;
                    }
                }

                return intelligibility;
            }
        }

        // ============================================
        // TOWER STRUCTURE
        // ============================================

        class TowerBlock {
            constructor(x, y, material) {
                this.x = x;
                this.y = y;
                this.material = material;
                this.integrity = 100;
                this.cracks = [];

                // Material properties
                const props = {
                    stone: { strength: 100, weight: 3, color: '#808080' },
                    wood: { strength: 50, weight: 1, color: '#8b4513' },
                    brick: { strength: 75, weight: 2, color: '#b22222' },
                    metal: { strength: 150, weight: 4, color: '#c0c0c0' }
                };

                this.properties = props[material] || props.stone;
            }

            takeDamage(amount) {
                this.integrity -= amount;
                if (this.integrity < 0) this.integrity = 0;

                // Add cracks
                if (this.integrity < 70 && Math.random() < 0.3) {
                    this.cracks.push({
                        x1: Math.random() * 30,
                        y1: Math.random() * 30,
                        x2: Math.random() * 30,
                        y2: Math.random() * 30
                    });
                }
            }

            repair(amount) {
                this.integrity += amount;
                if (this.integrity > 100) this.integrity = 100;
                if (this.integrity > 70) {
                    this.cracks = [];
                }
            }
        }

        class Tower {
            constructor() {
                this.blocks = [];
                this.width = 5;
                this.height = 0;
                this.centerX = 0;

                // Initialize foundation
                for (let x = -2; x <= 2; x++) {
                    this.blocks.push(new TowerBlock(x, 0, 'stone'));
                }
                this.height = 1;
            }

            getBlock(x, y) {
                return this.blocks.find(b => b.x === x && b.y === y);
            }

            addBlock(x, y, material) {
                if (this.getBlock(x, y)) return false; // Already exists

                const block = new TowerBlock(x, y, material);
                this.blocks.push(block);

                if (y >= this.height) {
                    this.height = y + 1;
                }

                return true;
            }

            calculateStability() {
                let totalStability = 0;
                let count = 0;

                this.blocks.forEach(block => {
                    // Check support below
                    const below = this.getBlock(block.x, block.y - 1);
                    const belowLeft = this.getBlock(block.x - 1, block.y - 1);
                    const belowRight = this.getBlock(block.x + 1, block.y - 1);

                    let support = 0;
                    if (below) support += below.integrity * 0.5;
                    if (belowLeft) support += belowLeft.integrity * 0.25;
                    if (belowRight) support += belowRight.integrity * 0.25;

                    const stability = Math.min(100, support);

                    // Damage if insufficient support
                    if (stability < 50 && Math.random() < 0.01) {
                        block.takeDamage(1);
                    }

                    totalStability += stability;
                    count++;
                });

                return count > 0 ? totalStability / count : 100;
            }

            checkCollapse() {
                // Remove blocks with 0 integrity
                const collapsed = this.blocks.filter(b => b.integrity <= 0);
                this.blocks = this.blocks.filter(b => b.integrity > 0);

                // Recalculate height
                this.height = 0;
                this.blocks.forEach(b => {
                    if (b.y >= this.height) {
                        this.height = b.y + 1;
                    }
                });

                return collapsed.length;
            }
        }

        // ============================================
        // MAIN GAME
        // ============================================

        class Game {
            constructor() {
                this.canvas = document.getElementById('towerCanvas');
                this.ctx = this.canvas.getContext('2d');

                this.language = new LanguageEngine();
                this.tower = new Tower();
                this.workers = [];
                this.constructionQueue = [];

                this.resources = 100;
                this.time = 0;
                this.isPaused = false;
                this.lastUpdate = Date.now();

                this.camera = {
                    x: 0,
                    y: 0,
                    targetY: 0,
                    zoom: 1
                };

                this.messages = [];
                this.schools = [];
                this.divineEventTimer = 0;
                this.confusionTriggered = false;

                this.audioContext = null;

                this.initWorkers();
                this.setupCanvas();
                this.setupInput();
                this.loadGame();
            }

            initWorkers() {
                const baseDialect = 0;
                for (let i = 0; i < 10; i++) {
                    const x = (Math.random() - 0.5) * 100;
                    const y = 20;
                    this.workers.push(new Worker(x, y, baseDialect));
                }
            }

            setupCanvas() {
                const resize = () => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.canvas.width = rect.width;
                    this.canvas.height = rect.height;
                };

                resize();
                window.addEventListener('resize', resize);
            }

            setupInput() {
                let isDragging = false;
                let lastY = 0;

                this.canvas.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    lastY = e.clientY;
                });

                this.canvas.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        const dy = e.clientY - lastY;
                        this.camera.targetY += dy * 2;
                        lastY = e.clientY;
                    }
                });

                this.canvas.addEventListener('mouseup', () => {
                    isDragging = false;
                });

                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    this.camera.targetY -= e.deltaY;
                });
            }

            startGame() {
                document.getElementById('tutorialOverlay').style.display = 'none';
                this.initAudio();
                this.gameLoop();
            }

            initAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn('Audio not available');
                }
            }

            playSound(freq, duration) {
                if (!this.audioContext) return;

                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();

                osc.connect(gain);
                gain.connect(this.audioContext.destination);

                osc.frequency.value = freq;
                gain.gain.value = 0.1;

                osc.start();
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                osc.stop(this.audioContext.currentTime + duration);
            }

            gameLoop() {
                const now = Date.now();
                const deltaTime = Math.min(now - this.lastUpdate, 100);
                this.lastUpdate = now;

                if (!this.isPaused) {
                    this.update(deltaTime);
                }

                this.render();
                requestAnimationFrame(() => this.gameLoop());
            }

            update(deltaTime) {
                this.time += deltaTime;

                // Resource generation
                if (this.time % 1000 < deltaTime) {
                    this.resources += Math.max(1, Math.floor(this.workers.length * 0.5));
                }

                // Update workers
                this.workers.forEach(worker => {
                    worker.update(deltaTime, this.tower, this.language);

                    // Random speech
                    if (worker.speechTimer <= 0 && Math.random() < 0.001) {
                        const phrases = ['build up', 'carry stone', 'rest now', 'danger here', 'good work'];
                        worker.speak(phrases[Math.floor(Math.random() * phrases.length)], this.language);
                    }
                });

                // Language evolution - groups form based on proximity
                this.evolveLanguage(deltaTime);

                // Process construction queue
                this.processConstruction(deltaTime);

                // Tower stability
                const stability = this.tower.calculateStability();
                const collapsed = this.tower.checkCollapse();

                if (collapsed > 0) {
                    this.addMessage(`${collapsed} blocks collapsed!`, 'warning');
                    this.playSound(100, 0.5);
                }

                // Camera follow tower
                this.camera.targetY = -this.tower.height * 30 + this.canvas.height / 2;
                this.camera.y += (this.camera.targetY - this.camera.y) * 0.05;

                // Divine events
                this.updateDivineEvents(deltaTime);

                // Update UI
                this.updateUI();

                // Check win condition
                if (this.tower.height >= 200) {
                    this.endGame('heaven');
                }
            }

            evolveLanguage(deltaTime) {
                // Group workers by location
                const groups = new Map();

                this.workers.forEach(worker => {
                    const groupKey = Math.floor(worker.y / 100);
                    if (!groups.has(groupKey)) {
                        groups.set(groupKey, []);
                    }
                    groups.get(groupKey).push(worker);
                });

                // Check if groups should develop new dialects
                groups.forEach((groupWorkers, key) => {
                    if (groupWorkers.length < 3) return;

                    // If isolated for long enough, split dialect
                    const avgDialect = groupWorkers[0].dialectId;
                    const allSame = groupWorkers.every(w => w.dialectId === avgDialect);

                    if (allSame && Math.random() < 0.0001 * deltaTime) {
                        // Create new dialect
                        const newDialectId = this.language.createDialect(`Level-${key}`, avgDialect);

                        // Some workers adopt it
                        groupWorkers.forEach(w => {
                            if (Math.random() < 0.3) {
                                w.dialectId = newDialectId;
                            }
                        });

                        this.addMessage(`New dialect emerged at level ${key}!`, 'warning');
                    }
                });

                // Workers interact with nearby workers
                for (let i = 0; i < this.workers.length; i++) {
                    for (let j = i + 1; j < this.workers.length; j++) {
                        const w1 = this.workers[i];
                        const w2 = this.workers[j];

                        const dx = w1.x - w2.x;
                        const dy = w1.y - w2.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < 30) {
                            const intelligibility = w1.interactWith(w2, this.language);
                            w2.interactWith(w1, this.language);

                            // Miscommunication consequences
                            if (intelligibility < 0.5 && Math.random() < 0.001) {
                                w1.morale -= 5;
                                w2.morale -= 5;
                                w1.speak('no understand', this.language);
                                w2.speak('confusion', this.language);
                            }
                        }
                    }
                }

                // Evolve each dialect
                this.language.dialects.forEach((dialect, id) => {
                    this.language.evolveDialect(id, new Map());
                });
            }

            processConstruction(deltaTime) {
                if (this.constructionQueue.length === 0) return;

                const task = this.constructionQueue[0];

                // Assign workers to task
                const availableWorkers = this.workers.filter(w => !w.task || w.task === task);

                if (availableWorkers.length > 0) {
                    availableWorkers.slice(0, 3).forEach(worker => {
                        worker.assignTask(task);

                        // Check if worker understood the task
                        const intelligibility = this.language.calculateMutualIntelligibility(worker.dialectId, 0);

                        if (intelligibility < 0.5) {
                            // Miscommunication - wrong direction/material
                            if (Math.random() < 0.3) {
                                task.miscommunication = true;
                                worker.speak('build where', this.language);
                            }
                        }
                    });
                }

                // Progress task
                task.progress += deltaTime * 0.01 * availableWorkers.length;

                if (task.progress >= 100) {
                    this.completeConstruction(task);
                    this.constructionQueue.shift();
                }
            }

            completeConstruction(task) {
                let x = task.x;
                let y = task.y;
                let material = task.material;

                // Miscommunication effects
                if (task.miscommunication) {
                    // Wrong direction
                    if (Math.random() < 0.5) {
                        x += (Math.random() - 0.5) * 2;
                    }
                    // Wrong material
                    if (Math.random() < 0.3) {
                        const materials = ['stone', 'wood', 'brick', 'metal'];
                        material = materials[Math.floor(Math.random() * materials.length)];
                    }

                    this.addMessage('Miscommunication caused construction error!', 'warning');
                }

                const success = this.tower.addBlock(Math.round(x), Math.round(y), material);

                if (success) {
                    this.playSound(200 + Math.random() * 100, 0.2);

                    if (this.tower.height % 10 === 0) {
                        this.addMessage(`Tower reached ${this.tower.height} meters!`, 'success');
                    }
                } else {
                    this.addMessage('Construction failed - space occupied!', 'warning');
                }
            }

            queueConstruction(direction, material) {
                const costs = { stone: 10, wood: 5, brick: 8, metal: 15 };
                const cost = costs[material];

                if (this.resources < cost) {
                    this.addMessage('Not enough resources!', 'warning');
                    return;
                }

                this.resources -= cost;

                let x = 0, y = this.tower.height;

                if (direction === 'left') x = -Math.floor(this.tower.width / 2);
                if (direction === 'right') x = Math.floor(this.tower.width / 2);

                this.constructionQueue.push({
                    x, y, material,
                    progress: 0,
                    miscommunication: false
                });

                this.addMessage(`Queued: Build ${direction} with ${material}`, 'success');
            }

            reinforce() {
                if (this.resources < 15) {
                    this.addMessage('Not enough resources!', 'warning');
                    return;
                }

                this.resources -= 15;

                // Repair weakest blocks
                const weak = this.tower.blocks
                    .filter(b => b.integrity < 100)
                    .sort((a, b) => a.integrity - b.integrity)
                    .slice(0, 5);

                weak.forEach(block => block.repair(20));

                this.addMessage('Reinforced weak sections', 'success');
            }

            buildSchool() {
                if (this.resources < 50) {
                    this.addMessage('Not enough resources!', 'warning');
                    return;
                }

                this.resources -= 50;
                this.schools.push({ level: this.tower.height, timer: 0 });

                // Schools slowly standardize language
                const baseDialect = 0;
                this.workers.forEach(w => {
                    if (Math.random() < 0.2) {
                        w.dialectId = baseDialect;
                    }
                });

                this.addMessage('Built school - teaching standard language', 'success');
            }

            updateDivineEvents(deltaTime) {
                if (this.tower.height < 100) return;

                this.divineEventTimer += deltaTime;

                // The Confusion event
                if (!this.confusionTriggered && this.tower.height >= 150) {
                    this.confusionTriggered = true;
                    this.triggerConfusion();
                }

                // Random divine phenomena
                if (this.divineEventTimer > 30000) {
                    this.divineEventTimer = 0;

                    const events = [
                        () => {
                            this.addMessage('Thunder shakes the tower!', 'warning');
                            this.tower.blocks.forEach(b => {
                                if (Math.random() < 0.1) b.takeDamage(5);
                            });
                            this.playSound(50, 1);
                        },
                        () => {
                            this.addMessage('Divine light inspires the workers!', 'success');
                            this.workers.forEach(w => w.morale += 20);
                        },
                        () => {
                            this.addMessage('Strange winds cause confusion...', 'warning');
                            this.workers.forEach(w => {
                                if (Math.random() < 0.1) {
                                    w.dialectId = Math.floor(Math.random() * this.language.dialects.size);
                                }
                            });
                        }
                    ];

                    events[Math.floor(Math.random() * events.length)]();
                }
            }

            triggerConfusion() {
                this.addMessage('THE CONFUSION - Languages scatter!', 'warning');

                // Massively fragment languages
                this.workers.forEach(worker => {
                    if (Math.random() < 0.7) {
                        const newDialect = this.language.createDialect(`Scattered-${worker.id}`, worker.dialectId);
                        worker.dialectId = newDialect;
                    }
                });

                this.playSound(100, 2);

                this.showModal(
                    'THE CONFUSION',
                    'A divine force has scattered your languages! Workers can no longer understand each other. Can you rebuild unity and reach heaven?'
                );
            }

            updateUI() {
                document.getElementById('heightDisplay').textContent = `${this.tower.height}m`;
                document.getElementById('workerCount').textContent = this.workers.length;
                document.getElementById('dialectCount').textContent = this.language.dialects.size;
                document.getElementById('resourceCount').textContent = this.resources;

                const stability = this.tower.calculateStability();
                document.getElementById('stabilityDisplay').textContent = `${Math.round(stability)}%`;

                // Progress bar
                document.getElementById('progressFill').style.width = `${(this.tower.height / 200) * 100}%`;

                // Dialect list
                const dialectList = document.getElementById('dialectList');
                dialectList.innerHTML = '';
                this.language.dialects.forEach((dialect, id) => {
                    const speakers = this.workers.filter(w => w.dialectId === id).length;
                    if (speakers > 0) {
                        const div = document.createElement('div');
                        div.className = 'dialect-item';
                        div.innerHTML = `
                            <div class="dialect-name">${dialect.name}</div>
                            <div class="dialect-speakers">${speakers} speakers</div>
                        `;
                        dialectList.appendChild(div);
                    }
                });

                // Worker list
                const workerList = document.getElementById('workerList');
                workerList.innerHTML = '';
                this.workers.slice(0, 15).forEach(worker => {
                    const dialect = this.language.dialects.get(worker.dialectId);
                    const div = document.createElement('div');
                    div.className = 'worker-item';
                    div.innerHTML = `
                        <span>${worker.role}</span>
                        <span>${dialect ? dialect.name : 'Unknown'}</span>
                    `;
                    workerList.appendChild(div);
                });

                // Language sample
                const languagePanel = document.getElementById('languagePanel');
                languagePanel.innerHTML = '';
                const baseDialect = this.language.dialects.get(0);
                if (baseDialect) {
                    Array.from(baseDialect.vocabulary.entries()).slice(0, 10).forEach(([eng, trans]) => {
                        const span = document.createElement('span');
                        span.className = 'vocab-word';
                        span.textContent = `${eng}=${trans}`;
                        languagePanel.appendChild(span);
                    });
                }
            }

            render() {
                const ctx = this.ctx;
                const w = this.canvas.width;
                const h = this.canvas.height;

                // Sky gradient based on height
                const skyProgress = Math.min(this.tower.height / 200, 1);
                const skyGrad = ctx.createLinearGradient(0, 0, 0, h);

                if (skyProgress < 0.3) {
                    skyGrad.addColorStop(0, '#87ceeb');
                    skyGrad.addColorStop(1, '#4a90a4');
                } else if (skyProgress < 0.7) {
                    skyGrad.addColorStop(0, '#4a5a8a');
                    skyGrad.addColorStop(1, '#1a2332');
                } else {
                    skyGrad.addColorStop(0, '#1a1a2e');
                    skyGrad.addColorStop(0.5, '#0f0f1e');
                    skyGrad.addColorStop(1, '#ffd700');
                }

                ctx.fillStyle = skyGrad;
                ctx.fillRect(0, 0, w, h);

                // Stars at high altitude
                if (skyProgress > 0.5) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    for (let i = 0; i < 50; i++) {
                        const x = (i * 137.5) % w;
                        const y = (i * 97.3) % (h * 0.5);
                        ctx.fillRect(x, y, 2, 2);
                    }
                }

                ctx.save();
                ctx.translate(w / 2, h / 2 - this.camera.y);

                // Ground
                ctx.fillStyle = '#8b7355';
                ctx.fillRect(-w, 0, w * 2, 50);

                // Tower blocks
                this.tower.blocks.forEach(block => {
                    const x = block.x * 30;
                    const y = -block.y * 30;

                    ctx.fillStyle = block.properties.color;
                    ctx.fillRect(x - 15, y - 15, 30, 30);

                    // Integrity shading
                    if (block.integrity < 100) {
                        ctx.fillStyle = `rgba(0, 0, 0, ${(100 - block.integrity) / 200})`;
                        ctx.fillRect(x - 15, y - 15, 30, 30);
                    }

                    // Cracks
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 1;
                    block.cracks.forEach(crack => {
                        ctx.beginPath();
                        ctx.moveTo(x - 15 + crack.x1, y - 15 + crack.y1);
                        ctx.lineTo(x - 15 + crack.x2, y - 15 + crack.y2);
                        ctx.stroke();
                    });

                    // Border
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x - 15, y - 15, 30, 30);
                });

                // Workers
                this.workers.forEach(worker => {
                    const x = worker.x;
                    const y = -worker.y;

                    // Body
                    ctx.fillStyle = '#f4e4c1';
                    ctx.beginPath();
                    ctx.arc(x, y - 5, 3, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#8b6f47';
                    ctx.fillRect(x - 2, y, 4, 6);

                    // Role indicator
                    const colors = {
                        builder: '#ff6b35',
                        carrier: '#4ecdc4',
                        engineer: '#ffd700',
                        teacher: '#a78bfa'
                    };
                    ctx.fillStyle = colors[worker.role] || '#fff';
                    ctx.fillRect(x - 1, y - 10, 2, 3);
                });

                ctx.restore();

                // Speech bubbles (screen space)
                this.workers.forEach(worker => {
                    if (worker.speechTimer > 0 && worker.speechText) {
                        const screenX = w / 2 + worker.x;
                        const screenY = h / 2 - this.camera.y - worker.y - 15;

                        if (screenY > 0 && screenY < h) {
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                            ctx.strokeStyle = '#333';
                            ctx.lineWidth = 2;

                            const text = worker.speechText;
                            ctx.font = '11px Georgia';
                            const metrics = ctx.measureText(text);
                            const padding = 8;

                            const bubbleX = screenX - metrics.width / 2 - padding;
                            const bubbleY = screenY - 25;
                            const bubbleW = metrics.width + padding * 2;
                            const bubbleH = 20;

                            // Bubble
                            ctx.beginPath();
                            ctx.roundRect(bubbleX, bubbleY, bubbleW, bubbleH, 5);
                            ctx.fill();
                            ctx.stroke();

                            // Tail
                            ctx.beginPath();
                            ctx.moveTo(screenX, screenY - 5);
                            ctx.lineTo(screenX - 5, screenY - 10);
                            ctx.lineTo(screenX + 5, screenY - 10);
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();

                            // Text
                            ctx.fillStyle = '#333';
                            ctx.fillText(text, bubbleX + padding, bubbleY + 14);
                        }
                    }
                });

                // Construction queue indicator
                if (this.constructionQueue.length > 0) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(10, h - 60, 200, 50);

                    ctx.fillStyle = '#ffd700';
                    ctx.font = '12px Georgia';
                    ctx.fillText(`Building: ${this.constructionQueue[0].material}`, 20, h - 35);

                    const progress = this.constructionQueue[0].progress;
                    ctx.fillStyle = '#4ecdc4';
                    ctx.fillRect(20, h - 25, progress * 1.6, 10);
                    ctx.strokeStyle = '#fff';
                    ctx.strokeRect(20, h - 25, 160, 10);
                }
            }

            addMessage(text, type = 'normal') {
                const msg = { text, type, time: Date.now() };
                this.messages.push(msg);

                const log = document.getElementById('messageLog');
                const div = document.createElement('div');
                div.className = `message ${type}`;
                div.textContent = text;
                log.appendChild(div);

                setTimeout(() => {
                    div.remove();
                    this.messages = this.messages.filter(m => m !== msg);
                }, 5000);
            }

            showModal(title, content) {
                const modal = document.getElementById('modal');
                const modalContent = document.getElementById('modalContent');

                modalContent.innerHTML = `
                    <h2>${title}</h2>
                    <p>${content}</p>
                    <button class="modal-btn" onclick="game.closeModal()">Continue</button>
                `;

                modal.style.display = 'flex';
            }

            closeModal() {
                document.getElementById('modal').style.display = 'none';
            }

            showLanguageModal() {
                let content = '<h2>Language Analysis</h2>';

                this.language.dialects.forEach((dialect, id) => {
                    const speakers = this.workers.filter(w => w.dialectId === id).length;
                    if (speakers > 0) {
                        content += `<h3>${dialect.name} (${speakers} speakers)</h3>`;
                        content += '<div style="text-align: left; margin: 10px 0;">';

                        Array.from(dialect.vocabulary.entries()).slice(0, 15).forEach(([eng, trans]) => {
                            content += `<span class="vocab-word">${eng} = ${trans}</span> `;
                        });

                        content += '</div>';
                    }
                });

                content += '<button class="modal-btn" onclick="game.closeModal()">Close</button>';

                const modal = document.getElementById('modal');
                const modalContent = document.getElementById('modalContent');
                modalContent.innerHTML = content;
                modal.style.display = 'flex';
            }

            endGame(reason) {
                this.isPaused = true;

                const endings = {
                    heaven: {
                        title: 'Heaven Reached!',
                        content: `You have built your tower to the very gates of heaven!<br><br>
                                 Final Height: ${this.tower.height}m<br>
                                 Workers: ${this.workers.length}<br>
                                 Dialects: ${this.language.dialects.size}<br><br>
                                 ${this.language.dialects.size === 1
                                     ? 'Humanity speaks with ONE VOICE. The divine is impressed by your unity.'
                                     : this.language.dialects.size < 5
                                     ? 'Though languages differ, cooperation prevailed. Beauty in diversity.'
                                     : 'Languages scattered across the earth. The tower stands, but humanity is divided.'}`
                    },
                    collapse: {
                        title: 'Tower Collapsed',
                        content: `The tower has fallen due to structural failure or linguistic chaos.<br><br>
                                 Try again with better management of both construction and communication.`
                    }
                };

                const ending = endings[reason] || endings.collapse;

                this.showModal(ending.title, ending.content +
                    '<br><br><button class="modal-btn" onclick="game.reset()">New Tower</button>');
            }

            pause() {
                this.isPaused = !this.isPaused;
            }

            save() {
                const saveData = {
                    tower: {
                        blocks: this.tower.blocks.map(b => ({
                            x: b.x, y: b.y, material: b.material, integrity: b.integrity
                        })),
                        height: this.tower.height,
                        width: this.tower.width
                    },
                    workers: this.workers.map(w => ({
                        x: w.x, y: w.y, dialectId: w.dialectId, role: w.role,
                        strength: w.strength, morale: w.morale, fatigue: w.fatigue
                    })),
                    dialects: Array.from(this.language.dialects.entries()),
                    resources: this.resources,
                    time: this.time,
                    confusionTriggered: this.confusionTriggered
                };

                localStorage.setItem('babel_save', JSON.stringify(saveData));
                this.addMessage('Game saved!', 'success');
            }

            loadGame() {
                const saved = localStorage.getItem('babel_save');
                if (!saved) return;

                try {
                    const data = JSON.parse(saved);

                    // Restore tower
                    this.tower.blocks = [];
                    data.tower.blocks.forEach(b => {
                        const block = new TowerBlock(b.x, b.y, b.material);
                        block.integrity = b.integrity;
                        this.tower.blocks.push(block);
                    });
                    this.tower.height = data.tower.height;
                    this.tower.width = data.tower.width;

                    // Restore workers
                    this.workers = data.workers.map(w => {
                        const worker = new Worker(w.x, w.y, w.dialectId);
                        worker.role = w.role;
                        worker.strength = w.strength;
                        worker.morale = w.morale;
                        worker.fatigue = w.fatigue;
                        return worker;
                    });

                    // Restore dialects
                    this.language.dialects.clear();
                    data.dialects.forEach(([id, dialect]) => {
                        this.language.dialects.set(id, {
                            ...dialect,
                            vocabulary: new Map(Object.entries(dialect.vocabulary || {}))
                        });
                    });

                    this.resources = data.resources;
                    this.time = data.time;
                    this.confusionTriggered = data.confusionTriggered;

                    this.addMessage('Game loaded!', 'success');
                } catch (e) {
                    console.error('Load failed:', e);
                }
            }

            reset() {
                if (confirm('Reset the game? All progress will be lost.')) {
                    localStorage.removeItem('babel_save');
                    location.reload();
                }
            }
        }

        // ============================================
        // INITIALIZE
        // ============================================

        const game = new Game();
    </script>
</body>
</html>