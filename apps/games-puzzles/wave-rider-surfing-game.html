<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wave Rider - Extreme Surfing Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #000;
            color: #fff;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #game-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }

        #score-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 215, 0, 0.5);
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.3);
        }

        .score-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            font-size: 18px;
        }

        .score-label {
            color: #aaa;
            margin-right: 20px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 14px;
        }

        .score-value {
            color: #FFD700;
            font-weight: bold;
            font-size: 24px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .score-value.huge {
            font-size: 36px;
        }

        #combo-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8),
                         0 0 40px rgba(255, 215, 0, 0.6);
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        #combo-display.show {
            opacity: 1;
            animation: comboPopIn 0.5s ease-out;
        }

        @keyframes comboPopIn {
            0% { transform: translate(-50%, -50%) scale(0.5); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        #trick-notification {
            position: absolute;
            top: 150px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 215, 0, 0.9);
            color: #000;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 24px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        #trick-notification.show {
            opacity: 1;
            animation: slideDown 0.5s ease-out;
        }

        @keyframes slideDown {
            0% { transform: translateX(-50%) translateY(-50px); }
            100% { transform: translateX(-50%) translateY(0); }
        }

        #controls-info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 30px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            text-align: center;
            font-size: 14px;
        }

        .control-row {
            margin: 5px 0;
        }

        .control-key {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            padding: 5px 10px;
            border-radius: 5px;
            margin: 0 5px;
            font-weight: bold;
            color: #4fc3f7;
            border: 1px solid rgba(79, 195, 247, 0.3);
        }

        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 20, 40, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            pointer-events: all;
        }

        #start-screen.hidden {
            display: none;
        }

        .game-title {
            font-size: 72px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.8),
                         0 0 60px rgba(255, 215, 0, 0.6);
            margin-bottom: 20px;
            animation: titlePulse 2s ease-in-out infinite;
        }

        @keyframes titlePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .game-subtitle {
            font-size: 24px;
            color: #4fc3f7;
            margin-bottom: 40px;
        }

        .start-button {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            color: #000;
            border: none;
            padding: 20px 60px;
            border-radius: 15px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 10px 30px rgba(255, 215, 0, 0.5);
            pointer-events: all;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .start-button:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 15px 40px rgba(255, 215, 0, 0.7);
        }

        .start-button:active {
            transform: translateY(-2px) scale(1.02);
        }

        .instructions {
            margin-top: 40px;
            max-width: 600px;
            text-align: center;
            line-height: 1.8;
            color: #aaa;
        }

        .instructions h3 {
            color: #4fc3f7;
            margin-bottom: 15px;
            font-size: 20px;
        }

        #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 20, 40, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            pointer-events: all;
        }

        #game-over-screen.show {
            display: flex;
            animation: fadeIn 0.5s ease-out;
        }

        @keyframes fadeIn {
            0% { opacity: 0; }
            100% { opacity: 1; }
        }

        .game-over-title {
            font-size: 64px;
            font-weight: bold;
            color: #ff4444;
            text-shadow: 0 0 30px rgba(255, 68, 68, 0.8);
            margin-bottom: 30px;
        }

        .final-score {
            font-size: 36px;
            color: #FFD700;
            margin-bottom: 20px;
        }

        .high-score {
            font-size: 24px;
            color: #4fc3f7;
            margin-bottom: 40px;
        }

        .restart-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 50px;
            border-radius: 10px;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.5);
            pointer-events: all;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .restart-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 40px rgba(102, 126, 234, 0.7);
        }

        #speed-bar-container {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .bar-label {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #speed-bar {
            width: 100%;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
        }

        #speed-fill {
            height: 100%;
            background: linear-gradient(90deg, #4fc3f7 0%, #FFD700 50%, #ff4444 100%);
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: 0 0 20px rgba(79, 195, 247, 0.5);
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: white;
            border-radius: 50%;
            pointer-events: none;
            animation: particleFade 1s ease-out forwards;
        }

        @keyframes particleFade {
            0% {
                opacity: 1;
                transform: scale(1);
            }
            100% {
                opacity: 0;
                transform: scale(0);
            }
        }

        #multiplier-display {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 68, 68, 0.5);
            box-shadow: 0 0 30px rgba(255, 68, 68, 0.3);
            text-align: center;
        }

        .multiplier-value {
            font-size: 48px;
            font-weight: bold;
            color: #ff4444;
            text-shadow: 0 0 20px rgba(255, 68, 68, 0.8);
        }

        .multiplier-label {
            font-size: 14px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="game-ui">
        <div id="score-panel">
            <div class="score-item">
                <span class="score-label">Score</span>
                <span class="score-value huge" id="current-score">0</span>
            </div>
            <div class="score-item">
                <span class="score-label">Distance</span>
                <span class="score-value" id="distance">0m</span>
            </div>
            <div class="score-item">
                <span class="score-label">Best Wave</span>
                <span class="score-value" id="best-wave">0</span>
            </div>
        </div>

        <div id="multiplier-display">
            <div class="multiplier-value" id="multiplier-value">1x</div>
            <div class="multiplier-label">Multiplier</div>
        </div>

        <div id="combo-display"></div>
        <div id="trick-notification"></div>

        <div id="speed-bar-container">
            <div class="bar-label">Speed</div>
            <div id="speed-bar">
                <div id="speed-fill"></div>
            </div>
        </div>

        <div id="controls-info">
            <div class="control-row">
                <span class="control-key">‚Üê</span>
                <span class="control-key">‚Üí</span>
                Move Left/Right
            </div>
            <div class="control-row">
                <span class="control-key">‚Üë</span>
                Speed Boost
            </div>
            <div class="control-row">
                <span class="control-key">SPACE</span>
                Jump & Tricks
            </div>
        </div>
    </div>

    <div id="start-screen">
        <div class="game-title">üèÑ WAVE RIDER</div>
        <div class="game-subtitle">Extreme Surfing Experience</div>
        <button class="start-button" id="start-button">START SURFING</button>
        <div class="instructions">
            <h3>How to Play</h3>
            <p>
                Ride the waves and perform tricks to score points!<br>
                Stay on the wave, perform aerial tricks, and build your multiplier.<br>
                The longer you survive, the higher your score!<br>
                Avoid wiping out by keeping your balance!
            </p>
        </div>
    </div>

    <div id="game-over-screen">
        <div class="game-over-title">WIPE OUT!</div>
        <div class="final-score">Final Score: <span id="final-score-value">0</span></div>
        <div class="high-score">High Score: <span id="high-score-value">0</span></div>
        <button class="restart-button" id="restart-button">SURF AGAIN</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ============================================
        // WAVE RIDER - SURFING GAME
        // ============================================

        class WaveRiderGame {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                
                this.waterSurface = null;
                this.poolBottom = null;
                this.surfer = null;
                this.surfboard = null;
                
                this.causticsTarget = null;
                this.causticsScene = null;
                this.causticsCamera = null;
                
                this.time = 0;
                this.gameState = 'start'; // 'start', 'playing', 'gameover'
                this.lastFrameTime = performance.now();
                
                // Game parameters
                this.params = {
                    waveSpeed: 1.5,
                    waveAmplitude: 0.3,
                    causticsIntensity: 2.5,
                    lightHeight: 8.0,
                    refractionIndex: 1.33
                };

                // Player state
                this.player = {
                    position: new THREE.Vector3(0, 0, 0),
                    velocity: new THREE.Vector3(0, 0, 0),
                    rotation: 0,
                    targetRotation: 0,
                    speed: 0,
                    maxSpeed: 15,
                    acceleration: 0,
                    isAirborne: false,
                    airTime: 0,
                    onWave: false,
                    balance: 1.0
                };

                // Game stats
                this.stats = {
                    score: 0,
                    distance: 0,
                    multiplier: 1,
                    comboTimer: 0,
                    bestWave: 0,
                    currentWaveScore: 0,
                    trickInProgress: false,
                    lastTrick: '',
                    tricksPerformed: []
                };

                // Controls
                this.keys = {
                    left: false,
                    right: false,
                    up: false,
                    space: false
                };

                // High score
                this.highScore = parseInt(localStorage.getItem('waveRiderHighScore') || '0');

                this.obstacles = [];
                this.particles = [];

                this.init();
                this.setupEventListeners();
                this.showStartScreen();
            }

            init() {
                // Create main scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB); // Sky blue
                this.scene.fog = new THREE.Fog(0x87CEEB, 20, 80);

                // Create camera
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.camera.position.set(0, 4, -8);
                this.camera.lookAt(0, 0, 0);

                // Create renderer
                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    alpha: false
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);

                // Setup lights
                this.setupLights();

                // Create caustics rendering target
                this.setupCausticsTarget();

                // Create ocean floor
                this.createOceanFloor();

                // Create water surface
                this.createWaterSurface();

                // Create surfer
                this.createSurfer();

                // Create obstacles
                this.spawnObstacles();

                // Handle window resize
                window.addEventListener('resize', () => this.onWindowResize());

                // Start animation loop
                this.animate();
            }

            setupLights() {
                // Ambient light
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);

                // Main directional light (sun)
                this.mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
                this.mainLight.position.set(10, this.params.lightHeight, 5);
                this.mainLight.castShadow = true;
                this.mainLight.shadow.mapSize.width = 2048;
                this.mainLight.shadow.mapSize.height = 2048;
                this.mainLight.shadow.camera.near = 0.5;
                this.mainLight.shadow.camera.far = 30;
                this.mainLight.shadow.camera.left = -15;
                this.mainLight.shadow.camera.right = 15;
                this.mainLight.shadow.camera.top = 15;
                this.mainLight.shadow.camera.bottom = -15;
                this.scene.add(this.mainLight);
            }

            setupCausticsTarget() {
                this.causticsTarget = new THREE.WebGLRenderTarget(512, 512, {
                    minFilter: THREE.LinearFilter,
                    magFilter: THREE.LinearFilter,
                    format: THREE.RGBAFormat
                });

                this.causticsCamera = new THREE.OrthographicCamera(-10, 10, 10, -10, 0.1, 20);
                this.causticsCamera.position.set(0, 10, 0);
                this.causticsCamera.lookAt(0, 0, 0);

                this.causticsScene = new THREE.Scene();
            }

            createOceanFloor() {
                const floorGeometry = new THREE.PlaneGeometry(200, 200, 1, 1);
                
                const floorMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        causticsMap: { value: this.causticsTarget.texture },
                        causticsIntensity: { value: this.params.causticsIntensity }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        varying vec3 vPosition;

                        void main() {
                            vUv = uv;
                            vPosition = position;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform sampler2D causticsMap;
                        uniform float causticsIntensity;

                        varying vec2 vUv;
                        varying vec3 vPosition;

                        void main() {
                            // Ocean floor color
                            vec3 baseColor = vec3(0.1, 0.3, 0.5);
                            
                            // Add caustics
                            vec2 causticsUv = vUv * 0.5 + 0.25;
                            vec4 caustics = texture2D(causticsMap, causticsUv);
                            vec3 causticsColor = caustics.rgb * causticsIntensity;
                            
                            vec3 finalColor = baseColor * (0.3 + causticsColor);
                            
                            // Add depth fade
                            float fade = smoothstep(0.0, 1.0, 1.0 - length(vPosition.xy) / 100.0);
                            finalColor *= fade;

                            gl_FragColor = vec4(finalColor, 1.0);
                        }
                    `
                });

                this.poolBottom = new THREE.Mesh(floorGeometry, floorMaterial);
                this.poolBottom.rotation.x = -Math.PI / 2;
                this.poolBottom.position.y = -3;
                this.poolBottom.receiveShadow = true;
                this.scene.add(this.poolBottom);
            }

            createWaterSurface() {
                const waterGeometry = new THREE.PlaneGeometry(200, 200, 256, 256);
                
                const waterMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        waveSpeed: { value: this.params.waveSpeed },
                        waveAmplitude: { value: this.params.waveAmplitude },
                        lightPosition: { value: new THREE.Vector3(10, this.params.lightHeight, 5) }
                    },
                    vertexShader: `
                        uniform float time;
                        uniform float waveSpeed;
                        uniform float waveAmplitude;

                        varying vec3 vPosition;
                        varying vec3 vNormal;
                        varying vec2 vUv;
                        varying float vElevation;

                        vec3 getWavePosition(vec3 pos) {
                            float wave1 = sin(pos.x * 0.5 + time * waveSpeed) * waveAmplitude;
                            float wave2 = sin(pos.z * 0.3 - time * waveSpeed * 0.7) * waveAmplitude * 0.8;
                            float wave3 = sin((pos.x - pos.z) * 0.4 + time * waveSpeed * 1.3) * waveAmplitude * 0.6;
                            
                            // Add larger rolling waves
                            float bigWave = sin(pos.x * 0.15 + time * waveSpeed * 0.5) * waveAmplitude * 2.0;
                            
                            pos.y += wave1 + wave2 + wave3 + bigWave;
                            return pos;
                        }

                        vec3 getWaveNormal(vec3 pos, float delta) {
                            vec3 posX = getWavePosition(pos + vec3(delta, 0.0, 0.0));
                            vec3 posZ = getWavePosition(pos + vec3(0.0, 0.0, delta));
                            vec3 tangentX = normalize(posX - pos);
                            vec3 tangentZ = normalize(posZ - pos);
                            return normalize(cross(tangentZ, tangentX));
                        }

                        void main() {
                            vUv = uv;
                            
                            vec3 pos = position;
                            pos = getWavePosition(pos);
                            
                            vPosition = (modelMatrix * vec4(pos, 1.0)).xyz;
                            vNormal = getWaveNormal(position, 0.1);
                            vElevation = pos.y - position.y;
                            
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform vec3 lightPosition;

                        varying vec3 vPosition;
                        varying vec3 vNormal;
                        varying vec2 vUv;
                        varying float vElevation;

                        void main() {
                            vec3 waterColorDeep = vec3(0.0, 0.2, 0.4);
                            vec3 waterColorShallow = vec3(0.0, 0.4, 0.6);
                            
                            vec3 waterColor = mix(waterColorShallow, waterColorDeep, smoothstep(-0.2, 0.2, vElevation));

                            vec3 normal = normalize(vNormal);
                            vec3 lightDir = normalize(lightPosition - vPosition);
                            vec3 viewDir = normalize(cameraPosition - vPosition);
                            vec3 halfDir = normalize(lightDir + viewDir);

                            float diff = max(dot(normal, lightDir), 0.0);
                            float spec = pow(max(dot(normal, halfDir), 0.0), 32.0);
                            float fresnel = pow(1.0 - max(dot(viewDir, normal), 0.0), 3.0);

                            vec3 finalColor = waterColor * (0.6 + diff * 0.4);
                            finalColor += vec3(1.0) * spec * 0.6;
                            finalColor = mix(finalColor, vec3(0.7, 0.9, 1.0), fresnel * 0.2);

                            gl_FragColor = vec4(finalColor, 0.85 + fresnel * 0.1);
                        }
                    `,
                    transparent: true,
                    side: THREE.DoubleSide
                });

                this.waterSurface = new THREE.Mesh(waterGeometry, waterMaterial);
                this.waterSurface.rotation.x = -Math.PI / 2;
                this.waterSurface.position.y = 0;
                this.waterSurface.receiveShadow = true;
                this.scene.add(this.waterSurface);

                this.createCausticsMesh();
            }

            createCausticsMesh() {
                const causticsGeometry = new THREE.PlaneGeometry(200, 200, 128, 128);
                
                const causticsMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        waveSpeed: { value: this.params.waveSpeed },
                        waveAmplitude: { value: this.params.waveAmplitude },
                        lightPosition: { value: new THREE.Vector3(10, this.params.lightHeight, 5) },
                        refractionIndex: { value: this.params.refractionIndex }
                    },
                    vertexShader: `
                        uniform float time;
                        uniform float waveSpeed;
                        uniform float waveAmplitude;
                        uniform vec3 lightPosition;
                        uniform float refractionIndex;

                        varying float vIntensity;

                        vec3 getWavePosition(vec3 pos) {
                            float wave1 = sin(pos.x * 0.5 + time * waveSpeed) * waveAmplitude;
                            float wave2 = sin(pos.z * 0.3 - time * waveSpeed * 0.7) * waveAmplitude * 0.8;
                            float wave3 = sin((pos.x - pos.z) * 0.4 + time * waveSpeed * 1.3) * waveAmplitude * 0.6;
                            float bigWave = sin(pos.x * 0.15 + time * waveSpeed * 0.5) * waveAmplitude * 2.0;
                            
                            pos.y += wave1 + wave2 + wave3 + bigWave;
                            return pos;
                        }

                        vec3 getWaveNormal(vec3 pos, float delta) {
                            vec3 posX = getWavePosition(pos + vec3(delta, 0.0, 0.0));
                            vec3 posZ = getWavePosition(pos + vec3(0.0, 0.0, delta));
                            vec3 tangentX = normalize(posX - pos);
                            vec3 tangentZ = normalize(posZ - pos);
                            return normalize(cross(tangentZ, tangentX));
                        }

                        void main() {
                            vec3 pos = position;
                            pos.y = 0.0;
                            vec3 wavePos = getWavePosition(pos);
                            vec3 waveNormal = getWaveNormal(pos, 0.1);

                            vec3 lightDir = normalize(wavePos - lightPosition);
                            vec3 refracted = refract(lightDir, waveNormal, 1.0 / refractionIndex);
                            
                            float t = (wavePos.y - (-3.0)) / -refracted.y;
                            vec3 refractedPos = wavePos + refracted * t;
                            
                            float delta = 0.15;
                            vec3 pos1 = getWavePosition(pos + vec3(delta, 0.0, 0.0));
                            vec3 pos2 = getWavePosition(pos + vec3(0.0, 0.0, delta));
                            
                            vec3 normal1 = getWaveNormal(pos + vec3(delta, 0.0, 0.0), 0.1);
                            vec3 normal2 = getWaveNormal(pos + vec3(0.0, 0.0, delta), 0.1);
                            
                            vec3 dir1 = normalize(pos1 - lightPosition);
                            vec3 dir2 = normalize(pos2 - lightPosition);
                            
                            vec3 refr1 = refract(dir1, normal1, 1.0 / refractionIndex);
                            vec3 refr2 = refract(dir2, normal2, 1.0 / refractionIndex);
                            
                            float t1 = (pos1.y - (-3.0)) / -refr1.y;
                            float t2 = (pos2.y - (-3.0)) / -refr2.y;
                            
                            vec3 refrPos1 = pos1 + refr1 * t1;
                            vec3 refrPos2 = pos2 + refr2 * t2;
                            
                            float originalArea = delta * delta;
                            float refractedArea = length(refrPos1 - refractedPos) * length(refrPos2 - refractedPos);
                            vIntensity = originalArea / max(refractedArea, 0.01);
                            vIntensity = clamp(vIntensity, 0.0, 10.0);
                            
                            gl_Position = projectionMatrix * viewMatrix * vec4(refractedPos, 1.0);
                            gl_PointSize = 3.0;
                        }
                    `,
                    fragmentShader: `
                        varying float vIntensity;

                        void main() {
                            float brightness = vIntensity * 0.08;
                            vec3 causticsColor = vec3(brightness);
                            causticsColor = mix(causticsColor, vec3(0.5, 0.8, 1.0) * brightness, 0.3);
                            
                            gl_FragColor = vec4(causticsColor, 1.0);
                        }
                    `,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    transparent: true
                });

                this.causticsMesh = new THREE.Points(causticsGeometry, causticsMaterial);
                this.causticsMesh.rotation.x = -Math.PI / 2;
                this.causticsMesh.position.y = -3;
                this.causticsScene.add(this.causticsMesh);
            }

            createSurfer() {
                // Create surfboard
                const boardGeometry = new THREE.BoxGeometry(0.5, 0.1, 1.5);
                const boardMaterial = new THREE.MeshStandardMaterial({
                    color: 0xff6b35,
                    roughness: 0.3,
                    metalness: 0.1
                });
                this.surfboard = new THREE.Mesh(boardGeometry, boardMaterial);
                this.surfboard.castShadow = true;
                this.surfboard.receiveShadow = true;

                // Create surfer body (simple representation)
                const bodyGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.8, 8);
                const bodyMaterial = new THREE.MeshStandardMaterial({
                    color: 0x3498db
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.5;
                body.castShadow = true;

                // Create head
                const headGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                const headMaterial = new THREE.MeshStandardMaterial({
                    color: 0xffdbac
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.0;
                head.castShadow = true;

                // Create arms
                const armGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.6, 6);
                const armMaterial = new THREE.MeshStandardMaterial({
                    color: 0x3498db
                });
                
                const leftArm = new THREE.Mesh(armGeometry, armMaterial);
                leftArm.position.set(-0.3, 0.5, 0);
                leftArm.rotation.z = Math.PI / 4;
                leftArm.castShadow = true;

                const rightArm = new THREE.Mesh(armGeometry, armMaterial);
                rightArm.position.set(0.3, 0.5, 0);
                rightArm.rotation.z = -Math.PI / 4;
                rightArm.castShadow = true;

                // Group everything
                this.surfer = new THREE.Group();
                this.surfer.add(this.surfboard);
                this.surfer.add(body);
                this.surfer.add(head);
                this.surfer.add(leftArm);
                this.surfer.add(rightArm);

                this.scene.add(this.surfer);
            }

            spawnObstacles() {
                // Spawn buoys as obstacles
                const buoyGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const buoyMaterial = new THREE.MeshStandardMaterial({
                    color: 0xff0000,
                    roughness: 0.5
                });

                for (let i = 0; i < 10; i++) {
                    const buoy = new THREE.Mesh(buoyGeometry, buoyMaterial);
                    buoy.position.set(
                        (Math.random() - 0.5) * 20,
                        0,
                        15 + i * 15 + Math.random() * 10
                    );
                    buoy.castShadow = true;
                    buoy.receiveShadow = true;
                    this.scene.add(buoy);
                    this.obstacles.push(buoy);
                }
            }

            getWaveHeight(x, z) {
                const time = this.time;
                const waveSpeed = this.params.waveSpeed;
                const waveAmplitude = this.params.waveAmplitude;

                const wave1 = Math.sin(x * 0.5 + time * waveSpeed) * waveAmplitude;
                const wave2 = Math.sin(z * 0.3 - time * waveSpeed * 0.7) * waveAmplitude * 0.8;
                const wave3 = Math.sin((x - z) * 0.4 + time * waveSpeed * 1.3) * waveAmplitude * 0.6;
                const bigWave = Math.sin(x * 0.15 + time * waveSpeed * 0.5) * waveAmplitude * 2.0;

                return wave1 + wave2 + wave3 + bigWave;
            }

            getWaveSlope(x, z) {
                const delta = 0.1;
                const h1 = this.getWaveHeight(x - delta, z);
                const h2 = this.getWaveHeight(x + delta, z);
                return (h2 - h1) / (2 * delta);
            }

            updatePlayer(deltaTime) {
                if (this.gameState !== 'playing') return;

                const player = this.player;
                const speed = player.speed;

                // Input handling
                if (this.keys.left) {
                    player.velocity.x -= 10 * deltaTime;
                }
                if (this.keys.right) {
                    player.velocity.x += 10 * deltaTime;
                }
                if (this.keys.up && !player.isAirborne) {
                    player.acceleration = 2;
                }
                if (this.keys.space && !player.isAirborne && !this.stats.trickInProgress) {
                    // Jump
                    player.velocity.y = 4;
                    player.isAirborne = true;
                    player.airTime = 0;
                    this.stats.trickInProgress = true;
                }

                // Apply acceleration
                player.speed += player.acceleration * deltaTime;
                player.speed = Math.max(3, Math.min(player.speed, player.maxSpeed));
                player.acceleration *= 0.95;

                // Forward movement
                player.velocity.z = player.speed;

                // Lateral drag
                player.velocity.x *= 0.95;
                player.velocity.x = Math.max(-5, Math.min(5, player.velocity.x));

                // Update position
                player.position.x += player.velocity.x * deltaTime;
                player.position.z += player.velocity.z * deltaTime;

                // Keep player in bounds
                player.position.x = Math.max(-8, Math.min(8, player.position.x));

                // Get wave height at player position
                const waveHeight = this.getWaveHeight(player.position.x, player.position.z);
                const waveSlope = this.getWaveSlope(player.position.x, player.position.z);

                if (player.isAirborne) {
                    // Gravity
                    player.velocity.y -= 9.8 * deltaTime;
                    player.position.y += player.velocity.y * deltaTime;
                    player.airTime += deltaTime;

                    // Aerial rotation
                    player.rotation += 3 * deltaTime;

                    // Check landing
                    if (player.position.y <= waveHeight + 0.1) {
                        player.position.y = waveHeight;
                        player.isAirborne = false;
                        player.velocity.y = 0;

                        // Score aerial trick
                        if (player.airTime > 0.5) {
                            this.performTrick('Aerial', Math.floor(player.airTime * 100));
                        }
                        this.stats.trickInProgress = false;
                    }
                } else {
                    // Stay on wave
                    player.position.y = waveHeight;
                    player.targetRotation = waveSlope * 0.5;
                    player.onWave = true;

                    // Score for wave riding
                    this.stats.currentWaveScore += player.speed * deltaTime;
                    this.addScore(Math.floor(player.speed * deltaTime * this.stats.multiplier));
                }

                // Smooth rotation
                player.rotation += (player.targetRotation - player.rotation) * 5 * deltaTime;

                // Update surfer mesh position and rotation
                this.surfer.position.copy(player.position);
                this.surfer.rotation.y = Math.PI;
                this.surfer.rotation.z = player.rotation;
                this.surfer.rotation.x = waveSlope * 0.3;

                // Update distance
                this.stats.distance = Math.floor(player.position.z);
                document.getElementById('distance').textContent = this.stats.distance + 'm';

                // Check for game over conditions
                if (player.position.y < -2) {
                    this.gameOver();
                }

                // Update multiplier based on performance
                this.updateMultiplier(deltaTime);

                // Update speed bar
                const speedPercent = (player.speed / player.maxSpeed) * 100;
                document.getElementById('speed-fill').style.width = speedPercent + '%';

                // Create particles
                if (!player.isAirborne && Math.random() < 0.3) {
                    this.createParticle(player.position.clone());
                }
            }

            updateMultiplier(deltaTime) {
                this.stats.comboTimer -= deltaTime;
                
                if (this.stats.comboTimer <= 0) {
                    this.stats.multiplier = Math.max(1, this.stats.multiplier - 1);
                }

                document.getElementById('multiplier-value').textContent = this.stats.multiplier + 'x';
            }

            performTrick(trickName, points) {
                points = Math.floor(points * this.stats.multiplier);
                this.addScore(points);
                
                this.stats.multiplier = Math.min(10, this.stats.multiplier + 1);
                this.stats.comboTimer = 3;

                // Show trick notification
                const notification = document.getElementById('trick-notification');
                notification.textContent = `${trickName} +${points}!`;
                notification.classList.add('show');
                setTimeout(() => {
                    notification.classList.remove('show');
                }, 1500);

                // Show combo
                this.showCombo();
            }

            showCombo() {
                if (this.stats.multiplier > 1) {
                    const comboDisplay = document.getElementById('combo-display');
                    comboDisplay.textContent = `${this.stats.multiplier}x COMBO!`;
                    comboDisplay.classList.add('show');
                    setTimeout(() => {
                        comboDisplay.classList.remove('show');
                    }, 1000);
                }
            }

            addScore(points) {
                this.stats.score += points;
                document.getElementById('current-score').textContent = this.stats.score;
            }

            createParticle(position) {
                const particleEl = document.createElement('div');
                particleEl.className = 'particle';
                
                // Convert 3D position to screen position
                const vector = position.clone();
                vector.project(this.camera);
                
                const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-(vector.y * 0.5) + 0.5) * window.innerHeight;
                
                particleEl.style.left = x + 'px';
                particleEl.style.top = y + 'px';
                
                document.getElementById('game-ui').appendChild(particleEl);
                
                setTimeout(() => {
                    particleEl.remove();
                }, 1000);
            }

            updateObstacles(deltaTime) {
                this.obstacles.forEach((obstacle, index) => {
                    // Update obstacle position on wave
                    const waveHeight = this.getWaveHeight(obstacle.position.x, obstacle.position.z);
                    obstacle.position.y = waveHeight + 0.5;

                    // Move obstacles backward relative to player
                    obstacle.position.z -= this.player.velocity.z * deltaTime;

                    // Respawn if behind player
                    if (obstacle.position.z < this.player.position.z - 20) {
                        obstacle.position.z = this.player.position.z + 100 + Math.random() * 50;
                        obstacle.position.x = (Math.random() - 0.5) * 20;
                    }

                    // Check collision
                    const distance = this.player.position.distanceTo(obstacle.position);
                    if (distance < 1.5 && !this.player.isAirborne) {
                        this.gameOver();
                    }
                });
            }

            updateCaustics() {
                // Update water surface uniforms
                if (this.waterSurface.material.uniforms) {
                    this.waterSurface.material.uniforms.time.value = this.time;
                    this.waterSurface.material.uniforms.waveSpeed.value = this.params.waveSpeed;
                    this.waterSurface.material.uniforms.waveAmplitude.value = this.params.waveAmplitude;
                }

                // Update caustics mesh uniforms
                if (this.causticsMesh.material.uniforms) {
                    this.causticsMesh.material.uniforms.time.value = this.time;
                    this.causticsMesh.material.uniforms.waveSpeed.value = this.params.waveSpeed;
                    this.causticsMesh.material.uniforms.waveAmplitude.value = this.params.waveAmplitude;
                }

                // Render caustics to texture
                const currentRenderTarget = this.renderer.getRenderTarget();
                this.renderer.setRenderTarget(this.causticsTarget);
                this.renderer.clear();
                this.renderer.render(this.causticsScene, this.causticsCamera);
                this.renderer.setRenderTarget(currentRenderTarget);

                // Update floor material
                if (this.poolBottom.material.uniforms) {
                    this.poolBottom.material.uniforms.time.value = this.time;
                }
            }

            updateCamera() {
                if (this.gameState !== 'playing') return;

                // Camera follows player
                const targetX = this.player.position.x * 0.5;
                const targetY = this.player.position.y + 4;
                const targetZ = this.player.position.z - 8;

                this.camera.position.x += (targetX - this.camera.position.x) * 0.1;
                this.camera.position.y += (targetY - this.camera.position.y) * 0.1;
                this.camera.position.z += (targetZ - this.camera.position.z) * 0.1;

                this.camera.lookAt(
                    this.player.position.x,
                    this.player.position.y + 1,
                    this.player.position.z + 5
                );
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                const currentTime = performance.now();
                const deltaTime = Math.min((currentTime - this.lastFrameTime) / 1000, 0.1);
                this.lastFrameTime = currentTime;

                if (this.gameState === 'playing') {
                    this.time += deltaTime;

                    // Update game logic
                    this.updatePlayer(deltaTime);
                    this.updateObstacles(deltaTime);
                    this.updateCaustics();
                    this.updateCamera();
                }

                // Render scene
                this.renderer.render(this.scene, this.camera);
            }

            startGame() {
                this.gameState = 'playing';
                
                // Reset player
                this.player.position.set(0, 0, 0);
                this.player.velocity.set(0, 0, 0);
                this.player.rotation = 0;
                this.player.speed = 5;
                this.player.isAirborne = false;

                // Reset stats
                this.stats.score = 0;
                this.stats.distance = 0;
                this.stats.multiplier = 1;
                this.stats.comboTimer = 0;
                this.stats.currentWaveScore = 0;

                // Update UI
                document.getElementById('current-score').textContent = '0';
                document.getElementById('distance').textContent = '0m';
                document.getElementById('multiplier-value').textContent = '1x';

                // Hide start screen
                document.getElementById('start-screen').classList.add('hidden');
            }

            gameOver() {
                if (this.gameState !== 'playing') return;
                
                this.gameState = 'gameover';

                // Update high score
                if (this.stats.score > this.highScore) {
                    this.highScore = this.stats.score;
                    localStorage.setItem('waveRiderHighScore', this.highScore.toString());
                }

                // Show game over screen
                document.getElementById('final-score-value').textContent = this.stats.score;
                document.getElementById('high-score-value').textContent = this.highScore;
                document.getElementById('game-over-screen').classList.add('show');
            }

            restartGame() {
                // Hide game over screen
                document.getElementById('game-over-screen').classList.remove('show');
                
                // Reset obstacles
                this.obstacles.forEach((obstacle, i) => {
                    obstacle.position.set(
                        (Math.random() - 0.5) * 20,
                        0,
                        15 + i * 15 + Math.random() * 10
                    );
                });

                // Start new game
                this.startGame();
            }

            showStartScreen() {
                document.getElementById('high-score-value').textContent = this.highScore;
            }

            setupEventListeners() {
                // Keyboard controls
                window.addEventListener('keydown', (e) => {
                    if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
                        this.keys.left = true;
                    }
                    if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                        this.keys.right = true;
                    }
                    if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
                        this.keys.up = true;
                    }
                    if (e.key === ' ') {
                        this.keys.space = true;
                        e.preventDefault();
                    }
                });

                window.addEventListener('keyup', (e) => {
                    if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
                        this.keys.left = false;
                    }
                    if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                        this.keys.right = false;
                    }
                    if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
                        this.keys.up = false;
                    }
                    if (e.key === ' ') {
                        this.keys.space = false;
                    }
                });

                // Start button
                document.getElementById('start-button').addEventListener('click', () => {
                    this.startGame();
                });

                // Restart button
                document.getElementById('restart-button').addEventListener('click', () => {
                    this.restartGame();
                });
            }

            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        // Initialize game when page loads
        window.addEventListener('DOMContentLoaded', () => {
            new WaveRiderGame();
        });
    </script>
</body>
</html>
