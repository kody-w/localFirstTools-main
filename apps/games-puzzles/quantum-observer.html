<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Observer - Wavefunction Collapse Puzzle</title>
    <meta name="description" content="A first-person puzzle game where reality exists in superposition. Objects change states when unobserved. Master the Observer Effect to solve puzzles.">
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #0ff;
            pointer-events: none;
            text-shadow: 0 0 5px #0ff;
        }
        #reticle {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        #reticle.active {
            background: rgba(0, 255, 255, 0.3);
            border-color: #fff;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.7);
            pointer-events: none;
            font-size: 14px;
        }
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            z-index: 100;
        }
        button {
            background: transparent;
            border: 2px solid #0ff;
            color: #0ff;
            padding: 15px 30px;
            font-size: 18px;
            font-family: inherit;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        button:hover {
            background: rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 15px #0ff;
        }
        .quantum-state {
            position: absolute;
            right: 20px;
            top: 20px;
            text-align: right;
        }
        .state-bar {
            width: 150px;
            height: 5px;
            background: #333;
            margin-top: 5px;
            position: relative;
        }
        .state-fill {
            height: 100%;
            background: #0ff;
            width: 0%;
            transition: width 0.2s;
        }
        #level-info {
            font-size: 24px;
            margin-bottom: 10px;
        }
        .glitch {
            animation: glitch 1s linear infinite;
        }
        @keyframes glitch {
            2%, 64% { transform: translate(2px,0) skew(0deg); }
            4%, 60% { transform: translate(-2px,0) skew(0deg); }
            62% { transform: translate(0,0) skew(5deg); }
        }
    </style>
</head>
<body>
    <div id="ui">
        <div id="level-info">LEVEL 1: SUPERPOSITION</div>
        <div>OBJECTS: <span id="obj-count">0</span></div>
        <div>COLLAPSED: <span id="collapsed-count">0</span></div>
    </div>

    <div class="quantum-state">
        <div>COHERENCE</div>
        <div class="state-bar"><div class="state-fill" id="coherence-bar"></div></div>
    </div>

    <div id="reticle"></div>
    
    <div id="instructions">
        WASD to Move • MOUSE to Look • CLICK to Interact<br>
        Look away to let reality evolve. Look back to collapse the wavefunction.
    </div>

    <div id="overlay">
        <h1 style="font-size: 48px; margin-bottom: 10px; text-shadow: 0 0 10px #0ff;">QUANTUM OBSERVER</h1>
        <p style="max-width: 600px; text-align: center; line-height: 1.6;">
            Welcome to the Quantum Realm.<br><br>
            Objects here exist in a state of <strong>Superposition</strong>.<br>
            They are in multiple states simultaneously until <strong>Observed</strong>.<br><br>
            If you need an object to change, <strong>look away</strong>.<br>
            When you look back, the wavefunction will collapse into a single state.<br><br>
            Manipulate probability to escape.
        </p>
        <button id="start-btn">ENTER SIMULATION</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // Game State
        const STATE = {
            level: 1,
            coherence: 100,
            isPaused: true,
            objects: [],
            lastTime: 0
        };

        // Three.js Setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050510);
        scene.fog = new THREE.FogExp2(0x050510, 0.03);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.y = 1.6;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight.position.set(0, 10, 0);
        scene.add(dirLight);

        // Controls
        const controls = new PointerLockControls(camera, document.body);
        
        const moveState = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            sprint: false
        };

        // Quantum Object Class
        class QuantumObject {
            constructor(position, type, possibleStates) {
                this.position = position.clone();
                this.type = type; // 'cube', 'sphere', 'door', 'key'
                this.possibleStates = possibleStates; // Array of {pos, color, scale, etc}
                this.currentStateIndex = 0;
                this.isObserved = false;
                this.probabilityCloud = null;
                this.mesh = null;
                this.lastObservationTime = 0;
                this.entropy = 0;
                
                this.init();
            }

            init() {
                // Create the mesh based on initial state
                this.updateMesh(this.possibleStates[0]);
                
                // Create probability cloud (wireframe ghost)
                const geometry = this.mesh.geometry.clone();
                const material = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.1
                });
                this.probabilityCloud = new THREE.Mesh(geometry, material);
                this.probabilityCloud.position.copy(this.position);
                scene.add(this.probabilityCloud);
            }

            updateMesh(state) {
                if (this.mesh) scene.remove(this.mesh);

                let geometry;
                if (this.type === 'cube') geometry = new THREE.BoxGeometry(1, 1, 1);
                else if (this.type === 'sphere') geometry = new THREE.SphereGeometry(0.5, 32, 32);
                else if (this.type === 'door') geometry = new THREE.BoxGeometry(2, 3, 0.2);
                else if (this.type === 'key') geometry = new THREE.OctahedronGeometry(0.3);
                else if (this.type === 'platform') geometry = new THREE.BoxGeometry(2, 0.2, 2);

                const material = new THREE.MeshPhongMaterial({
                    color: state.color || 0xffffff,
                    emissive: state.emissive || 0x000000,
                    transparent: true,
                    opacity: state.opacity || 1.0,
                    shininess: 100
                });

                this.mesh = new THREE.Mesh(geometry, material);
                
                // Apply state transform
                if (state.position) this.mesh.position.copy(state.position);
                else this.mesh.position.copy(this.position);
                
                if (state.rotation) this.mesh.rotation.set(state.rotation.x, state.rotation.y, state.rotation.z);
                if (state.scale) this.mesh.scale.copy(state.scale);

                this.mesh.userData = { isQuantum: true, parent: this };
                scene.add(this.mesh);
            }

            update(camera, time) {
                // Check if in view frustum
                const frustum = new THREE.Frustum();
                const projScreenMatrix = new THREE.Matrix4();
                projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
                frustum.setFromProjectionMatrix(projScreenMatrix);

                const wasObserved = this.isObserved;
                this.isObserved = frustum.containsPoint(this.mesh.position);

                // Raycast check for occlusion (simplified)
                if (this.isObserved) {
                    const dir = this.mesh.position.clone().sub(camera.position).normalize();
                    const dist = this.mesh.position.distanceTo(camera.position);
                    const raycaster = new THREE.Raycaster(camera.position, dir, 0.1, dist - 0.5);
                    // In a real engine we'd check occlusion against walls, but for now we assume walls block view
                    // We'll just use frustum for the "Observer Effect" mechanic as it's more predictable for gameplay
                }

                if (this.isObserved) {
                    // Wavefunction Collapse
                    if (!wasObserved) {
                        // Just entered view - collapse to a specific state based on probability
                        this.collapse();
                    }
                    
                    // Visual effect for observed state
                    this.mesh.material.opacity = 1.0;
                    this.probabilityCloud.visible = false;
                    this.entropy = 0;
                } else {
                    // Evolution / Superposition
                    this.entropy += 0.01;
                    
                    // Visual effect for unobserved state (if we could see it, which we can't, but for debug/peripheral)
                    // Actually, we can see the probability cloud if it's large enough to enter frustum while center is out
                    this.probabilityCloud.visible = true;
                    this.probabilityCloud.rotation.x += 0.01;
                    this.probabilityCloud.rotation.y += 0.02;
                    
                    // Cycle through possible states "in the dark"
                    if (Math.random() < 0.05) {
                        this.currentStateIndex = Math.floor(Math.random() * this.possibleStates.length);
                        // We don't update the mesh yet, only when observed
                    }
                }
            }

            collapse() {
                // Pick a state
                const state = this.possibleStates[this.currentStateIndex];
                this.updateMesh(state);
                
                // Particle effect
                createCollapseEffect(this.mesh.position);
                
                // Sound effect would go here
            }
        }

        // Particle System
        const particles = [];
        function createCollapseEffect(pos) {
            const geometry = new THREE.BufferGeometry();
            const count = 20;
            const positions = new Float32Array(count * 3);
            
            for(let i=0; i<count; i++) {
                positions[i*3] = pos.x + (Math.random()-0.5);
                positions[i*3+1] = pos.y + (Math.random()-0.5);
                positions[i*3+2] = pos.z + (Math.random()-0.5);
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({ color: 0x00ffff, size: 0.1 });
            const points = new THREE.Points(geometry, material);
            scene.add(points);
            particles.push({ mesh: points, life: 1.0 });
        }

        // Level Generation
        function loadLevel(levelNum) {
            // Clear existing
            STATE.objects.forEach(obj => {
                scene.remove(obj.mesh);
                scene.remove(obj.probabilityCloud);
            });
            STATE.objects = [];
            
            // Reset Player
            camera.position.set(0, 1.6, 5);
            camera.rotation.set(0, 0, 0);

            // Build Room
            createRoom(20, 10, 20);

            if (levelNum === 1) {
                // Tutorial: The Blinking Cube
                // A cube that moves between two pedestals when you look away
                
                // Pedestals
                createStaticBox(new THREE.Vector3(-3, 0.5, -5), new THREE.Vector3(1, 1, 1), 0x444444);
                createStaticBox(new THREE.Vector3(3, 0.5, -5), new THREE.Vector3(1, 1, 1), 0x444444);
                
                // Quantum Cube
                const qCube = new QuantumObject(new THREE.Vector3(0, 0, 0), 'cube', [
                    { position: new THREE.Vector3(-3, 1.5, -5), color: 0x00ffff },
                    { position: new THREE.Vector3(3, 1.5, -5), color: 0xff00ff }
                ]);
                STATE.objects.push(qCube);
                
                // Goal: Door that opens when cube is on the pink pedestal (right)
                const door = new QuantumObject(new THREE.Vector3(0, 0, 0), 'door', [
                    { position: new THREE.Vector3(0, 1.5, -9.9), color: 0x555555, scale: new THREE.Vector3(1, 1, 1) }, // Closed
                    { position: new THREE.Vector3(0, 1.5, -9.9), color: 0x00ff00, scale: new THREE.Vector3(0.1, 1, 1) } // Open
                ]);
                // Link door state to cube state
                door.update = function(camera) {
                    QuantumObject.prototype.update.call(this, camera);
                    // Override logic: if cube is at index 1 (pink), door is open (index 1)
                    if (qCube.currentStateIndex === 1) {
                        if (this.currentStateIndex !== 1) {
                            this.currentStateIndex = 1;
                            this.collapse();
                        }
                    } else {
                        if (this.currentStateIndex !== 0) {
                            this.currentStateIndex = 0;
                            this.collapse();
                        }
                    }
                };
                STATE.objects.push(door);
                
                document.getElementById('level-info').innerText = "LEVEL 1: THE OBSERVER EFFECT";
            }
            else if (levelNum === 2) {
                // The Bridge of Probability
                // Platforms that only exist when you look at them, but disappear if you look too long?
                // Or platforms that move.
                
                // Gap
                createStaticBox(new THREE.Vector3(0, 0, 5), new THREE.Vector3(4, 0.1, 4), 0x444444); // Start
                createStaticBox(new THREE.Vector3(0, 0, -15), new THREE.Vector3(4, 0.1, 4), 0x444444); // End
                
                // Quantum Platforms
                for(let i=0; i<5; i++) {
                    const z = 2 - (i * 3);
                    const platform = new QuantumObject(new THREE.Vector3(0, 0, 0), 'platform', [
                        { position: new THREE.Vector3(-2, 0, z), color: 0x00ff00 },
                        { position: new THREE.Vector3(0, 0, z), color: 0x00ff00 },
                        { position: new THREE.Vector3(2, 0, z), color: 0x00ff00 },
                        { position: new THREE.Vector3(0, -10, z), color: 0xff0000 } // Pitfall state
                    ]);
                    STATE.objects.push(platform);
                }
                
                document.getElementById('level-info').innerText = "LEVEL 2: PROBABILITY BRIDGE";
            }
        }

        function createRoom(w, h, d) {
            const geometry = new THREE.BoxGeometry(w, h, d);
            const material = new THREE.MeshPhongMaterial({ 
                color: 0x202030, 
                side: THREE.BackSide,
                grid: true
            });
            const room = new THREE.Mesh(geometry, material);
            room.position.y = h/2;
            scene.add(room);
            
            // Grid helper
            const grid = new THREE.GridHelper(w, w/2, 0x00ffff, 0x222222);
            scene.add(grid);
        }

        function createStaticBox(pos, size, color) {
            const geometry = new THREE.BoxGeometry(size.x, size.y, size.z);
            const material = new THREE.MeshPhongMaterial({ color: color });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(pos);
            scene.add(mesh);
            return mesh;
        }

        // Input Handling
        document.addEventListener('keydown', (e) => {
            switch(e.code) {
                case 'KeyW': moveState.forward = true; break;
                case 'KeyS': moveState.backward = true; break;
                case 'KeyA': moveState.left = true; break;
                case 'KeyD': moveState.right = true; break;
                case 'ShiftLeft': moveState.sprint = true; break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'KeyW': moveState.forward = false; break;
                case 'KeyS': moveState.backward = false; break;
                case 'KeyA': moveState.left = false; break;
                case 'KeyD': moveState.right = false; break;
                case 'ShiftLeft': moveState.sprint = false; break;
            }
        });

        document.getElementById('start-btn').addEventListener('click', () => {
            controls.lock();
            document.getElementById('overlay').style.display = 'none';
            STATE.isPaused = false;
            loadLevel(1);
        });

        controls.addEventListener('unlock', () => {
            document.getElementById('overlay').style.display = 'flex';
            STATE.isPaused = true;
        });

        // Game Loop
        const clock = new THREE.Clock();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();

        function animate() {
            requestAnimationFrame(animate);

            if (STATE.isPaused) return;

            const delta = clock.getDelta();

            // Movement
            if (controls.isLocked) {
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;

                direction.z = Number(moveState.forward) - Number(moveState.backward);
                direction.x = Number(moveState.right) - Number(moveState.left);
                direction.normalize();

                const speed = moveState.sprint ? 15.0 : 8.0;

                if (moveState.forward || moveState.backward) velocity.z -= direction.z * speed * 10.0 * delta;
                if (moveState.left || moveState.right) velocity.x -= direction.x * speed * 10.0 * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
            }

            // Update Quantum Objects
            let observedCount = 0;
            STATE.objects.forEach(obj => {
                obj.update(camera, clock.elapsedTime);
                if (obj.isObserved) observedCount++;
            });

            // Update UI
            document.getElementById('obj-count').innerText = STATE.objects.length;
            document.getElementById('collapsed-count').innerText = observedCount;
            
            const coherence = Math.max(0, 100 - (observedCount * 10));
            document.getElementById('coherence-bar').style.width = coherence + '%';

            // Update Particles
            for(let i=particles.length-1; i>=0; i--) {
                const p = particles[i];
                p.life -= delta;
                p.mesh.material.opacity = p.life;
                p.mesh.scale.multiplyScalar(1.05);
                if(p.life <= 0) {
                    scene.remove(p.mesh);
                    particles.splice(i, 1);
                }
            }

            // Level Progression Check
            if (STATE.level === 1) {
                // Check if player walked through door
                if (camera.position.z < -10) {
                    STATE.level = 2;
                    loadLevel(2);
                }
            }

            renderer.render(scene, camera);
        }

        animate();

        // Window Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>