<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EvoMon History Viewer</title>
    <style>
        body {
            margin: 0;
            background: #050510;
            color: #fff;
            font-family: 'Segoe UI', sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        
        header {
            padding: 15px 20px;
            background: #0a0a1a;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        h1 { margin: 0; font-size: 24px; color: #00ffff; }
        
        #main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        #sidebar {
            width: 300px;
            background: #0a0a15;
            border-right: 1px solid #333;
            display: flex;
            flex-direction: column;
        }
        
        #history-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }
        
        .history-item {
            padding: 15px;
            margin-bottom: 10px;
            background: #111;
            border: 1px solid #333;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .history-item:hover { background: #1a1a2a; border-color: #555; }
        .history-item.active { background: #002233; border-color: #00ffff; }
        
        .gen-badge {
            display: inline-block;
            background: #004444;
            color: #00ffff;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
            margin-bottom: 5px;
        }
        
        .event-title { font-weight: bold; margin-bottom: 5px; }
        .event-date { font-size: 11px; color: #888; }
        
        #viewer-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        
        #canvas-container {
            flex: 1;
            background: #000;
            position: relative;
        }
        
        #canvas-3d { width: 100%; height: 100%; display: block; }
        
        #overlay-2d {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #444;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #stats-panel {
            height: 200px;
            background: #0a0a1a;
            border-top: 1px solid #333;
            padding: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
        }
        
        .stat-group h3 { margin: 0 0 10px 0; color: #aaa; font-size: 14px; text-transform: uppercase; }
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 14px; }
        .stat-val { color: #00ffff; font-family: monospace; }
        
        button {
            background: #222;
            color: #fff;
            border: 1px solid #444;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover { background: #333; border-color: #666; }
        
        #empty-state {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #555;
        }
    </style>
</head>
<body>
    <header>
        <h1>EvoMon History Viewer</h1>
        <div>
            <button onclick="document.getElementById('file-input').click()">Import Save File</button>
            <input type="file" id="file-input" style="display: none" onchange="app.loadSave(this)">
        </div>
    </header>
    
    <div id="main-container">
        <div id="sidebar">
            <div style="padding: 15px; border-bottom: 1px solid #333; font-size: 12px; color: #888;">
                TIMELINE
            </div>
            <div id="history-list">
                <!-- Items injected here -->
            </div>
        </div>
        
        <div id="viewer-area">
            <div id="empty-state">
                <h2>No Creature Loaded</h2>
                <p>Import an EvoMon save file to view its evolutionary history.</p>
            </div>
            
            <div id="canvas-container" style="display: none;">
                <canvas id="canvas-3d"></canvas>
                <div id="overlay-2d"></div>
            </div>
            
            <div id="stats-panel" style="display: none;">
                <div class="stat-group">
                    <h3>Genome</h3>
                    <div class="stat-row"><span>Aggression</span><span class="stat-val" id="val-agg">0.00</span></div>
                    <div class="stat-row"><span>Resilience</span><span class="stat-val" id="val-res">0.00</span></div>
                    <div class="stat-row"><span>Agility</span><span class="stat-val" id="val-agi">0.00</span></div>
                    <div class="stat-row"><span>Element</span><span class="stat-val" id="val-ele">0.00</span></div>
                </div>
                <div class="stat-group">
                    <h3>Status</h3>
                    <div class="stat-row"><span>Generation</span><span class="stat-val" id="val-gen">1</span></div>
                    <div class="stat-row"><span>Level</span><span class="stat-val" id="val-lvl">1</span></div>
                    <div class="stat-row"><span>Event</span><span class="stat-val" id="val-evt">-</span></div>
                </div>
                <div class="stat-group">
                    <h3>Details</h3>
                    <div id="val-desc" style="font-size: 13px; color: #ccc; line-height: 1.4;"></div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class ViewerApp {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.creature = null;
                this.currentData = null;
                
                this.initThree();
                window.addEventListener('resize', () => this.onResize());
            }
            
            initThree() {
                const canvas = document.getElementById('canvas-3d');
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x111111);
                
                this.camera = new THREE.PerspectiveCamera(45, canvas.clientWidth / canvas.clientHeight, 0.1, 100);
                this.camera.position.set(0, 1, 3);
                this.camera.lookAt(0, 0.5, 0);
                
                this.renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
                this.renderer.setSize(canvas.clientWidth, canvas.clientHeight);
                
                // Lights
                const ambient = new THREE.AmbientLight(0x404040);
                this.scene.add(ambient);
                
                const dirLight = new THREE.DirectionalLight(0xffffff, 1);
                dirLight.position.set(5, 10, 7);
                this.scene.add(dirLight);
                
                const backLight = new THREE.DirectionalLight(0x445566, 0.5);
                backLight.position.set(-5, 2, -5);
                this.scene.add(backLight);
                
                this.animate();
            }
            
            loadSave(input) {
                const file = input.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const json = JSON.parse(e.target.result);
                        // Handle wrapped format vs raw stats
                        this.currentData = json.stats || json;
                        
                        // Ensure genome exists in currentData if not in log
                        if (!this.currentData.genome && this.currentData.evolutionLog && this.currentData.evolutionLog.length > 0) {
                             this.currentData.genome = this.currentData.evolutionLog[this.currentData.evolutionLog.length-1].genome;
                        }

                        if (!this.currentData.evolutionLog || this.currentData.evolutionLog.length === 0) {
                            // Create fake log for legacy saves
                            this.currentData.evolutionLog = [{
                                gen: 1,
                                timestamp: new Date().toISOString(),
                                event: "Current State",
                                genome: this.currentData.genome,
                                level: this.currentData.level
                            }];
                        }
                        
                        this.renderHistoryList();
                        this.loadEntry(this.currentData.evolutionLog.length - 1); // Load latest
                        
                        document.getElementById('empty-state').style.display = 'none';
                        document.getElementById('canvas-container').style.display = 'block';
                        document.getElementById('stats-panel').style.display = 'grid';
                        
                        // Force resize after display change
                        this.onResize();
                        
                    } catch (err) {
                        console.error(err);
                        alert("Failed to parse save file: " + err.message);
                    }
                };
                reader.readAsText(file);
                // Reset input so same file can be selected again
                input.value = '';
            }
            
            renderHistoryList() {
                const list = document.getElementById('history-list');
                list.innerHTML = '';
                
                this.currentData.evolutionLog.forEach((entry, index) => {
                    const el = document.createElement('div');
                    el.className = 'history-item';
                    el.innerHTML = `
                        <span class="gen-badge">GEN ${entry.gen}</span>
                        <div class="event-title">${entry.event}</div>
                        <div class="event-date">${new Date(entry.timestamp).toLocaleString()}</div>
                    `;
                    el.onclick = () => {
                        document.querySelectorAll('.history-item').forEach(i => i.classList.remove('active'));
                        el.classList.add('active');
                        this.loadEntry(index);
                    };
                    list.appendChild(el);
                });
                
                // Select last item by default
                list.lastChild.classList.add('active');
            }
            
            loadEntry(index) {
                const entry = this.currentData.evolutionLog[index];
                
                // Update Stats
                document.getElementById('val-agg').textContent = entry.genome.aggression.toFixed(2);
                document.getElementById('val-res').textContent = entry.genome.resilience.toFixed(2);
                document.getElementById('val-agi').textContent = entry.genome.agility.toFixed(2);
                document.getElementById('val-ele').textContent = entry.genome.element.toFixed(2);
                
                document.getElementById('val-gen').textContent = entry.gen;
                document.getElementById('val-lvl').textContent = entry.level;
                document.getElementById('val-evt').textContent = entry.event;
                document.getElementById('val-desc').textContent = entry.details || "No details available.";
                
                // Render 3D
                this.render3D(entry.genome);
                
                // Render 2D
                this.render2D(entry.genome);
            }
            
            render3D(genome) {
                if (this.creature) this.scene.remove(this.creature);
                
                const group = new THREE.Group();
                
                // --- REUSED GENERATION LOGIC FROM GAME ---
                
                // Base Geometry
                const geo = new THREE.SphereGeometry(0.6, 32, 32);
                const posAttribute = geo.attributes.position;
                const vertex = new THREE.Vector3();
                
                for (let i = 0; i < posAttribute.count; i++) {
                    vertex.fromBufferAttribute(posAttribute, i);
                    
                    // Resilience (Blockiness)
                    if (genome.resilience > 0.1) {
                        const cubeFactor = genome.resilience;
                        const maxDim = Math.max(Math.abs(vertex.x), Math.max(Math.abs(vertex.y), Math.abs(vertex.z)));
                        const sphereLen = vertex.length();
                        const cubeLen = 0.6 * (sphereLen / maxDim);
                        const targetLen = sphereLen * (1 - cubeFactor) + cubeLen * cubeFactor;
                        vertex.setLength(targetLen);
                    }
                    
                    // Aggression (Spikiness)
                    if (genome.aggression > 0.1) {
                        const noise = Math.sin(vertex.x * 10) * Math.sin(vertex.y * 10) * Math.sin(vertex.z * 10);
                        if (noise > 0.5) {
                            const spikeAmt = (noise - 0.5) * genome.aggression * 0.5;
                            vertex.add(vertex.clone().normalize().multiplyScalar(spikeAmt));
                        }
                    }
                    
                    posAttribute.setXYZ(i, vertex.x, vertex.y, vertex.z);
                }
                
                geo.computeVertexNormals();
                
                // Color
                const hue = Math.floor(genome.element * 360);
                const color = new THREE.Color(`hsl(${hue}, 70%, 50%)`);
                
                const body = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ 
                    color: color,
                    roughness: 0.7 - (genome.resilience * 0.5),
                    metalness: genome.resilience * 0.3
                }));
                group.add(body);
                
                // Limbs
                const limbCount = Math.floor(genome.agility * 6);
                if (limbCount > 0) {
                    for(let i=0; i<limbCount; i++) {
                        const angle = (i / limbCount) * Math.PI * 2;
                        let limbGeo;
                        if (THREE.CapsuleGeometry) {
                            limbGeo = new THREE.CapsuleGeometry(0.1, 0.4 + genome.agility * 0.5, 4, 8);
                        } else {
                            limbGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.4 + genome.agility * 0.5, 8);
                        }
                        const limb = new THREE.Mesh(limbGeo, new THREE.MeshStandardMaterial({ color: color }));
                        limb.position.set(Math.cos(angle)*0.5, 0, Math.sin(angle)*0.5);
                        limb.lookAt(0, 0, 0);
                        limb.rotateX(Math.PI/2);
                        group.add(limb);
                    }
                }
                
                // Eyes
                const eyeSize = 0.1 + (genome.agility * 0.05);
                const eyeCount = 1 + Math.floor(genome.element * 3);
                const eyeAngleSpan = Math.PI / 2;
                const startAngle = -eyeAngleSpan / 2;
                
                for(let i=0; i<eyeCount; i++) {
                    let angle = 0;
                    if (eyeCount > 1) {
                        angle = startAngle + (i / (eyeCount - 1)) * eyeAngleSpan;
                    }
                    const ex = Math.sin(angle) * 0.5;
                    const ez = Math.cos(angle) * 0.5;
                    
                    const eye = new THREE.Mesh(
                        new THREE.SphereGeometry(eyeSize, 8, 8),
                        new THREE.MeshBasicMaterial({ color: 0xffffff })
                    );
                    eye.position.set(ex, 0.2, ez);
                    
                    const pupil = new THREE.Mesh(
                        new THREE.SphereGeometry(eyeSize * 0.4, 8, 8),
                        new THREE.MeshBasicMaterial({ color: 0x000000 })
                    );
                    pupil.position.set(0, 0, eyeSize);
                    eye.add(pupil);
                    
                    group.add(eye);
                }
                
                this.creature = group;
                this.scene.add(this.creature);
            }
            
            render2D(genome) {
                const container = document.getElementById('overlay-2d');
                container.innerHTML = '';
                const cvs = document.createElement('canvas');
                cvs.width = 200; cvs.height = 200;
                container.appendChild(cvs);
                
                const ctx = cvs.getContext('2d');
                const hue = Math.floor(genome.element * 360);
                
                // Scale up for 200x200 (original was 150x150)
                ctx.scale(1.33, 1.33);
                
                // Limbs
                const limbCount = Math.floor(genome.agility * 6);
                ctx.fillStyle = `hsl(${hue}, 70%, 40%)`;
                for(let i=0; i<limbCount; i++) {
                    const angle = (i / limbCount) * Math.PI * 2;
                    const lx = 75 + Math.cos(angle) * 60;
                    const ly = 75 + Math.sin(angle) * 60;
                    
                    ctx.beginPath();
                    ctx.moveTo(75, 75);
                    ctx.lineTo(lx, ly);
                    ctx.lineWidth = 10;
                    ctx.strokeStyle = `hsl(${hue}, 70%, 40%)`;
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.arc(lx, ly, 8, 0, Math.PI*2);
                    ctx.fill();
                }
                
                // Body
                ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                if (genome.resilience > 0.6) {
                    ctx.fillRect(40, 40, 70, 70);
                } else {
                    ctx.beginPath();
                    ctx.arc(75, 75, 40, 0, Math.PI*2);
                    ctx.fill();
                }
                
                // Spikes
                if (genome.aggression > 0.4) {
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.moveTo(75, 20); ctx.lineTo(90, 50); ctx.lineTo(60, 50);
                    ctx.fill();
                }
                
                // Eyes
                const eyeCount = 1 + Math.floor(genome.element * 3);
                const eyeSpacing = 20;
                const startX = 75 - ((eyeCount - 1) * eyeSpacing) / 2;
                
                for(let i=0; i<eyeCount; i++) {
                    const ex = startX + i * eyeSpacing;
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(ex, 60, 8, 0, Math.PI*2);
                    ctx.fill();
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(ex + 2, 60, 3, 0, Math.PI*2);
                    ctx.fill();
                }
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                if (this.creature) {
                    this.creature.rotation.y += 0.01;
                }
                this.renderer.render(this.scene, this.camera);
            }
            
            onResize() {
                const container = document.getElementById('canvas-container');
                if (container && this.camera && this.renderer) {
                    this.camera.aspect = container.clientWidth / container.clientHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(container.clientWidth, container.clientHeight);
                }
            }
        }
        
        const app = new ViewerApp();
    </script>
</body>
</html>