<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Steam Deck Game Store</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0e1015;
            color: #ffffff;
            overflow-x: hidden;
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        /* Loading Screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0e1015;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.3s ease;
        }

        .loading-screen.hide {
            opacity: 0;
            pointer-events: none;
        }

        .loading-logo {
            font-size: 48px;
            margin-bottom: 30px;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
        }

        .loading-text {
            font-size: 18px;
            color: #8b8b8b;
            margin-bottom: 20px;
        }

        .loading-bar {
            width: 200px;
            height: 4px;
            background: #1a1d23;
            border-radius: 2px;
            overflow: hidden;
        }

        .loading-bar-fill {
            height: 100%;
            background: #4fc3f7;
            width: 0%;
            animation: loadingFill 2s ease-in-out infinite;
        }

        @keyframes loadingFill {
            0% { width: 0%; }
            50% { width: 80%; }
            100% { width: 100%; }
        }

        /* Main Container */
        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
            background: linear-gradient(135deg, #0e1015 0%, #1a1d23 100%);
        }

        /* Header */
        .header {
            padding: 20px 40px;
            background: rgba(26, 29, 35, 0.8);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 15px;
            font-size: 24px;
            font-weight: 600;
        }

        .logo-icon {
            font-size: 32px;
        }

        .nav-buttons {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .nav-button {
            padding: 8px 20px;
            background: rgba(79, 195, 247, 0.1);
            border: 1px solid rgba(79, 195, 247, 0.3);
            border-radius: 20px;
            color: #4fc3f7;
            font-size: 14px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .nav-button:hover,
        .nav-button.active {
            background: rgba(79, 195, 247, 0.2);
            border-color: #4fc3f7;
            transform: translateY(-2px);
        }

        /* Content Area */
        .content {
            flex: 1;
            overflow-y: auto;
            padding: 40px;
            position: relative;
        }

        /* Search */
        .search-container {
            max-width: 600px;
            margin: 0 auto 30px;
        }

        .search-box {
            width: 100%;
            padding: 15px 25px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 30px;
            color: #ffffff;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .search-box:focus {
            outline: none;
            border-color: #4fc3f7;
            background: rgba(255, 255, 255, 0.08);
        }

        /* Category Tabs */
        .category-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            overflow-x: auto;
            scrollbar-width: none;
        }

        .category-tabs::-webkit-scrollbar {
            display: none;
        }

        .category-tab {
            padding: 10px 25px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 25px;
            color: #8b8b8b;
            font-size: 14px;
            white-space: nowrap;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .category-tab:hover,
        .category-tab.active {
            background: rgba(79, 195, 247, 0.2);
            border-color: #4fc3f7;
            color: #4fc3f7;
        }

        /* Game Grid */
        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 25px;
            padding-bottom: 100px;
        }

        .game-card {
            background: rgba(26, 29, 35, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .game-card:hover {
            transform: translateY(-5px);
            border-color: #4fc3f7;
            box-shadow: 0 10px 30px rgba(79, 195, 247, 0.2);
        }

        .game-icon {
            font-size: 64px;
            margin-bottom: 15px;
            display: block;
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
        }

        .game-title {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 8px;
            color: #ffffff;
        }

        .game-description {
            font-size: 14px;
            color: #8b8b8b;
            line-height: 1.5;
            margin-bottom: 15px;
        }

        .game-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .game-size {
            font-size: 12px;
            color: #666;
        }

        .play-button {
            padding: 8px 20px;
            background: #4fc3f7;
            border: none;
            border-radius: 20px;
            color: #0e1015;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .play-button:hover {
            background: #29b6f6;
            transform: scale(1.05);
        }

        /* Modal Base */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(14, 16, 21, 0.95);
            backdrop-filter: blur(20px);
            display: none;
            z-index: 1000;
            overflow-y: auto;
        }

        .modal.show {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            max-width: 1000px;
            margin: 40px auto;
            padding: 40px;
            background: rgba(26, 29, 35, 0.9);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .close-modal {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 50%;
            color: #ffffff;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .close-modal:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: rotate(90deg);
        }

        /* Controls Footer */
        .controls-footer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(26, 29, 35, 0.95);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding: 15px 40px;
            display: flex;
            justify-content: center;
            gap: 40px;
            z-index: 100;
        }

        .control-hint {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: #8b8b8b;
        }

        .button-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            font-weight: 600;
            color: #ffffff;
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: rgba(26, 29, 35, 0.95);
            border: 1px solid rgba(79, 195, 247, 0.5);
            border-radius: 30px;
            padding: 15px 30px;
            color: #4fc3f7;
            font-size: 14px;
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 2000;
            pointer-events: none;
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        /* Emulator Container */
        .emulator-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #000;
            z-index: 2000;
            display: none;
        }

        .emulator-container.show {
            display: block;
        }

        .emulator-iframe {
            width: 100%;
            height: 100%;
            border: none;
        }

        .emulator-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 2001;
        }

        .emulator-button {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 50%;
            color: #ffffff;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .emulator-button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        /* No games message */
        .no-games {
            text-align: center;
            padding: 100px 20px;
            color: #666;
        }

        .no-games-icon {
            font-size: 64px;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .no-games-text {
            font-size: 18px;
        }

        /* Import/Export Buttons */
        .import-export-container {
            position: fixed;
            top: 80px;
            right: 40px;
            display: flex;
            gap: 10px;
            z-index: 99;
        }

        .import-btn, .export-btn {
            padding: 10px 20px;
            background: rgba(79, 195, 247, 0.1);
            border: 1px solid rgba(79, 195, 247, 0.3);
            border-radius: 20px;
            color: #4fc3f7;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .import-btn:hover, .export-btn:hover {
            background: rgba(79, 195, 247, 0.2);
            border-color: #4fc3f7;
            transform: translateY(-2px);
        }

        .file-input {
            display: none;
        }

        /* Game Creator Modal */
        .game-creator {
            max-width: 800px;
            margin: 40px auto;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            margin-bottom: 8px;
            color: #4fc3f7;
            font-size: 14px;
        }

        .form-input, .form-textarea, .form-select {
            width: 100%;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: #ffffff;
            font-size: 14px;
        }

        .form-textarea {
            min-height: 200px;
            font-family: 'Courier New', monospace;
        }

        .form-input:focus, .form-textarea:focus, .form-select:focus {
            outline: none;
            border-color: #4fc3f7;
            background: rgba(255, 255, 255, 0.08);
        }

        .create-game-btn {
            padding: 12px 30px;
            background: #4fc3f7;
            border: none;
            border-radius: 25px;
            color: #0e1015;
            font-weight: 600;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .create-game-btn:hover {
            background: #29b6f6;
            transform: scale(1.05);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .header {
                padding: 15px 20px;
            }

            .content {
                padding: 20px;
            }

            .games-grid {
                grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
                gap: 20px;
            }

            .controls-footer {
                padding: 10px 20px;
                gap: 20px;
            }

            .import-export-container {
                top: 70px;
                right: 20px;
            }
        }

        /* Focus styles for accessibility */
        *:focus {
            outline: 3px solid #4fc3f7;
            outline-offset: 2px;
        }

        button:focus,
        input:focus {
            outline: 3px solid #4fc3f7;
            outline-offset: 2px;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-logo">üéÆ</div>
        <div class="loading-text">Loading Game Store...</div>
        <div class="loading-bar">
            <div class="loading-bar-fill"></div>
        </div>
    </div>

    <!-- Main Container -->
    <div class="container">
        <!-- Header -->
        <header class="header">
            <div class="logo">
                <span class="logo-icon">üéÆ</span>
                <span>Steam Deck Game Store</span>
            </div>
            <div class="nav-buttons">
                <button class="nav-button active" data-view="store">Store</button>
                <button class="nav-button" data-view="library">My Library</button>
                <button class="nav-button" data-view="create">Create</button>
                <button class="nav-button" data-view="settings">Settings</button>
            </div>
        </header>

        <!-- Import/Export Controls -->
        <div class="import-export-container">
            <button class="import-btn" id="importBtn">üì• Import Game</button>
            <button class="export-btn" id="exportBtn">üì§ Export All</button>
            <input type="file" id="fileInput" class="file-input" accept=".json">
        </div>

        <!-- Content Area -->
        <main class="content" id="content">
            <!-- Search -->
            <div class="search-container">
                <input type="text" class="search-box" id="searchBox" placeholder="Search games...">
            </div>

            <!-- Category Tabs -->
            <div class="category-tabs" id="categoryTabs">
                <!-- Categories will be rendered here -->
            </div>

            <!-- Games Grid -->
            <div class="games-grid" id="gamesGrid">
                <!-- Games will be rendered here -->
            </div>
        </main>

        <!-- Controls Footer -->
        <footer class="controls-footer" id="controlsFooter">
            <!-- Control hints will be rendered here -->
        </footer>
    </div>

    <!-- Game Detail Modal -->
    <div class="modal" id="gameDetailModal">
        <div class="modal-content">
            <button class="close-modal" data-action="close-modal">‚úï</button>
            <div id="gameDetailContent">
                <!-- Game details will be rendered here -->
            </div>
        </div>
    </div>

    <!-- Emulator Container -->
    <div class="emulator-container" id="emulatorContainer">
        <div class="emulator-controls">
            <button class="emulator-button" data-action="close-emulator" title="Close Game">‚úï</button>
        </div>
        <iframe class="emulator-iframe" id="emulatorFrame" sandbox="allow-scripts allow-same-origin"></iframe>
    </div>

    <!-- Toast Notification -->
    <div class="toast" id="toast"></div>

    <script>
        'use strict';

        // ===== CONFIGURATION =====
        const AppConfig = {
            repository: {
                owner: 'kody-w',
                name: 'localFirstTools',
                branch: 'main'
            },
            categories: ['all', 'action', 'puzzle', 'arcade', 'strategy', 'adventure'],
            storage: {
                favorites: 'steamDeck_favorites_v1',
                installed: 'steamDeck_installed_v1',
                settings: 'steamDeck_settings_v1'
            },
            animation: {
                short: 200,
                medium: 300,
                long: 500
            }
        };

        // ===== DATA MODELS =====
        class Game {
            constructor(data) {
                this.id = data.id || '';
                this.name = data.name || 'Unknown Game';
                this.description = data.description || 'No description available';
                this.icon = data.icon || 'üéÆ';
                this.category = data.category || 'arcade';
                this.url = data.url || '';
                this.size = data.size || '0 KB';
                this.isEmulated = data.isEmulated || false;
                this.isLocal = data.isLocal || false;
                this.code = data.code || null;
                this.author = data.author || 'Unknown';
                this.version = data.version || '1.0';
            }

            toJSON() {
                return {
                    id: this.id,
                    name: this.name,
                    description: this.description,
                    icon: this.icon,
                    category: this.category,
                    author: this.author,
                    version: this.version,
                    code: this.code,
                    isLocal: true
                };
            }
        }

        // ===== STATE MANAGER =====
        class StateManager {
            constructor() {
                this.state = {
                    games: [],
                    filteredGames: [],
                    currentView: 'store',
                    currentCategory: 'all',
                    searchQuery: '',
                    favorites: new Set(),
                    installedGames: new Set(),
                    selectedIndex: 0,
                    inputMode: 'mouse'
                };
                this.subscribers = new Map();
            }

            setState(updates) {
                Object.assign(this.state, updates);
                this.notify(Object.keys(updates));
            }

            getState() {
                return { ...this.state };
            }

            subscribe(key, callback) {
                if (!this.subscribers.has(key)) {
                    this.subscribers.set(key, new Set());
                }
                this.subscribers.get(key).add(callback);
                return () => this.subscribers.get(key).delete(callback);
            }

            notify(keys) {
                keys.forEach(key => {
                    const callbacks = this.subscribers.get(key);
                    if (callbacks) {
                        callbacks.forEach(callback => callback(this.state[key]));
                    }
                });
            }
        }

        // ===== STORAGE SERVICE =====
        class StorageService {
            static save(key, data) {
                try {
                    localStorage.setItem(key, JSON.stringify(data));
                    return true;
                } catch (error) {
                    console.error('Storage save error:', error);
                    return false;
                }
            }

            static load(key, defaultValue = null) {
                try {
                    const data = localStorage.getItem(key);
                    return data ? JSON.parse(data) : defaultValue;
                } catch (error) {
                    console.error('Storage load error:', error);
                    return defaultValue;
                }
            }

            static remove(key) {
                try {
                    localStorage.removeItem(key);
                    return true;
                } catch (error) {
                    console.error('Storage remove error:', error);
                    return false;
                }
            }

            static saveLocalGames(games) {
                const localGames = games.filter(g => g.isLocal).map(g => g.toJSON());
                return StorageService.save('steamDeck_localGames_v1', localGames);
            }

            static loadLocalGames() {
                const saved = StorageService.load('steamDeck_localGames_v1', []);
                return saved.map(data => new Game(data));
            }
        }

        // ===== GITHUB SERVICE =====
        class GitHubService {
            static async fetchGames() {
                const { owner, name, branch } = AppConfig.repository;
                const apiUrl = `https://api.github.com/repos/${owner}/${name}/contents?ref=${branch}`;
                
                try {
                    const response = await fetch(apiUrl);
                    if (!response.ok) {
                        throw new Error(`GitHub API error: ${response.status}`);
                    }
                    
                    const contents = await response.json();
                    
                    // Filter for HTML game files
                    const gameFiles = contents.filter(item => 
                        item.type === 'file' && 
                        item.name.endsWith('.html') &&
                        !item.name.includes('index') &&
                        !item.name.includes('gallery') &&
                        !item.name.includes('template') &&
                        !item.name.includes('steamdeck')
                    );
                    
                    return gameFiles.map(file => {
                        const baseName = file.name.replace('.html', '');
                        const gameInfo = GitHubService.getGameInfo(baseName);
                        
                        return new Game({
                            id: baseName,
                            name: gameInfo.name || GitHubService.formatName(baseName),
                            description: gameInfo.description,
                            icon: gameInfo.icon,
                            category: gameInfo.category,
                            url: file.download_url || `https://raw.githubusercontent.com/${owner}/${name}/${branch}/${file.name}`,
                            size: GitHubService.formatFileSize(file.size)
                        });
                    });
                } catch (error) {
                    console.error('Error fetching games:', error);
                    return GitHubService.getFallbackGames();
                }
            }

            static getGameInfo(filename) {
                const gameDatabase = {
                    'snake': { 
                        icon: 'üêç', 
                        category: 'arcade', 
                        description: 'The classic snake game - eat food and grow longer!',
                        name: 'Snake Classic'
                    },
                    'tetris': { 
                        icon: 'üß±', 
                        category: 'puzzle', 
                        description: 'Stack blocks and clear lines in this timeless puzzle game',
                        name: 'Tetris'
                    },
                    'breakout': { 
                        icon: 'üéØ', 
                        category: 'arcade', 
                        description: 'Break all the bricks with your paddle and ball',
                        name: 'Breakout'
                    },
                    'pong': { 
                        icon: 'üèì', 
                        category: 'arcade', 
                        description: 'The original tennis-like arcade game',
                        name: 'Pong'
                    },
                    'space-invaders': { 
                        icon: 'üëæ', 
                        category: 'action', 
                        description: 'Defend Earth from waves of alien invaders',
                        name: 'Space Invaders'
                    },
                    'flappy': { 
                        icon: 'üê¶', 
                        category: 'arcade', 
                        description: 'Navigate through pipes in this addictive game',
                        name: 'Flappy Bird Clone'
                    },
                    'asteroids': { 
                        icon: '‚òÑÔ∏è', 
                        category: 'action', 
                        description: 'Destroy asteroids and survive in space',
                        name: 'Asteroids'
                    },
                    'pacman': { 
                        icon: 'üëª', 
                        category: 'arcade', 
                        description: 'Eat dots and avoid ghosts in the maze',
                        name: 'Pac-Man Clone'
                    }
                };
                
                const lowerFilename = filename.toLowerCase();
                for (const [key, info] of Object.entries(gameDatabase)) {
                    if (lowerFilename.includes(key)) {
                        return info;
                    }
                }
                
                return {
                    icon: 'üéÆ',
                    category: 'arcade',
                    description: 'A fun game to play on your Steam Deck',
                    name: null
                };
            }

            static formatName(baseName) {
                return baseName
                    .replace(/[-_]/g, ' ')
                    .replace(/\b\w/g, l => l.toUpperCase());
            }

            static formatFileSize(bytes) {
                if (bytes < 1024) return bytes + ' B';
                if (bytes < 1024 * 1024) return Math.round(bytes / 1024) + ' KB';
                return Math.round(bytes / (1024 * 1024)) + ' MB';
            }

            static getFallbackGames() {
                return [];
            }
        }

        // ===== LOCAL GAME SERVICE =====
        class LocalGameService {
            static getBuiltInTetris() {
                return new Game({
                    id: 'built-in-tetris',
                    name: 'Tetris',
                    description: 'The classic block-stacking puzzle game',
                    icon: 'üß±',
                    category: 'puzzle',
                    author: 'Built-in',
                    version: '1.0',
                    isLocal: true,
                    size: '8 KB',
                    code: `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #111;
            color: white;
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        #game {
            text-align: center;
        }
        canvas {
            border: 2px solid #fff;
            background: #000;
        }
        #score {
            font-size: 24px;
            margin: 10px 0;
        }
        #controls {
            margin-top: 20px;
            font-size: 14px;
            color: #888;
        }
    </style>
</head>
<body>
    <div id="game">
        <h1>Tetris</h1>
        <div id="score">Score: <span id="scoreValue">0</span></div>
        <canvas id="canvas"></canvas>
        <div id="controls">
            Use Arrow Keys: ‚Üê ‚Üí to move, ‚Üì to drop, ‚Üë to rotate<br>
            Press SPACE to pause
        </div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 30;
        
        canvas.width = COLS * BLOCK_SIZE;
        canvas.height = ROWS * BLOCK_SIZE;
        
        let board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
        let score = 0;
        let gameRunning = true;
        
        const colors = [
            null,
            '#FF0D72', '#0DC2FF', '#0DFF72',
            '#F538FF', '#FF8E0D', '#FFE138', '#3877FF'
        ];
        
        const pieces = [
            [[1,1,1,1]],
            [[2,0,0],[2,2,2]],
            [[0,0,3],[3,3,3]],
            [[4,4],[4,4]],
            [[0,5,5],[5,5,0]],
            [[0,6,0],[6,6,6]],
            [[7,7,0],[0,7,7]]
        ];
        
        class Piece {
            constructor() {
                this.type = Math.floor(Math.random() * pieces.length);
                this.shape = pieces[this.type];
                this.color = this.type + 1;
                this.x = Math.floor(COLS / 2) - Math.floor(this.shape[0].length / 2);
                this.y = 0;
            }
            
            rotate() {
                const rotated = this.shape[0].map((_, i) =>
                    this.shape.map(row => row[i]).reverse()
                );
                if (this.valid(this.x, this.y, rotated)) {
                    this.shape = rotated;
                }
            }
            
            valid(x, y, shape = this.shape) {
                for (let row = 0; row < shape.length; row++) {
                    for (let col = 0; col < shape[row].length; col++) {
                        if (shape[row][col]) {
                            const newX = x + col;
                            const newY = y + row;
                            if (newX < 0 || newX >= COLS || newY >= ROWS) {
                                return false;
                            }
                            if (newY >= 0 && board[newY][newX]) {
                                return false;
                            }
                        }
                    }
                }
                return true;
            }
            
            lock() {
                for (let row = 0; row < this.shape.length; row++) {
                    for (let col = 0; col < this.shape[row].length; col++) {
                        if (this.shape[row][col]) {
                            if (this.y + row < 0) {
                                gameRunning = false;
                                alert('Game Over! Score: ' + score);
                                resetGame();
                                return;
                            }
                            board[this.y + row][this.x + col] = this.color;
                        }
                    }
                }
                clearLines();
            }
            
            move(dir) {
                const newX = this.x + dir;
                if (this.valid(newX, this.y)) {
                    this.x = newX;
                    return true;
                }
                return false;
            }
            
            drop() {
                if (this.valid(this.x, this.y + 1)) {
                    this.y++;
                    return true;
                }
                this.lock();
                return false;
            }
        }
        
        let currentPiece = new Piece();
        let dropCounter = 0;
        let lastTime = 0;
        
        function clearLines() {
            let linesCleared = 0;
            for (let row = ROWS - 1; row >= 0; row--) {
                if (board[row].every(cell => cell > 0)) {
                    board.splice(row, 1);
                    board.unshift(Array(COLS).fill(0));
                    linesCleared++;
                    row++;
                }
            }
            if (linesCleared > 0) {
                score += linesCleared * 100 * linesCleared;
                document.getElementById('scoreValue').textContent = score;
            }
        }
        
        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw board
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    if (board[row][col]) {
                        ctx.fillStyle = colors[board[row][col]];
                        ctx.fillRect(col * BLOCK_SIZE, row * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
                    }
                }
            }
            
            // Draw current piece
            for (let row = 0; row < currentPiece.shape.length; row++) {
                for (let col = 0; col < currentPiece.shape[row].length; col++) {
                    if (currentPiece.shape[row][col]) {
                        ctx.fillStyle = colors[currentPiece.color];
                        ctx.fillRect(
                            (currentPiece.x + col) * BLOCK_SIZE,
                            (currentPiece.y + row) * BLOCK_SIZE,
                            BLOCK_SIZE - 1, BLOCK_SIZE - 1
                        );
                    }
                }
            }
        }
        
        function update(time = 0) {
            if (!gameRunning) return;
            
            const deltaTime = time - lastTime;
            lastTime = time;
            dropCounter += deltaTime;
            
            if (dropCounter > 1000) {
                if (!currentPiece.drop()) {
                    currentPiece = new Piece();
                }
                dropCounter = 0;
            }
            
            draw();
            requestAnimationFrame(update);
        }
        
        function resetGame() {
            board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
            score = 0;
            document.getElementById('scoreValue').textContent = score;
            currentPiece = new Piece();
            gameRunning = true;
            update();
        }
        
        document.addEventListener('keydown', e => {
            if (!gameRunning && e.key !== ' ') return;
            
            switch(e.key) {
                case 'ArrowLeft':
                    currentPiece.move(-1);
                    break;
                case 'ArrowRight':
                    currentPiece.move(1);
                    break;
                case 'ArrowDown':
                    currentPiece.drop();
                    dropCounter = 0;
                    break;
                case 'ArrowUp':
                    currentPiece.rotate();
                    break;
                case ' ':
                    gameRunning = !gameRunning;
                    if (gameRunning) update();
                    break;
            }
        });
        
        update();
    <\/script>
</body>
</html>`
                });
            }

            static createGameFromJSON(json) {
                try {
                    const data = typeof json === 'string' ? JSON.parse(json) : json;
                    
                    // Validate required fields
                    if (!data.name || !data.code) {
                        throw new Error('Invalid game file: missing name or code');
                    }
                    
                    // Generate ID if not present
                    if (!data.id) {
                        data.id = 'local-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
                    }
                    
                    data.isLocal = true;
                    return new Game(data);
                } catch (error) {
                    console.error('Error creating game from JSON:', error);
                    throw error;
                }
            }

            static exportGame(game) {
                const gameData = game.toJSON();
                const blob = new Blob([JSON.stringify(gameData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `${game.id}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            static exportAllGames(games) {
                const localGames = games.filter(g => g.isLocal);
                if (localGames.length === 0) {
                    UIRenderer.showToast('No local games to export');
                    return;
                }
                
                const exportData = {
                    version: '1.0',
                    exported: new Date().toISOString(),
                    games: localGames.map(g => g.toJSON())
                };
                
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `steam-deck-games-${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                UIRenderer.showToast(`Exported ${localGames.length} games`);
            }
        }

        // ===== UI RENDERER =====
        /**
         * UIRenderer - Static class for rendering all UI components
         * Uses modern DOM manipulation with createElement() - no innerHTML for dynamic content
         */
        class UIRenderer {
            /**
             * Render category tabs
             * @param {Array<string>} categories - Array of category names
             * @param {string} activeCategory - Currently active category
             */
            static renderCategories(categories, activeCategory) {
                const container = document.getElementById('categoryTabs');

                // Clear existing content
                while (container.firstChild) {
                    container.removeChild(container.firstChild);
                }

                // Create fragment for better performance
                const fragment = document.createDocumentFragment();

                categories.forEach(category => {
                    const tab = document.createElement('button');
                    tab.className = 'category-tab';
                    tab.dataset.category = category;
                    tab.textContent = category.charAt(0).toUpperCase() + category.slice(1);
                    tab.setAttribute('aria-label', `Filter by ${category}`);
                    tab.setAttribute('role', 'tab');

                    if (category === activeCategory) {
                        tab.classList.add('active');
                        tab.setAttribute('aria-selected', 'true');
                    } else {
                        tab.setAttribute('aria-selected', 'false');
                    }

                    fragment.appendChild(tab);
                });

                container.appendChild(fragment);
            }

            /**
             * Render game cards in grid
             * @param {Array<Game>} games - Array of game objects
             * @param {Set} favorites - Set of favorited game IDs
             * @param {Set} installed - Set of installed game IDs
             */
            static renderGames(games, favorites, installed) {
                const grid = document.getElementById('gamesGrid');

                // Clear existing content
                while (grid.firstChild) {
                    grid.removeChild(grid.firstChild);
                }

                // Handle empty state
                if (games.length === 0) {
                    const noGamesContainer = document.createElement('div');
                    noGamesContainer.className = 'no-games';

                    const icon = document.createElement('div');
                    icon.className = 'no-games-icon';
                    icon.textContent = 'üéÆ';
                    icon.setAttribute('aria-hidden', 'true');

                    const text = document.createElement('div');
                    text.className = 'no-games-text';
                    text.textContent = 'No games found';

                    noGamesContainer.appendChild(icon);
                    noGamesContainer.appendChild(text);
                    grid.appendChild(noGamesContainer);
                    return;
                }

                // Create fragment for better performance
                const fragment = document.createDocumentFragment();

                games.forEach(game => {
                    const card = UIRenderer._createGameCard(game, favorites, installed);
                    fragment.appendChild(card);
                });

                grid.appendChild(fragment);
            }

            /**
             * Create a single game card element
             * @private
             */
            static _createGameCard(game, favorites, installed) {
                const card = document.createElement('div');
                card.className = 'game-card';
                card.dataset.gameId = game.id;
                card.setAttribute('role', 'article');
                card.setAttribute('aria-label', `${game.name} game card`);
                card.tabIndex = 0;

                // Game icon
                const icon = document.createElement('div');
                icon.className = 'game-icon';
                icon.textContent = game.icon;
                icon.setAttribute('aria-hidden', 'true');

                // Game title
                const title = document.createElement('h3');
                title.className = 'game-title';
                title.textContent = game.name;

                // Game description
                const description = document.createElement('p');
                description.className = 'game-description';
                description.textContent = game.description;

                // Meta section (size + play button)
                const meta = document.createElement('div');
                meta.className = 'game-meta';

                // Size indicator
                const size = document.createElement('span');
                size.className = 'game-size';
                size.textContent = game.size;
                size.setAttribute('aria-label', `Game size: ${game.size}`);

                // Play/Install button
                const playButton = document.createElement('button');
                playButton.className = 'play-button';
                playButton.dataset.action = 'launch';
                playButton.dataset.gameId = game.id;

                const isInstalled = installed.has(game.id);
                playButton.textContent = isInstalled ? 'Play' : 'Install';
                playButton.setAttribute('aria-label', `${isInstalled ? 'Play' : 'Install'} ${game.name}`);

                // Stop propagation on play button so card click doesn't trigger
                playButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                });

                // Assemble meta section
                meta.appendChild(size);
                meta.appendChild(playButton);

                // Assemble card
                card.appendChild(icon);
                card.appendChild(title);
                card.appendChild(description);
                card.appendChild(meta);

                return card;
            }

            /**
             * Render game detail view in modal
             * @param {Game} game - Game object to display
             * @param {boolean} isFavorite - Whether game is favorited
             */
            static renderGameDetail(game, isFavorite) {
                const content = document.getElementById('gameDetailContent');

                // Clear existing content
                while (content.firstChild) {
                    content.removeChild(content.firstChild);
                }

                // Header section with icon and info
                const header = document.createElement('div');
                header.style.display = 'flex';
                header.style.gap = '30px';
                header.style.marginBottom = '30px';
                header.style.flexWrap = 'wrap';

                // Large game icon
                const icon = document.createElement('div');
                icon.style.fontSize = '120px';
                icon.textContent = game.icon;
                icon.setAttribute('aria-hidden', 'true');

                // Info section
                const info = document.createElement('div');
                info.style.flex = '1';
                info.style.minWidth = '300px';

                // Game title
                const title = document.createElement('h1');
                title.style.fontSize = '36px';
                title.style.marginBottom = '10px';
                title.textContent = game.name;

                // Description
                const desc = document.createElement('p');
                desc.style.fontSize = '18px';
                desc.style.color = '#8b8b8b';
                desc.style.lineHeight = '1.6';
                desc.style.marginBottom = '20px';
                desc.textContent = game.description;

                // Meta information (category, size, etc.)
                const metaInfo = document.createElement('div');
                metaInfo.style.color = '#8b8b8b';
                metaInfo.style.fontSize = '14px';

                const categorySpan = document.createElement('span');
                categorySpan.textContent = `Category: ${game.category}`;

                const separator = document.createTextNode(' | ');

                const sizeSpan = document.createElement('span');
                sizeSpan.textContent = `Size: ${game.size}`;

                metaInfo.appendChild(categorySpan);
                metaInfo.appendChild(separator);
                metaInfo.appendChild(sizeSpan);

                // Additional metadata if available
                if (game.author && game.author !== 'Unknown') {
                    const authorSeparator = document.createTextNode(' | ');
                    const authorSpan = document.createElement('span');
                    authorSpan.textContent = `Author: ${game.author}`;
                    metaInfo.appendChild(authorSeparator);
                    metaInfo.appendChild(authorSpan);
                }

                if (game.version) {
                    const versionSeparator = document.createTextNode(' | ');
                    const versionSpan = document.createElement('span');
                    versionSpan.textContent = `Version: ${game.version}`;
                    metaInfo.appendChild(versionSeparator);
                    metaInfo.appendChild(versionSpan);
                }

                // Assemble info section
                info.appendChild(title);
                info.appendChild(desc);
                info.appendChild(metaInfo);

                // Assemble header
                header.appendChild(icon);
                header.appendChild(info);

                // Action buttons section
                const actions = document.createElement('div');
                actions.style.display = 'flex';
                actions.style.gap = '15px';
                actions.style.marginTop = '30px';
                actions.style.flexWrap = 'wrap';

                // Play button
                const playBtn = document.createElement('button');
                playBtn.className = 'play-button';
                playBtn.style.padding = '12px 30px';
                playBtn.style.fontSize = '16px';
                playBtn.dataset.action = 'launch-detail';
                playBtn.dataset.gameId = game.id;
                playBtn.textContent = 'Play Now';
                playBtn.setAttribute('aria-label', `Play ${game.name}`);

                // Favorite toggle button
                const favBtn = document.createElement('button');
                favBtn.className = 'nav-button';
                favBtn.style.padding = '12px 30px';
                favBtn.style.fontSize = '16px';
                favBtn.dataset.action = 'toggle-favorite';
                favBtn.dataset.gameId = game.id;
                favBtn.textContent = isFavorite ? '‚òÖ Favorited' : '‚òÜ Add to Favorites';
                favBtn.setAttribute('aria-label', isFavorite ? `Remove ${game.name} from favorites` : `Add ${game.name} to favorites`);
                favBtn.setAttribute('aria-pressed', isFavorite ? 'true' : 'false');

                // Assemble actions
                actions.appendChild(playBtn);
                actions.appendChild(favBtn);

                // Assemble final content
                content.appendChild(header);
                content.appendChild(actions);
            }

            /**
             * Update controls footer based on input mode
             * @param {string} inputMode - Current input mode (gamepad, keyboard, mouse, touch)
             */
            static updateControlsFooter(inputMode) {
                const footer = document.getElementById('controlsFooter');

                // Clear existing content
                while (footer.firstChild) {
                    footer.removeChild(footer.firstChild);
                }

                // Define control hints for each input mode
                const controlSchemes = {
                    'gamepad': [
                        { icon: 'A', text: 'Select' },
                        { icon: 'B', text: 'Back' },
                        { icon: 'X', text: 'Details' },
                        { icon: 'Y', text: 'Favorite' }
                    ],
                    'keyboard': [
                        { icon: '‚Üµ', text: 'Select' },
                        { icon: 'ESC', text: 'Back' },
                        { icon: '‚Üë‚Üì', text: 'Navigate' },
                        { icon: 'F', text: 'Favorite' }
                    ],
                    'touch': [
                        { icon: 'üëÜ', text: 'Tap to Select' },
                        { icon: 'üì±', text: 'Swipe to Scroll' }
                    ],
                    'mouse': [
                        { icon: 'üñ±Ô∏è', text: 'Click to Select' },
                        { icon: '‚Üª', text: 'Scroll to Browse' }
                    ]
                };

                // Get hints for current mode, fallback to mouse
                const hints = controlSchemes[inputMode] || controlSchemes.mouse;

                // Create fragment for better performance
                const fragment = document.createDocumentFragment();

                hints.forEach(hint => {
                    const hintDiv = document.createElement('div');
                    hintDiv.className = 'control-hint';

                    const iconSpan = document.createElement('span');
                    iconSpan.className = 'button-icon';
                    iconSpan.textContent = hint.icon;
                    iconSpan.setAttribute('aria-hidden', 'true');

                    const textSpan = document.createElement('span');
                    textSpan.textContent = hint.text;

                    hintDiv.appendChild(iconSpan);
                    hintDiv.appendChild(textSpan);
                    fragment.appendChild(hintDiv);
                });

                footer.appendChild(fragment);
            }

            /**
             * Show toast notification
             * @param {string} message - Message to display
             * @param {number} duration - Duration in milliseconds (default: 3000)
             */
            static showToast(message, duration = 3000) {
                const toast = document.getElementById('toast');

                // Clear existing content and set new message
                while (toast.firstChild) {
                    toast.removeChild(toast.firstChild);
                }

                const messageText = document.createTextNode(message);
                toast.appendChild(messageText);

                toast.setAttribute('role', 'status');
                toast.setAttribute('aria-live', 'polite');

                // Show toast
                toast.classList.add('show');

                // Auto-hide after duration
                setTimeout(() => {
                    toast.classList.remove('show');
                }, duration);
            }

            /**
             * Clear all toast notifications
             */
            static hideToast() {
                const toast = document.getElementById('toast');
                toast.classList.remove('show');
            }
        }

        // ===== INPUT MANAGER =====
        class InputManager {
            constructor(stateManager) {
                this.stateManager = stateManager;
                this.lastNavigationTime = 0;
                this.navigationThrottle = 200;
                this.setupEventListeners();
                this.detectInputMode();
            }

            setupEventListeners() {
                // Keyboard input
                document.addEventListener('keydown', (e) => this.handleKeyboard(e));
                
                // Mouse input
                document.addEventListener('mousemove', () => {
                    if (this.stateManager.state.inputMode !== 'mouse') {
                        this.setInputMode('mouse');
                    }
                });
                
                // Touch input
                document.addEventListener('touchstart', () => {
                    if (this.stateManager.state.inputMode !== 'touch') {
                        this.setInputMode('touch');
                    }
                }, { passive: true });
                
                // Gamepad support
                window.addEventListener('gamepadconnected', (e) => {
                    console.log('Gamepad connected:', e.gamepad.id);
                    UIRenderer.showToast('Gamepad connected');
                    this.setInputMode('gamepad');
                    this.pollGamepad();
                });
                
                window.addEventListener('gamepaddisconnected', () => {
                    console.log('Gamepad disconnected');
                    UIRenderer.showToast('Gamepad disconnected');
                    this.setInputMode('mouse');
                });
            }

            detectInputMode() {
                const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
                this.setInputMode(isTouchDevice ? 'touch' : 'mouse');
            }

            setInputMode(mode) {
                this.stateManager.setState({ inputMode: mode });
                UIRenderer.updateControlsFooter(mode);
            }

            handleKeyboard(e) {
                if (e.target.tagName === 'INPUT') return;
                
                if (this.stateManager.state.inputMode !== 'keyboard') {
                    this.setInputMode('keyboard');
                }
                
                switch(e.key) {
                    case 'ArrowUp':
                    case 'ArrowDown':
                    case 'ArrowLeft':
                    case 'ArrowRight':
                        e.preventDefault();
                        this.navigate(e.key.replace('Arrow', '').toLowerCase());
                        break;
                    case 'Enter':
                    case ' ':
                        e.preventDefault();
                        this.selectCurrent();
                        break;
                    case 'Escape':
                        e.preventDefault();
                        this.goBack();
                        break;
                }
            }

            pollGamepad() {
                const gamepads = navigator.getGamepads();
                const gamepad = gamepads[0];
                
                if (gamepad) {
                    // Handle gamepad input here
                    // This is simplified - you'd implement full gamepad support
                    
                    requestAnimationFrame(() => this.pollGamepad());
                }
            }

            navigate(direction) {
                const now = Date.now();
                if (now - this.lastNavigationTime < this.navigationThrottle) return;
                this.lastNavigationTime = now;
                
                // Navigation logic here
                console.log('Navigate:', direction);
            }

            selectCurrent() {
                // Select current focused item
                const focused = document.querySelector('.game-card:focus, .game-card.selected');
                if (focused) {
                    focused.click();
                }
            }

            goBack() {
                // Close modals or go back
                const modal = document.querySelector('.modal.show');
                if (modal) {
                    modal.classList.remove('show');
                }
            }
        }

        // ===== GAME MANAGER =====
        class GameManager {
            constructor(stateManager) {
                this.stateManager = stateManager;
                this.setupEventListeners();
            }

            setupEventListeners() {
                // Event delegation for all clicks
                document.addEventListener('click', (e) => {
                    const action = e.target.dataset.action;
                    if (!action) return;
                    
                    const gameId = e.target.dataset.gameId;
                    
                    switch(action) {
                        case 'launch':
                        case 'launch-detail':
                            this.launchGame(gameId);
                            break;
                        case 'toggle-favorite':
                            this.toggleFavorite(gameId);
                            break;
                        case 'close-modal':
                            this.closeModal();
                            break;
                        case 'close-emulator':
                            this.closeEmulator();
                            break;
                    }
                });
                
                // Game card clicks for details
                document.addEventListener('click', (e) => {
                    const card = e.target.closest('.game-card');
                    if (card && !e.target.closest('.play-button')) {
                        this.showGameDetails(card.dataset.gameId);
                    }
                });
            }

            async launchGame(gameId) {
                const state = this.stateManager.getState();
                const game = state.games.find(g => g.id === gameId);
                if (!game) return;
                
                // Mark as installed
                const installed = new Set(state.installedGames);
                installed.add(gameId);
                this.stateManager.setState({ installedGames: installed });
                StorageService.save(AppConfig.storage.installed, Array.from(installed));
                
                // Launch in iframe
                const emulatorContainer = document.getElementById('emulatorContainer');
                const emulatorFrame = document.getElementById('emulatorFrame');
                
                // For local games, create a data URL from the code
                if (game.isLocal && game.code) {
                    const blob = new Blob([game.code], { type: 'text/html' });
                    emulatorFrame.src = URL.createObjectURL(blob);
                } else {
                    emulatorFrame.src = game.url;
                }
                
                emulatorContainer.classList.add('show');
                
                UIRenderer.showToast(`Launching ${game.name}...`);
                this.closeModal();
            }

            closeEmulator() {
                const emulatorContainer = document.getElementById('emulatorContainer');
                const emulatorFrame = document.getElementById('emulatorFrame');
                
                emulatorFrame.src = '';
                emulatorContainer.classList.remove('show');
            }

            showGameDetails(gameId) {
                const state = this.stateManager.getState();
                const game = state.games.find(g => g.id === gameId);
                if (!game) return;
                
                const isFavorite = state.favorites.has(gameId);
                UIRenderer.renderGameDetail(game, isFavorite);
                
                const modal = document.getElementById('gameDetailModal');
                modal.classList.add('show');
            }

            closeModal() {
                const modals = document.querySelectorAll('.modal');
                modals.forEach(modal => modal.classList.remove('show'));
            }

            toggleFavorite(gameId) {
                const state = this.stateManager.getState();
                const favorites = new Set(state.favorites);
                
                if (favorites.has(gameId)) {
                    favorites.delete(gameId);
                    UIRenderer.showToast('Removed from favorites');
                } else {
                    favorites.add(gameId);
                    UIRenderer.showToast('Added to favorites');
                }
                
                this.stateManager.setState({ favorites });
                StorageService.save(AppConfig.storage.favorites, Array.from(favorites));
                
                // Update detail view if open
                const detailContent = document.getElementById('gameDetailContent');
                if (detailContent.innerHTML) {
                    const game = state.games.find(g => g.id === gameId);
                    if (game) {
                        UIRenderer.renderGameDetail(game, favorites.has(gameId));
                    }
                }
            }

            filterGames() {
                const state = this.stateManager.getState();
                let filtered = [...state.games];
                
                // Filter by view
                if (state.currentView === 'library') {
                    filtered = filtered.filter(game => state.installedGames.has(game.id));
                }
                
                // Filter by category
                if (state.currentCategory !== 'all') {
                    filtered = filtered.filter(game => game.category === state.currentCategory);
                }
                
                // Filter by search
                if (state.searchQuery) {
                    const query = state.searchQuery.toLowerCase();
                    filtered = filtered.filter(game => 
                        game.name.toLowerCase().includes(query) ||
                        game.description.toLowerCase().includes(query)
                    );
                }
                
                this.stateManager.setState({ filteredGames: filtered });
                UIRenderer.renderGames(filtered, state.favorites, state.installedGames);
            }
        }

        // ===== MAIN APPLICATION =====
        class SteamDeckGameStore {
            constructor() {
                this.stateManager = new StateManager();
                this.inputManager = new InputManager(this.stateManager);
                this.gameManager = new GameManager(this.stateManager);
                
                this.init();
            }

            async init() {
                // Load saved data
                this.loadSavedData();
                
                // Setup UI event listeners
                this.setupUIListeners();
                
                // Setup import/export
                this.setupImportExport();
                
                // Subscribe to state changes
                this.subscribeToStateChanges();
                
                // Load games
                await this.loadGames();
                
                // Hide loading screen
                setTimeout(() => {
                    document.getElementById('loadingScreen').classList.add('hide');
                }, 500);
            }

            loadSavedData() {
                const favorites = StorageService.load(AppConfig.storage.favorites, []);
                const installed = StorageService.load(AppConfig.storage.installed, []);
                
                this.stateManager.setState({
                    favorites: new Set(favorites),
                    installedGames: new Set(installed)
                });
            }

            setupUIListeners() {
                // Navigation buttons
                document.querySelectorAll('.nav-button').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const view = btn.dataset.view;
                        
                        // Update active state
                        document.querySelectorAll('.nav-button').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        
                        // Update state and re-filter
                        this.stateManager.setState({ currentView: view });
                        
                        if (view === 'settings') {
                            this.showSettings();
                        } else if (view === 'create') {
                            this.showCreateGame();
                        } else {
                            this.gameManager.filterGames();
                        }
                    });
                });
                
                // Category tabs
                document.addEventListener('click', (e) => {
                    if (e.target.classList.contains('category-tab')) {
                        const category = e.target.dataset.category;
                        
                        // Update active state
                        document.querySelectorAll('.category-tab').forEach(tab => tab.classList.remove('active'));
                        e.target.classList.add('active');
                        
                        // Update state and re-filter
                        this.stateManager.setState({ currentCategory: category });
                        this.gameManager.filterGames();
                    }
                });
                
                // Search box
                let searchTimeout;
                document.getElementById('searchBox').addEventListener('input', (e) => {
                    clearTimeout(searchTimeout);
                    searchTimeout = setTimeout(() => {
                        this.stateManager.setState({ searchQuery: e.target.value });
                        this.gameManager.filterGames();
                    }, 300);
                });
            }

            subscribeToStateChanges() {
                // Re-render when filtered games change
                this.stateManager.subscribe('filteredGames', (games) => {
                    const state = this.stateManager.getState();
                    UIRenderer.renderGames(games, state.favorites, state.installedGames);
                });
            }

            async loadGames() {
                try {
                    // Load GitHub games
                    const githubGames = await GitHubService.fetchGames();
                    
                    // Load local games from storage
                    const localGames = StorageService.loadLocalGames();
                    
                    // Add built-in Tetris if not already present
                    const hasTetris = localGames.some(g => g.id === 'built-in-tetris');
                    if (!hasTetris) {
                        const tetris = LocalGameService.getBuiltInTetris();
                        localGames.push(tetris);
                        StorageService.saveLocalGames([tetris]);
                    }
                    
                    // Combine all games
                    const allGames = [...githubGames, ...localGames];
                    
                    this.stateManager.setState({ 
                        games: allGames, 
                        filteredGames: allGames 
                    });
                    
                    // Render categories
                    UIRenderer.renderCategories(AppConfig.categories, 'all');
                    
                    // Initial render
                    const state = this.stateManager.getState();
                    UIRenderer.renderGames(allGames, state.favorites, state.installedGames);
                } catch (error) {
                    console.error('Failed to load games:', error);
                    
                    // Fallback to local games only
                    const localGames = StorageService.loadLocalGames();
                    const hasTetris = localGames.some(g => g.id === 'built-in-tetris');
                    if (!hasTetris) {
                        localGames.push(LocalGameService.getBuiltInTetris());
                    }
                    
                    this.stateManager.setState({ 
                        games: localGames, 
                        filteredGames: localGames 
                    });
                    
                    UIRenderer.renderCategories(AppConfig.categories, 'all');
                    const state = this.stateManager.getState();
                    UIRenderer.renderGames(localGames, state.favorites, state.installedGames);
                    UIRenderer.showToast('Offline mode - showing local games only');
                }
            }

            setupImportExport() {
                // Import button
                document.getElementById('importBtn').addEventListener('click', () => {
                    document.getElementById('fileInput').click();
                });
                
                // File input handler
                document.getElementById('fileInput').addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    try {
                        const text = await file.text();
                        const data = JSON.parse(text);
                        
                        let imported = 0;
                        const state = this.stateManager.getState();
                        const games = [...state.games];
                        
                        // Check if it's a single game or multiple games
                        if (data.games && Array.isArray(data.games)) {
                            // Multiple games export
                            for (const gameData of data.games) {
                                try {
                                    const game = LocalGameService.createGameFromJSON(gameData);
                                    // Check if game already exists
                                    const exists = games.some(g => g.id === game.id);
                                    if (!exists) {
                                        games.push(game);
                                        imported++;
                                    }
                                } catch (err) {
                                    console.error('Failed to import game:', err);
                                }
                            }
                        } else {
                            // Single game
                            const game = LocalGameService.createGameFromJSON(data);
                            const exists = games.some(g => g.id === game.id);
                            if (!exists) {
                                games.push(game);
                                imported = 1;
                            }
                        }
                        
                        if (imported > 0) {
                            // Update state and save
                            this.stateManager.setState({ games, filteredGames: games });
                            StorageService.saveLocalGames(games);
                            this.gameManager.filterGames();
                            UIRenderer.showToast(`Imported ${imported} game(s)`);
                        } else {
                            UIRenderer.showToast('No new games to import');
                        }
                    } catch (error) {
                        console.error('Import error:', error);
                        UIRenderer.showToast('Failed to import games');
                    }
                    
                    // Reset file input
                    e.target.value = '';
                });
                
                // Export button
                document.getElementById('exportBtn').addEventListener('click', () => {
                    LocalGameService.exportAllGames(this.stateManager.getState().games);
                });
            }

            showCreateGame() {
                const grid = document.getElementById('gamesGrid');
                const sampleCode = `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>My Game</title>
    <style>
        body { 
            margin: 0; 
            padding: 20px; 
            background: #111; 
            color: white; 
            font-family: Arial, sans-serif; 
        }
    </style>
</head>
<body>
    <h1>My Game</h1>
    <p>Your game code here...</p>
    <scr` + `ipt>
        // Your game logic here
        console.log('Game loaded!');
    </scr` + `ipt>
</body>
</html>`;
                
                grid.innerHTML = `
                    <div class="game-creator">
                        <h2 style="margin-bottom: 30px;">Create New Game</h2>
                        
                        <div class="form-group">
                            <label class="form-label">Game Name *</label>
                            <input type="text" class="form-input" id="gameName" placeholder="My Awesome Game">
                        </div>
                        
                        <div class="form-group">
                            <label class="form-label">Description</label>
                            <input type="text" class="form-input" id="gameDesc" placeholder="A fun game to play">
                        </div>
                        
                        <div class="form-group">
                            <label class="form-label">Icon (Emoji)</label>
                            <input type="text" class="form-input" id="gameIcon" placeholder="üéÆ" value="üéÆ">
                        </div>
                        
                        <div class="form-group">
                            <label class="form-label">Category</label>
                            <select class="form-select" id="gameCategory">
                                <option value="arcade">Arcade</option>
                                <option value="puzzle">Puzzle</option>
                                <option value="action">Action</option>
                                <option value="strategy">Strategy</option>
                                <option value="adventure">Adventure</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label class="form-label">Author</label>
                            <input type="text" class="form-input" id="gameAuthor" placeholder="Your Name">
                        </div>
                        
                        <div class="form-group">
                            <label class="form-label">HTML Code *</label>
                            <textarea class="form-textarea" id="gameCode" placeholder="Paste your complete HTML game code here">${sampleCode}</textarea>
                        </div>
                        
                        <div style="display: flex; gap: 15px;">
                            <button class="create-game-btn" id="createBtn">Create Game</button>
                            <button class="nav-button" style="padding: 12px 30px;" id="testBtn">Test Game</button>
                            <button class="nav-button" style="padding: 12px 30px;" id="exportCreatedBtn">Export as JSON</button>
                        </div>
                        
                        <div style="margin-top: 30px; padding: 20px; background: rgba(79, 195, 247, 0.1); border-radius: 10px;">
                            <h4 style="color: #4fc3f7; margin-bottom: 10px;">Tips:</h4>
                            <ul style="color: #8b8b8b; line-height: 1.8; margin-left: 20px;">
                                <li>Your game should be a complete HTML file with all CSS and JavaScript inline</li>
                                <li>The game will run in a sandboxed iframe for security</li>
                                <li>You can test your game before saving it</li>
                                <li>Export your game as JSON to share with others</li>
                                <li>Use localStorage for saving game progress</li>
                            </ul>
                        </div>
                    </div>
                `;
                
                // Add event listeners
                document.getElementById('createBtn').addEventListener('click', () => {
                    this.createNewGame();
                });
                
                document.getElementById('testBtn').addEventListener('click', () => {
                    this.testGame();
                });
                
                document.getElementById('exportCreatedBtn').addEventListener('click', () => {
                    this.exportCreatedGame();
                });
            }

            createNewGame() {
                const name = document.getElementById('gameName').value.trim();
                const code = document.getElementById('gameCode').value.trim();
                
                if (!name || !code) {
                    UIRenderer.showToast('Please provide a name and code for your game');
                    return;
                }
                
                const gameData = {
                    id: 'local-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9),
                    name: name,
                    description: document.getElementById('gameDesc').value || 'A custom game',
                    icon: document.getElementById('gameIcon').value || 'üéÆ',
                    category: document.getElementById('gameCategory').value,
                    author: document.getElementById('gameAuthor').value || 'Unknown',
                    version: '1.0',
                    code: code,
                    isLocal: true
                };
                
                try {
                    const game = new Game(gameData);
                    
                    // Add to state
                    const state = this.stateManager.getState();
                    const games = [...state.games, game];
                    this.stateManager.setState({ games, filteredGames: games });
                    
                    // Save to storage
                    StorageService.saveLocalGames(games);
                    
                    UIRenderer.showToast(`Game "${name}" created successfully!`);
                    
                    // Switch to store view
                    document.querySelector('[data-view="store"]').click();
                } catch (error) {
                    console.error('Error creating game:', error);
                    UIRenderer.showToast('Failed to create game');
                }
            }

            testGame() {
                const code = document.getElementById('gameCode').value.trim();
                
                if (!code) {
                    UIRenderer.showToast('Please provide game code to test');
                    return;
                }
                
                // Launch in iframe
                const emulatorContainer = document.getElementById('emulatorContainer');
                const emulatorFrame = document.getElementById('emulatorFrame');
                
                const blob = new Blob([code], { type: 'text/html' });
                emulatorFrame.src = URL.createObjectURL(blob);
                emulatorContainer.classList.add('show');
                
                UIRenderer.showToast('Testing game...');
            }

            exportCreatedGame() {
                const name = document.getElementById('gameName').value.trim();
                const code = document.getElementById('gameCode').value.trim();
                
                if (!name || !code) {
                    UIRenderer.showToast('Please provide a name and code for your game');
                    return;
                }
                
                const gameData = {
                    name: name,
                    description: document.getElementById('gameDesc').value || 'A custom game',
                    icon: document.getElementById('gameIcon').value || 'üéÆ',
                    category: document.getElementById('gameCategory').value,
                    author: document.getElementById('gameAuthor').value || 'Unknown',
                    version: '1.0',
                    code: code
                };
                
                const blob = new Blob([JSON.stringify(gameData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `${name.toLowerCase().replace(/\s+/g, '-')}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                UIRenderer.showToast('Game exported as JSON');
            }

            showSettings() {
                const grid = document.getElementById('gamesGrid');
                grid.innerHTML = `
                    <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
                        <h2 style="margin-bottom: 30px;">Settings</h2>
                        <div style="background: rgba(26, 29, 35, 0.6); padding: 30px; border-radius: 15px;">
                            <h3 style="margin-bottom: 20px;">About</h3>
                            <p style="color: #8b8b8b; line-height: 1.6;">
                                Steam Deck Game Store v1.0<br>
                                A local-first game launcher with gamepad support.<br><br>
                                Repository: ${AppConfig.repository.owner}/${AppConfig.repository.name}
                            </p>
                            <br>
                            <h3 style="margin-bottom: 20px;">Controls</h3>
                            <p style="color: #8b8b8b; line-height: 1.6;">
                                Current input mode: ${this.stateManager.state.inputMode}<br>
                                Gamepad support: ${navigator.getGamepads ? 'Available' : 'Not available'}
                            </p>
                            <br>
                            <h3 style="margin-bottom: 20px;">Local Games</h3>
                            <p style="color: #8b8b8b; line-height: 1.6;">
                                Imported games: ${this.stateManager.state.games.filter(g => g.isLocal).length}<br>
                                You can import/export games using the buttons in the top-right corner.
                            </p>
                        </div>
                    </div>
                `;
            }
        }

        // ===== INITIALIZATION =====
        document.addEventListener('DOMContentLoaded', () => {
            window.gameStore = new SteamDeckGameStore();
        });
    </script>
</body>
</html>