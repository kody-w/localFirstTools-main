<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="ECS Game Console with CHIP-8 Emulation - Play ECS games and classic ROMs in one unified console">
    <meta name="theme-color" content="#05050a">
    <meta name="color-scheme" content="dark">
    <title>ECS Game Console + Emulator</title>
    <!-- game, console, ecs, emulator, chip8, retro, arcade -->
    <style>
        :root {
            --bg-darkest: #05050a;
            --bg-dark: #0a0a12;
            --bg-medium: #12121f;
            --bg-light: #1a1a2e;
            --bg-lighter: #252540;
            --text-primary: #e8e8f0;
            --text-secondary: #8888a0;
            --text-dim: #555566;
            --accent: #00d4ff;
            --accent-glow: rgba(0, 212, 255, 0.3);
            --secondary: #ff00aa;
            --tertiary: #00ff88;
            --warning: #ffaa00;
            --danger: #ff4466;
            --success: #44ff88;
            --emulator: #ff6600;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'SF Mono', 'Consolas', 'Monaco', monospace;
            background: var(--bg-darkest);
            color: var(--text-primary);
            min-height: 100vh;
            overflow: hidden;
        }

        .launcher {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            background: var(--bg-darkest);
            z-index: 100;
            transition: opacity 0.5s, visibility 0.5s;
        }

        .launcher.hidden { opacity: 0; visibility: hidden; pointer-events: none; }

        .launcher-header {
            padding: 1.5rem;
            text-align: center;
            background: linear-gradient(180deg, var(--bg-medium) 0%, var(--bg-darkest) 100%);
            border-bottom: 1px solid var(--bg-light);
        }

        .console-logo {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 0.5rem;
        }

        .console-logo h1 {
            font-size: 2rem;
            font-weight: 300;
            letter-spacing: 0.15em;
            background: linear-gradient(135deg, var(--accent) 0%, var(--secondary) 50%, var(--tertiary) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .console-tagline {
            color: var(--text-secondary);
            font-size: 0.8rem;
            letter-spacing: 0.2em;
            text-transform: uppercase;
        }

        .mode-tabs {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1rem;
        }

        .mode-tab {
            padding: 0.6rem 1.5rem;
            background: var(--bg-dark);
            border: 1px solid var(--bg-light);
            border-radius: 20px;
            color: var(--text-secondary);
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .mode-tab:hover { border-color: var(--accent); color: var(--text-primary); }
        .mode-tab.active { background: var(--accent); color: var(--bg-darkest); border-color: var(--accent); }
        .mode-tab.active.emulator { background: var(--emulator); border-color: var(--emulator); }

        .launcher-content {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .cartridge-library {
            flex: 1;
            padding: 1.5rem;
            overflow-y: auto;
        }

        .library-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .library-title {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            color: var(--text-secondary);
        }

        .cartridge-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 1rem;
        }

        .cartridge-card {
            background: var(--bg-dark);
            border: 1px solid var(--bg-light);
            border-radius: 10px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s;
        }

        .cartridge-card:hover {
            transform: translateY(-3px);
            border-color: var(--accent);
            box-shadow: 0 8px 30px rgba(0, 212, 255, 0.15);
        }

        .cartridge-card.selected {
            border-color: var(--accent);
            box-shadow: 0 0 0 2px var(--accent-glow);
        }

        .cartridge-card.emulator-cart { border-left: 3px solid var(--emulator); }
        .cartridge-card.emulator-cart.selected { border-color: var(--emulator); box-shadow: 0 0 0 2px rgba(255, 102, 0, 0.3); }

        .cartridge-preview {
            height: 100px;
            background: var(--bg-medium);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .cartridge-preview canvas { width: 100%; height: 100%; }

        .cart-type-badge {
            position: absolute;
            top: 6px;
            right: 6px;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.55rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .cart-type-badge.ecs { background: var(--tertiary); color: #000; }
        .cart-type-badge.emulator { background: var(--emulator); color: #fff; }

        .cartridge-info { padding: 0.8rem; }

        .cartridge-title {
            font-size: 0.85rem;
            font-weight: 600;
            margin-bottom: 0.3rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .cartridge-genre {
            font-size: 0.65rem;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .detail-panel {
            width: 320px;
            background: var(--bg-dark);
            border-left: 1px solid var(--bg-light);
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
        }

        .detail-title {
            font-size: 1.2rem;
            margin-bottom: 0.5rem;
        }

        .detail-desc {
            font-size: 0.75rem;
            color: var(--text-secondary);
            line-height: 1.5;
            margin-bottom: 1rem;
        }

        .detail-meta {
            font-size: 0.7rem;
            color: var(--text-dim);
            margin-bottom: 1rem;
        }

        .detail-controls {
            background: var(--bg-medium);
            border-radius: 8px;
            padding: 0.8rem;
            margin-bottom: 1rem;
        }

        .detail-controls h4 {
            font-size: 0.65rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
            text-transform: uppercase;
        }

        .control-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            padding: 0.2rem 0;
        }

        .control-key { color: var(--accent); }

        .btn {
            padding: 0.6rem 1.2rem;
            border: none;
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .btn-primary { background: var(--accent); color: var(--bg-darkest); }
        .btn-primary:hover { background: var(--tertiary); transform: scale(1.02); }
        .btn-primary.emulator { background: var(--emulator); }
        .btn-primary.emulator:hover { background: #ff8833; }

        .btn-ghost {
            background: transparent;
            color: var(--text-secondary);
            border: 1px solid var(--bg-lighter);
        }

        .btn-ghost:hover { background: var(--bg-light); color: var(--text-primary); }

        .btn:disabled { opacity: 0.4; cursor: not-allowed; }

        .play-actions { margin-top: auto; display: flex; flex-direction: column; gap: 0.5rem; }

        /* GAME SCREEN */
        .game-screen {
            position: fixed;
            inset: 0;
            display: none;
            flex-direction: column;
            background: var(--bg-darkest);
        }

        .game-screen.active { display: flex; }

        .game-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.8rem 1.5rem;
            background: var(--bg-dark);
            border-bottom: 1px solid var(--bg-light);
        }

        .game-title-bar {
            font-size: 0.85rem;
            font-weight: 600;
        }

        .game-controls { display: flex; gap: 0.5rem; }

        .game-stats {
            display: flex;
            gap: 1.5rem;
            font-size: 0.75rem;
        }

        .stat-item { display: flex; align-items: center; gap: 0.4rem; }
        .stat-label { color: var(--text-dim); }
        .stat-value { color: var(--accent); font-weight: 600; }

        .game-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-darkest);
            position: relative;
        }

        #gameCanvas {
            background: #000;
            border-radius: 4px;
            box-shadow: 0 0 50px rgba(0, 212, 255, 0.1);
        }

        /* CRT Overlay for Emulator */
        .crt-overlay {
            position: absolute;
            pointer-events: none;
            border-radius: 4px;
        }

        .scanlines {
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15) 0px,
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
        }

        /* Emulator Debug Panel */
        .emulator-debug {
            position: absolute;
            right: 10px;
            top: 10px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid var(--emulator);
            border-radius: 8px;
            padding: 10px;
            font-size: 0.6rem;
            max-width: 200px;
            display: none;
        }

        .emulator-debug.visible { display: block; }

        .debug-title {
            color: var(--emulator);
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 0.7rem;
        }

        .registers-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 2px;
        }

        .reg {
            background: var(--bg-medium);
            padding: 2px 4px;
            border-radius: 2px;
            display: flex;
            justify-content: space-between;
        }

        .reg-name { color: var(--tertiary); }
        .reg-val { color: var(--text-primary); }

        .debug-section {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid var(--bg-light);
        }

        /* Pause Overlay */
        .pause-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 1rem;
        }

        .pause-overlay.visible { display: flex; }
        .pause-text { font-size: 2rem; color: var(--warning); }

        /* Game Over */
        .gameover-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 1rem;
        }

        .gameover-overlay.visible { display: flex; }
        .gameover-text { font-size: 2.5rem; color: var(--danger); }
        .final-score { font-size: 1.2rem; color: var(--text-secondary); }

        @media (max-width: 900px) {
            .launcher-content { flex-direction: column; }
            .detail-panel { width: 100%; border-left: none; border-top: 1px solid var(--bg-light); }
            .cartridge-grid { grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); }
        }
    </style>
</head>
<body>
    <!-- LAUNCHER -->
    <div class="launcher" id="launcher">
        <div class="launcher-header">
            <div class="console-logo">
                <h1>ECS CONSOLE</h1>
            </div>
            <div class="console-tagline">ECS Game Engine + CHIP-8 Emulator</div>
            <div class="mode-tabs">
                <button class="mode-tab active" data-mode="all" onclick="setMode('all')">All Games</button>
                <button class="mode-tab" data-mode="ecs" onclick="setMode('ecs')">ECS Games</button>
                <button class="mode-tab emulator" data-mode="emulator" onclick="setMode('emulator')">CHIP-8 ROMs</button>
            </div>
        </div>

        <div class="launcher-content">
            <div class="cartridge-library">
                <div class="library-header">
                    <span class="library-title" id="libraryTitle">Game Library</span>
                </div>
                <div class="cartridge-grid" id="cartridgeGrid"></div>
            </div>

            <div class="detail-panel">
                <h2 class="detail-title" id="detailTitle">Select a Game</h2>
                <p class="detail-desc" id="detailDesc">Choose a game from the library to see details and play.</p>
                <div class="detail-meta" id="detailMeta"></div>
                <div class="detail-controls" id="detailControls" style="display:none">
                    <h4>Controls</h4>
                    <div id="controlsList"></div>
                </div>
                <div class="play-actions">
                    <button class="btn btn-primary" id="playButton" disabled onclick="startGame()">
                        INSERT CARTRIDGE
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- GAME SCREEN -->
    <div class="game-screen" id="gameScreen">
        <div class="game-header">
            <span class="game-title-bar" id="gameTitleBar">Game</span>
            <div class="game-stats" id="gameStats"></div>
            <div class="game-controls">
                <button class="btn btn-ghost" id="debugBtn" onclick="toggleDebug()" style="display:none">Debug</button>
                <button class="btn btn-ghost" onclick="togglePause()">Pause</button>
                <button class="btn btn-ghost" onclick="restartGame()">Restart</button>
                <button class="btn btn-ghost" onclick="exitGame()">Exit</button>
            </div>
        </div>
        <div class="game-container">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
            <div class="crt-overlay scanlines" id="crtOverlay" style="display:none"></div>
            <div class="emulator-debug" id="emulatorDebug">
                <div class="debug-title">CPU Registers</div>
                <div class="registers-grid" id="debugRegisters"></div>
                <div class="debug-section">
                    <div>PC: <span id="debugPC">0x200</span></div>
                    <div>I: <span id="debugI">0x000</span></div>
                    <div>Cycles: <span id="debugCycles">0</span></div>
                </div>
            </div>
            <div class="pause-overlay" id="pauseOverlay">
                <div class="pause-text">PAUSED</div>
                <button class="btn btn-primary" onclick="togglePause()">Resume</button>
            </div>
            <div class="gameover-overlay" id="gameoverOverlay">
                <div class="gameover-text">GAME OVER</div>
                <div class="final-score" id="finalScore"></div>
                <button class="btn btn-primary" onclick="restartGame()">Play Again</button>
                <button class="btn btn-ghost" onclick="exitGame()">Exit</button>
            </div>
        </div>
    </div>

    <script>
        // ═══════════════════════════════════════════════════════════════════════════
        // CHIP-8 EMULATOR CORE
        // ═══════════════════════════════════════════════════════════════════════════

        class Chip8 {
            constructor() { this.reset(); }

            reset() {
                this.memory = new Uint8Array(4096);
                this.V = new Uint8Array(16);
                this.I = 0;
                this.PC = 0x200;
                this.stack = new Uint16Array(16);
                this.SP = 0;
                this.delayTimer = 0;
                this.soundTimer = 0;
                this.display = new Uint8Array(64 * 32);
                this.keys = new Uint8Array(16);
                this.drawFlag = false;
                this.waitingForKey = false;
                this.keyRegister = 0;
                this.cycles = 0;
                this.loadFontset();
            }

            loadFontset() {
                const fontset = [
                    0xF0, 0x90, 0x90, 0x90, 0xF0, 0x20, 0x60, 0x20, 0x20, 0x70,
                    0xF0, 0x10, 0xF0, 0x80, 0xF0, 0xF0, 0x10, 0xF0, 0x10, 0xF0,
                    0x90, 0x90, 0xF0, 0x10, 0x10, 0xF0, 0x80, 0xF0, 0x10, 0xF0,
                    0xF0, 0x80, 0xF0, 0x90, 0xF0, 0xF0, 0x10, 0x20, 0x40, 0x40,
                    0xF0, 0x90, 0xF0, 0x90, 0xF0, 0xF0, 0x90, 0xF0, 0x10, 0xF0,
                    0xF0, 0x90, 0xF0, 0x90, 0x90, 0xE0, 0x90, 0xE0, 0x90, 0xE0,
                    0xF0, 0x80, 0x80, 0x80, 0xF0, 0xE0, 0x90, 0x90, 0x90, 0xE0,
                    0xF0, 0x80, 0xF0, 0x80, 0xF0, 0xF0, 0x80, 0xF0, 0x80, 0x80
                ];
                for (let i = 0; i < fontset.length; i++) this.memory[i] = fontset[i];
            }

            loadROM(data) {
                this.reset();
                for (let i = 0; i < data.length; i++) this.memory[0x200 + i] = data[i];
            }

            cycle() {
                if (this.waitingForKey) return;
                const opcode = (this.memory[this.PC] << 8) | this.memory[this.PC + 1];
                this.PC += 2;
                this.cycles++;
                this.execute(opcode);
            }

            execute(opcode) {
                const x = (opcode & 0x0F00) >> 8;
                const y = (opcode & 0x00F0) >> 4;
                const n = opcode & 0x000F;
                const nn = opcode & 0x00FF;
                const nnn = opcode & 0x0FFF;

                switch (opcode & 0xF000) {
                    case 0x0000:
                        if (opcode === 0x00E0) { this.display.fill(0); this.drawFlag = true; }
                        else if (opcode === 0x00EE) { this.SP--; this.PC = this.stack[this.SP]; }
                        break;
                    case 0x1000: this.PC = nnn; break;
                    case 0x2000: this.stack[this.SP] = this.PC; this.SP++; this.PC = nnn; break;
                    case 0x3000: if (this.V[x] === nn) this.PC += 2; break;
                    case 0x4000: if (this.V[x] !== nn) this.PC += 2; break;
                    case 0x5000: if (this.V[x] === this.V[y]) this.PC += 2; break;
                    case 0x6000: this.V[x] = nn; break;
                    case 0x7000: this.V[x] = (this.V[x] + nn) & 0xFF; break;
                    case 0x8000:
                        switch (n) {
                            case 0: this.V[x] = this.V[y]; break;
                            case 1: this.V[x] |= this.V[y]; this.V[0xF] = 0; break;
                            case 2: this.V[x] &= this.V[y]; this.V[0xF] = 0; break;
                            case 3: this.V[x] ^= this.V[y]; this.V[0xF] = 0; break;
                            case 4: const sum = this.V[x] + this.V[y]; this.V[x] = sum & 0xFF; this.V[0xF] = sum > 255 ? 1 : 0; break;
                            case 5: const vf5 = this.V[x] >= this.V[y] ? 1 : 0; this.V[x] = (this.V[x] - this.V[y]) & 0xFF; this.V[0xF] = vf5; break;
                            case 6: const lsb = this.V[x] & 1; this.V[x] >>= 1; this.V[0xF] = lsb; break;
                            case 7: const vf7 = this.V[y] >= this.V[x] ? 1 : 0; this.V[x] = (this.V[y] - this.V[x]) & 0xFF; this.V[0xF] = vf7; break;
                            case 0xE: const msb = (this.V[x] >> 7) & 1; this.V[x] = (this.V[x] << 1) & 0xFF; this.V[0xF] = msb; break;
                        }
                        break;
                    case 0x9000: if (this.V[x] !== this.V[y]) this.PC += 2; break;
                    case 0xA000: this.I = nnn; break;
                    case 0xB000: this.PC = nnn + this.V[0]; break;
                    case 0xC000: this.V[x] = Math.floor(Math.random() * 256) & nn; break;
                    case 0xD000:
                        const xPos = this.V[x] % 64, yPos = this.V[y] % 32;
                        this.V[0xF] = 0;
                        for (let row = 0; row < n; row++) {
                            const byte = this.memory[this.I + row];
                            for (let col = 0; col < 8; col++) {
                                if ((byte & (0x80 >> col)) !== 0) {
                                    const idx = ((yPos + row) % 32) * 64 + ((xPos + col) % 64);
                                    if (this.display[idx]) this.V[0xF] = 1;
                                    this.display[idx] ^= 1;
                                }
                            }
                        }
                        this.drawFlag = true;
                        break;
                    case 0xE000:
                        if (nn === 0x9E && this.keys[this.V[x] & 0xF]) this.PC += 2;
                        else if (nn === 0xA1 && !this.keys[this.V[x] & 0xF]) this.PC += 2;
                        break;
                    case 0xF000:
                        switch (nn) {
                            case 0x07: this.V[x] = this.delayTimer; break;
                            case 0x0A: this.waitingForKey = true; this.keyRegister = x; break;
                            case 0x15: this.delayTimer = this.V[x]; break;
                            case 0x18: this.soundTimer = this.V[x]; break;
                            case 0x1E: this.I = (this.I + this.V[x]) & 0xFFF; break;
                            case 0x29: this.I = (this.V[x] & 0xF) * 5; break;
                            case 0x33:
                                this.memory[this.I] = Math.floor(this.V[x] / 100);
                                this.memory[this.I + 1] = Math.floor((this.V[x] / 10) % 10);
                                this.memory[this.I + 2] = this.V[x] % 10;
                                break;
                            case 0x55: for (let i = 0; i <= x; i++) this.memory[this.I + i] = this.V[i]; break;
                            case 0x65: for (let i = 0; i <= x; i++) this.V[i] = this.memory[this.I + i]; break;
                        }
                        break;
                }
            }

            updateTimers() {
                if (this.delayTimer > 0) this.delayTimer--;
                if (this.soundTimer > 0) this.soundTimer--;
            }

            keyDown(key) {
                this.keys[key] = 1;
                if (this.waitingForKey) { this.V[this.keyRegister] = key; this.waitingForKey = false; }
            }

            keyUp(key) { this.keys[key] = 0; }
        }

        // ═══════════════════════════════════════════════════════════════════════════
        // ECS ENGINE CORE
        // ═══════════════════════════════════════════════════════════════════════════

        class ECSWorld {
            constructor() {
                this.nextId = 1;
                this.entities = new Set();
                this.components = {};
                this.toDestroy = [];
            }

            createEntity() {
                const id = this.nextId++;
                this.entities.add(id);
                return id;
            }

            destroyEntity(id) { this.toDestroy.push(id); }

            flushDestroy() {
                for (const id of this.toDestroy) {
                    this.entities.delete(id);
                    for (const type in this.components) delete this.components[type][id];
                }
                this.toDestroy = [];
            }

            addComponent(id, type, data) {
                if (!this.components[type]) this.components[type] = {};
                this.components[type][id] = { ...data };
            }

            getComponent(id, type) { return this.components[type]?.[id]; }
            hasComponent(id, type) { return !!this.components[type]?.[id]; }

            query(...types) {
                return [...this.entities].filter(id => types.every(t => this.hasComponent(id, t)));
            }
        }

        // ═══════════════════════════════════════════════════════════════════════════
        // GAME LIBRARY
        // ═══════════════════════════════════════════════════════════════════════════

        const GAME_LIBRARY = [
            // ECS GAMES
            {
                type: 'ecs',
                meta: { id: 'asteroid-blaster', title: 'Asteroid Blaster', genre: 'Shooter', description: 'Classic asteroid shooter. Destroy asteroids and enemies!' },
                controls: { 'W/↑': 'Thrust', 'A/←': 'Left', 'D/→': 'Right', 'Space': 'Fire' },
                setup(world, state, canvas) {
                    state.score = 0; state.lives = 3;
                    const p = world.createEntity();
                    world.addComponent(p, 'Transform', { x: canvas.width/2, y: canvas.height/2, rot: 0 });
                    world.addComponent(p, 'Velocity', { vx: 0, vy: 0, drag: 0.98 });
                    world.addComponent(p, 'Sprite', { type: 'ship', color: '#00ffcc', size: 15 });
                    world.addComponent(p, 'Player', { thrust: 300, rotSpeed: 4, fireRate: 0.15, fireCooldown: 0 });
                    world.addComponent(p, 'Collider', { radius: 12, group: 'player' });
                    for (let i = 0; i < 5; i++) spawnAsteroid(world, canvas, 40);
                },
                systems: ['playerShip', 'asteroidAI', 'movement', 'collision', 'render'],
                hud: ['score', 'lives']
            },
            {
                type: 'ecs',
                meta: { id: 'neon-invaders', title: 'Neon Invaders', genre: 'Arcade', description: 'Space Invaders with a neon twist!' },
                controls: { 'A/←': 'Left', 'D/→': 'Right', 'Space': 'Fire' },
                setup(world, state, canvas) {
                    state.score = 0; state.lives = 3;
                    const p = world.createEntity();
                    world.addComponent(p, 'Transform', { x: canvas.width/2, y: canvas.height - 50, rot: 0 });
                    world.addComponent(p, 'Velocity', { vx: 0, vy: 0 });
                    world.addComponent(p, 'Sprite', { type: 'ship', color: '#00ffcc', size: 15 });
                    world.addComponent(p, 'Player', { thrust: 0, rotSpeed: 0, fireRate: 0.25, fireCooldown: 0, moveSpeed: 300 });
                    world.addComponent(p, 'Collider', { radius: 12, group: 'player' });
                    state.invaderDir = 1; state.invaderTimer = 0; state.invaderSpeed = 0.8;
                    const colors = ['#ff4466', '#ff8844', '#ffaa00', '#44ff88', '#4488ff'];
                    for (let row = 0; row < 5; row++) {
                        for (let col = 0; col < 11; col++) {
                            const inv = world.createEntity();
                            world.addComponent(inv, 'Transform', { x: 60 + col * 55, y: 60 + row * 40, rot: 0 });
                            world.addComponent(inv, 'Sprite', { type: 'invader', color: colors[row], size: 12 });
                            world.addComponent(inv, 'Invader', { row, col });
                            world.addComponent(inv, 'Collider', { radius: 10, group: 'enemy' });
                        }
                    }
                },
                systems: ['playerInvaders', 'invaderAI', 'movement', 'collision', 'render'],
                hud: ['score', 'lives']
            },
            {
                type: 'ecs',
                meta: { id: 'snake', title: 'Snake', genre: 'Puzzle', description: 'Classic snake game. Eat food and grow!' },
                controls: { 'W/↑': 'Up', 'S/↓': 'Down', 'A/←': 'Left', 'D/→': 'Right' },
                setup(world, state, canvas) {
                    state.score = 0;
                    const grid = 20;
                    state.grid = grid;
                    state.snake = [{ x: 10, y: 10 }, { x: 9, y: 10 }, { x: 8, y: 10 }];
                    state.dir = { x: 1, y: 0 };
                    state.nextDir = { x: 1, y: 0 };
                    state.moveTimer = 0;
                    state.moveInterval = 0.1;
                    state.food = { x: 15, y: 10 };
                },
                systems: ['snake'],
                hud: ['score']
            },
            {
                type: 'ecs',
                meta: { id: 'breakout', title: 'Breakout', genre: 'Arcade', description: 'Break all the bricks with your ball!' },
                controls: { 'A/←': 'Left', 'D/→': 'Right' },
                setup(world, state, canvas) {
                    state.score = 0; state.lives = 3;
                    const paddle = world.createEntity();
                    world.addComponent(paddle, 'Transform', { x: canvas.width/2, y: canvas.height - 40 });
                    world.addComponent(paddle, 'Sprite', { type: 'rect', color: '#00ffcc', w: 80, h: 12 });
                    world.addComponent(paddle, 'Paddle', { speed: 400 });
                    const ball = world.createEntity();
                    world.addComponent(ball, 'Transform', { x: canvas.width/2, y: canvas.height - 60 });
                    world.addComponent(ball, 'Velocity', { vx: 200, vy: -300 });
                    world.addComponent(ball, 'Sprite', { type: 'circle', color: '#ffffff', size: 8 });
                    world.addComponent(ball, 'Ball', {});
                    const colors = ['#ff4466', '#ff8844', '#ffaa00', '#44ff88', '#4488ff'];
                    for (let row = 0; row < 5; row++) {
                        for (let col = 0; col < 12; col++) {
                            const brick = world.createEntity();
                            world.addComponent(brick, 'Transform', { x: 50 + col * 60, y: 50 + row * 25 });
                            world.addComponent(brick, 'Sprite', { type: 'rect', color: colors[row], w: 55, h: 20 });
                            world.addComponent(brick, 'Brick', {});
                        }
                    }
                },
                systems: ['paddle', 'ballPhysics', 'movement', 'render'],
                hud: ['score', 'lives']
            },
            {
                type: 'ecs',
                meta: { id: 'geometry-swarm', title: 'Geometry Swarm', genre: 'Shooter', description: 'Twin-stick survival shooter. Auto-aim at nearest enemy!' },
                controls: { 'WASD': 'Move', 'Auto': 'Fire at nearest enemy' },
                setup(world, state, canvas) {
                    state.score = 0; state.lives = 3; state.spawnTimer = 0; state.fireTimer = 0;
                    const p = world.createEntity();
                    world.addComponent(p, 'Transform', { x: canvas.width/2, y: canvas.height/2, rot: 0 });
                    world.addComponent(p, 'Velocity', { vx: 0, vy: 0 });
                    world.addComponent(p, 'Sprite', { type: 'diamond', color: '#00ffcc', size: 12 });
                    world.addComponent(p, 'Player', { speed: 250, fireRate: 0.1 });
                    world.addComponent(p, 'Collider', { radius: 12, group: 'player' });
                },
                systems: ['twinStick', 'geometrySpawner', 'movement', 'collision', 'render'],
                hud: ['score', 'lives']
            },
            {
                type: 'ecs',
                meta: { id: 'missile-defense', title: 'Missile Defense', genre: 'Strategy', description: 'Protect your cities from incoming missiles! Click to intercept.' },
                controls: { 'Click': 'Launch interceptor' },
                setup(world, state, canvas) {
                    state.score = 0; state.cities = 6; state.wave = 1; state.missileTimer = 0;
                    const cityPositions = [0.15, 0.3, 0.45, 0.55, 0.7, 0.85];
                    for (const xp of cityPositions) {
                        const city = world.createEntity();
                        world.addComponent(city, 'Transform', { x: canvas.width * xp, y: canvas.height - 30 });
                        world.addComponent(city, 'Sprite', { type: 'city', color: '#44ff88', size: 20 });
                        world.addComponent(city, 'City', {});
                    }
                    const launcher = world.createEntity();
                    world.addComponent(launcher, 'Transform', { x: canvas.width/2, y: canvas.height - 20 });
                    world.addComponent(launcher, 'Sprite', { type: 'rect', color: '#4488ff', w: 30, h: 15 });
                },
                systems: ['missileDefense', 'movement', 'render'],
                hud: ['score', 'cities', 'wave']
            },

            // CHIP-8 ROMS
            {
                type: 'emulator',
                meta: { id: 'maze', title: 'Maze', genre: 'Demo', description: 'Random maze generator - watch mesmerizing patterns!' },
                controls: { 'None': 'Watch the maze generate' },
                rom: [0x60,0x00,0x61,0x00,0xA2,0x22,0xC2,0x01,0x32,0x01,0xA2,0x1E,0xD0,0x14,0x70,0x04,0x30,0x40,0x12,0x04,0x60,0x00,0x71,0x04,0x31,0x20,0x12,0x04,0x12,0x1C,0x80,0x40,0x20,0x10,0x20,0x40,0x80,0x10]
            },
            {
                type: 'emulator',
                meta: { id: 'pong', title: 'Pong', genre: 'Sports', description: 'Classic Pong - first video game ever!' },
                controls: { '1': 'P1 Up', 'Q': 'P1 Down', '4': 'P2 Up', 'R': 'P2 Down' },
                rom: [0x6A,0x02,0x6B,0x0C,0x6C,0x3F,0x6D,0x0C,0xA2,0xEA,0xDA,0xB6,0xDC,0xD6,0x6E,0x00,0x22,0xD4,0x66,0x03,0x68,0x02,0x60,0x60,0xF0,0x15,0xF0,0x07,0x30,0x00,0x12,0x1A,0xC7,0x17,0x77,0x08,0x69,0xFF,0xA2,0xF0,0xD6,0x71,0xA2,0xEA,0xDA,0xB6,0xDC,0xD6,0x60,0x01,0xE0,0xA1,0x7B,0xFE,0x60,0x04,0xE0,0xA1,0x7B,0x02,0x60,0x1F,0x8B,0x02,0xDA,0xB6,0x60,0x0C,0xE0,0xA1,0x7D,0xFE,0x60,0x0D,0xE0,0xA1,0x7D,0x02,0x60,0x1F,0x8D,0x02,0xDC,0xD6,0xA2,0xF0,0xD6,0x71,0x86,0x84,0x87,0x94,0x60,0x3F,0x86,0x02,0x61,0x1F,0x87,0x12,0x46,0x02,0x12,0x78,0x46,0x3F,0x12,0x82,0x47,0x1F,0x69,0xFF,0x47,0x00,0x69,0x01,0xD6,0x71,0x12,0x2A,0x68,0x02,0x63,0x01,0x80,0x70,0x80,0xB5,0x12,0x8A,0x68,0xFE,0x63,0x0A,0x80,0x70,0x80,0xD5,0x3F,0x01,0x12,0xA2,0x61,0x02,0x80,0x15,0x3F,0x01,0x12,0xBA,0x80,0x15,0x3F,0x01,0x12,0xC8,0x80,0x15,0x3F,0x01,0x12,0xC2,0x60,0x20,0xF0,0x18,0x22,0xD4,0x8E,0x34,0x22,0xD4,0x66,0x3E,0x33,0x01,0x66,0x03,0x68,0xFE,0x33,0x01,0x68,0x02,0x12,0x16,0x79,0xFF,0x49,0xFE,0x69,0xFF,0x12,0xC8,0x79,0x01,0x49,0x02,0x69,0x01,0x60,0x04,0xF0,0x18,0x76,0x01,0x46,0x40,0x76,0xFE,0x12,0x6C,0xA2,0xF2,0xFE,0x33,0xF2,0x65,0xF1,0x29,0x64,0x14,0x65,0x02,0xD4,0x55,0x74,0x15,0xF2,0x29,0xD4,0x55,0x00,0xEE,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x00,0x00]
            },
            {
                type: 'emulator',
                meta: { id: 'invaders', title: 'Space Invaders', genre: 'Shooter', description: 'Classic Space Invaders!' },
                controls: { 'Q': 'Left', 'E': 'Right', 'W': 'Fire' },
                rom: [0x12,0x26,0xE0,0x9E,0x7D,0xFE,0xE0,0xA1,0x7D,0x02,0x3D,0x01,0x6D,0x01,0x3D,0x3D,0x6D,0x3D,0x00,0xEE,0x77,0x08,0xD8,0x75,0x00,0xEE,0xDC,0xD5,0x3F,0x00,0x12,0x24,0x7C,0x08,0x3C,0x38,0x12,0x18,0x00,0xEE,0x6B,0x00,0x6C,0x00,0x6D,0x1C,0x22,0x06,0xA2,0x5E,0xD8,0xD5,0x60,0x04,0xE0,0x9E,0x22,0x12,0x60,0x06,0xE0,0x9E,0x22,0x18,0xD8,0xD5,0x60,0x05,0xE0,0x9E,0x22,0x54,0x3B,0x00,0x22,0x30,0x22,0x36,0x12,0x28,0x22,0x4E,0x12,0x28,0xD8,0x75,0x3F,0x00,0x12,0x68,0x6B,0x00,0x7D,0x08,0xDD,0x85,0x00,0xEE,0xDC,0xD5,0x3F,0x00,0x12,0x5C,0x7C,0x08,0x3C,0x28,0x12,0x46,0x6C,0x00,0x00,0xEE,0x80,0x40,0xE0,0x40,0x80,0x20,0x70,0x20,0x00,0x40,0xE0,0x40,0x00,0x00]
            },
            {
                type: 'emulator',
                meta: { id: 'tetris', title: 'Tetris', genre: 'Puzzle', description: 'Classic Tetris block game!' },
                controls: { 'W': 'Rotate', 'A': 'Left', 'D': 'Right', 'S': 'Drop' },
                rom: [0xA2,0xB4,0x23,0xE6,0x22,0xB6,0x70,0x01,0xD0,0x11,0x30,0x25,0x12,0x06,0x71,0xFF,0xD0,0x11,0x60,0x1A,0xD0,0x11,0x60,0x25,0x31,0x00,0x12,0x0E,0xC4,0x70,0x44,0x70,0x12,0x06,0x00,0xE0,0x6E,0x05,0x65,0x00,0x6B,0x06,0x6A,0x00,0x6D,0x01,0xA2,0xA6,0x60,0x0B,0xF0,0x1E,0xF0,0x65,0x30,0x00,0x12,0x4C,0x31,0x00,0x12,0x58,0x71,0x01,0x12,0x2C,0x61,0x04,0x23,0x90,0x45,0x60,0x12,0x40,0x7A,0xFF,0x4A,0x06,0x6A,0x06,0x12,0x40,0x7A,0x01,0x12,0x40,0x00,0xE0,0xA2,0xA4,0x60,0x19,0x6C,0x10,0xDC,0x01,0x70,0x04,0x3C,0x00,0x12,0x60,0x23,0x90,0x12,0x26,0xC6,0x07,0x76,0xA4,0xF6,0x1E,0xF0,0x65,0xA3,0x00,0xF5,0x55,0x6D,0xFF,0x12,0x2C,0xA2,0xA6,0x8F,0xB0,0xF0,0x1E,0xDA,0xB1,0x00,0xEE,0x6F,0x00,0x6E,0x04,0x7E,0xFF,0x3E,0xFF,0x00,0xEE,0xA3,0x00,0xFE,0x65,0x60,0x01,0x80,0xE4,0xA3,0x00,0xF0,0x55,0x12,0x74,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0xC0,0x80,0x80,0x00,0x40,0xC0,0x40,0x00,0x80,0xC0,0x80,0x00,0xC0,0x40,0x40,0x00,0x80,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0x10,0xF0,0x80,0xF0]
            },
            {
                type: 'emulator',
                meta: { id: 'brix', title: 'Brix', genre: 'Arcade', description: 'Breakout clone for CHIP-8!' },
                controls: { 'Q': 'Left', 'E': 'Right' },
                rom: [0x6E,0x05,0x65,0x00,0x6B,0x06,0x6A,0x00,0xA2,0xD2,0x60,0x1F,0x61,0x01,0xD0,0x12,0x70,0x04,0x30,0x3F,0x12,0x10,0x60,0x00,0x71,0x02,0xD0,0x12,0x31,0x1D,0x12,0x08,0x6A,0x00,0x6B,0x20,0x6C,0x1F,0x6D,0x04,0xA2,0xD0,0xDA,0xB1,0xA2,0xD4,0xDC,0xD1,0x22,0xCA,0xA2,0xD0,0xDA,0xB1,0x83,0xD4,0x73,0x01,0x43,0x02,0x63,0xFE,0x82,0xC4,0x72,0x01,0x42,0x02,0x62,0xFE,0x8A,0x34,0x8B,0x24,0x4A,0x00,0x12,0xA8,0x4B,0x20,0x12,0xA8,0x4B,0x00,0x12,0xA8,0xA2,0xD4,0xDC,0xD1,0x3F,0x00,0x12,0x40,0x60,0x0A,0xF0,0x15,0xF0,0x07,0x30,0x00,0x12,0x6E,0x7C,0x01,0x4C,0x40,0x7C,0xFE,0x60,0x07,0xE0,0x9E,0x12,0x8E,0x60,0x09,0xE0,0x9E,0x12,0x98,0x12,0xA0,0xA2,0xD4,0xDC,0xD1,0x7C,0xFE,0xDC,0xD1,0x12,0xA0,0xA2,0xD4,0xDC,0xD1,0x7C,0x02,0xDC,0xD1,0x12,0x40,0x6D,0xFC,0x12,0x40,0x12,0x2E,0x00,0xE0,0xA2,0xD6,0x6C,0x19,0xDC,0xA5,0x00,0xEE,0x00,0x00,0xFF,0x00,0x3C,0x00,0x00,0x00,0x3C,0x24,0x24,0x24,0x3C]
            },
            {
                type: 'emulator',
                meta: { id: 'ibm', title: 'IBM Logo', genre: 'Demo', description: 'Classic IBM logo test ROM' },
                controls: { 'None': 'Test ROM - displays IBM logo' },
                rom: [0x00,0xE0,0xA2,0x2A,0x60,0x0C,0x61,0x08,0xD0,0x1F,0x70,0x09,0xA2,0x39,0xD0,0x1F,0xA2,0x48,0x70,0x08,0xD0,0x1F,0x70,0x04,0xA2,0x57,0xD0,0x1F,0x70,0x08,0xA2,0x66,0xD0,0x1F,0x70,0x08,0xA2,0x75,0xD0,0x1F,0x12,0x28,0xFF,0x00,0xFF,0x00,0x3C,0x00,0x3C,0x00,0x3C,0x00,0x3C,0x00,0xFF,0x00,0xFF,0xFF,0x00,0xFF,0x00,0x38,0x00,0x3F,0x00,0x3F,0x00,0x38,0x00,0xFF,0x00,0xFF,0x80,0x00,0xE0,0x00,0xE0,0x00,0x80,0x00,0x80,0x00,0xE0,0x00,0xE0,0x00,0x80,0xF8,0x00,0xFC,0x00,0x3E,0x00,0x3F,0x00,0x3B,0x00,0x39,0x00,0xF8,0x00,0xF8,0x03,0x00,0x07,0x00,0x0F,0x00,0xBF,0x00,0xFB,0x00,0xF3,0x00,0xE3,0x00,0x43,0xE0,0x00,0xE0,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0xE0,0x00,0xE0]
            },
            {
                type: 'emulator',
                meta: { id: 'particle', title: 'Particle', genre: 'Demo', description: 'Bouncing particle simulation' },
                controls: { 'None': 'Watch the particle bounce!' },
                rom: [0x61,0x00,0x62,0x00,0xA2,0x2C,0xD1,0x21,0xC0,0x01,0x30,0x01,0x71,0xFF,0x30,0x00,0x71,0x01,0xC0,0x01,0x30,0x01,0x72,0xFF,0x30,0x00,0x72,0x01,0x40,0x00,0x61,0x00,0x41,0x3F,0x61,0x3F,0x40,0x00,0x62,0x00,0x42,0x1F,0x62,0x1F,0x12,0x04,0x80]
            },
            {
                type: 'emulator',
                meta: { id: 'keypad', title: 'Keypad Test', genre: 'Utility', description: 'Test your keypad input' },
                controls: { '1-V': 'Press keys to see hex display' },
                rom: [0x6F,0x00,0x60,0x00,0xF0,0x0A,0xF0,0x29,0x61,0x08,0x62,0x10,0x00,0xE0,0xD1,0x25,0x12,0x00]
            }
        ];

        // ═══════════════════════════════════════════════════════════════════════════
        // APPLICATION STATE
        // ═══════════════════════════════════════════════════════════════════════════

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let currentGame = null;
        let gameMode = null; // 'ecs' or 'emulator'
        let world = null;
        let chip8 = null;
        let state = {};
        let running = false;
        let paused = false;
        let lastTime = 0;
        let keys = {};
        let selectedGame = null;
        let filterMode = 'all';

        // CHIP-8 key mapping
        const chip8Keys = {
            '1': 0x1, '2': 0x2, '3': 0x3, '4': 0xC,
            'q': 0x4, 'w': 0x5, 'e': 0x6, 'r': 0xD,
            'a': 0x7, 's': 0x8, 'd': 0x9, 'f': 0xE,
            'z': 0xA, 'x': 0x0, 'c': 0xB, 'v': 0xF
        };

        // ═══════════════════════════════════════════════════════════════════════════
        // UI FUNCTIONS
        // ═══════════════════════════════════════════════════════════════════════════

        function initUI() {
            renderLibrary();
        }

        function setMode(mode) {
            filterMode = mode;
            document.querySelectorAll('.mode-tab').forEach(t => {
                t.classList.toggle('active', t.dataset.mode === mode);
            });
            renderLibrary();
        }

        function renderLibrary() {
            const grid = document.getElementById('cartridgeGrid');
            grid.innerHTML = '';

            const games = GAME_LIBRARY.filter(g => {
                if (filterMode === 'all') return true;
                return g.type === filterMode;
            });

            document.getElementById('libraryTitle').textContent =
                filterMode === 'all' ? 'All Games' :
                filterMode === 'ecs' ? 'ECS Games' : 'CHIP-8 ROMs';

            games.forEach(game => {
                const card = document.createElement('div');
                card.className = `cartridge-card ${game.type === 'emulator' ? 'emulator-cart' : ''}`;
                card.innerHTML = `
                    <div class="cartridge-preview">
                        <canvas width="200" height="100"></canvas>
                        <span class="cart-type-badge ${game.type}">${game.type === 'emulator' ? 'ROM' : 'ECS'}</span>
                    </div>
                    <div class="cartridge-info">
                        <div class="cartridge-title">${game.meta.title}</div>
                        <div class="cartridge-genre">${game.meta.genre}</div>
                    </div>
                `;
                card.onclick = () => selectGame(game);
                grid.appendChild(card);

                // Draw preview
                const previewCanvas = card.querySelector('canvas');
                drawPreview(previewCanvas, game);
            });
        }

        function drawPreview(canvas, game) {
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (game.type === 'emulator') {
                // Draw pixelated ROM preview
                ctx.fillStyle = game.meta.id === 'maze' ? '#33ff66' : '#ff6600';
                for (let i = 0; i < 20; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    ctx.fillRect(x, y, 4, 4);
                }
                ctx.fillStyle = '#ff6600';
                ctx.font = '12px monospace';
                ctx.fillText('CHIP-8', 70, 55);
            } else {
                // Draw ECS preview shapes
                ctx.fillStyle = '#00ffcc';
                ctx.beginPath();
                ctx.moveTo(100, 30);
                ctx.lineTo(85, 60);
                ctx.lineTo(115, 60);
                ctx.closePath();
                ctx.fill();

                if (game.meta.id.includes('invader')) {
                    ctx.fillStyle = '#ff4466';
                    for (let i = 0; i < 3; i++) {
                        ctx.fillRect(60 + i * 30, 75, 15, 10);
                    }
                }
            }
        }

        function selectGame(game) {
            selectedGame = game;
            document.querySelectorAll('.cartridge-card').forEach(c => c.classList.remove('selected'));
            event.currentTarget.classList.add('selected');

            document.getElementById('detailTitle').textContent = game.meta.title;
            document.getElementById('detailDesc').textContent = game.meta.description;
            document.getElementById('detailMeta').innerHTML = `
                <div>Type: ${game.type === 'emulator' ? 'CHIP-8 ROM' : 'ECS Game'}</div>
                <div>Genre: ${game.meta.genre}</div>
            `;

            const controlsList = document.getElementById('controlsList');
            controlsList.innerHTML = '';
            for (const [key, action] of Object.entries(game.controls)) {
                controlsList.innerHTML += `<div class="control-row"><span class="control-key">${key}</span><span>${action}</span></div>`;
            }
            document.getElementById('detailControls').style.display = 'block';

            const btn = document.getElementById('playButton');
            btn.disabled = false;
            btn.textContent = 'PLAY';
            btn.className = `btn btn-primary ${game.type === 'emulator' ? 'emulator' : ''}`;
        }

        function startGame() {
            if (!selectedGame) return;

            gameMode = selectedGame.type;
            currentGame = selectedGame;
            state = {};

            document.getElementById('launcher').classList.add('hidden');
            document.getElementById('gameScreen').classList.add('active');
            document.getElementById('gameTitleBar').textContent = currentGame.meta.title;

            if (gameMode === 'emulator') {
                chip8 = new Chip8();
                chip8.loadROM(new Uint8Array(currentGame.rom));
                canvas.width = 640;
                canvas.height = 320;
                document.getElementById('crtOverlay').style.display = 'block';
                document.getElementById('crtOverlay').style.width = canvas.width + 'px';
                document.getElementById('crtOverlay').style.height = canvas.height + 'px';
                document.getElementById('debugBtn').style.display = 'block';
                document.getElementById('gameStats').innerHTML = `
                    <div class="stat-item"><span class="stat-label">PC:</span><span class="stat-value" id="statPC">0x200</span></div>
                    <div class="stat-item"><span class="stat-label">Cycles:</span><span class="stat-value" id="statCycles">0</span></div>
                `;
            } else {
                world = new ECSWorld();
                canvas.width = 800;
                canvas.height = 600;
                document.getElementById('crtOverlay').style.display = 'none';
                document.getElementById('debugBtn').style.display = 'none';
                currentGame.setup(world, state, canvas);
                updateHUD();
            }

            running = true;
            paused = false;
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        function exitGame() {
            running = false;
            document.getElementById('launcher').classList.remove('hidden');
            document.getElementById('gameScreen').classList.remove('active');
            document.getElementById('pauseOverlay').classList.remove('visible');
            document.getElementById('gameoverOverlay').classList.remove('visible');
            document.getElementById('emulatorDebug').classList.remove('visible');
        }

        function togglePause() {
            paused = !paused;
            document.getElementById('pauseOverlay').classList.toggle('visible', paused);
        }

        function restartGame() {
            document.getElementById('pauseOverlay').classList.remove('visible');
            document.getElementById('gameoverOverlay').classList.remove('visible');
            startGame();
        }

        function toggleDebug() {
            document.getElementById('emulatorDebug').classList.toggle('visible');
        }

        function updateHUD() {
            if (gameMode !== 'ecs') return;
            const hud = currentGame.hud || [];
            let html = '';
            if (hud.includes('score')) html += `<div class="stat-item"><span class="stat-label">Score:</span><span class="stat-value">${state.score || 0}</span></div>`;
            if (hud.includes('lives')) html += `<div class="stat-item"><span class="stat-label">Lives:</span><span class="stat-value">${state.lives || 0}</span></div>`;
            if (hud.includes('cities')) html += `<div class="stat-item"><span class="stat-label">Cities:</span><span class="stat-value">${state.cities || 0}</span></div>`;
            if (hud.includes('wave')) html += `<div class="stat-item"><span class="stat-label">Wave:</span><span class="stat-value">${state.wave || 1}</span></div>`;
            document.getElementById('gameStats').innerHTML = html;
        }

        function gameOver() {
            running = false;
            document.getElementById('finalScore').textContent = `Score: ${state.score || 0}`;
            document.getElementById('gameoverOverlay').classList.add('visible');
        }

        // ═══════════════════════════════════════════════════════════════════════════
        // ECS SYSTEMS
        // ═══════════════════════════════════════════════════════════════════════════

        function spawnAsteroid(world, canvas, size) {
            const a = world.createEntity();
            const edge = Math.floor(Math.random() * 4);
            let x, y;
            if (edge === 0) { x = Math.random() * canvas.width; y = -20; }
            else if (edge === 1) { x = canvas.width + 20; y = Math.random() * canvas.height; }
            else if (edge === 2) { x = Math.random() * canvas.width; y = canvas.height + 20; }
            else { x = -20; y = Math.random() * canvas.height; }

            world.addComponent(a, 'Transform', { x, y, rot: Math.random() * Math.PI * 2 });
            world.addComponent(a, 'Velocity', { vx: (Math.random() - 0.5) * 100, vy: (Math.random() - 0.5) * 100, rotSpeed: (Math.random() - 0.5) * 2 });
            world.addComponent(a, 'Sprite', { type: 'asteroid', color: '#888', size });
            world.addComponent(a, 'Collider', { radius: size * 0.8, group: 'asteroid' });
            world.addComponent(a, 'Asteroid', { size });
        }

        function runECSSystems(dt) {
            const systems = currentGame.systems || [];

            // Player ship system (asteroids)
            if (systems.includes('playerShip')) {
                for (const id of world.query('Player', 'Transform', 'Velocity')) {
                    const p = world.getComponent(id, 'Player');
                    const t = world.getComponent(id, 'Transform');
                    const v = world.getComponent(id, 'Velocity');

                    if (keys['a'] || keys['arrowleft']) t.rot -= p.rotSpeed * dt;
                    if (keys['d'] || keys['arrowright']) t.rot += p.rotSpeed * dt;
                    if (keys['w'] || keys['arrowup']) {
                        v.vx += Math.cos(t.rot - Math.PI/2) * p.thrust * dt;
                        v.vy += Math.sin(t.rot - Math.PI/2) * p.thrust * dt;
                    }

                    p.fireCooldown -= dt;
                    if (keys[' '] && p.fireCooldown <= 0) {
                        p.fireCooldown = p.fireRate;
                        const b = world.createEntity();
                        world.addComponent(b, 'Transform', { x: t.x, y: t.y, rot: t.rot });
                        world.addComponent(b, 'Velocity', {
                            vx: Math.cos(t.rot - Math.PI/2) * 500,
                            vy: Math.sin(t.rot - Math.PI/2) * 500
                        });
                        world.addComponent(b, 'Sprite', { type: 'bullet', color: '#ffff00', size: 3 });
                        world.addComponent(b, 'Collider', { radius: 3, group: 'bullet' });
                        world.addComponent(b, 'Lifetime', { remaining: 1 });
                    }
                }
            }

            // Player invaders system
            if (systems.includes('playerInvaders')) {
                for (const id of world.query('Player', 'Transform')) {
                    const p = world.getComponent(id, 'Player');
                    const t = world.getComponent(id, 'Transform');

                    if (keys['a'] || keys['arrowleft']) t.x -= p.moveSpeed * dt;
                    if (keys['d'] || keys['arrowright']) t.x += p.moveSpeed * dt;
                    t.x = Math.max(20, Math.min(canvas.width - 20, t.x));

                    p.fireCooldown -= dt;
                    if (keys[' '] && p.fireCooldown <= 0) {
                        p.fireCooldown = p.fireRate;
                        const b = world.createEntity();
                        world.addComponent(b, 'Transform', { x: t.x, y: t.y - 20 });
                        world.addComponent(b, 'Velocity', { vx: 0, vy: -500 });
                        world.addComponent(b, 'Sprite', { type: 'bullet', color: '#ffff00', size: 4 });
                        world.addComponent(b, 'Collider', { radius: 4, group: 'bullet' });
                        world.addComponent(b, 'Lifetime', { remaining: 2 });
                    }
                }
            }

            // Invader AI
            if (systems.includes('invaderAI')) {
                state.invaderTimer += dt;
                if (state.invaderTimer >= state.invaderSpeed) {
                    state.invaderTimer = 0;
                    const invaders = world.query('Invader', 'Transform');
                    let hitEdge = false;

                    for (const id of invaders) {
                        const t = world.getComponent(id, 'Transform');
                        t.x += state.invaderDir * 15;
                        if (t.x < 30 || t.x > canvas.width - 30) hitEdge = true;
                    }

                    if (hitEdge) {
                        state.invaderDir *= -1;
                        for (const id of invaders) {
                            world.getComponent(id, 'Transform').y += 20;
                        }
                    }
                }
            }

            // Asteroid AI
            if (systems.includes('asteroidAI')) {
                const asteroids = world.query('Asteroid');
                if (asteroids.length < 3) spawnAsteroid(world, canvas, 30 + Math.random() * 20);
            }

            // Movement system
            if (systems.includes('movement')) {
                for (const id of world.query('Transform', 'Velocity')) {
                    const t = world.getComponent(id, 'Transform');
                    const v = world.getComponent(id, 'Velocity');

                    t.x += v.vx * dt;
                    t.y += v.vy * dt;
                    if (v.rotSpeed) t.rot += v.rotSpeed * dt;
                    if (v.drag) { v.vx *= v.drag; v.vy *= v.drag; }

                    // Screen wrap
                    if (t.x < -20) t.x = canvas.width + 20;
                    if (t.x > canvas.width + 20) t.x = -20;
                    if (t.y < -20) t.y = canvas.height + 20;
                    if (t.y > canvas.height + 20) t.y = -20;
                }
            }

            // Lifetime
            for (const id of world.query('Lifetime')) {
                const l = world.getComponent(id, 'Lifetime');
                l.remaining -= dt;
                if (l.remaining <= 0) world.destroyEntity(id);
            }

            // Collision
            if (systems.includes('collision')) {
                const bullets = world.query('Collider', 'Transform').filter(id => world.getComponent(id, 'Collider').group === 'bullet');
                const enemies = world.query('Collider', 'Transform').filter(id => {
                    const g = world.getComponent(id, 'Collider').group;
                    return g === 'asteroid' || g === 'enemy';
                });

                for (const bid of bullets) {
                    const bt = world.getComponent(bid, 'Transform');
                    const bc = world.getComponent(bid, 'Collider');

                    for (const eid of enemies) {
                        const et = world.getComponent(eid, 'Transform');
                        const ec = world.getComponent(eid, 'Collider');

                        const dx = bt.x - et.x, dy = bt.y - et.y;
                        if (Math.sqrt(dx*dx + dy*dy) < bc.radius + ec.radius) {
                            world.destroyEntity(bid);
                            world.destroyEntity(eid);
                            state.score += 100;

                            // Split asteroid
                            const ast = world.getComponent(eid, 'Asteroid');
                            if (ast && ast.size > 15) {
                                for (let i = 0; i < 2; i++) {
                                    const a = world.createEntity();
                                    world.addComponent(a, 'Transform', { x: et.x, y: et.y, rot: Math.random() * Math.PI * 2 });
                                    world.addComponent(a, 'Velocity', { vx: (Math.random() - 0.5) * 150, vy: (Math.random() - 0.5) * 150, rotSpeed: (Math.random() - 0.5) * 3 });
                                    world.addComponent(a, 'Sprite', { type: 'asteroid', color: '#888', size: ast.size * 0.6 });
                                    world.addComponent(a, 'Collider', { radius: ast.size * 0.5, group: 'asteroid' });
                                    world.addComponent(a, 'Asteroid', { size: ast.size * 0.6 });
                                }
                            }
                            break;
                        }
                    }
                }
            }

            // Snake system
            if (systems.includes('snake')) {
                state.moveTimer += dt;
                if (state.moveTimer >= state.moveInterval) {
                    state.moveTimer = 0;
                    state.dir = { ...state.nextDir };

                    const head = state.snake[0];
                    const newHead = { x: head.x + state.dir.x, y: head.y + state.dir.y };

                    // Check collision
                    if (newHead.x < 0 || newHead.x >= 40 || newHead.y < 0 || newHead.y >= 30) {
                        gameOver();
                        return;
                    }

                    for (const seg of state.snake) {
                        if (seg.x === newHead.x && seg.y === newHead.y) {
                            gameOver();
                            return;
                        }
                    }

                    state.snake.unshift(newHead);

                    if (newHead.x === state.food.x && newHead.y === state.food.y) {
                        state.score += 10;
                        state.food = {
                            x: Math.floor(Math.random() * 40),
                            y: Math.floor(Math.random() * 30)
                        };
                    } else {
                        state.snake.pop();
                    }
                }

                if ((keys['w'] || keys['arrowup']) && state.dir.y !== 1) state.nextDir = { x: 0, y: -1 };
                if ((keys['s'] || keys['arrowdown']) && state.dir.y !== -1) state.nextDir = { x: 0, y: 1 };
                if ((keys['a'] || keys['arrowleft']) && state.dir.x !== 1) state.nextDir = { x: -1, y: 0 };
                if ((keys['d'] || keys['arrowright']) && state.dir.x !== -1) state.nextDir = { x: 1, y: 0 };
            }

            // Paddle system
            if (systems.includes('paddle')) {
                for (const id of world.query('Paddle', 'Transform')) {
                    const p = world.getComponent(id, 'Paddle');
                    const t = world.getComponent(id, 'Transform');
                    if (keys['a'] || keys['arrowleft']) t.x -= p.speed * dt;
                    if (keys['d'] || keys['arrowright']) t.x += p.speed * dt;
                    t.x = Math.max(50, Math.min(canvas.width - 50, t.x));
                }
            }

            // Ball physics
            if (systems.includes('ballPhysics')) {
                for (const bid of world.query('Ball', 'Transform', 'Velocity')) {
                    const bt = world.getComponent(bid, 'Transform');
                    const bv = world.getComponent(bid, 'Velocity');

                    // Wall bounce
                    if (bt.x < 10 || bt.x > canvas.width - 10) bv.vx *= -1;
                    if (bt.y < 10) bv.vy *= -1;
                    if (bt.y > canvas.height) {
                        state.lives--;
                        if (state.lives <= 0) { gameOver(); return; }
                        bt.x = canvas.width / 2;
                        bt.y = canvas.height - 60;
                        bv.vx = 200;
                        bv.vy = -300;
                    }

                    // Paddle collision
                    for (const pid of world.query('Paddle', 'Transform')) {
                        const pt = world.getComponent(pid, 'Transform');
                        if (bt.y > pt.y - 15 && bt.y < pt.y + 5 &&
                            bt.x > pt.x - 45 && bt.x < pt.x + 45) {
                            bv.vy = -Math.abs(bv.vy);
                            bv.vx = (bt.x - pt.x) * 5;
                        }
                    }

                    // Brick collision
                    for (const brid of world.query('Brick', 'Transform', 'Sprite')) {
                        const brt = world.getComponent(brid, 'Transform');
                        const brs = world.getComponent(brid, 'Sprite');
                        if (bt.x > brt.x - brs.w/2 && bt.x < brt.x + brs.w/2 &&
                            bt.y > brt.y - brs.h/2 && bt.y < brt.y + brs.h/2) {
                            world.destroyEntity(brid);
                            bv.vy *= -1;
                            state.score += 10;
                            break;
                        }
                    }
                }
            }

            // Twin-stick player (Geometry Swarm)
            if (systems.includes('twinStick')) {
                for (const id of world.query('Player', 'Transform', 'Velocity')) {
                    const p = world.getComponent(id, 'Player');
                    const t = world.getComponent(id, 'Transform');
                    const v = world.getComponent(id, 'Velocity');

                    v.vx = 0; v.vy = 0;
                    if (keys['w'] || keys['arrowup']) v.vy = -p.speed;
                    if (keys['s'] || keys['arrowdown']) v.vy = p.speed;
                    if (keys['a'] || keys['arrowleft']) v.vx = -p.speed;
                    if (keys['d'] || keys['arrowright']) v.vx = p.speed;

                    t.x = Math.max(15, Math.min(canvas.width - 15, t.x));
                    t.y = Math.max(15, Math.min(canvas.height - 15, t.y));

                    // Auto-fire at nearest enemy
                    state.fireTimer -= dt;
                    if (state.fireTimer <= 0) {
                        state.fireTimer = p.fireRate;
                        const enemies = world.query('Enemy', 'Transform');
                        if (enemies.length > 0) {
                            let nearest = null, minDist = Infinity;
                            for (const eid of enemies) {
                                const et = world.getComponent(eid, 'Transform');
                                const dx = et.x - t.x, dy = et.y - t.y;
                                const dist = Math.sqrt(dx*dx + dy*dy);
                                if (dist < minDist) { minDist = dist; nearest = et; }
                            }
                            if (nearest) {
                                const dx = nearest.x - t.x, dy = nearest.y - t.y;
                                const len = Math.sqrt(dx*dx + dy*dy);
                                const b = world.createEntity();
                                world.addComponent(b, 'Transform', { x: t.x, y: t.y });
                                world.addComponent(b, 'Velocity', { vx: (dx/len) * 500, vy: (dy/len) * 500 });
                                world.addComponent(b, 'Sprite', { type: 'circle', color: '#ffff00', size: 4 });
                                world.addComponent(b, 'Collider', { radius: 4, group: 'bullet' });
                                world.addComponent(b, 'Lifetime', { remaining: 1.5 });
                            }
                        }
                    }
                }
            }

            // Geometry spawner
            if (systems.includes('geometrySpawner')) {
                state.spawnTimer -= dt;
                if (state.spawnTimer <= 0) {
                    state.spawnTimer = 1.5 - Math.min(state.score / 2000, 1);
                    const shapes = ['diamond', 'square', 'triangle'];
                    const colors = ['#ff4466', '#ffaa00', '#aa44ff', '#ff8844'];
                    const edge = Math.floor(Math.random() * 4);
                    let x, y;
                    if (edge === 0) { x = Math.random() * canvas.width; y = -20; }
                    else if (edge === 1) { x = canvas.width + 20; y = Math.random() * canvas.height; }
                    else if (edge === 2) { x = Math.random() * canvas.width; y = canvas.height + 20; }
                    else { x = -20; y = Math.random() * canvas.height; }

                    const e = world.createEntity();
                    world.addComponent(e, 'Transform', { x, y, rot: 0 });
                    const player = world.query('Player', 'Transform')[0];
                    const pt = player ? world.getComponent(player, 'Transform') : { x: canvas.width/2, y: canvas.height/2 };
                    const dx = pt.x - x, dy = pt.y - y;
                    const len = Math.sqrt(dx*dx + dy*dy);
                    const speed = 80 + Math.random() * 60;
                    world.addComponent(e, 'Velocity', { vx: (dx/len) * speed, vy: (dy/len) * speed, rotSpeed: (Math.random() - 0.5) * 3 });
                    world.addComponent(e, 'Sprite', { type: shapes[Math.floor(Math.random() * shapes.length)], color: colors[Math.floor(Math.random() * colors.length)], size: 10 + Math.random() * 8 });
                    world.addComponent(e, 'Collider', { radius: 12, group: 'enemy' });
                    world.addComponent(e, 'Enemy', {});
                }
            }

            // Missile Defense
            if (systems.includes('missileDefense')) {
                // Spawn missiles
                state.missileTimer -= dt;
                if (state.missileTimer <= 0) {
                    state.missileTimer = 2 - Math.min(state.wave * 0.1, 1.5);
                    const m = world.createEntity();
                    const startX = Math.random() * canvas.width;
                    const cities = world.query('City', 'Transform');
                    const targetCity = cities[Math.floor(Math.random() * cities.length)];
                    const targetX = targetCity ? world.getComponent(targetCity, 'Transform').x : canvas.width/2;
                    world.addComponent(m, 'Transform', { x: startX, y: -10 });
                    const dx = targetX - startX, dy = canvas.height - 20;
                    const len = Math.sqrt(dx*dx + dy*dy);
                    world.addComponent(m, 'Velocity', { vx: (dx/len) * 80, vy: (dy/len) * 80 });
                    world.addComponent(m, 'Sprite', { type: 'missile', color: '#ff4444', size: 6 });
                    world.addComponent(m, 'Missile', { targetX });
                    world.addComponent(m, 'Collider', { radius: 6, group: 'enemy' });
                }

                // Handle click - launch interceptor
                if (state.pendingClick) {
                    const click = state.pendingClick;
                    state.pendingClick = null;
                    const i = world.createEntity();
                    world.addComponent(i, 'Transform', { x: canvas.width/2, y: canvas.height - 30 });
                    const dx = click.x - canvas.width/2, dy = click.y - (canvas.height - 30);
                    const len = Math.sqrt(dx*dx + dy*dy);
                    world.addComponent(i, 'Velocity', { vx: (dx/len) * 300, vy: (dy/len) * 300 });
                    world.addComponent(i, 'Sprite', { type: 'circle', color: '#4488ff', size: 5 });
                    world.addComponent(i, 'Interceptor', { targetX: click.x, targetY: click.y });
                    world.addComponent(i, 'Collider', { radius: 20, group: 'bullet' });
                }

                // Check interceptor explosions
                for (const id of world.query('Interceptor', 'Transform')) {
                    const t = world.getComponent(id, 'Transform');
                    const i = world.getComponent(id, 'Interceptor');
                    const dx = i.targetX - t.x, dy = i.targetY - t.y;
                    if (Math.sqrt(dx*dx + dy*dy) < 10) {
                        world.destroyEntity(id);
                        // Create explosion
                        const exp = world.createEntity();
                        world.addComponent(exp, 'Transform', { x: t.x, y: t.y });
                        world.addComponent(exp, 'Sprite', { type: 'explosion', color: '#ff8844', size: 40 });
                        world.addComponent(exp, 'Lifetime', { remaining: 0.5 });
                        world.addComponent(exp, 'Collider', { radius: 40, group: 'bullet' });
                    }
                }

                // Check missiles hitting cities
                for (const mid of world.query('Missile', 'Transform')) {
                    const mt = world.getComponent(mid, 'Transform');
                    if (mt.y > canvas.height - 40) {
                        for (const cid of world.query('City', 'Transform')) {
                            const ct = world.getComponent(cid, 'Transform');
                            if (Math.abs(mt.x - ct.x) < 30) {
                                world.destroyEntity(cid);
                                state.cities--;
                                if (state.cities <= 0) { gameOver(); return; }
                                break;
                            }
                        }
                        world.destroyEntity(mid);
                    }
                }

                // Wave progression
                const missiles = world.query('Missile');
                if (missiles.length === 0 && state.missileTimer < 1) {
                    state.wave++;
                    state.score += 100 * state.wave;
                }
            }

            world.flushDestroy();
        }

        // ═══════════════════════════════════════════════════════════════════════════
        // RENDERING
        // ═══════════════════════════════════════════════════════════════════════════

        function renderECS() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Snake rendering
            if (currentGame.systems?.includes('snake')) {
                const grid = 20;
                ctx.fillStyle = '#00ff88';
                for (const seg of state.snake) {
                    ctx.fillRect(seg.x * grid, seg.y * grid, grid - 2, grid - 2);
                }
                ctx.fillStyle = '#ff4466';
                ctx.fillRect(state.food.x * grid, state.food.y * grid, grid - 2, grid - 2);
                return;
            }

            // Entity rendering
            for (const id of world.query('Transform', 'Sprite')) {
                const t = world.getComponent(id, 'Transform');
                const s = world.getComponent(id, 'Sprite');

                ctx.save();
                ctx.translate(t.x, t.y);
                if (t.rot) ctx.rotate(t.rot);

                ctx.fillStyle = s.color;
                ctx.strokeStyle = s.color;
                ctx.lineWidth = 2;

                switch (s.type) {
                    case 'ship':
                        ctx.beginPath();
                        ctx.moveTo(0, -s.size);
                        ctx.lineTo(-s.size * 0.7, s.size * 0.7);
                        ctx.lineTo(0, s.size * 0.3);
                        ctx.lineTo(s.size * 0.7, s.size * 0.7);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case 'asteroid':
                        ctx.beginPath();
                        for (let i = 0; i < 8; i++) {
                            const angle = (i / 8) * Math.PI * 2;
                            const r = s.size * (0.7 + Math.sin(i * 3) * 0.3);
                            if (i === 0) ctx.moveTo(Math.cos(angle) * r, Math.sin(angle) * r);
                            else ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
                        }
                        ctx.closePath();
                        ctx.stroke();
                        break;
                    case 'invader':
                        ctx.fillRect(-s.size, -s.size/2, s.size * 2, s.size);
                        ctx.fillRect(-s.size * 0.6, -s.size, s.size * 0.4, s.size/2);
                        ctx.fillRect(s.size * 0.2, -s.size, s.size * 0.4, s.size/2);
                        break;
                    case 'bullet':
                        ctx.beginPath();
                        ctx.arc(0, 0, s.size, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 'rect':
                        ctx.fillRect(-s.w/2, -s.h/2, s.w, s.h);
                        break;
                    case 'circle':
                        ctx.beginPath();
                        ctx.arc(0, 0, s.size, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 'diamond':
                        ctx.beginPath();
                        ctx.moveTo(0, -s.size);
                        ctx.lineTo(s.size, 0);
                        ctx.lineTo(0, s.size);
                        ctx.lineTo(-s.size, 0);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case 'square':
                        ctx.fillRect(-s.size, -s.size, s.size * 2, s.size * 2);
                        break;
                    case 'triangle':
                        ctx.beginPath();
                        ctx.moveTo(0, -s.size);
                        ctx.lineTo(s.size, s.size);
                        ctx.lineTo(-s.size, s.size);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case 'city':
                        // Building shape
                        ctx.fillRect(-s.size/2, -s.size, s.size, s.size);
                        ctx.fillRect(-s.size, -s.size/2, s.size * 2, s.size/2);
                        break;
                    case 'missile':
                        ctx.beginPath();
                        ctx.moveTo(0, -s.size);
                        ctx.lineTo(s.size/2, s.size);
                        ctx.lineTo(-s.size/2, s.size);
                        ctx.closePath();
                        ctx.fill();
                        // Trail
                        ctx.strokeStyle = s.color;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(0, s.size);
                        ctx.lineTo(0, s.size + 15);
                        ctx.stroke();
                        break;
                    case 'explosion':
                        ctx.globalAlpha = 0.7;
                        ctx.beginPath();
                        ctx.arc(0, 0, s.size, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                        break;
                }

                ctx.restore();
            }
        }

        function renderEmulator() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#33ff66';
            const scale = 10;
            for (let y = 0; y < 32; y++) {
                for (let x = 0; x < 64; x++) {
                    if (chip8.display[y * 64 + x]) {
                        ctx.fillRect(x * scale, y * scale, scale, scale);
                    }
                }
            }

            // Update debug
            if (document.getElementById('emulatorDebug').classList.contains('visible')) {
                const regs = document.getElementById('debugRegisters');
                regs.innerHTML = '';
                for (let i = 0; i < 16; i++) {
                    regs.innerHTML += `<div class="reg"><span class="reg-name">V${i.toString(16).toUpperCase()}</span><span class="reg-val">${chip8.V[i].toString(16).padStart(2, '0').toUpperCase()}</span></div>`;
                }
                document.getElementById('debugPC').textContent = '0x' + chip8.PC.toString(16).toUpperCase();
                document.getElementById('debugI').textContent = '0x' + chip8.I.toString(16).toUpperCase();
                document.getElementById('debugCycles').textContent = chip8.cycles;
            }

            document.getElementById('statPC').textContent = '0x' + chip8.PC.toString(16).toUpperCase();
            document.getElementById('statCycles').textContent = chip8.cycles;
        }

        // ═══════════════════════════════════════════════════════════════════════════
        // GAME LOOP
        // ═══════════════════════════════════════════════════════════════════════════

        let cycleAccum = 0;
        let timerAccum = 0;

        function gameLoop(timestamp) {
            if (!running) return;

            const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
            lastTime = timestamp;

            if (!paused) {
                if (gameMode === 'emulator') {
                    // CHIP-8 at 500Hz
                    cycleAccum += dt;
                    while (cycleAccum >= 0.002) {
                        chip8.cycle();
                        cycleAccum -= 0.002;
                    }

                    // Timers at 60Hz
                    timerAccum += dt;
                    if (timerAccum >= 1/60) {
                        chip8.updateTimers();
                        timerAccum -= 1/60;
                    }

                    if (chip8.drawFlag) {
                        renderEmulator();
                        chip8.drawFlag = false;
                    }
                } else {
                    runECSSystems(dt);
                    renderECS();
                    updateHUD();
                }
            }

            requestAnimationFrame(gameLoop);
        }

        // ═══════════════════════════════════════════════════════════════════════════
        // INPUT
        // ═══════════════════════════════════════════════════════════════════════════

        document.addEventListener('keydown', e => {
            const key = e.key.toLowerCase();
            keys[key] = true;

            if (gameMode === 'emulator' && chip8Keys[key] !== undefined) {
                chip8.keyDown(chip8Keys[key]);
            }

            if (key === 'escape') togglePause();
        });

        document.addEventListener('keyup', e => {
            const key = e.key.toLowerCase();
            keys[key] = false;

            if (gameMode === 'emulator' && chip8Keys[key] !== undefined) {
                chip8.keyUp(chip8Keys[key]);
            }
        });

        // Canvas click for Missile Defense
        canvas.addEventListener('click', e => {
            if (gameMode === 'ecs' && currentGame?.meta.id === 'missile-defense' && !paused) {
                const rect = canvas.getBoundingClientRect();
                state.pendingClick = {
                    x: (e.clientX - rect.left) * (canvas.width / rect.width),
                    y: (e.clientY - rect.top) * (canvas.height / rect.height)
                };
            }
        });

        // Initialize
        initUI();
    </script>
</body>
</html>
