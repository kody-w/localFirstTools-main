<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ECHO CHAMBER - Voice-Driven Dungeon</title>
    <meta name="description" content="A dungeon crawler where your voice shapes the world. Speak softly for stealth, shout for combat. The dungeon responds to YOUR sound.">
    <meta name="theme-color" content="#0a0a0a">
    <meta name="color-scheme" content="dark">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #0a0a0a;
            font-family: 'Segoe UI', system-ui, sans-serif;
            color: #fff;
        }

        #game-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* HUD Elements */
        .hud {
            position: fixed;
            z-index: 100;
            pointer-events: none;
        }

        #volume-meter {
            left: 30px;
            top: 50%;
            transform: translateY(-50%);
            width: 30px;
            height: 200px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #444;
            border-radius: 15px;
            overflow: hidden;
        }

        #volume-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(to top, #00ff88, #ffff00, #ff4444);
            transition: height 0.05s;
        }

        .volume-label {
            position: absolute;
            right: -60px;
            font-size: 10px;
            color: #888;
        }

        #stats-panel {
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #333;
        }

        #stats-panel h2 {
            font-size: 16px;
            color: #00ff88;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 14px;
        }

        .stat-label {
            color: #888;
        }

        .stat-value {
            color: #fff;
            font-weight: bold;
        }

        .health-bar {
            width: 150px;
            height: 12px;
            background: #333;
            border-radius: 6px;
            overflow: hidden;
            margin-top: 10px;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ff8844, #00ff88);
            transition: width 0.3s;
        }

        #mode-indicator {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 30px;
            border-radius: 25px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 3px;
            transition: all 0.3s;
        }

        #mode-indicator.stealth {
            border: 2px solid #00ff88;
            color: #00ff88;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }

        #mode-indicator.normal {
            border: 2px solid #ffff00;
            color: #ffff00;
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.3);
        }

        #mode-indicator.combat {
            border: 2px solid #ff4444;
            color: #ff4444;
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.3);
            animation: pulse-combat 0.5s infinite;
        }

        @keyframes pulse-combat {
            0%, 100% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.05); }
        }

        #instructions {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 30px;
            border-radius: 10px;
            text-align: center;
            max-width: 500px;
        }

        #instructions h3 {
            color: #00ff88;
            margin-bottom: 10px;
        }

        #instructions p {
            color: #888;
            font-size: 13px;
            line-height: 1.6;
        }

        #minimap {
            top: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #333;
            border-radius: 10px;
            overflow: hidden;
        }

        #minimap canvas {
            width: 100%;
            height: 100%;
        }

        /* Start Screen */
        #start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        #start-screen h1 {
            font-size: 64px;
            color: #00ff88;
            text-shadow: 0 0 30px #00ff88;
            margin-bottom: 20px;
            letter-spacing: 10px;
        }

        #start-screen p {
            color: #888;
            font-size: 18px;
            margin-bottom: 40px;
            text-align: center;
            max-width: 500px;
            line-height: 1.8;
        }

        #start-btn {
            padding: 20px 60px;
            font-size: 20px;
            background: transparent;
            border: 3px solid #00ff88;
            color: #00ff88;
            cursor: pointer;
            border-radius: 50px;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        #start-btn:hover {
            background: #00ff88;
            color: #000;
            box-shadow: 0 0 40px #00ff88;
        }

        .mic-permission {
            margin-top: 30px;
            padding: 15px 25px;
            background: rgba(255, 68, 68, 0.2);
            border: 1px solid #ff4444;
            border-radius: 8px;
            color: #ff8888;
            font-size: 14px;
        }

        /* Level complete */
        #level-complete {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px 60px;
            border-radius: 20px;
            border: 3px solid #00ff88;
            text-align: center;
            display: none;
            z-index: 500;
        }

        #level-complete h2 {
            color: #00ff88;
            font-size: 36px;
            margin-bottom: 20px;
        }

        #level-complete .stats {
            color: #888;
            margin-bottom: 30px;
        }

        #level-complete button {
            padding: 15px 40px;
            font-size: 16px;
            background: #00ff88;
            border: none;
            color: #000;
            cursor: pointer;
            border-radius: 8px;
        }

        /* Pitch indicator */
        #pitch-indicator {
            right: 30px;
            top: 50%;
            transform: translateY(-50%);
            width: 30px;
            height: 200px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #444;
            border-radius: 15px;
            overflow: hidden;
        }

        #pitch-marker {
            position: absolute;
            left: 5px;
            width: 20px;
            height: 4px;
            background: #ff00ff;
            border-radius: 2px;
            transition: top 0.1s;
        }

        .pitch-zones {
            position: absolute;
            left: -50px;
            width: 45px;
            text-align: right;
            font-size: 9px;
            color: #666;
        }
    </style>
</head>
<body>
    <div id="start-screen">
        <h1>ECHO CHAMBER</h1>
        <p>
            Your voice shapes the dungeon.<br>
            <strong style="color: #00ff88;">Whisper</strong> for stealth and narrow passages.<br>
            <strong style="color: #ffff00;">Speak normally</strong> for exploration.<br>
            <strong style="color: #ff4444;">SHOUT</strong> for combat and open arenas.
        </p>
        <button id="start-btn" onclick="startGame()">ENTER THE CHAMBER</button>
        <button id="keyboard-btn" onclick="startGame(true)" style="margin-top: 15px; padding: 12px 40px; font-size: 14px; background: transparent; border: 2px solid #888; color: #888; cursor: pointer; border-radius: 30px; transition: all 0.3s;">KEYBOARD MODE (No Mic)</button>
        <div style="margin-top: 20px; font-size: 12px; color: #666; max-width: 400px; text-align: center;">
            <strong>Keyboard Mode:</strong> SPACE = Combat, SHIFT = Normal, Neither = Stealth<br>
            <strong>Pitch Powers:</strong> High pitch reveals enemies, Low growl stuns nearby foes
        </div>
        <div class="mic-permission" id="mic-warning" style="display: none;">
            Microphone access is required. Please allow microphone access and try again.
        </div>
    </div>

    <canvas id="game-canvas"></canvas>

    <div id="volume-meter" class="hud">
        <div id="volume-fill" style="height: 0%"></div>
        <span class="volume-label" style="bottom: 10%;">Stealth</span>
        <span class="volume-label" style="bottom: 40%;">Normal</span>
        <span class="volume-label" style="bottom: 75%;">Combat</span>
    </div>

    <div id="pitch-indicator" class="hud">
        <div id="pitch-marker" style="top: 50%"></div>
        <div class="pitch-zones" style="top: 10px;">High</div>
        <div class="pitch-zones" style="bottom: 10px;">Low</div>
    </div>

    <div id="stats-panel" class="hud">
        <h2>Echo Chamber</h2>
        <div class="stat-row">
            <span class="stat-label">Level</span>
            <span class="stat-value" id="level-num">1</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Echoes Found</span>
            <span class="stat-value" id="echoes-found">0 / 0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Enemies</span>
            <span class="stat-value" id="enemies-left">0</span>
        </div>
        <div class="health-bar">
            <div class="health-fill" id="health-bar" style="width: 100%"></div>
        </div>
    </div>

    <div id="mode-indicator" class="hud stealth">STEALTH</div>

    <div id="minimap" class="hud">
        <canvas id="minimap-canvas"></canvas>
    </div>

    <div id="instructions" class="hud">
        <h3>Your Voice Is Your Weapon</h3>
        <p>
            Use <strong>WASD</strong> or <strong>Arrow Keys</strong> to move.<br>
            Your voice volume controls corridor width and combat power.<br>
            <strong>Hum a steady tone</strong> to reveal secret passages.
        </p>
    </div>

    <div id="level-complete">
        <h2>LEVEL COMPLETE</h2>
        <div class="stats">
            <p>Echoes collected: <span id="final-echoes">0</span></p>
            <p>Enemies defeated: <span id="final-enemies">0</span></p>
            <p>Stealth bonus: <span id="stealth-bonus">0</span></p>
        </div>
        <button onclick="nextLevel()">NEXT LEVEL</button>
    </div>

    <script>
        // ========== AUDIO ANALYSIS ==========
        let audioContext, analyser, microphone, dataArray;
        let volume = 0;
        let pitch = 0;
        let isAudioActive = false;
        let humDuration = 0;
        const HUM_THRESHOLD = 2; // seconds of consistent pitch to trigger secret

        // ========== AUDIO FEEDBACK SYSTEM ==========
        let masterGain = null;
        let reverbNode = null;
        let ambientOsc = null;

        function initAudioFeedback() {
            if (!audioContext) return;

            masterGain = audioContext.createGain();
            masterGain.gain.value = 0.3;
            masterGain.connect(audioContext.destination);

            // Create convolver for reverb effect
            reverbNode = audioContext.createGain();
            reverbNode.gain.value = 0.5;
            reverbNode.connect(masterGain);

            // Ambient dungeon drone
            startAmbientDrone();
        }

        function startAmbientDrone() {
            if (ambientOsc) return;

            ambientOsc = audioContext.createOscillator();
            const ambientGain = audioContext.createGain();

            ambientOsc.type = 'sine';
            ambientOsc.frequency.value = 55; // Low A
            ambientGain.gain.value = 0.08;

            // Add slow LFO for movement
            const lfo = audioContext.createOscillator();
            const lfoGain = audioContext.createGain();
            lfo.frequency.value = 0.1;
            lfoGain.gain.value = 5;
            lfo.connect(lfoGain);
            lfoGain.connect(ambientOsc.frequency);

            ambientOsc.connect(ambientGain);
            ambientGain.connect(masterGain);
            lfo.start();
            ambientOsc.start();
        }

        function playFootstep() {
            if (!masterGain) return;
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.type = 'triangle';
            osc.frequency.value = 100 + Math.random() * 50;
            gain.gain.setValueAtTime(0.1, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            osc.connect(gain);
            gain.connect(masterGain);
            osc.start();
            osc.stop(audioContext.currentTime + 0.15);
        }

        function playEchoCollect() {
            if (!masterGain) return;
            const notes = [523.25, 659.25, 783.99]; // C E G
            notes.forEach((freq, i) => {
                setTimeout(() => {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    gain.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                    osc.connect(gain);
                    gain.connect(masterGain);
                    osc.start();
                    osc.stop(audioContext.currentTime + 0.5);
                }, i * 80);
            });
        }

        function playEnemyHit() {
            if (!masterGain) return;
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(200, audioContext.currentTime);
            osc.frequency.exponentialRampToValueAtTime(80, audioContext.currentTime + 0.2);
            gain.gain.setValueAtTime(0.2, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
            osc.connect(gain);
            gain.connect(masterGain);
            osc.start();
            osc.stop(audioContext.currentTime + 0.25);
        }

        function playSecretReveal() {
            if (!masterGain) return;
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(300, audioContext.currentTime);
            osc.frequency.exponentialRampToValueAtTime(800, audioContext.currentTime + 0.5);
            gain.gain.setValueAtTime(0.4, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.6);
            osc.connect(gain);
            gain.connect(masterGain);
            osc.start();
            osc.stop(audioContext.currentTime + 0.7);
        }

        // ========== PITCH POWERS ==========
        let pitchPowerActive = null;
        let pitchPowerCooldown = 0;

        function checkPitchPower() {
            if (pitchPowerCooldown > 0) {
                pitchPowerCooldown--;
                return;
            }

            // High pitch (> 0.7) = Reveal enemies on minimap
            if (pitch > 0.7 && volume > 0.2) {
                pitchPowerActive = 'reveal';
                for (const enemy of enemies) {
                    enemy.revealed = true;
                }
                pitchPowerCooldown = 60;
            }
            // Low pitch (< 0.3) + high volume = Stun nearby enemies
            else if (pitch < 0.3 && volume > 0.6) {
                pitchPowerActive = 'stun';
                for (const enemy of enemies) {
                    const dx = player.x - enemy.x;
                    const dy = player.y - enemy.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 150) {
                        enemy.stunned = 60; // 1 second stun
                        enemy.alerted = false;
                    }
                }
                pitchPowerCooldown = 120;
                // Visual feedback
                for (let i = 0; i < 30; i++) {
                    particles.push({
                        x: player.x,
                        y: player.y,
                        vx: Math.cos(i * Math.PI / 15) * 5,
                        vy: Math.sin(i * Math.PI / 15) * 5,
                        life: 40,
                        color: '#8800ff'
                    });
                }
            }
        }

        // ========== VISUAL SOUND FEEDBACK (Accessibility) ==========
        let soundWaves = [];

        function createSoundWave(x, y, volume, color) {
            soundWaves.push({
                x, y,
                radius: 10,
                maxRadius: 50 + volume * 150,
                alpha: 0.6,
                color
            });
        }

        function updateSoundWaves() {
            for (let i = soundWaves.length - 1; i >= 0; i--) {
                const wave = soundWaves[i];
                wave.radius += 3;
                wave.alpha -= 0.02;
                if (wave.alpha <= 0 || wave.radius >= wave.maxRadius) {
                    soundWaves.splice(i, 1);
                }
            }
        }

        function renderSoundWaves(ctx, camX, camY) {
            for (const wave of soundWaves) {
                ctx.beginPath();
                ctx.arc(wave.x - camX, wave.y - camY, wave.radius, 0, Math.PI * 2);
                ctx.strokeStyle = wave.color;
                ctx.globalAlpha = wave.alpha;
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
        }

        // Create visual waves when player makes sound
        let lastWaveTime = 0;
        function maybeCreatePlayerWave() {
            const now = Date.now();
            if (volume > 0.1 && now - lastWaveTime > 200) {
                let color = '#00ff88';
                if (volume > 0.5) color = '#ff4444';
                else if (volume > 0.2) color = '#ffff00';
                createSoundWave(player.x, player.y, volume, color);
                lastWaveTime = now;
            }
        }

        // ========== KEYBOARD SOUND FALLBACK ==========
        let keyboardSoundMode = false;
        let spaceHeld = false;
        let shiftHeld = false;

        function updateKeyboardSound() {
            if (!keyboardSoundMode) return;

            // Space = high volume, Shift = medium volume, neither = stealth
            if (spaceHeld) {
                volume = 0.7;
            } else if (shiftHeld) {
                volume = 0.35;
            } else {
                volume = 0.05;
            }

            // Update UI
            document.getElementById('volume-fill').style.height = `${volume * 100}%`;
            let mode = 'stealth';
            if (volume > 0.5) mode = 'combat';
            else if (volume > 0.2) mode = 'normal';

            const indicator = document.getElementById('mode-indicator');
            indicator.className = `hud ${mode}`;
            indicator.textContent = mode.toUpperCase() + ' (KB)';
        }

        async function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                analyser.smoothingTimeConstant = 0.8;

                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);

                dataArray = new Uint8Array(analyser.frequencyBinCount);
                isAudioActive = true;
                return true;
            } catch (err) {
                console.error('Microphone access denied:', err);
                document.getElementById('mic-warning').style.display = 'block';
                return false;
            }
        }

        function analyzeAudio() {
            if (!isAudioActive) return;

            analyser.getByteFrequencyData(dataArray);

            // Calculate volume (RMS)
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                sum += dataArray[i] * dataArray[i];
            }
            volume = Math.sqrt(sum / dataArray.length) / 255;

            // Calculate dominant pitch
            let maxIndex = 0;
            let maxValue = 0;
            for (let i = 0; i < dataArray.length / 2; i++) {
                if (dataArray[i] > maxValue) {
                    maxValue = dataArray[i];
                    maxIndex = i;
                }
            }
            pitch = maxIndex / (dataArray.length / 2);

            // Update UI
            document.getElementById('volume-fill').style.height = `${volume * 100}%`;
            document.getElementById('pitch-marker').style.top = `${(1 - pitch) * 100}%`;

            // Determine mode
            let mode = 'stealth';
            if (volume > 0.5) mode = 'combat';
            else if (volume > 0.2) mode = 'normal';

            const indicator = document.getElementById('mode-indicator');
            indicator.className = `hud ${mode}`;
            indicator.textContent = mode.toUpperCase();

            // Check for humming (consistent pitch)
            if (volume > 0.1 && volume < 0.3) {
                humDuration += 1/60;
                if (humDuration >= HUM_THRESHOLD) {
                    revealSecrets();
                }
            } else {
                humDuration = 0;
            }
        }

        // ========== GAME STATE ==========
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimap-canvas');
        const minimapCtx = minimapCanvas.getContext('2d');

        let gameStarted = false;
        let level = 1;
        let player = { x: 0, y: 0, health: 100, maxHealth: 100 };
        let dungeon = [];
        let echoes = [];
        let enemies = [];
        let particles = [];
        let secretsRevealed = false;
        let echoesCollected = 0;
        let enemiesDefeated = 0;
        let stealthKills = 0;

        const TILE_SIZE = 40;
        const CORRIDOR_MIN = 1;
        const CORRIDOR_MAX = 4;

        const keys = { w: false, a: false, s: false, d: false, up: false, down: false, left: false, right: false };

        // ========== DUNGEON GENERATION ==========
        function generateDungeon() {
            dungeon = [];
            echoes = [];
            enemies = [];
            secretsRevealed = false;
            echoesCollected = 0;

            const width = 40 + level * 5;
            const height = 30 + level * 3;

            // Initialize with walls
            for (let y = 0; y < height; y++) {
                dungeon[y] = [];
                for (let x = 0; x < width; x++) {
                    dungeon[y][x] = { type: 'wall', revealed: false, isSecret: false };
                }
            }

            // Carve rooms and corridors using BSP
            const rooms = [];
            function carveRoom(x, y, w, h) {
                for (let dy = 0; dy < h; dy++) {
                    for (let dx = 0; dx < w; dx++) {
                        if (y + dy < height && x + dx < width) {
                            dungeon[y + dy][x + dx].type = 'floor';
                        }
                    }
                }
                rooms.push({ x: x + Math.floor(w/2), y: y + Math.floor(h/2), w, h });
            }

            // Generate rooms
            const numRooms = 5 + level * 2;
            for (let i = 0; i < numRooms; i++) {
                const roomW = 4 + Math.floor(Math.random() * 6);
                const roomH = 4 + Math.floor(Math.random() * 6);
                const roomX = 2 + Math.floor(Math.random() * (width - roomW - 4));
                const roomY = 2 + Math.floor(Math.random() * (height - roomH - 4));
                carveRoom(roomX, roomY, roomW, roomH);
            }

            // Connect rooms with corridors
            for (let i = 1; i < rooms.length; i++) {
                const a = rooms[i - 1];
                const b = rooms[i];
                carveCorridor(a.x, a.y, b.x, b.y);
            }

            // Add secret passages
            for (let i = 0; i < 3 + level; i++) {
                const room = rooms[Math.floor(Math.random() * rooms.length)];
                const dirs = [[0, -1], [0, 1], [-1, 0], [1, 0]];
                const dir = dirs[Math.floor(Math.random() * dirs.length)];
                let sx = room.x, sy = room.y;

                // Find wall adjacent to room
                while (dungeon[sy]?.[sx]?.type === 'floor') {
                    sx += dir[0];
                    sy += dir[1];
                }

                // Make 2-3 tiles secret passage
                for (let j = 0; j < 2 + Math.floor(Math.random() * 2); j++) {
                    if (dungeon[sy]?.[sx]) {
                        dungeon[sy][sx].type = 'wall';
                        dungeon[sy][sx].isSecret = true;
                    }
                    sx += dir[0];
                    sy += dir[1];
                }
            }

            // Place player in first room
            player.x = rooms[0].x * TILE_SIZE;
            player.y = rooms[0].y * TILE_SIZE;

            // Place echoes (collectibles)
            const numEchoes = 3 + level * 2;
            for (let i = 0; i < numEchoes; i++) {
                const room = rooms[Math.floor(Math.random() * rooms.length)];
                echoes.push({
                    x: (room.x + (Math.random() - 0.5) * 4) * TILE_SIZE,
                    y: (room.y + (Math.random() - 0.5) * 4) * TILE_SIZE,
                    collected: false,
                    glow: 0
                });
            }

            // Place enemies
            const numEnemies = 2 + level * 2;
            for (let i = 0; i < numEnemies; i++) {
                const room = rooms[1 + Math.floor(Math.random() * (rooms.length - 1))];
                enemies.push({
                    x: room.x * TILE_SIZE,
                    y: room.y * TILE_SIZE,
                    health: 30 + level * 10,
                    maxHealth: 30 + level * 10,
                    speed: 0.5 + level * 0.1,
                    alerted: false,
                    patrolAngle: Math.random() * Math.PI * 2
                });
            }

            updateUI();
        }

        function carveCorridor(x1, y1, x2, y2) {
            let x = x1, y = y1;
            while (x !== x2 || y !== y2) {
                if (dungeon[y]?.[x]) {
                    dungeon[y][x].type = 'floor';
                }
                if (Math.random() < 0.5 && x !== x2) {
                    x += x < x2 ? 1 : -1;
                } else if (y !== y2) {
                    y += y < y2 ? 1 : -1;
                }
            }
        }

        function revealSecrets() {
            if (secretsRevealed) return;
            secretsRevealed = true;
            playSecretReveal();

            // Reveal secret passages near player
            const px = Math.floor(player.x / TILE_SIZE);
            const py = Math.floor(player.y / TILE_SIZE);
            const revealRadius = 5;

            for (let dy = -revealRadius; dy <= revealRadius; dy++) {
                for (let dx = -revealRadius; dx <= revealRadius; dx++) {
                    if (dungeon[py + dy]?.[px + dx]?.isSecret) {
                        dungeon[py + dy][px + dx].type = 'floor';
                        dungeon[py + dy][px + dx].isSecret = false;
                        // Particle effect
                        for (let i = 0; i < 10; i++) {
                            particles.push({
                                x: (px + dx) * TILE_SIZE + TILE_SIZE/2,
                                y: (py + dy) * TILE_SIZE + TILE_SIZE/2,
                                vx: (Math.random() - 0.5) * 3,
                                vy: (Math.random() - 0.5) * 3,
                                life: 60,
                                color: '#ff00ff'
                            });
                        }
                    }
                }
            }

            setTimeout(() => secretsRevealed = false, 3000);
        }

        // ========== GAME LOOP ==========
        function gameLoop() {
            if (!gameStarted) {
                requestAnimationFrame(gameLoop);
                return;
            }

            analyzeAudio();
            updateKeyboardSound();
            checkPitchPower();
            maybeCreatePlayerWave();
            updateSoundWaves();
            update();
            render();
            renderMinimap();

            requestAnimationFrame(gameLoop);
        }

        function update() {
            // Player movement
            let moveX = 0, moveY = 0;
            const speed = 3;

            if (keys.w || keys.up) moveY -= speed;
            if (keys.s || keys.down) moveY += speed;
            if (keys.a || keys.left) moveX -= speed;
            if (keys.d || keys.right) moveX += speed;

            // Normalize diagonal movement
            if (moveX !== 0 && moveY !== 0) {
                moveX *= 0.707;
                moveY *= 0.707;
            }

            // Collision detection with dynamic corridor width
            const corridorWidth = CORRIDOR_MIN + (CORRIDOR_MAX - CORRIDOR_MIN) * Math.min(volume * 2, 1);
            const playerRadius = 8 + corridorWidth * 3;

            const newX = player.x + moveX;
            const newY = player.y + moveY;

            if (canMove(newX, player.y, playerRadius)) player.x = newX;
            if (canMove(player.x, newY, playerRadius)) player.y = newY;

            // Collect echoes
            for (const echo of echoes) {
                if (echo.collected) continue;
                const dx = player.x - echo.x;
                const dy = player.y - echo.y;
                if (Math.sqrt(dx*dx + dy*dy) < 30) {
                    echo.collected = true;
                    echoesCollected++;
                    updateUI();
                    playEchoCollect();

                    // Particle burst
                    for (let i = 0; i < 20; i++) {
                        particles.push({
                            x: echo.x, y: echo.y,
                            vx: (Math.random() - 0.5) * 5,
                            vy: (Math.random() - 0.5) * 5,
                            life: 40,
                            color: '#00ff88'
                        });
                    }
                }
            }

            // Update enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                const dist = Math.sqrt(dx*dx + dy*dy);

                // Handle stun (pitch power)
                if (enemy.stunned) {
                    enemy.stunned--;
                    // Stunned visual particles
                    if (Math.random() < 0.1) {
                        particles.push({
                            x: enemy.x + (Math.random() - 0.5) * 20,
                            y: enemy.y - 20,
                            vx: (Math.random() - 0.5) * 2,
                            vy: -1,
                            life: 20,
                            color: '#8800ff'
                        });
                    }
                    continue; // Skip AI while stunned
                }

                // Alert based on player volume
                const alertRange = 100 + volume * 300;
                if (dist < alertRange && volume > 0.15) {
                    enemy.alerted = true;
                }

                if (enemy.alerted) {
                    // Chase player
                    enemy.x += (dx / dist) * enemy.speed * 2;
                    enemy.y += (dy / dist) * enemy.speed * 2;

                    // Attack player
                    if (dist < 30) {
                        player.health -= 0.5;
                        updateUI();
                        if (player.health <= 0) {
                            gameOver();
                        }
                    }
                } else {
                    // Patrol
                    enemy.patrolAngle += 0.02;
                    enemy.x += Math.cos(enemy.patrolAngle) * enemy.speed * 0.5;
                    enemy.y += Math.sin(enemy.patrolAngle) * enemy.speed * 0.5;
                }

                // Combat - loud voice damages enemies
                if (volume > 0.5 && dist < 100) {
                    const damage = (volume - 0.5) * 20;
                    enemy.health -= damage;
                    playEnemyHit();

                    // Combat particles
                    if (Math.random() < 0.3) {
                        particles.push({
                            x: enemy.x + (Math.random() - 0.5) * 30,
                            y: enemy.y + (Math.random() - 0.5) * 30,
                            vx: (Math.random() - 0.5) * 4,
                            vy: (Math.random() - 0.5) * 4,
                            life: 20,
                            color: '#ff4444'
                        });
                    }
                }

                // Enemy death
                if (enemy.health <= 0) {
                    enemies.splice(i, 1);
                    enemiesDefeated++;
                    if (!enemy.alerted) stealthKills++;

                    for (let j = 0; j < 30; j++) {
                        particles.push({
                            x: enemy.x, y: enemy.y,
                            vx: (Math.random() - 0.5) * 8,
                            vy: (Math.random() - 0.5) * 8,
                            life: 50,
                            color: '#ff0000'
                        });
                    }
                    updateUI();
                }
            }

            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.95;
                p.vy *= 0.95;
                p.life--;
                if (p.life <= 0) particles.splice(i, 1);
            }

            // Check level complete
            if (echoesCollected >= echoes.length && enemies.length === 0) {
                levelComplete();
            }
        }

        function canMove(x, y, radius) {
            const tiles = [
                [x - radius, y - radius],
                [x + radius, y - radius],
                [x - radius, y + radius],
                [x + radius, y + radius]
            ];

            for (const [tx, ty] of tiles) {
                const tileX = Math.floor(tx / TILE_SIZE);
                const tileY = Math.floor(ty / TILE_SIZE);
                if (!dungeon[tileY]?.[tileX] || dungeon[tileY][tileX].type === 'wall') {
                    return false;
                }
            }
            return true;
        }

        // ========== RENDERING ==========
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            minimapCanvas.width = 150;
            minimapCanvas.height = 150;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        function render() {
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const camX = player.x - canvas.width / 2;
            const camY = player.y - canvas.height / 2;

            // Dynamic corridor visual effect based on volume
            const corridorWidth = CORRIDOR_MIN + (CORRIDOR_MAX - CORRIDOR_MIN) * Math.min(volume * 2, 1);

            // Render dungeon
            for (let y = 0; y < dungeon.length; y++) {
                for (let x = 0; x < dungeon[y].length; x++) {
                    const tile = dungeon[y][x];
                    const screenX = x * TILE_SIZE - camX;
                    const screenY = y * TILE_SIZE - camY;

                    // Skip if off screen
                    if (screenX < -TILE_SIZE || screenX > canvas.width ||
                        screenY < -TILE_SIZE || screenY > canvas.height) continue;

                    if (tile.type === 'floor') {
                        // Floor gradient based on distance from player
                        const dx = x * TILE_SIZE + TILE_SIZE/2 - player.x;
                        const dy = y * TILE_SIZE + TILE_SIZE/2 - player.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        const brightness = Math.max(0.1, 1 - dist / 400);

                        ctx.fillStyle = `rgb(${30 * brightness}, ${35 * brightness}, ${40 * brightness})`;
                        ctx.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE);

                        // Grid lines
                        ctx.strokeStyle = `rgba(255, 255, 255, ${0.05 * brightness})`;
                        ctx.strokeRect(screenX, screenY, TILE_SIZE, TILE_SIZE);
                    } else {
                        // Wall
                        if (tile.isSecret) {
                            // Secret wall glows when humming
                            const glowIntensity = humDuration / HUM_THRESHOLD;
                            ctx.fillStyle = `rgb(${40 + glowIntensity * 50}, ${20}, ${60 + glowIntensity * 50})`;
                        } else {
                            ctx.fillStyle = '#1a1a2e';
                        }
                        ctx.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE);
                    }
                }
            }

            // Render echoes
            for (const echo of echoes) {
                if (echo.collected) continue;
                const screenX = echo.x - camX;
                const screenY = echo.y - camY;

                echo.glow = (echo.glow + 0.05) % (Math.PI * 2);
                const glowSize = 15 + Math.sin(echo.glow) * 5;

                ctx.beginPath();
                ctx.arc(screenX, screenY, glowSize, 0, Math.PI * 2);
                const gradient = ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, glowSize);
                gradient.addColorStop(0, '#00ff88');
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.fill();
            }

            // Render enemies
            for (const enemy of enemies) {
                const screenX = enemy.x - camX;
                const screenY = enemy.y - camY;

                // Enemy body
                ctx.fillStyle = enemy.alerted ? '#ff4444' : '#ff8844';
                ctx.beginPath();
                ctx.arc(screenX, screenY, 15, 0, Math.PI * 2);
                ctx.fill();

                // Alert indicator
                if (enemy.alerted) {
                    ctx.fillStyle = '#ff0000';
                    ctx.font = 'bold 20px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('!', screenX, screenY - 25);
                }

                // Health bar
                if (enemy.health < enemy.maxHealth) {
                    ctx.fillStyle = '#333';
                    ctx.fillRect(screenX - 15, screenY - 25, 30, 4);
                    ctx.fillStyle = '#ff4444';
                    ctx.fillRect(screenX - 15, screenY - 25, 30 * (enemy.health / enemy.maxHealth), 4);
                }
            }

            // Render particles
            for (const p of particles) {
                const screenX = p.x - camX;
                const screenY = p.y - camY;
                ctx.globalAlpha = p.life / 60;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(screenX, screenY, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            // Render sound waves (accessibility feature)
            renderSoundWaves(ctx, camX, camY);

            // Render player
            const playerScreenX = canvas.width / 2;
            const playerScreenY = canvas.height / 2;

            // Voice aura
            if (volume > 0.1) {
                const auraRadius = 50 + volume * 100;
                const gradient = ctx.createRadialGradient(
                    playerScreenX, playerScreenY, 0,
                    playerScreenX, playerScreenY, auraRadius
                );
                let auraColor = '#00ff88';
                if (volume > 0.5) auraColor = '#ff4444';
                else if (volume > 0.2) auraColor = '#ffff00';

                gradient.addColorStop(0, auraColor + '44');
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(playerScreenX, playerScreenY, auraRadius, 0, Math.PI * 2);
                ctx.fill();
            }

            // Player body
            ctx.fillStyle = '#00ff88';
            ctx.beginPath();
            ctx.arc(playerScreenX, playerScreenY, 12, 0, Math.PI * 2);
            ctx.fill();

            // Health indicator ring
            ctx.strokeStyle = `rgb(${255 - player.health * 2.55}, ${player.health * 2.55}, 100)`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(playerScreenX, playerScreenY, 18, 0, Math.PI * 2 * (player.health / player.maxHealth));
            ctx.stroke();
        }

        function renderMinimap() {
            minimapCtx.fillStyle = '#0a0a0a';
            minimapCtx.fillRect(0, 0, 150, 150);

            const scale = 150 / (dungeon[0]?.length * TILE_SIZE || 1);
            const offsetX = 75 - player.x * scale;
            const offsetY = 75 - player.y * scale;

            // Draw dungeon
            for (let y = 0; y < dungeon.length; y++) {
                for (let x = 0; x < dungeon[y].length; x++) {
                    if (dungeon[y][x].type === 'floor') {
                        minimapCtx.fillStyle = '#333';
                        minimapCtx.fillRect(
                            x * TILE_SIZE * scale + offsetX,
                            y * TILE_SIZE * scale + offsetY,
                            TILE_SIZE * scale,
                            TILE_SIZE * scale
                        );
                    }
                }
            }

            // Draw echoes
            minimapCtx.fillStyle = '#00ff88';
            for (const echo of echoes) {
                if (!echo.collected) {
                    minimapCtx.beginPath();
                    minimapCtx.arc(echo.x * scale + offsetX, echo.y * scale + offsetY, 3, 0, Math.PI * 2);
                    minimapCtx.fill();
                }
            }

            // Draw enemies
            minimapCtx.fillStyle = '#ff4444';
            for (const enemy of enemies) {
                minimapCtx.beginPath();
                minimapCtx.arc(enemy.x * scale + offsetX, enemy.y * scale + offsetY, 3, 0, Math.PI * 2);
                minimapCtx.fill();
            }

            // Draw player
            minimapCtx.fillStyle = '#ffffff';
            minimapCtx.beginPath();
            minimapCtx.arc(75, 75, 4, 0, Math.PI * 2);
            minimapCtx.fill();
        }

        // ========== UI ==========
        function updateUI() {
            document.getElementById('level-num').textContent = level;
            document.getElementById('echoes-found').textContent = `${echoesCollected} / ${echoes.length}`;
            document.getElementById('enemies-left').textContent = enemies.length;
            document.getElementById('health-bar').style.width = `${player.health}%`;
        }

        function levelComplete() {
            document.getElementById('level-complete').style.display = 'block';
            document.getElementById('final-echoes').textContent = echoesCollected;
            document.getElementById('final-enemies').textContent = enemiesDefeated;
            document.getElementById('stealth-bonus').textContent = stealthKills * 50;
            gameStarted = false;
        }

        function nextLevel() {
            document.getElementById('level-complete').style.display = 'none';
            level++;
            player.health = Math.min(player.maxHealth, player.health + 20);
            enemiesDefeated = 0;
            stealthKills = 0;
            generateDungeon();
            gameStarted = true;
        }

        function gameOver() {
            alert(`Game Over! You reached level ${level}`);
            level = 1;
            player.health = 100;
            enemiesDefeated = 0;
            stealthKills = 0;
            generateDungeon();
        }

        // ========== INPUT ==========
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (key === 'w') keys.w = true;
            if (key === 'a') keys.a = true;
            if (key === 's') keys.s = true;
            if (key === 'd') keys.d = true;
            if (key === 'arrowup') keys.up = true;
            if (key === 'arrowdown') keys.down = true;
            if (key === 'arrowleft') keys.left = true;
            if (key === 'arrowright') keys.right = true;

            // Keyboard sound mode controls
            if (e.code === 'Space') {
                spaceHeld = true;
                e.preventDefault();
            }
            if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
                shiftHeld = true;
            }
        });

        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (key === 'w') keys.w = false;
            if (key === 'a') keys.a = false;
            if (key === 's') keys.s = false;
            if (key === 'd') keys.d = false;
            if (key === 'arrowup') keys.up = false;
            if (key === 'arrowdown') keys.down = false;
            if (key === 'arrowleft') keys.left = false;
            if (key === 'arrowright') keys.right = false;

            // Keyboard sound mode controls
            if (e.code === 'Space') spaceHeld = false;
            if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') shiftHeld = false;
        });

        // ========== START GAME ==========
        async function startGame(useKeyboard = false) {
            keyboardSoundMode = useKeyboard;

            if (!useKeyboard) {
                const success = await initAudio();
                if (!success) {
                    // Offer keyboard fallback
                    if (confirm('Microphone access denied. Would you like to play with keyboard controls instead?\n\nSPACE = Combat volume\nSHIFT = Normal volume\nNeither = Stealth')) {
                        keyboardSoundMode = true;
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    } else {
                        return;
                    }
                }
            } else {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }

            // Initialize audio feedback
            initAudioFeedback();

            document.getElementById('start-screen').style.display = 'none';
            generateDungeon();
            gameStarted = true;

            // Hide instructions after a few seconds
            setTimeout(() => {
                document.getElementById('instructions').style.opacity = '0';
                setTimeout(() => document.getElementById('instructions').style.display = 'none', 1000);
            }, 10000);
        }

        // Start the loop
        gameLoop();
    </script>
</body>
</html>
