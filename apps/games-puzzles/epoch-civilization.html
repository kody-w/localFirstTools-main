<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EPOCH - A 10,000 Year Civilization Simulator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a2e;
            color: #eee;
            overflow: hidden;
            height: 100vh;
        }

        #gameContainer {
            display: flex;
            height: 100vh;
        }

        #leftPanel {
            width: 300px;
            background: #16213e;
            border-right: 2px solid #0f3460;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        #mapContainer {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #0a0a15;
        }

        #worldCanvas {
            position: absolute;
            cursor: grab;
            image-rendering: pixelated;
        }

        #worldCanvas:active {
            cursor: grabbing;
        }

        #rightPanel {
            width: 320px;
            background: #16213e;
            border-left: 2px solid #0f3460;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .panel-section {
            padding: 15px;
            border-bottom: 1px solid #0f3460;
        }

        .panel-section h2 {
            font-size: 16px;
            margin-bottom: 10px;
            color: #00d4ff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .panel-section h3 {
            font-size: 14px;
            margin-bottom: 8px;
            color: #ffa500;
        }

        #worldStats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 13px;
        }

        .stat-item {
            background: #0f3460;
            padding: 8px;
            border-radius: 4px;
        }

        .stat-label {
            color: #888;
            font-size: 11px;
            text-transform: uppercase;
        }

        .stat-value {
            color: #fff;
            font-size: 16px;
            font-weight: bold;
            margin-top: 2px;
        }

        #timeControls {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .btn {
            background: #0f3460;
            border: none;
            color: #fff;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .btn:hover {
            background: #1a4d7a;
            transform: translateY(-1px);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn.active {
            background: #00d4ff;
            color: #000;
        }

        .btn-power {
            background: #8b00ff;
        }

        .btn-power:hover {
            background: #a020f0;
        }

        .btn-power:disabled {
            background: #4a4a4a;
            cursor: not-allowed;
            opacity: 0.5;
        }

        #timeline {
            background: #0f3460;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
        }

        #timelineBar {
            width: 100%;
            height: 30px;
            background: #1a1a2e;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        #timelineProgress {
            height: 100%;
            background: linear-gradient(90deg, #00d4ff, #ffa500);
            transition: width 0.3s;
        }

        #timelineYear {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 3px #000;
        }

        .era-marker {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #ffa500;
        }

        #eventLog {
            background: #0a0a15;
            height: 200px;
            overflow-y: auto;
            border-radius: 4px;
            padding: 10px;
            font-size: 12px;
            line-height: 1.6;
        }

        .event-item {
            margin-bottom: 8px;
            padding: 5px;
            border-left: 3px solid #00d4ff;
            padding-left: 8px;
            background: rgba(0, 212, 255, 0.05);
        }

        .event-item.war {
            border-left-color: #ff4444;
            background: rgba(255, 68, 68, 0.05);
        }

        .event-item.disaster {
            border-left-color: #ff8800;
            background: rgba(255, 136, 0, 0.05);
        }

        .event-item.golden {
            border-left-color: #ffd700;
            background: rgba(255, 215, 0, 0.05);
        }

        .event-year {
            color: #888;
            font-size: 11px;
        }

        #selectedCivInfo {
            font-size: 13px;
        }

        .civ-name {
            font-size: 18px;
            font-weight: bold;
            color: #00d4ff;
            margin-bottom: 10px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #0f3460;
        }

        .info-label {
            color: #888;
        }

        .info-value {
            color: #fff;
            font-weight: bold;
        }

        #godPowers {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .power-uses {
            font-size: 11px;
            color: #888;
            text-align: center;
            margin-top: 3px;
        }

        #legend {
            max-height: 300px;
            overflow-y: auto;
        }

        .legend-item {
            display: flex;
            align-items: center;
            padding: 5px;
            margin-bottom: 5px;
            background: #0f3460;
            border-radius: 3px;
            font-size: 12px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            margin-right: 8px;
            border: 1px solid #fff;
        }

        .legend-info {
            flex: 1;
        }

        .legend-era {
            font-size: 10px;
            color: #888;
        }

        #tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            display: none;
            z-index: 1000;
            border: 1px solid #00d4ff;
            max-width: 250px;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: #16213e;
            padding: 30px;
            border-radius: 8px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            border: 2px solid #00d4ff;
        }

        .modal h2 {
            color: #00d4ff;
            margin-bottom: 20px;
        }

        .close-modal {
            float: right;
            font-size: 24px;
            cursor: pointer;
            color: #888;
        }

        .close-modal:hover {
            color: #fff;
        }

        #welcomeModal .btn {
            margin-top: 20px;
            padding: 12px 24px;
            font-size: 14px;
        }

        .achievement {
            background: #0f3460;
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
            border-left: 3px solid #ffd700;
        }

        #minimap {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 200px;
            height: 150px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00d4ff;
            border-radius: 4px;
        }

        .zoom-controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            display: flex;
            gap: 5px;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            background: rgba(15, 52, 96, 0.9);
            border: 2px solid #00d4ff;
            border-radius: 50%;
            color: #fff;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .zoom-btn:hover {
            background: rgba(26, 77, 122, 0.9);
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #0a0a15;
        }

        ::-webkit-scrollbar-thumb {
            background: #0f3460;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #1a4d7a;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="leftPanel">
            <div class="panel-section">
                <h2>World Overview</h2>
                <div id="worldStats">
                    <div class="stat-item">
                        <div class="stat-label">Year</div>
                        <div class="stat-value" id="currentYear">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Era</div>
                        <div class="stat-value" id="currentEra">Stone</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Population</div>
                        <div class="stat-value" id="totalPop">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Civilizations</div>
                        <div class="stat-value" id="civCount">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Cities</div>
                        <div class="stat-value" id="cityCount">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Wars Active</div>
                        <div class="stat-value" id="warCount">0</div>
                    </div>
                </div>
            </div>

            <div class="panel-section">
                <h2>Time Controls</h2>
                <div id="timeControls">
                    <button class="btn" id="pauseBtn">‚è∏ Pause</button>
                    <button class="btn active" id="speed1x">1x</button>
                    <button class="btn" id="speed2x">2x</button>
                    <button class="btn" id="speed5x">5x</button>
                    <button class="btn" id="speed10x">10x</button>
                    <button class="btn" id="speed50x">50x</button>
                </div>
                <div id="timeline">
                    <div id="timelineBar">
                        <div id="timelineProgress"></div>
                        <div id="timelineYear">Year 0</div>
                    </div>
                </div>
            </div>

            <div class="panel-section">
                <h2>God Powers <span style="font-size:11px;color:#888">(Limited Uses)</span></h2>
                <div id="godPowers">
                    <button class="btn btn-power" id="powerTerraform">üèîÔ∏è Terraform</button>
                    <button class="btn btn-power" id="powerEarthquake">üåã Earthquake</button>
                    <button class="btn btn-power" id="powerMeteor">‚òÑÔ∏è Meteor</button>
                    <button class="btn btn-power" id="powerFlood">üåä Flood</button>
                    <button class="btn btn-power" id="powerPlague">ü¶† Plague</button>
                    <button class="btn btn-power" id="powerGift">üìú Gift Tech</button>
                    <button class="btn btn-power" id="powerSmite">‚ö° Smite City</button>
                    <button class="btn btn-power" id="powerInspire">‚ú® Inspire</button>
                </div>
            </div>

            <div class="panel-section">
                <h2>Event Log</h2>
                <div id="eventLog"></div>
            </div>

            <div class="panel-section">
                <button class="btn" id="saveBtn" style="width:100%;margin-bottom:10px">üíæ Save Game</button>
                <button class="btn" id="loadBtn" style="width:100%;margin-bottom:10px">üìÇ Load Game</button>
                <button class="btn" id="statsBtn" style="width:100%">üìä Statistics</button>
            </div>
        </div>

        <div id="mapContainer">
            <canvas id="worldCanvas"></canvas>
            <canvas id="minimap"></canvas>
            <div class="zoom-controls">
                <div class="zoom-btn" id="zoomIn">+</div>
                <div class="zoom-btn" id="zoomOut">‚àí</div>
            </div>
            <div id="tooltip"></div>
        </div>

        <div id="rightPanel">
            <div class="panel-section">
                <h2>Selected Civilization</h2>
                <div id="selectedCivInfo">
                    <p style="color:#888;font-size:13px;">Click a civilization on the map to view details</p>
                </div>
            </div>

            <div class="panel-section">
                <h2>Civilizations</h2>
                <div id="legend"></div>
            </div>
        </div>
    </div>

    <div id="welcomeModal" class="modal" style="display:flex">
        <div class="modal-content">
            <h2>üåç EPOCH: A 10,000 Year Journey</h2>
            <p style="line-height:1.8;margin-bottom:15px;">
                You are about to witness the rise and fall of civilizations across 10 millennia.
            </p>
            <p style="line-height:1.8;margin-bottom:15px;">
                Watch as nomadic tribes settle, discover fire, build cities, develop technology,
                wage wars, form alliances, and push toward the stars... or collapse into ruin.
            </p>
            <p style="line-height:1.8;margin-bottom:15px;">
                <strong>Your Role:</strong> You are an observer with limited divine powers. You can nudge
                civilizations with gifts, disasters, or terraforming, but the world evolves on its own.
                Each game is unique.
            </p>
            <p style="line-height:1.8;margin-bottom:15px;">
                <strong>Controls:</strong>
                <br>‚Ä¢ Drag to scroll, mouse wheel to zoom
                <br>‚Ä¢ Click cities/civs to see details
                <br>‚Ä¢ Use time controls to speed up history
                <br>‚Ä¢ Use God Powers sparingly (they recharge slowly)
            </p>
            <button class="btn" id="startBtn">Begin the First Age</button>
        </div>
    </div>

    <div id="statsModal" class="modal">
        <div class="modal-content">
            <span class="close-modal" id="closeStats">√ó</span>
            <h2>üìä World Statistics</h2>
            <div id="statsContent"></div>
        </div>
    </div>

    <script>
        // ============================================================================
        // CONSTANTS & CONFIGURATION
        // ============================================================================

        const WORLD_WIDTH = 240;
        const WORLD_HEIGHT = 180;
        const TILE_SIZE = 4;
        const MAX_YEAR = 10000;

        const TERRAIN = {
            OCEAN: 0,
            BEACH: 1,
            PLAINS: 2,
            FOREST: 3,
            HILLS: 4,
            MOUNTAINS: 5,
            DESERT: 6,
            TUNDRA: 7,
            RIVER: 8
        };

        const TERRAIN_COLORS = {
            [TERRAIN.OCEAN]: '#1a4d7a',
            [TERRAIN.BEACH]: '#d4c194',
            [TERRAIN.PLAINS]: '#6b8e23',
            [TERRAIN.FOREST]: '#2d5016',
            [TERRAIN.HILLS]: '#8b7355',
            [TERRAIN.MOUNTAINS]: '#696969',
            [TERRAIN.DESERT]: '#edc9af',
            [TERRAIN.TUNDRA]: '#e0e0e0',
            [TERRAIN.RIVER]: '#4169e1'
        };

        const ERAS = [
            { name: 'Stone Age', year: 0, tech: 0 },
            { name: 'Bronze Age', year: 1000, tech: 10 },
            { name: 'Iron Age', year: 2000, tech: 20 },
            { name: 'Classical', year: 3000, tech: 35 },
            { name: 'Medieval', year: 4500, tech: 50 },
            { name: 'Renaissance', year: 6000, tech: 65 },
            { name: 'Industrial', year: 7500, tech: 80 },
            { name: 'Modern', year: 8500, tech: 95 },
            { name: 'Space Age', year: 9500, tech: 100 }
        ];

        const GOVERNMENT_TYPES = ['Tribal', 'Chiefdom', 'Kingdom', 'Empire', 'Republic', 'Democracy', 'Federation'];

        const CIV_COLORS = [
            '#ff4444', '#44ff44', '#4444ff', '#ffff44', '#ff44ff', '#44ffff',
            '#ff8844', '#88ff44', '#4488ff', '#ff4488', '#88ff88', '#8844ff',
            '#ffaa44', '#aaff44', '#44aaff', '#ff44aa', '#aaff88', '#aa44ff'
        ];

        const CITY_NAMES = [
            'Akkad', 'Babylon', 'Carthage', 'Damascus', 'Ephesus', 'Florence', 'Genoa', 'Hagia',
            'Iconium', 'Jerusalem', 'Kiev', 'Londinium', 'Memphis', 'Novgorod', 'Ostia', 'Petra',
            'Qin', 'Rome', 'Sparta', 'Troy', 'Ur', 'Valencia', 'Wien', 'Xian', 'York', 'Zagreb',
            'Athena', 'Byzantium', 'Corinth', 'Delphi', 'Elysium', 'Faerun', 'Gondor', 'Hyrule',
            'Ilium', 'Jericho', 'Knossos', 'Lydia', 'Mordor', 'Nineveh', 'Olympus', 'Pompeii',
            'Qart', 'Ravenna', 'Sidon', 'Thebes', 'Ugarit', 'Valhalla', 'Waterdeep', 'Xanadu'
        ];

        // ============================================================================
        // WORLD GENERATION (Perlin Noise)
        // ============================================================================

        class PerlinNoise {
            constructor(seed = Math.random()) {
                this.seed = seed;
                this.permutation = this.generatePermutation();
            }

            generatePermutation() {
                const p = [];
                for (let i = 0; i < 256; i++) p[i] = i;
                for (let i = 255; i > 0; i--) {
                    const j = Math.floor(this.random() * (i + 1));
                    [p[i], p[j]] = [p[j], p[i]];
                }
                return p.concat(p);
            }

            random() {
                const x = Math.sin(this.seed++) * 10000;
                return x - Math.floor(x);
            }

            fade(t) {
                return t * t * t * (t * (t * 6 - 15) + 10);
            }

            lerp(t, a, b) {
                return a + t * (b - a);
            }

            grad(hash, x, y) {
                const h = hash & 3;
                const u = h < 2 ? x : y;
                const v = h < 2 ? y : x;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }

            noise(x, y) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                x -= Math.floor(x);
                y -= Math.floor(y);
                const u = this.fade(x);
                const v = this.fade(y);
                const p = this.permutation;
                const a = p[X] + Y;
                const b = p[X + 1] + Y;
                return this.lerp(v,
                    this.lerp(u, this.grad(p[a], x, y), this.grad(p[b], x - 1, y)),
                    this.lerp(u, this.grad(p[a + 1], x, y - 1), this.grad(p[b + 1], x - 1, y - 1))
                );
            }

            octaveNoise(x, y, octaves = 4, persistence = 0.5) {
                let total = 0;
                let frequency = 1;
                let amplitude = 1;
                let maxValue = 0;
                for (let i = 0; i < octaves; i++) {
                    total += this.noise(x * frequency, y * frequency) * amplitude;
                    maxValue += amplitude;
                    amplitude *= persistence;
                    frequency *= 2;
                }
                return total / maxValue;
            }
        }

        class World {
            constructor() {
                this.tiles = new Array(WORLD_WIDTH * WORLD_HEIGHT);
                this.resources = new Array(WORLD_WIDTH * WORLD_HEIGHT);
                this.generate();
            }

            generate() {
                const noise = new PerlinNoise(Math.random() * 1000);
                const moistureNoise = new PerlinNoise(Math.random() * 1000);

                // Generate base terrain
                for (let y = 0; y < WORLD_HEIGHT; y++) {
                    for (let x = 0; x < WORLD_WIDTH; x++) {
                        const idx = y * WORLD_WIDTH + x;

                        // Elevation noise
                        const elevation = noise.octaveNoise(x / 40, y / 40, 6, 0.5);
                        const moisture = moistureNoise.octaveNoise(x / 30, y / 30, 4, 0.5);

                        // Distance from center (for continent shape)
                        const centerX = WORLD_WIDTH / 2;
                        const centerY = WORLD_HEIGHT / 2;
                        const distFromCenter = Math.sqrt(
                            Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2)
                        ) / (WORLD_WIDTH / 2);

                        // Apply island mask
                        const islandMask = Math.max(0, 1 - distFromCenter * 1.3);
                        const finalElevation = (elevation + 0.3) * islandMask;

                        // Climate (latitude-based)
                        const latitude = Math.abs(y - WORLD_HEIGHT / 2) / (WORLD_HEIGHT / 2);

                        // Determine terrain
                        if (finalElevation < 0.15) {
                            this.tiles[idx] = TERRAIN.OCEAN;
                        } else if (finalElevation < 0.2) {
                            this.tiles[idx] = TERRAIN.BEACH;
                        } else if (latitude > 0.7 && finalElevation < 0.6) {
                            this.tiles[idx] = TERRAIN.TUNDRA;
                        } else if (moisture < -0.2 && latitude < 0.4 && finalElevation < 0.6) {
                            this.tiles[idx] = TERRAIN.DESERT;
                        } else if (finalElevation > 0.65) {
                            this.tiles[idx] = TERRAIN.MOUNTAINS;
                        } else if (finalElevation > 0.5) {
                            this.tiles[idx] = TERRAIN.HILLS;
                        } else if (moisture > 0.1 && finalElevation < 0.55) {
                            this.tiles[idx] = TERRAIN.FOREST;
                        } else {
                            this.tiles[idx] = TERRAIN.PLAINS;
                        }

                        // Resources
                        this.resources[idx] = this.calculateResources(this.tiles[idx], x, y);
                    }
                }

                // Add rivers
                this.addRivers();
            }

            addRivers() {
                const riverCount = 15 + Math.floor(Math.random() * 10);
                for (let i = 0; i < riverCount; i++) {
                    // Start from mountains
                    let x = Math.floor(Math.random() * WORLD_WIDTH);
                    let y = Math.floor(Math.random() * WORLD_HEIGHT);

                    if (this.getTerrain(x, y) !== TERRAIN.MOUNTAINS) continue;

                    // Flow downhill
                    for (let step = 0; step < 50; step++) {
                        const idx = y * WORLD_WIDTH + x;
                        const currentTerrain = this.tiles[idx];

                        if (currentTerrain === TERRAIN.OCEAN) break;
                        if (currentTerrain !== TERRAIN.MOUNTAINS && currentTerrain !== TERRAIN.HILLS) {
                            this.tiles[idx] = TERRAIN.RIVER;
                            this.resources[idx].food += 3;
                        }

                        // Move in random direction, prefer downhill
                        const directions = [
                            [0, 1], [1, 0], [0, -1], [-1, 0],
                            [1, 1], [1, -1], [-1, 1], [-1, -1]
                        ];
                        const dir = directions[Math.floor(Math.random() * directions.length)];
                        x += dir[0];
                        y += dir[1];

                        if (x < 0 || x >= WORLD_WIDTH || y < 0 || y >= WORLD_HEIGHT) break;
                    }
                }
            }

            calculateResources(terrain, x, y) {
                const resources = { food: 0, wood: 0, stone: 0, metal: 0, fish: 0 };

                switch(terrain) {
                    case TERRAIN.PLAINS:
                        resources.food = 5;
                        break;
                    case TERRAIN.FOREST:
                        resources.food = 2;
                        resources.wood = 5;
                        break;
                    case TERRAIN.HILLS:
                        resources.stone = 4;
                        resources.metal = 2;
                        break;
                    case TERRAIN.MOUNTAINS:
                        resources.stone = 3;
                        resources.metal = 5;
                        break;
                    case TERRAIN.RIVER:
                        resources.food = 6;
                        resources.fish = 3;
                        break;
                    case TERRAIN.BEACH:
                        resources.fish = 5;
                        resources.food = 1;
                        break;
                    case TERRAIN.DESERT:
                        resources.stone = 2;
                        break;
                    case TERRAIN.TUNDRA:
                        resources.fish = 2;
                        break;
                }

                return resources;
            }

            getTerrain(x, y) {
                if (x < 0 || x >= WORLD_WIDTH || y < 0 || y >= WORLD_HEIGHT) return TERRAIN.OCEAN;
                return this.tiles[y * WORLD_WIDTH + x];
            }

            getResources(x, y) {
                if (x < 0 || x >= WORLD_WIDTH || y < 0 || y >= WORLD_HEIGHT) {
                    return { food: 0, wood: 0, stone: 0, metal: 0, fish: 0 };
                }
                return this.resources[y * WORLD_WIDTH + x];
            }

            isLandTile(x, y) {
                const terrain = this.getTerrain(x, y);
                return terrain !== TERRAIN.OCEAN && terrain !== TERRAIN.BEACH;
            }
        }

        // ============================================================================
        // GAME ENTITIES
        // ============================================================================

        class City {
            constructor(x, y, name, civId) {
                this.x = x;
                this.y = y;
                this.name = name;
                this.civId = civId;
                this.population = 100 + Math.floor(Math.random() * 100);
                this.founded = game.year;
                this.tier = 0; // 0=settlement, 1=village, 2=town, 3=city, 4=metropolis
                this.hasWalls = false;
                this.hasUniversity = false;
                this.destroyed = false;
            }

            update() {
                if (this.destroyed) return;

                const civ = game.getCivilization(this.civId);
                if (!civ) return;

                // Population growth
                const resources = world.getResources(this.x, this.y);
                const foodBonus = resources.food / 5;
                const growthRate = 0.001 + foodBonus * 0.0002 + (civ.techLevel / 100) * 0.0005;
                this.population += this.population * growthRate * game.timeSpeed;

                // Tier advancement
                if (this.population > 10000 && this.tier < 4) this.tier = 4;
                else if (this.population > 5000 && this.tier < 3) this.tier = 3;
                else if (this.population > 2000 && this.tier < 2) this.tier = 2;
                else if (this.population > 500 && this.tier < 1) this.tier = 1;

                // Build university if advanced enough
                if (civ.techLevel > 50 && !this.hasUniversity && this.tier >= 3) {
                    this.hasUniversity = true;
                }

                // Build walls if at war or medieval+
                if ((civ.atWar || civ.techLevel > 45) && !this.hasWalls && this.tier >= 2) {
                    this.hasWalls = true;
                }
            }

            getSize() {
                return 3 + this.tier * 2;
            }
        }

        class Civilization {
            constructor(id, color, startX, startY) {
                this.id = id;
                this.color = color;
                this.name = this.generateName();
                this.techLevel = 0;
                this.culture = Math.random() * 100;
                this.militaryStrength = 10;
                this.government = GOVERNMENT_TYPES[0];
                this.religion = `${this.name}ism`;
                this.founded = game.year;
                this.cities = [];
                this.territory = [];
                this.allies = [];
                this.enemies = [];
                this.atWar = false;
                this.warTarget = null;
                this.tradeRoutes = [];
                this.goldenAge = false;
                this.goldenAgeEnd = 0;
                this.population = 50;
                this.nomadic = true;
                this.x = startX;
                this.y = startY;
                this.destroyed = false;
            }

            generateName() {
                const prefixes = ['Ak', 'El', 'Nor', 'Sul', 'Kar', 'Dor', 'Mal', 'Ven', 'Cal', 'Byz'];
                const suffixes = ['aria', 'ion', 'land', 'heim', 'stan', 'ia', 'um', 'os', 'an', 'or'];
                return prefixes[Math.floor(Math.random() * prefixes.length)] +
                       suffixes[Math.floor(Math.random() * suffixes.length)];
            }

            update() {
                if (this.destroyed) return;

                // Nomadic phase
                if (this.nomadic) {
                    this.updateNomadic();
                } else {
                    this.updateSettled();
                }

                // Tech advancement
                this.advanceTechnology();

                // Update government
                this.updateGovernment();

                // Golden age
                if (this.goldenAge && game.year > this.goldenAgeEnd) {
                    this.goldenAge = false;
                }

                // Check for collapse
                if (this.cities.length === 0 && !this.nomadic) {
                    this.destroyed = true;
                    game.addEvent(`${this.name} has collapsed!`, 'disaster');
                }
            }

            updateNomadic() {
                // Wander and grow
                this.population += this.population * 0.002 * game.timeSpeed;

                // Random walk
                if (Math.random() < 0.05 * game.timeSpeed) {
                    const dx = Math.floor(Math.random() * 3) - 1;
                    const dy = Math.floor(Math.random() * 3) - 1;
                    const newX = Math.max(0, Math.min(WORLD_WIDTH - 1, this.x + dx));
                    const newY = Math.max(0, Math.min(WORLD_HEIGHT - 1, this.y + dy));
                    if (world.isLandTile(newX, newY)) {
                        this.x = newX;
                        this.y = newY;
                    }
                }

                // Settle if population high enough and good location
                if (this.population > 200 && world.isLandTile(this.x, this.y)) {
                    const resources = world.getResources(this.x, this.y);
                    if (resources.food > 3 || resources.fish > 3) {
                        this.settle();
                    }
                }
            }

            settle() {
                this.nomadic = false;
                const cityName = this.getUniqueCityName();
                const city = new City(this.x, this.y, cityName, this.id);
                city.population = this.population;
                this.cities.push(city);
                this.expandTerritory();
                game.addEvent(`${this.name} has founded ${cityName}!`, 'golden');
            }

            updateSettled() {
                // Update all cities
                this.cities = this.cities.filter(c => !c.destroyed);
                this.cities.forEach(city => city.update());

                // Total population
                this.population = this.cities.reduce((sum, c) => sum + c.population, 0);

                // Expand cities
                if (Math.random() < 0.001 * game.timeSpeed && this.cities.length > 0) {
                    const parentCity = this.cities[Math.floor(Math.random() * this.cities.length)];
                    if (parentCity.population > 3000) {
                        this.foundNewCity();
                    }
                }

                // Expand territory
                if (Math.random() < 0.01 * game.timeSpeed) {
                    this.expandTerritory();
                }

                // War behavior
                if (this.atWar && this.warTarget) {
                    this.updateWar();
                }

                // Diplomacy
                if (Math.random() < 0.002 * game.timeSpeed) {
                    this.updateDiplomacy();
                }

                // Update military
                this.militaryStrength = this.population / 100 + this.techLevel / 2;
            }

            advanceTechnology() {
                // Research speed based on population, universities, trade, golden age
                let researchRate = 0.01 * game.timeSpeed;
                researchRate += (this.population / 100000) * game.timeSpeed;
                researchRate += this.cities.filter(c => c.hasUniversity).length * 0.05 * game.timeSpeed;
                researchRate += this.tradeRoutes.length * 0.01 * game.timeSpeed;
                if (this.goldenAge) researchRate *= 2;

                this.techLevel += researchRate;
                this.techLevel = Math.min(100, this.techLevel);
            }

            updateGovernment() {
                if (this.techLevel > 90) this.government = GOVERNMENT_TYPES[6];
                else if (this.techLevel > 75) this.government = GOVERNMENT_TYPES[5];
                else if (this.techLevel > 60) this.government = GOVERNMENT_TYPES[4];
                else if (this.techLevel > 40) this.government = GOVERNMENT_TYPES[3];
                else if (this.techLevel > 20) this.government = GOVERNMENT_TYPES[2];
                else if (this.techLevel > 5) this.government = GOVERNMENT_TYPES[1];
            }

            foundNewCity() {
                // Find good location near existing cities
                const candidates = [];
                this.cities.forEach(city => {
                    for (let dy = -15; dy <= 15; dy++) {
                        for (let dx = -15; dx <= 15; dx++) {
                            const x = city.x + dx;
                            const y = city.y + dy;
                            if (!world.isLandTile(x, y)) continue;
                            if (game.getCityAt(x, y)) continue;

                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < 5 || dist > 15) continue;

                            const resources = world.getResources(x, y);
                            const score = resources.food + resources.fish + Math.random() * 5;
                            candidates.push({ x, y, score });
                        }
                    }
                });

                if (candidates.length === 0) return;

                candidates.sort((a, b) => b.score - a.score);
                const best = candidates[0];
                const cityName = this.getUniqueCityName();
                const city = new City(best.x, best.y, cityName, this.id);
                this.cities.push(city);
                game.addEvent(`${this.name} has founded ${cityName}!`);
            }

            getUniqueCityName() {
                const used = new Set(this.cities.map(c => c.name));
                const available = CITY_NAMES.filter(n => !used.has(n));
                if (available.length === 0) {
                    return `${this.name} ${this.cities.length + 1}`;
                }
                return available[Math.floor(Math.random() * available.length)];
            }

            expandTerritory() {
                // Claim tiles around cities
                this.territory = [];
                this.cities.forEach(city => {
                    const radius = 3 + city.tier;
                    for (let dy = -radius; dy <= radius; dy++) {
                        for (let dx = -radius; dx <= radius; dx++) {
                            const x = city.x + dx;
                            const y = city.y + dy;
                            if (x < 0 || x >= WORLD_WIDTH || y < 0 || y >= WORLD_HEIGHT) continue;
                            if (!world.isLandTile(x, y)) continue;
                            if (dx * dx + dy * dy <= radius * radius) {
                                this.territory.push({ x, y });
                            }
                        }
                    }
                });
            }

            updateDiplomacy() {
                // Find neighbors
                const neighbors = game.civilizations.filter(civ => {
                    if (civ.id === this.id || civ.destroyed || civ.nomadic) return false;
                    return this.hasSharedBorder(civ);
                });

                if (neighbors.length === 0) return;

                neighbors.forEach(neighbor => {
                    const cultureDiff = Math.abs(this.culture - neighbor.culture);
                    const techDiff = Math.abs(this.techLevel - neighbor.techLevel);

                    // Chance of war
                    if (!this.atWar && !this.allies.includes(neighbor.id)) {
                        const warChance = (cultureDiff / 200) + (techDiff / 500);
                        if (Math.random() < warChance * 0.01 * game.timeSpeed) {
                            this.declareWar(neighbor);
                        }
                    }

                    // Chance of alliance
                    if (!this.allies.includes(neighbor.id) && !this.enemies.includes(neighbor.id)) {
                        const allianceChance = Math.max(0, 0.05 - cultureDiff / 1000 - techDiff / 500);
                        if (Math.random() < allianceChance * game.timeSpeed) {
                            this.formAlliance(neighbor);
                        }
                    }
                });
            }

            hasSharedBorder(otherCiv) {
                return this.territory.some(t1 =>
                    otherCiv.territory.some(t2 =>
                        Math.abs(t1.x - t2.x) <= 2 && Math.abs(t1.y - t2.y) <= 2
                    )
                );
            }

            declareWar(enemy) {
                this.atWar = true;
                this.warTarget = enemy.id;
                this.enemies.push(enemy.id);
                enemy.atWar = true;
                enemy.warTarget = this.id;
                enemy.enemies.push(this.id);
                game.wars.push({ attacker: this.id, defender: enemy.id, startYear: game.year });
                game.addEvent(`${this.name} declares war on ${enemy.name}!`, 'war');
            }

            formAlliance(ally) {
                this.allies.push(ally.id);
                ally.allies.push(this.id);
                game.addEvent(`${this.name} forms alliance with ${ally.name}!`);
            }

            updateWar() {
                const enemy = game.getCivilization(this.warTarget);
                if (!enemy || enemy.destroyed) {
                    this.endWar();
                    return;
                }

                // Combat calculation
                const myStrength = this.militaryStrength;
                const enemyStrength = enemy.militaryStrength;

                if (Math.random() < 0.05 * game.timeSpeed) {
                    if (myStrength > enemyStrength * 1.5) {
                        // We're winning - capture city
                        if (enemy.cities.length > 0 && Math.random() < 0.3) {
                            const targetCity = enemy.cities[Math.floor(Math.random() * enemy.cities.length)];
                            targetCity.civId = this.id;
                            targetCity.population *= 0.6; // War casualties
                            this.cities.push(targetCity);
                            enemy.cities = enemy.cities.filter(c => c !== targetCity);
                            game.addEvent(`${this.name} captures ${targetCity.name}!`, 'war');

                            if (enemy.cities.length === 0) {
                                game.addEvent(`${this.name} has conquered ${enemy.name}!`, 'war');
                                enemy.destroyed = true;
                                this.endWar();
                            }
                        }
                    } else if (enemyStrength > myStrength * 1.5) {
                        // We're losing - sue for peace
                        if (Math.random() < 0.5) {
                            this.endWar();
                            enemy.endWar();
                            game.addEvent(`${this.name} sues for peace with ${enemy.name}`);
                        }
                    }
                }

                // War exhaustion
                if (game.year - this.warStartYear > 100 && Math.random() < 0.01 * game.timeSpeed) {
                    this.endWar();
                    enemy.endWar();
                    game.addEvent(`${this.name} and ${enemy.name} sign peace treaty`);
                }
            }

            endWar() {
                this.atWar = false;
                this.warTarget = null;
                game.wars = game.wars.filter(w => w.attacker !== this.id && w.defender !== this.id);
            }

            getEra() {
                for (let i = ERAS.length - 1; i >= 0; i--) {
                    if (this.techLevel >= ERAS[i].tech) {
                        return ERAS[i].name;
                    }
                }
                return ERAS[0].name;
            }
        }

        // ============================================================================
        // GAME STATE
        // ============================================================================

        class Game {
            constructor() {
                this.year = 0;
                this.running = false;
                this.timeSpeed = 1;
                this.civilizations = [];
                this.events = [];
                this.wars = [];
                this.selectedCiv = null;
                this.godPowers = {
                    terraform: 3,
                    earthquake: 2,
                    meteor: 2,
                    flood: 2,
                    plague: 2,
                    gift: 3,
                    smite: 2,
                    inspire: 3
                };
                this.activePower = null;
                this.lastUpdate = Date.now();
                this.achievements = [];
            }

            init() {
                // Spawn initial tribes
                const tribeCount = 8 + Math.floor(Math.random() * 5);
                for (let i = 0; i < tribeCount; i++) {
                    let x, y;
                    do {
                        x = Math.floor(Math.random() * WORLD_WIDTH);
                        y = Math.floor(Math.random() * WORLD_HEIGHT);
                    } while (!world.isLandTile(x, y));

                    const color = CIV_COLORS[i % CIV_COLORS.length];
                    const civ = new Civilization(i, color, x, y);
                    this.civilizations.push(civ);
                }

                this.addEvent('The first tribes emerge...', 'golden');
            }

            update() {
                if (!this.running) return;

                const now = Date.now();
                const delta = (now - this.lastUpdate) / 1000; // seconds
                this.lastUpdate = now;

                // Advance time
                const yearsPassed = delta * this.timeSpeed;
                this.year += yearsPassed;

                if (this.year > MAX_YEAR) {
                    this.year = MAX_YEAR;
                    this.running = false;
                    this.addEvent('The age of humanity draws to a close...', 'golden');
                }

                // Update civilizations
                this.civilizations.forEach(civ => civ.update());

                // Random events
                if (Math.random() < 0.001 * this.timeSpeed) {
                    this.triggerRandomEvent();
                }

                // Recharge god powers
                if (Math.random() < 0.0005 * this.timeSpeed) {
                    const powers = Object.keys(this.godPowers);
                    const power = powers[Math.floor(Math.random() * powers.length)];
                    this.godPowers[power] = Math.min(5, this.godPowers[power] + 1);
                }

                // Check achievements
                this.checkAchievements();
            }

            triggerRandomEvent() {
                const events = [
                    this.eventFamine,
                    this.eventPlague,
                    this.eventVolcano,
                    this.eventFlood,
                    this.eventBarbarians,
                    this.eventGoldenAge,
                    this.eventGreatPerson
                ];

                const event = events[Math.floor(Math.random() * events.length)];
                event.call(this);
            }

            eventFamine() {
                const civs = this.civilizations.filter(c => !c.destroyed && !c.nomadic);
                if (civs.length === 0) return;

                const civ = civs[Math.floor(Math.random() * civs.length)];
                civ.population *= 0.85;
                civ.cities.forEach(city => city.population *= 0.85);
                this.addEvent(`Famine strikes ${civ.name}!`, 'disaster');
            }

            eventPlague() {
                const civs = this.civilizations.filter(c => !c.destroyed && !c.nomadic);
                if (civs.length === 0) return;

                const civ = civs[Math.floor(Math.random() * civs.length)];
                const deathRate = 0.3 + Math.random() * 0.4;
                civ.population *= (1 - deathRate);
                civ.cities.forEach(city => city.population *= (1 - deathRate));
                this.addEvent(`Plague devastates ${civ.name}! ${Math.floor(deathRate * 100)}% perish`, 'disaster');

                // Spread to neighbors via trade
                civs.forEach(neighbor => {
                    if (neighbor.id !== civ.id && civ.hasSharedBorder(neighbor)) {
                        if (Math.random() < 0.4) {
                            neighbor.population *= 0.8;
                            neighbor.cities.forEach(city => city.population *= 0.8);
                            this.addEvent(`Plague spreads to ${neighbor.name}`, 'disaster');
                        }
                    }
                });
            }

            eventVolcano() {
                const x = Math.floor(Math.random() * WORLD_WIDTH);
                const y = Math.floor(Math.random() * WORLD_HEIGHT);

                if (!world.isLandTile(x, y)) return;

                // Destroy nearby cities
                let destroyed = false;
                this.civilizations.forEach(civ => {
                    civ.cities.forEach(city => {
                        const dist = Math.sqrt(Math.pow(city.x - x, 2) + Math.pow(city.y - y, 2));
                        if (dist < 10) {
                            city.destroyed = true;
                            destroyed = true;
                            this.addEvent(`Volcano destroys ${city.name}!`, 'disaster');
                        }
                    });
                });

                if (!destroyed) {
                    this.addEvent(`Volcano erupts at (${x}, ${y})`, 'disaster');
                }
            }

            eventFlood() {
                const civs = this.civilizations.filter(c => !c.destroyed && !c.nomadic);
                if (civs.length === 0) return;

                const civ = civs[Math.floor(Math.random() * civs.length)];
                const riverCities = civ.cities.filter(city =>
                    world.getTerrain(city.x, city.y) === TERRAIN.RIVER
                );

                if (riverCities.length > 0) {
                    const city = riverCities[Math.floor(Math.random() * riverCities.length)];
                    city.population *= 0.7;
                    this.addEvent(`Flood damages ${city.name}`, 'disaster');
                }
            }

            eventBarbarians() {
                const civs = this.civilizations.filter(c => !c.destroyed && !c.nomadic);
                if (civs.length === 0) return;

                const civ = civs[Math.floor(Math.random() * civs.length)];
                if (civ.cities.length === 0) return;

                const city = civ.cities[Math.floor(Math.random() * civ.cities.length)];

                if (city.hasWalls || civ.militaryStrength > 100) {
                    this.addEvent(`${city.name} repels barbarian attack`);
                } else {
                    city.population *= 0.6;
                    this.addEvent(`Barbarians raid ${city.name}!`, 'disaster');
                }
            }

            eventGoldenAge() {
                const civs = this.civilizations.filter(c => !c.destroyed && !c.nomadic && !c.goldenAge);
                if (civs.length === 0) return;

                const civ = civs[Math.floor(Math.random() * civs.length)];
                civ.goldenAge = true;
                civ.goldenAgeEnd = this.year + 50 + Math.random() * 100;
                this.addEvent(`${civ.name} enters a Golden Age!`, 'golden');
            }

            eventGreatPerson() {
                const civs = this.civilizations.filter(c => !c.destroyed && !c.nomadic);
                if (civs.length === 0) return;

                const civ = civs[Math.floor(Math.random() * civs.length)];
                civ.techLevel += 5 + Math.random() * 10;
                this.addEvent(`A Great Person is born in ${civ.name}!`, 'golden');
            }

            getCivilization(id) {
                return this.civilizations.find(c => c.id === id);
            }

            getCityAt(x, y) {
                for (let civ of this.civilizations) {
                    for (let city of civ.cities) {
                        if (city.x === x && city.y === y && !city.destroyed) {
                            return city;
                        }
                    }
                }
                return null;
            }

            addEvent(message, type = 'normal') {
                const event = {
                    year: Math.floor(this.year),
                    message,
                    type
                };
                this.events.push(event);
                if (this.events.length > 100) {
                    this.events.shift();
                }
                ui.updateEventLog();
            }

            usePower(power) {
                if (this.godPowers[power] <= 0) return false;
                this.godPowers[power]--;
                this.activePower = power;
                ui.updatePowers();
                return true;
            }

            applyPower(x, y) {
                if (!this.activePower) return;

                switch(this.activePower) {
                    case 'terraform':
                        this.powerTerraform(x, y);
                        break;
                    case 'earthquake':
                        this.powerEarthquake(x, y);
                        break;
                    case 'meteor':
                        this.powerMeteor(x, y);
                        break;
                    case 'flood':
                        this.powerFlood(x, y);
                        break;
                    case 'plague':
                        this.powerPlague(x, y);
                        break;
                    case 'gift':
                        this.powerGift(x, y);
                        break;
                    case 'smite':
                        this.powerSmite(x, y);
                        break;
                    case 'inspire':
                        this.powerInspire(x, y);
                        break;
                }

                this.activePower = null;
            }

            powerTerraform(x, y) {
                const idx = y * WORLD_WIDTH + x;
                const current = world.tiles[idx];

                if (current === TERRAIN.OCEAN || current === TERRAIN.BEACH) {
                    world.tiles[idx] = TERRAIN.PLAINS;
                } else if (current === TERRAIN.DESERT || current === TERRAIN.TUNDRA) {
                    world.tiles[idx] = TERRAIN.PLAINS;
                } else if (current === TERRAIN.PLAINS) {
                    world.tiles[idx] = TERRAIN.FOREST;
                }

                world.resources[idx] = world.calculateResources(world.tiles[idx], x, y);
                this.addEvent(`Divine terraforming at (${x}, ${y})`);
            }

            powerEarthquake(x, y) {
                const city = this.getCityAt(x, y);
                if (city) {
                    city.population *= 0.5;
                    this.addEvent(`Earthquake strikes ${city.name}!`, 'disaster');
                } else {
                    this.addEvent(`Earthquake at (${x}, ${y})`, 'disaster');
                }
            }

            powerMeteor(x, y) {
                const radius = 5;
                this.civilizations.forEach(civ => {
                    civ.cities.forEach(city => {
                        const dist = Math.sqrt(Math.pow(city.x - x, 2) + Math.pow(city.y - y, 2));
                        if (dist < radius) {
                            city.destroyed = true;
                            this.addEvent(`Meteor obliterates ${city.name}!`, 'disaster');
                        }
                    });
                });
            }

            powerFlood(x, y) {
                this.civilizations.forEach(civ => {
                    civ.cities.forEach(city => {
                        const dist = Math.sqrt(Math.pow(city.x - x, 2) + Math.pow(city.y - y, 2));
                        if (dist < 8) {
                            city.population *= 0.6;
                            this.addEvent(`Divine flood damages ${city.name}`, 'disaster');
                        }
                    });
                });
            }

            powerPlague(x, y) {
                const city = this.getCityAt(x, y);
                if (city) {
                    const civ = this.getCivilization(city.civId);
                    city.population *= 0.4;
                    this.addEvent(`Divine plague strikes ${city.name}!`, 'disaster');
                }
            }

            powerGift(x, y) {
                const city = this.getCityAt(x, y);
                if (city) {
                    const civ = this.getCivilization(city.civId);
                    civ.techLevel += 15;
                    this.addEvent(`${civ.name} receives divine knowledge!`, 'golden');
                }
            }

            powerSmite(x, y) {
                const city = this.getCityAt(x, y);
                if (city) {
                    city.destroyed = true;
                    this.addEvent(`${city.name} is smitten by divine wrath!`, 'disaster');
                }
            }

            powerInspire(x, y) {
                const city = this.getCityAt(x, y);
                if (city) {
                    const civ = this.getCivilization(city.civId);
                    civ.culture += 30;
                    civ.goldenAge = true;
                    civ.goldenAgeEnd = this.year + 100;
                    this.addEvent(`${civ.name} is divinely inspired!`, 'golden');
                }
            }

            checkAchievements() {
                // First to space
                const spaceCivs = this.civilizations.filter(c => !c.destroyed && c.techLevel >= 100);
                if (spaceCivs.length > 0 && !this.achievements.includes('first_space')) {
                    this.achievements.push('first_space');
                    this.addEvent(`${spaceCivs[0].name} reaches the Space Age!`, 'golden');
                }

                // Total population milestones
                const totalPop = this.civilizations.reduce((sum, c) => sum + c.population, 0);
                if (totalPop > 1000000 && !this.achievements.includes('pop_1m')) {
                    this.achievements.push('pop_1m');
                    this.addEvent(`World population exceeds 1 million!`, 'golden');
                }
            }

            save() {
                const saveData = {
                    year: this.year,
                    civilizations: this.civilizations.map(c => ({
                        ...c,
                        cities: c.cities.filter(city => !city.destroyed)
                    })),
                    events: this.events,
                    wars: this.wars,
                    godPowers: this.godPowers,
                    achievements: this.achievements
                };

                try {
                    localStorage.setItem('epoch_save', JSON.stringify(saveData));
                    this.addEvent('Game saved');
                    return true;
                } catch(e) {
                    alert('Failed to save game: ' + e.message);
                    return false;
                }
            }

            load() {
                try {
                    const saveData = JSON.parse(localStorage.getItem('epoch_save'));
                    if (!saveData) {
                        alert('No save data found');
                        return false;
                    }

                    this.year = saveData.year;
                    this.civilizations = saveData.civilizations.map(data => {
                        const civ = new Civilization(data.id, data.color, data.x, data.y);
                        Object.assign(civ, data);
                        civ.cities = data.cities.map(cityData => {
                            const city = new City(cityData.x, cityData.y, cityData.name, cityData.civId);
                            Object.assign(city, cityData);
                            return city;
                        });
                        return civ;
                    });
                    this.events = saveData.events;
                    this.wars = saveData.wars;
                    this.godPowers = saveData.godPowers;
                    this.achievements = saveData.achievements || [];

                    this.addEvent('Game loaded');
                    return true;
                } catch(e) {
                    alert('Failed to load game: ' + e.message);
                    return false;
                }
            }
        }

        // ============================================================================
        // RENDERING
        // ============================================================================

        class Renderer {
            constructor() {
                this.canvas = document.getElementById('worldCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.minimapCanvas = document.getElementById('minimap');
                this.minimapCtx = this.minimapCanvas.getContext('2d');

                this.offsetX = 0;
                this.offsetY = 0;
                this.zoom = 1;

                this.setupCanvas();
            }

            setupCanvas() {
                const container = document.getElementById('mapContainer');
                this.canvas.width = WORLD_WIDTH * TILE_SIZE * 2;
                this.canvas.height = WORLD_HEIGHT * TILE_SIZE * 2;

                this.minimapCanvas.width = 200;
                this.minimapCanvas.height = 150;

                // Center view
                this.offsetX = -(this.canvas.width - container.clientWidth) / 2;
                this.offsetY = -(this.canvas.height - container.clientHeight) / 2;
            }

            render() {
                this.ctx.save();
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Apply zoom and pan
                this.ctx.scale(this.zoom, this.zoom);
                this.ctx.translate(this.offsetX / this.zoom, this.offsetY / this.zoom);

                // Draw terrain
                this.drawTerrain();

                // Draw territories
                this.drawTerritories();

                // Draw cities
                this.drawCities();

                // Draw nomadic tribes
                this.drawTribes();

                this.ctx.restore();

                // Draw minimap
                this.drawMinimap();
            }

            drawTerrain() {
                for (let y = 0; y < WORLD_HEIGHT; y++) {
                    for (let x = 0; x < WORLD_WIDTH; x++) {
                        const terrain = world.getTerrain(x, y);
                        this.ctx.fillStyle = TERRAIN_COLORS[terrain];
                        this.ctx.fillRect(x * TILE_SIZE * 2, y * TILE_SIZE * 2, TILE_SIZE * 2, TILE_SIZE * 2);
                    }
                }
            }

            drawTerritories() {
                game.civilizations.forEach(civ => {
                    if (civ.destroyed || civ.nomadic) return;

                    this.ctx.fillStyle = civ.color + '20';
                    this.ctx.strokeStyle = civ.color;
                    this.ctx.lineWidth = 0.5;

                    civ.territory.forEach(tile => {
                        this.ctx.fillRect(tile.x * TILE_SIZE * 2, tile.y * TILE_SIZE * 2,
                                        TILE_SIZE * 2, TILE_SIZE * 2);
                    });
                });
            }

            drawCities() {
                game.civilizations.forEach(civ => {
                    if (civ.destroyed) return;

                    civ.cities.forEach(city => {
                        if (city.destroyed) return;

                        const x = city.x * TILE_SIZE * 2 + TILE_SIZE;
                        const y = city.y * TILE_SIZE * 2 + TILE_SIZE;
                        const size = city.getSize();

                        // City circle
                        this.ctx.fillStyle = civ.color;
                        this.ctx.strokeStyle = '#fff';
                        this.ctx.lineWidth = 1;
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, size, 0, Math.PI * 2);
                        this.ctx.fill();
                        this.ctx.stroke();

                        // Walls
                        if (city.hasWalls) {
                            this.ctx.strokeStyle = '#555';
                            this.ctx.lineWidth = 2;
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, size + 2, 0, Math.PI * 2);
                            this.ctx.stroke();
                        }

                        // University
                        if (city.hasUniversity && this.zoom > 0.8) {
                            this.ctx.fillStyle = '#ffd700';
                            this.ctx.fillRect(x - 2, y - size - 4, 4, 3);
                        }

                        // City name
                        if (this.zoom > 1.2) {
                            this.ctx.fillStyle = '#fff';
                            this.ctx.strokeStyle = '#000';
                            this.ctx.lineWidth = 3;
                            this.ctx.font = '10px Arial';
                            this.ctx.textAlign = 'center';
                            this.ctx.strokeText(city.name, x, y - size - 8);
                            this.ctx.fillText(city.name, x, y - size - 8);
                        }
                    });
                });
            }

            drawTribes() {
                game.civilizations.forEach(civ => {
                    if (!civ.nomadic || civ.destroyed) return;

                    const x = civ.x * TILE_SIZE * 2 + TILE_SIZE;
                    const y = civ.y * TILE_SIZE * 2 + TILE_SIZE;

                    this.ctx.fillStyle = civ.color;
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 1;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 3, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.stroke();
                });
            }

            drawMinimap() {
                const ctx = this.minimapCtx;
                const w = this.minimapCanvas.width;
                const h = this.minimapCanvas.height;
                const scaleX = w / WORLD_WIDTH;
                const scaleY = h / WORLD_HEIGHT;

                ctx.clearRect(0, 0, w, h);

                // Draw simplified terrain
                for (let y = 0; y < WORLD_HEIGHT; y += 2) {
                    for (let x = 0; x < WORLD_WIDTH; x += 2) {
                        const terrain = world.getTerrain(x, y);
                        ctx.fillStyle = TERRAIN_COLORS[terrain];
                        ctx.fillRect(x * scaleX, y * scaleY, scaleX * 2, scaleY * 2);
                    }
                }

                // Draw civs
                game.civilizations.forEach(civ => {
                    if (civ.destroyed) return;
                    ctx.fillStyle = civ.color;
                    civ.cities.forEach(city => {
                        if (!city.destroyed) {
                            ctx.fillRect(city.x * scaleX - 1, city.y * scaleY - 1, 2, 2);
                        }
                    });
                });

                // Draw viewport
                const container = document.getElementById('mapContainer');
                const viewX = -this.offsetX / this.zoom / (TILE_SIZE * 2) * scaleX;
                const viewY = -this.offsetY / this.zoom / (TILE_SIZE * 2) * scaleY;
                const viewW = container.clientWidth / this.zoom / (TILE_SIZE * 2) * scaleX;
                const viewH = container.clientHeight / this.zoom / (TILE_SIZE * 2) * scaleY;

                ctx.strokeStyle = '#00d4ff';
                ctx.lineWidth = 2;
                ctx.strokeRect(viewX, viewY, viewW, viewH);
            }

            worldToScreen(x, y) {
                return {
                    x: x * TILE_SIZE * 2 * this.zoom + this.offsetX,
                    y: y * TILE_SIZE * 2 * this.zoom + this.offsetY
                };
            }

            screenToWorld(screenX, screenY) {
                return {
                    x: Math.floor((screenX - this.offsetX) / (TILE_SIZE * 2 * this.zoom)),
                    y: Math.floor((screenY - this.offsetY) / (TILE_SIZE * 2 * this.zoom))
                };
            }
        }

        // ============================================================================
        // UI CONTROLLER
        // ============================================================================

        class UI {
            constructor() {
                this.setupEventListeners();
            }

            setupEventListeners() {
                // Time controls
                document.getElementById('pauseBtn').addEventListener('click', () => {
                    game.running = !game.running;
                    document.getElementById('pauseBtn').textContent = game.running ? '‚è∏ Pause' : '‚ñ∂ Play';
                });

                document.getElementById('speed1x').addEventListener('click', () => this.setSpeed(1));
                document.getElementById('speed2x').addEventListener('click', () => this.setSpeed(2));
                document.getElementById('speed5x').addEventListener('click', () => this.setSpeed(5));
                document.getElementById('speed10x').addEventListener('click', () => this.setSpeed(10));
                document.getElementById('speed50x').addEventListener('click', () => this.setSpeed(50));

                // God powers
                document.getElementById('powerTerraform').addEventListener('click', () =>
                    game.usePower('terraform'));
                document.getElementById('powerEarthquake').addEventListener('click', () =>
                    game.usePower('earthquake'));
                document.getElementById('powerMeteor').addEventListener('click', () =>
                    game.usePower('meteor'));
                document.getElementById('powerFlood').addEventListener('click', () =>
                    game.usePower('flood'));
                document.getElementById('powerPlague').addEventListener('click', () =>
                    game.usePower('plague'));
                document.getElementById('powerGift').addEventListener('click', () =>
                    game.usePower('gift'));
                document.getElementById('powerSmite').addEventListener('click', () =>
                    game.usePower('smite'));
                document.getElementById('powerInspire').addEventListener('click', () =>
                    game.usePower('inspire'));

                // Save/Load
                document.getElementById('saveBtn').addEventListener('click', () => game.save());
                document.getElementById('loadBtn').addEventListener('click', () => {
                    if (game.load()) {
                        this.updateAll();
                    }
                });

                // Stats
                document.getElementById('statsBtn').addEventListener('click', () => this.showStats());
                document.getElementById('closeStats').addEventListener('click', () =>
                    document.getElementById('statsModal').style.display = 'none');

                // Canvas interactions
                this.setupCanvasInteraction();

                // Zoom
                document.getElementById('zoomIn').addEventListener('click', () => this.zoom(1.2));
                document.getElementById('zoomOut').addEventListener('click', () => this.zoom(0.8));

                // Start button
                document.getElementById('startBtn').addEventListener('click', () => {
                    document.getElementById('welcomeModal').style.display = 'none';
                    game.running = true;
                });
            }

            setupCanvasInteraction() {
                const canvas = renderer.canvas;
                const container = document.getElementById('mapContainer');
                let isDragging = false;
                let lastX, lastY;

                canvas.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    lastX = e.clientX;
                    lastY = e.clientY;
                });

                canvas.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        const dx = e.clientX - lastX;
                        const dy = e.clientY - lastY;
                        renderer.offsetX += dx;
                        renderer.offsetY += dy;
                        lastX = e.clientX;
                        lastY = e.clientY;
                    } else {
                        this.updateTooltip(e);
                    }
                });

                canvas.addEventListener('mouseup', () => {
                    isDragging = false;
                });

                canvas.addEventListener('mouseleave', () => {
                    isDragging = false;
                    document.getElementById('tooltip').style.display = 'none';
                });

                canvas.addEventListener('click', (e) => {
                    if (game.activePower) {
                        const rect = canvas.getBoundingClientRect();
                        const pos = renderer.screenToWorld(e.clientX - rect.left, e.clientY - rect.top);
                        game.applyPower(pos.x, pos.y);
                        return;
                    }

                    const rect = canvas.getBoundingClientRect();
                    const pos = renderer.screenToWorld(e.clientX - rect.left, e.clientY - rect.top);
                    const city = game.getCityAt(pos.x, pos.y);

                    if (city) {
                        game.selectedCiv = city.civId;
                        this.updateSelectedCiv();
                    }
                });

                container.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
                    this.zoom(zoomFactor);
                });
            }

            zoom(factor) {
                renderer.zoom *= factor;
                renderer.zoom = Math.max(0.5, Math.min(3, renderer.zoom));
            }

            updateTooltip(e) {
                const tooltip = document.getElementById('tooltip');
                const canvas = renderer.canvas;
                const rect = canvas.getBoundingClientRect();
                const pos = renderer.screenToWorld(e.clientX - rect.left, e.clientY - rect.top);

                if (pos.x < 0 || pos.x >= WORLD_WIDTH || pos.y < 0 || pos.y >= WORLD_HEIGHT) {
                    tooltip.style.display = 'none';
                    return;
                }

                const city = game.getCityAt(pos.x, pos.y);
                const terrain = world.getTerrain(pos.x, pos.y);
                const terrainName = Object.keys(TERRAIN).find(k => TERRAIN[k] === terrain);

                let html = `<strong>${terrainName}</strong><br>`;

                if (city && !city.destroyed) {
                    const civ = game.getCivilization(city.civId);
                    html += `<strong style="color:${civ.color}">${city.name}</strong><br>`;
                    html += `Population: ${Math.floor(city.population).toLocaleString()}<br>`;
                    html += `Era: ${civ.getEra()}`;
                }

                tooltip.innerHTML = html;
                tooltip.style.display = 'block';
                tooltip.style.left = (e.clientX + 10) + 'px';
                tooltip.style.top = (e.clientY + 10) + 'px';
            }

            setSpeed(speed) {
                game.timeSpeed = speed;
                document.querySelectorAll('#timeControls .btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.getElementById(`speed${speed}x`).classList.add('active');
            }

            updateAll() {
                this.updateStats();
                this.updateTimeline();
                this.updateSelectedCiv();
                this.updateLegend();
                this.updatePowers();
            }

            updateStats() {
                document.getElementById('currentYear').textContent = Math.floor(game.year);

                const highestEra = game.civilizations.reduce((max, civ) =>
                    civ.destroyed ? max : Math.max(max, civ.techLevel), 0);
                document.getElementById('currentEra').textContent =
                    ERAS.find(e => highestEra >= e.tech)?.name || 'Stone Age';

                const totalPop = game.civilizations.reduce((sum, civ) =>
                    sum + (civ.destroyed ? 0 : civ.population), 0);
                document.getElementById('totalPop').textContent = Math.floor(totalPop).toLocaleString();

                const activeCivs = game.civilizations.filter(c => !c.destroyed);
                document.getElementById('civCount').textContent = activeCivs.length;

                const totalCities = activeCivs.reduce((sum, civ) =>
                    sum + civ.cities.filter(c => !c.destroyed).length, 0);
                document.getElementById('cityCount').textContent = totalCities;

                document.getElementById('warCount').textContent = game.wars.length;
            }

            updateTimeline() {
                const progress = (game.year / MAX_YEAR) * 100;
                document.getElementById('timelineProgress').style.width = progress + '%';
                document.getElementById('timelineYear').textContent = `Year ${Math.floor(game.year)}`;
            }

            updateEventLog() {
                const log = document.getElementById('eventLog');
                log.innerHTML = '';

                const recent = game.events.slice(-20).reverse();
                recent.forEach(event => {
                    const div = document.createElement('div');
                    div.className = 'event-item ' + event.type;
                    div.innerHTML = `
                        <span class="event-year">Year ${event.year}</span><br>
                        ${event.message}
                    `;
                    log.appendChild(div);
                });
            }

            updateSelectedCiv() {
                const info = document.getElementById('selectedCivInfo');

                if (!game.selectedCiv) {
                    info.innerHTML = '<p style="color:#888;font-size:13px;">Click a civilization on the map to view details</p>';
                    return;
                }

                const civ = game.getCivilization(game.selectedCiv);
                if (!civ || civ.destroyed) {
                    info.innerHTML = '<p style="color:#888;font-size:13px;">This civilization has fallen</p>';
                    return;
                }

                const html = `
                    <div class="civ-name" style="color:${civ.color}">${civ.name}</div>
                    <div class="info-row">
                        <span class="info-label">Era</span>
                        <span class="info-value">${civ.getEra()}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Population</span>
                        <span class="info-value">${Math.floor(civ.population).toLocaleString()}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Cities</span>
                        <span class="info-value">${civ.cities.filter(c => !c.destroyed).length}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Technology</span>
                        <span class="info-value">${Math.floor(civ.techLevel)}/100</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Government</span>
                        <span class="info-value">${civ.government}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Military</span>
                        <span class="info-value">${Math.floor(civ.militaryStrength)}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Status</span>
                        <span class="info-value">${civ.goldenAge ? '‚ú® Golden Age' :
                            (civ.atWar ? '‚öîÔ∏è At War' : '‚úì Peace')}</span>
                    </div>
                    ${civ.allies.length > 0 ? `
                        <div class="info-row">
                            <span class="info-label">Allies</span>
                            <span class="info-value">${civ.allies.length}</span>
                        </div>
                    ` : ''}
                `;

                info.innerHTML = html;
            }

            updateLegend() {
                const legend = document.getElementById('legend');
                legend.innerHTML = '';

                const activeCivs = game.civilizations.filter(c => !c.destroyed);
                activeCivs.sort((a, b) => b.population - a.population);

                activeCivs.forEach(civ => {
                    const div = document.createElement('div');
                    div.className = 'legend-item';
                    div.style.cursor = 'pointer';
                    div.addEventListener('click', () => {
                        game.selectedCiv = civ.id;
                        this.updateSelectedCiv();
                    });

                    div.innerHTML = `
                        <div class="legend-color" style="background:${civ.color}"></div>
                        <div class="legend-info">
                            <strong>${civ.name}</strong>
                            <div class="legend-era">${civ.getEra()} ‚Ä¢ ${Math.floor(civ.population).toLocaleString()}</div>
                        </div>
                    `;
                    legend.appendChild(div);
                });
            }

            updatePowers() {
                Object.keys(game.godPowers).forEach(power => {
                    const btn = document.getElementById(`power${power.charAt(0).toUpperCase() + power.slice(1)}`);
                    if (!btn) return;

                    const uses = game.godPowers[power];
                    btn.disabled = uses <= 0;

                    let existingUses = btn.querySelector('.power-uses');
                    if (!existingUses) {
                        existingUses = document.createElement('div');
                        existingUses.className = 'power-uses';
                        btn.appendChild(existingUses);
                    }
                    existingUses.textContent = `${uses} uses`;
                });
            }

            showStats() {
                const modal = document.getElementById('statsModal');
                const content = document.getElementById('statsContent');

                const activeCivs = game.civilizations.filter(c => !c.destroyed);
                const fallenCivs = game.civilizations.filter(c => c.destroyed);
                const totalPop = activeCivs.reduce((sum, civ) => sum + civ.population, 0);

                let html = `
                    <div class="achievement">
                        <h3>World Statistics</h3>
                        <p>Current Year: ${Math.floor(game.year)}</p>
                        <p>Total Population: ${Math.floor(totalPop).toLocaleString()}</p>
                        <p>Active Civilizations: ${activeCivs.length}</p>
                        <p>Fallen Civilizations: ${fallenCivs.length}</p>
                        <p>Active Wars: ${game.wars.length}</p>
                    </div>
                `;

                if (activeCivs.length > 0) {
                    const largest = activeCivs.reduce((max, civ) =>
                        civ.population > max.population ? civ : max);
                    const mostAdvanced = activeCivs.reduce((max, civ) =>
                        civ.techLevel > max.techLevel ? civ : max);
                    const oldest = activeCivs.reduce((min, civ) =>
                        civ.founded < min.founded ? civ : min);

                    html += `
                        <div class="achievement">
                            <h3>üèÜ Records</h3>
                            <p>Largest Civilization: ${largest.name} (${Math.floor(largest.population).toLocaleString()})</p>
                            <p>Most Advanced: ${mostAdvanced.name} (${mostAdvanced.getEra()})</p>
                            <p>Oldest: ${oldest.name} (founded year ${oldest.founded})</p>
                        </div>
                    `;
                }

                if (game.achievements.length > 0) {
                    html += '<div class="achievement"><h3>‚ú® Achievements</h3>';
                    game.achievements.forEach(ach => {
                        if (ach === 'first_space') html += '<p>üöÄ First civilization reached Space Age</p>';
                        if (ach === 'pop_1m') html += '<p>üåç World population exceeded 1 million</p>';
                    });
                    html += '</div>';
                }

                content.innerHTML = html;
                modal.style.display = 'flex';
            }
        }

        // ============================================================================
        // GAME LOOP
        // ============================================================================

        let world;
        let game;
        let renderer;
        let ui;

        function init() {
            world = new World();
            game = new Game();
            renderer = new Renderer();
            ui = new UI();

            game.init();
            ui.updateAll();

            gameLoop();
        }

        function gameLoop() {
            game.update();
            renderer.render();
            ui.updateStats();
            ui.updateTimeline();

            if (Math.floor(game.year) % 10 === 0 && game.running) {
                ui.updateLegend();
            }

            requestAnimationFrame(gameLoop);
        }

        // Start game when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>