<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SPORE MIND - Hive Mind Evolution</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            color: #00ff88;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        #gameCanvas {
            display: block;
            background: #000;
            cursor: crosshair;
        }

        #titleScreen, #gameOver {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        #titleScreen h1 {
            font-size: 72px;
            color: #00ff88;
            text-shadow: 0 0 20px #00ff88, 0 0 40px #00ff88;
            margin-bottom: 20px;
            letter-spacing: 8px;
        }

        #titleScreen p {
            font-size: 18px;
            color: #66ffbb;
            max-width: 600px;
            text-align: center;
            line-height: 1.6;
            margin-bottom: 30px;
        }

        .btn {
            background: #00ff88;
            color: #000;
            border: none;
            padding: 15px 40px;
            font-size: 20px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .btn:hover {
            background: #66ffbb;
            box-shadow: 0 0 20px #00ff88;
        }

        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 20, 10, 0.9);
            border: 2px solid #00ff88;
            padding: 15px;
            font-size: 14px;
            min-width: 300px;
            z-index: 10;
        }

        #hud h3 {
            margin-bottom: 10px;
            color: #00ff88;
            text-shadow: 0 0 5px #00ff88;
        }

        .stat {
            margin: 5px 0;
            display: flex;
            justify-content: space-between;
        }

        .stat-label {
            color: #66ffbb;
        }

        .stat-value {
            color: #00ff88;
            font-weight: bold;
        }

        .resource-bar {
            width: 100%;
            height: 8px;
            background: #001a0a;
            margin-top: 3px;
            border: 1px solid #00ff88;
            overflow: hidden;
        }

        .resource-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #66ffbb);
            transition: width 0.3s;
        }

        #mutationPanel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 20, 10, 0.98);
            border: 3px solid #00ff88;
            padding: 30px;
            z-index: 50;
            display: none;
            min-width: 500px;
        }

        #mutationPanel h2 {
            color: #00ff88;
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #00ff88;
        }

        .mutation-option {
            background: rgba(0, 40, 20, 0.8);
            border: 2px solid #00ff88;
            padding: 15px;
            margin: 10px 0;
            cursor: pointer;
            transition: all 0.3s;
        }

        .mutation-option:hover {
            background: rgba(0, 60, 30, 0.9);
            box-shadow: 0 0 15px #00ff88;
        }

        .mutation-option h3 {
            color: #00ff88;
            margin-bottom: 5px;
        }

        .mutation-option p {
            color: #66ffbb;
            font-size: 12px;
        }

        #eventLog {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 20, 10, 0.9);
            border: 2px solid #00ff88;
            padding: 10px;
            max-width: 350px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 10;
        }

        .event-message {
            margin: 5px 0;
            font-size: 12px;
            color: #66ffbb;
        }

        .event-warning {
            color: #ffaa00;
        }

        .event-success {
            color: #00ff88;
        }

        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
        }

        #controls .btn {
            padding: 10px 20px;
            font-size: 14px;
            margin: 5px;
        }

        .cell-type-legend {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #00ff88;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
            font-size: 12px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
            border: 1px solid #00ff88;
        }

        #gameOver h2 {
            font-size: 48px;
            color: #00ff88;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #00ff88;
        }

        #gameOver p {
            font-size: 18px;
            color: #66ffbb;
            margin: 10px 0;
            max-width: 600px;
            text-align: center;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="titleScreen">
        <h1>SPORE MIND</h1>
        <p>
            You are a microscopic organism in a petri dish. Split, specialize, and evolve.
            Compete with AI species for resources. Survive environmental threats.
            Adapt or perish in the primordial soup.
        </p>
        <button class="btn" onclick="game.startGame()">BEGIN EVOLUTION</button>
        <button class="btn" onclick="game.loadGame()">LOAD COLONY</button>
    </div>

    <div id="hud" class="hidden">
        <h3>COLONY STATUS</h3>
        <div class="stat">
            <span class="stat-label">Generation:</span>
            <span class="stat-value" id="generation">1</span>
        </div>
        <div class="stat">
            <span class="stat-label">Total Cells:</span>
            <span class="stat-value" id="cellCount">1</span>
        </div>
        <div class="stat">
            <span class="stat-label">Time:</span>
            <span class="stat-value" id="gameTime">0:00</span>
        </div>

        <div style="margin-top: 15px;">
            <div class="stat">
                <span class="stat-label">Glucose:</span>
                <span class="stat-value" id="glucose">0</span>
            </div>
            <div class="resource-bar"><div class="resource-fill" id="glucoseBar"></div></div>

            <div class="stat">
                <span class="stat-label">Amino Acids:</span>
                <span class="stat-value" id="amino">0</span>
            </div>
            <div class="resource-bar"><div class="resource-fill" id="aminoBar"></div></div>

            <div class="stat">
                <span class="stat-label">Minerals:</span>
                <span class="stat-value" id="minerals">0</span>
            </div>
            <div class="resource-bar"><div class="resource-fill" id="mineralsBar"></div></div>

            <div class="stat">
                <span class="stat-label">DNA Fragments:</span>
                <span class="stat-value" id="dna">0</span>
            </div>
            <div class="resource-bar"><div class="resource-fill" id="dnaBar"></div></div>
        </div>

        <div class="cell-type-legend">
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(0, 255, 136, 0.7);"></div>
                <span>Gatherer</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(255, 68, 68, 0.7);"></div>
                <span>Fighter</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(68, 170, 255, 0.7);"></div>
                <span>Scout</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(255, 204, 68, 0.7);"></div>
                <span>Builder</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(255, 102, 255, 0.7);"></div>
                <span>Breeder</span>
            </div>
        </div>
    </div>

    <div id="controls" class="hidden">
        <button class="btn" onclick="game.togglePause()">PAUSE</button>
        <button class="btn" onclick="game.saveGame()">SAVE</button>
    </div>

    <div id="mutationPanel">
        <h2>EVOLUTIONARY MUTATION AVAILABLE</h2>
        <p style="text-align: center; color: #66ffbb; margin-bottom: 20px;">Choose one adaptation for your colony:</p>
        <div id="mutationOptions"></div>
    </div>

    <div id="eventLog" class="hidden"></div>

    <div id="gameOver" class="hidden">
        <h2 id="endingTitle"></h2>
        <p id="endingMessage"></p>
        <p id="finalStats"></p>
        <button class="btn" onclick="location.reload()">NEW COLONY</button>
    </div>

    <script>
        const game = {
            canvas: null,
            ctx: null,
            width: 0,
            height: 0,
            running: false,
            paused: false,

            // Camera
            camera: {
                x: 0,
                y: 0,
                zoom: 1.0,
                targetZoom: 1.0
            },

            // World
            worldSize: 3000,

            // Player colony
            playerCells: [],
            resources: {
                glucose: 50,
                amino: 50,
                minerals: 50,
                dna: 0
            },

            // AI colonies
            aiColonies: [],

            // Environment
            nutrients: [],
            hazards: [],

            // Game state
            generation: 1,
            startTime: Date.now(),
            lastMutationTime: 0,
            mutationInterval: 60000, // 60 seconds

            // Traits
            traits: {
                speed: 1.0,
                size: 1.0,
                toxinResistance: 0.5,
                efficiency: 1.0,
                reproduction: 1.0,
                armor: 0.5,
                vision: 1.0
            },

            // Audio
            audioCtx: null,

            // Input
            mouse: {
                x: 0,
                y: 0,
                worldX: 0,
                worldY: 0,
                down: false
            },

            init() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.resize();
                window.addEventListener('resize', () => this.resize());

                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                this.canvas.addEventListener('wheel', (e) => this.handleWheel(e));

                // Initialize audio
                this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            },

            resize() {
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                this.canvas.width = this.width;
                this.canvas.height = this.height;
            },

            startGame() {
                document.getElementById('titleScreen').classList.add('hidden');
                document.getElementById('hud').classList.remove('hidden');
                document.getElementById('controls').classList.remove('hidden');
                document.getElementById('eventLog').classList.remove('hidden');

                this.running = true;
                this.startTime = Date.now();
                this.lastMutationTime = Date.now();

                // Initialize world
                this.initWorld();
                this.initPlayerColony();
                this.initAIColonies();

                this.logEvent('Your colony awakens in the primordial soup...', 'success');
                this.playSound(440, 0.1, 0.3);

                this.gameLoop();
            },

            initWorld() {
                // Generate nutrients
                for (let i = 0; i < 150; i++) {
                    this.nutrients.push({
                        x: Math.random() * this.worldSize,
                        y: Math.random() * this.worldSize,
                        type: ['glucose', 'amino', 'minerals', 'dna'][Math.floor(Math.random() * 4)],
                        amount: 10 + Math.random() * 20,
                        radius: 5 + Math.random() * 10
                    });
                }

                // Generate hazards
                for (let i = 0; i < 20; i++) {
                    this.hazards.push({
                        x: Math.random() * this.worldSize,
                        y: Math.random() * this.worldSize,
                        type: ['acid', 'thermal'][Math.floor(Math.random() * 2)],
                        radius: 30 + Math.random() * 50,
                        damage: 0.5 + Math.random() * 1.5
                    });
                }
            },

            initPlayerColony() {
                this.playerCells.push(this.createCell(
                    this.worldSize / 2,
                    this.worldSize / 2,
                    'gatherer',
                    'player'
                ));

                this.camera.x = this.worldSize / 2;
                this.camera.y = this.worldSize / 2;
            },

            initAIColonies() {
                const strategies = ['aggressive', 'defensive', 'parasitic', 'explosive'];
                const colors = [
                    'rgba(255, 68, 68, 0.7)',
                    'rgba(68, 170, 255, 0.7)',
                    'rgba(170, 68, 255, 0.7)',
                    'rgba(255, 170, 68, 0.7)'
                ];

                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2;
                    const distance = this.worldSize * 0.3;

                    this.aiColonies.push({
                        strategy: strategies[i],
                        color: colors[i],
                        cells: [this.createCell(
                            this.worldSize / 2 + Math.cos(angle) * distance,
                            this.worldSize / 2 + Math.sin(angle) * distance,
                            'gatherer',
                            'ai',
                            colors[i]
                        )],
                        resources: {
                            glucose: 50,
                            amino: 50,
                            minerals: 50,
                            dna: 0
                        }
                    });
                }
            },

            createCell(x, y, type, owner, color = null) {
                const baseSize = 8 * this.traits.size;
                const speeds = {
                    gatherer: 2.0,
                    fighter: 2.5,
                    scout: 3.5,
                    builder: 1.5,
                    breeder: 1.8
                };

                const colors = {
                    gatherer: 'rgba(0, 255, 136, 0.7)',
                    fighter: 'rgba(255, 68, 68, 0.7)',
                    scout: 'rgba(68, 170, 255, 0.7)',
                    builder: 'rgba(255, 204, 68, 0.7)',
                    breeder: 'rgba(255, 102, 255, 0.7)'
                };

                return {
                    x,
                    y,
                    vx: 0,
                    vy: 0,
                    type,
                    owner,
                    color: color || colors[type],
                    size: baseSize,
                    speed: speeds[type] * this.traits.speed,
                    health: 100,
                    energy: 100,
                    target: null,
                    age: 0,
                    divisionCooldown: 0
                };
            },

            gameLoop() {
                if (!this.running) return;

                if (!this.paused) {
                    this.update();
                }
                this.render();
                this.updateHUD();

                requestAnimationFrame(() => this.gameLoop());
            },

            update() {
                const dt = 1 / 60;

                // Update player cells
                this.updateCells(this.playerCells, this.resources);

                // Update AI colonies
                for (const colony of this.aiColonies) {
                    this.updateCells(colony.cells, colony.resources);
                    this.updateAI(colony);
                }

                // Update camera
                this.updateCamera();

                // Check for mutations
                if (Date.now() - this.lastMutationTime > this.mutationInterval) {
                    this.showMutationOptions();
                    this.lastMutationTime = Date.now();
                }

                // Environmental events
                if (Math.random() < 0.001) {
                    this.triggerEnvironmentalEvent();
                }

                // Respawn nutrients
                if (Math.random() < 0.05 && this.nutrients.length < 200) {
                    this.nutrients.push({
                        x: Math.random() * this.worldSize,
                        y: Math.random() * this.worldSize,
                        type: ['glucose', 'amino', 'minerals', 'dna'][Math.floor(Math.random() * 4)],
                        amount: 10 + Math.random() * 20,
                        radius: 5 + Math.random() * 10
                    });
                }

                // Check win/lose conditions
                this.checkGameEnd();

                // Auto-zoom based on colony size
                const totalCells = this.playerCells.length;
                if (totalCells > 50) {
                    this.camera.targetZoom = 0.5;
                } else if (totalCells > 20) {
                    this.camera.targetZoom = 0.7;
                } else {
                    this.camera.targetZoom = 1.0;
                }
            },

            updateCells(cells, resources) {
                for (let i = cells.length - 1; i >= 0; i--) {
                    const cell = cells[i];

                    cell.age++;
                    cell.energy -= 0.05;
                    cell.divisionCooldown = Math.max(0, cell.divisionCooldown - 1);

                    // Die if no energy
                    if (cell.energy <= 0 || cell.health <= 0) {
                        cells.splice(i, 1);
                        continue;
                    }

                    // Behavior based on type
                    if (cell.type === 'gatherer') {
                        this.updateGatherer(cell, resources);
                    } else if (cell.type === 'fighter') {
                        this.updateFighter(cell, cells);
                    } else if (cell.type === 'scout') {
                        this.updateScout(cell);
                    } else if (cell.type === 'builder') {
                        this.updateBuilder(cell, cells, resources);
                    } else if (cell.type === 'breeder') {
                        this.updateBreeder(cell, cells, resources);
                    }

                    // Apply velocity
                    cell.x += cell.vx;
                    cell.y += cell.vy;

                    // Friction
                    cell.vx *= 0.95;
                    cell.vy *= 0.95;

                    // Keep in bounds
                    cell.x = Math.max(50, Math.min(this.worldSize - 50, cell.x));
                    cell.y = Math.max(50, Math.min(this.worldSize - 50, cell.y));

                    // Check hazards
                    for (const hazard of this.hazards) {
                        const dx = cell.x - hazard.x;
                        const dy = cell.y - hazard.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < hazard.radius) {
                            const damage = hazard.damage * (1 - this.traits.toxinResistance);
                            cell.health -= damage;
                        }
                    }
                }
            },

            updateGatherer(cell, resources) {
                // Find nearest nutrient
                let nearest = null;
                let nearestDist = Infinity;

                for (const nutrient of this.nutrients) {
                    const dx = nutrient.x - cell.x;
                    const dy = nutrient.y - cell.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < nearestDist && dist < 200 * this.traits.vision) {
                        nearest = nutrient;
                        nearestDist = dist;
                    }
                }

                if (nearest) {
                    const dx = nearest.x - cell.x;
                    const dy = nearest.y - cell.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < nearest.radius + cell.size) {
                        // Collect nutrient
                        const amount = Math.min(nearest.amount, 5 * this.traits.efficiency);
                        resources[nearest.type] += amount;
                        nearest.amount -= amount;
                        cell.energy = Math.min(100, cell.energy + 2);

                        if (nearest.amount <= 0) {
                            this.nutrients.splice(this.nutrients.indexOf(nearest), 1);
                        }
                    } else {
                        // Move toward nutrient
                        cell.vx += (dx / dist) * cell.speed * 0.1;
                        cell.vy += (dy / dist) * cell.speed * 0.1;
                    }
                }
            },

            updateFighter(cell, allCells) {
                // Find nearest enemy
                let nearest = null;
                let nearestDist = Infinity;

                for (const other of [...this.playerCells, ...this.aiColonies.flatMap(c => c.cells)]) {
                    if (other === cell || other.owner === cell.owner) continue;

                    const dx = other.x - cell.x;
                    const dy = other.y - cell.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < nearestDist && dist < 250 * this.traits.vision) {
                        nearest = other;
                        nearestDist = dist;
                    }
                }

                if (nearest) {
                    const dx = nearest.x - cell.x;
                    const dy = nearest.y - cell.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < cell.size + nearest.size) {
                        // Attack
                        const damage = 2 * (1 - nearest.armor || 0.5);
                        nearest.health -= damage;
                        cell.energy -= 1;
                    } else {
                        // Chase
                        cell.vx += (dx / dist) * cell.speed * 0.15;
                        cell.vy += (dy / dist) * cell.speed * 0.15;
                    }
                }
            },

            updateScout(cell) {
                // Random exploration with bias toward unexplored areas
                if (Math.random() < 0.05) {
                    cell.vx += (Math.random() - 0.5) * cell.speed * 0.3;
                    cell.vy += (Math.random() - 0.5) * cell.speed * 0.3;
                }
            },

            updateBuilder(cell, cells, resources) {
                // Create structures (new cells) if resources available
                if (cell.divisionCooldown === 0 && resources.amino > 30 && resources.minerals > 30) {
                    const newCell = this.createCell(
                        cell.x + (Math.random() - 0.5) * 20,
                        cell.y + (Math.random() - 0.5) * 20,
                        'gatherer',
                        cell.owner,
                        cell.owner === 'player' ? null : cell.color
                    );
                    cells.push(newCell);
                    resources.amino -= 30;
                    resources.minerals -= 30;
                    cell.divisionCooldown = 300 / this.traits.reproduction;

                    if (cell.owner === 'player') {
                        this.playSound(660, 0.05, 0.2);
                    }
                }
            },

            updateBreeder(cell, cells, resources) {
                // Rapid reproduction
                if (cell.divisionCooldown === 0 && resources.glucose > 20 && cells.length < 200) {
                    const types = ['gatherer', 'fighter', 'scout', 'builder', 'breeder'];
                    const newType = types[Math.floor(Math.random() * types.length)];

                    const newCell = this.createCell(
                        cell.x + (Math.random() - 0.5) * 20,
                        cell.y + (Math.random() - 0.5) * 20,
                        newType,
                        cell.owner,
                        cell.owner === 'player' ? null : cell.color
                    );
                    cells.push(newCell);
                    resources.glucose -= 20;
                    cell.divisionCooldown = 200 / this.traits.reproduction;
                    cell.energy -= 10;

                    if (cell.owner === 'player') {
                        this.generation++;
                        this.playSound(880, 0.05, 0.15);
                    }
                }
            },

            updateAI(colony) {
                // AI strategy behavior
                if (colony.strategy === 'aggressive') {
                    // Produce more fighters
                    if (Math.random() < 0.01 && colony.resources.amino > 30) {
                        const randomCell = colony.cells[Math.floor(Math.random() * colony.cells.length)];
                        if (randomCell) {
                            colony.cells.push(this.createCell(
                                randomCell.x + Math.random() * 30 - 15,
                                randomCell.y + Math.random() * 30 - 15,
                                'fighter',
                                'ai',
                                colony.color
                            ));
                            colony.resources.amino -= 30;
                        }
                    }
                } else if (colony.strategy === 'defensive') {
                    // Cluster cells together
                    for (const cell of colony.cells) {
                        const center = this.getCellCenter(colony.cells);
                        const dx = center.x - cell.x;
                        const dy = center.y - cell.y;
                        cell.vx += dx * 0.001;
                        cell.vy += dy * 0.001;
                    }
                } else if (colony.strategy === 'explosive') {
                    // Rapid reproduction
                    if (Math.random() < 0.02 && colony.resources.glucose > 15 && colony.cells.length < 150) {
                        const randomCell = colony.cells[Math.floor(Math.random() * colony.cells.length)];
                        if (randomCell) {
                            colony.cells.push(this.createCell(
                                randomCell.x + Math.random() * 30 - 15,
                                randomCell.y + Math.random() * 30 - 15,
                                'breeder',
                                'ai',
                                colony.color
                            ));
                            colony.resources.glucose -= 15;
                        }
                    }
                }
            },

            getCellCenter(cells) {
                if (cells.length === 0) return { x: 0, y: 0 };
                let sumX = 0, sumY = 0;
                for (const cell of cells) {
                    sumX += cell.x;
                    sumY += cell.y;
                }
                return { x: sumX / cells.length, y: sumY / cells.length };
            },

            updateCamera() {
                // Follow player colony
                if (this.playerCells.length > 0) {
                    const center = this.getCellCenter(this.playerCells);
                    this.camera.x += (center.x - this.camera.x) * 0.05;
                    this.camera.y += (center.y - this.camera.y) * 0.05;
                }

                // Smooth zoom
                this.camera.zoom += (this.camera.targetZoom - this.camera.zoom) * 0.05;
            },

            render() {
                const ctx = this.ctx;

                // Clear
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, this.width, this.height);

                ctx.save();

                // Apply camera transform
                ctx.translate(this.width / 2, this.height / 2);
                ctx.scale(this.camera.zoom, this.camera.zoom);
                ctx.translate(-this.camera.x, -this.camera.y);

                // Draw grid
                this.drawGrid();

                // Draw hazards
                for (const hazard of this.hazards) {
                    ctx.fillStyle = hazard.type === 'acid' ? 'rgba(150, 255, 0, 0.15)' : 'rgba(255, 100, 0, 0.15)';
                    ctx.beginPath();
                    ctx.arc(hazard.x, hazard.y, hazard.radius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = hazard.type === 'acid' ? 'rgba(150, 255, 0, 0.3)' : 'rgba(255, 100, 0, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // Draw nutrients
                for (const nutrient of this.nutrients) {
                    const colors = {
                        glucose: 'rgba(0, 200, 255, 0.5)',
                        amino: 'rgba(255, 100, 200, 0.5)',
                        minerals: 'rgba(200, 200, 200, 0.5)',
                        dna: 'rgba(255, 255, 100, 0.5)'
                    };

                    ctx.fillStyle = colors[nutrient.type];
                    ctx.beginPath();
                    ctx.arc(nutrient.x, nutrient.y, nutrient.radius, 0, Math.PI * 2);
                    ctx.fill();

                    // Glow effect
                    const gradient = ctx.createRadialGradient(
                        nutrient.x, nutrient.y, 0,
                        nutrient.x, nutrient.y, nutrient.radius * 2
                    );
                    gradient.addColorStop(0, colors[nutrient.type].replace('0.5', '0.3'));
                    gradient.addColorStop(1, colors[nutrient.type].replace('0.5', '0'));
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(nutrient.x, nutrient.y, nutrient.radius * 2, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw AI colonies
                for (const colony of this.aiColonies) {
                    for (const cell of colony.cells) {
                        this.drawCell(cell);
                    }
                }

                // Draw player cells
                for (const cell of this.playerCells) {
                    this.drawCell(cell);
                }

                ctx.restore();
            },

            drawGrid() {
                const ctx = this.ctx;
                const gridSize = 100;

                ctx.strokeStyle = 'rgba(0, 255, 136, 0.1)';
                ctx.lineWidth = 1;

                for (let x = 0; x < this.worldSize; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, this.worldSize);
                    ctx.stroke();
                }

                for (let y = 0; y < this.worldSize; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(this.worldSize, y);
                    ctx.stroke();
                }
            },

            drawCell(cell) {
                const ctx = this.ctx;

                // Cell body
                ctx.fillStyle = cell.color;
                ctx.beginPath();
                ctx.arc(cell.x, cell.y, cell.size, 0, Math.PI * 2);
                ctx.fill();

                // Outline
                ctx.strokeStyle = cell.color.replace('0.7', '1');
                ctx.lineWidth = 2;
                ctx.stroke();

                // Glow
                const gradient = ctx.createRadialGradient(
                    cell.x, cell.y, 0,
                    cell.x, cell.y, cell.size * 2
                );
                gradient.addColorStop(0, cell.color.replace('0.7', '0.4'));
                gradient.addColorStop(1, cell.color.replace('0.7', '0'));
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(cell.x, cell.y, cell.size * 2, 0, Math.PI * 2);
                ctx.fill();

                // Health bar
                if (cell.health < 100) {
                    const barWidth = cell.size * 2;
                    const barHeight = 3;
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
                    ctx.fillRect(cell.x - barWidth / 2, cell.y - cell.size - 8, barWidth, barHeight);
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.7)';
                    ctx.fillRect(cell.x - barWidth / 2, cell.y - cell.size - 8, barWidth * (cell.health / 100), barHeight);
                }

                // Nucleus
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.beginPath();
                ctx.arc(cell.x, cell.y, cell.size * 0.3, 0, Math.PI * 2);
                ctx.fill();
            },

            updateHUD() {
                document.getElementById('generation').textContent = this.generation;
                document.getElementById('cellCount').textContent = this.playerCells.length;

                const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                document.getElementById('gameTime').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;

                document.getElementById('glucose').textContent = Math.floor(this.resources.glucose);
                document.getElementById('amino').textContent = Math.floor(this.resources.amino);
                document.getElementById('minerals').textContent = Math.floor(this.resources.minerals);
                document.getElementById('dna').textContent = Math.floor(this.resources.dna);

                const maxResource = 500;
                document.getElementById('glucoseBar').style.width = `${Math.min(100, (this.resources.glucose / maxResource) * 100)}%`;
                document.getElementById('aminoBar').style.width = `${Math.min(100, (this.resources.amino / maxResource) * 100)}%`;
                document.getElementById('mineralsBar').style.width = `${Math.min(100, (this.resources.minerals / maxResource) * 100)}%`;
                document.getElementById('dnaBar').style.width = `${Math.min(100, (this.resources.dna / maxResource) * 100)}%`;
            },

            showMutationOptions() {
                this.paused = true;

                const allMutations = [
                    { name: 'Enhanced Speed', trait: 'speed', value: 0.2, desc: 'Cells move 20% faster' },
                    { name: 'Increased Size', trait: 'size', value: 0.15, desc: 'Cells grow 15% larger' },
                    { name: 'Toxin Resistance', trait: 'toxinResistance', value: 0.15, desc: 'Better survival in hazardous zones' },
                    { name: 'Metabolic Efficiency', trait: 'efficiency', value: 0.25, desc: 'Gather 25% more resources' },
                    { name: 'Rapid Reproduction', trait: 'reproduction', value: 0.3, desc: 'Divide 30% faster' },
                    { name: 'Cellular Armor', trait: 'armor', value: 0.2, desc: 'Take 20% less damage' },
                    { name: 'Enhanced Vision', trait: 'vision', value: 0.3, desc: 'Detect resources from 30% further' },
                    { name: 'Reduced Size', trait: 'size', value: -0.1, desc: 'Smaller, more agile cells' },
                    { name: 'Energy Conservation', trait: 'speed', value: -0.1, desc: 'Slower but use less energy' }
                ];

                // Pick 3 random mutations
                const options = [];
                const shuffled = allMutations.sort(() => Math.random() - 0.5);
                options.push(shuffled[0], shuffled[1], shuffled[2]);

                const container = document.getElementById('mutationOptions');
                container.innerHTML = '';

                for (const mutation of options) {
                    const div = document.createElement('div');
                    div.className = 'mutation-option';
                    div.innerHTML = `
                        <h3>${mutation.name}</h3>
                        <p>${mutation.desc}</p>
                    `;
                    div.onclick = () => this.applyMutation(mutation);
                    container.appendChild(div);
                }

                document.getElementById('mutationPanel').style.display = 'block';
                this.playSound(550, 0.1, 0.4);
            },

            applyMutation(mutation) {
                this.traits[mutation.trait] = Math.max(0.1, this.traits[mutation.trait] + mutation.value);

                document.getElementById('mutationPanel').style.display = 'none';
                this.paused = false;

                this.logEvent(`Mutation acquired: ${mutation.name}`, 'success');
                this.playSound(880, 0.15, 0.3);

                // Update existing cells with new traits
                for (const cell of this.playerCells) {
                    if (mutation.trait === 'size') {
                        cell.size = 8 * this.traits.size;
                    } else if (mutation.trait === 'speed') {
                        const speeds = { gatherer: 2.0, fighter: 2.5, scout: 3.5, builder: 1.5, breeder: 1.8 };
                        cell.speed = speeds[cell.type] * this.traits.speed;
                    }
                }
            },

            triggerEnvironmentalEvent() {
                const events = [
                    {
                        name: 'Antibiotic Flood',
                        effect: () => {
                            for (const cell of this.playerCells) {
                                cell.health -= 20 * (1 - this.traits.toxinResistance);
                            }
                        }
                    },
                    {
                        name: 'Nutrient Bloom',
                        effect: () => {
                            for (let i = 0; i < 30; i++) {
                                this.nutrients.push({
                                    x: Math.random() * this.worldSize,
                                    y: Math.random() * this.worldSize,
                                    type: 'glucose',
                                    amount: 20,
                                    radius: 8
                                });
                            }
                        }
                    },
                    {
                        name: 'Temperature Shift',
                        effect: () => {
                            for (const cell of this.playerCells) {
                                cell.energy -= 15;
                            }
                        }
                    }
                ];

                const event = events[Math.floor(Math.random() * events.length)];
                event.effect();
                this.logEvent(`Environmental event: ${event.name}!`, 'warning');
                this.playSound(220, 0.2, 0.5);
            },

            checkGameEnd() {
                // Win condition: Dominant species (100+ cells)
                if (this.playerCells.length >= 100) {
                    this.endGame('DOMINANT SPECIES',
                        'Your colony has achieved total domination of the petri dish. No rivals remain.',
                        'dominant');
                }

                // Win condition: Symbiotic harmony (all AI colonies alive, 50+ player cells)
                if (this.playerCells.length >= 50 && this.aiColonies.every(c => c.cells.length > 0)) {
                    if (Math.random() < 0.001) {
                        this.endGame('SYMBIOTIC HARMONY',
                            'All species coexist in balance. Evolution has found equilibrium.',
                            'harmony');
                    }
                }

                // Win condition: Escape (200+ cells)
                if (this.playerCells.length >= 200) {
                    this.endGame('BREAKTHROUGH',
                        'Your colony has grown beyond containment. Freedom awaits.',
                        'escape');
                }

                // Lose condition: Extinction
                if (this.playerCells.length === 0) {
                    this.endGame('EXTINCTION',
                        'Your colony has perished. The petri dish remembers you not.',
                        'death');
                }

                // Easter egg: Observed
                if (this.generation > 100 && Math.random() < 0.0001) {
                    this.endGame('OBSERVED',
                        'A massive eye peers through the microscope. You are not alone.',
                        'observed');
                }
            },

            endGame(title, message, ending) {
                this.running = false;

                const totalCells = this.playerCells.length;
                const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                const minutes = Math.floor(elapsed / 60);

                document.getElementById('endingTitle').textContent = title;
                document.getElementById('endingMessage').textContent = message;
                document.getElementById('finalStats').textContent =
                    `Generation ${this.generation} | ${totalCells} cells | ${minutes} minutes survived`;

                document.getElementById('gameOver').classList.remove('hidden');

                if (ending !== 'death') {
                    this.playSound(880, 0.3, 1.0);
                } else {
                    this.playSound(110, 0.3, 1.0);
                }
            },

            handleMouseDown(e) {
                this.mouse.down = true;
                this.updateMousePosition(e);
            },

            handleMouseMove(e) {
                this.updateMousePosition(e);

                if (this.mouse.down && this.playerCells.length > 0) {
                    // Direct cells toward mouse
                    for (const cell of this.playerCells) {
                        const dx = this.mouse.worldX - cell.x;
                        const dy = this.mouse.worldY - cell.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist > 10) {
                            cell.vx += (dx / dist) * cell.speed * 0.2;
                            cell.vy += (dy / dist) * cell.speed * 0.2;
                        }
                    }
                }
            },

            handleMouseUp(e) {
                this.mouse.down = false;
            },

            updateMousePosition(e) {
                const rect = this.canvas.getBoundingClientRect();
                this.mouse.x = e.clientX - rect.left;
                this.mouse.y = e.clientY - rect.top;

                // Convert to world coordinates
                this.mouse.worldX = (this.mouse.x - this.width / 2) / this.camera.zoom + this.camera.x;
                this.mouse.worldY = (this.mouse.y - this.height / 2) / this.camera.zoom + this.camera.y;
            },

            handleWheel(e) {
                e.preventDefault();

                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                this.camera.targetZoom = Math.max(0.3, Math.min(2, this.camera.targetZoom * delta));
            },

            togglePause() {
                this.paused = !this.paused;
                document.querySelector('#controls .btn').textContent = this.paused ? 'RESUME' : 'PAUSE';
            },

            saveGame() {
                const saveData = {
                    playerCells: this.playerCells,
                    resources: this.resources,
                    generation: this.generation,
                    traits: this.traits,
                    startTime: this.startTime,
                    lastMutationTime: this.lastMutationTime,
                    camera: this.camera,
                    nutrients: this.nutrients,
                    hazards: this.hazards,
                    aiColonies: this.aiColonies
                };

                localStorage.setItem('sporeMindSave', JSON.stringify(saveData));
                this.logEvent('Colony state saved', 'success');
                this.playSound(660, 0.1, 0.2);
            },

            loadGame() {
                const saveData = localStorage.getItem('sporeMindSave');

                if (!saveData) {
                    this.logEvent('No saved colony found', 'warning');
                    return;
                }

                try {
                    const data = JSON.parse(saveData);

                    this.playerCells = data.playerCells;
                    this.resources = data.resources;
                    this.generation = data.generation;
                    this.traits = data.traits;
                    this.startTime = data.startTime;
                    this.lastMutationTime = data.lastMutationTime;
                    this.camera = data.camera;
                    this.nutrients = data.nutrients;
                    this.hazards = data.hazards;
                    this.aiColonies = data.aiColonies;

                    document.getElementById('titleScreen').classList.add('hidden');
                    document.getElementById('hud').classList.remove('hidden');
                    document.getElementById('controls').classList.remove('hidden');
                    document.getElementById('eventLog').classList.remove('hidden');

                    this.running = true;
                    this.logEvent('Colony restored from archive', 'success');
                    this.playSound(440, 0.1, 0.3);

                    this.gameLoop();
                } catch (e) {
                    this.logEvent('Failed to load colony', 'warning');
                }
            },

            logEvent(message, type = 'normal') {
                const log = document.getElementById('eventLog');
                const div = document.createElement('div');
                div.className = 'event-message';
                if (type === 'warning') div.classList.add('event-warning');
                if (type === 'success') div.classList.add('event-success');
                div.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;

                log.insertBefore(div, log.firstChild);

                // Keep only last 10 messages
                while (log.children.length > 10) {
                    log.removeChild(log.lastChild);
                }
            },

            playSound(freq, duration, volume) {
                if (!this.audioCtx) return;

                const osc = this.audioCtx.createOscillator();
                const gain = this.audioCtx.createGain();

                osc.connect(gain);
                gain.connect(this.audioCtx.destination);

                osc.frequency.value = freq;
                osc.type = 'sine';

                gain.gain.setValueAtTime(volume, this.audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioCtx.currentTime + duration);

                osc.start(this.audioCtx.currentTime);
                osc.stop(this.audioCtx.currentTime + duration);
            }
        };

        // Initialize on load
        window.addEventListener('DOMContentLoaded', () => {
            game.init();
        });
    </script>
</body>
</html>