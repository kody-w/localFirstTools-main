<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>War Card Game</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1a0a2e;
            overflow: hidden;
            font-family: 'Segoe UI', system-ui, sans-serif;
            touch-action: none;
        }
        canvas {
            display: block;
            cursor: default;
        }
        #ui-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        #ui-overlay > * { pointer-events: auto; }
        .menu-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
        .menu-box {
            background: linear-gradient(145deg, #2a1050, #1a0a2e);
            border: 2px solid #8844cc;
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 0 60px rgba(136, 68, 204, 0.4);
        }
        .menu-box h1 {
            color: #e8c8ff;
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(136, 68, 204, 0.8);
        }
        .menu-box h2 {
            color: #bb88ee;
            font-size: 1.3rem;
            margin-bottom: 30px;
            font-weight: normal;
        }
        .menu-btn {
            display: block;
            width: 100%;
            padding: 14px;
            margin: 10px 0;
            font-size: 1.1rem;
            font-weight: bold;
            border: 2px solid #8844cc;
            border-radius: 12px;
            background: linear-gradient(135deg, #3a1570, #2a0a50);
            color: #e8c8ff;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        .menu-btn:hover {
            background: linear-gradient(135deg, #5a2590, #3a1570);
            border-color: #bb88ee;
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(136, 68, 204, 0.5);
        }
        .menu-btn.small {
            padding: 10px;
            font-size: 0.9rem;
        }
        .diff-select {
            display: flex;
            gap: 10px;
            margin: 15px 0;
        }
        .diff-btn {
            flex: 1;
            padding: 12px 8px;
            font-size: 0.9rem;
            border: 2px solid #555;
            border-radius: 10px;
            background: #1a0a2e;
            color: #aaa;
            cursor: pointer;
            transition: all 0.2s;
        }
        .diff-btn.active {
            border-color: #8844cc;
            color: #e8c8ff;
            background: #3a1570;
            box-shadow: 0 0 15px rgba(136, 68, 204, 0.3);
        }
        .diff-btn:hover { border-color: #8844cc; color: #ccc; }
        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            color: #bb88ee;
            font-size: 0.95rem;
            border-bottom: 1px solid rgba(136,68,204,0.2);
        }
        .stat-row span:last-child { color: #e8c8ff; font-weight: bold; }
        .hs-list {
            text-align: left;
            margin: 10px 0;
        }
        .hs-entry {
            display: flex;
            justify-content: space-between;
            padding: 5px 10px;
            color: #bb88ee;
            font-size: 0.85rem;
        }
        .hs-entry:nth-child(1) { color: #ffd700; }
        .hs-entry:nth-child(2) { color: #c0c0c0; }
        .hs-entry:nth-child(3) { color: #cd7f32; }
        .pause-hint {
            position: fixed;
            top: 10px; right: 10px;
            color: rgba(200,170,255,0.3);
            font-size: 0.75rem;
            pointer-events: none;
            z-index: 5;
        }
    </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div class="pause-hint">ESC = Pause | R = Restart</div>
<div id="ui-overlay"></div>

<script>
// ===== CONSTANTS =====
const SUITS = ['spades','hearts','clubs','diamonds'];
const SUIT_SYMBOLS = {spades:'\u2660',hearts:'\u2665',clubs:'\u2663',diamonds:'\u2666'};
const SUIT_COLORS = {spades:'#e8e8f0',hearts:'#ff4466',clubs:'#e8e8f0',diamonds:'#ff4466'};
const RANK_NAMES = ['','','2','3','4','5','6','7','8','9','10','J','Q','K','A'];
const CARD_W = 90, CARD_H = 130, CARD_RAD = 10;

// ===== AUDIO ENGINE =====
let audioCtx = null;
function initAudio() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}
function playSound(type, freq, dur) {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type;
    osc.frequency.value = freq;
    gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + dur);
}
function sfxFlip() { playSound('triangle', 800, 0.08); setTimeout(()=>playSound('triangle',1200,0.06),40); }
function sfxWin() { playSound('square',523,0.1); setTimeout(()=>playSound('square',659,0.1),100); setTimeout(()=>playSound('square',784,0.15),200); }
function sfxLose() { playSound('sawtooth',400,0.15); setTimeout(()=>playSound('sawtooth',300,0.2),120); }
function sfxWar() { for(let i=0;i<5;i++) setTimeout(()=>playSound('square',200+i*80,0.08),i*60); }
function sfxCombo() { playSound('sine',880,0.1); setTimeout(()=>playSound('sine',1100,0.15),80); }
function sfxClick() { playSound('triangle',600,0.05); }
function sfxGameOver() { [523,494,466,440,415,392].forEach((f,i)=>setTimeout(()=>playSound('sawtooth',f,0.2),i*150)); }
function sfxVictory() { [523,587,659,784,880,1047].forEach((f,i)=>setTimeout(()=>playSound('square',f,0.12),i*100)); }
function sfxBoss() { playSound('sawtooth',100,0.3); setTimeout(()=>playSound('sawtooth',80,0.4),200); }
function sfxCollect() { playSound('sine',1200,0.08); setTimeout(()=>playSound('sine',1600,0.1),60); }

// ===== CANVAS =====
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let W, H;
function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// ===== GAME STATE =====
let gameState = 'menu'; // menu, playing, paused, animating, gameover
let difficulty = 1; // 0=easy, 1=normal, 2=hard
let diffNames = ['Easy','Normal','Hard'];
let playerDeck = [], opponentDeck = [], warPile = [];
let playerCard = null, opponentCard = null;
let round = 0, streak = 0, maxStreak = 0, warsWon = 0, warsLost = 0;
let totalRounds = 0, score = 0, combo = 1;
let warDepth = 0, isWar = false;
let animPhase = ''; // 'flip','resolve','collect','war-deal'
let animTimer = 0;
let shakeX = 0, shakeY = 0, shakeDur = 0;
let particles = [];
let cardAnims = []; // {x,y,targetX,targetY,card,t,dur,side}
let bgStars = [];
let battleLog = [];
let speedMultiplier = 1;
let autoPlay = false;
let roundResult = ''; // 'win','lose','war'
let cardsWonThisRound = 0;
let warFaceDown = []; // visual positions of face-down war cards
let bossMode = false;
let bossHP = 0, bossMaxHP = 0;

// Touch
let touchStart = null;

// Persistent data
let highScores = [];
let totalGamesPlayed = 0;
let totalWins = 0;
let lifetimeCards = 0;

function loadData() {
    try {
        const d = JSON.parse(localStorage.getItem('war-card-game-save'));
        if (d) {
            highScores = d.highScores || [];
            totalGamesPlayed = d.totalGamesPlayed || 0;
            totalWins = d.totalWins || 0;
            lifetimeCards = d.lifetimeCards || 0;
        }
    } catch(e) {}
}
function saveData() {
    localStorage.setItem('war-card-game-save', JSON.stringify({
        highScores, totalGamesPlayed, totalWins, lifetimeCards
    }));
}
loadData();

// Init background stars
for (let i = 0; i < 100; i++) {
    bgStars.push({
        x: Math.random() * 2000,
        y: Math.random() * 2000,
        size: Math.random() * 2 + 0.5,
        brightness: Math.random() * 0.5 + 0.3,
        twinkle: Math.random() * Math.PI * 2
    });
}

// ===== DECK CREATION =====
function createDeck() {
    const deck = [];
    for (const suit of SUITS) {
        for (let rank = 2; rank <= 14; rank++) {
            deck.push({ suit, rank });
        }
    }
    return deck;
}

function shuffleDeck(deck) {
    for (let i = deck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [deck[i], deck[j]] = [deck[j], deck[i]];
    }
    return deck;
}

// ===== CARD RENDERING =====
function drawCard(x, y, card, faceUp, scale, angle, alpha) {
    ctx.save();
    ctx.globalAlpha = alpha || 1;
    ctx.translate(x + CARD_W*scale/2, y + CARD_H*scale/2);
    if (angle) ctx.rotate(angle);
    const w = CARD_W * scale;
    const h = CARD_H * scale;
    const r = CARD_RAD * scale;

    // Card shape
    ctx.beginPath();
    ctx.roundRect(-w/2, -h/2, w, h, r);

    if (faceUp && card) {
        // Card face
        ctx.fillStyle = '#faf8f0';
        ctx.fill();
        ctx.strokeStyle = '#888';
        ctx.lineWidth = 1.5 * scale;
        ctx.stroke();

        const isRed = card.suit === 'hearts' || card.suit === 'diamonds';
        const color = isRed ? '#cc2244' : '#222233';
        const sym = SUIT_SYMBOLS[card.suit];
        const rankStr = RANK_NAMES[card.rank];

        // Top-left rank+suit
        ctx.fillStyle = color;
        ctx.font = `bold ${14*scale}px 'Segoe UI', sans-serif`;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        ctx.fillText(rankStr, -w/2+6*scale, -h/2+5*scale);
        ctx.font = `${12*scale}px sans-serif`;
        ctx.fillText(sym, -w/2+6*scale, -h/2+20*scale);

        // Bottom-right (inverted)
        ctx.save();
        ctx.rotate(Math.PI);
        ctx.fillStyle = color;
        ctx.font = `bold ${14*scale}px 'Segoe UI', sans-serif`;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        ctx.fillText(rankStr, -w/2+6*scale, -h/2+5*scale);
        ctx.font = `${12*scale}px sans-serif`;
        ctx.fillText(sym, -w/2+6*scale, -h/2+20*scale);
        ctx.restore();

        // Center suit symbol
        ctx.fillStyle = color;
        ctx.font = `${36*scale}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(sym, 0, 0);

        // Face card indicator
        if (card.rank >= 11) {
            ctx.font = `bold ${28*scale}px 'Segoe UI', sans-serif`;
            ctx.fillStyle = color + '30';
            ctx.fillText(rankStr, 0, -2*scale);
        }
    } else {
        // Card back
        const grad = ctx.createLinearGradient(-w/2,-h/2,w/2,h/2);
        grad.addColorStop(0, '#3a1570');
        grad.addColorStop(0.5, '#5522aa');
        grad.addColorStop(1, '#3a1570');
        ctx.fillStyle = grad;
        ctx.fill();
        ctx.strokeStyle = '#8844cc';
        ctx.lineWidth = 2 * scale;
        ctx.stroke();

        // Pattern
        ctx.strokeStyle = 'rgba(200,170,255,0.2)';
        ctx.lineWidth = 1;
        for (let i = -w/2+8*scale; i < w/2; i += 8*scale) {
            ctx.beginPath();
            ctx.moveTo(i, -h/2+4*scale);
            ctx.lineTo(i, h/2-4*scale);
            ctx.stroke();
        }
        // Diamond center
        ctx.strokeStyle = 'rgba(200,170,255,0.4)';
        ctx.lineWidth = 1.5*scale;
        ctx.beginPath();
        ctx.moveTo(0, -15*scale);
        ctx.lineTo(10*scale, 0);
        ctx.lineTo(0, 15*scale);
        ctx.lineTo(-10*scale, 0);
        ctx.closePath();
        ctx.stroke();
    }

    ctx.restore();
}

// ===== DECK VISUAL =====
function drawDeckPile(x, y, count, label, scale) {
    const s = scale || 1;
    // Stack effect
    const layers = Math.min(count, 5);
    for (let i = 0; i < layers; i++) {
        drawCard(x - i*2*s, y - i*2*s, null, false, s, 0, 0.8);
    }
    // Count badge
    if (count > 0) {
        ctx.fillStyle = '#8844cc';
        ctx.beginPath();
        ctx.arc(x + CARD_W*s + 5, y + 10, 18*s, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.font = `bold ${14*s}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(count, x + CARD_W*s + 5, y + 10);
    }
    // Label
    ctx.fillStyle = 'rgba(200,170,255,0.6)';
    ctx.font = `${12*s}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.fillText(label, x + CARD_W*s/2, y + CARD_H*s + 18);
}

// ===== PARTICLES =====
function spawnParticles(x, y, count, color, speed) {
    for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const spd = (Math.random() * 0.5 + 0.5) * (speed || 3);
        particles.push({
            x, y,
            vx: Math.cos(angle) * spd,
            vy: Math.sin(angle) * spd,
            life: 1,
            decay: 0.01 + Math.random() * 0.02,
            size: Math.random() * 4 + 2,
            color: color || '#bb88ee'
        });
    }
}

function spawnCardParticles(x, y, suit) {
    const isRed = suit === 'hearts' || suit === 'diamonds';
    const color = isRed ? '#ff4466' : '#8888ff';
    spawnParticles(x, y, 15, color, 4);
}

function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.05;
        p.life -= p.decay;
        if (p.life <= 0) particles.splice(i, 1);
    }
}

function drawParticles() {
    for (const p of particles) {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.globalAlpha = 1;
}

// ===== SCREEN SHAKE =====
function shake(intensity, duration) {
    shakeX = (Math.random() - 0.5) * intensity;
    shakeY = (Math.random() - 0.5) * intensity;
    shakeDur = duration;
}

// ===== GAME LOGIC =====
function startGame() {
    initAudio();
    const deck = shuffleDeck(createDeck());
    playerDeck = deck.slice(0, 26);
    opponentDeck = deck.slice(26);
    warPile = [];
    playerCard = null;
    opponentCard = null;
    round = 0;
    streak = 0;
    maxStreak = 0;
    warsWon = 0;
    warsLost = 0;
    totalRounds = 0;
    score = 0;
    combo = 1;
    warDepth = 0;
    isWar = false;
    animPhase = '';
    animTimer = 0;
    roundResult = '';
    cardsWonThisRound = 0;
    battleLog = [];
    warFaceDown = [];
    bossMode = false;
    bossHP = 0;
    bossMaxHP = 0;
    autoPlay = false;
    speedMultiplier = 1;
    cardAnims = [];
    particles = [];
    gameState = 'playing';
    sfxClick();
}

function dealCards() {
    if (animPhase !== '' || gameState !== 'playing') return;
    if (playerDeck.length === 0 || opponentDeck.length === 0) {
        endGame();
        return;
    }

    playerCard = playerDeck.shift();
    opponentCard = opponentDeck.shift();
    round++;
    totalRounds++;

    // Check for boss round (every 10 rounds on Normal, 7 on Hard)
    const bossInterval = difficulty === 0 ? 15 : difficulty === 1 ? 10 : 7;
    if (round % bossInterval === 0 && round > 0) {
        bossMode = true;
        bossMaxHP = difficulty === 0 ? 2 : difficulty === 1 ? 3 : 4;
        bossHP = bossMaxHP;
        sfxBoss();
    }

    sfxFlip();
    animPhase = 'flip';
    animTimer = 0;
}

function resolveRound() {
    const pRank = playerCard.rank;
    const oRank = opponentCard.rank;

    // Difficulty adjustments
    let effectiveORank = oRank;
    if (difficulty === 2 && Math.random() < 0.15) {
        // Hard: occasional rank boost for opponent
        effectiveORank = Math.min(14, oRank + 1);
    }

    if (pRank > effectiveORank) {
        // Player wins
        roundResult = 'win';
        streak++;
        if (streak > maxStreak) maxStreak = streak;

        // Combo system
        if (streak >= 5) combo = 3;
        else if (streak >= 3) combo = 2;
        else combo = 1;

        const basePoints = pRank * 10;
        const warBonus = isWar ? warPile.length * 5 : 0;
        const comboBonus = combo > 1 ? basePoints * (combo - 1) : 0;
        const earnedPoints = basePoints + warBonus + comboBonus;
        score += earnedPoints;

        cardsWonThisRound = 2 + warPile.length;

        // Collect cards
        const won = [playerCard, opponentCard, ...warPile];
        shuffleDeck(won);
        playerDeck.push(...won);
        lifetimeCards += won.length;

        if (isWar) {
            warsWon++;
            sfxCombo();
        } else {
            sfxWin();
        }

        if (bossMode) {
            bossHP--;
            if (bossHP <= 0) {
                score += 500 * (difficulty + 1);
                bossMode = false;
                spawnParticles(W/2, H/2, 50, '#ffd700', 6);
                sfxVictory();
                battleLog.unshift(`BOSS DEFEATED! +${500*(difficulty+1)} pts`);
            }
        }

        if (combo > 1) {
            spawnParticles(W/2, H/2 - 50, 20, '#ffd700', 5);
            sfxCombo();
        }

        spawnCardParticles(W/2 - 80, H/2 - CARD_H/2, playerCard.suit);
        shake(8, 6);
        battleLog.unshift(`R${round}: ${RANK_NAMES[pRank]}${SUIT_SYMBOLS[playerCard.suit]} beats ${RANK_NAMES[oRank]}${SUIT_SYMBOLS[opponentCard.suit]} (+${earnedPoints})`);

        warPile = [];
        isWar = false;
        warDepth = 0;
        warFaceDown = [];

    } else if (effectiveORank > pRank) {
        // Opponent wins
        roundResult = 'lose';
        streak = 0;
        combo = 1;

        cardsWonThisRound = 0;
        const lost = [playerCard, opponentCard, ...warPile];
        shuffleDeck(lost);
        opponentDeck.push(...lost);

        if (isWar) {
            warsLost++;
        }

        sfxLose();
        spawnCardParticles(W/2 + 80, H/2 - CARD_H/2, opponentCard.suit);
        shake(5, 4);
        battleLog.unshift(`R${round}: ${RANK_NAMES[pRank]}${SUIT_SYMBOLS[playerCard.suit]} loses to ${RANK_NAMES[oRank]}${SUIT_SYMBOLS[opponentCard.suit]}`);

        warPile = [];
        isWar = false;
        warDepth = 0;
        warFaceDown = [];

    } else {
        // WAR!
        roundResult = 'war';
        sfxWar();
        shake(12, 10);
        spawnParticles(W/2, H/2, 30, '#ff4466', 5);
        battleLog.unshift(`R${round}: WAR! Both ${RANK_NAMES[pRank]}!`);

        // Put current cards in war pile
        warPile.push(playerCard, opponentCard);
        warDepth++;

        // Deal face-down cards (3 each, or fewer if running out)
        const faceDownCount = difficulty === 0 ? 1 : difficulty === 1 ? 3 : 3;
        const pFD = Math.min(faceDownCount, playerDeck.length - 1);
        const oFD = Math.min(faceDownCount, opponentDeck.length - 1);

        if (pFD <= 0 || oFD <= 0) {
            // Not enough cards for war, smaller player loses
            if (playerDeck.length <= 1) {
                opponentDeck.push(...warPile, ...playerDeck);
                playerDeck.length = 0;
                warPile = [];
            } else {
                playerDeck.push(...warPile, ...opponentDeck);
                opponentDeck.length = 0;
                warPile = [];
            }
            isWar = false;
            warDepth = 0;
            warFaceDown = [];
            animPhase = 'resolve';
            animTimer = 0;
            return;
        }

        for (let i = 0; i < pFD; i++) warPile.push(playerDeck.shift());
        for (let i = 0; i < oFD; i++) warPile.push(opponentDeck.shift());

        isWar = true;

        // Store face-down positions for visual
        warFaceDown = [];
        for (let i = 0; i < pFD; i++) {
            warFaceDown.push({ side: 'player', index: i });
        }
        for (let i = 0; i < oFD; i++) {
            warFaceDown.push({ side: 'opponent', index: i });
        }
    }

    // Check game over
    if (playerDeck.length === 0 || opponentDeck.length === 0) {
        animPhase = 'resolve';
        animTimer = 0;
        return;
    }

    animPhase = 'resolve';
    animTimer = 0;
}

function endGame() {
    gameState = 'gameover';
    totalGamesPlayed++;
    const won = playerDeck.length > opponentDeck.length;
    if (won) {
        totalWins++;
        score += 1000;
        sfxVictory();
    } else {
        sfxGameOver();
    }

    // Determine ending
    let ending = '';
    if (won && maxStreak >= 10) ending = 'Legendary Conqueror';
    else if (won && warsWon >= 5) ending = 'War Master';
    else if (won) ending = 'Victory';
    else if (warsLost >= 5) ending = 'Conquered in War';
    else ending = 'Defeat';

    // Add high score
    highScores.push({
        score,
        rounds: totalRounds,
        streak: maxStreak,
        wars: warsWon,
        difficulty: diffNames[difficulty],
        ending,
        date: new Date().toLocaleDateString()
    });
    highScores.sort((a, b) => b.score - a.score);
    highScores = highScores.slice(0, 10);
    saveData();

    showGameOverMenu(won, ending);
}

// ===== BACKGROUND =====
function drawBackground(time) {
    // Gradient background
    const grad = ctx.createLinearGradient(0, 0, 0, H);
    grad.addColorStop(0, '#0a0520');
    grad.addColorStop(0.5, '#1a0a2e');
    grad.addColorStop(1, '#0f0825');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, W, H);

    // Stars
    for (const s of bgStars) {
        s.twinkle += 0.01;
        const b = s.brightness + Math.sin(s.twinkle) * 0.15;
        ctx.fillStyle = `rgba(200,180,255,${b})`;
        ctx.beginPath();
        ctx.arc(s.x % W, s.y % H, s.size, 0, Math.PI * 2);
        ctx.fill();
    }

    // Table felt gradient
    const feltY = H/2 - 100;
    const feltH = 200;
    const feltGrad = ctx.createRadialGradient(W/2, H/2, 50, W/2, H/2, 350);
    feltGrad.addColorStop(0, 'rgba(30,15,60,0.6)');
    feltGrad.addColorStop(1, 'rgba(10,5,30,0.2)');
    ctx.fillStyle = feltGrad;
    ctx.beginPath();
    ctx.ellipse(W/2, H/2, 350, 150, 0, 0, Math.PI * 2);
    ctx.fill();
}

// ===== HUD =====
function drawHUD() {
    const padding = 15;

    // Score
    ctx.fillStyle = '#e8c8ff';
    ctx.font = 'bold 20px sans-serif';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    ctx.fillText(`Score: ${score}`, padding, padding);

    // Combo
    if (combo > 1) {
        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 18px sans-serif';
        ctx.fillText(`COMBO x${combo}`, padding, padding + 28);
    }

    // Streak
    if (streak > 0) {
        ctx.fillStyle = '#88ff88';
        ctx.font = '14px sans-serif';
        ctx.fillText(`Streak: ${streak}`, padding, padding + (combo > 1 ? 52 : 28));
    }

    // Round
    ctx.fillStyle = 'rgba(200,170,255,0.7)';
    ctx.font = '14px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(`Round ${round}`, W/2, padding);

    // War indicator
    if (isWar) {
        const warAlpha = 0.5 + Math.sin(Date.now() / 200) * 0.3;
        ctx.fillStyle = `rgba(255,68,100,${warAlpha})`;
        ctx.font = 'bold 24px sans-serif';
        ctx.fillText(`WAR! (depth: ${warDepth})`, W/2, padding + 22);
        ctx.fillStyle = 'rgba(255,68,100,0.6)';
        ctx.font = '13px sans-serif';
        ctx.fillText(`${warPile.length} cards in pot`, W/2, padding + 48);
    }

    // Boss indicator
    if (bossMode) {
        const bx = W/2;
        const by = padding + (isWar ? 68 : 22);
        ctx.fillStyle = 'rgba(255,200,0,0.8)';
        ctx.font = 'bold 16px sans-serif';
        ctx.fillText('BOSS BATTLE', bx, by);

        // HP bar
        const bw = 120, bh = 10;
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(bx - bw/2, by + 18, bw, bh);
        ctx.fillStyle = '#ff4466';
        ctx.fillRect(bx - bw/2, by + 18, bw * (bossHP / bossMaxHP), bh);
        ctx.strokeStyle = '#ffd700';
        ctx.lineWidth = 1;
        ctx.strokeRect(bx - bw/2, by + 18, bw, bh);
    }

    // Difficulty
    ctx.fillStyle = 'rgba(200,170,255,0.4)';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText(diffNames[difficulty], W - padding, padding);

    // Speed indicator
    if (speedMultiplier > 1) {
        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 14px sans-serif';
        ctx.fillText(`${speedMultiplier}x Speed`, W - padding, padding + 18);
    }

    if (autoPlay) {
        ctx.fillStyle = '#88ff88';
        ctx.font = '12px sans-serif';
        ctx.fillText('AUTO', W - padding, padding + (speedMultiplier > 1 ? 36 : 18));
    }

    // Deck counts at bottom
    const deckY = H - 55;
    ctx.fillStyle = '#8844cc';
    ctx.font = 'bold 14px sans-serif';
    ctx.textAlign = 'center';

    // Player deck info
    ctx.fillStyle = '#88ccff';
    ctx.fillText(`Your Deck: ${playerDeck.length}`, W/2 - 140, deckY);

    // Deck bar
    const barW = 100, barH = 8;
    const pRatio = playerDeck.length / 52;
    const oRatio = opponentDeck.length / 52;

    // Player bar
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fillRect(W/2 - 190, deckY + 8, barW, barH);
    ctx.fillStyle = '#4488cc';
    ctx.fillRect(W/2 - 190, deckY + 8, barW * pRatio, barH);

    // Opponent bar
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fillRect(W/2 + 90, deckY + 8, barW, barH);
    ctx.fillStyle = '#cc4444';
    ctx.fillRect(W/2 + 90, deckY + 8, barW * oRatio, barH);

    ctx.fillStyle = '#ff8888';
    ctx.fillText(`Enemy: ${opponentDeck.length}`, W/2 + 140, deckY);

    // Battle log (bottom left)
    ctx.fillStyle = 'rgba(200,170,255,0.4)';
    ctx.font = '11px sans-serif';
    ctx.textAlign = 'left';
    const logY = H - 130;
    const logMax = Math.min(battleLog.length, 5);
    for (let i = 0; i < logMax; i++) {
        ctx.globalAlpha = 1 - i * 0.18;
        ctx.fillText(battleLog[i], 15, logY + i * 16);
    }
    ctx.globalAlpha = 1;
}

// ===== DRAW PLAY AREA =====
function drawPlayArea(time) {
    const cx = W / 2;
    const cy = H / 2;
    const cardScale = Math.min(1, W / 600);

    // Player label
    ctx.fillStyle = '#88ccff';
    ctx.font = `bold ${16*cardScale}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.fillText('YOU', cx - 80, cy - CARD_H*cardScale/2 - 15);

    // Opponent label
    ctx.fillStyle = '#ff8888';
    ctx.fillText('ENEMY', cx + 80, cy - CARD_H*cardScale/2 - 15);

    // VS text
    ctx.fillStyle = 'rgba(200,170,255,0.3)';
    ctx.font = `bold ${20*cardScale}px sans-serif`;
    ctx.fillText('VS', cx, cy);

    // War face-down cards visual
    if (isWar && warFaceDown.length > 0) {
        for (const fd of warFaceDown) {
            const fdx = fd.side === 'player'
                ? cx - 80 - CARD_W*cardScale/2 - (fd.index+1)*8
                : cx + 80 - CARD_W*cardScale/2 + (fd.index+1)*8;
            const fdy = cy - CARD_H*cardScale/2 + fd.index * 3;
            drawCard(fdx, fdy, null, false, cardScale * 0.8, (fd.index - 1) * 0.05, 0.6);
        }
    }

    // Player card
    if (playerCard) {
        const px = cx - 80 - CARD_W*cardScale/2;
        const py = cy - CARD_H*cardScale/2;

        if (animPhase === 'flip') {
            const progress = Math.min(animTimer / 15, 1);
            const flipScale = Math.abs(Math.cos(progress * Math.PI));
            const showFace = progress > 0.5;
            const bobY = -Math.sin(progress * Math.PI) * 20;
            drawCard(px, py + bobY, playerCard, showFace, cardScale * flipScale, 0, 1);
        } else {
            drawCard(px, py, playerCard, true, cardScale, 0, 1);

            // Win/lose glow
            if (animPhase === 'resolve' && animTimer < 30) {
                if (roundResult === 'win') {
                    ctx.shadowColor = '#44ff88';
                    ctx.shadowBlur = 20;
                    drawCard(px, py, playerCard, true, cardScale, 0, 0.3);
                    ctx.shadowBlur = 0;
                }
            }
        }
    }

    // Opponent card
    if (opponentCard) {
        const ox = cx + 80 - CARD_W*cardScale/2;
        const oy = cy - CARD_H*cardScale/2;

        if (animPhase === 'flip') {
            const progress = Math.min(animTimer / 15, 1);
            const flipScale = Math.abs(Math.cos(progress * Math.PI));
            const showFace = progress > 0.5;
            const bobY = -Math.sin(progress * Math.PI) * 20;
            drawCard(ox, oy + bobY, opponentCard, showFace, cardScale * flipScale, 0, 1);
        } else {
            drawCard(ox, oy, opponentCard, true, cardScale, 0, 1);

            if (animPhase === 'resolve' && animTimer < 30 && roundResult === 'lose') {
                ctx.shadowColor = '#ff4466';
                ctx.shadowBlur = 20;
                drawCard(ox, oy, opponentCard, true, cardScale, 0, 0.3);
                ctx.shadowBlur = 0;
            }
        }
    }

    // Result text
    if (animPhase === 'resolve' && animTimer < 40) {
        const alpha = animTimer < 5 ? animTimer / 5 : animTimer > 30 ? (40 - animTimer) / 10 : 1;
        ctx.globalAlpha = alpha;
        ctx.font = `bold ${32 * cardScale}px sans-serif`;
        ctx.textAlign = 'center';

        if (roundResult === 'win') {
            ctx.fillStyle = '#44ff88';
            ctx.fillText('WIN!', cx, cy - CARD_H*cardScale/2 - 40);
            if (cardsWonThisRound > 2) {
                ctx.font = `${16*cardScale}px sans-serif`;
                ctx.fillText(`+${cardsWonThisRound} cards`, cx, cy - CARD_H*cardScale/2 - 20);
            }
        } else if (roundResult === 'lose') {
            ctx.fillStyle = '#ff4466';
            ctx.fillText('LOSE', cx, cy - CARD_H*cardScale/2 - 40);
        } else if (roundResult === 'war') {
            const warPulse = 1 + Math.sin(animTimer * 0.3) * 0.1;
            ctx.font = `bold ${40 * cardScale * warPulse}px sans-serif`;
            ctx.fillStyle = '#ff4466';
            ctx.fillText('WAR!', cx, cy - CARD_H*cardScale/2 - 40);
        }
        ctx.globalAlpha = 1;
    }

    // "Click to deal" prompt
    if (animPhase === '' && playerCard === null && gameState === 'playing') {
        const promptAlpha = 0.5 + Math.sin(time / 500) * 0.3;
        ctx.globalAlpha = promptAlpha;
        ctx.fillStyle = '#e8c8ff';
        ctx.font = `${18*cardScale}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.fillText('Click or press SPACE to deal', cx, cy + CARD_H*cardScale/2 + 40);
        ctx.font = `${12*cardScale}px sans-serif`;
        ctx.fillText('A = Auto  |  1/2/3 = Speed', cx, cy + CARD_H*cardScale/2 + 60);
        ctx.globalAlpha = 1;
    }

    // Deck piles
    const deckScale = cardScale * 0.6;
    drawDeckPile(20, H/2 - CARD_H*deckScale/2, playerDeck.length, 'Your Deck', deckScale);
    drawDeckPile(W - CARD_W*deckScale - 30, H/2 - CARD_H*deckScale/2, opponentDeck.length, 'Enemy Deck', deckScale);
}

// ===== ANIMATION UPDATE =====
function updateAnimation() {
    if (animPhase === '') return;

    animTimer += speedMultiplier;

    if (animPhase === 'flip') {
        if (animTimer >= 20) {
            resolveRound();
        }
    } else if (animPhase === 'resolve') {
        if (animTimer >= 45 / speedMultiplier) {
            animPhase = '';
            animTimer = 0;
            playerCard = null;
            opponentCard = null;

            // Check game over
            if (playerDeck.length === 0 || opponentDeck.length === 0) {
                endGame();
                return;
            }

            // Auto-deal if war continues or auto-play
            if (isWar) {
                setTimeout(() => dealCards(), 200 / speedMultiplier);
            } else if (autoPlay) {
                setTimeout(() => dealCards(), 300 / speedMultiplier);
            }
        }
    }
}

// ===== SCREEN SHAKE UPDATE =====
function updateShake() {
    if (shakeDur > 0) {
        shakeDur--;
        shakeX = (Math.random() - 0.5) * shakeDur * 1.5;
        shakeY = (Math.random() - 0.5) * shakeDur * 1.5;
    } else {
        shakeX = 0;
        shakeY = 0;
    }
}

// ===== MENUS =====
function showMainMenu() {
    const overlay = document.getElementById('ui-overlay');
    let hsHTML = '';
    if (highScores.length > 0) {
        hsHTML = '<div class="hs-list">';
        for (let i = 0; i < Math.min(5, highScores.length); i++) {
            const hs = highScores[i];
            hsHTML += `<div class="hs-entry"><span>#${i+1} ${hs.ending}</span><span>${hs.score} pts (${hs.difficulty})</span></div>`;
        }
        hsHTML += '</div>';
    }

    let statsHTML = '';
    if (totalGamesPlayed > 0) {
        statsHTML = `
            <div style="margin: 15px 0; padding: 10px; border: 1px solid rgba(136,68,204,0.3); border-radius: 8px;">
                <div class="stat-row"><span>Games Played</span><span>${totalGamesPlayed}</span></div>
                <div class="stat-row"><span>Win Rate</span><span>${Math.round(totalWins/totalGamesPlayed*100)}%</span></div>
                <div class="stat-row"><span>Lifetime Cards Won</span><span>${lifetimeCards}</span></div>
            </div>
        `;
    }

    overlay.innerHTML = `
        <div class="menu-overlay" id="main-menu">
            <div class="menu-box">
                <h1>WAR</h1>
                <h2>Card Game Battle</h2>
                <p style="color: #bb88ee; font-size: 0.9rem; margin-bottom: 20px;">
                    The classic card game of War, fully automated. Higher card wins the round.
                    Tie? It's WAR -- lay cards face down, flip one more to decide!
                </p>
                <div style="margin-bottom: 15px;">
                    <div style="color: #bb88ee; font-size: 0.9rem; margin-bottom: 8px;">Difficulty:</div>
                    <div class="diff-select">
                        <button class="diff-btn ${difficulty===0?'active':''}" onclick="setDiff(0)">Easy</button>
                        <button class="diff-btn ${difficulty===1?'active':''}" onclick="setDiff(1)">Normal</button>
                        <button class="diff-btn ${difficulty===2?'active':''}" onclick="setDiff(2)">Hard</button>
                    </div>
                    <div style="color: rgba(200,170,255,0.5); font-size: 0.75rem;">
                        ${difficulty===0 ? '1 face-down card in war, boss every 15 rounds' :
                          difficulty===1 ? '3 face-down cards in war, boss every 10 rounds' :
                          '3 face-down + rank boosts, boss every 7 rounds'}
                    </div>
                </div>
                <button class="menu-btn" onclick="document.getElementById('main-menu').remove(); startGame();">Deal the Cards</button>
                ${hsHTML ? '<div style="margin-top: 15px;"><div style="color: #bb88ee; font-size: 0.9rem; margin-bottom: 5px;">High Scores:</div>' + hsHTML + '</div>' : ''}
                ${statsHTML}
            </div>
        </div>
    `;
}

function showPauseMenu() {
    const overlay = document.getElementById('ui-overlay');
    overlay.innerHTML = `
        <div class="menu-overlay" id="pause-menu">
            <div class="menu-box">
                <h1>PAUSED</h1>
                <div style="margin: 15px 0; padding: 10px; border: 1px solid rgba(136,68,204,0.3); border-radius: 8px;">
                    <div class="stat-row"><span>Round</span><span>${round}</span></div>
                    <div class="stat-row"><span>Score</span><span>${score}</span></div>
                    <div class="stat-row"><span>Your Cards</span><span>${playerDeck.length}</span></div>
                    <div class="stat-row"><span>Enemy Cards</span><span>${opponentDeck.length}</span></div>
                    <div class="stat-row"><span>Win Streak</span><span>${streak}</span></div>
                    <div class="stat-row"><span>Best Streak</span><span>${maxStreak}</span></div>
                    <div class="stat-row"><span>Wars Won</span><span>${warsWon}</span></div>
                </div>
                <button class="menu-btn" onclick="document.getElementById('pause-menu').remove(); gameState='playing'; sfxClick();">Resume</button>
                <button class="menu-btn small" onclick="document.getElementById('pause-menu').remove(); gameState='menu'; showMainMenu(); sfxClick();">Quit to Menu</button>
            </div>
        </div>
    `;
}

function showGameOverMenu(won, ending) {
    const overlay = document.getElementById('ui-overlay');
    const endingColors = {
        'Legendary Conqueror': '#ffd700',
        'War Master': '#ff8844',
        'Victory': '#44ff88',
        'Conquered in War': '#ff4466',
        'Defeat': '#ff6666'
    };
    const endColor = endingColors[ending] || '#bb88ee';

    overlay.innerHTML = `
        <div class="menu-overlay" id="gameover-menu">
            <div class="menu-box">
                <h1 style="color: ${endColor};">${won ? 'VICTORY!' : 'DEFEAT'}</h1>
                <h2 style="color: ${endColor}; font-size: 1.5rem;">${ending}</h2>
                <div style="margin: 15px 0; padding: 10px; border: 1px solid rgba(136,68,204,0.3); border-radius: 8px;">
                    <div class="stat-row"><span>Final Score</span><span style="color: #ffd700;">${score}</span></div>
                    <div class="stat-row"><span>Rounds Played</span><span>${totalRounds}</span></div>
                    <div class="stat-row"><span>Best Streak</span><span>${maxStreak}</span></div>
                    <div class="stat-row"><span>Wars Won</span><span>${warsWon}</span></div>
                    <div class="stat-row"><span>Wars Lost</span><span>${warsLost}</span></div>
                    <div class="stat-row"><span>Your Cards Left</span><span>${playerDeck.length}</span></div>
                    <div class="stat-row"><span>Enemy Cards Left</span><span>${opponentDeck.length}</span></div>
                </div>
                <button class="menu-btn" onclick="document.getElementById('gameover-menu').remove(); startGame();">Play Again</button>
                <button class="menu-btn small" onclick="document.getElementById('gameover-menu').remove(); gameState='menu'; showMainMenu();">Main Menu</button>
            </div>
        </div>
    `;
}

function setDiff(d) {
    difficulty = d;
    sfxClick();
    showMainMenu();
}

// ===== INPUT =====
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
        if (gameState === 'playing') {
            gameState = 'paused';
            showPauseMenu();
        } else if (gameState === 'paused') {
            const pm = document.getElementById('pause-menu');
            if (pm) pm.remove();
            gameState = 'playing';
        }
        return;
    }

    if (e.key === 'r' || e.key === 'R') {
        if (gameState === 'playing' || gameState === 'gameover') {
            const menus = document.querySelectorAll('.menu-overlay');
            menus.forEach(m => m.remove());
            startGame();
        }
        return;
    }

    if (gameState === 'playing') {
        if (e.key === ' ' || e.key === 'Enter') {
            e.preventDefault();
            if (animPhase === '') dealCards();
        }
        if (e.key === 'a' || e.key === 'A') {
            autoPlay = !autoPlay;
            if (autoPlay && animPhase === '') dealCards();
        }
        if (e.key === '1') speedMultiplier = 1;
        if (e.key === '2') speedMultiplier = 2;
        if (e.key === '3') speedMultiplier = 3;
    }

    if (gameState === 'menu') {
        if (e.key === ' ' || e.key === 'Enter') {
            const mm = document.getElementById('main-menu');
            if (mm) { mm.remove(); startGame(); }
        }
    }
});

canvas.addEventListener('click', (e) => {
    initAudio();
    if (gameState === 'playing' && animPhase === '') {
        dealCards();
    }
});

canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    initAudio();
    if (gameState === 'playing' && animPhase === '') {
        dealCards();
    }
});

// ===== DRAW TUTORIAL TOOLTIP =====
function drawTutorial(time) {
    if (round > 5 || gameState !== 'playing') return;

    const tips = [
        'Click or tap anywhere to deal cards',
        'Higher card wins! Aces are highest',
        'Tied cards trigger WAR!',
        'In war, cards go face-down, then one more flip decides',
        'Build streaks for combo score multipliers!',
        'Press A for auto-play, 1-3 for speed'
    ];

    const tipIndex = Math.min(round, tips.length - 1);
    const tip = tips[tipIndex];

    const alpha = 0.4 + Math.sin(time / 800) * 0.2;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = '#e8c8ff';
    ctx.font = '13px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(tip, W/2, H - 20);
    ctx.globalAlpha = 1;
}

// ===== MAIN LOOP =====
let lastTime = 0;
function gameLoop(time) {
    const dt = time - lastTime;
    lastTime = time;

    resize();
    drawBackground(time);

    ctx.save();
    ctx.translate(shakeX, shakeY);

    if (gameState === 'playing' || gameState === 'gameover') {
        updateAnimation();
        updateShake();
        updateParticles();
        drawPlayArea(time);
        drawHUD();
        drawParticles();
        drawTutorial(time);
    } else if (gameState === 'paused') {
        drawPlayArea(time);
        drawHUD();
        drawParticles();
    }

    ctx.restore();

    requestAnimationFrame(gameLoop);
}

// ===== INIT =====
showMainMenu();
requestAnimationFrame(gameLoop);
</script>
</body>
</html>