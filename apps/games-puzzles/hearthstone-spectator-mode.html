<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Card Battle Arena - Spectator Mode</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            overflow: hidden;
        }

        #game-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
            padding: 10px;
        }

        #commentary-panel {
            position: fixed;
            right: 0;
            top: 0;
            width: 350px;
            height: 100vh;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 20px;
            overflow-y: auto;
            border-left: 3px solid rgba(255, 255, 255, 0.2);
        }

        #commentary-panel h2 {
            margin-bottom: 20px;
            color: #ffd43b;
            text-align: center;
        }

        .commentary-entry {
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            border-left: 3px solid #4dabf7;
            animation: slideIn 0.5s ease-out;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .commentary-turn {
            color: #ffd43b;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .commentary-action {
            color: #51cf66;
            font-weight: bold;
        }

        .commentary-reason {
            color: #adb5bd;
            font-style: italic;
            margin-top: 5px;
            font-size: 14px;
        }

        .game-controls {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
        }

        .control-btn {
            padding: 10px 20px;
            margin: 5px;
            background: linear-gradient(135deg, #4dabf7 0%, #339af0 100%);
            color: white;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .control-btn.active {
            background: linear-gradient(135deg, #51cf66 0%, #37b24d 100%);
        }

        .speed-control {
            margin-top: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
            color: white;
        }

        .speed-slider {
            width: 150px;
        }

        .player-area {
            height: 30vh;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .player-info {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .player-stats {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .health {
            font-size: 24px;
            font-weight: bold;
            color: #ff6b6b;
        }

        .mana {
            font-size: 18px;
            color: #4dabf7;
        }

        .hand {
            display: flex;
            justify-content: center;
            gap: 10px;
            flex: 1;
            align-items: center;
            padding: 10px;
            min-height: 120px;
        }

        .battlefield {
            height: 25vh;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            display: flex;
            flex-direction: column;
        }

        .battlefield-row {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            padding: 10px;
        }

        .card {
            width: 90px;
            height: 120px;
            background: linear-gradient(135deg, #e3e3e3 0%, #ffffff 100%);
            border: 3px solid #333;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            padding: 5px;
            transition: all 0.3s ease;
            position: relative;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .card.highlighted {
            border-color: #ffd43b;
            box-shadow: 0 0 20px rgba(255, 212, 59, 0.8);
            transform: translateY(-10px);
        }

        .card.attacking {
            animation: attack-animation 0.5s ease-out;
        }

        @keyframes attack-animation {
            0% { transform: translateX(0); }
            50% { transform: translateX(30px); }
            100% { transform: translateX(0); }
        }

        .card-cost {
            position: absolute;
            top: -5px;
            left: -5px;
            width: 25px;
            height: 25px;
            background: #4dabf7;
            border: 2px solid #333;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            color: white;
        }

        .card-name {
            background: #333;
            color: white;
            padding: 2px;
            border-radius: 5px;
            font-size: 10px;
            text-align: center;
            margin-bottom: 3px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .card-art {
            flex: 1;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 5px;
            margin-bottom: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }

        .card-text {
            font-size: 9px;
            text-align: center;
            margin-bottom: 3px;
            min-height: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .card-stats {
            display: flex;
            justify-content: space-between;
            padding: 0 8px;
        }

        .card-attack {
            background: #ff6b6b;
            color: white;
            padding: 3px 6px;
            border-radius: 5px;
            font-weight: bold;
            font-size: 12px;
        }

        .card-health {
            background: #51cf66;
            color: white;
            padding: 3px 6px;
            border-radius: 5px;
            font-weight: bold;
            font-size: 12px;
        }

        .spell-card .card-stats {
            display: none;
        }

        .spell-card .card-art {
            background: linear-gradient(135deg, #4dabf7 0%, #339af0 100%);
        }

        .damage-animation {
            position: absolute;
            font-size: 36px;
            font-weight: bold;
            color: #ff6b6b;
            pointer-events: none;
            animation: damage-float 1s ease-out forwards;
            z-index: 200;
        }

        @keyframes damage-float {
            0% {
                transform: translateY(0) scale(0.5);
                opacity: 1;
            }
            100% {
                transform: translateY(-50px) scale(1.5);
                opacity: 0;
            }
        }

        .game-over {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .game-over-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            color: white;
        }

        .game-over h2 {
            font-size: 48px;
            margin-bottom: 20px;
        }

        .restart-btn {
            padding: 15px 40px;
            background: #51cf66;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 20px;
        }

        .turn-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: #ffd43b;
            padding: 10px 30px;
            border-radius: 10px;
            font-size: 20px;
            font-weight: bold;
            z-index: 50;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="game-controls">
        <button class="control-btn" id="start-btn">Start Game</button>
        <button class="control-btn" id="pause-btn">Pause</button>
        <button class="control-btn" id="reset-btn">Reset</button>
        <div class="speed-control">
            <label>Speed:</label>
            <input type="range" class="speed-slider" id="speed-slider" min="0.5" max="3" step="0.5" value="1">
            <span id="speed-display">1x</span>
        </div>
    </div>

    <div id="game-container">
        <div class="player-area">
            <div class="player-info">
                <div class="player-stats">
                    <span class="player-name">CPU Player 1</span>
                    <span class="health">‚ù§Ô∏è <span id="player1-health">30</span></span>
                    <span class="mana">üíé <span id="player1-mana">0</span>/<span id="player1-max-mana">0</span></span>
                </div>
                <span id="player1-cards">Cards: 0</span>
            </div>
            <div class="hand" id="player1-hand"></div>
        </div>

        <div class="battlefield">
            <div class="battlefield-row" id="player1-battlefield"></div>
            <div class="turn-indicator" id="turn-indicator" style="display: none;">Player 1's Turn</div>
            <div class="battlefield-row" id="player2-battlefield"></div>
        </div>

        <div class="player-area">
            <div class="hand" id="player2-hand"></div>
            <div class="player-info">
                <div class="player-stats">
                    <span class="player-name">CPU Player 2</span>
                    <span class="health">‚ù§Ô∏è <span id="player2-health">30</span></span>
                    <span class="mana">üíé <span id="player2-mana">0</span>/<span id="player2-max-mana">0</span></span>
                </div>
                <span id="player2-cards">Cards: 0</span>
            </div>
        </div>
    </div>

    <div id="commentary-panel">
        <h2>üì∫ Play-by-Play Commentary</h2>
        <div id="commentary-content"></div>
    </div>

    <script>
        const CARD_DATABASE = {
            // Neutral Minions
            recruit: { name: "Recruit", cost: 1, attack: 1, health: 2, type: "minion", text: "", emoji: "üó°Ô∏è" },
            scout: { name: "Scout", cost: 2, attack: 2, health: 3, type: "minion", text: "", emoji: "üèπ" },
            knight: { name: "Knight", cost: 3, attack: 3, health: 4, type: "minion", text: "", emoji: "‚öîÔ∏è" },
            veteran: { name: "Veteran", cost: 4, attack: 4, health: 5, type: "minion", text: "", emoji: "üõ°Ô∏è" },
            champion: { name: "Champion", cost: 5, attack: 5, health: 6, type: "minion", text: "", emoji: "üëë" },
            
            // Special Minions
            berserker: { name: "Berserker", cost: 3, attack: 5, health: 2, type: "minion", text: "Charge", emoji: "üò§", charge: true },
            healer: { name: "Healer", cost: 2, attack: 1, health: 3, type: "minion", text: "Heal 2", emoji: "üíö", battlecry: "heal" },
            assassin: { name: "Assassin", cost: 4, attack: 4, health: 2, type: "minion", text: "Stealth", emoji: "ü•∑", stealth: true },
            tank: { name: "Tank", cost: 5, attack: 3, health: 8, type: "minion", text: "Taunt", emoji: "üõ°Ô∏è", taunt: true },
            wizard: { name: "Wizard", cost: 6, attack: 4, health: 4, type: "minion", text: "Spell +1", emoji: "üßô", spellpower: 1 },
            
            // Spells
            fireball: { name: "Fireball", cost: 4, type: "spell", text: "Deal 6 damage", emoji: "üî•", damage: 6 },
            lightning: { name: "Lightning", cost: 2, type: "spell", text: "Deal 3 damage", emoji: "‚ö°", damage: 3 },
            heal: { name: "Heal", cost: 1, type: "spell", text: "Restore 3 health", emoji: "‚ú®", heal: 3 },
            draw: { name: "Arcane Intellect", cost: 3, type: "spell", text: "Draw 2 cards", emoji: "üìö", draw: 2 },
            buff: { name: "Blessing", cost: 2, type: "spell", text: "+2/+2 to minion", emoji: "‚≠ê", buffAttack: 2, buffHealth: 2 },
            freeze: { name: "Frost Bolt", cost: 3, type: "spell", text: "Deal 3 damage and Freeze", emoji: "‚ùÑÔ∏è", damage: 3, freeze: true },
            aoe: { name: "Flamestrike", cost: 7, type: "spell", text: "Deal 4 to all enemies", emoji: "üî•", aoe: 4 }
        };

        class Card {
            constructor(template, id) {
                Object.assign(this, template);
                this.id = id;
                this.currentHealth = this.health;
                this.currentAttack = this.attack;
                this.exhausted = false;
                this.frozen = false;
                this.attacksThisTurn = 0;
            }

            canAttack() {
                return this.type === "minion" && !this.exhausted && !this.frozen && this.attacksThisTurn === 0;
            }

            takeDamage(amount) {
                this.currentHealth -= amount;
                return this.currentHealth <= 0;
            }

            heal(amount) {
                this.currentHealth = Math.min(this.currentHealth + amount, this.health);
            }

            buff(attack, health) {
                this.currentAttack += attack;
                this.attack += attack;
                this.currentHealth += health;
                this.health += health;
            }
        }

        class SpectatorGame {
            constructor() {
                this.player1Health = 30;
                this.player2Health = 30;
                this.player1MaxHealth = 30;
                this.player2MaxHealth = 30;
                this.player1Mana = 0;
                this.player1MaxMana = 0;
                this.player2Mana = 0;
                this.player2MaxMana = 0;
                this.turn = 1;
                this.currentPlayer = 1;
                this.player1Hand = [];
                this.player2Hand = [];
                this.player1Battlefield = [];
                this.player2Battlefield = [];
                this.player1Deck = [];
                this.player2Deck = [];
                this.gameOver = false;
                this.paused = false;
                this.gameSpeed = 1;
                this.cardIdCounter = 0;
                this.commentaryLog = [];
                
                this.initializeDecks();
                this.setupEventListeners();
            }

            initializeDecks() {
                const deckTemplate = [
                    'recruit', 'recruit', 'scout', 'scout', 'knight', 'knight',
                    'veteran', 'champion', 'berserker', 'healer', 'assassin',
                    'tank', 'wizard', 'fireball', 'fireball', 'lightning',
                    'lightning', 'heal', 'heal', 'draw', 'draw', 'buff',
                    'buff', 'freeze', 'freeze', 'aoe', 'recruit', 'scout',
                    'knight', 'veteran'
                ];

                for (let cardName of deckTemplate) {
                    this.player1Deck.push(new Card(CARD_DATABASE[cardName], this.cardIdCounter++));
                    this.player2Deck.push(new Card(CARD_DATABASE[cardName], this.cardIdCounter++));
                }

                this.shuffleDeck(this.player1Deck);
                this.shuffleDeck(this.player2Deck);
            }

            shuffleDeck(deck) {
                for (let i = deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deck[i], deck[j]] = [deck[j], deck[i]];
                }
            }

            setupEventListeners() {
                document.getElementById('start-btn').addEventListener('click', () => this.startGame());
                document.getElementById('pause-btn').addEventListener('click', () => this.togglePause());
                document.getElementById('reset-btn').addEventListener('click', () => location.reload());
                document.getElementById('speed-slider').addEventListener('input', (e) => {
                    this.gameSpeed = parseFloat(e.target.value);
                    document.getElementById('speed-display').textContent = `${this.gameSpeed}x`;
                });
            }

            addCommentary(action, reason = "") {
                const entry = {
                    turn: this.turn,
                    player: this.currentPlayer,
                    action: action,
                    reason: reason
                };
                
                this.commentaryLog.push(entry);
                
                const commentaryDiv = document.createElement('div');
                commentaryDiv.className = 'commentary-entry';
                commentaryDiv.innerHTML = `
                    <div class="commentary-turn">Turn ${this.turn} - Player ${this.currentPlayer}</div>
                    <div class="commentary-action">${action}</div>
                    ${reason ? `<div class="commentary-reason">${reason}</div>` : ''}
                `;
                
                const container = document.getElementById('commentary-content');
                container.insertBefore(commentaryDiv, container.firstChild);
                
                // Keep only last 10 entries visible
                while (container.children.length > 10) {
                    container.removeChild(container.lastChild);
                }
            }

            startGame() {
                this.addCommentary("üéÆ Game Started!", "Both players drawing initial hands...");
                
                // Draw initial hands
                for (let i = 0; i < 3; i++) {
                    this.drawCard(1);
                    this.drawCard(2);
                }
                // Player going first gets extra card
                this.drawCard(1);
                
                document.getElementById('start-btn').classList.add('active');
                document.getElementById('start-btn').textContent = 'Game Running';
                
                this.startTurn();
            }

            togglePause() {
                this.paused = !this.paused;
                const btn = document.getElementById('pause-btn');
                btn.textContent = this.paused ? 'Resume' : 'Pause';
                btn.classList.toggle('active', this.paused);
            }

            startTurn() {
                if (this.gameOver || this.paused) {
                    if (this.paused) {
                        setTimeout(() => this.startTurn(), 500);
                    }
                    return;
                }

                // Update mana
                if (this.turn <= 10) {
                    if (this.currentPlayer === 1) {
                        this.player1MaxMana = Math.ceil(this.turn / 2);
                    } else {
                        this.player2MaxMana = Math.floor(this.turn / 2) + 1;
                    }
                }

                const currentMana = this.currentPlayer === 1 ? this.player1MaxMana : this.player2MaxMana;
                if (this.currentPlayer === 1) {
                    this.player1Mana = this.player1MaxMana;
                } else {
                    this.player2Mana = this.player2MaxMana;
                }

                // Draw card
                this.drawCard(this.currentPlayer);
                
                // Show turn indicator
                const indicator = document.getElementById('turn-indicator');
                indicator.textContent = `Player ${this.currentPlayer}'s Turn`;
                indicator.style.display = 'block';
                
                this.addCommentary(
                    `üîÑ Turn ${Math.ceil(this.turn / 2)} begins`,
                    `Player ${this.currentPlayer} has ${currentMana} mana available`
                );

                // Refresh minions
                const battlefield = this.currentPlayer === 1 ? this.player1Battlefield : this.player2Battlefield;
                battlefield.forEach(card => {
                    card.exhausted = false;
                    card.attacksThisTurn = 0;
                    if (card.frozen) {
                        card.frozen = false;
                        card.exhausted = true;
                    }
                });

                this.updateDisplay();

                // Execute CPU turn
                setTimeout(() => this.executeCPUTurn(), 1500 / this.gameSpeed);
            }

            drawCard(player) {
                const deck = player === 1 ? this.player1Deck : this.player2Deck;
                const hand = player === 1 ? this.player1Hand : this.player2Hand;

                if (deck.length > 0 && hand.length < 10) {
                    const card = deck.shift();
                    hand.push(card);
                }
            }

            evaluateCardValue(card, gameState) {
                let value = 0;
                
                // Basic value based on stats
                if (card.type === "minion") {
                    value = card.attack + card.health;
                    
                    // Bonus for special abilities
                    if (card.charge) value += 2;
                    if (card.taunt) value += gameState.enemyMinions > 2 ? 3 : 1;
                    if (card.stealth) value += 1;
                    if (card.battlecry === "heal" && gameState.myHealth < 20) value += 3;
                } else if (card.type === "spell") {
                    if (card.damage) {
                        value = card.damage * 1.5;
                        if (gameState.enemyHealth <= card.damage) value += 10; // Lethal
                    }
                    if (card.heal && gameState.myHealth < 15) value += 4;
                    if (card.draw && gameState.myHand < 3) value += 3;
                    if (card.buffAttack && gameState.myMinions > 0) value += 4;
                    if (card.aoe && gameState.enemyMinions >= 3) value += 6;
                }
                
                // Mana efficiency
                value = value / (card.cost || 1);
                
                return value;
            }

            executeCPUTurn() {
                if (this.gameOver || this.paused) return;

                const isPlayer1 = this.currentPlayer === 1;
                const hand = isPlayer1 ? this.player1Hand : this.player2Hand;
                const mana = isPlayer1 ? this.player1Mana : this.player2Mana;
                const battlefield = isPlayer1 ? this.player1Battlefield : this.player2Battlefield;
                const enemyBattlefield = isPlayer1 ? this.player2Battlefield : this.player1Battlefield;
                const myHealth = isPlayer1 ? this.player1Health : this.player2Health;
                const enemyHealth = isPlayer1 ? this.player2Health : this.player1Health;

                const gameState = {
                    myHealth,
                    enemyHealth,
                    myMinions: battlefield.length,
                    enemyMinions: enemyBattlefield.length,
                    myHand: hand.length,
                    mana
                };

                // Phase 1: Play cards
                const playableCards = hand.filter(card => card.cost <= (isPlayer1 ? this.player1Mana : this.player2Mana));
                
                // Sort by evaluated value
                playableCards.sort((a, b) => {
                    return this.evaluateCardValue(b, gameState) - this.evaluateCardValue(a, gameState);
                });

                for (let card of playableCards) {
                    const currentMana = isPlayer1 ? this.player1Mana : this.player2Mana;
                    if (card.cost > currentMana) continue;

                    if (card.type === "minion" && battlefield.length < 7) {
                        if (this.playCard(card, isPlayer1)) {
                            this.highlightCard(card);
                            this.addCommentary(
                                `üé¥ Played ${card.name} (${card.cost} mana)`,
                                `${card.attack}/${card.health} minion${card.text ? ` with ${card.text}` : ''}`
                            );
                            this.updateDisplay();
                        }
                    } else if (card.type === "spell") {
                        const spellResult = this.executeCPUSpell(card, isPlayer1, gameState);
                        if (spellResult) {
                            this.updateDisplay();
                            break;
                        }
                    }
                }

                // Phase 2: Combat
                setTimeout(() => {
                    const attackers = battlefield.filter(card => card.canAttack());
                    const enemyTaunts = enemyBattlefield.filter(card => card.taunt);
                    
                    for (let attacker of attackers) {
                        let target = null;
                        let targetDescription = "";
                        
                        if (enemyTaunts.length > 0) {
                            // Must attack taunt
                            target = enemyTaunts.reduce((weakest, current) => 
                                current.currentHealth < weakest.currentHealth ? current : weakest
                            );
                            targetDescription = `${target.name} (Taunt)`;
                        } else {
                            // Strategic targeting
                            const tradeTargets = enemyBattlefield.filter(enemy => 
                                enemy.currentHealth <= attacker.currentAttack && 
                                enemy.currentAttack < attacker.currentHealth
                            );
                            
                            if (tradeTargets.length > 0) {
                                target = tradeTargets.reduce((best, current) => 
                                    current.currentAttack > best.currentAttack ? current : best
                                );
                                targetDescription = `${target.name} (favorable trade)`;
                            } else if (enemyHealth <= attacker.currentAttack) {
                                target = { type: "hero", isPlayer: !isPlayer1 };
                                targetDescription = "enemy hero (lethal damage!)";
                            } else if (enemyBattlefield.length > 0 && Math.random() > 0.4) {
                                target = enemyBattlefield[Math.floor(Math.random() * enemyBattlefield.length)];
                                targetDescription = target.name;
                            } else {
                                target = { type: "hero", isPlayer: !isPlayer1 };
                                targetDescription = "enemy hero (face damage)";
                            }
                        }
                        
                        if (target) {
                            this.highlightCard(attacker);
                            this.addCommentary(
                                `‚öîÔ∏è ${attacker.name} attacks ${targetDescription}`,
                                `Dealing ${attacker.currentAttack} damage`
                            );
                            
                            setTimeout(() => {
                                this.performAttack(attacker, target);
                            }, 500 / this.gameSpeed);
                        }
                    }

                    // End turn
                    setTimeout(() => {
                        document.getElementById('turn-indicator').style.display = 'none';
                        this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
                        this.turn++;
                        this.startTurn();
                    }, 1500 / this.gameSpeed);
                }, 1500 / this.gameSpeed);
            }

            highlightCard(card) {
                if (card.element) {
                    card.element.classList.add('highlighted');
                    setTimeout(() => {
                        if (card.element) {
                            card.element.classList.remove('highlighted');
                        }
                    }, 1000 / this.gameSpeed);
                }
            }

            playCard(card, isPlayer1) {
                const hand = isPlayer1 ? this.player1Hand : this.player2Hand;
                const mana = isPlayer1 ? this.player1Mana : this.player2Mana;

                if (card.cost > mana) return false;

                const index = hand.indexOf(card);
                if (index === -1) return false;

                if (isPlayer1) {
                    this.player1Mana -= card.cost;
                } else {
                    this.player2Mana -= card.cost;
                }

                hand.splice(index, 1);

                if (card.type === "minion") {
                    const battlefield = isPlayer1 ? this.player1Battlefield : this.player2Battlefield;
                    if (battlefield.length < 7) {
                        card.exhausted = !card.charge;
                        battlefield.push(card);
                        
                        if (card.battlecry === "heal") {
                            const healAmount = 2;
                            if (isPlayer1) {
                                this.player1Health = Math.min(this.player1Health + healAmount, this.player1MaxHealth);
                            } else {
                                this.player2Health = Math.min(this.player2Health + healAmount, this.player2MaxHealth);
                            }
                            this.addCommentary(`üíö Battlecry: Healed for ${healAmount}`);
                        }
                    }
                }

                return true;
            }

            executeCPUSpell(spell, isPlayer1, gameState) {
                const mana = isPlayer1 ? this.player1Mana : this.player2Mana;
                if (spell.cost > mana) return false;

                let executed = false;
                
                if (spell.damage) {
                    const enemyBattlefield = isPlayer1 ? this.player2Battlefield : this.player1Battlefield;
                    const enemyHealth = isPlayer1 ? this.player2Health : this.player1Health;
                    
                    if (spell.aoe && enemyBattlefield.length >= 2) {
                        if (this.playCard(spell, isPlayer1)) {
                            this.executeSpell(spell, null, isPlayer1);
                            this.addCommentary(
                                `üî• Cast ${spell.name}`,
                                `Dealing ${spell.aoe} damage to all enemies!`
                            );
                            executed = true;
                        }
                    } else if (!spell.aoe) {
                        let target = null;
                        let reason = "";
                        
                        if (enemyHealth <= spell.damage) {
                            target = { type: "hero", isPlayer: !isPlayer1 };
                            reason = "Going for lethal!";
                        } else if (enemyBattlefield.length > 0) {
                            const killTargets = enemyBattlefield.filter(m => m.currentHealth <= spell.damage);
                            if (killTargets.length > 0) {
                                target = killTargets.reduce((best, current) => 
                                    current.currentAttack > best.currentAttack ? current : best
                                );
                                reason = `Removing ${target.name} from board`;
                            } else {
                                target = { type: "hero", isPlayer: !isPlayer1 };
                                reason = "Direct damage to face";
                            }
                        } else {
                            target = { type: "hero", isPlayer: !isPlayer1 };
                            reason = "No minions to target";
                        }
                        
                        if (target && this.playCard(spell, isPlayer1)) {
                            this.executeSpell(spell, target, isPlayer1);
                            this.addCommentary(`‚ö° Cast ${spell.name}`, reason);
                            executed = true;
                        }
                    }
                }

                if (!executed && spell.heal) {
                    const myHealth = isPlayer1 ? this.player1Health : this.player2Health;
                    if (myHealth < 20) {
                        if (this.playCard(spell, isPlayer1)) {
                            this.executeSpell(spell, { type: "hero", isPlayer: isPlayer1 }, isPlayer1);
                            this.addCommentary(
                                `‚ú® Cast ${spell.name}`,
                                `Healing for ${spell.heal} (health was ${myHealth})`
                            );
                            executed = true;
                        }
                    }
                }

                if (!executed && spell.draw && gameState.myHand < 4) {
                    if (this.playCard(spell, isPlayer1)) {
                        this.executeSpell(spell, null, isPlayer1);
                        this.addCommentary(
                            `üìö Cast ${spell.name}`,
                            `Drawing ${spell.draw} cards (hand was getting low)`
                        );
                        executed = true;
                    }
                }

                if (!executed && spell.buffAttack && gameState.myMinions > 0) {
                    const battlefield = isPlayer1 ? this.player1Battlefield : this.player2Battlefield;
                    const target = battlefield.reduce((best, current) => 
                        current.currentAttack > best.currentAttack ? current : best
                    );
                    
                    if (this.playCard(spell, isPlayer1)) {
                        this.executeSpell(spell, target, isPlayer1);
                        this.addCommentary(
                            `‚≠ê Cast ${spell.name} on ${target.name}`,
                            `Buffing to ${target.currentAttack}/${target.currentHealth}`
                        );
                        executed = true;
                    }
                }

                return executed;
            }

            executeSpell(spell, target, isPlayer1) {
                if (spell.damage) {
                    const damage = spell.damage;
                    if (target && target.type === "minion") {
                        const isDead = target.takeDamage(damage);
                        this.showDamageAnimation(target.element, damage);
                        if (isDead) {
                            this.removeMinion(target);
                        }
                        if (spell.freeze) {
                            target.frozen = true;
                        }
                    } else if (target && target.type === "hero") {
                        if (target.isPlayer) {
                            this.player1Health -= damage;
                        } else {
                            this.player2Health -= damage;
                        }
                        this.checkGameOver();
                    }
                }

                if (spell.heal) {
                    if (target && target.type === "hero") {
                        if (target.isPlayer) {
                            this.player1Health = Math.min(this.player1Health + spell.heal, this.player1MaxHealth);
                        } else {
                            this.player2Health = Math.min(this.player2Health + spell.heal, this.player2MaxHealth);
                        }
                    }
                }

                if (spell.draw) {
                    for (let i = 0; i < spell.draw; i++) {
                        this.drawCard(isPlayer1 ? 1 : 2);
                    }
                }

                if (spell.buffAttack && target && target.type === "minion") {
                    target.buff(spell.buffAttack, spell.buffHealth);
                }

                if (spell.aoe) {
                    const targets = isPlayer1 ? this.player2Battlefield : this.player1Battlefield;
                    const toRemove = [];
                    targets.forEach(minion => {
                        const isDead = minion.takeDamage(spell.aoe);
                        if (minion.element) {
                            this.showDamageAnimation(minion.element, spell.aoe);
                        }
                        if (isDead) {
                            toRemove.push(minion);
                        }
                    });
                    toRemove.forEach(minion => this.removeMinion(minion));
                }

                this.updateDisplay();
            }

            performAttack(attacker, target) {
                if (!attacker.canAttack()) return;

                attacker.attacksThisTurn++;
                
                if (attacker.element) {
                    attacker.element.classList.add('attacking');
                    setTimeout(() => {
                        if (attacker.element) {
                            attacker.element.classList.remove('attacking');
                        }
                    }, 500 / this.gameSpeed);
                }
                
                if (target.type === "minion") {
                    const attackerDead = attacker.takeDamage(target.currentAttack);
                    const targetDead = target.takeDamage(attacker.currentAttack);
                    
                    this.showDamageAnimation(attacker.element, target.currentAttack);
                    this.showDamageAnimation(target.element, attacker.currentAttack);
                    
                    if (attackerDead) this.removeMinion(attacker);
                    if (targetDead) {
                        this.removeMinion(target);
                        this.addCommentary(`üíÄ ${target.name} destroyed!`);
                    }
                } else if (target.type === "hero") {
                    if (target.isPlayer) {
                        this.player1Health -= attacker.currentAttack;
                    } else {
                        this.player2Health -= attacker.currentAttack;
                    }
                    this.checkGameOver();
                }

                this.updateDisplay();
            }

            removeMinion(minion) {
                const p1Index = this.player1Battlefield.indexOf(minion);
                const p2Index = this.player2Battlefield.indexOf(minion);
                
                if (p1Index !== -1) {
                    this.player1Battlefield.splice(p1Index, 1);
                } else if (p2Index !== -1) {
                    this.player2Battlefield.splice(p2Index, 1);
                }
            }

            showDamageAnimation(element, damage) {
                if (!element) return;
                
                const rect = element.getBoundingClientRect();
                const damageEl = document.createElement('div');
                damageEl.className = 'damage-animation';
                damageEl.textContent = `-${damage}`;
                damageEl.style.left = rect.left + rect.width / 2 + 'px';
                damageEl.style.top = rect.top + 'px';
                document.body.appendChild(damageEl);
                
                setTimeout(() => damageEl.remove(), 1000);
            }

            checkGameOver() {
                if (this.player1Health <= 0) {
                    this.showGameOver(2);
                } else if (this.player2Health <= 0) {
                    this.showGameOver(1);
                }
            }

            showGameOver(winner) {
                this.gameOver = true;
                this.addCommentary(
                    `üèÜ Player ${winner} Wins!`,
                    `Final score: P1: ${this.player1Health} HP, P2: ${this.player2Health} HP`
                );
                
                const gameOverDiv = document.createElement('div');
                gameOverDiv.className = 'game-over';
                gameOverDiv.innerHTML = `
                    <div class="game-over-content">
                        <h2>Player ${winner} Wins!</h2>
                        <p>Player 1: ${this.player1Health} HP remaining</p>
                        <p>Player 2: ${this.player2Health} HP remaining</p>
                        <button class="restart-btn" onclick="location.reload()">Watch Another Game</button>
                    </div>
                `;
                document.body.appendChild(gameOverDiv);
            }

            createCardElement(card) {
                const div = document.createElement('div');
                div.className = `card ${card.type === 'spell' ? 'spell-card' : ''}`;
                div.dataset.cardId = card.id;
                
                div.innerHTML = `
                    <div class="card-cost">${card.cost}</div>
                    <div class="card-name">${card.name}</div>
                    <div class="card-art">${card.emoji || ''}</div>
                    <div class="card-text">${card.text || ''}</div>
                    ${card.type === 'minion' ? `
                        <div class="card-stats">
                            <span class="card-attack">${card.currentAttack || card.attack}</span>
                            <span class="card-health">${card.currentHealth || card.health}</span>
                        </div>
                    ` : ''}
                `;
                
                card.element = div;
                return div;
            }

            updateDisplay() {
                // Update health and mana
                document.getElementById('player1-health').textContent = this.player1Health;
                document.getElementById('player2-health').textContent = this.player2Health;
                document.getElementById('player1-mana').textContent = this.player1Mana;
                document.getElementById('player1-max-mana').textContent = this.player1MaxMana;
                document.getElementById('player2-mana').textContent = this.player2Mana;
                document.getElementById('player2-max-mana').textContent = this.player2MaxMana;
                document.getElementById('player1-cards').textContent = `Cards: ${this.player1Hand.length}`;
                document.getElementById('player2-cards').textContent = `Cards: ${this.player2Hand.length}`;
                
                // Update hands
                const player1HandEl = document.getElementById('player1-hand');
                const player2HandEl = document.getElementById('player2-hand');
                
                player1HandEl.innerHTML = '';
                this.player1Hand.forEach(card => {
                    const cardEl = this.createCardElement(card);
                    if (card.cost <= this.player1Mana && this.currentPlayer === 1) {
                        cardEl.style.borderColor = '#51cf66';
                    }
                    player1HandEl.appendChild(cardEl);
                });
                
                player2HandEl.innerHTML = '';
                this.player2Hand.forEach(card => {
                    const cardEl = this.createCardElement(card);
                    if (card.cost <= this.player2Mana && this.currentPlayer === 2) {
                        cardEl.style.borderColor = '#51cf66';
                    }
                    player2HandEl.appendChild(cardEl);
                });
                
                // Update battlefields
                const player1BattlefieldEl = document.getElementById('player1-battlefield');
                const player2BattlefieldEl = document.getElementById('player2-battlefield');
                
                player1BattlefieldEl.innerHTML = '';
                this.player1Battlefield.forEach(card => {
                    const cardEl = this.createCardElement(card);
                    if (card.canAttack() && this.currentPlayer === 1) {
                        cardEl.style.borderColor = '#ffd43b';
                    }
                    player1BattlefieldEl.appendChild(cardEl);
                });
                
                player2BattlefieldEl.innerHTML = '';
                this.player2Battlefield.forEach(card => {
                    const cardEl = this.createCardElement(card);
                    if (card.canAttack() && this.currentPlayer === 2) {
                        cardEl.style.borderColor = '#ffd43b';
                    }
                    player2BattlefieldEl.appendChild(cardEl);
                });
            }
        }

        // Initialize game
        const game = new SpectatorGame();
    </script>
</body>
</html>