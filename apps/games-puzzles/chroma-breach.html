<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chroma Breach: The Datamosh Protocol</title>
    <meta name="description" content="A first-person puzzle game where you manipulate the fabric of digital reality using video compression artifacts. Learn about I-frames, P-frames, and motion vectors while solving glitches.">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
            user-select: none;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }
        .hud-element {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #0f0;
            color: #0f0;
            padding: 10px;
            text-shadow: 0 0 5px #0f0;
            backdrop-filter: blur(2px);
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            border: 2px solid #0f0;
            border-radius: 50%;
            pointer-events: none;
        }
        #crosshair::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background: #0f0;
            transform: translate(-50%, -50%);
        }
        #weapon-status {
            position: absolute;
            bottom: 20px;
            right: 20px;
            text-align: right;
        }
        #mode-indicator {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        #ammo-bar {
            width: 200px;
            height: 10px;
            background: #333;
            border: 1px solid #0f0;
        }
        #ammo-fill {
            width: 100%;
            height: 100%;
            background: #0f0;
            transition: width 0.1s;
        }
        #dialogue-box {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            background: rgba(0, 20, 0, 0.9);
            border: 2px solid #0f0;
            padding: 20px;
            display: none;
        }
        #dialogue-text {
            color: #fff;
            font-size: 16px;
            line-height: 1.5;
        }
        #dialogue-speaker {
            color: #0f0;
            font-weight: bold;
            margin-bottom: 5px;
            text-transform: uppercase;
        }
        #level-info {
            position: absolute;
            top: 20px;
            left: 20px;
        }
        #tutorial-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #fff;
            background: rgba(0, 0, 0, 0.8);
            padding: 40px;
            border: 2px solid #0f0;
            max-width: 600px;
            display: none;
            pointer-events: auto;
        }
        button {
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 10px 20px;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            cursor: pointer;
            margin-top: 20px;
        }
        button:hover {
            background: #0f0;
            color: #000;
        }
        .glitch-text {
            animation: glitch 1s linear infinite;
        }
        @keyframes glitch {
            2%, 64% { transform: translate(2px,0) skew(0deg); }
            4%, 60% { transform: translate(-2px,0) skew(0deg); }
            62% { transform: translate(0,0) skew(5deg); }
        }
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
        }
        h1 {
            font-size: 64px;
            color: #0f0;
            text-shadow: 4px 4px #f0f;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 5px;
        }
        .scanline {
            width: 100%;
            height: 100px;
            z-index: 10;
            background: linear-gradient(0deg, rgba(0,0,0,0) 0%, rgba(0, 255, 0, 0.2) 50%, rgba(0,0,0,0) 100%);
            opacity: 0.1;
            position: absolute;
            bottom: 100%;
            animation: scanline 10s linear infinite;
            pointer-events: none;
        }
        @keyframes scanline {
            0% { bottom: 100%; }
            100% { bottom: -100px; }
        }
    </style>
</head>
<body>
    <div id="start-screen">
        <h1 class="glitch-text">CHROMA BREACH</h1>
        <p style="color: #fff; margin-bottom: 40px; max-width: 600px; text-align: center;">
            The simulation is destabilizing. You are the Debugger.<br>
            Wield the artifacts of compression to rewrite reality.
        </p>
        <button id="start-btn">INITIALIZE PROTOCOL</button>
    </div>

    <div id="ui-layer">
        <div id="level-info" class="hud-element">
            <div id="level-name">SECTOR 01: THE I-FRAME</div>
            <div id="fps-counter">60 FPS</div>
        </div>
        
        <div id="crosshair"></div>
        
        <div id="weapon-status" class="hud-element">
            <div id="mode-indicator">MODE: MOSH (LMB)</div>
            <div id="ammo-bar"><div id="ammo-fill"></div></div>
            <div style="font-size: 12px; margin-top: 5px;">BUFFER STABILITY</div>
        </div>
        
        <div id="dialogue-box">
            <div id="dialogue-speaker">SYSTEM</div>
            <div id="dialogue-text">Welcome, Debugger. The rendering engine is failing. Use your Datamosh Tool to manipulate the video stream and traverse the corruption.</div>
        </div>
    </div>

    <div id="tutorial-overlay">
        <h2 id="tutorial-title">TUTORIAL</h2>
        <p id="tutorial-content">Content</p>
        <button id="tutorial-btn">ACKNOWLEDGE</button>
    </div>

    <div class="scanline"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

        // ==========================================
        // GAME STATE
        // ==========================================
        const STATE = {
            currentLevel: 0,
            isMoshing: false,
            moshEnergy: 100,
            playerPos: new THREE.Vector3(),
            dialogueQueue: [],
            isPaused: false,
            hasWeapon: false
        };

        // ==========================================
        // SHADERS
        // ==========================================
        
        // The Datamosh Shader simulates video compression artifacts
        // It uses a "previous frame" texture and motion vectors
        const DatamoshShader = {
            uniforms: {
                "tDiffuse": { value: null },
                "tPrev": { value: null },
                "uMoshing": { value: 0.0 },
                "uMotion": { value: new THREE.Vector2(0, 0) },
                "uResolution": { value: new THREE.Vector2() },
                "uTime": { value: 0.0 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform sampler2D tPrev;
                uniform float uMoshing;
                uniform vec2 uResolution;
                uniform float uTime;
                varying vec2 vUv;

                // Pseudo-random for noise
                float rand(vec2 co){
                    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
                }

                void main() {
                    vec4 currentColor = texture2D(tDiffuse, vUv);
                    vec4 prevColor = texture2D(tPrev, vUv);
                    
                    // If moshing is active, we ignore the new "I-frame" data (currentColor)
                    // and instead push the previous pixels based on their luminance/motion
                    
                    if (uMoshing > 0.5) {
                        // Calculate a fake motion vector based on color difference or just noise
                        // In a real codec, this would be provided. Here we simulate "drag".
                        
                        // Simple "smear" effect:
                        // We want moving objects to "paint" onto the background
                        
                        // Detect motion magnitude
                        float diff = distance(currentColor.rgb, prevColor.rgb);
                        
                        // If there is significant difference (movement), we use the NEW color (the moving object)
                        // If there is NO difference (static background), we KEEP the OLD color (persistence)
                        // BUT, to get the "drag" effect, we need to sample the previous texture at a distorted offset
                        
                        // This is a simplified "I-frame removal" simulation
                        // 1. If pixel is moving (high diff), draw it.
                        // 2. If pixel is static (low diff), draw the PREVIOUS frame's pixel at this location.
                        
                        // However, true datamoshing is about motion vectors applying to WRONG pixels.
                        // Let's simulate "Bloom/Smear" where bright/moving pixels overwrite static ones.
                        
                        vec2 offset = (currentColor.rg - 0.5) * 0.01; // Use color as motion vector
                        vec4 draggedColor = texture2D(tPrev, vUv - offset);
                        
                        // Threshold for "updating" the pixel
                        // If the new pixel is very different, it "breaks through" the mosh
                        // But we want the background to NOT update.
                        
                        // "Lock" the background:
                        // If the current pixel is "background" (we'll use alpha or specific color in game), keep prev.
                        
                        // Better simulation:
                        // Mix based on "force".
                        
                        gl_FragColor = mix(draggedColor, currentColor, 0.05); // High persistence (95% old frame)
                        
                        // Add some digital noise/artifacts
                        if (rand(vUv + uTime) > 0.99) {
                            gl_FragColor = texture2D(tPrev, vUv + vec2(0.01, 0.0)); // Horizontal tear
                        }
                    } else {
                        gl_FragColor = currentColor;
                    }
                }
            `
        };

        // ==========================================
        // ENGINE SETUP
        // ==========================================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        scene.fog = new THREE.FogExp2(0x111111, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: false }); // Disable AA for retro feel
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Post-processing
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        // Custom Mosh Pass
        // We need a way to feed the "previous frame" back into the shader
        // This requires a Ping-Pong buffer setup which is complex in standard Three.js examples
        // Simplified approach: Just use a "AfterImage" style effect but with logic
        
        // For this prototype, we will simulate the gameplay mechanic via logic in the update loop
        // and use a simple visual shader for the "glitch" look.
        // The "Smear" mechanic will be implemented by creating "trails" of geometry.
        
        // Actually, let's try a simpler visual trick for the "Mosh":
        // When "Moshing", we don't clear the buffer. We let it overdraw.
        renderer.autoClearColor = false;

        const controls = new PointerLockControls(camera, document.body);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        // ==========================================
        // LEVEL GENERATION
        // ==========================================
        const objects = [];
        const moshableObjects = []; // Objects that create trails
        const platforms = [];

        function createLevel(levelIndex) {
            // Clear existing
            objects.forEach(obj => scene.remove(obj));
            objects.length = 0;
            moshableObjects.length = 0;
            platforms.length = 0;

            // Floor
            const floorGeo = new THREE.PlaneGeometry(200, 200);
            const floorMat = new THREE.MeshStandardMaterial({ 
                color: 0x222222, 
                roughness: 0.8,
                wireframe: true
            });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            scene.add(floor);
            objects.push(floor);

            if (levelIndex === 0) {
                // LEVEL 1: THE GAP
                // Teach the player to use "Mosh" to bridge a gap
                
                // Starting Platform
                createPlatform(0, 0, 0, 10, 10, 0x444444);
                
                // The Gap
                // Target Platform
                createPlatform(0, 0, -20, 10, 10, 0x444444);
                
                // The "Moshable" Object
                // A block moving back and forth across the gap
                const mover = createMover(0, 2, -10, 2, 2, 2, 0x00ff00);
                mover.userData.velocity = new THREE.Vector3(0, 0, 0.1); // Moving Z? No, move X to bridge?
                // Move Z to bridge the gap? No, the gap is along Z.
                // Move Z back and forth.
                mover.userData.range = { min: -15, max: -5 };
                mover.userData.axis = 'z';
                mover.userData.speed = 0.1;
                
                showTutorial("THE I-FRAME", "Video compression works by saving a full picture (I-Frame) and then only saving changes (P-Frames).\n\nIf you delete the I-Frame, the computer forgets to clear the screen.\n\nHold LEFT CLICK to 'Mosh'. Moving green objects will smear and create solid bridges.");
            }
            else if (levelIndex === 1) {
                // LEVEL 2: THE WALL
                // Teach "Pixel Sort" (or just vertical mosh) to melt walls?
                // Let's stick to the Smear mechanic for now, maybe vertical smear to climb.
                
                createPlatform(0, 0, 0, 20, 20, 0x444444);
                
                // A high wall
                createBlock(0, 5, -10, 20, 10, 2, 0x880000); // Red wall
                
                // An elevator mover
                const lift = createMover(0, 1, -5, 4, 1, 4, 0x00ff00);
                lift.userData.axis = 'y';
                lift.userData.range = { min: 1, max: 8 };
                lift.userData.speed = 0.05;
                
                showTutorial("MOTION VECTORS", "Motion vectors tell pixels where to move.\n\nUse the Mosh tool on this vertical lift to create a ramp or column you can climb.");
            }
        }

        function createPlatform(x, y, z, w, d, color) {
            const geo = new THREE.BoxGeometry(w, 1, d);
            const mat = new THREE.MeshStandardMaterial({ color: color });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, y - 0.5, z);
            scene.add(mesh);
            objects.push(mesh);
            platforms.push(mesh); // For collision
            
            // Grid helper on top
            const grid = new THREE.GridHelper(Math.max(w, d), Math.max(w, d) / 2, 0x000000, 0x000000);
            grid.position.set(x, y, z);
            scene.add(grid);
            objects.push(grid);
        }

        function createBlock(x, y, z, w, h, d, color) {
            const geo = new THREE.BoxGeometry(w, h, d);
            const mat = new THREE.MeshStandardMaterial({ color: color });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, y, z);
            scene.add(mesh);
            objects.push(mesh);
            platforms.push(mesh);
        }

        function createMover(x, y, z, w, h, d, color) {
            const geo = new THREE.BoxGeometry(w, h, d);
            const mat = new THREE.MeshBasicMaterial({ 
                color: color,
                wireframe: true 
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, y, z);
            
            // Inner solid core
            const coreGeo = new THREE.BoxGeometry(w*0.8, h*0.8, d*0.8);
            const coreMat = new THREE.MeshBasicMaterial({ color: color });
            const core = new THREE.Mesh(coreGeo, coreMat);
            mesh.add(core);
            
            scene.add(mesh);
            objects.push(mesh);
            moshableObjects.push(mesh);
            platforms.push(mesh); // It's solid
            return mesh;
        }

        // ==========================================
        // GAMEPLAY LOGIC
        // ==========================================
        
        // Trail System for "Smearing"
        // When moshing, we spawn static copies of the moving object
        const trails = [];
        
        function updateMosh(deltaTime) {
            if (STATE.isMoshing && STATE.moshEnergy > 0) {
                STATE.moshEnergy -= deltaTime * 20;
                document.getElementById('ammo-fill').style.width = STATE.moshEnergy + '%';
                
                // Spawn trails for moving objects
                moshableObjects.forEach(obj => {
                    // Only spawn if moved enough
                    if (!obj.userData.lastPos) obj.userData.lastPos = obj.position.clone();
                    
                    if (obj.position.distanceTo(obj.userData.lastPos) > 0.5) {
                        spawnTrail(obj);
                        obj.userData.lastPos = obj.position.clone();
                    }
                });
                
                // Visual effect: Jitter camera slightly
                camera.position.x += (Math.random() - 0.5) * 0.05;
                camera.position.y += (Math.random() - 0.5) * 0.05;
                
            } else {
                if (STATE.moshEnergy < 100) {
                    STATE.moshEnergy += deltaTime * 10;
                    document.getElementById('ammo-fill').style.width = STATE.moshEnergy + '%';
                }
            }
        }

        function spawnTrail(sourceObj) {
            // Create a static clone of the object at its current position
            // This acts as a bridge
            const clone = sourceObj.clone();
            clone.position.copy(sourceObj.position);
            clone.rotation.copy(sourceObj.rotation);
            
            // Make it look "glitchy"
            clone.material = sourceObj.material.clone();
            clone.material.wireframe = false;
            clone.material.transparent = true;
            clone.material.opacity = 0.8;
            clone.material.color.setHex(0x00ff00); // Glitch green
            
            // Remove children (the core) to save perf, or keep them?
            // Clone does deep copy of children? No, Three.js clone is shallow for children usually unless recursive.
            // Actually Mesh.clone() doesn't clone children by default in older versions, but let's check.
            // We'll just use the geometry.
            
            scene.add(clone);
            trails.push({ mesh: clone, life: 10.0 }); // Lasts 10 seconds
            platforms.push(clone); // It's solid!
        }

        function updateTrails(deltaTime) {
            for (let i = trails.length - 1; i >= 0; i--) {
                const trail = trails[i];
                trail.life -= deltaTime;
                
                // Flicker effect
                trail.mesh.visible = Math.random() > 0.1;
                
                if (trail.life <= 0) {
                    scene.remove(trail.mesh);
                    // Remove from platforms collision array
                    const idx = platforms.indexOf(trail.mesh);
                    if (idx > -1) platforms.splice(idx, 1);
                    
                    trails.splice(i, 1);
                }
            }
        }

        function updateMovers(deltaTime) {
            const time = performance.now() * 0.001;
            
            moshableObjects.forEach(obj => {
                const range = obj.userData.range;
                const speed = obj.userData.speed;
                const axis = obj.userData.axis;
                
                // Simple sine wave movement
                // We want it to be predictable
                const val = range.min + (range.max - range.min) * (0.5 + 0.5 * Math.sin(time * speed * 10)); // Speed up
                
                if (axis === 'x') obj.position.x = val;
                if (axis === 'y') obj.position.y = val;
                if (axis === 'z') obj.position.z = val;
            });
        }

        // ==========================================
        // PLAYER CONTROLS
        // ==========================================
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const moveState = { forward: false, backward: false, left: false, right: false, jump: false };
        let canJump = false;

        document.addEventListener('keydown', (event) => {
            switch (event.code) {
                case 'KeyW': moveState.forward = true; break;
                case 'KeyA': moveState.left = true; break;
                case 'KeyS': moveState.backward = true; break;
                case 'KeyD': moveState.right = true; break;
                case 'Space': if (canJump) velocity.y += 15; canJump = false; break;
            }
        });

        document.addEventListener('keyup', (event) => {
            switch (event.code) {
                case 'KeyW': moveState.forward = false; break;
                case 'KeyA': moveState.left = false; break;
                case 'KeyS': moveState.backward = false; break;
                case 'KeyD': moveState.right = false; break;
            }
        });

        document.addEventListener('mousedown', () => {
            if (controls.isLocked) STATE.isMoshing = true;
        });

        document.addEventListener('mouseup', () => {
            STATE.isMoshing = false;
        });

        // Collision Detection (Raycasting)
        function checkCollision(position) {
            // Simple floor check
            const raycaster = new THREE.Raycaster(position, new THREE.Vector3(0, -1, 0), 0, 2);
            const intersects = raycaster.intersectObjects(platforms);
            return intersects.length > 0;
        }

        // ==========================================
        // UI & GAME LOOP
        // ==========================================
        
        function showTutorial(title, text) {
            document.getElementById('tutorial-title').innerText = title;
            document.getElementById('tutorial-content').innerText = text;
            document.getElementById('tutorial-overlay').style.display = 'block';
            controls.unlock();
            STATE.isPaused = true;
        }

        document.getElementById('tutorial-btn').addEventListener('click', () => {
            document.getElementById('tutorial-overlay').style.display = 'none';
            controls.lock();
            STATE.isPaused = false;
        });

        document.getElementById('start-btn').addEventListener('click', () => {
            document.getElementById('start-screen').style.display = 'none';
            createLevel(0);
            controls.lock();
        });

        controls.addEventListener('unlock', () => {
            if (!STATE.isPaused) {
                // document.getElementById('start-screen').style.display = 'flex';
            }
        });

        let prevTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            prevTime = time;

            if (controls.isLocked && !STATE.isPaused) {
                // Physics
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 30.0 * delta; // Gravity

                direction.z = Number(moveState.forward) - Number(moveState.backward);
                direction.x = Number(moveState.right) - Number(moveState.left);
                direction.normalize();

                if (moveState.forward || moveState.backward) velocity.z -= direction.z * 100.0 * delta;
                if (moveState.left || moveState.right) velocity.x -= direction.x * 100.0 * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                
                // Floor Collision
                if (camera.position.y < 2) {
                    // Check if over platform
                    // Simple check: just assume floor at y=0 for now unless we fall
                    // Raycast down
                    const rayOrigin = camera.position.clone();
                    rayOrigin.y -= 1; // Feet
                    const raycaster = new THREE.Raycaster(rayOrigin, new THREE.Vector3(0, -1, 0), 0, 2);
                    const intersects = raycaster.intersectObjects(platforms);
                    
                    if (intersects.length > 0) {
                        velocity.y = Math.max(0, velocity.y);
                        camera.position.y = intersects[0].point.y + 2; // Height
                        canJump = true;
                    }
                }
                
                camera.position.y += velocity.y * delta;
                
                if (camera.position.y < -10) {
                    // Respawn
                    camera.position.set(0, 2, 0);
                    velocity.set(0, 0, 0);
                }

                updateMovers(delta);
                updateMosh(delta);
                updateTrails(delta);
            }

            // Render
            // If moshing, we want to create the smear effect
            // The simplest way without complex shaders in this setup is to NOT clear the buffer
            // But Three.js clears by default.
            
            if (STATE.isMoshing) {
                renderer.autoClear = false;
                renderer.autoClearColor = false;
            } else {
                renderer.autoClear = true;
                renderer.autoClearColor = true;
            }
            
            renderer.render(scene, camera);
        }

        animate();

        // Window Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>