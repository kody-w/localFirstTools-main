<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PARALLAX - A Dimension-Shifting Puzzle Platformer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #fff;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #game-container {
            width: 100%;
            max-width: 1200px;
            height: 100vh;
            position: relative;
            background: #000;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #menu-screen, #level-select-screen, #pause-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .hidden {
            display: none !important;
        }

        h1 {
            font-size: 4rem;
            margin-bottom: 1rem;
            text-shadow: 0 0 20px rgba(255, 0, 0, 0.5),
                         0 0 40px rgba(0, 100, 255, 0.5),
                         0 0 60px rgba(0, 255, 100, 0.5);
            animation: titlePulse 3s ease-in-out infinite;
        }

        @keyframes titlePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .subtitle {
            font-size: 1.2rem;
            margin-bottom: 3rem;
            opacity: 0.7;
        }

        .menu-btn {
            padding: 15px 40px;
            font-size: 1.3rem;
            font-family: 'Courier New', monospace;
            background: linear-gradient(90deg, #ff0000, #0064ff, #00ff64);
            border: none;
            color: #fff;
            cursor: pointer;
            margin: 10px;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
        }

        .menu-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 40px rgba(255, 255, 255, 0.6);
        }

        .level-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 20px;
            margin: 20px;
        }

        .level-btn {
            padding: 30px;
            font-size: 1.5rem;
            font-family: 'Courier New', monospace;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #fff;
            color: #fff;
            cursor: pointer;
            transition: all 0.2s;
        }

        .level-btn:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .level-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .level-btn.completed {
            background: linear-gradient(135deg, #ff0000, #0064ff, #00ff64);
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 1.2rem;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
            z-index: 50;
        }

        .hud-item {
            margin-bottom: 10px;
        }

        .dimension-indicator {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .dim-badge {
            padding: 8px 16px;
            border: 2px solid #fff;
            transition: all 0.3s;
            opacity: 0.3;
        }

        .dim-badge.active {
            opacity: 1;
            box-shadow: 0 0 20px currentColor;
            transform: scale(1.2);
        }

        .dim-a {
            background: #ff0000;
            color: #fff;
        }

        .dim-b {
            background: #0064ff;
            color: #fff;
        }

        .dim-c {
            background: #00ff64;
            color: #000;
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: 0.9rem;
            opacity: 0.8;
            z-index: 50;
        }

        .victory-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border: 3px solid #fff;
            text-align: center;
            z-index: 200;
            box-shadow: 0 0 50px rgba(255, 255, 255, 0.5);
        }

        .stats {
            margin: 20px 0;
            font-size: 1.1rem;
        }

        .stats div {
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>

        <div id="hud">
            <div class="dimension-indicator">
                <div class="dim-badge dim-a" id="dim-a-badge">A</div>
                <div class="dim-badge dim-b" id="dim-b-badge">B</div>
                <div class="dim-badge dim-c" id="dim-c-badge">C</div>
            </div>
            <div class="hud-item">Level: <span id="level-num">1</span></div>
            <div class="hud-item">Crystals: <span id="crystal-count">0</span></div>
            <div class="hud-item">Time: <span id="timer">0:00</span></div>
            <div class="hud-item">Deaths: <span id="death-count">0</span></div>
        </div>

        <div id="instructions">
            WASD/ARROWS: Move | SPACE: Jump | 1/2/3: Switch Dimension | P: Pause | R: Restart Level
        </div>

        <div id="menu-screen">
            <h1>PARALLAX</h1>
            <div class="subtitle">Shift Between Realities</div>
            <button class="menu-btn" onclick="game.startGame()">START GAME</button>
            <button class="menu-btn" onclick="game.showLevelSelect()">LEVEL SELECT</button>
            <button class="menu-btn" onclick="game.showInstructions()">HOW TO PLAY</button>
        </div>

        <div id="level-select-screen" class="hidden">
            <h1>LEVEL SELECT</h1>
            <div class="level-grid" id="level-grid"></div>
            <button class="menu-btn" onclick="game.showMenu()">BACK</button>
        </div>

        <div id="pause-screen" class="hidden">
            <h1>PAUSED</h1>
            <button class="menu-btn" onclick="game.resume()">RESUME</button>
            <button class="menu-btn" onclick="game.restartLevel()">RESTART LEVEL</button>
            <button class="menu-btn" onclick="game.showMenu()">MAIN MENU</button>
        </div>
    </div>

    <script>
        // Audio System with Web Audio API
        class AudioSystem {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.ctx.createGain();
                this.masterGain.connect(this.ctx.destination);
                this.masterGain.gain.value = 0.3;
                this.oscillators = { a: null, b: null, c: null };
                this.currentDimension = 'a';
            }

            playTone(freq, duration = 0.1, type = 'sine') {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.frequency.value = freq;
                osc.type = type;

                gain.gain.value = 0.2;
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);

                osc.connect(gain);
                gain.connect(this.masterGain);

                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            }

            jump() {
                this.playTone(440, 0.1, 'square');
            }

            land() {
                this.playTone(220, 0.05, 'sine');
            }

            collect() {
                this.playTone(880, 0.2, 'sine');
                setTimeout(() => this.playTone(1100, 0.2, 'sine'), 50);
            }

            switchDimension() {
                this.playTone(660, 0.15, 'triangle');
            }

            death() {
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => this.playTone(440 - i * 80, 0.1, 'sawtooth'), i * 50);
                }
            }

            victory() {
                const notes = [523, 587, 659, 784];
                notes.forEach((note, i) => {
                    setTimeout(() => this.playTone(note, 0.3, 'sine'), i * 150);
                });
            }
        }

        // Particle System
        class Particle {
            constructor(x, y, color, vx = 0, vy = 0, life = 1) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.vx = vx;
                this.vy = vy;
                this.life = life;
                this.maxLife = life;
                this.size = 3;
            }

            update(dt) {
                this.x += this.vx * dt * 60;
                this.y += this.vy * dt * 60;
                this.vy += 0.5 * dt * 60;
                this.life -= dt;
            }

            draw(ctx) {
                const alpha = this.life / this.maxLife;
                ctx.fillStyle = this.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                ctx.fillRect(this.x - this.size / 2, this.y - this.size / 2, this.size, this.size);
            }
        }

        // Game Entity Base Class
        class Entity {
            constructor(x, y, w, h, dimensions = ['a', 'b', 'c']) {
                this.x = x;
                this.y = y;
                this.w = w;
                this.h = h;
                this.dimensions = dimensions;
            }

            isInDimension(dim) {
                return this.dimensions.includes(dim);
            }

            draw(ctx, stripY, stripHeight, dim, activeDim) {
                // Override in subclasses
            }
        }

        // Platform
        class Platform extends Entity {
            constructor(x, y, w, h, dimensions) {
                super(x, y, w, h, dimensions);
            }

            draw(ctx, stripY, stripHeight, dim, activeDim) {
                if (!this.isInDimension(dim)) return;

                const alpha = dim === activeDim ? 1 : 0.3;
                const colors = { a: '#ff4444', b: '#4488ff', c: '#44ff88' };

                ctx.globalAlpha = alpha;
                ctx.fillStyle = colors[dim];
                ctx.fillRect(this.x, stripY + this.y, this.w, this.h);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, stripY + this.y, this.w, this.h);
                ctx.globalAlpha = 1;
            }
        }

        // Crystal (collectible)
        class Crystal extends Entity {
            constructor(x, y, dimensions) {
                super(x, y, 20, 20, dimensions);
                this.collected = false;
                this.rotation = 0;
            }

            update(dt) {
                this.rotation += dt * 3;
            }

            draw(ctx, stripY, stripHeight, dim, activeDim) {
                if (!this.isInDimension(dim) || this.collected) return;

                const alpha = dim === activeDim ? 1 : 0.4;
                const colors = { a: '#ffff00', b: '#00ffff', c: '#ff00ff' };

                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.translate(this.x + this.w / 2, stripY + this.y + this.h / 2);
                ctx.rotate(this.rotation);

                ctx.fillStyle = colors[dim];
                ctx.beginPath();
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const radius = i % 2 === 0 ? 12 : 6;
                    const px = Math.cos(angle) * radius;
                    const py = Math.sin(angle) * radius;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.restore();
            }

            checkCollision(player) {
                if (this.collected) return false;
                return player.x < this.x + this.w &&
                       player.x + player.w > this.x &&
                       player.y < this.y + this.h &&
                       player.y + player.h > this.y;
            }
        }

        // Hazard
        class Hazard extends Entity {
            constructor(x, y, w, h, dimensions) {
                super(x, y, w, h, dimensions);
                this.animPhase = Math.random() * Math.PI * 2;
            }

            update(dt) {
                this.animPhase += dt * 5;
            }

            draw(ctx, stripY, stripHeight, dim, activeDim) {
                if (!this.isInDimension(dim)) return;

                const alpha = dim === activeDim ? 1 : 0.3;
                const pulse = 0.5 + Math.sin(this.animPhase) * 0.5;

                ctx.globalAlpha = alpha;
                ctx.fillStyle = `rgba(255, 0, 0, ${pulse})`;
                ctx.fillRect(this.x, stripY + this.y, this.w, this.h);
                ctx.globalAlpha = 1;
            }

            checkCollision(player, activeDim) {
                if (!this.isInDimension(activeDim)) return false;
                return player.x < this.x + this.w &&
                       player.x + player.w > this.x &&
                       player.y < this.y + this.h &&
                       player.y + player.h > this.y;
            }
        }

        // Switch (activates something in another dimension)
        class Switch extends Entity {
            constructor(x, y, dimensions, targetId) {
                super(x, y, 24, 24, dimensions);
                this.activated = false;
                this.targetId = targetId;
            }

            update(dt) {}

            draw(ctx, stripY, stripHeight, dim, activeDim) {
                if (!this.isInDimension(dim)) return;

                const alpha = dim === activeDim ? 1 : 0.3;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.activated ? '#00ff00' : '#888';
                ctx.fillRect(this.x, stripY + this.y, this.w, this.h);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, stripY + this.y, this.w, this.h);
                ctx.globalAlpha = 1;
            }

            checkCollision(player, activeDim) {
                if (!this.isInDimension(activeDim) || this.activated) return false;
                return player.x < this.x + this.w &&
                       player.x + player.w > this.x &&
                       player.y < this.y + this.h &&
                       player.y + player.h > this.y;
            }
        }

        // Movable Platform
        class MovingPlatform extends Platform {
            constructor(x, y, w, h, dimensions, path) {
                super(x, y, w, h, dimensions);
                this.startX = x;
                this.startY = y;
                this.path = path; // array of {x, y, duration}
                this.pathIndex = 0;
                this.pathProgress = 0;
            }

            update(dt) {
                if (this.path.length === 0) return;

                const current = this.path[this.pathIndex];
                this.pathProgress += dt / current.duration;

                if (this.pathProgress >= 1) {
                    this.pathProgress = 0;
                    this.pathIndex = (this.pathIndex + 1) % this.path.length;
                }

                const next = this.path[(this.pathIndex + 1) % this.path.length];
                const t = this.pathProgress;
                this.x = current.x + (next.x - current.x) * t;
                this.y = current.y + (next.y - current.y) * t;
            }
        }

        // Player
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.w = 20;
                this.h = 20;
                this.vx = 0;
                this.vy = 0;
                this.grounded = false;
                this.jumpPower = -12;
                this.moveSpeed = 5;
                this.activeDimension = 'a';
            }

            update(dt, keys, level) {
                // Horizontal movement
                if (keys['ArrowLeft'] || keys['a']) {
                    this.vx = -this.moveSpeed;
                } else if (keys['ArrowRight'] || keys['d']) {
                    this.vx = this.moveSpeed;
                } else {
                    this.vx = 0;
                }

                // Jump
                if ((keys[' '] || keys['ArrowUp'] || keys['w']) && this.grounded) {
                    this.vy = this.jumpPower;
                    this.grounded = false;
                    game.audio.jump();
                }

                // Gravity (varies by dimension)
                const gravityMultiplier = this.activeDimension === 'c' ? 0.6 : 1;
                this.vy += 0.5 * gravityMultiplier;

                // Max fall speed
                if (this.vy > 20) this.vy = 20;

                // Apply velocity
                this.x += this.vx;
                this.y += this.vy;

                // Collision detection with platforms
                this.grounded = false;
                level.platforms.forEach(platform => {
                    if (platform.isInDimension(this.activeDimension)) {
                        this.collideWithPlatform(platform);
                    }
                });

                // World bounds
                if (this.x < 0) this.x = 0;
                if (this.x + this.w > level.width) this.x = level.width - this.w;
                if (this.y > level.height) {
                    game.playerDeath();
                }
            }

            collideWithPlatform(platform) {
                // Simple AABB collision with platform
                if (this.x < platform.x + platform.w &&
                    this.x + this.w > platform.x &&
                    this.y + this.h > platform.y &&
                    this.y < platform.y + platform.h) {

                    // Determine collision side
                    const overlapX = Math.min(
                        this.x + this.w - platform.x,
                        platform.x + platform.w - this.x
                    );
                    const overlapY = Math.min(
                        this.y + this.h - platform.y,
                        platform.y + platform.h - this.y
                    );

                    if (overlapX < overlapY) {
                        // Side collision
                        if (this.x < platform.x) {
                            this.x = platform.x - this.w;
                        } else {
                            this.x = platform.x + platform.w;
                        }
                        this.vx = 0;
                    } else {
                        // Top/bottom collision
                        if (this.y < platform.y) {
                            this.y = platform.y - this.h;
                            this.vy = 0;
                            this.grounded = true;
                        } else {
                            this.y = platform.y + platform.h;
                            this.vy = 0;
                        }
                    }
                }
            }

            switchDimension(dim) {
                if (this.activeDimension !== dim) {
                    this.activeDimension = dim;
                    game.audio.switchDimension();
                    game.spawnParticles(this.x + this.w / 2, this.y + this.h / 2, dim);
                }
            }

            draw(ctx, stripY, stripHeight, dim) {
                const colors = { a: '#ff0000', b: '#0064ff', c: '#00ff64' };
                const alpha = dim === this.activeDimension ? 1 : 0.4;

                ctx.globalAlpha = alpha;
                ctx.fillStyle = colors[dim];
                ctx.fillRect(this.x, stripY + this.y, this.w, this.h);

                // Glow effect for active dimension
                if (dim === this.activeDimension) {
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = colors[dim];
                    ctx.fillRect(this.x, stripY + this.y, this.w, this.h);
                    ctx.shadowBlur = 0;
                }

                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, stripY + this.y, this.w, this.h);
                ctx.globalAlpha = 1;
            }
        }

        // Level Class
        class Level {
            constructor(config) {
                this.number = config.number;
                this.width = 1200;
                this.height = 600;
                this.playerStart = config.playerStart;
                this.platforms = config.platforms || [];
                this.crystals = config.crystals || [];
                this.hazards = config.hazards || [];
                this.switches = config.switches || [];
                this.movingPlatforms = config.movingPlatforms || [];
            }

            update(dt) {
                this.crystals.forEach(c => c.update(dt));
                this.hazards.forEach(h => h.update(dt));
                this.movingPlatforms.forEach(p => p.update(dt));
            }

            getAllPlatforms() {
                return [...this.platforms, ...this.movingPlatforms];
            }
        }

        // Level Definitions
        const LEVELS = [
            // Level 1: Introduction
            {
                number: 1,
                playerStart: { x: 50, y: 100 },
                platforms: [
                    new Platform(0, 580, 1200, 20, ['a', 'b', 'c']), // Ground
                    new Platform(200, 480, 150, 20, ['a']),
                    new Platform(400, 380, 150, 20, ['b']),
                    new Platform(600, 280, 150, 20, ['c']),
                    new Platform(900, 380, 200, 20, ['a', 'b', 'c'])
                ],
                crystals: [
                    new Crystal(950, 340, ['a', 'b', 'c'])
                ]
            },

            // Level 2: Dimension Gaps
            {
                number: 2,
                playerStart: { x: 50, y: 100 },
                platforms: [
                    new Platform(0, 580, 200, 20, ['a', 'b', 'c']),
                    new Platform(250, 500, 150, 20, ['a']),
                    new Platform(450, 420, 150, 20, ['b']),
                    new Platform(650, 340, 150, 20, ['c']),
                    new Platform(850, 420, 150, 20, ['b']),
                    new Platform(1000, 580, 200, 20, ['a', 'b', 'c'])
                ],
                crystals: [
                    new Crystal(1050, 540, ['a', 'b', 'c'])
                ],
                hazards: [
                    new Hazard(400, 560, 400, 20, ['a'])
                ]
            },

            // Level 3: First Puzzle
            {
                number: 3,
                playerStart: { x: 50, y: 100 },
                platforms: [
                    new Platform(0, 580, 250, 20, ['a', 'b', 'c']),
                    new Platform(300, 480, 100, 20, ['a']),
                    new Platform(300, 480, 100, 20, ['b']),
                    new Platform(450, 380, 100, 20, ['b']),
                    new Platform(450, 380, 100, 20, ['c']),
                    new Platform(600, 280, 100, 20, ['c']),
                    new Platform(750, 380, 100, 20, ['a']),
                    new Platform(900, 480, 300, 20, ['a', 'b', 'c'])
                ],
                crystals: [
                    new Crystal(950, 440, ['a', 'b', 'c'])
                ],
                hazards: [
                    new Hazard(450, 560, 50, 20, ['b']),
                    new Hazard(600, 560, 50, 20, ['c'])
                ]
            },

            // Level 4: Mid-Air Switch
            {
                number: 4,
                playerStart: { x: 50, y: 100 },
                platforms: [
                    new Platform(0, 580, 200, 20, ['a']),
                    new Platform(250, 400, 100, 20, ['a']),
                    new Platform(450, 300, 100, 20, ['b']),
                    new Platform(650, 400, 100, 20, ['c']),
                    new Platform(850, 500, 100, 20, ['b']),
                    new Platform(1000, 580, 200, 20, ['a', 'b', 'c'])
                ],
                crystals: [
                    new Crystal(1050, 540, ['a', 'b', 'c'])
                ],
                hazards: [
                    new Hazard(0, 560, 200, 20, ['b']),
                    new Hazard(1000, 560, 200, 20, ['c'])
                ]
            },

            // Level 5: The Gauntlet
            {
                number: 5,
                playerStart: { x: 50, y: 100 },
                platforms: [
                    new Platform(0, 580, 150, 20, ['a', 'b', 'c']),
                    new Platform(200, 480, 80, 20, ['a']),
                    new Platform(330, 380, 80, 20, ['b']),
                    new Platform(460, 280, 80, 20, ['c']),
                    new Platform(590, 380, 80, 20, ['a']),
                    new Platform(720, 480, 80, 20, ['b']),
                    new Platform(850, 380, 80, 20, ['c']),
                    new Platform(980, 480, 220, 20, ['a', 'b', 'c'])
                ],
                crystals: [
                    new Crystal(1050, 440, ['a', 'b', 'c'])
                ],
                hazards: [
                    new Hazard(150, 560, 850, 20, ['a']),
                    new Hazard(200, 460, 80, 20, ['b']),
                    new Hazard(590, 360, 80, 20, ['b'])
                ]
            },

            // Level 6: Vertical Challenge
            {
                number: 6,
                playerStart: { x: 50, y: 500 },
                platforms: [
                    new Platform(0, 580, 200, 20, ['a', 'b', 'c']),
                    new Platform(150, 480, 100, 20, ['a']),
                    new Platform(50, 380, 100, 20, ['b']),
                    new Platform(150, 280, 100, 20, ['c']),
                    new Platform(50, 180, 100, 20, ['a']),
                    new Platform(150, 80, 100, 20, ['b']),
                    new Platform(300, 80, 900, 20, ['a', 'b', 'c']),
                    new Platform(500, 180, 100, 20, ['c']),
                    new Platform(700, 280, 100, 20, ['b']),
                    new Platform(900, 380, 100, 20, ['a'])
                ],
                crystals: [
                    new Crystal(1050, 40, ['a', 'b', 'c'])
                ],
                hazards: [
                    new Hazard(300, 60, 200, 20, ['a']),
                    new Hazard(600, 60, 200, 20, ['b'])
                ]
            },

            // Level 7: Hazard Dance
            {
                number: 7,
                playerStart: { x: 50, y: 100 },
                platforms: [
                    new Platform(0, 580, 200, 20, ['a', 'b', 'c']),
                    new Platform(250, 480, 150, 20, ['a', 'b', 'c']),
                    new Platform(450, 480, 150, 20, ['a', 'b', 'c']),
                    new Platform(650, 480, 150, 20, ['a', 'b', 'c']),
                    new Platform(850, 480, 150, 20, ['a', 'b', 'c']),
                    new Platform(1000, 580, 200, 20, ['a', 'b', 'c'])
                ],
                crystals: [
                    new Crystal(1050, 540, ['a', 'b', 'c'])
                ],
                hazards: [
                    new Hazard(250, 460, 150, 20, ['a']),
                    new Hazard(450, 460, 150, 20, ['b']),
                    new Hazard(650, 460, 150, 20, ['c']),
                    new Hazard(850, 460, 150, 20, ['a']),
                    new Hazard(200, 560, 800, 20, ['b'])
                ]
            },

            // Level 8: The Maze
            {
                number: 8,
                playerStart: { x: 50, y: 500 },
                platforms: [
                    new Platform(0, 580, 100, 20, ['a', 'b', 'c']),
                    new Platform(150, 580, 50, 120, ['a']), // Wall
                    new Platform(250, 580, 100, 20, ['b', 'c']),
                    new Platform(400, 480, 50, 120, ['b']),
                    new Platform(500, 580, 100, 20, ['a', 'c']),
                    new Platform(650, 380, 50, 220, ['c']),
                    new Platform(750, 580, 100, 20, ['a', 'b']),
                    new Platform(900, 280, 50, 320, ['a']),
                    new Platform(1000, 580, 200, 20, ['a', 'b', 'c']),
                    new Platform(150, 480, 200, 20, ['b', 'c']),
                    new Platform(400, 380, 200, 20, ['a', 'c']),
                    new Platform(650, 280, 200, 20, ['a', 'b'])
                ],
                crystals: [
                    new Crystal(1050, 540, ['a', 'b', 'c'])
                ]
            },

            // Level 9: Precision Jumps
            {
                number: 9,
                playerStart: { x: 50, y: 100 },
                platforms: [
                    new Platform(0, 580, 120, 20, ['a', 'b', 'c']),
                    new Platform(180, 480, 60, 20, ['a']),
                    new Platform(300, 400, 60, 20, ['b']),
                    new Platform(420, 320, 60, 20, ['c']),
                    new Platform(540, 400, 60, 20, ['a']),
                    new Platform(660, 480, 60, 20, ['b']),
                    new Platform(780, 400, 60, 20, ['c']),
                    new Platform(900, 320, 60, 20, ['a']),
                    new Platform(1020, 400, 180, 20, ['a', 'b', 'c'])
                ],
                crystals: [
                    new Crystal(1070, 360, ['a', 'b', 'c'])
                ],
                hazards: [
                    new Hazard(120, 560, 880, 20, ['a']),
                    new Hazard(240, 560, 640, 20, ['b']),
                    new Hazard(360, 560, 400, 20, ['c'])
                ]
            },

            // Level 10: Moving Platforms Intro
            {
                number: 10,
                playerStart: { x: 50, y: 100 },
                platforms: [
                    new Platform(0, 580, 200, 20, ['a', 'b', 'c']),
                    new Platform(800, 580, 400, 20, ['a', 'b', 'c'])
                ],
                movingPlatforms: [
                    new MovingPlatform(250, 480, 120, 20, ['a'], [
                        { x: 250, y: 480, duration: 2 },
                        { x: 500, y: 480, duration: 2 }
                    ]),
                    new MovingPlatform(550, 380, 120, 20, ['b'], [
                        { x: 550, y: 380, duration: 2 },
                        { x: 550, y: 200, duration: 2 }
                    ])
                ],
                crystals: [
                    new Crystal(900, 540, ['a', 'b', 'c'])
                ]
            },

            // Level 11: Moving Maze
            {
                number: 11,
                playerStart: { x: 50, y: 500 },
                platforms: [
                    new Platform(0, 580, 150, 20, ['a', 'b', 'c']),
                    new Platform(1000, 580, 200, 20, ['a', 'b', 'c'])
                ],
                movingPlatforms: [
                    new MovingPlatform(200, 500, 100, 20, ['a'], [
                        { x: 200, y: 500, duration: 1.5 },
                        { x: 350, y: 500, duration: 1.5 }
                    ]),
                    new MovingPlatform(450, 400, 100, 20, ['b'], [
                        { x: 450, y: 400, duration: 2 },
                        { x: 450, y: 250, duration: 2 }
                    ]),
                    new MovingPlatform(600, 350, 100, 20, ['c'], [
                        { x: 600, y: 350, duration: 1.5 },
                        { x: 750, y: 350, duration: 1.5 }
                    ]),
                    new MovingPlatform(850, 450, 100, 20, ['a', 'b'], [
                        { x: 850, y: 450, duration: 2 },
                        { x: 850, y: 200, duration: 2 }
                    ])
                ],
                crystals: [
                    new Crystal(1050, 540, ['a', 'b', 'c'])
                ],
                hazards: [
                    new Hazard(150, 560, 850, 20, ['b'])
                ]
            },

            // Level 12: Dimension Layers
            {
                number: 12,
                playerStart: { x: 50, y: 100 },
                platforms: [
                    new Platform(0, 580, 1200, 20, ['a']),
                    new Platform(0, 580, 1200, 20, ['b']),
                    new Platform(0, 580, 1200, 20, ['c']),
                    new Platform(200, 480, 100, 80, ['a']),
                    new Platform(350, 380, 100, 80, ['a']),
                    new Platform(500, 280, 100, 80, ['a']),
                    new Platform(400, 480, 100, 80, ['b']),
                    new Platform(550, 380, 100, 80, ['b']),
                    new Platform(700, 280, 100, 80, ['b']),
                    new Platform(600, 480, 100, 80, ['c']),
                    new Platform(750, 380, 100, 80, ['c']),
                    new Platform(900, 280, 100, 80, ['c'])
                ],
                crystals: [
                    new Crystal(950, 240, ['c'])
                ],
                hazards: [
                    new Hazard(200, 460, 100, 20, ['b', 'c']),
                    new Hazard(350, 360, 100, 20, ['b', 'c']),
                    new Hazard(500, 260, 100, 20, ['b', 'c'])
                ]
            },

            // Level 13: The Conductor
            {
                number: 13,
                playerStart: { x: 50, y: 500 },
                platforms: [
                    new Platform(0, 580, 200, 20, ['a', 'b', 'c']),
                    new Platform(250, 480, 150, 20, ['a']),
                    new Platform(450, 380, 150, 20, ['b']),
                    new Platform(650, 280, 150, 20, ['c']),
                    new Platform(1000, 180, 200, 20, ['a', 'b', 'c'])
                ],
                movingPlatforms: [
                    new MovingPlatform(850, 380, 100, 20, ['a', 'b'], [
                        { x: 850, y: 380, duration: 1.5 },
                        { x: 850, y: 230, duration: 1.5 }
                    ])
                ],
                crystals: [
                    new Crystal(1050, 140, ['a', 'b', 'c'])
                ],
                hazards: [
                    new Hazard(250, 460, 150, 20, ['b', 'c']),
                    new Hazard(450, 360, 150, 20, ['a', 'c']),
                    new Hazard(650, 260, 150, 20, ['a', 'b']),
                    new Hazard(200, 560, 800, 20, ['a'])
                ]
            },

            // Level 14: Precision Master
            {
                number: 14,
                playerStart: { x: 50, y: 100 },
                platforms: [
                    new Platform(0, 580, 100, 20, ['a', 'b', 'c']),
                    new Platform(1100, 80, 100, 20, ['a', 'b', 'c'])
                ],
                movingPlatforms: [
                    new MovingPlatform(150, 500, 80, 20, ['a'], [
                        { x: 150, y: 500, duration: 1 },
                        { x: 250, y: 500, duration: 1 }
                    ]),
                    new MovingPlatform(300, 420, 80, 20, ['b'], [
                        { x: 300, y: 420, duration: 1.2 },
                        { x: 300, y: 300, duration: 1.2 }
                    ]),
                    new MovingPlatform(400, 350, 80, 20, ['c'], [
                        { x: 400, y: 350, duration: 1 },
                        { x: 520, y: 350, duration: 1 }
                    ]),
                    new MovingPlatform(600, 280, 80, 20, ['a'], [
                        { x: 600, y: 280, duration: 1.5 },
                        { x: 600, y: 150, duration: 1.5 }
                    ]),
                    new MovingPlatform(700, 220, 80, 20, ['b'], [
                        { x: 700, y: 220, duration: 1 },
                        { x: 850, y: 220, duration: 1 }
                    ]),
                    new MovingPlatform(950, 180, 80, 20, ['c'], [
                        { x: 950, y: 180, duration: 1.2 },
                        { x: 950, y: 120, duration: 1.2 }
                    ])
                ],
                crystals: [
                    new Crystal(1130, 40, ['a', 'b', 'c'])
                ],
                hazards: [
                    new Hazard(100, 560, 1000, 20, ['a', 'b'])
                ]
            },

            // Level 15: The Finale
            {
                number: 15,
                playerStart: { x: 50, y: 500 },
                platforms: [
                    new Platform(0, 580, 120, 20, ['a', 'b', 'c']),
                    new Platform(170, 480, 80, 20, ['a']),
                    new Platform(300, 400, 80, 20, ['b']),
                    new Platform(430, 320, 80, 20, ['c']),
                    new Platform(800, 180, 200, 20, ['a', 'b', 'c']),
                    new Platform(200, 250, 100, 20, ['a']),
                    new Platform(350, 200, 100, 20, ['b']),
                    new Platform(500, 150, 100, 20, ['c'])
                ],
                movingPlatforms: [
                    new MovingPlatform(560, 240, 90, 20, ['a', 'b'], [
                        { x: 560, y: 240, duration: 1.5 },
                        { x: 680, y: 240, duration: 1.5 }
                    ]),
                    new MovingPlatform(650, 320, 90, 20, ['b', 'c'], [
                        { x: 650, y: 320, duration: 1.2 },
                        { x: 650, y: 200, duration: 1.2 }
                    ])
                ],
                crystals: [
                    new Crystal(900, 140, ['a', 'b', 'c'])
                ],
                hazards: [
                    new Hazard(120, 560, 880, 20, ['a']),
                    new Hazard(170, 460, 80, 20, ['b', 'c']),
                    new Hazard(300, 380, 80, 20, ['a', 'c']),
                    new Hazard(430, 300, 80, 20, ['a', 'b']),
                    new Hazard(200, 230, 100, 20, ['b', 'c']),
                    new Hazard(350, 180, 100, 20, ['a', 'c']),
                    new Hazard(500, 130, 100, 20, ['a', 'b'])
                ]
            },

            // Bonus Level 16: Speed Run
            {
                number: 16,
                playerStart: { x: 50, y: 100 },
                platforms: [
                    new Platform(0, 580, 1200, 20, ['a', 'b', 'c']),
                    new Platform(150, 480, 60, 20, ['a']),
                    new Platform(250, 480, 60, 20, ['b']),
                    new Platform(350, 480, 60, 20, ['c']),
                    new Platform(450, 480, 60, 20, ['a']),
                    new Platform(550, 480, 60, 20, ['b']),
                    new Platform(650, 480, 60, 20, ['c']),
                    new Platform(750, 480, 60, 20, ['a']),
                    new Platform(850, 480, 60, 20, ['b']),
                    new Platform(950, 480, 60, 20, ['c']),
                    new Platform(1050, 380, 150, 20, ['a', 'b', 'c'])
                ],
                crystals: [
                    new Crystal(1100, 340, ['a', 'b', 'c'])
                ],
                hazards: [
                    new Hazard(150, 460, 60, 20, ['b', 'c']),
                    new Hazard(250, 460, 60, 20, ['a', 'c']),
                    new Hazard(350, 460, 60, 20, ['a', 'b']),
                    new Hazard(450, 460, 60, 20, ['b', 'c']),
                    new Hazard(550, 460, 60, 20, ['a', 'c']),
                    new Hazard(650, 460, 60, 20, ['a', 'b']),
                    new Hazard(750, 460, 60, 20, ['b', 'c']),
                    new Hazard(850, 460, 60, 20, ['a', 'c']),
                    new Hazard(950, 460, 60, 20, ['a', 'b'])
                ]
            }
        ];

        // Main Game Class
        class Game {
            constructor() {
                this.canvas = document.getElementById('game-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.audio = new AudioSystem();

                this.keys = {};
                this.player = null;
                this.currentLevel = null;
                this.currentLevelNumber = 1;
                this.particles = [];

                this.paused = false;
                this.gameStarted = false;

                this.stats = {
                    crystalsCollected: 0,
                    totalDeaths: 0,
                    levelTime: 0,
                    totalTime: 0
                };

                this.save = this.loadSave();

                this.setupCanvas();
                this.setupEventListeners();
                this.updateLevelSelect();
                this.gameLoop();
            }

            setupCanvas() {
                const resize = () => {
                    const container = document.getElementById('game-container');
                    const rect = container.getBoundingClientRect();
                    this.canvas.width = 1200;
                    this.canvas.height = 600;
                };
                resize();
                window.addEventListener('resize', resize);
            }

            setupEventListeners() {
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key] = true;

                    if (this.gameStarted && !this.paused) {
                        // Dimension switching
                        if (e.key === '1') this.player.switchDimension('a');
                        if (e.key === '2') this.player.switchDimension('b');
                        if (e.key === '3') this.player.switchDimension('c');

                        // Restart
                        if (e.key === 'r' || e.key === 'R') this.restartLevel();
                    }

                    // Pause
                    if (e.key === 'p' || e.key === 'P') {
                        if (this.gameStarted) {
                            this.paused ? this.resume() : this.pause();
                        }
                    }

                    // Prevent spacebar scrolling
                    if (e.key === ' ' && this.gameStarted) {
                        e.preventDefault();
                    }
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.key] = false;
                });
            }

            loadSave() {
                const saved = localStorage.getItem('parallax_save');
                if (saved) {
                    return JSON.parse(saved);
                }
                return {
                    levelsCompleted: [],
                    bestTimes: {},
                    totalDeaths: 0,
                    totalCrystals: 0
                };
            }

            saveSave() {
                localStorage.setItem('parallax_save', JSON.stringify(this.save));
            }

            startGame() {
                document.getElementById('menu-screen').classList.add('hidden');
                this.loadLevel(1);
                this.gameStarted = true;
            }

            loadLevel(levelNum) {
                if (levelNum < 1 || levelNum > LEVELS.length) return;

                this.currentLevelNumber = levelNum;
                const levelConfig = LEVELS[levelNum - 1];
                this.currentLevel = new Level(levelConfig);

                // Initialize platforms array to include moving platforms
                this.currentLevel.platforms = this.currentLevel.getAllPlatforms();

                this.player = new Player(
                    this.currentLevel.playerStart.x,
                    this.currentLevel.playerStart.y
                );

                this.stats.levelTime = 0;
                this.stats.levelDeaths = 0;
                this.paused = false;

                document.getElementById('level-num').textContent = levelNum;
                this.updateHUD();
            }

            restartLevel() {
                this.loadLevel(this.currentLevelNumber);
            }

            nextLevel() {
                if (this.currentLevelNumber < LEVELS.length) {
                    this.loadLevel(this.currentLevelNumber + 1);
                } else {
                    this.showVictory();
                }
            }

            pause() {
                this.paused = true;
                document.getElementById('pause-screen').classList.remove('hidden');
            }

            resume() {
                this.paused = false;
                document.getElementById('pause-screen').classList.add('hidden');
            }

            showMenu() {
                this.gameStarted = false;
                this.paused = false;
                document.getElementById('menu-screen').classList.remove('hidden');
                document.getElementById('pause-screen').classList.add('hidden');
                document.getElementById('level-select-screen').classList.add('hidden');
            }

            showLevelSelect() {
                document.getElementById('menu-screen').classList.add('hidden');
                document.getElementById('level-select-screen').classList.remove('hidden');
                this.updateLevelSelect();
            }

            updateLevelSelect() {
                const grid = document.getElementById('level-grid');
                grid.innerHTML = '';

                for (let i = 1; i <= LEVELS.length; i++) {
                    const btn = document.createElement('button');
                    btn.className = 'level-btn';
                    btn.textContent = i;

                    const unlocked = i === 1 || this.save.levelsCompleted.includes(i - 1);
                    const completed = this.save.levelsCompleted.includes(i);

                    if (completed) {
                        btn.classList.add('completed');
                    }

                    if (!unlocked) {
                        btn.disabled = true;
                    } else {
                        btn.onclick = () => {
                            document.getElementById('level-select-screen').classList.add('hidden');
                            this.loadLevel(i);
                            this.gameStarted = true;
                        };
                    }

                    grid.appendChild(btn);
                }
            }

            showInstructions() {
                alert(`PARALLAX - How to Play

You exist in 3 dimensions simultaneously!

CONTROLS:
- WASD or Arrow Keys: Move
- Space: Jump
- 1/2/3: Switch active dimension
- P: Pause
- R: Restart level

GOAL:
Collect the crystal in each level to proceed.

MECHANICS:
- You appear in all 3 dimension strips at once
- Only the ACTIVE dimension's physics affect you
- Platforms in inactive dimensions are ghosted
- Switch dimensions mid-air to reach new paths
- Avoid hazards in the active dimension

Each dimension has unique properties:
- Dimension A (Red): Normal world
- Dimension B (Blue): Mirror world with shifted platforms
- Dimension C (Green): Low gravity shadow world

Plan your route across all dimensions!`);
            }

            playerDeath() {
                this.stats.totalDeaths++;
                this.stats.levelDeaths++;
                this.save.totalDeaths++;
                this.audio.death();

                // Death particles
                for (let i = 0; i < 20; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 2 + Math.random() * 3;
                    this.particles.push(new Particle(
                        this.player.x + this.player.w / 2,
                        this.player.y + this.player.h / 2,
                        'rgb(255, 0, 0)',
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed - 2,
                        1
                    ));
                }

                setTimeout(() => this.restartLevel(), 1000);
            }

            collectCrystal(crystal) {
                crystal.collected = true;
                this.stats.crystalsCollected++;
                this.save.totalCrystals++;
                this.audio.collect();

                // Collect particles
                for (let i = 0; i < 30; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 1 + Math.random() * 4;
                    this.particles.push(new Particle(
                        crystal.x + crystal.w / 2,
                        crystal.y + crystal.h / 2,
                        'rgb(255, 255, 0)',
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed - 2,
                        1.5
                    ));
                }

                // Check if all crystals collected
                const allCollected = this.currentLevel.crystals.every(c => c.collected);
                if (allCollected) {
                    this.completeLevel();
                }
            }

            completeLevel() {
                this.audio.victory();

                // Save progress
                if (!this.save.levelsCompleted.includes(this.currentLevelNumber)) {
                    this.save.levelsCompleted.push(this.currentLevelNumber);
                }

                const time = this.stats.levelTime;
                if (!this.save.bestTimes[this.currentLevelNumber] ||
                    time < this.save.bestTimes[this.currentLevelNumber]) {
                    this.save.bestTimes[this.currentLevelNumber] = time;
                }

                this.saveSave();

                // Show victory screen
                setTimeout(() => {
                    const victoryDiv = document.createElement('div');
                    victoryDiv.className = 'victory-screen';
                    victoryDiv.innerHTML = `
                        <h2>LEVEL ${this.currentLevelNumber} COMPLETE!</h2>
                        <div class="stats">
                            <div>Time: ${this.formatTime(this.stats.levelTime)}</div>
                            <div>Deaths: ${this.stats.levelDeaths}</div>
                            <div>Best Time: ${this.formatTime(this.save.bestTimes[this.currentLevelNumber])}</div>
                        </div>
                        <button class="menu-btn" onclick="game.continueAfterVictory()">
                            ${this.currentLevelNumber < LEVELS.length ? 'NEXT LEVEL' : 'FINISH'}
                        </button>
                    `;
                    document.getElementById('game-container').appendChild(victoryDiv);
                }, 1000);
            }

            continueAfterVictory() {
                const victoryScreen = document.querySelector('.victory-screen');
                if (victoryScreen) victoryScreen.remove();

                if (this.currentLevelNumber < LEVELS.length) {
                    this.nextLevel();
                } else {
                    this.showFinalVictory();
                }
            }

            showFinalVictory() {
                const victoryDiv = document.createElement('div');
                victoryDiv.className = 'victory-screen';
                victoryDiv.innerHTML = `
                    <h1>CONGRATULATIONS!</h1>
                    <h2>YOU COMPLETED ALL LEVELS!</h2>
                    <div class="stats">
                        <div>Total Crystals: ${this.save.totalCrystals}</div>
                        <div>Total Deaths: ${this.save.totalDeaths}</div>
                        <div>Total Time: ${this.formatTime(this.stats.totalTime)}</div>
                    </div>
                    <button class="menu-btn" onclick="game.showMenu()">MAIN MENU</button>
                `;
                document.getElementById('game-container').appendChild(victoryDiv);
            }

            spawnParticles(x, y, dimension) {
                const colors = { a: 'rgb(255, 0, 0)', b: 'rgb(0, 100, 255)', c: 'rgb(0, 255, 100)' };
                for (let i = 0; i < 10; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 1 + Math.random() * 2;
                    this.particles.push(new Particle(
                        x, y,
                        colors[dimension],
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed - 1,
                        0.5
                    ));
                }
            }

            update(dt) {
                if (!this.gameStarted || this.paused || !this.currentLevel) return;

                // Update timer
                this.stats.levelTime += dt;
                this.stats.totalTime += dt;

                // Update player
                this.player.update(dt, this.keys, this.currentLevel);

                // Update level entities
                this.currentLevel.update(dt);

                // Update active dimension badge
                document.getElementById('dim-a-badge').classList.toggle('active', this.player.activeDimension === 'a');
                document.getElementById('dim-b-badge').classList.toggle('active', this.player.activeDimension === 'b');
                document.getElementById('dim-c-badge').classList.toggle('active', this.player.activeDimension === 'c');

                // Check crystal collection
                this.currentLevel.crystals.forEach(crystal => {
                    if (!crystal.collected && crystal.checkCollision(this.player)) {
                        this.collectCrystal(crystal);
                    }
                });

                // Check hazard collision
                this.currentLevel.hazards.forEach(hazard => {
                    if (hazard.checkCollision(this.player, this.player.activeDimension)) {
                        this.playerDeath();
                    }
                });

                // Update particles
                this.particles = this.particles.filter(p => {
                    p.update(dt);
                    return p.life > 0;
                });

                this.updateHUD();
            }

            updateHUD() {
                document.getElementById('crystal-count').textContent = this.stats.crystalsCollected;
                document.getElementById('timer').textContent = this.formatTime(this.stats.levelTime);
                document.getElementById('death-count').textContent = this.stats.totalDeaths;
            }

            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            }

            draw() {
                const ctx = this.ctx;
                const w = this.canvas.width;
                const h = this.canvas.height;

                // Clear
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, w, h);

                if (!this.currentLevel) return;

                const stripHeight = h / 3;
                const dimensions = ['a', 'b', 'c'];
                const bgColors = {
                    a: 'rgba(60, 0, 0, 0.3)',
                    b: 'rgba(0, 30, 60, 0.3)',
                    c: 'rgba(0, 60, 30, 0.3)'
                };

                // Draw each dimension strip
                dimensions.forEach((dim, index) => {
                    const stripY = index * stripHeight;

                    // Background
                    ctx.fillStyle = bgColors[dim];
                    ctx.fillRect(0, stripY, w, stripHeight);

                    // Dimension separator
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, stripY);
                    ctx.lineTo(w, stripY);
                    ctx.stroke();

                    // Draw platforms
                    this.currentLevel.platforms.forEach(platform => {
                        platform.draw(ctx, stripY, stripHeight, dim, this.player.activeDimension);
                    });

                    // Draw hazards
                    this.currentLevel.hazards.forEach(hazard => {
                        hazard.draw(ctx, stripY, stripHeight, dim, this.player.activeDimension);
                    });

                    // Draw crystals
                    this.currentLevel.crystals.forEach(crystal => {
                        crystal.draw(ctx, stripY, stripHeight, dim, this.player.activeDimension);
                    });

                    // Draw player
                    this.player.draw(ctx, stripY, stripHeight, dim);

                    // Draw particles (project into each dimension)
                    this.particles.forEach(p => {
                        p.draw(ctx);
                    });

                    // Dimension label
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.font = 'bold 40px Courier New';
                    ctx.fillText(dim.toUpperCase(), 20, stripY + 50);
                });
            }

            gameLoop() {
                const now = performance.now();
                const dt = Math.min((now - (this.lastTime || now)) / 1000, 0.1);
                this.lastTime = now;

                this.update(dt);
                this.draw();

                requestAnimationFrame(() => this.gameLoop());
            }
        }

        // Start the game
        const game = new Game();
    </script>
</body>
</html>