<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SimCopter 98</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', Courier, monospace; }
        #canvas { width: 100vw; height: 100vh; display: block; }
        
        /* Game HUD */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .hud-bottom {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
        }

        .panel {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff00;
            color: #00ff00;
            padding: 10px;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            border-radius: 0;
        }

        .minimap-container {
            width: 200px;
            height: 200px;
            background: #000;
            border: 2px solid #00ff00;
            position: relative;
            overflow: hidden;
            border-radius: 0;
        }

        #minimap {
            width: 100%;
            height: 100%;
        }

        #mission-text {
            font-size: 18px;
            color: #ffff00;
            text-align: center;
            margin-top: 10px;
            background: #000;
            padding: 5px;
            border: 1px solid #ffff00;
        }

        .bar-container {
            width: 200px;
            height: 15px;
            background: #333;
            border: 1px solid #00ff00;
            margin-bottom: 5px;
        }

        .bar {
            height: 100%;
            background: #00ff00;
            width: 100%;
        }

        .bar.danger { background: #ff0000; }
        .bar.warn { background: #ffff00; }

        #radio-subtitles {
            position: absolute;
            top: 15%;
            left: 50%;
            transform: translateX(-50%);
            color: #00ff00;
            font-size: 24px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border: 1px solid #00ff00;
            text-align: center;
            width: auto;
            min-width: 300px;
            display: none;
        }

        /* Start Screen */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
        }

        h1 {
            font-size: 72px;
            color: #00ff00;
            margin-bottom: 20px;
            font-family: 'Courier New', monospace;
            letter-spacing: -2px;
            text-transform: uppercase;
        }

        button {
            background: #000;
            color: #00ff00;
            border: 2px solid #00ff00;
            padding: 15px 40px;
            font-size: 24px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            transition: all 0.1s;
            margin: 10px;
        }

        button:hover {
            background: #00ff00;
            color: #000;
        }

        .controls-help {
            margin-top: 40px;
            color: #00ff00;
            text-align: left;
            line-height: 1.5;
            background: #000;
            padding: 20px;
            border: 1px solid #00ff00;
            font-family: 'Courier New', monospace;
        }
    </style>
</head>
<body>
    <div id="start-screen">
        <h1>SIM COPTER 98</h1>
        <button onclick="startGame()">Start Patrol</button>
        <div class="controls-help">
            <h3>FLIGHT CONTROLS</h3>
            W/S: Pitch Forward/Back<br>
            A/D: Yaw Left/Right<br>
            UP/DOWN: Altitude (Collective)<br>
            DOUBLE TAP UP: Toggle Altitude Hold<br>
            SPACE: Water Cannon / Spotlight<br>
            E: Exit/Enter Helicopter (Must be landed)<br>
            <br>
            <h3>GROUND CONTROLS</h3>
            WASD: Move<br>
            SPACE: Interact / Arrest / Rescue
        </div>
    </div>

    <div id="hud" style="display: none;">
        <div class="hud-top">
            <div class="panel">
                <div>FUNDS: $<span id="money">0</span></div>
                <div id="mission-text">PATROL MODE: WAITING FOR DISPATCH...</div>
            </div>
            <div class="minimap-container">
                <canvas id="minimap"></canvas>
            </div>
        </div>
        
        <div id="radio-subtitles">DISPATCH: 10-32, WE HAVE A SITUATION.</div>

        <div class="hud-bottom">
            <div class="panel">
                <div>FUEL</div>
                <div class="bar-container"><div id="fuel-bar" class="bar"></div></div>
                <div>DAMAGE</div>
                <div class="bar-container"><div id="damage-bar" class="bar"></div></div>
                <div>WATER</div>
                <div class="bar-container"><div id="water-bar" class="bar"></div></div>
            </div>
            <div class="panel">
                <div>ALT: <span id="alt-val">0</span> ft</div>
                <div>SPD: <span id="spd-val">0</span> kts</div>
                <div>PASSENGERS: <span id="passengers">0</span>/4</div>
            </div>
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game State
        let gameActive = false;
        let mode = 'heli'; // 'heli' or 'walk'
        let money = 0;
        let fuel = 100;
        let damage = 0;
        let water = 100;
        let passengers = 0;
        let altitudeHold = false;
        let lastUpPress = 0;
        
        // Three.js globals
        let scene, camera, renderer;
        let helicopter, rotor, tailRotor;
        let player; // Walking player
        let city = [];
        let terrain;
        
        // Entities
        let fires = [];
        let civilians = [];
        let criminals = [];
        let cars = [];
        let particles = [];
        
        // Controls
        const keys = {};
        
        // Physics
        let velocity = new THREE.Vector3();
        let rotationVelocity = 0;
        const GRAVITY = 9.8;
        
        // Audio context
        let audioCtx;
        
        function init() {
            // Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue
            scene.fog = new THREE.Fog(0x87CEEB, 50, 500); // Closer fog for that 90s draw distance

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.BasicShadowMap;

            // Lights
            const ambientLight = new THREE.AmbientLight(0x808080);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
            sunLight.position.set(100, 200, 50);
            sunLight.castShadow = true;
            sunLight.shadow.camera.top = 200;
            sunLight.shadow.camera.bottom = -200;
            sunLight.shadow.camera.left = -200;
            sunLight.shadow.camera.right = 200;
            sunLight.shadow.mapSize.width = 1024;
            sunLight.shadow.mapSize.height = 1024;
            scene.add(sunLight);

            // Terrain
            createTerrain();
            
            // Airport
            createAirport();
            
            // City
            generateCity();

            // Helicopter
            createHelicopter();
            
            // Player (Walking)
            createPlayer();

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', e => {
                keys[e.code] = true;
                
                // Double tap detection for Altitude Hold
                if (e.code === 'ArrowUp') {
                    const now = Date.now();
                    if (now - lastUpPress < 300) {
                        altitudeHold = !altitudeHold;
                        const msg = altitudeHold ? "ALTITUDE HOLD: ENGAGED" : "ALTITUDE HOLD: DISENGAGED";
                        showRadioMessage(msg);
                    }
                    lastUpPress = now;
                }
                
                // Break altitude hold if manual control used
                if ((e.code === 'ArrowUp' || e.code === 'ArrowDown') && altitudeHold && Date.now() - lastUpPress > 300) {
                    // altitudeHold = false; // Optional: auto-disengage on manual input
                }
            });
            document.addEventListener('keyup', e => keys[e.code] = false);

            // Start Loop
            animate();
        }

        function createTerrain() {
            const geometry = new THREE.PlaneGeometry(2000, 2000, 20, 20);
            const material = new THREE.MeshLambertMaterial({ color: 0x335533 }); // Darker green
            terrain = new THREE.Mesh(geometry, material);
            terrain.rotation.x = -Math.PI / 2;
            terrain.receiveShadow = true;
            scene.add(terrain);
            
            // Water
            const waterGeo = new THREE.PlaneGeometry(2000, 2000);
            const waterMat = new THREE.MeshBasicMaterial({ color: 0x000066, transparent: true, opacity: 0.8 });
            const water = new THREE.Mesh(waterGeo, waterMat);
            water.rotation.x = -Math.PI / 2;
            water.position.y = -2;
            scene.add(water);
        }
        
        function createAirport() {
            // Airport base
            const airportGeo = new THREE.PlaneGeometry(200, 200);
            const airportMat = new THREE.MeshLambertMaterial({ color: 0x333333 }); // Asphalt
            const airport = new THREE.Mesh(airportGeo, airportMat);
            airport.rotation.x = -Math.PI / 2;
            airport.position.set(-600, 0.2, -600);
            airport.receiveShadow = true;
            scene.add(airport);
            
            // Helipad H
            const hGeo = new THREE.PlaneGeometry(30, 30);
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#333';
            ctx.fillRect(0,0,128,128);
            ctx.strokeStyle = '#ffff00';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.arc(64,64, 50, 0, Math.PI*2);
            ctx.stroke();
            ctx.fillStyle = '#ffff00';
            ctx.font = '80px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('H', 64, 64);
            
            const hTex = new THREE.CanvasTexture(canvas);
            const hMat = new THREE.MeshBasicMaterial({ map: hTex, transparent: true });
            const helipad = new THREE.Mesh(hGeo, hMat);
            helipad.rotation.x = -Math.PI / 2;
            helipad.position.set(-600, 0.3, -600);
            scene.add(helipad);
            
            // Control Tower
            const towerGeo = new THREE.BoxGeometry(20, 60, 20);
            const towerMat = new THREE.MeshLambertMaterial({ color: 0x888888 });
            const tower = new THREE.Mesh(towerGeo, towerMat);
            tower.position.set(-650, 30, -650);
            tower.castShadow = true;
            scene.add(tower);
            
            // Tower Windows
            const winGeo = new THREE.BoxGeometry(22, 10, 22);
            const winMat = new THREE.MeshBasicMaterial({ color: 0x88ccff, transparent: true, opacity: 0.6 });
            const windows = new THREE.Mesh(winGeo, winMat);
            windows.position.set(-650, 55, -650);
            scene.add(windows);
            
            // Add to collision
            city.push({
                mesh: tower,
                bounds: new THREE.Box3().setFromObject(tower),
                height: 60
            });
        }

        function generateCity() {
            const blockSize = 80;
            const streetWidth = 20;
            const gridSize = 8;
            
            const offset = (gridSize * (blockSize + streetWidth)) / 2;

            // Ground plane for city (concrete)
            const cityGroundGeo = new THREE.PlaneGeometry(gridSize * (blockSize + streetWidth), gridSize * (blockSize + streetWidth));
            const cityGroundMat = new THREE.MeshLambertMaterial({ color: 0x555555 });
            const cityGround = new THREE.Mesh(cityGroundGeo, cityGroundMat);
            cityGround.rotation.x = -Math.PI / 2;
            cityGround.position.y = 0.1;
            cityGround.receiveShadow = true;
            scene.add(cityGround);

            for(let x = 0; x < gridSize; x++) {
                for(let z = 0; z < gridSize; z++) {
                    const wx = x * (blockSize + streetWidth) - offset;
                    const wz = z * (blockSize + streetWidth) - offset;
                    
                    // Randomly decide building type
                    const rand = Math.random();
                    let type = 'residential';
                    if(rand > 0.7) type = 'commercial';
                    if(rand > 0.9) type = 'industrial';
                    
                    // Create buildings
                    const subdivisions = 2;
                    const lotSize = blockSize / subdivisions;
                    
                    for(let i=0; i<subdivisions; i++) {
                        for(let j=0; j<subdivisions; j++) {
                            if(Math.random() > 0.2) {
                                const bx = wx + i*lotSize + lotSize/2;
                                const bz = wz + j*lotSize + lotSize/2;
                                createBuilding(bx, bz, lotSize - 4, type);
                            }
                        }
                    }
                }
            }
        }

        function createBuilding(x, z, size, type) {
            let color, minHeight, maxHeight;
            
            switch(type) {
                case 'residential':
                    color = 0x888888; // Grey concrete
                    minHeight = 10;
                    maxHeight = 25;
                    break;
                case 'commercial':
                    color = 0x666677; // Blue-grey
                    minHeight = 40;
                    maxHeight = 100;
                    break;
                case 'industrial':
                    color = 0x776655; // Brown-grey
                    minHeight = 15;
                    maxHeight = 40;
                    break;
            }

            const height = minHeight + Math.random() * (maxHeight - minHeight);
            const geometry = new THREE.BoxGeometry(size, height, size);
            
            // Simple texture
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#' + color.toString(16).padStart(6, '0');
            ctx.fillRect(0,0,64,64);
            
            // Windows
            ctx.fillStyle = (Math.random() > 0.5) ? '#111' : '#223'; // Dark windows
            if(Math.random() > 0.5) ctx.fillStyle = '#ffffaa'; // Lit windows
            
            const rows = Math.floor(height / 4);
            const cols = 4;
            const w = 64/cols;
            const h = 64/rows;
            
            for(let i=0; i<cols; i++) {
                for(let j=0; j<rows; j++) {
                    if(Math.random() > 0.3) {
                        ctx.fillRect(i*w + 2, j*h + 2, w-4, h-4);
                    }
                }
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            const material = new THREE.MeshLambertMaterial({ map: texture });
            
            const building = new THREE.Mesh(geometry, material);
            building.position.set(x, height/2, z);
            building.castShadow = true;
            building.receiveShadow = true;
            scene.add(building);
            
            // Add to collision list
            city.push({ 
                mesh: building, 
                bounds: new THREE.Box3().setFromObject(building),
                height: height
            });
        }

        function createHelicopter() {
            helicopter = new THREE.Group();
            
            // Body
            const bodyGeo = new THREE.BoxGeometry(4, 4, 10);
            const bodyMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            helicopter.add(body);
            
            // Cockpit
            const cockpitGeo = new THREE.BoxGeometry(3.8, 2, 3);
            const cockpitMat = new THREE.MeshPhongMaterial({ color: 0x333333 });
            const cockpit = new THREE.Mesh(cockpitGeo, cockpitMat);
            cockpit.position.set(0, 0.5, -4); // Flipped to -Z
            helicopter.add(cockpit);
            
            // Tail
            const tailGeo = new THREE.BoxGeometry(1, 1, 10);
            const tail = new THREE.Mesh(tailGeo, bodyMat);
            tail.position.set(0, 0, 8); // Flipped to +Z
            helicopter.add(tail);
            
            // Main Rotor
            rotor = new THREE.Group();
            const blade1 = new THREE.Mesh(new THREE.BoxGeometry(20, 0.2, 1), new THREE.MeshBasicMaterial({ color: 0x111111 }));
            const blade2 = new THREE.Mesh(new THREE.BoxGeometry(1, 0.2, 20), new THREE.MeshBasicMaterial({ color: 0x111111 }));
            rotor.add(blade1);
            rotor.add(blade2);
            rotor.position.y = 2.5;
            helicopter.add(rotor);
            
            // Tail Rotor
            tailRotor = new THREE.Mesh(new THREE.BoxGeometry(4, 0.2, 0.5), new THREE.MeshBasicMaterial({ color: 0x111111 }));
            tailRotor.position.set(0.6, 0, 12.5); // Flipped to +Z
            tailRotor.rotation.x = Math.PI / 2;
            helicopter.add(tailRotor);
            
            // Skids
            const skidGeo = new THREE.BoxGeometry(0.5, 0.5, 8);
            const skidMat = new THREE.MeshPhongMaterial({ color: 0x333333 });
            const leftSkid = new THREE.Mesh(skidGeo, skidMat);
            leftSkid.position.set(2, -2.5, 0);
            const rightSkid = new THREE.Mesh(skidGeo, skidMat);
            rightSkid.position.set(-2, -2.5, 0);
            helicopter.add(leftSkid);
            helicopter.add(rightSkid);
            
            // Legs
            const legGeo = new THREE.BoxGeometry(0.2, 2, 0.2);
            const l1 = new THREE.Mesh(legGeo, skidMat); l1.position.set(2, -1.5, 2);
            const l2 = new THREE.Mesh(legGeo, skidMat); l2.position.set(2, -1.5, -2);
            const r1 = new THREE.Mesh(legGeo, skidMat); r1.position.set(-2, -1.5, 2);
            const r2 = new THREE.Mesh(legGeo, skidMat); r2.position.set(-2, -1.5, -2);
            helicopter.add(l1, l2, r1, r2);

            helicopter.position.set(-600, 0.5, -600); // Start at airport
            helicopter.castShadow = true;
            scene.add(helicopter);
        }

        function createPlayer() {
            const geo = new THREE.CylinderGeometry(0.5, 0.5, 1.8, 8);
            const mat = new THREE.MeshPhongMaterial({ color: 0x0000ff });
            player = new THREE.Mesh(geo, mat);
            player.position.set(-600, 0.5, -600); // Start at airport
            player.visible = false;
            scene.add(player);
        }

        // --- Mission System ---
        const MISSION_TYPES = ['FIRE', 'MEDEVAC', 'CHASE', 'RIOT'];
        let currentMission = null;
        let missionTimer = 0;

        function startMission() {
            if(currentMission) return;
            
            const type = MISSION_TYPES[Math.floor(Math.random() * MISSION_TYPES.length)];
            
            // Find a random spot in the city
            const x = (Math.random() - 0.5) * 800;
            const z = (Math.random() - 0.5) * 800;
            
            currentMission = {
                type: type,
                x: x,
                z: z,
                active: true
            };
            
            let msg = "";
            
            if(type === 'FIRE') {
                msg = "10-45: FIRE REPORTED. EXTINGUISH IMMEDIATELY.";
                createFire(x, z);
            } else if(type === 'MEDEVAC') {
                msg = "10-52: INJURED CIVILIAN REQUIRING TRANSPORT.";
                createCivilian(x, z, 'injured');
            } else if(type === 'CHASE') {
                msg = "10-80: SPEEDING VEHICLE. INTERCEPT.";
                createCar(x, z);
            } else if(type === 'RIOT') {
                msg = "10-16: CROWD CONTROL REQUIRED. DISPERSE.";
                createRiot(x, z);
            }
            
            showRadioMessage(msg);
            document.getElementById('mission-text').innerText = "MISSION: " + type;
        }

        function createFire(x, z) {
            const fireGroup = new THREE.Group();
            fireGroup.position.set(x, 0, z);
            
            // Particle system for fire
            const particleCount = 50;
            const geo = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            
            for(let i=0; i<particleCount*3; i++) {
                positions[i] = (Math.random() - 0.5) * 5;
            }
            
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const mat = new THREE.PointsMaterial({ color: 0xff4400, size: 4, transparent: true, opacity: 0.8 });
            const particles = new THREE.Points(geo, mat);
            fireGroup.add(particles);
            
            // Light
            const light = new THREE.PointLight(0xff4400, 1, 50);
            light.position.y = 5;
            fireGroup.add(light);
            
            scene.add(fireGroup);
            fires.push({ group: fireGroup, health: 100, particles: particles });
        }

        function createCivilian(x, z, type) {
            const geo = new THREE.CylinderGeometry(0.3, 0.3, 1.7, 8);
            const color = type === 'injured' ? 0xff0000 : 0x00ff00;
            const mat = new THREE.MeshPhongMaterial({ color: color });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, 0.85, z);
            scene.add(mesh);
            civilians.push({ mesh: mesh, type: type, rescued: false });
        }

        function createCar(x, z) {
            const geo = new THREE.BoxGeometry(2, 1, 4);
            const mat = new THREE.MeshPhongMaterial({ color: 0xff00ff }); // Hot pink speeder
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, 0.5, z);
            scene.add(mesh);
            
            // Random direction
            const dir = new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize();
            
            cars.push({ mesh: mesh, dir: dir, speed: 0.8, caught: false });
        }

        function createRiot(x, z) {
            for(let i=0; i<10; i++) {
                const ox = (Math.random() - 0.5) * 10;
                const oz = (Math.random() - 0.5) * 10;
                createCivilian(x + ox, z + oz, 'rioter');
            }
        }

        function showRadioMessage(text) {
            const el = document.getElementById('radio-subtitles');
            el.innerText = text;
            el.style.display = 'block';
            
            // Play radio static sound
            playTone(100, 'sawtooth', 0.1);
            setTimeout(() => playTone(80, 'sawtooth', 0.1), 100);
            
            setTimeout(() => {
                el.style.display = 'none';
            }, 5000);
        }

        // --- Audio ---
        function playTone(freq, type, duration) {
            if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        }

        // --- Game Loop ---
        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('hud').style.display = 'flex';
            gameActive = true;
            
            // Start engine sound loop?
            // For now just simple tones on actions
            
            // Start mission loop
            setInterval(() => {
                if(!currentMission) startMission();
            }, 5000);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function getGroundHeight(x, z) {
            // Check buildings
            for(let b of city) {
                if(x >= b.bounds.min.x && x <= b.bounds.max.x &&
                   z >= b.bounds.min.z && z <= b.bounds.max.z) {
                    return b.height;
                }
            }
            return 0; // Ground level
        }

        function updatePhysics() {
            if(!gameActive) return;

            if(mode === 'heli') {
                // Helicopter Physics
                
                // Input
                if(keys['KeyW']) velocity.z -= 0.02; // Pitch forward
                if(keys['KeyS']) velocity.z += 0.02; // Pitch back
                if(keys['KeyA']) rotationVelocity += 0.001; // Yaw left
                if(keys['KeyD']) rotationVelocity -= 0.001; // Yaw right
                
                if(keys['ArrowUp']) velocity.y += 0.03; // Collective Up
                if(keys['ArrowDown']) velocity.y -= 0.03; // Collective Down
                
                // Damping
                velocity.x *= 0.98;
                velocity.z *= 0.98;
                velocity.y *= 0.98;
                rotationVelocity *= 0.95;
                
                // Gravity
                if (!altitudeHold) {
                    velocity.y -= 0.01; 
                } else {
                    // In altitude hold, damp vertical velocity aggressively to hover
                    velocity.y *= 0.8;
                    // If user presses up/down, they override hold temporarily (or we could disable hold)
                    if(keys['ArrowUp'] || keys['ArrowDown']) {
                        // Actually, let's just let the input add to velocity, but gravity is off
                        // This makes it "floaty" but controllable
                    }
                }

                // Apply Rotation
                helicopter.rotation.y += rotationVelocity;
                
                const forward = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), helicopter.rotation.y);
                
                // Move based on tilt
                const moveVec = forward.clone().multiplyScalar(-velocity.z * 10);
                
                helicopter.position.add(moveVec);
                helicopter.position.y += velocity.y;
                
                // Ground Collision
                const groundH = getGroundHeight(helicopter.position.x, helicopter.position.z);
                if(helicopter.position.y < groundH) {
                    helicopter.position.y = groundH;
                    velocity.y = Math.max(0, velocity.y);
                    // Friction
                    velocity.z *= 0.9;
                    rotationVelocity *= 0.9;
                    
                    // Disable altitude hold on landing
                    if (altitudeHold) {
                        altitudeHold = false;
                        showRadioMessage("ALTITUDE HOLD: DISENGAGED (LANDED)");
                    }
                }
                
                // Tilt visual
                helicopter.rotation.x = velocity.z * 2;
                helicopter.rotation.z = -rotationVelocity * 10;

                // Rotor spin
                rotor.rotation.y += 0.5;
                tailRotor.rotation.x += 0.5;

                // Camera Follow
                const camOffset = new THREE.Vector3(0, 5, 15).applyAxisAngle(new THREE.Vector3(0, 1, 0), helicopter.rotation.y);
                camera.position.lerp(helicopter.position.clone().add(camOffset), 0.1);
                camera.lookAt(helicopter.position);
                
                // Water Cannon
                if(keys['Space'] && water > 0) {
                    water -= 0.1;
                    spawnWaterParticle(helicopter.position.clone().add(new THREE.Vector3(0, -1, 0)));
                }
                
                // Exit Heli
                if(keys['KeyE'] && helicopter.position.y < groundH + 1 && Math.abs(velocity.z) < 0.1) {
                    mode = 'walk';
                    // Place player next to heli
                    const exitOffset = new THREE.Vector3(3, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), helicopter.rotation.y);
                    player.position.copy(helicopter.position).add(exitOffset);
                    player.position.y = getGroundHeight(player.position.x, player.position.z);
                    player.visible = true;
                    showRadioMessage("ON FOOT.");
                    keys['KeyE'] = false;
                }

            } else {
                // Walking Physics
                const speed = 0.3;
                const oldPos = player.position.clone();
                
                if(keys['KeyW']) {
                    player.position.z -= Math.cos(player.rotation.y) * speed;
                    player.position.x -= Math.sin(player.rotation.y) * speed;
                }
                if(keys['KeyS']) {
                    player.position.z += Math.cos(player.rotation.y) * speed;
                    player.position.x += Math.sin(player.rotation.y) * speed;
                }
                if(keys['KeyA']) player.rotation.y += 0.05;
                if(keys['KeyD']) player.rotation.y -= 0.05;
                
                // Ground clamping
                const groundH = getGroundHeight(player.position.x, player.position.z);
                
                // Simple wall collision: if height difference is too big, revert move
                if(Math.abs(groundH - player.position.y) > 2) {
                    player.position.copy(oldPos);
                } else {
                    player.position.y = groundH;
                }
                
                // Camera First Person
                camera.position.copy(player.position).add(new THREE.Vector3(0, 1.6, 0));
                const lookTarget = new THREE.Vector3(
                    player.position.x - Math.sin(player.rotation.y) * 10,
                    player.position.y + 1.6,
                    player.position.z - Math.cos(player.rotation.y) * 10
                );
                camera.lookAt(lookTarget);
                
                // Enter Heli
                if(keys['KeyE']) {
                    if(player.position.distanceTo(helicopter.position) < 5) {
                        mode = 'heli';
                        player.visible = false;
                        showRadioMessage("BACK IN THE CHOPPER.");
                        keys['KeyE'] = false;
                    }
                }
                
                // Interact
                if(keys['Space']) {
                    checkInteractions();
                }
            }
            
            // Update Entities
            updateFires();
            updateCivilians();
            updateCars();
            updateParticles();
            
            // Update HUD
            updateHUD();
        }

        function spawnWaterParticle(pos) {
            const p = {
                pos: pos,
                vel: new THREE.Vector3(0, -1, 0).add(new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5)),
                life: 60
            };
            particles.push(p);
            
            // Visual
            const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            const mat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(pos);
            scene.add(mesh);
            p.mesh = mesh;
        }

        function updateParticles() {
            for(let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.life--;
                p.pos.add(p.vel);
                p.mesh.position.copy(p.pos);
                
                // Check collision with fires
                if(p.pos.y < 1) {
                    fires.forEach(fire => {
                        if(p.pos.distanceTo(fire.group.position) < 5) {
                            fire.health -= 1;
                        }
                    });
                }
                
                if(p.life <= 0 || p.pos.y < 0) {
                    scene.remove(p.mesh);
                    particles.splice(i, 1);
                }
            }
        }

        function updateFires() {
            for(let i = fires.length - 1; i >= 0; i--) {
                const fire = fires[i];
                // Animate
                fire.particles.rotation.y += 0.1;
                
                if(fire.health <= 0) {
                    scene.remove(fire.group);
                    fires.splice(i, 1);
                    money += 500;
                    showRadioMessage("FIRE EXTINGUISHED. GOOD JOB.");
                    currentMission = null;
                }
            }
        }

        function updateCivilians() {
            // Rioters move randomly
            civilians.forEach(civ => {
                if(civ.type === 'rioter') {
                    civ.mesh.position.x += (Math.random() - 0.5) * 0.2;
                    civ.mesh.position.z += (Math.random() - 0.5) * 0.2;
                }
            });
        }

        function updateCars() {
            cars.forEach(car => {
                if(!car.caught) {
                    car.mesh.position.add(car.dir.clone().multiplyScalar(car.speed));
                    
                    // Wrap around world
                    if(Math.abs(car.mesh.position.x) > 1000) car.mesh.position.x *= -1;
                    if(Math.abs(car.mesh.position.z) > 1000) car.mesh.position.z *= -1;
                    
                    // Check if heli is close and spotlight is on (Space)
                    if(mode === 'heli' && keys['Space']) {
                        if(helicopter.position.distanceTo(car.mesh.position) < 20) {
                            car.speed = 0;
                            car.caught = true;
                            money += 200;
                            showRadioMessage("SUSPECT VEHICLE STOPPED.");
                            currentMission = null;
                        }
                    }
                }
            });
        }

        function checkInteractions() {
            // Rescue injured
            for(let i = civilians.length - 1; i >= 0; i--) {
                const civ = civilians[i];
                if(player.position.distanceTo(civ.mesh.position) < 3) {
                    if(civ.type === 'injured' && passengers < 4) {
                        scene.remove(civ.mesh);
                        civilians.splice(i, 1);
                        passengers++;
                        showRadioMessage("CIVILIAN SECURED.");
                        if(civilians.length === 0) currentMission = null;
                    } else if (civ.type === 'rioter') {
                        scene.remove(civ.mesh);
                        civilians.splice(i, 1);
                        money += 50;
                        showRadioMessage("RIOTER ARRESTED.");
                        if(civilians.length === 0) {
                            showRadioMessage("CROWD DISPERSED.");
                            currentMission = null;
                        }
                    }
                }
            }
        }

        function updateHUD() {
            document.getElementById('money').innerText = money;
            document.getElementById('fuel-bar').style.width = fuel + '%';
            document.getElementById('water-bar').style.width = water + '%';
            document.getElementById('passengers').innerText = passengers;
            document.getElementById('alt-val').innerText = Math.round(helicopter.position.y * 10);
            
            // Speed calculation
            const speed = Math.sqrt(velocity.x*velocity.x + velocity.z*velocity.z) * 100;
            document.getElementById('spd-val').innerText = Math.round(speed);
            
            // Minimap
            drawMinimap();
        }

        function drawMinimap() {
            const c = document.getElementById('minimap');
            const ctx = c.getContext('2d');
            c.width = 200;
            c.height = 200;
            
            ctx.fillStyle = '#000';
            ctx.fillRect(0,0,200,200);
            
            // Scale
            const scale = 0.1;
            const cx = 100;
            const cy = 100;
            
            // Draw Player/Heli
            const px = mode === 'heli' ? helicopter.position.x : player.position.x;
            const pz = mode === 'heli' ? helicopter.position.z : player.position.z;
            
            // Draw Mission Target
            if(currentMission) {
                const tx = (currentMission.x - px) * scale + cx;
                const ty = (currentMission.z - pz) * scale + cy;
                ctx.fillStyle = '#f00';
                ctx.beginPath();
                ctx.arc(tx, ty, 5, 0, Math.PI*2);
                ctx.fill();
                
                // Pulse
                if(Date.now() % 500 < 250) {
                    ctx.strokeStyle = '#f00';
                    ctx.beginPath();
                    ctx.arc(tx, ty, 10, 0, Math.PI*2);
                    ctx.stroke();
                }
            }
            
            // Draw Self
            ctx.fillStyle = '#0f0';
            ctx.beginPath();
            ctx.moveTo(cx, cy-5);
            ctx.lineTo(cx+4, cy+4);
            ctx.lineTo(cx-4, cy+4);
            ctx.fill();
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>