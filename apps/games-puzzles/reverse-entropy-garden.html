<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reverse Entropy Garden</title>
    <meta name="description" content="Plant seeds of chaos and watch them grow backwards into perfect order as entropy runs in reverse">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0a0a; overflow: hidden; font-family: 'Courier New', monospace; color: #a0ffa0; }
        #canvas { position: fixed; top: 0; left: 0; }
        #controls {
            position: fixed; top: 20px; left: 20px; background: rgba(10,30,10,0.9);
            padding: 20px; border-radius: 10px; border: 1px solid rgba(100,200,100,0.3); z-index: 100;
        }
        h3 { margin-bottom: 15px; color: #c0ffc0; }
        button {
            display: block; width: 100%; padding: 10px; margin: 8px 0;
            background: rgba(50,100,50,0.4); border: 1px solid rgba(100,200,100,0.4);
            color: #a0ffa0; cursor: pointer; border-radius: 8px; text-align: left;
        }
        button:hover { background: rgba(80,150,80,0.5); }
        #stats {
            position: fixed; top: 20px; right: 20px; background: rgba(10,30,10,0.9);
            padding: 20px; border-radius: 10px; border: 1px solid rgba(100,200,100,0.3);
        }
        .stat { margin: 8px 0; text-align: right; }
        .stat-value { font-size: 24px; color: #c0ffc0; }
        .stat-label { font-size: 10px; opacity: 0.6; }
        #info { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); font-size: 12px; opacity: 0.5; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="controls">
        <h3>Plant Chaos Seeds</h3>
        <button id="explosion-btn">Explosion</button>
        <button id="shatter-btn">Shattered Glass</button>
        <button id="spill-btn">Spilled Paint</button>
        <button id="scatter-btn">Scattered Petals</button>
        <button id="clear-btn">Clear Garden</button>
    </div>
    <div id="stats">
        <div class="stat"><div class="stat-value" id="entropy">100%</div><div class="stat-label">Entropy Level</div></div>
        <div class="stat"><div class="stat-value" id="order">0%</div><div class="stat-label">Order Restored</div></div>
    </div>
    <div id="info">Click to plant chaos | Watch it reassemble into perfect order</div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let W, H;
        function resize() { W = canvas.width = innerWidth; H = canvas.height = innerHeight; }
        resize(); window.onresize = resize;

        let objects = [];
        let selectedType = 'explosion';
        let totalEntropy = 0;
        let maxEntropy = 0;

        class ReversibleObject {
            constructor(x, y, type) {
                this.originX = x; this.originY = y;
                this.type = type;
                this.fragments = [];
                this.createFragments();
                this.entropy = 1;
            }
            createFragments() {
                const count = 20 + Math.random() * 30;
                for (let i = 0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 100 + Math.random() * 200;
                    const targetX = this.originX + Math.cos(angle) * dist;
                    const targetY = this.originY + Math.sin(angle) * dist;
                    this.fragments.push({
                        x: targetX, y: targetY,
                        originX: this.originX + (Math.random() - 0.5) * 50,
                        originY: this.originY + (Math.random() - 0.5) * 50,
                        rotation: Math.random() * Math.PI * 4,
                        targetRotation: 0,
                        size: 5 + Math.random() * 15,
                        color: this.getColor(i),
                        progress: 0,
                        delay: Math.random() * 100
                    });
                }
            }
            getColor(i) {
                if (this.type === 'explosion') {
                    const colors = ['#ff6600', '#ff3300', '#ffcc00', '#ff9900', '#ff0000'];
                    return colors[i % colors.length];
                } else if (this.type === 'shatter') {
                    return 'rgba(200, 220, 255, 0.7)';
                } else if (this.type === 'spill') {
                    const colors = ['#ff0066', '#0066ff', '#00ff66', '#ffff00', '#ff00ff'];
                    return colors[Math.floor(Math.random() * colors.length)];
                } else {
                    const colors = ['#ffaaaa', '#ffcccc', '#ff8888', '#ffdddd', '#ff6666'];
                    return colors[i % colors.length];
                }
            }
            update(time) {
                let totalProgress = 0;
                this.fragments.forEach(f => {
                    if (time > f.delay) {
                        f.progress = Math.min(1, f.progress + 0.005);
                        const ease = 1 - Math.pow(1 - f.progress, 3);
                        f.x = f.x + (f.originX - f.x) * ease * 0.02;
                        f.y = f.y + (f.originY - f.y) * ease * 0.02;
                        f.rotation += (f.targetRotation - f.rotation) * 0.02;
                    }
                    totalProgress += f.progress;
                });
                this.entropy = 1 - (totalProgress / this.fragments.length);
                return this.entropy > 0.01;
            }
            draw() {
                this.fragments.forEach(f => {
                    ctx.save();
                    ctx.translate(f.x, f.y);
                    ctx.rotate(f.rotation);
                    ctx.fillStyle = f.color;
                    if (this.type === 'shatter') {
                        ctx.beginPath();
                        ctx.moveTo(0, -f.size);
                        ctx.lineTo(f.size * 0.8, f.size * 0.5);
                        ctx.lineTo(-f.size * 0.8, f.size * 0.5);
                        ctx.closePath();
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                        ctx.stroke();
                    } else if (this.type === 'scatter') {
                        ctx.beginPath();
                        for (let i = 0; i < 5; i++) {
                            const angle = (i / 5) * Math.PI * 2;
                            const r = i % 2 === 0 ? f.size : f.size * 0.5;
                            if (i === 0) ctx.moveTo(Math.cos(angle) * r, Math.sin(angle) * r);
                            else ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
                        }
                        ctx.closePath();
                        ctx.fill();
                    } else {
                        ctx.fillRect(-f.size/2, -f.size/2, f.size, f.size);
                    }
                    ctx.restore();
                });
                if (this.entropy < 0.3) {
                    ctx.beginPath();
                    ctx.arc(this.originX, this.originY, 30, 0, Math.PI * 2);
                    ctx.fillStyle = "rgba(100, 255, 100, " + (0.3 - this.entropy) + ")";
                    ctx.fill();
                }
            }
        }

        function addChaos(x, y, type) {
            objects.push(new ReversibleObject(x, y, type));
            maxEntropy = objects.length;
        }

        let time = 0;
        function animate() {
            time++;
            ctx.fillStyle = 'rgba(10, 10, 10, 0.05)';
            ctx.fillRect(0, 0, W, H);
            totalEntropy = 0;
            objects = objects.filter(obj => {
                const alive = obj.update(time);
                obj.draw();
                totalEntropy += obj.entropy;
                return alive;
            });
            const entropyPct = maxEntropy > 0 ? Math.round((totalEntropy / maxEntropy) * 100) : 0;
            const orderPct = 100 - entropyPct;
            document.getElementById('entropy').textContent = entropyPct + '%';
            document.getElementById('order').textContent = orderPct + '%';
            requestAnimationFrame(animate);
        }

        document.getElementById('explosion-btn').onclick = () => selectedType = 'explosion';
        document.getElementById('shatter-btn').onclick = () => selectedType = 'shatter';
        document.getElementById('spill-btn').onclick = () => selectedType = 'spill';
        document.getElementById('scatter-btn').onclick = () => selectedType = 'scatter';
        document.getElementById('clear-btn').onclick = () => { objects = []; maxEntropy = 0; ctx.fillStyle = '#0a0a0a'; ctx.fillRect(0,0,W,H); };

        canvas.onclick = e => addChaos(e.clientX, e.clientY, selectedType);

        animate();
    </script>
</body>
</html>