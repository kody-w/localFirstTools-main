<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Factory Floor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #gameContainer {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        #canvas {
            display: block;
            background: #0f0f1e;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
            cursor: crosshair;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #topBar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(180deg, rgba(26, 26, 46, 0.95) 0%, rgba(26, 26, 46, 0.8) 100%);
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid rgba(79, 209, 197, 0.3);
            pointer-events: auto;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        #levelInfo {
            display: flex;
            gap: 30px;
            align-items: center;
        }

        .stat {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .statLabel {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .statValue {
            font-size: 20px;
            font-weight: bold;
            color: #4fd1c5;
        }

        #timer {
            font-size: 28px;
            font-weight: bold;
            color: #ff6b6b;
            text-shadow: 0 0 10px rgba(255, 107, 107, 0.5);
        }

        #toolBar {
            position: absolute;
            left: 20px;
            top: 120px;
            background: linear-gradient(135deg, rgba(26, 26, 46, 0.95) 0%, rgba(22, 33, 62, 0.95) 100%);
            padding: 15px;
            border-radius: 12px;
            border: 2px solid rgba(79, 209, 197, 0.3);
            pointer-events: auto;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            transition: transform 0.3s ease;
        }

        #toolBar:hover {
            transform: translateX(5px);
        }

        .toolTitle {
            font-size: 14px;
            color: #4fd1c5;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
        }

        .tool {
            width: 60px;
            height: 60px;
            margin: 8px 0;
            background: linear-gradient(135deg, #2a2a3e 0%, #1f1f2e 100%);
            border: 2px solid #3a3a5e;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            position: relative;
            overflow: hidden;
        }

        .tool:hover {
            border-color: #4fd1c5;
            box-shadow: 0 0 15px rgba(79, 209, 197, 0.4);
            transform: scale(1.05);
        }

        .tool.selected {
            border-color: #4fd1c5;
            background: linear-gradient(135deg, #3a5a57 0%, #2a4a47 100%);
            box-shadow: 0 0 20px rgba(79, 209, 197, 0.6);
        }

        .toolKey {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 10px;
            color: #666;
            background: rgba(0, 0, 0, 0.5);
            padding: 2px 4px;
            border-radius: 3px;
        }

        #recipePanel {
            position: absolute;
            right: 20px;
            top: 120px;
            width: 280px;
            max-height: 500px;
            background: linear-gradient(135deg, rgba(26, 26, 46, 0.95) 0%, rgba(22, 33, 62, 0.95) 100%);
            padding: 15px;
            border-radius: 12px;
            border: 2px solid rgba(79, 209, 197, 0.3);
            pointer-events: auto;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
        }

        .recipe {
            background: linear-gradient(135deg, #2a2a3e 0%, #1f1f2e 100%);
            padding: 12px;
            margin: 8px 0;
            border-radius: 8px;
            border: 1px solid #3a3a5e;
            transition: all 0.2s ease;
        }

        .recipe:hover {
            border-color: #4fd1c5;
            box-shadow: 0 0 10px rgba(79, 209, 197, 0.3);
        }

        .recipeName {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 6px;
            color: #4fd1c5;
        }

        .recipeFormula {
            font-size: 12px;
            color: #aaa;
        }

        .resourceDot {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin: 0 2px;
            vertical-align: middle;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 100;
        }

        #overlay.hidden {
            display: none;
        }

        .screen {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            padding: 50px;
            border-radius: 20px;
            border: 3px solid #4fd1c5;
            box-shadow: 0 0 50px rgba(79, 209, 197, 0.4);
            text-align: center;
            max-width: 600px;
            animation: slideIn 0.5s ease;
        }

        @keyframes slideIn {
            from {
                transform: scale(0.8);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        h1 {
            font-size: 48px;
            color: #4fd1c5;
            text-shadow: 0 0 20px rgba(79, 209, 197, 0.5);
            margin-bottom: 20px;
        }

        h2 {
            font-size: 32px;
            color: #4fd1c5;
            margin-bottom: 15px;
        }

        p {
            font-size: 16px;
            color: #aaa;
            margin: 15px 0;
            line-height: 1.6;
        }

        button {
            background: linear-gradient(135deg, #4fd1c5 0%, #3aa89d 100%);
            color: #1a1a2e;
            border: none;
            padding: 15px 40px;
            font-size: 18px;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            margin: 10px 5px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(79, 209, 197, 0.3);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(79, 209, 197, 0.5);
        }

        button:active {
            transform: translateY(0);
        }

        .stars {
            font-size: 48px;
            margin: 20px 0;
            letter-spacing: 10px;
        }

        .star {
            color: #666;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }

        .star.filled {
            color: #ffd700;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
        }

        .tutorialStep {
            background: rgba(26, 26, 46, 0.8);
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            border-left: 4px solid #4fd1c5;
            text-align: left;
        }

        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 20px;
            text-align: left;
        }

        .controlItem {
            background: rgba(26, 26, 46, 0.5);
            padding: 10px;
            border-radius: 6px;
            font-size: 14px;
        }

        .key {
            display: inline-block;
            background: #4fd1c5;
            color: #1a1a2e;
            padding: 3px 8px;
            border-radius: 4px;
            font-weight: bold;
            margin-right: 5px;
        }

        #pauseButton {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4fd1c5 0%, #3aa89d 100%);
            border: 3px solid rgba(79, 209, 197, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            pointer-events: auto;
            box-shadow: 0 4px 12px rgba(79, 209, 197, 0.4);
            transition: all 0.3s ease;
        }

        #pauseButton:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(79, 209, 197, 0.6);
        }

        .efficiencyBar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 5px;
        }

        .efficiencyFill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b 0%, #ffd700 50%, #4fd1c5 100%);
            border-radius: 4px;
            transition: width 0.5s ease;
        }

        #objectivePanel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, rgba(26, 26, 46, 0.95) 0%, rgba(22, 33, 62, 0.95) 100%);
            padding: 15px 20px;
            border-radius: 12px;
            border: 2px solid rgba(79, 209, 197, 0.3);
            pointer-events: auto;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
        }

        .objective {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 5px 0;
        }

        .objectiveLabel {
            font-size: 14px;
            color: #aaa;
        }

        .objectiveProgress {
            font-size: 16px;
            font-weight: bold;
            color: #4fd1c5;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="canvas"></canvas>
        <div id="ui">
            <div id="topBar">
                <div id="levelInfo">
                    <div class="stat">
                        <div class="statLabel">Level</div>
                        <div class="statValue" id="levelNum">1</div>
                    </div>
                    <div class="stat">
                        <div class="statLabel">Score</div>
                        <div class="statValue" id="score">0</div>
                    </div>
                    <div class="stat">
                        <div class="statLabel">Budget</div>
                        <div class="statValue" id="budget">20</div>
                    </div>
                    <div class="stat">
                        <div class="statLabel">Efficiency</div>
                        <div class="statValue" id="efficiency">0%</div>
                    </div>
                </div>
                <div id="timer">5:00</div>
            </div>

            <div id="toolBar">
                <div class="toolTitle">Tools</div>
                <div class="tool" data-tool="conveyor" data-key="1" title="Conveyor Belt (1)">
                    ‚ûú<span class="toolKey">1</span>
                </div>
                <div class="tool" data-tool="assembler" data-key="2" title="Assembler (2)">
                    ‚öô<span class="toolKey">2</span>
                </div>
                <div class="tool" data-tool="splitter" data-key="3" title="Splitter (3)">
                    ‚äï<span class="toolKey">3</span>
                </div>
                <div class="tool" data-tool="storage" data-key="4" title="Storage Bin (4)">
                    ‚äû<span class="toolKey">4</span>
                </div>
                <div class="tool" data-tool="delete" data-key="5" title="Delete (5/Del)">
                    ‚úï<span class="toolKey">5</span>
                </div>
            </div>

            <div id="recipePanel">
                <div class="toolTitle">Recipes</div>
                <div id="recipeList"></div>
            </div>

            <div id="objectivePanel">
                <div class="toolTitle">Objective</div>
                <div id="objectiveList"></div>
            </div>

            <div id="pauseButton" title="Pause (P)">‚è∏</div>
        </div>

        <div id="overlay">
            <div id="overlayContent"></div>
        </div>
    </div>

    <script>
        // Audio Context
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        function playSound(frequency, duration, type = 'sine', volume = 0.1) {
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.frequency.value = frequency;
            oscillator.type = type;
            gainNode.gain.value = volume;

            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + duration);
        }

        function conveyorHum() {
            playSound(80, 0.1, 'sawtooth', 0.03);
        }

        function assemblerClank() {
            playSound(200, 0.05, 'square', 0.08);
            setTimeout(() => playSound(150, 0.05, 'square', 0.06), 50);
        }

        function itemDelivered() {
            playSound(600, 0.1, 'sine', 0.12);
            setTimeout(() => playSound(800, 0.1, 'sine', 0.08), 100);
        }

        function levelComplete() {
            playSound(400, 0.15, 'sine', 0.15);
            setTimeout(() => playSound(500, 0.15, 'sine', 0.15), 150);
            setTimeout(() => playSound(600, 0.2, 'sine', 0.15), 300);
            setTimeout(() => playSound(800, 0.3, 'sine', 0.15), 500);
        }

        function errorBuzz() {
            playSound(100, 0.2, 'sawtooth', 0.15);
        }

        // Game State
        const GRID_WIDTH = 40;
        const GRID_HEIGHT = 25;
        const CELL_SIZE = 32;

        const RESOURCES = {
            iron: { color: '#c0c0c0', name: 'Iron' },
            copper: { color: '#ff8c42', name: 'Copper' },
            coal: { color: '#2d2d2d', name: 'Coal' },
            circuit: { color: '#4fd1c5', name: 'Circuit' },
            steel: { color: '#708090', name: 'Steel' },
            chip: { color: '#9370db', name: 'Chip' },
            battery: { color: '#ffd700', name: 'Battery' },
            module: { color: '#ff69b4', name: 'Module' }
        };

        const RECIPES = {
            circuit: { inputs: ['iron', 'copper'], output: 'circuit', time: 2 },
            steel: { inputs: ['iron', 'coal'], output: 'steel', time: 3 },
            chip: { inputs: ['circuit', 'copper'], output: 'chip', time: 4 },
            battery: { inputs: ['copper', 'coal'], output: 'battery', time: 3 },
            module: { inputs: ['circuit', 'chip', 'battery'], output: 'module', time: 5 }
        };

        const LEVELS = [
            {
                name: 'Tutorial',
                time: 300,
                budget: 20,
                objectives: { circuit: 5 },
                description: 'Produce 5 circuits to complete the tutorial'
            },
            {
                name: 'Steel Production',
                time: 240,
                budget: 25,
                objectives: { steel: 8 },
                description: 'Produce 8 steel units'
            },
            {
                name: 'Circuit Factory',
                time: 300,
                budget: 30,
                objectives: { circuit: 15, chip: 5 },
                description: 'Produce 15 circuits and 5 chips'
            },
            {
                name: 'Power Plant',
                time: 360,
                budget: 35,
                objectives: { battery: 10, chip: 8 },
                description: 'Produce 10 batteries and 8 chips'
            },
            {
                name: 'Advanced Factory',
                time: 420,
                budget: 40,
                objectives: { module: 5, steel: 15 },
                description: 'Produce 5 modules and 15 steel units'
            },
            {
                name: 'Master Production',
                time: 480,
                budget: 45,
                objectives: { module: 10, battery: 20, steel: 20 },
                description: 'Produce 10 modules, 20 batteries, and 20 steel units'
            }
        ];

        let canvas, ctx;
        let game = {
            state: 'title', // title, playing, paused, levelComplete, gameOver
            level: 0,
            score: 0,
            time: 0,
            budget: 0,
            grid: [],
            items: [],
            sources: [],
            selectedTool: 'conveyor',
            rotation: 0,
            mouseGridX: 0,
            mouseGridY: 0,
            production: {},
            delivered: {},
            efficiency: 0,
            combo: 0,
            lastDelivery: 0,
            particles: []
        };

        let keys = {};

        // Initialize
        function init() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');

            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            canvas.addEventListener('click', handleClick);
            canvas.addEventListener('contextmenu', handleRightClick);
            canvas.addEventListener('mousemove', handleMouseMove);

            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);

            document.querySelectorAll('.tool').forEach(tool => {
                tool.addEventListener('click', () => {
                    game.selectedTool = tool.dataset.tool;
                    updateToolSelection();
                });
            });

            document.getElementById('pauseButton').addEventListener('click', togglePause);

            loadProgress();
            showTitleScreen();
            generateRecipeList();

            requestAnimationFrame(gameLoop);
        }

        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }

        function gameLoop(timestamp) {
            const dt = timestamp - (game.lastTimestamp || timestamp);
            game.lastTimestamp = timestamp;

            if (game.state === 'playing') {
                update(dt / 1000);
            }

            render();
            requestAnimationFrame(gameLoop);
        }

        // Update
        function update(dt) {
            game.time -= dt;

            if (game.time <= 0) {
                game.time = 0;
                if (!checkObjectives()) {
                    gameOver();
                }
            }

            // Update items on conveyors
            for (let i = game.items.length - 1; i >= 0; i--) {
                const item = game.items[i];
                item.progress += dt * 0.5; // Speed of items

                if (item.progress >= 1) {
                    const nextX = item.x + (item.dir === 'right' ? 1 : item.dir === 'left' ? -1 : 0);
                    const nextY = item.y + (item.dir === 'down' ? 1 : item.dir === 'up' ? -1 : 0);

                    if (nextX >= 0 && nextX < GRID_WIDTH && nextY >= 0 && nextY < GRID_HEIGHT) {
                        const nextCell = game.grid[nextY][nextX];

                        if (nextCell && nextCell.type === 'conveyor') {
                            item.x = nextX;
                            item.y = nextY;
                            item.dir = nextCell.dir;
                            item.progress = 0;
                            conveyorHum();
                        } else if (nextCell && nextCell.type === 'assembler') {
                            if (tryAddToAssembler(nextCell, item)) {
                                game.items.splice(i, 1);
                            } else {
                                item.progress = 1; // Stuck
                            }
                        } else if (nextCell && nextCell.type === 'storage') {
                            storeItem(nextCell, item);
                            game.items.splice(i, 1);
                        } else if (nextCell && nextCell.type === 'splitter') {
                            // Splitter logic - alternate outputs
                            const outputs = getOutputDirections(nextCell.dir);
                            nextCell.lastOutput = (nextCell.lastOutput || 0) + 1;
                            item.dir = outputs[nextCell.lastOutput % outputs.length];
                            item.x = nextX;
                            item.y = nextY;
                            item.progress = 0;
                        } else {
                            item.progress = 1; // Stuck at edge
                        }
                    } else {
                        game.items.splice(i, 1); // Remove items that go off grid
                    }
                }
            }

            // Update assemblers
            game.grid.forEach(row => {
                row.forEach(cell => {
                    if (cell && cell.type === 'assembler' && cell.recipe) {
                        const recipe = RECIPES[cell.recipe];
                        if (recipe && hasAllInputs(cell, recipe)) {
                            cell.progress = (cell.progress || 0) + dt;

                            if (cell.progress >= recipe.time) {
                                produceItem(cell, recipe);
                                cell.progress = 0;
                            }
                        }
                    }
                });
            });

            // Update sources
            game.sources.forEach(source => {
                source.timer -= dt;
                if (source.timer <= 0) {
                    spawnResource(source);
                    source.timer = source.interval;
                }
            });

            // Update particles
            for (let i = game.particles.length - 1; i >= 0; i--) {
                const p = game.particles[i];
                p.life -= dt;
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.vy += 100 * dt; // Gravity

                if (p.life <= 0) {
                    game.particles.splice(i, 1);
                }
            }

            // Calculate efficiency
            const elapsed = LEVELS[game.level].time - game.time;
            const itemsProduced = Object.values(game.production).reduce((a, b) => a + b, 0);
            const itemsPerMinute = elapsed > 0 ? (itemsProduced / elapsed) * 60 : 0;
            game.efficiency = Math.min(100, Math.floor(itemsPerMinute * 10));

            // Check objectives
            if (checkObjectives()) {
                levelCompleteScreen();
            }

            // Update UI
            updateUI();
        }

        // Render
        function render() {
            ctx.fillStyle = '#0f0f1e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (game.state === 'title' || game.state === 'levelComplete' || game.state === 'gameOver') {
                return; // Overlay handles rendering
            }

            const offsetX = (canvas.width - GRID_WIDTH * CELL_SIZE) / 2;
            const offsetY = (canvas.height - GRID_HEIGHT * CELL_SIZE) / 2;

            ctx.save();
            ctx.translate(offsetX, offsetY);

            // Draw grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            for (let x = 0; x <= GRID_WIDTH; x++) {
                ctx.beginPath();
                ctx.moveTo(x * CELL_SIZE, 0);
                ctx.lineTo(x * CELL_SIZE, GRID_HEIGHT * CELL_SIZE);
                ctx.stroke();
            }
            for (let y = 0; y <= GRID_HEIGHT; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * CELL_SIZE);
                ctx.lineTo(GRID_WIDTH * CELL_SIZE, y * CELL_SIZE);
                ctx.stroke();
            }

            // Draw cells
            game.grid.forEach((row, y) => {
                row.forEach((cell, x) => {
                    if (cell) {
                        drawCell(cell, x, y);
                    }
                });
            });

            // Draw items
            game.items.forEach(item => {
                drawItem(item);
            });

            // Draw particles
            game.particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / p.maxLife;
                ctx.fillRect(p.x, p.y, 4, 4);
                ctx.globalAlpha = 1;
            });

            // Draw hover preview
            if (game.selectedTool !== 'delete' && game.mouseGridX >= 0 && game.mouseGridX < GRID_WIDTH &&
                game.mouseGridY >= 0 && game.mouseGridY < GRID_HEIGHT) {
                ctx.globalAlpha = 0.5;
                drawCell({ type: game.selectedTool, dir: getDirFromRotation(game.rotation) }, game.mouseGridX, game.mouseGridY);
                ctx.globalAlpha = 1;
            }

            ctx.restore();
        }

        function drawCell(cell, x, y) {
            const px = x * CELL_SIZE;
            const py = y * CELL_SIZE;

            ctx.save();

            if (cell.type === 'conveyor') {
                ctx.fillStyle = '#2a2a3e';
                ctx.fillRect(px + 2, py + 2, CELL_SIZE - 4, CELL_SIZE - 4);

                ctx.strokeStyle = '#4fd1c5';
                ctx.lineWidth = 3;
                ctx.beginPath();

                const centerX = px + CELL_SIZE / 2;
                const centerY = py + CELL_SIZE / 2;
                const arrowSize = 12;

                if (cell.dir === 'right') {
                    ctx.moveTo(centerX - arrowSize, centerY);
                    ctx.lineTo(centerX + arrowSize, centerY);
                    ctx.lineTo(centerX + arrowSize - 6, centerY - 6);
                    ctx.moveTo(centerX + arrowSize, centerY);
                    ctx.lineTo(centerX + arrowSize - 6, centerY + 6);
                } else if (cell.dir === 'left') {
                    ctx.moveTo(centerX + arrowSize, centerY);
                    ctx.lineTo(centerX - arrowSize, centerY);
                    ctx.lineTo(centerX - arrowSize + 6, centerY - 6);
                    ctx.moveTo(centerX - arrowSize, centerY);
                    ctx.lineTo(centerX - arrowSize + 6, centerY + 6);
                } else if (cell.dir === 'down') {
                    ctx.moveTo(centerX, centerY - arrowSize);
                    ctx.lineTo(centerX, centerY + arrowSize);
                    ctx.lineTo(centerX - 6, centerY + arrowSize - 6);
                    ctx.moveTo(centerX, centerY + arrowSize);
                    ctx.lineTo(centerX + 6, centerY + arrowSize - 6);
                } else if (cell.dir === 'up') {
                    ctx.moveTo(centerX, centerY + arrowSize);
                    ctx.lineTo(centerX, centerY - arrowSize);
                    ctx.lineTo(centerX - 6, centerY - arrowSize + 6);
                    ctx.moveTo(centerX, centerY - arrowSize);
                    ctx.lineTo(centerX + 6, centerY - arrowSize + 6);
                }

                ctx.stroke();
            } else if (cell.type === 'assembler') {
                const isActive = cell.progress > 0;
                ctx.fillStyle = isActive ? '#3a5a57' : '#2a2a3e';
                ctx.fillRect(px + 2, py + 2, CELL_SIZE - 4, CELL_SIZE - 4);

                if (isActive) {
                    ctx.shadowColor = '#4fd1c5';
                    ctx.shadowBlur = 15;
                }

                ctx.fillStyle = '#4fd1c5';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('‚öô', px + CELL_SIZE / 2, py + CELL_SIZE / 2);

                ctx.shadowBlur = 0;

                // Progress bar
                if (cell.recipe && cell.progress > 0) {
                    const recipe = RECIPES[cell.recipe];
                    const progressWidth = ((CELL_SIZE - 8) * cell.progress / recipe.time);
                    ctx.fillStyle = '#ffd700';
                    ctx.fillRect(px + 4, py + CELL_SIZE - 8, progressWidth, 4);
                }

                // Input indicators
                if (cell.inputs) {
                    Object.keys(cell.inputs).forEach((resource, i) => {
                        const count = cell.inputs[resource];
                        ctx.fillStyle = RESOURCES[resource].color;
                        ctx.fillRect(px + 4 + i * 6, py + 4, 4, 4);
                        ctx.fillStyle = '#fff';
                        ctx.font = '8px Arial';
                        ctx.fillText(count, px + 6 + i * 6, py + 12);
                    });
                }
            } else if (cell.type === 'storage') {
                ctx.fillStyle = '#2a2a3e';
                ctx.fillRect(px + 2, py + 2, CELL_SIZE - 4, CELL_SIZE - 4);

                const isFull = cell.stored && Object.keys(cell.stored).length > 0;
                if (isFull) {
                    ctx.shadowColor = '#ffd700';
                    ctx.shadowBlur = 10;
                }

                ctx.fillStyle = '#ffd700';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('‚äû', px + CELL_SIZE / 2, py + CELL_SIZE / 2);

                ctx.shadowBlur = 0;
            } else if (cell.type === 'splitter') {
                ctx.fillStyle = '#2a2a3e';
                ctx.fillRect(px + 2, py + 2, CELL_SIZE - 4, CELL_SIZE - 4);

                ctx.fillStyle = '#ff8c42';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('‚äï', px + CELL_SIZE / 2, py + CELL_SIZE / 2);
            } else if (cell.type === 'source') {
                ctx.fillStyle = RESOURCES[cell.resource].color;
                ctx.fillRect(px, py, CELL_SIZE, CELL_SIZE);

                ctx.fillStyle = '#000';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(RESOURCES[cell.resource].name, px + CELL_SIZE / 2, py + CELL_SIZE / 2);
            }

            ctx.restore();
        }

        function drawItem(item) {
            const baseX = item.x * CELL_SIZE;
            const baseY = item.y * CELL_SIZE;

            let offsetX = 0, offsetY = 0;

            if (item.dir === 'right') {
                offsetX = item.progress * CELL_SIZE;
            } else if (item.dir === 'left') {
                offsetX = (1 - item.progress) * CELL_SIZE;
            } else if (item.dir === 'down') {
                offsetY = item.progress * CELL_SIZE;
            } else if (item.dir === 'up') {
                offsetY = (1 - item.progress) * CELL_SIZE;
            }

            const px = baseX + offsetX + CELL_SIZE / 2;
            const py = baseY + offsetY + CELL_SIZE / 2;

            ctx.fillStyle = RESOURCES[item.resource].color;
            ctx.shadowColor = RESOURCES[item.resource].color;
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.arc(px, py, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        // Game Logic
        function startLevel(levelIndex) {
            game.level = levelIndex;
            const level = LEVELS[levelIndex];

            game.time = level.time;
            game.budget = level.budget;
            game.score = 0;
            game.production = {};
            game.delivered = {};
            game.efficiency = 0;
            game.combo = 0;
            game.particles = [];

            // Initialize grid
            game.grid = [];
            for (let y = 0; y < GRID_HEIGHT; y++) {
                game.grid[y] = [];
                for (let x = 0; x < GRID_WIDTH; x++) {
                    game.grid[y][x] = null;
                }
            }

            // Setup resource sources
            game.sources = [];
            game.items = [];

            // Place iron sources on left edge
            for (let i = 0; i < 3; i++) {
                const y = Math.floor(GRID_HEIGHT / 4) + i * Math.floor(GRID_HEIGHT / 4);
                game.grid[y][0] = { type: 'source', resource: 'iron' };
                game.sources.push({ x: 0, y: y, resource: 'iron', interval: 3, timer: 1 });
            }

            // Place copper sources on top edge
            for (let i = 0; i < 3; i++) {
                const x = Math.floor(GRID_WIDTH / 4) + i * Math.floor(GRID_WIDTH / 4);
                game.grid[0][x] = { type: 'source', resource: 'copper' };
                game.sources.push({ x: x, y: 0, resource: 'copper', interval: 3, timer: 1.5 });
            }

            // Place coal sources on right edge
            for (let i = 0; i < 2; i++) {
                const y = Math.floor(GRID_HEIGHT / 3) + i * Math.floor(GRID_HEIGHT / 3);
                game.grid[y][GRID_WIDTH - 1] = { type: 'source', resource: 'coal' };
                game.sources.push({ x: GRID_WIDTH - 1, y: y, resource: 'coal', interval: 4, timer: 2 });
            }

            game.state = 'playing';
            updateUI();
            hideOverlay();

            if (levelIndex === 0) {
                showTutorial();
            }
        }

        function spawnResource(source) {
            // Find adjacent conveyor
            const dirs = [
                { dx: 1, dy: 0, dir: 'right' },
                { dx: -1, dy: 0, dir: 'left' },
                { dx: 0, dy: 1, dir: 'down' },
                { dx: 0, dy: -1, dir: 'up' }
            ];

            for (const d of dirs) {
                const nx = source.x + d.dx;
                const ny = source.y + d.dy;

                if (nx >= 0 && nx < GRID_WIDTH && ny >= 0 && ny < GRID_HEIGHT) {
                    const cell = game.grid[ny][nx];
                    if (cell && cell.type === 'conveyor') {
                        game.items.push({
                            x: nx,
                            y: ny,
                            resource: source.resource,
                            dir: cell.dir,
                            progress: 0
                        });
                        return;
                    }
                }
            }
        }

        function tryAddToAssembler(assembler, item) {
            if (!assembler.inputs) {
                assembler.inputs = {};
            }

            // Determine recipe if not set
            if (!assembler.recipe) {
                for (const [recipeName, recipe] of Object.entries(RECIPES)) {
                    if (recipe.inputs.includes(item.resource)) {
                        assembler.recipe = recipeName;
                        break;
                    }
                }
            }

            const recipe = RECIPES[assembler.recipe];
            if (recipe && recipe.inputs.includes(item.resource)) {
                assembler.inputs[item.resource] = (assembler.inputs[item.resource] || 0) + 1;
                return true;
            }

            return false;
        }

        function hasAllInputs(assembler, recipe) {
            if (!assembler.inputs) return false;

            for (const input of recipe.inputs) {
                if (!assembler.inputs[input] || assembler.inputs[input] < 1) {
                    return false;
                }
            }
            return true;
        }

        function produceItem(assembler, recipe) {
            // Consume inputs
            recipe.inputs.forEach(input => {
                assembler.inputs[input]--;
                if (assembler.inputs[input] <= 0) {
                    delete assembler.inputs[input];
                }
            });

            // Find output direction
            const cell = findCellInGrid(assembler);
            if (cell) {
                const dirs = [
                    { dx: 1, dy: 0, dir: 'right' },
                    { dx: -1, dy: 0, dir: 'left' },
                    { dx: 0, dy: 1, dir: 'down' },
                    { dx: 0, dy: -1, dir: 'up' }
                ];

                for (const d of dirs) {
                    const nx = cell.x + d.dx;
                    const ny = cell.y + d.dy;

                    if (nx >= 0 && nx < GRID_WIDTH && ny >= 0 && ny < GRID_HEIGHT) {
                        const nextCell = game.grid[ny][nx];
                        if (nextCell && (nextCell.type === 'conveyor' || nextCell.type === 'storage')) {
                            game.items.push({
                                x: nx,
                                y: ny,
                                resource: recipe.output,
                                dir: nextCell.type === 'conveyor' ? nextCell.dir : 'right',
                                progress: 0
                            });

                            game.production[recipe.output] = (game.production[recipe.output] || 0) + 1;
                            assemblerClank();

                            // Particles
                            createParticles(cell.x * CELL_SIZE + CELL_SIZE / 2, cell.y * CELL_SIZE + CELL_SIZE / 2, RESOURCES[recipe.output].color);
                            return;
                        }
                    }
                }
            }
        }

        function storeItem(storage, item) {
            if (!storage.stored) {
                storage.stored = {};
            }

            storage.stored[item.resource] = (storage.stored[item.resource] || 0) + 1;
            game.delivered[item.resource] = (game.delivered[item.resource] || 0) + 1;

            // Score
            const now = Date.now();
            if (now - game.lastDelivery < 2000) {
                game.combo++;
            } else {
                game.combo = 1;
            }
            game.lastDelivery = now;

            const baseScore = 10;
            const comboMultiplier = 1 + (game.combo - 1) * 0.1;
            game.score += Math.floor(baseScore * comboMultiplier);

            itemDelivered();

            const cell = findCellInGrid(storage);
            if (cell) {
                createParticles(cell.x * CELL_SIZE + CELL_SIZE / 2, cell.y * CELL_SIZE + CELL_SIZE / 2, '#ffd700');
            }
        }

        function createParticles(x, y, color) {
            for (let i = 0; i < 10; i++) {
                game.particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 200,
                    vy: (Math.random() - 0.5) * 200 - 100,
                    color: color,
                    life: 0.5,
                    maxLife: 0.5
                });
            }
        }

        function findCellInGrid(cell) {
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    if (game.grid[y][x] === cell) {
                        return { x, y };
                    }
                }
            }
            return null;
        }

        function checkObjectives() {
            const level = LEVELS[game.level];
            for (const [resource, required] of Object.entries(level.objectives)) {
                if ((game.delivered[resource] || 0) < required) {
                    return false;
                }
            }
            return true;
        }

        // Input Handling
        function handleClick(e) {
            if (game.state !== 'playing') return;

            const rect = canvas.getBoundingClientRect();
            const offsetX = (canvas.width - GRID_WIDTH * CELL_SIZE) / 2;
            const offsetY = (canvas.height - GRID_HEIGHT * CELL_SIZE) / 2;

            const x = e.clientX - rect.left - offsetX;
            const y = e.clientY - rect.top - offsetY;

            const gridX = Math.floor(x / CELL_SIZE);
            const gridY = Math.floor(y / CELL_SIZE);

            if (gridX < 0 || gridX >= GRID_WIDTH || gridY < 0 || gridY >= GRID_HEIGHT) return;

            const cell = game.grid[gridY][gridX];

            if (game.selectedTool === 'delete') {
                if (cell && cell.type !== 'source') {
                    game.grid[gridY][gridX] = null;
                    game.budget++;
                    updateUI();
                }
            } else {
                if (!cell && game.budget > 0) {
                    const cost = getCost(game.selectedTool);
                    if (game.budget >= cost) {
                        game.grid[gridY][gridX] = {
                            type: game.selectedTool,
                            dir: getDirFromRotation(game.rotation)
                        };
                        game.budget -= cost;
                        updateUI();
                    } else {
                        errorBuzz();
                    }
                }
            }
        }

        function handleRightClick(e) {
            e.preventDefault();
            game.rotation = (game.rotation + 1) % 4;
        }

        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const offsetX = (canvas.width - GRID_WIDTH * CELL_SIZE) / 2;
            const offsetY = (canvas.height - GRID_HEIGHT * CELL_SIZE) / 2;

            const x = e.clientX - rect.left - offsetX;
            const y = e.clientY - rect.top - offsetY;

            game.mouseGridX = Math.floor(x / CELL_SIZE);
            game.mouseGridY = Math.floor(y / CELL_SIZE);
        }

        function handleKeyDown(e) {
            keys[e.key.toLowerCase()] = true;

            if (e.key >= '1' && e.key <= '5') {
                const tools = ['conveyor', 'assembler', 'splitter', 'storage', 'delete'];
                game.selectedTool = tools[parseInt(e.key) - 1];
                updateToolSelection();
            }

            if (e.key.toLowerCase() === 'r') {
                game.rotation = (game.rotation + 1) % 4;
            }

            if (e.key.toLowerCase() === 'p') {
                togglePause();
            }

            if (e.key === 'Delete' || e.key === 'Backspace') {
                game.selectedTool = 'delete';
                updateToolSelection();
            }
        }

        function handleKeyUp(e) {
            keys[e.key.toLowerCase()] = false;
        }

        function getCost(tool) {
            const costs = {
                conveyor: 1,
                assembler: 3,
                splitter: 2,
                storage: 2
            };
            return costs[tool] || 1;
        }

        function getDirFromRotation(rotation) {
            const dirs = ['right', 'down', 'left', 'up'];
            return dirs[rotation];
        }

        function getOutputDirections(inputDir) {
            if (inputDir === 'right' || inputDir === 'left') {
                return ['up', 'down'];
            } else {
                return ['left', 'right'];
            }
        }

        function togglePause() {
            if (game.state === 'playing') {
                game.state = 'paused';
                showPauseScreen();
            } else if (game.state === 'paused') {
                game.state = 'playing';
                hideOverlay();
            }
        }

        // UI Updates
        function updateUI() {
            document.getElementById('levelNum').textContent = game.level + 1;
            document.getElementById('score').textContent = game.score;
            document.getElementById('budget').textContent = game.budget;
            document.getElementById('efficiency').textContent = game.efficiency + '%';

            const minutes = Math.floor(game.time / 60);
            const seconds = Math.floor(game.time % 60);
            document.getElementById('timer').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;

            if (game.time < 60) {
                document.getElementById('timer').style.color = '#ff6b6b';
            } else {
                document.getElementById('timer').style.color = '#4fd1c5';
            }

            updateObjectivePanel();
        }

        function updateObjectivePanel() {
            const level = LEVELS[game.level];
            const list = document.getElementById('objectiveList');
            list.innerHTML = '';

            for (const [resource, required] of Object.entries(level.objectives)) {
                const current = game.delivered[resource] || 0;
                const div = document.createElement('div');
                div.className = 'objective';
                div.innerHTML = `
                    <span class="resourceDot" style="background: ${RESOURCES[resource].color}"></span>
                    <span class="objectiveLabel">${RESOURCES[resource].name}:</span>
                    <span class="objectiveProgress">${current}/${required}</span>
                `;
                list.appendChild(div);
            }
        }

        function updateToolSelection() {
            document.querySelectorAll('.tool').forEach(tool => {
                if (tool.dataset.tool === game.selectedTool) {
                    tool.classList.add('selected');
                } else {
                    tool.classList.remove('selected');
                }
            });
        }

        function generateRecipeList() {
            const list = document.getElementById('recipeList');
            list.innerHTML = '';

            for (const [name, recipe] of Object.entries(RECIPES)) {
                const div = document.createElement('div');
                div.className = 'recipe';

                const inputsHTML = recipe.inputs.map(r =>
                    `<span class="resourceDot" style="background: ${RESOURCES[r].color}"></span>`
                ).join(' + ');

                const outputHTML = `<span class="resourceDot" style="background: ${RESOURCES[recipe.output].color}"></span>`;

                div.innerHTML = `
                    <div class="recipeName">${RESOURCES[recipe.output].name}</div>
                    <div class="recipeFormula">${inputsHTML} ‚Üí ${outputHTML} (${recipe.time}s)</div>
                `;

                list.appendChild(div);
            }
        }

        // Screens
        function showTitleScreen() {
            const content = `
                <div class="screen">
                    <h1>üè≠ Factory Floor</h1>
                    <p>Build conveyor networks, combine resources, and meet production targets!</p>
                    <p>Route materials through assemblers to create complex products.</p>
                    <button onclick="startLevel(0)">Start Factory</button>
                    <button onclick="showInstructions()">How to Play</button>
                </div>
            `;
            showOverlay(content);
        }

        function showTutorial() {
            const content = `
                <div class="screen">
                    <h2>Tutorial - Level 1</h2>
                    <div class="tutorialStep">
                        <strong>Objective:</strong> Produce 5 circuits to complete the level
                    </div>
                    <div class="tutorialStep">
                        <strong>Resources:</strong> Iron (gray) and copper (orange) spawn at the edges
                    </div>
                    <div class="tutorialStep">
                        <strong>Recipe:</strong> Iron + Copper = Circuit (cyan)
                    </div>
                    <div class="tutorialStep">
                        <strong>Steps:</strong>
                        <br>1. Place conveyors (1) to route iron and copper to the same location
                        <br>2. Place an assembler (2) where both resources meet
                        <br>3. Place a conveyor leading from the assembler to a storage bin (4)
                        <br>4. Storage bins count toward your objective!
                    </div>
                    <button onclick="hideOverlay(); game.state = 'playing'">Got it!</button>
                </div>
            `;
            game.state = 'paused';
            showOverlay(content);
        }

        function showInstructions() {
            const content = `
                <div class="screen">
                    <h2>How to Play</h2>
                    <p>Build efficient factories to meet production targets before time runs out!</p>
                    <div class="controls">
                        <div class="controlItem"><span class="key">Click</span> Place machine</div>
                        <div class="controlItem"><span class="key">Right Click</span> Rotate</div>
                        <div class="controlItem"><span class="key">1-5</span> Select tool</div>
                        <div class="controlItem"><span class="key">R</span> Rotate</div>
                        <div class="controlItem"><span class="key">Del</span> Delete mode</div>
                        <div class="controlItem"><span class="key">P</span> Pause</div>
                    </div>
                    <div class="tutorialStep">
                        <strong>Machines:</strong>
                        <br>‚ûú Conveyor: Moves items in one direction
                        <br>‚öô Assembler: Combines inputs into outputs
                        <br>‚äï Splitter: Splits one belt into two paths
                        <br>‚äû Storage: Stores finished products (counts for objectives)
                    </div>
                    <button onclick="showTitleScreen()">Back</button>
                </div>
            `;
            showOverlay(content);
        }

        function showPauseScreen() {
            const content = `
                <div class="screen">
                    <h2>‚è∏ Paused</h2>
                    <p>Take a break and plan your factory layout!</p>
                    <button onclick="togglePause()">Resume</button>
                    <button onclick="showInstructions()">How to Play</button>
                    <button onclick="showTitleScreen(); game.state = 'title'">Quit to Menu</button>
                </div>
            `;
            showOverlay(content);
        }

        function levelCompleteScreen() {
            game.state = 'levelComplete';
            levelComplete();

            const level = LEVELS[game.level];
            const efficiency = game.efficiency;
            const stars = efficiency >= 80 ? 3 : efficiency >= 50 ? 2 : 1;

            const starsHTML = ['‚òÖ', '‚òÖ', '‚òÖ'].map((s, i) =>
                `<span class="star ${i < stars ? 'filled' : ''}">${s}</span>`
            ).join('');

            saveProgress();

            const nextLevel = game.level + 1;
            const hasNext = nextLevel < LEVELS.length;

            const content = `
                <div class="screen">
                    <h2>üè≠ Level Complete!</h2>
                    <div class="stars">${starsHTML}</div>
                    <p><strong>Score:</strong> ${game.score}</p>
                    <p><strong>Efficiency:</strong> ${efficiency}%</p>
                    <p><strong>Time Remaining:</strong> ${Math.floor(game.time)}s</p>
                    ${hasNext ?
                        `<button onclick="startLevel(${nextLevel})">Next Level</button>` :
                        `<p style="color: #4fd1c5; font-size: 20px; margin: 20px 0;">üéâ All levels complete! üéâ</p>`
                    }
                    <button onclick="startLevel(${game.level})">Retry Level</button>
                    <button onclick="showTitleScreen(); game.state = 'title'">Main Menu</button>
                </div>
            `;
            showOverlay(content);
        }

        function gameOver() {
            game.state = 'gameOver';
            errorBuzz();

            const content = `
                <div class="screen">
                    <h2>‚è± Time's Up!</h2>
                    <p>You didn't meet the production targets in time.</p>
                    <p><strong>Score:</strong> ${game.score}</p>
                    <p><strong>Efficiency:</strong> ${game.efficiency}%</p>
                    <button onclick="startLevel(${game.level})">Try Again</button>
                    <button onclick="showTitleScreen(); game.state = 'title'">Main Menu</button>
                </div>
            `;
            showOverlay(content);
        }

        function showOverlay(content) {
            document.getElementById('overlayContent').innerHTML = content;
            document.getElementById('overlay').classList.remove('hidden');
        }

        function hideOverlay() {
            document.getElementById('overlay').classList.add('hidden');
        }

        // Save/Load
        function saveProgress() {
            const save = {
                level: game.level,
                highScore: game.score
            };

            const existing = localStorage.getItem('factoryFloorSave');
            if (existing) {
                const data = JSON.parse(existing);
                if (data.level > save.level) {
                    save.level = data.level;
                }
                if (data.highScore > save.highScore) {
                    save.highScore = data.highScore;
                }
            }

            localStorage.setItem('factoryFloorSave', JSON.stringify(save));
        }

        function loadProgress() {
            const save = localStorage.getItem('factoryFloorSave');
            if (save) {
                const data = JSON.parse(save);
                // Progress loaded but not applied automatically
            }
        }

        // Start
        init();
    </script>
</body>
</html>