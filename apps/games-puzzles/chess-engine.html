<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Engine - Classic Chess with AI</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #2c1810 0%, #1a0f08 100%);
            color: #f5e6d3;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            display: flex;
            gap: 30px;
            max-width: 1400px;
            width: 100%;
            flex-wrap: wrap;
            justify-content: center;
        }

        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
            min-width: 280px;
        }

        .board-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .captured-pieces {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 8px;
            min-height: 50px;
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            align-items: center;
            border: 2px solid #8b4513;
        }

        .captured-piece {
            font-size: 24px;
            opacity: 0.8;
        }

        #chessboard {
            border: 8px solid #8b4513;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            background: #d4a574;
            position: relative;
        }

        .board-row {
            display: flex;
        }

        .square {
            width: 70px;
            height: 70px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 48px;
            cursor: pointer;
            position: relative;
            user-select: none;
            transition: background-color 0.2s;
        }

        .square.light {
            background-color: #f0d9b5;
        }

        .square.dark {
            background-color: #b58863;
        }

        .square.selected {
            background-color: #baca44 !important;
        }

        .square.legal-move::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 50%;
        }

        .square.legal-move.has-piece::after {
            width: 100%;
            height: 100%;
            border-radius: 0;
            background-color: rgba(255, 0, 0, 0.3);
            border: 3px solid rgba(255, 0, 0, 0.6);
        }

        .square.last-move {
            background-color: rgba(186, 202, 68, 0.5) !important;
        }

        .square.in-check {
            background-color: rgba(255, 0, 0, 0.4) !important;
            animation: pulse-check 1s infinite;
        }

        @keyframes pulse-check {
            0%, 100% { box-shadow: inset 0 0 20px rgba(255, 0, 0, 0.6); }
            50% { box-shadow: inset 0 0 40px rgba(255, 0, 0, 0.9); }
        }

        .coordinates {
            position: absolute;
            font-size: 11px;
            font-weight: bold;
            color: #8b4513;
            opacity: 0.7;
        }

        .coord-file {
            bottom: 2px;
            right: 4px;
        }

        .coord-rank {
            top: 2px;
            left: 4px;
        }

        .right-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
            min-width: 300px;
            max-width: 400px;
        }

        .panel {
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid #8b4513;
            border-radius: 8px;
            padding: 20px;
        }

        h1 {
            text-align: center;
            margin-bottom: 20px;
            color: #f5e6d3;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            font-size: 28px;
        }

        h2 {
            margin-bottom: 15px;
            color: #d4a574;
            font-size: 20px;
            border-bottom: 2px solid #8b4513;
            padding-bottom: 8px;
        }

        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }

        button {
            background: linear-gradient(135deg, #8b4513 0%, #6b3410 100%);
            color: #f5e6d3;
            border: 2px solid #d4a574;
            padding: 12px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button:hover:not(:disabled) {
            background: linear-gradient(135deg, #a0522d 0%, #8b4513 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .full-width {
            grid-column: 1 / -1;
        }

        .settings {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        label {
            font-weight: bold;
            color: #d4a574;
        }

        select, input[type="number"] {
            background: rgba(0, 0, 0, 0.3);
            color: #f5e6d3;
            border: 2px solid #8b4513;
            padding: 8px;
            border-radius: 4px;
            font-size: 14px;
        }

        .status {
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            margin-bottom: 15px;
            text-align: center;
            font-size: 16px;
            font-weight: bold;
            border: 2px solid #8b4513;
        }

        .status.white-turn {
            background: rgba(240, 217, 181, 0.2);
        }

        .status.black-turn {
            background: rgba(60, 40, 30, 0.5);
        }

        .status.game-over {
            background: rgba(139, 69, 19, 0.3);
            font-size: 18px;
        }

        .move-history {
            max-height: 300px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }

        .move-entry {
            padding: 6px;
            margin: 2px 0;
            cursor: pointer;
            border-radius: 3px;
            transition: background-color 0.2s;
            display: grid;
            grid-template-columns: 40px 1fr 1fr;
            gap: 10px;
        }

        .move-entry:hover {
            background: rgba(139, 69, 19, 0.3);
        }

        .move-entry.current {
            background: rgba(139, 69, 19, 0.5);
            font-weight: bold;
        }

        .move-number {
            color: #8b4513;
            font-weight: bold;
        }

        .thinking {
            text-align: center;
            color: #d4a574;
            font-style: italic;
            padding: 10px;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, #2c1810 0%, #1a0f08 100%);
            padding: 30px;
            border-radius: 8px;
            border: 4px solid #8b4513;
            text-align: center;
            max-width: 400px;
        }

        .promotion-pieces {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            justify-content: center;
        }

        .promotion-piece {
            font-size: 64px;
            cursor: pointer;
            padding: 10px;
            border-radius: 8px;
            transition: all 0.3s;
            background: rgba(139, 69, 19, 0.3);
        }

        .promotion-piece:hover {
            background: rgba(139, 69, 19, 0.6);
            transform: scale(1.1);
        }

        textarea {
            width: 100%;
            height: 150px;
            background: rgba(0, 0, 0, 0.3);
            color: #f5e6d3;
            border: 2px solid #8b4513;
            padding: 10px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            margin: 10px 0;
            resize: vertical;
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }

            .square {
                width: 45px;
                height: 45px;
                font-size: 32px;
            }

            .left-panel, .right-panel {
                width: 100%;
            }
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: #8b4513;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #a0522d;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="left-panel">
            <div class="panel">
                <h2>Game Mode</h2>
                <div class="settings">
                    <div class="setting-row">
                        <label>Mode:</label>
                        <select id="gameMode">
                            <option value="ai">Player vs AI</option>
                            <option value="pvp">Player vs Player</option>
                        </select>
                    </div>
                    <div class="setting-row" id="playerColorRow">
                        <label>Play as:</label>
                        <select id="playerColor">
                            <option value="white">White</option>
                            <option value="black">Black</option>
                        </select>
                    </div>
                    <div class="setting-row" id="difficultyRow">
                        <label>AI Difficulty:</label>
                        <select id="aiDifficulty">
                            <option value="1">Easy (1)</option>
                            <option value="2">Medium (2)</option>
                            <option value="3" selected>Hard (3)</option>
                            <option value="4">Expert (4)</option>
                        </select>
                    </div>
                    <div class="setting-row">
                        <label>Sound:</label>
                        <select id="soundToggle">
                            <option value="on">On</option>
                            <option value="off">Off</option>
                        </select>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h2>Controls</h2>
                <div class="controls">
                    <button onclick="newGame()" class="full-width">New Game</button>
                    <button onclick="undoMove()" id="undoBtn">Undo Move</button>
                    <button onclick="flipBoard()">Flip Board</button>
                    <button onclick="resign()" id="resignBtn">Resign</button>
                    <button onclick="offerDraw()" id="drawBtn">Offer Draw</button>
                    <button onclick="showPGNExport()">Export PGN</button>
                    <button onclick="showPGNImport()">Import PGN</button>
                </div>
            </div>

            <div class="panel">
                <h2>Captured Pieces</h2>
                <div class="captured-pieces" id="capturedWhite"></div>
                <div class="captured-pieces" id="capturedBlack"></div>
            </div>
        </div>

        <div class="board-container">
            <div class="captured-pieces" id="capturedTop"></div>
            <div id="chessboard"></div>
            <div class="captured-pieces" id="capturedBottom"></div>
        </div>

        <div class="right-panel">
            <div class="panel">
                <h1>Chess Engine</h1>
                <div class="status" id="status">White to move</div>
                <div id="thinking"></div>
            </div>

            <div class="panel">
                <h2>Move History</h2>
                <div class="move-history" id="moveHistory"></div>
            </div>
        </div>
    </div>

    <div class="modal" id="promotionModal">
        <div class="modal-content">
            <h2>Choose Promotion Piece</h2>
            <div class="promotion-pieces" id="promotionPieces"></div>
        </div>
    </div>

    <div class="modal" id="pgnModal">
        <div class="modal-content">
            <h2 id="pgnModalTitle">PGN</h2>
            <textarea id="pgnText"></textarea>
            <div class="controls">
                <button onclick="closePGNModal()">Close</button>
                <button onclick="importPGN()" id="importPGNBtn" style="display: none;">Import</button>
                <button onclick="copyPGN()" id="copyPGNBtn" style="display: none;">Copy</button>
            </div>
        </div>
    </div>

    <script>
        // Unicode chess pieces
        const PIECES = {
            K: '♔', Q: '♕', R: '♖', B: '♗', N: '♘', P: '♙',
            k: '♚', q: '♛', r: '♜', b: '♝', n: '♞', p: '♟'
        };

        // Initial board state (FEN notation style)
        const INITIAL_BOARD = [
            ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
            ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
            ['.', '.', '.', '.', '.', '.', '.', '.'],
            ['.', '.', '.', '.', '.', '.', '.', '.'],
            ['.', '.', '.', '.', '.', '.', '.', '.'],
            ['.', '.', '.', '.', '.', '.', '.', '.'],
            ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
            ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
        ];

        // Piece-square tables for AI evaluation
        const PIECE_SQUARE_TABLES = {
            P: [
                0,  0,  0,  0,  0,  0,  0,  0,
                50, 50, 50, 50, 50, 50, 50, 50,
                10, 10, 20, 30, 30, 20, 10, 10,
                5,  5, 10, 25, 25, 10,  5,  5,
                0,  0,  0, 20, 20,  0,  0,  0,
                5, -5,-10,  0,  0,-10, -5,  5,
                5, 10, 10,-20,-20, 10, 10,  5,
                0,  0,  0,  0,  0,  0,  0,  0
            ],
            N: [
                -50,-40,-30,-30,-30,-30,-40,-50,
                -40,-20,  0,  0,  0,  0,-20,-40,
                -30,  0, 10, 15, 15, 10,  0,-30,
                -30,  5, 15, 20, 20, 15,  5,-30,
                -30,  0, 15, 20, 20, 15,  0,-30,
                -30,  5, 10, 15, 15, 10,  5,-30,
                -40,-20,  0,  5,  5,  0,-20,-40,
                -50,-40,-30,-30,-30,-30,-40,-50
            ],
            B: [
                -20,-10,-10,-10,-10,-10,-10,-20,
                -10,  0,  0,  0,  0,  0,  0,-10,
                -10,  0,  5, 10, 10,  5,  0,-10,
                -10,  5,  5, 10, 10,  5,  5,-10,
                -10,  0, 10, 10, 10, 10,  0,-10,
                -10, 10, 10, 10, 10, 10, 10,-10,
                -10,  5,  0,  0,  0,  0,  5,-10,
                -20,-10,-10,-10,-10,-10,-10,-20
            ],
            R: [
                0,  0,  0,  0,  0,  0,  0,  0,
                5, 10, 10, 10, 10, 10, 10,  5,
                -5,  0,  0,  0,  0,  0,  0, -5,
                -5,  0,  0,  0,  0,  0,  0, -5,
                -5,  0,  0,  0,  0,  0,  0, -5,
                -5,  0,  0,  0,  0,  0,  0, -5,
                -5,  0,  0,  0,  0,  0,  0, -5,
                0,  0,  0,  5,  5,  0,  0,  0
            ],
            Q: [
                -20,-10,-10, -5, -5,-10,-10,-20,
                -10,  0,  0,  0,  0,  0,  0,-10,
                -10,  0,  5,  5,  5,  5,  0,-10,
                -5,  0,  5,  5,  5,  5,  0, -5,
                0,  0,  5,  5,  5,  5,  0, -5,
                -10,  5,  5,  5,  5,  5,  0,-10,
                -10,  0,  5,  0,  0,  0,  0,-10,
                -20,-10,-10, -5, -5,-10,-10,-20
            ],
            K: [
                -30,-40,-40,-50,-50,-40,-40,-30,
                -30,-40,-40,-50,-50,-40,-40,-30,
                -30,-40,-40,-50,-50,-40,-40,-30,
                -30,-40,-40,-50,-50,-40,-40,-30,
                -20,-30,-30,-40,-40,-30,-30,-20,
                -10,-20,-20,-20,-20,-20,-20,-10,
                20, 20,  0,  0,  0,  0, 20, 20,
                20, 30, 10,  0,  0, 10, 30, 20
            ]
        };

        // Game state
        let board = [];
        let selectedSquare = null;
        let legalMoves = [];
        let currentTurn = 'white';
        let gameMode = 'ai';
        let playerColor = 'white';
        let aiDifficulty = 3;
        let gameOver = false;
        let moveHistory = [];
        let capturedPieces = { white: [], black: [] };
        let castlingRights = { white: { kingside: true, queenside: true }, black: { kingside: true, queenside: true } };
        let enPassantSquare = null;
        let halfMoveClock = 0;
        let fullMoveNumber = 1;
        let lastMove = null;
        let boardFlipped = false;
        let soundEnabled = true;
        let historyIndex = -1;
        let audioContext = null;

        // Initialize audio context
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        // Sound effects using Web Audio API
        function playSound(type) {
            if (!soundEnabled) return;
            initAudio();

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            const now = audioContext.currentTime;

            switch(type) {
                case 'move':
                    oscillator.frequency.setValueAtTime(440, now);
                    gainNode.gain.setValueAtTime(0.1, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    break;
                case 'capture':
                    oscillator.frequency.setValueAtTime(220, now);
                    gainNode.gain.setValueAtTime(0.15, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                    break;
                case 'check':
                    oscillator.frequency.setValueAtTime(660, now);
                    gainNode.gain.setValueAtTime(0.2, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                    break;
                case 'castle':
                    oscillator.frequency.setValueAtTime(330, now);
                    gainNode.gain.setValueAtTime(0.12, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                    break;
            }

            oscillator.start(now);
            oscillator.stop(now + 0.2);
        }

        // Initialize game
        function initGame() {
            board = INITIAL_BOARD.map(row => [...row]);
            selectedSquare = null;
            legalMoves = [];
            currentTurn = 'white';
            gameOver = false;
            moveHistory = [];
            capturedPieces = { white: [], black: [] };
            castlingRights = { white: { kingside: true, queenside: true }, black: { kingside: true, queenside: true } };
            enPassantSquare = null;
            halfMoveClock = 0;
            fullMoveNumber = 1;
            lastMove = null;
            historyIndex = -1;

            renderBoard();
            updateStatus();
            updateMoveHistory();
            updateCapturedPieces();

            if (gameMode === 'ai' && playerColor === 'black') {
                setTimeout(() => makeAIMove(), 500);
            }
        }

        // Render the chess board
        function renderBoard() {
            const boardElement = document.getElementById('chessboard');
            boardElement.innerHTML = '';

            const displayBoard = boardFlipped ? [...board].reverse() : board;

            displayBoard.forEach((row, rowIndex) => {
                const actualRow = boardFlipped ? 7 - rowIndex : rowIndex;
                const rowElement = document.createElement('div');
                rowElement.className = 'board-row';

                const displayRow = boardFlipped ? [...row].reverse() : row;

                displayRow.forEach((piece, colIndex) => {
                    const actualCol = boardFlipped ? 7 - colIndex : colIndex;
                    const square = document.createElement('div');
                    const isLight = (actualRow + actualCol) % 2 === 0;
                    square.className = `square ${isLight ? 'light' : 'dark'}`;
                    square.dataset.row = actualRow;
                    square.dataset.col = actualCol;

                    if (piece !== '.') {
                        square.textContent = PIECES[piece];
                        square.classList.add('has-piece');
                    }

                    // Add coordinates
                    if (actualCol === 0) {
                        const rankCoord = document.createElement('span');
                        rankCoord.className = 'coordinates coord-rank';
                        rankCoord.textContent = 8 - actualRow;
                        square.appendChild(rankCoord);
                    }
                    if (actualRow === 7) {
                        const fileCoord = document.createElement('span');
                        fileCoord.className = 'coordinates coord-file';
                        fileCoord.textContent = String.fromCharCode(97 + actualCol);
                        square.appendChild(fileCoord);
                    }

                    // Highlight selected square
                    if (selectedSquare && selectedSquare.row === actualRow && selectedSquare.col === actualCol) {
                        square.classList.add('selected');
                    }

                    // Highlight legal moves
                    if (legalMoves.some(move => move.toRow === actualRow && move.toCol === actualCol)) {
                        square.classList.add('legal-move');
                    }

                    // Highlight last move
                    if (lastMove &&
                        ((lastMove.fromRow === actualRow && lastMove.fromCol === actualCol) ||
                         (lastMove.toRow === actualRow && lastMove.toCol === actualCol))) {
                        square.classList.add('last-move');
                    }

                    // Highlight king in check
                    if (piece === 'K' && isInCheck('white')) {
                        square.classList.add('in-check');
                    }
                    if (piece === 'k' && isInCheck('black')) {
                        square.classList.add('in-check');
                    }

                    square.addEventListener('click', () => handleSquareClick(actualRow, actualCol));

                    rowElement.appendChild(square);
                });

                boardElement.appendChild(rowElement);
            });
        }

        // Handle square click
        function handleSquareClick(row, col) {
            if (gameOver) return;
            if (historyIndex !== -1) return; // Can't move while reviewing history

            const piece = board[row][col];

            // If no piece is selected
            if (!selectedSquare) {
                if (piece === '.') return;
                const pieceColor = piece === piece.toUpperCase() ? 'white' : 'black';

                // Check if it's the player's turn
                if (gameMode === 'ai' && pieceColor !== playerColor) return;
                if (pieceColor !== currentTurn) return;

                selectedSquare = { row, col };
                legalMoves = getLegalMoves(row, col);
                renderBoard();
            } else {
                // Check if the move is legal
                const move = legalMoves.find(m => m.toRow === row && m.toCol === col);

                if (move) {
                    makeMove(move);
                    selectedSquare = null;
                    legalMoves = [];
                    renderBoard();
                } else {
                    // Clicked on another piece of the same color
                    const clickedPiece = board[row][col];
                    if (clickedPiece !== '.') {
                        const clickedPieceColor = clickedPiece === clickedPiece.toUpperCase() ? 'white' : 'black';
                        if (clickedPieceColor === currentTurn) {
                            selectedSquare = { row, col };
                            legalMoves = getLegalMoves(row, col);
                            renderBoard();
                            return;
                        }
                    }

                    selectedSquare = null;
                    legalMoves = [];
                    renderBoard();
                }
            }
        }

        // Get legal moves for a piece
        function getLegalMoves(row, col) {
            const piece = board[row][col];
            if (piece === '.') return [];

            const pieceColor = piece === piece.toUpperCase() ? 'white' : 'black';
            const moves = [];

            const pieceType = piece.toUpperCase();

            switch(pieceType) {
                case 'P':
                    moves.push(...getPawnMoves(row, col, pieceColor));
                    break;
                case 'N':
                    moves.push(...getKnightMoves(row, col, pieceColor));
                    break;
                case 'B':
                    moves.push(...getBishopMoves(row, col, pieceColor));
                    break;
                case 'R':
                    moves.push(...getRookMoves(row, col, pieceColor));
                    break;
                case 'Q':
                    moves.push(...getQueenMoves(row, col, pieceColor));
                    break;
                case 'K':
                    moves.push(...getKingMoves(row, col, pieceColor));
                    break;
            }

            // Filter out moves that would leave king in check
            return moves.filter(move => !wouldBeInCheck(move, pieceColor));
        }

        // Pawn moves
        function getPawnMoves(row, col, color) {
            const moves = [];
            const direction = color === 'white' ? -1 : 1;
            const startRow = color === 'white' ? 6 : 1;

            // Move forward one square
            if (board[row + direction]?.[col] === '.') {
                moves.push({ fromRow: row, fromCol: col, toRow: row + direction, toCol: col });

                // Move forward two squares from starting position
                if (row === startRow && board[row + 2 * direction][col] === '.') {
                    moves.push({ fromRow: row, fromCol: col, toRow: row + 2 * direction, toCol: col });
                }
            }

            // Capture diagonally
            for (const dcol of [-1, 1]) {
                const newCol = col + dcol;
                const newRow = row + direction;
                if (board[newRow]?.[newCol]) {
                    const target = board[newRow][newCol];
                    if (target !== '.') {
                        const targetColor = target === target.toUpperCase() ? 'white' : 'black';
                        if (targetColor !== color) {
                            moves.push({ fromRow: row, fromCol: col, toRow: newRow, toCol: newCol });
                        }
                    }
                }
            }

            // En passant
            if (enPassantSquare && row + direction === enPassantSquare.row) {
                for (const dcol of [-1, 1]) {
                    if (col + dcol === enPassantSquare.col) {
                        moves.push({
                            fromRow: row,
                            fromCol: col,
                            toRow: enPassantSquare.row,
                            toCol: enPassantSquare.col,
                            enPassant: true,
                            captureRow: row,
                            captureCol: enPassantSquare.col
                        });
                    }
                }
            }

            return moves;
        }

        // Knight moves
        function getKnightMoves(row, col, color) {
            const moves = [];
            const offsets = [
                [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                [1, -2], [1, 2], [2, -1], [2, 1]
            ];

            for (const [drow, dcol] of offsets) {
                const newRow = row + drow;
                const newCol = col + dcol;
                if (board[newRow]?.[newCol] !== undefined) {
                    const target = board[newRow][newCol];
                    if (target === '.') {
                        moves.push({ fromRow: row, fromCol: col, toRow: newRow, toCol: newCol });
                    } else {
                        const targetColor = target === target.toUpperCase() ? 'white' : 'black';
                        if (targetColor !== color) {
                            moves.push({ fromRow: row, fromCol: col, toRow: newRow, toCol: newCol });
                        }
                    }
                }
            }

            return moves;
        }

        // Bishop moves
        function getBishopMoves(row, col, color) {
            return getSlidingMoves(row, col, color, [[1, 1], [1, -1], [-1, 1], [-1, -1]]);
        }

        // Rook moves
        function getRookMoves(row, col, color) {
            return getSlidingMoves(row, col, color, [[1, 0], [-1, 0], [0, 1], [0, -1]]);
        }

        // Queen moves
        function getQueenMoves(row, col, color) {
            return getSlidingMoves(row, col, color, [[1, 1], [1, -1], [-1, 1], [-1, -1], [1, 0], [-1, 0], [0, 1], [0, -1]]);
        }

        // Sliding moves (for bishop, rook, queen)
        function getSlidingMoves(row, col, color, directions) {
            const moves = [];

            for (const [drow, dcol] of directions) {
                let newRow = row + drow;
                let newCol = col + dcol;

                while (board[newRow]?.[newCol] !== undefined) {
                    const target = board[newRow][newCol];
                    if (target === '.') {
                        moves.push({ fromRow: row, fromCol: col, toRow: newRow, toCol: newCol });
                    } else {
                        const targetColor = target === target.toUpperCase() ? 'white' : 'black';
                        if (targetColor !== color) {
                            moves.push({ fromRow: row, fromCol: col, toRow: newRow, toCol: newCol });
                        }
                        break;
                    }
                    newRow += drow;
                    newCol += dcol;
                }
            }

            return moves;
        }

        // King moves
        function getKingMoves(row, col, color) {
            const moves = [];
            const offsets = [
                [-1, -1], [-1, 0], [-1, 1],
                [0, -1],           [0, 1],
                [1, -1],  [1, 0],  [1, 1]
            ];

            for (const [drow, dcol] of offsets) {
                const newRow = row + drow;
                const newCol = col + dcol;
                if (board[newRow]?.[newCol] !== undefined) {
                    const target = board[newRow][newCol];
                    if (target === '.') {
                        moves.push({ fromRow: row, fromCol: col, toRow: newRow, toCol: newCol });
                    } else {
                        const targetColor = target === target.toUpperCase() ? 'white' : 'black';
                        if (targetColor !== color) {
                            moves.push({ fromRow: row, fromCol: col, toRow: newRow, toCol: newCol });
                        }
                    }
                }
            }

            // Castling
            if (!isInCheck(color)) {
                const baseRow = color === 'white' ? 7 : 0;

                // Kingside castling
                if (castlingRights[color].kingside) {
                    if (board[baseRow][5] === '.' && board[baseRow][6] === '.') {
                        if (!wouldBeInCheck({ fromRow: row, fromCol: col, toRow: baseRow, toCol: 5 }, color)) {
                            moves.push({
                                fromRow: row,
                                fromCol: col,
                                toRow: baseRow,
                                toCol: 6,
                                castle: 'kingside'
                            });
                        }
                    }
                }

                // Queenside castling
                if (castlingRights[color].queenside) {
                    if (board[baseRow][3] === '.' && board[baseRow][2] === '.' && board[baseRow][1] === '.') {
                        if (!wouldBeInCheck({ fromRow: row, fromCol: col, toRow: baseRow, toCol: 3 }, color)) {
                            moves.push({
                                fromRow: row,
                                fromCol: col,
                                toRow: baseRow,
                                toCol: 2,
                                castle: 'queenside'
                            });
                        }
                    }
                }
            }

            return moves;
        }

        // Check if a move would leave the king in check
        function wouldBeInCheck(move, color) {
            const tempBoard = board.map(row => [...row]);
            const tempCastling = JSON.parse(JSON.stringify(castlingRights));
            const tempEnPassant = enPassantSquare;

            // Make the move temporarily
            const piece = tempBoard[move.fromRow][move.fromCol];
            tempBoard[move.toRow][move.toCol] = piece;
            tempBoard[move.fromRow][move.fromCol] = '.';

            // Handle en passant capture
            if (move.enPassant) {
                tempBoard[move.captureRow][move.captureCol] = '.';
            }

            // Check if king is in check
            const kingPos = findKing(tempBoard, color);
            const inCheck = isSquareUnderAttack(tempBoard, kingPos.row, kingPos.col, color);

            // Restore board
            board = board.map(row => [...row]);
            castlingRights = tempCastling;
            enPassantSquare = tempEnPassant;

            return inCheck;
        }

        // Find king position
        function findKing(boardState, color) {
            const king = color === 'white' ? 'K' : 'k';
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (boardState[row][col] === king) {
                        return { row, col };
                    }
                }
            }
            return null;
        }

        // Check if a square is under attack
        function isSquareUnderAttack(boardState, row, col, defenderColor) {
            const attackerColor = defenderColor === 'white' ? 'black' : 'white';

            // Check for pawn attacks
            const pawnDirection = attackerColor === 'white' ? 1 : -1;
            const attackerPawn = attackerColor === 'white' ? 'P' : 'p';
            for (const dcol of [-1, 1]) {
                const attackRow = row - pawnDirection;
                const attackCol = col + dcol;
                if (boardState[attackRow]?.[attackCol] === attackerPawn) {
                    return true;
                }
            }

            // Check for knight attacks
            const attackerKnight = attackerColor === 'white' ? 'N' : 'n';
            const knightOffsets = [
                [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                [1, -2], [1, 2], [2, -1], [2, 1]
            ];
            for (const [drow, dcol] of knightOffsets) {
                if (boardState[row + drow]?.[col + dcol] === attackerKnight) {
                    return true;
                }
            }

            // Check for sliding piece attacks (bishop, rook, queen)
            const directions = [
                [1, 1], [1, -1], [-1, 1], [-1, -1],  // Diagonal (bishop, queen)
                [1, 0], [-1, 0], [0, 1], [0, -1]      // Straight (rook, queen)
            ];

            for (const [drow, dcol] of directions) {
                let newRow = row + drow;
                let newCol = col + dcol;

                while (boardState[newRow]?.[newCol] !== undefined) {
                    const piece = boardState[newRow][newCol];
                    if (piece !== '.') {
                        const pieceColor = piece === piece.toUpperCase() ? 'white' : 'black';
                        if (pieceColor === attackerColor) {
                            const pieceType = piece.toUpperCase();
                            const isDiagonal = Math.abs(drow) === Math.abs(dcol) && drow !== 0;

                            if (pieceType === 'Q' ||
                                (pieceType === 'B' && isDiagonal) ||
                                (pieceType === 'R' && !isDiagonal) ||
                                (pieceType === 'K' && Math.abs(newRow - row) <= 1 && Math.abs(newCol - col) <= 1)) {
                                return true;
                            }
                        }
                        break;
                    }
                    newRow += drow;
                    newCol += dcol;
                }
            }

            return false;
        }

        // Check if a color is in check
        function isInCheck(color) {
            const kingPos = findKing(board, color);
            if (!kingPos) return false;
            return isSquareUnderAttack(board, kingPos.row, kingPos.col, color);
        }

        // Make a move
        function makeMove(move) {
            const piece = board[move.fromRow][move.fromCol];
            const captured = board[move.toRow][move.toCol];
            const pieceColor = piece === piece.toUpperCase() ? 'white' : 'black';
            const pieceType = piece.toUpperCase();

            // Store move for history
            const moveData = {
                move: move,
                piece: piece,
                captured: captured,
                castlingRights: JSON.parse(JSON.stringify(castlingRights)),
                enPassantSquare: enPassantSquare,
                halfMoveClock: halfMoveClock,
                board: board.map(row => [...row])
            };

            // Handle pawn promotion
            if (pieceType === 'P' && (move.toRow === 0 || move.toRow === 7)) {
                showPromotionDialog(move, pieceColor);
                return;
            }

            // Update half-move clock
            if (pieceType === 'P' || captured !== '.') {
                halfMoveClock = 0;
            } else {
                halfMoveClock++;
            }

            // Handle en passant
            if (move.enPassant) {
                const capturedPawn = board[move.captureRow][move.captureCol];
                board[move.captureRow][move.captureCol] = '.';
                capturedPieces[pieceColor === 'white' ? 'black' : 'white'].push(capturedPawn);
                playSound('capture');
            } else if (captured !== '.') {
                capturedPieces[pieceColor === 'white' ? 'black' : 'white'].push(captured);
                playSound('capture');
            } else {
                playSound('move');
            }

            // Set en passant square
            if (pieceType === 'P' && Math.abs(move.toRow - move.fromRow) === 2) {
                enPassantSquare = { row: (move.fromRow + move.toRow) / 2, col: move.toCol };
            } else {
                enPassantSquare = null;
            }

            // Handle castling
            if (move.castle) {
                const baseRow = pieceColor === 'white' ? 7 : 0;
                if (move.castle === 'kingside') {
                    board[baseRow][5] = board[baseRow][7];
                    board[baseRow][7] = '.';
                } else {
                    board[baseRow][3] = board[baseRow][0];
                    board[baseRow][0] = '.';
                }
                playSound('castle');
            }

            // Update castling rights
            if (pieceType === 'K') {
                castlingRights[pieceColor].kingside = false;
                castlingRights[pieceColor].queenside = false;
            }
            if (pieceType === 'R') {
                if (move.fromCol === 0) {
                    castlingRights[pieceColor].queenside = false;
                }
                if (move.fromCol === 7) {
                    castlingRights[pieceColor].kingside = false;
                }
            }

            // Make the move
            board[move.toRow][move.toCol] = piece;
            board[move.fromRow][move.fromCol] = '.';

            lastMove = move;

            // Update move history
            moveHistory.push(moveData);
            historyIndex = -1;

            // Switch turn
            if (currentTurn === 'black') {
                fullMoveNumber++;
            }
            currentTurn = currentTurn === 'white' ? 'black' : 'white';

            // Check for check
            if (isInCheck(currentTurn)) {
                playSound('check');
            }

            // Check for game over
            checkGameOver();

            renderBoard();
            updateStatus();
            updateMoveHistory();
            updateCapturedPieces();

            // AI move
            if (gameMode === 'ai' && !gameOver && currentTurn !== playerColor) {
                setTimeout(() => makeAIMove(), 500);
            }
        }

        // Show promotion dialog
        function showPromotionDialog(move, color) {
            const modal = document.getElementById('promotionModal');
            const piecesContainer = document.getElementById('promotionPieces');
            piecesContainer.innerHTML = '';

            const pieces = ['Q', 'R', 'B', 'N'];
            pieces.forEach(pieceType => {
                const pieceSymbol = color === 'white' ? PIECES[pieceType] : PIECES[pieceType.toLowerCase()];
                const pieceDiv = document.createElement('div');
                pieceDiv.className = 'promotion-piece';
                pieceDiv.textContent = pieceSymbol;
                pieceDiv.onclick = () => {
                    const promotedPiece = color === 'white' ? pieceType : pieceType.toLowerCase();
                    board[move.toRow][move.toCol] = promotedPiece;
                    board[move.fromRow][move.fromCol] = '.';

                    lastMove = move;

                    const captured = board[move.toRow][move.toCol];
                    moveHistory.push({
                        move: move,
                        piece: color === 'white' ? 'P' : 'p',
                        captured: captured,
                        promotion: promotedPiece,
                        castlingRights: JSON.parse(JSON.stringify(castlingRights)),
                        enPassantSquare: enPassantSquare,
                        halfMoveClock: halfMoveClock,
                        board: board.map(row => [...row])
                    });

                    currentTurn = currentTurn === 'white' ? 'black' : 'white';
                    if (currentTurn === 'white') {
                        fullMoveNumber++;
                    }

                    checkGameOver();
                    renderBoard();
                    updateStatus();
                    updateMoveHistory();

                    modal.classList.remove('active');

                    if (gameMode === 'ai' && !gameOver && currentTurn !== playerColor) {
                        setTimeout(() => makeAIMove(), 500);
                    }
                };
                piecesContainer.appendChild(pieceDiv);
            });

            modal.classList.add('active');
        }

        // Check if game is over
        function checkGameOver() {
            const hasLegalMoves = hasAnyLegalMoves(currentTurn);

            if (!hasLegalMoves) {
                if (isInCheck(currentTurn)) {
                    // Checkmate
                    gameOver = true;
                    const winner = currentTurn === 'white' ? 'Black' : 'White';
                    document.getElementById('status').textContent = `Checkmate! ${winner} wins!`;
                } else {
                    // Stalemate
                    gameOver = true;
                    document.getElementById('status').textContent = 'Stalemate! Draw.';
                }
            } else if (halfMoveClock >= 100) {
                // 50-move rule (100 half-moves)
                gameOver = true;
                document.getElementById('status').textContent = 'Draw by 50-move rule.';
            } else if (isInsufficientMaterial()) {
                gameOver = true;
                document.getElementById('status').textContent = 'Draw by insufficient material.';
            }
        }

        // Check if there are any legal moves
        function hasAnyLegalMoves(color) {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece !== '.') {
                        const pieceColor = piece === piece.toUpperCase() ? 'white' : 'black';
                        if (pieceColor === color) {
                            const moves = getLegalMoves(row, col);
                            if (moves.length > 0) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        // Check for insufficient material
        function isInsufficientMaterial() {
            const pieces = [];
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece !== '.' && piece.toUpperCase() !== 'K') {
                        pieces.push(piece.toUpperCase());
                    }
                }
            }

            // King vs King
            if (pieces.length === 0) return true;

            // King + minor piece vs King
            if (pieces.length === 1 && (pieces[0] === 'B' || pieces[0] === 'N')) return true;

            // King + Bishop vs King + Bishop (same color squares)
            if (pieces.length === 2 && pieces[0] === 'B' && pieces[1] === 'B') {
                // Would need to check if bishops are on same color squares, but this is rare
                return true;
            }

            return false;
        }

        // AI move using minimax with alpha-beta pruning
        function makeAIMove() {
            document.getElementById('thinking').innerHTML = '<div class="thinking">AI is thinking...</div>';

            setTimeout(() => {
                const depth = parseInt(aiDifficulty);
                const bestMove = findBestMove(depth);

                if (bestMove) {
                    makeMove(bestMove);
                }

                document.getElementById('thinking').innerHTML = '';
            }, 100);
        }

        // Find best move using minimax
        function findBestMove(depth) {
            let bestMove = null;
            let bestValue = -Infinity;
            const alpha = -Infinity;
            const beta = Infinity;

            const allMoves = getAllLegalMoves(currentTurn);

            for (const move of allMoves) {
                const tempBoard = board.map(row => [...row]);
                const tempCastling = JSON.parse(JSON.stringify(castlingRights));
                const tempEnPassant = enPassantSquare;
                const tempHalfMove = halfMoveClock;

                // Make move
                applyMove(move);

                // Evaluate
                const value = -minimax(depth - 1, -beta, -alpha, currentTurn === 'white' ? 'black' : 'white');

                // Undo move
                board = tempBoard;
                castlingRights = tempCastling;
                enPassantSquare = tempEnPassant;
                halfMoveClock = tempHalfMove;

                if (value > bestValue) {
                    bestValue = value;
                    bestMove = move;
                }
            }

            return bestMove;
        }

        // Minimax algorithm with alpha-beta pruning
        function minimax(depth, alpha, beta, maximizingColor) {
            if (depth === 0) {
                return evaluateBoard(maximizingColor);
            }

            const allMoves = getAllLegalMoves(maximizingColor);

            if (allMoves.length === 0) {
                if (isInCheck(maximizingColor)) {
                    return -10000; // Checkmate
                }
                return 0; // Stalemate
            }

            let maxValue = -Infinity;

            for (const move of allMoves) {
                const tempBoard = board.map(row => [...row]);
                const tempCastling = JSON.parse(JSON.stringify(castlingRights));
                const tempEnPassant = enPassantSquare;
                const tempHalfMove = halfMoveClock;

                applyMove(move);

                const value = -minimax(depth - 1, -beta, -alpha, maximizingColor === 'white' ? 'black' : 'white');

                board = tempBoard;
                castlingRights = tempCastling;
                enPassantSquare = tempEnPassant;
                halfMoveClock = tempHalfMove;

                maxValue = Math.max(maxValue, value);
                alpha = Math.max(alpha, value);

                if (alpha >= beta) {
                    break; // Beta cutoff
                }
            }

            return maxValue;
        }

        // Apply move (for AI evaluation)
        function applyMove(move) {
            const piece = board[move.fromRow][move.fromCol];
            const captured = board[move.toRow][move.toCol];
            const pieceType = piece.toUpperCase();

            if (pieceType === 'P' || captured !== '.') {
                halfMoveClock = 0;
            } else {
                halfMoveClock++;
            }

            if (move.enPassant) {
                board[move.captureRow][move.captureCol] = '.';
            }

            if (move.castle) {
                const pieceColor = piece === piece.toUpperCase() ? 'white' : 'black';
                const baseRow = pieceColor === 'white' ? 7 : 0;
                if (move.castle === 'kingside') {
                    board[baseRow][5] = board[baseRow][7];
                    board[baseRow][7] = '.';
                } else {
                    board[baseRow][3] = board[baseRow][0];
                    board[baseRow][0] = '.';
                }
            }

            board[move.toRow][move.toCol] = piece;
            board[move.fromRow][move.fromCol] = '.';
        }

        // Get all legal moves for a color
        function getAllLegalMoves(color) {
            const moves = [];
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece !== '.') {
                        const pieceColor = piece === piece.toUpperCase() ? 'white' : 'black';
                        if (pieceColor === color) {
                            moves.push(...getLegalMoves(row, col));
                        }
                    }
                }
            }
            return moves;
        }

        // Evaluate board position
        function evaluateBoard(color) {
            let score = 0;

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece !== '.') {
                        const pieceColor = piece === piece.toUpperCase() ? 'white' : 'black';
                        const pieceType = piece.toUpperCase();
                        const pieceValue = getPieceValue(pieceType);
                        const positionValue = getPositionValue(pieceType, row, col, pieceColor);

                        const totalValue = pieceValue + positionValue;

                        if (pieceColor === color) {
                            score += totalValue;
                        } else {
                            score -= totalValue;
                        }
                    }
                }
            }

            return score;
        }

        // Get piece value
        function getPieceValue(piece) {
            const values = { P: 100, N: 320, B: 330, R: 500, Q: 900, K: 20000 };
            return values[piece] || 0;
        }

        // Get position value from piece-square tables
        function getPositionValue(pieceType, row, col, color) {
            if (!PIECE_SQUARE_TABLES[pieceType]) return 0;

            const index = color === 'white' ? row * 8 + col : (7 - row) * 8 + col;
            return PIECE_SQUARE_TABLES[pieceType][index] / 10;
        }

        // Update status
        function updateStatus() {
            const statusElement = document.getElementById('status');

            if (gameOver) {
                statusElement.classList.remove('white-turn', 'black-turn');
                statusElement.classList.add('game-over');
                return;
            }

            statusElement.classList.remove('game-over');

            if (currentTurn === 'white') {
                statusElement.classList.add('white-turn');
                statusElement.classList.remove('black-turn');
                statusElement.textContent = 'White to move';
            } else {
                statusElement.classList.add('black-turn');
                statusElement.classList.remove('white-turn');
                statusElement.textContent = 'Black to move';
            }

            if (isInCheck(currentTurn)) {
                statusElement.textContent += ' (Check!)';
            }
        }

        // Update move history
        function updateMoveHistory() {
            const historyElement = document.getElementById('moveHistory');
            historyElement.innerHTML = '';

            for (let i = 0; i < moveHistory.length; i += 2) {
                const moveNumber = Math.floor(i / 2) + 1;
                const whiteMove = moveHistory[i];
                const blackMove = moveHistory[i + 1];

                const entry = document.createElement('div');
                entry.className = 'move-entry';
                if (historyIndex === i || historyIndex === i + 1) {
                    entry.classList.add('current');
                }

                const numberSpan = document.createElement('span');
                numberSpan.className = 'move-number';
                numberSpan.textContent = `${moveNumber}.`;

                const whiteSpan = document.createElement('span');
                whiteSpan.textContent = formatMove(whiteMove);
                whiteSpan.onclick = () => reviewMove(i);

                const blackSpan = document.createElement('span');
                if (blackMove) {
                    blackSpan.textContent = formatMove(blackMove);
                    blackSpan.onclick = () => reviewMove(i + 1);
                }

                entry.appendChild(numberSpan);
                entry.appendChild(whiteSpan);
                entry.appendChild(blackSpan);

                historyElement.appendChild(entry);
            }

            historyElement.scrollTop = historyElement.scrollHeight;
        }

        // Format move in algebraic notation
        function formatMove(moveData) {
            if (!moveData) return '';

            const move = moveData.move;
            const piece = moveData.piece;
            const pieceType = piece.toUpperCase();

            if (move.castle) {
                return move.castle === 'kingside' ? 'O-O' : 'O-O-O';
            }

            let notation = '';

            if (pieceType !== 'P') {
                notation += pieceType;
            }

            notation += String.fromCharCode(97 + move.fromCol);
            notation += 8 - move.fromRow;

            if (moveData.captured !== '.') {
                notation = pieceType === 'P' ? String.fromCharCode(97 + move.fromCol) + 'x' + String.fromCharCode(97 + move.toCol) + (8 - move.toRow) : notation + 'x' + String.fromCharCode(97 + move.toCol) + (8 - move.toRow);
            } else {
                notation += String.fromCharCode(97 + move.toCol);
                notation += 8 - move.toRow;
            }

            if (moveData.promotion) {
                notation += '=' + moveData.promotion.toUpperCase();
            }

            return notation;
        }

        // Review previous move
        function reviewMove(index) {
            historyIndex = index;
            board = moveHistory[index].board.map(row => [...row]);
            renderBoard();
            updateMoveHistory();
        }

        // Update captured pieces
        function updateCapturedPieces() {
            const capturedWhiteElement = document.getElementById('capturedWhite');
            const capturedBlackElement = document.getElementById('capturedBlack');
            const capturedTopElement = document.getElementById('capturedTop');
            const capturedBottomElement = document.getElementById('capturedBottom');

            capturedWhiteElement.innerHTML = capturedPieces.black.map(p => `<span class="captured-piece">${PIECES[p]}</span>`).join('');
            capturedBlackElement.innerHTML = capturedPieces.white.map(p => `<span class="captured-piece">${PIECES[p]}</span>`).join('');

            if (boardFlipped) {
                capturedTopElement.innerHTML = capturedWhiteElement.innerHTML;
                capturedBottomElement.innerHTML = capturedBlackElement.innerHTML;
            } else {
                capturedTopElement.innerHTML = capturedBlackElement.innerHTML;
                capturedBottomElement.innerHTML = capturedWhiteElement.innerHTML;
            }
        }

        // New game
        function newGame() {
            if (!gameOver && moveHistory.length > 0) {
                if (!confirm('Start a new game? Current game will be lost.')) {
                    return;
                }
            }

            gameMode = document.getElementById('gameMode').value;
            playerColor = document.getElementById('playerColor').value;
            aiDifficulty = parseInt(document.getElementById('aiDifficulty').value);
            soundEnabled = document.getElementById('soundToggle').value === 'on';

            initGame();
        }

        // Undo move
        function undoMove() {
            if (historyIndex !== -1) {
                // Go back to current position first
                historyIndex = -1;
                if (moveHistory.length > 0) {
                    const lastMove = moveHistory[moveHistory.length - 1];
                    board = lastMove.board.map(row => [...row]);
                }
                renderBoard();
                updateMoveHistory();
                return;
            }

            if (moveHistory.length === 0) return;

            // Undo the last move (or two moves if playing against AI)
            const undoCount = gameMode === 'ai' && moveHistory.length > 1 ? 2 : 1;

            for (let i = 0; i < undoCount && moveHistory.length > 0; i++) {
                const lastMove = moveHistory.pop();

                if (moveHistory.length > 0) {
                    const prevMove = moveHistory[moveHistory.length - 1];
                    board = prevMove.board.map(row => [...row]);
                    castlingRights = JSON.parse(JSON.stringify(prevMove.castlingRights));
                    enPassantSquare = prevMove.enPassantSquare;
                    halfMoveClock = prevMove.halfMoveClock;
                    lastMove.captured !== '.' && capturedPieces[currentTurn].pop();
                } else {
                    initGame();
                    return;
                }
            }

            currentTurn = currentTurn === 'white' ? 'black' : 'white';
            gameOver = false;

            renderBoard();
            updateStatus();
            updateMoveHistory();
            updateCapturedPieces();
        }

        // Resign
        function resign() {
            if (gameOver) return;
            if (!confirm('Resign the game?')) return;

            gameOver = true;
            const winner = currentTurn === 'white' ? 'Black' : 'White';
            document.getElementById('status').textContent = `${winner} wins by resignation!`;
            updateStatus();
        }

        // Offer draw
        function offerDraw() {
            if (gameOver) return;
            if (!confirm('Offer a draw?')) return;

            gameOver = true;
            document.getElementById('status').textContent = 'Draw accepted!';
            updateStatus();
        }

        // Flip board
        function flipBoard() {
            boardFlipped = !boardFlipped;
            renderBoard();
            updateCapturedPieces();
        }

        // Export PGN
        function showPGNExport() {
            const pgn = exportToPGN();
            document.getElementById('pgnModalTitle').textContent = 'Export PGN';
            document.getElementById('pgnText').value = pgn;
            document.getElementById('pgnText').readOnly = true;
            document.getElementById('importPGNBtn').style.display = 'none';
            document.getElementById('copyPGNBtn').style.display = 'inline-block';
            document.getElementById('pgnModal').classList.add('active');
        }

        // Export to PGN format
        function exportToPGN() {
            let pgn = '[Event "Chess Engine Game"]\n';
            pgn += `[Date "${new Date().toISOString().split('T')[0]}"]\n`;
            pgn += '[White "White"]\n';
            pgn += '[Black "Black"]\n';
            pgn += gameOver ? `[Result "${getGameResult()}"]\n\n` : '[Result "*"]\n\n';

            for (let i = 0; i < moveHistory.length; i += 2) {
                const moveNumber = Math.floor(i / 2) + 1;
                pgn += `${moveNumber}. ${formatMove(moveHistory[i])} `;
                if (moveHistory[i + 1]) {
                    pgn += `${formatMove(moveHistory[i + 1])} `;
                }
            }

            if (gameOver) {
                pgn += getGameResult();
            }

            return pgn;
        }

        // Get game result
        function getGameResult() {
            const status = document.getElementById('status').textContent;
            if (status.includes('White wins')) return '1-0';
            if (status.includes('Black wins')) return '0-1';
            if (status.includes('Draw') || status.includes('Stalemate')) return '1/2-1/2';
            return '*';
        }

        // Copy PGN to clipboard
        function copyPGN() {
            const pgnText = document.getElementById('pgnText');
            pgnText.select();
            document.execCommand('copy');
            alert('PGN copied to clipboard!');
        }

        // Show PGN import
        function showPGNImport() {
            document.getElementById('pgnModalTitle').textContent = 'Import PGN';
            document.getElementById('pgnText').value = '';
            document.getElementById('pgnText').readOnly = false;
            document.getElementById('importPGNBtn').style.display = 'inline-block';
            document.getElementById('copyPGNBtn').style.display = 'none';
            document.getElementById('pgnModal').classList.add('active');
        }

        // Import PGN
        function importPGN() {
            const pgnText = document.getElementById('pgnText').value;
            // PGN import would require a full PGN parser
            // For simplicity, we'll just show an alert
            alert('PGN import is not yet implemented. This feature requires a full PGN parser.');
            closePGNModal();
        }

        // Close PGN modal
        function closePGNModal() {
            document.getElementById('pgnModal').classList.remove('active');
        }

        // Event listeners
        document.getElementById('gameMode').addEventListener('change', (e) => {
            const pvpMode = e.target.value === 'pvp';
            document.getElementById('playerColorRow').style.display = pvpMode ? 'none' : 'flex';
            document.getElementById('difficultyRow').style.display = pvpMode ? 'none' : 'flex';
        });

        // Initialize on load
        window.addEventListener('load', () => {
            initGame();
        });
    </script>
</body>
</html>