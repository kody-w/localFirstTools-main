{
  "console": "creep-siege",
  "name": "Creep Siege",
  "year": 2026,
  "icon": "üëπ",
  "theme": {
    "bg": "#0a1a0a",
    "accent": "#ff4444"
  },
  "render": {
    "width": 256,
    "height": 224,
    "scanlines": false,
    "scanlineAlpha": 0.02
  },
  "audio": {
    "type": "synth",
    "channels": 4
  },
  "games": [
    {
      "id": "creep-siege",
      "name": "Creep Siege: Ancient Offensive",
      "icon": "üëπ",
      "desc": "You ARE the creep wave. Spawn monsters, evolve mid-run, overwhelm adaptive tower defenses across 20 waves",
      "code": "if (mode === 'init') {\nG.GW = 16; G.GH = 14; G.TS = 16;\nG.wave = 1; G.maxWave = 20;\nG.phase = 'spawn';\nG.gold = 50; G.totalGold = 50;\nG.score = 0;\nG.lives = 3;\nG.reached = 0;\nG.waveTimer = 0;\nG.shake = 0; G.flash = 0; G.flashC = '#fff';\nG.kcd = 0; G.selIdx = 0;\nG.particles = [];\nG.dmgNums = [];\nG.showEvolve = false;\nG.grid = [];\nfor (var y = 0; y < G.GH; y++) {\nG.grid[y] = [];\nfor (var x = 0; x < G.GW; x++) G.grid[y][x] = 1;\n}\nfor (var x = 0; x < G.GW; x++) { G.grid[1][x] = 0; G.grid[2][x] = 0; }\nfor (var x = 0; x < G.GW; x++) { G.grid[6][x] = 0; G.grid[7][x] = 0; }\nfor (var x = 0; x < G.GW; x++) { G.grid[11][x] = 0; G.grid[12][x] = 0; }\nfor (var y = 2; y <= 6; y++) G.grid[y][3] = 0;\nfor (var y = 7; y <= 11; y++) G.grid[y][4] = 0;\nfor (var y = 2; y <= 6; y++) G.grid[y][12] = 0;\nfor (var y = 7; y <= 11; y++) G.grid[y][11] = 0;\nfor (var y = 3; y <= 5; y++) G.grid[y][8] = 0;\nfor (var y = 8; y <= 10; y++) G.grid[y][8] = 0;\nG.grid[1][0] = 2; G.grid[6][0] = 2; G.grid[11][0] = 2;\nG.grid[1][15] = 3; G.grid[7][15] = 3; G.grid[12][15] = 3;\nG.flowField = [];\nfor (var y = 0; y < G.GH; y++) {\nG.flowField[y] = [];\nfor (var x = 0; x < G.GW; x++) G.flowField[y][x] = null;\n}\nvar queue = [];\nvar visited = [];\nfor (var y = 0; y < G.GH; y++) { visited[y] = []; for (var x = 0; x < G.GW; x++) visited[y][x] = false; }\nfor (var y = 0; y < G.GH; y++) {\nfor (var x = 0; x < G.GW; x++) {\nif (G.grid[y][x] === 3) { queue.push({x:x, y:y, dist:0}); visited[y][x] = true; G.flowField[y][x] = {dx:0, dy:0, dist:0}; }\n}\n}\nvar dirs = [{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];\nwhile (queue.length > 0) {\nvar cur = queue.shift();\nfor (var d = 0; d < 4; d++) {\nvar nx = cur.x + dirs[d].dx, ny = cur.y + dirs[d].dy;\nif (nx >= 0 && nx < G.GW && ny >= 0 && ny < G.GH && !visited[ny][nx] && G.grid[ny][nx] !== 1) {\nvisited[ny][nx] = true;\nG.flowField[ny][nx] = { dx: -dirs[d].dx, dy: -dirs[d].dy, dist: cur.dist + 1 };\nqueue.push({x:nx, y:ny, dist:cur.dist+1});\n}\n}\n}\nG.towers = [];\nG.towerTypes = {\narrow:   { name:'Arrow',   dmg:8,  rate:30, range:48,  color:'#44aaff', projSpd:4, projC:'#88ccff', slow:0 },\ncannon:  { name:'Cannon',  dmg:25, rate:60, range:40,  color:'#ff8844', projSpd:2.5, projC:'#ffaa44', slow:0, splash:20 },\nfrost:   { name:'Frost',   dmg:5,  rate:40, range:52,  color:'#88ffff', projSpd:3, projC:'#aaffff', slow:0.5 },\nvenom:   { name:'Venom',   dmg:3,  rate:35, range:44,  color:'#44ff44', projSpd:3, projC:'#88ff88', slow:0, dot:4 },\narcane:  { name:'Arcane',  dmg:15, rate:50, range:56,  color:'#cc44ff', projSpd:3.5, projC:'#dd88ff', slow:0, manaburn:1 }\n};\nG.projectiles = [];\nG.creeps = [];\nG.creepTypes = [\n{ id:'melee',  name:'Melee Creep',  icon:'‚ôü', hp:40,  speed:0.8, cost:5,  armor:1, magic:0, reward:3, desc:'Balanced fighter' },\n{ id:'ranged', name:'Ranged Creep',  icon:'‚ôú', hp:25,  speed:0.7, cost:7,  armor:0, magic:1, reward:4, desc:'Magic resistant' },\n{ id:'siege',  name:'Siege Creep',   icon:'‚ôû', hp:80,  speed:0.5, cost:12, armor:3, magic:0, reward:6, desc:'Heavy armor tank' },\n{ id:'speed',  name:'Phase Creep',   icon:'‚ôù', hp:20,  speed:1.5, cost:8,  armor:0, magic:0, reward:5, desc:'Blazing speed' },\n{ id:'mega',   name:'Mega Creep',    icon:'‚ôõ', hp:150, speed:0.4, cost:25, armor:2, magic:2, reward:12, desc:'Unstoppable force' }\n];\nG.evolutions = [];\nG.evoPool = [\n{ id:'hp1',      name:'Vitality+',    desc:'All creeps +15% HP',       icon:'‚ô•', apply:function(){G.creepTypes.forEach(function(c){c.hp=Math.ceil(c.hp*1.15)})} },\n{ id:'hp2',      name:'Vitality++',   desc:'All creeps +25% HP',       icon:'‚ô•‚ô•', apply:function(){G.creepTypes.forEach(function(c){c.hp=Math.ceil(c.hp*1.25)})} },\n{ id:'spd1',     name:'Swiftness+',   desc:'All creeps +15% speed',    icon:'¬ª', apply:function(){G.creepTypes.forEach(function(c){c.speed*=1.15})} },\n{ id:'arm1',     name:'Armor+',       desc:'All creeps +1 armor',      icon:'‚óÜ', apply:function(){G.creepTypes.forEach(function(c){c.armor+=1})} },\n{ id:'arm2',     name:'Armor++',      desc:'All creeps +2 armor',      icon:'‚óÜ‚óÜ', apply:function(){G.creepTypes.forEach(function(c){c.armor+=2})} },\n{ id:'mag1',     name:'Magic Shell',  desc:'All creeps +1 magic res',  icon:'‚úß', apply:function(){G.creepTypes.forEach(function(c){c.magic+=1})} },\n{ id:'regen1',   name:'Regen',        desc:'Creeps heal 1hp/sec',      icon:'‚ôª', apply:function(){G._regen=(G._regen||0)+1} },\n{ id:'thorns',   name:'Thorns',       desc:'Towers take 5 dmg on hit', icon:'‚ö°', apply:function(){G._thorns=(G._thorns||0)+5} },\n{ id:'gold1',    name:'Plunder',      desc:'+5 gold per wave',         icon:'$', apply:function(){G._bonusGold=(G._bonusGold||0)+5} },\n{ id:'discount', name:'Efficiency',   desc:'Creep costs -20%',         icon:'‚Üì', apply:function(){G.creepTypes.forEach(function(c){c.cost=Math.max(1,Math.ceil(c.cost*0.8))})} },\n{ id:'splash1',  name:'Scatter',      desc:'Creeps split into 2 on death', icon:'√∑', apply:function(){G._splitOnDeath=(G._splitOnDeath||0)+1} },\n{ id:'invis',    name:'Shadow Walk',  desc:'Phase Creeps get 2s invis on spawn', icon:'‚óå', apply:function(){G._invisTime=(G._invisTime||0)+120} },\n{ id:'mega1',    name:'Ancient Power',desc:'Mega Creeps +50% HP',      icon:'‚ôõ+', apply:function(){var m=G.creepTypes.find(function(c){return c.id==='mega'});if(m)m.hp=Math.ceil(m.hp*1.5)} },\n{ id:'lifesteal',name:'Vampiric',     desc:'Creeps heal 20% of tower dmg taken', icon:'ü¶á', apply:function(){G._lifesteal=(G._lifesteal||0)+0.2} }\n];\nG.evoChoices = null;\nG.aiMemory = { melee:0, ranged:0, siege:0, speed:0, mega:0 };\nG._regen = 0; G._thorns = 0; G._bonusGold = 0;\nG._splitOnDeath = 0; G._invisTime = 0; G._lifesteal = 0;\nG.spawnQueue = [];\nG.spawnTimer = 0;\nG.spawnLane = 1;\nG.laneRows = [1, 6, 11];\nG.placeTowers = function(w) {\nvar budget = 2 + Math.floor(w * 1.5);\nvar spots = [];\nfor (var y = 0; y < G.GH; y++) {\nfor (var x = 0; x < G.GW; x++) {\nif (G.grid[y][x] !== 1) continue;\nvar adj = false;\nfor (var d = 0; d < 4; d++) {\nvar nx = x+dirs[d].dx, ny = y+dirs[d].dy;\nif (nx>=0&&nx<G.GW&&ny>=0&&ny<G.GH&&G.grid[ny][nx]===0) adj = true;\n}\nif (adj && !G.towers.some(function(t){return t.gx===x&&t.gy===y})) spots.push({x:x,y:y});\n}\n}\nfor (var i = spots.length - 1; i > 0; i--) { var j = Math.floor(Math.random()*(i+1)); var t=spots[i]; spots[i]=spots[j]; spots[j]=t; }\nvar typeKeys = Object.keys(G.towerTypes);\nfor (var i = 0; i < Math.min(budget, spots.length); i++) {\nvar s = spots[i];\nvar pick = 'arrow';\nif (G.aiMemory.siege > G.aiMemory.melee && Math.random() < 0.6) pick = 'venom';\nelse if (G.aiMemory.speed > 3 && Math.random() < 0.5) pick = 'frost';\nelse if (G.aiMemory.ranged > G.aiMemory.melee && Math.random() < 0.4) pick = 'arcane';\nelse if (G.aiMemory.mega > 2 && Math.random() < 0.5) pick = 'cannon';\nelse pick = typeKeys[Math.floor(Math.random() * typeKeys.length)];\nvar tt = G.towerTypes[pick];\nG.towers.push({\ngx: s.x, gy: s.y,\nx: s.x * G.TS + G.TS/2, y: s.y * G.TS + G.TS/2,\ntype: pick, hp: 60 + w * 10, maxHp: 60 + w * 10,\ndmg: Math.ceil(tt.dmg * (1 + w * 0.12)),\nrate: Math.max(10, tt.rate - Math.floor(w * 0.5)),\nrange: tt.range + Math.floor(w * 0.5),\ncolor: tt.color, projSpd: tt.projSpd, projC: tt.projC,\nslow: tt.slow, dot: tt.dot || 0, splash: tt.splash || 0,\nmanaburn: tt.manaburn || 0,\ncooldown: 0\n});\n}\n};\nG.placeTowers(1);\nG.waveCreepsAlive = 0;\nG.waveComplete = false;\n}\nif (mode === 'update') {\nif (G.phase === 'victory' || G.phase === 'defeat') return;\nG.kcd = Math.max(0, G.kcd - 1);\nG.shake = Math.max(0, G.shake - 0.4);\nG.flash = Math.max(0, G.flash - 2);\nvar spd = (dt || 0.016) * 60;\nG.particles = G.particles.filter(function(p) {\np.x += p.vx; p.y += p.vy; p.vy += (p.grav || 0); p.life--; return p.life > 0;\n});\nG.dmgNums = G.dmgNums.filter(function(d) { d.y -= 0.5; d.life--; return d.life > 0; });\nif (G.phase === 'spawn') {\nif ((K('w') || K('ArrowUp')) && G.kcd <= 0) {\nG.spawnLane = (G.spawnLane + 2) % 3; G.kcd = 10; snd.beep();\n}\nif ((K('s') || K('ArrowDown')) && G.kcd <= 0) {\nG.spawnLane = (G.spawnLane + 1) % 3; G.kcd = 10; snd.beep();\n}\nif ((K('a') || K('ArrowLeft')) && G.kcd <= 0) {\nG.selIdx = (G.selIdx + G.creepTypes.length - 1) % G.creepTypes.length; G.kcd = 10; snd.beep();\n}\nif ((K('d') || K('ArrowRight')) && G.kcd <= 0) {\nG.selIdx = (G.selIdx + 1) % G.creepTypes.length; G.kcd = 10; snd.beep();\n}\nif ((K(' ') || K('Enter')) && G.kcd <= 0) {\nvar ct = G.creepTypes[G.selIdx];\nif (G.gold >= ct.cost) {\nG.gold -= ct.cost;\nG.spawnQueue.push({ type: ct.id, lane: G.spawnLane });\nG.aiMemory[ct.id] = (G.aiMemory[ct.id] || 0) + 1;\nsnd.pickup();\nG.kcd = 8;\n} else {\nsnd.tone(100, 0.05, 0.05); G.kcd = 15;\n}\n}\nif (K('f') && G.spawnQueue.length > 0 && G.kcd <= 0) {\nG.phase = 'battle';\nG.reached = 0;\nG.waveCreepsAlive = G.spawnQueue.length;\nG.spawnTimer = 0;\nG.waveComplete = false;\nsnd.tone(300, 0.1, 0.08);\nG.kcd = 20;\n}\nreturn;\n}\nif (G.phase === 'evolve') {\nif (!G.evoChoices) {\nvar pool = G.evoPool.slice();\nfor (var i = pool.length - 1; i > 0; i--) { var j = Math.floor(Math.random()*(i+1)); var t=pool[i]; pool[i]=pool[j]; pool[j]=t; }\nG.evoChoices = pool.slice(0, 3);\nG.selIdx = 0;\n}\nif ((K('w') || K('ArrowUp')) && G.kcd <= 0) { G.selIdx = (G.selIdx + 2) % 3; G.kcd = 10; snd.beep(); }\nif ((K('s') || K('ArrowDown')) && G.kcd <= 0) { G.selIdx = (G.selIdx + 1) % 3; G.kcd = 10; snd.beep(); }\nif ((K(' ') || K('Enter')) && G.kcd <= 0) {\nvar chosen = G.evoChoices[G.selIdx];\nchosen.apply();\nG.evolutions.push(chosen.id);\nG.evoChoices = null;\nG.flash = 20; G.flashC = '#ff4444';\nsnd.score();\nG.wave++;\nif (G.wave > G.maxWave) {\nG.phase = 'victory'; G.score += G.gold * 10;\nsnd.win(); return;\n}\nG.gold += 30 + G.wave * 5 + (G._bonusGold || 0);\nG.totalGold += 30 + G.wave * 5 + (G._bonusGold || 0);\nG.spawnQueue = [];\nG.placeTowers(G.wave);\nG.phase = 'spawn';\nG.kcd = 20;\n}\nreturn;\n}\nif (G.phase === 'battle') {\nG.spawnTimer -= spd;\nif (G.spawnTimer <= 0 && G.spawnQueue.length > 0) {\nvar sq = G.spawnQueue.shift();\nvar ct = G.creepTypes.find(function(c) { return c.id === sq.type; });\nif (ct) {\nvar ly = G.laneRows[sq.lane];\nvar creep = {\nx: 4, y: ly * G.TS + G.TS / 2,\ngx: 0, gy: ly,\nhp: ct.hp, maxHp: ct.hp,\nspeed: ct.speed,\narmor: ct.armor, magic: ct.magic,\ntype: ct.id, icon: ct.icon,\nreward: ct.reward,\nslowTimer: 0, dotTimer: 0, dotDmg: 0,\ninvisTimer: ct.id === 'speed' ? (G._invisTime || 0) : 0\n};\nG.creeps.push(creep);\n}\nG.spawnTimer = 15;\n}\nG.creeps.forEach(function(c) {\nvar spdMult = 1;\nif (c.slowTimer > 0) { c.slowTimer -= spd; spdMult = 0.5; }\nif (c.dotTimer > 0) { c.dotTimer -= spd; c.hp -= c.dotDmg * (dt || 0.016); }\nif (c.invisTimer > 0) c.invisTimer -= spd;\nif (G._regen > 0) c.hp = Math.min(c.maxHp, c.hp + G._regen * (dt || 0.016));\nvar gx = Math.floor(c.x / G.TS);\nvar gy = Math.floor(c.y / G.TS);\ngx = Math.max(0, Math.min(G.GW - 1, gx));\ngy = Math.max(0, Math.min(G.GH - 1, gy));\nc.gx = gx; c.gy = gy;\nvar flow = G.flowField[gy] && G.flowField[gy][gx];\nif (flow) {\nvar tx = (gx + flow.dx) * G.TS + G.TS / 2;\nvar ty = (gy + flow.dy) * G.TS + G.TS / 2;\nvar dx = tx - c.x, dy = ty - c.y;\nvar dist = Math.sqrt(dx * dx + dy * dy);\nif (dist > 1) {\nc.x += (dx / dist) * c.speed * spdMult * spd;\nc.y += (dy / dist) * c.speed * spdMult * spd;\n}\n}\nif (G.grid[gy] && G.grid[gy][gx] === 3) {\nc.hp = 0;\nG.reached++;\nG.score += 50 * G.wave;\nsnd.score();\nG.flash = 10; G.flashC = '#44ff44';\nfor (var i = 0; i < 8; i++)\nG.particles.push({ x:c.x, y:c.y, vx:(Math.random()-0.5)*4, vy:(Math.random()-0.5)*4, life:20, c:'#44ff44', s:2, grav:0 });\n}\n});\nG.towers.forEach(function(t) {\nt.cooldown = Math.max(0, t.cooldown - spd);\nif (t.cooldown > 0 || t.hp <= 0) return;\nvar best = null, bd = 9999;\nG.creeps.forEach(function(c) {\nif (c.hp <= 0 || c.invisTimer > 0) return;\nvar dx = c.x - t.x, dy = c.y - t.y;\nvar dist = Math.sqrt(dx*dx + dy*dy);\nif (dist < t.range && dist < bd) { best = c; bd = dist; }\n});\nif (best) {\nt.cooldown = t.rate;\nvar dx = best.x - t.x, dy = best.y - t.y;\nvar dist = Math.sqrt(dx*dx + dy*dy);\nG.projectiles.push({\nx: t.x, y: t.y,\nvx: (dx/dist) * t.projSpd, vy: (dy/dist) * t.projSpd,\ndmg: t.dmg, color: t.projC,\nslow: t.slow, dot: t.dot, splash: t.splash, manaburn: t.manaburn,\nlife: 60, owner: t\n});\n}\n});\nG.projectiles = G.projectiles.filter(function(p) {\np.x += p.vx * spd; p.y += p.vy * spd; p.life -= spd;\nfor (var i = 0; i < G.creeps.length; i++) {\nvar c = G.creeps[i];\nif (c.hp <= 0) continue;\nvar dx = p.x - c.x, dy = p.y - c.y;\nif (Math.sqrt(dx*dx + dy*dy) < 8) {\nvar dmg = p.dmg;\nif (p.manaburn) dmg = Math.max(1, dmg - c.magic * 3);\nelse dmg = Math.max(1, dmg - c.armor * 2);\nc.hp -= dmg;\nG.dmgNums.push({ x:c.x, y:c.y-8, v:Math.floor(dmg), life:25, c:'#ff4444' });\nif (p.slow > 0) c.slowTimer = Math.max(c.slowTimer, 60);\nif (p.dot > 0) { c.dotTimer = 90; c.dotDmg = p.dot; }\nif (p.splash > 0) {\nG.creeps.forEach(function(c2) {\nif (c2 === c || c2.hp <= 0) return;\nvar d2 = Math.sqrt((c2.x-p.x)*(c2.x-p.x)+(c2.y-p.y)*(c2.y-p.y));\nif (d2 < p.splash) {\nvar sd = Math.max(1, Math.floor(dmg * 0.5));\nc2.hp -= sd;\nG.dmgNums.push({ x:c2.x, y:c2.y-8, v:sd, life:20, c:'#ff8844' });\n}\n});\nfor (var j = 0; j < 6; j++)\nG.particles.push({ x:p.x, y:p.y, vx:(Math.random()-0.5)*3, vy:(Math.random()-0.5)*3, life:12, c:'#ff8844', s:2, grav:0 });\n}\nif (G._thorns > 0 && p.owner) {\np.owner.hp -= G._thorns;\nG.dmgNums.push({ x:p.owner.x, y:p.owner.y-8, v:G._thorns, life:20, c:'#ffff44' });\n}\nif (G._lifesteal > 0) {\nc.hp = Math.min(c.maxHp, c.hp + dmg * G._lifesteal);\n}\nG.particles.push({ x:c.x, y:c.y, vx:(Math.random()-0.5)*2, vy:-1-Math.random()*2, life:10, c:p.color, s:2, grav:0.1 });\nsnd.tone(350 + Math.random()*100, 0.02, 0.02);\nreturn false;\n}\n}\nreturn p.life > 0;\n});\nG.creeps = G.creeps.filter(function(c) {\nif (c.hp <= 0) {\nG.waveCreepsAlive--;\nif (G._splitOnDeath > 0 && c.type !== 'split') {\nfor (var s = 0; s < G._splitOnDeath; s++) {\nG.creeps.push({\nx: c.x + (Math.random()-0.5)*8, y: c.y + (Math.random()-0.5)*8,\ngx: c.gx, gy: c.gy,\nhp: Math.ceil(c.maxHp * 0.3), maxHp: Math.ceil(c.maxHp * 0.3),\nspeed: c.speed * 1.2, armor: 0, magic: 0,\ntype: 'split', icon: '¬∑', reward: 0,\nslowTimer: 0, dotTimer: 0, dotDmg: 0, invisTimer: 0\n});\nG.waveCreepsAlive++;\n}\n}\nfor (var i = 0; i < 5; i++)\nG.particles.push({ x:c.x, y:c.y, vx:(Math.random()-0.5)*3, vy:(Math.random()-0.5)*3, life:15, c:'#ff4444', s:1.5, grav:0.05 });\nreturn false;\n}\nreturn true;\n});\nG.towers = G.towers.filter(function(t) {\nif (t.hp <= 0) {\nG.score += 25;\nfor (var i = 0; i < 6; i++)\nG.particles.push({ x:t.x, y:t.y, vx:(Math.random()-0.5)*3, vy:-Math.random()*3, life:20, c:t.color, s:2, grav:0.1 });\nsnd.explode();\nreturn false;\n}\nreturn true;\n});\nif (G.spawnQueue.length === 0 && G.creeps.length === 0 && !G.waveComplete) {\nG.waveComplete = true;\nif (G.reached >= G.lives) {\nG.score += G.reached * 100;\nG.gold += G.reached * 5;\nG.flash = 20; G.flashC = '#44ff44';\nsnd.win();\nG.phase = 'evolve';\n} else {\nG.score += G.reached * 30;\nG.flash = 15; G.flashC = '#ff4444';\nG.shake = 8;\nsnd.die();\nG.gold += 15;\nG.spawnQueue = [];\nG.phase = 'spawn';\n}\n}\n}\n}\nif (mode === 'draw') {\nvar sx = G.shake > 0 ? (Math.random()-0.5)*G.shake*2 : 0;\nvar sy = G.shake > 0 ? (Math.random()-0.5)*G.shake*2 : 0;\nO.save(); O.translate(sx, sy);\ncls('#0a1a0a');\nfor (var y = 0; y < G.GH; y++) {\nfor (var x = 0; x < G.GW; x++) {\nvar cell = G.grid[y][x];\nvar px = x * G.TS, py = y * G.TS;\nif (cell === 1) {\nO.fillStyle = (x + y) % 2 === 0 ? '#1a2a1a' : '#152515';\nO.fillRect(px, py, G.TS, G.TS);\n} else if (cell === 0) {\nO.fillStyle = '#2a2215';\nO.fillRect(px, py, G.TS, G.TS);\nO.fillStyle = '#332a1a';\nO.fillRect(px + 1, py + 1, G.TS - 2, G.TS - 2);\nif (y === 1 || y === 6 || y === 11) {\nO.fillStyle = 'rgba(255,200,100,0.05)';\nO.fillRect(px, py + G.TS - 1, G.TS, 1);\n}\n} else if (cell === 2) {\nO.fillStyle = '#1a3a1a';\nO.fillRect(px, py, G.TS, G.TS);\nO.fillStyle = 'rgba(68,255,68,' + (0.2 + Math.sin(G.waveTimer * 0.05) * 0.1) + ')';\nO.fillRect(px + 2, py + 2, G.TS - 4, G.TS - 4);\n} else if (cell === 3) {\nO.fillStyle = '#2a1a1a';\nO.fillRect(px, py, G.TS, G.TS);\nO.fillStyle = 'rgba(255,68,68,' + (0.3 + Math.sin(G.waveTimer * 0.03) * 0.15) + ')';\nO.fillRect(px + 1, py + 1, G.TS - 2, G.TS - 2);\ntxt('‚öë', px + G.TS/2, py + G.TS/2, 8, '#ff4444');\n}\n}\n}\nvar laneNames = ['TOP', 'MID', 'BOT'];\nvar laneYs = [1, 6, 11];\nfor (var i = 0; i < 3; i++) {\nvar ly = laneYs[i] * G.TS + G.TS;\nO.fillStyle = 'rgba(255,255,255,0.08)';\ntxt(laneNames[i], 3, ly, 5, 'rgba(255,255,255,0.15)', 'left');\n}\nG.towers.forEach(function(t) {\nif (t.hp <= 0) return;\nO.fillStyle = '#333';\nO.fillRect(t.x - 5, t.y - 5, 10, 10);\nO.fillStyle = t.color;\nO.fillRect(t.x - 4, t.y - 6, 8, 8);\nO.fillStyle = t.color;\nO.fillRect(t.x - 2, t.y - 8, 4, 3);\nif (G.phase === 'spawn') {\nO.strokeStyle = 'rgba(255,255,255,0.04)';\nO.beginPath(); O.arc(t.x, t.y, t.range, 0, Math.PI*2); O.stroke();\n}\nif (t.hp < t.maxHp) {\nO.fillStyle = '#333'; O.fillRect(t.x-5, t.y+6, 10, 2);\nO.fillStyle = t.hp/t.maxHp > 0.5 ? '#44ff44' : '#ff4444';\nO.fillRect(t.x-5, t.y+6, Math.floor(10*t.hp/t.maxHp), 2);\n}\n});\nG.projectiles.forEach(function(p) {\nO.fillStyle = p.color;\nO.fillRect(p.x - 1.5, p.y - 1.5, 3, 3);\nO.fillStyle = p.color + '44';\nO.fillRect(p.x - p.vx - 1, p.y - p.vy - 1, 2, 2);\n});\nG.creeps.forEach(function(c) {\nif (c.hp <= 0) return;\nif (c.invisTimer > 0) {\nO.globalAlpha = 0.2;\n}\nO.fillStyle = 'rgba(0,0,0,0.3)';\nO.fillRect(c.x - 3, c.y + 3, 6, 2);\nvar colors = { melee:'#cc8844', ranged:'#4488cc', siege:'#888888', speed:'#88ff88', mega:'#ff4488', split:'#aa6644' };\nO.fillStyle = colors[c.type] || '#aa8844';\nif (c.type === 'mega') {\nO.fillRect(c.x - 5, c.y - 6, 10, 10);\nO.fillStyle = '#ff88aa';\nO.fillRect(c.x - 3, c.y - 8, 6, 3);\n} else if (c.type === 'siege') {\nO.fillRect(c.x - 4, c.y - 4, 8, 8);\nO.fillStyle = '#aaa';\nO.fillRect(c.x - 5, c.y - 2, 10, 4);\n} else {\nO.fillRect(c.x - 3, c.y - 4, 6, 7);\nO.fillStyle = '#ffccaa';\nO.fillRect(c.x - 2, c.y - 6, 4, 3);\n}\nif (c.slowTimer > 0) {\nO.strokeStyle = '#88ffff'; O.lineWidth = 1;\nO.strokeRect(c.x - 4, c.y - 5, 8, 9);\n}\nif (c.dotTimer > 0) {\nO.fillStyle = 'rgba(68,255,68,0.4)';\nO.fillRect(c.x - 1, c.y - 7, 2, 2);\n}\nO.globalAlpha = 1;\nif (c.hp < c.maxHp) {\nO.fillStyle = '#333'; O.fillRect(c.x - 5, c.y - 9, 10, 2);\nO.fillStyle = c.hp / c.maxHp > 0.5 ? '#44ff44' : (c.hp / c.maxHp > 0.25 ? '#ffaa00' : '#ff4444');\nO.fillRect(c.x - 5, c.y - 9, Math.max(1, Math.floor(10 * c.hp / c.maxHp)), 2);\n}\n});\nG.particles.forEach(function(p) {\nO.fillStyle = p.c || '#fff';\nO.fillRect(p.x - (p.s||1)/2, p.y - (p.s||1)/2, p.s||1, p.s||1);\n});\nG.dmgNums.forEach(function(d) {\ntxt(String(d.v), d.x, d.y, 7, d.c);\n});\nif (G.flash > 0) {\nO.fillStyle = G.flashC + Math.min(255,Math.floor(G.flash*5)).toString(16).padStart(2,'0');\nO.fillRect(0, 0, RW, RH);\n}\nrect(0, 0, RW, 12, 'rgba(0,0,0,0.7)');\ntxt('Wave ' + G.wave + '/' + G.maxWave, 40, 7, 7, '#ff4444', 'left');\ntxt('Gold: ' + G.gold, 110, 7, 7, '#daa520', 'left');\ntxt('Score: ' + G.score, 180, 7, 7, '#aaa', 'left');\nfor (var i = 0; i < G.lives; i++) {\ntxt('‚öë', RW - 8 - i * 10, 7, 6, i < G.reached ? '#44ff44' : '#444');\n}\nif (G.phase === 'spawn') {\nG.waveTimer += (dt||0.016)*60;\nfor (var i = 0; i < 3; i++) {\nvar ly = G.laneRows[i] * G.TS;\nif (i === G.spawnLane) {\nO.strokeStyle = 'rgba(68,255,68,0.6)';\nO.lineWidth = 2;\nO.strokeRect(0, ly - 1, 16, G.TS * 2 + 2);\ntxt('‚ñ∫', 8, ly + G.TS, 10, '#44ff44');\n}\n}\nvar qCounts = [0,0,0];\nG.spawnQueue.forEach(function(sq) { qCounts[sq.lane]++; });\nfor (var i = 0; i < 3; i++) {\nif (qCounts[i] > 0) {\ntxt('√ó' + qCounts[i], 22, G.laneRows[i] * G.TS + G.TS, 6, '#44ff44', 'left');\n}\n}\nrect(0, RH - 42, RW, 42, 'rgba(0,0,0,0.85)');\nO.strokeStyle = '#444'; O.lineWidth = 1;\nO.strokeRect(0, RH - 42, RW, 1);\nvar panelY = RH - 38;\ntxt('DEPLOY CREEPS', RW/2, panelY, 7, '#ff4444');\npanelY += 10;\nfor (var i = 0; i < G.creepTypes.length; i++) {\nvar ct = G.creepTypes[i];\nvar bx = 8 + i * 50;\nvar sel = i === G.selIdx;\nvar afford = G.gold >= ct.cost;\nrect(bx, panelY, 46, 22, sel ? 'rgba(255,68,68,0.2)' : 'rgba(40,40,40,0.5)');\nif (sel) { O.strokeStyle = '#ff4444'; O.strokeRect(bx, panelY, 46, 22); }\ntxt(ct.icon, bx + 8, panelY + 8, 8, afford ? '#fff' : '#555');\ntxt(ct.name.split(' ')[0], bx + 23, panelY + 7, 5, sel ? '#fff' : '#aaa', 'left');\ntxt(ct.cost + 'g', bx + 23, panelY + 15, 5, afford ? '#daa520' : '#664400', 'left');\n}\ntxt('A/D Select ¬∑ W/S Lane ¬∑ Space Queue ¬∑ F Launch', RW/2, RH - 4, 5, '#666');\nif (G.spawnQueue.length > 0) {\ntxt('Queue: ' + G.spawnQueue.length + ' creeps', RW/2, panelY - 5, 6, '#888');\n}\n}\nif (G.phase === 'evolve' && G.evoChoices) {\nO.fillStyle = 'rgba(0,0,0,0.85)';\nO.fillRect(0, 0, RW, RH);\ntxt('WAVE ' + G.wave + ' COMPLETE!', RW/2, 25, 12, '#44ff44');\ntxt(G.reached + ' creeps breached the ancient', RW/2, 40, 7, '#aaa');\ntxt('‚îÅ‚îÅ‚îÅ EVOLVE ‚îÅ‚îÅ‚îÅ', RW/2, 58, 8, '#ff4444');\nfor (var i = 0; i < 3; i++) {\nvar evo = G.evoChoices[i];\nvar y = 75 + i * 40;\nvar sel = i === G.selIdx;\nrect(30, y - 10, 196, 32, sel ? 'rgba(255,68,68,0.2)' : 'rgba(30,30,30,0.8)');\nif (sel) { O.strokeStyle = '#ff4444'; O.lineWidth = 1; O.strokeRect(30, y - 10, 196, 32); }\ntxt(evo.icon, 50, y + 2, 10, sel ? '#ff8888' : '#888');\ntxt(evo.name, 72, y - 2, 8, sel ? '#fff' : '#aaa', 'left');\ntxt(evo.desc, 72, y + 10, 6, sel ? '#ccc' : '#777', 'left');\n}\ntxt('W/S + Enter to choose', RW/2, RH - 15, 6, '#666');\nif (G.evolutions.length > 0) {\ntxt('Evolved: ' + G.evolutions.join(', '), RW/2, RH - 6, 5, '#553333');\n}\n}\nif (G.phase === 'battle') {\nG.waveTimer += (dt||0.016)*60;\nvar total = G.waveCreepsAlive + G.creeps.length;\nrect(0, RH - 6, RW, 6, 'rgba(0,0,0,0.6)');\nif (total > 0) {\nrect(0, RH - 6, Math.floor(RW * G.creeps.length / Math.max(1, total)), 6, 'rgba(255,68,68,0.4)');\n}\ntxt('Alive: ' + G.creeps.length + ' | Breached: ' + G.reached + '/' + G.lives, RW/2, RH - 3, 5, '#aaa');\n}\nif (G.phase === 'victory') {\nO.fillStyle = 'rgba(0,0,0,0.8)';\nO.fillRect(0, 0, RW, RH);\ntxt('ANCIENT DESTROYED', RW/2, RH/2 - 30, 14, '#ff4444');\ntxt('All 20 waves conquered!', RW/2, RH/2 - 10, 8, '#aaa');\ntxt('Final Score: ' + G.score, RW/2, RH/2 + 10, 10, '#daa520');\ntxt('Evolutions: ' + G.evolutions.length, RW/2, RH/2 + 28, 7, '#888');\nvar ey = RH/2 + 42;\nG.evolutions.forEach(function(e, i) {\nif (i > 5) return;\ntxt(e, 50 + (i % 6) * 28, ey, 5, '#ff8888');\n});\n}\nif (G.phase === 'defeat') {\nO.fillStyle = 'rgba(0,0,0,0.8)';\nO.fillRect(0, 0, RW, RH);\ntxt('CREEPS VANQUISHED', RW/2, RH/2 - 15, 14, '#444');\ntxt('Wave ' + G.wave + ' proved too much', RW/2, RH/2 + 5, 8, '#888');\ntxt('Score: ' + G.score, RW/2, RH/2 + 25, 10, '#daa520');\n}\nO.restore();\nvar phaseNames = { spawn:'DEPLOY', battle:'BATTLE', evolve:'EVOLVE', victory:'VICTORY', defeat:'DEFEAT' };\nhud('Wave ' + G.wave + '/' + G.maxWave + ' | ' + phaseNames[G.phase] + ' | Gold:' + G.gold + ' | Score:' + G.score);\ncontrols(G.phase==='spawn' ? 'A/D Creep ¬∑ W/S Lane ¬∑ Space Queue ¬∑ F Launch' : G.phase==='evolve' ? 'W/S + Enter Choose' : 'Watch the battle!');\n}"
    }
  ]
}