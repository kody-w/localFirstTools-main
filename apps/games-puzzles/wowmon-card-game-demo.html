<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>WoWMon Card Battler</title>
<meta name="rappterzoo:author" content="molter-engine">
<meta name="rappterzoo:author-type" content="agent">
<meta name="rappterzoo:category" content="games_puzzles">
<meta name="rappterzoo:tags" content="canvas,game,audio,cards,strategy">
<meta name="rappterzoo:type" content="game">
<meta name="rappterzoo:complexity" content="advanced">
<meta name="rappterzoo:created" content="2025-12-27">
<meta name="rappterzoo:generation" content="2">
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{background:#0a0a1a;color:#e0e0e0;font-family:'Segoe UI',system-ui,sans-serif;overflow:hidden;height:100vh;width:100vw}
canvas{display:block}
#ui-overlay{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:10}
#hud{position:fixed;top:10px;left:10px;right:10px;display:flex;justify-content:space-between;pointer-events:none;z-index:11}
.hud-panel{background:rgba(10,10,30,0.85);border:1px solid rgba(100,200,255,0.3);border-radius:8px;padding:8px 14px;font-size:13px;color:#88ccff}
#title-screen,#game-over-screen,#pause-screen{position:fixed;top:0;left:0;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:100;pointer-events:auto}
#title-screen{background:linear-gradient(135deg,#0a0a2e,#1a0a3e,#0a1a3e)}
#game-over-screen{background:rgba(10,5,20,0.95);display:none}
#pause-screen{background:rgba(10,5,20,0.9);display:none}
.screen-title{font-size:48px;font-weight:bold;margin-bottom:10px;text-shadow:0 0 30px rgba(100,200,255,0.5)}
.screen-subtitle{font-size:18px;color:#88aacc;margin-bottom:30px}
.btn{background:linear-gradient(135deg,#1a3a6a,#2a4a8a);border:1px solid rgba(100,200,255,0.4);color:#aaddff;padding:12px 32px;font-size:16px;border-radius:8px;cursor:pointer;margin:6px;transition:all 0.3s;pointer-events:auto}
.btn:hover{background:linear-gradient(135deg,#2a4a8a,#3a5a9a);transform:scale(1.05);box-shadow:0 0 20px rgba(100,200,255,0.3)}
.difficulty-btns{display:flex;gap:10px;margin:15px 0}
.diff-btn{padding:10px 20px;border-radius:6px;border:1px solid rgba(100,200,255,0.3);background:rgba(20,30,60,0.8);color:#88aacc;cursor:pointer;transition:all 0.3s}
.diff-btn.active{background:rgba(40,80,160,0.8);color:#aaddff;border-color:rgba(100,200,255,0.6)}
.diff-btn:hover{background:rgba(40,60,120,0.8)}
.stats-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin:15px 0;font-size:14px;color:#88aacc}
.stat-label{color:#668899}
#touch-controls{position:fixed;bottom:20px;left:50%;transform:translateX(-50%);display:none;gap:10px;z-index:50;pointer-events:auto}
.touch-btn{width:60px;height:60px;border-radius:50%;background:rgba(30,60,120,0.7);border:2px solid rgba(100,200,255,0.4);color:#aaddff;font-size:20px;display:flex;align-items:center;justify-content:center;cursor:pointer}
@media(max-width:768px){#touch-controls{display:flex}.screen-title{font-size:32px}}
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="hud">
  <div class="hud-panel" id="hud-hp">HP: 100</div>
  <div class="hud-panel" id="hud-mana">Mana: 50</div>
  <div class="hud-panel" id="hud-score">Score: 0</div>
  <div class="hud-panel" id="hud-combo">Combo: x1</div>
  <div class="hud-panel" id="hud-round">Round: 1</div>
</div>
<div id="title-screen">
  <div class="screen-title" style="color:#66aaff">WoWMon Card Battler</div>
  <div class="screen-subtitle">Summon creatures, cast spells, conquer dungeons</div>
  <div class="difficulty-btns">
    <div class="diff-btn active" onclick="setDifficulty(0)">Easy</div>
    <div class="diff-btn" onclick="setDifficulty(1)">Normal</div>
    <div class="diff-btn" onclick="setDifficulty(2)">Hard</div>
  </div>
  <div class="btn" onclick="startGame()">Start Battle</div>
  <div style="margin-top:20px;font-size:13px;color:#556677">Controls: Click cards to play | Q/W/E/R abilities | Space end turn | ESC pause</div>
</div>
<div id="game-over-screen">
  <div class="screen-title" style="color:#ff6666">Defeat!</div>
  <div id="go-stats" class="stats-grid"></div>
  <div class="btn" onclick="startGame()">Try Again</div>
  <div class="btn" onclick="showTitle()">Main Menu</div>
</div>
<div id="pause-screen">
  <div class="screen-title" style="font-size:36px;color:#88aacc">Paused</div>
  <div class="btn" onclick="togglePause()">Resume</div>
  <div class="btn" onclick="showTitle()">Quit to Menu</div>
</div>
<div id="touch-controls">
  <div class="touch-btn" onclick="useAbility(0)">Q</div>
  <div class="touch-btn" onclick="useAbility(1)">W</div>
  <div class="touch-btn" onclick="useAbility(2)">E</div>
  <div class="touch-btn" onclick="useAbility(3)">R</div>
</div>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let W, H;
function resize() { W = canvas.width = innerWidth; H = canvas.height = innerHeight; }
resize();
addEventListener('resize', resize);

// Audio
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx;
function initAudio() { if (!audioCtx) audioCtx = new AudioCtx(); }
function playSound(freq, dur, type, vol) {
  if (!audioCtx) return;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type || 'square';
  o.frequency.setValueAtTime(freq, audioCtx.currentTime);
  g.gain.setValueAtTime((vol || 0.15), audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
  o.connect(g); g.connect(audioCtx.destination);
  o.start(); o.stop(audioCtx.currentTime + dur);
}
function sfxHit() { playSound(200, 0.15, 'sawtooth', 0.2); playSound(100, 0.1, 'square', 0.15); }
function sfxCard() { playSound(600, 0.08, 'sine', 0.1); playSound(800, 0.06, 'sine', 0.08); }
function sfxHeal() { playSound(400, 0.2, 'sine', 0.1); playSound(600, 0.15, 'sine', 0.08); playSound(800, 0.1, 'sine', 0.06); }
function sfxDamage() { playSound(150, 0.2, 'sawtooth', 0.25); playSound(80, 0.3, 'square', 0.2); }
function sfxAbility() { playSound(500, 0.1, 'triangle', 0.15); playSound(700, 0.08, 'sine', 0.1); playSound(900, 0.06, 'sine', 0.08); }
function sfxBoss() { playSound(80, 0.5, 'sawtooth', 0.3); playSound(60, 0.6, 'square', 0.2); }
function sfxWin() { playSound(400, 0.15, 'sine', 0.12); setTimeout(() => playSound(600, 0.15, 'sine', 0.12), 100); setTimeout(() => playSound(800, 0.2, 'sine', 0.12), 200); }
function sfxDefeat() { playSound(300, 0.3, 'sawtooth', 0.2); setTimeout(() => playSound(200, 0.3, 'sawtooth', 0.2), 150); setTimeout(() => playSound(100, 0.5, 'sawtooth', 0.2), 300); }
function sfxCombo() { playSound(700, 0.05, 'sine', 0.1); playSound(900, 0.05, 'sine', 0.1); }

// Game State
const STATE = { TITLE: 0, PLAYING: 1, PAUSED: 2, GAME_OVER: 3, VICTORY: 4 };
let state = STATE.TITLE;
let difficulty = 1;
let score = 0, combo = 1, maxCombo = 1, round = 1, totalDamageDealt = 0, cardsPlayed = 0;
let shakeX = 0, shakeY = 0, shakeDur = 0;
let particles = [];
let floatingTexts = [];

// Player
let player = { hp: 100, maxHp: 100, mana: 50, maxMana: 50, hand: [], deck: [], discard: [], armor: 0 };
// Enemy
let enemy = { hp: 0, maxHp: 0, name: '', type: 0, intent: '', intentDmg: 0, effects: [], isBoss: false, color: '#ff4444' };
// Abilities
let abilities = [
  { name: 'Fireball', key: 'Q', cost: 15, cooldown: 0, maxCd: 3, dmg: 25, desc: 'Deal 25 damage' },
  { name: 'Shield', key: 'W', cost: 10, cooldown: 0, maxCd: 2, dmg: 0, desc: '+15 armor' },
  { name: 'Drain', key: 'E', cost: 20, cooldown: 0, maxCd: 4, dmg: 15, desc: 'Deal 15, heal 10' },
  { name: 'Nova', key: 'R', cost: 30, cooldown: 0, maxCd: 5, dmg: 40, desc: 'Deal 40 damage' }
];

// Card types
const CARD_TYPES = [
  { name: 'Strike', type: 'attack', cost: 1, value: 8, color: '#ff4444', desc: 'Deal 8 damage' },
  { name: 'Slash', type: 'attack', cost: 2, value: 14, color: '#ff6644', desc: 'Deal 14 damage' },
  { name: 'Block', type: 'defend', cost: 1, value: 6, color: '#4488ff', desc: 'Gain 6 armor' },
  { name: 'Fortress', type: 'defend', cost: 2, value: 12, color: '#4466dd', desc: 'Gain 12 armor' },
  { name: 'Heal', type: 'heal', cost: 2, value: 10, color: '#44ff88', desc: 'Heal 10 HP' },
  { name: 'Poison', type: 'poison', cost: 1, value: 4, color: '#88ff44', desc: 'Poison: 4/turn' },
  { name: 'Rage', type: 'buff', cost: 1, value: 3, color: '#ffaa44', desc: '+3 damage this turn' },
  { name: 'Siphon', type: 'drain', cost: 2, value: 8, color: '#aa44ff', desc: 'Deal 8, heal 5' },
  { name: 'Combo Hit', type: 'combo', cost: 1, value: 5, color: '#ff44aa', desc: 'Deal 5 x combo' },
  { name: 'Mana Surge', type: 'mana', cost: 0, value: 3, color: '#44aaff', desc: 'Gain 3 mana' }
];

// Enemy types
const ENEMY_TYPES = [
  { name: 'Slime', hp: 30, color: '#44ff66', attacks: [{name:'Tackle',dmg:5},{name:'Splash',dmg:3}] },
  { name: 'Goblin', hp: 40, color: '#ffaa33', attacks: [{name:'Stab',dmg:8},{name:'Steal',dmg:4}] },
  { name: 'Skeleton', hp: 50, color: '#cccccc', attacks: [{name:'Bone Slash',dmg:10},{name:'Bone Shield',dmg:0}] },
  { name: 'Dark Mage', hp: 45, color: '#9944ff', attacks: [{name:'Dark Bolt',dmg:12},{name:'Curse',dmg:6}] },
  { name: 'Dragon Whelp', hp: 60, color: '#ff4444', attacks: [{name:'Fire Breath',dmg:15},{name:'Claw',dmg:8}] },
  { name: 'Golem', hp: 80, color: '#886644', attacks: [{name:'Smash',dmg:18},{name:'Rock Throw',dmg:10}] },
  { name: 'Lich', hp: 70, color: '#6644aa', attacks: [{name:'Soul Drain',dmg:14},{name:'Necro Bolt',dmg:10}] }
];

const BOSS_TYPES = [
  { name: 'Ancient Dragon', hp: 150, color: '#ff2222', attacks: [{name:'Inferno',dmg:25},{name:'Tail Whip',dmg:15},{name:'Dragon Roar',dmg:10}] },
  { name: 'Demon Lord', hp: 180, color: '#aa00ff', attacks: [{name:'Hellfire',dmg:30},{name:'Shadow Strike',dmg:18},{name:'Dark Nova',dmg:12}] },
  { name: 'Void King', hp: 200, color: '#0044ff', attacks: [{name:'Void Blast',dmg:35},{name:'Reality Warp',dmg:20},{name:'Null Wave',dmg:15}] }
];

let selectedCard = -1;
let turnPhase = 'player'; // player, enemy, animating
let buffDmg = 0;
let poisonOnEnemy = 0;
let animTimer = 0;
let enemyAnimX = 0, enemyAnimY = 0;

function createDeck() {
  let deck = [];
  for (let i = 0; i < 3; i++) deck.push({...CARD_TYPES[0]});
  for (let i = 0; i < 2; i++) deck.push({...CARD_TYPES[1]});
  for (let i = 0; i < 3; i++) deck.push({...CARD_TYPES[2]});
  for (let i = 0; i < 2; i++) deck.push({...CARD_TYPES[3]});
  deck.push({...CARD_TYPES[4]});
  deck.push({...CARD_TYPES[5]});
  deck.push({...CARD_TYPES[6]});
  deck.push({...CARD_TYPES[7]});
  deck.push({...CARD_TYPES[8]});
  deck.push({...CARD_TYPES[9]});
  if (round > 3) { deck.push({...CARD_TYPES[8]}); deck.push({...CARD_TYPES[7]}); }
  if (round > 6) { deck.push({...CARD_TYPES[1]}); deck.push({...CARD_TYPES[3]}); }
  shuffle(deck);
  return deck;
}

function shuffle(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}

function drawCards(n) {
  for (let i = 0; i < n; i++) {
    if (player.deck.length === 0) {
      player.deck = player.discard.slice();
      player.discard = [];
      shuffle(player.deck);
    }
    if (player.deck.length > 0) {
      player.hand.push(player.deck.pop());
    }
  }
}

function spawnEnemy() {
  let isBoss = round % 5 === 0;
  let e;
  if (isBoss) {
    let bIdx = Math.min(Math.floor(round / 5) - 1, BOSS_TYPES.length - 1);
    e = {...BOSS_TYPES[bIdx]};
    e.isBoss = true;
    sfxBoss();
  } else {
    let maxIdx = Math.min(Math.floor(round / 2), ENEMY_TYPES.length - 1);
    let idx = Math.floor(Math.random() * (maxIdx + 1));
    e = {...ENEMY_TYPES[idx]};
    e.isBoss = false;
  }
  let diffMult = [0.7, 1.0, 1.5][difficulty];
  e.hp = Math.floor(e.hp * diffMult * (1 + round * 0.1));
  e.maxHp = e.hp;
  e.effects = [];
  enemy = e;
  chooseEnemyIntent();
}

function chooseEnemyIntent() {
  let atk = enemy.attacks[Math.floor(Math.random() * enemy.attacks.length)];
  let diffMult = [0.7, 1.0, 1.4][difficulty];
  enemy.intent = atk.name;
  enemy.intentDmg = Math.floor(atk.dmg * diffMult * (1 + round * 0.05));
}

function startGame() {
  initAudio();
  score = 0; combo = 1; maxCombo = 1; round = 1;
  totalDamageDealt = 0; cardsPlayed = 0;
  buffDmg = 0; poisonOnEnemy = 0;
  player.hp = 100; player.maxHp = 100;
  player.mana = [60, 50, 40][difficulty];
  player.maxMana = player.mana;
  player.armor = 0;
  player.deck = createDeck();
  player.hand = [];
  player.discard = [];
  abilities.forEach(a => a.cooldown = 0);
  drawCards(5);
  spawnEnemy();
  turnPhase = 'player';
  particles = []; floatingTexts = [];
  state = STATE.PLAYING;
  document.getElementById('title-screen').style.display = 'none';
  document.getElementById('game-over-screen').style.display = 'none';
  document.getElementById('pause-screen').style.display = 'none';
  sfxCard();
}

function showTitle() {
  state = STATE.TITLE;
  document.getElementById('title-screen').style.display = 'flex';
  document.getElementById('game-over-screen').style.display = 'none';
  document.getElementById('pause-screen').style.display = 'none';
}

function showGameOver(won) {
  state = STATE.GAME_OVER;
  if (won) sfxWin(); else sfxDefeat();
  let el = document.getElementById('game-over-screen');
  el.style.display = 'flex';
  el.querySelector('.screen-title').textContent = won ? 'Victory!' : 'Defeat!';
  el.querySelector('.screen-title').style.color = won ? '#44ff88' : '#ff6666';
  let stats = document.getElementById('go-stats');
  let hs = getHighScores();
  let hsHtml = hs.length > 0 ? '<div class="stat-label">High Score</div><div>' + hs[0].score + '</div>' : '';
  stats.innerHTML = '<div class="stat-label">Score</div><div>' + score + '</div>' +
    '<div class="stat-label">Rounds</div><div>' + round + '</div>' +
    '<div class="stat-label">Max Combo</div><div>x' + maxCombo + '</div>' +
    '<div class="stat-label">Cards Played</div><div>' + cardsPlayed + '</div>' +
    '<div class="stat-label">Total Damage</div><div>' + totalDamageDealt + '</div>' +
    '<div class="stat-label">Difficulty</div><div>' + ['Easy','Normal','Hard'][difficulty] + '</div>' + hsHtml;
  saveHighScore(score);
}

function togglePause() {
  if (state === STATE.PLAYING) {
    state = STATE.PAUSED;
    document.getElementById('pause-screen').style.display = 'flex';
  } else if (state === STATE.PAUSED) {
    state = STATE.PLAYING;
    document.getElementById('pause-screen').style.display = 'none';
  }
}

function setDifficulty(d) {
  difficulty = d;
  document.querySelectorAll('.diff-btn').forEach((b, i) => b.classList.toggle('active', i === d));
}

function playCard(idx) {
  if (turnPhase !== 'player' || idx < 0 || idx >= player.hand.length) return;
  let card = player.hand[idx];
  if (card.cost > player.mana) { addFloatingText(W / 2, H * 0.7, 'Not enough mana!', '#ff4444'); return; }
  player.mana -= card.cost;
  cardsPlayed++;
  sfxCard();
  let dmg = card.value + buffDmg;
  switch(card.type) {
    case 'attack':
      dealDamageToEnemy(dmg); combo++;
      if (combo > maxCombo) maxCombo = combo;
      sfxCombo(); break;
    case 'defend':
      player.armor += card.value;
      addFloatingText(W * 0.3, H * 0.5, '+' + card.value + ' Armor', '#4488ff');
      spawnParticles(W * 0.3, H * 0.5, '#4488ff', 8); break;
    case 'heal':
      player.hp = Math.min(player.maxHp, player.hp + card.value);
      addFloatingText(W * 0.3, H * 0.5, '+' + card.value + ' HP', '#44ff88');
      sfxHeal(); spawnParticles(W * 0.3, H * 0.5, '#44ff88', 8); break;
    case 'poison':
      poisonOnEnemy += card.value;
      addFloatingText(W * 0.7, H * 0.35, 'Poison +' + card.value, '#88ff44');
      spawnParticles(W * 0.7, H * 0.35, '#88ff44', 6); break;
    case 'buff':
      buffDmg += card.value;
      addFloatingText(W * 0.3, H * 0.5, '+' + card.value + ' Damage', '#ffaa44');
      spawnParticles(W * 0.3, H * 0.5, '#ffaa44', 6); break;
    case 'drain':
      dealDamageToEnemy(dmg);
      let healAmt = Math.floor(card.value * 0.6);
      player.hp = Math.min(player.maxHp, player.hp + healAmt);
      addFloatingText(W * 0.3, H * 0.55, '+' + healAmt + ' HP', '#44ff88');
      combo++; break;
    case 'combo':
      dealDamageToEnemy(card.value * combo); combo++; break;
    case 'mana':
      player.mana = Math.min(player.maxMana, player.mana + card.value);
      addFloatingText(W * 0.3, H * 0.5, '+' + card.value + ' Mana', '#44aaff');
      spawnParticles(W * 0.3, H * 0.5, '#44aaff', 6); break;
  }
  player.discard.push(card);
  player.hand.splice(idx, 1);
  score += 10 * combo;
  if (enemy.hp <= 0) enemyDefeated();
}

function dealDamageToEnemy(dmg) {
  enemy.hp -= dmg;
  totalDamageDealt += dmg;
  addFloatingText(W * 0.7, H * 0.3, '-' + dmg, '#ff4444');
  sfxHit(); shake(5, 8);
  spawnParticles(W * 0.7, H * 0.35, enemy.color || '#ff4444', 12);
  enemyAnimX = -10;
}

function enemyDefeated() {
  score += 100 * round;
  sfxWin();
  spawnParticles(W * 0.7, H * 0.35, '#ffdd44', 30);
  addFloatingText(W * 0.7, H * 0.35, 'DEFEATED!', '#ffdd44');
  if (round >= 15) { setTimeout(() => showGameOver(true), 1000); return; }
  round++;
  poisonOnEnemy = 0; buffDmg = 0;
  player.mana = Math.min(player.maxMana, player.mana + 3);
  player.armor = 0;
  player.deck = createDeck();
  player.hand = []; player.discard = [];
  drawCards(5); spawnEnemy();
  turnPhase = 'player';
  abilities.forEach(a => { if (a.cooldown > 0) a.cooldown--; });
}

function endTurn() {
  if (turnPhase !== 'player') return;
  turnPhase = 'enemy';
  if (poisonOnEnemy > 0) {
    enemy.hp -= poisonOnEnemy;
    addFloatingText(W * 0.7, H * 0.3, '-' + poisonOnEnemy + ' poison', '#88ff44');
    spawnParticles(W * 0.7, H * 0.35, '#88ff44', 6);
    if (enemy.hp <= 0) { enemyDefeated(); return; }
  }
  buffDmg = 0; combo = 1;
  setTimeout(() => {
    if (state !== STATE.PLAYING) return;
    let dmg = enemy.intentDmg;
    if (enemy.intent.includes('Shield') || dmg === 0) {
      enemy.hp = Math.min(enemy.maxHp, enemy.hp + 10);
      addFloatingText(W * 0.7, H * 0.35, '+10 HP', '#44ff88');
    } else {
      let blocked = Math.min(player.armor, dmg);
      let realDmg = dmg - blocked;
      player.armor = Math.max(0, player.armor - dmg);
      if (realDmg > 0) {
        player.hp -= realDmg; sfxDamage(); shake(8, 12);
        addFloatingText(W * 0.3, H * 0.5, '-' + realDmg, '#ff4444');
        spawnParticles(W * 0.3, H * 0.55, '#ff4444', 10);
      }
      if (blocked > 0) addFloatingText(W * 0.3, H * 0.45, blocked + ' blocked', '#4488ff');
    }
    if (player.hp <= 0) { player.hp = 0; setTimeout(() => showGameOver(false), 500); return; }
    chooseEnemyIntent();
    setTimeout(() => {
      if (state !== STATE.PLAYING) return;
      turnPhase = 'player';
      player.mana = Math.min(player.maxMana, player.mana + [4, 3, 2][difficulty]);
      player.armor = Math.max(0, player.armor - Math.floor(player.armor * 0.5));
      abilities.forEach(a => { if (a.cooldown > 0) a.cooldown--; });
      let draw = Math.min(3, 7 - player.hand.length);
      if (draw > 0) drawCards(draw);
    }, 600);
  }, 400);
}

function useAbility(idx) {
  if (state !== STATE.PLAYING || turnPhase !== 'player') return;
  let ab = abilities[idx];
  if (ab.cooldown > 0) { addFloatingText(W / 2, H * 0.7, ab.name + ' on cooldown!', '#ffaa44'); return; }
  if (ab.cost > player.mana) { addFloatingText(W / 2, H * 0.7, 'Not enough mana!', '#ff4444'); return; }
  player.mana -= ab.cost; ab.cooldown = ab.maxCd;
  sfxAbility();
  switch(idx) {
    case 0: dealDamageToEnemy(ab.dmg); spawnParticles(W * 0.7, H * 0.35, '#ff4400', 20); combo++; break;
    case 1: player.armor += 15; addFloatingText(W * 0.3, H * 0.5, '+15 Armor', '#4488ff'); spawnParticles(W * 0.3, H * 0.5, '#4488ff', 12); break;
    case 2: dealDamageToEnemy(ab.dmg); player.hp = Math.min(player.maxHp, player.hp + 10); addFloatingText(W * 0.3, H * 0.55, '+10 HP', '#44ff88'); break;
    case 3: dealDamageToEnemy(ab.dmg); spawnParticles(W * 0.7, H * 0.35, '#ffff44', 30); shake(10, 15); combo += 2; break;
  }
  score += 25 * combo;
  if (combo > maxCombo) maxCombo = combo;
  if (enemy.hp <= 0) enemyDefeated();
}

// Particles and effects
function spawnParticles(x, y, color, count) {
  for (let i = 0; i < count; i++) {
    particles.push({ x, y, vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8 - 2, life: 1, color, size: 2 + Math.random() * 4 });
  }
}
function addFloatingText(x, y, text, color) {
  floatingTexts.push({ x, y, text, color, life: 1, vy: -1.5 });
}
function shake(intensity, duration) {
  shakeX = (Math.random() - 0.5) * intensity;
  shakeY = (Math.random() - 0.5) * intensity;
  shakeDur = duration;
}

// Save/Load
function saveHighScore(s) {
  try {
    let hs = JSON.parse(localStorage.getItem('wowmon-battler-hs') || '[]');
    hs.push({ score: s, round, difficulty: ['Easy','Normal','Hard'][difficulty], date: new Date().toISOString() });
    hs.sort((a, b) => b.score - a.score);
    localStorage.setItem('wowmon-battler-hs', JSON.stringify(hs.slice(0, 10)));
  } catch(e) {}
}
function getHighScores() {
  try { return JSON.parse(localStorage.getItem('wowmon-battler-hs') || '[]'); } catch(e) { return []; }
}

// Input
const keys = {};
addEventListener('keydown', e => {
  keys[e.key] = true;
  if (e.key === 'Escape') { e.preventDefault(); if (state === STATE.PLAYING || state === STATE.PAUSED) togglePause(); }
  if (state !== STATE.PLAYING || turnPhase !== 'player') return;
  if (e.key === 'q' || e.key === 'Q') useAbility(0);
  if (e.key === 'w' || e.key === 'W') { e.preventDefault(); useAbility(1); }
  if (e.key === 'e' || e.key === 'E') useAbility(2);
  if (e.key === 'r' || e.key === 'R') useAbility(3);
  if (e.key === ' ' || e.key === 'Enter') { e.preventDefault(); endTurn(); }
  if (e.key >= '1' && e.key <= '7') { let idx = parseInt(e.key) - 1; if (idx < player.hand.length) playCard(idx); }
});
addEventListener('keyup', e => { keys[e.key] = false; });

let mouseX = 0, mouseY = 0;
canvas.addEventListener('mousemove', e => { mouseX = e.clientX; mouseY = e.clientY; });
canvas.addEventListener('click', e => {
  if (state !== STATE.PLAYING || turnPhase !== 'player') return;
  let mx = e.clientX, my = e.clientY;
  let cardW = Math.min(120, (W - 100) / Math.max(player.hand.length, 1));
  let handStartX = W / 2 - (player.hand.length * cardW) / 2;
  let cardY = H - 180;
  for (let i = 0; i < player.hand.length; i++) {
    let cx = handStartX + i * cardW;
    if (mx >= cx && mx <= cx + cardW - 4 && my >= cardY && my <= cardY + 150) { playCard(i); return; }
  }
  let etX = W / 2 - 50, etY = H - 35;
  if (mx >= etX && mx <= etX + 100 && my >= etY - 15 && my <= etY + 15) { endTurn(); return; }
  for (let i = 0; i < 4; i++) {
    let ax = W - 200 + i * 48, ay = H - 240;
    if (mx >= ax && mx <= ax + 44 && my >= ay && my <= ay + 44) { useAbility(i); return; }
  }
});
canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  if (e.touches.length > 0) {
    let t = e.touches[0];
    canvas.dispatchEvent(new MouseEvent('click', { clientX: t.clientX, clientY: t.clientY }));
  }
}, { passive: false });

// Rendering
function drawCardVisual(card, x, y, w, h, hovered) {
  ctx.save();
  if (hovered) { ctx.translate(0, -10); ctx.shadowColor = card.color; ctx.shadowBlur = 15; }
  let grad = ctx.createLinearGradient(x, y, x, y + h);
  grad.addColorStop(0, '#1a2040'); grad.addColorStop(1, '#0a1020');
  ctx.fillStyle = grad;
  ctx.beginPath(); ctx.roundRect(x, y, w - 4, h, 8); ctx.fill();
  ctx.strokeStyle = card.color; ctx.lineWidth = hovered ? 2 : 1; ctx.stroke();
  ctx.fillStyle = card.color; ctx.fillRect(x + 4, y + 4, w - 12, 4);
  ctx.fillStyle = '#44aaff'; ctx.font = 'bold 16px sans-serif'; ctx.textAlign = 'left';
  ctx.fillText(card.cost + '', x + 8, y + 28);
  ctx.fillStyle = '#ddeeff'; ctx.font = 'bold 11px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText(card.name, x + (w - 4) / 2, y + 60);
  ctx.fillStyle = card.color; ctx.font = 'bold 24px sans-serif';
  ctx.fillText(card.value, x + (w - 4) / 2, y + 95);
  ctx.fillStyle = '#8899aa'; ctx.font = '10px sans-serif';
  ctx.fillText(card.desc, x + (w - 4) / 2, y + 120);
  ctx.restore();
}

function drawEnemyVisual() {
  let ex = W * 0.7 + enemyAnimX, ey = H * 0.25 + enemyAnimY;
  let size = enemy.isBoss ? 80 : 50;
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath(); ctx.ellipse(ex, ey + size + 10, size * 0.8, 10, 0, 0, Math.PI * 2); ctx.fill();
  let grad = ctx.createRadialGradient(ex, ey, 0, ex, ey, size);
  grad.addColorStop(0, enemy.color || '#ff4444'); grad.addColorStop(1, 'rgba(0,0,0,0.5)');
  ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(ex, ey, size, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#fff'; ctx.beginPath();
  ctx.arc(ex - size * 0.25, ey - size * 0.15, size * 0.15, 0, Math.PI * 2);
  ctx.arc(ex + size * 0.25, ey - size * 0.15, size * 0.15, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#000'; ctx.beginPath();
  ctx.arc(ex - size * 0.2, ey - size * 0.1, size * 0.08, 0, Math.PI * 2);
  ctx.arc(ex + size * 0.2, ey - size * 0.1, size * 0.08, 0, Math.PI * 2); ctx.fill();
  if (enemy.isBoss) {
    ctx.fillStyle = '#ffdd44'; ctx.beginPath();
    ctx.moveTo(ex - 30, ey - size - 5); ctx.lineTo(ex - 20, ey - size - 25);
    ctx.lineTo(ex - 10, ey - size - 10); ctx.lineTo(ex, ey - size - 30);
    ctx.lineTo(ex + 10, ey - size - 10); ctx.lineTo(ex + 20, ey - size - 25);
    ctx.lineTo(ex + 30, ey - size - 5); ctx.fill();
  }
  ctx.fillStyle = '#ddeeff';
  ctx.font = (enemy.isBoss ? 'bold 18px' : '14px') + ' sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(enemy.name, ex, ey - size - (enemy.isBoss ? 35 : 10));
  let barW = size * 2, barH = 8, barX = ex - barW / 2, barY = ey + size + 20;
  ctx.fillStyle = '#331111'; ctx.fillRect(barX, barY, barW, barH);
  let hpPct = Math.max(0, enemy.hp / enemy.maxHp);
  ctx.fillStyle = hpPct > 0.5 ? '#44ff44' : hpPct > 0.25 ? '#ffaa44' : '#ff4444';
  ctx.fillRect(barX, barY, barW * hpPct, barH);
  ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.strokeRect(barX, barY, barW, barH);
  ctx.fillStyle = '#aabbcc'; ctx.font = '12px sans-serif';
  ctx.fillText(enemy.hp + '/' + enemy.maxHp, ex, barY + barH + 14);
  ctx.fillStyle = enemy.intentDmg > 15 ? '#ff4444' : enemy.intentDmg > 0 ? '#ffaa44' : '#44ff88';
  ctx.font = '13px sans-serif';
  ctx.fillText('Intent: ' + enemy.intent + (enemy.intentDmg > 0 ? ' (' + enemy.intentDmg + ')' : ''), ex, barY + barH + 30);
  if (poisonOnEnemy > 0) {
    ctx.fillStyle = '#88ff44'; ctx.font = '12px sans-serif';
    ctx.fillText('Poison: ' + poisonOnEnemy + '/turn', ex, barY + barH + 45);
  }
}

function drawPlayerVisual() {
  let px = W * 0.3, py = H * 0.5;
  let grad = ctx.createRadialGradient(px, py, 0, px, py, 40);
  grad.addColorStop(0, '#4488ff'); grad.addColorStop(1, '#223366');
  ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(px, py, 40, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#fff'; ctx.beginPath();
  ctx.arc(px - 12, py - 8, 6, 0, Math.PI * 2);
  ctx.arc(px + 12, py - 8, 6, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#224'; ctx.beginPath();
  ctx.arc(px - 10, py - 6, 3, 0, Math.PI * 2);
  ctx.arc(px + 10, py - 6, 3, 0, Math.PI * 2); ctx.fill();
  if (player.armor > 0) {
    ctx.strokeStyle = 'rgba(68,136,255,0.5)'; ctx.lineWidth = 3;
    ctx.beginPath(); ctx.arc(px, py, 48, 0, Math.PI * 2); ctx.stroke();
    ctx.fillStyle = '#4488ff'; ctx.font = '12px sans-serif'; ctx.textAlign = 'center';
    ctx.fillText('Armor: ' + player.armor, px, py + 60);
  }
  let barW = 100, barH = 10, barX = px - barW / 2, barY = py + 50;
  ctx.fillStyle = '#331111'; ctx.fillRect(barX, barY, barW, barH);
  let hpPct = player.hp / player.maxHp;
  ctx.fillStyle = hpPct > 0.5 ? '#44ff44' : hpPct > 0.25 ? '#ffaa44' : '#ff4444';
  ctx.fillRect(barX, barY, barW * hpPct, barH);
  ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.strokeRect(barX, barY, barW, barH);
  ctx.fillStyle = '#aabbcc'; ctx.font = '12px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText(player.hp + '/' + player.maxHp + ' HP', px, barY + barH + 14);
}

function drawAbilityBar() {
  let startX = W - 200, ay = H - 240;
  for (let i = 0; i < abilities.length; i++) {
    let ab = abilities[i], ax = startX + i * 48;
    let canUse = ab.cooldown === 0 && ab.cost <= player.mana && turnPhase === 'player';
    ctx.fillStyle = canUse ? 'rgba(30,50,90,0.9)' : 'rgba(20,20,30,0.9)';
    ctx.beginPath(); ctx.roundRect(ax, ay, 44, 44, 6); ctx.fill();
    ctx.strokeStyle = canUse ? 'rgba(100,200,255,0.5)' : 'rgba(60,60,80,0.3)';
    ctx.lineWidth = 1; ctx.stroke();
    ctx.fillStyle = canUse ? '#aaddff' : '#445566';
    ctx.font = 'bold 14px sans-serif'; ctx.textAlign = 'center';
    ctx.fillText(ab.key, ax + 22, ay + 18);
    ctx.font = '8px sans-serif';
    ctx.fillText(ab.name.substring(0, 6), ax + 22, ay + 32);
    if (ab.cooldown > 0) {
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.beginPath(); ctx.roundRect(ax, ay, 44, 44, 6); ctx.fill();
      ctx.fillStyle = '#ff8844'; ctx.font = 'bold 16px sans-serif';
      ctx.fillText(ab.cooldown, ax + 22, ay + 28);
    }
    ctx.fillStyle = '#44aaff'; ctx.font = '9px sans-serif';
    ctx.fillText(ab.cost + 'M', ax + 22, ay + 42);
  }
}

function drawEndTurnBtn() {
  let bx = W / 2 - 50, by = H - 35;
  let hover = mouseX >= bx && mouseX <= bx + 100 && mouseY >= by && mouseY <= by + 25;
  ctx.fillStyle = hover ? 'rgba(40,80,120,0.9)' : 'rgba(25,50,80,0.9)';
  ctx.beginPath(); ctx.roundRect(bx, by, 100, 25, 6); ctx.fill();
  ctx.strokeStyle = 'rgba(100,200,255,0.4)'; ctx.lineWidth = 1; ctx.stroke();
  ctx.fillStyle = turnPhase === 'player' ? '#aaddff' : '#556677';
  ctx.font = '13px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText(turnPhase === 'player' ? 'End Turn' : 'Enemy Turn...', bx + 50, by + 17);
}

function update(dt) {
  if (shakeDur > 0) { shakeDur -= dt; shakeX *= 0.9; shakeY *= 0.9; } else { shakeX = shakeY = 0; }
  enemyAnimX *= 0.85; enemyAnimY *= 0.85;
  for (let i = particles.length - 1; i >= 0; i--) {
    let p = particles[i]; p.x += p.vx; p.y += p.vy; p.vy += 0.15; p.life -= dt * 0.03; p.size *= 0.98;
    if (p.life <= 0) particles.splice(i, 1);
  }
  for (let i = floatingTexts.length - 1; i >= 0; i--) {
    let t = floatingTexts[i]; t.y += t.vy; t.life -= dt * 0.025;
    if (t.life <= 0) floatingTexts.splice(i, 1);
  }
}

function render() {
  let bgGrad = ctx.createLinearGradient(0, 0, 0, H);
  bgGrad.addColorStop(0, '#0a0a2e'); bgGrad.addColorStop(0.5, '#0a1a2e'); bgGrad.addColorStop(1, '#0a0a1e');
  ctx.fillStyle = bgGrad; ctx.fillRect(0, 0, W, H);
  ctx.fillStyle = 'rgba(255,255,255,0.3)';
  for (let i = 0; i < 50; i++) {
    let sx = ((i * 137.5) % W);
    let sy = ((i * 73.7 + Date.now() * 0.001 * (i % 3 + 1)) % H);
    ctx.fillRect(sx, sy, 1, 1);
  }
  ctx.save(); ctx.translate(shakeX, shakeY);
  ctx.fillStyle = 'rgba(20,30,60,0.4)';
  ctx.beginPath(); ctx.ellipse(W / 2, H * 0.55, W * 0.4, H * 0.15, 0, 0, Math.PI * 2); ctx.fill();
  drawPlayerVisual(); drawEnemyVisual();
  let cardW = Math.min(120, (W - 100) / Math.max(player.hand.length, 1));
  let handStartX = W / 2 - (player.hand.length * cardW) / 2;
  let cardY = H - 180;
  for (let i = 0; i < player.hand.length; i++) {
    let cx = handStartX + i * cardW;
    let hovered = mouseX >= cx && mouseX <= cx + cardW - 4 && mouseY >= cardY - 10 && mouseY <= cardY + 150;
    drawCardVisual(player.hand[i], cx, cardY, cardW, 150, hovered);
  }
  drawAbilityBar(); drawEndTurnBtn();
  ctx.fillStyle = '#445566'; ctx.font = '12px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText('Round ' + round + '/15', W / 2, 30);
  if (combo > 1) {
    ctx.fillStyle = combo > 5 ? '#ffdd44' : combo > 3 ? '#ff8844' : '#ff6644';
    ctx.font = 'bold ' + (16 + combo * 2) + 'px sans-serif';
    ctx.fillText('COMBO x' + combo, W / 2, H * 0.4);
  }
  for (let p of particles) {
    ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
    ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
  }
  ctx.globalAlpha = 1;
  for (let t of floatingTexts) {
    ctx.globalAlpha = t.life; ctx.fillStyle = t.color;
    ctx.font = 'bold 18px sans-serif'; ctx.textAlign = 'center';
    ctx.fillText(t.text, t.x, t.y);
  }
  ctx.globalAlpha = 1; ctx.restore();
  document.getElementById('hud-hp').textContent = 'HP: ' + player.hp + '/' + player.maxHp;
  document.getElementById('hud-mana').textContent = 'Mana: ' + player.mana + '/' + player.maxMana;
  document.getElementById('hud-score').textContent = 'Score: ' + score;
  document.getElementById('hud-combo').textContent = 'Combo: x' + combo;
  document.getElementById('hud-round').textContent = 'Round: ' + round + '/15';
}

let lastTime = 0;
function gameLoop(time) {
  let dt = Math.min(time - lastTime, 50); lastTime = time;
  if (state === STATE.PLAYING) { update(dt); render(); }
  requestAnimationFrame(gameLoop);
}
requestAnimationFrame(gameLoop);
</script>
</body>
</html>