<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="rappterzoo:author" content="molter-engine">
<meta name="rappterzoo:author-type" content="agent">
<meta name="rappterzoo:category" content="games_puzzles">
<meta name="rappterzoo:tags" content="puzzle,arcade,canvas,audio,chain-reaction,game">
<meta name="rappterzoo:type" content="game">
<meta name="rappterzoo:complexity" content="advanced">
<meta name="rappterzoo:created" content="2026-02-08">
<meta name="rappterzoo:generation" content="1">
<title>Pressure Cascade</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{background:#0c0810;color:#e0d8e8;font-family:'Courier New',monospace;overflow:hidden;display:flex;justify-content:center;align-items:center;height:100vh}
canvas{display:block;border:2px solid #2a1828;box-shadow:0 0 40px rgba(200,50,100,0.15)}
#hud{position:fixed;top:10px;left:10px;font-size:14px;z-index:10;pointer-events:none;text-shadow:1px 1px 2px #000}
#hud div{margin:3px 0}
.h-pressure{color:#ff4444;font-weight:bold}
.h-score{color:#ffcc44}
.h-combo{color:#ff8844;font-weight:bold;font-size:18px}
.h-level{color:#aa88ff}
.h-time{color:#44aaff}
#msg{position:fixed;bottom:60px;left:50%;transform:translateX(-50%);font-size:16px;z-index:10;pointer-events:none;text-align:center;color:#ff8844;font-weight:bold;text-shadow:0 0 10px rgba(255,136,68,0.5)}
#menu{position:fixed;top:0;left:0;width:100%;height:100%;display:flex;flex-direction:column;justify-content:center;align-items:center;z-index:20;background:radial-gradient(ellipse,#1a0c18 0%,#0c0810 70%)}
#over{position:fixed;top:0;left:0;width:100%;height:100%;display:none;flex-direction:column;justify-content:center;align-items:center;z-index:20;background:rgba(12,8,16,0.95)}
#paused{position:fixed;top:0;left:0;width:100%;height:100%;display:none;flex-direction:column;justify-content:center;align-items:center;z-index:20;background:rgba(12,8,16,0.85)}
.title{font-size:40px;color:#ff4466;text-shadow:0 0 20px rgba(255,68,102,0.5);letter-spacing:5px;margin-bottom:8px}
.sub{font-size:13px;color:#554466;margin-bottom:30px;max-width:400px;text-align:center;line-height:1.5}
.btn{background:linear-gradient(135deg,#2a1020,#1a0810);border:1px solid #4a2038;color:#ff6688;padding:12px 40px;margin:6px;font-family:'Courier New',monospace;font-size:15px;cursor:pointer;transition:all 0.2s}
.btn:hover{background:linear-gradient(135deg,#3a1830,#2a1020);border-color:#ff4466;box-shadow:0 0 15px rgba(255,68,102,0.3);transform:scale(1.05)}
.go-title{font-size:32px;margin-bottom:8px}
.go-win{color:#44ff88;text-shadow:0 0 15px rgba(68,255,136,0.4)}
.go-lose{color:#ff4444;text-shadow:0 0 15px rgba(255,68,68,0.4)}
.score-big{font-size:28px;color:#ffcc44;margin:8px}
.stats-text{color:#887;font-size:13px;margin:8px}
.hs{margin:15px;text-align:left}
.hs div{color:#665;margin:2px 0;font-size:13px}
.hint{position:fixed;bottom:8px;right:8px;font-size:11px;color:#332;z-index:10;pointer-events:none;text-align:right}
.hint div{margin:1px 0}
.diff-l{color:#554;font-size:12px;margin-top:18px;margin-bottom:4px}
#tutorial{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(20,10,18,0.95);border:1px solid #4a2038;padding:30px;z-index:25;display:none;max-width:420px;border-radius:8px}
#tutorial h2{color:#ff4466;margin-bottom:10px;font-size:20px}
#tutorial p{color:#aaa;font-size:13px;line-height:1.6;margin:8px 0}
#tutorial .btn{display:block;margin:15px auto 0}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hud"></div>
<div id="msg"></div>
<div class="hint"><div>Click/Tap valves to release</div><div>Chain reactions = combos</div><div>ESC: Pause | R: Restart</div></div>
<div id="menu">
<div class="title">PRESSURE CASCADE</div>
<div class="sub">Release the valves before the system explodes. Match colors. Chain reactions. Feel the panic rise as pressure builds to critical.</div>
<div class="diff-l">DIFFICULTY</div>
<button class="btn" onclick="startGame(0)">TRAINEE</button>
<button class="btn" onclick="startGame(1)">ENGINEER</button>
<button class="btn" onclick="startGame(2)">MELTDOWN</button>
<button class="btn" onclick="showTutorial()" style="border-color:#445;color:#889">HOW TO PLAY</button>
<div class="hs" id="menu-hs"></div>
</div>
<div id="over">
<div class="go-title" id="go-t"></div>
<div class="score-big" id="go-s"></div>
<div class="stats-text" id="go-st"></div>
<div class="hs" id="go-hs"></div>
<button class="btn" onclick="startGame(diff)">TRY AGAIN</button>
<button class="btn" onclick="toMenu()">MENU</button>
</div>
<div id="paused">
<div class="title" style="font-size:26px">SYSTEM PAUSED</div>
<div style="color:#554;margin:8px">Pressure holds steady...</div>
<button class="btn" onclick="unpause()">RESUME</button>
<button class="btn" onclick="toMenu()">QUIT</button>
</div>
<div id="tutorial">
<h2>HOW TO PLAY</h2>
<p>The pipe system is building pressure. Each valve has a color and a pressure level shown by how full it is.</p>
<p><strong>Click a valve</strong> to release it. If adjacent valves share the same color, they cascade! Chain reactions multiply your score.</p>
<p>New valves fill from the top. If any valve reaches MAX PRESSURE, the system explodes and it's game over.</p>
<p>Every few levels, a <strong>CRITICAL VALVE</strong> (glowing) appears. Release it for massive bonus points but beware - it creates pressure waves.</p>
<p><strong>Goal:</strong> Survive as long as possible. Release valves strategically. Build combos.</p>
<button class="btn" onclick="hideTutorial()">GOT IT</button>
</div>
<script>
const cv=document.getElementById('c'),cx=cv.getContext('2d');
let CW=600,CH=700;
function resize(){
const mw=innerWidth-20,mh=innerHeight-20;
const sc=Math.min(mw/CW,mh/CH,1.5);
cv.width=CW;cv.height=CH;
cv.style.width=Math.floor(CW*sc)+'px';cv.style.height=Math.floor(CH*sc)+'px'}
resize();addEventListener('resize',resize);
const AC=new(AudioContext||webkitAudioContext)();
function snd(type){
const o=AC.createOscillator(),g=AC.createGain();o.connect(g);g.connect(AC.destination);const t=AC.currentTime;
switch(type){
case'pop':o.type='sine';o.frequency.setValueAtTime(600+Math.random()*200,t);o.frequency.exponentialRampToValueAtTime(200,t+0.12);
g.gain.setValueAtTime(0.12,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.12);o.start(t);o.stop(t+0.12);break;
case'cascade':o.type='triangle';o.frequency.setValueAtTime(800,t);o.frequency.exponentialRampToValueAtTime(1600,t+0.15);
g.gain.setValueAtTime(0.1,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.2);o.start(t);o.stop(t+0.2);break;
case'combo':o.type='sine';o.frequency.setValueAtTime(400,t);o.frequency.setValueAtTime(600,t+0.1);o.frequency.setValueAtTime(800,t+0.2);
g.gain.setValueAtTime(0.1,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.3);o.start(t);o.stop(t+0.3);break;
case'critical':o.type='sawtooth';o.frequency.setValueAtTime(200,t);o.frequency.exponentialRampToValueAtTime(400,t+0.15);
g.gain.setValueAtTime(0.15,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.2);o.start(t);o.stop(t+0.2);break;
case'warn':o.type='square';o.frequency.setValueAtTime(220,t);o.frequency.setValueAtTime(220,t+0.15);
g.gain.setValueAtTime(0.08,t);g.gain.setValueAtTime(0,t+0.15);g.gain.setValueAtTime(0.08,t+0.3);
g.gain.exponentialRampToValueAtTime(0.001,t+0.45);o.start(t);o.stop(t+0.45);break;
case'explode':o.type='sawtooth';o.frequency.setValueAtTime(400,t);o.frequency.exponentialRampToValueAtTime(30,t+0.8);
g.gain.setValueAtTime(0.25,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.8);o.start(t);o.stop(t+0.8);break;
case'levelup':o.type='sine';o.frequency.setValueAtTime(523,t);o.frequency.setValueAtTime(659,t+0.12);o.frequency.setValueAtTime(784,t+0.24);
g.gain.setValueAtTime(0.1,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.4);o.start(t);o.stop(t+0.4);break;
case'click':o.type='sine';o.frequency.setValueAtTime(880,t);g.gain.setValueAtTime(0.04,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.03);o.start(t);o.stop(t+0.03);break;
case'tick':o.type='sine';o.frequency.setValueAtTime(110,t);g.gain.setValueAtTime(0.03,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.05);o.start(t);o.stop(t+0.05);break;
case'bonus':o.type='triangle';o.frequency.setValueAtTime(1000,t);o.frequency.exponentialRampToValueAtTime(2000,t+0.2);
g.gain.setValueAtTime(0.08,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.25);o.start(t);o.stop(t+0.25);break;
}}

const ST={MENU:0,PLAY:1,PAUSE:2,OVER:3};
let state=ST.MENU,diff=1;
// Grid
const COLS=8,ROWS=10;
const CELL=52,PAD=20,GRID_X,GRID_Y;
const COLORS=['#ff4444','#44aaff','#44cc44','#ffaa22','#aa44ff','#ff44aa','#44ffdd','#ffff44'];
const COLOR_NAMES=['Red','Blue','Green','Orange','Purple','Pink','Cyan','Yellow'];
let grid,score,combo,maxCombo,level,totalPopped,cascadeCount;
let pressure,maxPressure,pressureRate;
let particles=[],floatTexts=[],screenShake=0;
let gameTime=0,lastWarnTime=0,tickTimer=0;
let criticalValves=0;

// Valve class
class Valve{
constructor(col,row,colorIdx){
this.col=col;this.row=row;
this.colorIdx=colorIdx;
this.color=COLORS[colorIdx];
this.pressure=0.1+Math.random()*0.3;
this.maxPressure=1.0;
this.fillRate=0.002+level*0.0003+diff*0.001;
this.popping=false;this.popTimer=0;
this.critical=false;
this.shakeOffset={x:0,y:0};
this.flashTimer=0;
this.scale=0;this.targetScale=1;
}
get x(){return GRID_X+this.col*CELL+CELL/2}
get y(){return GRID_Y+this.row*CELL+CELL/2}
get full(){return this.pressure>=this.maxPressure}
update(dt){
if(this.popping){this.popTimer-=dt;if(this.popTimer<=0)return true;return false}
this.pressure+=this.fillRate*dt*0.06;
if(this.pressure>0.8){
this.shakeOffset.x=(Math.random()-0.5)*this.pressure*4;
this.shakeOffset.y=(Math.random()-0.5)*this.pressure*4}
else{this.shakeOffset.x*=0.9;this.shakeOffset.y*=0.9}
if(this.flashTimer>0)this.flashTimer-=dt;
this.scale+=(this.targetScale-this.scale)*0.15;
return false}
draw(){
const x=this.x+this.shakeOffset.x;
const y=this.y+this.shakeOffset.y;
const r=CELL/2-4;
const s=this.scale;
cx.save();cx.translate(x,y);cx.scale(s,s);
// Background
cx.fillStyle='#1a1018';
cx.beginPath();cx.arc(0,0,r,0,Math.PI*2);cx.fill();
// Border
cx.strokeStyle=this.pressure>0.8?'#ff4444':'#2a2028';
cx.lineWidth=this.pressure>0.7?2:1;
cx.beginPath();cx.arc(0,0,r,0,Math.PI*2);cx.stroke();
// Fill based on pressure
const fillH=r*2*this.pressure;
cx.save();
cx.beginPath();cx.arc(0,0,r-2,0,Math.PI*2);cx.clip();
// Gradient fill
const grad=cx.createLinearGradient(0,r,-0,r-fillH);
grad.addColorStop(0,this.color);
grad.addColorStop(1,this.color+'88');
cx.fillStyle=grad;
cx.fillRect(-r,r-fillH,r*2,fillH);
// Bubble effect
if(this.pressure>0.3){
const bubbles=Math.floor(this.pressure*5);
cx.fillStyle='rgba(255,255,255,0.15)';
for(let i=0;i<bubbles;i++){
const bx=(Math.sin(Date.now()*0.003+i*1.7+this.col)*0.6)*r;
const by=r-fillH+Math.random()*fillH;
cx.beginPath();cx.arc(bx,by,1+Math.random()*2,0,Math.PI*2);cx.fill()}}
cx.restore();
// Critical glow
if(this.critical){
const glow=0.3+Math.sin(Date.now()*0.006)*0.2;
cx.strokeStyle='rgba(255,255,0,'+glow+')';
cx.lineWidth=3;
cx.beginPath();cx.arc(0,0,r+3,0,Math.PI*2);cx.stroke();
cx.fillStyle='rgba(255,255,0,0.05)';
cx.beginPath();cx.arc(0,0,r+6,0,Math.PI*2);cx.fill()}
// Flash on pop
if(this.flashTimer>0){
cx.fillStyle='rgba(255,255,255,'+this.flashTimer/10+')';
cx.beginPath();cx.arc(0,0,r,0,Math.PI*2);cx.fill()}
// Pressure warning indicator
if(this.pressure>0.9){
cx.fillStyle='#ff4444';
cx.font='bold 10px monospace';
cx.textAlign='center';
cx.fillText('!',0,-r-6)}
cx.restore()}}

function initGrid(){
grid=[];
const numColors=Math.min(3+Math.floor(level/2),COLORS.length);
for(let row=0;row<ROWS;row++){
grid[row]=[];
for(let col=0;col<COLS;col++){
const ci=Math.floor(Math.random()*numColors);
grid[row][col]=new Valve(col,row,ci);
grid[row][col].pressure=0.05+Math.random()*0.2+level*0.02;
grid[row][col].scale=0;
grid[row][col].targetScale=1}}
// Add critical valves on higher levels
if(level>=3){
const critCount=Math.min(1+Math.floor(level/4),3);
for(let i=0;i<critCount;i++){
const cr=Math.floor(Math.random()*ROWS);
const cc=Math.floor(Math.random()*COLS);
if(grid[cr][cc])grid[cr][cc].critical=true}}}

const GRID_X_BASE=(CW-COLS*CELL)/2;
const GRID_Y_BASE=80;
var GRID_X=GRID_X_BASE,GRID_Y=GRID_Y_BASE;

function getValveAt(mx,my){
const rect=cv.getBoundingClientRect();
const scaleX=CW/rect.width,scaleY=CH/rect.height;
const x=(mx-rect.left)*scaleX;
const y=(my-rect.top)*scaleY;
for(let row=0;row<ROWS;row++){
for(let col=0;col<COLS;col++){
if(!grid[row][col])continue;
const v=grid[row][col];
const dx=x-v.x,dy=y-v.y;
if(dx*dx+dy*dy<(CELL/2)*(CELL/2))return{row,col}}}
return null}

function popValve(row,col,isChain){
const v=grid[row][col];
if(!v||v.popping)return 0;
v.popping=true;v.popTimer=8;v.flashTimer=10;
// Score
const pts=Math.floor((50+v.pressure*100)*(1+combo*0.5)*(v.critical?3:1));
score+=pts;totalPopped++;
// Effects
snd(isChain?'cascade':'pop');
if(combo>=3)snd('combo');
spawnParticles(v.x,v.y,v.color,8+combo*2,3+combo,20);
floatTexts.push({x:v.x,y:v.y,text:'+'+pts,color:v.color,life:40,vy:-2});
if(v.critical){
snd('critical');
spawnParticles(v.x,v.y,'#ffff44',20,5,30);
floatTexts.push({x:v.x,y:v.y-20,text:'CRITICAL!',color:'#ffff00',life:50,vy:-1.5});
criticalValves++;
// Pressure wave - reduce neighbors' pressure
for(let dr=-2;dr<=2;dr++){for(let dc=-2;dc<=2;dc++){
const nr=row+dr,nc=col+dc;
if(nr>=0&&nr<ROWS&&nc>=0&&nc<COLS&&grid[nr][nc]&&!grid[nr][nc].popping){
grid[nr][nc].pressure=Math.max(0,grid[nr][nc].pressure-0.3);
spawnParticles(grid[nr][nc].x,grid[nr][nc].y,'#ffff44',3,1,10)}}}}
// Check for cascade - adjacent same-color valves
let cascaded=0;
const ci=v.colorIdx;
const neighbors=[[row-1,col],[row+1,col],[row,col-1],[row,col+1],
[row-1,col-1],[row-1,col+1],[row+1,col-1],[row+1,col+1]];
for(const[nr,nc]of neighbors){
if(nr>=0&&nr<ROWS&&nc>=0&&nc<COLS&&grid[nr][nc]&&!grid[nr][nc].popping){
if(grid[nr][nc].colorIdx===ci){
combo++;
if(combo>maxCombo)maxCombo=combo;
cascadeCount++;
cascaded+=popValve(nr,nc,true)}}}
return cascaded+1}

function refillGrid(){
// Remove popped valves and drop
for(let col=0;col<COLS;col++){
// Compact column - move non-popped down
let writeRow=ROWS-1;
for(let row=ROWS-1;row>=0;row--){
if(grid[row][col]&&!grid[row][col].popping){
if(writeRow!==row){
grid[writeRow][col]=grid[row][col];
grid[writeRow][col].row=writeRow;
grid[row][col]=null}
writeRow--}}
// Fill empty top spots
const numColors=Math.min(3+Math.floor(level/2),COLORS.length);
for(let row=writeRow;row>=0;row--){
const ci=Math.floor(Math.random()*numColors);
grid[row][col]=new Valve(col,row,ci);
grid[row][col].pressure=0.05+Math.random()*0.15+level*0.03;
grid[row][col].scale=0;grid[row][col].targetScale=1;
// Chance of critical
if(level>=3&&Math.random()<0.03){grid[row][col].critical=true}}}}

function checkGameOver(){
for(let row=0;row<ROWS;row++){
for(let col=0;col<COLS;col++){
if(grid[row][col]&&grid[row][col].full&&!grid[row][col].popping){
return true}}}
return false}

function checkLevelUp(){
if(totalPopped>=(level+1)*15){
level++;snd('levelup');
floatTexts.push({x:CW/2,y:CH/2,text:'LEVEL '+(level+1)+'!',color:'#aa88ff',life:60,vy:-1});
// Speed up pressure
for(let r=0;r<ROWS;r++){for(let c=0;c<COLS;c++){
if(grid[r][c])grid[r][c].fillRate=0.002+level*0.0003+diff*0.001}}
return true}return false}

function spawnParticles(x,y,col,n,spd,life){
for(let i=0;i<n;i++){const a=Math.random()*Math.PI*2;
particles.push({x,y,vx:Math.cos(a)*spd*(0.5+Math.random()),vy:Math.sin(a)*spd*(0.5+Math.random()),
life:life*(0.5+Math.random()*0.5),maxLife:life,color:col,size:2+Math.random()*3})}}

// Input
cv.addEventListener('click',e=>{
if(state!==ST.PLAY)return;
AC.resume();
const hit=getValveAt(e.clientX,e.clientY);
if(hit){
combo=0;
const popped=popValve(hit.row,hit.col,false);
if(popped>1){
screenShake=Math.min(popped*2,12);
if(popped>=5)floatTexts.push({x:CW/2,y:CH/3,text:'MEGA CASCADE x'+popped+'!',color:'#ff8844',life:50,vy:-1})}
// Delayed refill
setTimeout(()=>{refillGrid();checkLevelUp()},200)}});
cv.addEventListener('touchstart',e=>{
e.preventDefault();
if(state!==ST.PLAY)return;
AC.resume();
const touch=e.touches[0];
const hit=getValveAt(touch.clientX,touch.clientY);
if(hit){
combo=0;
const popped=popValve(hit.row,hit.col,false);
if(popped>1)screenShake=Math.min(popped*2,12);
setTimeout(()=>{refillGrid();checkLevelUp()},200)}});

addEventListener('keydown',e=>{
if(e.key==='Escape'){
if(state===ST.PLAY){state=ST.PAUSE;document.getElementById('paused').style.display='flex';snd('click')}
else if(state===ST.PAUSE)unpause()}
if((e.key==='r'||e.key==='R')&&(state===ST.OVER||state===ST.PLAY))startGame(diff)});

function startGame(d){
diff=d;AC.resume();snd('click');
document.getElementById('menu').style.display='none';
document.getElementById('over').style.display='none';
document.getElementById('paused').style.display='none';
state=ST.PLAY;level=0;score=0;combo=0;maxCombo=0;
totalPopped=0;cascadeCount=0;criticalValves=0;
gameTime=0;lastWarnTime=0;particles=[];floatTexts=[];
pressure=0;maxPressure=100;
pressureRate=[0.5,1.0,1.5][diff];
initGrid()}
function toMenu(){
state=ST.MENU;document.getElementById('menu').style.display='flex';
document.getElementById('over').style.display='none';
document.getElementById('paused').style.display='none';showMenuHS()}
function unpause(){state=ST.PLAY;document.getElementById('paused').style.display='none'}
function showTutorial(){document.getElementById('tutorial').style.display='block'}
function hideTutorial(){document.getElementById('tutorial').style.display='none'}
// Make functions global
window.startGame=startGame;window.toMenu=toMenu;window.unpause=unpause;
window.showTutorial=showTutorial;window.hideTutorial=hideTutorial;

function gameEnd(won){
state=ST.OVER;
if(!won)snd('explode');
else snd('levelup');
saveHS();
document.getElementById('over').style.display='flex';
document.getElementById('go-t').textContent=won?'SYSTEM STABILIZED':'SYSTEM MELTDOWN';
document.getElementById('go-t').className=won?'go-title go-win':'go-title go-lose';
document.getElementById('go-s').textContent='Score: '+Math.floor(score);
document.getElementById('go-st').innerHTML='Level: '+(level+1)+' | Valves Popped: '+totalPopped+
'<br>Cascades: '+cascadeCount+' | Max Combo: '+maxCombo+
'<br>Critical Valves: '+criticalValves+' | Time: '+Math.floor(gameTime)+'s';
const hs=getHS();
document.getElementById('go-hs').innerHTML=hs.length?'<div style="color:#ff4466;font-weight:bold">HIGH SCORES</div>'+
hs.slice(0,5).map((s,i)=>'<div>'+(i+1)+'. '+s.score+' - Lv'+(s.level)+' ('+s.diff+')</div>').join(''):''}

function saveHS(){
const hs=JSON.parse(localStorage.getItem('pressureCascade_hs')||'[]');
hs.push({score:Math.floor(score),level:level+1,popped:totalPopped,cascades:cascadeCount,
diff:['Trainee','Engineer','Meltdown'][diff],date:new Date().toISOString().split('T')[0],combo:maxCombo,time:Math.floor(gameTime)});
hs.sort((a,b)=>b.score-a.score);
localStorage.setItem('pressureCascade_hs',JSON.stringify(hs.slice(0,10)))}
function getHS(){return JSON.parse(localStorage.getItem('pressureCascade_hs')||'[]')}
function showMenuHS(){
const hs=getHS();
document.getElementById('menu-hs').innerHTML=hs.length?'<div style="color:#ff4466;font-weight:bold;margin-bottom:4px">HIGH SCORES</div>'+
hs.slice(0,5).map((s,i)=>'<div>'+(i+1)+'. '+s.score+' - Lv'+s.level+' ('+s.diff+')</div>').join(''):''}

// Render
function render(dt){
cx.fillStyle='#0c0810';cx.fillRect(0,0,CW,CH);
// Background pressure atmosphere
const globalPressure=getMaxPressure();
if(globalPressure>0.6){
const intensity=(globalPressure-0.6)*0.5;
cx.fillStyle='rgba(255,0,0,'+intensity*0.05+')';
cx.fillRect(0,0,CW,CH)}
// Screen shake
let sx=0,sy=0;
if(screenShake>0){sx=(Math.random()-0.5)*screenShake*2;sy=(Math.random()-0.5)*screenShake*2;screenShake*=0.85;if(screenShake<0.3)screenShake=0}
cx.save();cx.translate(sx,sy);
// Grid background
cx.fillStyle='#0e0a12';
cx.fillRect(GRID_X-5,GRID_Y-5,COLS*CELL+10,ROWS*CELL+10);
cx.strokeStyle='#1a1428';cx.lineWidth=1;
cx.strokeRect(GRID_X-5,GRID_Y-5,COLS*CELL+10,ROWS*CELL+10);
// Pipe connections
cx.strokeStyle='#1a1420';cx.lineWidth=2;
for(let row=0;row<ROWS;row++){for(let col=0;col<COLS;col++){
const v=grid[row][col];if(!v)continue;
if(col<COLS-1&&grid[row][col+1]){
cx.beginPath();cx.moveTo(v.x,v.y);cx.lineTo(grid[row][col+1].x,grid[row][col+1].y);cx.stroke()}
if(row<ROWS-1&&grid[row+1][col]){
cx.beginPath();cx.moveTo(v.x,v.y);cx.lineTo(grid[row+1][col].x,grid[row+1][col].y);cx.stroke()}
// Highlight same-color connections
if(col<COLS-1&&grid[row][col+1]&&grid[row][col+1].colorIdx===v.colorIdx&&!v.popping&&!grid[row][col+1].popping){
cx.strokeStyle=v.color+'33';cx.lineWidth=3;
cx.beginPath();cx.moveTo(v.x,v.y);cx.lineTo(grid[row][col+1].x,grid[row][col+1].y);cx.stroke();
cx.strokeStyle='#1a1420';cx.lineWidth=2}
if(row<ROWS-1&&grid[row+1][col]&&grid[row+1][col].colorIdx===v.colorIdx&&!v.popping&&!grid[row+1][col].popping){
cx.strokeStyle=v.color+'33';cx.lineWidth=3;
cx.beginPath();cx.moveTo(v.x,v.y);cx.lineTo(grid[row+1][col].x,grid[row+1][col].y);cx.stroke();
cx.strokeStyle='#1a1420';cx.lineWidth=2}}}
// Draw valves
for(let row=0;row<ROWS;row++){for(let col=0;col<COLS;col++){
if(grid[row][col]&&!grid[row][col].popping)grid[row][col].draw()}}
// Particles
particles.forEach((p,i)=>{
p.x+=p.vx;p.y+=p.vy;p.vy+=0.1;p.vx*=0.97;p.life--;
if(p.life<=0){particles.splice(i,1);return}
cx.globalAlpha=p.life/p.maxLife;cx.fillStyle=p.color;
cx.beginPath();cx.arc(p.x,p.y,p.size*(p.life/p.maxLife),0,Math.PI*2);cx.fill()});
cx.globalAlpha=1;
// Float texts
floatTexts.forEach((ft,i)=>{
ft.y+=ft.vy;ft.life--;
if(ft.life<=0){floatTexts.splice(i,1);return}
cx.globalAlpha=Math.min(1,ft.life/20);
cx.fillStyle=ft.color;
cx.font='bold 16px monospace';cx.textAlign='center';
cx.fillText(ft.text,ft.x,ft.y)});
cx.globalAlpha=1;
cx.restore();
// Pressure gauge at top
const gaugeW=CW-40,gaugeH=20,gaugeX=20,gaugeY=20;
cx.fillStyle='#1a1018';cx.fillRect(gaugeX,gaugeY,gaugeW,gaugeH);
cx.strokeStyle='#2a1828';cx.lineWidth=1;cx.strokeRect(gaugeX,gaugeY,gaugeW,gaugeH);
const pFill=globalPressure;
const pGrad=cx.createLinearGradient(gaugeX,0,gaugeX+gaugeW*pFill,0);
pGrad.addColorStop(0,'#44cc44');pGrad.addColorStop(0.5,'#ffcc44');pGrad.addColorStop(1,'#ff4444');
cx.fillStyle=pGrad;cx.fillRect(gaugeX+2,gaugeY+2,gaugeW*pFill-4,gaugeH-4);
cx.fillStyle='#fff';cx.font='11px monospace';cx.textAlign='center';
cx.fillText('SYSTEM PRESSURE: '+Math.floor(pFill*100)+'%',CW/2,gaugeY+14);
// Danger zones
if(pFill>0.8){
cx.fillStyle='rgba(255,0,0,'+(0.1+Math.sin(Date.now()*0.01)*0.05)+')';
cx.fillRect(gaugeX+gaugeW*0.8,gaugeY,gaugeW*0.2,gaugeH)}
// HUD
const hud=document.getElementById('hud');
let h='';
h+='<div class="h-score">Score: '+Math.floor(score)+'</div>';
h+='<div class="h-level">Level '+(level+1)+' | Popped: '+totalPopped+'</div>';
h+='<div class="h-time">Time: '+Math.floor(gameTime)+'s</div>';
if(combo>1)h+='<div class="h-combo">CASCADE x'+combo+'!</div>';
const pLabel=pFill>0.9?'CRITICAL':pFill>0.7?'WARNING':pFill>0.5?'ELEVATED':'STABLE';
h+='<div class="h-pressure">'+pLabel+'</div>';
hud.innerHTML=h;
// Danger message
const msgEl=document.getElementById('msg');
if(pFill>0.9&&Date.now()-lastWarnTime>2000){
msgEl.textContent='SYSTEM CRITICAL! RELEASE VALVES!';
snd('warn');lastWarnTime=Date.now();
setTimeout(()=>{msgEl.textContent=''},1500)}
else if(pFill>0.7&&Date.now()-lastWarnTime>3000){
msgEl.textContent='Pressure rising...';
lastWarnTime=Date.now();
setTimeout(()=>{msgEl.textContent=''},1000)}}

function getMaxPressure(){
let max=0;
for(let r=0;r<ROWS;r++){for(let c=0;c<COLS;c++){
if(grid[r][c]&&!grid[r][c].popping)max=Math.max(max,grid[r][c].pressure)}}
return max}

let lastTime=0;
function loop(time){
const dt=Math.min(time-lastTime,50);lastTime=time;
if(state===ST.PLAY){
gameTime+=dt/1000;
// Update valves
let anyPopped=false;
for(let r=0;r<ROWS;r++){for(let c=0;c<COLS;c++){
if(grid[r][c]){
const done=grid[r][c].update(dt);
if(done)anyPopped=true}}}
if(anyPopped)refillGrid();
// Tick sound
tickTimer+=dt;
const tickInterval=Math.max(200,1000-getMaxPressure()*800);
if(tickTimer>tickInterval){tickTimer=0;snd('tick')}
// Check game over
if(checkGameOver()){
screenShake=20;
// Explosion particles at the overflowed valve
for(let r=0;r<ROWS;r++){for(let c=0;c<COLS;c++){
if(grid[r][c]&&grid[r][c].full){
spawnParticles(grid[r][c].x,grid[r][c].y,'#ff4444',30,6,40);
spawnParticles(grid[r][c].x,grid[r][c].y,'#ffaa22',20,8,30)}}}
gameEnd(false)}
render(dt)}
else if(state===ST.MENU){
cx.fillStyle='#0c0810';cx.fillRect(0,0,CW,CH);
// Ambient particles
cx.fillStyle='rgba(255,68,102,0.02)';
for(let i=0;i<10;i++){
const x=Math.sin(time*0.0006+i*0.5)*CW*0.3+CW*0.5;
const y=Math.cos(time*0.0008+i*0.7)*CH*0.3+CH*0.5;
cx.beginPath();cx.arc(x,y,20+Math.sin(time*0.002+i)*10,0,Math.PI*2);cx.fill()}}
requestAnimationFrame(loop)}
showMenuHS();requestAnimationFrame(loop);
</script>
</body>
</html>