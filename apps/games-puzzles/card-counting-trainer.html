<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Card Counting Trainer</title>
    <meta name="description" content="Master the Hi-Lo card counting system through increasingly challenging rounds. Track the running count as cards are dealt, beat the dealer, and climb the leaderboard.">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(135deg, #0f4c2a, #1a1a1a);
            min-height: 100vh; font-family: 'Segoe UI', sans-serif;
            overflow: hidden; user-select: none; -webkit-user-select: none;
        }
        canvas { display: block; }
        #hud {
            position: fixed; top: 0; left: 0; right: 0;
            padding: 8px 12px; display: none;
            justify-content: space-between; align-items: center;
            pointer-events: none; z-index: 100;
            background: linear-gradient(to bottom, rgba(0,0,0,0.7), transparent);
        }
        .hud-section { display: flex; flex-direction: column; gap: 2px; }
        .hud-label { font-size: 9px; color: rgba(255,215,0,0.6); text-transform: uppercase; letter-spacing: 1px; }
        .hud-value { font-size: 14px; color: #ffd700; font-weight: bold; }
        .bar-container { width: 100px; height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; overflow: hidden; }
        .bar-fill { height: 100%; border-radius: 3px; transition: width 0.3s; }
        .chips-bar { background: linear-gradient(to right, #ffd700, #ff8c00); }
        .streak-display { font-size: 13px; color: #ffd700; text-shadow: 0 0 6px rgba(255,215,0,0.5); }
        #menu-screen {
            position: fixed; inset: 0; z-index: 200;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: radial-gradient(ellipse at center, #0f4c2a, #0a0a0a);
        }
        #menu-screen h1 {
            font-size: 42px; color: #ffd700; margin-bottom: 8px;
            text-shadow: 0 0 30px rgba(255,215,0,0.4);
            animation: goldGlow 3s ease-in-out infinite;
        }
        @keyframes goldGlow {
            0%, 100% { text-shadow: 0 0 20px rgba(255,215,0,0.3); }
            50% { text-shadow: 0 0 40px rgba(255,215,0,0.6), 0 0 60px rgba(255,140,0,0.2); }
        }
        .subtitle { color: rgba(255,215,0,0.4); font-style: italic; margin-bottom: 35px; font-size: 14px; }
        .menu-btn {
            width: 210px; padding: 12px; margin: 5px;
            background: rgba(255,215,0,0.1); border: 1px solid rgba(255,215,0,0.3);
            color: #ffd700; font-size: 15px; font-family: inherit; cursor: pointer;
            border-radius: 8px; transition: all 0.3s;
        }
        .menu-btn:hover { background: rgba(255,215,0,0.25); border-color: #ffd700; transform: scale(1.05); }
        .diff-label { font-size: 10px; opacity: 0.5; display: block; margin-top: 2px; }
        .high-scores { margin-top: 20px; text-align: center; }
        .high-scores h3 { color: rgba(255,215,0,0.4); font-size: 12px; margin-bottom: 5px; }
        .high-scores p { color: rgba(255,215,0,0.3); font-size: 11px; }
        #pause-overlay {
            position: fixed; inset: 0; z-index: 200;
            display: none; flex-direction: column; align-items: center; justify-content: center;
            background: rgba(0,0,0,0.85);
        }
        #pause-overlay h2 { color: #ffd700; font-size: 36px; margin-bottom: 20px; }
        #gameover-screen {
            position: fixed; inset: 0; z-index: 200;
            display: none; flex-direction: column; align-items: center; justify-content: center;
            background: rgba(0,0,0,0.9);
        }
        #gameover-screen h2 { font-size: 40px; margin-bottom: 8px; }
        .stat-row { color: rgba(255,255,255,0.6); font-size: 13px; margin: 3px 0; }
        .ending-text { color: #ffd700; font-size: 16px; margin: 12px 0; font-style: italic; max-width: 380px; text-align: center; }
    </style>
</head>
<body>
    <canvas id="c"></canvas>
    <div id="hud">
        <div class="hud-section">
            <span class="hud-label">Round</span>
            <span class="hud-value" id="round-val">1</span>
        </div>
        <div class="hud-section">
            <span class="hud-label">Chips</span>
            <div class="bar-container"><div class="bar-fill chips-bar" id="chips-bar" style="width:100%"></div></div>
        </div>
        <div class="hud-section">
            <span class="hud-label">Score</span>
            <span class="hud-value" id="score-val">0</span>
        </div>
        <div class="hud-section">
            <span class="streak-display" id="streak-val"></span>
        </div>
        <div class="hud-section">
            <span class="hud-label">Accuracy</span>
            <span class="hud-value" id="acc-val">100%</span>
        </div>
        <div class="hud-section">
            <span class="hud-label">Cards Left</span>
            <span class="hud-value" id="cards-val">52</span>
        </div>
    </div>
    <div id="menu-screen">
        <h1>Card Counting Trainer</h1>
        <p class="subtitle">Master the Hi-Lo system and beat the house</p>
        <button class="menu-btn" onclick="startGame('easy')">Beginner<span class="diff-label">Slow dealing, count hints</span></button>
        <button class="menu-btn" onclick="startGame('normal')">Pro<span class="diff-label">Standard speed, no hints</span></button>
        <button class="menu-btn" onclick="startGame('hard')">Shark<span class="diff-label">Fast dealing, multi-deck, pressure</span></button>
        <div class="high-scores" id="high-scores"></div>
    </div>
    <div id="pause-overlay">
        <h2>Paused</h2>
        <button class="menu-btn" onclick="resumeGame()">Resume</button>
        <button class="menu-btn" onclick="quitToMenu()">Quit to Menu</button>
    </div>
    <div id="gameover-screen">
        <h2 id="go-title" style="color:#ffd700;">Game Over</h2>
        <p class="ending-text" id="go-ending"></p>
        <div id="go-stats"></div>
        <button class="menu-btn" style="margin-top:15px;" onclick="startGame(G.difficulty)">Play Again (R)</button>
        <button class="menu-btn" onclick="quitToMenu()">Menu</button>
    </div>

    <script>
    // ===== AUDIO =====
    const AC = window.AudioContext || window.webkitAudioContext;
    let ac = null;
    function initAudio() { if (!ac) ac = new AC(); }
    function snd(type, freq, dur, vol) {
        if (!ac) return;
        const o = ac.createOscillator(), g = ac.createGain();
        o.connect(g); g.connect(ac.destination);
        o.type = type; o.frequency.setValueAtTime(freq, ac.currentTime);
        g.gain.setValueAtTime(vol || 0.1, ac.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, ac.currentTime + dur);
        o.start(); o.stop(ac.currentTime + dur);
    }
    function sfxCorrect() { snd('sine', 660, 0.1, 0.1); snd('sine', 880, 0.15, 0.08); }
    function sfxWrong() { snd('sawtooth', 200, 0.2, 0.12); snd('square', 150, 0.15, 0.08); }
    function sfxDeal() { snd('triangle', 400 + Math.random() * 200, 0.08, 0.06); }
    function sfxWin() { [440,554,659,880].forEach((f,i) => setTimeout(() => snd('sine', f, 0.3, 0.1), i*80)); }
    function sfxBet() { snd('sine', 500, 0.1, 0.08); snd('triangle', 300, 0.08, 0.06); }
    function sfxChips() { for(let i=0;i<3;i++) setTimeout(() => snd('triangle', 800+i*100, 0.05, 0.05), i*30); }
    function sfxMenu() { snd('sine', 440, 0.1, 0.06); }
    function sfxBust() { snd('sawtooth', 100, 0.3, 0.15); snd('square', 70, 0.25, 0.1); }
    function sfxBlackjack() { [523,659,784,1047].forEach((f,i) => setTimeout(() => snd('sine', f, 0.25, 0.1), i*60)); }

    // ===== CANVAS =====
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    let W, H;
    function resize() { W = canvas.width = innerWidth; H = canvas.height = innerHeight; }
    resize(); window.addEventListener('resize', resize);

    // ===== CARD SYSTEM =====
    const SUITS = ['spades', 'hearts', 'diamonds', 'clubs'];
    const SUIT_SYMBOLS = { spades: '\u2660', hearts: '\u2665', diamonds: '\u2666', clubs: '\u2663' };
    const SUIT_COLORS = { spades: '#222', hearts: '#c0392b', diamonds: '#c0392b', clubs: '#222' };
    const VALUES = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];

    function createDeck(numDecks) {
        const deck = [];
        for (let d = 0; d < numDecks; d++) {
            for (const suit of SUITS) {
                for (let i = 0; i < VALUES.length; i++) {
                    const val = VALUES[i];
                    let bjVal = i + 1;
                    if (i >= 10) bjVal = 10;
                    if (i === 0) bjVal = 11; // Ace
                    let hiloVal = 0;
                    if (bjVal >= 2 && bjVal <= 6) hiloVal = 1;
                    else if (bjVal === 10 || bjVal === 11) hiloVal = -1;
                    deck.push({ value: val, suit, bjValue: bjVal, hiloValue: hiloVal, isAce: i === 0 });
                }
            }
        }
        // Shuffle
        for (let i = deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [deck[i], deck[j]] = [deck[j], deck[i]];
        }
        return deck;
    }

    function handValue(cards) {
        let total = 0, aces = 0;
        for (const c of cards) {
            total += c.bjValue;
            if (c.isAce) aces++;
        }
        while (total > 21 && aces > 0) { total -= 10; aces--; }
        return total;
    }

    // ===== GAME STATE =====
    const G = {
        state: 'menu', difficulty: 'normal',
        score: 0, streak: 0, maxStreak: 0,
        chips: 1000, maxChips: 1000, startChips: 1000,
        round: 0, totalCorrect: 0, totalGuesses: 0,
        deck: [], dealtCards: [], trueCount: 0,
        playerHand: [], dealerHand: [], dealerHidden: true,
        phase: 'betting', // betting, dealing, counting, playing, result
        bet: 0, countInput: '',
        buttons: [],
        particles: [], floatingTexts: [],
        shakeX: 0, shakeY: 0, shakeMag: 0,
        time: 0, lastTime: 0,
        showHint: false,
        numDecks: 1,
        diffSettings: {
            easy:   { numDecks: 1, startChips: 1500, dealSpeed: 1.5, showHints: true, betOptions: [25,50,100] },
            normal: { numDecks: 2, startChips: 1000, dealSpeed: 1.0, showHints: false, betOptions: [50,100,200] },
            hard:   { numDecks: 4, startChips: 500,  dealSpeed: 0.6, showHints: false, betOptions: [100,200,500] }
        },
        settings: null,
        dealTimer: 0, dealQueue: [],
        resultMessage: '', resultColor: '#fff'
    };

    // ===== INPUT =====
    let mouseX = 0, mouseY = 0;
    document.addEventListener('keydown', e => {
        if (e.key === 'Escape') {
            if (G.state === 'playing') pauseGame();
            else if (G.state === 'paused') resumeGame();
            e.preventDefault();
        }
        if (e.key === 'r' && G.state === 'gameover') startGame(G.difficulty);
        if (G.state === 'playing' && G.phase === 'counting') {
            if (e.key === 'Backspace') { G.countInput = G.countInput.slice(0, -1); e.preventDefault(); }
            else if (e.key === 'Enter') { submitCount(); e.preventDefault(); }
            else if (e.key === '-' && G.countInput === '') G.countInput = '-';
            else if (e.key >= '0' && e.key <= '9') G.countInput += e.key;
        }
        if (G.state === 'playing' && G.phase === 'playing') {
            if (e.key === 'h') playerHit();
            if (e.key === 's') playerStand();
            if (e.key === 'd') playerDouble();
        }
    });
    canvas.addEventListener('mousemove', e => { mouseX = e.clientX; mouseY = e.clientY; });
    canvas.addEventListener('click', e => { initAudio(); handleClick(e.clientX, e.clientY); });
    canvas.addEventListener('touchstart', e => {
        e.preventDefault(); initAudio();
        const t = e.touches[0]; mouseX = t.clientX; mouseY = t.clientY;
        handleClick(t.clientX, t.clientY);
    }, { passive: false });

    // ===== CLICK HANDLING =====
    function handleClick(x, y) {
        if (G.state !== 'playing') return;
        for (const btn of G.buttons) {
            if (x >= btn.x && x <= btn.x + btn.w && y >= btn.y && y <= btn.y + btn.h) {
                btn.action();
                return;
            }
        }
    }

    // ===== GAME PHASES =====
    function startBetting() {
        G.phase = 'betting';
        G.bet = 0;
        G.buttons = [];
        G.playerHand = [];
        G.dealerHand = [];
        G.dealerHidden = true;
        G.resultMessage = '';

        // Check if deck needs reshuffling
        if (G.deck.length < 15) {
            G.deck = createDeck(G.numDecks);
            G.trueCount = 0;
            G.dealtCards = [];
            addFloat(W / 2, H / 2, 'DECK RESHUFFLED', '#ffd700', 1.5);
        }
    }

    function placeBet(amount) {
        if (G.chips < amount) return;
        G.bet = amount;
        G.chips -= amount;
        sfxBet();
        dealCards();
    }

    function dealCards() {
        G.phase = 'dealing';
        G.dealQueue = ['player', 'dealer', 'player', 'dealer'];
        G.dealTimer = 0;
    }

    function dealNextCard() {
        if (G.dealQueue.length === 0) {
            // Done dealing, enter counting phase
            G.phase = 'counting';
            G.countInput = '';
            return;
        }
        const target = G.dealQueue.shift();
        const card = G.deck.pop();
        if (target === 'player') G.playerHand.push(card);
        else G.dealerHand.push(card);

        // Track running count (only face-up cards)
        if (target === 'player' || G.dealerHand.length === 1) {
            G.trueCount += card.hiloValue;
        }
        G.dealtCards.push(card);
        sfxDeal();
    }

    function submitCount() {
        const guess = parseInt(G.countInput || '0');
        G.totalGuesses++;
        G.round++;

        if (guess === G.trueCount) {
            G.totalCorrect++;
            G.streak++;
            if (G.streak > G.maxStreak) G.maxStreak = G.streak;
            const bonus = 10 * G.streak;
            G.score += bonus;
            sfxCorrect();
            addFloat(W / 2, H * 0.3, 'CORRECT! +' + bonus + (G.streak > 1 ? ' x' + G.streak : ''), '#2ecc71', 1.5);
            G.shakeMag = 3;
        } else {
            G.streak = 0;
            sfxWrong();
            addFloat(W / 2, H * 0.3, 'WRONG! Count was ' + G.trueCount, '#e74c3c', 2);
            G.shakeMag = 6;
            G.chips = Math.max(0, G.chips - 25);
        }

        // Move to playing phase
        G.phase = 'playing';
        // Check for natural blackjack
        if (handValue(G.playerHand) === 21) {
            sfxBlackjack();
            addFloat(W / 2, H * 0.5, 'BLACKJACK!', '#ffd700', 2);
            G.shakeMag = 8;
            playerBlackjack();
            return;
        }
    }

    function playerHit() {
        if (G.phase !== 'playing') return;
        const card = G.deck.pop();
        G.playerHand.push(card);
        G.trueCount += card.hiloValue;
        G.dealtCards.push(card);
        sfxDeal();

        if (handValue(G.playerHand) > 21) {
            sfxBust();
            G.shakeMag = 8;
            resolveHand('bust');
        }
    }

    function playerStand() {
        if (G.phase !== 'playing') return;
        dealerPlay();
    }

    function playerDouble() {
        if (G.phase !== 'playing' || G.playerHand.length !== 2 || G.chips < G.bet) return;
        G.chips -= G.bet;
        G.bet *= 2;
        const card = G.deck.pop();
        G.playerHand.push(card);
        G.trueCount += card.hiloValue;
        G.dealtCards.push(card);
        sfxDeal();

        if (handValue(G.playerHand) > 21) {
            sfxBust();
            resolveHand('bust');
        } else {
            dealerPlay();
        }
    }

    function playerBlackjack() {
        G.dealerHidden = false;
        // Reveal dealer hole card count
        if (G.dealerHand.length > 1) G.trueCount += G.dealerHand[1].hiloValue;

        if (handValue(G.dealerHand) === 21) {
            resolveHand('push');
        } else {
            const winnings = Math.floor(G.bet * 2.5);
            G.chips += winnings;
            G.score += 50;
            sfxChips();
            G.resultMessage = 'Blackjack! +' + winnings;
            G.resultColor = '#ffd700';
            G.phase = 'result';
        }
    }

    function dealerPlay() {
        G.dealerHidden = false;
        // Reveal hidden card's count
        if (G.dealerHand.length > 1) G.trueCount += G.dealerHand[1].hiloValue;

        // Dealer draws to 17
        while (handValue(G.dealerHand) < 17) {
            const card = G.deck.pop();
            G.dealerHand.push(card);
            G.trueCount += card.hiloValue;
            G.dealtCards.push(card);
        }

        const playerVal = handValue(G.playerHand);
        const dealerVal = handValue(G.dealerHand);

        if (dealerVal > 21) resolveHand('dealer_bust');
        else if (playerVal > dealerVal) resolveHand('win');
        else if (playerVal < dealerVal) resolveHand('lose');
        else resolveHand('push');
    }

    function resolveHand(result) {
        G.phase = 'result';
        switch (result) {
            case 'bust':
                G.resultMessage = 'BUST! Lost ' + G.bet;
                G.resultColor = '#e74c3c';
                sfxBust();
                break;
            case 'dealer_bust':
                G.chips += G.bet * 2;
                G.resultMessage = 'Dealer busts! +' + (G.bet * 2);
                G.resultColor = '#2ecc71';
                G.score += 30;
                sfxWin();
                sfxChips();
                break;
            case 'win':
                G.chips += G.bet * 2;
                G.resultMessage = 'You win! +' + (G.bet * 2);
                G.resultColor = '#2ecc71';
                G.score += 20;
                sfxWin();
                sfxChips();
                break;
            case 'lose':
                G.resultMessage = 'Dealer wins. Lost ' + G.bet;
                G.resultColor = '#e74c3c';
                break;
            case 'push':
                G.chips += G.bet;
                G.resultMessage = 'Push! Bet returned.';
                G.resultColor = '#f1c40f';
                break;
        }
        G.dealerHidden = false;

        if (G.chips <= 0) {
            setTimeout(() => gameOver('broke'), 1500);
        }
        if (G.round >= 30) {
            setTimeout(() => gameOver(G.chips > G.startChips ? 'profit' : 'survived'), 1500);
        }
    }

    // ===== PARTICLES =====
    function addFloat(x, y, text, color, dur) {
        G.floatingTexts.push({ x, y, text, color, life: dur, maxLife: dur });
    }

    // ===== GAME FLOW =====
    function startGame(diff) {
        initAudio(); sfxMenu();
        G.difficulty = diff;
        G.settings = G.diffSettings[diff];
        G.state = 'playing';
        G.score = 0; G.streak = 0; G.maxStreak = 0;
        G.numDecks = G.settings.numDecks;
        G.chips = G.settings.startChips; G.maxChips = G.settings.startChips; G.startChips = G.settings.startChips;
        G.round = 0; G.totalCorrect = 0; G.totalGuesses = 0;
        G.deck = createDeck(G.numDecks);
        G.dealtCards = []; G.trueCount = 0;
        G.particles = []; G.floatingTexts = [];
        G.shakeMag = 0; G.time = 0;
        G.showHint = G.settings.showHints;

        document.getElementById('menu-screen').style.display = 'none';
        document.getElementById('gameover-screen').style.display = 'none';
        document.getElementById('pause-overlay').style.display = 'none';
        document.getElementById('hud').style.display = 'flex';

        startBetting();
    }

    function pauseGame() { G.state = 'paused'; document.getElementById('pause-overlay').style.display = 'flex'; sfxMenu(); }
    function resumeGame() { G.state = 'playing'; document.getElementById('pause-overlay').style.display = 'none'; G.lastTime = performance.now(); sfxMenu(); }
    function quitToMenu() {
        G.state = 'menu';
        document.getElementById('menu-screen').style.display = 'flex';
        document.getElementById('pause-overlay').style.display = 'none';
        document.getElementById('gameover-screen').style.display = 'none';
        document.getElementById('hud').style.display = 'none';
        displayHighScores();
    }

    function gameOver(ending) {
        G.state = 'gameover';
        document.getElementById('gameover-screen').style.display = 'flex';
        const endings = {
            broke: { title: 'Bankrupt!', text: 'You lost all your chips. The house always wins... unless you count better.' },
            survived: { title: 'Session Over', text: 'You made it through 30 rounds. Not bad, but the house edge caught up.' },
            profit: { title: 'Card Shark!', text: 'You walked away with more than you started! The count was your friend.' },
            master: { title: 'Count Master!', text: 'Perfect counting, massive profits. The casino would ban you in real life!' }
        };
        if (ending === 'profit' && G.totalCorrect / Math.max(1, G.totalGuesses) > 0.85) ending = 'master';
        const e = endings[ending] || endings.survived;
        document.getElementById('go-title').textContent = e.title;
        document.getElementById('go-title').style.color = ending === 'broke' ? '#e74c3c' : '#ffd700';
        document.getElementById('go-ending').textContent = e.text;
        const accuracy = G.totalGuesses > 0 ? Math.round(G.totalCorrect / G.totalGuesses * 100) : 0;
        let html = '';
        html += '<p class="stat-row">Score: ' + G.score + '</p>';
        html += '<p class="stat-row">Final chips: ' + G.chips + '</p>';
        html += '<p class="stat-row">Profit: ' + (G.chips - G.startChips) + '</p>';
        html += '<p class="stat-row">Rounds played: ' + G.round + '</p>';
        html += '<p class="stat-row">Count accuracy: ' + accuracy + '% (' + G.totalCorrect + '/' + G.totalGuesses + ')</p>';
        html += '<p class="stat-row">Best streak: ' + G.maxStreak + '</p>';
        html += '<p class="stat-row">Difficulty: ' + G.difficulty + '</p>';
        document.getElementById('go-stats').innerHTML = html;
        saveHighScore(G.score, G.chips, accuracy);
    }

    // ===== LOCALSTORAGE =====
    function saveHighScore(score, chips, accuracy) {
        try {
            let scores = JSON.parse(localStorage.getItem('cardcount-scores') || '[]');
            scores.push({ score, chips, accuracy, date: new Date().toISOString(), difficulty: G.difficulty });
            scores.sort((a, b) => b.score - a.score);
            scores = scores.slice(0, 10);
            localStorage.setItem('cardcount-scores', JSON.stringify(scores));
        } catch(e) {}
    }

    function displayHighScores() {
        try {
            const scores = JSON.parse(localStorage.getItem('cardcount-scores') || '[]');
            const el = document.getElementById('high-scores');
            if (scores.length === 0) el.innerHTML = '<h3>High Scores</h3><p>No scores yet</p>';
            else {
                let html = '<h3>High Scores</h3>';
                scores.slice(0, 5).forEach((s, i) => {
                    html += '<p>' + (i + 1) + '. ' + s.score + ' pts (' + s.accuracy + '% acc, ' + s.difficulty + ')</p>';
                });
                el.innerHTML = html;
            }
        } catch(e) {}
    }

    // ===== DRAW CARD =====
    function drawPlayingCard(card, x, y, w, h, faceDown) {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(x + 2, y + 2, w, h);

        if (faceDown) {
            ctx.fillStyle = '#1a5276';
            ctx.fillRect(x, y, w, h);
            ctx.strokeStyle = '#2980b9';
            ctx.lineWidth = 2;
            ctx.strokeRect(x + 3, y + 3, w - 6, h - 6);
            // Pattern
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 4; j++) {
                    ctx.fillStyle = 'rgba(41,128,185,0.3)';
                    ctx.fillRect(x + 8 + i * 14, y + 8 + j * 14, 10, 10);
                }
            }
            return;
        }

        // White card
        ctx.fillStyle = '#f5f5f0';
        ctx.fillRect(x, y, w, h);
        ctx.strokeStyle = '#ccc';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, w, h);

        const color = SUIT_COLORS[card.suit];
        const symbol = SUIT_SYMBOLS[card.suit];

        // Value top-left
        ctx.fillStyle = color;
        ctx.font = 'bold 14px serif';
        ctx.textAlign = 'left';
        ctx.fillText(card.value, x + 5, y + 18);
        ctx.font = '12px serif';
        ctx.fillText(symbol, x + 5, y + 32);

        // Center suit
        ctx.font = '28px serif';
        ctx.textAlign = 'center';
        ctx.fillText(symbol, x + w / 2, y + h / 2 + 10);

        // Hi-Lo value indicator
        let hiloColor = '#888';
        let hiloText = '0';
        if (card.hiloValue === 1) { hiloColor = '#2ecc71'; hiloText = '+1'; }
        else if (card.hiloValue === -1) { hiloColor = '#e74c3c'; hiloText = '-1'; }
        ctx.fillStyle = hiloColor;
        ctx.font = '10px sans-serif';
        ctx.fillText(hiloText, x + w / 2, y + h - 6);
    }

    // ===== UPDATE =====
    function update(dt) {
        if (G.state !== 'playing') return;
        G.time += dt;

        // Deal animation
        if (G.phase === 'dealing') {
            G.dealTimer -= dt;
            if (G.dealTimer <= 0) {
                dealNextCard();
                G.dealTimer = 0.3 / G.settings.dealSpeed;
            }
        }

        // Shake decay
        G.shakeMag *= 0.9;
        G.shakeX = (Math.random() - 0.5) * G.shakeMag;
        G.shakeY = (Math.random() - 0.5) * G.shakeMag;

        // Floating texts
        G.floatingTexts.forEach(f => { f.y -= 25 * dt; f.life -= dt; });
        G.floatingTexts = G.floatingTexts.filter(f => f.life > 0);

        // HUD
        document.getElementById('round-val').textContent = G.round;
        document.getElementById('chips-bar').style.width = Math.min(100, G.chips / G.startChips * 100) + '%';
        document.getElementById('score-val').textContent = G.score;
        document.getElementById('streak-val').textContent = G.streak > 1 ? G.streak + 'x streak' : '';
        const acc = G.totalGuesses > 0 ? Math.round(G.totalCorrect / G.totalGuesses * 100) : 100;
        document.getElementById('acc-val').textContent = acc + '%';
        document.getElementById('cards-val').textContent = G.deck.length;
    }

    // ===== RENDER =====
    function draw() {
        ctx.save();
        ctx.translate(G.shakeX, G.shakeY);

        // Background â€” green felt
        const bgGrad = ctx.createRadialGradient(W / 2, H / 2, 0, W / 2, H / 2, Math.max(W, H) * 0.7);
        bgGrad.addColorStop(0, '#1a5e2e');
        bgGrad.addColorStop(1, '#0d2f17');
        ctx.fillStyle = bgGrad;
        ctx.fillRect(-10, -10, W + 20, H + 20);

        // Felt texture
        ctx.strokeStyle = 'rgba(255,255,255,0.02)';
        ctx.lineWidth = 1;
        for (let i = 0; i < W; i += 20) {
            ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, H); ctx.stroke();
        }

        if (G.state === 'menu') { ctx.restore(); return; }
        if (G.state !== 'playing' && G.state !== 'paused') { ctx.restore(); return; }

        G.buttons = [];
        const cardW = 55, cardH = 78;

        // Dealer hand
        ctx.fillStyle = 'rgba(255,255,255,0.1)';
        ctx.font = '12px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('DEALER', W / 2, H * 0.08);

        for (let i = 0; i < G.dealerHand.length; i++) {
            const x = W / 2 - (G.dealerHand.length * (cardW + 5)) / 2 + i * (cardW + 5);
            const faceDown = G.dealerHidden && i === 1;
            drawPlayingCard(G.dealerHand[i], x, H * 0.1, cardW, cardH, faceDown);
        }

        if (G.dealerHand.length > 0 && !G.dealerHidden) {
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(handValue(G.dealerHand), W / 2, H * 0.1 + cardH + 18);
        }

        // Player hand
        ctx.fillStyle = 'rgba(255,255,255,0.1)';
        ctx.font = '12px sans-serif';
        ctx.fillText('PLAYER', W / 2, H * 0.52);

        for (let i = 0; i < G.playerHand.length; i++) {
            const x = W / 2 - (G.playerHand.length * (cardW + 5)) / 2 + i * (cardW + 5);
            drawPlayingCard(G.playerHand[i], x, H * 0.54, cardW, cardH, false);
        }

        if (G.playerHand.length > 0) {
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px sans-serif';
            ctx.textAlign = 'center';
            const pv = handValue(G.playerHand);
            ctx.fillText(pv, W / 2, H * 0.54 + cardH + 18);
            if (pv > 21) { ctx.fillStyle = '#e74c3c'; ctx.fillText('BUST', W / 2, H * 0.54 + cardH + 34); }
        }

        // Chips display
        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Chips: ' + G.chips, W / 2, H - 20);
        if (G.bet > 0) {
            ctx.fillStyle = '#ff8c00';
            ctx.fillText('Bet: ' + G.bet, W / 2, H - 40);
        }

        // Phase-specific UI
        if (G.phase === 'betting') {
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 20px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Place your bet', W / 2, H * 0.4);

            const opts = G.settings.betOptions;
            for (let i = 0; i < opts.length; i++) {
                const bx = W / 2 - (opts.length * 80) / 2 + i * 80;
                const by = H * 0.44;
                const canBet = G.chips >= opts[i];
                const hovered = mouseX >= bx && mouseX <= bx + 70 && mouseY >= by && mouseY <= by + 35;

                ctx.fillStyle = canBet ? (hovered ? 'rgba(255,215,0,0.3)' : 'rgba(255,215,0,0.15)') : 'rgba(100,100,100,0.15)';
                ctx.fillRect(bx, by, 70, 35);
                ctx.strokeStyle = canBet ? '#ffd700' : '#555';
                ctx.lineWidth = 1;
                ctx.strokeRect(bx, by, 70, 35);
                ctx.fillStyle = canBet ? '#ffd700' : '#666';
                ctx.font = 'bold 14px sans-serif';
                ctx.fillText(opts[i], bx + 35, by + 23);

                if (canBet) {
                    const betAmt = opts[i];
                    G.buttons.push({ x: bx, y: by, w: 70, h: 35, action: () => placeBet(betAmt) });
                }
            }
        }

        if (G.phase === 'counting') {
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(W / 2 - 150, H * 0.32, 300, 80);

            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 16px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('What is the running count?', W / 2, H * 0.35);

            // Input display
            ctx.fillStyle = '#111';
            ctx.fillRect(W / 2 - 40, H * 0.37, 80, 30);
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 2;
            ctx.strokeRect(W / 2 - 40, H * 0.37, 80, 30);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 20px sans-serif';
            ctx.fillText(G.countInput || '_', W / 2, H * 0.37 + 22);

            // Number pad
            const nums = ['-', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'OK'];
            const padY = H * 0.42;
            for (let i = 0; i < nums.length; i++) {
                const col = i % 6, row = Math.floor(i / 6);
                const px = W / 2 - 150 + col * 52;
                const py = padY + row * 35;
                const hovered = mouseX >= px && mouseX <= px + 48 && mouseY >= py && mouseY <= py + 30;
                ctx.fillStyle = hovered ? 'rgba(255,215,0,0.3)' : 'rgba(255,215,0,0.1)';
                ctx.fillRect(px, py, 48, 30);
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 1;
                ctx.strokeRect(px, py, 48, 30);
                ctx.fillStyle = '#ffd700';
                ctx.font = 'bold 14px sans-serif';
                ctx.fillText(nums[i], px + 24, py + 20);
                const numVal = nums[i];
                G.buttons.push({ x: px, y: py, w: 48, h: 30, action: () => {
                    if (numVal === 'OK') submitCount();
                    else if (numVal === '-') { if (G.countInput === '') G.countInput = '-'; }
                    else G.countInput += numVal;
                }});
            }

            // Hint
            if (G.showHint) {
                ctx.fillStyle = 'rgba(46,204,113,0.4)';
                ctx.font = '11px sans-serif';
                ctx.fillText('Hint: count is ' + G.trueCount, W / 2, padY + 80);
            }
        }

        if (G.phase === 'playing') {
            const btns = [
                { label: 'Hit (H)', action: playerHit },
                { label: 'Stand (S)', action: playerStand },
                { label: 'Double (D)', action: playerDouble }
            ];
            for (let i = 0; i < btns.length; i++) {
                const bx = W / 2 - (btns.length * 85) / 2 + i * 85;
                const by = H * 0.75;
                const hovered = mouseX >= bx && mouseX <= bx + 80 && mouseY >= by && mouseY <= by + 35;
                const canUse = i !== 2 || (G.playerHand.length === 2 && G.chips >= G.bet);

                ctx.fillStyle = canUse ? (hovered ? 'rgba(255,215,0,0.3)' : 'rgba(255,215,0,0.15)') : 'rgba(100,100,100,0.1)';
                ctx.fillRect(bx, by, 80, 35);
                ctx.strokeStyle = canUse ? '#ffd700' : '#555';
                ctx.lineWidth = 1;
                ctx.strokeRect(bx, by, 80, 35);
                ctx.fillStyle = canUse ? '#fff' : '#666';
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(btns[i].label, bx + 40, by + 22);

                if (canUse) G.buttons.push({ x: bx, y: by, w: 80, h: 35, action: btns[i].action });
            }
        }

        if (G.phase === 'result') {
            ctx.fillStyle = G.resultColor;
            ctx.font = 'bold 22px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(G.resultMessage, W / 2, H * 0.4);

            // Next round button
            const nx = W / 2 - 60, ny = H * 0.44;
            const hovered = mouseX >= nx && mouseX <= nx + 120 && mouseY >= ny && mouseY <= ny + 35;
            ctx.fillStyle = hovered ? 'rgba(255,215,0,0.3)' : 'rgba(255,215,0,0.15)';
            ctx.fillRect(nx, ny, 120, 35);
            ctx.strokeStyle = '#ffd700';
            ctx.strokeRect(nx, ny, 120, 35);
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 14px sans-serif';
            ctx.fillText('Next Hand', nx + 60, ny + 23);
            G.buttons.push({ x: nx, y: ny, w: 120, h: 35, action: startBetting });
        }

        // Running count display (always visible at bottom)
        if (G.phase !== 'counting') {
            ctx.fillStyle = 'rgba(255,255,255,0.15)';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'right';
            ctx.fillText('Cards dealt: ' + G.dealtCards.length + ' | Deck: ' + G.deck.length, W - 15, H - 8);
        }

        // Floating texts
        G.floatingTexts.forEach(f => {
            ctx.globalAlpha = f.life / f.maxLife;
            ctx.fillStyle = f.color;
            ctx.font = 'bold 16px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(f.text, f.x, f.y);
        });
        ctx.globalAlpha = 1;

        ctx.restore();
    }

    // ===== MAIN LOOP =====
    function loop(now) {
        if (!G.lastTime) G.lastTime = now;
        const dt = Math.min((now - G.lastTime) / 1000, 0.05);
        G.lastTime = now;
        if (G.state === 'playing') update(dt);
        draw();
        requestAnimationFrame(loop);
    }

    displayHighScores();
    requestAnimationFrame(loop);
    </script>
</body>
</html>
