<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Code Quest - Visual Programming Puzzle Game. Solve puzzles with drag-and-drop blocks that compile to real JavaScript. Learn programming through play!">
    <meta name="color-scheme" content="light dark">
    <meta name="theme-color" content="#6366f1" media="(prefers-color-scheme: light)">
    <meta name="theme-color" content="#818cf8" media="(prefers-color-scheme: dark)">
    <!-- game, education, programming, blocks, visual, puzzle, javascript -->
    <title>Code Quest - Visual Programming Puzzle Game</title>
    <style>
        /* === CSS RESET & BASE === */
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            /* Light theme (default) */
            --bg-primary: #f0f4f8;
            --bg-secondary: #ffffff;
            --bg-tertiary: #e2e8f0;
            --text-primary: #1a202c;
            --text-secondary: #4a5568;
            --text-muted: #718096;
            --accent-primary: #6366f1;
            --accent-secondary: #8b5cf6;
            --accent-success: #10b981;
            --accent-warning: #f59e0b;
            --accent-danger: #ef4444;
            --border-color: #e2e8f0;
            --shadow-sm: 0 1px 3px rgba(0,0,0,0.1);
            --shadow-md: 0 4px 6px rgba(0,0,0,0.1);
            --shadow-lg: 0 10px 25px rgba(0,0,0,0.15);
            --block-variable: #10b981;
            --block-math: #3b82f6;
            --block-logic: #8b5cf6;
            --block-loop: #f59e0b;
            --block-function: #ec4899;
            --block-output: #06b6d4;
        }

        [data-theme="dark"] {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-tertiary: #334155;
            --text-primary: #f1f5f9;
            --text-secondary: #cbd5e1;
            --text-muted: #94a3b8;
            --accent-primary: #818cf8;
            --accent-secondary: #a78bfa;
            --border-color: #475569;
            --shadow-sm: 0 1px 3px rgba(0,0,0,0.3);
            --shadow-md: 0 4px 6px rgba(0,0,0,0.4);
            --shadow-lg: 0 10px 25px rgba(0,0,0,0.5);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow: hidden;
            transition: background 0.3s, color 0.3s;
        }

        /* === DATA CONTROLS (Import/Export) === */
        .data-controls {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
            display: flex;
            gap: 8px;
        }

        .data-controls button {
            padding: 8px 16px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .data-controls button:hover {
            background: var(--accent-primary);
            color: white;
            border-color: var(--accent-primary);
        }

        /* === MAIN LAYOUT === */
        .app-container {
            display: grid;
            grid-template-columns: 300px 1fr 280px;
            grid-template-rows: 60px 1fr;
            height: 100vh;
            gap: 0;
        }

        /* === HEADER === */
        .header {
            grid-column: 1 / -1;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            box-shadow: var(--shadow-sm);
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .logo {
            font-size: 22px;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .level-info {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 16px;
            background: var(--bg-tertiary);
            border-radius: 8px;
        }

        .level-badge {
            background: var(--accent-primary);
            color: white;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
        }

        .level-title {
            font-size: 14px;
            font-weight: 500;
        }

        .header-center {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn-primary {
            background: var(--accent-success);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .btn-secondary:hover {
            background: var(--accent-primary);
            color: white;
        }

        .btn-danger {
            background: var(--accent-danger);
            color: white;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .theme-toggle {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: none;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .theme-toggle:hover {
            background: var(--accent-primary);
            color: white;
        }

        .stars-display {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 20px;
            color: var(--accent-warning);
        }

        .stars-count {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
        }

        /* === GAME WORLD PANEL === */
        .game-world {
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panel-header {
            padding: 15px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .game-canvas-container {
            flex: 1;
            position: relative;
            padding: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #gameCanvas {
            border-radius: 12px;
            box-shadow: var(--shadow-md);
            max-width: 100%;
            max-height: 100%;
        }

        .goal-display {
            padding: 15px;
            background: var(--bg-tertiary);
            border-top: 1px solid var(--border-color);
        }

        .goal-title {
            font-size: 12px;
            text-transform: uppercase;
            color: var(--text-muted);
            margin-bottom: 8px;
            letter-spacing: 0.5px;
        }

        .goal-text {
            font-size: 14px;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        .hint-btn {
            margin-top: 10px;
            padding: 6px 12px;
            background: var(--accent-warning);
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .hint-btn:hover {
            transform: scale(1.05);
        }

        .hint-text {
            margin-top: 10px;
            padding: 10px;
            background: rgba(245, 158, 11, 0.1);
            border-radius: 6px;
            font-size: 13px;
            color: var(--accent-warning);
            display: none;
        }

        .hint-text.visible {
            display: block;
        }

        /* === WORKSPACE (Center) === */
        .workspace {
            display: flex;
            flex-direction: column;
            background: var(--bg-primary);
            overflow: hidden;
        }

        .workspace-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 20px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
        }

        .view-tabs {
            display: flex;
            gap: 5px;
        }

        .view-tab {
            padding: 8px 16px;
            background: transparent;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
        }

        .view-tab.active {
            background: var(--accent-primary);
            color: white;
        }

        .view-tab:hover:not(.active) {
            background: var(--bg-tertiary);
        }

        .workspace-content {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        /* Block View */
        .block-workspace {
            position: absolute;
            inset: 0;
            padding: 20px;
            overflow: auto;
            background:
                linear-gradient(90deg, var(--border-color) 1px, transparent 1px),
                linear-gradient(var(--border-color) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        .blocks-container {
            min-height: 400px;
            min-width: 100%;
            padding: 20px;
        }

        .block {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 12px 16px;
            border-radius: 8px;
            color: white;
            font-size: 14px;
            font-weight: 500;
            cursor: move;
            margin: 5px;
            box-shadow: var(--shadow-sm);
            transition: transform 0.2s, box-shadow 0.2s;
            user-select: none;
            position: relative;
        }

        .block:hover {
            transform: scale(1.02);
            box-shadow: var(--shadow-md);
        }

        .block.dragging {
            opacity: 0.8;
            transform: scale(1.05);
            z-index: 100;
        }

        .block.executing {
            animation: blockPulse 0.5s ease-in-out infinite;
        }

        @keyframes blockPulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(255,255,255,0.4); }
            50% { box-shadow: 0 0 0 8px rgba(255,255,255,0); }
        }

        .block-variable { background: var(--block-variable); }
        .block-math { background: var(--block-math); }
        .block-logic { background: var(--block-logic); }
        .block-loop { background: var(--block-loop); }
        .block-function { background: var(--block-function); }
        .block-output { background: var(--block-output); }

        .block-input {
            padding: 4px 8px;
            border: none;
            border-radius: 4px;
            background: rgba(255,255,255,0.9);
            color: #333;
            font-size: 13px;
            min-width: 60px;
            max-width: 100px;
        }

        .block-select {
            padding: 4px 8px;
            border: none;
            border-radius: 4px;
            background: rgba(255,255,255,0.9);
            color: #333;
            font-size: 13px;
        }

        .block-delete {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent-danger);
            color: white;
            border: none;
            cursor: pointer;
            font-size: 12px;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .block:hover .block-delete {
            display: flex;
        }

        .block-container {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 20px;
            min-height: 200px;
            box-shadow: var(--shadow-sm);
        }

        .block-container-label {
            font-size: 12px;
            text-transform: uppercase;
            color: var(--text-muted);
            margin-bottom: 10px;
            letter-spacing: 0.5px;
        }

        .drop-zone {
            min-height: 60px;
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            color: var(--text-muted);
            font-size: 14px;
            transition: all 0.2s;
        }

        .drop-zone.drag-over {
            border-color: var(--accent-primary);
            background: rgba(99, 102, 241, 0.1);
        }

        .drop-zone.has-blocks {
            flex-wrap: wrap;
            justify-content: flex-start;
            border-style: solid;
            border-color: var(--border-color);
        }

        /* Code View */
        .code-workspace {
            position: absolute;
            inset: 0;
            display: none;
            flex-direction: column;
        }

        .code-workspace.active {
            display: flex;
        }

        .code-editor {
            flex: 1;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            padding: 20px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            overflow: auto;
            white-space: pre-wrap;
        }

        .code-keyword { color: #c586c0; }
        .code-string { color: #ce9178; }
        .code-number { color: #b5cea8; }
        .code-function { color: #dcdcaa; }
        .code-variable { color: #9cdcfe; }
        .code-comment { color: #6a9955; }

        /* === BLOCK PALETTE (Right) === */
        .block-palette {
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .palette-categories {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }

        .palette-category {
            margin-bottom: 20px;
        }

        .palette-category-title {
            font-size: 12px;
            text-transform: uppercase;
            color: var(--text-muted);
            margin-bottom: 10px;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .palette-category-title::before {
            content: '';
            width: 8px;
            height: 8px;
            border-radius: 2px;
        }

        .palette-category.variables .palette-category-title::before { background: var(--block-variable); }
        .palette-category.math .palette-category-title::before { background: var(--block-math); }
        .palette-category.logic .palette-category-title::before { background: var(--block-logic); }
        .palette-category.loops .palette-category-title::before { background: var(--block-loop); }
        .palette-category.functions .palette-category-title::before { background: var(--block-function); }
        .palette-category.output .palette-category-title::before { background: var(--block-output); }

        .palette-block {
            padding: 10px 14px;
            margin-bottom: 8px;
            border-radius: 6px;
            color: white;
            font-size: 13px;
            font-weight: 500;
            cursor: grab;
            transition: all 0.2s;
            box-shadow: var(--shadow-sm);
        }

        .palette-block:hover {
            transform: translateX(4px);
            box-shadow: var(--shadow-md);
        }

        .palette-block:active {
            cursor: grabbing;
        }

        .palette-block.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* === CODE OUTPUT PANEL === */
        .code-output-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 200px;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            transform: translateY(160px);
            transition: transform 0.3s;
            z-index: 50;
        }

        .code-output-panel.expanded {
            transform: translateY(0);
        }

        .code-output-header {
            padding: 10px 20px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        .code-output-content {
            flex: 1;
            overflow: auto;
            padding: 15px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
        }

        .output-line {
            padding: 4px 0;
            border-bottom: 1px solid var(--border-color);
        }

        .output-line.success { color: var(--accent-success); }
        .output-line.error { color: var(--accent-danger); }
        .output-line.info { color: var(--accent-primary); }

        /* === LEVEL SELECTION SCREEN === */
        .level-screen {
            position: fixed;
            inset: 0;
            background: var(--bg-primary);
            z-index: 2000;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px;
        }

        .level-screen.active {
            display: flex;
        }

        .level-screen-title {
            font-size: 48px;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .level-screen-subtitle {
            font-size: 18px;
            color: var(--text-secondary);
            margin-bottom: 40px;
        }

        .level-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 20px;
            max-width: 900px;
            width: 100%;
            margin-bottom: 40px;
        }

        .level-card {
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 16px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .level-card:hover:not(.locked) {
            transform: translateY(-5px);
            border-color: var(--accent-primary);
            box-shadow: var(--shadow-lg);
        }

        .level-card.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .level-card.completed {
            border-color: var(--accent-success);
        }

        .level-card.current {
            border-color: var(--accent-primary);
            box-shadow: 0 0 20px rgba(99, 102, 241, 0.3);
        }

        .level-number {
            font-size: 32px;
            font-weight: 700;
            color: var(--accent-primary);
            margin-bottom: 8px;
        }

        .level-card.locked .level-number {
            color: var(--text-muted);
        }

        .level-card.locked .level-number::before {
            content: 'üîí';
        }

        .level-name {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }

        .level-stars {
            font-size: 18px;
            color: var(--accent-warning);
        }

        .level-stars.empty {
            color: var(--text-muted);
        }

        .level-screen-buttons {
            display: flex;
            gap: 15px;
        }

        .level-editor-btn {
            padding: 12px 24px;
            background: var(--accent-secondary);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .level-editor-btn:hover {
            transform: scale(1.05);
        }

        /* === LEVEL EDITOR === */
        .level-editor {
            position: fixed;
            inset: 0;
            background: var(--bg-primary);
            z-index: 2000;
            display: none;
            flex-direction: column;
        }

        .level-editor.active {
            display: flex;
        }

        .editor-header {
            padding: 20px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .editor-title {
            font-size: 24px;
            font-weight: 700;
        }

        .editor-content {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 20px;
            overflow: auto;
        }

        .editor-section {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 20px;
        }

        .editor-section-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 15px;
            color: var(--text-primary);
        }

        .editor-field {
            margin-bottom: 15px;
        }

        .editor-field label {
            display: block;
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: 5px;
        }

        .editor-field input,
        .editor-field textarea,
        .editor-field select {
            width: 100%;
            padding: 10px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 14px;
        }

        .editor-field textarea {
            min-height: 100px;
            resize: vertical;
        }

        /* === CELEBRATION OVERLAY === */
        .celebration {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
        }

        .celebration.active {
            display: flex;
        }

        .celebration-content {
            text-align: center;
            animation: celebrationPop 0.5s ease-out;
        }

        @keyframes celebrationPop {
            0% { transform: scale(0); opacity: 0; }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }

        .celebration-stars {
            font-size: 60px;
            margin-bottom: 20px;
        }

        .celebration-title {
            font-size: 48px;
            font-weight: 700;
            color: white;
            margin-bottom: 10px;
        }

        .celebration-subtitle {
            font-size: 24px;
            color: var(--accent-warning);
            margin-bottom: 30px;
        }

        .celebration-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            animation: confettiFall 3s ease-out forwards;
        }

        @keyframes confettiFall {
            0% { transform: translateY(-100vh) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }

        /* === DEBUGGER === */
        .debugger-panel {
            position: fixed;
            bottom: 20px;
            left: 320px;
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 15px;
            box-shadow: var(--shadow-lg);
            display: none;
            z-index: 100;
        }

        .debugger-panel.active {
            display: block;
        }

        .debugger-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .debugger-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .debugger-btn {
            width: 36px;
            height: 36px;
            border: none;
            border-radius: 6px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .debugger-btn:hover {
            background: var(--accent-primary);
            color: white;
        }

        .debugger-variables {
            font-family: monospace;
            font-size: 13px;
            max-height: 150px;
            overflow: auto;
        }

        .debugger-var {
            padding: 4px 8px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            margin-bottom: 4px;
        }

        /* === RESPONSIVE === */
        @media (max-width: 1024px) {
            .app-container {
                grid-template-columns: 1fr;
                grid-template-rows: 60px auto 1fr auto;
            }

            .game-world {
                display: none;
            }

            .block-palette {
                border-left: none;
                border-top: 1px solid var(--border-color);
                max-height: 200px;
            }

            .data-controls {
                position: static;
                justify-content: center;
                padding: 10px;
                background: var(--bg-secondary);
            }
        }

        @media (max-width: 768px) {
            .header {
                flex-wrap: wrap;
                padding: 10px;
                gap: 10px;
            }

            .header-center {
                order: 3;
                width: 100%;
                justify-content: center;
            }

            .level-screen-title {
                font-size: 32px;
            }

            .level-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .celebration-title {
                font-size: 32px;
            }
        }
    </style>
</head>
<body>
    <!-- Data Controls -->
    <div class="data-controls">
        <button onclick="game.exportProgress()">Export Progress</button>
        <button onclick="document.getElementById('importFile').click()">Import Progress</button>
        <input type="file" id="importFile" accept=".json" style="display: none;" onchange="game.importProgress(event)">
        <button onclick="game.exportCode()">Export Code</button>
    </div>

    <!-- Level Selection Screen -->
    <div class="level-screen active" id="levelScreen">
        <h1 class="level-screen-title">Code Quest</h1>
        <p class="level-screen-subtitle">Learn programming through puzzle adventures</p>
        <div class="level-grid" id="levelGrid"></div>
        <div class="level-screen-buttons">
            <button class="level-editor-btn" onclick="game.openLevelEditor()">Create Level</button>
        </div>
    </div>

    <!-- Level Editor -->
    <div class="level-editor" id="levelEditor">
        <div class="editor-header">
            <h2 class="editor-title">Level Editor</h2>
            <div>
                <button class="btn btn-secondary" onclick="game.testCustomLevel()">Test Level</button>
                <button class="btn btn-primary" onclick="game.saveCustomLevel()">Save Level</button>
                <button class="btn btn-danger" onclick="game.closeLevelEditor()">Close</button>
            </div>
        </div>
        <div class="editor-content">
            <div class="editor-section">
                <h3 class="editor-section-title">Level Settings</h3>
                <div class="editor-field">
                    <label>Level Name</label>
                    <input type="text" id="editorLevelName" placeholder="My Custom Level">
                </div>
                <div class="editor-field">
                    <label>Puzzle Type</label>
                    <select id="editorPuzzleType">
                        <option value="move">Move Character</option>
                        <option value="math">Math Problem</option>
                        <option value="collect">Collect Items</option>
                        <option value="logic">Logic Puzzle</option>
                    </select>
                </div>
                <div class="editor-field">
                    <label>Description</label>
                    <textarea id="editorDescription" placeholder="Describe the puzzle goal..."></textarea>
                </div>
                <div class="editor-field">
                    <label>Hint</label>
                    <textarea id="editorHint" placeholder="Hint for players..."></textarea>
                </div>
            </div>
            <div class="editor-section">
                <h3 class="editor-section-title">Available Blocks</h3>
                <div class="editor-field">
                    <label>Select blocks available for this puzzle:</label>
                    <div id="editorBlocks" style="margin-top: 10px;"></div>
                </div>
                <div class="editor-field">
                    <label>Target Value (for math/logic puzzles)</label>
                    <input type="text" id="editorTarget" placeholder="e.g., 42">
                </div>
                <div class="editor-field">
                    <label>Grid Size</label>
                    <select id="editorGridSize">
                        <option value="5">5x5</option>
                        <option value="7">7x7</option>
                        <option value="10">10x10</option>
                    </select>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Game Interface -->
    <div class="app-container" id="gameInterface" style="display: none;">
        <!-- Header -->
        <div class="header">
            <div class="header-left">
                <span class="logo">Code Quest</span>
                <div class="level-info">
                    <span class="level-badge" id="levelBadge">Level 1</span>
                    <span class="level-title" id="levelTitle">First Steps</span>
                </div>
            </div>
            <div class="header-center">
                <button class="btn btn-primary" id="runBtn" onclick="game.run()">
                    <span>Run</span>
                </button>
                <button class="btn btn-secondary" onclick="game.stepThrough()">
                    <span>Step</span>
                </button>
                <button class="btn btn-secondary" onclick="game.reset()">
                    <span>Reset</span>
                </button>
            </div>
            <div class="header-right">
                <div class="stars-display">
                    <span id="totalStars">0</span>
                    <span class="stars-count">stars</span>
                </div>
                <button class="theme-toggle" onclick="game.toggleTheme()" title="Toggle theme" aria-label="Toggle dark/light theme">
                    <span id="themeIcon">üåô</span>
                </button>
                <button class="btn btn-secondary" onclick="game.showLevelSelect()">Levels</button>
            </div>
        </div>

        <!-- Game World Panel -->
        <div class="game-world">
            <div class="panel-header">
                <span>Game World</span>
            </div>
            <div class="game-canvas-container">
                <canvas id="gameCanvas" width="260" height="260"></canvas>
            </div>
            <div class="goal-display">
                <div class="goal-title">Goal</div>
                <p class="goal-text" id="goalText">Move the character to the flag!</p>
                <button class="hint-btn" onclick="game.showHint()">Show Hint</button>
                <div class="hint-text" id="hintText"></div>
            </div>
        </div>

        <!-- Workspace -->
        <div class="workspace">
            <div class="workspace-header">
                <div class="view-tabs">
                    <button class="view-tab active" onclick="game.switchView('blocks')" id="blocksTab">Blocks</button>
                    <button class="view-tab" onclick="game.switchView('code')" id="codeTab">Code</button>
                </div>
                <button class="btn btn-secondary" onclick="game.clearWorkspace()">Clear</button>
            </div>
            <div class="workspace-content">
                <div class="block-workspace" id="blockWorkspace">
                    <div class="block-container">
                        <div class="block-container-label">Your Program</div>
                        <div class="drop-zone" id="mainDropZone" ondragover="game.handleDragOver(event)" ondrop="game.handleDrop(event)" ondragleave="game.handleDragLeave(event)">
                            Drag blocks here to build your program
                        </div>
                    </div>
                </div>
                <div class="code-workspace" id="codeWorkspace">
                    <div class="code-editor" id="codeEditor">
                        <span class="code-comment">// Your generated JavaScript code will appear here</span>
                    </div>
                </div>
            </div>

            <!-- Code Output Panel -->
            <div class="code-output-panel" id="outputPanel">
                <div class="code-output-header" onclick="game.toggleOutput()">
                    <span>Console Output</span>
                    <span id="outputToggle">‚ñ≤</span>
                </div>
                <div class="code-output-content" id="outputContent"></div>
            </div>
        </div>

        <!-- Block Palette -->
        <div class="block-palette">
            <div class="panel-header">
                <span>Blocks</span>
            </div>
            <div class="palette-categories" id="paletteCategories"></div>
        </div>
    </div>

    <!-- Debugger Panel -->
    <div class="debugger-panel" id="debuggerPanel">
        <div class="debugger-title">Debugger</div>
        <div class="debugger-controls">
            <button class="debugger-btn" onclick="game.debugStep()" title="Step">‚è≠</button>
            <button class="debugger-btn" onclick="game.debugContinue()" title="Continue">‚ñ∂</button>
            <button class="debugger-btn" onclick="game.debugStop()" title="Stop">‚èπ</button>
        </div>
        <div class="debugger-variables" id="debuggerVariables"></div>
    </div>

    <!-- Celebration Overlay -->
    <div class="celebration" id="celebration">
        <div class="celebration-content">
            <div class="celebration-stars" id="celebrationStars"></div>
            <h2 class="celebration-title">Level Complete!</h2>
            <p class="celebration-subtitle" id="celebrationSubtitle">Perfect Solution!</p>
            <div class="celebration-buttons">
                <button class="btn btn-secondary" onclick="game.replayLevel()">Replay</button>
                <button class="btn btn-primary" onclick="game.nextLevel()">Next Level</button>
            </div>
        </div>
    </div>

    <script>
        // === CODE QUEST GAME ENGINE ===
        const APP_NAME = 'code-quest';

        // Block definitions
        const BLOCK_TYPES = {
            // Variables
            set_var: { category: 'variables', label: 'Set', template: 'set {var} to {value}', inputs: ['var', 'value'] },
            get_var: { category: 'variables', label: 'Get', template: 'get {var}', inputs: ['var'] },

            // Math
            add: { category: 'math', label: 'Add', template: '{a} + {b}', inputs: ['a', 'b'] },
            subtract: { category: 'math', label: 'Subtract', template: '{a} - {b}', inputs: ['a', 'b'] },
            multiply: { category: 'math', label: 'Multiply', template: '{a} * {b}', inputs: ['a', 'b'] },
            divide: { category: 'math', label: 'Divide', template: '{a} / {b}', inputs: ['a', 'b'] },

            // Logic
            if_block: { category: 'logic', label: 'If', template: 'if {condition}', inputs: ['condition'], hasBody: true },
            else_block: { category: 'logic', label: 'Else', template: 'else', inputs: [] },
            and: { category: 'logic', label: 'And', template: '{a} and {b}', inputs: ['a', 'b'] },
            or: { category: 'logic', label: 'Or', template: '{a} or {b}', inputs: ['a', 'b'] },
            not: { category: 'logic', label: 'Not', template: 'not {a}', inputs: ['a'] },
            equals: { category: 'logic', label: 'Equals', template: '{a} == {b}', inputs: ['a', 'b'] },
            greater: { category: 'logic', label: 'Greater', template: '{a} > {b}', inputs: ['a', 'b'] },
            less: { category: 'logic', label: 'Less', template: '{a} < {b}', inputs: ['a', 'b'] },

            // Loops
            repeat: { category: 'loops', label: 'Repeat', template: 'repeat {times} times', inputs: ['times'], hasBody: true },
            while_loop: { category: 'loops', label: 'While', template: 'while {condition}', inputs: ['condition'], hasBody: true },

            // Functions
            define_func: { category: 'functions', label: 'Function', template: 'function {name}()', inputs: ['name'], hasBody: true },
            call_func: { category: 'functions', label: 'Call', template: 'call {name}()', inputs: ['name'] },

            // Output
            print: { category: 'output', label: 'Print', template: 'print {message}', inputs: ['message'] },
            return_val: { category: 'output', label: 'Return', template: 'return {value}', inputs: ['value'] },

            // Movement (for game puzzles)
            move_up: { category: 'movement', label: 'Move Up', template: 'move up', inputs: [] },
            move_down: { category: 'movement', label: 'Move Down', template: 'move down', inputs: [] },
            move_left: { category: 'movement', label: 'Move Left', template: 'move left', inputs: [] },
            move_right: { category: 'movement', label: 'Move Right', template: 'move right', inputs: [] },
            turn_left: { category: 'movement', label: 'Turn Left', template: 'turn left', inputs: [] },
            turn_right: { category: 'movement', label: 'Turn Right', template: 'turn right', inputs: [] }
        };

        // Level definitions
        const LEVELS = [
            {
                id: 1,
                name: 'First Steps',
                type: 'move',
                description: 'Move the character to the flag!',
                hint: 'Use the Move Right block to move the character.',
                goal: { x: 4, y: 2 },
                start: { x: 1, y: 2 },
                obstacles: [],
                availableBlocks: ['move_up', 'move_down', 'move_left', 'move_right'],
                gridSize: 5,
                optimalMoves: 3
            },
            {
                id: 2,
                name: 'Around the Corner',
                type: 'move',
                description: 'Navigate around the wall to reach the goal.',
                hint: 'Go down first, then around the wall.',
                goal: { x: 4, y: 2 },
                start: { x: 1, y: 2 },
                obstacles: [{ x: 2, y: 1 }, { x: 2, y: 2 }, { x: 2, y: 3 }],
                availableBlocks: ['move_up', 'move_down', 'move_left', 'move_right'],
                gridSize: 5,
                optimalMoves: 5
            },
            {
                id: 3,
                name: 'Loop the Path',
                type: 'move',
                description: 'Use a loop to move efficiently!',
                hint: 'Use repeat 4 times with move right.',
                goal: { x: 4, y: 0 },
                start: { x: 0, y: 0 },
                obstacles: [],
                availableBlocks: ['move_up', 'move_down', 'move_left', 'move_right', 'repeat'],
                gridSize: 5,
                optimalMoves: 4
            },
            {
                id: 4,
                name: 'Simple Math',
                type: 'math',
                description: 'Calculate the result: 5 + 7',
                hint: 'Use the Add block with values 5 and 7, then Print the result.',
                target: 12,
                availableBlocks: ['set_var', 'get_var', 'add', 'print'],
                gridSize: 5,
                optimalMoves: 3
            },
            {
                id: 5,
                name: 'Variable Storage',
                type: 'math',
                description: 'Store 10 in variable "x", multiply by 4, print result.',
                hint: 'Set x to 10, then use multiply with x and 4.',
                target: 40,
                availableBlocks: ['set_var', 'get_var', 'multiply', 'print'],
                gridSize: 5,
                optimalMoves: 4
            },
            {
                id: 6,
                name: 'Maze Runner',
                type: 'move',
                description: 'Navigate the complex maze!',
                hint: 'Plan your path carefully. Loops can help!',
                goal: { x: 6, y: 6 },
                start: { x: 0, y: 0 },
                obstacles: [
                    { x: 1, y: 0 }, { x: 1, y: 1 }, { x: 1, y: 2 },
                    { x: 3, y: 2 }, { x: 3, y: 3 }, { x: 3, y: 4 },
                    { x: 5, y: 4 }, { x: 5, y: 5 }, { x: 5, y: 6 }
                ],
                availableBlocks: ['move_up', 'move_down', 'move_left', 'move_right', 'repeat'],
                gridSize: 7,
                optimalMoves: 10
            },
            {
                id: 7,
                name: 'Conditional Path',
                type: 'logic',
                description: 'If x > 5, print "big", else print "small". Set x to 10.',
                hint: 'Use an if block with a greater than condition.',
                target: 'big',
                availableBlocks: ['set_var', 'get_var', 'if_block', 'else_block', 'greater', 'print'],
                gridSize: 5,
                optimalMoves: 5
            },
            {
                id: 8,
                name: 'Function Power',
                type: 'function',
                description: 'Create a function "double" that multiplies by 2. Call it with 21.',
                hint: 'Define a function, use multiply inside, then call it.',
                target: 42,
                availableBlocks: ['set_var', 'get_var', 'define_func', 'call_func', 'multiply', 'print', 'return_val'],
                gridSize: 5,
                optimalMoves: 6
            }
        ];

        // Game state
        let gameState = {
            currentLevel: 1,
            completedLevels: {},
            totalStars: 0,
            theme: 'light',
            customLevels: [],
            blocks: [],
            variables: {},
            output: [],
            isRunning: false,
            debugMode: false,
            debugIndex: 0,
            character: { x: 0, y: 0, direction: 'right' }
        };

        // Load saved state
        function loadState() {
            try {
                const saved = localStorage.getItem(APP_NAME);
                if (saved) {
                    const parsed = JSON.parse(saved);
                    gameState = { ...gameState, ...parsed };
                }
            } catch (e) {
                console.error('Failed to load state:', e);
            }
        }

        // Save state
        function saveState() {
            try {
                localStorage.setItem(APP_NAME, JSON.stringify({
                    currentLevel: gameState.currentLevel,
                    completedLevels: gameState.completedLevels,
                    totalStars: gameState.totalStars,
                    theme: gameState.theme,
                    customLevels: gameState.customLevels
                }));
            } catch (e) {
                console.error('Failed to save state:', e);
            }
        }

        // Game object
        const game = {
            blockIdCounter: 0,

            init() {
                loadState();
                this.applyTheme();
                this.renderLevelGrid();
                this.setupDragAndDrop();
            },

            // Theme management
            toggleTheme() {
                gameState.theme = gameState.theme === 'light' ? 'dark' : 'light';
                this.applyTheme();
                saveState();
            },

            applyTheme() {
                document.documentElement.setAttribute('data-theme', gameState.theme);
                document.getElementById('themeIcon').textContent = gameState.theme === 'light' ? 'üåô' : '‚òÄÔ∏è';
            },

            // Level selection
            renderLevelGrid() {
                const grid = document.getElementById('levelGrid');
                const allLevels = [...LEVELS, ...gameState.customLevels];

                grid.innerHTML = allLevels.map((level, index) => {
                    const completed = gameState.completedLevels[level.id];
                    const stars = completed ? completed.stars : 0;
                    const isLocked = index > 0 && !gameState.completedLevels[allLevels[index - 1].id];
                    const isCurrent = level.id === gameState.currentLevel;

                    return `
                        <div class="level-card ${completed ? 'completed' : ''} ${isLocked ? 'locked' : ''} ${isCurrent ? 'current' : ''}"
                             onclick="game.selectLevel(${level.id}, ${isLocked})">
                            <div class="level-number">${level.id}</div>
                            <div class="level-name">${level.name}</div>
                            <div class="level-stars ${stars === 0 ? 'empty' : ''}">
                                ${'‚òÖ'.repeat(stars)}${'‚òÜ'.repeat(3 - stars)}
                            </div>
                        </div>
                    `;
                }).join('');

                // Update total stars
                document.getElementById('totalStars').textContent = gameState.totalStars;
            },

            selectLevel(levelId, isLocked) {
                if (isLocked) return;
                gameState.currentLevel = levelId;
                this.startLevel(levelId);
            },

            startLevel(levelId) {
                const level = [...LEVELS, ...gameState.customLevels].find(l => l.id === levelId);
                if (!level) return;

                // Hide level screen, show game interface
                document.getElementById('levelScreen').classList.remove('active');
                document.getElementById('gameInterface').style.display = 'grid';

                // Update UI
                document.getElementById('levelBadge').textContent = `Level ${level.id}`;
                document.getElementById('levelTitle').textContent = level.name;
                document.getElementById('goalText').textContent = level.description;
                document.getElementById('hintText').textContent = level.hint;
                document.getElementById('hintText').classList.remove('visible');

                // Reset state
                gameState.blocks = [];
                gameState.variables = {};
                gameState.output = [];
                gameState.character = { ...level.start, direction: 'right' };

                // Render palette
                this.renderPalette(level.availableBlocks);

                // Clear workspace
                this.clearWorkspace();

                // Render game world
                this.renderGameWorld(level);

                saveState();
            },

            showLevelSelect() {
                document.getElementById('gameInterface').style.display = 'none';
                document.getElementById('levelScreen').classList.add('active');
                this.renderLevelGrid();
            },

            // Block palette
            renderPalette(availableBlocks) {
                const categories = {
                    variables: { name: 'Variables', blocks: [] },
                    math: { name: 'Math', blocks: [] },
                    logic: { name: 'Logic', blocks: [] },
                    loops: { name: 'Loops', blocks: [] },
                    functions: { name: 'Functions', blocks: [] },
                    output: { name: 'Output', blocks: [] },
                    movement: { name: 'Movement', blocks: [] }
                };

                Object.entries(BLOCK_TYPES).forEach(([type, def]) => {
                    if (availableBlocks.includes(type)) {
                        categories[def.category].blocks.push({ type, ...def });
                    }
                });

                const container = document.getElementById('paletteCategories');
                container.innerHTML = Object.entries(categories)
                    .filter(([_, cat]) => cat.blocks.length > 0)
                    .map(([key, cat]) => `
                        <div class="palette-category ${key}">
                            <div class="palette-category-title">${cat.name}</div>
                            ${cat.blocks.map(block => `
                                <div class="palette-block block-${block.category}"
                                     draggable="true"
                                     data-block-type="${block.type}"
                                     ondragstart="game.handlePaletteDragStart(event, '${block.type}')">
                                    ${block.label}
                                </div>
                            `).join('')}
                        </div>
                    `).join('');
            },

            // Drag and drop
            setupDragAndDrop() {
                // This is set up via inline event handlers
            },

            handlePaletteDragStart(event, blockType) {
                event.dataTransfer.setData('text/plain', JSON.stringify({ type: 'new', blockType }));
                event.dataTransfer.effectAllowed = 'copy';
            },

            handleDragOver(event) {
                event.preventDefault();
                event.dataTransfer.dropEffect = 'copy';
                event.currentTarget.classList.add('drag-over');
            },

            handleDragLeave(event) {
                event.currentTarget.classList.remove('drag-over');
            },

            handleDrop(event) {
                event.preventDefault();
                event.currentTarget.classList.remove('drag-over');

                try {
                    const data = JSON.parse(event.dataTransfer.getData('text/plain'));

                    if (data.type === 'new') {
                        const block = {
                            id: ++this.blockIdCounter,
                            type: data.blockType,
                            values: {},
                            children: []
                        };
                        gameState.blocks.push(block);
                        this.renderBlocks();
                        this.generateCode();
                    }
                } catch (e) {
                    console.error('Drop error:', e);
                }
            },

            // Block rendering
            renderBlocks() {
                const dropZone = document.getElementById('mainDropZone');

                if (gameState.blocks.length === 0) {
                    dropZone.innerHTML = 'Drag blocks here to build your program';
                    dropZone.classList.remove('has-blocks');
                    return;
                }

                dropZone.classList.add('has-blocks');
                dropZone.innerHTML = gameState.blocks.map(block => this.renderBlock(block)).join('');
            },

            renderBlock(block) {
                const def = BLOCK_TYPES[block.type];
                if (!def) return '';

                let content = def.label;

                // Add inputs
                if (def.inputs && def.inputs.length > 0) {
                    def.inputs.forEach(input => {
                        const value = block.values[input] || '';
                        content += ` <input type="text" class="block-input"
                            value="${value}"
                            placeholder="${input}"
                            onchange="game.updateBlockValue(${block.id}, '${input}', this.value)"
                            onclick="event.stopPropagation()">`;
                    });
                }

                return `
                    <div class="block block-${def.category}"
                         draggable="true"
                         data-block-id="${block.id}"
                         id="block-${block.id}">
                        ${content}
                        <button class="block-delete" onclick="game.deleteBlock(${block.id})" aria-label="Delete block">√ó</button>
                    </div>
                `;
            },

            updateBlockValue(blockId, inputName, value) {
                const block = gameState.blocks.find(b => b.id === blockId);
                if (block) {
                    block.values[inputName] = value;
                    this.generateCode();
                }
            },

            deleteBlock(blockId) {
                gameState.blocks = gameState.blocks.filter(b => b.id !== blockId);
                this.renderBlocks();
                this.generateCode();
            },

            clearWorkspace() {
                gameState.blocks = [];
                this.renderBlocks();
                this.generateCode();
                document.getElementById('outputContent').innerHTML = '';
            },

            // View switching
            switchView(view) {
                const blocksTab = document.getElementById('blocksTab');
                const codeTab = document.getElementById('codeTab');
                const blockWorkspace = document.getElementById('blockWorkspace');
                const codeWorkspace = document.getElementById('codeWorkspace');

                if (view === 'blocks') {
                    blocksTab.classList.add('active');
                    codeTab.classList.remove('active');
                    blockWorkspace.style.display = 'block';
                    codeWorkspace.classList.remove('active');
                } else {
                    codeTab.classList.add('active');
                    blocksTab.classList.remove('active');
                    blockWorkspace.style.display = 'none';
                    codeWorkspace.classList.add('active');
                }
            },

            // Code generation
            generateCode() {
                const codeEditor = document.getElementById('codeEditor');
                let code = '<span class="code-comment">// Generated JavaScript Code</span>\n\n';

                gameState.blocks.forEach(block => {
                    code += this.blockToCode(block) + '\n';
                });

                codeEditor.innerHTML = code;
            },

            blockToCode(block) {
                const def = BLOCK_TYPES[block.type];
                if (!def) return '';

                switch (block.type) {
                    case 'set_var':
                        return `<span class="code-keyword">let</span> <span class="code-variable">${block.values.var || 'x'}</span> = <span class="code-number">${block.values.value || '0'}</span>;`;
                    case 'get_var':
                        return `<span class="code-variable">${block.values.var || 'x'}</span>`;
                    case 'add':
                        return `(${block.values.a || '0'} <span class="code-keyword">+</span> ${block.values.b || '0'})`;
                    case 'subtract':
                        return `(${block.values.a || '0'} <span class="code-keyword">-</span> ${block.values.b || '0'})`;
                    case 'multiply':
                        return `(${block.values.a || '0'} <span class="code-keyword">*</span> ${block.values.b || '0'})`;
                    case 'divide':
                        return `(${block.values.a || '0'} <span class="code-keyword">/</span> ${block.values.b || '0'})`;
                    case 'print':
                        return `<span class="code-function">console.log</span>(<span class="code-string">${block.values.message || "''"}</span>);`;
                    case 'repeat':
                        return `<span class="code-keyword">for</span> (<span class="code-keyword">let</span> i = 0; i < ${block.values.times || '1'}; i++) { }`;
                    case 'if_block':
                        return `<span class="code-keyword">if</span> (${block.values.condition || 'true'}) { }`;
                    case 'else_block':
                        return `<span class="code-keyword">else</span> { }`;
                    case 'while_loop':
                        return `<span class="code-keyword">while</span> (${block.values.condition || 'true'}) { }`;
                    case 'define_func':
                        return `<span class="code-keyword">function</span> <span class="code-function">${block.values.name || 'myFunc'}</span>() { }`;
                    case 'call_func':
                        return `<span class="code-function">${block.values.name || 'myFunc'}</span>();`;
                    case 'return_val':
                        return `<span class="code-keyword">return</span> ${block.values.value || '0'};`;
                    case 'move_up':
                        return `<span class="code-function">moveUp</span>();`;
                    case 'move_down':
                        return `<span class="code-function">moveDown</span>();`;
                    case 'move_left':
                        return `<span class="code-function">moveLeft</span>();`;
                    case 'move_right':
                        return `<span class="code-function">moveRight</span>();`;
                    case 'greater':
                        return `(${block.values.a || '0'} > ${block.values.b || '0'})`;
                    case 'less':
                        return `(${block.values.a || '0'} < ${block.values.b || '0'})`;
                    case 'equals':
                        return `(${block.values.a || '0'} === ${block.values.b || '0'})`;
                    case 'and':
                        return `(${block.values.a || 'true'} && ${block.values.b || 'true'})`;
                    case 'or':
                        return `(${block.values.a || 'true'} || ${block.values.b || 'true'})`;
                    case 'not':
                        return `!${block.values.a || 'true'}`;
                    default:
                        return `// ${block.type}`;
                }
            },

            // Game world rendering
            renderGameWorld(level) {
                const canvas = document.getElementById('gameCanvas');
                const ctx = canvas.getContext('2d');
                const cellSize = Math.floor(260 / (level.gridSize || 5));

                canvas.width = cellSize * (level.gridSize || 5);
                canvas.height = cellSize * (level.gridSize || 5);

                // Clear
                ctx.fillStyle = gameState.theme === 'dark' ? '#1e293b' : '#f0f4f8';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw grid
                ctx.strokeStyle = gameState.theme === 'dark' ? '#475569' : '#cbd5e1';
                ctx.lineWidth = 1;
                for (let i = 0; i <= (level.gridSize || 5); i++) {
                    ctx.beginPath();
                    ctx.moveTo(i * cellSize, 0);
                    ctx.lineTo(i * cellSize, canvas.height);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, i * cellSize);
                    ctx.lineTo(canvas.width, i * cellSize);
                    ctx.stroke();
                }

                // Draw obstacles
                if (level.obstacles) {
                    ctx.fillStyle = gameState.theme === 'dark' ? '#64748b' : '#94a3b8';
                    level.obstacles.forEach(obs => {
                        ctx.fillRect(obs.x * cellSize + 2, obs.y * cellSize + 2, cellSize - 4, cellSize - 4);
                    });
                }

                // Draw goal
                if (level.goal) {
                    ctx.fillStyle = '#10b981';
                    ctx.beginPath();
                    const gx = level.goal.x * cellSize + cellSize / 2;
                    const gy = level.goal.y * cellSize + cellSize / 2;
                    ctx.moveTo(gx, gy - cellSize / 3);
                    ctx.lineTo(gx + cellSize / 4, gy);
                    ctx.lineTo(gx, gy + cellSize / 3);
                    ctx.lineTo(gx - cellSize / 4, gy);
                    ctx.closePath();
                    ctx.fill();

                    // Flag pole
                    ctx.strokeStyle = '#059669';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(gx, gy - cellSize / 3);
                    ctx.lineTo(gx, gy + cellSize / 3);
                    ctx.stroke();
                }

                // Draw character
                const char = gameState.character;
                if (char) {
                    const cx = char.x * cellSize + cellSize / 2;
                    const cy = char.y * cellSize + cellSize / 2;
                    const radius = cellSize / 3;

                    // Body
                    ctx.fillStyle = '#6366f1';
                    ctx.beginPath();
                    ctx.arc(cx, cy, radius, 0, Math.PI * 2);
                    ctx.fill();

                    // Eyes
                    ctx.fillStyle = 'white';
                    const eyeOffset = radius / 3;
                    ctx.beginPath();
                    ctx.arc(cx - eyeOffset, cy - eyeOffset / 2, radius / 4, 0, Math.PI * 2);
                    ctx.arc(cx + eyeOffset, cy - eyeOffset / 2, radius / 4, 0, Math.PI * 2);
                    ctx.fill();

                    // Pupils
                    ctx.fillStyle = '#1e1b4b';
                    ctx.beginPath();
                    ctx.arc(cx - eyeOffset, cy - eyeOffset / 2, radius / 8, 0, Math.PI * 2);
                    ctx.arc(cx + eyeOffset, cy - eyeOffset / 2, radius / 8, 0, Math.PI * 2);
                    ctx.fill();
                }
            },

            // Execution
            async run() {
                const level = [...LEVELS, ...gameState.customLevels].find(l => l.id === gameState.currentLevel);
                if (!level) return;

                gameState.isRunning = true;
                gameState.output = [];
                gameState.variables = {};
                gameState.character = { ...level.start, direction: 'right' };

                document.getElementById('outputContent').innerHTML = '';
                document.getElementById('runBtn').disabled = true;

                this.renderGameWorld(level);

                let success = false;
                let moveCount = 0;

                // Execute blocks
                for (const block of gameState.blocks) {
                    if (!gameState.isRunning) break;

                    // Highlight current block
                    const blockEl = document.getElementById(`block-${block.id}`);
                    if (blockEl) blockEl.classList.add('executing');

                    const result = await this.executeBlock(block, level);
                    moveCount++;

                    if (blockEl) blockEl.classList.remove('executing');

                    // Check if we hit a wall
                    if (result === 'collision') {
                        this.addOutput('Hit a wall!', 'error');
                        break;
                    }

                    await this.delay(300);
                    this.renderGameWorld(level);
                }

                // Check win condition
                if (level.type === 'move' && level.goal) {
                    success = gameState.character.x === level.goal.x && gameState.character.y === level.goal.y;
                } else if (level.type === 'math' || level.type === 'logic' || level.type === 'function') {
                    const lastOutput = gameState.output[gameState.output.length - 1];
                    success = lastOutput && lastOutput.text == level.target;
                }

                if (success) {
                    const stars = this.calculateStars(moveCount, level.optimalMoves);
                    this.completeLevel(stars);
                } else {
                    this.addOutput('Try again!', 'error');
                }

                document.getElementById('runBtn').disabled = false;
                gameState.isRunning = false;
            },

            async executeBlock(block, level) {
                const def = BLOCK_TYPES[block.type];
                if (!def) return null;

                switch (block.type) {
                    case 'move_up':
                        return this.moveCharacter(0, -1, level);
                    case 'move_down':
                        return this.moveCharacter(0, 1, level);
                    case 'move_left':
                        return this.moveCharacter(-1, 0, level);
                    case 'move_right':
                        return this.moveCharacter(1, 0, level);
                    case 'set_var':
                        gameState.variables[block.values.var || 'x'] = this.evaluateValue(block.values.value);
                        this.addOutput(`Set ${block.values.var} = ${gameState.variables[block.values.var]}`, 'info');
                        break;
                    case 'print':
                        const val = this.evaluateValue(block.values.message);
                        this.addOutput(String(val), 'success');
                        break;
                    case 'repeat':
                        const times = parseInt(block.values.times) || 1;
                        for (let i = 0; i < times && gameState.isRunning; i++) {
                            for (const child of block.children || []) {
                                await this.executeBlock(child, level);
                                await this.delay(300);
                            }
                        }
                        break;
                    default:
                        break;
                }
                return null;
            },

            evaluateValue(val) {
                if (val === undefined || val === '') return 0;

                // Check if it's a variable reference
                if (gameState.variables[val] !== undefined) {
                    return gameState.variables[val];
                }

                // Try to evaluate as expression
                try {
                    // Replace variable names with values
                    let expr = val;
                    Object.keys(gameState.variables).forEach(varName => {
                        expr = expr.replace(new RegExp(`\\b${varName}\\b`, 'g'), gameState.variables[varName]);
                    });
                    return eval(expr);
                } catch (e) {
                    return val;
                }
            },

            moveCharacter(dx, dy, level) {
                const newX = gameState.character.x + dx;
                const newY = gameState.character.y + dy;
                const gridSize = level.gridSize || 5;

                // Check bounds
                if (newX < 0 || newX >= gridSize || newY < 0 || newY >= gridSize) {
                    return 'collision';
                }

                // Check obstacles
                if (level.obstacles && level.obstacles.some(o => o.x === newX && o.y === newY)) {
                    return 'collision';
                }

                gameState.character.x = newX;
                gameState.character.y = newY;
                return 'ok';
            },

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            },

            addOutput(text, type = 'info') {
                gameState.output.push({ text, type });
                const outputContent = document.getElementById('outputContent');
                outputContent.innerHTML += `<div class="output-line ${type}">${text}</div>`;
                outputContent.scrollTop = outputContent.scrollHeight;
            },

            calculateStars(moves, optimal) {
                if (moves <= optimal) return 3;
                if (moves <= optimal * 1.5) return 2;
                return 1;
            },

            completeLevel(stars) {
                const level = gameState.currentLevel;
                const prev = gameState.completedLevels[level];

                if (!prev || prev.stars < stars) {
                    const oldStars = prev ? prev.stars : 0;
                    gameState.totalStars += stars - oldStars;
                    gameState.completedLevels[level] = { stars, completed: true };
                }

                saveState();
                this.showCelebration(stars);
            },

            showCelebration(stars) {
                const celebration = document.getElementById('celebration');
                const starsEl = document.getElementById('celebrationStars');
                const subtitle = document.getElementById('celebrationSubtitle');

                starsEl.textContent = '‚òÖ'.repeat(stars) + '‚òÜ'.repeat(3 - stars);

                if (stars === 3) {
                    subtitle.textContent = 'Perfect Solution!';
                } else if (stars === 2) {
                    subtitle.textContent = 'Great Job!';
                } else {
                    subtitle.textContent = 'Level Complete!';
                }

                celebration.classList.add('active');
                this.createConfetti();
            },

            createConfetti() {
                const celebration = document.getElementById('celebration');
                const colors = ['#6366f1', '#8b5cf6', '#10b981', '#f59e0b', '#ef4444', '#ec4899'];

                for (let i = 0; i < 50; i++) {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.left = Math.random() * 100 + '%';
                    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.animationDelay = Math.random() * 2 + 's';
                    confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
                    celebration.appendChild(confetti);

                    setTimeout(() => confetti.remove(), 3000);
                }
            },

            replayLevel() {
                document.getElementById('celebration').classList.remove('active');
                this.startLevel(gameState.currentLevel);
            },

            nextLevel() {
                document.getElementById('celebration').classList.remove('active');
                const allLevels = [...LEVELS, ...gameState.customLevels];
                const currentIndex = allLevels.findIndex(l => l.id === gameState.currentLevel);

                if (currentIndex < allLevels.length - 1) {
                    const nextLevel = allLevels[currentIndex + 1];
                    gameState.currentLevel = nextLevel.id;
                    this.startLevel(nextLevel.id);
                } else {
                    this.showLevelSelect();
                }
            },

            reset() {
                const level = [...LEVELS, ...gameState.customLevels].find(l => l.id === gameState.currentLevel);
                if (level) {
                    gameState.character = { ...level.start, direction: 'right' };
                    gameState.variables = {};
                    gameState.output = [];
                    document.getElementById('outputContent').innerHTML = '';
                    this.renderGameWorld(level);
                }
            },

            // Debugger
            stepThrough() {
                gameState.debugMode = true;
                gameState.debugIndex = 0;
                document.getElementById('debuggerPanel').classList.add('active');
                this.updateDebugger();
            },

            debugStep() {
                if (gameState.debugIndex < gameState.blocks.length) {
                    const block = gameState.blocks[gameState.debugIndex];
                    const level = [...LEVELS, ...gameState.customLevels].find(l => l.id === gameState.currentLevel);
                    this.executeBlock(block, level);
                    this.renderGameWorld(level);
                    gameState.debugIndex++;
                    this.updateDebugger();
                }
            },

            debugContinue() {
                gameState.debugMode = false;
                document.getElementById('debuggerPanel').classList.remove('active');
                this.run();
            },

            debugStop() {
                gameState.debugMode = false;
                gameState.debugIndex = 0;
                document.getElementById('debuggerPanel').classList.remove('active');
            },

            updateDebugger() {
                const varsEl = document.getElementById('debuggerVariables');
                varsEl.innerHTML = Object.entries(gameState.variables)
                    .map(([k, v]) => `<div class="debugger-var">${k} = ${v}</div>`)
                    .join('') || '<div style="color: var(--text-muted);">No variables</div>';
            },

            // Hints
            showHint() {
                document.getElementById('hintText').classList.toggle('visible');
            },

            // Output panel
            toggleOutput() {
                const panel = document.getElementById('outputPanel');
                const toggle = document.getElementById('outputToggle');
                panel.classList.toggle('expanded');
                toggle.textContent = panel.classList.contains('expanded') ? '‚ñº' : '‚ñ≤';
            },

            // Level Editor
            openLevelEditor() {
                document.getElementById('levelScreen').classList.remove('active');
                document.getElementById('levelEditor').classList.add('active');
                this.renderEditorBlocks();
            },

            closeLevelEditor() {
                document.getElementById('levelEditor').classList.remove('active');
                document.getElementById('levelScreen').classList.add('active');
            },

            renderEditorBlocks() {
                const container = document.getElementById('editorBlocks');
                container.innerHTML = Object.entries(BLOCK_TYPES)
                    .map(([type, def]) => `
                        <label style="display: block; margin-bottom: 5px;">
                            <input type="checkbox" value="${type}" checked> ${def.label}
                        </label>
                    `).join('');
            },

            saveCustomLevel() {
                const name = document.getElementById('editorLevelName').value || 'Custom Level';
                const type = document.getElementById('editorPuzzleType').value;
                const description = document.getElementById('editorDescription').value || 'Complete the puzzle!';
                const hint = document.getElementById('editorHint').value || 'Think about it...';
                const target = document.getElementById('editorTarget').value;
                const gridSize = parseInt(document.getElementById('editorGridSize').value) || 5;

                const checkedBlocks = Array.from(document.querySelectorAll('#editorBlocks input:checked'))
                    .map(cb => cb.value);

                const newLevel = {
                    id: 100 + gameState.customLevels.length + 1,
                    name,
                    type,
                    description,
                    hint,
                    target: target || undefined,
                    goal: type === 'move' ? { x: gridSize - 1, y: gridSize - 1 } : undefined,
                    start: type === 'move' ? { x: 0, y: 0 } : undefined,
                    obstacles: [],
                    availableBlocks: checkedBlocks,
                    gridSize,
                    optimalMoves: 10
                };

                gameState.customLevels.push(newLevel);
                saveState();

                alert('Level saved!');
                this.closeLevelEditor();
                this.renderLevelGrid();
            },

            testCustomLevel() {
                // Similar to save but doesn't persist
                const name = document.getElementById('editorLevelName').value || 'Test Level';
                const type = document.getElementById('editorPuzzleType').value;
                const description = document.getElementById('editorDescription').value || 'Complete the puzzle!';
                const hint = document.getElementById('editorHint').value || 'Think about it...';
                const gridSize = parseInt(document.getElementById('editorGridSize').value) || 5;

                const checkedBlocks = Array.from(document.querySelectorAll('#editorBlocks input:checked'))
                    .map(cb => cb.value);

                const testLevel = {
                    id: 9999,
                    name,
                    type,
                    description,
                    hint,
                    goal: type === 'move' ? { x: gridSize - 1, y: gridSize - 1 } : undefined,
                    start: type === 'move' ? { x: 0, y: 0 } : undefined,
                    obstacles: [],
                    availableBlocks: checkedBlocks,
                    gridSize,
                    optimalMoves: 10
                };

                document.getElementById('levelEditor').classList.remove('active');
                gameState.currentLevel = 9999;
                gameState.customLevels.push(testLevel);
                this.startLevel(9999);
            },

            // Data management
            exportProgress() {
                const data = {
                    app: APP_NAME,
                    version: '1.0.0',
                    exportDate: new Date().toISOString(),
                    currentLevel: gameState.currentLevel,
                    completedLevels: gameState.completedLevels,
                    totalStars: gameState.totalStars,
                    customLevels: gameState.customLevels,
                    theme: gameState.theme
                };

                const dataStr = JSON.stringify(data, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `${APP_NAME}-progress-${new Date().toISOString().split('T')[0]}.json`;
                link.click();
                URL.revokeObjectURL(url);
            },

            importProgress(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);

                        if (data.app !== APP_NAME) {
                            alert('Invalid save file');
                            return;
                        }

                        gameState.currentLevel = data.currentLevel || 1;
                        gameState.completedLevels = data.completedLevels || {};
                        gameState.totalStars = data.totalStars || 0;
                        gameState.customLevels = data.customLevels || [];
                        gameState.theme = data.theme || 'light';

                        saveState();
                        this.applyTheme();
                        this.renderLevelGrid();

                        alert('Progress imported successfully!');
                    } catch (error) {
                        alert('Failed to import: Invalid JSON file');
                    }
                };
                reader.readAsText(file);
                event.target.value = '';
            },

            exportCode() {
                let code = '// Generated by Code Quest\n\n';

                gameState.blocks.forEach(block => {
                    code += this.blockToPlainCode(block) + '\n';
                });

                const blob = new Blob([code], { type: 'text/javascript' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `code-quest-solution-${new Date().toISOString().split('T')[0]}.js`;
                link.click();
                URL.revokeObjectURL(url);
            },

            blockToPlainCode(block) {
                switch (block.type) {
                    case 'set_var':
                        return `let ${block.values.var || 'x'} = ${block.values.value || '0'};`;
                    case 'print':
                        return `console.log(${block.values.message || "''"});`;
                    case 'move_up':
                        return `moveUp();`;
                    case 'move_down':
                        return `moveDown();`;
                    case 'move_left':
                        return `moveLeft();`;
                    case 'move_right':
                        return `moveRight();`;
                    case 'repeat':
                        return `for (let i = 0; i < ${block.values.times || '1'}; i++) { }`;
                    case 'if_block':
                        return `if (${block.values.condition || 'true'}) { }`;
                    case 'add':
                        return `(${block.values.a || '0'} + ${block.values.b || '0'})`;
                    case 'multiply':
                        return `(${block.values.a || '0'} * ${block.values.b || '0'})`;
                    default:
                        return `// ${block.type}`;
                }
            }
        };

        // Initialize on load
        document.addEventListener('DOMContentLoaded', () => {
            game.init();
        });
    </script>
</body>
</html>
