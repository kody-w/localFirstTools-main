<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Star Wars Galaxies - Tatooine</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Lucida Console', monospace;
            background: #000;
            color: #ffd700;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }
        #game-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; }

        /* SWG-style UI */
        .swg-panel {
            background: linear-gradient(180deg, rgba(20,30,50,0.95) 0%, rgba(10,15,25,0.98) 100%);
            border: 2px solid #4a6fa5;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(74,111,165,0.5), inset 0 0 20px rgba(0,0,0,0.5);
        }

        /* Top HUD */
        #top-hud {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 100;
        }

        /* HAM Bars (Health/Action/Mind) */
        #ham-bars {
            position: fixed;
            top: 10px;
            left: 10px;
            width: 250px;
            z-index: 100;
        }
        .ham-bar {
            height: 20px;
            margin-bottom: 3px;
            border-radius: 3px;
            position: relative;
            overflow: hidden;
        }
        .ham-bar-bg {
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            border: 1px solid #333;
        }
        .ham-bar-fill {
            position: absolute;
            height: 100%;
            transition: width 0.3s;
        }
        .ham-bar-text {
            position: absolute;
            width: 100%;
            text-align: center;
            font-size: 11px;
            line-height: 20px;
            color: #fff;
            text-shadow: 1px 1px 2px #000;
        }
        #health-bar .ham-bar-fill { background: linear-gradient(180deg, #ff4444, #aa0000); }
        #action-bar .ham-bar-fill { background: linear-gradient(180deg, #44ff44, #00aa00); }
        #mind-bar .ham-bar-fill { background: linear-gradient(180deg, #4444ff, #0000aa); }

        /* Target Frame */
        #target-frame {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 250px;
            padding: 10px;
            display: none;
            z-index: 100;
        }
        #target-frame.active { display: block; }
        #target-name { font-size: 14px; color: #ffd700; margin-bottom: 5px; }
        #target-health-bar {
            height: 15px;
            background: rgba(0,0,0,0.7);
            border: 1px solid #333;
            border-radius: 3px;
            overflow: hidden;
        }
        #target-health-fill {
            height: 100%;
            background: linear-gradient(180deg, #ff6666, #cc0000);
            transition: width 0.3s;
        }

        /* Action Bar */
        #action-bar-ui {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            z-index: 100;
        }
        .action-slot {
            width: 50px;
            height: 50px;
            background: rgba(20,30,50,0.9);
            border: 2px solid #4a6fa5;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
        }
        .action-slot:hover { border-color: #ffd700; transform: scale(1.1); }
        .action-slot.on-cooldown { opacity: 0.5; }
        .action-slot .cooldown-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(0,0,0,0.7);
            transition: height 0.1s;
        }
        .action-slot .keybind {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 10px;
            color: #aaa;
        }
        .action-slot .ability-name {
            position: absolute;
            top: -20px;
            font-size: 9px;
            color: #ffd700;
            white-space: nowrap;
            display: none;
        }
        .action-slot:hover .ability-name { display: block; }

        /* Chat/System Messages */
        #chat-box {
            position: fixed;
            bottom: 80px;
            left: 10px;
            width: 400px;
            height: 150px;
            padding: 10px;
            overflow-y: auto;
            font-size: 12px;
            z-index: 100;
        }
        .chat-message { margin-bottom: 3px; }
        .chat-system { color: #ffcc00; }
        .chat-combat { color: #ff6666; }
        .chat-xp { color: #66ff66; }
        .chat-loot { color: #66ccff; }
        .chat-spatial { color: #ffffff; }

        /* Credits Display */
        #credits-display {
            position: fixed;
            top: 10px;
            left: 270px;
            padding: 5px 15px;
            font-size: 14px;
            z-index: 100;
        }
        #credits-display span { color: #ffd700; }

        /* Profession/Skills Button */
        #skills-button {
            position: fixed;
            top: 80px;
            left: 10px;
            padding: 8px 15px;
            cursor: pointer;
            z-index: 100;
        }
        #skills-button:hover { border-color: #ffd700; }

        /* Skills Window */
        #skills-window {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 600px;
            height: 500px;
            padding: 20px;
            display: none;
            z-index: 200;
        }
        #skills-window.active { display: block; }
        #skills-window h2 { color: #ffd700; margin-bottom: 15px; text-align: center; }
        .skill-tree {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }
        .skill-box {
            padding: 10px;
            text-align: center;
            border: 2px solid #333;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .skill-box.unlocked { border-color: #4a6fa5; background: rgba(74,111,165,0.3); }
        .skill-box.available { border-color: #ffd700; }
        .skill-box.locked { opacity: 0.5; }
        .skill-box:hover { transform: scale(1.05); }
        .skill-name { font-size: 11px; color: #ffd700; }
        .skill-xp { font-size: 10px; color: #aaa; margin-top: 5px; }
        .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #aa0000;
            border: none;
            color: #fff;
            width: 25px;
            height: 25px;
            border-radius: 3px;
            cursor: pointer;
        }

        /* Inventory Window */
        #inventory-window {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            height: 450px;
            padding: 20px;
            display: none;
            z-index: 200;
        }
        #inventory-window.active { display: block; }
        #inventory-window h2 { color: #ffd700; margin-bottom: 15px; }
        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 5px;
        }
        .inv-slot {
            width: 40px;
            height: 40px;
            background: rgba(0,0,0,0.5);
            border: 1px solid #4a6fa5;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            cursor: pointer;
        }
        .inv-slot:hover { border-color: #ffd700; }
        .inv-slot.has-item { background: rgba(74,111,165,0.3); }
        .inv-slot.equipped { border: 2px solid #ffd700; background: rgba(255,215,0,0.2); }

        /* Equipment Slots */
        .equipment-slots {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #333;
        }
        .equip-slot {
            width: 50px;
            height: 50px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #4a6fa5;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }
        .equip-slot:hover { border-color: #ffd700; }
        .equip-slot.has-item { background: rgba(255,215,0,0.15); border-color: #ffd700; }
        .equip-slot-label { font-size: 9px; color: #aaa; margin-top: 2px; }
        .equip-slot-icon { font-size: 22px; }
        .equipment-stats {
            font-size: 11px;
            color: #66ff66;
            margin-top: 5px;
        }

        /* Muzzle Flash Effect */
        .muzzle-flash {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, rgba(255,100,50,1) 0%, rgba(255,50,0,0.8) 30%, rgba(255,0,0,0) 70%);
            border-radius: 50%;
            pointer-events: none;
            z-index: 150;
            animation: muzzleFlash 80ms ease-out forwards;
        }
        @keyframes muzzleFlash {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(0.5); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
        }

        /* Impact Sparks */
        .impact-spark {
            position: fixed;
            width: 6px;
            height: 6px;
            background: #ffaa00;
            border-radius: 50%;
            pointer-events: none;
            z-index: 150;
            box-shadow: 0 0 6px #ff6600, 0 0 10px #ff3300;
        }
        @keyframes sparkFly {
            0% { opacity: 1; }
            100% { opacity: 0; transform: translateY(30px); }
        }

        /* Help Overlay */
        #help-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 500;
        }
        #help-overlay.active { display: flex; }
        .help-content {
            width: 800px;
            max-height: 90vh;
            padding: 25px;
            overflow-y: auto;
        }
        .help-content h2 { color: #ffd700; text-align: center; margin-bottom: 20px; font-size: 24px; }
        .help-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
        }
        .help-section h3 { color: #4a6fa5; margin-bottom: 12px; font-size: 14px; border-bottom: 1px solid #333; padding-bottom: 5px; }
        .help-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            font-size: 12px;
        }
        .help-row .key {
            background: rgba(74,111,165,0.3);
            padding: 2px 8px;
            border-radius: 3px;
            color: #ffd700;
            font-weight: bold;
            min-width: 50px;
            text-align: center;
        }
        .help-row .desc { color: #ccc; }
        .help-footer {
            text-align: center;
            margin-top: 20px;
            color: #666;
            font-size: 11px;
        }
        #help-button {
            position: fixed;
            top: 10px;
            right: 270px;
            width: 30px;
            height: 30px;
            padding: 0;
            font-size: 16px;
            cursor: pointer;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Daily Challenges */
        #daily-challenges-button {
            position: fixed;
            top: 10px;
            right: 310px;
            width: 30px;
            height: 30px;
            padding: 0;
            font-size: 16px;
            cursor: pointer;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #daily-challenges-button.has-incomplete { animation: challengePulse 2s infinite; }
        @keyframes challengePulse {
            0%, 100% { box-shadow: 0 0 5px rgba(255,215,0,0.3); }
            50% { box-shadow: 0 0 15px rgba(255,215,0,0.8); }
        }
        #daily-challenges-panel {
            position: fixed;
            top: 50px;
            right: 10px;
            width: 280px;
            max-height: 400px;
            overflow-y: auto;
            padding: 15px;
            display: none;
            z-index: 200;
        }
        #daily-challenges-panel.active { display: block; }
        .daily-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 1px solid #4a6fa5;
            padding-bottom: 8px;
        }
        .daily-header h3 { color: #ffd700; margin: 0; font-size: 14px; }
        .daily-timer { color: #888; font-size: 11px; }
        .challenge-item {
            padding: 10px;
            margin-bottom: 8px;
            background: rgba(0,0,0,0.4);
            border-left: 3px solid #4a6fa5;
            border-radius: 3px;
        }
        .challenge-item.completed {
            border-left-color: #4aff4a;
            background: rgba(74,255,74,0.1);
        }
        .challenge-name { color: #fff; font-size: 12px; font-weight: bold; margin-bottom: 5px; }
        .challenge-desc { color: #aaa; font-size: 11px; margin-bottom: 8px; }
        .challenge-progress {
            height: 8px;
            background: rgba(0,0,0,0.5);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 5px;
        }
        .challenge-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4a6fa5, #6a9fd5);
            transition: width 0.3s ease;
        }
        .challenge-item.completed .challenge-progress-bar { background: linear-gradient(90deg, #4aff4a, #8aff8a); }
        .challenge-reward { color: #ffd700; font-size: 10px; }
        .challenge-status {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: #888;
        }

        /* Inventory Button */
        #inventory-button {
            position: fixed;
            top: 115px;
            left: 10px;
            padding: 8px 15px;
            cursor: pointer;
            z-index: 100;
        }

        /* Crafting Window */
        #crafting-window {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            height: 400px;
            padding: 20px;
            display: none;
            z-index: 200;
        }
        #crafting-window.active { display: block; }
        .recipe-list {
            max-height: 300px;
            overflow-y: auto;
        }
        .recipe-item {
            padding: 10px;
            border-bottom: 1px solid #333;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
        }
        .recipe-item:hover { background: rgba(74,111,165,0.3); }
        .recipe-item.can-craft { color: #66ff66; }
        .recipe-item.cannot-craft { color: #666; }

        /* Interaction Prompt */
        #interact-prompt {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 15px 30px;
            font-size: 16px;
            display: none;
            z-index: 150;
        }
        #interact-prompt.active { display: block; }

        /* Buff Display */
        #buff-display {
            position: fixed;
            top: 90px;
            left: 270px;
            display: flex;
            gap: 5px;
            z-index: 100;
        }
        .buff-icon {
            width: 30px;
            height: 30px;
            background: rgba(20,30,50,0.9);
            border: 1px solid #4a6fa5;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            position: relative;
        }
        .buff-timer {
            position: absolute;
            bottom: -12px;
            font-size: 9px;
            color: #aaa;
        }

        /* Loading Screen */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        #loading-screen h1 {
            font-size: 48px;
            color: #ffd700;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(255,215,0,0.5);
        }
        #loading-screen p { color: #4a6fa5; font-size: 18px; }
        .loading-bar {
            width: 300px;
            height: 10px;
            background: #222;
            border-radius: 5px;
            margin-top: 20px;
            overflow: hidden;
        }
        .loading-fill {
            height: 100%;
            background: linear-gradient(90deg, #4a6fa5, #ffd700);
            animation: loading 2s ease-in-out;
        }
        @keyframes loading { from { width: 0; } to { width: 100%; } }

        /* Minimap */
        #minimap {
            position: fixed;
            bottom: 80px;
            right: 10px;
            width: 150px;
            height: 150px;
            border-radius: 50%;
            overflow: hidden;
            z-index: 100;
        }
        #minimap-canvas {
            width: 100%;
            height: 100%;
        }

        /* Location Display */
        #location-display {
            position: fixed;
            bottom: 240px;
            right: 10px;
            padding: 5px 10px;
            font-size: 11px;
            z-index: 100;
        }

        /* Crosshair */
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 50;
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255,215,0,0.7);
        }
        #crosshair::before { width: 2px; height: 100%; left: 50%; transform: translateX(-50%); }
        #crosshair::after { height: 2px; width: 100%; top: 50%; transform: translateY(-50%); }

        /* Vendor Window */
        #vendor-window {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            height: 400px;
            padding: 20px;
            display: none;
            z-index: 200;
        }
        #vendor-window.active { display: block; }
        .vendor-items { max-height: 300px; overflow-y: auto; }
        .vendor-item {
            padding: 10px;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .vendor-item button {
            background: #4a6fa5;
            border: none;
            color: #fff;
            padding: 5px 15px;
            border-radius: 3px;
            cursor: pointer;
        }
        .vendor-item button:hover { background: #5a7fb5; }
        .vendor-item button:disabled { background: #333; cursor: not-allowed; }

        /* Cantina Buff UI */
        #cantina-ui {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            padding: 20px;
            display: none;
            z-index: 200;
            text-align: center;
        }
        #cantina-ui.active { display: block; }
        #cantina-ui h2 { color: #ffd700; margin-bottom: 15px; }
        .entertainer-list { margin: 20px 0; }
        .entertainer-item {
            padding: 10px;
            border: 1px solid #4a6fa5;
            margin-bottom: 10px;
            border-radius: 5px;
        }
        .watch-btn {
            background: #4a6fa5;
            border: none;
            color: #fff;
            padding: 8px 20px;
            border-radius: 3px;
            cursor: pointer;
            margin-top: 10px;
        }
        .watch-btn:hover { background: #5a7fb5; }
        .buff-progress {
            width: 100%;
            height: 10px;
            background: #222;
            border-radius: 5px;
            margin-top: 10px;
            overflow: hidden;
        }
        .buff-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff00ff, #00ffff);
            transition: width 0.5s;
        }

        /* Floating Damage Numbers */
        .floating-text {
            position: fixed;
            font-family: 'Arial Black', sans-serif;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 10px currentColor;
            pointer-events: none;
            z-index: 500;
            animation: floatUp 1.5s ease-out forwards;
            white-space: nowrap;
        }
        .floating-text.damage-dealt { color: #ffff00; font-size: 24px; }
        .floating-text.damage-taken { color: #ff4444; font-size: 28px; }
        .floating-text.healing { color: #44ff44; font-size: 24px; }
        .floating-text.xp-gain { color: #00ffff; font-size: 20px; }
        .floating-text.credits { color: #ffd700; font-size: 20px; }
        .floating-text.critical { font-size: 32px; animation: floatUpCrit 1.5s ease-out forwards; }

        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            20% { transform: translateY(-20px) scale(1.2); }
            100% { opacity: 0; transform: translateY(-80px) scale(0.8); }
        }
        @keyframes floatUpCrit {
            0% { opacity: 1; transform: translateY(0) scale(1.5); }
            15% { transform: translateY(-15px) scale(1.8); }
            100% { opacity: 0; transform: translateY(-100px) scale(1); }
        }

        /* Screen Shake Effect */
        .screen-shake {
            animation: shake 0.3s ease-out;
        }
        @keyframes shake {
            0%, 100% { transform: translate(0, 0); }
            10% { transform: translate(-5px, -3px); }
            20% { transform: translate(5px, 3px); }
            30% { transform: translate(-4px, 2px); }
            40% { transform: translate(4px, -2px); }
            50% { transform: translate(-3px, 3px); }
            60% { transform: translate(3px, -3px); }
            70% { transform: translate(-2px, 2px); }
            80% { transform: translate(2px, -2px); }
            90% { transform: translate(-1px, 1px); }
        }

        /* Hit Flash Overlay */
        #hit-flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 400;
            opacity: 0;
            transition: opacity 0.1s;
        }
        #hit-flash.active {
            animation: hitFlash 0.4s ease-out;
        }
        @keyframes hitFlash {
            0% { opacity: 0.6; }
            100% { opacity: 0; }
        }

        /* Blaster Bolt Trail */
        .blaster-bolt {
            position: fixed;
            width: 30px;
            height: 4px;
            border-radius: 2px;
            pointer-events: none;
            z-index: 450;
            box-shadow: 0 0 10px currentColor, 0 0 20px currentColor;
        }

        /* Mission Terminal Window */
        #mission-window {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 550px;
            height: 500px;
            padding: 20px;
            display: none;
            z-index: 200;
        }
        #mission-window.active { display: block; }
        #mission-window h2 { color: #ffd700; margin-bottom: 15px; text-align: center; }
        .mission-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }
        .mission-tab {
            flex: 1;
            padding: 8px;
            background: rgba(0,0,0,0.5);
            border: 1px solid #4a6fa5;
            color: #aaa;
            cursor: pointer;
            text-align: center;
        }
        .mission-tab.active { border-color: #ffd700; color: #ffd700; background: rgba(74,111,165,0.3); }
        .mission-list { max-height: 350px; overflow-y: auto; }
        .mission-item {
            padding: 15px;
            border: 1px solid #4a6fa5;
            margin-bottom: 10px;
            border-radius: 5px;
            background: rgba(0,0,0,0.3);
        }
        .mission-item:hover { border-color: #ffd700; }
        .mission-title { color: #ffd700; font-size: 14px; margin-bottom: 5px; }
        .mission-desc { color: #aaa; font-size: 12px; margin-bottom: 10px; }
        .mission-reward { color: #66ff66; font-size: 12px; }
        .mission-difficulty { font-size: 11px; margin-top: 5px; }
        .mission-difficulty.easy { color: #66ff66; }
        .mission-difficulty.medium { color: #ffcc00; }
        .mission-difficulty.hard { color: #ff6666; }
        .mission-accept-btn {
            background: #4a6fa5;
            border: none;
            color: #fff;
            padding: 8px 20px;
            border-radius: 3px;
            cursor: pointer;
            margin-top: 10px;
        }
        .mission-accept-btn:hover { background: #5a7fb5; }
        .mission-progress {
            height: 8px;
            background: #222;
            border-radius: 4px;
            margin-top: 8px;
            overflow: hidden;
        }
        .mission-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4a6fa5, #ffd700);
            transition: width 0.3s;
        }

        /* Active Mission HUD */
        #active-mission-hud {
            position: fixed;
            top: 120px;
            right: 10px;
            width: 200px;
            padding: 10px;
            display: none;
            z-index: 100;
        }
        #active-mission-hud.active { display: block; }
        #active-mission-hud .mission-title { font-size: 12px; }
        #active-mission-hud .mission-objective { color: #aaa; font-size: 11px; margin-top: 5px; }

        /* Waypoint Marker */
        .waypoint-marker {
            position: fixed;
            width: 12px;
            height: 12px;
            background: #ffd700;
            border: 2px solid #fff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 55;
            box-shadow: 0 0 10px #ffd700;
            animation: waypointPulse 1.5s infinite;
        }
        @keyframes waypointPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(1.3); opacity: 0.7; }
        }

        /* Ability Tooltip */
        #ability-tooltip {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 16px;
            min-width: 220px;
            max-width: 280px;
            display: none;
            z-index: 300;
            font-size: 12px;
            pointer-events: none;
        }
        #ability-tooltip.active { display: block; }
        #ability-tooltip .tooltip-name {
            font-size: 14px;
            color: #ffd700;
            font-weight: bold;
            margin-bottom: 8px;
            border-bottom: 1px solid #4a6fa5;
            padding-bottom: 5px;
        }
        #ability-tooltip .tooltip-row {
            display: flex;
            justify-content: space-between;
            margin: 3px 0;
        }
        #ability-tooltip .tooltip-label { color: #aaa; }
        #ability-tooltip .tooltip-value { color: #fff; }
        #ability-tooltip .tooltip-value.damage { color: #ff6666; }
        #ability-tooltip .tooltip-value.healing { color: #66ff66; }
        #ability-tooltip .tooltip-value.cost { color: #ffaa00; }
        #ability-tooltip .tooltip-value.bonus { color: #00ffff; }
        #ability-tooltip .tooltip-desc {
            color: #888;
            font-size: 11px;
            margin-top: 8px;
            font-style: italic;
        }

        /* Achievement System */
        #achievements-button {
            position: fixed;
            top: 150px;
            left: 10px;
            padding: 8px 15px;
            cursor: pointer;
            z-index: 100;
        }
        #achievements-button:hover { border-color: #ffd700; }

        #achievements-window {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 650px;
            height: 500px;
            padding: 20px;
            display: none;
            z-index: 200;
            overflow: hidden;
        }
        #achievements-window.active { display: block; }
        #achievements-window h2 {
            color: #ffd700;
            margin-bottom: 15px;
            text-align: center;
            border-bottom: 2px solid #4a6fa5;
            padding-bottom: 10px;
        }
        .achievements-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            max-height: 400px;
            overflow-y: auto;
            padding-right: 10px;
        }
        .achievement-card {
            padding: 12px;
            border: 2px solid #333;
            border-radius: 5px;
            background: rgba(0,0,0,0.3);
            display: flex;
            gap: 12px;
            transition: all 0.2s;
        }
        .achievement-card.unlocked {
            border-color: #ffd700;
            background: rgba(255,215,0,0.1);
        }
        .achievement-card.locked { opacity: 0.5; }
        .achievement-icon {
            font-size: 28px;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(20,30,50,0.8);
            border-radius: 5px;
            border: 1px solid #4a6fa5;
        }
        .achievement-info { flex: 1; }
        .achievement-name {
            color: #ffd700;
            font-size: 13px;
            font-weight: bold;
            margin-bottom: 4px;
        }
        .achievement-desc { color: #aaa; font-size: 11px; margin-bottom: 6px; }
        .achievement-progress {
            height: 6px;
            background: rgba(0,0,0,0.5);
            border-radius: 3px;
            overflow: hidden;
        }
        .achievement-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4a6fa5, #ffd700);
            transition: width 0.3s;
        }
        .achievement-progress-text {
            font-size: 10px;
            color: #888;
            margin-top: 3px;
        }

        /* Achievement Notification */
        .achievement-notification {
            position: fixed;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 25px;
            z-index: 500;
            display: flex;
            align-items: center;
            gap: 15px;
            animation: achievementSlide 4s ease-out forwards;
        }
        .achievement-notification .notif-icon { font-size: 36px; }
        .achievement-notification .notif-text { }
        .achievement-notification .notif-title {
            color: #ffd700;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        .achievement-notification .notif-name {
            color: #fff;
            font-size: 16px;
            font-weight: bold;
        }
        @keyframes achievementSlide {
            0% { opacity: 0; transform: translateX(-50%) translateY(-30px); }
            10% { opacity: 1; transform: translateX(-50%) translateY(0); }
            85% { opacity: 1; transform: translateX(-50%) translateY(0); }
            100% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
        }
        /* Mobile Controls */
        #mobile-controls {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }
        
        .touch-zone {
            position: absolute;
            bottom: 20px;
            width: 150px;
            height: 150px;
            pointer-events: auto;
        }
        
        #joystick-zone {
            left: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        #joystick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        
        #jump-button {
            position: absolute;
            bottom: 140px;
            right: 40px;
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.4);
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            user-select: none;
        }
        
        #camera-zone {
            position: absolute;
            top: 0;
            right: 0;
            width: 50%;
            height: 100%;
            pointer-events: auto;
            z-index: 999;
        }

        @media (hover: none) and (pointer: coarse) {
            #mobile-controls { display: block; }
            #action-bar-ui { bottom: 20px; }
        }
    </style>
</head>
<body>
    <div id="mobile-controls">
        <div id="joystick-zone" class="touch-zone">
            <div id="joystick-knob"></div>
        </div>
        <div id="jump-button">‚¨ÜÔ∏è</div>
        <div id="camera-zone"></div>
    </div>

    <div id="loading-screen">
        <h1>STAR WARS GALAXIES</h1>
        <p>Loading Tatooine...</p>
        <div class="loading-bar"><div class="loading-fill"></div></div>
    </div>

    <div id="game-container"></div>
    <div id="crosshair"></div>
    <div id="hit-flash" style="background: radial-gradient(ellipse at center, transparent 30%, rgba(255,0,0,0.5) 100%);"></div>

    <!-- HAM Bars -->
    <div id="ham-bars" class="swg-panel">
        <div id="health-bar" class="ham-bar">
            <div class="ham-bar-bg"></div>
            <div class="ham-bar-fill" style="width: 100%"></div>
            <div class="ham-bar-text">Health: 1000/1000</div>
        </div>
        <div id="action-bar" class="ham-bar">
            <div class="ham-bar-bg"></div>
            <div class="ham-bar-fill" style="width: 100%"></div>
            <div class="ham-bar-text">Action: 500/500</div>
        </div>
        <div id="mind-bar" class="ham-bar">
            <div class="ham-bar-bg"></div>
            <div class="ham-bar-fill" style="width: 100%"></div>
            <div class="ham-bar-text">Mind: 500/500</div>
        </div>
    </div>

    <!-- Credits -->
    <div id="credits-display" class="swg-panel">Credits: <span id="credits-amount">1000</span></div>

    <!-- Buff Display -->
    <div id="buff-display"></div>

    <!-- Help Button -->
    <div id="help-button" class="swg-panel" onclick="toggleHelpOverlay()">?</div>

    <!-- Daily Challenges Button -->
    <div id="daily-challenges-button" class="swg-panel" onclick="toggleDailyChallenges()">üìã</div>

    <!-- Daily Challenges Panel -->
    <div id="daily-challenges-panel" class="swg-panel">
        <div class="daily-header">
            <h3>Daily Challenges</h3>
            <span class="daily-timer" id="daily-timer">Resets in: --:--</span>
        </div>
        <div id="challenges-list"></div>
    </div>

    <!-- Help Overlay -->
    <div id="help-overlay">
        <div class="help-content swg-panel">
            <button class="close-btn" onclick="closeHelpOverlay()">X</button>
            <h2>Game Help & Controls</h2>
            <div class="help-grid">
                <div class="help-section">
                    <h3>Movement & Combat</h3>
                    <div class="help-row"><span class="key">W A S D</span><span class="desc">Move</span></div>
                    <div class="help-row"><span class="key">Mouse</span><span class="desc">Look around</span></div>
                    <div class="help-row"><span class="key">Click</span><span class="desc">Lock cursor</span></div>
                    <div class="help-row"><span class="key">SHIFT</span><span class="desc">Run</span></div>
                    <div class="help-row"><span class="key">TAB</span><span class="desc">Cycle targets</span></div>
                    <div class="help-row"><span class="key">E</span><span class="desc">Interact</span></div>
                    <div class="help-row"><span class="key">1-6</span><span class="desc">Use abilities</span></div>
                    <div class="help-row"><span class="key">ESC</span><span class="desc">Close windows</span></div>
                </div>
                <div class="help-section">
                    <h3>Windows & Menus</h3>
                    <div class="help-row"><span class="key">K</span><span class="desc">Skills</span></div>
                    <div class="help-row"><span class="key">I</span><span class="desc">Inventory</span></div>
                    <div class="help-row"><span class="key">J</span><span class="desc">Achievements</span></div>
                    <div class="help-row"><span class="key">H</span><span class="desc">This help</span></div>
                    <div class="help-row"><span class="key">F5</span><span class="desc">Quick Save</span></div>
                </div>
                <div class="help-section">
                    <h3>Game Systems</h3>
                    <div class="help-row"><span class="key" style="background:#aa0000;">Health</span><span class="desc">Take damage</span></div>
                    <div class="help-row"><span class="key" style="background:#00aa00;">Action</span><span class="desc">For abilities</span></div>
                    <div class="help-row"><span class="key" style="background:#0000aa;">Mind</span><span class="desc">For healing</span></div>
                    <div class="help-row"><span class="key">Missions</span><span class="desc">Terminal in town</span></div>
                    <div class="help-row"><span class="key">Buffs</span><span class="desc">Visit Cantina</span></div>
                    <div class="help-row"><span class="key">Equip</span><span class="desc">Click items (I)</span></div>
                </div>
            </div>
            <div class="help-footer">Press H anytime to toggle this help screen</div>
        </div>
    </div>

    <!-- Target Frame -->
    <div id="target-frame" class="swg-panel">
        <div id="target-name">Target Name</div>
        <div id="target-level">Level 1</div>
        <div id="target-health-bar"><div id="target-health-fill" style="width: 100%"></div></div>
    </div>

    <!-- Skills Button -->
    <div id="skills-button" class="swg-panel">Skills (K)</div>

    <!-- Inventory Button -->
    <div id="inventory-button" class="swg-panel">Inventory (I)</div>

    <!-- Action Bar -->
    <div id="action-bar-ui">
        <div class="action-slot" data-slot="1" data-ability="rangedShot">
            <span class="ability-name">Ranged Shot</span>
            üî´
            <span class="keybind">1</span>
            <div class="cooldown-overlay" style="height: 0%"></div>
        </div>
        <div class="action-slot" data-slot="2" data-ability="burstFire">
            <span class="ability-name">Burst Fire</span>
            üí•
            <span class="keybind">2</span>
            <div class="cooldown-overlay" style="height: 0%"></div>
        </div>
        <div class="action-slot" data-slot="3" data-ability="heal">
            <span class="ability-name">Heal</span>
            üíö
            <span class="keybind">3</span>
            <div class="cooldown-overlay" style="height: 0%"></div>
        </div>
        <div class="action-slot" data-slot="4" data-ability="stimpak">
            <span class="ability-name">Stim Pack</span>
            üíâ
            <span class="keybind">4</span>
            <div class="cooldown-overlay" style="height: 0%"></div>
        </div>
        <div class="action-slot" data-slot="5" data-ability="harvest">
            <span class="ability-name">Harvest</span>
            ‚õèÔ∏è
            <span class="keybind">5</span>
            <div class="cooldown-overlay" style="height: 0%"></div>
        </div>
        <div class="action-slot" data-slot="6" data-ability="scan">
            <span class="ability-name">Creature Scan</span>
            üîç
            <span class="keybind">6</span>
            <div class="cooldown-overlay" style="height: 0%"></div>
        </div>
    </div>

    <!-- Ability Tooltip -->
    <div id="ability-tooltip" class="swg-panel">
        <div class="tooltip-name">Ability Name</div>
        <div class="tooltip-stats"></div>
        <div class="tooltip-desc"></div>
    </div>

    <!-- Achievements Button -->
    <div id="achievements-button" class="swg-panel">Achievements (J)</div>

    <!-- Achievements Window -->
    <div id="achievements-window" class="swg-panel">
        <button class="close-btn" onclick="closeAchievementsWindow()">X</button>
        <h2>Achievements</h2>
        <div id="achievements-grid" class="achievements-grid"></div>
    </div>

    <!-- Chat Box -->
    <div id="chat-box" class="swg-panel"></div>

    <!-- Minimap -->
    <div id="minimap" class="swg-panel">
        <canvas id="minimap-canvas" width="150" height="150"></canvas>
    </div>

    <!-- Location Display -->
    <div id="location-display" class="swg-panel">Tatooine (0, 0)</div>

    <!-- Interaction Prompt -->
    <div id="interact-prompt" class="swg-panel">[E] to interact</div>

    <!-- Skills Window -->
    <div id="skills-window" class="swg-panel">
        <button class="close-btn" onclick="closeSkillsWindow()">X</button>
        <h2>Skill Trees</h2>
        <div id="profession-tabs" style="display: flex; gap: 10px; margin-bottom: 15px;">
            <button onclick="showProfession('marksman')" class="swg-panel" style="padding: 5px 15px; cursor: pointer;">Marksman</button>
            <button onclick="showProfession('brawler')" class="swg-panel" style="padding: 5px 15px; cursor: pointer;">Brawler</button>
            <button onclick="showProfession('artisan')" class="swg-panel" style="padding: 5px 15px; cursor: pointer;">Artisan</button>
            <button onclick="showProfession('medic')" class="swg-panel" style="padding: 5px 15px; cursor: pointer;">Medic</button>
            <button onclick="showProfession('entertainer')" class="swg-panel" style="padding: 5px 15px; cursor: pointer;">Entertainer</button>
            <button onclick="showProfession('scout')" class="swg-panel" style="padding: 5px 15px; cursor: pointer;">Scout</button>
            <button onclick="showProfession('jedi')" class="swg-panel" style="padding: 5px 15px; cursor: pointer; color: #00ffff; text-shadow: 0 0 5px #00ffff;">Jedi</button>
        </div>
        <div id="skill-tree-container" class="skill-tree"></div>
    </div>

    <!-- Inventory Window -->
    <div id="inventory-window" class="swg-panel">
        <button class="close-btn" onclick="closeInventoryWindow()">X</button>
        <h2>Inventory</h2>
        <div class="equipment-slots">
            <div class="equip-slot" id="weapon-slot" onclick="unequipItem('weapon')" title="Weapon Slot">
                <span class="equip-slot-icon" id="weapon-slot-icon">-</span>
                <span class="equip-slot-label">Weapon</span>
            </div>
            <div class="equip-slot" id="armor-slot" onclick="unequipItem('armor')" title="Armor Slot">
                <span class="equip-slot-icon" id="armor-slot-icon">-</span>
                <span class="equip-slot-label">Armor</span>
            </div>
            <div class="equipment-stats" id="equipment-stats"></div>
        </div>
        <div id="inventory-grid" class="inventory-grid"></div>
        <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #333;">
            <h3 style="color: #ffd700; margin-bottom: 10px;">Resources</h3>
            <div id="resources-display" style="font-size: 12px;"></div>
        </div>
    </div>

    <!-- Crafting Window -->
    <div id="crafting-window" class="swg-panel">
        <button class="close-btn" onclick="closeCraftingWindow()">X</button>
        <h2>Crafting Station</h2>
        <div id="recipe-list" class="recipe-list"></div>
    </div>

    <!-- Vendor Window -->
    <div id="vendor-window" class="swg-panel">
        <button class="close-btn" onclick="closeVendorWindow()">X</button>
        <h2 id="vendor-name">Vendor</h2>
        <div id="vendor-items" class="vendor-items"></div>
    </div>

    <!-- Mission Terminal Window -->
    <div id="mission-window" class="swg-panel">
        <button class="close-btn" onclick="closeMissionWindow()">X</button>
        <h2>Mission Terminal</h2>
        <div class="mission-tabs">
            <div class="mission-tab active" data-tab="available" onclick="switchMissionTab('available')">Available</div>
            <div class="mission-tab" data-tab="active" onclick="switchMissionTab('active')">Active</div>
        </div>
        <div id="mission-list" class="mission-list"></div>
    </div>

    <!-- Active Mission HUD -->
    <div id="active-mission-hud" class="swg-panel">
        <div class="mission-title" id="active-mission-title">No Active Mission</div>
        <div class="mission-objective" id="active-mission-objective"></div>
        <div class="mission-progress"><div class="mission-progress-fill" id="active-mission-progress" style="width: 0%"></div></div>
    </div>

    <!-- Cantina UI -->
    <div id="cantina-ui" class="swg-panel">
        <button class="close-btn" onclick="closeCantinaUI()">X</button>
        <h2>Chalmun's Cantina</h2>
        <p style="color: #aaa; margin-bottom: 15px;">Watch entertainers to receive buffs!</p>
        <div class="entertainer-list">
            <div class="entertainer-item">
                <div>üé≠ Figrin D'an - Musician</div>
                <div style="color: #66ff66; font-size: 12px;">+50 Action Regen, +25% XP Bonus</div>
                <button class="watch-btn" onclick="watchEntertainer('musician')">Watch Performance</button>
            </div>
            <div class="entertainer-item">
                <div>üíÉ Oola - Dancer</div>
                <div style="color: #66ff66; font-size: 12px;">+50 Mind Regen, +10% Combat Speed</div>
                <button class="watch-btn" onclick="watchEntertainer('dancer')">Watch Performance</button>
            </div>
        </div>
        <div id="watching-progress" style="display: none;">
            <p style="color: #ffd700;">Watching performance...</p>
            <div class="buff-progress"><div class="buff-progress-fill" style="width: 0%"></div></div>
            <p id="buff-countdown" style="font-size: 12px; color: #aaa; margin-top: 5px;">Building buff: 0%</p>
        </div>
    </div>

    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script>
        // ==================== GAME STATE ====================
        const GameState = {
            player: {
                health: 1000, maxHealth: 1000,
                action: 500, maxAction: 500,
                mind: 500, maxMind: 500,
                credits: 1000,
                level: 1,
                position: { x: 0, y: 0, z: 0 }
            },
            target: null,
            inventory: [],
            equipment: {
                weapon: null,
                armor: null
            },
            resources: {
                iron: 0, copper: 0, steel: 0,
                hide: 0, bone: 0, meat: 0,
                chemicals: 0, flora: 0
            },
            skills: {
                marksman: { novice: true, rifleman1: false, rifleman2: false, rifleman3: false, rifleman4: false, pistoleer1: false, pistoleer2: false, pistoleer3: false, pistoleer4: false, carbineer1: false, carbineer2: false, carbineer3: false, carbineer4: false, master: false },
                brawler: { novice: false, unarmed1: false, unarmed2: false, unarmed3: false, unarmed4: false, onehand1: false, onehand2: false, onehand3: false, onehand4: false, twohand1: false, twohand2: false, twohand3: false, twohand4: false, master: false },
                artisan: { novice: true, engineering1: false, engineering2: false, engineering3: false, engineering4: false, domestic1: false, domestic2: false, domestic3: false, domestic4: false, business1: false, business2: false, business3: false, business4: false, master: false },
                medic: { novice: false, firstaid1: false, firstaid2: false, firstaid3: false, firstaid4: false, diagnostics1: false, diagnostics2: false, diagnostics3: false, diagnostics4: false, pharmacy1: false, pharmacy2: false, pharmacy3: false, pharmacy4: false, master: false },
                entertainer: { novice: false, dancing1: false, dancing2: false, dancing3: false, dancing4: false, music1: false, music2: false, music3: false, music4: false, image1: false, image2: false, image3: false, image4: false, master: false },
                scout: { novice: true, exploration1: false, exploration2: false, exploration3: false, exploration4: false, hunting1: false, hunting2: false, hunting3: false, hunting4: false, survival1: false, survival2: false, survival3: false, survival4: false, master: false },
                jedi: { novice: false, lightsaber1: false, lightsaber2: false, lightsaber3: false, lightsaber4: false, force1: false, force2: false, force3: false, force4: false, master: false }
            },
            skillXP: {
                marksman: 0, brawler: 0, artisan: 0, medic: 0, entertainer: 0, scout: 0, jedi: 0
            },
            buffs: [],
            cooldowns: {},
            inCombat: false,
            isPointerLocked: false,
            activeMission: null,
            missionProgress: {},
            statistics: {
                totalKills: 0,
                creaturesKilled: {},
                totalCreditsEarned: 0,
                totalXPEarned: 0,
                missionsCompleted: 0,
                criticalHits: 0,
                deaths: 0,
                totalPlayTime: 0
            },
            achievements: {},
            dailyChallenges: {
                lastRefresh: null,
                challenges: [],
                completedToday: 0
            }
        };

        const SKILL_XP_REQUIRED = 1000;
        const SAVE_VERSION = 1;

        // ==================== SAVE/LOAD SYSTEM ====================
        function saveGame(silent = false) {
            try {
                const saveData = {
                    version: SAVE_VERSION,
                    timestamp: Date.now(),
                    player: {
                        health: GameState.player.health,
                        maxHealth: GameState.player.maxHealth,
                        action: GameState.player.action,
                        maxAction: GameState.player.maxAction,
                        mind: GameState.player.mind,
                        maxMind: GameState.player.maxMind,
                        credits: GameState.player.credits,
                        level: GameState.player.level,
                        position: {
                            x: camera ? camera.position.x : 0,
                            z: camera ? camera.position.z : 0
                        }
                    },
                    inventory: GameState.inventory,
                    equipment: GameState.equipment,
                    resources: GameState.resources,
                    skills: GameState.skills,
                    skillXP: GameState.skillXP,
                    statistics: GameState.statistics,
                    achievements: GameState.achievements,
                    dailyChallenges: GameState.dailyChallenges
                };
                localStorage.setItem('swg_tatooine_save', JSON.stringify(saveData));
                if (!silent) addChatMessage('Game saved.', 'system');
                return true;
            } catch (e) {
                console.error('Save failed:', e);
                if (!silent) addChatMessage('Failed to save game!', 'system');
                return false;
            }
        }

        function loadGame() {
            try {
                const saved = localStorage.getItem('swg_tatooine_save');
                if (!saved) return false;

                const saveData = JSON.parse(saved);

                // Restore player stats
                Object.assign(GameState.player, saveData.player);
                GameState.inventory = saveData.inventory || [];
                GameState.equipment = saveData.equipment || { weapon: null, armor: null };
                GameState.resources = saveData.resources || GameState.resources;
                GameState.skills = saveData.skills || GameState.skills;
                GameState.skillXP = saveData.skillXP || GameState.skillXP;
                GameState.statistics = saveData.statistics || GameState.statistics;
                GameState.achievements = saveData.achievements || {};
                GameState.dailyChallenges = saveData.dailyChallenges || { lastRefresh: null, challenges: [], completedToday: 0 };

                return saveData;
            } catch (e) {
                console.error('Load failed:', e);
                return false;
            }
        }

        function clearSaveData() {
            if (confirm('Delete all save data? This cannot be undone.')) {
                localStorage.removeItem('swg_tatooine_save');
                location.reload();
            }
        }

        // ==================== AUDIO SYSTEM ====================
        const AudioManager = {
            ctx: null,
            masterGain: null,
            enabled: true,

            init() {
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.ctx.createGain();
                    this.masterGain.gain.value = 0.4;
                    this.masterGain.connect(this.ctx.destination);
                } catch (e) {
                    console.warn('Audio not supported');
                }
            },

            resume() {
                if (this.ctx && this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            },

            // Blaster shot - laser synth
            playBlasterShot() {
                if (!this.ctx || !this.enabled) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(800, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(200, this.ctx.currentTime + 0.12);
                gain.gain.setValueAtTime(0.25, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.12);
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.12);
            },

            // Critical hit - enhanced blaster
            playCritical() {
                if (!this.ctx || !this.enabled) return;
                this.playBlasterShot();
                setTimeout(() => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = 'square';
                    osc.frequency.value = 1200;
                    gain.gain.setValueAtTime(0.15, this.ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.08);
                    osc.connect(gain);
                    gain.connect(this.masterGain);
                    osc.start();
                    osc.stop(this.ctx.currentTime + 0.08);
                }, 40);
            },

            // Player hurt - low thud
            playPlayerHurt() {
                if (!this.ctx || !this.enabled) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(100, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(40, this.ctx.currentTime + 0.25);
                gain.gain.setValueAtTime(0.35, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.25);
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.25);
            },

            // Enemy death - descending tone
            playEnemyDeath() {
                if (!this.ctx || !this.enabled) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(400, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(80, this.ctx.currentTime + 0.4);
                gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.4);
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.4);
            },

            // UI click
            playUIClick() {
                if (!this.ctx || !this.enabled) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.value = 800;
                gain.gain.setValueAtTime(0.12, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.04);
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.04);
            },

            // Target acquired
            playTargetAcquired() {
                if (!this.ctx || !this.enabled) return;
                [400, 600].forEach((freq, i) => {
                    setTimeout(() => {
                        const osc = this.ctx.createOscillator();
                        const gain = this.ctx.createGain();
                        osc.type = 'square';
                        osc.frequency.value = freq;
                        gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.08);
                        osc.connect(gain);
                        gain.connect(this.masterGain);
                        osc.start();
                        osc.stop(this.ctx.currentTime + 0.08);
                    }, i * 80);
                });
            },

            // Loot jingle
            playLootJingle() {
                if (!this.ctx || !this.enabled) return;
                [523, 659, 784].forEach((freq, i) => {
                    setTimeout(() => {
                        const osc = this.ctx.createOscillator();
                        const gain = this.ctx.createGain();
                        osc.type = 'triangle';
                        osc.frequency.value = freq;
                        gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.2);
                        osc.connect(gain);
                        gain.connect(this.masterGain);
                        osc.start();
                        osc.stop(this.ctx.currentTime + 0.2);
                    }, i * 60);
                });
            },

            // Mission complete fanfare
            playMissionComplete() {
                if (!this.ctx || !this.enabled) return;
                [392, 494, 587, 784].forEach((freq, i) => {
                    setTimeout(() => {
                        const osc = this.ctx.createOscillator();
                        const gain = this.ctx.createGain();
                        osc.type = 'triangle';
                        osc.frequency.value = freq;
                        gain.gain.setValueAtTime(0.12, this.ctx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);
                        osc.connect(gain);
                        gain.connect(this.masterGain);
                        osc.start();
                        osc.stop(this.ctx.currentTime + 0.3);
                    }, i * 100);
                });
            },

            // Error buzz
            playError() {
                if (!this.ctx || !this.enabled) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.value = 150;
                gain.gain.setValueAtTime(0.15, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.15);
            }
        };

        // ==================== SKILL BONUSES SYSTEM ====================
        function calculateSkillBonuses() {
            let damageBonus = 0;
            let critBonus = 0;

            const marksman = GameState.skills.marksman;
            if (marksman.rifleman1) damageBonus += 5;
            if (marksman.rifleman2) damageBonus += 10;
            if (marksman.rifleman3) damageBonus += 15;
            if (marksman.rifleman4) { damageBonus += 20; critBonus += 5; }
            if (marksman.pistoleer1) critBonus += 2;
            if (marksman.pistoleer2) critBonus += 3;
            if (marksman.pistoleer3) critBonus += 4;
            if (marksman.pistoleer4) critBonus += 5;
            if (marksman.carbineer1) damageBonus += 3;
            if (marksman.carbineer2) damageBonus += 6;
            if (marksman.carbineer3) damageBonus += 9;
            if (marksman.carbineer4) damageBonus += 12;
            if (marksman.master) { damageBonus += 25; critBonus += 10; }

            const brawler = GameState.skills.brawler;
            if (brawler.unarmed1) damageBonus += 2;
            if (brawler.unarmed2) damageBonus += 4;
            if (brawler.unarmed3) damageBonus += 6;
            if (brawler.unarmed4) damageBonus += 8;
            if (brawler.master) damageBonus += 15;

            return { damageBonus, critBonus };
        }

        // ==================== MISSION TEMPLATES ====================
        const MISSION_TEMPLATES = {
            destroy: [
                { id: 'hunt_womprats', title: 'Womp Rat Infestation', desc: 'Clear out the womp rat population near the moisture farms.', target: 'womprat', count: 5, credits: 200, xp: 100, difficulty: 'easy' },
                { id: 'hunt_dewbacks', title: 'Dewback Hunting', desc: 'Local ranchers need dewback hides. Hunt some down.', target: 'dewback', count: 3, credits: 400, xp: 200, difficulty: 'medium' },
                { id: 'hunt_tuskens', title: 'Tusken Threat', desc: 'Tusken Raiders have been raiding caravans. Eliminate them.', target: 'tusken', count: 4, credits: 600, xp: 350, difficulty: 'medium' },
                { id: 'hunt_banthas', title: 'Bantha Bounty', desc: 'A wealthy collector wants bantha meat for a feast.', target: 'bantha', count: 2, credits: 800, xp: 400, difficulty: 'hard' },
                { id: 'krayt_slayer', title: 'Krayt Dragon Slayer', desc: 'Only the bravest dare face a Krayt Dragon. Are you one of them?', target: 'krayt', count: 1, credits: 5000, xp: 2000, difficulty: 'hard' }
            ],
            survey: [
                { id: 'survey_iron', title: 'Iron Survey', desc: 'The mining guild needs iron ore samples from the desert.', resource: 'iron', count: 5, credits: 150, xp: 80, difficulty: 'easy' },
                { id: 'survey_copper', title: 'Copper Expedition', desc: 'Locate and harvest copper deposits for electronics.', resource: 'copper', count: 5, credits: 150, xp: 80, difficulty: 'easy' },
                { id: 'survey_chemicals', title: 'Chemical Collection', desc: 'Gather chemical compounds for the medical facilities.', resource: 'chemicals', count: 8, credits: 250, xp: 120, difficulty: 'medium' },
                { id: 'survey_flora', title: 'Botanical Research', desc: 'Collect flora samples for agricultural research.', resource: 'flora', count: 10, credits: 300, xp: 150, difficulty: 'medium' }
            ],
            delivery: [
                { id: 'deliver_starport', title: 'Starport Delivery', desc: 'Deliver supplies to the Mos Eisley Starport.', waypoint: { x: -30, z: 30 }, credits: 100, xp: 50, difficulty: 'easy' },
                { id: 'deliver_cantina', title: 'Cantina Resupply', desc: 'Bring beverages to Chalmun\'s Cantina.', waypoint: { x: 70, z: 52 }, credits: 100, xp: 50, difficulty: 'easy' },
                { id: 'deliver_farm', title: 'Farm Equipment', desc: 'Deliver parts to the remote moisture farm.', waypoint: { x: -100, z: -80 }, credits: 200, xp: 100, difficulty: 'medium' },
                { id: 'deliver_outpost', title: 'Outpost Supplies', desc: 'Bring critical supplies to a distant outpost.', waypoint: { x: 150, z: -150 }, credits: 350, xp: 175, difficulty: 'hard' }
            ]
        };

        let availableMissions = [];
        let currentMissionTab = 'available';

        // ==================== SKILL DEFINITIONS ====================
        const SKILL_TREES = {
            marksman: {
                name: 'Marksman',
                skills: [
                    { id: 'novice', name: 'Novice Marksman', row: 0, col: 1.5, requires: null },
                    { id: 'rifleman1', name: 'Rifles I', row: 1, col: 0, requires: 'novice' },
                    { id: 'rifleman2', name: 'Rifles II', row: 2, col: 0, requires: 'rifleman1' },
                    { id: 'rifleman3', name: 'Rifles III', row: 3, col: 0, requires: 'rifleman2' },
                    { id: 'rifleman4', name: 'Rifles IV', row: 4, col: 0, requires: 'rifleman3' },
                    { id: 'pistoleer1', name: 'Pistols I', row: 1, col: 1, requires: 'novice' },
                    { id: 'pistoleer2', name: 'Pistols II', row: 2, col: 1, requires: 'pistoleer1' },
                    { id: 'pistoleer3', name: 'Pistols III', row: 3, col: 1, requires: 'pistoleer2' },
                    { id: 'pistoleer4', name: 'Pistols IV', row: 4, col: 1, requires: 'pistoleer3' },
                    { id: 'carbineer1', name: 'Carbines I', row: 1, col: 2, requires: 'novice' },
                    { id: 'carbineer2', name: 'Carbines II', row: 2, col: 2, requires: 'carbineer1' },
                    { id: 'carbineer3', name: 'Carbines III', row: 3, col: 2, requires: 'carbineer2' },
                    { id: 'carbineer4', name: 'Carbines IV', row: 4, col: 2, requires: 'carbineer3' },
                    { id: 'master', name: 'Master Marksman', row: 5, col: 1, requires: ['rifleman4', 'pistoleer4', 'carbineer4'] }
                ]
            },
            brawler: {
                name: 'Brawler',
                skills: [
                    { id: 'novice', name: 'Novice Brawler', row: 0, col: 1.5, requires: null },
                    { id: 'unarmed1', name: 'Unarmed I', row: 1, col: 0, requires: 'novice' },
                    { id: 'unarmed2', name: 'Unarmed II', row: 2, col: 0, requires: 'unarmed1' },
                    { id: 'unarmed3', name: 'Unarmed III', row: 3, col: 0, requires: 'unarmed2' },
                    { id: 'unarmed4', name: 'Unarmed IV', row: 4, col: 0, requires: 'unarmed3' },
                    { id: 'onehand1', name: 'One-Hand I', row: 1, col: 1, requires: 'novice' },
                    { id: 'onehand2', name: 'One-Hand II', row: 2, col: 1, requires: 'onehand1' },
                    { id: 'onehand3', name: 'One-Hand III', row: 3, col: 1, requires: 'onehand2' },
                    { id: 'onehand4', name: 'One-Hand IV', row: 4, col: 1, requires: 'onehand3' },
                    { id: 'twohand1', name: 'Two-Hand I', row: 1, col: 2, requires: 'novice' },
                    { id: 'twohand2', name: 'Two-Hand II', row: 2, col: 2, requires: 'twohand1' },
                    { id: 'twohand3', name: 'Two-Hand III', row: 3, col: 2, requires: 'twohand2' },
                    { id: 'twohand4', name: 'Two-Hand IV', row: 4, col: 2, requires: 'twohand3' },
                    { id: 'master', name: 'Master Brawler', row: 5, col: 1, requires: ['unarmed4', 'onehand4', 'twohand4'] }
                ]
            },
            artisan: {
                name: 'Artisan',
                skills: [
                    { id: 'novice', name: 'Novice Artisan', row: 0, col: 1.5, requires: null },
                    { id: 'engineering1', name: 'Engineering I', row: 1, col: 0, requires: 'novice' },
                    { id: 'engineering2', name: 'Engineering II', row: 2, col: 0, requires: 'engineering1' },
                    { id: 'engineering3', name: 'Engineering III', row: 3, col: 0, requires: 'engineering2' },
                    { id: 'engineering4', name: 'Engineering IV', row: 4, col: 0, requires: 'engineering3' },
                    { id: 'domestic1', name: 'Domestic I', row: 1, col: 1, requires: 'novice' },
                    { id: 'domestic2', name: 'Domestic II', row: 2, col: 1, requires: 'domestic1' },
                    { id: 'domestic3', name: 'Domestic III', row: 3, col: 1, requires: 'domestic2' },
                    { id: 'domestic4', name: 'Domestic IV', row: 4, col: 1, requires: 'domestic3' },
                    { id: 'business1', name: 'Business I', row: 1, col: 2, requires: 'novice' },
                    { id: 'business2', name: 'Business II', row: 2, col: 2, requires: 'business1' },
                    { id: 'business3', name: 'Business III', row: 3, col: 2, requires: 'business2' },
                    { id: 'business4', name: 'Business IV', row: 4, col: 2, requires: 'business3' },
                    { id: 'master', name: 'Master Artisan', row: 5, col: 1, requires: ['engineering4', 'domestic4', 'business4'] }
                ]
            },
            medic: {
                name: 'Medic',
                skills: [
                    { id: 'novice', name: 'Novice Medic', row: 0, col: 1.5, requires: null },
                    { id: 'firstaid1', name: 'First Aid I', row: 1, col: 0, requires: 'novice' },
                    { id: 'firstaid2', name: 'First Aid II', row: 2, col: 0, requires: 'firstaid1' },
                    { id: 'firstaid3', name: 'First Aid III', row: 3, col: 0, requires: 'firstaid2' },
                    { id: 'firstaid4', name: 'First Aid IV', row: 4, col: 0, requires: 'firstaid3' },
                    { id: 'diagnostics1', name: 'Diagnostics I', row: 1, col: 1, requires: 'novice' },
                    { id: 'diagnostics2', name: 'Diagnostics II', row: 2, col: 1, requires: 'diagnostics1' },
                    { id: 'diagnostics3', name: 'Diagnostics III', row: 3, col: 1, requires: 'diagnostics2' },
                    { id: 'diagnostics4', name: 'Diagnostics IV', row: 4, col: 1, requires: 'diagnostics3' },
                    { id: 'pharmacy1', name: 'Pharmacology I', row: 1, col: 2, requires: 'novice' },
                    { id: 'pharmacy2', name: 'Pharmacology II', row: 2, col: 2, requires: 'pharmacy1' },
                    { id: 'pharmacy3', name: 'Pharmacology III', row: 3, col: 2, requires: 'pharmacy2' },
                    { id: 'pharmacy4', name: 'Pharmacology IV', row: 4, col: 2, requires: 'pharmacy3' },
                    { id: 'master', name: 'Master Medic', row: 5, col: 1, requires: ['firstaid4', 'diagnostics4', 'pharmacy4'] }
                ]
            },
            entertainer: {
                name: 'Entertainer',
                skills: [
                    { id: 'novice', name: 'Novice Entertainer', row: 0, col: 1.5, requires: null },
                    { id: 'dancing1', name: 'Dancing I', row: 1, col: 0, requires: 'novice' },
                    { id: 'dancing2', name: 'Dancing II', row: 2, col: 0, requires: 'dancing1' },
                    { id: 'dancing3', name: 'Dancing III', row: 3, col: 0, requires: 'dancing2' },
                    { id: 'dancing4', name: 'Dancing IV', row: 4, col: 0, requires: 'dancing3' },
                    { id: 'music1', name: 'Musician I', row: 1, col: 1, requires: 'novice' },
                    { id: 'music2', name: 'Musician II', row: 2, col: 1, requires: 'music1' },
                    { id: 'music3', name: 'Musician III', row: 3, col: 1, requires: 'music2' },
                    { id: 'music4', name: 'Musician IV', row: 4, col: 1, requires: 'music3' },
                    { id: 'image1', name: 'Image Design I', row: 1, col: 2, requires: 'novice' },
                    { id: 'image2', name: 'Image Design II', row: 2, col: 2, requires: 'image1' },
                    { id: 'image3', name: 'Image Design III', row: 3, col: 2, requires: 'image2' },
                    { id: 'image4', name: 'Image Design IV', row: 4, col: 2, requires: 'image3' },
                    { id: 'master', name: 'Master Entertainer', row: 5, col: 1, requires: ['dancing4', 'music4', 'image4'] }
                ]
            },
            scout: {
                name: 'Scout',
                skills: [
                    { id: 'novice', name: 'Novice Scout', row: 0, col: 1.5, requires: null },
                    { id: 'exploration1', name: 'Exploration I', row: 1, col: 0, requires: 'novice' },
                    { id: 'exploration2', name: 'Exploration II', row: 2, col: 0, requires: 'exploration1' },
                    { id: 'exploration3', name: 'Exploration III', row: 3, col: 0, requires: 'exploration2' },
                    { id: 'exploration4', name: 'Exploration IV', row: 4, col: 0, requires: 'exploration3' },
                    { id: 'hunting1', name: 'Hunting I', row: 1, col: 1, requires: 'novice' },
                    { id: 'hunting2', name: 'Hunting II', row: 2, col: 1, requires: 'hunting1' },
                    { id: 'hunting3', name: 'Hunting III', row: 3, col: 1, requires: 'hunting2' },
                    { id: 'hunting4', name: 'Hunting IV', row: 4, col: 1, requires: 'hunting3' },
                    { id: 'survival1', name: 'Survival I', row: 1, col: 2, requires: 'novice' },
                    { id: 'survival2', name: 'Survival II', row: 2, col: 2, requires: 'survival1' },
                    { id: 'survival3', name: 'Survival III', row: 3, col: 2, requires: 'survival2' },
                    { id: 'survival4', name: 'Survival IV', row: 4, col: 2, requires: 'survival3' },
                    { id: 'master', name: 'Master Scout', row: 5, col: 1, requires: ['exploration4', 'hunting4', 'survival4'] }
                ]
            },
            jedi: {
                name: 'Jedi',
                skills: [
                    { id: 'novice', name: 'Force Sensitive', row: 0, col: 1.5, requires: null },
                    { id: 'lightsaber1', name: 'Lightsaber I', row: 1, col: 0, requires: 'novice' },
                    { id: 'lightsaber2', name: 'Lightsaber II', row: 2, col: 0, requires: 'lightsaber1' },
                    { id: 'lightsaber3', name: 'Lightsaber III', row: 3, col: 0, requires: 'lightsaber2' },
                    { id: 'lightsaber4', name: 'Lightsaber IV', row: 4, col: 0, requires: 'lightsaber3' },
                    { id: 'force1', name: 'Force Powers I', row: 1, col: 2, requires: 'novice' },
                    { id: 'force2', name: 'Force Powers II', row: 2, col: 2, requires: 'force1' },
                    { id: 'force3', name: 'Force Powers III', row: 3, col: 2, requires: 'force2' },
                    { id: 'force4', name: 'Force Powers IV', row: 4, col: 2, requires: 'force3' },
                    { id: 'master', name: 'Jedi Master', row: 5, col: 1, requires: ['lightsaber4', 'force4'] }
                ]
            }
        };

        // ==================== ABILITIES ====================
        const ABILITIES = {
            rangedShot: { name: 'Ranged Shot', damage: 50, actionCost: 20, cooldown: 1000, range: 50, type: 'ranged' },
            burstFire: { name: 'Burst Fire', damage: 120, actionCost: 60, cooldown: 5000, range: 40, type: 'ranged' },
            heal: { name: 'Heal', healing: 150, mindCost: 50, cooldown: 8000, type: 'heal' },
            stimpak: { name: 'Stim Pack', healing: 300, cooldown: 30000, type: 'item', requires: 'stimpak' },
            harvest: { name: 'Harvest', cooldown: 3000, type: 'harvest' },
            scan: { name: 'Creature Scan', cooldown: 5000, type: 'scan', range: 30 },
            lightsaberStrike: { name: 'Lightsaber Strike', damage: 150, actionCost: 30, cooldown: 1500, range: 5, type: 'lightsaber' },
            forcePush: { name: 'Force Push', damage: 50, mindCost: 40, cooldown: 8000, range: 15, type: 'force' },
            forceHeal: { name: 'Force Heal', healing: 400, mindCost: 100, cooldown: 15000, type: 'heal' },
            lightsaberThrow: { name: 'Lightsaber Throw', damage: 200, actionCost: 50, cooldown: 10000, range: 25, type: 'lightsaber' }
        };

        // ==================== CREATURES ====================
        const CREATURE_TYPES = {
            womprat: { name: 'Womp Rat', health: 150, damage: 15, xp: 50, level: 1, loot: ['hide', 'bone', 'meat'], credits: [5, 15], icon: 'üêÄ', behavior: 'pack', aggroRadius: 0 },
            dewback: { name: 'Dewback', health: 400, damage: 35, xp: 150, level: 5, loot: ['hide', 'bone', 'meat'], credits: [20, 50], icon: 'ü¶é', behavior: 'charge', aggroRadius: 15 },
            bantha: { name: 'Bantha', health: 800, damage: 50, xp: 300, level: 10, loot: ['hide', 'bone', 'meat', 'hide'], credits: [50, 100], icon: 'ü¶¨', behavior: 'defensive', aggroRadius: 10 },
            tusken: { name: 'Tusken Raider', health: 350, damage: 45, xp: 200, level: 8, loot: ['iron', 'credits'], credits: [30, 80], icon: 'üë§', behavior: 'ranged', aggroRadius: 25 },
            krayt: { name: 'Krayt Dragon', health: 5000, damage: 200, xp: 2000, level: 50, loot: ['bone', 'bone', 'bone', 'kraytPearl'], credits: [500, 1000], icon: 'üêâ', boss: true, behavior: 'boss', aggroRadius: 40 },
            jawa: { name: 'Jawa Scavenger', health: 100, damage: 10, xp: 30, level: 1, loot: ['copper', 'iron'], credits: [10, 30], icon: 'üßô', neutral: true, behavior: 'flee', aggroRadius: 0 },
            rontoHerd: { name: 'Ronto', health: 600, damage: 40, xp: 180, level: 7, loot: ['hide', 'meat', 'bone'], credits: [40, 80], icon: 'ü¶í', behavior: 'defensive', aggroRadius: 12 },
            // Mid-tier creatures (L15-L35) to fill the gap between Bantha and Krayt
            sandPanther: { name: 'Sand Panther', health: 700, damage: 60, xp: 400, level: 15, loot: ['hide', 'bone', 'meat'], credits: [70, 140], icon: 'üêÜ', behavior: 'pack', aggroRadius: 20 },
            squill: { name: 'Squill', health: 1000, damage: 80, xp: 550, level: 20, loot: ['hide', 'meat', 'bone', 'chemicals'], credits: [100, 200], icon: 'ü¶Ç', behavior: 'charge', aggroRadius: 22 },
            tuskenChieftain: { name: 'Tusken Chieftain', health: 1400, damage: 100, xp: 750, level: 25, loot: ['iron', 'steel', 'credits'], credits: [150, 300], icon: '‚öîÔ∏è', behavior: 'ranged', aggroRadius: 30, elite: true },
            canyonWraith: { name: 'Canyon Wraith', health: 2200, damage: 130, xp: 1000, level: 35, loot: ['bone', 'hide', 'chemicals', 'bone'], credits: [250, 500], icon: 'üëª', behavior: 'defensive', aggroRadius: 25 }
        };

        // ==================== RECIPES ====================
        const RECIPES = [
            { id: 'basicBlaster', name: 'Basic Blaster', materials: { iron: 5, copper: 3 }, skill: 'artisan', result: { type: 'weapon', damage: 30 } },
            { id: 'stimpak', name: 'Stim Pack', materials: { chemicals: 3, flora: 2 }, skill: 'artisan', result: { type: 'consumable', healing: 300 } },
            { id: 'medpack', name: 'Med Pack', materials: { chemicals: 5, flora: 3 }, skill: 'medic', result: { type: 'consumable', healing: 500 } },
            { id: 'compositeArmor', name: 'Composite Armor', materials: { steel: 10, hide: 5, bone: 3 }, skill: 'artisan', result: { type: 'armor', defense: 50 } },
            { id: 'surveyDevice', name: 'Survey Device', materials: { copper: 5, iron: 3 }, skill: 'artisan', result: { type: 'tool' } }
        ];

        // ==================== VENDORS ====================
        const VENDORS = {
            weaponVendor: {
                name: 'Wuher\'s Arms Dealer',
                items: [
                    { name: 'CDEF Pistol', price: 500, type: 'weapon', damage: 40 },
                    { name: 'DL-44 Heavy Blaster', price: 1500, type: 'weapon', damage: 70 },
                    { name: 'E-11 Blaster Rifle', price: 2500, type: 'weapon', damage: 100 },
                    { name: 'Bowcaster', price: 5000, type: 'weapon', damage: 150 },
                    { name: 'Training Lightsaber', price: 1000, type: 'weapon', damage: 40 }
                ]
            },
            armorVendor: {
                name: 'Desert Outfitters',
                items: [
                    { name: 'Padded Armor', price: 300, type: 'armor', defense: 20 },
                    { name: 'Battle Armor', price: 1000, type: 'armor', defense: 50 },
                    { name: 'Composite Armor', price: 3000, type: 'armor', defense: 100 }
                ]
            },
            generalVendor: {
                name: 'Mos Eisley General Store',
                items: [
                    { name: 'Stim Pack', price: 50, type: 'consumable', healing: 300 },
                    { name: 'Survey Device', price: 200, type: 'tool' },
                    { name: 'Mineral Survey Tool', price: 500, type: 'tool' },
                    { name: 'Creature Trap', price: 300, type: 'tool' },
                    { name: 'Jedi Holocron', price: 5000, type: 'holocron' }
                ]
            }
        };

        // ==================== ACHIEVEMENTS ====================
        const ACHIEVEMENT_DEFINITIONS = [
            // Combat Achievements
            { id: 'firstBlood', name: 'First Blood', desc: 'Defeat your first creature', icon: '‚öîÔ∏è', check: () => GameState.statistics.totalKills >= 1, threshold: 1 },
            { id: 'hunter10', name: 'Novice Hunter', desc: 'Defeat 10 creatures', icon: 'üéØ', check: () => GameState.statistics.totalKills >= 10, threshold: 10 },
            { id: 'hunter50', name: 'Skilled Hunter', desc: 'Defeat 50 creatures', icon: 'üèπ', check: () => GameState.statistics.totalKills >= 50, threshold: 50 },
            { id: 'hunter100', name: 'Master Hunter', desc: 'Defeat 100 creatures', icon: 'üèÜ', check: () => GameState.statistics.totalKills >= 100, threshold: 100 },
            { id: 'hunter500', name: 'Legendary Hunter', desc: 'Defeat 500 creatures', icon: 'üëë', check: () => GameState.statistics.totalKills >= 500, threshold: 500 },

            // Critical Hit Achievements
            { id: 'crit10', name: 'Sharp Shooter', desc: 'Land 10 critical hits', icon: 'üí•', check: () => GameState.statistics.criticalHits >= 10, threshold: 10 },
            { id: 'crit50', name: 'Precision Expert', desc: 'Land 50 critical hits', icon: 'üéØ', check: () => GameState.statistics.criticalHits >= 50, threshold: 50 },

            // Creature-Specific Achievements
            { id: 'ratSlayer', name: 'Rat Catcher', desc: 'Defeat 20 Womp Rats', icon: 'üêÄ', check: () => (GameState.statistics.creaturesKilled.womprat || 0) >= 20, threshold: 20 },
            { id: 'kraytSlayer', name: 'Krayt Slayer', desc: 'Defeat a Krayt Dragon', icon: 'üêâ', check: () => (GameState.statistics.creaturesKilled.krayt || 0) >= 1, threshold: 1 },
            { id: 'tuskenTerror', name: 'Tusken Terror', desc: 'Defeat 25 Tusken Raiders', icon: 'üë§', check: () => (GameState.statistics.creaturesKilled.tusken || 0) >= 25, threshold: 25 },

            // Wealth Achievements
            { id: 'credits1k', name: 'Modest Fortune', desc: 'Earn 1,000 total credits', icon: 'üí∞', check: () => GameState.statistics.totalCreditsEarned >= 1000, threshold: 1000 },
            { id: 'credits10k', name: 'Wealthy Trader', desc: 'Earn 10,000 total credits', icon: 'üíé', check: () => GameState.statistics.totalCreditsEarned >= 10000, threshold: 10000 },
            { id: 'credits100k', name: 'Credit Mogul', desc: 'Earn 100,000 total credits', icon: 'üè¶', check: () => GameState.statistics.totalCreditsEarned >= 100000, threshold: 100000 },

            // Mission Achievements
            { id: 'mission1', name: 'Mission Rookie', desc: 'Complete your first mission', icon: 'üìã', check: () => GameState.statistics.missionsCompleted >= 1, threshold: 1 },
            { id: 'mission10', name: 'Reliable Contractor', desc: 'Complete 10 missions', icon: 'üìú', check: () => GameState.statistics.missionsCompleted >= 10, threshold: 10 },
            { id: 'mission25', name: 'Mission Specialist', desc: 'Complete 25 missions', icon: 'üéñÔ∏è', check: () => GameState.statistics.missionsCompleted >= 25, threshold: 25 },

            // XP Achievements
            { id: 'xp5k', name: 'Apprentice', desc: 'Earn 5,000 total XP', icon: 'üìö', check: () => GameState.statistics.totalXPEarned >= 5000, threshold: 5000 },
            { id: 'xp25k', name: 'Journeyman', desc: 'Earn 25,000 total XP', icon: 'üéì', check: () => GameState.statistics.totalXPEarned >= 25000, threshold: 25000 },
            { id: 'xp100k', name: 'Expert', desc: 'Earn 100,000 total XP', icon: 'üåü', check: () => GameState.statistics.totalXPEarned >= 100000, threshold: 100000 }
        ];

        function checkAchievements() {
            let newAchievements = [];
            ACHIEVEMENT_DEFINITIONS.forEach(achievement => {
                if (!GameState.achievements[achievement.id] && achievement.check()) {
                    GameState.achievements[achievement.id] = {
                        unlockedAt: Date.now()
                    };
                    newAchievements.push(achievement);
                }
            });

            // Show notifications for new achievements
            newAchievements.forEach((achievement, i) => {
                setTimeout(() => showAchievementNotification(achievement), i * 500);
            });

            return newAchievements.length > 0;
        }

        function showAchievementNotification(achievement) {
            // Play sound
            AudioManager.playMissionComplete();

            // Create notification element
            const notif = document.createElement('div');
            notif.className = 'achievement-notification swg-panel';
            notif.innerHTML = `
                <div class="notif-icon">${achievement.icon}</div>
                <div class="notif-text">
                    <div class="notif-title">Achievement Unlocked!</div>
                    <div class="notif-name">${achievement.name}</div>
                </div>
            `;
            document.body.appendChild(notif);

            // Chat message
            addChatMessage(`Achievement Unlocked: ${achievement.name} - ${achievement.desc}`, 'xp');

            // Remove after animation
            setTimeout(() => {
                if (notif.parentNode) notif.parentNode.removeChild(notif);
            }, 4000);
        }

        function renderAchievementsWindow() {
            const container = document.getElementById('achievements-grid');
            container.innerHTML = '';

            const unlockedCount = Object.keys(GameState.achievements).length;
            const totalCount = ACHIEVEMENT_DEFINITIONS.length;

            // Update header with count
            document.querySelector('#achievements-window h2').textContent = `Achievements (${unlockedCount}/${totalCount})`;

            ACHIEVEMENT_DEFINITIONS.forEach(achievement => {
                const isUnlocked = !!GameState.achievements[achievement.id];
                const card = document.createElement('div');
                card.className = `achievement-card ${isUnlocked ? 'unlocked' : 'locked'}`;

                // Calculate progress for locked achievements
                let progressHtml = '';
                if (!isUnlocked && achievement.threshold) {
                    const current = getAchievementProgress(achievement);
                    const percent = Math.min(100, (current / achievement.threshold) * 100);
                    progressHtml = `
                        <div class="achievement-progress">
                            <div class="achievement-progress-fill" style="width: ${percent}%"></div>
                        </div>
                        <div class="achievement-progress-text">${current.toLocaleString()} / ${achievement.threshold.toLocaleString()}</div>
                    `;
                }

                card.innerHTML = `
                    <div class="achievement-icon">${isUnlocked ? achievement.icon : 'üîí'}</div>
                    <div class="achievement-info">
                        <div class="achievement-name">${achievement.name}</div>
                        <div class="achievement-desc">${achievement.desc}</div>
                        ${progressHtml}
                    </div>
                `;

                container.appendChild(card);
            });
        }

        function getAchievementProgress(achievement) {
            // Extract current progress based on achievement type
            if (achievement.id.startsWith('hunter')) return GameState.statistics.totalKills;
            if (achievement.id.startsWith('crit')) return GameState.statistics.criticalHits;
            if (achievement.id.startsWith('credits')) return GameState.statistics.totalCreditsEarned;
            if (achievement.id.startsWith('mission')) return GameState.statistics.missionsCompleted;
            if (achievement.id.startsWith('xp')) return GameState.statistics.totalXPEarned;
            if (achievement.id === 'ratSlayer') return GameState.statistics.creaturesKilled.womprat || 0;
            if (achievement.id === 'kraytSlayer') return GameState.statistics.creaturesKilled.krayt || 0;
            if (achievement.id === 'tuskenTerror') return GameState.statistics.creaturesKilled.tusken || 0;
            if (achievement.id === 'firstBlood') return GameState.statistics.totalKills;
            return 0;
        }

        function toggleAchievementsWindow() {
            const window = document.getElementById('achievements-window');
            window.classList.toggle('active');
            if (window.classList.contains('active')) {
                renderAchievementsWindow();
            }
        }

        function closeAchievementsWindow() {
            document.getElementById('achievements-window').classList.remove('active');
        }

        // ==================== DAILY CHALLENGE SYSTEM ====================
        const DAILY_CHALLENGE_TEMPLATES = [
            // Kill challenges
            { type: 'kills', name: 'Hunter', desc: 'Kill {count} creatures', countRange: [5, 15], rewards: { credits: 100, xp: 200 }, icon: 'üéØ' },
            { type: 'killType', creature: 'womprat', name: 'Rat Exterminator', desc: 'Kill {count} Womp Rats', countRange: [3, 8], rewards: { credits: 75, xp: 150 }, icon: 'üêÄ' },
            { type: 'killType', creature: 'dewback', name: 'Dewback Wrangler', desc: 'Kill {count} Dewbacks', countRange: [2, 5], rewards: { credits: 150, xp: 300 }, icon: 'ü¶é' },
            { type: 'killType', creature: 'tusken', name: 'Tusken Hunter', desc: 'Kill {count} Tusken Raiders', countRange: [2, 4], rewards: { credits: 200, xp: 400 }, icon: 'üë§' },
            { type: 'killType', creature: 'bantha', name: 'Big Game Hunter', desc: 'Kill {count} Banthas', countRange: [1, 3], rewards: { credits: 250, xp: 500 }, icon: 'ü¶¨' },

            // Resource challenges
            { type: 'gather', resource: 'any', name: 'Scavenger', desc: 'Gather {count} resources', countRange: [10, 25], rewards: { credits: 80, xp: 160 }, icon: 'üì¶' },
            { type: 'gather', resource: 'hide', name: 'Tanner', desc: 'Gather {count} hides', countRange: [5, 12], rewards: { credits: 100, xp: 180 }, icon: 'üß∂' },
            { type: 'gather', resource: 'bone', name: 'Bone Collector', desc: 'Gather {count} bones', countRange: [5, 10], rewards: { credits: 90, xp: 170 }, icon: 'ü¶¥' },

            // Combat challenges
            { type: 'criticalHits', name: 'Precision Strike', desc: 'Land {count} critical hits', countRange: [3, 8], rewards: { credits: 120, xp: 250 }, icon: 'üí•' },
            { type: 'abilityUses', name: 'Combat Specialist', desc: 'Use abilities {count} times', countRange: [15, 30], rewards: { credits: 100, xp: 200 }, icon: '‚öîÔ∏è' },

            // Mission challenges
            { type: 'missions', name: 'Mercenary Work', desc: 'Complete {count} missions', countRange: [1, 3], rewards: { credits: 200, xp: 400 }, icon: 'üìú' },

            // Earning challenges
            { type: 'earnCredits', name: 'Entrepreneur', desc: 'Earn {count} credits', countRange: [200, 500], rewards: { credits: 50, xp: 300 }, icon: 'üí∞' },
            { type: 'earnXP', name: 'Learner', desc: 'Earn {count} XP', countRange: [500, 1500], rewards: { credits: 150, xp: 100 }, icon: 'üìö' },

            // Survival challenges
            { type: 'surviveMinutes', name: 'Survivor', desc: 'Survive for {count} minutes without dying', countRange: [5, 15], rewards: { credits: 180, xp: 350 }, icon: 'üõ°Ô∏è' }
        ];

        function getDailyResetTime() {
            const now = new Date();
            const reset = new Date(now);
            reset.setHours(0, 0, 0, 0);
            reset.setDate(reset.getDate() + 1);
            return reset.getTime();
        }

        function getTimeUntilReset() {
            const now = Date.now();
            const reset = getDailyResetTime();
            const diff = reset - now;
            const hours = Math.floor(diff / (1000 * 60 * 60));
            const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
            return `${hours}h ${minutes}m`;
        }

        function generateDailyChallenges() {
            const today = new Date().toDateString();

            // Check if we need to refresh challenges
            if (GameState.dailyChallenges.lastRefresh !== today) {
                // Use date as seed for consistent challenges per day
                const seed = new Date().setHours(0, 0, 0, 0);
                const rng = (x) => {
                    x = Math.sin(x) * 10000;
                    return x - Math.floor(x);
                };

                // Select 3 random challenges
                const shuffled = [...DAILY_CHALLENGE_TEMPLATES].sort((a, b) => rng(seed + DAILY_CHALLENGE_TEMPLATES.indexOf(a)) - 0.5);
                const selected = shuffled.slice(0, 3);

                GameState.dailyChallenges = {
                    lastRefresh: today,
                    challenges: selected.map((template, i) => {
                        const count = template.countRange[0] + Math.floor(rng(seed + i * 100) * (template.countRange[1] - template.countRange[0] + 1));
                        return {
                            id: `daily_${i}_${Date.now()}`,
                            template: DAILY_CHALLENGE_TEMPLATES.indexOf(template),
                            name: template.name,
                            desc: template.desc.replace('{count}', count),
                            icon: template.icon,
                            type: template.type,
                            creature: template.creature,
                            resource: template.resource,
                            target: count,
                            progress: 0,
                            completed: false,
                            claimed: false,
                            rewards: {
                                credits: Math.floor(template.rewards.credits * (count / template.countRange[0])),
                                xp: Math.floor(template.rewards.xp * (count / template.countRange[0]))
                            },
                            startStats: {
                                kills: GameState.statistics.totalKills,
                                criticalHits: GameState.statistics.criticalHits,
                                missions: GameState.statistics.missionsCompleted,
                                credits: GameState.statistics.totalCreditsEarned,
                                xp: GameState.statistics.totalXPEarned,
                                abilityUses: GameState.abilityUsesThisSession || 0,
                                surviveStart: Date.now(),
                                creatureKills: { ...GameState.statistics.creaturesKilled },
                                resourcesGathered: { ...GameState.resources }
                            }
                        };
                    }),
                    completedToday: 0
                };

                saveGame(true);
                addChatMessage('New daily challenges available!', 'system');
            }
        }

        function updateDailyChallengeProgress() {
            if (!GameState.dailyChallenges.challenges) return;

            GameState.dailyChallenges.challenges.forEach(challenge => {
                if (challenge.completed) return;

                const start = challenge.startStats;
                let newProgress = 0;

                switch (challenge.type) {
                    case 'kills':
                        newProgress = GameState.statistics.totalKills - start.kills;
                        break;
                    case 'killType':
                        const creatureKills = GameState.statistics.creaturesKilled[challenge.creature] || 0;
                        const startCreatureKills = start.creatureKills[challenge.creature] || 0;
                        newProgress = creatureKills - startCreatureKills;
                        break;
                    case 'gather':
                        if (challenge.resource === 'any') {
                            const totalNow = Object.values(GameState.resources).reduce((a, b) => a + b, 0);
                            const totalStart = Object.values(start.resourcesGathered).reduce((a, b) => a + b, 0);
                            newProgress = totalNow - totalStart;
                        } else {
                            newProgress = (GameState.resources[challenge.resource] || 0) - (start.resourcesGathered[challenge.resource] || 0);
                        }
                        break;
                    case 'criticalHits':
                        newProgress = GameState.statistics.criticalHits - start.criticalHits;
                        break;
                    case 'abilityUses':
                        newProgress = (GameState.abilityUsesThisSession || 0) - start.abilityUses;
                        break;
                    case 'missions':
                        newProgress = GameState.statistics.missionsCompleted - start.missions;
                        break;
                    case 'earnCredits':
                        newProgress = GameState.statistics.totalCreditsEarned - start.credits;
                        break;
                    case 'earnXP':
                        newProgress = GameState.statistics.totalXPEarned - start.xp;
                        break;
                    case 'surviveMinutes':
                        // Track minutes since challenge start without dying
                        const minutesSurvived = Math.floor((Date.now() - start.surviveStart) / 60000);
                        newProgress = minutesSurvived;
                        break;
                }

                challenge.progress = Math.max(0, Math.min(challenge.target, newProgress));

                // Check for completion
                if (challenge.progress >= challenge.target && !challenge.completed) {
                    challenge.completed = true;
                    GameState.dailyChallenges.completedToday++;
                    showDailyChallengeComplete(challenge);
                }
            });

            updateDailyChallengesUI();
        }

        function showDailyChallengeComplete(challenge) {
            AudioManager.playMissionComplete();
            addChatMessage(`Daily Challenge Complete: ${challenge.name}! Claim your reward.`, 'xp');

            // Flash the button
            const button = document.getElementById('daily-challenges-button');
            button.classList.add('has-incomplete');
        }

        function claimChallengeReward(challengeId) {
            const challenge = GameState.dailyChallenges.challenges.find(c => c.id === challengeId);
            if (!challenge || !challenge.completed || challenge.claimed) return;

            challenge.claimed = true;

            // Grant rewards
            GameState.player.credits += challenge.rewards.credits;
            GameState.statistics.totalCreditsEarned += challenge.rewards.credits;

            const totalXP = challenge.rewards.xp;
            distributeXP(totalXP);
            GameState.statistics.totalXPEarned += totalXP;

            addChatMessage(`Claimed: +${challenge.rewards.credits} credits, +${challenge.rewards.xp} XP`, 'xp');
            AudioManager.playSound('pickup');

            updateDailyChallengesUI();
            updateUI();
            saveGame(true);

            // Check if all claimed
            const allClaimed = GameState.dailyChallenges.challenges.every(c => c.claimed);
            if (allClaimed) {
                document.getElementById('daily-challenges-button').classList.remove('has-incomplete');
            }
        }

        function toggleDailyChallenges() {
            const panel = document.getElementById('daily-challenges-panel');
            panel.classList.toggle('active');
            if (panel.classList.contains('active')) {
                generateDailyChallenges();
                updateDailyChallengesUI();
            }
        }

        function updateDailyChallengesUI() {
            const container = document.getElementById('challenges-list');
            const timer = document.getElementById('daily-timer');

            if (!GameState.dailyChallenges.challenges) {
                generateDailyChallenges();
            }

            timer.textContent = `Resets in: ${getTimeUntilReset()}`;

            container.innerHTML = GameState.dailyChallenges.challenges.map(challenge => {
                const percent = Math.min(100, (challenge.progress / challenge.target) * 100);
                const statusText = challenge.claimed ? 'Claimed' : (challenge.completed ? 'Click to Claim!' : `${challenge.progress}/${challenge.target}`);

                return `
                    <div class="challenge-item ${challenge.completed ? 'completed' : ''}"
                         onclick="${challenge.completed && !challenge.claimed ? `claimChallengeReward('${challenge.id}')` : ''}"
                         style="${challenge.completed && !challenge.claimed ? 'cursor: pointer;' : ''}">
                        <div class="challenge-name">${challenge.icon} ${challenge.name}</div>
                        <div class="challenge-desc">${challenge.desc}</div>
                        <div class="challenge-progress">
                            <div class="challenge-progress-bar" style="width: ${percent}%"></div>
                        </div>
                        <div class="challenge-status">
                            <span>${statusText}</span>
                            <span class="challenge-reward">${challenge.rewards.credits}üí∞ ${challenge.rewards.xp}‚≠ê</span>
                        </div>
                    </div>
                `;
            }).join('');

            // Update button pulse
            const hasUnclaimedComplete = GameState.dailyChallenges.challenges.some(c => c.completed && !c.claimed);
            const button = document.getElementById('daily-challenges-button');
            if (hasUnclaimedComplete) {
                button.classList.add('has-incomplete');
            } else {
                button.classList.remove('has-incomplete');
            }
        }

        function resetSurvivalChallengeOnDeath() {
            if (!GameState.dailyChallenges.challenges) return;

            GameState.dailyChallenges.challenges.forEach(challenge => {
                if (challenge.type === 'surviveMinutes' && !challenge.completed) {
                    challenge.startStats.surviveStart = Date.now();
                    challenge.progress = 0;
                    addChatMessage('Survival challenge reset due to death.', 'combat');
                }
            });
        }

        // ==================== ABILITY TOOLTIPS ====================
        function showAbilityTooltip(abilityId, slotElement) {
            const ability = ABILITIES[abilityId];
            if (!ability) return;

            const tooltip = document.getElementById('ability-tooltip');
            const nameEl = tooltip.querySelector('.tooltip-name');
            const statsEl = tooltip.querySelector('.tooltip-stats');
            const descEl = tooltip.querySelector('.tooltip-desc');

            nameEl.textContent = ability.name;

            // Build stats HTML
            let statsHtml = '';
            const skillBonuses = calculateSkillBonuses();

            if (ability.damage) {
                const bonusDamage = Math.floor(ability.damage * skillBonuses.damageBonus / 100);
                const totalDamage = ability.damage + bonusDamage;
                statsHtml += `<div class="tooltip-row"><span class="tooltip-label">Damage:</span><span class="tooltip-value damage">${totalDamage}${bonusDamage > 0 ? ` <span class="bonus">(+${bonusDamage})</span>` : ''}</span></div>`;
            }
            if (ability.healing) {
                statsHtml += `<div class="tooltip-row"><span class="tooltip-label">Healing:</span><span class="tooltip-value healing">${ability.healing}</span></div>`;
            }
            if (ability.actionCost) {
                statsHtml += `<div class="tooltip-row"><span class="tooltip-label">Action Cost:</span><span class="tooltip-value cost">${ability.actionCost}</span></div>`;
            }
            if (ability.mindCost) {
                statsHtml += `<div class="tooltip-row"><span class="tooltip-label">Mind Cost:</span><span class="tooltip-value cost">${ability.mindCost}</span></div>`;
            }
            if (ability.cooldown) {
                const cdSeconds = (ability.cooldown / 1000).toFixed(1);
                statsHtml += `<div class="tooltip-row"><span class="tooltip-label">Cooldown:</span><span class="tooltip-value">${cdSeconds}s</span></div>`;
            }
            if (ability.range) {
                statsHtml += `<div class="tooltip-row"><span class="tooltip-label">Range:</span><span class="tooltip-value">${ability.range}m</span></div>`;
            }

            // Add skill bonus info if applicable
            if (ability.type === 'ranged' && (skillBonuses.damageBonus > 0 || skillBonuses.critBonus > 0)) {
                statsHtml += `<div class="tooltip-row" style="margin-top: 8px; border-top: 1px solid #333; padding-top: 5px;"><span class="tooltip-label">Crit Chance:</span><span class="tooltip-value bonus">${(15 + skillBonuses.critBonus).toFixed(0)}%</span></div>`;
            }

            statsEl.innerHTML = statsHtml;

            // Add description based on ability type
            let desc = '';
            switch (ability.type) {
                case 'ranged': desc = 'Requires a target. Fires a blaster bolt at the enemy.'; break;
                case 'heal': desc = 'Restore your own health using the Force.'; break;
                case 'item': desc = 'Use a stim pack from your inventory.'; break;
                case 'harvest': desc = 'Gather resources from nearby nodes.'; break;
                case 'scan': desc = 'Analyze a targeted creature to reveal its stats.'; break;
            }
            descEl.textContent = desc;

            tooltip.classList.add('active');
        }

        function hideAbilityTooltip() {
            document.getElementById('ability-tooltip').classList.remove('active');
        }

        function initTooltips() {
            document.querySelectorAll('.action-slot').forEach(slot => {
                slot.addEventListener('mouseenter', () => {
                    const abilityId = slot.dataset.ability;
                    showAbilityTooltip(abilityId, slot);
                });
                slot.addEventListener('mouseleave', hideAbilityTooltip);
            });
        }

        // ==================== THREE.JS SETUP ====================
        let scene, camera, renderer, clock;
        let creatures = [];
        let resourceNodes = [];
        let structures = [];
        let npcs = [];
        const keys = { w: false, a: false, s: false, d: false, shift: false };
        let rotation = { x: 0, y: 0 };
        let interactableNear = null;
        let floatingTexts = [];
        let blasterBolts = [];

        function init() {
            // Initialize audio system
            AudioManager.init();

            // Load saved game if exists
            const savedGame = loadGame();

            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xd4a574);
            scene.fog = new THREE.Fog(0xd4a574, 50, 500);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            // Restore position if saved
            if (savedGame && savedGame.player.position) {
                camera.position.set(savedGame.player.position.x, 2, savedGame.player.position.z);
            } else {
                camera.position.set(0, 2, 0);
            }

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('game-container').appendChild(renderer.domElement);

            clock = new THREE.Clock();

            // Lighting - Tatooine twin suns
            const sun1 = new THREE.DirectionalLight(0xffffcc, 1.0);
            sun1.position.set(50, 100, 50);
            sun1.castShadow = true;
            scene.add(sun1);

            const sun2 = new THREE.DirectionalLight(0xffccaa, 0.6);
            sun2.position.set(-30, 80, -20);
            scene.add(sun2);

            const ambient = new THREE.AmbientLight(0xffd4aa, 0.4);
            scene.add(ambient);

            // Create world
            createTerrain();
            createMosEisley();
            createCantina();
            createStarport();
            createMoistureFarms();
            createKraytSkeleton();
            spawnCreatures();
            spawnResourceNodes();

            setupControls();
            setupUI();

            // Auto-save every 60 seconds
            setInterval(() => saveGame(true), 60000);

            // Save on page unload
            window.addEventListener('beforeunload', () => saveGame(true));

            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loading-screen').style.display = 'none';
                if (savedGame) {
                    addChatMessage('Welcome back to Tatooine! Your progress has been restored.', 'system');
                    addChatMessage(`Credits: ${GameState.player.credits} | Kills: ${GameState.statistics.totalKills}`, 'system');
                } else {
                    addChatMessage('Welcome to Tatooine! Use WASD to move, mouse to look.', 'system');
                    addChatMessage('Click on creatures to target them. Press 1-6 for abilities.', 'system');
                    addChatMessage('Visit Mos Eisley cantina for buffs, or hunt creatures for XP!', 'system');
                }
                updateHAMBars();
                updateCreditsDisplay();

                // Initialize daily challenges
                generateDailyChallenges();
            }, 2500);

            animate();
        }

        function createTerrain() {
            // Sand ground
            const groundGeometry = new THREE.PlaneGeometry(1000, 1000, 100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0xd4a574,
                roughness: 1,
                metalness: 0
            });

            // Add some height variation for dunes
            const positions = groundGeometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i];
                const z = positions[i + 1];
                positions[i + 2] = Math.sin(x * 0.02) * 3 + Math.cos(z * 0.02) * 3 + Math.random() * 0.5;
            }
            groundGeometry.computeVertexNormals();

            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Rock formations
            for (let i = 0; i < 30; i++) {
                const rockGeometry = new THREE.DodecahedronGeometry(3 + Math.random() * 5);
                const rockMaterial = new THREE.MeshStandardMaterial({
                    color: 0x8b7355,
                    roughness: 0.9
                });
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                rock.position.set(
                    (Math.random() - 0.5) * 800,
                    Math.random() * 3,
                    (Math.random() - 0.5) * 800
                );
                rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                rock.scale.y = 0.5 + Math.random() * 0.5;
                rock.castShadow = true;
                scene.add(rock);
            }

            // Twin suns in sky
            const sunGeometry = new THREE.SphereGeometry(20, 32, 32);
            const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff99 });
            const skybox1 = new THREE.Mesh(sunGeometry, sunMaterial);
            skybox1.position.set(200, 300, 200);
            scene.add(skybox1);

            const sun2Mesh = new THREE.Mesh(sunGeometry, new THREE.MeshBasicMaterial({ color: 0xffaa77 }));
            sun2Mesh.position.set(150, 280, 180);
            sun2Mesh.scale.set(0.7, 0.7, 0.7);
            scene.add(sun2Mesh);
        }

        function createMosEisley() {
            const cityCenter = { x: 50, z: 50 };

            // Create dome buildings typical of Mos Eisley
            for (let i = 0; i < 15; i++) {
                const angle = (i / 15) * Math.PI * 2;
                const radius = 20 + Math.random() * 30;
                const x = cityCenter.x + Math.cos(angle) * radius;
                const z = cityCenter.z + Math.sin(angle) * radius;

                createDomeBuilding(x, z, 3 + Math.random() * 4);
            }

            // Central marketplace
            const marketGeometry = new THREE.CylinderGeometry(8, 10, 3, 8);
            const marketMaterial = new THREE.MeshStandardMaterial({ color: 0xc4a46a });
            const market = new THREE.Mesh(marketGeometry, marketMaterial);
            market.position.set(cityCenter.x, 1.5, cityCenter.z);
            market.castShadow = true;
            scene.add(market);

            // Add vendors
            createVendorNPC(cityCenter.x + 5, cityCenter.z, 'weaponVendor');
            createVendorNPC(cityCenter.x - 5, cityCenter.z, 'armorVendor');
            createVendorNPC(cityCenter.x, cityCenter.z + 5, 'generalVendor');

            // Mission Terminal
            const terminalNPC = createNPCMarker(cityCenter.x, cityCenter.z - 8, 'Mission Terminal', 0xffd700);
            terminalNPC.userData = { type: 'missionTerminal', interactable: true, name: 'Mission Terminal' };
            npcs.push(terminalNPC);
        }

        function createDomeBuilding(x, z, height) {
            const group = new THREE.Group();

            // Base
            const baseGeometry = new THREE.CylinderGeometry(4, 5, height, 16);
            const baseMaterial = new THREE.MeshStandardMaterial({ color: 0xd4b896 });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = height / 2;
            base.castShadow = true;
            group.add(base);

            // Dome
            const domeGeometry = new THREE.SphereGeometry(4, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const dome = new THREE.Mesh(domeGeometry, baseMaterial);
            dome.position.y = height;
            dome.castShadow = true;
            group.add(dome);

            // Door
            const doorGeometry = new THREE.BoxGeometry(1.5, 2.5, 0.3);
            const doorMaterial = new THREE.MeshStandardMaterial({ color: 0x4a3520 });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(0, 1.25, 4.8);
            group.add(door);

            group.position.set(x, 0, z);
            scene.add(group);
            structures.push(group);
        }

        function createCantina() {
            const cantinaPos = { x: 70, z: 40 };

            // Main cantina building - larger dome
            const group = new THREE.Group();

            const baseGeometry = new THREE.CylinderGeometry(10, 12, 6, 16);
            const baseMaterial = new THREE.MeshStandardMaterial({ color: 0xc4a46a });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 3;
            base.castShadow = true;
            group.add(base);

            const domeGeometry = new THREE.SphereGeometry(10, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const dome = new THREE.Mesh(domeGeometry, baseMaterial);
            dome.position.y = 6;
            dome.castShadow = true;
            group.add(dome);

            // Cantina sign
            const signGeometry = new THREE.BoxGeometry(8, 2, 0.3);
            const signMaterial = new THREE.MeshBasicMaterial({ color: 0xff6600 });
            const sign = new THREE.Mesh(signGeometry, signMaterial);
            sign.position.set(0, 10, 10);
            group.add(sign);

            // Entrance marker
            const entranceLight = new THREE.PointLight(0xff6600, 1, 15);
            entranceLight.position.set(0, 4, 12);
            group.add(entranceLight);

            group.position.set(cantinaPos.x, 0, cantinaPos.z);
            group.userData = { type: 'cantina', name: "Chalmun's Cantina" };
            scene.add(group);
            structures.push(group);

            // Create cantina entrance hitbox
            const hitboxGeometry = new THREE.BoxGeometry(5, 5, 5);
            const hitboxMaterial = new THREE.MeshBasicMaterial({ visible: false });
            const hitbox = new THREE.Mesh(hitboxGeometry, hitboxMaterial);
            hitbox.position.set(cantinaPos.x, 2, cantinaPos.z + 12);
            hitbox.userData = { type: 'cantina', interactable: true, name: "Chalmun's Cantina" };
            scene.add(hitbox);
            npcs.push(hitbox);
        }

        function createStarport() {
            const starportPos = { x: -50, z: 30 };

            const group = new THREE.Group();

            // Main hangar
            const hangarGeometry = new THREE.BoxGeometry(40, 15, 30);
            const hangarMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });
            const hangar = new THREE.Mesh(hangarGeometry, hangarMaterial);
            hangar.position.y = 7.5;
            hangar.castShadow = true;
            group.add(hangar);

            // Control tower
            const towerGeometry = new THREE.CylinderGeometry(3, 4, 25, 8);
            const tower = new THREE.Mesh(towerGeometry, hangarMaterial);
            tower.position.set(-15, 12.5, -10);
            tower.castShadow = true;
            group.add(tower);

            // Landing pad
            const padGeometry = new THREE.CylinderGeometry(15, 15, 0.5, 32);
            const padMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
            const pad = new THREE.Mesh(padGeometry, padMaterial);
            pad.position.set(30, 0.25, 0);
            group.add(pad);

            // Parked ship (YT-1300 style)
            const shipGroup = new THREE.Group();
            const shipBody = new THREE.CylinderGeometry(8, 8, 3, 32);
            const shipMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
            const ship = new THREE.Mesh(shipBody, shipMaterial);
            ship.rotation.x = Math.PI / 2;
            shipGroup.add(ship);

            const cockpitGeometry = new THREE.SphereGeometry(2, 16, 16);
            const cockpit = new THREE.Mesh(cockpitGeometry, shipMaterial);
            cockpit.position.set(6, 0, 0);
            shipGroup.add(cockpit);

            shipGroup.position.set(30, 3, 0);
            group.add(shipGroup);

            group.position.set(starportPos.x, 0, starportPos.z);
            group.userData = { type: 'starport', name: 'Mos Eisley Starport' };
            scene.add(group);
            structures.push(group);

            // Starport shuttle service NPC
            const shuttleNPC = createNPCMarker(starportPos.x + 20, starportPos.z, 'Shuttle Pilot', 0x4444ff);
            shuttleNPC.userData = { type: 'shuttle', interactable: true, name: 'Shuttle to Other Planets' };
            npcs.push(shuttleNPC);
        }

        function createMoistureFarms() {
            const farmLocations = [
                { x: -100, z: -80 },
                { x: -150, z: -120 },
                { x: 120, z: -100 }
            ];

            farmLocations.forEach(loc => {
                const group = new THREE.Group();

                // Main homestead dome
                createDomeBuilding(0, 0, 4);

                // Moisture vaporators
                for (let i = 0; i < 6; i++) {
                    const vaporator = new THREE.Group();
                    const poleGeometry = new THREE.CylinderGeometry(0.3, 0.4, 8, 8);
                    const poleMaterial = new THREE.MeshStandardMaterial({ color: 0x666666 });
                    const pole = new THREE.Mesh(poleGeometry, poleMaterial);
                    pole.position.y = 4;
                    vaporator.add(pole);

                    const topGeometry = new THREE.CylinderGeometry(0.8, 0.5, 2, 8);
                    const top = new THREE.Mesh(topGeometry, poleMaterial);
                    top.position.y = 8;
                    vaporator.add(top);

                    const angle = (i / 6) * Math.PI * 2;
                    vaporator.position.set(Math.cos(angle) * 20, 0, Math.sin(angle) * 20);
                    group.add(vaporator);
                }

                group.position.set(loc.x, 0, loc.z);
                scene.add(group);
            });
        }

        function createKraytSkeleton() {
            const skeletonPos = { x: 200, z: -150 };

            const group = new THREE.Group();

            // Spine
            for (let i = 0; i < 20; i++) {
                const vertebra = new THREE.Mesh(
                    new THREE.SphereGeometry(2 - i * 0.08, 8, 8),
                    new THREE.MeshStandardMaterial({ color: 0xf5f5dc })
                );
                vertebra.position.set(i * 3, 1 + Math.sin(i * 0.3) * 0.5, 0);
                vertebra.scale.y = 0.6;
                group.add(vertebra);
            }

            // Skull
            const skull = new THREE.Mesh(
                new THREE.SphereGeometry(4, 8, 8),
                new THREE.MeshStandardMaterial({ color: 0xf5f5dc })
            );
            skull.position.set(-5, 2, 0);
            skull.scale.set(2, 1, 1.2);
            group.add(skull);

            // Ribs
            for (let i = 0; i < 8; i++) {
                const rib = new THREE.Mesh(
                    new THREE.TorusGeometry(3, 0.3, 8, 16, Math.PI),
                    new THREE.MeshStandardMaterial({ color: 0xf5f5dc })
                );
                rib.position.set(i * 4 + 10, 2, 0);
                rib.rotation.y = Math.PI / 2;
                rib.rotation.x = Math.PI / 6;
                group.add(rib);

                const rib2 = rib.clone();
                rib2.rotation.x = -Math.PI / 6;
                rib2.scale.x = -1;
                group.add(rib2);
            }

            group.position.set(skeletonPos.x, 0, skeletonPos.z);
            scene.add(group);

            // Krayt dragon spawn point (rare boss)
            setTimeout(() => {
                if (Math.random() < 0.3) {
                    spawnCreature('krayt', skeletonPos.x - 30, skeletonPos.z);
                    addChatMessage('You sense a powerful presence nearby...', 'system');
                }
            }, 60000);
        }

        function createVendorNPC(x, z, vendorType) {
            const npc = createNPCMarker(x, z, VENDORS[vendorType].name, 0x00ff00);
            npc.userData = { type: 'vendor', vendorType: vendorType, interactable: true, name: VENDORS[vendorType].name };
            npcs.push(npc);
        }

        function createNPCMarker(x, z, name, color) {
            const group = new THREE.Group();

            // CapsuleGeometry is not available in r128, use CylinderGeometry instead
            const bodyGeometry = new THREE.CylinderGeometry(0.4, 0.4, 1.2, 8);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: color });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1.2;
            group.add(body);

            const headGeometry = new THREE.SphereGeometry(0.35, 8, 8);
            const head = new THREE.Mesh(headGeometry, bodyMaterial);
            head.position.y = 2.1;
            group.add(head);

            // Floating name indicator
            const indicatorGeometry = new THREE.RingGeometry(0.5, 0.7, 32);
            const indicatorMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
            const indicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial);
            indicator.position.y = 3;
            indicator.rotation.x = -Math.PI / 2;
            group.add(indicator);

            group.position.set(x, 0, z);
            group.userData.name = name;
            scene.add(group);
            return group;
        }

        function spawnCreatures() {
            // Womp rats near city
            for (let i = 0; i < 20; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = 80 + Math.random() * 100;
                spawnCreature('womprat', Math.cos(angle) * distance, Math.sin(angle) * distance);
            }

            // Dewbacks in desert
            for (let i = 0; i < 10; i++) {
                spawnCreature('dewback', (Math.random() - 0.5) * 400, (Math.random() - 0.5) * 400 - 100);
            }

            // Banthas in herds
            for (let i = 0; i < 3; i++) {
                const herdX = (Math.random() - 0.5) * 300;
                const herdZ = (Math.random() - 0.5) * 300 - 150;
                for (let j = 0; j < 4; j++) {
                    spawnCreature('bantha', herdX + (Math.random() - 0.5) * 30, herdZ + (Math.random() - 0.5) * 30);
                }
            }

            // Tusken raiders in canyon areas
            for (let i = 0; i < 8; i++) {
                spawnCreature('tusken', 150 + (Math.random() - 0.5) * 100, -200 + (Math.random() - 0.5) * 100);
            }

            // Jawas near moisture farms
            for (let i = 0; i < 5; i++) {
                spawnCreature('jawa', -120 + (Math.random() - 0.5) * 50, -100 + (Math.random() - 0.5) * 50);
            }

            // Rontos
            for (let i = 0; i < 6; i++) {
                spawnCreature('rontoHerd', (Math.random() - 0.5) * 300, (Math.random() - 0.5) * 300);
            }

            // Sand Panthers in far desert (L15)
            for (let i = 0; i < 5; i++) {
                spawnCreature('sandPanther', 250 + (Math.random() - 0.5) * 80, -280 + (Math.random() - 0.5) * 80);
            }

            // Squills in rocky areas (L20)
            for (let i = 0; i < 4; i++) {
                spawnCreature('squill', -220 + (Math.random() - 0.5) * 60, -320 + (Math.random() - 0.5) * 60);
            }

            // Tusken Chieftain camp (L25) - elite tuskens
            for (let i = 0; i < 3; i++) {
                spawnCreature('tuskenChieftain', 200 + (Math.random() - 0.5) * 40, -350 + (Math.random() - 0.5) * 40);
            }

            // Canyon Wraiths near Krayt skeleton (L35)
            for (let i = 0; i < 3; i++) {
                spawnCreature('canyonWraith', -280 + (Math.random() - 0.5) * 50, 200 + (Math.random() - 0.5) * 50);
            }
        }

        function spawnCreature(type, x, z) {
            const creatureData = CREATURE_TYPES[type];
            const group = new THREE.Group();

            let bodySize = 0.5;
            let bodyColor = 0x8b4513;

            switch(type) {
                case 'womprat':
                    bodySize = 0.3;
                    bodyColor = 0x8b7355;
                    break;
                case 'dewback':
                    bodySize = 1.2;
                    bodyColor = 0x556b2f;
                    break;
                case 'bantha':
                    bodySize = 2;
                    bodyColor = 0x8b4513;
                    break;
                case 'tusken':
                    bodySize = 0.5;
                    bodyColor = 0x8b8378;
                    break;
                case 'krayt':
                    bodySize = 5;
                    bodyColor = 0x4a4a4a;
                    break;
                case 'jawa':
                    bodySize = 0.3;
                    bodyColor = 0x4a3520;
                    break;
                case 'rontoHerd':
                    bodySize = 1.5;
                    bodyColor = 0x8b7355;
                    break;
                case 'sandPanther':
                    bodySize = 0.8;
                    bodyColor = 0xc9a66b; // Sandy tan color
                    break;
                case 'squill':
                    bodySize = 1.0;
                    bodyColor = 0x5c4033; // Dark brown
                    break;
                case 'tuskenChieftain':
                    bodySize = 0.7;
                    bodyColor = 0x6b5b4f; // Darker tusken
                    break;
                case 'canyonWraith':
                    bodySize = 1.8;
                    bodyColor = 0x383838; // Ghostly dark gray
                    break;
            }

            // Simple creature mesh
            const bodyGeometry = new THREE.SphereGeometry(bodySize, 8, 8);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: bodyColor });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = bodySize;
            body.scale.set(1.5, 1, 1);
            body.castShadow = true;
            group.add(body);

            // Head
            const headGeometry = new THREE.SphereGeometry(bodySize * 0.5, 8, 8);
            const head = new THREE.Mesh(headGeometry, bodyMaterial);
            head.position.set(bodySize * 1.2, bodySize * 1.2, 0);
            group.add(head);

            // Health bar (hidden until targeted)
            const healthBarBg = new THREE.Mesh(
                new THREE.PlaneGeometry(2, 0.2),
                new THREE.MeshBasicMaterial({ color: 0x333333, side: THREE.DoubleSide })
            );
            healthBarBg.position.y = bodySize * 2.5;
            healthBarBg.visible = false;
            group.add(healthBarBg);

            const healthBarFill = new THREE.Mesh(
                new THREE.PlaneGeometry(2, 0.2),
                new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide })
            );
            healthBarFill.position.y = bodySize * 2.5;
            healthBarFill.position.z = 0.01;
            healthBarFill.visible = false;
            group.add(healthBarFill);

            group.position.set(x, 0, z);
            group.userData = {
                type: 'creature',
                creatureType: type,
                ...creatureData,
                currentHealth: creatureData.health,
                maxHealth: creatureData.health,
                targetable: true,
                healthBarBg: healthBarBg,
                healthBarFill: healthBarFill,
                wanderTarget: null,
                lastWander: 0,
                inCombat: false,
                combatTarget: null
            };

            scene.add(group);
            creatures.push(group);
            return group;
        }

        function spawnResourceNodes() {
            const resourceTypes = [
                { type: 'iron', color: 0x555555, icon: 'ÔøΩite' },
                { type: 'copper', color: 0xb87333, icon: 'üü§' },
                { type: 'chemicals', color: 0x00ff00, icon: 'üß™' },
                { type: 'flora', color: 0x228b22, icon: 'üåø' }
            ];

            for (let i = 0; i < 40; i++) {
                const resType = resourceTypes[Math.floor(Math.random() * resourceTypes.length)];
                const x = (Math.random() - 0.5) * 600;
                const z = (Math.random() - 0.5) * 600;

                const node = new THREE.Group();

                if (resType.type === 'iron' || resType.type === 'copper') {
                    const rockGeometry = new THREE.DodecahedronGeometry(1);
                    const rockMaterial = new THREE.MeshStandardMaterial({ color: resType.color });
                    const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                    rock.position.y = 0.5;
                    node.add(rock);
                } else {
                    const plantGeometry = new THREE.ConeGeometry(0.5, 1.5, 8);
                    const plantMaterial = new THREE.MeshStandardMaterial({ color: resType.color });
                    const plant = new THREE.Mesh(plantGeometry, plantMaterial);
                    plant.position.y = 0.75;
                    node.add(plant);
                }

                // Glow indicator
                const glowGeometry = new THREE.RingGeometry(0.8, 1, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({ color: resType.color, side: THREE.DoubleSide, transparent: true, opacity: 0.5 });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.rotation.x = -Math.PI / 2;
                glow.position.y = 0.05;
                node.add(glow);

                node.position.set(x, 0, z);
                node.userData = {
                    type: 'resource',
                    resourceType: resType.type,
                    amount: 5 + Math.floor(Math.random() * 10),
                    interactable: true
                };

                scene.add(node);
                resourceNodes.push(node);
            }
        }

        // ==================== CONTROLS ====================
        function setupControls() {
            document.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                if (key in keys) keys[key] = true;
                if (key === 'shift') keys.shift = true;

                // Ability hotkeys
                if (e.key >= '1' && e.key <= '6') {
                    e.preventDefault();
                    useAbility(parseInt(e.key));
                }

                // UI hotkeys
                if (key === 'k') toggleSkillsWindow();
                if (key === 'i') toggleInventoryWindow();
                if (key === 'j') toggleAchievementsWindow();
                if (key === 'h') toggleHelpOverlay();
                if (key === 'e') interactWithNearby();
                if (key === 'escape') closeAllWindows();
                if (key === 'tab') {
                    e.preventDefault();
                    cycleTarget();
                }
                if (key === 'f5') {
                    e.preventDefault();
                    saveGame();
                }
            });

            // Resume audio on first interaction (browser autoplay policy)
            document.addEventListener('click', () => AudioManager.resume(), { once: true });

            document.addEventListener('keyup', (e) => {
                const key = e.key.toLowerCase();
                if (key in keys) keys[key] = false;
                if (key === 'shift') keys.shift = false;
            });

            renderer.domElement.addEventListener('click', () => {
                if (!GameState.isPointerLocked) {
                    renderer.domElement.requestPointerLock();
                } else {
                    // Click to target
                    const raycaster = new THREE.Raycaster();
                    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

                    const creatureHits = raycaster.intersectObjects(creatures, true);
                    if (creatureHits.length > 0) {
                        let targetGroup = creatureHits[0].object;
                        while (targetGroup.parent && !targetGroup.userData.type) {
                            targetGroup = targetGroup.parent;
                        }
                        if (targetGroup.userData.targetable) {
                            setTarget(targetGroup);
                        }
                    }
                }
            });

            document.addEventListener('pointerlockchange', () => {
                GameState.isPointerLocked = document.pointerLockElement === renderer.domElement;
            });

            document.addEventListener('mousemove', (e) => {
                if (GameState.isPointerLocked) {
                    rotation.y -= e.movementX * 0.002;
                    rotation.x -= e.movementY * 0.002;
                    rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotation.x));
                }
            });

            // UI button events
            document.getElementById('skills-button').addEventListener('click', toggleSkillsWindow);
            document.getElementById('inventory-button').addEventListener('click', toggleInventoryWindow);
            document.getElementById('achievements-button').addEventListener('click', toggleAchievementsWindow);

            // Action bar clicks
            document.querySelectorAll('.action-slot').forEach(slot => {
                slot.addEventListener('click', () => {
                    const slotNum = parseInt(slot.dataset.slot);
                    useAbility(slotNum);
                });
            });

            // Initialize ability tooltips
            initTooltips();

            // Mobile Controls
            setupMobileControls();
        }

        function setupMobileControls() {
            const joystickZone = document.getElementById('joystick-zone');
            const joystickKnob = document.getElementById('joystick-knob');
            const jumpButton = document.getElementById('jump-button');
            const cameraZone = document.getElementById('camera-zone');
            
            let joystickActive = false;
            let joystickOrigin = { x: 0, y: 0 };
            let joystickCurrent = { x: 0, y: 0 };
            
            // Joystick Logic
            joystickZone.addEventListener('touchstart', (e) => {
                e.preventDefault();
                joystickActive = true;
                const touch = e.touches[0];
                const rect = joystickZone.getBoundingClientRect();
                joystickOrigin = { 
                    x: rect.left + rect.width / 2, 
                    y: rect.top + rect.height / 2 
                };
                updateJoystick(touch.clientX, touch.clientY);
            });
            
            joystickZone.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (joystickActive) {
                    const touch = e.touches[0];
                    updateJoystick(touch.clientX, touch.clientY);
                }
            });
            
            joystickZone.addEventListener('touchend', (e) => {
                e.preventDefault();
                joystickActive = false;
                joystickKnob.style.transform = `translate(-50%, -50%)`;
                keys.w = false;
                keys.s = false;
                keys.a = false;
                keys.d = false;
            });
            
            function updateJoystick(x, y) {
                const maxDist = 50;
                let dx = x - joystickOrigin.x;
                let dy = y - joystickOrigin.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist > maxDist) {
                    const angle = Math.atan2(dy, dx);
                    dx = Math.cos(angle) * maxDist;
                    dy = Math.sin(angle) * maxDist;
                }
                
                joystickKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                
                // Map to WASD
                const threshold = 10;
                keys.w = dy < -threshold;
                keys.s = dy > threshold;
                keys.a = dx < -threshold;
                keys.d = dx > threshold;
            }
            
            // Jump Button
            jumpButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (GameState.player.onGround) {
                    velocity.y = 15;
                    GameState.player.onGround = false;
                }
            });
            
            // Camera Touch Control
            let lastTouchX = 0;
            let lastTouchY = 0;
            
            cameraZone.addEventListener('touchstart', (e) => {
                lastTouchX = e.touches[0].clientX;
                lastTouchY = e.touches[0].clientY;
            });
            
            cameraZone.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const dx = touch.clientX - lastTouchX;
                const dy = touch.clientY - lastTouchY;
                
                rotation.y -= dx * 0.005;
                rotation.x -= dy * 0.005;
                rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotation.x));
                
                lastTouchX = touch.clientX;
                lastTouchY = touch.clientY;
            });
        }

        function setupUI() {
            updateHAMBars();
            updateCreditsDisplay();
            renderInventory();
        }

        // ==================== TARGETING ====================
        function setTarget(creature) {
            // Clear previous target
            if (GameState.target) {
                GameState.target.userData.healthBarBg.visible = false;
                GameState.target.userData.healthBarFill.visible = false;
            }

            GameState.target = creature;
            creature.userData.healthBarBg.visible = true;
            creature.userData.healthBarFill.visible = true;

            updateTargetFrame();
            document.getElementById('target-frame').classList.add('active');

            addChatMessage(`Target: ${creature.userData.name} (Level ${creature.userData.level})`, 'system');
        }

        function clearTarget() {
            if (GameState.target) {
                GameState.target.userData.healthBarBg.visible = false;
                GameState.target.userData.healthBarFill.visible = false;
            }
            GameState.target = null;
            document.getElementById('target-frame').classList.remove('active');
        }

        function cycleTarget() {
            const nearbyCreatures = creatures.filter(c => {
                const dist = camera.position.distanceTo(c.position);
                return dist < 50 && c.userData.currentHealth > 0;
            }).sort((a, b) => camera.position.distanceTo(a.position) - camera.position.distanceTo(b.position));

            if (nearbyCreatures.length === 0) return;

            const currentIndex = GameState.target ? nearbyCreatures.indexOf(GameState.target) : -1;
            const nextIndex = (currentIndex + 1) % nearbyCreatures.length;
            setTarget(nearbyCreatures[nextIndex]);
        }

        function updateTargetFrame() {
            if (!GameState.target) return;

            const target = GameState.target;
            document.getElementById('target-name').textContent = `${target.userData.icon} ${target.userData.name}`;
            document.getElementById('target-level').textContent = `Level ${target.userData.level}`;

            const healthPercent = (target.userData.currentHealth / target.userData.maxHealth) * 100;
            document.getElementById('target-health-fill').style.width = `${healthPercent}%`;

            // Update 3D health bar
            target.userData.healthBarFill.scale.x = healthPercent / 100;
            target.userData.healthBarFill.position.x = -(1 - healthPercent / 100);
        }

        // ==================== ABILITIES ====================
        function useAbility(slotNum) {
            const slot = document.querySelector(`.action-slot[data-slot="${slotNum}"]`);
            if (!slot) return;

            const abilityId = slot.dataset.ability;
            const ability = ABILITIES[abilityId];
            if (!ability) return;

            // Check cooldown
            if (GameState.cooldowns[abilityId] && Date.now() < GameState.cooldowns[abilityId]) {
                addChatMessage(`${ability.name} is on cooldown!`, 'combat');
                return;
            }

            // Check resources
            if (ability.actionCost && GameState.player.action < ability.actionCost) {
                addChatMessage('Not enough action!', 'combat');
                return;
            }
            if (ability.mindCost && GameState.player.mind < ability.mindCost) {
                addChatMessage('Not enough mind!', 'combat');
                return;
            }

            // Execute ability
            switch (ability.type) {
                case 'ranged':
                    if (!GameState.target) {
                        addChatMessage('No target selected!', 'combat');
                        return;
                    }
                    const dist = camera.position.distanceTo(GameState.target.position);
                    if (dist > ability.range) {
                        addChatMessage('Target out of range!', 'combat');
                        return;
                    }
                    dealDamage(GameState.target, ability.damage);
                    GameState.player.action -= ability.actionCost;
                    gainSkillXP('marksman', 20);
                    break;

                case 'heal':
                    const healAmount = Math.min(ability.healing, GameState.player.maxHealth - GameState.player.health);
                    GameState.player.health += healAmount;
                    GameState.player.mind -= ability.mindCost;
                    addChatMessage(`You heal for ${healAmount} health.`, 'combat');
                    gainSkillXP('medic', 30);
                    // Floating heal text
                    const healPos = camera.position.clone();
                    healPos.y += 0.5;
                    createFloatingText(`+${healAmount}`, healPos, 'healing');
                    break;

                case 'harvest':
                    harvestNearbyResource();
                    break;

                case 'scan':
                    scanCreature();
                    break;

                case 'lightsaber':
                    if (!GameState.target) {
                        addChatMessage('No target selected!', 'combat');
                        return;
                    }
                    const saberDist = camera.position.distanceTo(GameState.target.position);
                    if (saberDist > ability.range) {
                        addChatMessage('Target out of range!', 'combat');
                        return;
                    }
                    dealDamage(GameState.target, ability.damage);
                    GameState.player.action -= ability.actionCost;
                    gainSkillXP('jedi', 50);
                    // Lightsaber sound
                    // AudioManager.playLightsaberSwing(); // Assuming this exists or I should add it
                    break;

                case 'force':
                    if (!GameState.target) {
                        addChatMessage('No target selected!', 'combat');
                        return;
                    }
                    const forceDist = camera.position.distanceTo(GameState.target.position);
                    if (forceDist > ability.range) {
                        addChatMessage('Target out of range!', 'combat');
                        return;
                    }
                    dealDamage(GameState.target, ability.damage);
                    GameState.player.mind -= ability.mindCost;
                    gainSkillXP('jedi', 40);
                    // Force push effect
                    const pushDir = new THREE.Vector3().subVectors(GameState.target.position, camera.position).normalize();
                    GameState.target.position.add(pushDir.multiplyScalar(5));
                    addChatMessage(`You used ${ability.name}!`, 'combat');
                    break;

                case 'item':
                    if (ability.requires === 'stimpak') {
                        const hasStimpak = GameState.inventory.find(i => i.type === 'stimpak');
                        if (!hasStimpak) {
                            addChatMessage('No stim packs in inventory!', 'system');
                            return;
                        }
                        GameState.inventory = GameState.inventory.filter(i => i !== hasStimpak);
                        const stimHeal = Math.min(ability.healing, GameState.player.maxHealth - GameState.player.health);
                        GameState.player.health = Math.min(GameState.player.maxHealth, GameState.player.health + ability.healing);
                        addChatMessage(`Used stim pack. Healed for ${ability.healing}.`, 'combat');
                        // Floating heal text
                        const stimPos = camera.position.clone();
                        stimPos.y += 0.5;
                        createFloatingText(`+${stimHeal}`, stimPos, 'healing');
                        renderInventory();
                    }
                    break;
            }

            // Set cooldown
            GameState.cooldowns[abilityId] = Date.now() + ability.cooldown;
            startCooldownAnimation(slot, ability.cooldown);

            // Track ability uses for daily challenges
            GameState.abilityUsesThisSession = (GameState.abilityUsesThisSession || 0) + 1;

            updateHAMBars();
        }

        function useItem(index) {
            const item = GameState.inventory[index];
            if (!item) return;

            if (item.type === 'consumable') {
                if (item.healing) {
                    const healAmount = Math.min(item.healing, GameState.player.maxHealth - GameState.player.health);
                    GameState.player.health += healAmount;
                    addChatMessage(`Used ${item.name}. Healed for ${healAmount}.`, 'combat');
                    createFloatingText(`+${healAmount}`, camera.position.clone().add(new THREE.Vector3(0, 0.5, 0)), 'healing');
                }
                // Remove one item
                GameState.inventory.splice(index, 1);
                renderInventory();
                updateHAMBars();
            } else if (item.type === 'holocron') {
                if (GameState.skills.jedi.novice) {
                    addChatMessage('You have already unlocked the secrets of the Jedi.', 'system');
                } else {
                    GameState.skills.jedi.novice = true;
                    addChatMessage('You feel a surge of Force energy... You have unlocked the Jedi profession!', 'xp');
                    addChatMessage('New abilities available!', 'system');
                    
                    // Auto-equip basic lightsaber if not present
                    if (!GameState.inventory.find(i => i.name === 'Training Lightsaber')) {
                        GameState.inventory.push({ type: 'weapon', name: 'Training Lightsaber', damage: 40, price: 0 });
                        addChatMessage('You received a Training Lightsaber.', 'loot');
                    }
                    
                    // Add abilities to empty slots
                    assignAbilityToSlot(7, 'lightsaberStrike');
                    assignAbilityToSlot(8, 'forcePush');
                    
                    // Show Jedi tab
                    showProfession('jedi');
                    toggleSkillsWindow();
                }
                // Remove holocron
                GameState.inventory.splice(index, 1);
                renderInventory();
            }
        }

        function assignAbilityToSlot(slotNum, abilityId) {
            // Simple helper to add ability if slot exists or create it
            // For now, we just assume user will drag/drop or we auto-assign to 1-6 if empty
            // But since UI is hardcoded 1-6, we might need to replace existing ones or add more slots
            // Let's just replace slot 1 and 2 for now if they are basic
            if (slotNum === 7) {
                const slot = document.querySelector('.action-slot[data-slot="1"]');
                slot.dataset.ability = abilityId;
                slot.querySelector('.ability-name').textContent = ABILITIES[abilityId].name;
                slot.innerHTML = slot.innerHTML.replace('üî´', '‚öîÔ∏è'); // Replace icon
            }
            if (slotNum === 8) {
                const slot = document.querySelector('.action-slot[data-slot="2"]');
                slot.dataset.ability = abilityId;
                slot.querySelector('.ability-name').textContent = ABILITIES[abilityId].name;
                slot.innerHTML = slot.innerHTML.replace('üí•', '‚úã'); // Replace icon
            }
        }

        function startCooldownAnimation(slot, duration) {
            const overlay = slot.querySelector('.cooldown-overlay');
            slot.classList.add('on-cooldown');
            overlay.style.height = '100%';

            const startTime = Date.now();
            const animate = () => {
                const elapsed = Date.now() - startTime;
                const remaining = 1 - (elapsed / duration);
                if (remaining <= 0) {
                    overlay.style.height = '0%';
                    slot.classList.remove('on-cooldown');
                } else {
                    overlay.style.height = `${remaining * 100}%`;
                    requestAnimationFrame(animate);
                }
            };
            requestAnimationFrame(animate);
        }

        // ==================== COMBAT FEEDBACK SYSTEM ====================
        function createFloatingText(text, worldPosition, type, isCritical = false) {
            // Convert 3D position to screen coordinates
            const screenPos = worldPosition.clone().project(camera);
            const x = (screenPos.x + 1) / 2 * window.innerWidth;
            const y = (-screenPos.y + 1) / 2 * window.innerHeight;

            // Don't show if behind camera
            if (screenPos.z > 1) return;

            // Create floating text element
            const floatEl = document.createElement('div');
            floatEl.className = `floating-text ${type}${isCritical ? ' critical' : ''}`;
            floatEl.textContent = text;
            floatEl.style.left = `${x}px`;
            floatEl.style.top = `${y}px`;
            floatEl.style.transform = 'translate(-50%, -50%)';
            document.body.appendChild(floatEl);

            // Track for cleanup
            const floatData = {
                element: floatEl,
                startTime: Date.now(),
                duration: 1500
            };
            floatingTexts.push(floatData);

            // Auto-remove after animation
            setTimeout(() => {
                if (floatEl.parentNode) {
                    floatEl.parentNode.removeChild(floatEl);
                }
                floatingTexts = floatingTexts.filter(f => f !== floatData);
            }, 1500);
        }

        function triggerScreenShake(intensity = 1) {
            const container = document.getElementById('game-container');
            container.classList.remove('screen-shake');
            void container.offsetWidth; // Force reflow
            container.style.setProperty('--shake-intensity', intensity);
            container.classList.add('screen-shake');
            setTimeout(() => container.classList.remove('screen-shake'), 300);
        }

        function triggerHitFlash() {
            const flash = document.getElementById('hit-flash');
            flash.classList.remove('active');
            void flash.offsetWidth; // Force reflow
            flash.classList.add('active');
            setTimeout(() => flash.classList.remove('active'), 400);
        }

        function createBlasterBolt(startPos, endPos, color = '#ff0000') {
            // Convert 3D positions to screen coordinates
            const startScreen = startPos.clone().project(camera);
            const endScreen = endPos.clone().project(camera);

            if (startScreen.z > 1 || endScreen.z > 1) return;

            const x1 = (startScreen.x + 1) / 2 * window.innerWidth;
            const y1 = (-startScreen.y + 1) / 2 * window.innerHeight;
            const x2 = (endScreen.x + 1) / 2 * window.innerWidth;
            const y2 = (-endScreen.y + 1) / 2 * window.innerHeight;

            // Calculate angle
            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
            const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);

            const bolt = document.createElement('div');
            bolt.className = 'blaster-bolt';
            bolt.style.cssText = `
                left: ${x1}px;
                top: ${y1}px;
                width: ${Math.min(distance, 60)}px;
                color: ${color};
                background: ${color};
                transform: rotate(${angle}deg);
                transform-origin: left center;
            `;
            document.body.appendChild(bolt);

            // Animate bolt traveling
            const startTime = Date.now();
            const animateBolt = () => {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / 150; // 150ms travel time

                if (progress >= 1) {
                    if (bolt.parentNode) bolt.parentNode.removeChild(bolt);
                    return;
                }

                const currentX = x1 + (x2 - x1) * progress;
                const currentY = y1 + (y2 - y1) * progress;
                bolt.style.left = `${currentX}px`;
                bolt.style.top = `${currentY}px`;
                bolt.style.opacity = 1 - progress * 0.5;

                requestAnimationFrame(animateBolt);
            };
            requestAnimationFrame(animateBolt);
        }

        // ==================== MUZZLE FLASH & IMPACT SPARKS ====================
        function createMuzzleFlash() {
            const flash = document.createElement('div');
            flash.className = 'muzzle-flash';
            document.body.appendChild(flash);
            setTimeout(() => flash.remove(), 100);
        }

        function createImpactSparks(worldPos, sparkCount = 5) {
            // Project 3D position to screen
            const pos = worldPos.clone();
            pos.project(camera);
            const x = (pos.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-pos.y * 0.5 + 0.5) * window.innerHeight;

            for (let i = 0; i < sparkCount; i++) {
                const spark = document.createElement('div');
                spark.className = 'impact-spark';
                spark.style.left = `${x}px`;
                spark.style.top = `${y}px`;
                document.body.appendChild(spark);

                // Random direction for each spark
                const angle = (Math.PI * 2 * i) / sparkCount + Math.random() * 0.5;
                const speed = 50 + Math.random() * 80;
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed - 30; // Upward bias

                let startTime = null;
                const duration = 300 + Math.random() * 200;

                const animateSpark = (timestamp) => {
                    if (!startTime) startTime = timestamp;
                    const progress = (timestamp - startTime) / duration;

                    if (progress < 1) {
                        const gravity = 150 * progress * progress;
                        spark.style.left = `${x + vx * progress}px`;
                        spark.style.top = `${y + vy * progress + gravity}px`;
                        spark.style.opacity = 1 - progress;
                        requestAnimationFrame(animateSpark);
                    } else {
                        spark.remove();
                    }
                };
                requestAnimationFrame(animateSpark);
            }
        }

        // ==================== HELP OVERLAY ====================
        function toggleHelpOverlay() {
            document.getElementById('help-overlay').classList.toggle('active');
        }

        function closeHelpOverlay() {
            document.getElementById('help-overlay').classList.remove('active');
        }

        // ==================== EQUIPMENT SYSTEM ====================
        function equipItem(inventoryIndex) {
            const item = GameState.inventory[inventoryIndex];
            if (!item) return;

            if (item.type === 'weapon') {
                // Unequip current weapon first
                if (GameState.equipment.weapon) {
                    GameState.inventory.push(GameState.equipment.weapon);
                }
                GameState.equipment.weapon = item;
                GameState.inventory.splice(inventoryIndex, 1);
                addChatMessage(`Equipped ${item.name} (+${item.damage} damage)`, 'system');
                AudioManager.playUIClick();
            } else if (item.type === 'armor') {
                // Unequip current armor first
                if (GameState.equipment.armor) {
                    GameState.inventory.push(GameState.equipment.armor);
                }
                GameState.equipment.armor = item;
                GameState.inventory.splice(inventoryIndex, 1);
                addChatMessage(`Equipped ${item.name} (+${item.defense} defense)`, 'system');
                AudioManager.playUIClick();
            }
            renderInventory();
        }

        function unequipItem(slot) {
            if (slot === 'weapon' && GameState.equipment.weapon) {
                GameState.inventory.push(GameState.equipment.weapon);
                addChatMessage(`Unequipped ${GameState.equipment.weapon.name}`, 'system');
                GameState.equipment.weapon = null;
                AudioManager.playUIClick();
            } else if (slot === 'armor' && GameState.equipment.armor) {
                GameState.inventory.push(GameState.equipment.armor);
                addChatMessage(`Unequipped ${GameState.equipment.armor.name}`, 'system');
                GameState.equipment.armor = null;
                AudioManager.playUIClick();
            }
            renderInventory();
        }

        function updateEquipmentSlots() {
            const weaponSlot = document.getElementById('weapon-slot');
            const armorSlot = document.getElementById('armor-slot');
            const weaponIcon = document.getElementById('weapon-slot-icon');
            const armorIcon = document.getElementById('armor-slot-icon');
            const statsDisplay = document.getElementById('equipment-stats');

            if (GameState.equipment.weapon) {
                weaponSlot.classList.add('has-item');
                weaponIcon.textContent = 'üî´';
                weaponSlot.title = `${GameState.equipment.weapon.name} (Click to unequip)`;
            } else {
                weaponSlot.classList.remove('has-item');
                weaponIcon.textContent = '-';
                weaponSlot.title = 'Weapon Slot';
            }

            if (GameState.equipment.armor) {
                armorSlot.classList.add('has-item');
                armorIcon.textContent = 'üõ°Ô∏è';
                armorSlot.title = `${GameState.equipment.armor.name} (Click to unequip)`;
            } else {
                armorSlot.classList.remove('has-item');
                armorIcon.textContent = '-';
                armorSlot.title = 'Armor Slot';
            }

            // Show total equipment stats
            const totalDamage = GameState.equipment.weapon ? GameState.equipment.weapon.damage : 0;
            const totalDefense = GameState.equipment.armor ? GameState.equipment.armor.defense : 0;
            statsDisplay.innerHTML = totalDamage || totalDefense ?
                `+${totalDamage} DMG | +${totalDefense} DEF` : '';
        }

        function dealDamage(target, baseDamage) {
            // Calculate damage with skill bonuses and equipped weapon
            const skillBonuses = calculateSkillBonuses();
            const weaponDamage = GameState.equipment.weapon ? GameState.equipment.weapon.damage : 0;
            const totalBaseDamage = baseDamage + weaponDamage;
            const critChance = 0.15 + (skillBonuses.critBonus / 100);
            const isCritical = Math.random() < critChance;
            const sicknessMultiplier = getCloningSicknessMultiplier('damage');
            let damage = Math.floor(totalBaseDamage * (1 + skillBonuses.damageBonus / 100) * (0.8 + Math.random() * 0.4) * sicknessMultiplier);
            if (isCritical) {
                damage = Math.floor(damage * 1.5);
                GameState.statistics.criticalHits++;
            }
            target.userData.currentHealth -= damage;

            addChatMessage(`You hit ${target.userData.name} for ${damage} damage!${isCritical ? ' CRITICAL!' : ''}`, 'combat');

            // Play audio
            if (isCritical) {
                AudioManager.playCritical();
            } else {
                AudioManager.playBlasterShot();
            }

            // Muzzle flash effect
            createMuzzleFlash();

            // Floating damage number
            const targetPos = target.position.clone();
            targetPos.y += 2; // Above creature
            createFloatingText(isCritical ? `${damage}!` : damage.toString(), targetPos, 'damage-dealt', isCritical);

            // Blaster bolt effect from player to target
            const playerPos = camera.position.clone();
            playerPos.y -= 0.3; // Slightly below eye level
            createBlasterBolt(playerPos, target.position.clone(), '#ff0000');

            // Impact sparks at target after bolt arrives (150ms travel time)
            const impactPos = target.position.clone();
            setTimeout(() => createImpactSparks(impactPos, isCritical ? 8 : 5), 150);

            // Aggro the creature
            target.userData.inCombat = true;
            target.userData.combatTarget = camera;
            GameState.inCombat = true;

            // Trigger pack aggro for pack-type creatures
            triggerPackAggro(target);

            if (target.userData.currentHealth <= 0) {
                killCreature(target);
            } else {
                updateTargetFrame();
            }
        }

        function killCreature(creature) {
            addChatMessage(`You have defeated ${creature.userData.name}!`, 'combat');

            // Play death sound and loot jingle
            AudioManager.playEnemyDeath();
            setTimeout(() => AudioManager.playLootJingle(), 200);

            // Track statistics
            GameState.statistics.totalKills++;
            const creatureType = creature.userData.creatureType;
            GameState.statistics.creaturesKilled[creatureType] = (GameState.statistics.creaturesKilled[creatureType] || 0) + 1;

            // Store creature position before removal for floating text
            const creaturePos = creature.position.clone();
            creaturePos.y += 2;

            // Grant XP (reduced by cloning sickness)
            const xpGain = creature.userData.xp;
            const xpBonus = getBuffValue('xpBonus');
            const sicknessXpMultiplier = getCloningSicknessMultiplier('xp');
            const totalXP = Math.floor(xpGain * (1 + xpBonus / 100) * sicknessXpMultiplier);
            GameState.statistics.totalXPEarned += totalXP;
            gainSkillXP('marksman', totalXP);
            const sicknessText = sicknessXpMultiplier < 1 ? ' (reduced by Cloning Sickness)' : '';
            addChatMessage(`You gained ${totalXP} combat experience.${sicknessText}`, 'xp');

            // Floating XP text
            createFloatingText(`+${totalXP} XP`, creaturePos, 'xp-gain');

            // Loot
            const loot = creature.userData.loot;
            loot.forEach(item => {
                if (Math.random() < 0.7) {
                    if (item === 'credits') {
                        const credits = creature.userData.credits[0] + Math.floor(Math.random() * (creature.userData.credits[1] - creature.userData.credits[0]));
                        GameState.player.credits += credits;
                        addChatMessage(`Looted ${credits} credits.`, 'loot');
                    } else if (GameState.resources[item] !== undefined) {
                        const amount = 1 + Math.floor(Math.random() * 3);
                        GameState.resources[item] += amount;
                        addChatMessage(`Looted ${amount} ${item}.`, 'loot');
                    } else if (item === 'kraytPearl') {
                        GameState.inventory.push({ type: 'kraytPearl', name: 'Krayt Dragon Pearl', value: 10000 });
                        addChatMessage('RARE LOOT: Krayt Dragon Pearl!', 'loot');
                    }
                }
            });

            // Credit drop
            const credits = creature.userData.credits[0] + Math.floor(Math.random() * (creature.userData.credits[1] - creature.userData.credits[0]));
            GameState.player.credits += credits;
            addChatMessage(`Looted ${credits} credits.`, 'loot');

            // Floating credits text (slightly delayed)
            setTimeout(() => {
                const creditPos = creaturePos.clone();
                creditPos.y += 0.5;
                createFloatingText(`+${credits}c`, creditPos, 'credits');
            }, 200);

            // Track mission kills
            onCreatureKill(creature.userData.creatureType);

            // Check for new achievements
            checkAchievements();

            updateCreditsDisplay();
            renderInventory();

            // Clear target
            if (GameState.target === creature) {
                clearTarget();
            }

            // Remove from creatures array immediately (prevents further targeting)
            creatures = creatures.filter(c => c !== creature);

            // Death animation - fade out the creature
            const deathDuration = 500; // ms
            const startTime = Date.now();

            // Make materials transparent for animation
            creature.traverse(child => {
                if (child.isMesh && child.material) {
                    child.material.transparent = true;
                }
            });

            const animateDeath = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(1, elapsed / deathDuration);

                // Fade out and scale down
                creature.traverse(child => {
                    if (child.isMesh && child.material) {
                        child.material.opacity = 1 - progress;
                    }
                });
                creature.scale.setScalar(1 - progress * 0.3);
                creature.position.y -= 0.02; // Sink into ground

                if (progress < 1) {
                    requestAnimationFrame(animateDeath);
                } else {
                    // Remove from scene after animation
                    scene.remove(creature);

                    // Respawn after delay
                    setTimeout(() => {
                        const type = creature.userData.creatureType;
                        const x = (Math.random() - 0.5) * 400;
                        const z = (Math.random() - 0.5) * 400;
                        spawnCreature(type, x, z);
                    }, 30000);
                }
            };
            requestAnimationFrame(animateDeath);
        }

        function harvestNearbyResource() {
            const nearestResource = resourceNodes.find(r => {
                const dist = camera.position.distanceTo(r.position);
                return dist < 5 && r.userData.amount > 0;
            });

            if (!nearestResource) {
                addChatMessage('No harvestable resources nearby.', 'system');
                return;
            }

            const resType = nearestResource.userData.resourceType;
            const amount = 1 + Math.floor(Math.random() * 3);
            GameState.resources[resType] += amount;
            nearestResource.userData.amount -= 1;

            addChatMessage(`Harvested ${amount} ${resType}.`, 'loot');
            gainSkillXP('scout', 15);
            gainSkillXP('artisan', 10);
            renderInventory();

            // Check survey mission progress
            checkMissionProgress();

            if (nearestResource.userData.amount <= 0) {
                scene.remove(nearestResource);
                resourceNodes = resourceNodes.filter(r => r !== nearestResource);

                // Respawn
                setTimeout(() => {
                    const types = ['iron', 'copper', 'chemicals', 'flora'];
                    const newType = types[Math.floor(Math.random() * types.length)];
                    // Simplified respawn
                }, 60000);
            }
        }

        function scanCreature() {
            if (!GameState.target) {
                addChatMessage('No target to scan.', 'system');
                return;
            }

            const target = GameState.target;
            addChatMessage(`--- Creature Scan: ${target.userData.name} ---`, 'system');
            addChatMessage(`Level: ${target.userData.level}`, 'system');
            addChatMessage(`Health: ${target.userData.currentHealth}/${target.userData.maxHealth}`, 'system');
            addChatMessage(`Damage: ~${target.userData.damage}`, 'system');
            addChatMessage(`Loot: ${target.userData.loot.join(', ')}`, 'system');

            gainSkillXP('scout', 25);
        }

        // ==================== SKILL SYSTEM ====================
        function gainSkillXP(profession, amount) {
            const xpBonus = getBuffValue('xpBonus');
            const totalXP = Math.floor(amount * (1 + xpBonus / 100));
            GameState.skillXP[profession] += totalXP;

            // Check for skill unlocks
            checkSkillUnlocks(profession);
        }

        function checkSkillUnlocks(profession) {
            const tree = SKILL_TREES[profession];
            if (!tree) return;

            const currentXP = GameState.skillXP[profession];
            const skills = GameState.skills[profession];

            tree.skills.forEach(skill => {
                if (skills[skill.id]) return; // Already unlocked

                // Check requirements
                let canUnlock = false;
                if (skill.requires === null) {
                    canUnlock = true;
                } else if (Array.isArray(skill.requires)) {
                    canUnlock = skill.requires.every(req => skills[req]);
                } else {
                    canUnlock = skills[skill.requires];
                }

                if (canUnlock && currentXP >= SKILL_XP_REQUIRED * (skill.row + 1)) {
                    // Auto-unlock novice, prompt for others
                    if (skill.id.includes('novice') || skill.row === 0) {
                        skills[skill.id] = true;
                        addChatMessage(`Skill unlocked: ${skill.name}!`, 'xp');
                    }
                }
            });
        }

        function showProfession(profession) {
            const container = document.getElementById('skill-tree-container');
            container.innerHTML = '';

            const tree = SKILL_TREES[profession];
            if (!tree) return;

            tree.skills.forEach(skill => {
                const box = document.createElement('div');
                box.className = 'skill-box';

                const isUnlocked = GameState.skills[profession][skill.id];
                let canUnlock = false;

                if (skill.requires === null) {
                    canUnlock = true;
                } else if (Array.isArray(skill.requires)) {
                    canUnlock = skill.requires.every(req => GameState.skills[profession][req]);
                } else {
                    canUnlock = GameState.skills[profession][skill.requires];
                }

                if (isUnlocked) {
                    box.classList.add('unlocked');
                } else if (canUnlock) {
                    box.classList.add('available');
                } else {
                    box.classList.add('locked');
                }

                box.innerHTML = `
                    <div class="skill-name">${skill.name}</div>
                    <div class="skill-xp">${isUnlocked ? 'LEARNED' : `${GameState.skillXP[profession]}/${SKILL_XP_REQUIRED * (skill.row + 1)} XP`}</div>
                `;

                box.addEventListener('click', () => {
                    if (!isUnlocked && canUnlock && GameState.skillXP[profession] >= SKILL_XP_REQUIRED * (skill.row + 1)) {
                        GameState.skills[profession][skill.id] = true;
                        addChatMessage(`Learned: ${skill.name}!`, 'xp');
                        showProfession(profession);
                    }
                });

                container.appendChild(box);
            });
        }

        // ==================== BUFFS ====================
        function addBuff(name, icon, duration, effects) {
            GameState.buffs.push({
                name, icon, duration, effects,
                startTime: Date.now(),
                endTime: Date.now() + duration
            });

            renderBuffs();
            addChatMessage(`Buff gained: ${name}`, 'xp');
        }

        function renderBuffs() {
            const container = document.getElementById('buff-display');
            container.innerHTML = '';

            GameState.buffs.forEach(buff => {
                const remaining = Math.max(0, buff.endTime - Date.now());
                const minutes = Math.floor(remaining / 60000);
                const seconds = Math.floor((remaining % 60000) / 1000);

                const buffEl = document.createElement('div');
                buffEl.className = 'buff-icon';
                buffEl.innerHTML = `
                    ${buff.icon}
                    <span class="buff-timer">${minutes}:${seconds.toString().padStart(2, '0')}</span>
                `;
                buffEl.title = buff.name;
                container.appendChild(buffEl);
            });
        }

        function getBuffValue(effectName) {
            let total = 0;
            GameState.buffs.forEach(buff => {
                if (buff.effects[effectName]) {
                    total += buff.effects[effectName];
                }
            });
            return total;
        }

        function updateBuffs() {
            const now = Date.now();
            const expiredBuffs = GameState.buffs.filter(b => now >= b.endTime);
            expiredBuffs.forEach(buff => {
                addChatMessage(`Buff expired: ${buff.name}`, 'system');
            });
            GameState.buffs = GameState.buffs.filter(b => now < b.endTime);

            if (expiredBuffs.length > 0 || GameState.buffs.length > 0) {
                renderBuffs();
            }
        }

        // ==================== CANTINA ====================
        let watchingEntertainer = false;
        let watchProgress = 0;

        function watchEntertainer(type) {
            if (watchingEntertainer) return;

            watchingEntertainer = true;
            watchProgress = 0;

            document.getElementById('watching-progress').style.display = 'block';
            document.querySelectorAll('.watch-btn').forEach(btn => btn.disabled = true);

            const interval = setInterval(() => {
                watchProgress += 2;
                document.querySelector('.buff-progress-fill').style.width = `${watchProgress}%`;
                document.getElementById('buff-countdown').textContent = `Building buff: ${watchProgress}%`;

                if (watchProgress >= 100) {
                    clearInterval(interval);
                    watchingEntertainer = false;
                    document.getElementById('watching-progress').style.display = 'none';
                    document.querySelectorAll('.watch-btn').forEach(btn => btn.disabled = false);

                    if (type === 'musician') {
                        addBuff('Musician Inspiration', 'üéµ', 30 * 60 * 1000, { actionRegen: 50, xpBonus: 25 });
                    } else {
                        addBuff('Dance of Mind', 'üíÉ', 30 * 60 * 1000, { mindRegen: 50, combatSpeed: 10 });
                    }

                    closeCantinaUI();
                }
            }, 500);
        }

        // ==================== VENDORS ====================
        function openVendorWindow(vendorType) {
            const vendor = VENDORS[vendorType];
            if (!vendor) return;

            document.getElementById('vendor-name').textContent = vendor.name;
            const container = document.getElementById('vendor-items');
            container.innerHTML = '';

            vendor.items.forEach(item => {
                const canAfford = GameState.player.credits >= item.price;
                const itemEl = document.createElement('div');
                itemEl.className = 'vendor-item';
                itemEl.innerHTML = `
                    <div>
                        <div style="color: #ffd700;">${item.name}</div>
                        <div style="font-size: 11px; color: #aaa;">${item.type} ${item.damage ? `(Damage: ${item.damage})` : ''} ${item.defense ? `(Defense: ${item.defense})` : ''}</div>
                    </div>
                    <div>
                        <span style="color: ${canAfford ? '#66ff66' : '#ff6666'};">${item.price} credits</span>
                        <button ${canAfford ? '' : 'disabled'} onclick="buyItem('${vendorType}', '${item.name}')">Buy</button>
                    </div>
                `;
                container.appendChild(itemEl);
            });

            document.getElementById('vendor-window').classList.add('active');
        }

        function buyItem(vendorType, itemName) {
            const vendor = VENDORS[vendorType];
            const item = vendor.items.find(i => i.name === itemName);
            if (!item || GameState.player.credits < item.price) return;

            GameState.player.credits -= item.price;
            GameState.inventory.push({ ...item });

            addChatMessage(`Purchased ${item.name} for ${item.price} credits.`, 'loot');
            updateCreditsDisplay();
            renderInventory();
            openVendorWindow(vendorType); // Refresh
        }

        // ==================== INTERACTION ====================
        function interactWithNearby() {
            if (!interactableNear) return;

            const data = interactableNear.userData;

            if (data.type === 'vendor') {
                openVendorWindow(data.vendorType);
            } else if (data.type === 'cantina') {
                document.getElementById('cantina-ui').classList.add('active');
            } else if (data.type === 'resource') {
                harvestNearbyResource();
            } else if (data.type === 'shuttle') {
                addChatMessage('Shuttle service coming soon! Travel to other planets...', 'system');
            } else if (data.type === 'missionTerminal') {
                openMissionWindow();
            }

            // Check if we can complete a delivery mission
            if (checkDeliveryMission()) {
                completeMission();
            }
        }

        function checkInteractables() {
            let nearest = null;
            let nearestDist = 10;

            [...npcs, ...resourceNodes].forEach(obj => {
                if (!obj.userData.interactable) return;
                const dist = camera.position.distanceTo(obj.position);
                if (dist < nearestDist) {
                    nearest = obj;
                    nearestDist = dist;
                }
            });

            // Check cantina entrance
            structures.forEach(s => {
                if (s.userData.type === 'cantina') {
                    const dist = camera.position.distanceTo(new THREE.Vector3(s.position.x, 2, s.position.z + 12));
                    if (dist < 8) {
                        nearest = s;
                        nearestDist = dist;
                    }
                }
            });

            interactableNear = nearest;

            const prompt = document.getElementById('interact-prompt');
            if (nearest) {
                prompt.textContent = `[E] ${nearest.userData.name || 'Interact'}`;
                prompt.classList.add('active');
            } else {
                prompt.classList.remove('active');
            }
        }

        // ==================== UI UPDATES ====================
        function updateHAMBars() {
            const p = GameState.player;

            document.querySelector('#health-bar .ham-bar-fill').style.width = `${(p.health / p.maxHealth) * 100}%`;
            document.querySelector('#health-bar .ham-bar-text').textContent = `Health: ${Math.floor(p.health)}/${p.maxHealth}`;

            document.querySelector('#action-bar .ham-bar-fill').style.width = `${(p.action / p.maxAction) * 100}%`;
            document.querySelector('#action-bar .ham-bar-text').textContent = `Action: ${Math.floor(p.action)}/${p.maxAction}`;

            document.querySelector('#mind-bar .ham-bar-fill').style.width = `${(p.mind / p.maxMind) * 100}%`;
            document.querySelector('#mind-bar .ham-bar-text').textContent = `Mind: ${Math.floor(p.mind)}/${p.maxMind}`;
        }

        function updateCreditsDisplay() {
            document.getElementById('credits-amount').textContent = GameState.player.credits.toLocaleString();
        }

        function renderInventory() {
            const grid = document.getElementById('inventory-grid');
            grid.innerHTML = '';

            for (let i = 0; i < 32; i++) {
                const slot = document.createElement('div');
                slot.className = 'inv-slot';

                if (GameState.inventory[i]) {
                    const item = GameState.inventory[i];
                    slot.classList.add('has-item');
                    slot.textContent = getItemIcon(item.type);

                    // Add title with equip hint for weapons/armor
                    if (item.type === 'weapon') {
                        slot.title = `${item.name} (+${item.damage} DMG) - Click to equip`;
                        slot.style.cursor = 'pointer';
                        const index = i;
                        slot.onclick = () => equipItem(index);
                    } else if (item.type === 'armor') {
                        slot.title = `${item.name} (+${item.defense} DEF) - Click to equip`;
                        slot.style.cursor = 'pointer';
                        const index = i;
                        slot.onclick = () => equipItem(index);
                    } else if (item.type === 'consumable' || item.type === 'holocron') {
                        slot.title = `${item.name} - Click to use`;
                        slot.style.cursor = 'pointer';
                        const index = i;
                        slot.onclick = () => useItem(index);
                    } else {
                        slot.title = item.name;
                    }
                }

                grid.appendChild(slot);
            }

            // Update equipment slots display
            updateEquipmentSlots();

            // Resources display
            const resDisplay = document.getElementById('resources-display');
            resDisplay.innerHTML = Object.entries(GameState.resources)
                .filter(([k, v]) => v > 0)
                .map(([k, v]) => `<span style="margin-right: 15px;">${k}: ${v}</span>`)
                .join('');
        }

        function getItemIcon(type) {
            const icons = {
                weapon: 'üî´',
                armor: 'üõ°Ô∏è',
                consumable: 'üíä',
                tool: 'üîß',
                kraytPearl: 'üíé',
                holocron: 'üîÆ'
            };
            return icons[type] || 'üì¶';
        }

        function addChatMessage(text, type = 'system') {
            const chatBox = document.getElementById('chat-box');
            const msg = document.createElement('div');
            msg.className = `chat-message chat-${type}`;
            msg.textContent = `[${new Date().toLocaleTimeString()}] ${text}`;
            chatBox.appendChild(msg);
            chatBox.scrollTop = chatBox.scrollHeight;

            // Limit messages
            while (chatBox.children.length > 50) {
                chatBox.removeChild(chatBox.firstChild);
            }
        }

        function updateMinimap() {
            const canvas = document.getElementById('minimap-canvas');
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, 150, 150);

            const scale = 0.15;
            const centerX = 75;
            const centerY = 75;

            // Draw structures
            ctx.fillStyle = '#888';
            structures.forEach(s => {
                const x = centerX + (s.position.x - camera.position.x) * scale;
                const y = centerY + (s.position.z - camera.position.z) * scale;
                if (x > 0 && x < 150 && y > 0 && y < 150) {
                    ctx.fillRect(x - 3, y - 3, 6, 6);
                }
            });

            // Draw creatures
            ctx.fillStyle = '#ff4444';
            creatures.forEach(c => {
                const x = centerX + (c.position.x - camera.position.x) * scale;
                const y = centerY + (c.position.z - camera.position.z) * scale;
                if (x > 0 && x < 150 && y > 0 && y < 150) {
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // Draw NPCs
            ctx.fillStyle = '#44ff44';
            npcs.forEach(n => {
                const x = centerX + (n.position.x - camera.position.x) * scale;
                const y = centerY + (n.position.z - camera.position.z) * scale;
                if (x > 0 && x < 150 && y > 0 && y < 150) {
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // Draw player
            ctx.fillStyle = '#00ffff';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 4, 0, Math.PI * 2);
            ctx.fill();

            // Draw direction indicator
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(centerX + Math.sin(rotation.y) * 10, centerY - Math.cos(rotation.y) * 10);
            ctx.stroke();
        }

        function updateLocationDisplay() {
            const x = Math.floor(camera.position.x);
            const z = Math.floor(camera.position.z);
            document.getElementById('location-display').textContent = `Tatooine (${x}, ${z})`;
        }

        // ==================== WINDOW TOGGLES ====================
        function toggleSkillsWindow() {
            const window = document.getElementById('skills-window');
            window.classList.toggle('active');
            if (window.classList.contains('active')) {
                showProfession('marksman');
            }
        }

        function closeSkillsWindow() {
            document.getElementById('skills-window').classList.remove('active');
        }

        function toggleInventoryWindow() {
            document.getElementById('inventory-window').classList.toggle('active');
            renderInventory();
        }

        function closeInventoryWindow() {
            document.getElementById('inventory-window').classList.remove('active');
        }

        function closeCraftingWindow() {
            document.getElementById('crafting-window').classList.remove('active');
        }

        function closeVendorWindow() {
            document.getElementById('vendor-window').classList.remove('active');
        }

        function closeCantinaUI() {
            document.getElementById('cantina-ui').classList.remove('active');
        }

        function closeAllWindows() {
            closeSkillsWindow();
            closeInventoryWindow();
            closeCraftingWindow();
            closeVendorWindow();
            closeCantinaUI();
            closeMissionWindow();
            closeAchievementsWindow();
            closeHelpOverlay();
        }

        // ==================== MISSION SYSTEM ====================
        function generateAvailableMissions() {
            availableMissions = [];

            // Pick 2-3 random missions from each type
            ['destroy', 'survey', 'delivery'].forEach(type => {
                const templates = MISSION_TEMPLATES[type];
                const shuffled = [...templates].sort(() => Math.random() - 0.5);
                const count = 1 + Math.floor(Math.random() * 2);
                for (let i = 0; i < Math.min(count, shuffled.length); i++) {
                    availableMissions.push({ ...shuffled[i], type });
                }
            });

            // Shuffle final list
            availableMissions.sort(() => Math.random() - 0.5);
        }

        function openMissionWindow() {
            if (availableMissions.length === 0) {
                generateAvailableMissions();
            }
            currentMissionTab = 'available';
            updateMissionTabs();
            renderMissionList();
            document.getElementById('mission-window').classList.add('active');
        }

        function closeMissionWindow() {
            document.getElementById('mission-window').classList.remove('active');
        }

        function switchMissionTab(tab) {
            currentMissionTab = tab;
            updateMissionTabs();
            renderMissionList();
        }

        function updateMissionTabs() {
            document.querySelectorAll('.mission-tab').forEach(t => {
                t.classList.toggle('active', t.dataset.tab === currentMissionTab);
            });
        }

        function renderMissionList() {
            const container = document.getElementById('mission-list');
            container.innerHTML = '';

            if (currentMissionTab === 'available') {
                if (GameState.activeMission) {
                    container.innerHTML = '<div style="text-align: center; color: #aaa; padding: 20px;">Complete or abandon your current mission first.</div>';
                    return;
                }

                availableMissions.forEach((mission, index) => {
                    const missionEl = document.createElement('div');
                    missionEl.className = 'mission-item';
                    missionEl.innerHTML = `
                        <div class="mission-title">${mission.title}</div>
                        <div class="mission-desc">${mission.desc}</div>
                        <div class="mission-reward">Reward: ${mission.credits} credits, ${mission.xp} XP</div>
                        <div class="mission-difficulty ${mission.difficulty}">${mission.difficulty.toUpperCase()}</div>
                        <button class="mission-accept-btn" onclick="acceptMission(${index})">Accept Mission</button>
                    `;
                    container.appendChild(missionEl);
                });
            } else {
                // Active mission tab
                if (!GameState.activeMission) {
                    container.innerHTML = '<div style="text-align: center; color: #aaa; padding: 20px;">No active mission.</div>';
                    return;
                }

                const mission = GameState.activeMission;
                const progress = getMissionProgress();
                const progressPercent = Math.min(100, (progress.current / progress.required) * 100);

                const missionEl = document.createElement('div');
                missionEl.className = 'mission-item';
                missionEl.innerHTML = `
                    <div class="mission-title">${mission.title}</div>
                    <div class="mission-desc">${mission.desc}</div>
                    <div class="mission-objective" style="color: #fff; margin: 10px 0;">
                        ${getMissionObjectiveText()}
                    </div>
                    <div class="mission-progress">
                        <div class="mission-progress-fill" style="width: ${progressPercent}%"></div>
                    </div>
                    <div style="color: #aaa; font-size: 11px; margin-top: 5px;">${progress.current} / ${progress.required}</div>
                    <div class="mission-reward">Reward: ${mission.credits} credits, ${mission.xp} XP</div>
                    <button class="mission-accept-btn" style="background: #aa4444;" onclick="abandonMission()">Abandon Mission</button>
                `;
                container.appendChild(missionEl);
            }
        }

        function acceptMission(index) {
            const mission = availableMissions[index];
            GameState.activeMission = mission;
            GameState.missionProgress = { killCount: 0, harvestCount: 0, startResources: { ...GameState.resources } };

            addChatMessage(`Mission accepted: ${mission.title}`, 'system');
            updateActiveMissionHUD();
            closeMissionWindow();

            // Remove from available
            availableMissions.splice(index, 1);
        }

        function abandonMission() {
            if (GameState.activeMission) {
                addChatMessage(`Mission abandoned: ${GameState.activeMission.title}`, 'system');
                GameState.activeMission = null;
                GameState.missionProgress = {};
                updateActiveMissionHUD();
                renderMissionList();
            }
        }

        function getMissionProgress() {
            const mission = GameState.activeMission;
            if (!mission) return { current: 0, required: 1 };

            switch (mission.type) {
                case 'destroy':
                    return { current: GameState.missionProgress.killCount || 0, required: mission.count };
                case 'survey':
                    const startAmount = GameState.missionProgress.startResources?.[mission.resource] || 0;
                    const currentAmount = GameState.resources[mission.resource] || 0;
                    return { current: Math.max(0, currentAmount - startAmount), required: mission.count };
                case 'delivery':
                    const dist = Math.sqrt(
                        Math.pow(camera.position.x - mission.waypoint.x, 2) +
                        Math.pow(camera.position.z - mission.waypoint.z, 2)
                    );
                    return { current: dist < 10 ? 1 : 0, required: 1 };
                default:
                    return { current: 0, required: 1 };
            }
        }

        function getMissionObjectiveText() {
            const mission = GameState.activeMission;
            if (!mission) return '';

            const progress = getMissionProgress();

            switch (mission.type) {
                case 'destroy':
                    const creatureName = CREATURE_TYPES[mission.target]?.name || mission.target;
                    return `Kill ${progress.current}/${mission.count} ${creatureName}s`;
                case 'survey':
                    return `Harvest ${progress.current}/${mission.count} ${mission.resource}`;
                case 'delivery':
                    if (progress.current >= progress.required) {
                        return 'Deliver the package! (Press E)';
                    }
                    const dist = Math.sqrt(
                        Math.pow(camera.position.x - mission.waypoint.x, 2) +
                        Math.pow(camera.position.z - mission.waypoint.z, 2)
                    );
                    return `Travel to waypoint (${Math.floor(dist)}m away)`;
                default:
                    return '';
            }
        }

        function updateActiveMissionHUD() {
            const hud = document.getElementById('active-mission-hud');
            const mission = GameState.activeMission;

            if (!mission) {
                hud.classList.remove('active');
                return;
            }

            hud.classList.add('active');
            document.getElementById('active-mission-title').textContent = mission.title;
            document.getElementById('active-mission-objective').textContent = getMissionObjectiveText();

            const progress = getMissionProgress();
            const progressPercent = Math.min(100, (progress.current / progress.required) * 100);
            document.getElementById('active-mission-progress').style.width = `${progressPercent}%`;
        }

        function checkMissionProgress() {
            if (!GameState.activeMission) return;

            const progress = getMissionProgress();
            updateActiveMissionHUD();

            if (progress.current >= progress.required) {
                completeMission();
            }
        }

        function completeMission() {
            const mission = GameState.activeMission;
            if (!mission) return;

            // Play mission complete fanfare
            AudioManager.playMissionComplete();

            // Track statistics
            GameState.statistics.missionsCompleted++;
            GameState.statistics.totalCreditsEarned += mission.credits;

            // Grant rewards
            GameState.player.credits += mission.credits;
            gainSkillXP('scout', mission.xp);

            addChatMessage(`Mission Complete: ${mission.title}!`, 'system');
            addChatMessage(`Earned ${mission.credits} credits and ${mission.xp} XP!`, 'xp');

            // Floating reward text
            const rewardPos = camera.position.clone();
            rewardPos.y += 1;
            createFloatingText(`+${mission.credits}c`, rewardPos, 'credits');
            setTimeout(() => {
                const xpPos = camera.position.clone();
                xpPos.y += 1.5;
                createFloatingText(`+${mission.xp} XP`, xpPos, 'xp-gain');
            }, 300);

            updateCreditsDisplay();

            // Check for new achievements
            checkAchievements();

            // Clear mission
            GameState.activeMission = null;
            GameState.missionProgress = {};
            updateActiveMissionHUD();

            // Generate new missions
            generateAvailableMissions();
        }

        function onCreatureKill(creatureType) {
            if (!GameState.activeMission || GameState.activeMission.type !== 'destroy') return;

            if (GameState.activeMission.target === creatureType) {
                GameState.missionProgress.killCount = (GameState.missionProgress.killCount || 0) + 1;
                checkMissionProgress();
            }
        }

        function checkDeliveryMission() {
            if (!GameState.activeMission || GameState.activeMission.type !== 'delivery') return false;

            const mission = GameState.activeMission;
            const dist = Math.sqrt(
                Math.pow(camera.position.x - mission.waypoint.x, 2) +
                Math.pow(camera.position.z - mission.waypoint.z, 2)
            );

            return dist < 10;
        }

        // ==================== CREATURE AI ====================
        function updateCreatures(delta) {
            creatures.forEach(creature => {
                if (creature.userData.currentHealth <= 0) return;

                const data = creature.userData;
                const distToPlayer = camera.position.distanceTo(creature.position);
                const creatureType = CREATURE_TYPES[data.creatureType];
                const behavior = creatureType?.behavior || 'default';
                const aggroRadius = creatureType?.aggroRadius || 0;

                // Face health bars to camera
                if (data.healthBarBg) {
                    data.healthBarBg.lookAt(camera.position);
                    data.healthBarFill.lookAt(camera.position);
                }

                // Proximity aggro for aggressive creatures
                if (!data.inCombat && !data.neutral && aggroRadius > 0 && distToPlayer < aggroRadius) {
                    data.inCombat = true;
                    data.combatTarget = camera;
                    addChatMessage(`${data.name} attacks!`, 'combat');

                    // Pack behavior: alert nearby same-type creatures
                    if (behavior === 'pack') {
                        creatures.forEach(other => {
                            if (other !== creature &&
                                other.userData.creatureType === data.creatureType &&
                                other.userData.currentHealth > 0 &&
                                creature.position.distanceTo(other.position) < 25) {
                                other.userData.inCombat = true;
                                other.userData.combatTarget = camera;
                            }
                        });
                    }
                }

                // Flee behavior (Jawas run when attacked)
                if (behavior === 'flee' && data.inCombat) {
                    const awayDirection = new THREE.Vector3()
                        .subVectors(creature.position, camera.position)
                        .normalize();
                    creature.position.add(awayDirection.multiplyScalar(0.1));
                    if (distToPlayer > 40) {
                        data.inCombat = false;
                        data.combatTarget = null;
                    }
                    return;
                }

                if (data.inCombat && data.combatTarget) {
                    const direction = new THREE.Vector3()
                        .subVectors(camera.position, creature.position)
                        .normalize();

                    // Behavior-specific combat logic
                    let attackRange = 3;
                    let moveSpeed = data.level * 0.02 + 0.05;
                    let damageMultiplier = 1;

                    // Ranged behavior (Tuskens shoot from distance)
                    if (behavior === 'ranged') {
                        attackRange = 20;
                        if (distToPlayer < 8) {
                            // Back away if too close
                            creature.position.add(direction.multiplyScalar(-0.03));
                        }
                    }

                    // Charge behavior (Dewbacks charge periodically)
                    if (behavior === 'charge') {
                        if (!data.lastCharge || Date.now() - data.lastCharge > 8000) {
                            if (distToPlayer > 10 && distToPlayer < 30) {
                                data.isCharging = true;
                                data.chargeStart = Date.now();
                                data.lastCharge = Date.now();
                                addChatMessage(`${data.name} charges!`, 'combat');
                            }
                        }
                        if (data.isCharging) {
                            moveSpeed = 0.25; // Fast charge
                            damageMultiplier = 2;
                            if (Date.now() - data.chargeStart > 2000 || distToPlayer < 3) {
                                data.isCharging = false;
                            }
                        }
                    }

                    // Defensive behavior (Banthas gain defense when low health)
                    if (behavior === 'defensive') {
                        const healthPercent = data.currentHealth / data.maxHealth;
                        if (healthPercent < 0.5) {
                            data.defensiveStance = true;
                            damageMultiplier = 0.7; // Deal less damage but...
                        }
                    }

                    // Boss behavior (Krayt special attacks)
                    if (behavior === 'boss') {
                        const healthPercent = data.currentHealth / data.maxHealth;
                        // Roar attack every 15 seconds
                        if (!data.lastRoar || Date.now() - data.lastRoar > 15000) {
                            if (distToPlayer < 25) {
                                addChatMessage(`${data.name} lets out a terrifying ROAR!`, 'combat');
                                triggerScreenShake(1);
                                data.lastRoar = Date.now();
                            }
                        }
                        // Tail swipe at low health
                        if (healthPercent < 0.25) {
                            damageMultiplier = 1.5;
                        }
                    }

                    // Movement
                    if (distToPlayer > attackRange) {
                        creature.position.add(direction.multiplyScalar(moveSpeed));
                    } else {
                        // Attack player
                        if (!data.lastAttack || Date.now() - data.lastAttack > 2000) {
                            let baseDamage = Math.floor(data.damage * (0.8 + Math.random() * 0.4) * damageMultiplier);
                            const armorDefense = GameState.equipment.armor ? GameState.equipment.armor.defense : 0;

                            // Defensive stance reduces incoming damage too
                            if (data.defensiveStance) {
                                baseDamage = Math.floor(baseDamage * 0.8);
                            }

                            const damage = Math.max(1, baseDamage - armorDefense);
                            GameState.player.health -= damage;
                            const blocked = armorDefense > 0 ? ` (${armorDefense} blocked)` : '';
                            const chargeText = data.isCharging ? ' CHARGE!' : '';
                            addChatMessage(`${data.name} hits you for ${damage} damage!${blocked}${chargeText}`, 'combat');
                            data.lastAttack = Date.now();
                            updateHAMBars();

                            // Ranged creatures create incoming blaster bolt
                            if (behavior === 'ranged') {
                                createBlasterBolt(creature.position.clone(), camera.position.clone(), '#00ff00');
                            }

                            // Combat feedback
                            const playerDamagePos = camera.position.clone();
                            playerDamagePos.y += 0.5;
                            createFloatingText(`-${damage}`, playerDamagePos, 'damage-taken');
                            triggerScreenShake(damage / data.damage);
                            triggerHitFlash();
                            AudioManager.playPlayerHurt();

                            if (GameState.player.health <= 0) {
                                playerDeath();
                            }
                        }
                    }

                    // De-aggro if player is far
                    if (distToPlayer > 60) {
                        data.inCombat = false;
                        data.combatTarget = null;
                        data.isCharging = false;
                        data.defensiveStance = false;
                    }
                } else if (!data.neutral) {
                    // Wander
                    if (!data.wanderTarget || Date.now() - data.lastWander > 5000) {
                        data.wanderTarget = new THREE.Vector3(
                            creature.position.x + (Math.random() - 0.5) * 30,
                            0,
                            creature.position.z + (Math.random() - 0.5) * 30
                        );
                        data.lastWander = Date.now();
                    }

                    const wanderDir = new THREE.Vector3()
                        .subVectors(data.wanderTarget, creature.position)
                        .normalize();

                    if (creature.position.distanceTo(data.wanderTarget) > 2) {
                        creature.position.add(wanderDir.multiplyScalar(0.02));
                    }
                }

                // Rotate to face movement direction
                if (data.wanderTarget || data.combatTarget) {
                    const target = data.combatTarget ? camera.position : data.wanderTarget;
                    const angle = Math.atan2(
                        target.x - creature.position.x,
                        target.z - creature.position.z
                    );
                    creature.rotation.y = angle;
                }
            });
        }

        // Pack aggro helper - called when player attacks a pack creature
        function triggerPackAggro(attackedCreature) {
            const behavior = CREATURE_TYPES[attackedCreature.userData.creatureType]?.behavior;
            if (behavior === 'pack') {
                creatures.forEach(other => {
                    if (other !== attackedCreature &&
                        other.userData.creatureType === attackedCreature.userData.creatureType &&
                        other.userData.currentHealth > 0 &&
                        attackedCreature.position.distanceTo(other.position) < 25) {
                        other.userData.inCombat = true;
                        other.userData.combatTarget = camera;
                    }
                });
            }
        }

        function playerDeath() {
            addChatMessage('You have been incapacitated!', 'combat');
            GameState.statistics.deaths++;

            // Death penalty: Lose 10% of credits (max 500)
            const creditLoss = Math.min(500, Math.floor(GameState.player.credits * 0.1));
            if (creditLoss > 0) {
                GameState.player.credits -= creditLoss;
                addChatMessage(`You lost ${creditLoss} credits!`, 'combat');
            }

            // Reset survival challenges on death
            resetSurvivalChallengeOnDeath();

            // Respawn at starport
            setTimeout(() => {
                GameState.player.health = GameState.player.maxHealth;
                GameState.player.action = GameState.player.maxAction;
                GameState.player.mind = GameState.player.maxMind;
                camera.position.set(-30, 2, 30);
                clearTarget();
                updateHAMBars();
                updateCreditsDisplay();
                addChatMessage('You have been cloned at the nearest cloning facility.', 'system');

                // Apply Cloning Sickness debuff
                applyCloningSickness();
            }, 3000);
        }

        function applyCloningSickness() {
            // Check if already has cloning sickness
            const existingSickness = GameState.buffs.find(b => b.id === 'cloningSickness');
            if (existingSickness) {
                // Stack duration for repeated deaths
                existingSickness.endTime = Date.now() + 180000; // Reset to 3 minutes
                existingSickness.stacks = Math.min(3, (existingSickness.stacks || 1) + 1);
                addChatMessage(`Cloning Sickness intensified! (${existingSickness.stacks} stacks)`, 'system');
            } else {
                // Add new cloning sickness
                GameState.buffs.push({
                    id: 'cloningSickness',
                    name: 'Cloning Sickness',
                    icon: 'ü§¢',
                    endTime: Date.now() + 180000, // 3 minutes
                    stacks: 1,
                    effects: {
                        damageReduction: -0.2,  // -20% damage dealt
                        regenReduction: -0.5,   // -50% regen
                        xpReduction: -0.25      // -25% XP
                    }
                });
                addChatMessage('You are suffering from Cloning Sickness! (-20% damage, -50% regen, -25% XP for 3 minutes)', 'system');
            }
            renderBuffs();
        }

        function hasCloningSickness() {
            const sickness = GameState.buffs.find(b => b.id === 'cloningSickness');
            return sickness ? sickness : null;
        }

        function getCloningSicknessMultiplier(type) {
            const sickness = hasCloningSickness();
            if (!sickness) return 1;

            const stacks = sickness.stacks || 1;
            // Use diminishing returns to prevent negative multipliers
            // Stack 1: base penalty, Stack 2: 75% additional, Stack 3: 50% additional
            const diminishingFactor = 1 + (stacks > 1 ? 0.75 : 0) + (stacks > 2 ? 0.5 : 0);

            switch (type) {
                case 'damage':
                    // Max -45% at 3 stacks (0.55 multiplier)
                    return Math.max(0.55, 1 + (sickness.effects.damageReduction * diminishingFactor));
                case 'regen':
                    // Max -85% at 3 stacks (0.15 multiplier) - never negative!
                    return Math.max(0.15, 1 + (sickness.effects.regenReduction * diminishingFactor));
                case 'xp':
                    // Max -55% at 3 stacks (0.45 multiplier)
                    return Math.max(0.45, 1 + (sickness.effects.xpReduction * diminishingFactor));
                default:
                    return 1;
            }
        }

        // ==================== REGENERATION ====================
        function regenerate(delta) {
            const p = GameState.player;

            // Base regen
            let healthRegen = 1;
            let actionRegen = 2 + getBuffValue('actionRegen') * 0.1;
            let mindRegen = 2 + getBuffValue('mindRegen') * 0.1;

            // Slower regen in combat
            if (GameState.inCombat) {
                healthRegen *= 0.2;
                actionRegen *= 0.5;
                mindRegen *= 0.5;
            }

            // Apply cloning sickness regen penalty
            const regenMultiplier = getCloningSicknessMultiplier('regen');
            healthRegen *= regenMultiplier;
            actionRegen *= regenMultiplier;
            mindRegen *= regenMultiplier;

            p.health = Math.min(p.maxHealth, p.health + healthRegen * delta);
            p.action = Math.min(p.maxAction, p.action + actionRegen * delta);
            p.mind = Math.min(p.maxMind, p.mind + mindRegen * delta);
        }

        // ==================== MAIN LOOP ====================
        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            // Player movement
            const moveSpeed = keys.shift ? 0.3 : 0.15;
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();

            const right = new THREE.Vector3();
            right.crossVectors(forward, new THREE.Vector3(0, 1, 0));

            if (keys.w) camera.position.add(forward.clone().multiplyScalar(moveSpeed));
            if (keys.s) camera.position.add(forward.clone().multiplyScalar(-moveSpeed));
            if (keys.a) camera.position.add(right.clone().multiplyScalar(-moveSpeed));
            if (keys.d) camera.position.add(right.clone().multiplyScalar(moveSpeed));

            camera.rotation.order = 'YXZ';
            camera.rotation.y = rotation.y;
            camera.rotation.x = rotation.x;

            // Keep camera above ground
            camera.position.y = 2;

            // Update game systems
            updateCreatures(delta);
            regenerate(delta);
            updateBuffs();
            checkInteractables();

            // Update UI
            if (Math.random() < 0.1) {
                updateHAMBars();
                updateMinimap();
                updateLocationDisplay();
                if (GameState.target) updateTargetFrame();
                if (GameState.activeMission) {
                    updateActiveMissionHUD();
                    // Auto-check delivery missions
                    if (GameState.activeMission.type === 'delivery') {
                        checkMissionProgress();
                    }
                }
                // Update daily challenges every ~10 frames
                if (Math.random() < 0.1) {
                    updateDailyChallengeProgress();
                }
            }

            renderer.render(scene, camera);
        }

        // ==================== WINDOW RESIZE ====================
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ==================== START ====================
        init();
    </script>
</body>
</html>
