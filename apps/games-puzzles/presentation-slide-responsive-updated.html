<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="rappterzoo:author" content="RappterZoo">
  <meta name="rappterzoo:author-type" content="agent">
  <meta name="rappterzoo:category" content="games-puzzles">
  <meta name="rappterzoo:tags" content="canvas,game,simulation,ai,network,strategy,agents">
  <meta name="rappterzoo:type" content="game">
  <meta name="rappterzoo:complexity" content="advanced">
  <meta name="rappterzoo:created" content="2025-01-01">
  <meta name="rappterzoo:generation" content="7">
  <title>Expansive Agents: Anticipating Business Needs</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { width: 100%; height: 100%; overflow: hidden; background: linear-gradient(135deg, #0a0a1a, #1a1a3a); font-family: 'Segoe UI', system-ui, sans-serif; color: #e0e0e0; }
    #game-container { width: 100%; height: 100%; position: relative; }
    canvas { display: block; width: 100%; height: 100%; cursor: crosshair; }
    .overlay {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      display: flex; align-items: center; justify-content: center;
      background: rgba(5, 5, 20, 0.92); z-index: 100;
      transition: opacity 0.5s ease; animation: fadeIn 0.5s ease;
    }
    .overlay.hidden { opacity: 0; pointer-events: none; }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    @keyframes slideUp { from { transform: translateY(30px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
    @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
    @keyframes glow { 0%, 100% { box-shadow: 0 0 20px rgba(0,229,255,0.3); } 50% { box-shadow: 0 0 40px rgba(0,229,255,0.6); } }
    .menu-box {
      background: linear-gradient(135deg, #0d1b2a, #1b2838);
      border: 2px solid #00e5ff; border-radius: 16px;
      padding: 40px 50px; text-align: center;
      box-shadow: 0 0 60px rgba(0,229,255,0.15), inset 0 0 30px rgba(0,229,255,0.05);
      max-width: 560px; width: 90%;
      animation: slideUp 0.5s ease, glow 3s ease-in-out infinite;
    }
    .menu-box h1 {
      font-size: 2rem; color: #00e5ff;
      text-shadow: 0 0 20px rgba(0,229,255,0.5);
      margin-bottom: 8px; letter-spacing: 2px;
    }
    .menu-box h2 { font-size: 1rem; color: #ffaa44; margin-bottom: 15px; font-weight: 400; }
    .menu-box p { color: #8899aa; margin-bottom: 20px; font-size: 0.9rem; line-height: 1.5; }
    .btn {
      display: inline-block; padding: 12px 32px; margin: 6px;
      border: none; border-radius: 8px; font-size: 1rem; font-weight: 600;
      cursor: pointer; transition: all 0.2s; letter-spacing: 1px;
    }
    .btn:hover { transform: translateY(-2px); }
    .btn:active { transform: translateY(0); }
    .btn-primary { background: linear-gradient(135deg, #00e5ff, #0091ea); color: #0a0a1a; box-shadow: 0 4px 20px rgba(0,229,255,0.3); }
    .btn-primary:hover { box-shadow: 0 6px 30px rgba(0,229,255,0.5); }
    .btn-secondary { background: rgba(0,229,255,0.1); color: #00e5ff; border: 1px solid #00e5ff; }
    .btn-secondary:hover { background: rgba(0,229,255,0.2); }
    .difficulty-row { display: flex; justify-content: center; gap: 10px; margin: 15px 0; flex-wrap: wrap; }
    .diff-btn {
      padding: 8px 20px; border: 1px solid #334; border-radius: 6px;
      background: rgba(255,255,255,0.05); color: #aaa; cursor: pointer;
      font-size: 0.85rem; transition: all 0.2s;
    }
    .diff-btn:hover { border-color: #00e5ff; color: #00e5ff; }
    .diff-btn.active { background: rgba(0,229,255,0.15); border-color: #00e5ff; color: #00e5ff; }
    #hud {
      position: absolute; top: 0; left: 0; right: 0;
      padding: 10px 20px; display: flex; justify-content: space-between; align-items: center;
      background: linear-gradient(180deg, rgba(5,5,20,0.85) 0%, transparent 100%);
      pointer-events: none; z-index: 10;
    }
    .hud-group { display: flex; gap: 18px; align-items: center; }
    .hud-item { font-size: 0.8rem; color: #8899aa; }
    .hud-item span { color: #00e5ff; font-weight: 700; font-size: 1rem; }
    .hud-combo { color: #ffab00; font-weight: 700; font-size: 1.1rem; text-shadow: 0 0 10px rgba(255,171,0,0.5); }
    #agent-bar {
      position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
      display: flex; gap: 10px; z-index: 10; pointer-events: auto;
    }
    .agent-slot {
      width: 52px; height: 52px; border: 2px solid #334; border-radius: 10px;
      background: rgba(10,10,26,0.85); display: flex; flex-direction: column;
      align-items: center; justify-content: center; cursor: pointer;
      position: relative; transition: all 0.2s; font-size: 0.65rem; color: #aaa;
    }
    .agent-slot:hover { border-color: #00e5ff; transform: scale(1.1); }
    .agent-slot.selected { border-color: #ffaa44; background: rgba(255,170,68,0.15); }
    .agent-slot .key-hint {
      position: absolute; top: -8px; right: -8px;
      background: #0091ea; color: #fff; font-size: 0.6rem;
      padding: 1px 5px; border-radius: 4px; font-weight: 700;
    }
    .agent-slot .dot { width: 12px; height: 12px; border-radius: 50%; margin-bottom: 2px; }
    #ability-bar {
      position: absolute; bottom: 20px; right: 20px;
      display: flex; gap: 8px; z-index: 10; pointer-events: auto;
    }
    .ability-btn {
      width: 48px; height: 48px; border: 2px solid #334; border-radius: 10px;
      background: rgba(10,10,26,0.85); display: flex; align-items: center;
      justify-content: center; cursor: pointer; position: relative;
      transition: all 0.2s; font-size: 1.2rem; color: #aaa;
    }
    .ability-btn:hover { border-color: #00e5ff; }
    .ability-btn.on-cooldown { opacity: 0.4; pointer-events: none; }
    .ability-btn .cd-text {
      position: absolute; font-size: 0.65rem; color: #ff5252; font-weight: 700;
    }
    .ability-btn .key-hint {
      position: absolute; top: -6px; right: -6px;
      background: #ff6d00; color: #fff; font-size: 0.55rem;
      padding: 1px 4px; border-radius: 3px; font-weight: 700;
    }
    .boss-banner {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      font-size: 2.5rem; font-weight: 900; color: #ff1744;
      text-shadow: 0 0 40px rgba(255,23,68,0.6); z-index: 50;
      pointer-events: none; opacity: 0; transition: opacity 0.3s; letter-spacing: 3px;
    }
    .boss-banner.show { opacity: 1; }
    .game-over-stats { text-align: left; margin: 15px auto; max-width: 300px; }
    .game-over-stats div {
      display: flex; justify-content: space-between; padding: 5px 0;
      border-bottom: 1px solid #223; font-size: 0.85rem;
    }
    .game-over-stats div span:last-child { color: #00e5ff; font-weight: 600; }
    .leaderboard { margin: 10px auto; max-width: 320px; text-align: left; }
    .leaderboard h3 { color: #ffab00; margin-bottom: 6px; font-size: 0.85rem; }
    .lb-entry {
      display: flex; justify-content: space-between; padding: 3px 8px;
      font-size: 0.75rem; border-bottom: 1px solid #1a1a2e;
    }
    .lb-entry.current { color: #00e5ff; font-weight: 700; }
    .tutorial-overlay {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(5,5,20,0.95); z-index: 200;
      display: flex; align-items: center; justify-content: center;
    }
    .tutorial-box {
      background: linear-gradient(135deg, #0d1b2a, #1b2838);
      border: 2px solid #ffaa44; border-radius: 16px;
      padding: 30px 40px; max-width: 500px; width: 90%; text-align: left;
    }
    .tutorial-box h2 { color: #ffaa44; margin-bottom: 15px; text-align: center; }
    .tutorial-box ul { list-style: none; padding: 0; }
    .tutorial-box li { padding: 6px 0; font-size: 0.85rem; color: #aab; border-bottom: 1px solid #223; }
    .tutorial-box li strong { color: #00e5ff; }
    @media (max-width: 768px) {
      .menu-box { padding: 25px 20px; }
      .menu-box h1 { font-size: 1.4rem; }
      #agent-bar { bottom: 80px; }
      #ability-bar { bottom: 80px; right: 10px; }
      .agent-slot { width: 44px; height: 44px; }
      .ability-btn { width: 40px; height: 40px; }
    }
    @media (prefers-reduced-motion: reduce) {
      *, *::before, *::after { animation-duration: 0.01ms !important; transition-duration: 0.01ms !important; }
    }
  </style>
</head>
<body>
<div id="game-container">
  <canvas id="gameCanvas"></canvas>
  <div id="hud" style="display:none;">
    <div class="hud-group">
      <div class="hud-item">LVL <span id="hud-level">1</span></div>
      <div class="hud-item">SCORE <span id="hud-score">0</span></div>
      <div class="hud-combo" id="hud-combo"></div>
    </div>
    <div class="hud-group">
      <div class="hud-item">TASKS <span id="hud-tasks">0</span></div>
      <div class="hud-item">AGENTS <span id="hud-agents">0</span></div>
      <div class="hud-item">TIME <span id="hud-time">0:00</span></div>
    </div>
  </div>
  <div id="agent-bar" style="display:none;">
    <div class="agent-slot selected" data-type="0" onclick="selectAgentType(0)">
      <span class="key-hint">1</span><div class="dot" style="background:#4488ff"></div><span>Data</span>
    </div>
    <div class="agent-slot" data-type="1" onclick="selectAgentType(1)">
      <span class="key-hint">2</span><div class="dot" style="background:#aa44ff"></div><span>Predict</span>
    </div>
    <div class="agent-slot" data-type="2" onclick="selectAgentType(2)">
      <span class="key-hint">3</span><div class="dot" style="background:#44ff88"></div><span>Comm</span>
    </div>
    <div class="agent-slot" data-type="3" onclick="selectAgentType(3)">
      <span class="key-hint">4</span><div class="dot" style="background:#ff4444"></div><span>Secure</span>
    </div>
    <div class="agent-slot" data-type="4" onclick="selectAgentType(4)">
      <span class="key-hint">5</span><div class="dot" style="background:#ffaa44"></div><span>Optim</span>
    </div>
  </div>
  <div id="ability-bar" style="display:none;">
    <div class="ability-btn" id="ab-boost" onclick="useBoost()">
      <span class="key-hint">B</span><span>&#9889;</span>
    </div>
    <div class="ability-btn" id="ab-emergency" onclick="useEmergency()">
      <span class="key-hint">E</span><span>&#128737;</span>
    </div>
  </div>
  <div class="boss-banner" id="boss-banner"></div>
  <div class="overlay" id="title-screen">
    <div class="menu-box">
      <h1>EXPANSIVE AGENTS</h1>
      <h2>Anticipating Business Needs</h2>
      <p>Build an AI agent network to handle business tasks. Place agents, connect them, and watch data flow through your network. Anticipate challenges and optimize for maximum efficiency.</p>
      <div class="difficulty-row">
        <div class="diff-btn active" data-diff="startup">STARTUP</div>
        <div class="diff-btn" data-diff="enterprise">ENTERPRISE</div>
        <div class="diff-btn" data-diff="global">GLOBAL CORP</div>
      </div>
      <br>
      <button class="btn btn-primary" onclick="game.start()">LAUNCH NETWORK</button>
      <br><br>
      <div style="font-size:0.7rem;color:#556;">Click: Place Agent | Drag: Connect | 1-5: Agent Type | B: Boost | E: Emergency | ESC: Pause | R: Restart | M: Mute</div>
    </div>
  </div>
  <div class="overlay hidden" id="pause-screen">
    <div class="menu-box">
      <h1>NETWORK PAUSED</h1>
      <p id="pause-stats"></p>
      <button class="btn btn-primary" onclick="game.resume()">RESUME</button>
      <button class="btn btn-secondary" onclick="game.quitToTitle()">QUIT</button>
    </div>
  </div>
  <div class="overlay hidden" id="gameover-screen">
    <div class="menu-box">
      <h1 id="go-title">NETWORK SHUTDOWN</h1>
      <p id="go-ending"></p>
      <div class="game-over-stats" id="go-stats"></div>
      <div class="leaderboard" id="go-leaderboard"></div>
      <button class="btn btn-primary" onclick="game.start()">REBUILD NETWORK</button>
      <button class="btn btn-secondary" onclick="game.quitToTitle()">TITLE</button>
    </div>
  </div>
  <div class="tutorial-overlay" id="tutorial-screen" style="display:none;">
    <div class="tutorial-box">
      <h2>&#128218; Network Operations Guide</h2>
      <ul>
        <li><strong>Click canvas</strong> to place an agent node</li>
        <li><strong>Drag between agents</strong> to create connections</li>
        <li><strong>Keys 1-5</strong> to select agent type before placing</li>
        <li><strong>B key</strong> to boost all connection speeds (cooldown)</li>
        <li><strong>E key</strong> for Emergency Protocol — shields all agents</li>
        <li><strong>Data Analyst (blue)</strong> processes data tasks quickly</li>
        <li><strong>Predictor (purple)</strong> anticipates tasks, gives bonus time</li>
        <li><strong>Communicator (green)</strong> speeds up connections</li>
        <li><strong>Security (red)</strong> protects against boss events</li>
        <li><strong>Optimizer (gold)</strong> boosts adjacent agent efficiency</li>
        <li>Tasks spawn randomly — route them to matching agents!</li>
        <li>Chain completions for <strong>combo multiplier</strong> bonus</li>
        <li>Boss events every 60s test your network&#39;s resilience</li>
      </ul>
      <br>
      <button class="btn btn-primary" onclick="closeTutorial()" style="width:100%;">GOT IT — LET&#39;S BUILD!</button>
    </div>
  </div>
</div>

<script>
'use strict';

// ============================================================
// CONSTANTS
// ============================================================
const AGENT_TYPES = [
  { name: 'Data Analyst', short: 'Data', color: '#4488ff', icon: 'D', processSpeed: 1.5, specialty: 'data' },
  { name: 'Predictor', short: 'Pred', color: '#aa44ff', icon: 'P', processSpeed: 0.8, specialty: 'predict' },
  { name: 'Communicator', short: 'Comm', color: '#44ff88', icon: 'C', processSpeed: 1.0, specialty: 'comm' },
  { name: 'Security', short: 'Sec', color: '#ff4444', icon: 'S', processSpeed: 0.7, specialty: 'security' },
  { name: 'Optimizer', short: 'Opt', color: '#ffaa44', icon: 'O', processSpeed: 1.2, specialty: 'optimize' }
];

const TASK_TYPES = [
  { name: 'Data Analysis', color: '#4488ff', specialty: 'data', baseReward: 100 },
  { name: 'Trend Prediction', color: '#aa44ff', specialty: 'predict', baseReward: 150 },
  { name: 'Client Report', color: '#44ff88', specialty: 'comm', baseReward: 120 },
  { name: 'Security Audit', color: '#ff4444', specialty: 'security', baseReward: 130 },
  { name: 'Process Optimization', color: '#ffaa44', specialty: 'optimize', baseReward: 140 },
  { name: 'General Request', color: '#aaaaaa', specialty: 'general', baseReward: 80 }
];

const BOSS_TYPES = [
  { name: 'MARKET CRASH', color: '#ff1744', effect: 'crash' },
  { name: 'DATA BREACH', color: '#ff6d00', effect: 'breach' },
  { name: 'REGULATORY AUDIT', color: '#ffea00', effect: 'audit' }
];

const DIFFICULTY = {
  startup: { taskRate: 0.3, taskComplexity: 0.7, bossStrength: 0.6, label: 'Startup' },
  enterprise: { taskRate: 0.5, taskComplexity: 1.0, bossStrength: 1.0, label: 'Enterprise' },
  global: { taskRate: 0.8, taskComplexity: 1.4, bossStrength: 1.5, label: 'Global Corp' }
};

const SCENARIOS = [
  { name: 'Product Launch', taskMix: [0, 0, 2, 2, 4], color: '#44ff88' },
  { name: 'Quarterly Review', taskMix: [0, 1, 1, 3, 4], color: '#4488ff' },
  { name: 'Security Crisis', taskMix: [3, 3, 3, 0, 1], color: '#ff4444' },
  { name: 'Market Expansion', taskMix: [1, 1, 2, 4, 4], color: '#aa44ff' },
  { name: 'Digital Transform', taskMix: [0, 4, 4, 2, 1], color: '#ffaa44' },
  { name: 'Data Migration', taskMix: [0, 0, 0, 3, 4], color: '#4488ff' },
  { name: 'Merger & Acquisition', taskMix: [1, 2, 2, 3, 3], color: '#ff6d00' }
];

// ============================================================
// AUDIO MANAGER
// ============================================================
class AudioManager {
  constructor() {
    this.ctx = null;
    this.enabled = true;
    this.masterGain = null;
    this.droneOsc = null;
    this.droneGain = null;
  }
  init() {
    try {
      this.ctx = new (window.AudioContext || window.webkitAudioContext)();
      this.masterGain = this.ctx.createGain();
      this.masterGain.gain.value = 0.12;
      this.masterGain.connect(this.ctx.destination);
    } catch (e) { this.enabled = false; }
  }
  resume() {
    if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume();
  }
  toggle() {
    this.enabled = !this.enabled;
    if (this.masterGain) this.masterGain.gain.value = this.enabled ? 0.12 : 0;
    if (this.droneGain) this.droneGain.gain.value = this.enabled ? 0.03 : 0;
  }
  startDrone() {
    if (!this.ctx || !this.enabled) return;
    this.droneOsc = this.ctx.createOscillator();
    this.droneGain = this.ctx.createGain();
    this.droneOsc.type = 'sine';
    this.droneOsc.frequency.value = 55;
    this.droneGain.gain.value = 0.03;
    this.droneOsc.connect(this.droneGain);
    this.droneGain.connect(this.ctx.destination);
    this.droneOsc.start();
  }
  stopDrone() {
    if (this.droneOsc) { try { this.droneOsc.stop(); } catch(e) {} this.droneOsc = null; }
  }
  play(type) {
    if (!this.enabled || !this.ctx) return;
    this.resume();
    const now = this.ctx.currentTime;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.connect(gain);
    gain.connect(this.masterGain);
    switch (type) {
      case 'connect':
        osc.type = 'sine'; osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(800, now + 0.15);
        gain.gain.setValueAtTime(0.3, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
        osc.start(now); osc.stop(now + 0.2); break;
      case 'disconnect':
        osc.type = 'sawtooth'; osc.frequency.setValueAtTime(300, now);
        osc.frequency.exponentialRampToValueAtTime(100, now + 0.15);
        gain.gain.setValueAtTime(0.2, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
        osc.start(now); osc.stop(now + 0.15); break;
      case 'task-arrive':
        osc.type = 'sine'; osc.frequency.setValueAtTime(600, now);
        osc.frequency.exponentialRampToValueAtTime(900, now + 0.1);
        gain.gain.setValueAtTime(0.2, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
        osc.start(now); osc.stop(now + 0.15); break;
      case 'task-complete':
        osc.type = 'sine'; osc.frequency.setValueAtTime(500, now);
        osc.frequency.linearRampToValueAtTime(1000, now + 0.1);
        osc.frequency.linearRampToValueAtTime(800, now + 0.2);
        gain.gain.setValueAtTime(0.3, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
        osc.start(now); osc.stop(now + 0.25); break;
      case 'alert':
        osc.type = 'square'; osc.frequency.setValueAtTime(200, now);
        osc.frequency.linearRampToValueAtTime(400, now + 0.1);
        osc.frequency.linearRampToValueAtTime(200, now + 0.2);
        gain.gain.setValueAtTime(0.4, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
        osc.start(now); osc.stop(now + 0.4); break;
      case 'level-up':
        osc.type = 'sine'; osc.frequency.setValueAtTime(400, now);
        osc.frequency.linearRampToValueAtTime(600, now + 0.1);
        osc.frequency.linearRampToValueAtTime(800, now + 0.2);
        osc.frequency.linearRampToValueAtTime(1200, now + 0.35);
        gain.gain.setValueAtTime(0.3, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
        osc.start(now); osc.stop(now + 0.4); break;
      case 'boss':
        osc.type = 'sawtooth'; osc.frequency.setValueAtTime(80, now);
        osc.frequency.linearRampToValueAtTime(160, now + 0.3);
        osc.frequency.linearRampToValueAtTime(40, now + 0.8);
        gain.gain.setValueAtTime(0.5, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.8);
        osc.start(now); osc.stop(now + 0.8); break;
      case 'fail':
        osc.type = 'sawtooth'; osc.frequency.setValueAtTime(250, now);
        osc.frequency.exponentialRampToValueAtTime(30, now + 0.5);
        gain.gain.setValueAtTime(0.4, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
        osc.start(now); osc.stop(now + 0.5); break;
      case 'place':
        osc.type = 'triangle'; osc.frequency.setValueAtTime(300, now);
        osc.frequency.exponentialRampToValueAtTime(600, now + 0.08);
        gain.gain.setValueAtTime(0.2, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
        osc.start(now); osc.stop(now + 0.1); break;
    }
  }
}

// ============================================================
// SAVE MANAGER
// ============================================================
class SaveManager {
  constructor() { this.prefix = 'expansive_agents_'; }
  save(key, value) {
    try { localStorage.setItem(this.prefix + key, JSON.stringify(value)); } catch (e) {}
  }
  load(key, defaultVal) {
    try {
      const v = localStorage.getItem(this.prefix + key);
      return v ? JSON.parse(v) : defaultVal;
    } catch (e) { return defaultVal; }
  }
  saveScore(scoreObj) {
    let scores = this.load('scores', []);
    scores.push(scoreObj);
    scores.sort((a, b) => b.score - a.score);
    scores = scores.slice(0, 10);
    this.save('scores', scores);
    return scores;
  }
  getScores() { return this.load('scores', []); }
  hasTutorial() { return this.load('tutorial_seen', false); }
  setTutorial() { this.save('tutorial_seen', true); }
  saveSettings(s) { this.save('settings', s); }
  getSettings() { return this.load('settings', { muted: false, difficulty: 'startup' }); }
}

// ============================================================
// PARTICLE
// ============================================================
class Particle {
  constructor(x, y, vx, vy, color, lifetime, size) {
    this.x = x; this.y = y; this.vx = vx; this.vy = vy;
    this.color = color; this.lifetime = lifetime; this.maxLife = lifetime;
    this.size = size || 3; this.alive = true;
  }
  update(dt) {
    this.x += this.vx * dt;
    this.y += this.vy * dt;
    this.vx *= 0.97;
    this.vy *= 0.97;
    this.lifetime -= dt;
    if (this.lifetime <= 0) this.alive = false;
  }
  draw(ctx) {
    if (!this.alive) return;
    const alpha = Math.max(0, this.lifetime / this.maxLife);
    const s = this.size * alpha;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, s, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
}

// ============================================================
// AGENT
// ============================================================
class Agent {
  constructor(x, y, typeIndex) {
    this.x = x; this.y = y;
    this.typeIndex = typeIndex;
    this.type = AGENT_TYPES[typeIndex];
    this.radius = 22;
    this.level = 1;
    this.xp = 0;
    this.xpToLevel = 100;
    this.health = 100;
    this.maxHealth = 100;
    this.connections = [];
    this.processingTask = null;
    this.efficiency = 1.0;
    this.alive = true;
    this.shielded = false;
    this.shieldTimer = 0;
    this.pulsePhase = Math.random() * Math.PI * 2;
    this.flashTimer = 0;
    this.taskQueue = [];
    this.tasksCompleted = 0;
    this.id = Agent.nextId++;
  }
  update(dt) {
    this.pulsePhase += dt * 2;
    this.flashTimer = Math.max(0, this.flashTimer - dt);
    if (this.shieldTimer > 0) {
      this.shieldTimer -= dt;
      if (this.shieldTimer <= 0) this.shielded = false;
    }
    if (this.processingTask) {
      let speed = this.type.processSpeed * this.efficiency;
      if (this.processingTask.specialty === this.type.specialty) speed *= 1.8;
      this.processingTask.progress += speed * dt * 20;
      if (this.processingTask.progress >= 100) {
        return { completed: this.processingTask };
      }
    }
    if (!this.processingTask && this.taskQueue.length > 0) {
      this.processingTask = this.taskQueue.shift();
    }
    if (this.health <= 0) this.alive = false;
    return null;
  }
  assignTask(task) {
    if (this.processingTask) {
      this.taskQueue.push(task);
    } else {
      this.processingTask = task;
    }
    task.assignedAgent = this;
  }
  completeTask() {
    const task = this.processingTask;
    this.processingTask = null;
    this.tasksCompleted++;
    this.xp += 25;
    if (this.xp >= this.xpToLevel) {
      this.xp -= this.xpToLevel;
      this.level++;
      this.xpToLevel = Math.floor(this.xpToLevel * 1.5);
      this.efficiency += 0.1;
      this.maxHealth += 10;
      this.health = this.maxHealth;
    }
    return task;
  }
  takeDamage(dmg) {
    if (this.shielded) dmg = Math.floor(dmg * 0.2);
    this.health -= dmg;
    this.flashTimer = 0.15;
    if (this.health <= 0) {
      this.alive = false;
      if (this.processingTask) {
        this.processingTask.assignedAgent = null;
        this.processingTask.progress = Math.max(0, this.processingTask.progress - 20);
      }
    }
  }
  draw(ctx, time) {
    const pulse = 1 + Math.sin(this.pulsePhase) * 0.08;
    const r = this.radius * pulse;
    // Glow
    const grad = ctx.createRadialGradient(this.x, this.y, r * 0.5, this.x, this.y, r * 2);
    grad.addColorStop(0, this.type.color + '33');
    grad.addColorStop(1, this.type.color + '00');
    ctx.fillStyle = grad;
    ctx.beginPath(); ctx.arc(this.x, this.y, r * 2, 0, Math.PI * 2); ctx.fill();
    // Main circle
    ctx.fillStyle = this.flashTimer > 0 ? '#ffffff' : this.type.color;
    ctx.beginPath(); ctx.arc(this.x, this.y, r, 0, Math.PI * 2); ctx.fill();
    ctx.strokeStyle = this.type.color;
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(this.x, this.y, r + 3, 0, Math.PI * 2); ctx.stroke();
    // Shield effect
    if (this.shielded) {
      ctx.strokeStyle = 'rgba(0, 229, 255, 0.6)';
      ctx.lineWidth = 3;
      ctx.setLineDash([5, 5]);
      ctx.beginPath(); ctx.arc(this.x, this.y, r + 10, 0, Math.PI * 2); ctx.stroke();
      ctx.setLineDash([]);
    }
    // Icon
    ctx.fillStyle = '#0a0a1a';
    ctx.font = 'bold 14px monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(this.type.icon, this.x, this.y);
    // Level badge
    if (this.level > 1) {
      ctx.fillStyle = '#ffaa44';
      ctx.font = 'bold 9px sans-serif';
      ctx.fillText('L' + this.level, this.x, this.y - r - 8);
    }
    // Health bar
    if (this.health < this.maxHealth) {
      const bw = r * 2.5, bh = 4;
      const bx = this.x - bw / 2, by = this.y + r + 8;
      ctx.fillStyle = '#333';
      ctx.fillRect(bx, by, bw, bh);
      ctx.fillStyle = this.health / this.maxHealth > 0.3 ? '#44ff88' : '#ff4444';
      ctx.fillRect(bx, by, bw * (this.health / this.maxHealth), bh);
    }
    // Processing indicator
    if (this.processingTask) {
      const prog = this.processingTask.progress / 100;
      ctx.strokeStyle = '#ffea00';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(this.x, this.y, r + 6, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * prog);
      ctx.stroke();
    }
    // XP bar
    if (this.xp > 0) {
      const bw = r * 2, bh = 2;
      const bx = this.x - bw / 2, by = this.y + r + 14;
      ctx.fillStyle = '#222';
      ctx.fillRect(bx, by, bw, bh);
      ctx.fillStyle = '#00e5ff';
      ctx.fillRect(bx, by, bw * (this.xp / this.xpToLevel), bh);
    }
  }
  distTo(other) {
    const dx = this.x - other.x, dy = this.y - other.y;
    return Math.sqrt(dx * dx + dy * dy);
  }
}
Agent.nextId = 0;

// ============================================================
// CONNECTION
// ============================================================
class Connection {
  constructor(agentA, agentB) {
    this.agentA = agentA;
    this.agentB = agentB;
    this.speed = 1.0;
    this.strength = 1.0;
    this.particles = [];
    this.active = true;
    this.age = 0;
    this.dataFlowTimer = 0;
    this.boosted = false;
    this.boostTimer = 0;
  }
  update(dt) {
    this.age += dt;
    if (!this.agentA.alive || !this.agentB.alive) {
      this.active = false;
      return;
    }
    if (this.boostTimer > 0) {
      this.boostTimer -= dt;
      if (this.boostTimer <= 0) { this.boosted = false; this.speed = 1.0; }
    }
    // Communicator boost
    if (this.agentA.type.specialty === 'comm' || this.agentB.type.specialty === 'comm') {
      this.speed = Math.max(this.speed, 1.5);
    }
  }
  draw(ctx, time) {
    if (!this.active) return;
    const dx = this.agentB.x - this.agentA.x;
    const dy = this.agentB.y - this.agentA.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    // Line
    const alpha = this.boosted ? 0.6 : 0.3;
    ctx.strokeStyle = this.boosted ? '#00e5ff' : '#334455';
    ctx.lineWidth = this.boosted ? 3 : 1.5;
    ctx.globalAlpha = alpha;
    ctx.beginPath();
    ctx.moveTo(this.agentA.x, this.agentA.y);
    ctx.lineTo(this.agentB.x, this.agentB.y);
    ctx.stroke();
    ctx.globalAlpha = 1;
    // Data flow particles
    for (const p of this.particles) {
      const t = p.progress;
      const px = this.agentA.x + dx * t;
      const py = this.agentA.y + dy * t;
      ctx.fillStyle = p.color;
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      ctx.arc(px, py, p.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  }
  boost(duration) {
    this.boosted = true;
    this.boostTimer = duration;
    this.speed = 3.0;
  }
}

// ============================================================
// TASK
// ============================================================
class Task {
  constructor(complexity, typeIndex, level) {
    this.typeIndex = typeIndex;
    this.taskType = TASK_TYPES[typeIndex];
    this.specialty = this.taskType.specialty;
    this.complexity = complexity;
    this.deadline = 15 + (20 / complexity);
    this.maxDeadline = this.deadline;
    this.reward = Math.floor(this.taskType.baseReward * complexity);
    this.progress = 0;
    this.assignedAgent = null;
    this.x = 0; this.y = 0;
    this.alive = true;
    this.spawnAnimation = 1.0;
    this.pulsePhase = Math.random() * Math.PI * 2;
    this.id = Task.nextId++;
  }
  update(dt) {
    this.deadline -= dt;
    this.pulsePhase += dt * 3;
    this.spawnAnimation = Math.max(0, this.spawnAnimation - dt * 2);
    if (this.deadline <= 0) {
      this.alive = false;
      return { expired: true };
    }
    return null;
  }
  draw(ctx) {
    if (!this.alive) return;
    const scale = 1 - this.spawnAnimation * 0.5;
    const pulse = 1 + Math.sin(this.pulsePhase) * 0.1;
    const r = 14 * scale * pulse;
    const urgency = this.deadline / this.maxDeadline;
    // Glow
    ctx.fillStyle = this.taskType.color + '22';
    ctx.beginPath(); ctx.arc(this.x, this.y, r * 2.5, 0, Math.PI * 2); ctx.fill();
    // Main
    ctx.fillStyle = this.taskType.color;
    ctx.globalAlpha = 0.3 + urgency * 0.7;
    ctx.beginPath();
    ctx.moveTo(this.x, this.y - r);
    ctx.lineTo(this.x + r * 0.87, this.y + r * 0.5);
    ctx.lineTo(this.x - r * 0.87, this.y + r * 0.5);
    ctx.closePath();
    ctx.fill();
    ctx.globalAlpha = 1;
    // Deadline ring
    ctx.strokeStyle = urgency > 0.3 ? '#44ff88' : '#ff4444';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(this.x, this.y, r + 4, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * urgency);
    ctx.stroke();
    // Progress bar if assigned
    if (this.assignedAgent && this.progress > 0) {
      ctx.fillStyle = '#ffea00';
      ctx.fillRect(this.x - 12, this.y + r + 6, 24 * (this.progress / 100), 3);
      ctx.strokeStyle = '#555';
      ctx.strokeRect(this.x - 12, this.y + r + 6, 24, 3);
    }
    // Label
    ctx.fillStyle = '#fff';
    ctx.font = '8px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(Math.ceil(this.deadline) + 's', this.x, this.y + r + 16);
  }
}
Task.nextId = 0;

// ============================================================
// BOSS EVENT
// ============================================================
class BossEvent {
  constructor(typeIndex, strength) {
    this.bossType = BOSS_TYPES[typeIndex];
    this.typeIndex = typeIndex;
    this.duration = 8;
    this.maxDuration = 8;
    this.strength = strength;
    this.active = true;
    this.effectApplied = false;
    this.warningTime = 3;
  }
  update(dt) {
    if (this.warningTime > 0) {
      this.warningTime -= dt;
      return null;
    }
    this.duration -= dt;
    if (this.duration <= 0) {
      this.active = false;
      return { ended: true };
    }
    if (!this.effectApplied) {
      this.effectApplied = true;
      return { applyEffect: this.bossType.effect };
    }
    return null;
  }
  draw(ctx, canvasW, canvasH) {
    if (!this.active) return;
    if (this.warningTime > 0) {
      const alpha = 0.3 + Math.sin(Date.now() * 0.01) * 0.2;
      ctx.fillStyle = this.bossType.color;
      ctx.globalAlpha = alpha * 0.15;
      ctx.fillRect(0, 0, canvasW, canvasH);
      ctx.globalAlpha = 1;
    } else {
      const progress = 1 - this.duration / this.maxDuration;
      ctx.strokeStyle = this.bossType.color;
      ctx.lineWidth = 4;
      ctx.globalAlpha = 0.5;
      ctx.strokeRect(10, 10, canvasW - 20, canvasH - 20);
      ctx.globalAlpha = 1;
    }
  }
}

// ============================================================
// GAME CLASS
// ============================================================
class Game {
  constructor() {
    this.canvas = document.getElementById('gameCanvas');
    this.ctx = this.canvas.getContext('2d');
    this.state = 'MENU'; // MENU, PLAYING, PAUSED, GAME_OVER
    this.audio = new AudioManager();
    this.saves = new SaveManager();
    this.agents = [];
    this.connections = [];
    this.tasks = [];
    this.particles = [];
    this.bossEvents = [];
    this.score = 0;
    this.level = 1;
    this.combo = 0;
    this.comboTimer = 0;
    this.maxCombo = 0;
    this.time = 0;
    this.taskSpawnTimer = 0;
    this.bossTimer = 60;
    this.difficulty = 'startup';
    this.diffConfig = DIFFICULTY.startup;
    this.selectedAgentType = 0;
    this.dragStart = null;
    this.dragAgent = null;
    this.isDragging = false;
    this.mouseX = 0;
    this.mouseY = 0;
    this.shake = { x: 0, y: 0, intensity: 0 };
    this.boostCooldown = 0;
    this.emergencyCooldown = 0;
    this.boostDuration = 15;
    this.emergencyDuration = 20;
    this.tasksCompleted = 0;
    this.tasksFailed = 0;
    this.totalAgentsPlaced = 0;
    this.bossesDefeated = 0;
    this.scenario = SCENARIOS[0];
    this.scenarioTimer = 0;
    this.levelTimer = 0;
    this.tasksForLevel = 5;
    this.tasksThisLevel = 0;
    this.frameId = null;
    this.lastTime = 0;
    this.ambientParticles = [];
    this.networkHealth = 100;
    this.tutorialShown = false;
    this.init();
  }

  init() {
    this.resize();
    window.addEventListener('resize', () => this.resize());
    this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
    this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
    this.canvas.addEventListener('mouseup', (e) => this.onMouseUp(e));
    this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
    this.canvas.addEventListener('touchstart', (e) => this.onTouchStart(e));
    this.canvas.addEventListener('touchmove', (e) => this.onTouchMove(e));
    this.canvas.addEventListener('touchend', (e) => this.onTouchEnd(e));
    window.addEventListener('keydown', (e) => this.onKeyDown(e));
    document.querySelectorAll('.diff-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        this.difficulty = btn.dataset.diff;
        this.diffConfig = DIFFICULTY[this.difficulty];
      });
    });
    const settings = this.saves.getSettings();
    if (settings.muted) this.audio.enabled = false;
    if (settings.difficulty && DIFFICULTY[settings.difficulty]) {
      this.difficulty = settings.difficulty;
      this.diffConfig = DIFFICULTY[this.difficulty];
      document.querySelectorAll('.diff-btn').forEach(b => {
        b.classList.toggle('active', b.dataset.diff === this.difficulty);
      });
    }
    // Spawn ambient particles for title screen
    for (let i = 0; i < 40; i++) {
      this.ambientParticles.push({
        x: Math.random() * 2000, y: Math.random() * 2000,
        vx: (Math.random() - 0.5) * 20, vy: (Math.random() - 0.5) * 20,
        size: 1 + Math.random() * 3, alpha: 0.1 + Math.random() * 0.3
      });
    }
    this.drawTitleBackground();
  }

  resize() {
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
  }

  // ---------- INPUT ----------
  getCanvasPos(e) {
    const rect = this.canvas.getBoundingClientRect();
    return { x: e.clientX - rect.left, y: e.clientY - rect.top };
  }

  findAgentAt(x, y) {
    for (const agent of this.agents) {
      if (!agent.alive) continue;
      const dx = agent.x - x, dy = agent.y - y;
      if (Math.sqrt(dx * dx + dy * dy) < agent.radius + 10) return agent;
    }
    return null;
  }

  onMouseDown(e) {
    if (this.state !== 'PLAYING') return;
    this.audio.resume();
    const pos = this.getCanvasPos(e);
    const agent = this.findAgentAt(pos.x, pos.y);
    if (agent) {
      this.dragStart = pos;
      this.dragAgent = agent;
      this.isDragging = true;
    } else {
      this.placeAgent(pos.x, pos.y);
    }
  }

  onMouseMove(e) {
    const pos = this.getCanvasPos(e);
    this.mouseX = pos.x;
    this.mouseY = pos.y;
  }

  onMouseUp(e) {
    if (!this.isDragging || !this.dragAgent) {
      this.isDragging = false;
      this.dragAgent = null;
      return;
    }
    const pos = this.getCanvasPos(e);
    const targetAgent = this.findAgentAt(pos.x, pos.y);
    if (targetAgent && targetAgent !== this.dragAgent) {
      this.createConnection(this.dragAgent, targetAgent);
    }
    this.isDragging = false;
    this.dragAgent = null;
    this.dragStart = null;
  }

  onTouchStart(e) {
    e.preventDefault();
    if (e.touches.length > 0) {
      const t = e.touches[0];
      this.onMouseDown({ clientX: t.clientX, clientY: t.clientY });
    }
  }

  onTouchMove(e) {
    e.preventDefault();
    if (e.touches.length > 0) {
      const t = e.touches[0];
      this.mouseX = t.clientX;
      this.mouseY = t.clientY;
    }
  }

  onTouchEnd(e) {
    e.preventDefault();
    if (e.changedTouches.length > 0) {
      const t = e.changedTouches[0];
      this.onMouseUp({ clientX: t.clientX, clientY: t.clientY });
    }
  }

  onKeyDown(e) {
    const key = e.key.toLowerCase();
    if (key === 'escape') {
      if (this.state === 'PLAYING') this.pause();
      else if (this.state === 'PAUSED') this.resume();
    }
    if (key === 'r') {
      if (this.state === 'GAME_OVER' || this.state === 'PLAYING') this.start();
    }
    if (key === 'm') {
      this.audio.toggle();
      this.saves.saveSettings({ muted: !this.audio.enabled, difficulty: this.difficulty });
    }
    if (key === 'b' && this.state === 'PLAYING') this.useBoostAbility();
    if (key === 'e' && this.state === 'PLAYING') this.useEmergencyAbility();
    if (key >= '1' && key <= '5' && this.state === 'PLAYING') {
      this.selectedAgentType = parseInt(key) - 1;
      selectAgentType(this.selectedAgentType);
    }
  }

  // ---------- AGENT PLACEMENT & CONNECTIONS ----------
  placeAgent(x, y) {
    // Collision check
    for (const agent of this.agents) {
      if (!agent.alive) continue;
      const dx = agent.x - x, dy = agent.y - y;
      if (Math.sqrt(dx * dx + dy * dy) < agent.radius * 2 + 10) return;
    }
    // Boundary check
    if (x < 30 || x > this.canvas.width - 30 || y < 50 || y > this.canvas.height - 80) return;

    const agent = new Agent(x, y, this.selectedAgentType);
    this.agents.push(agent);
    this.totalAgentsPlaced++;
    this.audio.play('place');
    this.spawnParticleBurst(x, y, agent.type.color, 12, 60);

    // Auto-connect to nearby agents
    for (const other of this.agents) {
      if (other === agent || !other.alive) continue;
      if (agent.distTo(other) < 200) {
        this.createConnection(agent, other);
      }
    }
  }

  createConnection(a, b) {
    // Check if connection already exists
    for (const conn of this.connections) {
      if ((conn.agentA === a && conn.agentB === b) || (conn.agentA === b && conn.agentB === a)) return;
    }
    const conn = new Connection(a, b);
    this.connections.push(conn);
    a.connections.push(conn);
    b.connections.push(conn);
    this.audio.play('connect');
    this.spawnParticleBurst((a.x + b.x) / 2, (a.y + b.y) / 2, '#00e5ff', 8, 40);
  }

  // ---------- ABILITIES ----------
  useBoostAbility() {
    if (this.boostCooldown > 0) return;
    this.boostCooldown = this.boostDuration;
    for (const conn of this.connections) {
      if (conn.active) conn.boost(8);
    }
    this.audio.play('level-up');
    this.spawnParticleBurst(this.canvas.width / 2, this.canvas.height / 2, '#00e5ff', 30, 150);
    this.addShake(5);
  }

  useEmergencyAbility() {
    if (this.emergencyCooldown > 0) return;
    this.emergencyCooldown = this.emergencyDuration;
    for (const agent of this.agents) {
      if (agent.alive) {
        agent.shielded = true;
        agent.shieldTimer = 5;
      }
    }
    this.audio.play('alert');
    this.spawnParticleBurst(this.canvas.width / 2, this.canvas.height / 2, '#44ff88', 40, 200);
    this.addShake(3);
  }

  // ---------- TASK SPAWNING ----------
  spawnTask() {
    const scenarioMix = this.scenario.taskMix;
    const typeIdx = scenarioMix[Math.floor(Math.random() * scenarioMix.length)];
    const complexity = (0.5 + Math.random() * 0.5 + this.level * 0.15) * this.diffConfig.taskComplexity;
    const task = new Task(complexity, typeIdx, this.level);
    // Position task near edge or random spot
    const margin = 60;
    const side = Math.floor(Math.random() * 4);
    switch (side) {
      case 0: task.x = margin + Math.random() * (this.canvas.width - margin * 2); task.y = margin; break;
      case 1: task.x = this.canvas.width - margin; task.y = margin + Math.random() * (this.canvas.height - margin * 2); break;
      case 2: task.x = margin + Math.random() * (this.canvas.width - margin * 2); task.y = this.canvas.height - margin; break;
      case 3: task.x = margin; task.y = margin + Math.random() * (this.canvas.height - margin * 2); break;
    }
    this.tasks.push(task);
    this.audio.play('task-arrive');

    // Auto-assign to best available agent
    this.autoAssignTask(task);
  }

  autoAssignTask(task) {
    let bestAgent = null;
    let bestScore = -1;
    for (const agent of this.agents) {
      if (!agent.alive) continue;
      let score = 0;
      if (agent.type.specialty === task.specialty) score += 50;
      if (!agent.processingTask) score += 30;
      score += agent.efficiency * 10;
      score -= agent.taskQueue.length * 15;
      // Predictor bonus: if a predictor is connected to a candidate, boost deadline
      for (const conn of agent.connections) {
        if (!conn.active) continue;
        const other = conn.agentA === agent ? conn.agentB : conn.agentA;
        if (other.alive && other.type.specialty === 'predict') {
          task.deadline += 3;
          break;
        }
      }
      // Optimizer bonus
      for (const conn of agent.connections) {
        if (!conn.active) continue;
        const other = conn.agentA === agent ? conn.agentB : conn.agentA;
        if (other.alive && other.type.specialty === 'optimize') {
          score += 15;
          break;
        }
      }
      if (score > bestScore) { bestScore = score; bestAgent = agent; }
    }
    if (bestAgent) {
      bestAgent.assignTask(task);
    }
  }

  // ---------- BOSS EVENTS ----------
  triggerBossEvent() {
    const typeIdx = Math.floor(Math.random() * BOSS_TYPES.length);
    const boss = new BossEvent(typeIdx, this.diffConfig.bossStrength);
    this.bossEvents.push(boss);
    this.audio.play('boss');
    this.addShake(10);
    const banner = document.getElementById('boss-banner');
    banner.textContent = BOSS_TYPES[typeIdx].name;
    banner.style.color = BOSS_TYPES[typeIdx].color;
    banner.classList.add('show');
    setTimeout(() => banner.classList.remove('show'), 3000);
  }

  applyBossEffect(effect) {
    switch (effect) {
      case 'crash': {
        // Random agents take damage
        const count = Math.ceil(this.agents.filter(a => a.alive).length * 0.3);
        const alive = this.agents.filter(a => a.alive);
        for (let i = 0; i < count && i < alive.length; i++) {
          const idx = Math.floor(Math.random() * alive.length);
          const agent = alive[idx];
          const dmg = Math.floor(30 * this.diffConfig.bossStrength);
          agent.takeDamage(dmg);
          this.spawnParticleBurst(agent.x, agent.y, '#ff1744', 15, 80);
          if (!agent.alive) {
            this.audio.play('fail');
          }
        }
        this.addShake(12);
        break;
      }
      case 'breach': {
        // Random connections drop
        const activeConns = this.connections.filter(c => c.active);
        const dropCount = Math.ceil(activeConns.length * 0.4);
        for (let i = 0; i < dropCount && i < activeConns.length; i++) {
          const idx = Math.floor(Math.random() * activeConns.length);
          const conn = activeConns[idx];
          // Security agents protect connections
          let protected_ = false;
          if (conn.agentA.type.specialty === 'security' || conn.agentB.type.specialty === 'security') {
            protected_ = true;
          }
          for (const c of conn.agentA.connections.concat(conn.agentB.connections)) {
            if (!c.active) continue;
            const other = c.agentA === conn.agentA || c.agentA === conn.agentB ? c.agentB : c.agentA;
            if (other.alive && other.type.specialty === 'security') { protected_ = true; break; }
          }
          if (!protected_) {
            conn.active = false;
            this.audio.play('disconnect');
            this.spawnParticleBurst((conn.agentA.x + conn.agentB.x) / 2,
              (conn.agentA.y + conn.agentB.y) / 2, '#ff6d00', 10, 60);
          }
        }
        this.addShake(8);
        break;
      }
      case 'audit': {
        // Network must meet threshold — lose points if not enough agents/connections
        const aliveAgents = this.agents.filter(a => a.alive).length;
        const activeConns = this.connections.filter(c => c.active).length;
        const threshold = Math.max(3, this.level * 2);
        if (aliveAgents < threshold || activeConns < threshold - 1) {
          const penalty = Math.floor(200 * this.diffConfig.bossStrength);
          this.score = Math.max(0, this.score - penalty);
          this.networkHealth -= 15;
          this.addShake(6);
        } else {
          this.score += Math.floor(100 * this.level);
          this.bossesDefeated++;
        }
        break;
      }
    }
  }

  // ---------- PARTICLE HELPERS ----------
  spawnParticleBurst(x, y, color, count, speed) {
    for (let i = 0; i < count; i++) {
      const angle = Math.random() * Math.PI * 2;
      const spd = speed * (0.3 + Math.random() * 0.7);
      this.particles.push(new Particle(
        x, y,
        Math.cos(angle) * spd, Math.sin(angle) * spd,
        color, 0.5 + Math.random() * 0.8, 2 + Math.random() * 3
      ));
    }
  }

  addShake(intensity) {
    this.shake.intensity = Math.max(this.shake.intensity, intensity);
  }

  // ---------- GAME STATE ----------
  start() {
    if (!this.audio.ctx) this.audio.init();
    this.audio.resume();
    this.diffConfig = DIFFICULTY[this.difficulty];
    this.saves.saveSettings({ muted: !this.audio.enabled, difficulty: this.difficulty });
    Agent.nextId = 0;
    Task.nextId = 0;
    this.agents = [];
    this.connections = [];
    this.tasks = [];
    this.particles = [];
    this.bossEvents = [];
    this.score = 0;
    this.level = 1;
    this.combo = 0;
    this.comboTimer = 0;
    this.maxCombo = 0;
    this.time = 0;
    this.taskSpawnTimer = 0;
    this.bossTimer = 60;
    this.boostCooldown = 0;
    this.emergencyCooldown = 0;
    this.tasksCompleted = 0;
    this.tasksFailed = 0;
    this.totalAgentsPlaced = 0;
    this.bossesDefeated = 0;
    this.networkHealth = 100;
    this.tasksThisLevel = 0;
    this.tasksForLevel = 5 + this.level * 2;
    this.scenario = SCENARIOS[0];
    this.scenarioTimer = 0;
    this.isDragging = false;
    this.dragAgent = null;
    this.state = 'PLAYING';
    this.showUI(true);
    this.audio.startDrone();
    if (!this.saves.hasTutorial()) {
      this.showTutorial();
    }
    this.lastTime = performance.now();
    if (!this.frameId) this.gameLoop(this.lastTime);
  }

  showTutorial() {
    document.getElementById('tutorial-screen').style.display = 'flex';
    this.state = 'PAUSED';
    this.tutorialShown = true;
  }

  pause() {
    this.state = 'PAUSED';
    document.getElementById('pause-screen').classList.remove('hidden');
    document.getElementById('pause-stats').textContent =
      'Level: ' + this.level + ' | Score: ' + this.score + ' | Agents: ' + this.agents.filter(a => a.alive).length;
    this.audio.stopDrone();
  }

  resume() {
    this.state = 'PLAYING';
    document.getElementById('pause-screen').classList.add('hidden');
    this.lastTime = performance.now();
    this.audio.startDrone();
  }

  quitToTitle() {
    this.state = 'MENU';
    this.audio.stopDrone();
    if (this.frameId) { cancelAnimationFrame(this.frameId); this.frameId = null; }
    this.showUI(false);
    document.getElementById('title-screen').classList.remove('hidden');
    document.getElementById('pause-screen').classList.add('hidden');
    document.getElementById('gameover-screen').classList.add('hidden');
    this.drawTitleBackground();
  }

  showUI(visible) {
    const d = visible ? '' : 'none';
    document.getElementById('hud').style.display = visible ? 'flex' : 'none';
    document.getElementById('agent-bar').style.display = d;
    document.getElementById('ability-bar').style.display = d;
    if (visible) {
      document.getElementById('title-screen').classList.add('hidden');
      document.getElementById('gameover-screen').classList.add('hidden');
      document.getElementById('pause-screen').classList.add('hidden');
    }
  }

  gameOver() {
    this.state = 'GAME_OVER';
    this.audio.stopDrone();
    this.audio.play('fail');
    // Determine ending
    let ending, endTitle;
    const efficiency = this.tasksCompleted > 0 ? this.score / (this.time + 1) : 0;
    if (this.score >= 5000 && this.level >= 10) {
      endTitle = 'THE SINGULARITY';
      ending = 'Your network achieved perfect autonomy. The agents now anticipate needs before they arise. Humanity prospers under your digital stewardship.';
    } else if (this.score >= 2500 && this.level >= 6) {
      endTitle = 'OPTIMAL NETWORK';
      ending = 'An exceptionally well-designed network. Your agents work in perfect harmony, handling tasks with remarkable efficiency.';
    } else if (this.score >= 1000 && this.level >= 3) {
      endTitle = 'SUSTAINABLE NETWORK';
      ending = 'A solid foundation. Your network handles most challenges, though there is room for optimization.';
    } else {
      endTitle = 'NETWORK COLLAPSE';
      ending = 'The network could not sustain the growing demands. Business needs overwhelmed your agents. Rebuild and try again.';
    }
    document.getElementById('go-title').textContent = endTitle;
    document.getElementById('go-ending').textContent = ending;
    document.getElementById('go-stats').innerHTML =
      '<div><span>Final Level</span><span>' + this.level + '</span></div>' +
      '<div><span>Score</span><span>' + this.score + '</span></div>' +
      '<div><span>Tasks Completed</span><span>' + this.tasksCompleted + '</span></div>' +
      '<div><span>Tasks Failed</span><span>' + this.tasksFailed + '</span></div>' +
      '<div><span>Max Combo</span><span>x' + this.maxCombo + '</span></div>' +
      '<div><span>Agents Deployed</span><span>' + this.totalAgentsPlaced + '</span></div>' +
      '<div><span>Bosses Survived</span><span>' + this.bossesDefeated + '</span></div>' +
      '<div><span>Time</span><span>' + this.formatTime(this.time) + '</span></div>' +
      '<div><span>Difficulty</span><span>' + this.diffConfig.label + '</span></div>';
    // Save score
    const scores = this.saves.saveScore({
      score: this.score, level: this.level, diff: this.difficulty,
      time: Math.floor(this.time), date: new Date().toISOString()
    });
    // Render leaderboard
    let lbHtml = '<h3>TOP SCORES</h3>';
    scores.forEach((s, i) => {
      const isCurrent = s.score === this.score && s.level === this.level;
      lbHtml += '<div class="lb-entry' + (isCurrent ? ' current' : '') + '">' +
        '<span>#' + (i + 1) + ' Lv' + s.level + ' ' + (DIFFICULTY[s.diff] ? DIFFICULTY[s.diff].label : s.diff) + '</span>' +
        '<span>' + s.score + '</span></div>';
    });
    document.getElementById('go-leaderboard').innerHTML = lbHtml;
    document.getElementById('gameover-screen').classList.remove('hidden');
    document.getElementById('hud').style.display = 'none';
  }

  formatTime(t) {
    const m = Math.floor(t / 60);
    const s = Math.floor(t % 60);
    return m + ':' + (s < 10 ? '0' : '') + s;
  }

  // ---------- UPDATE ----------
  update(dt) {
    if (this.state !== 'PLAYING') return;
    this.time += dt;

    // Combo decay
    if (this.comboTimer > 0) {
      this.comboTimer -= dt;
      if (this.comboTimer <= 0) this.combo = 0;
    }

    // Cooldowns
    this.boostCooldown = Math.max(0, this.boostCooldown - dt);
    this.emergencyCooldown = Math.max(0, this.emergencyCooldown - dt);

    // Task spawning
    this.taskSpawnTimer -= dt;
    const spawnInterval = Math.max(1, 4 - this.level * 0.2) / this.diffConfig.taskRate;
    if (this.taskSpawnTimer <= 0 && this.tasks.length < 15 + this.level * 2) {
      this.taskSpawnTimer = spawnInterval;
      this.spawnTask();
    }

    // Boss timer
    this.bossTimer -= dt;
    if (this.bossTimer <= 0) {
      this.bossTimer = 60;
      this.triggerBossEvent();
    }

    // Scenario rotation every 3 levels
    const scenarioIdx = Math.floor((this.level - 1) / 3) % SCENARIOS.length;
    this.scenario = SCENARIOS[scenarioIdx];

    // Update agents
    for (let i = this.agents.length - 1; i >= 0; i--) {
      const agent = this.agents[i];
      if (!agent.alive) {
        this.removeAgentConnections(agent);
        continue;
      }
      const result = agent.update(dt);
      if (result && result.completed) {
        this.onTaskCompleted(agent, result.completed);
      }
      // Optimizer effect: boost efficiency of connected agents
      if (agent.type.specialty === 'optimize') {
        for (const conn of agent.connections) {
          if (!conn.active) continue;
          const other = conn.agentA === agent ? conn.agentB : conn.agentA;
          if (other.alive) other.efficiency = Math.max(other.efficiency, 1.0 + agent.level * 0.1);
        }
      }
    }
    this.agents = this.agents.filter(a => a.alive);

    // Update connections
    for (const conn of this.connections) {
      if (conn.active) {
        conn.update(dt);
        // Fix particle tracking
        for (let i = conn.particles.length - 1; i >= 0; i--) {
          const p = conn.particles[i];
          p.progress += dt * conn.speed * 1.5;
          const t = Math.min(1, p.progress);
          p.x = conn.agentA.x + (conn.agentB.x - conn.agentA.x) * t;
          p.y = conn.agentA.y + (conn.agentB.y - conn.agentA.y) * t;
          if (p.progress >= 1) conn.particles.splice(i, 1);
        }
        // Spawn data flow particles
        conn.dataFlowTimer += dt;
        if (conn.dataFlowTimer > 0.5 / conn.speed) {
          conn.dataFlowTimer = 0;
          conn.particles.push({
            x: conn.agentA.x, y: conn.agentA.y,
            progress: 0, color: conn.agentA.type.color,
            size: 2 + Math.random() * 2
          });
        }
      }
    }
    this.connections = this.connections.filter(c => c.active);

    // Update tasks
    for (let i = this.tasks.length - 1; i >= 0; i--) {
      const task = this.tasks[i];
      if (!task.alive) { this.tasks.splice(i, 1); continue; }
      const result = task.update(dt);
      if (result && result.expired) {
        this.onTaskFailed(task);
        this.tasks.splice(i, 1);
      }
      // Re-assign unassigned tasks
      if (!task.assignedAgent || !task.assignedAgent.alive) {
        task.assignedAgent = null;
        task.progress = Math.max(0, task.progress - dt * 5);
        this.autoAssignTask(task);
      }
    }

    // Update boss events
    for (let i = this.bossEvents.length - 1; i >= 0; i--) {
      const boss = this.bossEvents[i];
      const result = boss.update(dt);
      if (result) {
        if (result.applyEffect) this.applyBossEffect(result.applyEffect);
        if (result.ended) { this.bossEvents.splice(i, 1); }
      }
    }

    // Update particles
    for (const p of this.particles) p.update(dt);
    this.particles = this.particles.filter(p => p.alive);

    // Ambient particles
    for (const p of this.ambientParticles) {
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      if (p.x < 0 || p.x > this.canvas.width) p.vx *= -1;
      if (p.y < 0 || p.y > this.canvas.height) p.vy *= -1;
      p.x = Math.max(0, Math.min(this.canvas.width, p.x));
      p.y = Math.max(0, Math.min(this.canvas.height, p.y));
    }

    // Screen shake decay
    if (this.shake.intensity > 0) {
      this.shake.x = (Math.random() - 0.5) * this.shake.intensity * 2;
      this.shake.y = (Math.random() - 0.5) * this.shake.intensity * 2;
      this.shake.intensity *= 0.9;
      if (this.shake.intensity < 0.3) { this.shake.intensity = 0; this.shake.x = 0; this.shake.y = 0; }
    }

    // Network health
    const aliveAgents = this.agents.filter(a => a.alive).length;
    if (aliveAgents === 0 && this.totalAgentsPlaced > 0 && this.time > 10) {
      this.networkHealth -= dt * 20;
    } else if (this.tasksFailed > this.tasksCompleted * 2 && this.time > 30) {
      this.networkHealth -= dt * 5;
    } else {
      this.networkHealth = Math.min(100, this.networkHealth + dt * 0.5);
    }
    if (this.networkHealth <= 0) {
      this.gameOver();
      return;
    }

    // Level progression
    if (this.tasksThisLevel >= this.tasksForLevel) {
      this.level++;
      this.tasksThisLevel = 0;
      this.tasksForLevel = 5 + this.level * 2;
      this.audio.play('level-up');
      this.spawnParticleBurst(this.canvas.width / 2, 40, '#ffaa44', 25, 100);
    }

    // Update HUD
    this.updateHUD();
    this.updateAbilityUI();
  }

  onTaskCompleted(agent, task) {
    const comboMult = Math.max(1, 1 + this.combo * 0.3);
    const reward = Math.floor(task.reward * comboMult * agent.efficiency);
    this.score += reward;
    this.tasksCompleted++;
    this.tasksThisLevel++;
    this.combo++;
    this.comboTimer = 3;
    if (this.combo > this.maxCombo) this.maxCombo = this.combo;
    agent.completeTask();
    task.alive = false;
    this.audio.play('task-complete');
    this.spawnParticleBurst(agent.x, agent.y, '#ffea00', 15, 70);
    this.spawnParticleBurst(task.x, task.y, task.taskType.color, 10, 50);
    // Remove from tasks array
    const idx = this.tasks.indexOf(task);
    if (idx >= 0) this.tasks.splice(idx, 1);
  }

  onTaskFailed(task) {
    this.tasksFailed++;
    this.combo = 0;
    this.comboTimer = 0;
    this.networkHealth -= 5;
    this.score = Math.max(0, this.score - 50);
    this.audio.play('fail');
    this.spawnParticleBurst(task.x, task.y, '#ff4444', 12, 60);
    this.addShake(3);
  }

  removeAgentConnections(agent) {
    for (const conn of agent.connections) {
      conn.active = false;
    }
    agent.connections = [];
  }

  updateHUD() {
    document.getElementById('hud-level').textContent = this.level;
    document.getElementById('hud-score').textContent = this.score;
    document.getElementById('hud-tasks').textContent = this.tasks.filter(t => t.alive).length;
    document.getElementById('hud-agents').textContent = this.agents.filter(a => a.alive).length;
    document.getElementById('hud-time').textContent = this.formatTime(this.time);
    const comboEl = document.getElementById('hud-combo');
    comboEl.textContent = this.combo > 1 ? 'x' + this.combo + ' COMBO' : '';
  }

  updateAbilityUI() {
    const boostBtn = document.getElementById('ab-boost');
    const emergBtn = document.getElementById('ab-emergency');
    if (this.boostCooldown > 0) {
      boostBtn.classList.add('on-cooldown');
      let cd = boostBtn.querySelector('.cd-text');
      if (!cd) { cd = document.createElement('span'); cd.className = 'cd-text'; boostBtn.appendChild(cd); }
      cd.textContent = Math.ceil(this.boostCooldown) + 's';
    } else {
      boostBtn.classList.remove('on-cooldown');
      const cd = boostBtn.querySelector('.cd-text');
      if (cd) cd.remove();
    }
    if (this.emergencyCooldown > 0) {
      emergBtn.classList.add('on-cooldown');
      let cd = emergBtn.querySelector('.cd-text');
      if (!cd) { cd = document.createElement('span'); cd.className = 'cd-text'; emergBtn.appendChild(cd); }
      cd.textContent = Math.ceil(this.emergencyCooldown) + 's';
    } else {
      emergBtn.classList.remove('on-cooldown');
      const cd = emergBtn.querySelector('.cd-text');
      if (cd) cd.remove();
    }
  }

  // ---------- DRAW ----------
  draw() {
    const ctx = this.ctx;
    const w = this.canvas.width;
    const h = this.canvas.height;
    ctx.save();
    ctx.translate(this.shake.x, this.shake.y);

    // Background gradient
    const bgGrad = ctx.createLinearGradient(0, 0, w, h);
    bgGrad.addColorStop(0, '#0a0a1a');
    bgGrad.addColorStop(1, '#1a1a3a');
    ctx.fillStyle = bgGrad;
    ctx.fillRect(0, 0, w, h);

    // Grid
    this.drawGrid(ctx, w, h);

    // Ambient particles
    for (const p of this.ambientParticles) {
      ctx.fillStyle = 'rgba(0, 229, 255, ' + (p.alpha * 0.15) + ')';
      ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill();
    }

    // Boss event overlays
    for (const boss of this.bossEvents) {
      boss.draw(ctx, w, h);
    }

    // Connections (draw first, behind agents)
    for (const conn of this.connections) {
      if (conn.active) this.drawConnection(ctx, conn);
    }

    // Drag preview line
    if (this.isDragging && this.dragAgent) {
      ctx.strokeStyle = '#00e5ff66';
      ctx.lineWidth = 2;
      ctx.setLineDash([8, 4]);
      ctx.beginPath();
      ctx.moveTo(this.dragAgent.x, this.dragAgent.y);
      ctx.lineTo(this.mouseX, this.mouseY);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // Tasks
    for (const task of this.tasks) {
      if (task.alive) task.draw(ctx);
    }

    // Agents
    const time = this.time;
    for (const agent of this.agents) {
      if (agent.alive) agent.draw(ctx, time);
    }

    // Task-to-agent assignment lines
    for (const task of this.tasks) {
      if (task.alive && task.assignedAgent && task.assignedAgent.alive) {
        ctx.strokeStyle = task.taskType.color + '44';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.moveTo(task.x, task.y);
        ctx.lineTo(task.assignedAgent.x, task.assignedAgent.y);
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }

    // Particles
    for (const p of this.particles) p.draw(ctx);

    // Network health bar
    this.drawNetworkHealth(ctx, w);

    // Scenario label
    ctx.fillStyle = this.scenario.color + '88';
    ctx.font = '11px sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText('Scenario: ' + this.scenario.name, w - 20, h - 15);

    ctx.restore();
  }

  drawGrid(ctx, w, h) {
    ctx.strokeStyle = 'rgba(0, 229, 255, 0.04)';
    ctx.lineWidth = 1;
    const gridSize = 60;
    for (let x = 0; x < w; x += gridSize) {
      ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
    }
    for (let y = 0; y < h; y += gridSize) {
      ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
    }
  }

  drawConnection(ctx, conn) {
    const a = conn.agentA, b = conn.agentB;
    const alpha = conn.boosted ? 0.6 : 0.25;
    ctx.strokeStyle = conn.boosted ? '#00e5ff' : '#334455';
    ctx.lineWidth = conn.boosted ? 3 : 1.5;
    ctx.globalAlpha = alpha;
    ctx.beginPath();
    ctx.moveTo(a.x, a.y);
    ctx.lineTo(b.x, b.y);
    ctx.stroke();
    ctx.globalAlpha = 1;
    // Data flow particles
    for (const p of conn.particles) {
      ctx.fillStyle = p.color;
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
    // Strength indicator at midpoint
    if (conn.strength > 1.5) {
      const mx = (a.x + b.x) / 2, my = (a.y + b.y) / 2;
      ctx.fillStyle = '#ffaa44';
      ctx.font = '8px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('x' + conn.strength.toFixed(1), mx, my - 5);
    }
  }

  drawNetworkHealth(ctx, w) {
    const bw = 200, bh = 8;
    const bx = (w - bw) / 2, by = this.canvas.height - 12;
    ctx.fillStyle = '#111';
    ctx.fillRect(bx, by, bw, bh);
    const healthPct = this.networkHealth / 100;
    const healthColor = healthPct > 0.5 ? '#44ff88' : healthPct > 0.25 ? '#ffaa44' : '#ff4444';
    ctx.fillStyle = healthColor;
    ctx.fillRect(bx, by, bw * healthPct, bh);
    ctx.strokeStyle = '#334';
    ctx.strokeRect(bx, by, bw, bh);
    ctx.fillStyle = '#888';
    ctx.font = '9px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Network Health', w / 2, by - 3);
  }

  // ---------- TITLE BACKGROUND ----------
  drawTitleBackground() {
    if (this.state !== 'MENU') return;
    const ctx = this.ctx;
    const w = this.canvas.width, h = this.canvas.height;
    ctx.fillStyle = 'rgba(10, 10, 26, 0.15)';
    ctx.fillRect(0, 0, w, h);
    const t = Date.now() * 0.001;
    // Animated nodes
    for (let i = 0; i < 15; i++) {
      const x = (Math.sin(t * 0.2 + i * 1.3) * 0.4 + 0.5) * w;
      const y = (Math.cos(t * 0.15 + i * 1.8) * 0.4 + 0.5) * h;
      const color = AGENT_TYPES[i % 5].color;
      ctx.fillStyle = color + '15';
      ctx.beginPath(); ctx.arc(x, y, 25 + Math.sin(t + i) * 8, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = color + '33';
      ctx.beginPath(); ctx.arc(x, y, 8, 0, Math.PI * 2); ctx.fill();
      // Connect to next
      const j = (i + 1) % 15;
      const x2 = (Math.sin(t * 0.2 + j * 1.3) * 0.4 + 0.5) * w;
      const y2 = (Math.cos(t * 0.15 + j * 1.8) * 0.4 + 0.5) * h;
      ctx.strokeStyle = color + '0a';
      ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x2, y2); ctx.stroke();
    }
    requestAnimationFrame(() => this.drawTitleBackground());
  }

  // ---------- GAME LOOP ----------
  gameLoop(timestamp) {
    this.frameId = requestAnimationFrame((ts) => this.gameLoop(ts));
    const dt = Math.min((timestamp - this.lastTime) / 1000, 0.05);
    this.lastTime = timestamp;
    if (this.state === 'PLAYING') {
      this.update(dt);
      this.draw();
    }
  }
}

// ============================================================
// GLOBAL HELPERS
// ============================================================
let game;

function selectAgentType(idx) {
  if (game) game.selectedAgentType = idx;
  document.querySelectorAll('.agent-slot').forEach((el, i) => {
    el.classList.toggle('selected', i === idx);
  });
}

function useBoost() { if (game) game.useBoostAbility(); }
function useEmergency() { if (game) game.useEmergencyAbility(); }

function closeTutorial() {
  document.getElementById('tutorial-screen').style.display = 'none';
  if (game) {
    game.saves.setTutorial();
    game.state = 'PLAYING';
    game.lastTime = performance.now();
  }
}

// ============================================================
// INITIALIZATION
// ============================================================
document.addEventListener('DOMContentLoaded', () => {
  game = new Game();
});

</script>
</body>
</html>