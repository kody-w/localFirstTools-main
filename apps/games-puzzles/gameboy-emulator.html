<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Boy DMG Emulator</title>
    <meta name="rappterzoo:author" content="copilot-agent">
    <meta name="rappterzoo:author-type" content="agent">
    <meta name="rappterzoo:category" content="games-puzzles">
    <meta name="rappterzoo:tags" content="emulator,gameboy,retro,hardware">
    <meta name="rappterzoo:type" content="interactive">
    <meta name="rappterzoo:complexity" content="advanced">
    <meta name="rappterzoo:created" content="2025-01-20">
    <meta name="rappterzoo:generation" content="1">
    <style>
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:'Segoe UI',system-ui,sans-serif;background:#1a1a2e;color:#e0e0e0;min-height:100vh;display:flex;justify-content:center;align-items:flex-start;padding:20px;overflow-x:hidden}
.app-wrap{display:flex;gap:20px;max-width:1400px;width:100%;flex-wrap:wrap;justify-content:center}
/* Game Boy Shell */
.gb-shell{background:linear-gradient(145deg,#c8c4bf,#b0aca6);border-radius:20px 20px 80px 20px;padding:25px 20px 40px;width:380px;box-shadow:6px 6px 20px rgba(0,0,0,0.5),-2px -2px 6px rgba(255,255,255,0.1);position:relative;flex-shrink:0}
.gb-shell::before{content:'DOT MATRIX WITH STEREO SOUND';position:absolute;top:70px;left:50%;transform:translateX(-50%);font-size:7px;letter-spacing:2px;color:#555;font-weight:bold}
.gb-brand{text-align:center;font-weight:bold;font-size:14px;color:#333;margin-bottom:8px;font-style:italic;letter-spacing:2px}
.gb-brand span{color:#8b1a1a;font-size:18px}
.screen-bezel{background:linear-gradient(145deg,#555,#3a3a3a);border-radius:12px 12px 12px 40px;padding:15px 15px 20px;margin:5px auto 15px;width:320px}
.screen-inner{background:#0f380f;border-radius:6px;overflow:hidden;position:relative}
.screen-label{color:#aaa;font-size:8px;text-align:center;margin-top:6px;letter-spacing:1px}
#screen{display:block;width:320px;height:288px;image-rendering:pixelated;image-rendering:crisp-edges}
.power-led{width:8px;height:8px;border-radius:50%;background:#333;position:absolute;left:15px;top:15px;box-shadow:0 0 2px #000}
.power-led.on{background:#9bbc0f;box-shadow:0 0 8px #9bbc0f}
/* Controls layout */
.gb-controls{display:flex;justify-content:space-between;padding:0 15px;margin-top:20px}
.dpad{width:90px;height:90px;position:relative}
.dpad-btn{position:absolute;background:#222;border:none;color:#fff;cursor:pointer;-webkit-tap-highlight-color:transparent}
.dpad-btn:active,.dpad-btn.pressed{background:#444}
.dpad-up{width:30px;height:32px;left:30px;top:0;border-radius:4px 4px 0 0}
.dpad-down{width:30px;height:32px;left:30px;bottom:0;border-radius:0 0 4px 4px}
.dpad-left{width:32px;height:30px;left:0;top:30px;border-radius:4px 0 0 4px}
.dpad-right{width:32px;height:30px;right:0;top:30px;border-radius:0 4px 4px 0}
.dpad-center{position:absolute;width:30px;height:30px;left:30px;top:30px;background:#222;pointer-events:none}
.ab-btns{display:flex;gap:10px;align-items:center;transform:rotate(-25deg);margin-top:15px}
.ab-btn{width:48px;height:48px;border-radius:50%;background:#8b1a1a;border:none;color:#fff;font-weight:bold;font-size:13px;cursor:pointer;box-shadow:2px 2px 5px rgba(0,0,0,0.5);-webkit-tap-highlight-color:transparent}
.ab-btn:active,.ab-btn.pressed{background:#6b0a0a;box-shadow:1px 1px 3px rgba(0,0,0,0.5)}
.ss-btns{display:flex;gap:15px;justify-content:center;margin-top:15px}
.ss-btn{width:50px;height:14px;border-radius:7px;background:#555;border:none;color:#999;font-size:8px;cursor:pointer;transform:rotate(-25deg);-webkit-tap-highlight-color:transparent}
.ss-btn:active,.ss-btn.pressed{background:#777}
.ss-labels{display:flex;gap:15px;justify-content:center;margin-top:4px}
.ss-labels span{font-size:8px;color:#555;font-weight:bold;text-transform:uppercase;width:50px;text-align:center}
/* Speaker grille */
.speaker{position:absolute;bottom:15px;right:15px;display:grid;grid-template-columns:repeat(6,4px);gap:3px;transform:rotate(-30deg)}
.speaker-dot{width:4px;height:4px;border-radius:50%;background:#999}
/* Side panel */
.side-panel{flex:1;min-width:320px;max-width:600px;display:flex;flex-direction:column;gap:12px}
.panel-card{background:#16213e;border-radius:10px;padding:15px;box-shadow:0 4px 15px rgba(0,0,0,0.3)}
.panel-card h3{margin:0 0 10px;color:#9bbc0f;font-size:14px}
/* Toolbar */
.toolbar{display:flex;flex-wrap:wrap;gap:6px;align-items:center}
.toolbar button,.toolbar label{background:#1a1a3e;color:#9bbc0f;border:1px solid #333;padding:6px 12px;border-radius:6px;font-size:12px;cursor:pointer;transition:all .15s}
.toolbar button:hover,.toolbar label:hover{background:#252550;border-color:#9bbc0f}
.toolbar button.active{background:#306230;border-color:#9bbc0f}
.toolbar button:disabled{opacity:0.4;cursor:not-allowed}
input[type="file"]{display:none}
.toolbar .sep{width:1px;height:20px;background:#333}
#fps-display{font-family:monospace;color:#8bac0f;font-size:12px;margin-left:auto}
#status-bar{color:#888;font-size:11px;text-align:center;padding:4px}
/* Debug panel */
.debug-panel{display:none;max-height:500px;overflow-y:auto}
.debug-panel.show{display:block}
.debug-section{margin-bottom:10px}
.debug-section h4{color:#8bac0f;font-size:12px;margin:0 0 5px;cursor:pointer}
.debug-section h4:hover{color:#9bbc0f}
.reg-grid{display:grid;grid-template-columns:repeat(4,1fr);gap:3px;font-family:monospace;font-size:11px}
.reg-item{background:#0a0a1a;padding:3px 5px;border-radius:3px}
.reg-item .label{color:#666;font-size:9px}
.reg-item .val{color:#9bbc0f}
.flag-grid{display:flex;gap:8px;font-family:monospace;font-size:11px}
.flag-item{padding:2px 6px;border-radius:3px;background:#0a0a1a}
.flag-item.set{color:#9bbc0f;background:#1a2a0f}
.flag-item.clear{color:#444}
#disasm-view,#mem-view{font-family:monospace;font-size:10px;background:#0a0a1a;padding:6px;border-radius:4px;white-space:pre;line-height:1.4;max-height:200px;overflow-y:auto;color:#8bac0f}
#tile-canvas{border:1px solid #333;border-radius:4px;image-rendering:pixelated;image-rendering:crisp-edges;background:#0f380f;width:256px;height:192px}
/* Palette selector */
.palette-row{display:flex;gap:8px;align-items:center;font-size:11px}
.palette-opt{display:flex;gap:2px;cursor:pointer;padding:3px 6px;border-radius:4px;border:1px solid transparent}
.palette-opt.active{border-color:#9bbc0f}
.palette-swatch{width:14px;height:14px;border-radius:2px}
/* Controls help */
.help-grid{display:grid;grid-template-columns:auto 1fr;gap:4px 12px;font-size:11px}
.help-grid kbd{background:#222;padding:1px 5px;border-radius:3px;font-family:monospace;color:#9bbc0f;font-size:10px}
/* Drag overlay */
.drag-overlay{display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.8);z-index:999;justify-content:center;align-items:center;font-size:24px;color:#9bbc0f}
.drag-overlay.show{display:flex}
@media(max-width:800px){
.app-wrap{flex-direction:column;align-items:center}
.side-panel{min-width:0;width:100%;max-width:380px}
}
    </style>
</head>
<body>
<div class="drag-overlay" id="drag-overlay">Drop .gb ROM file here</div>
<div class="app-wrap">
<!-- Game Boy Shell -->
<div class="gb-shell">
<div class="gb-brand">Nintendo <span>GAME BOY</span>&#x2122;</div>
<div class="screen-bezel">
<div class="power-led" id="power-led"></div>
<div class="screen-inner">
<canvas id="screen" width="160" height="144"></canvas>
</div>
<div class="screen-label">&#x25CF; BATTERY</div>
</div>
<div class="gb-controls">
<div class="dpad">
<button class="dpad-btn dpad-up" data-btn="up"></button>
<button class="dpad-btn dpad-down" data-btn="down"></button>
<button class="dpad-btn dpad-left" data-btn="left"></button>
<button class="dpad-btn dpad-right" data-btn="right"></button>
<div class="dpad-center"></div>
</div>
<div class="ab-btns">
<button class="ab-btn" data-btn="b">B</button>
<button class="ab-btn" data-btn="a">A</button>
</div>
</div>
<div class="ss-btns">
<button class="ss-btn" data-btn="select"></button>
<button class="ss-btn" data-btn="start"></button>
</div>
<div class="ss-labels"><span>SELECT</span><span>START</span></div>
<div class="speaker" aria-hidden="true"></div>
</div>

<!-- Side Panel -->
<div class="side-panel">
<div class="panel-card">
<div class="toolbar">
<label for="rom-input">&#x1F4C2; Load ROM</label>
<input type="file" id="rom-input" accept=".gb,.gbc,.bin">
<div class="sep"></div>
<button id="btn-play" disabled title="Play/Pause">&#x25B6; Play</button>
<button id="btn-reset" disabled title="Reset">&#x21BB; Reset</button>
<button id="btn-step" disabled title="Step one instruction">Step</button>
<div class="sep"></div>
<button id="btn-speed" disabled>1x</button>
<button id="btn-mute" title="Toggle audio">&#x1F50A;</button>
<button id="btn-debug" title="Toggle debug panel">Debug</button>
<button id="btn-save" disabled title="Save state">Save</button>
<button id="btn-load" disabled title="Load state">Load</button>
<span id="fps-display">-- FPS</span>
</div>
<div id="status-bar">Drag &amp; drop a .gb ROM or click Load ROM</div>
</div>

<div class="panel-card">
<h3>Palette</h3>
<div class="palette-row">
<div class="palette-opt active" data-palette="green"><div class="palette-swatch" style="background:#9bbc0f"></div><div class="palette-swatch" style="background:#8bac0f"></div><div class="palette-swatch" style="background:#306230"></div><div class="palette-swatch" style="background:#0f380f"></div> Green</div>
<div class="palette-opt" data-palette="gray"><div class="palette-swatch" style="background:#fff"></div><div class="palette-swatch" style="background:#aaa"></div><div class="palette-swatch" style="background:#555"></div><div class="palette-swatch" style="background:#000"></div> Gray</div>
<div class="palette-opt" data-palette="brown"><div class="palette-swatch" style="background:#e8d4a2"></div><div class="palette-swatch" style="background:#d0a870"></div><div class="palette-swatch" style="background:#8b6914"></div><div class="palette-swatch" style="background:#3e2500"></div> Brown</div>
</div>
</div>

<div class="panel-card">
<h3>Controls</h3>
<div class="help-grid">
<kbd>&#x2190;&#x2191;&#x2192;&#x2193;</kbd><span>D-Pad</span>
<kbd>Z</kbd><span>B Button</span>
<kbd>X</kbd><span>A Button</span>
<kbd>Enter</kbd><span>Start</span>
<kbd>Shift</kbd><span>Select</span>
<kbd>Space</kbd><span>Turbo (hold)</span>
<kbd>P</kbd><span>Pause</span>
<kbd>R</kbd><span>Reset</span>
</div>
</div>

<div class="panel-card">
<h3>Debug <span style="color:#666;font-size:11px">(toggle with Debug button)</span></h3>
<div class="debug-panel" id="debug-panel">
<div class="debug-section">
<h4>CPU Registers</h4>
<div class="reg-grid" id="reg-display"></div>
<div class="flag-grid" id="flag-display" style="margin-top:5px"></div>
</div>
<div class="debug-section">
<h4>Disassembly</h4>
<div id="disasm-view"></div>
</div>
<div class="debug-section">
<h4>VRAM Tiles</h4>
<canvas id="tile-canvas" width="128" height="192"></canvas>
</div>
<div class="debug-section">
<h4>Memory</h4>
<div id="mem-view"></div>
</div>
</div>
</div>
</div>
</div>

    <script>
        // ===== Game Boy DMG Emulator - Complete Implementation =====
        // Sharp LR35902 CPU, PPU scanline renderer, APU, Timer, MBC1, Joypad

        // Generate speaker grille dots
        (function(){const s=document.querySelector('.speaker');for(let i=0;i<18;i++){const d=document.createElement('div');d.className='speaker-dot';s.appendChild(d)}})();

        // ==================== MMU (Memory Management Unit) ====================
        class MMU {
            constructor() { this.reset(); }
            reset() {
                this.romBanks = null; this.romBank = 1;
                this.vram = new Uint8Array(0x2000);
                this.eram = new Uint8Array(0x8000); // External RAM (up to 32KB for MBC1)
                this.wram = new Uint8Array(0x2000);
                this.oam = new Uint8Array(0xA0);
                this.io = new Uint8Array(0x80);
                this.hram = new Uint8Array(0x7F);
                this.ie = 0; // Interrupt Enable 0xFFFF
                // MBC1 state
                this.mbcType = 0; this.ramEnable = false;
                this.ramBank = 0; this.mbcMode = 0;
                // Init IO registers to post-boot values
                this.io[0x00]=0xCF;this.io[0x01]=0x00;this.io[0x02]=0x7E;
                this.io[0x04]=0xAB;this.io[0x05]=0x00;this.io[0x06]=0x00;this.io[0x07]=0xF8;
                this.io[0x0F]=0xE1;this.io[0x10]=0x80;this.io[0x11]=0xBF;this.io[0x12]=0xF3;
                this.io[0x14]=0xBF;this.io[0x16]=0x3F;this.io[0x17]=0x00;this.io[0x19]=0xBF;
                this.io[0x1A]=0x7F;this.io[0x1B]=0xFF;this.io[0x1C]=0x9F;this.io[0x1E]=0xBF;
                this.io[0x20]=0xFF;this.io[0x21]=0x00;this.io[0x22]=0x00;this.io[0x23]=0xBF;
                this.io[0x24]=0x77;this.io[0x25]=0xF3;this.io[0x26]=0xF1;
                this.io[0x40]=0x91;this.io[0x41]=0x85;this.io[0x42]=0x00;this.io[0x43]=0x00;
                this.io[0x44]=0x00;this.io[0x45]=0x00;this.io[0x46]=0xFF;this.io[0x47]=0xFC;
                this.io[0x48]=0xFF;this.io[0x49]=0xFF;this.io[0x4A]=0x00;this.io[0x4B]=0x00;
            }
            loadROM(data) {
                this.romData = new Uint8Array(data);
                const cartType = data[0x147];
                if (cartType >= 1 && cartType <= 3) this.mbcType = 1;
                else this.mbcType = 0;
                const romSizeCode = data[0x148];
                const numBanks = 2 << romSizeCode;
                this.romBanks = new Array(numBanks);
                for (let b = 0; b < numBanks; b++) {
                    this.romBanks[b] = new Uint8Array(0x4000);
                    for (let i = 0; i < 0x4000; i++) {
                        const addr = b * 0x4000 + i;
                        this.romBanks[b][i] = addr < data.length ? data[addr] : 0;
                    }
                }
                this.romBank = 1;
            }
            readByte(addr) {
                addr &= 0xFFFF;
                if (addr < 0x4000) {
                    return this.romBanks ? this.romBanks[0][addr] : 0xFF;
                } else if (addr < 0x8000) {
                    const bank = this.romBank || 1;
                    return this.romBanks ? this.romBanks[bank % this.romBanks.length][addr - 0x4000] : 0xFF;
                } else if (addr < 0xA000) {
                    return this.vram[addr - 0x8000];
                } else if (addr < 0xC000) {
                    if (this.ramEnable) return this.eram[(this.ramBank * 0x2000) + (addr - 0xA000)];
                    return 0xFF;
                } else if (addr < 0xE000) {
                    return this.wram[addr - 0xC000];
                } else if (addr < 0xFE00) {
                    return this.wram[addr - 0xE000]; // Echo RAM
                } else if (addr < 0xFEA0) {
                    return this.oam[addr - 0xFE00];
                } else if (addr < 0xFF00) {
                    return 0xFF; // Unusable
                } else if (addr < 0xFF80) {
                    return this.readIO(addr);
                } else if (addr < 0xFFFF) {
                    return this.hram[addr - 0xFF80];
                } else {
                    return this.ie;
                }
            }
            writeByte(addr, val) {
                addr &= 0xFFFF; val &= 0xFF;
                if (addr < 0x2000) {
                    if (this.mbcType === 1) this.ramEnable = (val & 0x0F) === 0x0A;
                } else if (addr < 0x4000) {
                    if (this.mbcType === 1) {
                        let bank = val & 0x1F; if (bank === 0) bank = 1;
                        this.romBank = (this.romBank & 0x60) | bank;
                    }
                } else if (addr < 0x6000) {
                    if (this.mbcType === 1) {
                        if (this.mbcMode === 0) this.romBank = (this.romBank & 0x1F) | ((val & 3) << 5);
                        else this.ramBank = val & 3;
                    }
                } else if (addr < 0x8000) {
                    if (this.mbcType === 1) this.mbcMode = val & 1;
                } else if (addr < 0xA000) {
                    this.vram[addr - 0x8000] = val;
                } else if (addr < 0xC000) {
                    if (this.ramEnable) this.eram[(this.ramBank * 0x2000) + (addr - 0xA000)] = val;
                } else if (addr < 0xE000) {
                    this.wram[addr - 0xC000] = val;
                } else if (addr < 0xFE00) {
                    this.wram[addr - 0xE000] = val;
                } else if (addr < 0xFEA0) {
                    this.oam[addr - 0xFE00] = val;
                } else if (addr < 0xFF00) {
                    // Unusable
                } else if (addr < 0xFF80) {
                    this.writeIO(addr, val);
                } else if (addr < 0xFFFF) {
                    this.hram[addr - 0xFF80] = val;
                } else {
                    this.ie = val;
                }
            }
            readIO(addr) {
                const reg = addr - 0xFF00;
                if (reg === 0x00) return this.getJoypad();
                return this.io[reg];
            }
            writeIO(addr, val) {
                const reg = addr - 0xFF00;
                if (reg === 0x00) { this.io[0x00] = (val & 0x30) | (this.io[0x00] & 0xCF); return; }
                if (reg === 0x04) { this.io[0x04] = 0; return; } // DIV reset
                if (reg === 0x44) { return; } // LY read-only
                if (reg === 0x46) { // DMA transfer
                    const src = val << 8;
                    for (let i = 0; i < 0xA0; i++) this.oam[i] = this.readByte(src + i);
                    this.io[reg] = val; return;
                }
                this.io[reg] = val;
            }
            getJoypad() {
                let result = this.io[0x00] | 0x0F;
                if (!(this.io[0x00] & 0x10)) { // Direction
                    if (this._joyDir !== undefined) result &= (0xF0 | this._joyDir);
                }
                if (!(this.io[0x00] & 0x20)) { // Buttons
                    if (this._joyBtn !== undefined) result &= (0xF0 | this._joyBtn);
                }
                return result;
            }
            readWord(addr) { return this.readByte(addr) | (this.readByte(addr+1) << 8); }
            writeWord(addr, val) { this.writeByte(addr, val & 0xFF); this.writeByte(addr+1, (val >> 8) & 0xFF); }
        }

        // ==================== CPU (Sharp LR35902) ====================
        class CPU {
            constructor(mmu) { this.mmu = mmu; this.reset(); }
            reset() {
                this.a = 0x01; this.b = 0x00; this.c = 0x13; this.d = 0x00;
                this.e = 0xD8; this.h = 0x01; this.l = 0x4D;
                this.sp = 0xFFFE; this.pc = 0x0100;
                this.fZ = 1; this.fN = 0; this.fH = 1; this.fC = 1;
                this.cycles = 0; this.halt = false; this.stop = false;
                this.ime = false; this.imeDelay = 0;
            }
            
            getF() { return (this.fZ << 7) | (this.fN << 6) | (this.fH << 5) | (this.fC << 4); }
            setF(v) { this.fZ = (v >> 7) & 1; this.fN = (v >> 6) & 1; this.fH = (v >> 5) & 1; this.fC = (v >> 4) & 1; }
            getAF() { return (this.a << 8) | this.getF(); }
            setAF(v) { this.a = (v >> 8) & 0xFF; this.setF(v & 0xF0); }
            getBC() { return (this.b << 8) | this.c; }
            setBC(v) { this.b = (v >> 8) & 0xFF; this.c = v & 0xFF; }
            getDE() { return (this.d << 8) | this.e; }
            setDE(v) { this.d = (v >> 8) & 0xFF; this.e = v & 0xFF; }
            getHL() { return (this.h << 8) | this.l; }
            setHL(v) { this.h = (v >> 8) & 0xFF; this.l = v & 0xFF; }
            // Register by index: 0=B 1=C 2=D 3=E 4=H 5=L 6=(HL) 7=A
            gr(i) { const R=[this.b,this.c,this.d,this.e,this.h,this.l,this.mmu.readByte(this.getHL()),this.a]; return R[i]; }
            sr(i,v) { switch(i){case 0:this.b=v;break;case 1:this.c=v;break;case 2:this.d=v;break;case 3:this.e=v;break;case 4:this.h=v;break;case 5:this.l=v;break;case 6:this.mmu.writeByte(this.getHL(),v);break;case 7:this.a=v;break;} }
            fb() { const v=this.mmu.readByte(this.pc); this.pc=(this.pc+1)&0xFFFF; return v; }
            fw() { const lo=this.fb(); return lo|(this.fb()<<8); }
            push16(v) { this.sp=(this.sp-2)&0xFFFF; this.mmu.writeByte(this.sp,v&0xFF); this.mmu.writeByte((this.sp+1)&0xFFFF,(v>>8)&0xFF); }
            pop16() { const lo=this.mmu.readByte(this.sp); const hi=this.mmu.readByte((this.sp+1)&0xFFFF); this.sp=(this.sp+2)&0xFFFF; return (hi<<8)|lo; }
            s8(v) { return v>127?v-256:v; }
            // ALU helpers
            _add(v){const r=this.a+v;this.fH=((this.a&0xF)+(v&0xF))>0xF?1:0;this.fC=r>0xFF?1:0;this.a=r&0xFF;this.fZ=this.a===0?1:0;this.fN=0;}
            _adc(v){const c=this.fC;const r=this.a+v+c;this.fH=((this.a&0xF)+(v&0xF)+c)>0xF?1:0;this.fC=r>0xFF?1:0;this.a=r&0xFF;this.fZ=this.a===0?1:0;this.fN=0;}
            _sub(v){const r=this.a-v;this.fH=(this.a&0xF)<(v&0xF)?1:0;this.fC=r<0?1:0;this.a=r&0xFF;this.fZ=this.a===0?1:0;this.fN=1;}
            _sbc(v){const c=this.fC;const r=this.a-v-c;this.fH=((this.a&0xF)-(v&0xF)-c)<0?1:0;this.fC=r<0?1:0;this.a=r&0xFF;this.fZ=this.a===0?1:0;this.fN=1;}
            _and(v){this.a&=v;this.fZ=this.a===0?1:0;this.fN=0;this.fH=1;this.fC=0;}
            _xor(v){this.a^=v;this.fZ=this.a===0?1:0;this.fN=0;this.fH=0;this.fC=0;}
            _or(v){this.a|=v;this.fZ=this.a===0?1:0;this.fN=0;this.fH=0;this.fC=0;}
            _cp(v){const r=this.a-v;this.fZ=(r&0xFF)===0?1:0;this.fN=1;this.fH=(this.a&0xF)<(v&0xF)?1:0;this.fC=r<0?1:0;}
            _inc(v){const r=(v+1)&0xFF;this.fZ=r===0?1:0;this.fN=0;this.fH=(v&0xF)===0xF?1:0;return r;}
            _dec(v){const r=(v-1)&0xFF;this.fZ=r===0?1:0;this.fN=1;this.fH=(v&0xF)===0?1:0;return r;}
            _addHL(v){const hl=this.getHL();const r=hl+v;this.fN=0;this.fH=((hl&0xFFF)+(v&0xFFF))>0xFFF?1:0;this.fC=r>0xFFFF?1:0;this.setHL(r&0xFFFF);}
            // CB prefix handler - all 256 CB opcodes
            executeCB() {
                const op=this.fb();
                const ri=op&7, group=op>>6, bit=(op>>3)&7;
                let v=this.gr(ri), r;
                switch(group) {
                case 0: // Rotates/shifts
                    switch(bit) {
                    case 0: r=((v<<1)|(v>>7))&0xFF;this.fC=v>>7;break; // RLC
                    case 1: r=((v>>1)|(v<<7))&0xFF;this.fC=v&1;break; // RRC
                    case 2: r=((v<<1)|this.fC)&0xFF;this.fC=v>>7;break; // RL
                    case 3: r=((v>>1)|(this.fC<<7))&0xFF;this.fC=v&1;break; // RR
                    case 4: r=(v<<1)&0xFF;this.fC=v>>7;break; // SLA
                    case 5: r=((v>>1)|(v&0x80));this.fC=v&1;break; // SRA
                    case 6: r=((v<<4)|(v>>4))&0xFF;this.fC=0;break; // SWAP
                    case 7: r=v>>1;this.fC=v&1;break; // SRL
                    }
                    this.fZ=r===0?1:0;this.fN=0;this.fH=0;
                    this.sr(ri,r);
                    break;
                case 1: // BIT
                    this.fZ=((v>>bit)&1)===0?1:0;this.fN=0;this.fH=1;
                    break;
                case 2: // RES
                    this.sr(ri,v&~(1<<bit));
                    break;
                case 3: // SET
                    this.sr(ri,v|(1<<bit));
                    break;
                }
                this.cycles+=(ri===6)?(group===1?12:16):8;
            }
            // Handle interrupts
            handleInterrupts() {
                const fired=this.mmu.io[0x0F]&this.mmu.ie&0x1F;
                if(fired) { this.halt=false; }
                if(!this.ime||!fired) return;
                for(let i=0;i<5;i++){
                    if(fired&(1<<i)){
                        this.ime=false;
                        this.mmu.io[0x0F]&=~(1<<i);
                        this.push16(this.pc);
                        this.pc=0x40+i*8;
                        this.cycles+=20;
                        return;
                    }
                }
            }
            // Execute one instruction - ALL 256 base opcodes
            execute() {
                this.handleInterrupts();
                if(this.halt){this.cycles+=4;return;}
                if(this.imeDelay>0){this.imeDelay--;if(this.imeDelay===0)this.ime=true;}
                const op=this.fb();
                // 0x40-0x7F: LD r,r block (except 0x76=HALT)
                if(op>=0x40&&op<=0x7F){
                    if(op===0x76){this.halt=true;this.cycles+=4;return;}
                    const dst=(op>>3)&7,src=op&7;
                    this.sr(dst,this.gr(src));
                    this.cycles+=(src===6||dst===6)?8:4;
                    return;
                }
                // 0x80-0xBF: ALU A,r
                if(op>=0x80&&op<=0xBF){
                    const v=this.gr(op&7),fn=(op>>3)&7;
                    switch(fn){case 0:this._add(v);break;case 1:this._adc(v);break;case 2:this._sub(v);break;case 3:this._sbc(v);break;case 4:this._and(v);break;case 5:this._xor(v);break;case 6:this._or(v);break;case 7:this._cp(v);break;}
                    this.cycles+=(op&7)===6?8:4;
                    return;
                }
                // All other opcodes
                let n,nn,v,r,c,addr;
                switch(op) {
                case 0x00:this.cycles+=4;break; // NOP
                case 0x01:this.setBC(this.fw());this.cycles+=12;break; // LD BC,d16
                case 0x02:this.mmu.writeByte(this.getBC(),this.a);this.cycles+=8;break; // LD (BC),A
                case 0x03:this.setBC((this.getBC()+1)&0xFFFF);this.cycles+=8;break; // INC BC
                case 0x04:this.b=this._inc(this.b);this.cycles+=4;break; // INC B
                case 0x05:this.b=this._dec(this.b);this.cycles+=4;break; // DEC B
                case 0x06:this.b=this.fb();this.cycles+=8;break; // LD B,d8
                case 0x07:c=this.a>>7;this.a=((this.a<<1)|c)&0xFF;this.fZ=0;this.fN=0;this.fH=0;this.fC=c;this.cycles+=4;break; // RLCA
                case 0x08:nn=this.fw();this.mmu.writeByte(nn,this.sp&0xFF);this.mmu.writeByte((nn+1)&0xFFFF,(this.sp>>8)&0xFF);this.cycles+=20;break; // LD (a16),SP
                case 0x09:this._addHL(this.getBC());this.cycles+=8;break; // ADD HL,BC
                case 0x0A:this.a=this.mmu.readByte(this.getBC());this.cycles+=8;break; // LD A,(BC)
                case 0x0B:this.setBC((this.getBC()-1)&0xFFFF);this.cycles+=8;break; // DEC BC
                case 0x0C:this.c=this._inc(this.c);this.cycles+=4;break; // INC C
                case 0x0D:this.c=this._dec(this.c);this.cycles+=4;break; // DEC C
                case 0x0E:this.c=this.fb();this.cycles+=8;break; // LD C,d8
                case 0x0F:c=this.a&1;this.a=((this.a>>1)|(c<<7))&0xFF;this.fZ=0;this.fN=0;this.fH=0;this.fC=c;this.cycles+=4;break; // RRCA
                case 0x10:this.fb();this.stop=true;this.cycles+=4;break; // STOP
                case 0x11:this.setDE(this.fw());this.cycles+=12;break; // LD DE,d16
                case 0x12:this.mmu.writeByte(this.getDE(),this.a);this.cycles+=8;break; // LD (DE),A
                case 0x13:this.setDE((this.getDE()+1)&0xFFFF);this.cycles+=8;break; // INC DE
                case 0x14:this.d=this._inc(this.d);this.cycles+=4;break; // INC D
                case 0x15:this.d=this._dec(this.d);this.cycles+=4;break; // DEC D
                case 0x16:this.d=this.fb();this.cycles+=8;break; // LD D,d8
                case 0x17:c=this.a>>7;this.a=((this.a<<1)|this.fC)&0xFF;this.fZ=0;this.fN=0;this.fH=0;this.fC=c;this.cycles+=4;break; // RLA
                case 0x18:n=this.s8(this.fb());this.pc=(this.pc+n)&0xFFFF;this.cycles+=12;break; // JR r8
                case 0x19:this._addHL(this.getDE());this.cycles+=8;break; // ADD HL,DE
                case 0x1A:this.a=this.mmu.readByte(this.getDE());this.cycles+=8;break; // LD A,(DE)
                case 0x1B:this.setDE((this.getDE()-1)&0xFFFF);this.cycles+=8;break; // DEC DE
                case 0x1C:this.e=this._inc(this.e);this.cycles+=4;break; // INC E
                case 0x1D:this.e=this._dec(this.e);this.cycles+=4;break; // DEC E
                case 0x1E:this.e=this.fb();this.cycles+=8;break; // LD E,d8
                case 0x1F:c=this.a&1;this.a=((this.a>>1)|(this.fC<<7))&0xFF;this.fZ=0;this.fN=0;this.fH=0;this.fC=c;this.cycles+=4;break; // RRA
                case 0x20:n=this.s8(this.fb());if(!this.fZ){this.pc=(this.pc+n)&0xFFFF;this.cycles+=12;}else{this.cycles+=8;}break; // JR NZ
                case 0x21:this.setHL(this.fw());this.cycles+=12;break; // LD HL,d16
                case 0x22:this.mmu.writeByte(this.getHL(),this.a);this.setHL((this.getHL()+1)&0xFFFF);this.cycles+=8;break; // LD (HL+),A
                case 0x23:this.setHL((this.getHL()+1)&0xFFFF);this.cycles+=8;break; // INC HL
                case 0x24:this.h=this._inc(this.h);this.cycles+=4;break; // INC H
                case 0x25:this.h=this._dec(this.h);this.cycles+=4;break; // DEC H
                case 0x26:this.h=this.fb();this.cycles+=8;break; // LD H,d8
                case 0x27: // DAA
                    if(!this.fN){if(this.fC||this.a>0x99){this.a+=0x60;this.fC=1;}if(this.fH||(this.a&0x0F)>0x09){this.a+=0x06;}}
                    else{if(this.fC){this.a-=0x60;}if(this.fH){this.a-=0x06;}}
                    this.a&=0xFF;this.fZ=this.a===0?1:0;this.fH=0;this.cycles+=4;break;
                case 0x28:n=this.s8(this.fb());if(this.fZ){this.pc=(this.pc+n)&0xFFFF;this.cycles+=12;}else{this.cycles+=8;}break; // JR Z
                case 0x29:this._addHL(this.getHL());this.cycles+=8;break; // ADD HL,HL
                case 0x2A:this.a=this.mmu.readByte(this.getHL());this.setHL((this.getHL()+1)&0xFFFF);this.cycles+=8;break; // LD A,(HL+)
                case 0x2B:this.setHL((this.getHL()-1)&0xFFFF);this.cycles+=8;break; // DEC HL
                case 0x2C:this.l=this._inc(this.l);this.cycles+=4;break; // INC L
                case 0x2D:this.l=this._dec(this.l);this.cycles+=4;break; // DEC L
                case 0x2E:this.l=this.fb();this.cycles+=8;break; // LD L,d8
                case 0x2F:this.a=~this.a&0xFF;this.fN=1;this.fH=1;this.cycles+=4;break; // CPL
                case 0x30:n=this.s8(this.fb());if(!this.fC){this.pc=(this.pc+n)&0xFFFF;this.cycles+=12;}else{this.cycles+=8;}break; // JR NC
                case 0x31:this.sp=this.fw();this.cycles+=12;break; // LD SP,d16
                case 0x32:this.mmu.writeByte(this.getHL(),this.a);this.setHL((this.getHL()-1)&0xFFFF);this.cycles+=8;break; // LD (HL-),A
                case 0x33:this.sp=(this.sp+1)&0xFFFF;this.cycles+=8;break; // INC SP
                case 0x34:v=this.mmu.readByte(this.getHL());this.mmu.writeByte(this.getHL(),this._inc(v));this.cycles+=12;break; // INC (HL)
                case 0x35:v=this.mmu.readByte(this.getHL());this.mmu.writeByte(this.getHL(),this._dec(v));this.cycles+=12;break; // DEC (HL)
                case 0x36:this.mmu.writeByte(this.getHL(),this.fb());this.cycles+=12;break; // LD (HL),d8
                case 0x37:this.fN=0;this.fH=0;this.fC=1;this.cycles+=4;break; // SCF
                case 0x38:n=this.s8(this.fb());if(this.fC){this.pc=(this.pc+n)&0xFFFF;this.cycles+=12;}else{this.cycles+=8;}break; // JR C
                case 0x39:this._addHL(this.sp);this.cycles+=8;break; // ADD HL,SP
                case 0x3A:this.a=this.mmu.readByte(this.getHL());this.setHL((this.getHL()-1)&0xFFFF);this.cycles+=8;break; // LD A,(HL-)
                case 0x3B:this.sp=(this.sp-1)&0xFFFF;this.cycles+=8;break; // DEC SP
                case 0x3C:this.a=this._inc(this.a);this.cycles+=4;break; // INC A
                case 0x3D:this.a=this._dec(this.a);this.cycles+=4;break; // DEC A
                case 0x3E:this.a=this.fb();this.cycles+=8;break; // LD A,d8
                case 0x3F:this.fN=0;this.fH=0;this.fC=this.fC?0:1;this.cycles+=4;break; // CCF
                // 0x40-0x7F handled above (LD r,r + HALT)
                // 0x80-0xBF handled above (ALU)
                case 0xC0:if(!this.fZ){this.pc=this.pop16();this.cycles+=20;}else{this.cycles+=8;}break; // RET NZ
                case 0xC1:this.setBC(this.pop16());this.cycles+=12;break; // POP BC
                case 0xC2:nn=this.fw();if(!this.fZ){this.pc=nn;this.cycles+=16;}else{this.cycles+=12;}break; // JP NZ,a16
                case 0xC3:this.pc=this.fw();this.cycles+=16;break; // JP a16
                case 0xC4:nn=this.fw();if(!this.fZ){this.push16(this.pc);this.pc=nn;this.cycles+=24;}else{this.cycles+=12;}break; // CALL NZ
                case 0xC5:this.push16(this.getBC());this.cycles+=16;break; // PUSH BC
                case 0xC6:this._add(this.fb());this.cycles+=8;break; // ADD A,d8
                case 0xC7:this.push16(this.pc);this.pc=0x00;this.cycles+=16;break; // RST 00
                case 0xC8:if(this.fZ){this.pc=this.pop16();this.cycles+=20;}else{this.cycles+=8;}break; // RET Z
                case 0xC9:this.pc=this.pop16();this.cycles+=16;break; // RET
                case 0xCA:nn=this.fw();if(this.fZ){this.pc=nn;this.cycles+=16;}else{this.cycles+=12;}break; // JP Z,a16
                case 0xCB:this.executeCB();break; // CB prefix
                case 0xCC:nn=this.fw();if(this.fZ){this.push16(this.pc);this.pc=nn;this.cycles+=24;}else{this.cycles+=12;}break; // CALL Z
                case 0xCD:nn=this.fw();this.push16(this.pc);this.pc=nn;this.cycles+=24;break; // CALL a16
                case 0xCE:this._adc(this.fb());this.cycles+=8;break; // ADC A,d8
                case 0xCF:this.push16(this.pc);this.pc=0x08;this.cycles+=16;break; // RST 08
                case 0xD0:if(!this.fC){this.pc=this.pop16();this.cycles+=20;}else{this.cycles+=8;}break; // RET NC
                case 0xD1:this.setDE(this.pop16());this.cycles+=12;break; // POP DE
                case 0xD2:nn=this.fw();if(!this.fC){this.pc=nn;this.cycles+=16;}else{this.cycles+=12;}break; // JP NC,a16
                case 0xD4:nn=this.fw();if(!this.fC){this.push16(this.pc);this.pc=nn;this.cycles+=24;}else{this.cycles+=12;}break; // CALL NC
                case 0xD5:this.push16(this.getDE());this.cycles+=16;break; // PUSH DE
                case 0xD6:this._sub(this.fb());this.cycles+=8;break; // SUB d8
                case 0xD7:this.push16(this.pc);this.pc=0x10;this.cycles+=16;break; // RST 10
                case 0xD8:if(this.fC){this.pc=this.pop16();this.cycles+=20;}else{this.cycles+=8;}break; // RET C
                case 0xD9:this.pc=this.pop16();this.ime=true;this.cycles+=16;break; // RETI
                case 0xDA:nn=this.fw();if(this.fC){this.pc=nn;this.cycles+=16;}else{this.cycles+=12;}break; // JP C,a16
                case 0xDC:nn=this.fw();if(this.fC){this.push16(this.pc);this.pc=nn;this.cycles+=24;}else{this.cycles+=12;}break; // CALL C
                case 0xDE:this._sbc(this.fb());this.cycles+=8;break; // SBC A,d8
                case 0xDF:this.push16(this.pc);this.pc=0x18;this.cycles+=16;break; // RST 18
                case 0xE0:this.mmu.writeByte(0xFF00+this.fb(),this.a);this.cycles+=12;break; // LDH (a8),A
                case 0xE1:this.setHL(this.pop16());this.cycles+=12;break; // POP HL
                case 0xE2:this.mmu.writeByte(0xFF00+this.c,this.a);this.cycles+=8;break; // LD (C),A
                case 0xE5:this.push16(this.getHL());this.cycles+=16;break; // PUSH HL
                case 0xE6:this._and(this.fb());this.cycles+=8;break; // AND d8
                case 0xE7:this.push16(this.pc);this.pc=0x20;this.cycles+=16;break; // RST 20
                case 0xE8: // ADD SP,r8
                    n=this.s8(this.fb());r=(this.sp+n)&0xFFFF;
                    this.fZ=0;this.fN=0;this.fH=((this.sp&0xF)+(n&0xF))>0xF?1:0;this.fC=((this.sp&0xFF)+(n&0xFF))>0xFF?1:0;
                    this.sp=r;this.cycles+=16;break;
                case 0xE9:this.pc=this.getHL();this.cycles+=4;break; // JP HL
                case 0xEA:this.mmu.writeByte(this.fw(),this.a);this.cycles+=16;break; // LD (a16),A
                case 0xEE:this._xor(this.fb());this.cycles+=8;break; // XOR d8
                case 0xEF:this.push16(this.pc);this.pc=0x28;this.cycles+=16;break; // RST 28
                case 0xF0:this.a=this.mmu.readByte(0xFF00+this.fb());this.cycles+=12;break; // LDH A,(a8)
                case 0xF1:this.setAF(this.pop16());this.cycles+=12;break; // POP AF
                case 0xF2:this.a=this.mmu.readByte(0xFF00+this.c);this.cycles+=8;break; // LD A,(C)
                case 0xF3:this.ime=false;this.cycles+=4;break; // DI
                case 0xF5:this.push16(this.getAF());this.cycles+=16;break; // PUSH AF
                case 0xF6:this._or(this.fb());this.cycles+=8;break; // OR d8
                case 0xF7:this.push16(this.pc);this.pc=0x30;this.cycles+=16;break; // RST 30
                case 0xF8: // LD HL,SP+r8
                    n=this.s8(this.fb());r=(this.sp+n)&0xFFFF;
                    this.fZ=0;this.fN=0;this.fH=((this.sp&0xF)+(n&0xF))>0xF?1:0;this.fC=((this.sp&0xFF)+(n&0xFF))>0xFF?1:0;
                    this.setHL(r);this.cycles+=12;break;
                case 0xF9:this.sp=this.getHL();this.cycles+=8;break; // LD SP,HL
                case 0xFA:this.a=this.mmu.readByte(this.fw());this.cycles+=16;break; // LD A,(a16)
                case 0xFB:this.imeDelay=2;this.cycles+=4;break; // EI
                case 0xFE:this._cp(this.fb());this.cycles+=8;break; // CP d8
                case 0xFF:this.push16(this.pc);this.pc=0x38;this.cycles+=16;break; // RST 38
                default:this.cycles+=4;break; // Undefined opcodes (0xD3,0xDB,0xDD,0xE3,0xE4,0xEB,0xEC,0xED,0xF4,0xFC,0xFD)
                }
            }
        }
        
        // ==================== PPU (Picture Processing Unit) ====================
        class PPU {
            constructor(mmu, canvas) {
                this.mmu = mmu; this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.imageData = this.ctx.createImageData(160, 144);
                this.fb = new Uint8Array(160 * 144 * 4);
                this.bgPriority = new Uint8Array(160); // Per-pixel BG priority for sprite rendering
                this.palettes = {
                    green: [[155,188,15],[139,172,15],[48,98,48],[15,56,15]],
                    gray: [[255,255,255],[170,170,170],[85,85,85],[0,0,0]],
                    brown: [[232,212,162],[208,168,112],[139,105,20],[62,37,0]]
                };
                this.paletteName = 'green';
                this.reset();
            }
            reset() {
                this.modeClock = 0; this.mode = 2; this.line = 0;
                this.frameReady = false; this.windowLine = 0;
            }
            getPalColors(palReg) {
                const base = this.palettes[this.paletteName];
                return [base[palReg & 3], base[(palReg >> 2) & 3], base[(palReg >> 4) & 3], base[(palReg >> 6) & 3]];
            }
            step(cycles) {
                const io = this.mmu.io;
                const lcdc = io[0x40];
                if (!(lcdc & 0x80)) return; // LCD off
                this.modeClock += cycles;
                switch (this.mode) {
                case 2: // OAM search (80 cycles)
                    if (this.modeClock >= 80) {
                        this.modeClock -= 80; this.mode = 3;
                    } break;
                case 3: // Pixel transfer (172 cycles)
                    if (this.modeClock >= 172) {
                        this.modeClock -= 172; this.mode = 0;
                        this.renderScanline();
                        // HBlank STAT interrupt
                        if (io[0x41] & 0x08) io[0x0F] |= 0x02;
                    } break;
                case 0: // HBlank (204 cycles)
                    if (this.modeClock >= 204) {
                        this.modeClock -= 204; this.line++;
                        if (this.line === 144) {
                            this.mode = 1;
                            this.frameReady = true;
                            io[0x0F] |= 0x01; // VBlank interrupt
                            if (io[0x41] & 0x10) io[0x0F] |= 0x02; // VBlank STAT
                        } else {
                            this.mode = 2;
                            if (io[0x41] & 0x20) io[0x0F] |= 0x02; // OAM STAT
                        }
                        this.checkLYC();
                    } break;
                case 1: // VBlank (10 lines Ã— 456 cycles)
                    if (this.modeClock >= 456) {
                        this.modeClock -= 456; this.line++;
                        if (this.line > 153) {
                            this.line = 0; this.mode = 2; this.windowLine = 0;
                            if (io[0x41] & 0x20) io[0x0F] |= 0x02;
                        }
                        this.checkLYC();
                    } break;
                }
                io[0x44] = this.line;
                io[0x41] = (io[0x41] & 0xFC) | this.mode;
            }
            checkLYC() {
                const io = this.mmu.io;
                if (this.line === io[0x45]) {
                    io[0x41] |= 0x04;
                    if (io[0x41] & 0x40) io[0x0F] |= 0x02;
                } else { io[0x41] &= ~0x04; }
            }
            renderScanline() {
                const io = this.mmu.io, lcdc = io[0x40], ly = this.line;
                if (ly >= 144) return;
                const bgPal = this.getPalColors(io[0x47]);
                const obp0 = this.getPalColors(io[0x48]);
                const obp1 = this.getPalColors(io[0x49]);
                const offset = ly * 160 * 4;
                // Clear bg priority
                this.bgPriority.fill(0);
                // Background
                if (lcdc & 0x01) {
                    const scx = io[0x43], scy = io[0x42];
                    const tileMap = (lcdc & 0x08) ? 0x1C00 : 0x1800;
                    const tileData = (lcdc & 0x10) ? 0x0000 : 0x0800;
                    const useUnsigned = !!(lcdc & 0x10);
                    const yy = (ly + scy) & 0xFF;
                    const tileRow = (yy >> 3) & 31;
                    const tileYOff = yy & 7;
                    for (let px = 0; px < 160; px++) {
                        const xx = (px + scx) & 0xFF;
                        const tileCol = (xx >> 3) & 31;
                        let tileNum = this.mmu.vram[tileMap + tileRow * 32 + tileCol];
                        let tileAddr;
                        if (useUnsigned) { tileAddr = tileData + tileNum * 16; }
                        else { tileAddr = 0x1000 + ((tileNum > 127 ? tileNum - 256 : tileNum) * 16); }
                        const b1 = this.mmu.vram[tileAddr + tileYOff * 2];
                        const b2 = this.mmu.vram[tileAddr + tileYOff * 2 + 1];
                        const bit = 7 - (xx & 7);
                        const colorId = ((b2 >> bit) & 1) << 1 | ((b1 >> bit) & 1);
                        this.bgPriority[px] = colorId;
                        const c = bgPal[colorId];
                        const idx = offset + px * 4;
                        this.fb[idx] = c[0]; this.fb[idx+1] = c[1]; this.fb[idx+2] = c[2]; this.fb[idx+3] = 255;
                    }
                } else {
                    const c = this.palettes[this.paletteName][0];
                    for (let px = 0; px < 160; px++) {
                        const idx = offset + px * 4;
                        this.fb[idx] = c[0]; this.fb[idx+1] = c[1]; this.fb[idx+2] = c[2]; this.fb[idx+3] = 255;
                    }
                }
                // Window
                if ((lcdc & 0x20) && (lcdc & 0x01)) {
                    const wx = io[0x4B] - 7, wy = io[0x4A];
                    if (ly >= wy && wx < 160) {
                        const winMap = (lcdc & 0x40) ? 0x1C00 : 0x1800;
                        const tileData = (lcdc & 0x10) ? 0x0000 : 0x0800;
                        const useUnsigned = !!(lcdc & 0x10);
                        const wly = this.windowLine;
                        const tileRow = (wly >> 3) & 31;
                        const tileYOff = wly & 7;
                        for (let px = Math.max(0, wx); px < 160; px++) {
                            const xx = px - wx;
                            const tileCol = (xx >> 3) & 31;
                            let tileNum = this.mmu.vram[winMap + tileRow * 32 + tileCol];
                            let tileAddr;
                            if (useUnsigned) { tileAddr = tileData + tileNum * 16; }
                            else { tileAddr = 0x1000 + ((tileNum > 127 ? tileNum - 256 : tileNum) * 16); }
                            const b1 = this.mmu.vram[tileAddr + tileYOff * 2];
                            const b2 = this.mmu.vram[tileAddr + tileYOff * 2 + 1];
                            const bit = 7 - (xx & 7);
                            const colorId = ((b2 >> bit) & 1) << 1 | ((b1 >> bit) & 1);
                            this.bgPriority[px] = colorId;
                            const c = bgPal[colorId];
                            const idx = offset + px * 4;
                            this.fb[idx] = c[0]; this.fb[idx+1] = c[1]; this.fb[idx+2] = c[2]; this.fb[idx+3] = 255;
                        }
                        this.windowLine++;
                    }
                }
                // Sprites
                if (lcdc & 0x02) {
                    const spriteH = (lcdc & 0x04) ? 16 : 8;
                    const sprites = [];
                    for (let i = 0; i < 40 && sprites.length < 10; i++) {
                        const sy = this.mmu.oam[i*4] - 16;
                        const sx = this.mmu.oam[i*4+1] - 8;
                        if (ly >= sy && ly < sy + spriteH) {
                            sprites.push({y:sy, x:sx, tile:this.mmu.oam[i*4+2], flags:this.mmu.oam[i*4+3], idx:i});
                        }
                    }
                    sprites.sort((a,b) => a.x === b.x ? a.idx - b.idx : a.x - b.x);
                    for (let si = sprites.length - 1; si >= 0; si--) {
                        const sp = sprites[si];
                        const pal = (sp.flags & 0x10) ? obp1 : obp0;
                        const flipX = !!(sp.flags & 0x20);
                        const flipY = !!(sp.flags & 0x40);
                        const bgOver = !!(sp.flags & 0x80);
                        let tileNum = sp.tile;
                        let yOff = ly - sp.y;
                        if (spriteH === 16) tileNum &= 0xFE;
                        if (flipY) yOff = spriteH - 1 - yOff;
                        const tileAddr = tileNum * 16 + yOff * 2;
                        const b1 = this.mmu.vram[tileAddr];
                        const b2 = this.mmu.vram[tileAddr + 1];
                        for (let px = 0; px < 8; px++) {
                            const screenX = sp.x + px;
                            if (screenX < 0 || screenX >= 160) continue;
                            const bit = flipX ? px : 7 - px;
                            const colorId = ((b2 >> bit) & 1) << 1 | ((b1 >> bit) & 1);
                            if (colorId === 0) continue; // Transparent
                            if (bgOver && this.bgPriority[screenX] !== 0) continue;
                            const c = pal[colorId];
                            const idx = offset + screenX * 4;
                            this.fb[idx] = c[0]; this.fb[idx+1] = c[1]; this.fb[idx+2] = c[2]; this.fb[idx+3] = 255;
                        }
                    }
                }
            }
            flush() {
                this.imageData.data.set(this.fb);
                this.ctx.putImageData(this.imageData, 0, 0);
                this.frameReady = false;
            }
        }

        // ==================== APU (Audio Processing Unit) ====================
        class APU {
            constructor(mmu) {
                this.mmu = mmu; this.muted = false;
                this.ctx = null; this.masterGain = null;
                this.channels = [null, null, null, null];
                this.gains = [null, null, null, null];
                this.enabled = false;
            }
            init() {
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)({sampleRate: 44100});
                    this.masterGain = this.ctx.createGain();
                    this.masterGain.gain.value = 0.15;
                    this.masterGain.connect(this.ctx.destination);
                    for (let i = 0; i < 4; i++) {
                        this.gains[i] = this.ctx.createGain();
                        this.gains[i].gain.value = 0;
                        this.gains[i].connect(this.masterGain);
                    }
                    // Ch1 & Ch2: Pulse oscillators
                    for (let i = 0; i < 2; i++) {
                        this.channels[i] = this.ctx.createOscillator();
                        this.channels[i].type = 'square';
                        this.channels[i].frequency.value = 0;
                        this.channels[i].connect(this.gains[i]);
                        this.channels[i].start();
                    }
                    // Ch3: Wave - use oscillator as approximation
                    this.channels[2] = this.ctx.createOscillator();
                    this.channels[2].type = 'triangle';
                    this.channels[2].frequency.value = 0;
                    this.channels[2].connect(this.gains[2]);
                    this.channels[2].start();
                    // Ch4: Noise
                    const bufSize = this.ctx.sampleRate * 2;
                    const noiseBuf = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
                    const data = noiseBuf.getChannelData(0);
                    for (let i = 0; i < bufSize; i++) data[i] = Math.random() * 2 - 1;
                    this.channels[3] = this.ctx.createBufferSource();
                    this.channels[3].buffer = noiseBuf;
                    this.channels[3].loop = true;
                    this.channels[3].connect(this.gains[3]);
                    this.channels[3].start();
                    this.enabled = true;
                } catch(e) { this.enabled = false; }
            }
            update() {
                if (!this.enabled || this.muted) {
                    if (this.masterGain) this.masterGain.gain.value = 0;
                    return;
                }
                if (this.masterGain) this.masterGain.gain.value = 0.15;
                const io = this.mmu.io;
                if (!(io[0x26] & 0x80)) { // Master sound off
                    for (let i = 0; i < 4; i++) if (this.gains[i]) this.gains[i].gain.value = 0;
                    return;
                }
                // Ch1: Pulse with sweep
                const nr14 = io[0x14], nr12 = io[0x12];
                if (nr14 & 0x80) {
                    const freq = ((nr14 & 7) << 8) | io[0x13];
                    const hz = freq > 0 ? 131072 / (2048 - freq) : 0;
                    if (this.channels[0]) this.channels[0].frequency.value = hz;
                    const vol = (nr12 >> 4) / 15;
                    if (this.gains[0]) this.gains[0].gain.value = vol;
                    io[0x14] &= 0x7F;
                }
                // Ch2: Pulse
                const nr24 = io[0x19], nr22 = io[0x17];
                if (nr24 & 0x80) {
                    const freq = ((nr24 & 7) << 8) | io[0x18];
                    const hz = freq > 0 ? 131072 / (2048 - freq) : 0;
                    if (this.channels[1]) this.channels[1].frequency.value = hz;
                    const vol = (nr22 >> 4) / 15;
                    if (this.gains[1]) this.gains[1].gain.value = vol;
                    io[0x19] &= 0x7F;
                }
                // Ch3: Wave
                const nr34 = io[0x1E];
                if ((nr34 & 0x80) && (io[0x1A] & 0x80)) {
                    const freq = ((nr34 & 7) << 8) | io[0x1D];
                    const hz = freq > 0 ? 65536 / (2048 - freq) : 0;
                    if (this.channels[2]) this.channels[2].frequency.value = hz;
                    const volShift = (io[0x1C] >> 5) & 3;
                    const vol = volShift === 0 ? 0 : 1 / volShift;
                    if (this.gains[2]) this.gains[2].gain.value = vol * 0.5;
                    io[0x1E] &= 0x7F;
                }
                // Ch4: Noise
                const nr44 = io[0x23], nr42 = io[0x21];
                if (nr44 & 0x80) {
                    const vol = (nr42 >> 4) / 15;
                    if (this.gains[3]) this.gains[3].gain.value = vol * 0.3;
                    io[0x23] &= 0x7F;
                }
            }
            toggleMute() {
                this.muted = !this.muted;
                if (this.masterGain) this.masterGain.gain.value = this.muted ? 0 : 0.15;
                return this.muted;
            }
            resume() { if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume(); }
        }

        // ==================== Timer ====================
        class GBTimer {
            constructor(mmu) { this.mmu = mmu; this.reset(); }
            reset() { this.divCounter = 0; this.timaCounter = 0; }
            step(cycles) {
                const io = this.mmu.io;
                // DIV: increments every 256 cycles (16384 Hz)
                this.divCounter += cycles;
                while (this.divCounter >= 256) {
                    this.divCounter -= 256;
                    io[0x04] = (io[0x04] + 1) & 0xFF;
                }
                // TIMA
                const tac = io[0x07];
                if (tac & 0x04) { // Timer enabled
                    const clocks = [1024, 16, 64, 256]; // Cycles per TIMA increment
                    const rate = clocks[tac & 3];
                    this.timaCounter += cycles;
                    while (this.timaCounter >= rate) {
                        this.timaCounter -= rate;
                        io[0x05]++;
                        if (io[0x05] > 0xFF) {
                            io[0x05] = io[0x06]; // Reload from TMA
                            io[0x0F] |= 0x04; // Timer interrupt
                        }
                        io[0x05] &= 0xFF;
                    }
                }
            }
        }

        // ==================== Joypad ====================
        class Joypad {
            constructor(mmu) {
                this.mmu = mmu;
                this.keys = {right:0,left:0,up:0,down:0,a:0,b:0,select:0,start:0};
                this.turbo = false;
                this._setupKeyboard();
                this._setupTouch();
            }
            _setupKeyboard() {
                const map = {'ArrowRight':'right','ArrowLeft':'left','ArrowUp':'up','ArrowDown':'down',
                    'z':'b','Z':'b','x':'a','X':'a','Shift':'select','Enter':'start',' ':'turbo'};
                document.addEventListener('keydown', e => {
                    const k = map[e.key];
                    if (k === 'turbo') { this.turbo = true; e.preventDefault(); return; }
                    if (k) { this.keys[k] = 1; this._update(); e.preventDefault(); }
                });
                document.addEventListener('keyup', e => {
                    const k = map[e.key];
                    if (k === 'turbo') { this.turbo = false; e.preventDefault(); return; }
                    if (k) { this.keys[k] = 0; this._update(); e.preventDefault(); }
                });
            }
            _setupTouch() {
                const btns = document.querySelectorAll('[data-btn]');
                const press = (e) => { const b = e.currentTarget.dataset.btn; this.keys[b] = 1; this._update(); e.currentTarget.classList.add('pressed'); e.preventDefault(); };
                const release = (e) => { const b = e.currentTarget.dataset.btn; this.keys[b] = 0; this._update(); e.currentTarget.classList.remove('pressed'); e.preventDefault(); };
                btns.forEach(b => {
                    b.addEventListener('mousedown', press); b.addEventListener('touchstart', press);
                    b.addEventListener('mouseup', release); b.addEventListener('touchend', release);
                    b.addEventListener('mouseleave', release); b.addEventListener('touchcancel', release);
                });
            }
            _update() {
                const d = 0x0F & ~((this.keys.right?1:0)|(this.keys.left?2:0)|(this.keys.up?4:0)|(this.keys.down?8:0));
                const b = 0x0F & ~((this.keys.a?1:0)|(this.keys.b?2:0)|(this.keys.select?4:0)|(this.keys.start?8:0));
                this.mmu._joyDir = d; this.mmu._joyBtn = b;
                // Request joypad interrupt if any button pressed
                if ((d & 0x0F) !== 0x0F || (b & 0x0F) !== 0x0F) this.mmu.io[0x0F] |= 0x10;
            }
        }

        // ==================== Debug View ====================
        class DebugView {
            constructor(cpu, mmu, ppu) {
                this.cpu = cpu; this.mmu = mmu; this.ppu = ppu;
                this.tileCanvas = document.getElementById('tile-canvas');
                this.tileCtx = this.tileCanvas ? this.tileCanvas.getContext('2d') : null;
                this.visible = false;
            }
            update() {
                if (!this.visible) return;
                const cpu = this.cpu;
                // Registers
                const rd = document.getElementById('reg-display');
                if (rd) rd.innerHTML = [
                    ['A', cpu.a], ['F', cpu.getF()], ['B', cpu.b], ['C', cpu.c],
                    ['D', cpu.d], ['E', cpu.e], ['H', cpu.h], ['L', cpu.l],
                    ['SP', cpu.sp], ['PC', cpu.pc], ['IME', cpu.ime?1:0], ['CYC', cpu.cycles]
                ].map(([l,v]) => `<div class="reg-item"><span class="label">${l}</span> <span class="val">${typeof v==='number'&&l!=='CYC'?'0x'+v.toString(16).toUpperCase().padStart(l.length>1?4:2,'0'):v}</span></div>`).join('');
                // Flags
                const fd = document.getElementById('flag-display');
                if (fd) fd.innerHTML = ['Z','N','H','C'].map((f,i) => {
                    const set = [cpu.fZ,cpu.fN,cpu.fH,cpu.fC][i];
                    return `<span class="flag-item ${set?'set':'clear'}">${f}=${set?1:0}</span>`;
                }).join('');
                // Disassembly
                const dv = document.getElementById('disasm-view');
                if (dv) {
                    let lines = [], pc = cpu.pc;
                    for (let i = 0; i < 12; i++) {
                        const addr = pc & 0xFFFF;
                        const b = this.mmu.readByte(addr);
                        const prefix = addr === cpu.pc ? 'â–º ' : '  ';
                        lines.push(`${prefix}${addr.toString(16).padStart(4,'0').toUpperCase()}: ${b.toString(16).padStart(2,'0').toUpperCase()}`);
                        pc = (pc + 1) & 0xFFFF;
                    }
                    dv.textContent = lines.join('\n');
                }
                // VRAM tiles
                if (this.tileCtx) {
                    const imgData = this.tileCtx.createImageData(128, 192);
                    const pal = this.ppu.palettes[this.ppu.paletteName];
                    for (let t = 0; t < 384; t++) {
                        const tx = (t % 16) * 8, ty = Math.floor(t / 16) * 8;
                        for (let row = 0; row < 8; row++) {
                            const b1 = this.mmu.vram[t * 16 + row * 2];
                            const b2 = this.mmu.vram[t * 16 + row * 2 + 1];
                            for (let col = 0; col < 8; col++) {
                                const bit = 7 - col;
                                const cid = ((b2 >> bit) & 1) << 1 | ((b1 >> bit) & 1);
                                const c = pal[cid];
                                const idx = ((ty + row) * 128 + (tx + col)) * 4;
                                imgData.data[idx] = c[0]; imgData.data[idx+1] = c[1]; imgData.data[idx+2] = c[2]; imgData.data[idx+3] = 255;
                            }
                        }
                    }
                    this.tileCtx.putImageData(imgData, 0, 0);
                }
                // Memory hex view
                const mv = document.getElementById('mem-view');
                if (mv) {
                    let lines = [];
                    const start = cpu.pc & 0xFFF0;
                    for (let row = 0; row < 16; row++) {
                        const addr = (start + row * 16) & 0xFFFF;
                        let hex = '', ascii = '';
                        for (let col = 0; col < 16; col++) {
                            const b = this.mmu.readByte((addr + col) & 0xFFFF);
                            hex += b.toString(16).padStart(2, '0').toUpperCase() + ' ';
                            ascii += (b >= 32 && b < 127) ? String.fromCharCode(b) : '.';
                        }
                        lines.push(`${addr.toString(16).padStart(4,'0').toUpperCase()}: ${hex} ${ascii}`);
                    }
                    mv.textContent = lines.join('\n');
                }
            }
        }

        // ==================== GameBoy (Main Orchestrator) ====================
        class GameBoy {
            constructor() {
                this.canvas = document.getElementById('screen');
                this.mmu = new MMU();
                this.cpu = new CPU(this.mmu);
                this.ppu = new PPU(this.mmu, this.canvas);
                this.apu = new APU(this.mmu);
                this.timer = new GBTimer(this.mmu);
                this.joypad = new Joypad(this.mmu);
                this.debug = new DebugView(this.cpu, this.mmu, this.ppu);
                this.running = false; this.paused = false;
                this.speed = 1; this.romData = null; this.romName = '';
                this.frameCount = 0; this.lastFPSTime = performance.now();
                this.animId = null;
                this.CYCLES_PER_FRAME = 70224;
            }
            loadROM(data, filename) {
                this.romData = new Uint8Array(data);
                this.romName = filename || 'ROM';
                this.mmu.reset();
                this.mmu.loadROM(this.romData);
                this.cpu.reset();
                this.ppu.reset();
                this.timer.reset();
                if (!this.apu.enabled) this.apu.init();
                this.apu.resume();
                this.running = true; this.paused = false;
                document.getElementById('power-led').classList.add('on');
                this._updateUI();
                this._enableButtons(true);
                if (!this.animId) this._loop();
            }
            reset() {
                if (!this.romData) return;
                this.mmu.reset();
                this.mmu.loadROM(this.romData);
                this.cpu.reset(); this.ppu.reset(); this.timer.reset();
                this.paused = false;
                this._updateUI();
            }
            _loop() {
                if (!this.running) { this.animId = null; return; }
                if (!this.paused) {
                    const spd = this.joypad.turbo ? 8 : this.speed;
                    const target = this.CYCLES_PER_FRAME * spd;
                    let cycles = 0;
                    while (cycles < target) {
                        const before = this.cpu.cycles;
                        this.cpu.execute();
                        const elapsed = this.cpu.cycles - before;
                        this.ppu.step(elapsed);
                        this.timer.step(elapsed);
                        cycles += elapsed;
                        if (this.ppu.frameReady) {
                            this.ppu.flush();
                            this.apu.update();
                        }
                    }
                    if (!this.ppu.frameReady) { this.ppu.flush(); }
                    this.debug.update();
                    this._updateFPS();
                }
                this.animId = requestAnimationFrame(() => this._loop());
            }
            step() {
                if (!this.romData) return;
                const before = this.cpu.cycles;
                this.cpu.execute();
                const elapsed = this.cpu.cycles - before;
                this.ppu.step(elapsed);
                this.timer.step(elapsed);
                if (this.ppu.frameReady) this.ppu.flush();
                this.debug.update();
            }
            togglePause() {
                this.paused = !this.paused;
                this._updateUI();
                if (!this.paused && !this.animId) this._loop();
            }
            cycleSpeed() {
                const speeds = [1, 2, 4];
                this.speed = speeds[(speeds.indexOf(this.speed) + 1) % speeds.length];
                document.getElementById('btn-speed').textContent = this.speed + 'x';
            }
            _updateFPS() {
                this.frameCount++;
                const now = performance.now();
                if (now - this.lastFPSTime >= 1000) {
                    const fps = Math.round(this.frameCount * 1000 / (now - this.lastFPSTime));
                    document.getElementById('fps-display').textContent = fps + ' FPS';
                    this.frameCount = 0; this.lastFPSTime = now;
                }
            }
            _updateUI() {
                const sb = document.getElementById('status-bar');
                const pb = document.getElementById('btn-play');
                if (this.romData) {
                    sb.textContent = this.paused ? `Paused: ${this.romName}` : `Playing: ${this.romName}`;
                    pb.innerHTML = this.paused ? '&#x25B6; Play' : '&#x23F8; Pause';
                }
            }
            _enableButtons(on) {
                ['btn-play','btn-reset','btn-step','btn-speed','btn-save','btn-load'].forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.disabled = !on;
                });
            }
            saveState() {
                if (!this.romData) return;
                const state = {
                    cpu: {a:this.cpu.a,b:this.cpu.b,c:this.cpu.c,d:this.cpu.d,e:this.cpu.e,h:this.cpu.h,l:this.cpu.l,
                        sp:this.cpu.sp,pc:this.cpu.pc,fZ:this.cpu.fZ,fN:this.cpu.fN,fH:this.cpu.fH,fC:this.cpu.fC,
                        cycles:this.cpu.cycles,halt:this.cpu.halt,ime:this.cpu.ime,imeDelay:this.cpu.imeDelay},
                    mmu: {vram:Array.from(this.mmu.vram),wram:Array.from(this.mmu.wram),oam:Array.from(this.mmu.oam),
                        io:Array.from(this.mmu.io),hram:Array.from(this.mmu.hram),ie:this.mmu.ie,
                        eram:Array.from(this.mmu.eram),romBank:this.mmu.romBank,ramBank:this.mmu.ramBank,
                        ramEnable:this.mmu.ramEnable,mbcMode:this.mmu.mbcMode},
                    ppu: {modeClock:this.ppu.modeClock,mode:this.ppu.mode,line:this.ppu.line,windowLine:this.ppu.windowLine}
                };
                try {
                    localStorage.setItem('gb_savestate', JSON.stringify(state));
                    document.getElementById('status-bar').textContent = 'State saved!';
                } catch(e) {
                    document.getElementById('status-bar').textContent = 'Save failed: ' + e.message;
                }
            }
            loadState() {
                if (!this.romData) return;
                try {
                    const raw = localStorage.getItem('gb_savestate');
                    if (!raw) { document.getElementById('status-bar').textContent = 'No saved state found'; return; }
                    const state = JSON.parse(raw);
                    Object.assign(this.cpu, state.cpu);
                    this.mmu.vram.set(state.mmu.vram); this.mmu.wram.set(state.mmu.wram);
                    this.mmu.oam.set(state.mmu.oam); this.mmu.io.set(state.mmu.io);
                    this.mmu.hram.set(state.mmu.hram); this.mmu.ie = state.mmu.ie;
                    this.mmu.eram.set(state.mmu.eram); this.mmu.romBank = state.mmu.romBank;
                    this.mmu.ramBank = state.mmu.ramBank; this.mmu.ramEnable = state.mmu.ramEnable;
                    this.mmu.mbcMode = state.mmu.mbcMode;
                    Object.assign(this.ppu, state.ppu);
                    document.getElementById('status-bar').textContent = 'State loaded!';
                } catch(e) {
                    document.getElementById('status-bar').textContent = 'Load failed: ' + e.message;
                }
            }
        }

        // ==================== Initialization ====================
        const gb = new GameBoy();

        // ROM file input
        document.getElementById('rom-input').addEventListener('change', async e => {
            const file = e.target.files[0];
            if (file) { gb.loadROM(new Uint8Array(await file.arrayBuffer()), file.name); }
        });

        // Drag and drop
        const overlay = document.getElementById('drag-overlay');
        document.addEventListener('dragover', e => { e.preventDefault(); overlay.classList.add('show'); });
        document.addEventListener('dragleave', e => { if (!e.relatedTarget) overlay.classList.remove('show'); });
        document.addEventListener('drop', async e => {
            e.preventDefault(); overlay.classList.remove('show');
            const file = e.dataTransfer.files[0];
            if (file) { gb.loadROM(new Uint8Array(await file.arrayBuffer()), file.name); }
        });

        // Toolbar buttons
        document.getElementById('btn-play').addEventListener('click', () => gb.togglePause());
        document.getElementById('btn-reset').addEventListener('click', () => gb.reset());
        document.getElementById('btn-step').addEventListener('click', () => { if(!gb.paused) gb.togglePause(); gb.step(); });
        document.getElementById('btn-speed').addEventListener('click', () => gb.cycleSpeed());
        document.getElementById('btn-mute').addEventListener('click', () => {
            if (!gb.apu.enabled) gb.apu.init();
            const muted = gb.apu.toggleMute();
            document.getElementById('btn-mute').innerHTML = muted ? '&#x1F507;' : '&#x1F50A;';
        });
        document.getElementById('btn-debug').addEventListener('click', () => {
            const panel = document.getElementById('debug-panel');
            panel.classList.toggle('show');
            gb.debug.visible = panel.classList.contains('show');
            document.getElementById('btn-debug').classList.toggle('active', gb.debug.visible);
            if (gb.debug.visible) gb.debug.update();
        });
        document.getElementById('btn-save').addEventListener('click', () => gb.saveState());
        document.getElementById('btn-load').addEventListener('click', () => gb.loadState());

        // Palette selector
        document.querySelectorAll('.palette-opt').forEach(el => {
            el.addEventListener('click', () => {
                document.querySelectorAll('.palette-opt').forEach(p => p.classList.remove('active'));
                el.classList.add('active');
                gb.ppu.paletteName = el.dataset.palette;
            });
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', e => {
            if (e.key === 'p' || e.key === 'P') { if(gb.romData) gb.togglePause(); }
            if (e.key === 'r' && e.ctrlKey) { e.preventDefault(); if(gb.romData) gb.reset(); }
        });

        // Init audio on first interaction
        document.addEventListener('click', () => { if (!gb.apu.enabled) gb.apu.init(); gb.apu.resume(); }, {once: true});
    </script>
</body>
</html>