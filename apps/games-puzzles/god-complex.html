<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GOD COMPLEX ‚Äî You ARE The Deity</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            overflow: hidden;
            color: #fff;
        }

        #gameCanvas {
            display: block;
            cursor: crosshair;
            image-rendering: crisp-edges;
            box-shadow: 0 0 80px rgba(255, 255, 255, 0.3), inset 0 0 100px rgba(0, 0, 0, 0.5);
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #topBar {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 30px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 215, 0, 0.3);
            pointer-events: auto;
        }

        .stat {
            display: inline-block;
            margin: 0 15px;
            font-size: 14px;
            letter-spacing: 1px;
        }

        .stat-label {
            color: #ffd700;
            font-weight: bold;
        }

        .stat-value {
            color: #fff;
            margin-left: 5px;
        }

        #divineEnergyBar {
            display: inline-block;
            width: 150px;
            height: 10px;
            background: rgba(50, 50, 50, 0.8);
            border-radius: 5px;
            overflow: hidden;
            vertical-align: middle;
            margin-left: 10px;
            border: 1px solid #ffd700;
        }

        #divineEnergyFill {
            height: 100%;
            background: linear-gradient(90deg, #ffd700, #ffed4e);
            transition: width 0.3s ease;
            box-shadow: 0 0 10px #ffd700;
        }

        #miracleWheel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            height: 400px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #miracleWheel.active {
            opacity: 1;
            pointer-events: auto;
        }

        .miracle-button {
            position: absolute;
            width: 80px;
            height: 80px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ffd700;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            backdrop-filter: blur(5px);
        }

        .miracle-button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px #ffd700;
            border-color: #fff;
        }

        .miracle-button.cooldown {
            opacity: 0.3;
            cursor: not-allowed;
            border-color: #666;
        }

        .miracle-button.insufficient {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: #f44;
        }

        .miracle-icon {
            font-size: 24px;
        }

        .miracle-name {
            font-size: 9px;
            margin-top: 2px;
            text-align: center;
            color: #ffd700;
        }

        .miracle-cost {
            font-size: 8px;
            color: #aaa;
        }

        #factionPanel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            max-width: 300px;
            max-height: 300px;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 215, 0, 0.3);
            pointer-events: auto;
        }

        .faction-item {
            margin-bottom: 10px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            border-left: 4px solid;
        }

        .faction-name {
            font-weight: bold;
            font-size: 13px;
            margin-bottom: 3px;
        }

        .faction-stat {
            font-size: 10px;
            color: #ccc;
            margin: 2px 0;
        }

        #eventLog {
            position: absolute;
            top: 80px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            width: 350px;
            max-height: 400px;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 215, 0, 0.3);
            pointer-events: auto;
        }

        .event {
            margin-bottom: 10px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            border-left: 3px solid;
            font-size: 12px;
            line-height: 1.4;
        }

        .event.miracle { border-color: #ffd700; }
        .event.theological { border-color: #9370db; }
        .event.war { border-color: #ff4444; }
        .event.schism { border-color: #ff8c00; }
        .event.prophet { border-color: #00ffff; }

        .event-time {
            font-size: 9px;
            color: #888;
            margin-bottom: 3px;
        }

        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            pointer-events: auto;
        }

        #startScreen.hidden {
            display: none;
        }

        #title {
            font-size: 64px;
            font-weight: bold;
            background: linear-gradient(45deg, #ffd700, #ffed4e, #ffd700);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 20px;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            letter-spacing: 4px;
        }

        #subtitle {
            font-size: 20px;
            color: #aaa;
            margin-bottom: 40px;
            font-style: italic;
        }

        #startBtn {
            padding: 20px 50px;
            font-size: 20px;
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            color: #000;
            transition: all 0.3s ease;
            box-shadow: 0 5px 20px rgba(255, 215, 0, 0.4);
        }

        #startBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(255, 215, 0, 0.6);
        }

        .instructions {
            margin-top: 40px;
            max-width: 600px;
            text-align: center;
            color: #ccc;
            line-height: 1.6;
            font-size: 14px;
        }

        #endScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            pointer-events: auto;
        }

        #endScreen.active {
            display: flex;
        }

        .end-title {
            font-size: 48px;
            margin-bottom: 30px;
        }

        .end-stats {
            background: rgba(255, 255, 255, 0.05);
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 30px;
        }

        .end-stat {
            font-size: 18px;
            margin: 10px 0;
        }

        #restartBtn {
            padding: 15px 40px;
            font-size: 18px;
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            color: #000;
        }

        #pauseBtn {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 5px;
            color: #ffd700;
            cursor: pointer;
            pointer-events: auto;
            backdrop-filter: blur(10px);
        }

        #pauseBtn:hover {
            background: rgba(0, 0, 0, 0.9);
            border-color: #ffd700;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 215, 0, 0.5);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 215, 0, 0.7);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="ui">
        <div id="topBar">
            <span class="stat">
                <span class="stat-label">DAY</span>
                <span class="stat-value" id="dayCounter">1</span>
            </span>
            <span class="stat">
                <span class="stat-label">POPULATION</span>
                <span class="stat-value" id="population">200</span>
            </span>
            <span class="stat">
                <span class="stat-label">FACTIONS</span>
                <span class="stat-value" id="factionCount">1</span>
            </span>
            <span class="stat">
                <span class="stat-label">AGE</span>
                <span class="stat-value" id="ageDisplay">Tribal</span>
            </span>
            <span class="stat">
                <span class="stat-label">DIVINE ENERGY</span>
                <span class="stat-value" id="energyDisplay">100</span>
                <div id="divineEnergyBar">
                    <div id="divineEnergyFill" style="width: 100%"></div>
                </div>
            </span>
        </div>

        <button id="pauseBtn">PAUSE</button>

        <div id="miracleWheel">
            <!-- Miracles positioned in circle -->
        </div>

        <div id="factionPanel">
            <div style="font-size: 14px; font-weight: bold; margin-bottom: 10px; color: #ffd700;">FACTIONS</div>
            <div id="factionList"></div>
        </div>

        <div id="eventLog">
            <div style="font-size: 14px; font-weight: bold; margin-bottom: 10px; color: #ffd700;">DIVINE CHRONICLE</div>
            <div id="eventList"></div>
        </div>
    </div>

    <div id="startScreen">
        <div id="title">GOD COMPLEX</div>
        <div id="subtitle">You ARE The Deity</div>
        <button id="startBtn">CREATE WORLD</button>
        <div class="instructions">
            You are a god. Your followers cannot hear your voice ‚Äî only witness your miracles.<br>
            <strong>Right-click</strong> anywhere to open the miracle wheel.<br>
            Every action will be interpreted differently by competing factions.<br>
            Guide your civilization without direct communication. Shape theology through ambiguity.
        </div>
    </div>

    <div id="endScreen">
        <div class="end-title" id="endTitle"></div>
        <div class="end-stats" id="endStats"></div>
        <button id="restartBtn">CREATE NEW WORLD</button>
    </div>

    <script>
        // ==================== CONSTANTS ====================
        const CANVAS_WIDTH = window.innerWidth;
        const CANVAS_HEIGHT = window.innerHeight;
        const WORLD_WIDTH = 800;
        const WORLD_HEIGHT = 600;

        const AGES = ['Tribal', 'Agricultural', 'Urban', 'Imperial', 'Enlightened'];
        const AGE_REQUIREMENTS = [0, 50, 150, 300, 500]; // Population thresholds

        const MIRACLES = {
            LIGHTNING: { name: 'Lightning', icon: '‚ö°', cost: 30, cooldown: 5000, type: 'destructive' },
            RAIN: { name: 'Rain', icon: 'üåßÔ∏è', cost: 20, cooldown: 3000, type: 'constructive' },
            DROUGHT: { name: 'Drought', icon: 'üèúÔ∏è', cost: 25, cooldown: 4000, type: 'punishing' },
            EARTHQUAKE: { name: 'Quake', icon: 'üåç', cost: 40, cooldown: 7000, type: 'dramatic' },
            PLAGUE: { name: 'Plague', icon: '‚ò†Ô∏è', cost: 35, cooldown: 6000, type: 'devastating' },
            HEALING: { name: 'Healing', icon: '‚ú®', cost: 25, cooldown: 4000, type: 'benevolent' },
            BOUNTY: { name: 'Bounty', icon: 'üåæ', cost: 30, cooldown: 5000, type: 'generous' },
            FAMINE: { name: 'Famine', icon: 'üíÄ', cost: 30, cooldown: 5000, type: 'harsh' },
            ECLIPSE: { name: 'Eclipse', icon: 'üåë', cost: 50, cooldown: 10000, type: 'ominous' },
            AURORA: { name: 'Aurora', icon: 'üåå', cost: 35, cooldown: 6000, type: 'mysterious' },
            FLOOD: { name: 'Flood', icon: 'üåä', cost: 45, cooldown: 8000, type: 'catastrophic' },
            RESURRECTION: { name: 'Resurrect', icon: 'üë§', cost: 80, cooldown: 15000, type: 'ultimate' }
        };

        const FACTION_ARCHETYPES = {
            KINDLED: {
                name: 'The Kindled',
                color: '#ff4444',
                interpretations: {
                    LIGHTNING: 'divine approval',
                    RAIN: 'divine tears',
                    EARTHQUAKE: 'divine power',
                    PLAGUE: 'trial by fire',
                    HEALING: 'undeserved mercy',
                    BOUNTY: 'temporary favor',
                    FAMINE: 'test of strength',
                    ECLIPSE: 'divine shadow',
                    AURORA: 'celestial fire',
                    FLOOD: 'cleansing fury',
                    RESURRECTION: 'rebirth through flame'
                }
            },
            NURTURERS: {
                name: 'The Nurturers',
                color: '#44ff44',
                interpretations: {
                    LIGHTNING: 'divine punishment',
                    RAIN: 'divine blessing',
                    EARTHQUAKE: 'disruption of nature',
                    PLAGUE: 'imbalance',
                    HEALING: 'restoration',
                    BOUNTY: 'ultimate blessing',
                    FAMINE: 'abandonment',
                    ECLIPSE: 'nature\'s pause',
                    AURORA: 'nature\'s beauty',
                    FLOOD: 'nature\'s wrath',
                    RESURRECTION: 'cycle continues'
                }
            },
            ASCETICS: {
                name: 'The Ascetics',
                color: '#888888',
                interpretations: {
                    LIGHTNING: 'divine test',
                    RAIN: 'softness weakness',
                    EARTHQUAKE: 'foundation shaking',
                    PLAGUE: 'sacred suffering',
                    HEALING: 'weakness',
                    BOUNTY: 'temptation',
                    FAMINE: 'purification',
                    ECLIPSE: 'darkness reveals truth',
                    AURORA: 'beautiful distraction',
                    FLOOD: 'baptism through pain',
                    RESURRECTION: 'cheating death'
                }
            },
            SEEKERS: {
                name: 'The Seekers',
                color: '#4444ff',
                interpretations: {
                    LIGHTNING: 'energy manifestation',
                    RAIN: 'pattern of cycles',
                    EARTHQUAKE: 'tectonic message',
                    PLAGUE: 'biological lesson',
                    HEALING: 'understanding biology',
                    BOUNTY: 'agricultural knowledge',
                    FAMINE: 'data point',
                    ECLIPSE: 'prophecy revealed',
                    AURORA: 'atmospheric revelation',
                    FLOOD: 'hydrological event',
                    RESURRECTION: 'unknown science'
                }
            },
            WRATHFUL: {
                name: 'The Wrathful',
                color: '#ff8800',
                interpretations: {
                    LIGHTNING: 'divine anger',
                    RAIN: 'temporary mercy',
                    EARTHQUAKE: 'rage unleashed',
                    PLAGUE: 'punishment deserved',
                    HEALING: 'rare forgiveness',
                    BOUNTY: 'last chance',
                    FAMINE: 'wrath continues',
                    ECLIPSE: 'god turns away',
                    AURORA: 'false hope',
                    FLOOD: 'apocalypse',
                    RESURRECTION: 'second chance for judgment'
                }
            }
        };

        const TERRAIN_TYPES = {
            GRASS: { color: '#4a7c3f', fertility: 0.8 },
            FOREST: { color: '#2d5016', fertility: 0.6 },
            MOUNTAIN: { color: '#6b6b6b', fertility: 0.2 },
            DESERT: { color: '#d4a574', fertility: 0.3 },
            WATER: { color: '#3b5998', fertility: 0 },
            PLAINS: { color: '#8fbc8f', fertility: 0.9 }
        };

        // ==================== GAME STATE ====================
        let gameState = {
            day: 1,
            age: 0,
            divineEnergy: 100,
            maxDivineEnergy: 100,
            followers: [],
            factions: [],
            settlements: [],
            terrain: [],
            miracles: [],
            events: [],
            cooldowns: {},
            paused: false,
            timeOfDay: 0, // 0-1
            season: 0, // 0-3
            score: {
                totalPopulation: 0,
                peaceYears: 0,
                warYears: 0,
                miraclesPerformed: 0,
                factionsCreated: 0
            }
        };

        // ==================== CANVAS SETUP ====================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        // ==================== TERRAIN GENERATION ====================
        function generateTerrain() {
            const terrain = [];
            const cellSize = 20;
            const cols = Math.ceil(WORLD_WIDTH / cellSize);
            const rows = Math.ceil(WORLD_HEIGHT / cellSize);

            // Simple noise-like generation
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const noise = Math.random();
                    let type;
                    if (noise < 0.1) type = 'WATER';
                    else if (noise < 0.3) type = 'DESERT';
                    else if (noise < 0.4) type = 'MOUNTAIN';
                    else if (noise < 0.6) type = 'FOREST';
                    else if (noise < 0.8) type = 'GRASS';
                    else type = 'PLAINS';

                    terrain.push({
                        x: x * cellSize,
                        y: y * cellSize,
                        type,
                        fertility: TERRAIN_TYPES[type].fertility,
                        water: type === 'WATER' ? 1 : Math.random() * 0.3
                    });
                }
            }
            return terrain;
        }

        // ==================== FOLLOWER CREATION ====================
        function createFollower(x, y, factionId = 0) {
            return {
                id: Math.random().toString(36).substr(2, 9),
                x: x || Math.random() * WORLD_WIDTH,
                y: y || Math.random() * WORLD_HEIGHT,
                factionId,
                age: Math.floor(Math.random() * 60) + 20,
                health: 100,
                faith: 50 + Math.random() * 50,
                isAlive: true,
                isProphet: false,
                vx: 0,
                vy: 0
            };
        }

        // ==================== FACTION CREATION ====================
        function createFaction(archetype, parentFaction = null) {
            const archetypeData = FACTION_ARCHETYPES[archetype];
            return {
                id: Math.random().toString(36).substr(2, 9),
                name: archetypeData.name + (parentFaction ? ' Reformed' : ''),
                archetype,
                color: archetypeData.color,
                population: 0,
                fervor: 50,
                militaryStrength: 10,
                theologicalComplexity: parentFaction ? parentFaction.theologicalComplexity + 10 : 10,
                interpretations: { ...archetypeData.interpretations },
                temples: 0,
                at_war_with: [],
                founded_day: gameState.day
            };
        }

        // ==================== INITIALIZATION ====================
        function initGame() {
            gameState = {
                day: 1,
                age: 0,
                divineEnergy: 100,
                maxDivineEnergy: 100,
                followers: [],
                factions: [],
                settlements: [],
                terrain: generateTerrain(),
                miracles: [],
                events: [],
                cooldowns: {},
                paused: false,
                timeOfDay: 0.5,
                season: 0,
                score: {
                    totalPopulation: 0,
                    peaceYears: 0,
                    warYears: 0,
                    miraclesPerformed: 0,
                    factionsCreated: 0
                }
            };

            // Create initial faction (unified belief)
            const initialFaction = createFaction('NURTURERS');
            gameState.factions.push(initialFaction);
            gameState.score.factionsCreated = 1;

            // Create initial followers
            for (let i = 0; i < 200; i++) {
                const follower = createFollower();
                gameState.followers.push(follower);
            }

            // Create initial settlements
            for (let i = 0; i < 5; i++) {
                gameState.settlements.push({
                    x: Math.random() * WORLD_WIDTH,
                    y: Math.random() * WORLD_HEIGHT,
                    population: 40,
                    factionId: initialFaction.id
                });
            }

            addEvent('The world begins. Followers await divine guidance.', 'theological');
            updateUI();
            saveGame();
        }

        // ==================== EVENT LOGGING ====================
        function addEvent(text, type = 'theological') {
            const event = {
                text,
                type,
                day: gameState.day,
                time: Date.now()
            };
            gameState.events.unshift(event);
            if (gameState.events.length > 50) gameState.events.pop();

            const eventList = document.getElementById('eventList');
            const eventDiv = document.createElement('div');
            eventDiv.className = `event ${type}`;
            eventDiv.innerHTML = `
                <div class="event-time">Day ${gameState.day}</div>
                ${text}
            `;
            eventList.insertBefore(eventDiv, eventList.firstChild);
            if (eventList.children.length > 30) {
                eventList.removeChild(eventList.lastChild);
            }
        }

        // ==================== MIRACLE SYSTEM ====================
        function performMiracle(miracleKey, worldX, worldY) {
            const miracle = MIRACLES[miracleKey];

            // Check cooldown
            if (gameState.cooldowns[miracleKey] && Date.now() < gameState.cooldowns[miracleKey]) {
                return false;
            }

            // Check energy
            if (gameState.divineEnergy < miracle.cost) {
                return false;
            }

            // Consume energy
            gameState.divineEnergy -= miracle.cost;
            gameState.cooldowns[miracleKey] = Date.now() + miracle.cooldown;
            gameState.score.miraclesPerformed++;

            // Create visual miracle effect
            gameState.miracles.push({
                type: miracleKey,
                x: worldX,
                y: worldY,
                startTime: Date.now(),
                duration: 2000
            });

            // Apply physical effects
            applyMiraclePhysics(miracleKey, worldX, worldY);

            // Generate theological interpretations
            interpretMiracle(miracleKey, worldX, worldY);

            addEvent(`You cast ${miracle.name} upon the world.`, 'miracle');
            updateUI();
            return true;
        }

        function applyMiraclePhysics(miracleKey, x, y) {
            const radius = 80;

            switch(miracleKey) {
                case 'LIGHTNING':
                    // Kill followers in radius
                    gameState.followers.forEach(f => {
                        const dist = Math.hypot(f.x - x, f.y - y);
                        if (dist < radius && Math.random() < 0.3) {
                            f.isAlive = false;
                        }
                    });
                    break;

                case 'RAIN':
                    // Increase water in terrain
                    gameState.terrain.forEach(t => {
                        const dist = Math.hypot(t.x - x, t.y - y);
                        if (dist < radius * 2) {
                            t.water = Math.min(1, t.water + 0.3);
                        }
                    });
                    break;

                case 'DROUGHT':
                    // Decrease water
                    gameState.terrain.forEach(t => {
                        const dist = Math.hypot(t.x - x, t.y - y);
                        if (dist < radius * 2) {
                            t.water = Math.max(0, t.water - 0.5);
                        }
                    });
                    break;

                case 'EARTHQUAKE':
                    // Damage settlements, kill followers
                    gameState.followers.forEach(f => {
                        const dist = Math.hypot(f.x - x, f.y - y);
                        if (dist < radius) {
                            f.health -= 40;
                            if (f.health <= 0) f.isAlive = false;
                        }
                    });
                    break;

                case 'PLAGUE':
                    // Spread disease
                    gameState.followers.forEach(f => {
                        const dist = Math.hypot(f.x - x, f.y - y);
                        if (dist < radius * 1.5 && Math.random() < 0.5) {
                            f.health -= 60;
                            if (f.health <= 0) f.isAlive = false;
                        }
                    });
                    break;

                case 'HEALING':
                    // Heal followers
                    gameState.followers.forEach(f => {
                        const dist = Math.hypot(f.x - x, f.y - y);
                        if (dist < radius) {
                            f.health = 100;
                        }
                    });
                    break;

                case 'BOUNTY':
                    // Increase fertility
                    gameState.terrain.forEach(t => {
                        const dist = Math.hypot(t.x - x, t.y - y);
                        if (dist < radius * 2) {
                            t.fertility = Math.min(1, t.fertility + 0.3);
                        }
                    });
                    break;

                case 'FAMINE':
                    // Decrease fertility and kill
                    gameState.terrain.forEach(t => {
                        const dist = Math.hypot(t.x - x, t.y - y);
                        if (dist < radius * 2) {
                            t.fertility = Math.max(0, t.fertility - 0.4);
                        }
                    });
                    gameState.followers.forEach(f => {
                        const dist = Math.hypot(f.x - x, f.y - y);
                        if (dist < radius && Math.random() < 0.2) {
                            f.isAlive = false;
                        }
                    });
                    break;

                case 'RESURRECTION':
                    // Revive nearest dead follower
                    const deadFollowers = gameState.followers.filter(f => !f.isAlive);
                    if (deadFollowers.length > 0) {
                        const nearest = deadFollowers.reduce((closest, f) => {
                            const dist = Math.hypot(f.x - x, f.y - y);
                            return dist < Math.hypot(closest.x - x, closest.y - y) ? f : closest;
                        });
                        nearest.isAlive = true;
                        nearest.health = 100;
                        nearest.faith = 100;
                        addEvent('A soul returns from beyond. The people witness the impossible.', 'miracle');
                    }
                    break;
            }
        }

        function interpretMiracle(miracleKey, x, y) {
            const radius = 150;
            const affectedFactions = new Set();

            // Find which factions witnessed this
            gameState.followers.forEach(f => {
                if (!f.isAlive) return;
                const dist = Math.hypot(f.x - x, f.y - y);
                if (dist < radius) {
                    affectedFactions.add(f.factionId);
                }
            });

            // Each faction interprets based on their archetype
            affectedFactions.forEach(factionId => {
                const faction = gameState.factions.find(f => f.id === factionId);
                if (!faction) return;

                const interpretation = faction.interpretations[miracleKey] || 'mysterious sign';

                // Adjust fervor based on interpretation sentiment
                const positive = ['blessing', 'approval', 'favor', 'beauty', 'restoration', 'knowledge'];
                const negative = ['punishment', 'weakness', 'abandonment', 'wrath', 'test'];

                let fervorChange = 0;
                if (positive.some(word => interpretation.includes(word))) {
                    fervorChange = 5 + Math.random() * 10;
                } else if (negative.some(word => interpretation.includes(word))) {
                    fervorChange = -(5 + Math.random() * 10);
                }

                faction.fervor = Math.max(0, Math.min(100, faction.fervor + fervorChange));
                faction.theologicalComplexity += 1;

                addEvent(
                    `${faction.name} witness ${MIRACLES[miracleKey].name} ‚Äî they interpret it as ${interpretation}.`,
                    'theological'
                );

                // Chance of schism if complexity too high
                if (faction.theologicalComplexity > 80 && Math.random() < 0.15) {
                    triggerSchism(faction);
                }

                // Chance of prophet spawning
                if (fervorChange > 10 && Math.random() < 0.1) {
                    spawnProphet(faction);
                }
            });
        }

        // ==================== FACTION DYNAMICS ====================
        function triggerSchism(parentFaction) {
            // Create breakaway faction with different archetype
            const archetypes = Object.keys(FACTION_ARCHETYPES);
            const newArchetype = archetypes[Math.floor(Math.random() * archetypes.length)];
            const newFaction = createFaction(newArchetype, parentFaction);

            gameState.factions.push(newFaction);
            gameState.score.factionsCreated++;

            // Split followers
            const parentFollowers = gameState.followers.filter(f => f.factionId === parentFaction.id && f.isAlive);
            const splitCount = Math.floor(parentFollowers.length * (0.2 + Math.random() * 0.3));

            for (let i = 0; i < splitCount; i++) {
                if (parentFollowers[i]) {
                    parentFollowers[i].factionId = newFaction.id;
                }
            }

            addEvent(
                `SCHISM! ${newFaction.name} break away from ${parentFaction.name} over theological disputes.`,
                'schism'
            );
        }

        function spawnProphet(faction) {
            const factionFollowers = gameState.followers.filter(f =>
                f.factionId === faction.id && f.isAlive && !f.isProphet
            );

            if (factionFollowers.length === 0) return;

            const prophet = factionFollowers[Math.floor(Math.random() * factionFollowers.length)];
            prophet.isProphet = true;
            prophet.faith = 100;

            addEvent(
                `A prophet arises among ${faction.name}! They claim divine revelation.`,
                'prophet'
            );

            // Prophet dramatically increases fervor
            faction.fervor = Math.min(100, faction.fervor + 20);
        }

        function checkForWars() {
            // Factions with incompatible interpretations near each other = war
            for (let i = 0; i < gameState.factions.length; i++) {
                for (let j = i + 1; j < gameState.factions.length; j++) {
                    const f1 = gameState.factions[i];
                    const f2 = gameState.factions[j];

                    // Already at war
                    if (f1.at_war_with.includes(f2.id)) continue;

                    // Check proximity and theological incompatibility
                    const f1Followers = gameState.followers.filter(f => f.factionId === f1.id && f.isAlive);
                    const f2Followers = gameState.followers.filter(f => f.factionId === f2.id && f.isAlive);

                    if (f1Followers.length === 0 || f2Followers.length === 0) continue;

                    // Calculate average distance between factions
                    let totalDist = 0;
                    let count = 0;
                    for (const follower1 of f1Followers.slice(0, 10)) {
                        for (const follower2 of f2Followers.slice(0, 10)) {
                            totalDist += Math.hypot(follower1.x - follower2.x, follower1.y - follower2.y);
                            count++;
                        }
                    }
                    const avgDist = totalDist / count;

                    // If close enough and high fervor = war
                    if (avgDist < 200 && (f1.fervor > 70 || f2.fervor > 70) && Math.random() < 0.05) {
                        f1.at_war_with.push(f2.id);
                        f2.at_war_with.push(f1.id);
                        addEvent(
                            `HOLY WAR! ${f1.name} and ${f2.name} clash over irreconcilable beliefs.`,
                            'war'
                        );
                    }
                }
            }
        }

        function simulateWars() {
            gameState.factions.forEach(faction => {
                if (faction.at_war_with.length === 0) return;

                faction.at_war_with.forEach(enemyId => {
                    const enemy = gameState.factions.find(f => f.id === enemyId);
                    if (!enemy) return;

                    // Combat casualties
                    const factionFollowers = gameState.followers.filter(f => f.factionId === faction.id && f.isAlive);
                    const enemyFollowers = gameState.followers.filter(f => f.factionId === enemy.id && f.isAlive);

                    // Kill some followers from each side
                    const casualties = Math.min(factionFollowers.length, enemyFollowers.length, 5);
                    for (let i = 0; i < casualties; i++) {
                        if (Math.random() < 0.5 && factionFollowers[i]) {
                            factionFollowers[i].isAlive = false;
                        }
                        if (Math.random() < 0.5 && enemyFollowers[i]) {
                            enemyFollowers[i].isAlive = false;
                        }
                    }
                });
            });

            // Check for war endings
            gameState.factions.forEach(faction => {
                faction.at_war_with = faction.at_war_with.filter(enemyId => {
                    const enemy = gameState.factions.find(f => f.id === enemyId);
                    if (!enemy) return false;

                    const enemyPop = gameState.followers.filter(f => f.factionId === enemy.id && f.isAlive).length;
                    const factionPop = gameState.followers.filter(f => f.factionId === faction.id && f.isAlive).length;

                    // War ends if one side is too weak
                    if (enemyPop < 10 || factionPop < 10) {
                        addEvent(`The war between ${faction.name} and ${enemy.name} ends.`, 'war');
                        return false;
                    }
                    return true;
                });
            });
        }

        // ==================== CIVILIZATION PROGRESSION ====================
        function updateAge() {
            const totalPop = gameState.followers.filter(f => f.isAlive).length;
            for (let i = AGES.length - 1; i >= 0; i--) {
                if (totalPop >= AGE_REQUIREMENTS[i] && gameState.age < i) {
                    gameState.age = i;
                    addEvent(`Civilization advances to the ${AGES[i]} Age!`, 'theological');
                    break;
                }
            }
        }

        // ==================== SIMULATION TICK ====================
        function simulateTick() {
            if (gameState.paused) return;

            // Remove dead followers
            const aliveBefore = gameState.followers.filter(f => f.isAlive).length;
            gameState.followers = gameState.followers.filter(f => f.isAlive || Math.random() < 0.1); // Keep some dead for resurrection

            // Natural death
            gameState.followers.forEach(f => {
                if (!f.isAlive) return;
                f.age += 0.1;
                if (f.age > 80 && Math.random() < 0.001) {
                    f.isAlive = false;
                }
            });

            // Birth (in settlements with good fertility)
            gameState.settlements.forEach(settlement => {
                const terrain = gameState.terrain.find(t =>
                    Math.hypot(t.x - settlement.x, t.y - settlement.y) < 50
                );
                if (terrain && terrain.fertility > 0.5 && terrain.water > 0.3 && Math.random() < 0.02) {
                    const baby = createFollower(
                        settlement.x + (Math.random() - 0.5) * 40,
                        settlement.y + (Math.random() - 0.5) * 40,
                        settlement.factionId
                    );
                    baby.age = 0;
                    gameState.followers.push(baby);
                }
            });

            // Move followers slightly (migration toward settlements)
            gameState.followers.forEach(f => {
                if (!f.isAlive) return;
                const nearestSettlement = gameState.settlements.reduce((closest, s) => {
                    const dist = Math.hypot(s.x - f.x, s.y - f.y);
                    return dist < Math.hypot(closest.x - f.x, closest.y - f.y) ? s : closest;
                }, gameState.settlements[0]);

                if (nearestSettlement) {
                    const dx = nearestSettlement.x - f.x;
                    const dy = nearestSettlement.y - f.y;
                    const dist = Math.hypot(dx, dy);
                    if (dist > 20) {
                        f.x += (dx / dist) * 0.5;
                        f.y += (dy / dist) * 0.5;
                    }
                }

                // Keep in bounds
                f.x = Math.max(0, Math.min(WORLD_WIDTH, f.x));
                f.y = Math.max(0, Math.min(WORLD_HEIGHT, f.y));
            });

            // Update faction populations
            gameState.factions.forEach(faction => {
                faction.population = gameState.followers.filter(f =>
                    f.factionId === faction.id && f.isAlive
                ).length;
            });

            // Remove extinct factions
            gameState.factions = gameState.factions.filter(f => f.population > 0);

            // Check for wars
            if (gameState.day % 10 === 0) {
                checkForWars();
            }

            // Simulate wars
            if (gameState.day % 3 === 0) {
                simulateWars();
            }

            // Track war/peace
            const atWar = gameState.factions.some(f => f.at_war_with.length > 0);
            if (atWar) {
                gameState.score.warYears += 1;
            } else {
                gameState.score.peaceYears += 1;
            }

            // Update age
            updateAge();

            // Regenerate divine energy (based on worship)
            const worshipRate = gameState.followers.filter(f => f.isAlive).length * 0.01;
            gameState.divineEnergy = Math.min(gameState.maxDivineEnergy, gameState.divineEnergy + worshipRate);

            // Update time of day and season
            gameState.timeOfDay = (gameState.timeOfDay + 0.02) % 1;
            if (gameState.day % 90 === 0) {
                gameState.season = (gameState.season + 1) % 4;
            }

            // Check end conditions
            checkEndConditions();
        }

        function checkEndConditions() {
            const alivePop = gameState.followers.filter(f => f.isAlive).length;

            // Apocalypse
            if (alivePop < 10) {
                endGame('APOCALYPSE', 'Your civilization has collapsed. The world lies in ruin.');
                return;
            }

            // Abandonment
            if (gameState.divineEnergy < 5 && alivePop > 0) {
                const avgFaith = gameState.followers.reduce((sum, f) => sum + (f.isAlive ? f.faith : 0), 0) / alivePop;
                if (avgFaith < 10) {
                    endGame('ABANDONMENT', 'The people have stopped believing. You fade from existence.');
                    return;
                }
            }

            // Harmony
            if (gameState.factions.length === 1 && alivePop > 100 && gameState.day > 200) {
                endGame('HARMONY', 'All followers united under one faith. Perfect theological unity.');
                return;
            }

            // Transcendence
            if (gameState.age === 4 && alivePop > 300) {
                endGame('TRANSCENDENCE', 'Your followers have achieved enlightenment and understand your true nature.');
                return;
            }
        }

        function endGame(outcome, message) {
            gameState.paused = true;
            const endScreen = document.getElementById('endScreen');
            document.getElementById('endTitle').textContent = outcome;

            const totalPop = gameState.followers.filter(f => f.isAlive).length;
            const totalScore = totalPop + gameState.score.peaceYears * 10 - gameState.score.warYears * 5 + gameState.score.miraclesPerformed * 5;

            document.getElementById('endStats').innerHTML = `
                <div class="end-stat">${message}</div>
                <div class="end-stat">Days Survived: ${gameState.day}</div>
                <div class="end-stat">Final Population: ${totalPop}</div>
                <div class="end-stat">Factions Created: ${gameState.score.factionsCreated}</div>
                <div class="end-stat">Miracles Performed: ${gameState.score.miraclesPerformed}</div>
                <div class="end-stat">Years of Peace: ${gameState.score.peaceYears}</div>
                <div class="end-stat">Years of War: ${gameState.score.warYears}</div>
                <div class="end-stat">Final Age: ${AGES[gameState.age]}</div>
                <div class="end-stat" style="margin-top: 20px; font-size: 24px; color: #ffd700;">Score: ${totalScore}</div>
            `;
            endScreen.classList.add('active');
        }

        // ==================== RENDERING ====================
        function render() {
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // Calculate camera offset to center world
            const offsetX = (CANVAS_WIDTH - WORLD_WIDTH) / 2;
            const offsetY = (CANVAS_HEIGHT - WORLD_HEIGHT) / 2;

            ctx.save();
            ctx.translate(offsetX, offsetY);

            // Draw terrain
            gameState.terrain.forEach(cell => {
                const baseColor = TERRAIN_TYPES[cell.type].color;
                const waterMod = Math.floor(cell.water * 30);
                ctx.fillStyle = adjustColor(baseColor, waterMod);
                ctx.fillRect(cell.x, cell.y, 20, 20);
            });

            // Draw settlements
            gameState.settlements.forEach(settlement => {
                const faction = gameState.factions.find(f => f.id === settlement.factionId);
                const color = faction ? faction.color : '#888';
                ctx.fillStyle = color + '44';
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                const size = 15 + Math.sqrt(settlement.population);
                ctx.beginPath();
                ctx.arc(settlement.x, settlement.y, size, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            });

            // Draw followers
            gameState.followers.forEach(follower => {
                if (!follower.isAlive) return;
                const faction = gameState.factions.find(f => f.id === follower.factionId);
                const color = faction ? faction.color : '#888';

                ctx.fillStyle = color;
                if (follower.isProphet) {
                    ctx.strokeStyle = '#ffd700';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(follower.x, follower.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                } else {
                    ctx.fillRect(follower.x - 1, follower.y - 1, 2, 2);
                }
            });

            // Draw miracles
            const now = Date.now();
            gameState.miracles = gameState.miracles.filter(m => now - m.startTime < m.duration);
            gameState.miracles.forEach(miracle => {
                const progress = (now - miracle.startTime) / miracle.duration;
                const alpha = 1 - progress;
                const radius = 50 + progress * 100;

                ctx.save();
                ctx.globalAlpha = alpha;

                switch(miracle.type) {
                    case 'LIGHTNING':
                        ctx.strokeStyle = '#ffff00';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        for (let i = 0; i < 5; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const len = radius;
                            ctx.moveTo(miracle.x, miracle.y);
                            ctx.lineTo(miracle.x + Math.cos(angle) * len, miracle.y + Math.sin(angle) * len);
                        }
                        ctx.stroke();
                        break;

                    case 'RAIN':
                        ctx.fillStyle = '#4444ff';
                        for (let i = 0; i < 20; i++) {
                            const x = miracle.x + (Math.random() - 0.5) * radius * 2;
                            const y = miracle.y + (Math.random() - 0.5) * radius * 2;
                            ctx.fillRect(x, y, 1, 5);
                        }
                        break;

                    case 'EARTHQUAKE':
                        ctx.strokeStyle = '#8B4513';
                        ctx.lineWidth = 2;
                        for (let i = 0; i < 8; i++) {
                            const angle = (i / 8) * Math.PI * 2;
                            ctx.beginPath();
                            ctx.moveTo(miracle.x, miracle.y);
                            ctx.lineTo(
                                miracle.x + Math.cos(angle) * radius,
                                miracle.y + Math.sin(angle) * radius
                            );
                            ctx.stroke();
                        }
                        break;

                    case 'HEALING':
                    case 'BOUNTY':
                        ctx.strokeStyle = '#00ff00';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(miracle.x, miracle.y, radius, 0, Math.PI * 2);
                        ctx.stroke();
                        break;

                    case 'PLAGUE':
                    case 'FAMINE':
                        ctx.fillStyle = '#660066';
                        for (let i = 0; i < 15; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const dist = Math.random() * radius;
                            ctx.beginPath();
                            ctx.arc(
                                miracle.x + Math.cos(angle) * dist,
                                miracle.y + Math.sin(angle) * dist,
                                2, 0, Math.PI * 2
                            );
                            ctx.fill();
                        }
                        break;

                    case 'ECLIPSE':
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(miracle.x, miracle.y, radius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        break;

                    case 'AURORA':
                        const gradient = ctx.createRadialGradient(miracle.x, miracle.y, 0, miracle.x, miracle.y, radius);
                        gradient.addColorStop(0, '#00ffff');
                        gradient.addColorStop(0.5, '#ff00ff');
                        gradient.addColorStop(1, 'transparent');
                        ctx.fillStyle = gradient;
                        ctx.fillRect(miracle.x - radius, miracle.y - radius, radius * 2, radius * 2);
                        break;

                    case 'FLOOD':
                        ctx.fillStyle = '#3b5998';
                        ctx.beginPath();
                        ctx.arc(miracle.x, miracle.y, radius, 0, Math.PI * 2);
                        ctx.fill();
                        break;

                    case 'RESURRECTION':
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(miracle.x, miracle.y, radius * 0.5, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.arc(miracle.x, miracle.y, radius, 0, Math.PI * 2);
                        ctx.stroke();
                        break;
                }

                ctx.restore();
            });

            ctx.restore();

            // Draw vignette
            const gradient = ctx.createRadialGradient(
                CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, CANVAS_WIDTH * 0.3,
                CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, CANVAS_WIDTH * 0.7
            );
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0.4)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        }

        function adjustColor(hex, amount) {
            const num = parseInt(hex.slice(1), 16);
            const r = Math.max(0, Math.min(255, (num >> 16) + amount));
            const g = Math.max(0, Math.min(255, ((num >> 8) & 0x00FF) + amount));
            const b = Math.max(0, Math.min(255, (num & 0x0000FF) + amount));
            return '#' + ((r << 16) | (g << 8) | b).toString(16).padStart(6, '0');
        }

        // ==================== UI UPDATES ====================
        function updateUI() {
            document.getElementById('dayCounter').textContent = gameState.day;
            document.getElementById('population').textContent = gameState.followers.filter(f => f.isAlive).length;
            document.getElementById('factionCount').textContent = gameState.factions.length;
            document.getElementById('ageDisplay').textContent = AGES[gameState.age];
            document.getElementById('energyDisplay').textContent = Math.floor(gameState.divineEnergy);
            document.getElementById('divineEnergyFill').style.width =
                (gameState.divineEnergy / gameState.maxDivineEnergy * 100) + '%';

            // Update faction list
            const factionList = document.getElementById('factionList');
            factionList.innerHTML = '';
            gameState.factions.forEach(faction => {
                const div = document.createElement('div');
                div.className = 'faction-item';
                div.style.borderColor = faction.color;
                div.innerHTML = `
                    <div class="faction-name" style="color: ${faction.color}">${faction.name}</div>
                    <div class="faction-stat">Population: ${faction.population}</div>
                    <div class="faction-stat">Fervor: ${Math.floor(faction.fervor)}</div>
                    <div class="faction-stat">Complexity: ${Math.floor(faction.theologicalComplexity)}</div>
                    ${faction.at_war_with.length > 0 ? '<div class="faction-stat" style="color: #ff4444;">At War</div>' : ''}
                `;
                factionList.appendChild(div);
            });

            // Update miracle buttons cooldowns
            updateMiracleButtons();
        }

        function updateMiracleButtons() {
            const now = Date.now();
            Object.keys(MIRACLES).forEach(key => {
                const button = document.querySelector(`[data-miracle="${key}"]`);
                if (!button) return;

                const cooldownEnd = gameState.cooldowns[key] || 0;
                const onCooldown = now < cooldownEnd;
                const insufficient = gameState.divineEnergy < MIRACLES[key].cost;

                button.classList.remove('cooldown', 'insufficient');
                if (onCooldown) {
                    button.classList.add('cooldown');
                } else if (insufficient) {
                    button.classList.add('insufficient');
                }
            });
        }

        // ==================== MIRACLE WHEEL ====================
        function createMiracleWheel() {
            const wheel = document.getElementById('miracleWheel');
            const keys = Object.keys(MIRACLES);
            const angleStep = (Math.PI * 2) / keys.length;

            keys.forEach((key, index) => {
                const miracle = MIRACLES[key];
                const angle = index * angleStep - Math.PI / 2;
                const radius = 140;
                const x = Math.cos(angle) * radius + 200 - 40;
                const y = Math.sin(angle) * radius + 200 - 40;

                const button = document.createElement('div');
                button.className = 'miracle-button';
                button.dataset.miracle = key;
                button.style.left = x + 'px';
                button.style.top = y + 'px';
                button.innerHTML = `
                    <div class="miracle-icon">${miracle.icon}</div>
                    <div class="miracle-name">${miracle.name}</div>
                    <div class="miracle-cost">${miracle.cost}</div>
                `;

                button.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (currentMiracleTarget) {
                        performMiracle(key, currentMiracleTarget.x, currentMiracleTarget.y);
                        wheel.classList.remove('active');
                        currentMiracleTarget = null;
                    }
                });

                wheel.appendChild(button);
            });
        }

        let currentMiracleTarget = null;

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Convert to world coordinates
            const offsetX = (CANVAS_WIDTH - WORLD_WIDTH) / 2;
            const offsetY = (CANVAS_HEIGHT - WORLD_HEIGHT) / 2;
            const worldX = x - offsetX;
            const worldY = y - offsetY;

            if (worldX >= 0 && worldX <= WORLD_WIDTH && worldY >= 0 && worldY <= WORLD_HEIGHT) {
                currentMiracleTarget = { x: worldX, y: worldY };
                document.getElementById('miracleWheel').classList.add('active');
            }
        });

        document.addEventListener('click', (e) => {
            if (!e.target.closest('#miracleWheel')) {
                document.getElementById('miracleWheel').classList.remove('active');
                currentMiracleTarget = null;
            }
        });

        // ==================== SAVE/LOAD ====================
        function saveGame() {
            try {
                localStorage.setItem('godComplexSave', JSON.stringify(gameState));
            } catch (e) {
                console.warn('Could not save game:', e);
            }
        }

        function loadGame() {
            try {
                const saved = localStorage.getItem('godComplexSave');
                if (saved) {
                    gameState = JSON.parse(saved);
                    updateUI();
                    return true;
                }
            } catch (e) {
                console.warn('Could not load game:', e);
            }
            return false;
        }

        // ==================== GAME LOOP ====================
        let lastDayUpdate = Date.now();
        const DAY_LENGTH = 10000; // 10 seconds = 1 day

        function gameLoop() {
            const now = Date.now();

            if (!gameState.paused) {
                // Advance day
                if (now - lastDayUpdate > DAY_LENGTH) {
                    gameState.day++;
                    lastDayUpdate = now;
                    simulateTick();
                    updateUI();

                    // Auto-save every 10 days
                    if (gameState.day % 10 === 0) {
                        saveGame();
                    }
                }
            }

            render();
            updateMiracleButtons();
            requestAnimationFrame(gameLoop);
        }

        // ==================== AUDIO ====================
        let audioContext;
        let masterGain;
        let choirOscillators = [];

        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                masterGain = audioContext.createGain();
                masterGain.gain.value = 0.1;
                masterGain.connect(audioContext.destination);

                // Ambient choir drone
                const frequencies = [130.81, 164.81, 196.00, 246.94]; // C3, E3, G3, B3
                frequencies.forEach(freq => {
                    const osc = audioContext.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.value = freq;

                    const gain = audioContext.createGain();
                    gain.gain.value = 0.02;

                    osc.connect(gain);
                    gain.connect(masterGain);
                    osc.start();

                    choirOscillators.push({ osc, gain });
                });
            } catch (e) {
                console.warn('Audio not available:', e);
            }
        }

        // ==================== EVENT HANDLERS ====================
        document.getElementById('startBtn').addEventListener('click', () => {
            document.getElementById('startScreen').classList.add('hidden');
            initGame();
            initAudio();
            gameLoop();
        });

        document.getElementById('restartBtn').addEventListener('click', () => {
            document.getElementById('endScreen').classList.remove('active');
            document.getElementById('startScreen').classList.remove('hidden');
        });

        document.getElementById('pauseBtn').addEventListener('click', () => {
            gameState.paused = !gameState.paused;
            document.getElementById('pauseBtn').textContent = gameState.paused ? 'RESUME' : 'PAUSE';
        });

        // ==================== INITIALIZATION ====================
        createMiracleWheel();

        // Try to load saved game
        if (loadGame()) {
            document.getElementById('startScreen').classList.add('hidden');
            gameLoop();
        }
    </script>
</body>
</html>