<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aero Architect: The Wind Tunnel</title>
    <meta name="description" content="A puzzle game where you master fluid dynamics. Design wind tunnels, control airflow, and learn real aerodynamics in this AAA-lite simulation game.">
    <style>
        :root {
            --bg-color: #0a0a12;
            --panel-bg: rgba(16, 20, 30, 0.9);
            --accent-color: #00f3ff;
            --accent-glow: 0 0 10px #00f3ff;
            --text-color: #e0e6ed;
            --success-color: #00ff9d;
            --warning-color: #ffcc00;
            --danger-color: #ff0055;
            --font-main: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            --font-mono: 'Consolas', 'Monaco', monospace;
        }

        * {
            box-sizing: border-box;
            user-select: none;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-main);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
        }

        .hud-panel {
            background: var(--panel-bg);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-left: 4px solid var(--accent-color);
            padding: 15px;
            border-radius: 4px;
            pointer-events: auto;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        /* Top Bar */
        #top-bar {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            width: 100%;
        }

        #level-info {
            max-width: 400px;
        }

        h1 {
            margin: 0 0 5px 0;
            font-size: 24px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--accent-color);
            text-shadow: var(--accent-glow);
        }

        h2 {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #8899aa;
            font-weight: 400;
        }

        #objective {
            font-size: 14px;
            line-height: 1.4;
            color: #ccddee;
        }

        #simulation-stats {
            text-align: right;
            font-family: var(--font-mono);
            font-size: 12px;
            color: #667788;
        }

        .stat-value {
            color: var(--accent-color);
            font-weight: bold;
        }

        /* Bottom Bar */
        #bottom-bar {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            gap: 20px;
        }

        #toolbox {
            display: flex;
            gap: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .tool-btn {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #aaa;
            font-size: 10px;
            transition: all 0.2s;
        }

        .tool-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border-color: var(--accent-color);
        }

        .tool-btn.active {
            background: rgba(0, 243, 255, 0.2);
            border-color: var(--accent-color);
            color: var(--accent-color);
            box-shadow: var(--accent-glow);
        }

        .tool-icon {
            font-size: 24px;
            margin-bottom: 4px;
        }

        #controls {
            display: flex;
            gap: 10px;
        }

        .control-btn {
            padding: 10px 20px;
            background: var(--accent-color);
            color: #000;
            border: none;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
        }

        .control-btn:hover {
            background: #fff;
            box-shadow: 0 0 15px var(--accent-color);
        }

        .control-btn.secondary {
            background: transparent;
            border: 1px solid var(--accent-color);
            color: var(--accent-color);
        }

        .control-btn.secondary:hover {
            background: rgba(0, 243, 255, 0.1);
        }

        /* Tutorial / Message Overlay */
        #message-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 12, 18, 0.95);
            border: 1px solid var(--accent-color);
            padding: 40px;
            border-radius: 8px;
            max-width: 600px;
            text-align: center;
            pointer-events: auto;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
            display: none;
            z-index: 100;
        }

        #message-overlay.visible {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        #message-title {
            font-size: 32px;
            color: var(--accent-color);
            margin-bottom: 20px;
            text-transform: uppercase;
        }

        #message-body {
            font-size: 18px;
            line-height: 1.6;
            margin-bottom: 30px;
            color: #ccc;
        }

        #message-btn {
            padding: 15px 40px;
            font-size: 18px;
        }

        /* Educational Tooltip */
        #edu-tooltip {
            position: absolute;
            bottom: 120px;
            right: 20px;
            width: 300px;
            background: rgba(0, 20, 40, 0.9);
            border: 1px solid var(--success-color);
            padding: 15px;
            border-radius: 4px;
            display: none;
            animation: slideIn 0.5s ease;
        }

        #edu-tooltip h3 {
            color: var(--success-color);
            margin: 0 0 5px 0;
            font-size: 14px;
            text-transform: uppercase;
        }

        #edu-tooltip p {
            font-size: 12px;
            margin: 0;
            color: #fff;
        }

        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes slideIn { from { transform: translateX(50px); opacity: 0; } to { transform: translateX(0); opacity: 1; } }

        /* Canvas Overlay for Target/Source */
        #game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .marker {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 20px;
            box-shadow: 0 0 20px currentColor;
        }

        .source-marker {
            border: 2px solid var(--accent-color);
            color: var(--accent-color);
            background: rgba(0, 243, 255, 0.1);
        }

        .target-marker {
            border: 2px dashed var(--success-color);
            color: var(--success-color);
            background: rgba(0, 255, 157, 0.1);
        }

        .target-marker.hit {
            background: rgba(0, 255, 157, 0.4);
            border-style: solid;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 10px var(--success-color); }
            50% { box-shadow: 0 0 30px var(--success-color); }
            100% { box-shadow: 0 0 10px var(--success-color); }
        }

        #progress-bar-container {
            position: absolute;
            top: 50%;
            right: 30px;
            transform: translateY(-50%);
            width: 10px;
            height: 200px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            overflow: hidden;
        }

        #progress-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 0%;
            background: var(--success-color);
            transition: height 0.2s;
        }

        #progress-label {
            position: absolute;
            top: 50%;
            right: 50px;
            transform: translateY(-50%) rotate(-90deg);
            color: var(--success-color);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
            white-space: nowrap;
        }

    </style>
</head>
<body>

    <canvas id="fluid-canvas"></canvas>
    <div id="game-overlay"></div>

    <div id="ui-layer">
        <div id="top-bar">
            <div id="level-info" class="hud-panel">
                <h1 id="level-title">Level 1: Laminar Flow</h1>
                <h2 id="level-subtitle">The Basics of Aerodynamics</h2>
                <p id="objective">Guide the smoke stream to the sensor. The flow must be steady.</p>
            </div>
            <div id="simulation-stats" class="hud-panel">
                <div>FPS: <span id="fps-stat" class="stat-value">60</span></div>
                <div>Viscosity: <span id="visc-stat" class="stat-value">0.000</span></div>
                <div>Pressure: <span id="press-stat" class="stat-value">101.3</span> kPa</div>
            </div>
        </div>

        <div id="progress-bar-container">
            <div id="progress-bar"></div>
        </div>
        <div id="progress-label">Flow Efficiency</div>

        <div id="edu-tooltip">
            <h3 id="edu-title">Concept: Laminar Flow</h3>
            <p id="edu-text">Laminar flow occurs when a fluid flows in parallel layers, with no disruption between the layers. It is smooth and efficient.</p>
        </div>

        <div id="bottom-bar">
            <div id="toolbox" class="hud-panel">
                <div class="tool-btn active" data-tool="block" title="Solid Block">
                    <div class="tool-icon">■</div>
                    <span>Block</span>
                </div>
                <div class="tool-btn" data-tool="airfoil" title="Airfoil Wing">
                    <div class="tool-icon">◢</div>
                    <span>Wing</span>
                </div>
                <div class="tool-btn" data-tool="circle" title="Cylinder">
                    <div class="tool-icon">●</div>
                    <span>Cylinder</span>
                </div>
                <div class="tool-btn" data-tool="eraser" title="Eraser">
                    <div class="tool-icon">⌫</div>
                    <span>Erase</span>
                </div>
            </div>

            <div id="controls">
                <button id="reset-btn" class="control-btn secondary">Reset Flow</button>
                <button id="clear-btn" class="control-btn secondary">Clear All</button>
                <button id="next-level-btn" class="control-btn" style="display:none;">Next Level >></button>
            </div>
        </div>
    </div>

    <div id="message-overlay" class="visible">
        <h1 id="message-title">Aero Architect</h1>
        <div id="message-body">
            <p>Welcome to the Wind Tunnel, Engineer.</p>
            <p>Your goal is to master the air. Guide the smoke streams to the target sensors by placing aerodynamic shapes.</p>
            <p>You will learn about <strong>Laminar Flow</strong>, <strong>Turbulence</strong>, the <strong>Coanda Effect</strong>, and more.</p>
            <p>Click and drag to place obstacles. Guide the flow.</p>
        </div>
        <button id="message-btn" class="control-btn">Start Simulation</button>
    </div>

    <script>
        // ==========================================
        // FLUID DYNAMICS ENGINE (Grid-Based Solver)
        // ==========================================
        class FluidSolver {
            constructor(size, diffusion, viscosity, dt) {
                this.N = size;
                this.diff = diffusion;
                this.visc = viscosity;
                this.dt = dt;
                
                this.size = (size + 2) * (size + 2);
                this.s = new Float32Array(this.size);
                this.density = new Float32Array(this.size);
                
                this.Vx = new Float32Array(this.size);
                this.Vy = new Float32Array(this.size);
                
                this.Vx0 = new Float32Array(this.size);
                this.Vy0 = new Float32Array(this.size);
                
                // Obstacle grid (0 = empty, 1 = wall)
                this.obstacles = new Uint8Array(this.size);
            }

            IX(x, y) {
                return x + (this.N + 2) * y;
            }

            addDensity(x, y, amount) {
                const index = this.IX(x, y);
                this.density[index] += amount;
                // Clamp density
                if (this.density[index] > 255) this.density[index] = 255;
            }

            addVelocity(x, y, amountX, amountY) {
                const index = this.IX(x, y);
                this.Vx[index] += amountX;
                this.Vy[index] += amountY;
            }

            setObstacle(x, y, isObstacle) {
                const index = this.IX(x, y);
                this.obstacles[index] = isObstacle ? 1 : 0;
                if (isObstacle) {
                    this.density[index] = 0;
                    this.Vx[index] = 0;
                    this.Vy[index] = 0;
                }
            }

            step() {
                const N = this.N;
                const visc = this.visc;
                const diff = this.diff;
                const dt = this.dt;
                const Vx = this.Vx;
                const Vy = this.Vy;
                const Vx0 = this.Vx0;
                const Vy0 = this.Vy0;
                const s = this.s;
                const density = this.density;

                this.diffuse(1, Vx0, Vx, visc, dt);
                this.diffuse(2, Vy0, Vy, visc, dt);

                this.project(Vx0, Vy0, Vx, Vy);

                this.advect(1, Vx, Vx0, Vx0, Vy0, dt);
                this.advect(2, Vy, Vy0, Vx0, Vy0, dt);

                this.project(Vx, Vy, Vx0, Vy0);

                this.diffuse(0, s, density, diff, dt);
                this.advect(0, density, s, Vx, Vy, dt);
            }

            diffuse(b, x, x0, diff, dt) {
                const a = dt * diff * (this.N - 2) * (this.N - 2);
                this.lin_solve(b, x, x0, a, 1 + 6 * a); // 6 for 3D, 4 for 2D? Standard is 4 for 2D.
                // Actually standard Stam uses 4 neighbors in 2D.
                // Let's use a simplified Gauss-Seidel for 2D
                this.lin_solve2D(b, x, x0, a, 1 + 4 * a);
            }

            lin_solve2D(b, x, x0, a, c) {
                const cRecip = 1.0 / c;
                for (let k = 0; k < 10; k++) { // Iterations
                    for (let j = 1; j <= this.N; j++) {
                        for (let i = 1; i <= this.N; i++) {
                            if (this.obstacles[this.IX(i, j)]) continue;
                            x[this.IX(i, j)] =
                                (x0[this.IX(i, j)] +
                                    a * (x[this.IX(i + 1, j)] +
                                         x[this.IX(i - 1, j)] +
                                         x[this.IX(i, j + 1)] +
                                         x[this.IX(i, j - 1)]
                                    )) * cRecip;
                        }
                    }
                    this.set_bnd(b, x);
                }
            }

            project(velocX, velocY, p, div) {
                const h = 1.0 / this.N;
                for (let j = 1; j <= this.N; j++) {
                    for (let i = 1; i <= this.N; i++) {
                        if (this.obstacles[this.IX(i, j)]) {
                            div[this.IX(i, j)] = 0;
                            p[this.IX(i, j)] = 0;
                            continue;
                        }
                        div[this.IX(i, j)] = -0.5 * h * (
                            velocX[this.IX(i + 1, j)] - velocX[this.IX(i - 1, j)] +
                            velocY[this.IX(i, j + 1)] - velocY[this.IX(i, j - 1)]
                        );
                        p[this.IX(i, j)] = 0;
                    }
                }
                this.set_bnd(0, div);
                this.set_bnd(0, p);
                this.lin_solve2D(0, p, div, 1, 4);

                for (let j = 1; j <= this.N; j++) {
                    for (let i = 1; i <= this.N; i++) {
                        if (this.obstacles[this.IX(i, j)]) continue;
                        velocX[this.IX(i, j)] -= 0.5 * (p[this.IX(i + 1, j)] - p[this.IX(i - 1, j)]) / h;
                        velocY[this.IX(i, j)] -= 0.5 * (p[this.IX(i, j + 1)] - p[this.IX(i, j - 1)]) / h;
                    }
                }
                this.set_bnd(1, velocX);
                this.set_bnd(2, velocY);
            }

            advect(b, d, d0, velocX, velocY, dt) {
                let i0, i1, j0, j1;
                let x, y, s0, t0, s1, t1;
                const dt0 = dt * this.N;
                const Nfloat = this.N;

                for (let j = 1; j <= this.N; j++) {
                    for (let i = 1; i <= this.N; i++) {
                        if (this.obstacles[this.IX(i, j)]) continue;
                        
                        x = i - dt0 * velocX[this.IX(i, j)];
                        y = j - dt0 * velocY[this.IX(i, j)];

                        if (x < 0.5) x = 0.5;
                        if (x > Nfloat + 0.5) x = Nfloat + 0.5;
                        i0 = Math.floor(x);
                        i1 = i0 + 1;
                        
                        if (y < 0.5) y = 0.5;
                        if (y > Nfloat + 0.5) y = Nfloat + 0.5;
                        j0 = Math.floor(y);
                        j1 = j0 + 1;

                        s1 = x - i0;
                        s0 = 1.0 - s1;
                        t1 = y - j0;
                        t0 = 1.0 - t1;

                        d[this.IX(i, j)] =
                            s0 * (t0 * d0[this.IX(i0, j0)] + t1 * d0[this.IX(i0, j1)]) +
                            s1 * (t0 * d0[this.IX(i1, j0)] + t1 * d0[this.IX(i1, j1)]);
                    }
                }
                this.set_bnd(b, d);
            }

            set_bnd(b, x) {
                for (let i = 1; i <= this.N; i++) {
                    // Walls
                    x[this.IX(i, 0)] = b === 2 ? -x[this.IX(i, 1)] : x[this.IX(i, 1)];
                    x[this.IX(i, this.N + 1)] = b === 2 ? -x[this.IX(i, this.N)] : x[this.IX(i, this.N)];
                    
                    x[this.IX(0, i)] = b === 1 ? -x[this.IX(1, i)] : x[this.IX(1, i)];
                    x[this.IX(this.N + 1, i)] = b === 1 ? -x[this.IX(this.N, i)] : x[this.IX(this.N, i)];
                }
                
                // Corners
                x[this.IX(0, 0)] = 0.5 * (x[this.IX(1, 0)] + x[this.IX(0, 1)]);
                x[this.IX(0, this.N + 1)] = 0.5 * (x[this.IX(1, this.N + 1)] + x[this.IX(0, this.N)]);
                x[this.IX(this.N + 1, 0)] = 0.5 * (x[this.IX(this.N, 0)] + x[this.IX(this.N + 1, 1)]);
                x[this.IX(this.N + 1, this.N + 1)] = 0.5 * (x[this.IX(this.N, this.N + 1)] + x[this.IX(this.N + 1, this.N)]);

                // Handle internal obstacles
                for (let j = 1; j <= this.N; j++) {
                    for (let i = 1; i <= this.N; i++) {
                        if (this.obstacles[this.IX(i, j)]) {
                            x[this.IX(i, j)] = 0;
                            // Reflect velocity at boundaries of obstacles could be added here for better physics
                        }
                    }
                }
            }
        }

        // ==========================================
        // GAME ENGINE
        // ==========================================
        const canvas = document.getElementById('fluid-canvas');
        const ctx = canvas.getContext('2d');
        
        // Configuration
        const GRID_SIZE = 100; // Resolution
        const SCALE = 8; // Visual scale
        const DT = 0.1;
        const DIFFUSION = 0.0001;
        const VISCOSITY = 0.00001; // Low viscosity for air
        
        let fluid = new FluidSolver(GRID_SIZE, DIFFUSION, VISCOSITY, DT);
        let animationId;
        let isRunning = false;
        let currentTool = 'block';
        let isMouseDown = false;
        let mouseX = 0, mouseY = 0;
        
        // Game State
        let currentLevel = 0;
        let score = 0;
        let flowEfficiency = 0;
        
        // Levels
        const LEVELS = [
            {
                title: "Laminar Flow",
                subtitle: "The Basics of Aerodynamics",
                objective: "Guide the smoke stream to the sensor. Avoid turbulence.",
                source: { x: 10, y: 50, vx: 50, vy: 0 },
                target: { x: 90, y: 50, radius: 5 },
                eduTitle: "Laminar Flow",
                eduText: "Laminar flow occurs when a fluid flows in parallel layers, with no disruption between the layers. It is smooth and efficient."
            },
            {
                title: "The Coanda Effect",
                subtitle: "Bending Air",
                objective: "The sensor is below the stream. Use a curved surface to bend the airflow downwards.",
                source: { x: 10, y: 30, vx: 50, vy: 0 },
                target: { x: 80, y: 70, radius: 5 },
                eduTitle: "Coanda Effect",
                eduText: "The Coanda effect is the tendency of a fluid jet to stay attached to a convex surface. You can use this to steer air without moving parts."
            },
            {
                title: "Obstacle Course",
                subtitle: "Managing Drag",
                objective: "Navigate around the fixed block to hit the target.",
                source: { x: 10, y: 50, vx: 50, vy: 0 },
                target: { x: 90, y: 50, radius: 5 },
                prebuiltObstacles: [
                    { x: 50, y: 50, w: 10, h: 40 } // Wall in middle
                ],
                eduTitle: "Flow Separation",
                eduText: "When flow hits a blunt object, it separates and creates turbulence (drag) behind it. Streamlined shapes reduce this separation."
            },
            {
                title: "Venturi Effect",
                subtitle: "Speed and Pressure",
                objective: "Squeeze the flow to increase its speed and reach the far target.",
                source: { x: 5, y: 50, vx: 20, vy: 0 }, // Slow start
                target: { x: 95, y: 50, radius: 5 },
                eduTitle: "Venturi Effect",
                eduText: "Constricting a pipe increases the fluid's velocity while decreasing its pressure. This is how carburetors and sprayers work."
            },
            {
                title: "Sandbox Mode",
                subtitle: "Free Engineering",
                objective: "Experiment with fluid dynamics freely.",
                source: { x: 50, y: 50, vx: 0, vy: 0 }, // Mouse controlled
                target: { x: -100, y: -100, radius: 0 }, // Hidden
                eduTitle: "Sandbox",
                eduText: "Draw walls, add smoke, and experiment. Try creating a Kármán vortex street by placing a cylinder in a fast flow."
            }
        ];

        // ==========================================
        // INITIALIZATION
        // ==========================================
        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            setupUI();
            loadLevel(0);
            
            // Start loop
            loop();
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        function setupUI() {
            // Tool selection
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentTool = btn.dataset.tool;
                });
            });

            // Controls
            document.getElementById('reset-btn').addEventListener('click', () => {
                fluid = new FluidSolver(GRID_SIZE, DIFFUSION, VISCOSITY, DT);
                loadLevel(currentLevel); // Reload obstacles
            });

            document.getElementById('clear-btn').addEventListener('click', () => {
                fluid = new FluidSolver(GRID_SIZE, DIFFUSION, VISCOSITY, DT);
                // Don't reload level obstacles, clear everything
            });

            document.getElementById('message-btn').addEventListener('click', () => {
                document.getElementById('message-overlay').classList.remove('visible');
                isRunning = true;
            });

            document.getElementById('next-level-btn').addEventListener('click', () => {
                if (currentLevel < LEVELS.length - 1) {
                    currentLevel++;
                    loadLevel(currentLevel);
                    document.getElementById('next-level-btn').style.display = 'none';
                    document.getElementById('message-overlay').classList.remove('visible');
                }
            });

            // Mouse interaction
            canvas.addEventListener('mousedown', e => { isMouseDown = true; handleInput(e); });
            canvas.addEventListener('mousemove', e => { 
                mouseX = e.clientX; 
                mouseY = e.clientY; 
                if(isMouseDown) handleInput(e); 
            });
            canvas.addEventListener('mouseup', () => { isMouseDown = false; });
            
            // Touch support
            canvas.addEventListener('touchstart', e => { isMouseDown = true; handleInput(e.touches[0]); });
            canvas.addEventListener('touchmove', e => { 
                if(isMouseDown) handleInput(e.touches[0]); 
                e.preventDefault();
            });
            canvas.addEventListener('touchend', () => { isMouseDown = false; });
        }

        function loadLevel(index) {
            const level = LEVELS[index];
            
            // Update UI
            document.getElementById('level-title').textContent = level.title;
            document.getElementById('level-subtitle').textContent = level.subtitle;
            document.getElementById('objective').textContent = level.objective;
            
            // Update Edu Tooltip
            const edu = document.getElementById('edu-tooltip');
            document.getElementById('edu-title').textContent = level.eduTitle;
            document.getElementById('edu-text').textContent = level.eduText;
            edu.style.display = 'block';
            
            // Reset Fluid
            fluid = new FluidSolver(GRID_SIZE, DIFFUSION, VISCOSITY, DT);
            
            // Place Markers
            const overlay = document.getElementById('game-overlay');
            overlay.innerHTML = '';
            
            // Source Marker
            if (level.source.vx !== 0 || level.source.vy !== 0) {
                const sourceEl = document.createElement('div');
                sourceEl.className = 'marker source-marker';
                // Convert grid coords to screen coords
                const sx = (level.source.x / GRID_SIZE) * canvas.width;
                const sy = (level.source.y / GRID_SIZE) * canvas.height;
                sourceEl.style.left = sx + 'px';
                sourceEl.style.top = sy + 'px';
                sourceEl.innerHTML = '➤';
                overlay.appendChild(sourceEl);
            }
            
            // Target Marker
            if (level.target.radius > 0) {
                const targetEl = document.createElement('div');
                targetEl.className = 'marker target-marker';
                targetEl.id = 'target-marker';
                const tx = (level.target.x / GRID_SIZE) * canvas.width;
                const ty = (level.target.y / GRID_SIZE) * canvas.height;
                targetEl.style.left = tx + 'px';
                targetEl.style.top = ty + 'px';
                targetEl.innerHTML = '◎';
                overlay.appendChild(targetEl);
            }

            // Prebuilt Obstacles
            if (level.prebuiltObstacles) {
                level.prebuiltObstacles.forEach(obs => {
                    // Draw into fluid grid
                    const x = Math.floor(obs.x);
                    const y = Math.floor(obs.y);
                    const w = Math.floor(obs.w);
                    const h = Math.floor(obs.h);
                    
                    for(let j = y - h/2; j < y + h/2; j++) {
                        for(let i = x - w/2; i < x + w/2; i++) {
                            if(i > 0 && i < GRID_SIZE && j > 0 && j < GRID_SIZE) {
                                fluid.setObstacle(i, j, true);
                            }
                        }
                    }
                });
            }
            
            // Show overlay for level 1
            if (index === 0) {
                document.getElementById('message-overlay').classList.add('visible');
            }
        }

        function handleInput(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Map to grid
            const gx = Math.floor((x / canvas.width) * GRID_SIZE);
            const gy = Math.floor((y / canvas.height) * GRID_SIZE);
            
            if (gx < 1 || gx >= GRID_SIZE - 1 || gy < 1 || gy >= GRID_SIZE - 1) return;

            const brushSize = 2;

            if (currentTool === 'block') {
                for(let j = -brushSize; j <= brushSize; j++) {
                    for(let i = -brushSize; i <= brushSize; i++) {
                        fluid.setObstacle(gx + i, gy + j, true);
                    }
                }
            } else if (currentTool === 'eraser') {
                for(let j = -brushSize; j <= brushSize; j++) {
                    for(let i = -brushSize; i <= brushSize; i++) {
                        fluid.setObstacle(gx + i, gy + j, false);
                    }
                }
            } else if (currentTool === 'circle') {
                // Draw a circle shape
                for(let j = -brushSize*2; j <= brushSize*2; j++) {
                    for(let i = -brushSize*2; i <= brushSize*2; i++) {
                        if (i*i + j*j < brushSize*brushSize*4) {
                            fluid.setObstacle(gx + i, gy + j, true);
                        }
                    }
                }
            } else if (currentTool === 'airfoil') {
                // Draw a simple airfoil shape approximation
                for(let i = -5; i <= 5; i++) {
                    // Camber line
                    let yOffset = Math.floor(-Math.sin((i+5)/10 * Math.PI) * 3);
                    fluid.setObstacle(gx + i, gy + yOffset, true);
                    fluid.setObstacle(gx + i, gy + yOffset + 1, true);
                }
            }
            
            // Sandbox interaction: add density/velocity with mouse
            if (currentLevel === 4) { // Sandbox
                 fluid.addDensity(gx, gy, 100);
                 fluid.addVelocity(gx, gy, (Math.random()-0.5)*10, (Math.random()-0.5)*10);
            }
        }

        // ==========================================
        // RENDERING & LOOP
        // ==========================================
        function loop() {
            if (isRunning) {
                // 1. Update Physics
                
                // Constant Source
                const level = LEVELS[currentLevel];
                if (level.source.vx !== 0 || level.source.vy !== 0) {
                    const sx = Math.floor(level.source.x);
                    const sy = Math.floor(level.source.y);
                    
                    // Add density and velocity at source
                    for(let j=-1; j<=1; j++) {
                        for(let i=-1; i<=1; i++) {
                            fluid.addDensity(sx+i, sy+j, 100);
                            fluid.addVelocity(sx+i, sy+j, level.source.vx, level.source.vy);
                        }
                    }
                }

                fluid.step();
                
                // 2. Check Win Condition
                checkWinCondition();
            }

            // 3. Render
            draw();

            animationId = requestAnimationFrame(loop);
        }

        function checkWinCondition() {
            const level = LEVELS[currentLevel];
            if (level.target.radius === 0) return; // Sandbox

            const tx = Math.floor(level.target.x);
            const ty = Math.floor(level.target.y);
            
            // Sample density at target
            let totalDensity = 0;
            let count = 0;
            for(let j=-2; j<=2; j++) {
                for(let i=-2; i<=2; i++) {
                    const idx = fluid.IX(tx+i, ty+j);
                    totalDensity += fluid.density[idx];
                    count++;
                }
            }
            
            const avgDensity = totalDensity / count;
            
            // Update progress bar
            const progress = Math.min(avgDensity / 50, 1.0) * 100; // Threshold of 50
            document.getElementById('progress-bar').style.height = progress + '%';
            
            if (progress >= 100) {
                document.getElementById('target-marker').classList.add('hit');
                
                // Auto advance after a few seconds of stability
                if (!this.winTimer) this.winTimer = 0;
                this.winTimer++;
                
                if (this.winTimer > 100) { // ~1.5 seconds
                    document.getElementById('next-level-btn').style.display = 'block';
                    this.winTimer = 0;
                }
            } else {
                document.getElementById('target-marker').classList.remove('hit');
                this.winTimer = 0;
            }
        }

        function draw() {
            // Clear background
            ctx.fillStyle = '#0a0a12';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const cellWidth = canvas.width / GRID_SIZE;
            const cellHeight = canvas.height / GRID_SIZE;
            
            // Draw Fluid Density
            // We'll use direct pixel manipulation for speed if needed, but fillRect is fine for 100x100
            
            for (let j = 1; j <= GRID_SIZE; j++) {
                for (let i = 1; i <= GRID_SIZE; i++) {
                    const idx = fluid.IX(i, j);
                    
                    // Draw Obstacles
                    if (fluid.obstacles[idx]) {
                        ctx.fillStyle = '#445566';
                        ctx.fillRect((i-1) * cellWidth, (j-1) * cellHeight, cellWidth + 1, cellHeight + 1);
                        continue;
                    }
                    
                    const d = fluid.density[idx];
                    if (d > 0.1) {
                        // Color mapping based on density
                        // Low density = blue/cyan, High density = white
                        const alpha = Math.min(d / 200, 0.8);
                        const r = Math.floor(0);
                        const g = Math.floor(243);
                        const b = Math.floor(255);
                        
                        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                        ctx.fillRect((i-1) * cellWidth, (j-1) * cellHeight, cellWidth + 1, cellHeight + 1);
                    }
                }
            }
            
            // Draw Velocity Vectors (optional, maybe on hover or debug mode)
            // drawVelocityField(cellWidth, cellHeight);
        }

        // Start
        init();

    </script>
</body>
</html>