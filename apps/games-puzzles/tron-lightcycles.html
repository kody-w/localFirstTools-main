<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tron Lightcycles</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #050510; overflow: hidden; font-family: 'Segoe UI', system-ui, sans-serif; touch-action: none; }
        canvas { display: block; }
        #ui { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        #ui > * { pointer-events: auto; }
        .ov { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.88); display: flex; align-items: center; justify-content: center; z-index: 100; }
        .bx {
            background: linear-gradient(145deg, #0a0a20, #050510);
            border: 2px solid #00f3ff; border-radius: 20px; padding: 35px;
            text-align: center; max-width: 500px; width: 92%;
            box-shadow: 0 0 60px rgba(0,243,255,0.3);
        }
        .bx h1 { color: #00f3ff; font-size: 2.2rem; margin-bottom: 8px; text-shadow: 0 0 20px rgba(0,243,255,0.6); letter-spacing: 4px; }
        .bx h2 { color: #6699bb; font-size: 1rem; margin-bottom: 20px; font-weight: normal; }
        .bx p { color: #445566; font-size: 0.85rem; margin-bottom: 15px; line-height: 1.5; }
        .btn { display: block; width: 100%; padding: 13px; margin: 8px 0; font-size: 1rem; font-weight: bold; border: 2px solid #00f3ff; border-radius: 12px; background: linear-gradient(135deg, #0a0a20, #0f0f30); color: #00f3ff; cursor: pointer; transition: all 0.2s; letter-spacing: 2px; }
        .btn:hover { background: linear-gradient(135deg, #101040, #151550); border-color: #44ffff; transform: translateY(-2px); box-shadow: 0 4px 20px rgba(0,243,255,0.4); }
        .btn.sm { padding: 10px; font-size: 0.85rem; }
        .dr { display: flex; gap: 8px; margin: 12px 0; }
        .db { flex: 1; padding: 10px; font-size: 0.85rem; border: 2px solid #223; border-radius: 10px; background: #050510; color: #556; cursor: pointer; transition: all 0.2s; }
        .db.on { border-color: #00f3ff; color: #00f3ff; background: #0a0a20; box-shadow: 0 0 12px rgba(0,243,255,0.2); }
        .st { display: flex; justify-content: space-between; padding: 5px 0; color: #6699bb; font-size: 0.88rem; border-bottom: 1px solid rgba(0,243,255,0.1); }
        .st span:last-child { color: #00f3ff; font-weight: bold; }
        .hint { position: fixed; top: 8px; right: 12px; color: rgba(0,243,255,0.2); font-size: 0.7rem; pointer-events: none; z-index: 5; }
    </style>
</head>
<body>
<canvas id="c"></canvas>
<div class="hint">WASD/Arrows | ESC = Pause | R = Restart</div>
<div id="ui"></div>
<script>
const cv = document.getElementById('c'), cx = cv.getContext('2d');
let W, H, GW, GH, CS; // canvas, grid, cell size
function resize() {
    W = cv.width = innerWidth;
    H = cv.height = innerHeight;
    CS = Math.max(4, Math.min(8, Math.floor(Math.min(W, H) / 100)));
    GW = Math.floor(W / CS);
    GH = Math.floor(H / CS);
}
addEventListener('resize', resize);
resize();

// Audio
let AC = null;
function initA() { if (!AC) AC = new (window.AudioContext || window.webkitAudioContext)(); }
function snd(t, f, d, v) {
    if (!AC) return;
    const o = AC.createOscillator(), g = AC.createGain();
    o.type = t; o.frequency.value = f;
    g.gain.setValueAtTime(v || 0.1, AC.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, AC.currentTime + d);
    o.connect(g); g.connect(AC.destination); o.start(); o.stop(AC.currentTime + d);
}
function sfxTurn() { snd('triangle', 400 + Math.random() * 200, 0.03, 0.08); }
function sfxCrash() { snd('sawtooth', 100, 0.3, 0.15); setTimeout(() => snd('sawtooth', 60, 0.4, 0.1), 100); }
function sfxBoost() { snd('sine', 800, 0.1); setTimeout(() => snd('sine', 1000, 0.08), 50); }
function sfxPowerup() { [660, 880, 1100].forEach((f, i) => setTimeout(() => snd('square', f, 0.08), i * 40)); }
function sfxWin() { [523, 659, 784, 1047].forEach((f, i) => setTimeout(() => snd('square', f, 0.12), i * 100)); }
function sfxLose() { [440, 370, 311, 261].forEach((f, i) => setTimeout(() => snd('sawtooth', f, 0.2), i * 120)); }
function sfxTick() { snd('triangle', 600, 0.02, 0.05); }

// State
let state = 'menu';
let diff = 1; // 0=easy, 1=normal, 2=hard
const DNAMES = ['Easy', 'Normal', 'Hard'];
let grid = []; // 0=empty, 1=p1trail, 2+=enemy trails
let player, enemies, powerups;
let score, round, wins, streak, maxStreak;
let gameSpeed, speedTimer;
let particles;
let shakeX = 0, shakeY = 0, shakeDur = 0;
let keys = {};
let roundTimer = 0;
let boostActive = false, boostTimer = 0;
let shieldActive = false, shieldTimer = 0;

// Persistence
let hs = [], gp = 0, tw = 0;
function loadS() { try { const d = JSON.parse(localStorage.getItem('tron-lc-save')); if (d) { hs = d.hs || []; gp = d.gp || 0; tw = d.tw || 0; } } catch (e) {} }
function saveS() { localStorage.setItem('tron-lc-save', JSON.stringify({ hs, gp, tw })); }
loadS();

// Colors
const COLORS = [
    { main: '#00f3ff', glow: 'rgba(0,243,255,', trail: '#006688' },
    { main: '#ff9d00', glow: 'rgba(255,157,0,', trail: '#885500' },
    { main: '#ff3366', glow: 'rgba(255,51,102,', trail: '#882244' },
    { main: '#44ff44', glow: 'rgba(68,255,68,', trail: '#228822' },
    { main: '#cc44ff', glow: 'rgba(204,68,255,', trail: '#662288' },
];

// Powerup types
const PU_TYPES = ['speed', 'slow', 'shield', 'shrink'];
const PU_COLORS = { speed: '#ffff00', slow: '#00ff88', shield: '#00ccff', shrink: '#ff44ff' };
const PU_LABELS = { speed: 'SPD', slow: 'SLO', shield: 'SHD', shrink: 'SHR' };

// Particles
function spawn(x, y, n, color, spd) {
    for (let i = 0; i < n; i++) {
        const a = Math.random() * Math.PI * 2, s = (0.5 + Math.random()) * (spd || 3);
        particles.push({ x: x * CS + CS / 2, y: y * CS + CS / 2, vx: Math.cos(a) * s, vy: Math.sin(a) * s, life: 1, decay: 0.02 + Math.random() * 0.03, size: 2 + Math.random() * 3, color });
    }
}
function shake(i, d) { shakeX = (Math.random() - 0.5) * i; shakeY = (Math.random() - 0.5) * i; shakeDur = d; }

// Grid
function clearGrid() {
    grid = [];
    for (let i = 0; i < GW * GH; i++) grid[i] = 0;
}
function getGrid(x, y) {
    if (x < 0 || x >= GW || y < 0 || y >= GH) return -1; // wall
    return grid[y * GW + x];
}
function setGrid(x, y, v) {
    if (x >= 0 && x < GW && y >= 0 && y < GH) grid[y * GW + x] = v;
}

// Cycle class
class Cycle {
    constructor(x, y, dx, dy, id, color, isAI) {
        this.x = x; this.y = y;
        this.dx = dx; this.dy = dy;
        this.id = id;
        this.color = color;
        this.isAI = isAI;
        this.alive = true;
        this.trail = [];
        this.turnCooldown = 0;
    }

    turn(ndx, ndy) {
        // Can't reverse
        if (ndx === -this.dx && ndy === -this.dy) return;
        if (ndx === this.dx && ndy === this.dy) return;
        this.dx = ndx;
        this.dy = ndy;
        if (!this.isAI) sfxTurn();
    }

    move() {
        if (!this.alive) return;
        this.turnCooldown = Math.max(0, this.turnCooldown - 1);

        // Leave trail
        setGrid(this.x, this.y, this.id);
        this.trail.push({ x: this.x, y: this.y });

        // Move
        const speed = boostActive && this.id === 1 ? 2 : 1;
        for (let s = 0; s < speed; s++) {
            this.x += this.dx;
            this.y += this.dy;

            // Check collision
            const cell = getGrid(this.x, this.y);
            if (cell !== 0) {
                if (shieldActive && this.id === 1 && cell > 0) {
                    // Shield: clear nearby trail
                    for (let dx = -2; dx <= 2; dx++) {
                        for (let dy = -2; dy <= 2; dy++) {
                            const nx = this.x + dx, ny = this.y + dy;
                            if (getGrid(nx, ny) > 0 && getGrid(nx, ny) !== 1) {
                                setGrid(nx, ny, 0);
                            }
                        }
                    }
                    shieldActive = false;
                    shieldTimer = 0;
                    spawn(this.x, this.y, 20, '#00ccff', 4);
                } else {
                    this.die();
                    return;
                }
            }

            if (s < speed - 1) {
                setGrid(this.x, this.y, this.id);
                this.trail.push({ x: this.x, y: this.y });
            }
        }

        // Check powerup collision
        for (let i = powerups.length - 1; i >= 0; i--) {
            const p = powerups[i];
            if (Math.abs(p.x - this.x) <= 1 && Math.abs(p.y - this.y) <= 1) {
                this.collectPowerup(p);
                powerups.splice(i, 1);
            }
        }
    }

    collectPowerup(p) {
        sfxPowerup();
        spawn(p.x, p.y, 15, PU_COLORS[p.type], 4);
        if (this.id === 1) {
            // Player gets the benefit
            if (p.type === 'speed') { boostActive = true; boostTimer = 120; }
            else if (p.type === 'shield') { shieldActive = true; shieldTimer = 180; }
            else if (p.type === 'shrink') {
                // Remove last 30% of each enemy trail
                for (const e of enemies) {
                    const removeCount = Math.floor(e.trail.length * 0.3);
                    const removed = e.trail.splice(0, removeCount);
                    for (const t of removed) setGrid(t.x, t.y, 0);
                }
            } else if (p.type === 'slow') {
                // Enemies skip next 3 moves (handled in update)
                for (const e of enemies) e.skipMoves = 3;
            }
            score += 50;
        }
    }

    die() {
        this.alive = false;
        spawn(this.x, this.y, 30, this.color.main, 6);
        shake(15, 10);
        sfxCrash();
    }

    aiThink() {
        if (!this.isAI || !this.alive) return;
        if (this.turnCooldown > 0) return;

        // Look ahead in all 4 directions
        const dirs = [
            { dx: 0, dy: -1 }, { dx: 0, dy: 1 },
            { dx: -1, dy: 0 }, { dx: 1, dy: 0 }
        ];

        // Score each direction
        let bestDir = null, bestScore = -999;
        for (const d of dirs) {
            // Can't reverse
            if (d.dx === -this.dx && d.dy === -this.dy) continue;

            let dirScore = 0;
            let clear = true;

            // Look ahead
            const lookDist = diff === 0 ? 5 : diff === 1 ? 10 : 15;
            for (let i = 1; i <= lookDist; i++) {
                const nx = this.x + d.dx * i;
                const ny = this.y + d.dy * i;
                const cell = getGrid(nx, ny);
                if (cell !== 0) {
                    dirScore -= (lookDist - i) * 2;
                    if (i <= 2) clear = false;
                    break;
                }
                dirScore += 1;
            }

            // Prefer to stay away from walls
            const distToWall = Math.min(
                this.x + d.dx * 10, GW - (this.x + d.dx * 10),
                this.y + d.dy * 10, GH - (this.y + d.dy * 10)
            );
            if (distToWall < 5) dirScore -= 3;

            // Some randomness on easy
            if (diff === 0) dirScore += (Math.random() - 0.5) * 5;

            // Seek player on hard
            if (diff === 2 && player.alive) {
                const pdx = player.x - this.x;
                const pdy = player.y - this.y;
                if (d.dx * pdx + d.dy * pdy > 0) dirScore += 2;
            }

            if (dirScore > bestScore) {
                bestScore = dirScore;
                bestDir = d;
            }
        }

        if (bestDir && (bestDir.dx !== this.dx || bestDir.dy !== this.dy)) {
            this.turn(bestDir.dx, bestDir.dy);
            this.turnCooldown = 2;
        }
    }
}

// Game logic
function startGame() {
    initA();
    resize();
    clearGrid();
    particles = [];
    powerups = [];
    score = 0; round = 1; wins = 0; streak = 0; maxStreak = 0;
    boostActive = false; boostTimer = 0;
    shieldActive = false; shieldTimer = 0;
    state = 'playing';
    sfxTick();
    startRound();
}

function startRound() {
    resize();
    clearGrid();
    particles = [];
    powerups = [];
    boostActive = false; boostTimer = 0;
    shieldActive = false; shieldTimer = 0;
    roundTimer = 0;

    const numEnemies = Math.min(1 + Math.floor(round / 3), 4);
    gameSpeed = diff === 0 ? 8 : diff === 1 ? 6 : 4;

    // Spawn player at left-center
    player = new Cycle(Math.floor(GW * 0.15), Math.floor(GH * 0.5), 1, 0, 1, COLORS[0], false);

    // Spawn enemies
    enemies = [];
    const positions = [
        { x: Math.floor(GW * 0.85), y: Math.floor(GH * 0.5), dx: -1, dy: 0 },
        { x: Math.floor(GW * 0.5), y: Math.floor(GH * 0.15), dx: 0, dy: 1 },
        { x: Math.floor(GW * 0.5), y: Math.floor(GH * 0.85), dx: 0, dy: -1 },
        { x: Math.floor(GW * 0.15), y: Math.floor(GH * 0.15), dx: 1, dy: 1 },
    ];
    for (let i = 0; i < numEnemies; i++) {
        const p = positions[i];
        const e = new Cycle(p.x, p.y, p.dx, p.dy, i + 2, COLORS[i + 1], true);
        e.skipMoves = 0;
        enemies.push(e);
    }

    speedTimer = 0;
}

function spawnPowerup() {
    if (powerups.length >= 3) return;
    const type = PU_TYPES[Math.floor(Math.random() * PU_TYPES.length)];
    let x, y, attempts = 0;
    do {
        x = 5 + Math.floor(Math.random() * (GW - 10));
        y = 5 + Math.floor(Math.random() * (GH - 10));
        attempts++;
    } while (getGrid(x, y) !== 0 && attempts < 50);
    if (attempts < 50) {
        powerups.push({ x, y, type, life: 600 });
    }
}

function update() {
    if (state !== 'playing') return;

    speedTimer++;
    if (speedTimer < gameSpeed) return;
    speedTimer = 0;

    roundTimer++;

    // Spawn powerups periodically
    if (roundTimer % 40 === 0) spawnPowerup();

    // Update powerup timers
    for (let i = powerups.length - 1; i >= 0; i--) {
        powerups[i].life--;
        if (powerups[i].life <= 0) powerups.splice(i, 1);
    }

    // Update boost/shield timers
    if (boostTimer > 0) { boostTimer--; if (boostTimer <= 0) boostActive = false; }
    if (shieldTimer > 0) { shieldTimer--; if (shieldTimer <= 0) shieldActive = false; }

    // AI think
    for (const e of enemies) {
        if (e.alive) e.aiThink();
    }

    // Move player
    if (player.alive) player.move();

    // Move enemies
    for (const e of enemies) {
        if (e.alive) {
            if (e.skipMoves > 0) { e.skipMoves--; }
            else { e.move(); }
        }
    }

    // Score for surviving
    if (player.alive) score += 1;

    // Check round over
    const aliveEnemies = enemies.filter(e => e.alive).length;
    if (!player.alive) {
        // Player died
        streak = 0;
        sfxLose();
        setTimeout(() => {
            if (round >= 10) endGame();
            else { round++; startRound(); }
        }, 1500);
        state = 'roundover';
    } else if (aliveEnemies === 0) {
        // All enemies dead
        wins++;
        streak++;
        if (streak > maxStreak) maxStreak = streak;
        score += 200 * round;
        sfxWin();
        spawn(player.x, player.y, 40, '#00f3ff', 6);
        setTimeout(() => {
            round++;
            startRound();
        }, 1500);
        state = 'roundover';
    }

    // Update particles
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx; p.y += p.vy;
        p.life -= p.decay;
        if (p.life <= 0) particles.splice(i, 1);
    }

    // Shake
    if (shakeDur > 0) { shakeDur--; shakeX = (Math.random() - 0.5) * shakeDur * 1.5; shakeY = (Math.random() - 0.5) * shakeDur * 1.5; }
    else { shakeX = 0; shakeY = 0; }
}

function endGame() {
    state = 'gameover';
    gp++;
    let ending = '';
    if (wins >= 8 && maxStreak >= 5) ending = 'Grid Master';
    else if (wins >= 6) ending = 'Light Champion';
    else if (wins >= 4) ending = 'Circuit Runner';
    else if (wins >= 2) ending = 'Rookie Racer';
    else ending = 'Derezzed';

    if (wins >= 4) tw++;

    hs.push({ score, wins, rounds: round, streak: maxStreak, diff: DNAMES[diff], ending, date: new Date().toLocaleDateString() });
    hs.sort((a, b) => b.score - a.score);
    hs = hs.slice(0, 10);
    saveS();
    showGameOver(ending);
}

// Draw
function drawGrid() {
    // Background
    cx.fillStyle = '#050510';
    cx.fillRect(0, 0, W, H);

    // Grid lines
    cx.strokeStyle = 'rgba(20,20,50,0.5)';
    cx.lineWidth = 0.5;
    for (let x = 0; x < W; x += CS * 5) {
        cx.beginPath(); cx.moveTo(x, 0); cx.lineTo(x, H); cx.stroke();
    }
    for (let y = 0; y < H; y += CS * 5) {
        cx.beginPath(); cx.moveTo(0, y); cx.lineTo(W, y); cx.stroke();
    }
}

function drawTrails() {
    // Draw all trails from grid
    for (let y = 0; y < GH; y++) {
        for (let x = 0; x < GW; x++) {
            const v = grid[y * GW + x];
            if (v > 0) {
                const colorIdx = v - 1;
                const col = COLORS[colorIdx] || COLORS[0];
                cx.fillStyle = col.trail;
                cx.fillRect(x * CS, y * CS, CS, CS);
            }
        }
    }
}

function drawCycle(cycle) {
    if (!cycle.alive) return;
    const px = cycle.x * CS, py = cycle.y * CS;
    const col = cycle.color;

    // Glow
    cx.save();
    cx.shadowColor = col.main;
    cx.shadowBlur = 15;
    cx.fillStyle = col.main;
    cx.fillRect(px - 1, py - 1, CS + 2, CS + 2);
    cx.restore();

    // Shield visual
    if (shieldActive && cycle.id === 1) {
        cx.strokeStyle = 'rgba(0,200,255,0.5)';
        cx.lineWidth = 2;
        cx.beginPath();
        cx.arc(px + CS / 2, py + CS / 2, CS * 2, 0, Math.PI * 2);
        cx.stroke();
    }

    // Boost visual
    if (boostActive && cycle.id === 1) {
        cx.fillStyle = 'rgba(255,255,0,0.3)';
        cx.beginPath();
        cx.arc(px + CS / 2, py + CS / 2, CS * 1.5, 0, Math.PI * 2);
        cx.fill();
    }
}

function drawPowerups(t) {
    for (const p of powerups) {
        const px = p.x * CS, py = p.y * CS;
        const pulse = 0.7 + Math.sin(t / 200 + p.x) * 0.3;
        cx.globalAlpha = pulse * (p.life > 100 ? 1 : p.life / 100);
        cx.fillStyle = PU_COLORS[p.type];
        cx.beginPath();
        cx.arc(px + CS / 2, py + CS / 2, CS * 1.5, 0, Math.PI * 2);
        cx.fill();
        cx.fillStyle = '#000';
        cx.font = `bold ${CS}px sans-serif`;
        cx.textAlign = 'center';
        cx.textBaseline = 'middle';
        cx.fillText(PU_LABELS[p.type][0], px + CS / 2, py + CS / 2);
        cx.globalAlpha = 1;
    }
}

function drawHUD() {
    const p = 12;
    cx.fillStyle = '#00f3ff';
    cx.font = 'bold 18px sans-serif';
    cx.textAlign = 'left';
    cx.textBaseline = 'top';
    cx.fillText(`Score: ${score}`, p, p);

    cx.fillStyle = '#6699bb';
    cx.font = '13px sans-serif';
    cx.fillText(`Round ${round}/10`, p, p + 24);
    cx.fillText(`Wins: ${wins}`, p, p + 42);

    if (streak > 1) {
        cx.fillStyle = '#ffd700';
        cx.font = 'bold 14px sans-serif';
        cx.fillText(`Streak: ${streak}`, p, p + 60);
    }

    // Enemy count
    const alive = enemies.filter(e => e.alive).length;
    cx.fillStyle = '#ff9d00';
    cx.font = '13px sans-serif';
    cx.textAlign = 'right';
    cx.fillText(`Enemies: ${alive}/${enemies.length}`, W - p, p);
    cx.fillStyle = 'rgba(0,243,255,0.3)';
    cx.fillText(DNAMES[diff], W - p, p + 18);

    // Active powerup indicators
    let puY = p + 36;
    if (boostActive) {
        cx.fillStyle = '#ffff00';
        cx.font = 'bold 12px sans-serif';
        cx.fillText(`BOOST ${Math.ceil(boostTimer / 15)}s`, W - p, puY);
        puY += 16;
    }
    if (shieldActive) {
        cx.fillStyle = '#00ccff';
        cx.font = 'bold 12px sans-serif';
        cx.fillText(`SHIELD ${Math.ceil(shieldTimer / 15)}s`, W - p, puY);
    }
}

function drawParticles() {
    for (const p of particles) {
        cx.globalAlpha = p.life;
        cx.fillStyle = p.color;
        cx.beginPath();
        cx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        cx.fill();
    }
    cx.globalAlpha = 1;
}

function draw(t) {
    resize();
    cx.save();
    cx.translate(shakeX, shakeY);

    drawGrid();
    drawTrails();

    if (state === 'playing' || state === 'roundover') {
        drawCycle(player);
        for (const e of enemies) drawCycle(e);
        drawPowerups(t);
        drawHUD();
        drawParticles();
    }

    cx.restore();
}

// Menus
function showMenu() {
    const ui = document.getElementById('ui');
    let hsH = '';
    if (hs.length > 0) {
        hsH = '<div style="margin-top:10px;">';
        for (let i = 0; i < Math.min(5, hs.length); i++) {
            const h = hs[i];
            hsH += `<div class="st"><span>#${i + 1} ${h.ending} (${h.diff})</span><span>${h.score}</span></div>`;
        }
        hsH += '</div>';
    }
    ui.innerHTML = `<div class="ov" id="mm"><div class="bx">
        <h1>TRON</h1><h2>Lightcycles</h2>
        <p>Race on a grid, leaving a trail of light behind you. Opponents crash into trails and walls. Survive 10 rounds against increasingly aggressive AI.</p>
        <div style="color:#6699bb;font-size:0.85rem;margin-bottom:6px;">Controls: WASD or Arrow Keys</div>
        <div style="margin-bottom:12px;">
            <div style="color:#6699bb;font-size:0.85rem;margin-bottom:6px;">Difficulty:</div>
            <div class="dr">
                <button class="db ${diff === 0 ? 'on' : ''}" onclick="diff=0;showMenu();">Easy</button>
                <button class="db ${diff === 1 ? 'on' : ''}" onclick="diff=1;showMenu();">Normal</button>
                <button class="db ${diff === 2 ? 'on' : ''}" onclick="diff=2;showMenu();">Hard</button>
            </div>
            <div style="color:#445566;font-size:0.7rem;">${diff === 0 ? 'Slow speed, dumb AI' : diff === 1 ? 'Medium speed, tactical AI' : 'Fast speed, aggressive AI'}</div>
        </div>
        <button class="btn" onclick="document.getElementById('mm').remove();startGame();">Enter the Grid</button>
        ${hsH ? '<div style="color:#6699bb;font-size:0.85rem;margin-top:10px;">High Scores:</div>' + hsH : ''}
        ${gp > 0 ? '<div style="margin-top:8px;"><div class="st"><span>Games</span><span>' + gp + '</span></div><div class="st"><span>Total Wins</span><span>' + tw + '</span></div></div>' : ''}
    </div></div>`;
}

function showPause() {
    const ui = document.getElementById('ui');
    ui.innerHTML = `<div class="ov" id="pa"><div class="bx">
        <h1>PAUSED</h1>
        <div style="margin:12px 0;padding:8px;border:1px solid rgba(0,243,255,0.15);border-radius:8px;">
            <div class="st"><span>Score</span><span>${score}</span></div>
            <div class="st"><span>Round</span><span>${round}/10</span></div>
            <div class="st"><span>Wins</span><span>${wins}</span></div>
            <div class="st"><span>Streak</span><span>${streak}</span></div>
        </div>
        <button class="btn" onclick="document.getElementById('pa').remove();state='playing';">Resume</button>
        <button class="btn sm" onclick="document.getElementById('pa').remove();state='menu';showMenu();">Quit</button>
    </div></div>`;
}

function showGameOver(ending) {
    const ui = document.getElementById('ui');
    const won = wins >= 4;
    const eColor = won ? '#00f3ff' : '#ff3366';
    ui.innerHTML = `<div class="ov" id="go"><div class="bx">
        <h1 style="color:${eColor};">${won ? 'VICTORY' : 'DEREZZED'}</h1>
        <h2 style="color:${eColor};font-size:1.3rem;">${ending}</h2>
        <div style="margin:12px 0;padding:8px;border:1px solid rgba(0,243,255,0.15);border-radius:8px;">
            <div class="st"><span>Final Score</span><span style="color:#ffd700;">${score}</span></div>
            <div class="st"><span>Rounds Won</span><span>${wins}/10</span></div>
            <div class="st"><span>Best Streak</span><span>${maxStreak}</span></div>
        </div>
        <button class="btn" onclick="document.getElementById('go').remove();startGame();">Play Again</button>
        <button class="btn sm" onclick="document.getElementById('go').remove();state='menu';showMenu();">Main Menu</button>
    </div></div>`;
}

// Input
document.addEventListener('keydown', (e) => {
    initA();
    keys[e.key] = true;

    if (e.key === 'Escape') {
        if (state === 'playing') { state = 'paused'; showPause(); }
        else if (state === 'paused') { document.getElementById('pa')?.remove(); state = 'playing'; }
        return;
    }
    if ((e.key === 'r' || e.key === 'R') && (state === 'playing' || state === 'gameover' || state === 'roundover')) {
        document.querySelectorAll('.ov').forEach(m => m.remove());
        startGame();
        return;
    }

    if (state === 'playing' && player.alive) {
        if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') { e.preventDefault(); player.turn(0, -1); }
        if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') { e.preventDefault(); player.turn(0, 1); }
        if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') { e.preventDefault(); player.turn(-1, 0); }
        if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') { e.preventDefault(); player.turn(1, 0); }
    }

    if (state === 'menu' && (e.key === ' ' || e.key === 'Enter')) {
        document.getElementById('mm')?.remove();
        startGame();
    }
});

document.addEventListener('keyup', (e) => { keys[e.key] = false; });

// Touch controls
let touchStartX = 0, touchStartY = 0;
cv.addEventListener('touchstart', (e) => {
    e.preventDefault();
    initA();
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
});
cv.addEventListener('touchend', (e) => {
    e.preventDefault();
    if (state !== 'playing' || !player.alive) return;
    const dx = e.changedTouches[0].clientX - touchStartX;
    const dy = e.changedTouches[0].clientY - touchStartY;
    if (Math.abs(dx) > Math.abs(dy)) {
        player.turn(dx > 0 ? 1 : -1, 0);
    } else {
        player.turn(0, dy > 0 ? 1 : -1);
    }
});

// Main loop
function loop(t) {
    update();
    draw(t);
    requestAnimationFrame(loop);
}

showMenu();
requestAnimationFrame(loop);
</script>
</body>
</html>