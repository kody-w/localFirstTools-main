<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PalBoids: Swarm Collector</title>
    <meta name="description" content="A creature collection game where you tame wild boids to build a swarm that protects you from predators.">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0f172a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #e2e8f0;
            user-select: none;
        }
        canvas {
            display: block;
            cursor: crosshair;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(15, 23, 42, 0.8);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            width: 280px;
            pointer-events: auto;
        }
        h1 {
            margin: 0 0 10px 0;
            font-size: 1.4rem;
            font-weight: 700;
            color: #38bdf8;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }
        .stat-label { color: #94a3b8; }
        .stat-value { font-weight: bold; color: #f1f5f9; }
        
        #controls-hint {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.8rem;
            color: #64748b;
            line-height: 1.5;
        }
        
        .health-bar-container {
            width: 100%;
            height: 8px;
            background: #334155;
            border-radius: 4px;
            margin-top: 5px;
            overflow: hidden;
        }
        .health-bar {
            height: 100%;
            background: #22c55e;
            width: 100%;
            transition: width 0.2s;
        }
        
        #game-over {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 23, 42, 0.95);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            border: 2px solid #38bdf8;
            pointer-events: auto;
        }
        button {
            background: #38bdf8;
            color: #0f172a;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-weight: bold;
            font-size: 1rem;
            cursor: pointer;
            margin-top: 20px;
        }
        button:hover { background: #0ea5e9; }

        .notification {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            opacity: 0;
            transition: opacity 0.3s;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="ui-layer">
        <div id="hud">
            <h1>PalBoids</h1>
            
            <div class="stat-row">
                <span class="stat-label">Player Health</span>
                <span class="stat-value" id="hp-val">100%</span>
            </div>
            <div class="health-bar-container">
                <div class="health-bar" id="player-hp-bar"></div>
            </div>
            
            <div style="margin-top: 15px;"></div>
            
            <div class="stat-row">
                <span class="stat-label">Swarm Size</span>
                <span class="stat-value" id="swarm-count">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Wild Boids</span>
                <span class="stat-value" id="wild-count">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Predators</span>
                <span class="stat-value" id="predator-count" style="color: #ef4444;">0</span>
            </div>

            <div id="controls-hint">
                <strong>WASD</strong> to Move<br>
                <strong>Click</strong> to throw Tame Sphere<br>
                <strong>Space</strong> to recall swarm<br>
                Build your swarm to defeat predators!
            </div>
        </div>

        <div id="game-over">
            <h1 style="font-size: 2rem; margin-bottom: 10px;">GAME OVER</h1>
            <p id="game-over-msg">Your swarm was defeated.</p>
            <button onclick="location.reload()">Respawn</button>
        </div>
        
        <div id="notification" class="notification"></div>
    </div>

<script>
/**
 * Vector Utility Class
 */
class Vector {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    add(v) { this.x += v.x; this.y += v.y; return this; }
    sub(v) { this.x -= v.x; this.y -= v.y; return this; }
    mult(n) { this.x *= n; this.y *= n; return this; }
    div(n) { if (n !== 0) { this.x /= n; this.y /= n; } return this; }
    mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
    setMag(n) { return this.normalize().mult(n); }
    normalize() { const m = this.mag(); if (m !== 0) this.div(m); return this; }
    limit(max) { if (this.mag() > max) this.normalize().mult(max); return this; }
    dist(v) { const dx = this.x - v.x; const dy = this.y - v.y; return Math.sqrt(dx * dx + dy * dy); }
    static add(v1, v2) { return new Vector(v1.x + v2.x, v1.y + v2.y); }
    static sub(v1, v2) { return new Vector(v1.x - v2.x, v1.y - v2.y); }
    copy() { return new Vector(this.x, this.y); }
}

/**
 * Quadtree Spatial Partitioning
 */
class Rectangle {
    constructor(x, y, w, h) {
        this.x = x; this.y = y; this.w = w; this.h = h;
    }
    contains(point) {
        return (point.x >= this.x - this.w && point.x <= this.x + this.w &&
                point.y >= this.y - this.h && point.y <= this.y + this.h);
    }
    intersects(range) {
        return !(range.x - range.w > this.x + this.w || range.x + range.w < this.x - this.w ||
                 range.y - range.h > this.y + this.h || range.y + range.h < this.y - this.h);
    }
}

class QuadTree {
    constructor(boundary, capacity) {
        this.boundary = boundary;
        this.capacity = capacity;
        this.points = [];
        this.divided = false;
    }
    insert(point) {
        if (!this.boundary.contains(point.position)) return false;
        if (this.points.length < this.capacity) {
            this.points.push(point);
            return true;
        }
        if (!this.divided) this.subdivide();
        return (this.northeast.insert(point) || this.northwest.insert(point) ||
                this.southeast.insert(point) || this.southwest.insert(point));
    }
    subdivide() {
        const x = this.boundary.x; const y = this.boundary.y;
        const w = this.boundary.w / 2; const h = this.boundary.h / 2;
        this.northeast = new QuadTree(new Rectangle(x + w, y - h, w, h), this.capacity);
        this.northwest = new QuadTree(new Rectangle(x - w, y - h, w, h), this.capacity);
        this.southeast = new QuadTree(new Rectangle(x + w, y + h, w, h), this.capacity);
        this.southwest = new QuadTree(new Rectangle(x - w, y + h, w, h), this.capacity);
        this.divided = true;
    }
    query(range, found) {
        if (!found) found = [];
        if (!this.boundary.intersects(range)) return found;
        for (let p of this.points) {
            if (range.contains(p.position)) found.push(p);
        }
        if (this.divided) {
            this.northwest.query(range, found);
            this.northeast.query(range, found);
            this.southwest.query(range, found);
            this.southeast.query(range, found);
        }
        return found;
    }
}

/**
 * Game Entities
 */

class Player {
    constructor(x, y) {
        this.position = new Vector(x, y);
        this.velocity = new Vector(0, 0);
        this.speed = 4;
        this.health = 100;
        this.maxHealth = 100;
        this.radius = 15;
        this.keys = {};
    }

    update() {
        this.velocity.mult(0);
        if (this.keys['w'] || this.keys['ArrowUp']) this.velocity.y = -1;
        if (this.keys['s'] || this.keys['ArrowDown']) this.velocity.y = 1;
        if (this.keys['a'] || this.keys['ArrowLeft']) this.velocity.x = -1;
        if (this.keys['d'] || this.keys['ArrowRight']) this.velocity.x = 1;

        if (this.velocity.mag() > 0) {
            this.velocity.normalize().mult(this.speed);
        }
        
        this.position.add(this.velocity);
        
        // Edges
        if (this.position.x < 0) this.position.x = 0;
        if (this.position.x > width) this.position.x = width;
        if (this.position.y < 0) this.position.y = 0;
        if (this.position.y > height) this.position.y = height;
    }

    show(ctx) {
        ctx.beginPath();
        ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = '#38bdf8';
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Player indicator ring
        ctx.beginPath();
        ctx.arc(this.position.x, this.position.y, this.radius + 5, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(56, 189, 248, 0.3)';
        ctx.stroke();
    }
    
    takeDamage(amount) {
        this.health -= amount;
        if (this.health < 0) this.health = 0;
        updateHealthUI();
        if (this.health <= 0) gameOver("You were defeated by a predator!");
    }
}

class Projectile {
    constructor(x, y, targetX, targetY) {
        this.position = new Vector(x, y);
        this.velocity = new Vector(targetX - x, targetY - y);
        this.velocity.setMag(10);
        this.radius = 4;
        this.active = true;
        this.life = 60;
    }
    
    update() {
        this.position.add(this.velocity);
        this.life--;
        if (this.life <= 0) this.active = false;
    }
    
    show(ctx) {
        ctx.beginPath();
        ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = '#fbbf24'; // Gold color for "Tame Sphere"
        ctx.fill();
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#fbbf24';
        ctx.shadowBlur = 0;
    }
}

class Boid {
    constructor(x, y, type = 'wild') {
        this.position = new Vector(x, y);
        this.velocity = new Vector(Math.random() * 2 - 1, Math.random() * 2 - 1);
        this.velocity.setMag(Math.random() * 2 + 2);
        this.acceleration = new Vector(0, 0);
        
        this.type = type; // 'wild', 'tamed', 'predator'
        this.isTamed = (type === 'tamed');
        this.isPredator = (type === 'predator');
        
        // Stats based on type
        if (this.isPredator) {
            this.maxForce = 0.2;
            this.maxSpeed = 4.5;
            this.color = '#ef4444';
            this.size = 12;
            this.health = 200;
        } else if (this.isTamed) {
            this.maxForce = 0.15;
            this.maxSpeed = 5;
            this.color = '#22c55e';
            this.size = 6;
            this.health = 50;
        } else {
            // Wild
            this.maxForce = 0.1;
            this.maxSpeed = 3.5;
            this.color = '#94a3b8';
            this.size = 6;
            this.health = 30;
        }
        
        this.trail = [];
        this.trailLength = this.isPredator ? 15 : 5;
    }

    edges() {
        if (this.position.x > width) this.position.x = 0;
        else if (this.position.x < 0) this.position.x = width;
        if (this.position.y > height) this.position.y = 0;
        else if (this.position.y < 0) this.position.y = height;
    }

    // Standard Boid Behaviors
    align(boids, perception) {
        let steering = new Vector(0, 0);
        let total = 0;
        for (let other of boids) {
            let d = this.position.dist(other.position);
            if (other !== this && d < perception && other.type === this.type) {
                steering.add(other.velocity);
                total++;
            }
        }
        if (total > 0) {
            steering.div(total).setMag(this.maxSpeed).sub(this.velocity).limit(this.maxForce);
        }
        return steering;
    }

    cohesion(boids, perception) {
        let steering = new Vector(0, 0);
        let total = 0;
        for (let other of boids) {
            let d = this.position.dist(other.position);
            if (other !== this && d < perception && other.type === this.type) {
                steering.add(other.position);
                total++;
            }
        }
        if (total > 0) {
            steering.div(total).sub(this.position).setMag(this.maxSpeed).sub(this.velocity).limit(this.maxForce);
        }
        return steering;
    }

    separation(boids, perception) {
        let steering = new Vector(0, 0);
        let total = 0;
        for (let other of boids) {
            let d = this.position.dist(other.position);
            if (other !== this && d < perception) {
                let diff = Vector.sub(this.position, other.position);
                diff.div(d * d);
                
                // Stronger repulsion from predators if not attacking
                if (other.isPredator && !this.isPredator) {
                    diff.mult(10);
                }
                
                steering.add(diff);
                total++;
            }
        }
        if (total > 0) {
            steering.div(total).setMag(this.maxSpeed).sub(this.velocity).limit(this.maxForce * 1.5);
        }
        return steering;
    }

    // Game Behaviors
    seek(target) {
        let desired = Vector.sub(target, this.position);
        desired.setMag(this.maxSpeed);
        let steer = Vector.sub(desired, this.velocity);
        steer.limit(this.maxForce);
        return steer;
    }
    
    flee(target) {
        let desired = Vector.sub(this.position, target);
        desired.setMag(this.maxSpeed);
        let steer = Vector.sub(desired, this.velocity);
        steer.limit(this.maxForce);
        return steer;
    }

    behavior(boids, player) {
        // Basic flocking
        let perception = 50;
        let alignment = this.align(boids, perception);
        let cohesion = this.cohesion(boids, perception);
        let separation = this.separation(boids, perception);

        // Weights
        alignment.mult(1.0);
        cohesion.mult(1.0);
        separation.mult(1.5);

        this.acceleration.add(alignment);
        this.acceleration.add(cohesion);
        this.acceleration.add(separation);

        // Specific Logic
        if (this.isTamed) {
            // Follow player
            let followForce = this.seek(player.position);
            
            // If close to player, orbit/slow down
            let d = this.position.dist(player.position);
            if (d < 100) {
                followForce.mult(0.5);
            } else {
                followForce.mult(1.5);
            }
            this.acceleration.add(followForce);
            
            // Attack nearby predators
            let nearestPredator = null;
            let minDist = 200;
            for (let other of boids) {
                if (other.isPredator) {
                    let d = this.position.dist(other.position);
                    if (d < minDist) {
                        minDist = d;
                        nearestPredator = other;
                    }
                }
            }
            
            if (nearestPredator) {
                let attackForce = this.seek(nearestPredator.position);
                attackForce.mult(3.0); // Aggressive!
                this.acceleration.add(attackForce);
                
                // Damage logic
                if (minDist < 20) {
                    nearestPredator.takeDamage(0.5);
                    // Visual hit effect
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(nearestPredator.position.x, nearestPredator.position.y, 2, 2);
                }
            }
            
        } else if (this.isPredator) {
            // Chase player
            let chaseForce = this.seek(player.position);
            chaseForce.mult(0.8);
            this.acceleration.add(chaseForce);
            
            // Damage player if close
            let d = this.position.dist(player.position);
            if (d < player.radius + this.size) {
                player.takeDamage(0.5);
            }
            
        } else {
            // Wild: Flee from player if too close
            let d = this.position.dist(player.position);
            if (d < 100) {
                let fleeForce = this.flee(player.position);
                fleeForce.mult(2.0);
                this.acceleration.add(fleeForce);
            }
        }
    }
    
    takeDamage(amount) {
        this.health -= amount;
        if (this.health <= 0) {
            // Die
            return true; // Dead
        }
        return false; // Alive
    }

    update() {
        this.position.add(this.velocity);
        this.velocity.add(this.acceleration);
        this.velocity.limit(this.maxSpeed);
        this.acceleration.mult(0);

        // Trail
        if (frameCount % 3 === 0) {
            this.trail.push({x: this.position.x, y: this.position.y});
            if (this.trail.length > this.trailLength) this.trail.shift();
        }
    }

    show(ctx) {
        // Trail
        if (this.trail.length > 1) {
            ctx.beginPath();
            ctx.strokeStyle = this.color;
            ctx.globalAlpha = 0.3;
            ctx.lineWidth = 1;
            for (let i = 0; i < this.trail.length - 1; i++) {
                ctx.moveTo(this.trail[i].x, this.trail[i].y);
                ctx.lineTo(this.trail[i+1].x, this.trail[i+1].y);
            }
            ctx.stroke();
            ctx.globalAlpha = 1.0;
        }

        ctx.save();
        ctx.translate(this.position.x, this.position.y);
        ctx.rotate(Math.atan2(this.velocity.y, this.velocity.x));
        
        ctx.fillStyle = this.color;
        ctx.beginPath();
        
        if (this.isPredator) {
            ctx.moveTo(this.size, 0);
            ctx.lineTo(-this.size, this.size/2);
            ctx.lineTo(-this.size/2, 0);
            ctx.lineTo(-this.size, -this.size/2);
        } else {
            ctx.moveTo(this.size, 0);
            ctx.lineTo(-this.size/2, this.size/2);
            ctx.lineTo(-this.size/4, 0);
            ctx.lineTo(-this.size/2, -this.size/2);
        }
        
        ctx.closePath();
        ctx.fill();
        
        // Health bar for predators
        if (this.isPredator && this.health < 200) {
            ctx.rotate(-Math.atan2(this.velocity.y, this.velocity.x)); // Unrotate
            ctx.fillStyle = 'red';
            ctx.fillRect(-10, -15, 20, 3);
            ctx.fillStyle = '#0f0';
            ctx.fillRect(-10, -15, 20 * (this.health / 200), 3);
        }
        
        ctx.restore();
    }
}

/**
 * Main Game Loop
 */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let width, height;
let boids = [];
let projectiles = [];
let player;
let frameCount = 0;
let gameActive = true;

// Input Handling
window.addEventListener('keydown', e => player.keys[e.key] = true);
window.addEventListener('keyup', e => player.keys[e.key] = false);
window.addEventListener('mousedown', e => {
    if (!gameActive) return;
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    projectiles.push(new Projectile(player.position.x, player.position.y, mx, my));
});

function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
}

function initGame() {
    resize();
    player = new Player(width/2, height/2);
    boids = [];
    projectiles = [];
    
    // Spawn Wild Boids
    for (let i = 0; i < 100; i++) {
        boids.push(new Boid(Math.random() * width, Math.random() * height, 'wild'));
    }
    
    // Spawn Initial Predator
    spawnPredator();
    
    updateUI();
    gameActive = true;
    document.getElementById('game-over').style.display = 'none';
    
    requestAnimationFrame(gameLoop);
}

function spawnPredator() {
    // Spawn away from player
    let x, y;
    do {
        x = Math.random() * width;
        y = Math.random() * height;
    } while (new Vector(x, y).dist(player.position) < 300);
    
    boids.push(new Boid(x, y, 'predator'));
    showNotification("A Predator has appeared!");
}

function updateUI() {
    const wild = boids.filter(b => !b.isTamed && !b.isPredator).length;
    const tamed = boids.filter(b => b.isTamed).length;
    const preds = boids.filter(b => b.isPredator).length;
    
    document.getElementById('wild-count').textContent = wild;
    document.getElementById('swarm-count').textContent = tamed;
    document.getElementById('predator-count').textContent = preds;
}

function updateHealthUI() {
    const pct = (player.health / player.maxHealth) * 100;
    document.getElementById('player-hp-bar').style.width = `${pct}%`;
    document.getElementById('hp-val').textContent = `${Math.ceil(pct)}%`;
    
    if (pct < 30) {
        document.getElementById('player-hp-bar').style.background = '#ef4444';
    } else {
        document.getElementById('player-hp-bar').style.background = '#22c55e';
    }
}

function showNotification(msg) {
    const el = document.getElementById('notification');
    el.textContent = msg;
    el.style.opacity = 1;
    setTimeout(() => el.style.opacity = 0, 3000);
}

function gameOver(reason) {
    gameActive = false;
    document.getElementById('game-over').style.display = 'block';
    document.getElementById('game-over-msg').textContent = reason;
}

function gameLoop() {
    if (!gameActive) return;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, width, height);
    
    // Quadtree for optimization
    let boundary = new Rectangle(width / 2, height / 2, width / 2, height / 2);
    let qtree = new QuadTree(boundary, 4);
    for (let boid of boids) qtree.insert(boid);
    
    // Update Player
    player.update();
    player.show(ctx);
    
    // Update Projectiles
    for (let i = projectiles.length - 1; i >= 0; i--) {
        let p = projectiles[i];
        p.update();
        p.show(ctx);
        
        if (!p.active) {
            projectiles.splice(i, 1);
            continue;
        }
        
        // Check collisions with wild boids
        let range = new Rectangle(p.position.x, p.position.y, 10, 10);
        let nearby = qtree.query(range);
        
        for (let boid of nearby) {
            if (boid.type === 'wild' && p.position.dist(boid.position) < boid.size + p.radius) {
                // TAME!
                boid.type = 'tamed';
                boid.isTamed = true;
                boid.color = '#22c55e';
                boid.maxSpeed = 5;
                boid.health = 50;
                
                // Visual effect
                ctx.beginPath();
                ctx.arc(boid.position.x, boid.position.y, 20, 0, Math.PI*2);
                ctx.strokeStyle = '#fff';
                ctx.stroke();
                
                p.active = false;
                updateUI();
                break;
            }
        }
    }
    
    // Update Boids
    for (let i = boids.length - 1; i >= 0; i--) {
        let boid = boids[i];
        
        // Optimization: only query nearby boids
        let range = new Rectangle(boid.position.x, boid.position.y, 50, 50);
        let localBoids = qtree.query(range);
        
        boid.edges();
        boid.behavior(localBoids, player);
        boid.update();
        boid.show(ctx);
        
        // Death check
        if (boid.health <= 0) {
            // Explosion effect
            ctx.fillStyle = boid.color;
            for(let k=0; k<5; k++) {
                ctx.fillRect(boid.position.x + (Math.random()-0.5)*20, boid.position.y + (Math.random()-0.5)*20, 3, 3);
            }
            
            if (boid.isPredator) {
                showNotification("Predator Defeated!");
                // Spawn 2 more wild boids as reward
                boids.push(new Boid(Math.random()*width, Math.random()*height, 'wild'));
                boids.push(new Boid(Math.random()*width, Math.random()*height, 'wild'));
                
                // Schedule next predator
                setTimeout(spawnPredator, 5000);
            }
            
            boids.splice(i, 1);
            updateUI();
        }
    }
    
    // Spawn more wild boids if low
    if (boids.filter(b => b.type === 'wild').length < 20 && Math.random() < 0.05) {
        boids.push(new Boid(Math.random()*width, Math.random()*height, 'wild'));
        updateUI();
    }
    
    frameCount++;
    requestAnimationFrame(gameLoop);
}

// Init
window.addEventListener('resize', resize);
initGame();

</script>
</body>
</html>