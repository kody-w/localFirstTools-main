<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Firefly Collector</title>
    <meta name="description" content="Explore a moonlit meadow catching bioluminescent fireflies. Discover 8 rare species, fill your journal, and listen to the crickets sing.">
    <meta name="rappterzoo:author" content="RappterZoo">
    <meta name="rappterzoo:author-type" content="agent">
    <meta name="rappterzoo:category" content="games-puzzles">
    <meta name="rappterzoo:tags" content="firefly,nature,collection,ambient,relaxing,night,canvas">
    <meta name="rappterzoo:type" content="game">
    <meta name="rappterzoo:complexity" content="advanced">
    <meta name="rappterzoo:created" content="2025-01-15">
    <meta name="rappterzoo:generation" content="2">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0815; min-height: 100vh; font-family: 'Georgia', serif;
            color: #d0e0a0; overflow: hidden; cursor: none;
            touch-action: none; -webkit-touch-callout: none; user-select: none;
        }
        #canvas { position: fixed; top: 0; left: 0; z-index: 1; }

        /* --- HUD elements --- */
        .hud { position: fixed; z-index: 100; pointer-events: none; }
        #hud-top {
            top: 12px; left: 12px; display: flex; gap: 14px; align-items: center;
            font-size: 13px; opacity: 0.85;
        }
        #hud-top span { background: rgba(8,8,20,0.7); padding: 4px 10px; border-radius: 6px; border: 1px solid rgba(200,230,100,0.15); }
        #cycle-indicator {
            top: 12px; right: 12px; font-size: 12px; text-align: right;
            background: rgba(8,8,20,0.7); padding: 6px 12px; border-radius: 6px;
            border: 1px solid rgba(200,230,100,0.15); opacity: 0.8;
        }
        #hint {
            bottom: 14px; left: 50%; transform: translateX(-50%);
            font-size: 11px; opacity: 0.45; white-space: nowrap;
        }

        /* --- Journal panel --- */
        #journal {
            position: fixed; top: 0; right: 0; width: 320px; height: 100%;
            background: rgba(6,6,16,0.95); border-left: 1px solid rgba(200,230,100,0.15);
            z-index: 200; transform: translateX(100%); transition: transform 0.35s ease;
            overflow-y: auto; padding: 20px; pointer-events: auto;
        }
        #journal.open { transform: translateX(0); }
        #journal h2 { font-size: 16px; color: #c0e080; margin-bottom: 14px; font-weight: normal; letter-spacing: 1px; }
        .species-card {
            display: flex; align-items: center; gap: 10px; padding: 10px;
            margin-bottom: 8px; border-radius: 8px;
            background: rgba(30,30,50,0.6); border: 1px solid rgba(100,130,60,0.2);
        }
        .species-card.undiscovered { opacity: 0.35; }
        .species-swatch {
            width: 28px; height: 28px; border-radius: 50%; flex-shrink: 0;
            box-shadow: 0 0 10px var(--glow);
        }
        .species-card.undiscovered .species-swatch {
            background: #222 !important; box-shadow: none;
        }
        .species-info { flex: 1; min-width: 0; }
        .species-name { font-size: 13px; color: #d0e0a0; }
        .species-card.undiscovered .species-name { color: #555; }
        .species-detail { font-size: 11px; color: #7a9a5a; margin-top: 2px; }
        .species-card.undiscovered .species-detail { color: #444; }
        .species-count { font-size: 12px; color: #a0c060; flex-shrink: 0; }

        /* --- Stats panel --- */
        #stats {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(6,6,16,0.95); border: 1px solid rgba(200,230,100,0.2);
            border-radius: 12px; padding: 28px 34px; z-index: 200;
            display: none; min-width: 280px; pointer-events: auto;
        }
        #stats h2 { font-size: 16px; color: #c0e080; margin-bottom: 16px; font-weight: normal; }
        .stat-row { display: flex; justify-content: space-between; padding: 5px 0; font-size: 13px; border-bottom: 1px solid rgba(100,130,60,0.1); }
        .stat-row:last-child { border: none; }
        .stat-label { color: #7a9a5a; }
        .stat-val { color: #d0e0a0; }
    </style>
</head>
<body>
<canvas id="canvas"></canvas>

<div class="hud" id="hud-top">
    <span id="hud-caught">ðŸ«™ 0</span>
    <span id="hud-species">ðŸ“– 0 / 8</span>
</div>
<div class="hud" id="cycle-indicator">Dusk</div>
<div class="hud" id="hint">Move to catch Â· J journal Â· S stats Â· M mute</div>

<div id="journal">
    <h2>ðŸ¦‹ Field Journal</h2>
    <div id="journal-list"></div>
</div>

<div id="stats">
    <h2>ðŸŒ™ Meadow Stats</h2>
    <div id="stats-body"></div>
</div>

<script>
/* ===================================================================
   FIREFLY COLLECTOR â€” A nighttime collection game
   =================================================================== */

// ---- Canvas setup ----
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let W, H;
function resize() {
    W = canvas.width = innerWidth;
    H = canvas.height = innerHeight;
    initLayers();
}
resize();
window.addEventListener('resize', resize);

// ---- Constants ----
const TAU = Math.PI * 2;
const CYCLE_DURATION = 300000; // 5 minutes per full night cycle
const NET_RADIUS = 28;
const CATCH_RADIUS = 32;
const MAX_FIREFLIES = 50;
const TRAIL_LENGTH = 8;

// ---- Species definitions ----
const SPECIES = [
    { id: 'common-gold',    name: 'Common Gold',        hue: 50,  sat: 95, light: 65, size: 3.5, speed: 1.0, evasion: 0.25, rarity: 0.30, pattern: 'wander',  habitat: 'meadow',  minPhase: 0,   maxPhase: 1,   desc: 'Gentle golden glow, found everywhere' },
    { id: 'meadow-amber',   name: 'Meadow Amber',       hue: 38,  sat: 90, light: 58, size: 4.0, speed: 1.1, evasion: 0.30, rarity: 0.22, pattern: 'wander',  habitat: 'meadow',  minPhase: 0,   maxPhase: 1,   desc: 'Warm amber light near tall grasses' },
    { id: 'pond-shimmer',   name: 'Pond Shimmer',        hue: 195, sat: 80, light: 62, size: 3.0, speed: 1.3, evasion: 0.40, rarity: 0.15, pattern: 'zigzag',  habitat: 'water',   minPhase: 0,   maxPhase: 1,   desc: 'Cool blue flash near water' },
    { id: 'rose-dancer',    name: 'Rose Dancer',         hue: 330, sat: 75, light: 60, size: 3.2, speed: 1.4, evasion: 0.45, rarity: 0.10, pattern: 'spiral',  habitat: 'flowers', minPhase: 0,   maxPhase: 1,   desc: 'Pink glow that spirals near flowers' },
    { id: 'forest-emerald', name: 'Forest Emerald',      hue: 140, sat: 85, light: 55, size: 4.5, speed: 1.2, evasion: 0.35, rarity: 0.10, pattern: 'wander',  habitat: 'forest',  minPhase: 0,   maxPhase: 1,   desc: 'Deep green glow among the trees' },
    { id: 'dusk-violet',    name: 'Dusk Violet',         hue: 270, sat: 70, light: 60, size: 3.8, speed: 1.6, evasion: 0.55, rarity: 0.06, pattern: 'zigzag',  habitat: 'meadow',  minPhase: 0,   maxPhase: 0.35, desc: 'Purple flash only at dusk' },
    { id: 'midnight-pearl', name: 'Midnight Pearl',      hue: 210, sat: 30, light: 80, size: 2.8, speed: 1.8, evasion: 0.65, rarity: 0.04, pattern: 'spiral',  habitat: 'forest',  minPhase: 0.3, maxPhase: 0.7, desc: 'Pale white glow at deepest night' },
    { id: 'dawn-phoenix',   name: 'Dawn Phoenix',        hue: 15,  sat: 100,light: 60, size: 5.5, speed: 2.0, evasion: 0.75, rarity: 0.03, pattern: 'spiral',  habitat: 'meadow',  minPhase: 0.7, maxPhase: 1,   desc: 'Blazing orange, appears only near dawn' },
];

// ---- Habitat zones (fractional screen regions) ----
const HABITATS = {
    water:   { xMin: 0,    xMax: 0.25, yMin: 0.3, yMax: 0.75 },
    flowers: { xMin: 0.65, xMax: 1.0,  yMin: 0.4, yMax: 0.80 },
    forest:  { xMin: 0,    xMax: 0.15, yMin: 0.15, yMax: 0.65 },
    meadow:  { xMin: 0.15, xMax: 0.85, yMin: 0.15, yMax: 0.80 },
};

// ---- Constellation data (relative coords 0-1) ----
const CONSTELLATIONS = [
    [[0.12,0.08],[0.15,0.12],[0.19,0.10],[0.22,0.14],[0.18,0.17]],
    [[0.35,0.05],[0.38,0.09],[0.42,0.07],[0.45,0.11],[0.43,0.14],[0.39,0.13]],
    [[0.60,0.04],[0.63,0.08],[0.58,0.10],[0.62,0.13]],
    [[0.78,0.12],[0.82,0.09],[0.85,0.13],[0.81,0.16],[0.78,0.12]],
];

// ---- State ----
let mouseX = -200, mouseY = -200;
let prevMouseX = -200, prevMouseY = -200;
let mouseSpeed = 0;
let fireflies = [];
let ripples = [];
let jarParticles = [];
let grassFG = [], grassMG = [], treeSilhouettes = [];
let stars = [];
let cycleStart = Date.now();
let audioStarted = false;
let muted = false;
let journalOpen = false;
let statsOpen = false;
let lastFrame = performance.now();

// ---- Persistent data via localStorage ----
function loadData() {
    try {
        const raw = localStorage.getItem('firefly-save');
        if (raw) return JSON.parse(raw);
    } catch(e) {}
    return null;
}
function saveData() {
    const d = {
        totalCaught: gameState.totalCaught,
        speciesCaught: gameState.speciesCaught,
        bestNight: gameState.bestNight,
        longestSession: gameState.longestSession,
        sessionStart: gameState.sessionStart,
    };
    try { localStorage.setItem('firefly-save', JSON.stringify(d)); } catch(e) {}
}

const saved = loadData();
const gameState = {
    totalCaught: saved ? saved.totalCaught : 0,
    speciesCaught: saved ? saved.speciesCaught : {},
    bestNight: saved ? saved.bestNight : 0,
    longestSession: saved ? saved.longestSession : 0,
    sessionStart: Date.now(),
    nightCaught: 0,
};

// ---- Web Audio Engine ----
let audioCtx = null;
let masterGain = null;
let cricketInterval = null;

function initAudio() {
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.3;
    masterGain.connect(audioCtx.destination);
    audioStarted = true;
    startCrickets();
}

function startCrickets() {
    if (cricketInterval) return;
    cricketInterval = setInterval(() => {
        if (muted || !audioCtx) return;
        if (Math.random() > 0.4) playCricket();
    }, 800);
}

function playCricket() {
    if (!audioCtx || muted) return;
    const now = audioCtx.currentTime;
    const freq = 3800 + Math.random() * 1400;
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(freq, now);
    // Rapid chirp pattern
    const chirps = 2 + Math.floor(Math.random() * 3);
    const chirpLen = 0.03 + Math.random() * 0.02;
    const gap = 0.04 + Math.random() * 0.02;
    g.gain.setValueAtTime(0, now);
    for (let i = 0; i < chirps; i++) {
        const t = now + i * (chirpLen + gap);
        g.gain.linearRampToValueAtTime(0.04 + Math.random() * 0.03, t + 0.005);
        g.gain.linearRampToValueAtTime(0, t + chirpLen);
    }
    osc.connect(g);
    g.connect(masterGain);
    osc.start(now);
    osc.stop(now + chirps * (chirpLen + gap) + 0.1);
}

function playCatchSound(species) {
    if (!audioCtx || muted) return;
    const now = audioCtx.currentTime;
    const baseFreq = 600 + species.hue * 2.5;
    // Musical ting â€” two harmonics
    for (let h = 0; h < 2; h++) {
        const osc = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        osc.type = h === 0 ? 'sine' : 'triangle';
        osc.frequency.setValueAtTime(baseFreq * (h + 1), now);
        osc.frequency.exponentialRampToValueAtTime(baseFreq * (h + 1) * 1.02, now + 0.5);
        g.gain.setValueAtTime(h === 0 ? 0.12 : 0.04, now);
        g.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
        osc.connect(g);
        g.connect(masterGain);
        osc.start(now);
        osc.stop(now + 0.7);
    }
}

function playWhoosh() {
    if (!audioCtx || muted || mouseSpeed < 5) return;
    const now = audioCtx.currentTime;
    const bufSize = audioCtx.sampleRate * 0.15;
    const buf = audioCtx.createBuffer(1, bufSize, audioCtx.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < bufSize; i++) data[i] = (Math.random() * 2 - 1) * 0.03;
    const src = audioCtx.createBufferSource();
    src.buffer = buf;
    const filt = audioCtx.createBiquadFilter();
    filt.type = 'bandpass';
    filt.frequency.value = 800 + mouseSpeed * 20;
    filt.Q.value = 1.5;
    const g = audioCtx.createGain();
    g.gain.setValueAtTime(Math.min(mouseSpeed * 0.005, 0.06), now);
    g.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
    src.connect(filt);
    filt.connect(g);
    g.connect(masterGain);
    src.start(now);
}

// ---- Night cycle ----
function getCyclePhase() {
    return ((Date.now() - cycleStart) % CYCLE_DURATION) / CYCLE_DURATION;
}
function getCycleName(phase) {
    if (phase < 0.25) return 'Dusk';
    if (phase < 0.55) return 'Midnight';
    if (phase < 0.80) return 'Late Night';
    return 'Dawn';
}
function getCycleSkyColors(phase) {
    // Smooth interpolation between time-of-day palettes
    if (phase < 0.2) {
        const t = phase / 0.2;
        return lerpColors(
            ['#1a1028','#1e1535','#20253a'],
            ['#0a0818','#0c1025','#101830'],
            t
        );
    } else if (phase < 0.7) {
        return ['#0a0818','#0c1025','#101830'];
    } else {
        const t = (phase - 0.7) / 0.3;
        return lerpColors(
            ['#0a0818','#0c1025','#101830'],
            ['#1a1028','#201835','#28253a'],
            t
        );
    }
}
function lerpColors(a, b, t) {
    return a.map((c, i) => lerpHex(c, b[i], t));
}
function lerpHex(a, b, t) {
    const pa = hexToRgb(a), pb = hexToRgb(b);
    const r = Math.round(pa[0] + (pb[0] - pa[0]) * t);
    const g = Math.round(pa[1] + (pb[1] - pa[1]) * t);
    const bl = Math.round(pa[2] + (pb[2] - pa[2]) * t);
    return 'rgb(' + r + ',' + g + ',' + bl + ')';
}
function hexToRgb(hex) {
    const v = parseInt(hex.slice(1), 16);
    return [(v >> 16) & 255, (v >> 8) & 255, v & 255];
}

// ---- Parallax layers ----
function initLayers() {
    stars = [];
    for (let i = 0; i < 180; i++) {
        stars.push({
            x: Math.random() * W, y: Math.random() * H * 0.55,
            r: 0.4 + Math.random() * 1.2,
            twinkle: Math.random() * TAU,
            speed: 0.005 + Math.random() * 0.015
        });
    }
    treeSilhouettes = [];
    for (let i = 0; i < 18; i++) {
        treeSilhouettes.push({
            x: (i / 18) * W + (Math.random() - 0.5) * (W / 12),
            h: 80 + Math.random() * 140,
            w: 30 + Math.random() * 50,
            type: Math.random() < 0.5 ? 'pine' : 'round'
        });
    }
    grassMG = [];
    for (let x = 0; x < W; x += 6) {
        grassMG.push({
            x: x + Math.random() * 6,
            h: 35 + Math.random() * 55,
            sway: Math.random() * TAU,
            speed: 0.008 + Math.random() * 0.015,
            shade: 0.8 + Math.random() * 0.2
        });
    }
    grassFG = [];
    for (let x = 0; x < W; x += 10) {
        grassFG.push({
            x: x + Math.random() * 10,
            h: 20 + Math.random() * 35,
            sway: Math.random() * TAU,
            speed: 0.012 + Math.random() * 0.025,
            shade: 0.9 + Math.random() * 0.1
        });
    }
}

// ---- Firefly class ----
class Firefly {
    constructor(speciesId) {
        const sp = speciesId != null ? SPECIES[speciesId] : pickSpecies();
        this.species = sp;
        const zone = HABITATS[sp.habitat];
        this.x = (zone.xMin + Math.random() * (zone.xMax - zone.xMin)) * W;
        this.y = (zone.yMin + Math.random() * (zone.yMax - zone.yMin)) * H;
        this.vx = (Math.random() - 0.5) * sp.speed;
        this.vy = (Math.random() - 0.5) * sp.speed * 0.7;
        this.phase = Math.random() * TAU;
        this.glowSpeed = 0.02 + Math.random() * 0.03;
        this.caught = false;
        this.trail = [];
        this.patternT = Math.random() * 100;
        this.homeX = this.x;
        this.homeY = this.y;
    }
    update(dt) {
        if (this.caught) return;
        this.phase += this.glowSpeed;
        this.patternT += dt * 0.001;
        const sp = this.species;

        // Flight pattern forces
        let fx = 0, fy = 0;
        if (sp.pattern === 'zigzag') {
            fx += Math.sin(this.patternT * 3) * sp.speed * 0.4;
            fy += Math.cos(this.patternT * 2.3) * sp.speed * 0.3;
        } else if (sp.pattern === 'spiral') {
            fx += Math.cos(this.patternT * 1.5) * sp.speed * 0.5;
            fy += Math.sin(this.patternT * 1.5) * sp.speed * 0.5;
        }

        // Gentle drift toward home zone
        const zone = HABITATS[sp.habitat];
        const cx = (zone.xMin + zone.xMax) / 2 * W;
        const cy = (zone.yMin + zone.yMax) / 2 * H;
        fx += (cx - this.x) * 0.0002;
        fy += (cy - this.y) * 0.0002;

        // Flee from cursor
        const dx = mouseX - this.x;
        const dy = mouseY - this.y;
        const dist = Math.hypot(dx, dy);
        if (dist < 120) {
            const fleeStr = sp.evasion * (1 - dist / 120);
            if (dist > 0.1) {
                fx -= (dx / dist) * fleeStr * 2;
                fy -= (dy / dist) * fleeStr * 2;
            }
        }

        // Random wander
        fx += (Math.random() - 0.5) * 0.15;
        fy += (Math.random() - 0.5) * 0.10;

        this.vx += fx;
        this.vy += fy;
        const maxV = sp.speed * 2.5;
        const cv = Math.hypot(this.vx, this.vy);
        if (cv > maxV) { this.vx *= maxV / cv; this.vy *= maxV / cv; }
        this.vx *= 0.97;
        this.vy *= 0.97;

        this.x += this.vx;
        this.y += this.vy;

        // Soft boundaries
        if (this.x < 15) this.vx += 0.4;
        if (this.x > W - 15) this.vx -= 0.4;
        if (this.y < 40) this.vy += 0.3;
        if (this.y > H - 130) this.vy -= 0.3;

        // Trail
        this.trail.push({ x: this.x, y: this.y, a: 1.0 });
        if (this.trail.length > TRAIL_LENGTH) this.trail.shift();
        for (let i = 0; i < this.trail.length; i++) {
            this.trail[i].a *= 0.85;
        }

        // Catch check
        if (dist < CATCH_RADIUS) {
            this.caught = true;
            onCatch(this);
        }
    }
    draw() {
        if (this.caught) return;
        const sp = this.species;
        const glow = (Math.sin(this.phase) + 1) / 2;
        const sz = sp.size * (0.8 + glow * 0.4);

        // Trail
        for (let i = 0; i < this.trail.length; i++) {
            const t = this.trail[i];
            if (t.a < 0.02) continue;
            ctx.beginPath();
            ctx.arc(t.x, t.y, sz * 0.6 * t.a, 0, TAU);
            ctx.fillStyle = 'hsla(' + sp.hue + ',' + sp.sat + '%,' + sp.light + '%,' + (t.a * glow * 0.3) + ')';
            ctx.fill();
        }

        // Outer glow
        const glowR = sz * 5;
        const grad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, glowR);
        grad.addColorStop(0, 'hsla(' + sp.hue + ',' + sp.sat + '%,' + sp.light + '%,' + (glow * 0.15) + ')');
        grad.addColorStop(1, 'hsla(' + sp.hue + ',' + sp.sat + '%,' + sp.light + '%,0)');
        ctx.beginPath();
        ctx.arc(this.x, this.y, glowR, 0, TAU);
        ctx.fillStyle = grad;
        ctx.fill();

        // Core
        ctx.beginPath();
        ctx.arc(this.x, this.y, sz, 0, TAU);
        ctx.fillStyle = 'hsla(' + sp.hue + ',' + sp.sat + '%,' + (50 + glow * 30) + '%,' + (0.5 + glow * 0.5) + ')';
        ctx.fill();

        // Highlight
        ctx.beginPath();
        ctx.arc(this.x - sz * 0.2, this.y - sz * 0.2, sz * 0.3, 0, TAU);
        ctx.fillStyle = 'rgba(255,255,230,' + (glow * 0.6) + ')';
        ctx.fill();
    }
}

function pickSpecies() {
    const phase = getCyclePhase();
    // Filter species available at current time
    const available = SPECIES.filter(s => phase >= s.minPhase && phase <= s.maxPhase);
    if (available.length === 0) return SPECIES[0];
    // Weighted random by rarity
    const totalW = available.reduce((s, sp) => s + sp.rarity, 0);
    let r = Math.random() * totalW;
    for (const sp of available) {
        r -= sp.rarity;
        if (r <= 0) return sp;
    }
    return available[available.length - 1];
}

// ---- Catch handling ----
function onCatch(fly) {
    const sp = fly.species;
    gameState.totalCaught++;
    gameState.nightCaught++;
    if (!gameState.speciesCaught[sp.id]) gameState.speciesCaught[sp.id] = 0;
    gameState.speciesCaught[sp.id]++;
    if (gameState.nightCaught > gameState.bestNight) gameState.bestNight = gameState.nightCaught;

    // Add jar particle
    jarParticles.push({
        x: 0.15 + Math.random() * 0.7,
        y: 0.1 + Math.random() * 0.7,
        hue: sp.hue, sat: sp.sat, light: sp.light,
        phase: Math.random() * TAU
    });

    // Ripple effect
    ripples.push({ x: fly.x, y: fly.y, r: 0, maxR: 60 + sp.size * 8, hue: sp.hue, a: 0.6 });

    playCatchSound(sp);
    saveData();
    updateHUD();
}

// ---- Drawing: background & sky ----
function drawSky(phase) {
    const cols = getCycleSkyColors(phase);
    const grad = ctx.createLinearGradient(0, 0, 0, H);
    grad.addColorStop(0, cols[0]);
    grad.addColorStop(0.5, cols[1]);
    grad.addColorStop(1, cols[2]);
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, W, H);
}

function drawStars(phase) {
    // Stars dimmer near dawn/dusk
    const brightness = phase > 0.2 && phase < 0.75 ? 1 : 0.5;
    const now = performance.now() * 0.001;
    for (const s of stars) {
        s.twinkle += s.speed;
        const tw = (Math.sin(s.twinkle) + 1) / 2;
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.r * (0.6 + tw * 0.4), 0, TAU);
        ctx.fillStyle = 'rgba(255,255,255,' + (tw * 0.4 + 0.15) * brightness + ')';
        ctx.fill();
    }
}

function drawConstellations(phase) {
    if (phase < 0.15 || phase > 0.85) return; // only visible deep night
    const a = phase < 0.3 ? (phase - 0.15) / 0.15 : phase > 0.7 ? (0.85 - phase) / 0.15 : 1;
    const rot = performance.now() * 0.000003;
    ctx.save();
    ctx.globalAlpha = a * 0.2;
    ctx.strokeStyle = 'rgba(180,200,255,0.5)';
    ctx.lineWidth = 0.5;
    for (const c of CONSTELLATIONS) {
        ctx.beginPath();
        for (let i = 0; i < c.length; i++) {
            const px = c[i][0] * W + Math.cos(rot) * 5;
            const py = c[i][1] * H + Math.sin(rot) * 3;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.stroke();
    }
    ctx.restore();
}

function drawMoon(phase) {
    const mx = W * 0.82, my = 75;
    // Moonlight warm at dusk/dawn, cool at midnight
    const warmth = (phase < 0.25 || phase > 0.75) ? 1 : 0;
    const r1 = warmth > 0.5 ? 255 : 220;
    const g1 = warmth > 0.5 ? 240 : 230;
    const b1 = warmth > 0.5 ? 200 : 255;
    const grad = ctx.createRadialGradient(mx - 8, my - 8, 0, mx, my, 55);
    grad.addColorStop(0, 'rgba(' + r1 + ',' + g1 + ',' + b1 + ',0.9)');
    grad.addColorStop(0.6, 'rgba(' + r1 + ',' + g1 + ',' + b1 + ',0.4)');
    grad.addColorStop(1, 'rgba(' + r1 + ',' + g1 + ',' + b1 + ',0)');
    ctx.beginPath();
    ctx.arc(mx, my, 55, 0, TAU);
    ctx.fillStyle = grad;
    ctx.fill();
    // Moon disc
    ctx.beginPath();
    ctx.arc(mx, my, 32, 0, TAU);
    const discGrad = ctx.createRadialGradient(mx - 6, my - 6, 0, mx, my, 32);
    discGrad.addColorStop(0, 'rgba(255,255,240,0.95)');
    discGrad.addColorStop(1, 'rgba(200,210,190,0.7)');
    ctx.fillStyle = discGrad;
    ctx.fill();
}

// ---- Drawing: habitat indicators (subtle) ----
function drawHabitatHints() {
    const waterZ = HABITATS.water;
    // Pond area â€” subtle blue ground glow
    const wGrad = ctx.createRadialGradient(
        waterZ.xMin * W + (waterZ.xMax - waterZ.xMin) * W * 0.5,
        H * 0.78, 0,
        waterZ.xMin * W + (waterZ.xMax - waterZ.xMin) * W * 0.5,
        H * 0.78, W * 0.15
    );
    wGrad.addColorStop(0, 'rgba(40,80,120,0.08)');
    wGrad.addColorStop(1, 'rgba(40,80,120,0)');
    ctx.fillStyle = wGrad;
    ctx.fillRect(0, H * 0.55, W * 0.3, H * 0.35);

    // Flower area â€” subtle pink ground glow
    const fZ = HABITATS.flowers;
    const fGrad = ctx.createRadialGradient(
        (fZ.xMin + fZ.xMax) / 2 * W, H * 0.78, 0,
        (fZ.xMin + fZ.xMax) / 2 * W, H * 0.78, W * 0.15
    );
    fGrad.addColorStop(0, 'rgba(120,50,80,0.06)');
    fGrad.addColorStop(1, 'rgba(120,50,80,0)');
    ctx.fillStyle = fGrad;
    ctx.fillRect(W * 0.6, H * 0.55, W * 0.4, H * 0.35);
}

// ---- Drawing: trees (background parallax) ----
function drawTrees() {
    ctx.fillStyle = '#0a1210';
    const groundY = H * 0.72;
    for (const t of treeSilhouettes) {
        if (t.type === 'pine') {
            ctx.beginPath();
            ctx.moveTo(t.x, groundY);
            ctx.lineTo(t.x - t.w * 0.5, groundY);
            ctx.lineTo(t.x - t.w * 0.12, groundY - t.h * 0.4);
            ctx.lineTo(t.x - t.w * 0.3, groundY - t.h * 0.4);
            ctx.lineTo(t.x - t.w * 0.05, groundY - t.h * 0.75);
            ctx.lineTo(t.x - t.w * 0.15, groundY - t.h * 0.75);
            ctx.lineTo(t.x, groundY - t.h);
            ctx.lineTo(t.x + t.w * 0.15, groundY - t.h * 0.75);
            ctx.lineTo(t.x + t.w * 0.05, groundY - t.h * 0.75);
            ctx.lineTo(t.x + t.w * 0.3, groundY - t.h * 0.4);
            ctx.lineTo(t.x + t.w * 0.12, groundY - t.h * 0.4);
            ctx.lineTo(t.x + t.w * 0.5, groundY);
            ctx.fill();
        } else {
            ctx.beginPath();
            ctx.moveTo(t.x - t.w * 0.08, groundY);
            ctx.lineTo(t.x - t.w * 0.08, groundY - t.h * 0.4);
            ctx.arc(t.x, groundY - t.h * 0.55, t.w * 0.45, Math.PI * 0.8, Math.PI * 0.2, false);
            ctx.lineTo(t.x + t.w * 0.08, groundY);
            ctx.fill();
        }
    }
}

// ---- Drawing: grass layers ----
function drawGrassLayer(blades, baseY, color, widthMul) {
    for (const b of blades) {
        b.sway += b.speed;
        const sw = Math.sin(b.sway) * 5;
        ctx.beginPath();
        ctx.moveTo(b.x, baseY);
        ctx.quadraticCurveTo(b.x + sw, baseY - b.h * 0.6, b.x + sw * 1.5, baseY - b.h);
        const c = Math.floor(b.shade * 100);
        ctx.strokeStyle = color;
        ctx.globalAlpha = b.shade * 0.6;
        ctx.lineWidth = widthMul;
        ctx.stroke();
    }
    ctx.globalAlpha = 1;
}

function drawGround() {
    const groundY = H - 90;
    // Middle-ground grass
    drawGrassLayer(grassMG, groundY + 10, '#1a3525', 2.5);
    // Ground fill
    const gGrad = ctx.createLinearGradient(0, groundY, 0, H);
    gGrad.addColorStop(0, '#152520');
    gGrad.addColorStop(1, '#0a1510');
    ctx.fillStyle = gGrad;
    ctx.fillRect(0, groundY, W, H - groundY);
    // Foreground grass on top
    drawGrassLayer(grassFG, groundY - 5, '#1e4030', 1.8);

    // Tiny flowers near right edge (habitat hint)
    const flZ = HABITATS.flowers;
    for (let i = 0; i < 12; i++) {
        const fx = (flZ.xMin + Math.random() * (flZ.xMax - flZ.xMin)) * W;
        const fy = groundY - 3 - Math.random() * 15;
        ctx.beginPath();
        ctx.arc(fx, fy, 1.5, 0, TAU);
        ctx.fillStyle = 'rgba(200,120,160,0.25)';
        ctx.fill();
    }
    // Water shimmer near left edge
    const wZ = HABITATS.water;
    for (let i = 0; i < 8; i++) {
        const wx = (wZ.xMin + Math.random() * (wZ.xMax - wZ.xMin)) * W;
        const wy = groundY + 5 + Math.random() * 10;
        ctx.beginPath();
        ctx.arc(wx, wy, 1 + Math.random(), 0, TAU);
        ctx.fillStyle = 'rgba(80,140,200,0.15)';
        ctx.fill();
    }
}

// ---- Drawing: net cursor ----
function drawNet() {
    // Net ring
    ctx.beginPath();
    ctx.arc(mouseX, mouseY, NET_RADIUS, 0, TAU);
    ctx.strokeStyle = 'rgba(200,220,255,0.25)';
    ctx.lineWidth = 1.5;
    ctx.setLineDash([4, 4]);
    ctx.stroke();
    ctx.setLineDash([]);

    // Net mesh lines
    ctx.globalAlpha = 0.1;
    for (let a = 0; a < TAU; a += TAU / 6) {
        ctx.beginPath();
        ctx.moveTo(mouseX, mouseY);
        ctx.lineTo(mouseX + Math.cos(a) * NET_RADIUS, mouseY + Math.sin(a) * NET_RADIUS);
        ctx.strokeStyle = 'rgba(200,220,255,0.5)';
        ctx.lineWidth = 0.5;
        ctx.stroke();
    }
    ctx.globalAlpha = 1;

    // Handle
    ctx.beginPath();
    ctx.moveTo(mouseX, mouseY + NET_RADIUS);
    ctx.lineTo(mouseX + 4, mouseY + NET_RADIUS + 38);
    ctx.strokeStyle = 'rgba(139,90,43,0.7)';
    ctx.lineWidth = 3.5;
    ctx.lineCap = 'round';
    ctx.stroke();
    ctx.lineCap = 'butt';
}

// ---- Drawing: jar (canvas-rendered) ----
function drawJar() {
    const jx = W - 60, jy = H - 80, jw = 50, jh = 75;
    // Jar body
    ctx.beginPath();
    ctx.moveTo(jx - jw / 2 + 5, jy - jh / 2);
    ctx.quadraticCurveTo(jx - jw / 2, jy, jx - jw / 2 + 8, jy + jh / 2);
    ctx.lineTo(jx + jw / 2 - 8, jy + jh / 2);
    ctx.quadraticCurveTo(jx + jw / 2, jy, jx + jw / 2 - 5, jy - jh / 2);
    ctx.closePath();
    ctx.fillStyle = 'rgba(180,210,240,0.06)';
    ctx.fill();
    ctx.strokeStyle = 'rgba(180,210,240,0.2)';
    ctx.lineWidth = 1.5;
    ctx.stroke();

    // Lid
    ctx.fillStyle = '#3a3020';
    ctx.fillRect(jx - jw / 2 + 3, jy - jh / 2 - 8, jw - 6, 10);
    ctx.strokeStyle = 'rgba(100,80,50,0.5)';
    ctx.strokeRect(jx - jw / 2 + 3, jy - jh / 2 - 8, jw - 6, 10);

    // Glowing particles inside jar
    for (const p of jarParticles) {
        p.phase += 0.025;
        const glow = (Math.sin(p.phase) + 1) / 2;
        const px = jx - jw / 2 + 8 + p.x * (jw - 16);
        const py = jy - jh / 2 + 5 + p.y * (jh - 10);
        // Glow
        ctx.beginPath();
        ctx.arc(px, py, 6 + glow * 4, 0, TAU);
        ctx.fillStyle = 'hsla(' + p.hue + ',' + p.sat + '%,' + p.light + '%,' + (glow * 0.2) + ')';
        ctx.fill();
        // Core
        ctx.beginPath();
        ctx.arc(px, py, 1.5, 0, TAU);
        ctx.fillStyle = 'hsla(' + p.hue + ',' + p.sat + '%,' + (p.light + 15) + '%,' + (0.4 + glow * 0.5) + ')';
        ctx.fill();
    }

    // Overall jar glow when many caught
    if (jarParticles.length > 3) {
        const intensity = Math.min(jarParticles.length / 30, 1);
        const jGrad = ctx.createRadialGradient(jx, jy, 0, jx, jy, jh);
        jGrad.addColorStop(0, 'rgba(200,230,150,' + (intensity * 0.1) + ')');
        jGrad.addColorStop(1, 'rgba(200,230,150,0)');
        ctx.fillStyle = jGrad;
        ctx.beginPath();
        ctx.arc(jx, jy, jh, 0, TAU);
        ctx.fill();
    }

    // Count label
    ctx.font = '12px Georgia';
    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(200,230,150,0.7)';
    ctx.fillText(gameState.totalCaught + ' caught', jx, jy + jh / 2 + 18);
}

// ---- Drawing: ripple effects ----
function updateRipples(dt) {
    for (let i = ripples.length - 1; i >= 0; i--) {
        const rp = ripples[i];
        rp.r += dt * 0.08;
        rp.a -= dt * 0.002;
        if (rp.a <= 0 || rp.r > rp.maxR) {
            ripples.splice(i, 1);
            continue;
        }
        ctx.beginPath();
        ctx.arc(rp.x, rp.y, rp.r, 0, TAU);
        ctx.strokeStyle = 'hsla(' + rp.hue + ',80%,70%,' + rp.a + ')';
        ctx.lineWidth = 1.5;
        ctx.stroke();
    }
}

// ---- Firefly spawning ----
function spawnFirefly() {
    if (fireflies.length >= MAX_FIREFLIES) return;
    fireflies.push(new Firefly());
}

function managePopulation() {
    const alive = fireflies.filter(f => !f.caught).length;
    const phase = getCyclePhase();
    // More fireflies at dusk, fewer at midnight
    let targetPop = 25;
    if (phase < 0.25) targetPop = 35;
    else if (phase < 0.55) targetPop = 20;
    else if (phase < 0.8) targetPop = 22;
    else targetPop = 30;

    if (alive < targetPop && Math.random() < 0.03) spawnFirefly();
    // Remove old caught fireflies to free memory
    if (fireflies.length > MAX_FIREFLIES + 20) {
        fireflies = fireflies.filter(f => !f.caught);
    }
}

// ---- HUD updates ----
function updateHUD() {
    const uniqueFound = Object.keys(gameState.speciesCaught).length;
    document.getElementById('hud-caught').textContent = 'ðŸ«™ ' + gameState.totalCaught;
    document.getElementById('hud-species').textContent = 'ðŸ“– ' + uniqueFound + ' / ' + SPECIES.length;
}

function updateCycleIndicator() {
    const phase = getCyclePhase();
    const name = getCycleName(phase);
    const el = document.getElementById('cycle-indicator');
    const icons = { Dusk: 'ðŸŒ…', Midnight: 'ðŸŒ™', 'Late Night': 'âœ¨', Dawn: 'ðŸŒ„' };
    el.textContent = (icons[name] || '') + ' ' + name;
}

// ---- Journal panel ----
function renderJournal() {
    const list = document.getElementById('journal-list');
    list.innerHTML = '';
    for (const sp of SPECIES) {
        const found = gameState.speciesCaught[sp.id] || 0;
        const discovered = found > 0;
        const card = document.createElement('div');
        card.className = 'species-card' + (discovered ? '' : ' undiscovered');
        const swatch = document.createElement('div');
        swatch.className = 'species-swatch';
        if (discovered) {
            swatch.style.background = 'hsl(' + sp.hue + ',' + sp.sat + '%,' + sp.light + '%)';
            swatch.style.setProperty('--glow', 'hsla(' + sp.hue + ',' + sp.sat + '%,' + sp.light + '%,0.5)');
        }
        const info = document.createElement('div');
        info.className = 'species-info';
        const nameEl = document.createElement('div');
        nameEl.className = 'species-name';
        nameEl.textContent = discovered ? sp.name : '???';
        const desc = document.createElement('div');
        desc.className = 'species-detail';
        desc.textContent = discovered ? sp.desc : 'Not yet discovered';
        info.appendChild(nameEl);
        info.appendChild(desc);
        const countEl = document.createElement('div');
        countEl.className = 'species-count';
        countEl.textContent = discovered ? ('Ã—' + found) : '';
        card.appendChild(swatch);
        card.appendChild(info);
        card.appendChild(countEl);
        list.appendChild(card);
    }
}

// ---- Stats panel ----
function renderStats() {
    const body = document.getElementById('stats-body');
    const unique = Object.keys(gameState.speciesCaught).length;
    const sessionMs = Date.now() - gameState.sessionStart;
    const sessionMin = Math.floor(sessionMs / 60000);
    const sessionSec = Math.floor((sessionMs % 60000) / 1000);
    const longestMin = Math.floor(gameState.longestSession / 60000);
    const rows = [
        ['Total Caught', gameState.totalCaught],
        ['Species Found', unique + ' / ' + SPECIES.length],
        ['Best Night', gameState.bestNight],
        ['This Session', sessionMin + 'm ' + sessionSec + 's'],
        ['Longest Session', longestMin + 'm'],
        ['Night Caught', gameState.nightCaught],
    ];
    body.innerHTML = '';
    for (const [label, val] of rows) {
        const row = document.createElement('div');
        row.className = 'stat-row';
        row.innerHTML = '<span class="stat-label">' + label + '</span><span class="stat-val">' + val + '</span>';
        body.appendChild(row);
    }
}

// ---- Input ----
function handlePointer(x, y) {
    if (!audioStarted) initAudio();
    prevMouseX = mouseX;
    prevMouseY = mouseY;
    mouseX = x;
    mouseY = y;
}

canvas.addEventListener('mousemove', e => handlePointer(e.clientX, e.clientY));
canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    handlePointer(e.touches[0].clientX, e.touches[0].clientY);
}, { passive: false });
canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    handlePointer(e.touches[0].clientX, e.touches[0].clientY);
}, { passive: false });
// Tap to init audio on mobile
canvas.addEventListener('click', () => { if (!audioStarted) initAudio(); });

document.addEventListener('keydown', e => {
    const key = e.key.toLowerCase();
    if (key === 'j') {
        journalOpen = !journalOpen;
        document.getElementById('journal').classList.toggle('open', journalOpen);
        if (journalOpen) renderJournal();
        if (statsOpen) { statsOpen = false; document.getElementById('stats').style.display = 'none'; }
    } else if (key === 's') {
        statsOpen = !statsOpen;
        document.getElementById('stats').style.display = statsOpen ? 'block' : 'none';
        if (statsOpen) renderStats();
        if (journalOpen) { journalOpen = false; document.getElementById('journal').classList.remove('open'); }
    } else if (key === 'm') {
        muted = !muted;
        if (masterGain) masterGain.gain.value = muted ? 0 : 0.3;
    }
});

// ---- Night cycle reset ----
let lastCyclePhase = 0;
function checkCycleReset() {
    const phase = getCyclePhase();
    // Detect wrap-around (dawn â†’ dusk transition)
    if (phase < 0.05 && lastCyclePhase > 0.9) {
        gameState.nightCaught = 0;
    }
    lastCyclePhase = phase;
}

// ---- Session tracking ----
function updateSessionTime() {
    const elapsed = Date.now() - gameState.sessionStart;
    if (elapsed > gameState.longestSession) {
        gameState.longestSession = elapsed;
        saveData();
    }
}

// ---- Whoosh throttle ----
let lastWhoosh = 0;

// ---- Main loop ----
function animate(now) {
    const dt = Math.min(now - lastFrame, 50);
    lastFrame = now;

    mouseSpeed = Math.hypot(mouseX - prevMouseX, mouseY - prevMouseY);

    // Whoosh sound (throttled)
    if (mouseSpeed > 8 && now - lastWhoosh > 200) {
        playWhoosh();
        lastWhoosh = now;
    }

    const phase = getCyclePhase();

    // Draw scene
    drawSky(phase);
    drawStars(phase);
    drawConstellations(phase);
    drawMoon(phase);
    drawTrees();
    drawHabitatHints();

    // Update and draw fireflies
    for (const f of fireflies) {
        f.update(dt);
        f.draw();
    }

    drawGround();
    updateRipples(dt);
    drawNet();
    drawJar();

    // Population management
    managePopulation();
    checkCycleReset();

    // Periodic updates
    if (Math.floor(now / 2000) !== Math.floor((now - dt) / 2000)) {
        updateCycleIndicator();
        updateSessionTime();
    }

    prevMouseX = mouseX;
    prevMouseY = mouseY;

    requestAnimationFrame(animate);
}

// ---- Init ----
initLayers();
for (let i = 0; i < 25; i++) spawnFirefly();
updateHUD();
updateCycleIndicator();
lastFrame = performance.now();
requestAnimationFrame(animate);
</script>
</body>
</html>
