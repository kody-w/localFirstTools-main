<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Littoral Lexicon</title>
    <meta name="description" content="Words become coastal cliffs gradually eroded by waves, revealing linguistic fossils in sedimentary layers">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a1520; min-height: 100vh; font-family: 'Georgia', serif; color: #8090a0; overflow: hidden; }
        #canvas { position: fixed; top: 0; left: 0; }
        #controls {
            position: fixed; top: 20px; left: 20px; background: rgba(15,25,35,0.95);
            padding: 20px; border-radius: 10px; border: 1px solid rgba(100,130,160,0.3);
            z-index: 100;
        }
        h3 { margin-bottom: 15px; color: #a0c0d0; font-weight: normal; }
        .control-row { margin: 10px 0; }
        label { display: block; font-size: 11px; margin-bottom: 5px; opacity: 0.8; }
        input[type="range"] { width: 140px; }
        input[type="text"] { width: 140px; padding: 5px; background: rgba(0,0,0,0.3); border: 1px solid rgba(100,130,160,0.3); color: #a0c0d0; border-radius: 4px; }
        .value { float: right; color: #b0d0e0; font-size: 12px; }
        button {
            display: block; width: 100%; padding: 10px; margin: 6px 0;
            background: rgba(50,80,100,0.4); border: 1px solid rgba(100,130,160,0.4);
            color: #90b0c0; cursor: pointer; border-radius: 6px; font-family: inherit;
        }
        #info { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); font-size: 12px; opacity: 0.5; z-index: 100; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="controls">
        <h3>Littoral Lexicon</h3>
        <div class="control-row">
            <input type="text" id="word-input" placeholder="Type a word..." value="ETERNITY">
        </div>
        <div class="control-row">
            <label>Wave Intensity <span class="value" id="wave-val">50</span></label>
            <input type="range" id="wave" min="10" max="100" value="50">
        </div>
        <div class="control-row">
            <label>Erosion Speed <span class="value" id="erosion-val">30</span></label>
            <input type="range" id="erosion" min="5" max="100" value="30">
        </div>
        <button id="carve-btn">Carve Word</button>
        <button id="storm-btn">Storm Surge</button>
    </div>
    <div id="info">Type words to become cliffs | Watch them erode over geological time</div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let W, H, waterLevel;
        function resize() { 
            W = canvas.width = innerWidth; 
            H = canvas.height = innerHeight;
            waterLevel = H * 0.7;
        }
        resize(); window.onresize = resize;
        
        let waveIntensity = 0.5;
        let erosionSpeed = 0.3;
        let time = 0;
        
        const cliffs = [];
        const debris = [];
        const foam = [];
        
        class Cliff {
            constructor(word, x) {
                this.word = word;
                this.x = x;
                this.baseY = waterLevel;
                this.erosion = [];
                this.layers = [];
                this.debris = [];
                
                this.generateLayers();
                this.generateErosionPoints();
            }
            
            generateLayers() {
                const colors = [
                    { h: 35, s: 30, l: 25 },
                    { h: 30, s: 35, l: 30 },
                    { h: 25, s: 40, l: 35 },
                    { h: 40, s: 25, l: 40 },
                    { h: 35, s: 30, l: 45 }
                ];
                
                for (let i = 0; i < 5; i++) {
                    this.layers.push({
                        y: this.baseY - 120 + i * 30,
                        height: 30,
                        color: colors[i]
                    });
                }
            }
            
            generateErosionPoints() {
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = 400;
                tempCanvas.height = 200;
                
                tempCtx.fillStyle = 'white';
                tempCtx.font = 'bold 80px Georgia';
                tempCtx.textAlign = 'center';
                tempCtx.textBaseline = 'middle';
                tempCtx.fillText(this.word, 200, 100);
                
                const imageData = tempCtx.getImageData(0, 0, 400, 200);
                const data = imageData.data;
                
                for (let y = 0; y < 200; y += 3) {
                    for (let x = 0; x < 400; x += 3) {
                        const i = (y * 400 + x) * 4;
                        if (data[i] > 128) {
                            this.erosion.push({
                                x: this.x - 200 + x,
                                y: this.baseY - 150 + y,
                                originalX: this.x - 200 + x,
                                originalY: this.baseY - 150 + y,
                                health: 1,
                                layer: Math.floor(y / 40)
                            });
                        }
                    }
                }
            }
            
            update() {
                const waveHeight = Math.sin(time * 2) * 20 * waveIntensity;
                const currentWaterY = waterLevel + waveHeight;
                
                this.erosion.forEach(point => {
                    if (point.health <= 0) return;
                    
                    const distToWater = Math.abs(point.y - currentWaterY);
                    
                    if (distToWater < 40 && point.y > currentWaterY - 20) {
                        const erosionChance = erosionSpeed * 0.0005 * waveIntensity;
                        if (Math.random() < erosionChance) {
                            point.health -= 0.1;
                            
                            if (point.health <= 0) {
                                debris.push({
                                    x: point.x,
                                    y: point.y,
                                    vx: (Math.random() - 0.5) * 2,
                                    vy: Math.random() * 2,
                                    size: 2 + Math.random() * 3,
                                    life: 1,
                                    layer: point.layer
                                });
                            }
                        }
                    }
                });
            }
            
            draw() {
                this.layers.forEach((layer, i) => {
                    ctx.fillStyle = "hsl(" + layer.color.h + ", " + layer.color.s + "%, " + layer.color.l + "%)";
                    
                    const visiblePoints = this.erosion.filter(p => 
                        p.layer === i && p.health > 0
                    );
                    
                    visiblePoints.forEach(point => {
                        ctx.globalAlpha = point.health;
                        ctx.fillRect(point.x - 1, point.y - 1, 4, 4);
                    });
                });
                
                ctx.globalAlpha = 1;
                
                ctx.strokeStyle = 'rgba(80, 60, 40, 0.3)';
                ctx.lineWidth = 1;
                this.layers.forEach(layer => {
                    ctx.beginPath();
                    ctx.moveTo(this.x - 220, layer.y);
                    ctx.lineTo(this.x + 220, layer.y);
                    ctx.stroke();
                });
            }
        }
        
        function drawOcean() {
            const gradient = ctx.createLinearGradient(0, waterLevel - 50, 0, H);
            gradient.addColorStop(0, '#1a3040');
            gradient.addColorStop(0.3, '#0a2030');
            gradient.addColorStop(1, '#051520');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, waterLevel - 50, W, H - waterLevel + 50);
            
            for (let x = 0; x < W; x += 5) {
                const waveY = waterLevel + Math.sin(time * 2 + x * 0.02) * 20 * waveIntensity;
                const waveY2 = waterLevel + Math.sin(time * 1.5 + x * 0.03 + 1) * 15 * waveIntensity;
                
                ctx.beginPath();
                ctx.moveTo(x, waveY);
                ctx.lineTo(x + 5, waveY + Math.sin(time * 2 + (x + 5) * 0.02) * 20 * waveIntensity);
                ctx.lineTo(x + 5, H);
                ctx.lineTo(x, H);
                ctx.closePath();
                ctx.fillStyle = 'rgba(20, 60, 90, 0.3)';
                ctx.fill();
            }
            
            for (let i = foam.length - 1; i >= 0; i--) {
                const f = foam[i];
                f.x += f.vx;
                f.y += f.vy;
                f.life -= 0.02;
                
                if (f.life <= 0) {
                    foam.splice(i, 1);
                    continue;
                }
                
                ctx.beginPath();
                ctx.arc(f.x, f.y, f.size * f.life, 0, Math.PI * 2);
                ctx.fillStyle = "rgba(200, 220, 240, " + (f.life * 0.5) + ")";
                ctx.fill();
            }
            
            if (Math.random() < waveIntensity * 0.3) {
                foam.push({
                    x: Math.random() * W,
                    y: waterLevel + Math.sin(time * 2) * 20 * waveIntensity,
                    vx: (Math.random() - 0.5) * 2,
                    vy: -Math.random() * 2,
                    size: 2 + Math.random() * 4,
                    life: 1
                });
            }
        }
        
        function drawDebris() {
            const layerColors = [
                { h: 35, s: 30, l: 25 },
                { h: 30, s: 35, l: 30 },
                { h: 25, s: 40, l: 35 },
                { h: 40, s: 25, l: 40 },
                { h: 35, s: 30, l: 45 }
            ];
            
            for (let i = debris.length - 1; i >= 0; i--) {
                const d = debris[i];
                d.x += d.vx;
                d.y += d.vy;
                d.vy += 0.1;
                d.life -= 0.005;
                
                if (d.y > H || d.life <= 0) {
                    debris.splice(i, 1);
                    continue;
                }
                
                if (d.y > waterLevel) {
                    d.vy *= 0.9;
                    d.vx *= 0.95;
                }
                
                const color = layerColors[d.layer] || layerColors[0];
                ctx.beginPath();
                ctx.arc(d.x, d.y, d.size, 0, Math.PI * 2);
                ctx.fillStyle = "hsla(" + color.h + ", " + color.s + "%, " + color.l + "%, " + d.life + ")";
                ctx.fill();
            }
        }
        
        function drawBackground() {
            const gradient = ctx.createLinearGradient(0, 0, 0, waterLevel);
            gradient.addColorStop(0, '#0a1520');
            gradient.addColorStop(1, '#152535');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, W, waterLevel);
        }
        
        function animate() {
            time += 0.016;
            
            drawBackground();
            
            cliffs.forEach(cliff => {
                cliff.update();
                cliff.draw();
            });
            
            drawOcean();
            drawDebris();
            
            requestAnimationFrame(animate);
        }
        
        function carveWord() {
            const word = document.getElementById('word-input').value.toUpperCase() || 'ETERNITY';
            cliffs.length = 0;
            debris.length = 0;
            cliffs.push(new Cliff(word, W / 2));
        }
        
        document.getElementById('wave').oninput = e => {
            waveIntensity = e.target.value / 100;
            document.getElementById('wave-val').textContent = e.target.value;
        };
        
        document.getElementById('erosion').oninput = e => {
            erosionSpeed = e.target.value / 100;
            document.getElementById('erosion-val').textContent = e.target.value;
        };
        
        document.getElementById('carve-btn').onclick = carveWord;
        
        document.getElementById('storm-btn').onclick = () => {
            waveIntensity = 1;
            document.getElementById('wave').value = 100;
            document.getElementById('wave-val').textContent = '100';
            
            for (let i = 0; i < 50; i++) {
                foam.push({
                    x: Math.random() * W,
                    y: waterLevel + (Math.random() - 0.5) * 40,
                    vx: (Math.random() - 0.5) * 5,
                    vy: -Math.random() * 5,
                    size: 3 + Math.random() * 6,
                    life: 1
                });
            }
        };
        
        document.getElementById('word-input').onkeypress = e => {
            if (e.key === 'Enter') carveWord();
        };
        
        carveWord();
        animate();
    </script>
</body>
</html>