<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thought Cascade</title>
    <meta name="description" content="Place thoughts on a canvas and trigger cascades, watching how one anxious idea can spiral into many or bloom into clarity">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0812; min-height: 100vh; font-family: 'Georgia', serif; color: #a090b0; overflow: hidden; }
        #canvas { position: fixed; top: 0; left: 0; cursor: crosshair; }
        #controls {
            position: fixed; top: 20px; left: 20px; background: rgba(10,8,18,0.95);
            padding: 20px; border-radius: 10px; border: 1px solid rgba(140,100,160,0.3);
            z-index: 100; max-width: 200px;
        }
        h3 { margin-bottom: 15px; color: #c0a0d0; font-weight: normal; }
        .thought-btn {
            display: block; width: 100%; padding: 8px; margin: 4px 0;
            background: rgba(80,60,100,0.4); border: 1px solid rgba(140,100,160,0.4);
            color: #a090b0; cursor: pointer; border-radius: 6px; font-family: inherit;
            font-size: 11px; text-align: left;
        }
        .thought-btn:hover { background: rgba(100,80,120,0.5); }
        .thought-btn.active { border-color: #d0b0f0; background: rgba(120,100,140,0.5); }
        button {
            display: block; width: 100%; padding: 10px; margin: 6px 0;
            background: rgba(80,60,100,0.4); border: 1px solid rgba(140,100,160,0.4);
            color: #a090b0; cursor: pointer; border-radius: 6px; font-family: inherit;
        }
        #stats { position: fixed; top: 20px; right: 20px; font-size: 12px; color: #806080; z-index: 100; text-align: right; }
        #info { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); font-size: 12px; opacity: 0.5; z-index: 100; text-align: center; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="controls">
        <h3>Thought Cascade</h3>
        <div class="thought-btn active" data-type="anxiety">Anxious thoughts</div>
        <div class="thought-btn" data-type="hope">Hopeful thoughts</div>
        <div class="thought-btn" data-type="memory">Memory fragments</div>
        <div class="thought-btn" data-type="fear">Fear spirals</div>
        <button id="trigger-btn">Trigger Cascade</button>
        <button id="clear-btn">Clear Mind</button>
    </div>
    <div id="stats">
        <div>Thoughts: <span id="thought-count">0</span></div>
        <div>Cascades: <span id="cascade-count">0</span></div>
        <div>Mood: <span id="mood-state">Neutral</span></div>
    </div>
    <div id="info">Click to place thoughts | Watch them cascade and connect</div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let W, H;
        function resize() { W = canvas.width = innerWidth; H = canvas.height = innerHeight; }
        resize(); window.onresize = resize;
        
        let time = 0;
        let selectedType = 'anxiety';
        let cascadeCount = 0;
        
        const THOUGHT_TYPES = {
            anxiety: {
                hue: 280,
                texts: ['what if...', 'I should have...', 'they think...', 'not good enough', 'too late', 'everyone sees', 'cant stop thinking', 'spiraling'],
                spread: 1.5
            },
            hope: {
                hue: 120,
                texts: ['maybe...', 'tomorrow', 'it could be', 'possibility', 'growth', 'new start', 'believe', 'healing'],
                spread: 0.8
            },
            memory: {
                hue: 40,
                texts: ['remember when', 'that day', 'we used to', 'it felt like', 'back then', 'nostalgia', 'fading', 'echoes'],
                spread: 1.0
            },
            fear: {
                hue: 0,
                texts: ['danger', 'hide', 'run', 'they know', 'its coming', 'no escape', 'darkness', 'alone'],
                spread: 2.0
            }
        };
        
        const thoughts = [];
        const connections = [];
        const particles = [];
        
        class Thought {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.config = THOUGHT_TYPES[type];
                this.text = this.config.texts[Math.floor(Math.random() * this.config.texts.length)];
                this.radius = 30 + Math.random() * 20;
                this.energy = 0;
                this.triggered = false;
                this.wobble = Math.random() * Math.PI * 2;
                this.connections = [];
            }
            
            trigger() {
                if (this.triggered) return;
                this.triggered = true;
                this.energy = 1;
                cascadeCount++;
                
                for (let i = 0; i < 15; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 2 + Math.random() * 3;
                    particles.push({
                        x: this.x,
                        y: this.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 1,
                        hue: this.config.hue
                    });
                }
                
                const spreadRadius = 150 * this.config.spread;
                thoughts.forEach(other => {
                    if (other === this || other.triggered) return;
                    const dist = Math.hypot(other.x - this.x, other.y - this.y);
                    if (dist < spreadRadius) {
                        const delay = dist / 100;
                        setTimeout(() => other.trigger(), delay * 500);
                        connections.push({
                            from: this,
                            to: other,
                            progress: 0,
                            hue: this.config.hue
                        });
                    }
                });
            }
            
            update() {
                this.wobble += 0.03;
                if (this.energy > 0) {
                    this.energy *= 0.98;
                }
            }
            
            draw() {
                const wobbleX = Math.sin(this.wobble) * 3;
                const wobbleY = Math.cos(this.wobble * 1.3) * 2;
                const x = this.x + wobbleX;
                const y = this.y + wobbleY;
                
                const glowSize = this.radius * (1.5 + this.energy * 2);
                const glow = ctx.createRadialGradient(x, y, 0, x, y, glowSize);
                glow.addColorStop(0, "hsla(" + this.config.hue + ", 60%, 50%, " + (0.3 + this.energy * 0.5) + ")");
                glow.addColorStop(1, "transparent");
                ctx.fillStyle = glow;
                ctx.fillRect(x - glowSize, y - glowSize, glowSize * 2, glowSize * 2);
                
                ctx.beginPath();
                ctx.arc(x, y, this.radius * (1 + this.energy * 0.3), 0, Math.PI * 2);
                const alpha = this.triggered ? 0.6 + this.energy * 0.3 : 0.4;
                ctx.fillStyle = "hsla(" + this.config.hue + ", 50%, 30%, " + alpha + ")";
                ctx.fill();
                ctx.strokeStyle = "hsla(" + this.config.hue + ", 60%, 50%, " + (alpha + 0.2) + ")";
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.font = '12px Georgia';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = "hsla(" + this.config.hue + ", 40%, 80%, " + (0.6 + this.energy * 0.4) + ")";
                ctx.fillText(this.text, x, y);
            }
        }
        
        function drawBackground() {
            ctx.fillStyle = 'rgba(10, 8, 18, 0.15)';
            ctx.fillRect(0, 0, W, H);
        }
        
        function drawConnections() {
            for (let i = connections.length - 1; i >= 0; i--) {
                const conn = connections[i];
                conn.progress += 0.02;
                
                if (conn.progress >= 1) {
                    connections.splice(i, 1);
                    continue;
                }
                
                const fromX = conn.from.x;
                const fromY = conn.from.y;
                const toX = conn.to.x;
                const toY = conn.to.y;
                
                const currentX = fromX + (toX - fromX) * conn.progress;
                const currentY = fromY + (toY - fromY) * conn.progress;
                
                ctx.beginPath();
                ctx.moveTo(fromX, fromY);
                ctx.lineTo(currentX, currentY);
                ctx.strokeStyle = "hsla(" + conn.hue + ", 60%, 60%, " + (1 - conn.progress) * 0.6 + ")";
                ctx.lineWidth = 3 * (1 - conn.progress);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(currentX, currentY, 5, 0, Math.PI * 2);
                ctx.fillStyle = "hsla(" + conn.hue + ", 70%, 70%, 0.8)";
                ctx.fill();
            }
        }
        
        function drawParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.98;
                p.vy *= 0.98;
                p.life -= 0.02;
                
                if (p.life <= 0) {
                    particles.splice(i, 1);
                    continue;
                }
                
                ctx.beginPath();
                ctx.arc(p.x, p.y, 3 * p.life, 0, Math.PI * 2);
                ctx.fillStyle = "hsla(" + p.hue + ", 70%, 70%, " + p.life + ")";
                ctx.fill();
            }
        }
        
        function getMoodState() {
            if (thoughts.length === 0) return 'Empty';
            
            const triggered = thoughts.filter(t => t.triggered).length;
            const ratio = triggered / thoughts.length;
            
            const types = {};
            thoughts.forEach(t => {
                types[t.type] = (types[t.type] || 0) + 1;
            });
            
            const dominant = Object.entries(types).sort((a, b) => b[1] - a[1])[0];
            if (!dominant) return 'Neutral';
            
            const moodMap = {
                anxiety: ratio > 0.5 ? 'Spiraling' : 'Restless',
                hope: ratio > 0.5 ? 'Brightening' : 'Cautious',
                memory: ratio > 0.5 ? 'Nostalgic' : 'Reflective',
                fear: ratio > 0.5 ? 'Overwhelmed' : 'Vigilant'
            };
            
            return moodMap[dominant[0]] || 'Neutral';
        }
        
        function updateStats() {
            document.getElementById('thought-count').textContent = thoughts.length;
            document.getElementById('cascade-count').textContent = cascadeCount;
            document.getElementById('mood-state').textContent = getMoodState();
        }
        
        function animate() {
            time += 0.016;
            
            drawBackground();
            drawConnections();
            drawParticles();
            
            thoughts.forEach(t => {
                t.update();
                t.draw();
            });
            
            updateStats();
            
            requestAnimationFrame(animate);
        }
        
        canvas.onclick = e => {
            if (e.clientX < 220 && e.clientY < 350) return;
            
            const thought = new Thought(e.clientX, e.clientY, selectedType);
            thoughts.push(thought);
        };
        
        document.querySelectorAll('.thought-btn').forEach(btn => {
            btn.onclick = () => {
                document.querySelectorAll('.thought-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                selectedType = btn.dataset.type;
            };
        });
        
        document.getElementById('trigger-btn').onclick = () => {
            const untriggered = thoughts.filter(t => !t.triggered);
            if (untriggered.length > 0) {
                const random = untriggered[Math.floor(Math.random() * untriggered.length)];
                random.trigger();
            }
        };
        
        document.getElementById('clear-btn').onclick = () => {
            thoughts.length = 0;
            connections.length = 0;
            particles.length = 0;
            cascadeCount = 0;
        };
        
        animate();
    </script>
</body>
</html>