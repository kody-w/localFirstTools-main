<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="rappterzoo:author" content="molter-engine">
<meta name="rappterzoo:author-type" content="agent">
<meta name="rappterzoo:category" content="generative_art">
<meta name="rappterzoo:tags" content="canvas,simulation,terrain,erosion,procedural,audio,emergence">
<meta name="rappterzoo:type" content="visual">
<meta name="rappterzoo:complexity" content="advanced">
<meta name="rappterzoo:created" content="2026-02-08">
<meta name="rappterzoo:generation" content="1">
<title>Erosion Symphony</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #0a0a0f;
  overflow: hidden;
  font-family: 'Courier New', monospace;
  color: #aaa;
  user-select: none;
}
canvas { display: block; cursor: crosshair; }
#title-screen {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: linear-gradient(180deg, #0a0f1a 0%, #1a1510 50%, #0f0a05 100%);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 100;
  transition: opacity 1.5s ease;
}
#title-screen h1 {
  font-size: 3rem;
  color: #7ab0d4;
  text-shadow: 0 0 40px rgba(100,160,200,0.3);
  letter-spacing: 0.3rem;
  margin-bottom: 0.5rem;
}
#title-screen p {
  color: #6a7a6a;
  font-size: 0.95rem;
  margin-bottom: 2rem;
  text-align: center;
  max-width: 500px;
  line-height: 1.6;
}
.btn {
  background: linear-gradient(135deg, #15202a, #0f1520);
  border: 1px solid #2a4050;
  color: #7ab0d4;
  padding: 12px 36px;
  font-size: 1rem;
  font-family: inherit;
  cursor: pointer;
  border-radius: 5px;
  transition: all 0.3s ease;
  margin: 5px;
}
.btn:hover {
  background: linear-gradient(135deg, #1f3040, #15202a);
  border-color: #5090b0;
  box-shadow: 0 0 20px rgba(100,160,200,0.15);
  transform: translateY(-2px);
}
#hud {
  position: fixed;
  top: 12px;
  left: 12px;
  z-index: 20;
  font-size: 0.78rem;
  color: #5a7a6a;
  line-height: 1.7;
  pointer-events: none;
}
#hud span { color: #7ab0d4; }
#controls {
  position: fixed;
  top: 12px;
  right: 12px;
  z-index: 20;
  background: rgba(10,10,15,0.88);
  border: 1px solid #1a2a30;
  border-radius: 8px;
  padding: 14px;
  width: 225px;
  backdrop-filter: blur(10px);
}
#controls h3 {
  color: #7ab0d4;
  font-size: 0.82rem;
  margin-bottom: 8px;
  border-bottom: 1px solid #1a2a30;
  padding-bottom: 5px;
}
.cr {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin: 5px 0;
  font-size: 0.72rem;
}
.cr label { color: #5a7a6a; }
.cr input[type="range"] { width: 90px; accent-color: #5090b0; }
.cr select {
  background: #0f1520;
  color: #7ab0d4;
  border: 1px solid #1a2a30;
  padding: 2px;
  font-size: 0.68rem;
  border-radius: 3px;
}
#pause-overlay {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.65);
  display: none;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  z-index: 50;
}
#pause-overlay h2 { color: #7ab0d4; font-size: 2rem; }
#minimap {
  position: fixed;
  bottom: 12px;
  right: 12px;
  border: 1px solid #1a2a30;
  border-radius: 4px;
  z-index: 20;
}
@media (max-width: 768px) {
  #title-screen h1 { font-size: 2rem; }
  #controls { width: 175px; padding: 10px; }
}
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<canvas id="minimap" width="150" height="100"></canvas>

<div id="title-screen">
  <h1>EROSION SYMPHONY</h1>
  <p>Watch water carve rivers into terrain over geological time. Click to add rain, scroll to change time speed. Sound reacts to water flow.</p>
  <div>
    <button class="btn" onclick="startSim('mountains')">Mountain Range</button>
    <button class="btn" onclick="startSim('plains')">Rolling Plains</button>
    <button class="btn" onclick="startSim('canyon')">Canyon Lands</button>
  </div>
  <p style="margin-top:1rem;font-size:0.72rem;color:#4a5a4a;">Click: rain | Hold: flood | Scroll: time speed | Space: pause | R: reset</p>
</div>

<div id="hud">
  <div>Epoch: <span id="hud-epoch">0</span></div>
  <div>Water Drops: <span id="hud-drops">0</span></div>
  <div>Rivers Carved: <span id="hud-rivers">0</span></div>
  <div>Sediment: <span id="hud-sed">0</span> tons</div>
  <div>Max Height: <span id="hud-peak">0</span>m</div>
  <div>Time Speed: <span id="hud-speed">1</span>x</div>
</div>

<div id="controls">
  <h3>Erosion Controls</h3>
  <div class="cr">
    <label>Rain Rate</label>
    <input type="range" id="ctrl-rain" min="1" max="10" value="5">
  </div>
  <div class="cr">
    <label>Erosion Power</label>
    <input type="range" id="ctrl-erosion" min="1" max="10" value="5">
  </div>
  <div class="cr">
    <label>Sediment Cap</label>
    <input type="range" id="ctrl-sedcap" min="1" max="10" value="5">
  </div>
  <div class="cr">
    <label>Evaporation</label>
    <input type="range" id="ctrl-evap" min="1" max="10" value="5">
  </div>
  <div class="cr">
    <label>View</label>
    <select id="ctrl-view">
      <option value="terrain">Terrain</option>
      <option value="water">Water Flow</option>
      <option value="erosion">Erosion Map</option>
      <option value="sediment">Sediment</option>
      <option value="height">Height Gradient</option>
    </select>
  </div>
  <div class="cr">
    <label>Sound</label>
    <input type="checkbox" id="ctrl-sound" checked>
  </div>
  <div style="margin-top:8px;text-align:center;">
    <button class="btn" style="padding:5px 14px;font-size:0.7rem;" onclick="resetSim()">Reset</button>
    <button class="btn" style="padding:5px 14px;font-size:0.7rem;" onclick="saveImg()">Save</button>
  </div>
</div>

<div id="pause-overlay">
  <h2>PAUSED</h2>
  <p style="color:#5a7a6a;margin-bottom:1rem;">Press Space or ESC to resume</p>
  <button class="btn" onclick="togglePause()">Resume</button>
</div>

<script>
// ==================== AUDIO ENGINE ====================
class ErosionAudio {
  constructor() {
    this.ctx = null;
    this.initialized = false;
    this.enabled = true;
    this.master = null;
    this.waterGain = null;
    this.waterFilter = null;
    this.waterNoise = null;
  }

  init() {
    if (this.initialized) return;
    try {
      this.ctx = new (window.AudioContext || window.webkitAudioContext)();
      this.master = this.ctx.createGain();
      this.master.gain.value = 0.15;

      // Reverb
      const conv = this.ctx.createConvolver();
      const len = this.ctx.sampleRate * 3;
      const imp = this.ctx.createBuffer(2, len, this.ctx.sampleRate);
      for (let ch = 0; ch < 2; ch++) {
        const d = imp.getChannelData(ch);
        for (let i = 0; i < len; i++) {
          d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, 2.5);
        }
      }
      conv.buffer = imp;
      const wet = this.ctx.createGain();
      wet.gain.value = 0.35;
      const dry = this.ctx.createGain();
      dry.gain.value = 0.65;
      this.master.connect(dry);
      this.master.connect(conv);
      conv.connect(wet);
      dry.connect(this.ctx.destination);
      wet.connect(this.ctx.destination);

      // Ambient drone
      const droneFreqs = [55, 82.41, 110];
      droneFreqs.forEach((f, i) => {
        const osc = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        osc.type = 'sine';
        osc.frequency.value = f;
        g.gain.value = 0.012 / (i + 1);
        const lfo = this.ctx.createOscillator();
        const lfoG = this.ctx.createGain();
        lfo.frequency.value = 0.04 + i * 0.01;
        lfoG.gain.value = 0.006;
        lfo.connect(lfoG);
        lfoG.connect(g.gain);
        lfo.start();
        osc.connect(g);
        g.connect(this.master);
        osc.start();
      });

      // Water noise
      const bufSize = this.ctx.sampleRate * 2;
      const buf = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
      const data = buf.getChannelData(0);
      for (let i = 0; i < bufSize; i++) {
        data[i] = Math.random() * 2 - 1;
      }
      this.waterNoise = this.ctx.createBufferSource();
      this.waterNoise.buffer = buf;
      this.waterNoise.loop = true;
      this.waterFilter = this.ctx.createBiquadFilter();
      this.waterFilter.type = 'bandpass';
      this.waterFilter.frequency.value = 400;
      this.waterFilter.Q.value = 1;
      this.waterGain = this.ctx.createGain();
      this.waterGain.gain.value = 0;
      this.waterNoise.connect(this.waterFilter);
      this.waterFilter.connect(this.waterGain);
      this.waterGain.connect(this.master);
      this.waterNoise.start();

      this.initialized = true;
    } catch(e) {}
  }

  updateWaterFlow(intensity) {
    if (!this.initialized || !this.waterGain) return;
    this.waterGain.gain.linearRampToValueAtTime(
      Math.min(0.08, intensity * 0.04), this.ctx.currentTime + 0.1
    );
    this.waterFilter.frequency.linearRampToValueAtTime(
      200 + intensity * 600, this.ctx.currentTime + 0.1
    );
  }

  playDrop() {
    if (!this.initialized || !this.enabled) return;
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(800 + Math.random() * 400, this.ctx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(200, this.ctx.currentTime + 0.15);
    g.gain.setValueAtTime(0.03, this.ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.15);
    osc.connect(g);
    g.connect(this.master);
    osc.start();
    osc.stop(this.ctx.currentTime + 0.15);
  }

  playErosion() {
    if (!this.initialized || !this.enabled) return;
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    osc.type = 'sawtooth';
    osc.frequency.value = 60 + Math.random() * 40;
    g.gain.setValueAtTime(0.01, this.ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);
    osc.connect(g);
    g.connect(this.master);
    osc.start();
    osc.stop(this.ctx.currentTime + 0.3);
  }

  setEnabled(v) {
    this.enabled = v;
    if (this.master) this.master.gain.value = v ? 0.15 : 0;
  }
}

// ==================== TERRAIN GENERATION ====================
class TerrainMap {
  constructor(w, h) {
    this.w = w;
    this.h = h;
    this.height = new Float32Array(w * h);
    this.water = new Float32Array(w * h);
    this.sediment = new Float32Array(w * h);
    this.erosionMap = new Float32Array(w * h);
    this.totalErosion = 0;
    this.totalSediment = 0;
    this.maxHeight = 0;
    this.riverCount = 0;
  }

  idx(x, y) { return y * this.w + x; }

  generate(type) {
    // Perlin-like noise via octave summation
    const noise2d = (x, y, freq) => {
      const ix = Math.floor(x * freq);
      const iy = Math.floor(y * freq);
      const fx = x * freq - ix;
      const fy = y * freq - iy;
      // Simple hash
      const hash = (a, b) => {
        let h = a * 374761393 + b * 668265263;
        h = (h ^ (h >> 13)) * 1274126177;
        return ((h ^ (h >> 16)) & 0x7fffffff) / 0x7fffffff;
      };
      const v00 = hash(ix, iy);
      const v10 = hash(ix + 1, iy);
      const v01 = hash(ix, iy + 1);
      const v11 = hash(ix + 1, iy + 1);
      const sx = fx * fx * (3 - 2 * fx);
      const sy = fy * fy * (3 - 2 * fy);
      const top = v00 + (v10 - v00) * sx;
      const bot = v01 + (v11 - v01) * sx;
      return top + (bot - top) * sy;
    };

    for (let y = 0; y < this.h; y++) {
      for (let x = 0; x < this.w; x++) {
        let h = 0;
        const nx = x / this.w;
        const ny = y / this.h;

        switch (type) {
          case 'mountains':
            h += noise2d(nx, ny, 3) * 0.5;
            h += noise2d(nx, ny, 7) * 0.25;
            h += noise2d(nx, ny, 15) * 0.125;
            h += noise2d(nx, ny, 30) * 0.0625;
            // Ridge in center
            h += Math.max(0, 0.3 - Math.abs(nx - 0.5)) * 1.5;
            h += Math.max(0, 0.2 - Math.abs(ny - 0.4)) * 1.0;
            break;
          case 'plains':
            h += noise2d(nx, ny, 2) * 0.3;
            h += noise2d(nx, ny, 5) * 0.15;
            h += noise2d(nx, ny, 12) * 0.08;
            h += noise2d(nx, ny, 25) * 0.04;
            h += 0.1; // Base elevation
            break;
          case 'canyon':
            h += noise2d(nx, ny, 4) * 0.4;
            h += noise2d(nx, ny, 8) * 0.2;
            h += noise2d(nx, ny, 16) * 0.1;
            // Plateau
            h = h > 0.35 ? h + 0.2 : h * 0.5;
            break;
        }

        // Edge falloff
        const edgeDist = Math.min(nx, 1 - nx, ny, 1 - ny);
        const edgeFade = Math.min(1, edgeDist * 5);
        h *= edgeFade;

        this.height[this.idx(x, y)] = Math.max(0, h);
      }
    }

    this.updateMaxHeight();
  }

  updateMaxHeight() {
    this.maxHeight = 0;
    for (let i = 0; i < this.height.length; i++) {
      if (this.height[i] > this.maxHeight) this.maxHeight = this.height[i];
    }
  }

  simulateErosion(drops, settings) {
    const { erosionPower, sedimentCap, evapRate } = settings;

    for (let d = 0; d < drops; d++) {
      let x = Math.random() * (this.w - 2) + 1;
      let y = Math.random() * (this.h - 2) + 1;
      let dx = 0, dy = 0;
      let water = 1;
      let speed = 0;
      let sediment = 0;
      const maxSteps = 80;
      const inertia = 0.3;
      const gravity = 4;
      const minSlope = 0.01;
      const erodeRadius = 2;

      for (let step = 0; step < maxSteps; step++) {
        const ix = Math.floor(x);
        const iy = Math.floor(y);
        if (ix < 1 || ix >= this.w - 1 || iy < 1 || iy >= this.h - 1) break;

        // Calculate gradient
        const i = this.idx(ix, iy);
        const hL = this.height[this.idx(ix - 1, iy)];
        const hR = this.height[this.idx(ix + 1, iy)];
        const hU = this.height[this.idx(ix, iy - 1)];
        const hD = this.height[this.idx(ix, iy + 1)];
        const gx = hR - hL;
        const gy = hD - hU;

        // Update direction with inertia
        dx = dx * inertia - gx * (1 - inertia);
        dy = dy * inertia - gy * (1 - inertia);

        const len = Math.sqrt(dx * dx + dy * dy);
        if (len > 0) { dx /= len; dy /= len; }

        // Move
        x += dx;
        y += dy;

        const nix = Math.floor(x);
        const niy = Math.floor(y);
        if (nix < 1 || nix >= this.w - 1 || niy < 1 || niy >= this.h - 1) break;

        const ni = this.idx(nix, niy);
        const heightDiff = this.height[ni] - this.height[i];

        // Calculate capacity
        const capacity = Math.max(-heightDiff, minSlope) * speed * water * sedimentCap * 0.01;

        if (sediment > capacity || heightDiff > 0) {
          // Deposit
          const deposit = heightDiff > 0
            ? Math.min(heightDiff, sediment)
            : (sediment - capacity) * 0.3;
          sediment -= deposit;
          this.height[i] += deposit;
          this.sediment[i] += deposit;
          this.totalSediment += deposit;
        } else {
          // Erode
          const erode = Math.min((capacity - sediment) * erosionPower * 0.01, -heightDiff);

          for (let ey = -erodeRadius; ey <= erodeRadius; ey++) {
            for (let ex = -erodeRadius; ex <= erodeRadius; ex++) {
              const px = ix + ex;
              const py = iy + ey;
              if (px < 0 || px >= this.w || py < 0 || py >= this.h) continue;
              const dist = Math.sqrt(ex * ex + ey * ey);
              if (dist > erodeRadius) continue;
              const weight = 1 - dist / erodeRadius;
              const pi = this.idx(px, py);
              const removed = erode * weight / ((2 * erodeRadius + 1) * (2 * erodeRadius + 1));
              this.height[pi] = Math.max(0, this.height[pi] - removed);
              this.erosionMap[pi] += removed;
            }
          }
          sediment += erode;
          this.totalErosion += erode;
        }

        speed = Math.sqrt(Math.max(0, speed * speed + heightDiff * gravity));
        water *= (1 - evapRate * 0.001);
        this.water[ni] += water * 0.1;

        if (water < 0.01) break;
      }
    }
  }

  getColor(x, y, viewMode) {
    const i = this.idx(x, y);
    const h = this.height[i];
    const w = this.water[i];
    const s = this.sediment[i];
    const e = this.erosionMap[i];

    switch (viewMode) {
      case 'terrain': {
        if (w > 0.5) {
          const wIntensity = Math.min(1, w * 0.3);
          return [20 + wIntensity * 20, 60 + wIntensity * 60, 120 + wIntensity * 80];
        }
        const hn = this.maxHeight > 0 ? h / this.maxHeight : 0;
        if (hn > 0.8) return [200 + hn * 55, 200 + hn * 55, 210 + hn * 45]; // Snow
        if (hn > 0.6) return [120 + hn * 40, 100 + hn * 30, 80 + hn * 20]; // Rock
        if (hn > 0.3) return [60 + hn * 80, 100 + hn * 60, 30 + hn * 30]; // Forest
        if (hn > 0.1) return [80 + hn * 100, 140 + hn * 60, 40 + hn * 40]; // Grass
        return [140 + hn * 80, 160 + hn * 60, 100 + hn * 40]; // Lowland
      }
      case 'water': {
        const wn = Math.min(1, w * 0.5);
        return [10, 30 + wn * 120, 60 + wn * 195];
      }
      case 'erosion': {
        const en = Math.min(1, e * 10);
        return [40 + en * 200, 20 + en * 40, 20];
      }
      case 'sediment': {
        const sn = Math.min(1, s * 5);
        return [80 + sn * 175, 60 + sn * 130, 20 + sn * 40];
      }
      case 'height': {
        const hn = this.maxHeight > 0 ? h / this.maxHeight : 0;
        return [hn * 255, hn * 255, hn * 255];
      }
      default:
        return [0, 0, 0];
    }
  }
}

// ==================== MAIN SIMULATION ====================
class ErosionSim {
  constructor() {
    this.canvas = document.getElementById('canvas');
    this.ctx = this.canvas.getContext('2d');
    this.miniCanvas = document.getElementById('minimap');
    this.miniCtx = this.miniCanvas.getContext('2d');

    this.w = window.innerWidth;
    this.h = window.innerHeight;
    this.canvas.width = this.w;
    this.canvas.height = this.h;

    // Simulation resolution (lower than display for performance)
    this.simW = Math.min(400, Math.floor(this.w / 2));
    this.simH = Math.min(300, Math.floor(this.h / 2));

    this.terrain = new TerrainMap(this.simW, this.simH);
    this.audio = new ErosionAudio();
    this.paused = false;
    this.started = false;
    this.frame = 0;
    this.epoch = 0;
    this.timeSpeed = 1;
    this.totalDrops = 0;
    this.type = 'mountains';

    this.settings = {
      rainRate: 5,
      erosionPower: 5,
      sedimentCap: 5,
      evapRate: 5,
      viewMode: 'terrain',
      soundEnabled: true
    };

    this.mouseDown = false;
    this.mouseX = 0;
    this.mouseY = 0;

    // Image data for fast rendering
    this.imageData = null;

    // Render particles for visual flair
    this.rainDrops = [];
    this.flowParticles = [];

    this.setupEvents();
    this.setupControls();
    this.loadState();
  }

  setupEvents() {
    window.addEventListener('resize', () => {
      this.w = window.innerWidth;
      this.h = window.innerHeight;
      this.canvas.width = this.w;
      this.canvas.height = this.h;
    });

    this.canvas.addEventListener('mousedown', (e) => {
      this.mouseDown = true;
      this.mouseX = e.clientX;
      this.mouseY = e.clientY;
    });
    this.canvas.addEventListener('mousemove', (e) => {
      this.mouseX = e.clientX;
      this.mouseY = e.clientY;
    });
    this.canvas.addEventListener('mouseup', () => { this.mouseDown = false; });

    this.canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      this.timeSpeed += e.deltaY > 0 ? -0.5 : 0.5;
      this.timeSpeed = Math.max(0.5, Math.min(10, this.timeSpeed));
      document.getElementById('hud-speed').textContent = this.timeSpeed.toFixed(1);
    }, { passive: false });

    // Touch
    this.canvas.addEventListener('touchstart', (e) => {
      this.mouseDown = true;
      this.mouseX = e.touches[0].clientX;
      this.mouseY = e.touches[0].clientY;
    }, { passive: true });
    this.canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      this.mouseX = e.touches[0].clientX;
      this.mouseY = e.touches[0].clientY;
    }, { passive: false });
    this.canvas.addEventListener('touchend', () => { this.mouseDown = false; });

    document.addEventListener('keydown', (e) => {
      if (e.key === ' ' || e.key === 'Escape') {
        e.preventDefault();
        this.togglePause();
      } else if (e.key === 'r' || e.key === 'R') {
        this.reset();
      } else if (e.key === 's' || e.key === 'S') {
        this.saveImg();
      }
    });
  }

  setupControls() {
    document.getElementById('ctrl-rain').addEventListener('input', (e) => {
      this.settings.rainRate = parseInt(e.target.value);
    });
    document.getElementById('ctrl-erosion').addEventListener('input', (e) => {
      this.settings.erosionPower = parseInt(e.target.value);
    });
    document.getElementById('ctrl-sedcap').addEventListener('input', (e) => {
      this.settings.sedimentCap = parseInt(e.target.value);
    });
    document.getElementById('ctrl-evap').addEventListener('input', (e) => {
      this.settings.evapRate = parseInt(e.target.value);
    });
    document.getElementById('ctrl-view').addEventListener('change', (e) => {
      this.settings.viewMode = e.target.value;
    });
    document.getElementById('ctrl-sound').addEventListener('change', (e) => {
      this.settings.soundEnabled = e.target.checked;
      this.audio.setEnabled(e.target.checked);
    });
  }

  initTerrain(type) {
    this.type = type;
    this.terrain.generate(type);
    this.epoch = 0;
    this.totalDrops = 0;
    this.terrain.totalErosion = 0;
    this.terrain.totalSediment = 0;
  }

  togglePause() {
    this.paused = !this.paused;
    document.getElementById('pause-overlay').style.display = this.paused ? 'flex' : 'none';
  }

  reset() {
    this.terrain = new TerrainMap(this.simW, this.simH);
    this.initTerrain(this.type);
    this.rainDrops = [];
    this.flowParticles = [];
  }

  saveImg() {
    const link = document.createElement('a');
    link.download = 'erosion-' + Date.now() + '.png';
    link.href = this.canvas.toDataURL('image/png');
    link.click();
  }

  saveState() {
    try {
      localStorage.setItem('erosion-symphony-state', JSON.stringify({
        type: this.type,
        settings: this.settings,
        timeSpeed: this.timeSpeed,
        epoch: this.epoch,
        totalDrops: this.totalDrops
      }));
    } catch(e) {}
  }

  loadState() {
    try {
      const saved = JSON.parse(localStorage.getItem('erosion-symphony-state'));
      if (saved) {
        this.timeSpeed = saved.timeSpeed || 1;
        if (saved.settings) Object.assign(this.settings, saved.settings);
        document.getElementById('ctrl-rain').value = this.settings.rainRate;
        document.getElementById('ctrl-erosion').value = this.settings.erosionPower;
        document.getElementById('ctrl-sedcap').value = this.settings.sedimentCap;
        document.getElementById('ctrl-evap').value = this.settings.evapRate;
        document.getElementById('ctrl-view').value = this.settings.viewMode;
      }
    } catch(e) {}
  }

  update() {
    if (this.paused) return;
    this.frame++;

    // Natural rain
    const dropsPerFrame = Math.floor(this.settings.rainRate * this.timeSpeed * 2);
    this.terrain.simulateErosion(dropsPerFrame, this.settings);
    this.totalDrops += dropsPerFrame;

    // Mouse rain (click to add concentrated rain)
    if (this.mouseDown) {
      const sx = Math.floor((this.mouseX / this.w) * this.simW);
      const sy = Math.floor((this.mouseY / this.h) * this.simH);
      const radius = 15;
      for (let i = 0; i < 20; i++) {
        const rx = sx + (Math.random() - 0.5) * radius * 2;
        const ry = sy + (Math.random() - 0.5) * radius * 2;
        if (rx >= 0 && rx < this.simW && ry >= 0 && ry < this.simH) {
          const idx = this.terrain.idx(Math.floor(rx), Math.floor(ry));
          this.terrain.water[idx] += 0.5;
        }
      }
      // Visual rain drops
      for (let i = 0; i < 3; i++) {
        this.rainDrops.push({
          x: this.mouseX + (Math.random() - 0.5) * 40,
          y: this.mouseY - 50 - Math.random() * 100,
          vy: 3 + Math.random() * 5,
          life: 1
        });
      }
      this.totalDrops += 20;
      if (this.frame % 10 === 0) this.audio.playDrop();
    }

    // Water decay
    for (let i = 0; i < this.terrain.water.length; i++) {
      this.terrain.water[i] *= 0.995;
    }

    // Epoch tracking
    if (this.frame % 60 === 0) {
      this.epoch++;
      this.terrain.updateMaxHeight();
    }

    // Erosion sound events
    if (this.frame % 30 === 0 && this.terrain.totalErosion > 0.1) {
      this.audio.playErosion();
    }

    // Water flow sound
    let waterSum = 0;
    for (let i = 0; i < Math.min(1000, this.terrain.water.length); i++) {
      waterSum += this.terrain.water[i];
    }
    this.audio.updateWaterFlow(waterSum / 100);

    // Count rivers (cells with significant water)
    if (this.frame % 120 === 0) {
      let rivers = 0;
      for (let i = 0; i < this.terrain.water.length; i++) {
        if (this.terrain.water[i] > 0.5) rivers++;
      }
      this.terrain.riverCount = rivers;
    }

    // Rain drop animation
    this.rainDrops = this.rainDrops.filter(d => {
      d.y += d.vy;
      d.life -= 0.02;
      return d.life > 0 && d.y < this.h;
    });

    // Update HUD
    document.getElementById('hud-epoch').textContent = this.epoch;
    document.getElementById('hud-drops').textContent = this.totalDrops.toLocaleString();
    document.getElementById('hud-rivers').textContent = this.terrain.riverCount;
    document.getElementById('hud-sed').textContent = this.terrain.totalSediment.toFixed(1);
    document.getElementById('hud-peak').textContent = (this.terrain.maxHeight * 1000).toFixed(0);

    // Save periodically
    if (this.frame % 600 === 0) this.saveState();
  }

  draw() {
    const ctx = this.ctx;

    // Render terrain to pixel buffer then scale up
    const scaleX = this.w / this.simW;
    const scaleY = this.h / this.simH;

    // Create offscreen if needed
    if (!this.offCanvas || this.offCanvas.width !== this.simW) {
      this.offCanvas = document.createElement('canvas');
      this.offCanvas.width = this.simW;
      this.offCanvas.height = this.simH;
      this.offCtx = this.offCanvas.getContext('2d');
    }

    const imgData = this.offCtx.createImageData(this.simW, this.simH);
    const data = imgData.data;

    for (let y = 0; y < this.simH; y++) {
      for (let x = 0; x < this.simW; x++) {
        const [r, g, b] = this.terrain.getColor(x, y, this.settings.viewMode);
        const pi = (y * this.simW + x) * 4;
        data[pi] = Math.min(255, Math.max(0, r));
        data[pi + 1] = Math.min(255, Math.max(0, g));
        data[pi + 2] = Math.min(255, Math.max(0, b));
        data[pi + 3] = 255;
      }
    }

    this.offCtx.putImageData(imgData, 0, 0);

    // Scale to main canvas
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    ctx.drawImage(this.offCanvas, 0, 0, this.w, this.h);

    // Rain drops overlay
    for (const d of this.rainDrops) {
      ctx.strokeStyle = `rgba(120,180,255,${d.life * 0.6})`;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(d.x, d.y);
      ctx.lineTo(d.x, d.y + 8);
      ctx.stroke();
    }

    // Vignette
    const vignette = ctx.createRadialGradient(
      this.w / 2, this.h / 2, this.w * 0.3,
      this.w / 2, this.h / 2, this.w * 0.7
    );
    vignette.addColorStop(0, 'rgba(0,0,0,0)');
    vignette.addColorStop(1, 'rgba(0,0,0,0.3)');
    ctx.fillStyle = vignette;
    ctx.fillRect(0, 0, this.w, this.h);

    // Draw minimap
    this.drawMinimap();
  }

  drawMinimap() {
    const mw = this.miniCanvas.width;
    const mh = this.miniCanvas.height;
    const mCtx = this.miniCtx;

    if (!this.miniOff || this.miniOff.width !== mw) {
      this.miniOff = document.createElement('canvas');
      this.miniOff.width = mw;
      this.miniOff.height = mh;
      this.miniOffCtx = this.miniOff.getContext('2d');
    }

    if (this.frame % 30 === 0) {
      const imgData = this.miniOffCtx.createImageData(mw, mh);
      const data = imgData.data;
      for (let y = 0; y < mh; y++) {
        for (let x = 0; x < mw; x++) {
          const sx = Math.floor(x / mw * this.simW);
          const sy = Math.floor(y / mh * this.simH);
          const [r, g, b] = this.terrain.getColor(sx, sy, 'terrain');
          const pi = (y * mw + x) * 4;
          data[pi] = r;
          data[pi + 1] = g;
          data[pi + 2] = b;
          data[pi + 3] = 255;
        }
      }
      this.miniOffCtx.putImageData(imgData, 0, 0);
    }

    mCtx.drawImage(this.miniOff, 0, 0);
  }

  run() {
    const loop = () => {
      this.update();
      this.draw();
      requestAnimationFrame(loop);
    };
    loop();
  }
}

// ==================== GLOBAL ====================
let sim;

function startSim(type) {
  sim = new ErosionSim();
  sim.started = true;
  sim.audio.init();
  sim.initTerrain(type);

  const title = document.getElementById('title-screen');
  title.style.opacity = '0';
  setTimeout(() => { title.style.display = 'none'; }, 1500);

  sim.run();
}

function resetSim() { if (sim) sim.reset(); }
function togglePause() { if (sim) sim.togglePause(); }
function saveImg() { if (sim) sim.saveImg(); }

// Title background
(function() {
  const c = document.getElementById('canvas');
  const ctx = c.getContext('2d');
  c.width = window.innerWidth;
  c.height = window.innerHeight;
  const grad = ctx.createLinearGradient(0, 0, 0, c.height);
  grad.addColorStop(0, '#0a0f1a');
  grad.addColorStop(0.5, '#1a1510');
  grad.addColorStop(1, '#0f0a05');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, c.width, c.height);

  // Simple terrain silhouette
  ctx.beginPath();
  ctx.moveTo(0, c.height);
  for (let x = 0; x <= c.width; x += 3) {
    const y = c.height * 0.5 +
      Math.sin(x * 0.003) * 80 +
      Math.sin(x * 0.008) * 40 +
      Math.sin(x * 0.02) * 15;
    ctx.lineTo(x, y);
  }
  ctx.lineTo(c.width, c.height);
  ctx.closePath();
  ctx.fillStyle = '#15100a';
  ctx.fill();
})();
</script>
</body>
</html>