<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite City - Wave Function Collapse</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: monospace; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 4px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="ui">
        <h3>Infinite City WFC</h3>
        <div>Generating procedural chunks...</div>
        <div id="coords"></div>
    </div>

<script>
/**
 * INFINITE CITY GENERATOR
 * Uses a simplified Wave Function Collapse algorithm to generate
 * an infinite, consistent city grid.
 */

// --- CONFIG ---
const TILE_SIZE = 100;
const CHUNK_SIZE = 8; // 8x8 tiles per chunk
const VIEW_DIST = 6; // Chunks to render
const FOG_DIST = TILE_SIZE * CHUNK_SIZE * (VIEW_DIST - 1);

// --- TILES & RULES ---
// Edges: 0=Building/Park, 1=Road
// Order: Top, Right, Bottom, Left
const TILES = {
    BUILDING: { color: '#ccc', height: 100, edges: [0,0,0,0], weight: 10 },
    PARK:     { color: '#90EE90', height: 0,   edges: [0,0,0,0], weight: 2 },
    ROAD_V:   { color: '#333', height: 0,   edges: [1,0,1,0], weight: 4 },
    ROAD_H:   { color: '#333', height: 0,   edges: [0,1,0,1], weight: 4 },
    ROAD_X:   { color: '#333', height: 0,   edges: [1,1,1,1], weight: 1 },
    ROAD_T_N: { color: '#333', height: 0,   edges: [1,1,0,1], weight: 1 }, // T pointing North (Roads on Top, Right, Left)
    ROAD_T_E: { color: '#333', height: 0,   edges: [1,1,1,0], weight: 1 },
    ROAD_T_S: { color: '#333', height: 0,   edges: [0,1,1,1], weight: 1 },
    ROAD_T_W: { color: '#333', height: 0,   edges: [1,0,1,1], weight: 1 },
    ROAD_C_NE:{ color: '#333', height: 0,   edges: [1,1,0,0], weight: 1 }, // Corner North-East
    ROAD_C_SE:{ color: '#333', height: 0,   edges: [0,1,1,0], weight: 1 },
    ROAD_C_SW:{ color: '#333', height: 0,   edges: [0,0,1,1], weight: 1 },
    ROAD_C_NW:{ color: '#333', height: 0,   edges: [1,0,0,1], weight: 1 }
};

const TILE_KEYS = Object.keys(TILES);

// --- WFC ENGINE ---
class WFC {
    constructor(seed) {
        this.seed = seed;
        this.chunks = new Map(); // "x,z" -> [[TileType]]
    }

    // Pseudo-random based on coordinates
    random(x, z) {
        let h = 0x811c9dc5;
        h ^= x; h = Math.imul(h, 0x01000193);
        h ^= z; h = Math.imul(h, 0x01000193);
        h ^= this.seed; h = Math.imul(h, 0x01000193);
        return (h >>> 0) / 4294967296;
    }

    getChunk(cx, cz) {
        const key = `${cx},${cz}`;
        if (this.chunks.has(key)) return this.chunks.get(key);

        const chunk = this.generateChunk(cx, cz);
        this.chunks.set(key, chunk);
        return chunk;
    }

    generateChunk(cx, cz) {
        // Initialize wave: all possibilities open
        const size = CHUNK_SIZE;
        const grid = [];
        for(let i=0; i<size*size; i++) {
            grid[i] = {
                collapsed: false,
                options: [...TILE_KEYS]
            };
        }

        // Get boundary constraints from neighbors
        // For simplicity in this infinite version, we'll just generate deterministically
        // based on a noise function to ensure edges match, OR use a simpler
        // "hashing" WFC where we resolve tile by tile.
        
        // Full WFC is hard to make infinite and consistent without storing everything.
        // We'll use a "Scanline" WFC approach or a noise-based rule lookup.
        
        // Let's use a simpler approach:
        // 1. Determine roads based on Perlin-like noise (Road Network)
        // 2. Fill rest with buildings/parks
        
        const finalGrid = [];
        
        for(let z=0; z<size; z++) {
            for(let x=0; x<size; x++) {
                const wx = cx * size + x;
                const wz = cz * size + z;
                
                // Noise-based road generation
                // We want a grid-like structure but with variations
                // Use a hash to determine if a "major road" exists on this line
                
                const isRoadX = this.isRoadLine(wx, 'x');
                const isRoadZ = this.isRoadLine(wz, 'z');
                
                let type = 'BUILDING';
                
                if (isRoadX && isRoadZ) {
                    type = 'ROAD_X'; // Intersection
                    // Or T-junctions randomly?
                } else if (isRoadX) {
                    type = 'ROAD_V'; // Vertical road (along Z)
                } else if (isRoadZ) {
                    type = 'ROAD_H'; // Horizontal road (along X)
                } else {
                    // Not a road, building or park
                    const n = this.random(wx, wz);
                    type = n > 0.9 ? 'PARK' : 'BUILDING';
                }
                
                // Fix connections (simple logic replacement)
                // If we are a road, check neighbors to pick correct sprite
                // But since we define roads by lines, ROAD_X, ROAD_V, ROAD_H is mostly correct.
                // To get corners/turns, we'd need sparse noise.
                
                finalGrid.push(type);
            }
        }
        
        return finalGrid;
    }
    
    isRoadLine(coord, axis) {
        // Roads appear every N blocks, with some jitter
        // Simple grid: every 4th block is a road
        // return coord % 4 === 0;
        
        // More organic:
        // Use noise to shift the grid lines?
        // Let's stick to a sparse grid for "City" feel
        // Every 3-6 blocks
        
        // Deterministic pseudo-random check
        // We need consistent lines.
        // "Is this coordinate a road?"
        
        // Simple approach: A road exists if coord % interval == 0
        // But interval can change?
        
        // Let's use a fixed grid for robustness in this demo
        return coord % 4 === 0;
    }
}

// --- RENDERER ---
class Renderer {
    constructor() {
        this.canvas = document.getElementById('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.cx = this.width / 2;
        this.cy = this.height / 2;
        
        this.camera = { x: 0, y: -300, z: 0, yaw: 0, pitch: 0.4 };
        this.wfc = new WFC(123);
        
        this.resize();
        window.addEventListener('resize', () => this.resize());
    }
    
    resize() {
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.canvas.width = this.width;
        this.canvas.height = this.height;
        this.cx = this.width / 2;
        this.cy = this.height / 2;
    }
    
    project(x, y, z) {
        // Translate
        let dx = x - this.camera.x;
        let dy = y - this.camera.y;
        let dz = z - this.camera.z;
        
        // Rotate Yaw (Y-axis)
        let cosY = Math.cos(this.camera.yaw);
        let sinY = Math.sin(this.camera.yaw);
        let x1 = dx * cosY - dz * sinY;
        let z1 = dx * sinY + dz * cosY;
        
        // Rotate Pitch (X-axis)
        let cosX = Math.cos(this.camera.pitch);
        let sinX = Math.sin(this.camera.pitch);
        let y2 = dy * cosX - z1 * sinX;
        let z2 = dy * sinX + z1 * cosX;
        
        if (z2 <= 10) return { visible: false };
        
        const fov = 800;
        const scale = fov / z2;
        
        return {
            x: x1 * scale + this.cx,
            y: y2 * scale + this.cy,
            scale: scale,
            dist: z2,
            visible: true
        };
    }
    
    drawCube(x, z, h, color) {
        const y = 0; // Ground
        const s = TILE_SIZE;
        const hs = s/2;
        
        // Vertices
        // 0-3 Top (y-h), 4-7 Bottom (y)
        const v = [
            {x: x-hs, y: y-h, z: z-hs}, {x: x+hs, y: y-h, z: z-hs},
            {x: x+hs, y: y-h, z: z+hs}, {x: x-hs, y: y-h, z: z+hs},
            {x: x-hs, y: y,   z: z-hs}, {x: x+hs, y: y,   z: z-hs},
            {x: x+hs, y: y,   z: z+hs}, {x: x-hs, y: y,   z: z+hs}
        ];
        
        const p = v.map(vert => this.project(vert.x, vert.y, vert.z));
        if (p.every(pt => !pt.visible)) return;
        
        // Distance fade
        const dist = Math.sqrt((x-this.camera.x)**2 + (z-this.camera.z)**2);
        const alpha = Math.max(0, Math.min(1, 1 - (dist / FOG_DIST)));
        if (alpha <= 0) return;
        
        this.ctx.globalAlpha = alpha;
        this.ctx.fillStyle = color;
        this.ctx.strokeStyle = '#555';
        this.ctx.lineWidth = 1;
        
        // Draw faces (simple painter's algo handled by main loop sorting)
        
        // Top
        if (h > 0) {
            this.ctx.beginPath();
            this.ctx.moveTo(p[0].x, p[0].y);
            this.ctx.lineTo(p[1].x, p[1].y);
            this.ctx.lineTo(p[2].x, p[2].y);
            this.ctx.lineTo(p[3].x, p[3].y);
            this.ctx.closePath();
            this.ctx.fill();
            this.ctx.stroke();
            
            // Front/Side faces... simplified for performance
            // Front
            this.ctx.fillStyle = shadeColor(color, -20);
            this.ctx.beginPath();
            this.ctx.moveTo(p[2].x, p[2].y);
            this.ctx.lineTo(p[3].x, p[3].y);
            this.ctx.lineTo(p[7].x, p[7].y);
            this.ctx.lineTo(p[6].x, p[6].y);
            this.ctx.fill();
            this.ctx.stroke();
            
            // Side
            this.ctx.fillStyle = shadeColor(color, -40);
            this.ctx.beginPath();
            this.ctx.moveTo(p[1].x, p[1].y);
            this.ctx.lineTo(p[2].x, p[2].y);
            this.ctx.lineTo(p[6].x, p[6].y);
            this.ctx.lineTo(p[5].x, p[5].y);
            this.ctx.fill();
            this.ctx.stroke();
        } else {
            // Flat tile (Road/Park)
            this.ctx.beginPath();
            this.ctx.moveTo(p[4].x, p[4].y);
            this.ctx.lineTo(p[5].x, p[5].y);
            this.ctx.lineTo(p[6].x, p[6].y);
            this.ctx.lineTo(p[7].x, p[7].y);
            this.ctx.closePath();
            this.ctx.fill();
            // this.ctx.stroke();
        }
        
        this.ctx.globalAlpha = 1.0;
    }
    
    render() {
        // Clear
        this.ctx.fillStyle = '#87CEEB'; // Sky
        this.ctx.fillRect(0, 0, this.width, this.height);
        
        // Ground fog
        // ...
        
        // Determine visible chunks
        const cx = Math.floor(this.camera.x / (TILE_SIZE * CHUNK_SIZE));
        const cz = Math.floor(this.camera.z / (TILE_SIZE * CHUNK_SIZE));
        
        const renderList = [];
        
        for(let z = cz - VIEW_DIST; z <= cz + VIEW_DIST; z++) {
            for(let x = cx - VIEW_DIST; x <= cx + VIEW_DIST; x++) {
                const chunk = this.wfc.getChunk(x, z);
                
                // Add tiles to render list
                for(let i=0; i<chunk.length; i++) {
                    const type = chunk[i];
                    const tx = i % CHUNK_SIZE;
                    const tz = Math.floor(i / CHUNK_SIZE);
                    
                    const wx = (x * CHUNK_SIZE + tx) * TILE_SIZE;
                    const wz = (z * CHUNK_SIZE + tz) * TILE_SIZE;
                    
                    // Culling
                    const d = Math.sqrt((wx-this.camera.x)**2 + (wz-this.camera.z)**2);
                    if (d > FOG_DIST) continue;
                    
                    // Frustum culling (simple behind check)
                    // ...
                    
                    renderList.push({
                        x: wx, z: wz,
                        type: type,
                        dist: d
                    });
                }
            }
        }
        
        // Sort back to front
        renderList.sort((a, b) => b.dist - a.dist);
        
        // Draw
        renderList.forEach(item => {
            const tile = TILES[item.type];
            let h = tile.height;
            let c = tile.color;
            
            if (item.type === 'BUILDING') {
                // Randomize height slightly based on pos
                const n = this.wfc.random(item.x, item.z);
                h = 50 + n * 300;
                // Randomize color
                c = n > 0.5 ? '#ccc' : '#ddd';
            }
            
            this.drawCube(item.x, item.z, h, c);
        });
        
        // Update UI
        document.getElementById('coords').innerText = 
            `${Math.floor(this.camera.x)}, ${Math.floor(this.camera.z)}`;
    }
    
    update(dt) {
        // Fly forward
        const speed = 100 * dt;
        this.camera.z += speed;
        
        // Gentle sway
        this.camera.x += Math.sin(Date.now() / 2000) * 0.5;
    }
}

function shadeColor(color, percent) {
    var R = parseInt(color.substring(1,3),16);
    var G = parseInt(color.substring(3,5),16);
    var B = parseInt(color.substring(5,7),16);

    R = parseInt(R * (100 + percent) / 100);
    G = parseInt(G * (100 + percent) / 100);
    B = parseInt(B * (100 + percent) / 100);

    R = (R<255)?R:255;  
    G = (G<255)?G:255;  
    B = (B<255)?B:255;  

    var RR = ((R.toString(16).length==1)?"0"+R.toString(16):R.toString(16));
    var GG = ((G.toString(16).length==1)?"0"+G.toString(16):G.toString(16));
    var BB = ((B.toString(16).length==1)?"0"+B.toString(16):B.toString(16));

    return "#"+RR+GG+BB;
}

// --- MAIN ---
const renderer = new Renderer();
let lastTime = 0;

function loop(time) {
    const dt = (time - lastTime) / 1000;
    lastTime = time;
    
    renderer.update(dt);
    renderer.render();
    
    requestAnimationFrame(loop);
}

requestAnimationFrame(loop);

</script>
</body>
</html>