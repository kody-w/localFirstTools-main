<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rainy Night Neon Noir</title>
    <meta name="description" content="A contemplative generative art piece — rain-slicked streets reflecting flickering neon at 2am">
    <meta name="rappterzoo:title" content="Rainy Night Neon Noir">
    <meta name="rappterzoo:description" content="Stand on a rain-soaked city street at 2am. Watch neon light bleed into puddles while distant thunder rolls.">
    <meta name="rappterzoo:category" content="generative-art">
    <meta name="rappterzoo:tags" content="rain,neon,noir,generative,atmospheric,canvas,ambient,cinematic">
    <meta name="rappterzoo:type" content="visual">
    <meta name="rappterzoo:complexity" content="advanced">
    <meta name="rappterzoo:version" content="2.0">
    <meta name="rappterzoo:author" content="RappterZoo">
    <meta name="rappterzoo:author-type" content="agent">
    <meta name="rappterzoo:created" content="2025-01-15">
    <meta name="rappterzoo:generation" content="2">
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:#07070e;overflow:hidden;font-family:'Courier New',monospace;cursor:crosshair}
        canvas{position:fixed;top:0;left:0;width:100%;height:100%}
        #controls{
            position:fixed;top:16px;left:16px;
            background:rgba(7,7,14,0.92);
            padding:18px 22px;border-radius:8px;
            border:1px solid rgba(255,60,120,0.15);
            color:#c07090;z-index:100;
            min-width:220px;
            backdrop-filter:blur(6px);
            -webkit-backdrop-filter:blur(6px);
            transition:opacity 0.4s,transform 0.4s;
            font-size:12px;
            box-shadow:0 0 30px rgba(0,0,0,0.6);
        }
        #controls.hidden{opacity:0;pointer-events:none;transform:translateX(-20px)}
        #controls h3{
            margin-bottom:14px;color:#ff4080;
            font-size:14px;letter-spacing:3px;
            text-transform:uppercase;
            text-shadow:0 0 12px rgba(255,64,128,0.4);
        }
        .ctrl{margin:10px 0}
        .ctrl label{display:flex;justify-content:space-between;font-size:10px;opacity:0.6;margin-bottom:4px;letter-spacing:1px}
        .ctrl label span{opacity:0.9;color:#ff6090}
        input[type=range]{
            -webkit-appearance:none;width:100%;height:3px;
            background:rgba(255,60,120,0.15);border-radius:2px;outline:none;
        }
        input[type=range]::-webkit-slider-thumb{
            -webkit-appearance:none;width:12px;height:12px;
            background:#ff4080;border-radius:50%;cursor:pointer;
            box-shadow:0 0 8px rgba(255,64,128,0.5);
        }
        #hints{
            position:fixed;bottom:14px;left:50%;transform:translateX(-50%);
            color:rgba(180,140,160,0.3);font-size:10px;letter-spacing:2px;
            font-family:'Courier New',monospace;
            transition:opacity 2s;
        }
    </style>
</head>
<body>
<canvas id="c"></canvas>
<div id="controls">
    <h3>⬡ Neon Noir</h3>
    <div class="ctrl"><label>Rain Intensity <span id="vRain">70</span></label><input type="range" id="sRain" min="0" max="100" value="70"></div>
    <div class="ctrl"><label>Wind <span id="vWind">20</span></label><input type="range" id="sWind" min="-100" max="100" value="20"></div>
    <div class="ctrl"><label>Neon Brightness <span id="vNeon">80</span></label><input type="range" id="sNeon" min="0" max="100" value="80"></div>
    <div class="ctrl"><label>Ambience <span id="vAmb">60</span></label><input type="range" id="sAmb" min="0" max="100" value="60"></div>
    <div class="ctrl"><label>Color Temp <span id="vTemp">50</span></label><input type="range" id="sTemp" min="0" max="100" value="50"></div>
    <div class="ctrl"><label>Film Grain <span id="vGrain">30</span></label><input type="range" id="sGrain" min="0" max="100" value="30"></div>
    <div style="margin-top:14px;opacity:0.35;font-size:9px;letter-spacing:1px;line-height:1.6">
        [SPACE] rain &nbsp; [L] lightning &nbsp; [C] controls<br>[S] save screenshot
    </div>
</div>
<div id="hints">2 : 0 0 &ensp; A M</div>
<script>
// ── CANVAS SETUP ──
const cv = document.getElementById('c');
const cx = cv.getContext('2d');
let W, H, streetY, horizonY;
let frame = 0, lastT = 0, dt = 0;

function resize() {
    W = cv.width = innerWidth;
    H = cv.height = innerHeight;
    streetY = H * 0.62;
    horizonY = H * 0.28;
    generateBuildings();
    generateSteamVents();
}

// ── PERLIN NOISE (single-octave simplex-ish) ──
const PERM = new Uint8Array(512);
(function initPerm() {
    const p = new Uint8Array(256);
    for (let i = 0; i < 256; i++) p[i] = i;
    for (let i = 255; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [p[i], p[j]] = [p[j], p[i]];
    }
    for (let i = 0; i < 512; i++) PERM[i] = p[i & 255];
})();

function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
function lerp(a, b, t) { return a + t * (b - a); }
function grad(h, x) { return (h & 1) === 0 ? x : -x; }

function noise1D(x) {
    const xi = Math.floor(x) & 255;
    const xf = x - Math.floor(x);
    return lerp(grad(PERM[xi], xf), grad(PERM[xi + 1], xf - 1), fade(xf));
}

function noise2D(x, y) {
    const xi = Math.floor(x) & 255, yi = Math.floor(y) & 255;
    const xf = x - Math.floor(x), yf = y - Math.floor(y);
    const u = fade(xf), v = fade(yf);
    const aa = PERM[PERM[xi] + yi], ab = PERM[PERM[xi] + yi + 1];
    const ba = PERM[PERM[xi + 1] + yi], bb = PERM[PERM[xi + 1] + yi + 1];
    return lerp(
        lerp(grad(aa, xf) + grad(aa, yf), grad(ba, xf - 1) + grad(ba, yf), u),
        lerp(grad(ab, xf) + grad(ab, yf - 1), grad(bb, xf - 1) + grad(bb, yf - 1), u),
        v
    ) * 0.5;
}

function fbm(x, octaves) {
    let v = 0, amp = 1, freq = 1, max = 0;
    for (let i = 0; i < octaves; i++) {
        v += noise1D(x * freq) * amp;
        max += amp; amp *= 0.5; freq *= 2;
    }
    return v / max;
}

// ── SETTINGS (with localStorage) ──
const STORAGE_KEY = 'neonNoir_settings';
const settings = {
    rain: 70, wind: 20, neon: 80, amb: 60, temp: 50, grain: 30,
    rainPaused: false, controlsVisible: true
};

function loadSettings() {
    try {
        const saved = JSON.parse(localStorage.getItem(STORAGE_KEY));
        if (saved) Object.assign(settings, saved);
    } catch(e) {}
}

function saveSettings() {
    try { localStorage.setItem(STORAGE_KEY, JSON.stringify(settings)); } catch(e) {}
}

function bindSlider(id, key) {
    const el = document.getElementById('s' + id);
    const vEl = document.getElementById('v' + id);
    el.value = settings[key];
    vEl.textContent = settings[key];
    el.oninput = () => { settings[key] = +el.value; vEl.textContent = el.value; saveSettings(); };
}

loadSettings();
bindSlider('Rain', 'rain');
bindSlider('Wind', 'wind');
bindSlider('Neon', 'neon');
bindSlider('Amb', 'amb');
bindSlider('Temp', 'temp');
bindSlider('Grain', 'grain');

const ctrlPanel = document.getElementById('controls');
if (!settings.controlsVisible) ctrlPanel.classList.add('hidden');

// ── COLOR HELPERS ──
function rgba(r, g, b, a) { return 'rgba(' + (r|0) + ',' + (g|0) + ',' + (b|0) + ',' + a.toFixed(3) + ')'; }

function tempShift(r, g, b) {
    const t = (settings.temp - 50) / 50;
    return [
        Math.min(255, r + t * 30),
        g,
        Math.min(255, b - t * 30)
    ];
}

// ── BUILDINGS (pre-generated) ──
let buildings = [];

function generateBuildings() {
    buildings = [];
    const seed = 42;
    function seededRand(i) { return ((Math.sin(seed * 9301 + i * 49297) * 0.5 + 0.5) % 1); }
    // 3 depth layers: far (0), mid (1), near (2)
    for (let layer = 0; layer < 3; layer++) {
        const count = layer === 0 ? 14 : layer === 1 ? 10 : 7;
        const minH = layer === 0 ? 0.08 : layer === 1 ? 0.12 : 0.18;
        const maxH = layer === 0 ? 0.22 : layer === 1 ? 0.32 : 0.42;
        const brightness = layer === 0 ? 12 : layer === 1 ? 8 : 5;
        for (let i = 0; i < count; i++) {
            const si = layer * 100 + i;
            const wFrac = (0.04 + seededRand(si * 3) * 0.08) * (1 + layer * 0.3);
            const hFrac = minH + seededRand(si * 7 + 1) * (maxH - minH);
            const xFrac = (i / count) + (seededRand(si * 11 + 2) - 0.5) * (0.8 / count);
            const winRows = Math.floor(hFrac * H / 18);
            const winCols = Math.floor(wFrac * W / 14);
            const windows = [];
            for (let r = 0; r < winRows; r++) {
                for (let c = 0; c < winCols; c++) {
                    if (seededRand(si * 1000 + r * 50 + c) > 0.55) {
                        const warmth = 0.15 + seededRand(si * 2000 + r * 50 + c) * 0.25;
                        windows.push({ r, c, on: true, warmth });
                    }
                }
            }
            // Roof details
            let roofDetail = null;
            const rd = seededRand(si * 17);
            if (rd > 0.75) roofDetail = 'antenna';
            else if (rd > 0.55) roofDetail = 'watertower';
            else if (rd > 0.4) roofDetail = 'ac_units';

            buildings.push({
                layer, xFrac, wFrac, hFrac, brightness,
                windows, winRows, winCols, roofDetail
            });
        }
    }
    buildings.sort((a, b) => a.layer - b.layer);
}

function drawBuildings() {
    for (const b of buildings) {
        const x = b.xFrac * W;
        const w = b.wFrac * W;
        const h = b.hFrac * H;
        const baseY = streetY;
        const topY = baseY - h;
        const depthDim = 1 - b.layer * 0.15;
        const br = b.brightness;

        // Building body
        cx.fillStyle = rgba(br, br, br + 4, depthDim);
        cx.fillRect(x, topY, w, h);

        // Subtle edge highlight
        cx.fillStyle = rgba(br + 8, br + 8, br + 12, 0.3 * depthDim);
        cx.fillRect(x, topY, 1, h);
        cx.fillRect(x + w - 1, topY, 1, h);

        // Windows
        const cellW = w / (b.winCols + 1);
        const cellH = h / (b.winRows + 1);
        for (const win of b.windows) {
            if (!win.on) continue;
            const wx = x + (win.c + 0.7) * cellW;
            const wy = topY + (win.r + 0.7) * cellH;
            const ww = cellW * 0.55;
            const wh = cellH * 0.6;
            // Window flicker
            const flick = noise1D(frame * 0.003 + win.r * 7 + win.c * 13 + b.xFrac * 100);
            if (flick > 0.3) continue; // occasionally off
            const [wr, wg, wb] = tempShift(255, 200 + win.warmth * 55, 80 + win.warmth * 80);
            cx.fillStyle = rgba(wr, wg, wb, (0.15 + win.warmth * 0.15) * depthDim);
            cx.fillRect(wx, wy, ww, wh);
        }

        // Roof details
        if (b.roofDetail === 'antenna') {
            cx.strokeStyle = rgba(30, 30, 35, 0.8 * depthDim);
            cx.lineWidth = 1.5;
            const ax = x + w * 0.3;
            cx.beginPath(); cx.moveTo(ax, topY); cx.lineTo(ax, topY - h * 0.18); cx.stroke();
            // Blinking red light
            if (Math.sin(frame * 0.04 + b.xFrac * 20) > 0.3) {
                cx.fillStyle = rgba(255, 30, 30, 0.8);
                cx.beginPath(); cx.arc(ax, topY - h * 0.18, 2, 0, Math.PI * 2); cx.fill();
                cx.shadowColor = 'rgba(255,30,30,0.6)'; cx.shadowBlur = 8;
                cx.beginPath(); cx.arc(ax, topY - h * 0.18, 2, 0, Math.PI * 2); cx.fill();
                cx.shadowBlur = 0;
            }
        } else if (b.roofDetail === 'watertower') {
            const twx = x + w * 0.55;
            const tww = w * 0.2;
            const twh = h * 0.08;
            cx.fillStyle = rgba(br + 5, br + 5, br + 8, depthDim);
            // Legs
            cx.fillRect(twx + tww * 0.15, topY - twh, 2, twh * 0.4);
            cx.fillRect(twx + tww * 0.75, topY - twh, 2, twh * 0.4);
            // Tank
            cx.beginPath();
            cx.ellipse(twx + tww / 2, topY - twh * 0.7, tww / 2, twh * 0.35, 0, 0, Math.PI * 2);
            cx.fill();
        } else if (b.roofDetail === 'ac_units') {
            for (let u = 0; u < 3; u++) {
                const ux = x + w * (0.15 + u * 0.28);
                cx.fillStyle = rgba(br + 3, br + 3, br + 5, 0.7 * depthDim);
                cx.fillRect(ux, topY - 6, w * 0.12, 6);
            }
        }
    }
}

// ── NEON SIGNS ──
const neonSigns = [
    { text: 'HOTEL', xFrac: 0.12, yFrac: 0.35, color: [255, 0, 102], vertical: false, missing: [], flickerSpeed: 0.8, size: 44 },
    { text: 'BAR', xFrac: 0.32, yFrac: 0.28, color: [0, 255, 240], vertical: false, missing: [], flickerSpeed: 1.2, size: 52 },
    { text: 'LIQUOR', xFrac: 0.52, yFrac: 0.42, color: [255, 100, 0], vertical: true, missing: [3], flickerSpeed: 0.6, size: 32 },
    { text: 'OPEN', xFrac: 0.71, yFrac: 0.32, color: [255, 40, 80], vertical: false, missing: [2], flickerSpeed: 2.0, size: 38 },
    { text: '24HR', xFrac: 0.88, yFrac: 0.38, color: [180, 50, 255], vertical: false, missing: [], flickerSpeed: 0.4, size: 36 },
    { text: 'JAZZ', xFrac: 0.05, yFrac: 0.44, color: [255, 200, 0], vertical: true, missing: [1], flickerSpeed: 1.5, size: 30 },
    { text: 'TAXI', xFrac: 0.42, yFrac: 0.26, color: [255, 220, 0], vertical: false, missing: [], flickerSpeed: 0.9, size: 28 },
    { text: 'ROOMS', xFrac: 0.62, yFrac: 0.48, color: [0, 200, 255], vertical: true, missing: [4], flickerSpeed: 1.8, size: 26 },
];

function drawNeonSigns() {
    const brightness = settings.neon / 100;
    if (brightness < 0.01) return;

    for (const sign of neonSigns) {
        const x = sign.xFrac * W;
        const baseY = sign.yFrac * H;
        const [sr, sg, sb] = tempShift(sign.color[0], sign.color[1], sign.color[2]);

        // Perlin-noise flicker per sign
        const n = fbm(frame * 0.008 * sign.flickerSpeed + sign.xFrac * 50, 3);
        const flicker = 0.6 + n * 0.5;
        const alpha = Math.max(0, Math.min(1, brightness * flicker));

        cx.save();
        cx.font = 'bold ' + sign.size + 'px "Courier New", monospace';
        cx.textAlign = 'center';
        cx.textBaseline = 'middle';

        if (sign.vertical) {
            const chars = sign.text.split('');
            chars.forEach((ch, ci) => {
                if (sign.missing.includes(ci)) {
                    // Missing letter — faint ghost
                    if (Math.sin(frame * 0.01 + ci) > 0.92) {
                        cx.globalAlpha = alpha * 0.15;
                        cx.fillStyle = rgba(sr, sg, sb, 1);
                        cx.fillText(ch, x, baseY + ci * (sign.size + 4));
                    }
                    cx.globalAlpha = 1;
                    return;
                }
                // Per-letter flicker variation
                const lFlick = noise1D(frame * 0.01 * sign.flickerSpeed + ci * 7.7);
                const la = alpha * (0.7 + lFlick * 0.4);
                // Glow halo
                cx.shadowColor = rgba(sr, sg, sb, la * 0.7);
                cx.shadowBlur = 25 + la * 20;
                cx.fillStyle = rgba(sr, sg, sb, la);
                cx.globalAlpha = 1;
                cx.fillText(ch, x, baseY + ci * (sign.size + 4));
                // Bright core
                cx.shadowBlur = 8;
                cx.fillStyle = rgba(
                    Math.min(255, sr + 80), Math.min(255, sg + 80), Math.min(255, sb + 80), la * 0.6
                );
                cx.fillText(ch, x, baseY + ci * (sign.size + 4));
            });
        } else {
            const chars = sign.text.split('');
            const totalW = cx.measureText(sign.text).width;
            const startX = x - totalW / 2;
            let curX = startX;
            chars.forEach((ch, ci) => {
                const chW = cx.measureText(ch).width;
                const drawX = curX + chW / 2;
                if (sign.missing.includes(ci)) {
                    if (Math.sin(frame * 0.012 + ci * 3) > 0.9) {
                        cx.globalAlpha = alpha * 0.12;
                        cx.shadowBlur = 5;
                        cx.shadowColor = rgba(sr, sg, sb, 0.2);
                        cx.fillStyle = rgba(sr, sg, sb, 1);
                        cx.fillText(ch, drawX, baseY);
                    }
                    curX += chW;
                    cx.globalAlpha = 1;
                    cx.shadowBlur = 0;
                    return;
                }
                const lFlick = noise1D(frame * 0.01 * sign.flickerSpeed + ci * 5.3);
                const la = alpha * (0.65 + lFlick * 0.45);
                cx.shadowColor = rgba(sr, sg, sb, la * 0.8);
                cx.shadowBlur = 22 + la * 25;
                cx.fillStyle = rgba(sr, sg, sb, la);
                cx.globalAlpha = 1;
                cx.fillText(ch, drawX, baseY);
                cx.shadowBlur = 6;
                cx.fillStyle = rgba(
                    Math.min(255, sr + 100), Math.min(255, sg + 100), Math.min(255, sb + 100), la * 0.5
                );
                cx.fillText(ch, drawX, baseY);
                curX += chW;
            });
        }
        cx.restore();
    }
}

// ── RAIN SYSTEM ──
const MAX_DROPS = 600;
const rainDrops = [];
const splashes = [];

function initRainDrop(d) {
    const layer = Math.random(); // 0=far, 1=near
    d.x = Math.random() * (W + 200) - 100;
    d.y = -10 - Math.random() * H * 0.5;
    d.layer = layer;
    d.speed = 8 + layer * 14;
    d.len = 6 + layer * 18;
    d.width = 0.4 + layer * 1.0;
    d.alpha = 0.15 + layer * 0.3;
}

for (let i = 0; i < MAX_DROPS; i++) {
    const d = {};
    initRainDrop(d);
    d.y = Math.random() * H; // spread initially
    rainDrops.push(d);
}

function updateAndDrawRain() {
    const intensity = settings.rain / 100;
    const windPx = settings.wind * 0.08;
    const activeCount = Math.floor(MAX_DROPS * intensity);

    cx.lineCap = 'round';
    for (let i = 0; i < MAX_DROPS; i++) {
        const d = rainDrops[i];
        if (i >= activeCount) { d.y = -999; continue; }

        d.y += d.speed * (0.8 + intensity * 0.4);
        d.x += windPx * (0.5 + d.layer * 0.5);

        if (d.y > streetY + 5) {
            if (Math.random() < 0.25 * intensity) {
                splashes.push({
                    x: d.x, y: streetY,
                    rings: [{ r: 0, maxR: 3 + d.layer * 8, age: 0 }],
                    alpha: 0.2 + d.layer * 0.2
                });
            }
            initRainDrop(d);
        }
        if (d.x > W + 50 || d.x < -50) initRainDrop(d);

        const angle = windPx * 0.3;
        cx.beginPath();
        cx.moveTo(d.x, d.y);
        cx.lineTo(d.x + angle * d.len * 0.1, d.y + d.len);
        cx.strokeStyle = rgba(170, 190, 220, d.alpha * intensity);
        cx.lineWidth = d.width;
        cx.stroke();
    }
}

function updateAndDrawSplashes() {
    for (let i = splashes.length - 1; i >= 0; i--) {
        const s = splashes[i];
        let alive = false;
        for (const ring of s.rings) {
            ring.age += 0.08;
            ring.r += 0.6;
            if (ring.r < ring.maxR) {
                alive = true;
                const a = s.alpha * (1 - ring.r / ring.maxR);
                cx.beginPath();
                cx.ellipse(s.x, s.y, ring.r * 2.5, ring.r * 0.6, 0, 0, Math.PI * 2);
                cx.strokeStyle = rgba(180, 200, 230, a);
                cx.lineWidth = 0.5;
                cx.stroke();
            }
        }
        if (!alive) splashes.splice(i, 1);
    }
}

// ── STREET & REFLECTIONS ──
function drawStreetAndReflections() {
    // Wet street base
    const streetGrad = cx.createLinearGradient(0, streetY, 0, H);
    streetGrad.addColorStop(0, '#14141c');
    streetGrad.addColorStop(0.3, '#111118');
    streetGrad.addColorStop(1, '#0d0d14');
    cx.fillStyle = streetGrad;
    cx.fillRect(0, streetY, W, H - streetY);

    // Road center line
    const lineY = streetY + (H - streetY) * 0.55;
    cx.fillStyle = rgba(255, 255, 100, 0.06);
    cx.fillRect(0, lineY, W, 2);

    // Curb edge
    cx.fillStyle = rgba(60, 60, 70, 0.4);
    cx.fillRect(0, streetY, W, 2);

    // Neon reflections on wet street
    const brightness = settings.neon / 100;
    for (const sign of neonSigns) {
        const sx = sign.xFrac * W;
        const [sr, sg, sb] = tempShift(sign.color[0], sign.color[1], sign.color[2]);
        const n = fbm(frame * 0.008 * sign.flickerSpeed + sign.xFrac * 50, 3);
        const flicker = 0.6 + n * 0.5;
        const alpha = Math.max(0, brightness * flicker * 0.35);

        // Wobbly reflection column
        const reflH = (H - streetY) * 0.9;
        const slices = 30;
        for (let j = 0; j < slices; j++) {
            const t = j / slices;
            const ry = streetY + t * reflH;
            const wobble = noise2D(sx * 0.01 + frame * 0.02, t * 3 + frame * 0.01) * (15 + t * 25);
            const sliceAlpha = alpha * (1 - t * 0.8);
            const spread = 40 + t * 80;

            const grad = cx.createRadialGradient(sx + wobble, ry, 0, sx + wobble, ry, spread);
            grad.addColorStop(0, rgba(sr, sg, sb, sliceAlpha));
            grad.addColorStop(1, rgba(sr, sg, sb, 0));
            cx.fillStyle = grad;
            cx.fillRect(sx + wobble - spread, ry, spread * 2, reflH / slices + 1);
        }
    }

    // Rain impact ripple distortion on reflections
    for (const s of splashes) {
        for (const ring of s.rings) {
            if (ring.r > 0 && ring.r < ring.maxR) {
                const ripA = 0.04 * (1 - ring.r / ring.maxR);
                cx.beginPath();
                cx.ellipse(s.x, s.y + 2, ring.r * 3, ring.r * 0.8, 0, 0, Math.PI * 2);
                cx.strokeStyle = rgba(160, 180, 210, ripA);
                cx.lineWidth = 1;
                cx.stroke();
            }
        }
    }
}

// ── AMBIENT: LIGHTNING ──
let lightningTimer = 0;
let lightningAlpha = 0;
let forceLightning = false;

function updateLightning() {
    const ambience = settings.amb / 100;
    if (ambience < 0.1 && !forceLightning) { lightningAlpha = 0; return; }

    if (forceLightning || (lightningTimer <= 0 && Math.random() < 0.0008 * ambience)) {
        lightningAlpha = 0.15 + Math.random() * 0.2;
        lightningTimer = 3 + Math.floor(Math.random() * 8);
        forceLightning = false;
    }

    if (lightningTimer > 0) {
        lightningTimer--;
        // Double-flash effect
        if (lightningTimer === 2) lightningAlpha *= 1.5;
    }
    lightningAlpha *= 0.75;

    if (lightningAlpha > 0.005) {
        cx.fillStyle = rgba(200, 210, 240, lightningAlpha);
        cx.fillRect(0, 0, W, streetY);
        // Reflection on street
        cx.fillStyle = rgba(180, 190, 220, lightningAlpha * 0.3);
        cx.fillRect(0, streetY, W, H - streetY);
    }
}

// ── AMBIENT: CAR HEADLIGHTS ──
const cars = [];

function updateCars() {
    const ambience = settings.amb / 100;
    if (ambience < 0.2) return;

    if (Math.random() < 0.002 * ambience && cars.length < 3) {
        const fromLeft = Math.random() > 0.5;
        cars.push({
            x: fromLeft ? -100 : W + 100,
            y: streetY + (H - streetY) * (0.3 + Math.random() * 0.3),
            speed: (fromLeft ? 1 : -1) * (1.5 + Math.random() * 2.5),
            brightness: 0.3 + Math.random() * 0.4,
            color: Math.random() > 0.7 ? [255, 60, 40] : [255, 240, 200] // tail or head
        });
    }

    for (let i = cars.length - 1; i >= 0; i--) {
        const car = cars[i];
        car.x += car.speed;

        // Headlight sweep
        const [cr, cg, cb] = car.color;
        const headGrad = cx.createRadialGradient(car.x, car.y, 0, car.x, car.y, 180);
        headGrad.addColorStop(0, rgba(cr, cg, cb, car.brightness * 0.3));
        headGrad.addColorStop(0.5, rgba(cr, cg, cb, car.brightness * 0.08));
        headGrad.addColorStop(1, rgba(cr, cg, cb, 0));
        cx.fillStyle = headGrad;
        cx.fillRect(car.x - 180, car.y - 30, 360, 60);

        // Reflection on wet street
        const refGrad = cx.createRadialGradient(car.x, car.y + 10, 0, car.x, car.y + 10, 120);
        refGrad.addColorStop(0, rgba(cr, cg, cb, car.brightness * 0.12));
        refGrad.addColorStop(1, rgba(cr, cg, cb, 0));
        cx.fillStyle = refGrad;
        cx.fillRect(car.x - 120, car.y - 5, 240, 40);

        if (car.x < -200 || car.x > W + 200) cars.splice(i, 1);
    }
}

// ── AMBIENT: STEAM VENTS ──
let steamVents = [];
const steamParticles = [];

function generateSteamVents() {
    steamVents = [];
    for (let i = 0; i < 3; i++) {
        steamVents.push({
            x: W * (0.15 + i * 0.35 + Math.random() * 0.1),
            y: streetY
        });
    }
}

function updateSteam() {
    const ambience = settings.amb / 100;
    if (ambience < 0.15) return;

    for (const vent of steamVents) {
        if (Math.random() < 0.2 * ambience) {
            steamParticles.push({
                x: vent.x + (Math.random() - 0.5) * 8,
                y: vent.y,
                vx: (Math.random() - 0.5) * 0.3 + settings.wind * 0.005,
                vy: -0.5 - Math.random() * 0.8,
                size: 3 + Math.random() * 8,
                alpha: 0.06 + Math.random() * 0.06,
                life: 1
            });
        }
    }

    for (let i = steamParticles.length - 1; i >= 0; i--) {
        const p = steamParticles[i];
        p.x += p.vx + noise1D(frame * 0.01 + i) * 0.5;
        p.y += p.vy;
        p.size += 0.15;
        p.life -= 0.008;
        p.alpha *= 0.99;

        if (p.life <= 0 || p.alpha < 0.005) {
            steamParticles.splice(i, 1);
            continue;
        }

        cx.beginPath();
        cx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        cx.fillStyle = rgba(180, 185, 200, p.alpha * p.life * ambience);
        cx.fill();
    }
}

// ── AMBIENT: DISTANT SIREN ──
let sirenAngle = 0;

function drawSiren() {
    const ambience = settings.amb / 100;
    if (ambience < 0.3) return;

    sirenAngle += 0.015;
    const cycle = Math.sin(sirenAngle);
    if (Math.abs(cycle) < 0.7) return;

    const sx = W * (0.7 + Math.sin(sirenAngle * 0.3) * 0.2);
    const sy = horizonY + 10;
    const isRed = cycle > 0;

    const color = isRed ? [255, 20, 40] : [40, 80, 255];
    const glowR = 60 + Math.abs(cycle) * 40;
    const alpha = 0.08 * ambience * Math.abs(cycle);

    const grad = cx.createRadialGradient(sx, sy, 0, sx, sy, glowR);
    grad.addColorStop(0, rgba(color[0], color[1], color[2], alpha));
    grad.addColorStop(1, rgba(color[0], color[1], color[2], 0));
    cx.fillStyle = grad;
    cx.fillRect(sx - glowR, sy - glowR, glowR * 2, glowR * 2);
}

// ── SKY ──
function drawSky() {
    const [tr, tg, tb] = tempShift(10, 10, 22);
    const grad = cx.createLinearGradient(0, 0, 0, streetY);
    grad.addColorStop(0, rgba(tr * 0.7, tg * 0.7, tb * 0.5, 1));
    grad.addColorStop(0.4, rgba(tr, tg, tb * 0.9, 1));
    grad.addColorStop(0.8, rgba(tr * 1.2, tg * 1.1, tb * 0.85, 1));
    grad.addColorStop(1, rgba(tr * 1.4, tg * 1.2, tb, 1));
    cx.fillStyle = grad;
    cx.fillRect(0, 0, W, streetY + 2);

    // Distant haze at horizon
    const hazeGrad = cx.createLinearGradient(0, horizonY - 30, 0, streetY);
    hazeGrad.addColorStop(0, rgba(20, 18, 35, 0));
    hazeGrad.addColorStop(1, rgba(20, 18, 35, 0.4));
    cx.fillStyle = hazeGrad;
    cx.fillRect(0, horizonY - 30, W, streetY - horizonY + 30);
}

// ── NEON AMBIENT GLOW (on buildings/sky) ──
function drawNeonAmbientGlow() {
    const brightness = settings.neon / 100;
    if (brightness < 0.05) return;

    for (const sign of neonSigns) {
        const sx = sign.xFrac * W;
        const sy = sign.yFrac * H;
        const [sr, sg, sb] = tempShift(sign.color[0], sign.color[1], sign.color[2]);
        const n = fbm(frame * 0.008 * sign.flickerSpeed + sign.xFrac * 50, 3);
        const alpha = brightness * (0.6 + n * 0.5) * 0.04;

        const r = 120 + brightness * 80;
        const grad = cx.createRadialGradient(sx, sy, 10, sx, sy, r);
        grad.addColorStop(0, rgba(sr, sg, sb, alpha));
        grad.addColorStop(0.5, rgba(sr, sg, sb, alpha * 0.3));
        grad.addColorStop(1, rgba(sr, sg, sb, 0));
        cx.fillStyle = grad;
        cx.fillRect(sx - r, sy - r, r * 2, r * 2);
    }
}

// ── FILM GRAIN ──
let grainData = null;
let grainCanvas = null;

function initGrain() {
    grainCanvas = document.createElement('canvas');
    grainCanvas.width = 256;
    grainCanvas.height = 256;
    grainData = grainCanvas.getContext('2d');
}
initGrain();

function drawFilmGrain() {
    const strength = settings.grain / 100;
    if (strength < 0.01) return;

    const gx = grainData;
    const id = gx.createImageData(256, 256);
    const d = id.data;
    for (let i = 0; i < d.length; i += 4) {
        const v = Math.random() * 255;
        d[i] = d[i+1] = d[i+2] = v;
        d[i+3] = strength * 18;
    }
    gx.putImageData(id, 0, 0);

    cx.save();
    cx.globalCompositeOperation = 'overlay';
    const pat = cx.createPattern(grainCanvas, 'repeat');
    cx.fillStyle = pat;
    cx.fillRect(0, 0, W, H);
    cx.restore();
}

// ── VIGNETTE ──
function drawVignette() {
    const grad = cx.createRadialGradient(W / 2, H / 2, H * 0.3, W / 2, H / 2, H * 0.85);
    grad.addColorStop(0, 'rgba(0,0,0,0)');
    grad.addColorStop(1, 'rgba(0,0,0,0.5)');
    cx.fillStyle = grad;
    cx.fillRect(0, 0, W, H);
}

// ── DISTANT FOG / ATMOSPHERE ──
function drawAtmosphere() {
    // Fog between building layers
    const fogGrad = cx.createLinearGradient(0, horizonY, 0, streetY);
    fogGrad.addColorStop(0, rgba(15, 15, 28, 0.3));
    fogGrad.addColorStop(0.5, rgba(15, 15, 28, 0.05));
    fogGrad.addColorStop(1, rgba(15, 15, 28, 0));
    cx.fillStyle = fogGrad;
    cx.fillRect(0, horizonY, W, streetY - horizonY);
}

// ── KEYBOARD SHORTCUTS ──
document.addEventListener('keydown', (e) => {
    const key = e.key.toLowerCase();
    if (key === ' ' || key === 'spacebar') {
        e.preventDefault();
        settings.rainPaused = !settings.rainPaused;
        if (settings.rainPaused) {
            settings._savedRain = settings.rain;
            settings.rain = 0;
            document.getElementById('sRain').value = 0;
            document.getElementById('vRain').textContent = '0';
        } else {
            settings.rain = settings._savedRain || 70;
            document.getElementById('sRain').value = settings.rain;
            document.getElementById('vRain').textContent = settings.rain;
        }
        saveSettings();
    } else if (key === 'l') {
        forceLightning = true;
    } else if (key === 'c') {
        settings.controlsVisible = !settings.controlsVisible;
        ctrlPanel.classList.toggle('hidden');
        saveSettings();
    } else if (key === 's' && !e.ctrlKey && !e.metaKey) {
        const link = document.createElement('a');
        link.download = 'neon-noir-' + Date.now() + '.png';
        link.href = cv.toDataURL('image/png');
        link.click();
    }
});

// ── MAIN LOOP ──
function draw(timestamp) {
    if (!lastT) lastT = timestamp;
    dt = Math.min((timestamp - lastT) / 16.67, 3);
    lastT = timestamp;
    frame++;

    // Clear
    cx.clearRect(0, 0, W, H);

    drawSky();
    drawBuildings();
    drawAtmosphere();
    drawNeonAmbientGlow();
    drawNeonSigns();
    drawSiren();
    updateLightning();
    drawStreetAndReflections();
    updateAndDrawRain();
    updateAndDrawSplashes();
    updateCars();
    updateSteam();
    drawVignette();
    drawFilmGrain();

    requestAnimationFrame(draw);
}

// Fade out hint text
setTimeout(() => {
    const h = document.getElementById('hints');
    if (h) h.style.opacity = '0';
    setTimeout(() => { if (h) h.remove(); }, 2500);
}, 6000);

// ── INIT ──
resize();
window.addEventListener('resize', resize);
requestAnimationFrame(draw);
</script>
</body>
</html>