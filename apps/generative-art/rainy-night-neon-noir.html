<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rainy Night Neon Noir</title>
    <meta name="description" content="Moody urban scene with rain-slicked streets reflecting flickering neon signs — cinematic generative noir">
    <meta name="rappterzoo:category" content="generative-art">
    <meta name="rappterzoo:title" content="Rainy Night Neon Noir">
    <meta name="rappterzoo:description" content="Stand on a rain-soaked city street at 2am. Watch neon light bleed into puddles while distant thunder rolls.">
    <meta name="rappterzoo:tags" content="rain,neon,noir,city,generative,atmospheric,moody,reflection">
    <meta name="rappterzoo:version" content="2.0">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #05050d; overflow: hidden; font-family: 'Courier New', monospace; }
        canvas { position: fixed; top: 0; left: 0; display: block; }
        #grain { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; opacity: 0.06; mix-blend-mode: overlay; }
        #ui {
            position: fixed; top: 16px; left: 16px; z-index: 100;
            background: rgba(8, 8, 20, 0.92); backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 80, 140, 0.25); border-radius: 12px;
            padding: 18px 20px; min-width: 220px; color: #cc8090;
            box-shadow: 0 0 30px rgba(255, 0, 80, 0.08);
            transition: opacity 0.3s, transform 0.3s;
        }
        #ui.hidden { opacity: 0; pointer-events: none; transform: translateX(-20px); }
        #ui h2 { font-size: 14px; color: #ff5090; margin-bottom: 14px; letter-spacing: 2px; text-transform: uppercase;
            text-shadow: 0 0 12px rgba(255, 80, 140, 0.5); }
        .ctrl { margin: 10px 0; }
        .ctrl label { display: flex; justify-content: space-between; font-size: 11px; margin-bottom: 4px; opacity: 0.7; }
        .ctrl label span { color: #ff90b0; opacity: 1; }
        input[type="range"] { -webkit-appearance: none; width: 100%; height: 4px; border-radius: 2px;
            background: rgba(255, 80, 140, 0.15); outline: none; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 14px; height: 14px;
            border-radius: 50%; background: #ff5090; cursor: pointer; box-shadow: 0 0 8px rgba(255, 80, 140, 0.5); }
        .sep { height: 1px; background: rgba(255, 80, 140, 0.12); margin: 12px 0; }
        #keys { position: fixed; bottom: 16px; left: 50%; transform: translateX(-50%);
            color: rgba(255, 120, 160, 0.35); font-size: 11px; z-index: 100; text-align: center; pointer-events: none; }
        #keys.hidden { display: none; }
    </style>
</head>
<body>
<canvas id="c"></canvas>
<canvas id="grain"></canvas>
<div id="ui">
    <h2>☔ Neon Noir</h2>
    <div class="ctrl">
        <label>Rain Intensity <span id="v-rain">70</span></label>
        <input type="range" id="s-rain" min="0" max="100" value="70">
    </div>
    <div class="ctrl">
        <label>Wind <span id="v-wind">20</span></label>
        <input type="range" id="s-wind" min="-100" max="100" value="20">
    </div>
    <div class="ctrl">
        <label>Neon Brightness <span id="v-neon">80</span></label>
        <input type="range" id="s-neon" min="0" max="100" value="80">
    </div>
    <div class="sep"></div>
    <div class="ctrl">
        <label>Reflection <span id="v-ref">65</span></label>
        <input type="range" id="s-ref" min="0" max="100" value="65">
    </div>
    <div class="ctrl">
        <label>Fog Density <span id="v-fog">30</span></label>
        <input type="range" id="s-fog" min="0" max="100" value="30">
    </div>
    <div class="ctrl">
        <label>Color Temp <span id="v-temp">50</span></label>
        <input type="range" id="s-temp" min="0" max="100" value="50">
    </div>
</div>
<div id="keys">Space: rain · L: lightning · C: toggle panel · F: fullscreen</div>

<script>
// ═══════════════════════════════════════════
// RAINY NIGHT NEON NOIR — Generative Art v2.0
// ═══════════════════════════════════════════

const C = document.getElementById('c');
const X = C.getContext('2d');
const grainC = document.getElementById('grain');
const grainX = grainC.getContext('2d');
let W, H, streetY, horizonY;

// ── Settings with localStorage persistence ──
const STORAGE_KEY = 'neon-noir-settings';
let settings = {
    rain: 70, wind: 20, neon: 80,
    ref: 65, fog: 30, temp: 50
};

function loadSettings() {
    try {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) Object.assign(settings, JSON.parse(saved));
    } catch(e) {}
    Object.keys(settings).forEach(k => {
        const el = document.getElementById('s-' + k);
        if (el) { el.value = settings[k]; updateLabel(k, settings[k]); }
    });
}
function saveSettings() {
    try { localStorage.setItem(STORAGE_KEY, JSON.stringify(settings)); } catch(e) {}
}
function updateLabel(k, v) {
    const el = document.getElementById('v-' + k);
    if (el) el.textContent = v;
}

// ── Resize ──
function resize() {
    W = C.width = grainC.width = innerWidth;
    H = C.height = grainC.height = innerHeight;
    streetY = H * 0.62;
    horizonY = H * 0.35;
    generateBuildings();
    generateGrain();
}

// ── Noise utility ──
function noise(x, y, z) {
    const p = noise.perm;
    const X = Math.floor(x) & 255, Y = Math.floor(y) & 255, Z = Math.floor(z) & 255;
    x -= Math.floor(x); y -= Math.floor(y); z -= Math.floor(z);
    const u = fade(x), v = fade(y), w = fade(z);
    const A = p[X]+Y, AA = p[A]+Z, AB = p[A+1]+Z;
    const B = p[X+1]+Y, BA = p[B]+Z, BB = p[B+1]+Z;
    return lerp(w, lerp(v, lerp(u, grad(p[AA],x,y,z), grad(p[BA],x-1,y,z)),
        lerp(u, grad(p[AB],x,y-1,z), grad(p[BB],x-1,y-1,z))),
        lerp(v, lerp(u, grad(p[AA+1],x,y,z-1), grad(p[BA+1],x-1,y,z-1)),
        lerp(u, grad(p[AB+1],x,y-1,z-1), grad(p[BB+1],x-1,y-1,z-1))));
}
function fade(t) { return t*t*t*(t*(t*6-15)+10); }
function lerp(t,a,b) { return a + t*(b-a); }
function grad(hash,x,y,z) {
    const h = hash & 15, u = h<8?x:y, v = h<4?y:h===12||h===14?x:z;
    return ((h&1)===0?u:-u) + ((h&2)===0?v:-v);
}
noise.perm = new Array(512);
(function() {
    const p = [];
    for (let i = 0; i < 256; i++) p[i] = i;
    for (let i = 255; i > 0; i--) { const j = Math.floor(Math.random()*(i+1)); [p[i],p[j]] = [p[j],p[i]]; }
    for (let i = 0; i < 512; i++) noise.perm[i] = p[i & 255];
})();

// ── Buildings (pre-generated) ──
let buildings = [];
function generateBuildings() {
    buildings = [];
    const count = Math.floor(W / 60) + 4;
    let x = -30;
    for (let i = 0; i < count; i++) {
        const w = 40 + Math.random() * 80;
        const h = 60 + Math.random() * (streetY - horizonY - 40);
        const depth = Math.random(); // 0=far, 1=close
        const dark = 0.03 + depth * 0.06;
        const windows = [];
        const floorH = 16 + Math.random() * 6;
        const winW = 6 + Math.random() * 4;
        const winGap = winW + 4 + Math.random() * 6;
        for (let wy = 12; wy < h - 10; wy += floorH) {
            for (let wx = 6; wx < w - 10; wx += winGap) {
                const lit = Math.random() > 0.55;
                if (lit) {
                    const warmth = Math.random();
                    windows.push({
                        x: wx, y: wy, w: winW, h: floorH * 0.55,
                        r: 200 + warmth * 55, g: 160 + warmth * 40, b: 80 + warmth * 30,
                        a: 0.15 + Math.random() * 0.25, flicker: Math.random() * 0.02
                    });
                }
            }
        }
        // Roof details
        const roofDetails = [];
        if (Math.random() > 0.6) {
            roofDetails.push({ type: 'antenna', x: w * (0.3 + Math.random() * 0.4), h: 15 + Math.random() * 25 });
        }
        if (Math.random() > 0.7) {
            roofDetails.push({ type: 'tank', x: w * (0.2 + Math.random() * 0.3), w: 12 + Math.random() * 10, h: 10 + Math.random() * 8 });
        }
        if (Math.random() > 0.7) {
            roofDetails.push({ type: 'ac', x: w * (0.5 + Math.random() * 0.3), w: 8, h: 6 });
        }
        buildings.push({ x, y: streetY - h, w, h, dark, windows, roofDetails, depth });
        x += w + Math.random() * 8 - 4;
    }
    buildings.sort((a, b) => a.depth - b.depth); // far buildings draw first
}

// ── Neon Signs ──
const neonSigns = [
    { text: 'HOTEL', x: 0.12, y: 0.38, color: [255, 0, 100], flicker: 0.7, size: 44, vertical: false },
    { text: 'BAR', x: 0.32, y: 0.32, color: [0, 220, 255], flicker: 0.9, size: 50, vertical: false },
    { text: 'OPEN', x: 0.55, y: 0.45, color: [255, 120, 0], flicker: 0.85, size: 36, vertical: false },
    { text: '酒', x: 0.72, y: 0.30, color: [255, 0, 180], flicker: 0.6, size: 56, vertical: false },
    { text: 'JAZZ', x: 0.88, y: 0.42, color: [120, 0, 255], flicker: 0.75, size: 38, vertical: false },
    { text: 'L O U N G E', x: 0.45, y: 0.28, color: [255, 200, 0], flicker: 0.95, size: 22, vertical: false },
    { text: 'XXX', x: 0.18, y: 0.50, color: [255, 0, 40], flicker: 0.5, size: 28, vertical: false },
    { text: 'ROOMS', x: 0.78, y: 0.52, color: [0, 255, 140], flicker: 0.8, size: 30, vertical: true },
];

// ── Rain system ──
const MAX_DROPS = 600;
let raindrops = [];
class Drop {
    constructor(init) {
        this.layer = Math.random() < 0.3 ? 0 : Math.random() < 0.5 ? 1 : 2; // 0=far, 2=close
        this.reset(init);
    }
    reset(init) {
        const s = 0.4 + this.layer * 0.3;
        this.x = Math.random() * (W + 200) - 100;
        this.y = init ? Math.random() * streetY : -10 - Math.random() * 100;
        this.speed = (8 + Math.random() * 8) * s;
        this.len = (8 + Math.random() * 16) * s;
        this.alpha = (0.15 + this.layer * 0.12) * s;
        this.width = 0.5 + this.layer * 0.4;
    }
    update(wind) {
        this.y += this.speed;
        this.x += wind * (0.5 + this.layer * 0.3);
        if (this.y > streetY) {
            if (Math.random() < 0.15 + this.layer * 0.1) {
                splashes.push(new Splash(this.x, streetY + Math.random() * 4));
            }
            this.reset(false);
        }
        if (this.x < -50 || this.x > W + 50) this.reset(false);
    }
    draw() {
        const wx = settings.wind * 0.04;
        X.beginPath();
        X.moveTo(this.x, this.y);
        X.lineTo(this.x + wx * this.len, this.y + this.len);
        X.strokeStyle = `rgba(170, 190, 220, ${this.alpha})`;
        X.lineWidth = this.width;
        X.stroke();
    }
}

// ── Splash / ripple system ──
let splashes = [];
class Splash {
    constructor(x, y) {
        this.x = x; this.y = y;
        this.rings = [{ r: 0, maxR: 3 + Math.random() * 8, alpha: 0.5 }];
        this.life = 0; this.maxLife = 20 + Math.random() * 15;
    }
    update() {
        this.life++;
        this.rings.forEach(ring => {
            ring.r += (ring.maxR - ring.r) * 0.15;
            ring.alpha *= 0.92;
        });
        return this.life < this.maxLife;
    }
    draw() {
        this.rings.forEach(ring => {
            if (ring.alpha < 0.01) return;
            X.beginPath();
            X.ellipse(this.x, this.y, ring.r * 2.5, ring.r * 0.6, 0, 0, Math.PI * 2);
            X.strokeStyle = `rgba(160, 180, 210, ${ring.alpha})`;
            X.lineWidth = 0.8;
            X.stroke();
        });
    }
}

// ── Lightning system ──
let lightning = { active: false, timer: 0, flash: 0, bolt: [] };
function triggerLightning() {
    lightning.active = true;
    lightning.flash = 1;
    lightning.timer = 0;
    lightning.bolt = generateBolt(W * (0.2 + Math.random() * 0.6), 0, streetY * 0.5, 6);
}
function generateBolt(x, y, targetY, branches) {
    const pts = [{ x, y }];
    let cx = x, cy = y;
    while (cy < targetY) {
        cx += (Math.random() - 0.5) * 40;
        cy += 5 + Math.random() * 15;
        pts.push({ x: cx, y: cy });
    }
    const result = [pts];
    if (branches > 0) {
        const branchPt = pts[Math.floor(pts.length * (0.3 + Math.random() * 0.4))];
        if (Math.random() > 0.4) {
            result.push(...generateBolt(branchPt.x, branchPt.y, branchPt.y + 30 + Math.random() * 50, branches - 2));
        }
    }
    return result;
}

// ── Car headlights ──
let cars = [];
class Car {
    constructor() {
        this.dir = Math.random() > 0.5 ? 1 : -1;
        this.x = this.dir > 0 ? -100 : W + 100;
        this.y = streetY + 20 + Math.random() * (H - streetY - 60);
        this.speed = (1 + Math.random() * 2) * this.dir;
        this.color = Math.random() > 0.3 ? [255, 240, 200] : [255, 180, 180];
        this.width = 60 + Math.random() * 40;
    }
    update() {
        this.x += this.speed;
        return (this.dir > 0) ? this.x < W + 200 : this.x > -200;
    }
    draw() {
        const [r, g, b] = this.color;
        // Headlight beams
        const beamLen = this.width * 2 * this.dir;
        const grad = X.createLinearGradient(this.x, this.y, this.x + beamLen, this.y);
        grad.addColorStop(0, `rgba(${r},${g},${b},0.12)`);
        grad.addColorStop(1, `rgba(${r},${g},${b},0)`);
        X.fillStyle = grad;
        X.beginPath();
        X.moveTo(this.x, this.y - 2);
        X.lineTo(this.x + beamLen, this.y - 15);
        X.lineTo(this.x + beamLen, this.y + 15);
        X.lineTo(this.x, this.y + 2);
        X.fill();
        // Tail lights
        const tailX = this.x - 8 * this.dir;
        X.fillStyle = this.dir > 0 ? 'rgba(255,0,0,0.5)' : 'rgba(255,0,0,0.3)';
        X.beginPath();
        X.arc(tailX, this.y, 3, 0, Math.PI * 2);
        X.fill();
    }
}

// ── Steam ──
let steamParticles = [];
const steamVents = [];
function initSteam() {
    steamVents.length = 0;
    for (let i = 0; i < 3; i++) {
        steamVents.push({ x: W * (0.15 + Math.random() * 0.7), y: streetY });
    }
}
class SteamPart {
    constructor(vent) {
        this.x = vent.x + (Math.random() - 0.5) * 10;
        this.y = vent.y;
        this.vy = -0.3 - Math.random() * 0.8;
        this.vx = (Math.random() - 0.5) * 0.3;
        this.size = 5 + Math.random() * 10;
        this.alpha = 0.1 + Math.random() * 0.12;
        this.life = 60 + Math.random() * 60;
        this.age = 0;
    }
    update(wind) {
        this.age++;
        this.x += this.vx + wind * 0.01;
        this.y += this.vy;
        this.size += 0.2;
        this.alpha *= 0.985;
        return this.age < this.life && this.alpha > 0.005;
    }
    draw() {
        X.beginPath();
        X.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        X.fillStyle = `rgba(180, 180, 200, ${this.alpha})`;
        X.fill();
    }
}

// ── Film grain (pre-rendered to offscreen canvas) ──
function generateGrain() {
    const id = grainX.createImageData(W, H);
    const d = id.data;
    for (let i = 0; i < d.length; i += 4) {
        const v = Math.random() * 255;
        d[i] = d[i+1] = d[i+2] = v;
        d[i+3] = 255;
    }
    grainX.putImageData(id, 0, 0);
}

// ── RENDER ──
let time = 0;
let uiVisible = true;
let rainPaused = false;

function drawSky() {
    const g = X.createLinearGradient(0, 0, 0, streetY);
    const fogA = settings.fog / 100;
    const tempShift = (settings.temp - 50) / 100;
    g.addColorStop(0, `rgb(${8 + fogA*15 + tempShift*10}, ${8 + fogA*10}, ${18 + fogA*5 - tempShift*5})`);
    g.addColorStop(0.4, `rgb(${14 + fogA*20 + tempShift*8}, ${12 + fogA*15}, ${24 + fogA*10 - tempShift*5})`);
    g.addColorStop(0.7, `rgb(${18 + fogA*25 + tempShift*6}, ${16 + fogA*18}, ${28 + fogA*12})`);
    g.addColorStop(1, `rgb(${22 + fogA*20}, ${18 + fogA*15}, ${30 + fogA*10})`);
    X.fillStyle = g;
    X.fillRect(0, 0, W, streetY + 2);
}

function drawBuildings() {
    buildings.forEach(b => {
        const base = Math.floor(b.dark * 255);
        X.fillStyle = `rgb(${base}, ${base}, ${Math.floor(base * 1.1)})`;
        X.fillRect(b.x, b.y, b.w, b.h);
        // Windows
        b.windows.forEach(win => {
            const flick = 1 + Math.sin(time * 60 * win.flicker + win.x * 7) * 0.1;
            X.fillStyle = `rgba(${win.r}, ${win.g}, ${win.b}, ${win.a * flick})`;
            X.fillRect(b.x + win.x, b.y + win.y, win.w, win.h);
        });
        // Roof details
        b.roofDetails.forEach(d => {
            X.fillStyle = `rgb(${Math.floor(base * 0.7)}, ${Math.floor(base * 0.7)}, ${Math.floor(base * 0.8)})`;
            if (d.type === 'antenna') {
                X.fillRect(b.x + d.x, b.y - d.h, 2, d.h);
                X.fillStyle = (Math.sin(time * 2) > 0.8) ? 'rgba(255,0,0,0.8)' : 'rgba(255,0,0,0.2)';
                X.beginPath(); X.arc(b.x + d.x + 1, b.y - d.h, 2, 0, Math.PI * 2); X.fill();
            } else if (d.type === 'tank') {
                X.fillRect(b.x + d.x, b.y - d.h, d.w, d.h);
                X.fillRect(b.x + d.x + 2, b.y - d.h - 3, d.w - 4, 3);
            } else if (d.type === 'ac') {
                X.fillRect(b.x + d.x, b.y - d.h, d.w, d.h);
            }
        });
    });
}

function drawNeonSigns() {
    const brightness = settings.neon / 100;
    if (brightness < 0.05) return;
    neonSigns.forEach(sign => {
        const sx = sign.x * W;
        const sy = sign.y * H;
        const [r, g, b] = sign.color;
        // Noise-based flicker
        const n = noise(sign.x * 10, time * sign.flicker * 3, 0);
        const flick = Math.max(0, 0.6 + n * 0.5);
        const alpha = brightness * flick;
        if (alpha < 0.05) return;
        // Outer glow halo
        X.save();
        X.shadowBlur = 40 * alpha;
        X.shadowColor = `rgba(${r}, ${g}, ${b}, ${alpha * 0.6})`;
        X.font = `bold ${sign.size}px 'Courier New', monospace`;
        X.textAlign = 'center';
        X.textBaseline = 'middle';
        if (sign.vertical) {
            X.translate(sx, sy);
            X.rotate(Math.PI / 2);
            X.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
            X.fillText(sign.text, 0, 0);
            // Double pass for glow
            X.fillText(sign.text, 0, 0);
            X.restore();
        } else {
            // Simulate broken letters
            const broken = Math.sin(time * 0.3 + sign.x * 20) > 0.97;
            if (broken && sign.text.length > 2) {
                const idx = Math.floor(noise(sign.x, time * 0.1, 5) * sign.text.length) % sign.text.length;
                const chars = sign.text.split('');
                X.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                let cx = sx - (sign.text.length * sign.size * 0.3) / 2;
                chars.forEach((ch, ci) => {
                    const charAlpha = ci === Math.abs(idx) ? alpha * 0.1 : alpha;
                    X.fillStyle = `rgba(${r}, ${g}, ${b}, ${charAlpha})`;
                    X.fillText(ch, cx + ci * sign.size * 0.6, sy);
                });
            } else {
                X.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                X.fillText(sign.text, sx, sy);
                X.fillText(sign.text, sx, sy); // double for glow
            }
            X.restore();
        }
    });
}

function drawStreet() {
    // Main street surface
    const g = X.createLinearGradient(0, streetY, 0, H);
    g.addColorStop(0, '#181820');
    g.addColorStop(0.1, '#141418');
    g.addColorStop(1, '#0c0c10');
    X.fillStyle = g;
    X.fillRect(0, streetY, W, H - streetY);
    // Road markings
    X.fillStyle = 'rgba(200, 200, 100, 0.06)';
    X.fillRect(0, streetY + (H - streetY) * 0.5, W, 2);
    // Wet sheen
    const sheenG = X.createLinearGradient(0, streetY, 0, streetY + 30);
    sheenG.addColorStop(0, 'rgba(100, 110, 140, 0.08)');
    sheenG.addColorStop(1, 'rgba(100, 110, 140, 0)');
    X.fillStyle = sheenG;
    X.fillRect(0, streetY, W, 30);
}

function drawReflections() {
    const refStrength = settings.ref / 100;
    if (refStrength < 0.05) return;
    const brightness = settings.neon / 100;
    neonSigns.forEach(sign => {
        const sx = sign.x * W;
        const [r, g, b] = sign.color;
        const n = noise(sign.x * 10, time * sign.flicker * 3, 0);
        const flick = Math.max(0, 0.6 + n * 0.5);
        const alpha = brightness * flick * refStrength * 0.25;
        if (alpha < 0.02) return;
        // Vertical reflection streak
        const refY = streetY;
        const refH = (H - streetY) * 0.8;
        const grad = X.createLinearGradient(0, refY, 0, refY + refH);
        grad.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${alpha})`);
        grad.addColorStop(0.3, `rgba(${r}, ${g}, ${b}, ${alpha * 0.5})`);
        grad.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
        // Wobble effect from rain ripples
        const wobbleAmp = 8 + settings.rain * 0.15;
        const slices = 20;
        for (let i = 0; i < slices; i++) {
            const t = i / slices;
            const oy = refY + t * refH;
            const wobble = Math.sin(time * 3 + t * 10 + sign.x * 5) * wobbleAmp * t;
            const sliceW = 60 + t * 40;
            X.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha * (1 - t * 0.8)})`;
            X.fillRect(sx - sliceW / 2 + wobble, oy, sliceW, refH / slices + 1);
        }
    });
    // Window reflections
    buildings.forEach(b => {
        b.windows.forEach(win => {
            if (win.a < 0.2) return;
            const wx = b.x + win.x + win.w / 2;
            const refAlpha = win.a * refStrength * 0.1;
            X.fillStyle = `rgba(${win.r}, ${win.g}, ${win.b}, ${refAlpha})`;
            const ry = streetY + (streetY - (b.y + win.y)) * 0.3;
            X.fillRect(wx - 3, ry, 6, 10 + Math.random() * 5);
        });
    });
}

function drawLightning() {
    if (!lightning.active) return;
    lightning.timer++;
    if (lightning.timer > 15) { lightning.active = false; return; }
    lightning.flash *= 0.7;
    // Screen flash
    X.fillStyle = `rgba(200, 210, 240, ${lightning.flash * 0.15})`;
    X.fillRect(0, 0, W, H);
    // Bolt
    if (lightning.flash > 0.2) {
        lightning.bolt.forEach(branch => {
            X.beginPath();
            X.moveTo(branch[0].x, branch[0].y);
            branch.forEach(p => X.lineTo(p.x, p.y));
            X.strokeStyle = `rgba(220, 230, 255, ${lightning.flash * 0.8})`;
            X.lineWidth = 2;
            X.stroke();
            X.strokeStyle = `rgba(180, 200, 255, ${lightning.flash * 0.3})`;
            X.lineWidth = 6;
            X.stroke();
        });
    }
}

function drawFog() {
    const fogA = settings.fog / 100;
    if (fogA < 0.05) return;
    for (let i = 0; i < 5; i++) {
        const y = horizonY + i * 30;
        const n = noise(i * 0.5, time * 0.2, 3);
        const x = n * W * 0.3;
        const grad = X.createRadialGradient(W/2 + x, y, 0, W/2 + x, y, W * 0.5);
        grad.addColorStop(0, `rgba(60, 65, 80, ${fogA * 0.06})`);
        grad.addColorStop(1, 'transparent');
        X.fillStyle = grad;
        X.fillRect(0, y - 50, W, 100);
    }
}

// ── MAIN LOOP ──
function frame() {
    time += 0.016;
    // Clear
    X.fillStyle = '#05050d';
    X.fillRect(0, 0, W, H);
    // Scene layers
    drawSky();
    drawFog();
    drawBuildings();
    drawNeonSigns();
    drawStreet();
    drawReflections();
    // Rain
    if (!rainPaused) {
        const activeCount = Math.floor(settings.rain * MAX_DROPS / 100);
        while (raindrops.length < activeCount) raindrops.push(new Drop(true));
        if (raindrops.length > activeCount) raindrops.length = activeCount;
        const wind = settings.wind * 0.06;
        raindrops.forEach(d => { d.update(wind); d.draw(); });
    }
    // Splashes
    splashes = splashes.filter(s => { const alive = s.update(); s.draw(); return alive; });
    // Steam
    steamVents.forEach(v => {
        if (Math.random() < 0.3) steamParticles.push(new SteamPart(v));
    });
    steamParticles = steamParticles.filter(p => {
        const alive = p.update(settings.wind * 0.06);
        p.draw();
        return alive;
    });
    // Cars (spawn occasionally)
    if (Math.random() < 0.002) cars.push(new Car());
    cars = cars.filter(c => { const alive = c.update(); c.draw(); return alive; });
    // Lightning
    drawLightning();
    if (!lightning.active && Math.random() < 0.0005 * (settings.rain / 50)) {
        triggerLightning();
    }
    // Vignette
    const vig = X.createRadialGradient(W/2, H/2, W*0.25, W/2, H/2, W*0.75);
    vig.addColorStop(0, 'transparent');
    vig.addColorStop(1, 'rgba(0, 0, 0, 0.4)');
    X.fillStyle = vig;
    X.fillRect(0, 0, W, H);
    requestAnimationFrame(frame);
}

// ── Input binding ──
['rain','wind','neon','ref','fog','temp'].forEach(k => {
    document.getElementById('s-' + k).addEventListener('input', e => {
        settings[k] = parseInt(e.target.value);
        updateLabel(k, settings[k]);
        saveSettings();
    });
});

document.addEventListener('keydown', e => {
    if (e.key === ' ' || e.code === 'Space') { e.preventDefault(); rainPaused = !rainPaused; }
    if (e.key === 'l' || e.key === 'L') triggerLightning();
    if (e.key === 'c' || e.key === 'C') {
        uiVisible = !uiVisible;
        document.getElementById('ui').classList.toggle('hidden', !uiVisible);
        document.getElementById('keys').classList.toggle('hidden', !uiVisible);
    }
    if (e.key === 'f' || e.key === 'F') {
        if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(() => {});
        else document.exitFullscreen();
    }
});

// ── Init ──
loadSettings();
resize();
initSteam();
for (let i = 0; i < Math.floor(settings.rain * MAX_DROPS / 100); i++) {
    raindrops.push(new Drop(true));
}
window.addEventListener('resize', () => { resize(); initSteam(); });
frame();
</script>
</body>
</html>
