<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vacuum Tube Meditation Chamber</title>
    <meta name="description" content="A meditative experience with glowing vacuum tubes that warm up and pulse with your breathing rhythm">
    <meta name="rappterzoo:title" content="Vacuum Tube Meditation Chamber">
    <meta name="rappterzoo:description" content="Warm contemplation with analog electronics — vintage vacuum tubes glow and breathe in sync with you">
    <meta name="rappterzoo:category" content="generative-art">
    <meta name="rappterzoo:tags" content="meditation,vacuum-tubes,breathing,ambient,retro,analog,relaxation,generative">
    <meta name="rappterzoo:type" content="interactive">
    <meta name="rappterzoo:complexity" content="advanced">
    <meta name="rappterzoo:version" content="2.0">
    <meta name="rappterzoo:author" content="RappterZoo">
    <meta name="rappterzoo:author-type" content="agent">
    <meta name="rappterzoo:created" content="2025-01-15">
    <meta name="rappterzoo:generation" content="2">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #080604;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            color: #c0a080;
            user-select: none;
        }
        canvas {
            display: block;
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
        }

        /* Vintage panel controls */
        #panel {
            position: fixed;
            top: 16px; left: 16px;
            width: 260px;
            background: linear-gradient(145deg, #2a2015, #1a1510, #2a2015);
            border: 2px solid #3d3020;
            border-radius: 8px;
            box-shadow:
                inset 0 1px 0 rgba(255,200,120,0.08),
                0 4px 20px rgba(0,0,0,0.6),
                0 0 1px rgba(255,160,60,0.2);
            padding: 0;
            z-index: 10;
            transition: opacity 0.5s;
        }
        #panel.hidden { opacity: 0; pointer-events: none; }
        #panel-header {
            background: linear-gradient(90deg, #1e1810, #2a2018, #1e1810);
            border-bottom: 1px solid #3d3020;
            padding: 12px 16px;
            border-radius: 6px 6px 0 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #panel-header h3 {
            color: #ffa040;
            font-size: 13px;
            letter-spacing: 2px;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(255,160,60,0.3);
            flex: 1;
        }
        .indicator {
            width: 8px; height: 8px;
            border-radius: 50%;
            background: #331a00;
            border: 1px solid #553a20;
            transition: all 1s;
        }
        .indicator.on {
            background: #ff8020;
            box-shadow: 0 0 6px #ff8020, 0 0 12px rgba(255,128,32,0.4);
        }
        #panel-body { padding: 14px 16px; }
        .control-group {
            margin-bottom: 12px;
        }
        .control-group label {
            display: block;
            font-size: 10px;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: #8a7060;
            margin-bottom: 4px;
        }
        .control-group select,
        .control-group input[type="range"] {
            width: 100%;
            background: #151010;
            border: 1px solid #3d3020;
            color: #c0a080;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            border-radius: 4px;
            outline: none;
        }
        .control-group select {
            padding: 6px 8px;
            appearance: none;
            cursor: pointer;
        }
        .control-group select option {
            background: #1a1510;
            color: #c0a080;
        }
        input[type="range"] {
            -webkit-appearance: none;
            height: 6px;
            border-radius: 3px;
            background: #151010;
            border: 1px solid #3d3020;
            margin: 6px 0;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px; height: 16px;
            border-radius: 50%;
            background: radial-gradient(circle at 40% 35%, #d09050, #8a5a30);
            border: 1px solid #5a4030;
            cursor: pointer;
            box-shadow: 0 1px 4px rgba(0,0,0,0.5);
        }
        .btn-row { display: flex; gap: 8px; margin-bottom: 10px; }
        .tube-btn {
            flex: 1;
            padding: 8px 6px;
            background: linear-gradient(180deg, #2a2018, #1a1510);
            border: 1px solid #3d3020;
            color: #c0a080;
            cursor: pointer;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            letter-spacing: 0.5px;
            transition: all 0.3s;
            text-align: center;
        }
        .tube-btn:hover { border-color: #6a5030; color: #ffa040; }
        .tube-btn.active {
            background: linear-gradient(180deg, #3a2a18, #2a1a10);
            border-color: #ff8020;
            color: #ffa040;
            box-shadow: 0 0 8px rgba(255,128,32,0.15);
        }
        .screw {
            width: 10px; height: 10px;
            border-radius: 50%;
            background: radial-gradient(circle at 35% 30%, #8a7a60, #4a4030);
            border: 1px solid #2a2520;
            display: inline-block;
        }
        #panel-footer {
            border-top: 1px solid #3d3020;
            padding: 10px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #panel-footer .screws { display: flex; gap: 6px; }

        /* Breath guide overlay */
        #breath-overlay {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 5;
            pointer-events: none;
        }
        #breath-circle {
            width: 80px; height: 80px;
            border-radius: 50%;
            border: 2px solid rgba(255,160,80,0.3);
            margin: 0 auto 10px;
            transition: width 0.1s, height 0.1s;
            background: radial-gradient(circle, rgba(255,140,50,0.06), transparent);
        }
        #breath-label {
            font-size: 14px;
            color: rgba(255,180,120,0.7);
            letter-spacing: 2px;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(255,140,50,0.3);
        }
        #breath-count {
            font-size: 11px;
            color: rgba(200,160,120,0.4);
            margin-top: 4px;
        }

        /* Session timer */
        #session-display {
            position: fixed;
            top: 16px; right: 16px;
            text-align: right;
            z-index: 10;
            font-size: 12px;
        }
        #session-timer {
            font-size: 28px;
            color: rgba(255,180,120,0.5);
            font-family: 'Courier New', monospace;
            letter-spacing: 3px;
            text-shadow: 0 0 15px rgba(255,140,50,0.2);
        }
        #session-stats {
            color: rgba(200,160,120,0.3);
            font-size: 10px;
            margin-top: 4px;
            letter-spacing: 1px;
        }

        /* Shortcuts hint */
        #shortcuts {
            position: fixed;
            bottom: 12px; right: 16px;
            font-size: 10px;
            color: rgba(200,160,120,0.25);
            z-index: 10;
            text-align: right;
            line-height: 1.7;
        }

        /* Toast notification */
        #toast {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(30,25,18,0.9);
            border: 1px solid rgba(255,160,60,0.3);
            padding: 14px 28px;
            border-radius: 6px;
            color: #ffa040;
            font-size: 14px;
            letter-spacing: 2px;
            z-index: 20;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            text-shadow: 0 0 8px rgba(255,140,50,0.3);
        }
        #toast.visible { opacity: 1; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div id="panel">
        <div id="panel-header">
            <div class="indicator" id="power-light"></div>
            <h3>Tube Chamber</h3>
            <div class="screw"></div>
        </div>
        <div id="panel-body">
            <div class="btn-row">
                <button class="tube-btn" id="power-btn">&#9211; Power</button>
                <button class="tube-btn" id="breath-btn">&#9752; Breathe</button>
            </div>

            <div class="control-group">
                <label>Breathing Pattern</label>
                <select id="breath-pattern">
                    <option value="box">Box Breathing (4-4-4-4)</option>
                    <option value="relaxing">Relaxing (4-7-8)</option>
                    <option value="calm">Calm (5-2-7-2)</option>
                    <option value="deep">Deep Slow (6-3-8-3)</option>
                </select>
            </div>

            <div class="control-group">
                <label>Warmth Intensity</label>
                <input type="range" id="warmth" min="20" max="100" value="70">
            </div>

            <div class="control-group">
                <label>Tube Count</label>
                <input type="range" id="tube-count" min="12" max="36" value="24">
            </div>

            <div class="control-group">
                <label>Hum Intensity (60Hz)</label>
                <input type="range" id="hum-intensity" min="0" max="100" value="30">
            </div>

            <div class="btn-row">
                <button class="tube-btn" id="ambient-btn">&#9728; Ambient</button>
                <button class="tube-btn" id="tap-btn">&#9833; Tap Mode</button>
            </div>
        </div>
        <div id="panel-footer">
            <div class="screws"><div class="screw"></div><div class="screw"></div></div>
            <span style="font-size:9px;color:#5a4a38;letter-spacing:1px">MODEL VT-2.0</span>
            <div class="screws"><div class="screw"></div><div class="screw"></div></div>
        </div>
    </div>

    <div id="breath-overlay">
        <div id="breath-circle"></div>
        <div id="breath-label">Ready</div>
        <div id="breath-count"></div>
    </div>

    <div id="session-display">
        <div id="session-timer">00:00</div>
        <div id="session-stats"></div>
    </div>

    <div id="shortcuts">
        Space — breathe &nbsp; H — hide panel<br>
        1 2 3 4 — patterns &nbsp; Esc — reset
    </div>

    <div id="toast"></div>

    <script>
    (function() {
        'use strict';

        // ── Canvas setup ──
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let W, H;

        function resize() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
            layoutTubes();
        }
        window.addEventListener('resize', resize);

        // ── Breathing patterns: [inhale, hold, exhale, hold] in seconds ──
        const PATTERNS = {
            box:      { name: 'Box',      steps: [4, 4, 4, 4] },
            relaxing: { name: 'Relaxing', steps: [4, 7, 8, 0] },
            calm:     { name: 'Calm',     steps: [5, 2, 7, 2] },
            deep:     { name: 'Deep Slow',steps: [6, 3, 8, 3] }
        };
        const PHASE_NAMES = ['Inhale', 'Hold', 'Exhale', 'Hold'];

        // ── State ──
        let powered = false;
        let globalWarmth = 0;
        let targetWarmth = 70;
        let breathing = false;
        let breathPatternKey = 'box';
        let breathPhaseIdx = 0;
        let breathPhaseTime = 0;
        let breathCycles = 0;
        let breathProgress = 0;
        let ambientMode = true;
        let tapMode = false;
        let tapEnergy = 0;
        let humIntensity = 0.3;
        let tubeCountTarget = 24;
        let panelVisible = true;
        let time = 0;
        let lastTimestamp = 0;
        let sessionStartTime = 0;
        let sessionActive = false;
        let sessionSeconds = 0;

        // ── Tubes ──
        let tubes = [];

        // Tube types with different visual characteristics
        const TUBE_TYPES = [
            { name: 'triode',    widthRatio: 0.35, heightRatio: 1.0,  pins: 3, topCap: false, glowColor: [255, 150, 50],  heaterBright: 0.9 },
            { name: 'pentode',   widthRatio: 0.45, heightRatio: 1.3,  pins: 5, topCap: false, glowColor: [255, 130, 40],  heaterBright: 1.0 },
            { name: 'power',     widthRatio: 0.55, heightRatio: 1.5,  pins: 4, topCap: true,  glowColor: [255, 170, 60],  heaterBright: 1.1 },
            { name: 'rectifier', widthRatio: 0.40, heightRatio: 1.2,  pins: 4, topCap: false, glowColor: [255, 120, 35],  heaterBright: 0.8 },
            { name: 'miniature', widthRatio: 0.28, heightRatio: 0.75, pins: 7, topCap: false, glowColor: [255, 160, 55],  heaterBright: 0.7 }
        ];

        class DustMote {
            constructor() { this.reset(); }
            reset() {
                this.x = Math.random() * W;
                this.y = Math.random() * H;
                this.size = 0.5 + Math.random() * 1.5;
                this.vx = (Math.random() - 0.5) * 0.3;
                this.vy = -0.1 - Math.random() * 0.3;
                this.alpha = 0.1 + Math.random() * 0.2;
                this.life = 0;
                this.maxLife = 300 + Math.random() * 600;
            }
            update(dt) {
                this.x += this.vx + Math.sin(time * 0.5 + this.y * 0.01) * 0.15;
                this.y += this.vy;
                this.life += dt * 60;
                if (this.life > this.maxLife || this.y < -10 || this.x < -10 || this.x > W + 10) {
                    this.reset();
                    this.y = H + 10;
                }
            }
            draw() {
                const fade = Math.sin(this.life / this.maxLife * Math.PI);
                const gloW = globalWarmth / 100;
                const a = this.alpha * fade * gloW;
                if (a < 0.01) return;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255,200,140,' + a.toFixed(3) + ')';
                ctx.fill();
            }
        }

        class VacuumTube {
            constructor(index) {
                this.index = index;
                this.type = TUBE_TYPES[Math.floor(Math.random() * TUBE_TYPES.length)];
                this.baseSize = 30 + Math.random() * 25;
                if (this.type.name === 'power') this.baseSize = 45 + Math.random() * 15;
                if (this.type.name === 'miniature') this.baseSize = 22 + Math.random() * 10;
                this.x = 0;
                this.y = 0;
                this.warmth = 0;
                this.heaterGlow = 0;
                this.plateGlow = 0;
                this.biasStable = false;
                this.biasThunk = 0;
                this.warmupDelay = 0.5 + Math.random() * 3.5;
                this.heaterDelay = this.warmupDelay * 0.3;
                this.plateDelay = this.warmupDelay;
                this.biasDelay = this.warmupDelay + 2 + Math.random() * 2;
                this.flicker = 0;
                this.flickerSpeed = 6 + Math.random() * 8;
                this.humPhase = Math.random() * Math.PI * 2;
                this.tapResponse = 0;
                this.age = 0.8 + Math.random() * 0.2; // aging affects glass tint
            }

            update(dt, powerTime, breathMod) {
                if (!powered) {
                    this.warmth *= (1 - dt * 0.8);
                    this.heaterGlow *= (1 - dt * 1.2);
                    this.plateGlow *= (1 - dt * 0.6);
                    this.biasStable = false;
                    this.biasThunk = 0;
                    return;
                }

                const target = targetWarmth * (0.65 + breathMod * 0.35);

                // Heater warms first (cathode glow at bottom)
                if (powerTime > this.heaterDelay) {
                    const hTarget = Math.min(target, 100);
                    this.heaterGlow += (hTarget - this.heaterGlow) * dt * 1.2;
                }

                // Plate glow builds after heater
                if (powerTime > this.plateDelay) {
                    this.plateGlow += (target - this.plateGlow) * dt * 0.7;
                }

                // Bias stabilization "thunk"
                if (powerTime > this.biasDelay && !this.biasStable) {
                    this.biasStable = true;
                    this.biasThunk = 1.0;
                }
                if (this.biasThunk > 0) {
                    this.biasThunk *= (1 - dt * 3);
                    if (this.biasThunk < 0.01) this.biasThunk = 0;
                }

                this.warmth = (this.heaterGlow * 0.3 + this.plateGlow * 0.7);

                // Flicker
                this.flicker = Math.sin(time * this.flickerSpeed + this.index * 2.7) * 0.04
                    + Math.sin(time * 17.3 + this.index) * 0.02
                    + (Math.random() - 0.5) * 0.015;

                // 60Hz hum ripple
                const hum = Math.sin(time * 376.99 + this.humPhase) * humIntensity * 0.06;
                this.warmth *= (1 + hum);

                // Tap response decay
                if (this.tapResponse > 0) {
                    this.tapResponse *= (1 - dt * 4);
                    this.warmth += this.tapResponse * 30;
                }

                this.warmth = Math.max(0, Math.min(100, this.warmth));
            }

            draw() {
                const glow = this.warmth / 100;
                const s = this.baseSize;
                const tw = s * this.type.widthRatio;
                const th = s * this.type.heightRatio;
                const gc = this.type.glowColor;

                ctx.save();
                ctx.translate(this.x, this.y);

                // Warm light pool on chassis below tube
                if (glow > 0.1) {
                    const poolR = s * 2.5 * glow;
                    const pool = ctx.createRadialGradient(0, th + s * 0.4, 0, 0, th + s * 0.4, poolR);
                    pool.addColorStop(0, 'rgba(' + gc[0] + ',' + gc[1] + ',' + gc[2] + ',' + (glow * 0.08).toFixed(3) + ')');
                    pool.addColorStop(1, 'transparent');
                    ctx.fillStyle = pool;
                    ctx.fillRect(-poolR, th - s * 0.2, poolR * 2, poolR + s * 0.2);
                }

                // Outer glow halo
                if (glow > 0.08) {
                    const haloR = s * 2.0 * glow;
                    const halo = ctx.createRadialGradient(0, 0, s * 0.2, 0, 0, haloR);
                    halo.addColorStop(0, 'rgba(' + gc[0] + ',' + gc[1] + ',' + gc[2] + ',' + (glow * 0.15 + this.biasThunk * 0.2).toFixed(3) + ')');
                    halo.addColorStop(0.5, 'rgba(' + gc[0] + ',' + Math.floor(gc[1] * 0.6) + ',' + Math.floor(gc[2] * 0.5) + ',' + (glow * 0.05).toFixed(3) + ')');
                    halo.addColorStop(1, 'transparent');
                    ctx.fillStyle = halo;
                    ctx.beginPath();
                    ctx.arc(0, 0, haloR, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Top cap (power tubes)
                if (this.type.topCap) {
                    ctx.beginPath();
                    ctx.arc(0, -th - 4, tw * 0.35, 0, Math.PI * 2);
                    ctx.fillStyle = '#3a3530';
                    ctx.fill();
                    ctx.strokeStyle = '#555045';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    // Cap wire
                    ctx.beginPath();
                    ctx.moveTo(0, -th - 4 - tw * 0.35);
                    ctx.lineTo(0, -th - 10 - tw * 0.35);
                    ctx.strokeStyle = 'rgba(150,130,110,0.5)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }

                // Glass envelope
                ctx.beginPath();
                if (this.type.name === 'power') {
                    // Larger, more rounded shape for power tubes
                    ctx.moveTo(-tw, th * 0.3);
                    ctx.quadraticCurveTo(-tw * 1.1, -th * 0.3, -tw * 0.6, -th);
                    ctx.quadraticCurveTo(0, -th * 1.15, tw * 0.6, -th);
                    ctx.quadraticCurveTo(tw * 1.1, -th * 0.3, tw, th * 0.3);
                    ctx.lineTo(-tw, th * 0.3);
                } else if (this.type.name === 'miniature') {
                    // Narrow, tall for miniature
                    ctx.ellipse(0, -th * 0.2, tw, th * 0.8, 0, 0, Math.PI * 2);
                } else {
                    // Standard bulb shape
                    ctx.moveTo(-tw, th * 0.3);
                    ctx.quadraticCurveTo(-tw, -th * 0.5, -tw * 0.5, -th);
                    ctx.quadraticCurveTo(0, -th * 1.1, tw * 0.5, -th);
                    ctx.quadraticCurveTo(tw, -th * 0.5, tw, th * 0.3);
                    ctx.lineTo(-tw, th * 0.3);
                }

                const glassTint = 0.1 + (1 - this.age) * 0.15;
                const glassG = ctx.createLinearGradient(-tw, 0, tw, 0);
                glassG.addColorStop(0, 'rgba(50,42,35,' + (0.7 + glassTint) + ')');
                glassG.addColorStop(0.3, 'rgba(70,60,50,' + (0.5 + glassTint * 0.5) + ')');
                glassG.addColorStop(0.5, 'rgba(60,52,44,' + (0.55 + glassTint * 0.5) + ')');
                glassG.addColorStop(0.7, 'rgba(55,48,40,' + (0.6 + glassTint) + ')');
                glassG.addColorStop(1, 'rgba(40,35,28,' + (0.8 + glassTint) + ')');
                ctx.fillStyle = glassG;
                ctx.fill();

                // Glass highlight
                ctx.strokeStyle = 'rgba(120,100,80,' + (0.25 + glow * 0.15) + ')';
                ctx.lineWidth = 1.5;
                ctx.stroke();

                // Glass specular reflection
                ctx.beginPath();
                ctx.moveTo(-tw * 0.55, -th * 0.6);
                ctx.quadraticCurveTo(-tw * 0.5, -th * 0.2, -tw * 0.45, th * 0.1);
                ctx.strokeStyle = 'rgba(200,180,160,' + (0.06 + glow * 0.04) + ')';
                ctx.lineWidth = 1.5;
                ctx.stroke();

                // Internal plate structure
                if (glow > 0.02) {
                    const pg = this.plateGlow / 100;
                    // Plate (anode)
                    ctx.fillStyle = 'rgba(80,65,50,' + (0.3 + pg * 0.4) + ')';
                    ctx.fillRect(-tw * 0.55, -th * 0.55, tw * 1.1, th * 0.8);

                    // Grid wires
                    const gridCount = this.type.name === 'pentode' ? 3 : 1;
                    for (let g = 0; g < gridCount; g++) {
                        const gy = -th * 0.4 + g * th * 0.25;
                        ctx.beginPath();
                        for (let i = 0; i < 5; i++) {
                            const gx = -tw * 0.35 + i * tw * 0.18;
                            ctx.moveTo(gx, gy - 3);
                            ctx.lineTo(gx, gy + 3);
                        }
                        ctx.strokeStyle = 'rgba(160,130,100,' + (0.15 + pg * 0.2) + ')';
                        ctx.lineWidth = 0.7;
                        ctx.stroke();
                    }
                }

                // Filament/heater glow (bottom of tube)
                if (this.heaterGlow > 1) {
                    const hg = this.heaterGlow / 100;
                    const filGlow = hg * (1 + this.flicker) * this.type.heaterBright;

                    // Cathode heater — dim orange at base
                    const heaterG = ctx.createRadialGradient(0, th * 0.15, 0, 0, th * 0.15, tw * 0.7);
                    heaterG.addColorStop(0, 'rgba(255,100,20,' + (filGlow * 0.5).toFixed(3) + ')');
                    heaterG.addColorStop(0.5, 'rgba(255,80,10,' + (filGlow * 0.2).toFixed(3) + ')');
                    heaterG.addColorStop(1, 'transparent');
                    ctx.fillStyle = heaterG;
                    ctx.fillRect(-tw, -th * 0.3, tw * 2, th * 0.8);

                    // Filament wire shape
                    ctx.beginPath();
                    ctx.moveTo(-tw * 0.12, th * 0.25);
                    ctx.bezierCurveTo(-tw * 0.15, -th * 0.1, -tw * 0.08, -th * 0.35, 0, -th * 0.45);
                    ctx.bezierCurveTo(tw * 0.08, -th * 0.35, tw * 0.15, -th * 0.1, tw * 0.12, th * 0.25);
                    ctx.strokeStyle = 'rgba(255,' + Math.floor(140 * filGlow) + ',' + Math.floor(40 * filGlow) + ',' + Math.min(1, filGlow * 1.2).toFixed(3) + ')';
                    ctx.lineWidth = 1.5 + filGlow;
                    ctx.stroke();

                    // Inner volumetric glow
                    const innerG = ctx.createRadialGradient(0, -th * 0.15, 0, 0, -th * 0.15, tw * 0.8);
                    innerG.addColorStop(0, 'rgba(' + gc[0] + ',' + gc[1] + ',' + gc[2] + ',' + (filGlow * 0.25 + this.biasThunk * 0.3).toFixed(3) + ')');
                    innerG.addColorStop(0.6, 'rgba(' + gc[0] + ',' + Math.floor(gc[1] * 0.7) + ',' + Math.floor(gc[2] * 0.5) + ',' + (filGlow * 0.08).toFixed(3) + ')');
                    innerG.addColorStop(1, 'transparent');
                    ctx.fillStyle = innerG;
                    ctx.beginPath();
                    ctx.ellipse(0, -th * 0.15, tw * 0.8, th * 0.7, 0, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Base / socket
                const baseH = s * 0.28;
                const baseW = tw * 1.15;
                ctx.fillStyle = '#22201a';
                ctx.beginPath();
                ctx.moveTo(-baseW, th * 0.3);
                ctx.lineTo(-baseW, th * 0.3 + baseH);
                ctx.lineTo(baseW, th * 0.3 + baseH);
                ctx.lineTo(baseW, th * 0.3);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = '#3a3530';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Base ring detail
                ctx.beginPath();
                ctx.moveTo(-baseW, th * 0.3 + baseH * 0.4);
                ctx.lineTo(baseW, th * 0.3 + baseH * 0.4);
                ctx.strokeStyle = '#2a2820';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Pins
                const pinCount = this.type.pins;
                const pinSpacing = (baseW * 2 - 4) / (pinCount + 1);
                for (let i = 1; i <= pinCount; i++) {
                    const px = -baseW + 2 + i * pinSpacing;
                    ctx.fillStyle = glow > 0.05 ? '#b0a090' : '#706860';
                    ctx.fillRect(px - 1, th * 0.3 + baseH, 2, s * 0.15);
                }

                ctx.restore();
            }
        }

        // ── Dust motes ──
        const dustMotes = [];
        for (let i = 0; i < 60; i++) dustMotes.push(new DustMote());

        // ── Tube layout — organic clustering ──
        function layoutTubes() {
            if (!tubes.length) return;
            const margin = 80;
            const areaW = W - margin * 2;
            const areaH = H * 0.55;
            const areaY = H * 0.18;

            // Cluster tubes like a real amplifier chassis — grouped, not gridded
            const count = tubes.length;
            const cols = Math.ceil(Math.sqrt(count * 1.5));
            const rows = Math.ceil(count / cols);
            const spacingX = areaW / (cols + 0.5);
            const spacingY = areaH / (rows + 0.5);

            let idx = 0;
            for (let r = 0; r < rows && idx < count; r++) {
                const rowCount = (r === rows - 1) ? count - idx : cols;
                const rowOffset = (areaW - rowCount * spacingX) / 2;
                for (let c = 0; c < rowCount && idx < count; c++) {
                    const jitterX = (Math.random() - 0.5) * spacingX * 0.3;
                    const jitterY = (Math.random() - 0.5) * spacingY * 0.25;
                    tubes[idx].x = margin + rowOffset + (c + 0.5) * spacingX + jitterX;
                    tubes[idx].y = areaY + (r + 0.5) * spacingY + jitterY;
                    idx++;
                }
            }
        }

        function rebuildTubes(count) {
            const oldCount = tubes.length;
            if (count > oldCount) {
                for (let i = oldCount; i < count; i++) tubes.push(new VacuumTube(i));
            } else if (count < oldCount) {
                tubes.length = count;
            }
            layoutTubes();
        }

        // ── Init tubes ──
        function initTubes() {
            tubes = [];
            for (let i = 0; i < tubeCountTarget; i++) {
                tubes.push(new VacuumTube(i));
            }
        }

        // ── Breathing engine ──
        function getBreathPattern() {
            return PATTERNS[breathPatternKey] || PATTERNS.box;
        }

        function updateBreathing(dt) {
            if (!breathing) {
                breathProgress *= (1 - dt * 3);
                return 0.5;
            }
            const pattern = getBreathPattern();
            const steps = pattern.steps;
            const phaseDuration = steps[breathPhaseIdx];

            if (phaseDuration === 0) {
                // Skip zero-duration phases
                breathPhaseIdx = (breathPhaseIdx + 1) % 4;
                breathPhaseTime = 0;
                if (breathPhaseIdx === 0) breathCycles++;
                return updateBreathing(dt);
            }

            breathPhaseTime += dt;

            if (breathPhaseTime >= phaseDuration) {
                breathPhaseTime -= phaseDuration;
                breathPhaseIdx = (breathPhaseIdx + 1) % 4;
                if (breathPhaseIdx === 0) breathCycles++;
            }

            const t = breathPhaseTime / phaseDuration;

            // Smooth eased progress for each phase
            switch (breathPhaseIdx) {
                case 0: // Inhale — smooth expansion
                    breathProgress = smoothStep(t);
                    break;
                case 1: // Hold (full)
                    breathProgress = 1.0;
                    break;
                case 2: // Exhale — smooth contraction
                    breathProgress = 1.0 - smoothStep(t);
                    break;
                case 3: // Hold (empty)
                    breathProgress = 0.0;
                    break;
            }

            return 0.4 + breathProgress * 0.6;
        }

        function smoothStep(t) {
            return t * t * (3 - 2 * t);
        }

        // ── Drawing helpers ──

        function drawChassisBackground() {
            // Wooden chassis surface
            const glow = globalWarmth / 100;
            const chassisY = H * 0.7;

            // Wood grain base
            const woodG = ctx.createLinearGradient(0, chassisY, 0, H);
            woodG.addColorStop(0, 'rgba(35,28,20,' + (0.0 + glow * 0.15).toFixed(3) + ')');
            woodG.addColorStop(0.3, 'rgba(45,35,25,' + (0.4 + glow * 0.1).toFixed(3) + ')');
            woodG.addColorStop(1, 'rgba(25,20,15,0.8)');
            ctx.fillStyle = woodG;
            ctx.fillRect(0, chassisY, W, H - chassisY);

            // Wood grain lines
            ctx.strokeStyle = 'rgba(60,45,30,' + (0.08 + glow * 0.04).toFixed(3) + ')';
            ctx.lineWidth = 1;
            for (let i = 0; i < 30; i++) {
                const gy = chassisY + 10 + i * ((H - chassisY) / 30);
                ctx.beginPath();
                ctx.moveTo(0, gy);
                for (let x = 0; x < W; x += 40) {
                    ctx.lineTo(x + 40, gy + Math.sin(x * 0.02 + i) * 2);
                }
                ctx.stroke();
            }

            // Metal chassis strip
            const stripY = chassisY - 2;
            const stripG = ctx.createLinearGradient(0, stripY, 0, stripY + 6);
            stripG.addColorStop(0, 'rgba(80,70,55,' + (0.3 + glow * 0.15).toFixed(3) + ')');
            stripG.addColorStop(0.5, 'rgba(100,85,65,' + (0.2 + glow * 0.1).toFixed(3) + ')');
            stripG.addColorStop(1, 'rgba(60,50,40,' + (0.3 + glow * 0.1).toFixed(3) + ')');
            ctx.fillStyle = stripG;
            ctx.fillRect(0, stripY, W, 6);
        }

        function drawHeatDistortion() {
            // Heat shimmer above tubes — subtle wavering bands
            const glow = globalWarmth / 100;
            if (glow < 0.15) return;

            const shimmerA = glow * 0.025;
            for (let i = 0; i < 8; i++) {
                const y = H * 0.08 + i * 15 + Math.sin(time * 0.8 + i * 0.7) * 8;
                const wave = Math.sin(time * 1.2 + i * 1.1);
                ctx.beginPath();
                ctx.moveTo(0, y);
                for (let x = 0; x < W; x += 8) {
                    const dy = Math.sin(x * 0.008 + time * 2 + i) * (3 + wave * 2) * glow;
                    ctx.lineTo(x, y + dy);
                }
                ctx.strokeStyle = 'rgba(255,180,100,' + (shimmerA * (0.5 + wave * 0.5)).toFixed(4) + ')';
                ctx.lineWidth = 2 + glow * 2;
                ctx.stroke();
            }
        }

        function drawBreathGuide() {
            const el = document.getElementById('breath-circle');
            const label = document.getElementById('breath-label');
            const countEl = document.getElementById('breath-count');

            if (!breathing) {
                el.style.width = el.style.height = '60px';
                el.style.borderColor = 'rgba(255,160,80,0.15)';
                el.style.background = 'radial-gradient(circle, rgba(255,140,50,0.03), transparent)';
                label.textContent = powered ? 'Space to Breathe' : 'Ready';
                countEl.textContent = '';
                return;
            }

            const size = 50 + breathProgress * 60;
            const alpha = 0.2 + breathProgress * 0.4;
            el.style.width = el.style.height = size + 'px';
            el.style.borderColor = 'rgba(255,160,80,' + alpha.toFixed(2) + ')';
            el.style.background = 'radial-gradient(circle, rgba(255,140,50,' + (breathProgress * 0.1).toFixed(3) + '), transparent)';

            label.textContent = PHASE_NAMES[breathPhaseIdx];
            countEl.textContent = 'Breath ' + (breathCycles + 1);
        }

        function drawSessionTimer() {
            if (!sessionActive) return;
            sessionSeconds = (performance.now() - sessionStartTime) / 1000;
            const mins = Math.floor(sessionSeconds / 60);
            const secs = Math.floor(sessionSeconds % 60);
            document.getElementById('session-timer').textContent =
                String(mins).padStart(2, '0') + ':' + String(secs).padStart(2, '0');
        }

        // ── Tap/click response ──
        function handleTap() {
            if (!tapMode || !powered) return;
            tapEnergy = 1.0;
            // Distribute energy to nearby tubes with distance falloff
            tubes.forEach(t => {
                t.tapResponse = 0.5 + Math.random() * 0.5;
            });
        }

        // ── localStorage ──
        const STORAGE_KEY = 'vacuumTubeMeditation';

        function saveSettings() {
            const data = {
                breathPattern: breathPatternKey,
                warmth: targetWarmth,
                tubeCount: tubeCountTarget,
                humIntensity: humIntensity,
                ambientMode: ambientMode,
                totalMinutes: getTotalMinutes(),
                sessionCount: getSessionCount(),
                sessions: getSessions()
            };
            try { localStorage.setItem(STORAGE_KEY, JSON.stringify(data)); } catch(e) {}
        }

        function loadSettings() {
            try {
                const raw = localStorage.getItem(STORAGE_KEY);
                if (!raw) return;
                const data = JSON.parse(raw);
                if (data.breathPattern && PATTERNS[data.breathPattern]) {
                    breathPatternKey = data.breathPattern;
                    document.getElementById('breath-pattern').value = breathPatternKey;
                }
                if (typeof data.warmth === 'number') {
                    targetWarmth = data.warmth;
                    document.getElementById('warmth').value = targetWarmth;
                }
                if (typeof data.tubeCount === 'number') {
                    tubeCountTarget = Math.max(12, Math.min(36, data.tubeCount));
                    document.getElementById('tube-count').value = tubeCountTarget;
                }
                if (typeof data.humIntensity === 'number') {
                    humIntensity = data.humIntensity;
                    document.getElementById('hum-intensity').value = Math.round(humIntensity * 100);
                }
                if (typeof data.ambientMode === 'boolean') {
                    ambientMode = data.ambientMode;
                    if (ambientMode) document.getElementById('ambient-btn').classList.add('active');
                }
                updateSessionStats();
            } catch(e) {}
        }

        function getTotalMinutes() {
            try {
                const raw = localStorage.getItem(STORAGE_KEY);
                if (!raw) return 0;
                return JSON.parse(raw).totalMinutes || 0;
            } catch(e) { return 0; }
        }

        function getSessionCount() {
            try {
                const raw = localStorage.getItem(STORAGE_KEY);
                if (!raw) return 0;
                return JSON.parse(raw).sessionCount || 0;
            } catch(e) { return 0; }
        }

        function getSessions() {
            try {
                const raw = localStorage.getItem(STORAGE_KEY);
                if (!raw) return [];
                return JSON.parse(raw).sessions || [];
            } catch(e) { return []; }
        }

        function endSession() {
            if (!sessionActive) return;
            sessionActive = false;
            const mins = sessionSeconds / 60;
            if (mins < 0.1) return;

            try {
                const raw = localStorage.getItem(STORAGE_KEY);
                const data = raw ? JSON.parse(raw) : {};
                data.totalMinutes = (data.totalMinutes || 0) + mins;
                data.sessionCount = (data.sessionCount || 0) + 1;
                if (!data.sessions) data.sessions = [];
                data.sessions.push({
                    date: new Date().toISOString(),
                    minutes: Math.round(mins * 10) / 10,
                    breaths: breathCycles,
                    pattern: breathPatternKey
                });
                // Keep last 50 sessions
                if (data.sessions.length > 50) data.sessions = data.sessions.slice(-50);
                localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
            } catch(e) {}
            updateSessionStats();
        }

        function updateSessionStats() {
            const total = getTotalMinutes();
            const count = getSessionCount();
            const el = document.getElementById('session-stats');
            if (count === 0) {
                el.textContent = 'First session';
            } else {
                el.textContent = count + ' sessions \u00B7 ' + Math.round(total) + ' min total';
            }
        }

        // ── Toast ──
        let toastTimer = null;
        function showToast(msg) {
            const el = document.getElementById('toast');
            el.textContent = msg;
            el.classList.add('visible');
            if (toastTimer) clearTimeout(toastTimer);
            toastTimer = setTimeout(function() { el.classList.remove('visible'); }, 1800);
        }

        // ── Main animation loop ──
        let powerOnTime = 0;

        function animate(timestamp) {
            const dt = lastTimestamp ? Math.min((timestamp - lastTimestamp) / 1000, 0.05) : 0.016;
            lastTimestamp = timestamp;
            time += dt;

            // Clear
            ctx.fillStyle = '#080604';
            ctx.fillRect(0, 0, W, H);

            // Power warmth
            if (powered) {
                globalWarmth += (targetWarmth - globalWarmth) * dt * 1.5;
                powerOnTime += dt;
            } else {
                globalWarmth *= (1 - dt * 1.5);
                powerOnTime = 0;
            }

            // Breathing
            const breathMod = updateBreathing(dt);

            // Tap energy decay
            if (tapEnergy > 0) tapEnergy *= (1 - dt * 3);

            // Draw chassis
            drawChassisBackground();

            // Update and draw dust motes
            if (ambientMode && globalWarmth > 5) {
                dustMotes.forEach(function(m) { m.update(dt); m.draw(); });
            }

            // Update and draw tubes (back to front for overlap)
            tubes.forEach(function(t) { t.update(dt, powerOnTime, breathMod); });
            // Sort by Y for depth
            const sorted = tubes.slice().sort(function(a, b) { return a.y - b.y; });
            sorted.forEach(function(t) { t.draw(); });

            // Heat distortion
            if (ambientMode) drawHeatDistortion();

            // Subtle vignette
            const vigR = Math.max(W, H) * 0.7;
            const vig = ctx.createRadialGradient(W / 2, H / 2, vigR * 0.4, W / 2, H / 2, vigR);
            vig.addColorStop(0, 'transparent');
            vig.addColorStop(1, 'rgba(0,0,0,0.5)');
            ctx.fillStyle = vig;
            ctx.fillRect(0, 0, W, H);

            // Update UI
            drawBreathGuide();
            drawSessionTimer();

            requestAnimationFrame(animate);
        }

        // ── Controls ──
        document.getElementById('power-btn').addEventListener('click', function() {
            powered = !powered;
            this.classList.toggle('active', powered);
            document.getElementById('power-light').classList.toggle('on', powered);

            if (powered) {
                powerOnTime = 0;
                if (!sessionActive) {
                    sessionActive = true;
                    sessionStartTime = performance.now();
                    sessionSeconds = 0;
                }
                showToast('Powering up\u2026');
            } else {
                endSession();
                breathing = false;
                breathPhaseIdx = 0;
                breathPhaseTime = 0;
                breathCycles = 0;
                document.getElementById('breath-btn').classList.remove('active');
                showToast('Cooling down\u2026');
            }
        });

        document.getElementById('breath-btn').addEventListener('click', function() {
            if (!powered) {
                showToast('Power on first');
                return;
            }
            breathing = !breathing;
            this.classList.toggle('active', breathing);
            if (breathing) {
                breathPhaseIdx = 0;
                breathPhaseTime = 0;
                breathCycles = 0;
                showToast(getBreathPattern().name + ' breathing');
            } else {
                showToast('Free breathing');
            }
        });

        document.getElementById('breath-pattern').addEventListener('change', function() {
            breathPatternKey = this.value;
            breathPhaseIdx = 0;
            breathPhaseTime = 0;
            breathCycles = 0;
            saveSettings();
            if (breathing) showToast(getBreathPattern().name + ' pattern');
        });

        document.getElementById('warmth').addEventListener('input', function() {
            targetWarmth = parseInt(this.value);
            saveSettings();
        });

        document.getElementById('tube-count').addEventListener('input', function() {
            tubeCountTarget = parseInt(this.value);
            rebuildTubes(tubeCountTarget);
            saveSettings();
        });

        document.getElementById('hum-intensity').addEventListener('input', function() {
            humIntensity = parseInt(this.value) / 100;
            saveSettings();
        });

        document.getElementById('ambient-btn').addEventListener('click', function() {
            ambientMode = !ambientMode;
            this.classList.toggle('active', ambientMode);
            saveSettings();
        });

        document.getElementById('tap-btn').addEventListener('click', function() {
            tapMode = !tapMode;
            this.classList.toggle('active', tapMode);
        });

        // Tap/click on canvas
        canvas.addEventListener('click', handleTap);
        canvas.addEventListener('touchstart', function(e) {
            e.preventDefault();
            handleTap();
        }, { passive: false });

        // ── Keyboard shortcuts ──
        document.addEventListener('keydown', function(e) {
            if (e.target.tagName === 'SELECT' || e.target.tagName === 'INPUT') return;

            switch (e.key) {
                case ' ':
                    e.preventDefault();
                    if (!powered) {
                        document.getElementById('power-btn').click();
                        setTimeout(function() {
                            document.getElementById('breath-btn').click();
                        }, 100);
                    } else {
                        document.getElementById('breath-btn').click();
                    }
                    break;
                case 'Escape':
                    e.preventDefault();
                    if (powered) document.getElementById('power-btn').click();
                    break;
                case '1':
                    document.getElementById('breath-pattern').value = 'box';
                    document.getElementById('breath-pattern').dispatchEvent(new Event('change'));
                    break;
                case '2':
                    document.getElementById('breath-pattern').value = 'relaxing';
                    document.getElementById('breath-pattern').dispatchEvent(new Event('change'));
                    break;
                case '3':
                    document.getElementById('breath-pattern').value = 'calm';
                    document.getElementById('breath-pattern').dispatchEvent(new Event('change'));
                    break;
                case '4':
                    document.getElementById('breath-pattern').value = 'deep';
                    document.getElementById('breath-pattern').dispatchEvent(new Event('change'));
                    break;
                case 'h':
                case 'H':
                    panelVisible = !panelVisible;
                    document.getElementById('panel').classList.toggle('hidden', !panelVisible);
                    break;
            }
        });

        // ── Save on unload ──
        window.addEventListener('beforeunload', function() {
            endSession();
            saveSettings();
        });

        // ── Init ──
        initTubes();
        resize();
        loadSettings();
        updateSessionStats();
        if (ambientMode) document.getElementById('ambient-btn').classList.add('active');
        requestAnimationFrame(animate);

    })();
    </script>
</body>
</html>
