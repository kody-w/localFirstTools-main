<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vacuum Tube Meditation Chamber</title>
    <meta name="description" content="Meditate with hypnotic glowing vacuum tubes that pulse with your breathing rhythm — warm analog warmth meets mindfulness">
    <meta name="rappterzoo:category" content="generative-art">
    <meta name="rappterzoo:title" content="Vacuum Tube Meditation Chamber">
    <meta name="rappterzoo:description" content="A meditation space where vintage vacuum tubes warm up and pulse in sync with your breathing. Analog warmth meets mindfulness.">
    <meta name="rappterzoo:tags" content="meditation,vacuum-tube,breathing,retro,analog,warmth,mindfulness,generative">
    <meta name="rappterzoo:version" content="2.0">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #080604; overflow: hidden; font-family: 'Courier New', monospace; }
        canvas { position: fixed; top: 0; left: 0; display: block; }

        #panel {
            position: fixed; top: 16px; right: 16px; z-index: 100;
            background: linear-gradient(135deg, rgba(50,35,20,0.95), rgba(35,25,15,0.95));
            border: 2px solid rgba(160,100,40,0.4); border-radius: 14px;
            padding: 20px; min-width: 240px; color: #c09060;
            box-shadow: 0 4px 30px rgba(0,0,0,0.5), inset 0 1px 0 rgba(200,150,80,0.1);
            transition: opacity 0.3s, transform 0.3s;
        }
        #panel.hidden { opacity: 0; pointer-events: none; transform: translateX(20px); }
        #panel h2 { font-size: 13px; letter-spacing: 3px; text-transform: uppercase;
            color: #ffa040; text-shadow: 0 0 10px rgba(255,160,60,0.4); margin-bottom: 16px;
            border-bottom: 1px solid rgba(160,100,40,0.3); padding-bottom: 10px; }
        .grp { margin: 14px 0; }
        .grp-label { font-size: 10px; text-transform: uppercase; letter-spacing: 1px; opacity: 0.5; margin-bottom: 8px; }
        .ctrl { margin: 8px 0; display: flex; align-items: center; gap: 10px; }
        .ctrl label { font-size: 11px; flex: 1; opacity: 0.8; }
        .ctrl span { font-size: 11px; color: #ffb060; min-width: 24px; text-align: right; }
        input[type="range"] { -webkit-appearance: none; width: 100px; height: 4px; border-radius: 2px;
            background: rgba(160,100,40,0.2); outline: none; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 14px; height: 14px;
            border-radius: 50%; background: #d08030; cursor: pointer; box-shadow: 0 0 8px rgba(200,120,40,0.4); }
        select { background: rgba(50,35,20,0.8); border: 1px solid rgba(160,100,40,0.3);
            color: #c09060; padding: 4px 8px; border-radius: 6px; font-family: inherit; font-size: 11px; width: 100%; }
        .btn { display: block; width: 100%; padding: 10px; margin: 6px 0; cursor: pointer;
            background: rgba(160,100,40,0.15); border: 1px solid rgba(160,100,40,0.35);
            color: #c09060; border-radius: 8px; font-family: inherit; font-size: 12px;
            transition: background 0.2s; text-align: center; }
        .btn:hover { background: rgba(160,100,40,0.3); }
        .btn.active { background: rgba(200,120,40,0.3); border-color: rgba(255,160,60,0.5); color: #ffb060; }
        .sep { height: 1px; background: rgba(160,100,40,0.15); margin: 14px 0; }

        #breath-ring {
            position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%); z-index: 50;
            pointer-events: none; text-align: center;
        }
        #breath-ring canvas { display: block; margin: 0 auto; }
        #breath-label { color: rgba(255,180,100,0.6); font-size: 14px; margin-top: 8px;
            font-family: 'Courier New', monospace; letter-spacing: 2px; }
        #breath-count { color: rgba(255,180,100,0.3); font-size: 11px; margin-top: 4px;
            font-family: 'Courier New', monospace; }

        #session-info {
            position: fixed; top: 16px; left: 16px; z-index: 100;
            color: rgba(200,150,100,0.4); font-size: 11px; line-height: 1.8;
        }
        #session-info.hidden { display: none; }

        #keys { position: fixed; bottom: 16px; right: 16px; z-index: 100;
            color: rgba(200,150,100,0.25); font-size: 10px; text-align: right; line-height: 1.8; }
    </style>
</head>
<body>
<canvas id="c"></canvas>
<div id="panel">
    <h2>◉ Tube Chamber</h2>
    <div class="grp">
        <div class="grp-label">Breathing Pattern</div>
        <select id="pattern">
            <option value="box">Box Breathing (4-4-4-4)</option>
            <option value="relaxing">Relaxing (4-7-8)</option>
            <option value="calm">Calm (5-5-5)</option>
            <option value="energize">Energize (2-1-4-0)</option>
        </select>
    </div>
    <div class="sep"></div>
    <div class="grp">
        <div class="grp-label">Tube Controls</div>
        <div class="ctrl">
            <label>Warmth</label>
            <input type="range" id="s-warmth" min="10" max="100" value="75">
            <span id="v-warmth">75</span>
        </div>
        <div class="ctrl">
            <label>Hum</label>
            <input type="range" id="s-hum" min="0" max="100" value="40">
            <span id="v-hum">40</span>
        </div>
        <div class="ctrl">
            <label>Dust</label>
            <input type="range" id="s-dust" min="0" max="100" value="50">
            <span id="v-dust">50</span>
        </div>
    </div>
    <div class="sep"></div>
    <button class="btn" id="btn-power">⏻ Power On</button>
    <button class="btn" id="btn-breathe">Start Breathing Guide</button>
    <div class="sep"></div>
    <div class="grp">
        <div class="grp-label">Session</div>
        <div id="timer" style="text-align:center;font-size:20px;color:#ffa040;margin:8px 0;">0:00</div>
        <div id="total-sessions" style="font-size:10px;opacity:0.5;text-align:center;">Total: 0 sessions · 0 min</div>
    </div>
</div>

<div id="breath-ring">
    <canvas id="breathCanvas" width="160" height="160"></canvas>
    <div id="breath-label"></div>
    <div id="breath-count"></div>
</div>

<div id="session-info">
    <div id="sess-display"></div>
</div>

<div id="keys">
    Space: breathe · P: power<br>
    1-4: patterns · C: panel<br>
    Esc: reset session
</div>

<script>
// ═══════════════════════════════════════════════
// VACUUM TUBE MEDITATION CHAMBER v2.0
// ═══════════════════════════════════════════════

const C = document.getElementById('c');
const X = C.getContext('2d');
const BC = document.getElementById('breathCanvas');
const BX = BC.getContext('2d');
let W, H;

// ── Settings & Persistence ──
const STORE = 'vacuum-tube-meditation';
let cfg = {
    warmth: 75, hum: 40, dust: 50,
    pattern: 'box', totalMinutes: 0, totalSessions: 0
};
function load() {
    try { const s = localStorage.getItem(STORE); if (s) Object.assign(cfg, JSON.parse(s)); } catch(e) {}
    ['warmth','hum','dust'].forEach(k => {
        const el = document.getElementById('s-' + k);
        if (el) { el.value = cfg[k]; document.getElementById('v-' + k).textContent = cfg[k]; }
    });
    document.getElementById('pattern').value = cfg.pattern;
    updateTotalDisplay();
}
function save() {
    try { localStorage.setItem(STORE, JSON.stringify(cfg)); } catch(e) {}
}
function updateTotalDisplay() {
    document.getElementById('total-sessions').textContent =
        `Total: ${cfg.totalSessions} sessions · ${cfg.totalMinutes} min`;
}

// ── Breathing patterns: [inhale, hold, exhale, hold] in seconds ──
const patterns = {
    box: { name: 'Box', times: [4, 4, 4, 4], labels: ['Inhale', 'Hold', 'Exhale', 'Hold'] },
    relaxing: { name: 'Relaxing', times: [4, 7, 8, 0], labels: ['Inhale', 'Hold', 'Exhale', ''] },
    calm: { name: 'Calm', times: [5, 5, 5, 0], labels: ['Inhale', 'Hold', 'Exhale', ''] },
    energize: { name: 'Energize', times: [2, 1, 4, 0], labels: ['Inhale', 'Hold', 'Exhale', ''] },
};

// ── State ──
let powered = false;
let globalWarmth = 0;
let breathing = false;
let breathPhase = 0;   // 0-3 = inhale/hold/exhale/hold
let breathTimer = 0;
let breathValue = 0;   // 0=empty, 1=full
let breathCycles = 0;
let sessionStart = 0;
let sessionElapsed = 0;
let time = 0;
let panelVisible = true;

// ── Resize ──
function resize() {
    W = C.width = innerWidth;
    H = C.height = innerHeight;
    generateTubes();
}

// ── Tube types ──
const TUBE_TYPES = [
    { name: 'triode', wRatio: 0.35, hRatio: 1.0, capType: 'round', pins: 5 },
    { name: 'pentode', wRatio: 0.4, hRatio: 1.2, capType: 'dome', pins: 7 },
    { name: 'power', wRatio: 0.5, hRatio: 1.4, capType: 'flat', pins: 8 },
    { name: 'rectifier', wRatio: 0.45, hRatio: 1.1, capType: 'bullet', pins: 4 },
    { name: 'small', wRatio: 0.3, hRatio: 0.7, capType: 'round', pins: 7 },
];

let tubes = [];
class Tube {
    constructor(x, y, size, type) {
        this.x = x; this.y = y;
        this.size = size;
        this.type = type;
        this.warmth = 0;
        this.targetWarmth = 0;
        this.startDelay = 0.5 + Math.random() * 4;
        this.startTime = -1;
        this.flickerSeed = Math.random() * 100;
        this.humPhase = Math.random() * Math.PI * 2;
        this.cathodeGlow = 0;
        this.plateGlow = 0;
        this.stabilized = false;
        this.thunkTime = -1;
        this.rw = size * type.wRatio;
        this.rh = size * type.hRatio;
    }

    update(dt, gWarmth, breathMod, t) {
        if (!powered) {
            this.warmth *= 0.995;
            this.cathodeGlow *= 0.99;
            this.plateGlow *= 0.99;
            if (this.warmth < 0.5) { this.stabilized = false; this.startTime = -1; }
            return;
        }
        if (this.startTime < 0) this.startTime = t;
        const elapsed = t - this.startTime;
        if (elapsed < this.startDelay) return;

        const age = elapsed - this.startDelay;
        // Cathode heater first (0-2s), then plate (2-5s)
        this.cathodeGlow = Math.min(1, age / 2);
        this.plateGlow = Math.min(1, Math.max(0, (age - 1.5) / 3));

        // Thunk moment (bias stabilization)
        if (!this.stabilized && age > 3 + this.startDelay) {
            this.stabilized = true;
            this.thunkTime = t;
        }

        const target = gWarmth * this.plateGlow;
        const breathTarget = target * (0.7 + breathMod * 0.3);
        this.warmth += (breathTarget - this.warmth) * 0.03;

        // 60Hz hum modulation
        const humAmt = cfg.hum / 100;
        const hum = Math.sin(t * Math.PI * 120 + this.humPhase) * humAmt * 0.03;
        this.warmth += hum * this.warmth;
    }

    draw(t) {
        const cx = this.x, cy = this.y;
        const rw = this.rw, rh = this.rh;
        const glow = this.warmth / 100;
        const type = this.type;

        X.save();
        X.translate(cx, cy);

        // Ambient glow halo
        if (glow > 0.05) {
            const haloR = rh * 1.8 * glow;
            const halo = X.createRadialGradient(0, -rh * 0.2, rh * 0.2, 0, -rh * 0.2, haloR);
            halo.addColorStop(0, `rgba(255, 150, 50, ${glow * 0.15})`);
            halo.addColorStop(0.5, `rgba(255, 100, 30, ${glow * 0.05})`);
            halo.addColorStop(1, 'transparent');
            X.fillStyle = halo;
            X.fillRect(-haloR, -rh - haloR * 0.5, haloR * 2, haloR * 2);
        }

        // Glass envelope
        X.beginPath();
        if (type.capType === 'round') {
            X.ellipse(0, -rh * 0.1, rw, rh, 0, 0, Math.PI * 2);
        } else if (type.capType === 'dome') {
            X.moveTo(-rw, rh * 0.5);
            X.lineTo(-rw, -rh * 0.3);
            X.quadraticCurveTo(-rw, -rh * 0.9, 0, -rh * 0.9);
            X.quadraticCurveTo(rw, -rh * 0.9, rw, -rh * 0.3);
            X.lineTo(rw, rh * 0.5);
            X.closePath();
        } else if (type.capType === 'bullet') {
            X.moveTo(-rw, rh * 0.5);
            X.lineTo(-rw, -rh * 0.4);
            X.quadraticCurveTo(0, -rh * 1.1, rw, -rh * 0.4);
            X.lineTo(rw, rh * 0.5);
            X.closePath();
        } else {
            X.moveTo(-rw, rh * 0.5);
            X.lineTo(-rw, -rh * 0.7);
            X.lineTo(rw, -rh * 0.7);
            X.lineTo(rw, rh * 0.5);
            X.closePath();
        }
        // Glass fill
        const glass = X.createLinearGradient(-rw, 0, rw, 0);
        glass.addColorStop(0, 'rgba(50, 40, 35, 0.7)');
        glass.addColorStop(0.3, 'rgba(70, 60, 50, 0.5)');
        glass.addColorStop(0.7, 'rgba(50, 40, 35, 0.6)');
        glass.addColorStop(1, 'rgba(35, 30, 25, 0.8)');
        X.fillStyle = glass;
        X.fill();
        X.strokeStyle = 'rgba(120, 100, 70, 0.4)';
        X.lineWidth = 1.5;
        X.stroke();

        // Cathode heater glow (bottom, dim orange)
        if (this.cathodeGlow > 0.05) {
            const cg = this.cathodeGlow;
            const heater = X.createRadialGradient(0, rh * 0.3, 0, 0, rh * 0.3, rw * 0.8);
            heater.addColorStop(0, `rgba(255, 80, 20, ${cg * 0.4})`);
            heater.addColorStop(0.5, `rgba(255, 50, 10, ${cg * 0.15})`);
            heater.addColorStop(1, 'transparent');
            X.fillStyle = heater;
            X.fillRect(-rw, rh * 0.1, rw * 2, rh * 0.5);
        }

        // Plate glow / internal filament
        if (glow > 0.03) {
            const flick = 1 + Math.sin(t * 8 + this.flickerSeed) * 0.05 + Math.sin(t * 23.7 + this.flickerSeed * 3) * 0.03;
            const g = glow * flick;
            // Filament structure
            X.beginPath();
            X.moveTo(-rw * 0.25, rh * 0.35);
            X.quadraticCurveTo(-rw * 0.15, 0, -rw * 0.2, -rh * 0.35);
            X.quadraticCurveTo(0, -rh * 0.45, rw * 0.2, -rh * 0.35);
            X.quadraticCurveTo(rw * 0.15, 0, rw * 0.25, rh * 0.35);
            X.strokeStyle = `rgba(255, ${Math.floor(130 * g + 50)}, ${Math.floor(40 * g)}, ${g * 0.9})`;
            X.lineWidth = 1.5 + g;
            X.stroke();

            // Internal glow
            const inner = X.createRadialGradient(0, -rh * 0.1, 0, 0, -rh * 0.1, rh * 0.6);
            inner.addColorStop(0, `rgba(255, 160, 60, ${g * 0.25})`);
            inner.addColorStop(0.5, `rgba(255, 100, 30, ${g * 0.08})`);
            inner.addColorStop(1, 'transparent');
            X.fillStyle = inner;
            X.fillRect(-rw, -rh, rw * 2, rh * 2);

            // Glass reflection of glow
            X.beginPath();
            X.ellipse(-rw * 0.55, -rh * 0.2, rw * 0.12, rh * 0.3, 0.2, 0, Math.PI * 2);
            X.fillStyle = `rgba(255, 200, 150, ${g * 0.06})`;
            X.fill();
        }

        // Thunk flash
        if (this.thunkTime > 0 && t - this.thunkTime < 0.3) {
            const flash = 1 - (t - this.thunkTime) / 0.3;
            X.fillStyle = `rgba(255, 200, 100, ${flash * 0.2})`;
            X.fillRect(-rw * 1.5, -rh * 1.5, rw * 3, rh * 3);
        }

        // Base / socket
        X.fillStyle = '#1a1510';
        const baseH = rh * 0.25;
        X.fillRect(-rw * 0.9, rh * 0.5, rw * 1.8, baseH);
        X.strokeStyle = 'rgba(100, 80, 50, 0.5)';
        X.strokeRect(-rw * 0.9, rh * 0.5, rw * 1.8, baseH);

        // Pins
        const pinCount = type.pins;
        for (let i = 0; i < pinCount; i++) {
            const px = -rw * 0.6 + (rw * 1.2 / (pinCount - 1)) * i;
            X.fillStyle = 'rgba(160, 140, 100, 0.6)';
            X.fillRect(px - 1, rh * 0.5 + baseH, 2, 8);
        }

        X.restore();
    }
}

function generateTubes() {
    tubes = [];
    const cols = Math.max(4, Math.floor(W / 140));
    const rows = Math.max(2, Math.floor(H / 200));
    const spX = W / (cols + 1);
    const spY = (H - 120) / (rows + 1);
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            const x = spX * (c + 1) + (Math.random() - 0.5) * spX * 0.3;
            const y = spY * (r + 1) + 40 + (Math.random() - 0.5) * spY * 0.2;
            const size = 30 + Math.random() * 20;
            const type = TUBE_TYPES[Math.floor(Math.random() * TUBE_TYPES.length)];
            tubes.push(new Tube(x, y, size, type));
        }
    }
}

// ── Dust motes ──
let dustMotes = [];
class DustMote {
    constructor() { this.reset(); }
    reset() {
        this.x = Math.random() * W;
        this.y = Math.random() * H;
        this.vx = (Math.random() - 0.5) * 0.2;
        this.vy = -0.1 - Math.random() * 0.2;
        this.size = 0.5 + Math.random() * 1.5;
        this.alpha = 0.05 + Math.random() * 0.15;
        this.life = 200 + Math.random() * 400;
        this.age = 0;
    }
    update() {
        this.age++;
        this.x += this.vx + Math.sin(time * 0.5 + this.y * 0.01) * 0.1;
        this.y += this.vy;
        if (this.age > this.life || this.y < -10 || this.x < -10 || this.x > W + 10) this.reset();
    }
    draw() {
        // Only visible near warm tubes
        let illum = 0;
        tubes.forEach(t => {
            if (t.warmth < 5) return;
            const dx = this.x - t.x, dy = this.y - t.y;
            const d = Math.sqrt(dx * dx + dy * dy);
            if (d < 120) illum += (t.warmth / 100) * (1 - d / 120);
        });
        if (illum < 0.02) return;
        illum = Math.min(1, illum);
        X.beginPath();
        X.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        X.fillStyle = `rgba(255, 200, 140, ${this.alpha * illum})`;
        X.fill();
    }
}

// ── Wooden chassis surface ──
function drawChassis() {
    // Dark wood background
    const g = X.createLinearGradient(0, 0, 0, H);
    g.addColorStop(0, '#0c0a06');
    g.addColorStop(0.3, '#0a0804');
    g.addColorStop(0.7, '#0e0b07');
    g.addColorStop(1, '#080604');
    X.fillStyle = g;
    X.fillRect(0, 0, W, H);
    // Subtle wood grain horizontal lines
    X.globalAlpha = 0.015;
    for (let y = 0; y < H; y += 3 + Math.random() * 5) {
        X.fillStyle = Math.random() > 0.5 ? '#3a2a18' : '#2a1a0c';
        X.fillRect(0, y, W, 1);
    }
    X.globalAlpha = 1;
}

// ── Heat shimmer ──
function drawHeatShimmer(t) {
    tubes.forEach(tube => {
        if (tube.warmth < 20) return;
        const intensity = (tube.warmth / 100) * 0.03;
        for (let i = 0; i < 3; i++) {
            const yOff = -tube.rh * (1.2 + i * 0.5);
            const xWobble = Math.sin(t * 3 + i * 2 + tube.flickerSeed) * 8;
            const shimW = tube.rw * 1.5;
            X.fillStyle = `rgba(255, 180, 100, ${intensity * (1 - i * 0.3)})`;
            X.beginPath();
            X.ellipse(tube.x + xWobble, tube.y + yOff, shimW, 4, 0, 0, Math.PI * 2);
            X.fill();
        }
    });
}

// ── Breathing engine ──
function updateBreathing(dt) {
    if (!breathing) return;
    const pat = patterns[cfg.pattern];
    const phaseDur = pat.times[breathPhase];
    if (phaseDur === 0) {
        // Skip zero-duration phases
        breathPhase = (breathPhase + 1) % 4;
        breathTimer = 0;
        if (breathPhase === 0) breathCycles++;
        return;
    }
    breathTimer += dt;
    const progress = Math.min(1, breathTimer / phaseDur);
    // Smooth breath value
    if (breathPhase === 0) breathValue += (1 - breathValue) * (dt / phaseDur * 3); // inhale
    else if (breathPhase === 2) breathValue += (0 - breathValue) * (dt / phaseDur * 3); // exhale
    // hold phases: breathValue stays
    if (breathTimer >= phaseDur) {
        breathTimer = 0;
        breathPhase = (breathPhase + 1) % 4;
        if (breathPhase === 0) breathCycles++;
    }
    // Update labels
    const label = pat.labels[breathPhase];
    const remaining = Math.ceil(phaseDur - breathTimer);
    document.getElementById('breath-label').textContent = label ? `${label} · ${remaining}s` : '';
    document.getElementById('breath-count').textContent = `Cycle ${breathCycles + 1}`;
}

function drawBreathRing(t) {
    BX.clearRect(0, 0, 160, 160);
    if (!breathing) {
        BX.beginPath();
        BX.arc(80, 80, 30, 0, Math.PI * 2);
        BX.strokeStyle = 'rgba(255, 180, 100, 0.1)';
        BX.lineWidth = 2;
        BX.stroke();
        return;
    }
    const r = 20 + breathValue * 40;
    // Glow
    const grad = BX.createRadialGradient(80, 80, r * 0.5, 80, 80, r * 1.5);
    grad.addColorStop(0, `rgba(255, 160, 60, ${0.1 + breathValue * 0.1})`);
    grad.addColorStop(1, 'transparent');
    BX.fillStyle = grad;
    BX.fillRect(0, 0, 160, 160);
    // Ring
    BX.beginPath();
    BX.arc(80, 80, r, 0, Math.PI * 2);
    BX.strokeStyle = `rgba(255, 180, 100, ${0.3 + breathValue * 0.4})`;
    BX.lineWidth = 3;
    BX.stroke();
    // Phase arc
    const pat = patterns[cfg.pattern];
    const phaseDur = pat.times[breathPhase] || 1;
    const progress = breathTimer / phaseDur;
    BX.beginPath();
    BX.arc(80, 80, r + 6, -Math.PI / 2, -Math.PI / 2 + progress * Math.PI * 2);
    BX.strokeStyle = `rgba(255, 200, 100, 0.5)`;
    BX.lineWidth = 2;
    BX.stroke();
}

// ── Session timer ──
function updateSession() {
    if (!powered) return;
    if (sessionStart === 0) sessionStart = Date.now();
    sessionElapsed = Math.floor((Date.now() - sessionStart) / 1000);
    const min = Math.floor(sessionElapsed / 60);
    const sec = sessionElapsed % 60;
    document.getElementById('timer').textContent =
        `${min}:${sec.toString().padStart(2, '0')}`;
}

function endSession() {
    if (sessionElapsed > 30) {
        cfg.totalSessions++;
        cfg.totalMinutes += Math.floor(sessionElapsed / 60);
        save();
        updateTotalDisplay();
    }
    sessionStart = 0;
    sessionElapsed = 0;
    document.getElementById('timer').textContent = '0:00';
}

// ── Vignette ──
function drawVignette() {
    const vig = X.createRadialGradient(W / 2, H / 2, Math.min(W, H) * 0.3, W / 2, H / 2, Math.max(W, H) * 0.7);
    vig.addColorStop(0, 'transparent');
    vig.addColorStop(1, 'rgba(0, 0, 0, 0.5)');
    X.fillStyle = vig;
    X.fillRect(0, 0, W, H);
}

// ── Main loop ──
let lastT = 0;
function frame(ts) {
    const dt = Math.min(0.05, (ts - lastT) / 1000);
    lastT = ts;
    time += dt;

    globalWarmth = powered ? cfg.warmth : 0;
    const breathMod = breathing ? breathValue : 0.5;

    drawChassis();

    // Update & draw tubes
    tubes.forEach(t => t.update(dt, globalWarmth, breathMod, time));
    // Draw heat shimmer behind tubes
    drawHeatShimmer(time);
    tubes.forEach(t => t.draw(time));

    // Dust
    const dustCount = Math.floor(cfg.dust * 1.5);
    while (dustMotes.length < dustCount) dustMotes.push(new DustMote());
    if (dustMotes.length > dustCount) dustMotes.length = dustCount;
    dustMotes.forEach(d => { d.update(); d.draw(); });

    // Warm light pool on "floor"
    if (powered && globalWarmth > 10) {
        const poolGrad = X.createRadialGradient(W / 2, H + 50, 0, W / 2, H + 50, H * 0.5);
        poolGrad.addColorStop(0, `rgba(200, 120, 40, ${globalWarmth / 100 * 0.04})`);
        poolGrad.addColorStop(1, 'transparent');
        X.fillStyle = poolGrad;
        X.fillRect(0, H * 0.5, W, H * 0.5);
    }

    drawVignette();
    updateBreathing(dt);
    drawBreathRing(time);
    updateSession();

    requestAnimationFrame(frame);
}

// ── Controls ──
['warmth', 'hum', 'dust'].forEach(k => {
    document.getElementById('s-' + k).addEventListener('input', e => {
        cfg[k] = parseInt(e.target.value);
        document.getElementById('v-' + k).textContent = cfg[k];
        save();
    });
});

document.getElementById('pattern').addEventListener('change', e => {
    cfg.pattern = e.target.value;
    breathPhase = 0; breathTimer = 0;
    save();
});

document.getElementById('btn-power').addEventListener('click', function() {
    powered = !powered;
    this.textContent = powered ? '⏻ Power Off' : '⏻ Power On';
    this.classList.toggle('active', powered);
    if (!powered) endSession();
});

document.getElementById('btn-breathe').addEventListener('click', function() {
    breathing = !breathing;
    this.textContent = breathing ? 'Stop Breathing Guide' : 'Start Breathing Guide';
    this.classList.toggle('active', breathing);
    if (breathing) { breathPhase = 0; breathTimer = 0; breathCycles = 0; breathValue = 0; }
    else { document.getElementById('breath-label').textContent = ''; document.getElementById('breath-count').textContent = ''; }
});

document.addEventListener('keydown', e => {
    if (e.code === 'Space') {
        e.preventDefault();
        document.getElementById('btn-breathe').click();
    }
    if (e.key === 'p' || e.key === 'P') document.getElementById('btn-power').click();
    if (e.key === 'c' || e.key === 'C') {
        panelVisible = !panelVisible;
        document.getElementById('panel').classList.toggle('hidden', !panelVisible);
    }
    if (e.key === 'Escape') { endSession(); breathing = false; breathPhase = 0; breathTimer = 0;
        document.getElementById('btn-breathe').textContent = 'Start Breathing Guide';
        document.getElementById('btn-breathe').classList.remove('active');
        document.getElementById('breath-label').textContent = '';
        document.getElementById('breath-count').textContent = '';
    }
    if (e.key >= '1' && e.key <= '4') {
        const keys = ['box', 'relaxing', 'calm', 'energize'];
        const idx = parseInt(e.key) - 1;
        if (keys[idx]) {
            cfg.pattern = keys[idx];
            document.getElementById('pattern').value = cfg.pattern;
            breathPhase = 0; breathTimer = 0;
            save();
        }
    }
});

// ── Init ──
load();
resize();
window.addEventListener('resize', resize);
requestAnimationFrame(frame);
</script>
</body>
</html>
