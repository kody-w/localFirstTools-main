<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vacuum Tube Meditation Chamber</title>
    <meta name="description" content="A meditative experience with glowing vacuum tubes that warm up and pulse with your breathing rhythm">
    <meta name="rappterzoo:title" content="Vacuum Tube Meditation Chamber">
    <meta name="rappterzoo:description" content="Warm contemplation with analog electronics - vintage vacuum tubes glow and breathe in sync with you">
    <meta name="rappterzoo:category" content="generative-art">
    <meta name="rappterzoo:tags" content="meditation,vacuum-tubes,breathing,ambient,retro,analog,relaxation,generative">
    <meta name="rappterzoo:type" content="interactive">
    <meta name="rappterzoo:complexity" content="advanced">
    <meta name="rappterzoo:version" content="2.0">
    <meta name="rappterzoo:author" content="RappterZoo">
    <meta name="rappterzoo:author-type" content="agent">
    <meta name="rappterzoo:created" content="2025-01-15">
    <meta name="rappterzoo:generation" content="2">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #080604;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            color: #c0a080;
            user-select: none;
        }
        canvas {
            display: block;
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
        }
        #panel {
            position: fixed;
            top: 16px; left: 16px;
            width: 260px;
            background: linear-gradient(145deg, #2a2015, #1a1510, #2a2015);
            border: 2px solid #3d3020;
            border-radius: 8px;
            box-shadow: inset 0 1px 0 rgba(255,200,120,0.08), 0 4px 20px rgba(0,0,0,0.6), 0 0 1px rgba(255,160,60,0.2);
            padding: 0;
            z-index: 10;
            transition: opacity 0.5s;
        }
        #panel.hidden { opacity: 0; pointer-events: none; }
        #panel-header {
            background: linear-gradient(90deg, #1e1810, #2a2018, #1e1810);
            border-bottom: 1px solid #3d3020;
            padding: 12px 16px;
            border-radius: 6px 6px 0 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #panel-header h3 {
            color: #ffa040;
            font-size: 13px;
            letter-spacing: 2px;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(255,160,60,0.3);
            flex: 1;
        }
        .indicator {
            width: 8px; height: 8px;
            border-radius: 50%;
            background: #331a00;
            border: 1px solid #553a20;
            transition: all 1s;
        }
        .indicator.on {
            background: #ff8020;
            box-shadow: 0 0 6px #ff8020, 0 0 12px rgba(255,128,32,0.4);
        }
        #panel-body { padding: 14px 16px; }
        .control-group { margin-bottom: 12px; }
        .control-group label {
            display: block;
            font-size: 10px;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: #8a7060;
            margin-bottom: 4px;
        }
        .control-group select, .control-group input[type="range"] {
            width: 100%;
            background: #151010;
            border: 1px solid #3d3020;
            color: #c0a080;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            border-radius: 4px;
            outline: none;
        }
        .control-group select { padding: 6px 8px; appearance: none; cursor: pointer; }
        .control-group select option { background: #1a1510; color: #c0a080; }
        input[type="range"] {
            -webkit-appearance: none;
            height: 6px;
            border-radius: 3px;
            background: #151010;
            border: 1px solid #3d3020;
            margin: 6px 0;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px; height: 16px;
            border-radius: 50%;
            background: radial-gradient(circle at 40% 35%, #d09050, #8a5a30);
            border: 1px solid #5a4030;
            cursor: pointer;
            box-shadow: 0 1px 4px rgba(0,0,0,0.5);
        }
        .btn-row { display: flex; gap: 8px; margin-bottom: 10px; }
        .tube-btn {
            flex: 1;
            padding: 8px 6px;
            background: linear-gradient(180deg, #2a2018, #1a1510);
            border: 1px solid #3d3020;
            color: #c0a080;
            cursor: pointer;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            letter-spacing: 0.5px;
            transition: all 0.3s;
            text-align: center;
        }
        .tube-btn:hover { border-color: #6a5030; color: #ffa040; }
        .tube-btn.active {
            background: linear-gradient(180deg, #3a2a18, #2a1a10);
            border-color: #ff8020;
            color: #ffa040;
            box-shadow: 0 0 8px rgba(255,128,32,0.15);
        }
        .screw {
            width: 10px; height: 10px;
            border-radius: 50%;
            background: radial-gradient(circle at 35% 30%, #8a7a60, #4a4030);
            border: 1px solid #2a2520;
            display: inline-block;
        }
        #panel-footer {
            border-top: 1px solid #3d3020;
            padding: 10px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #panel-footer .screws { display: flex; gap: 6px; }
        #breath-overlay {
            position: fixed;
            bottom: 40px; left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 5;
            pointer-events: none;
        }
        #breath-circle {
            width: 80px; height: 80px;
            border-radius: 50%;
            border: 2px solid rgba(255,160,80,0.3);
            margin: 0 auto 10px;
            background: radial-gradient(circle, rgba(255,140,50,0.06), transparent);
        }
        #breath-label {
            font-size: 14px;
            color: rgba(255,180,120,0.7);
            letter-spacing: 2px;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(255,140,50,0.3);
        }
        #breath-count {
            font-size: 11px;
            color: rgba(200,160,120,0.4);
            margin-top: 4px;
        }
        #session-display {
            position: fixed;
            top: 16px; right: 16px;
            text-align: right;
            z-index: 10;
        }
        #session-timer {
            font-size: 28px;
            color: rgba(255,180,120,0.5);
            font-family: 'Courier New', monospace;
            letter-spacing: 3px;
            text-shadow: 0 0 15px rgba(255,140,50,0.2);
        }
        #session-stats {
            color: rgba(200,160,120,0.3);
            font-size: 10px;
            margin-top: 4px;
            letter-spacing: 1px;
        }
        #shortcuts {
            position: fixed;
            bottom: 12px; right: 16px;
            font-size: 10px;
            color: rgba(200,160,120,0.25);
            z-index: 10;
            text-align: right;
            line-height: 1.7;
        }
        #toast {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(30,25,18,0.9);
            border: 1px solid rgba(255,160,60,0.3);
            padding: 14px 28px;
            border-radius: 6px;
            color: #ffa040;
            font-size: 14px;
            letter-spacing: 2px;
            z-index: 20;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            text-shadow: 0 0 8px rgba(255,140,50,0.3);
        }
        #toast.visible { opacity: 1; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="panel">
        <div id="panel-header">
            <div class="indicator" id="power-light"></div>
            <h3>Tube Chamber</h3>
            <div class="screw"></div>
        </div>
        <div id="panel-body">
            <div class="btn-row">
                <button class="tube-btn" id="power-btn">&#9211; Power</button>
                <button class="tube-btn" id="breath-btn">&#9752; Breathe</button>
            </div>
            <div class="control-group">
                <label>Breathing Pattern</label>
                <select id="breath-pattern">
                    <option value="box">Box Breathing (4-4-4-4)</option>
                    <option value="relaxing">Relaxing (4-7-8)</option>
                    <option value="calm">Calm (5-2-7-2)</option>
                    <option value="deep">Deep Slow (6-3-8-3)</option>
                </select>
            </div>
            <div class="control-group">
                <label>Warmth Intensity</label>
                <input type="range" id="warmth" min="20" max="100" value="70">
            </div>
            <div class="control-group">
                <label>Tube Count</label>
                <input type="range" id="tube-count" min="12" max="36" value="24">
            </div>
            <div class="control-group">
                <label>Hum Intensity (60Hz)</label>
                <input type="range" id="hum-intensity" min="0" max="100" value="30">
            </div>
            <div class="btn-row">
                <button class="tube-btn" id="ambient-btn">&#9728; Ambient</button>
                <button class="tube-btn" id="tap-btn">&#9833; Tap Mode</button>
            </div>
        </div>
        <div id="panel-footer">
            <div class="screws"><div class="screw"></div><div class="screw"></div></div>
            <span style="font-size:9px;color:#5a4a38;letter-spacing:1px">MODEL VT-2.0</span>
            <div class="screws"><div class="screw"></div><div class="screw"></div></div>
        </div>
    </div>
    <div id="breath-overlay">
        <div id="breath-circle"></div>
        <div id="breath-label">Ready</div>
        <div id="breath-count"></div>
    </div>
    <div id="session-display">
        <div id="session-timer">00:00</div>
        <div id="session-stats"></div>
    </div>
    <div id="shortcuts">
        Space &mdash; breathe &nbsp; H &mdash; hide panel<br>
        1 2 3 4 &mdash; patterns &nbsp; Esc &mdash; reset
    </div>
    <div id="toast"></div>
    <script>
    (function() {
        'use strict';
        var canvas = document.getElementById('canvas');
        var ctx = canvas.getContext('2d');
        var W, H;
        function resize() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
            layoutTubes();
        }
        window.addEventListener('resize', resize);

        // Breathing patterns: [inhale, hold, exhale, hold] seconds
        var PATTERNS = {
            box:      { name: 'Box',       steps: [4, 4, 4, 4] },
            relaxing: { name: 'Relaxing',  steps: [4, 7, 8, 0] },
            calm:     { name: 'Calm',      steps: [5, 2, 7, 2] },
            deep:     { name: 'Deep Slow', steps: [6, 3, 8, 3] }
        };
        var PHASE_NAMES = ['Inhale', 'Hold', 'Exhale', 'Hold'];

        // State
        var powered = false, globalWarmth = 0, targetWarmth = 70;
        var breathing = false, breathPatternKey = 'box';
        var breathPhaseIdx = 0, breathPhaseTime = 0, breathCycles = 0, breathProgress = 0;
        var ambientMode = true, tapMode = false, tapEnergy = 0;
        var humIntensity = 0.3, tubeCountTarget = 24;
        var panelVisible = true, time = 0, lastTimestamp = 0;
        var sessionStartTime = 0, sessionActive = false, sessionSeconds = 0;
        var tubes = [], powerOnTime = 0;

        // Tube types with visual characteristics
        var TUBE_TYPES = [
            { name: 'triode',    wr: 0.35, hr: 1.0,  pins: 3, topCap: false, gc: [255,150,50],  hb: 0.9 },
            { name: 'pentode',   wr: 0.45, hr: 1.3,  pins: 5, topCap: false, gc: [255,130,40],  hb: 1.0 },
            { name: 'power',     wr: 0.55, hr: 1.5,  pins: 4, topCap: true,  gc: [255,170,60],  hb: 1.1 },
            { name: 'rectifier', wr: 0.40, hr: 1.2,  pins: 4, topCap: false, gc: [255,120,35],  hb: 0.8 },
            { name: 'mini',      wr: 0.28, hr: 0.75, pins: 7, topCap: false, gc: [255,160,55],  hb: 0.7 }
        ];

        // Dust mote class
        function DustMote() { this.reset(true); }
        DustMote.prototype.reset = function(initial) {
            this.x = Math.random() * (W || 800);
            this.y = initial ? Math.random() * (H || 600) : (H || 600) + 10;
            this.sz = 0.5 + Math.random() * 1.5;
            this.vx = (Math.random() - 0.5) * 0.3;
            this.vy = -0.1 - Math.random() * 0.3;
            this.alpha = 0.1 + Math.random() * 0.2;
            this.life = 0;
            this.maxLife = 300 + Math.random() * 600;
        };
        DustMote.prototype.update = function(dt) {
            this.x += this.vx + Math.sin(time * 0.5 + this.y * 0.01) * 0.15;
            this.y += this.vy;
            this.life += dt * 60;
            if (this.life > this.maxLife || this.y < -10 || this.x < -10 || this.x > W + 10) {
                this.reset(false);
            }
        };
        DustMote.prototype.draw = function() {
            var fade = Math.sin(this.life / this.maxLife * Math.PI);
            var gW = globalWarmth / 100;
            var a = this.alpha * fade * gW;
            if (a < 0.01) return;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.sz, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255,200,140,' + a.toFixed(3) + ')';
            ctx.fill();
        };

        var dustMotes = [];
        for (var dm = 0; dm < 60; dm++) dustMotes.push(new DustMote());

        // Vacuum Tube class
        function VacuumTube(index) {
            this.index = index;
            this.type = TUBE_TYPES[Math.floor(Math.random() * TUBE_TYPES.length)];
            this.baseSize = 30 + Math.random() * 25;
            if (this.type.name === 'power') this.baseSize = 45 + Math.random() * 15;
            if (this.type.name === 'mini') this.baseSize = 22 + Math.random() * 10;
            this.x = 0; this.y = 0;
            this.warmth = 0; this.heaterGlow = 0; this.plateGlow = 0;
            this.biasStable = false; this.biasThunk = 0;
            this.warmupDelay = 0.5 + Math.random() * 3.5;
            this.heaterDelay = this.warmupDelay * 0.3;
            this.plateDelay = this.warmupDelay;
            this.biasDelay = this.warmupDelay + 2 + Math.random() * 2;
            this.flicker = 0;
            this.flickerSpeed = 6 + Math.random() * 8;
            this.humPhase = Math.random() * Math.PI * 2;
            this.tapResponse = 0;
            this.age = 0.8 + Math.random() * 0.2;
        }
        VacuumTube.prototype.update = function(dt, pTime, breathMod) {
            if (!powered) {
                this.warmth *= (1 - dt * 0.8);
                this.heaterGlow *= (1 - dt * 1.2);
                this.plateGlow *= (1 - dt * 0.6);
                this.biasStable = false; this.biasThunk = 0;
                return;
            }
            var target = targetWarmth * (0.65 + breathMod * 0.35);
            if (pTime > this.heaterDelay) {
                this.heaterGlow += (Math.min(target, 100) - this.heaterGlow) * dt * 1.2;
            }
            if (pTime > this.plateDelay) {
                this.plateGlow += (target - this.plateGlow) * dt * 0.7;
            }
            if (pTime > this.biasDelay && !this.biasStable) {
                this.biasStable = true;
                this.biasThunk = 1.0;
            }
            if (this.biasThunk > 0) {
                this.biasThunk *= (1 - dt * 3);
                if (this.biasThunk < 0.01) this.biasThunk = 0;
            }
            this.warmth = this.heaterGlow * 0.3 + this.plateGlow * 0.7;
            this.flicker = Math.sin(time * this.flickerSpeed + this.index * 2.7) * 0.04
                + Math.sin(time * 17.3 + this.index) * 0.02
                + (Math.random() - 0.5) * 0.015;
            var hum = Math.sin(time * 376.99 + this.humPhase) * humIntensity * 0.06;
            this.warmth *= (1 + hum);
            if (this.tapResponse > 0) {
                this.tapResponse *= (1 - dt * 4);
                this.warmth += this.tapResponse * 30;
            }
            this.warmth = Math.max(0, Math.min(100, this.warmth));
        };
        VacuumTube.prototype.draw = function() {
            var glow = this.warmth / 100;
            var s = this.baseSize;
            var tw = s * this.type.wr;
            var th = s * this.type.hr;
            var gc = this.type.gc;
            ctx.save();
            ctx.translate(this.x, this.y);

            // Warm light pool on chassis below
            if (glow > 0.1) {
                var poolR = s * 2.5 * glow;
                var pool = ctx.createRadialGradient(0, th + s * 0.4, 0, 0, th + s * 0.4, poolR);
                pool.addColorStop(0, 'rgba(' + gc[0] + ',' + gc[1] + ',' + gc[2] + ',' + (glow * 0.08).toFixed(3) + ')');
                pool.addColorStop(1, 'transparent');
                ctx.fillStyle = pool;
                ctx.fillRect(-poolR, th - s * 0.2, poolR * 2, poolR + s * 0.2);
            }
            // Outer halo
            if (glow > 0.08) {
                var haloR = s * 2.0 * glow;
                var halo = ctx.createRadialGradient(0, 0, s * 0.2, 0, 0, haloR);
                halo.addColorStop(0, 'rgba(' + gc[0] + ',' + gc[1] + ',' + gc[2] + ',' + (glow * 0.15 + this.biasThunk * 0.2).toFixed(3) + ')');
                halo.addColorStop(0.5, 'rgba(' + gc[0] + ',' + Math.floor(gc[1] * 0.6) + ',' + Math.floor(gc[2] * 0.5) + ',' + (glow * 0.05).toFixed(3) + ')');
                halo.addColorStop(1, 'transparent');
                ctx.fillStyle = halo;
                ctx.beginPath();
                ctx.arc(0, 0, haloR, 0, Math.PI * 2);
                ctx.fill();
            }
            // Top cap for power tubes
            if (this.type.topCap) {
                ctx.beginPath();
                ctx.arc(0, -th - 4, tw * 0.35, 0, Math.PI * 2);
                ctx.fillStyle = '#3a3530'; ctx.fill();
                ctx.strokeStyle = '#555045'; ctx.lineWidth = 1; ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, -th - 4 - tw * 0.35);
                ctx.lineTo(0, -th - 10 - tw * 0.35);
                ctx.strokeStyle = 'rgba(150,130,110,0.5)'; ctx.lineWidth = 1; ctx.stroke();
            }
            // Glass envelope shape
            ctx.beginPath();
            if (this.type.name === 'power') {
                ctx.moveTo(-tw, th * 0.3);
                ctx.quadraticCurveTo(-tw * 1.1, -th * 0.3, -tw * 0.6, -th);
                ctx.quadraticCurveTo(0, -th * 1.15, tw * 0.6, -th);
                ctx.quadraticCurveTo(tw * 1.1, -th * 0.3, tw, th * 0.3);
                ctx.lineTo(-tw, th * 0.3);
            } else if (this.type.name === 'mini') {
                ctx.ellipse(0, -th * 0.2, tw, th * 0.8, 0, 0, Math.PI * 2);
            } else {
                ctx.moveTo(-tw, th * 0.3);
                ctx.quadraticCurveTo(-tw, -th * 0.5, -tw * 0.5, -th);
                ctx.quadraticCurveTo(0, -th * 1.1, tw * 0.5, -th);
                ctx.quadraticCurveTo(tw, -th * 0.5, tw, th * 0.3);
                ctx.lineTo(-tw, th * 0.3);
            }
            var glassTint = 0.1 + (1 - this.age) * 0.15;
            var glassG = ctx.createLinearGradient(-tw, 0, tw, 0);
            glassG.addColorStop(0, 'rgba(50,42,35,' + (0.7 + glassTint) + ')');
            glassG.addColorStop(0.3, 'rgba(70,60,50,' + (0.5 + glassTint * 0.5) + ')');
            glassG.addColorStop(0.5, 'rgba(60,52,44,' + (0.55 + glassTint * 0.5) + ')');
            glassG.addColorStop(0.7, 'rgba(55,48,40,' + (0.6 + glassTint) + ')');
            glassG.addColorStop(1, 'rgba(40,35,28,' + (0.8 + glassTint) + ')');
            ctx.fillStyle = glassG; ctx.fill();
            ctx.strokeStyle = 'rgba(120,100,80,' + (0.25 + glow * 0.15) + ')';
            ctx.lineWidth = 1.5; ctx.stroke();
            // Specular highlight
            ctx.beginPath();
            ctx.moveTo(-tw * 0.55, -th * 0.6);
            ctx.quadraticCurveTo(-tw * 0.5, -th * 0.2, -tw * 0.45, th * 0.1);
            ctx.strokeStyle = 'rgba(200,180,160,' + (0.06 + glow * 0.04) + ')';
            ctx.lineWidth = 1.5; ctx.stroke();
            // Internal plate structure
            if (glow > 0.02) {
                var pg = this.plateGlow / 100;
                ctx.fillStyle = 'rgba(80,65,50,' + (0.3 + pg * 0.4) + ')';
                ctx.fillRect(-tw * 0.55, -th * 0.55, tw * 1.1, th * 0.8);
                var gridCount = this.type.name === 'pentode' ? 3 : 1;
                for (var g = 0; g < gridCount; g++) {
                    var gy = -th * 0.4 + g * th * 0.25;
                    ctx.beginPath();
                    for (var gi = 0; gi < 5; gi++) {
                        var gx = -tw * 0.35 + gi * tw * 0.18;
                        ctx.moveTo(gx, gy - 3); ctx.lineTo(gx, gy + 3);
                    }
                    ctx.strokeStyle = 'rgba(160,130,100,' + (0.15 + pg * 0.2) + ')';
                    ctx.lineWidth = 0.7; ctx.stroke();
                }
            }
            // Heater/filament glow
            if (this.heaterGlow > 1) {
                var hg = this.heaterGlow / 100;
                var filGlow = hg * (1 + this.flicker) * this.type.hb;
                var heaterG = ctx.createRadialGradient(0, th * 0.15, 0, 0, th * 0.15, tw * 0.7);
                heaterG.addColorStop(0, 'rgba(255,100,20,' + (filGlow * 0.5).toFixed(3) + ')');
                heaterG.addColorStop(0.5, 'rgba(255,80,10,' + (filGlow * 0.2).toFixed(3) + ')');
                heaterG.addColorStop(1, 'transparent');
                ctx.fillStyle = heaterG;
                ctx.fillRect(-tw, -th * 0.3, tw * 2, th * 0.8);
                // Primary filament
                ctx.beginPath();
                ctx.moveTo(-tw * 0.12, th * 0.25);
                ctx.bezierCurveTo(-tw * 0.15, -th * 0.1, -tw * 0.08, -th * 0.35, 0, -th * 0.45);
                ctx.bezierCurveTo(tw * 0.08, -th * 0.35, tw * 0.15, -th * 0.1, tw * 0.12, th * 0.25);
                ctx.strokeStyle = 'rgba(255,' + Math.floor(140 * filGlow) + ',' + Math.floor(40 * filGlow) + ',' + Math.min(1, filGlow * 1.2).toFixed(3) + ')';
                ctx.lineWidth = 1.5 + filGlow; ctx.stroke();
                // Second filament for power/rectifier
                if (this.type.name === 'power' || this.type.name === 'rectifier') {
                    ctx.beginPath();
                    ctx.moveTo(tw * 0.05, th * 0.2);
                    ctx.bezierCurveTo(tw * 0.1, -th * 0.05, tw * 0.02, -th * 0.3, -tw * 0.03, -th * 0.4);
                    ctx.strokeStyle = 'rgba(255,' + Math.floor(120 * filGlow) + ',' + Math.floor(30 * filGlow) + ',' + (filGlow * 0.8).toFixed(3) + ')';
                    ctx.lineWidth = 1 + filGlow * 0.5; ctx.stroke();
                }
                // Volumetric inner glow
                var innerG = ctx.createRadialGradient(0, -th * 0.15, 0, 0, -th * 0.15, tw * 0.8);
                innerG.addColorStop(0, 'rgba(' + gc[0] + ',' + gc[1] + ',' + gc[2] + ',' + (filGlow * 0.25 + this.biasThunk * 0.3).toFixed(3) + ')');
                innerG.addColorStop(0.6, 'rgba(' + gc[0] + ',' + Math.floor(gc[1] * 0.7) + ',' + Math.floor(gc[2] * 0.5) + ',' + (filGlow * 0.08).toFixed(3) + ')');
                innerG.addColorStop(1, 'transparent');
                ctx.fillStyle = innerG;
                ctx.beginPath();
                ctx.ellipse(0, -th * 0.15, tw * 0.8, th * 0.7, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            // Base socket
            var baseH = s * 0.28;
            var baseW = tw * 1.15;
            ctx.fillStyle = '#22201a';
            ctx.beginPath();
            ctx.moveTo(-baseW, th * 0.3);
            ctx.lineTo(-baseW, th * 0.3 + baseH);
            ctx.lineTo(baseW, th * 0.3 + baseH);
            ctx.lineTo(baseW, th * 0.3);
            ctx.closePath(); ctx.fill();
            ctx.strokeStyle = '#3a3530'; ctx.lineWidth = 1; ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(-baseW, th * 0.3 + baseH * 0.4);
            ctx.lineTo(baseW, th * 0.3 + baseH * 0.4);
            ctx.strokeStyle = '#2a2820'; ctx.lineWidth = 1; ctx.stroke();
            // Pins
            var pinCount = this.type.pins;
            var pinSpacing = (baseW * 2 - 4) / (pinCount + 1);
            for (var pi = 1; pi <= pinCount; pi++) {
                var px = -baseW + 2 + pi * pinSpacing;
                ctx.fillStyle = glow > 0.05 ? '#b0a090' : '#706860';
                ctx.fillRect(px - 1, th * 0.3 + baseH, 2, s * 0.15);
            }
            ctx.restore();
        };

        // Organic tube layout
        function layoutTubes() {
            if (!tubes.length || !W) return;
            var margin = 80, areaW = W - margin * 2;
            var areaH = H * 0.55, areaY = H * 0.18;
            var count = tubes.length;
            var cols = Math.ceil(Math.sqrt(count * 1.5));
            var rows = Math.ceil(count / cols);
            var spacingX = areaW / (cols + 0.5);
            var spacingY = areaH / (rows + 0.5);
            var idx = 0;
            for (var r = 0; r < rows && idx < count; r++) {
                var rowCount = Math.min(cols, count - idx);
                if (r === rows - 1) rowCount = count - idx;
                var rowOffset = (areaW - rowCount * spacingX) / 2;
                for (var c = 0; c < rowCount && idx < count; c++) {
                    var jx = (Math.random() - 0.5) * spacingX * 0.3;
                    var jy = (Math.random() - 0.5) * spacingY * 0.25;
                    tubes[idx].x = margin + rowOffset + (c + 0.5) * spacingX + jx;
                    tubes[idx].y = areaY + (r + 0.5) * spacingY + jy;
                    idx++;
                }
            }
        }

        function rebuildTubes(count) {
            if (count > tubes.length) {
                for (var i = tubes.length; i < count; i++) tubes.push(new VacuumTube(i));
            } else if (count < tubes.length) {
                tubes.length = count;
            }
            layoutTubes();
        }

        function initTubes() {
            tubes = [];
            for (var i = 0; i < tubeCountTarget; i++) tubes.push(new VacuumTube(i));
        }

        function getBreathPattern() { return PATTERNS[breathPatternKey] || PATTERNS.box; }
        function smoothStep(t) { return t * t * (3 - 2 * t); }

        function updateBreathing(dt) {
            if (!breathing) { breathProgress *= (1 - dt * 3); return 0.5; }
            var steps = getBreathPattern().steps;
            var dur = steps[breathPhaseIdx];
            if (dur === 0) {
                breathPhaseIdx = (breathPhaseIdx + 1) % 4;
                breathPhaseTime = 0;
                if (breathPhaseIdx === 0) breathCycles++;
                return updateBreathing(dt);
            }
            breathPhaseTime += dt;
            if (breathPhaseTime >= dur) {
                breathPhaseTime -= dur;
                breathPhaseIdx = (breathPhaseIdx + 1) % 4;
                if (breathPhaseIdx === 0) breathCycles++;
            }
            var t = breathPhaseTime / dur;
            if (breathPhaseIdx === 0) breathProgress = smoothStep(t);
            else if (breathPhaseIdx === 1) breathProgress = 1.0;
            else if (breathPhaseIdx === 2) breathProgress = 1.0 - smoothStep(t);
            else breathProgress = 0.0;
            return 0.4 + breathProgress * 0.6;
        }

        function drawChassisBackground() {
            var glow = globalWarmth / 100;
            var chassisY = H * 0.7;
            var woodG = ctx.createLinearGradient(0, chassisY, 0, H);
            woodG.addColorStop(0, 'rgba(35,28,20,' + (glow * 0.15).toFixed(3) + ')');
            woodG.addColorStop(0.3, 'rgba(45,35,25,' + (0.4 + glow * 0.1).toFixed(3) + ')');
            woodG.addColorStop(1, 'rgba(25,20,15,0.8)');
            ctx.fillStyle = woodG;
            ctx.fillRect(0, chassisY, W, H - chassisY);
            ctx.strokeStyle = 'rgba(60,45,30,' + (0.08 + glow * 0.04).toFixed(3) + ')';
            ctx.lineWidth = 1;
            for (var i = 0; i < 25; i++) {
                var gy = chassisY + 10 + i * ((H - chassisY) / 25);
                ctx.beginPath(); ctx.moveTo(0, gy);
                for (var x = 0; x < W; x += 40) ctx.lineTo(x + 40, gy + Math.sin(x * 0.02 + i) * 2);
                ctx.stroke();
            }
            var stripY = chassisY - 2;
            var stripG = ctx.createLinearGradient(0, stripY, 0, stripY + 6);
            stripG.addColorStop(0, 'rgba(80,70,55,' + (0.3 + glow * 0.15).toFixed(3) + ')');
            stripG.addColorStop(0.5, 'rgba(100,85,65,' + (0.2 + glow * 0.1).toFixed(3) + ')');
            stripG.addColorStop(1, 'rgba(60,50,40,' + (0.3 + glow * 0.1).toFixed(3) + ')');
            ctx.fillStyle = stripG;
            ctx.fillRect(0, stripY, W, 6);
        }

        function drawHeatDistortion() {
            var glow = globalWarmth / 100;
            if (glow < 0.15) return;
            var shimmerA = glow * 0.025;
            for (var i = 0; i < 8; i++) {
                var y = H * 0.08 + i * 15 + Math.sin(time * 0.8 + i * 0.7) * 8;
                var wave = Math.sin(time * 1.2 + i * 1.1);
                ctx.beginPath(); ctx.moveTo(0, y);
                for (var x = 0; x < W; x += 8) {
                    ctx.lineTo(x, y + Math.sin(x * 0.008 + time * 2 + i) * (3 + wave * 2) * glow);
                }
                ctx.strokeStyle = 'rgba(255,180,100,' + (shimmerA * (0.5 + wave * 0.5)).toFixed(4) + ')';
                ctx.lineWidth = 2 + glow * 2; ctx.stroke();
            }
        }

        function drawBreathGuide() {
            var el = document.getElementById('breath-circle');
            var label = document.getElementById('breath-label');
            var countEl = document.getElementById('breath-count');
            if (!breathing) {
                el.style.width = el.style.height = '60px';
                el.style.borderColor = 'rgba(255,160,80,0.15)';
                label.textContent = powered ? 'Space to Breathe' : 'Ready';
                countEl.textContent = '';
                return;
            }
            var size = 50 + breathProgress * 60;
            var alpha = 0.2 + breathProgress * 0.4;
            el.style.width = el.style.height = size + 'px';
            el.style.borderColor = 'rgba(255,160,80,' + alpha.toFixed(2) + ')';
            label.textContent = PHASE_NAMES[breathPhaseIdx];
            countEl.textContent = 'Breath ' + (breathCycles + 1);
        }

        function drawSessionTimer() {
            if (!sessionActive) return;
            sessionSeconds = (performance.now() - sessionStartTime) / 1000;
            var m = Math.floor(sessionSeconds / 60);
            var s = Math.floor(sessionSeconds % 60);
            document.getElementById('session-timer').textContent =
                String(m).padStart(2, '0') + ':' + String(s).padStart(2, '0');
        }

        function handleTap() {
            if (!tapMode || !powered) return;
            tapEnergy = 1.0;
            for (var i = 0; i < tubes.length; i++) tubes[i].tapResponse = 0.5 + Math.random() * 0.5;
        }

        // localStorage persistence
        var STORAGE_KEY = 'vacuumTubeMeditation';
        function saveSettings() {
            var data = {
                breathPattern: breathPatternKey, warmth: targetWarmth,
                tubeCount: tubeCountTarget, humIntensity: humIntensity,
                ambientMode: ambientMode,
                totalMinutes: getTotalMinutes(), sessionCount: getSessionCount(),
                sessions: getSessions()
            };
            try { localStorage.setItem(STORAGE_KEY, JSON.stringify(data)); } catch(e) {}
        }
        function loadSettings() {
            try {
                var raw = localStorage.getItem(STORAGE_KEY);
                if (!raw) return;
                var d = JSON.parse(raw);
                if (d.breathPattern && PATTERNS[d.breathPattern]) {
                    breathPatternKey = d.breathPattern;
                    document.getElementById('breath-pattern').value = breathPatternKey;
                }
                if (typeof d.warmth === 'number') {
                    targetWarmth = d.warmth;
                    document.getElementById('warmth').value = targetWarmth;
                }
                if (typeof d.tubeCount === 'number') {
                    tubeCountTarget = Math.max(12, Math.min(36, d.tubeCount));
                    document.getElementById('tube-count').value = tubeCountTarget;
                }
                if (typeof d.humIntensity === 'number') {
                    humIntensity = d.humIntensity;
                    document.getElementById('hum-intensity').value = Math.round(humIntensity * 100);
                }
                if (typeof d.ambientMode === 'boolean') ambientMode = d.ambientMode;
                updateSessionStats();
            } catch(e) {}
        }
        function getTotalMinutes() {
            try { var r = localStorage.getItem(STORAGE_KEY); return r ? (JSON.parse(r).totalMinutes || 0) : 0; } catch(e) { return 0; }
        }
        function getSessionCount() {
            try { var r = localStorage.getItem(STORAGE_KEY); return r ? (JSON.parse(r).sessionCount || 0) : 0; } catch(e) { return 0; }
        }
        function getSessions() {
            try { var r = localStorage.getItem(STORAGE_KEY); return r ? (JSON.parse(r).sessions || []) : []; } catch(e) { return []; }
        }
        function endSession() {
            if (!sessionActive) return;
            sessionActive = false;
            var mins = sessionSeconds / 60;
            if (mins < 0.1) return;
            try {
                var raw = localStorage.getItem(STORAGE_KEY);
                var d = raw ? JSON.parse(raw) : {};
                d.totalMinutes = (d.totalMinutes || 0) + mins;
                d.sessionCount = (d.sessionCount || 0) + 1;
                if (!d.sessions) d.sessions = [];
                d.sessions.push({ date: new Date().toISOString(), minutes: Math.round(mins * 10) / 10, breaths: breathCycles, pattern: breathPatternKey });
                if (d.sessions.length > 50) d.sessions = d.sessions.slice(-50);
                localStorage.setItem(STORAGE_KEY, JSON.stringify(d));
            } catch(e) {}
            updateSessionStats();
        }
        function updateSessionStats() {
            var total = getTotalMinutes(), count = getSessionCount();
            var el = document.getElementById('session-stats');
            el.textContent = count === 0 ? 'First session' : count + ' sessions \u00b7 ' + Math.round(total) + ' min total';
        }

        var toastTimer = null;
        function showToast(msg) {
            var el = document.getElementById('toast');
            el.textContent = msg;
            el.classList.add('visible');
            if (toastTimer) clearTimeout(toastTimer);
            toastTimer = setTimeout(function() { el.classList.remove('visible'); }, 1800);
        }

        // Main animation loop
        function animate(timestamp) {
            var dt = lastTimestamp ? Math.min((timestamp - lastTimestamp) / 1000, 0.05) : 0.016;
            lastTimestamp = timestamp;
            time += dt;
            ctx.fillStyle = '#080604';
            ctx.fillRect(0, 0, W, H);

            if (powered) {
                globalWarmth += (targetWarmth - globalWarmth) * dt * 1.5;
                powerOnTime += dt;
            } else {
                globalWarmth *= (1 - dt * 1.5);
                powerOnTime = 0;
            }
            var breathMod = updateBreathing(dt);
            if (tapEnergy > 0) tapEnergy *= (1 - dt * 3);

            drawChassisBackground();

            if (ambientMode && globalWarmth > 5) {
                for (var di = 0; di < dustMotes.length; di++) { dustMotes[di].update(dt); dustMotes[di].draw(); }
            }

            for (var ui = 0; ui < tubes.length; ui++) tubes[ui].update(dt, powerOnTime, breathMod);
            var sorted = tubes.slice().sort(function(a, b) { return a.y - b.y; });
            for (var si = 0; si < sorted.length; si++) sorted[si].draw();

            if (ambientMode) drawHeatDistortion();

            // Vignette
            var vigR = Math.max(W, H) * 0.7;
            var vig = ctx.createRadialGradient(W / 2, H / 2, vigR * 0.4, W / 2, H / 2, vigR);
            vig.addColorStop(0, 'transparent');
            vig.addColorStop(1, 'rgba(0,0,0,0.5)');
            ctx.fillStyle = vig;
            ctx.fillRect(0, 0, W, H);

            drawBreathGuide();
            drawSessionTimer();
            requestAnimationFrame(animate);
        }

        // Control event bindings
        document.getElementById('power-btn').addEventListener('click', function() {
            powered = !powered;
            this.classList.toggle('active', powered);
            document.getElementById('power-light').classList.toggle('on', powered);
            if (powered) {
                powerOnTime = 0;
                if (!sessionActive) { sessionActive = true; sessionStartTime = performance.now(); sessionSeconds = 0; }
                showToast('Powering up...');
            } else {
                endSession();
                breathing = false; breathPhaseIdx = 0; breathPhaseTime = 0; breathCycles = 0;
                document.getElementById('breath-btn').classList.remove('active');
                showToast('Cooling down...');
            }
        });
        document.getElementById('breath-btn').addEventListener('click', function() {
            if (!powered) { showToast('Power on first'); return; }
            breathing = !breathing;
            this.classList.toggle('active', breathing);
            if (breathing) {
                breathPhaseIdx = 0; breathPhaseTime = 0; breathCycles = 0;
                showToast(getBreathPattern().name + ' breathing');
            } else { showToast('Free breathing'); }
        });
        document.getElementById('breath-pattern').addEventListener('change', function() {
            breathPatternKey = this.value;
            breathPhaseIdx = 0; breathPhaseTime = 0; breathCycles = 0;
            saveSettings();
            if (breathing) showToast(getBreathPattern().name + ' pattern');
        });
        document.getElementById('warmth').addEventListener('input', function() {
            targetWarmth = parseInt(this.value); saveSettings();
        });
        document.getElementById('tube-count').addEventListener('input', function() {
            tubeCountTarget = parseInt(this.value); rebuildTubes(tubeCountTarget); saveSettings();
        });
        document.getElementById('hum-intensity').addEventListener('input', function() {
            humIntensity = parseInt(this.value) / 100; saveSettings();
        });
        document.getElementById('ambient-btn').addEventListener('click', function() {
            ambientMode = !ambientMode;
            this.classList.toggle('active', ambientMode); saveSettings();
        });
        document.getElementById('tap-btn').addEventListener('click', function() {
            tapMode = !tapMode; this.classList.toggle('active', tapMode);
        });
        canvas.addEventListener('click', handleTap);
        canvas.addEventListener('touchstart', function(e) { e.preventDefault(); handleTap(); }, { passive: false });

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            if (e.target.tagName === 'SELECT' || e.target.tagName === 'INPUT') return;
            var sel;
            switch (e.key) {
                case ' ':
                    e.preventDefault();
                    if (!powered) {
                        document.getElementById('power-btn').click();
                        setTimeout(function() { document.getElementById('breath-btn').click(); }, 100);
                    } else { document.getElementById('breath-btn').click(); }
                    break;
                case 'Escape':
                    e.preventDefault();
                    if (powered) document.getElementById('power-btn').click();
                    break;
                case '1':
                    sel = document.getElementById('breath-pattern'); sel.value = 'box'; sel.dispatchEvent(new Event('change'));
                    break;
                case '2':
                    sel = document.getElementById('breath-pattern'); sel.value = 'relaxing'; sel.dispatchEvent(new Event('change'));
                    break;
                case '3':
                    sel = document.getElementById('breath-pattern'); sel.value = 'calm'; sel.dispatchEvent(new Event('change'));
                    break;
                case '4':
                    sel = document.getElementById('breath-pattern'); sel.value = 'deep'; sel.dispatchEvent(new Event('change'));
                    break;
                case 'h': case 'H':
                    panelVisible = !panelVisible;
                    document.getElementById('panel').classList.toggle('hidden', !panelVisible);
                    break;
            }
        });

        window.addEventListener('beforeunload', function() { endSession(); saveSettings(); });

        // Initialize
        initTubes();
        resize();
        loadSettings();
        updateSessionStats();
        if (ambientMode) document.getElementById('ambient-btn').classList.add('active');
        requestAnimationFrame(animate);
    })();
    </script>
</body>
</html>