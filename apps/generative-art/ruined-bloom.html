<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ruined Bloom</title>
    <meta name="description" content="Grow crystalline structures that decay into beautiful luminous fragments - entropy gardening where dissolution becomes art">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0808; min-height: 100vh; font-family: 'Georgia', serif; color: #a08080; overflow: hidden; }
        #canvas { position: fixed; top: 0; left: 0; cursor: crosshair; }
        #controls {
            position: fixed; top: 20px; left: 20px; background: rgba(20,15,15,0.95);
            padding: 20px; border-radius: 10px; border: 1px solid rgba(160,120,120,0.3);
            z-index: 100;
        }
        h3 { margin-bottom: 15px; color: #d0a0a0; font-weight: normal; }
        .control-row { margin: 10px 0; }
        label { display: block; font-size: 11px; margin-bottom: 5px; opacity: 0.8; }
        input[type="range"] { width: 140px; }
        .value { float: right; color: #e0b0b0; font-size: 12px; }
        button {
            display: block; width: 100%; padding: 10px; margin: 6px 0;
            background: rgba(100,70,70,0.4); border: 1px solid rgba(160,120,120,0.4);
            color: #b09090; cursor: pointer; border-radius: 6px; font-family: inherit;
        }
        #info { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); font-size: 12px; opacity: 0.5; z-index: 100; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="controls">
        <h3>Ruined Bloom</h3>
        <div class="control-row">
            <label>Growth Rate <span class="value" id="growth-val">50</span></label>
            <input type="range" id="growth" min="10" max="100" value="50">
        </div>
        <div class="control-row">
            <label>Decay Speed <span class="value" id="decay-val">30</span></label>
            <input type="range" id="decay" min="5" max="100" value="30">
        </div>
        <button id="seed-btn">Plant Crystal Seed</button>
        <button id="accelerate-btn">Accelerate Entropy</button>
    </div>
    <div id="info">Click and drag to grow crystals | Watch them decay into luminous dust</div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let W, H;
        function resize() { W = canvas.width = innerWidth; H = canvas.height = innerHeight; }
        resize(); window.onresize = resize;
        
        let growthRate = 0.5;
        let decaySpeed = 0.3;
        let time = 0;
        
        const crystals = [];
        const fragments = [];
        const scars = [];
        
        let isGrowing = false;
        let growthPath = [];
        
        class Crystal {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.branches = [];
                this.age = 0;
                this.maxAge = 300 + Math.random() * 200;
                this.hue = 280 + Math.random() * 60;
                this.health = 1;
                this.rootAngle = -Math.PI / 2 + (Math.random() - 0.5) * 0.5;
                
                this.grow(x, y, this.rootAngle, 50 + Math.random() * 30, 0);
            }
            
            grow(x, y, angle, length, depth) {
                if (depth > 5 || length < 5) return;
                
                const endX = x + Math.cos(angle) * length;
                const endY = y + Math.sin(angle) * length;
                
                this.branches.push({
                    x1: x, y1: y, x2: endX, y2: endY,
                    length: length,
                    depth: depth,
                    health: 1,
                    decayOffset: Math.random() * 50
                });
                
                const branchCount = Math.random() < 0.7 ? 2 : 3;
                for (let i = 0; i < branchCount; i++) {
                    const newAngle = angle + (Math.random() - 0.5) * 1.2;
                    const newLength = length * (0.6 + Math.random() * 0.2);
                    this.grow(endX, endY, newAngle, newLength, depth + 1);
                }
            }
            
            update() {
                this.age += 0.5 * decaySpeed;
                
                const decayProgress = this.age / this.maxAge;
                
                this.branches.forEach((branch, i) => {
                    const branchDecayTime = (branch.decayOffset / 100) * this.maxAge;
                    
                    if (this.age > branchDecayTime) {
                        const localDecay = (this.age - branchDecayTime) / (this.maxAge - branchDecayTime);
                        branch.health = Math.max(0, 1 - localDecay * 1.5);
                        
                        if (branch.health < 0.8 && Math.random() < decaySpeed * 0.02) {
                            this.shed(branch);
                        }
                    }
                });
                
                this.health = this.branches.reduce((sum, b) => sum + b.health, 0) / this.branches.length;
                
                return this.health > 0.01;
            }
            
            shed(branch) {
                const midX = (branch.x1 + branch.x2) / 2;
                const midY = (branch.y1 + branch.y2) / 2;
                
                for (let i = 0; i < 3; i++) {
                    fragments.push({
                        x: midX + (Math.random() - 0.5) * 10,
                        y: midY + (Math.random() - 0.5) * 10,
                        vx: (Math.random() - 0.5) * 2,
                        vy: Math.random() * 2,
                        size: 2 + Math.random() * 4,
                        life: 1,
                        hue: this.hue + (Math.random() - 0.5) * 30,
                        glow: 0.8
                    });
                }
            }
            
            draw() {
                const ageRatio = this.age / this.maxAge;
                const currentHue = this.hue + ageRatio * 60;
                
                this.branches.forEach(branch => {
                    if (branch.health <= 0) return;
                    
                    ctx.beginPath();
                    ctx.moveTo(branch.x1, branch.y1);
                    ctx.lineTo(branch.x2, branch.y2);
                    
                    const alpha = branch.health * 0.8;
                    const lightness = 40 + branch.health * 30;
                    
                    ctx.strokeStyle = "hsla(" + currentHue + ", 50%, " + lightness + "%, " + alpha + ")";
                    ctx.lineWidth = (3 - branch.depth * 0.4) * branch.health;
                    ctx.lineCap = "round";
                    ctx.stroke();
                    
                    if (branch.health > 0.5) {
                        ctx.strokeStyle = "hsla(" + currentHue + ", 70%, 70%, " + (alpha * 0.3) + ")";
                        ctx.lineWidth = (6 - branch.depth * 0.5) * branch.health;
                        ctx.stroke();
                    }
                });
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, 5 * this.health, 0, Math.PI * 2);
                ctx.fillStyle = "hsla(" + currentHue + ", 60%, 60%, " + this.health + ")";
                ctx.fill();
            }
        }
        
        function drawFragments() {
            for (let i = fragments.length - 1; i >= 0; i--) {
                const f = fragments[i];
                
                let attractX = 0, attractY = 0;
                crystals.forEach(c => {
                    if (c.age > c.maxAge * 0.5) {
                        const dx = c.x - f.x;
                        const dy = c.y - f.y;
                        const dist = Math.hypot(dx, dy);
                        if (dist > 30 && dist < 200) {
                            const force = (c.maxAge - c.age) * 0.0001 / dist;
                            attractX += (dx / dist) * force;
                            attractY += (dy / dist) * force;
                        }
                    }
                });
                
                f.vx += attractX;
                f.vy += attractY;
                f.vy += 0.02;
                f.vx *= 0.99;
                f.vy *= 0.99;
                
                f.x += f.vx;
                f.y += f.vy;
                f.life -= 0.003;
                f.glow *= 0.995;
                
                if (f.life <= 0 || f.y > H + 50) {
                    if (f.life > -0.5) {
                        scars.push({
                            x: f.x, y: f.y,
                            size: f.size * 0.5,
                            alpha: 0.3,
                            hue: f.hue
                        });
                    }
                    fragments.splice(i, 1);
                    continue;
                }
                
                ctx.beginPath();
                ctx.arc(f.x, f.y, f.size * f.life, 0, Math.PI * 2);
                
                const gradient = ctx.createRadialGradient(f.x, f.y, 0, f.x, f.y, f.size * 2);
                gradient.addColorStop(0, "hsla(" + f.hue + ", 70%, 70%, " + (f.life * f.glow) + ")");
                gradient.addColorStop(1, "transparent");
                ctx.fillStyle = gradient;
                ctx.fill();
                
                ctx.fillStyle = "hsla(" + f.hue + ", 60%, 80%, " + f.life + ")";
                ctx.fill();
            }
        }
        
        function drawScars() {
            for (let i = scars.length - 1; i >= 0; i--) {
                const s = scars[i];
                s.alpha *= 0.998;
                
                if (s.alpha < 0.01) {
                    scars.splice(i, 1);
                    continue;
                }
                
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
                ctx.fillStyle = "hsla(" + s.hue + ", 30%, 30%, " + s.alpha + ")";
                ctx.fill();
            }
        }
        
        function drawBackground() {
            ctx.fillStyle = 'rgba(10, 8, 8, 0.1)';
            ctx.fillRect(0, 0, W, H);
        }
        
        function drawGrowthPath() {
            if (growthPath.length < 2) return;
            
            ctx.beginPath();
            ctx.moveTo(growthPath[0].x, growthPath[0].y);
            growthPath.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.strokeStyle = 'rgba(200, 150, 150, 0.3)';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        function animate() {
            time += 0.016;
            
            drawBackground();
            drawScars();
            
            for (let i = crystals.length - 1; i >= 0; i--) {
                if (!crystals[i].update()) {
                    crystals[i].branches.forEach(b => {
                        for (let j = 0; j < 5; j++) {
                            fragments.push({
                                x: (b.x1 + b.x2) / 2,
                                y: (b.y1 + b.y2) / 2,
                                vx: (Math.random() - 0.5) * 3,
                                vy: (Math.random() - 0.5) * 3,
                                size: 3 + Math.random() * 3,
                                life: 1,
                                hue: crystals[i].hue,
                                glow: 1
                            });
                        }
                    });
                    crystals.splice(i, 1);
                }
            }
            
            crystals.forEach(c => c.draw());
            drawFragments();
            drawGrowthPath();
            
            requestAnimationFrame(animate);
        }
        
        canvas.onmousedown = e => {
            isGrowing = true;
            growthPath = [{ x: e.clientX, y: e.clientY }];
        };
        
        canvas.onmousemove = e => {
            if (!isGrowing) return;
            const last = growthPath[growthPath.length - 1];
            if (Math.hypot(e.clientX - last.x, e.clientY - last.y) > 20) {
                growthPath.push({ x: e.clientX, y: e.clientY });
            }
        };
        
        canvas.onmouseup = e => {
            if (growthPath.length > 0) {
                growthPath.forEach((p, i) => {
                    if (i % 2 === 0) {
                        setTimeout(() => {
                            crystals.push(new Crystal(p.x, p.y));
                        }, i * 100 * (1 - growthRate));
                    }
                });
            }
            isGrowing = false;
            growthPath = [];
        };
        
        document.getElementById('growth').oninput = e => {
            growthRate = e.target.value / 100;
            document.getElementById('growth-val').textContent = e.target.value;
        };
        
        document.getElementById('decay').oninput = e => {
            decaySpeed = e.target.value / 100;
            document.getElementById('decay-val').textContent = e.target.value;
        };
        
        document.getElementById('seed-btn').onclick = () => {
            crystals.push(new Crystal(
                W * 0.3 + Math.random() * W * 0.4,
                H * 0.5 + Math.random() * H * 0.3
            ));
        };
        
        document.getElementById('accelerate-btn').onclick = () => {
            crystals.forEach(c => {
                c.age += 50;
            });
        };
        
        ctx.fillStyle = '#0a0808';
        ctx.fillRect(0, 0, W, H);
        
        crystals.push(new Crystal(W / 2, H * 0.6));
        animate();
    </script>
</body>
</html>