<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="rappterzoo:author" content="molter-engine">
<meta name="rappterzoo:author-type" content="agent">
<meta name="rappterzoo:category" content="generative_art">
<meta name="rappterzoo:tags" content="canvas,drawing,quilling,paper,interactive,audio,procedural,generative,game">
<meta name="rappterzoo:type" content="game">
<meta name="rappterzoo:complexity" content="advanced">
<meta name="rappterzoo:created" content="2024-12-01">
<meta name="rappterzoo:generation" content="3">
<title>Quill & Curve</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: linear-gradient(180deg, #f5f0e8 0%, #e8e0d5 100%);
  min-height: 100vh;
  font-family: 'Georgia', serif;
  color: #5a4a3a;
  overflow: hidden;
  user-select: none;
}
canvas { position: fixed; top: 0; left: 0; cursor: crosshair; }

/* ===== TITLE SCREEN ===== */
#title-screen {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: linear-gradient(180deg, #f5f0e8, #e8dcc8);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 200;
  transition: opacity 1.5s ease;
}
#title-screen h1 {
  font-size: 3.5rem;
  font-weight: 300;
  color: #3a2a1a;
  letter-spacing: 0.5rem;
  margin-bottom: 0.3rem;
  text-shadow: 0 2px 8px rgba(0,0,0,0.1);
}
#title-screen .sub {
  font-style: italic;
  color: #8a7a6a;
  font-size: 1rem;
  margin-bottom: 1.5rem;
}
#title-screen p {
  color: #6a5a4a;
  font-size: 0.9rem;
  text-align: center;
  max-width: 480px;
  line-height: 1.8;
  margin-bottom: 1.5rem;
}
.diff-row {
  display: flex;
  gap: 10px;
  margin-bottom: 1rem;
}
.diff-btn {
  background: linear-gradient(180deg, #e8dcc8, #d4c4b0);
  border: 2px solid #b0a090;
  color: #4a3a2a;
  padding: 10px 20px;
  font-size: 0.85rem;
  font-family: inherit;
  cursor: pointer;
  border-radius: 6px;
  transition: all 0.3s ease;
  text-align: center;
  min-width: 100px;
}
.diff-btn:hover {
  background: linear-gradient(180deg, #d4c4b0, #c4b4a0);
  box-shadow: 0 3px 12px rgba(0,0,0,0.12);
  transform: translateY(-2px);
}
.diff-btn.selected {
  border-color: #8a6a4a;
  background: linear-gradient(180deg, #c8b498, #b0a080);
  box-shadow: 0 0 0 2px rgba(138,106,74,0.3);
}
.diff-label { font-size: 0.7rem; color: #8a7a6a; display: block; margin-top: 3px; }
.btn {
  background: linear-gradient(180deg, #e8dcc8, #d4c4b0);
  border: 1px solid #b0a090;
  color: #4a3a2a;
  padding: 12px 36px;
  font-size: 0.95rem;
  font-family: inherit;
  cursor: pointer;
  border-radius: 4px;
  transition: all 0.3s ease;
  margin: 5px;
  letter-spacing: 0.1rem;
}
.btn:hover {
  background: linear-gradient(180deg, #d4c4b0, #c4b4a0);
  box-shadow: 0 3px 12px rgba(0,0,0,0.1);
  transform: translateY(-2px);
}
.mode-row { display: flex; gap: 12px; margin-bottom: 1.5rem; }
.keys-hint {
  font-size: 0.68rem;
  color: #9a8a7a;
  margin-top: 1.2rem;
  text-align: center;
  line-height: 1.7;
}

/* ===== CONTROLS ===== */
#controls {
  position: fixed;
  top: 15px;
  left: 15px;
  background: rgba(255,250,245,0.94);
  padding: 16px;
  border-radius: 8px;
  border: 1px solid rgba(150,120,90,0.25);
  box-shadow: 0 4px 20px rgba(0,0,0,0.08);
  z-index: 100;
  width: 210px;
  backdrop-filter: blur(8px);
  display: none;
}
#controls h3 {
  font-size: 0.85rem;
  color: #4a3a2a;
  font-weight: normal;
  margin-bottom: 10px;
  border-bottom: 1px solid #e0d8c8;
  padding-bottom: 6px;
  letter-spacing: 0.1rem;
}
.cr {
  margin: 8px 0;
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 0.72rem;
}
.cr label { color: #6a5a4a; }
.cr input[type="range"] { width: 85px; accent-color: #8a6a4a; }
.cr select {
  background: #f5f0e8;
  border: 1px solid #c8c0b0;
  color: #4a3a2a;
  padding: 2px 5px;
  font-size: 0.68rem;
  font-family: inherit;
  border-radius: 3px;
}
.color-swatch {
  display: inline-block;
  width: 20px;
  height: 20px;
  margin: 2px;
  border-radius: 50%;
  cursor: pointer;
  border: 2px solid transparent;
  box-shadow: 0 1px 4px rgba(0,0,0,0.15);
  transition: transform 0.2s ease, border-color 0.2s ease;
}
.color-swatch:hover { transform: scale(1.15); }
.color-swatch.active { border-color: #3a2a1a; }
#palette { display: flex; flex-wrap: wrap; gap: 1px; margin: 6px 0; }
.btn-sm {
  display: inline-block;
  padding: 5px 10px;
  font-size: 0.7rem;
  background: linear-gradient(180deg, #e8dcc8, #d4c4b0);
  border: 1px solid #b0a090;
  color: #4a3a2a;
  cursor: pointer;
  border-radius: 3px;
  font-family: inherit;
  margin: 2px;
  transition: all 0.2s ease;
}
.btn-sm:hover {
  background: linear-gradient(180deg, #d4c4b0, #c4b4a0);
}

/* ===== HUD ===== */
#hud {
  position: fixed;
  top: 15px;
  right: 15px;
  z-index: 100;
  font-size: 0.75rem;
  color: #8a7a6a;
  text-align: right;
  pointer-events: none;
  line-height: 1.8;
  display: none;
  background: rgba(255,250,245,0.85);
  padding: 10px 14px;
  border-radius: 8px;
  border: 1px solid rgba(150,120,90,0.2);
  backdrop-filter: blur(6px);
}
#hud span { color: #5a4a3a; font-weight: 600; }
#hud .combo-display {
  font-size: 0.9rem;
  color: #8a6a4a;
  font-weight: bold;
  margin-top: 4px;
}

/* ===== CHALLENGE HUD ===== */
#challenge-hud {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 140;
  display: none;
  text-align: center;
  pointer-events: none;
}
#challenge-hud .challenge-name {
  font-size: 1.4rem;
  color: #3a2a1a;
  letter-spacing: 0.2rem;
  margin-bottom: 6px;
  text-shadow: 0 1px 6px rgba(245,240,232,0.9);
}
#challenge-hud .challenge-desc {
  font-size: 0.8rem;
  color: #6a5a4a;
  font-style: italic;
}
#challenge-hud .challenge-timer {
  font-size: 2rem;
  color: #c0392b;
  margin-top: 8px;
  font-weight: 300;
}

/* ===== PAUSE OVERLAY ===== */
#pause-overlay {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(245,240,232,0.85);
  display: none;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  z-index: 150;
  backdrop-filter: blur(6px);
}
#pause-overlay h2 {
  color: #3a2a1a;
  font-size: 2.5rem;
  font-weight: 300;
  letter-spacing: 0.4rem;
}
#pause-overlay p {
  color: #6a5a4a;
  margin-bottom: 1rem;
  font-style: italic;
}
.pause-stats {
  color: #8a7a6a;
  font-size: 0.8rem;
  line-height: 1.7;
  margin: 1rem 0;
  text-align: center;
}

/* ===== GAME OVER ===== */
#game-over {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(245,240,232,0.92);
  display: none;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  z-index: 160;
  backdrop-filter: blur(8px);
}
#game-over h2 {
  color: #3a2a1a;
  font-size: 2.5rem;
  font-weight: 300;
  letter-spacing: 0.4rem;
  margin-bottom: 0.5rem;
}
#game-over .final-grade {
  font-size: 4rem;
  font-weight: 300;
  margin: 0.5rem 0;
}
.go-stats {
  color: #6a5a4a;
  font-size: 0.85rem;
  line-height: 2;
  text-align: center;
  margin: 1rem 0;
}
.high-scores {
  margin-top: 1rem;
  font-size: 0.75rem;
  color: #8a7a6a;
  text-align: center;
  line-height: 1.8;
}
.high-scores h4 {
  color: #5a4a3a;
  font-size: 0.85rem;
  font-weight: normal;
  margin-bottom: 6px;
  letter-spacing: 0.1rem;
}

/* ===== GALLERY BAR ===== */
#gallery-bar {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  background: rgba(255,250,245,0.92);
  border-top: 1px solid #d8d0c0;
  padding: 8px 15px;
  z-index: 100;
  display: none;
  align-items: center;
  gap: 8px;
  font-size: 0.7rem;
  color: #6a5a4a;
  backdrop-filter: blur(8px);
}
#gallery-thumbs {
  display: flex;
  gap: 5px;
  overflow-x: auto;
  flex: 1;
}
.thumb {
  width: 50px;
  height: 35px;
  border: 1px solid #c8c0b0;
  border-radius: 3px;
  cursor: pointer;
  object-fit: cover;
  transition: border-color 0.2s ease;
}
.thumb:hover { border-color: #8a6a4a; }

/* ===== PARTICLES ===== */
.screen-particle {
  position: fixed;
  pointer-events: none;
  z-index: 130;
  border-radius: 50%;
}

/* ===== RESPONSIVE ===== */
@media (max-width: 768px) {
  #title-screen h1 { font-size: 2rem; }
  #controls { width: 175px; padding: 12px; font-size: 0.65rem; }
  .mode-row { flex-direction: column; gap: 6px; }
  .diff-row { flex-direction: column; gap: 6px; }
  #hud { font-size: 0.65rem; }
}
@media (max-width: 480px) {
  #controls { width: 155px; }
  #title-screen h1 { font-size: 1.6rem; letter-spacing: 0.2rem; }
}
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<div id="title-screen">
  <h1>QUILL & CURVE</h1>
  <div class="sub">paper filigree in the browser</div>
  <p>Draw flowing curves that transform into intricate quilled paper coils.
  Complete challenges, build combos, and master the art of paper quilling.</p>
  <div style="font-size:0.78rem;color:#6a5a4a;margin-bottom:0.8rem;">Difficulty</div>
  <div class="diff-row">
    <button class="diff-btn selected" onclick="setDifficulty('casual')" id="diff-casual">
      Casual
      <span class="diff-label">Relaxed timers</span>
    </button>
    <button class="diff-btn" onclick="setDifficulty('normal')" id="diff-normal">
      Normal
      <span class="diff-label">Standard pace</span>
    </button>
    <button class="diff-btn" onclick="setDifficulty('expert')" id="diff-expert">
      Expert
      <span class="diff-label">Tight deadlines</span>
    </button>
  </div>
  <div style="font-size:0.78rem;color:#6a5a4a;margin-bottom:0.5rem;">Mode</div>
  <div class="mode-row">
    <button class="btn" onclick="startApp('freehand')">Freehand</button>
    <button class="btn" onclick="startApp('challenge')">Challenge</button>
    <button class="btn" onclick="startApp('mandala')">Mandala</button>
  </div>
  <div class="keys-hint">
    Draw: mouse/touch | Scroll: coil size | ESC: pause | Z: undo | S: save | R: restart
  </div>
</div>

<div id="controls">
  <h3>Quill & Curve</h3>
  <div class="cr">
    <label>Coil Tightness</label>
    <input type="range" id="ctrl-tight" min="2" max="15" value="5">
  </div>
  <div class="cr">
    <label>Paper Width</label>
    <input type="range" id="ctrl-width" min="3" max="25" value="8">
  </div>
  <div class="cr">
    <label>Coil Layers</label>
    <input type="range" id="ctrl-layers" min="2" max="8" value="4">
  </div>
  <div class="cr">
    <label>3D Depth</label>
    <input type="range" id="ctrl-depth" min="1" max="10" value="4">
  </div>
  <div class="cr">
    <label>Style</label>
    <select id="ctrl-style">
      <option value="tight">Tight Coil</option>
      <option value="loose">Loose Spiral</option>
      <option value="marquise">Marquise</option>
      <option value="teardrop">Teardrop</option>
      <option value="heart">Heart</option>
    </select>
  </div>
  <div class="cr">
    <label>Mode</label>
    <select id="ctrl-mode">
      <option value="freehand">Freehand</option>
      <option value="mandala">Mandala</option>
      <option value="mirror">Mirror</option>
    </select>
  </div>
  <div class="cr">
    <label>Sound</label>
    <input type="checkbox" id="ctrl-sound" checked>
  </div>
  <div>
    <label style="font-size:0.72rem;color:#6a5a4a;">Paper Colors</label>
    <div id="palette"></div>
  </div>
  <div style="margin-top:8px;text-align:center;">
    <button class="btn-sm" onclick="app.clearCanvas()">Clear</button>
    <button class="btn-sm" onclick="app.undo()">Undo</button>
    <button class="btn-sm" onclick="app.saveImage()">Save</button>
    <button class="btn-sm" onclick="app.randomPattern()">Random</button>
  </div>
</div>

<div id="hud">
  <div>Score: <span id="hud-score">0</span></div>
  <div>Quills: <span id="hud-quills">0</span></div>
  <div>Coils: <span id="hud-coils">0</span></div>
  <div>Streak: <span id="hud-streak">0</span></div>
  <div class="combo-display" id="hud-combo"></div>
  <div>Level: <span id="hud-level">1</span></div>
  <div>Challenge: <span id="hud-challenge">--</span></div>
  <div>Gallery: <span id="hud-gallery">0</span></div>
</div>

<div id="challenge-hud">
  <div class="challenge-name" id="ch-name"></div>
  <div class="challenge-desc" id="ch-desc"></div>
  <div class="challenge-timer" id="ch-timer"></div>
</div>

<div id="pause-overlay">
  <h2>PAUSED</h2>
  <p>Press ESC or Space to continue</p>
  <div class="pause-stats" id="pause-stats"></div>
  <button class="btn" onclick="app.togglePause()">Continue</button>
  <button class="btn" style="margin-top:8px;" onclick="app.saveImage()">Save Image</button>
</div>

<div id="game-over">
  <h2>MASTERPIECE COMPLETE</h2>
  <div class="final-grade" id="go-grade" style="color:#8a6a4a;">A</div>
  <div class="go-stats" id="go-stats"></div>
  <div class="high-scores" id="go-highscores"></div>
  <div style="margin-top:1.5rem;">
    <button class="btn" onclick="restartGame()">New Canvas (R)</button>
    <button class="btn" onclick="backToTitle()">Title Screen</button>
  </div>
</div>

<div id="gallery-bar">
  <span>Gallery:</span>
  <div id="gallery-thumbs"></div>
</div>

<script>
// ==================== AUDIO ENGINE ====================
class QuillAudio {
  constructor() {
    this.ctx = null;
    this.initialized = false;
    this.enabled = true;
    this.master = null;
  }

  init() {
    if (this.initialized) return;
    try {
      this.ctx = new (window.AudioContext || window.webkitAudioContext)();
      this.master = this.ctx.createGain();
      this.master.gain.value = 0.06;

      const conv = this.ctx.createConvolver();
      const len = this.ctx.sampleRate * 2;
      const imp = this.ctx.createBuffer(2, len, this.ctx.sampleRate);
      for (let ch = 0; ch < 2; ch++) {
        const d = imp.getChannelData(ch);
        for (let i = 0; i < len; i++) {
          d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, 2.5);
        }
      }
      conv.buffer = imp;
      const wet = this.ctx.createGain();
      wet.gain.value = 0.35;
      this.master.connect(conv);
      conv.connect(wet);
      wet.connect(this.ctx.destination);
      this.master.connect(this.ctx.destination);

      // Gentle ambient pad
      const freqs = [261.63, 329.63, 392, 523.25];
      freqs.forEach((f, i) => {
        const osc = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        osc.type = 'sine';
        osc.frequency.value = f;
        g.gain.value = 0.003;
        const lfo = this.ctx.createOscillator();
        const lfoG = this.ctx.createGain();
        lfo.frequency.value = 0.05 + i * 0.02;
        lfoG.gain.value = 0.001;
        lfo.connect(lfoG);
        lfoG.connect(g.gain);
        lfo.start();
        osc.connect(g);
        g.connect(this.master);
        osc.start();
      });

      this.initialized = true;
    } catch(e) {}
  }

  _tone(freq, dur, type, vol) {
    if (!this.initialized || !this.enabled) return;
    const t = this.ctx.currentTime;
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    osc.type = type || 'triangle';
    osc.frequency.value = freq;
    g.gain.setValueAtTime(vol || 0.025, t);
    g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
    osc.connect(g);
    g.connect(this.master);
    osc.start(t);
    osc.stop(t + dur);
  }

  playCoil(x, y, w, h) {
    const notes = [261.63, 293.66, 329.63, 349.23, 392, 440, 493.88, 523.25];
    const freq = notes[Math.floor((y / h) * notes.length)] || 392;
    const pan = (x / w) * 2 - 1;
    if (!this.initialized || !this.enabled) return;
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    const panner = this.ctx.createStereoPanner();
    osc.type = 'triangle';
    osc.frequency.value = freq;
    g.gain.setValueAtTime(0.025, this.ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.0001, this.ctx.currentTime + 0.3);
    panner.pan.value = Math.max(-1, Math.min(1, pan));
    osc.connect(g);
    g.connect(panner);
    panner.connect(this.master);
    osc.start();
    osc.stop(this.ctx.currentTime + 0.3);
  }

  playPaperRustle() {
    if (!this.initialized || !this.enabled) return;
    const bufSize = this.ctx.sampleRate * 0.08;
    const buf = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < bufSize; i++) {
      data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufSize, 2);
    }
    const src = this.ctx.createBufferSource();
    src.buffer = buf;
    const filter = this.ctx.createBiquadFilter();
    filter.type = 'bandpass';
    filter.frequency.value = 2000;
    filter.Q.value = 3;
    const g = this.ctx.createGain();
    g.gain.value = 0.015;
    src.connect(filter);
    filter.connect(g);
    g.connect(this.master);
    src.start();
  }

  playCombo(level) {
    const base = 440;
    for (let i = 0; i < Math.min(level, 5); i++) {
      setTimeout(() => this._tone(base * Math.pow(1.25, i), 0.2, 'sine', 0.03), i * 80);
    }
  }

  playSuccess() {
    this._tone(523.25, 0.15, 'sine', 0.03);
    setTimeout(() => this._tone(659.25, 0.15, 'sine', 0.03), 100);
    setTimeout(() => this._tone(783.99, 0.25, 'sine', 0.04), 200);
  }

  playFail() {
    this._tone(200, 0.3, 'sawtooth', 0.02);
    setTimeout(() => this._tone(160, 0.4, 'sawtooth', 0.015), 150);
  }

  playLevelUp() {
    const notes = [392, 440, 493.88, 523.25, 587.33, 659.25];
    notes.forEach((f, i) => {
      setTimeout(() => this._tone(f, 0.2, 'sine', 0.035), i * 70);
    });
  }

  playMenu() {
    this._tone(440, 0.1, 'sine', 0.02);
  }

  setEnabled(v) {
    this.enabled = v;
    if (this.master) this.master.gain.value = v ? 0.06 : 0;
  }
}

// ==================== COLORS ====================
const COLORS = [
  '#e74c3c', '#f39c12', '#27ae60', '#3498db', '#9b59b6',
  '#e91e8f', '#1abc9c', '#e67e22', '#2c3e50', '#c0392b',
  '#f1c40f', '#8e44ad', '#d35400', '#16a085', '#2980b9',
  '#ecf0f1'
];

// ==================== COIL SHAPES ====================
function hexToRgb(hex) {
  const r = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return r ? { r: parseInt(r[1], 16), g: parseInt(r[2], 16), b: parseInt(r[3], 16) } : { r: 0, g: 0, b: 0 };
}

function drawCoilShape(ctx, x, y, size, color, style, layers, depthFactor) {
  const c = hexToRgb(color);

  // Shadow
  ctx.save();
  const shadowOffset = depthFactor * 2;
  ctx.fillStyle = 'rgba(0,0,0,0.08)';
  ctx.beginPath();
  ctx.ellipse(x + shadowOffset, y + shadowOffset, size * 0.9, size * 0.35, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();

  for (let layer = layers; layer >= 0; layer--) {
    const layerSize = size - layer * (size * 0.08);
    if (layerSize < 2) continue;

    const shade = Math.max(0.3, 1 - layer * 0.1);
    const highlight = layer === 0 ? 1.1 : 1;
    const lr = Math.min(255, Math.floor(c.r * shade * highlight));
    const lg = Math.min(255, Math.floor(c.g * shade * highlight));
    const lb = Math.min(255, Math.floor(c.b * shade * highlight));

    ctx.save();
    ctx.translate(x, y);

    switch (style) {
      case 'tight':
        ctx.beginPath();
        for (let a = 0; a <= Math.PI * 2; a += 0.05) {
          const r = layerSize + Math.sin(a * 6 + layer * 0.5) * 1.5;
          const px = Math.cos(a) * r;
          const py = Math.sin(a) * r * (0.4 + depthFactor * 0.03);
          if (a === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.closePath();
        break;

      case 'loose':
        ctx.beginPath();
        for (let a = 0; a <= Math.PI * 6; a += 0.1) {
          const progress = a / (Math.PI * 6);
          const r = layerSize * progress + Math.sin(a * 2) * 2;
          const px = Math.cos(a) * r;
          const py = Math.sin(a) * r * 0.45;
          if (a === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        break;

      case 'marquise':
        ctx.beginPath();
        for (let a = 0; a <= Math.PI * 2; a += 0.05) {
          const r = layerSize * (0.3 + 0.7 * Math.pow(Math.sin(a), 2));
          const px = Math.cos(a) * r * 1.5;
          const py = Math.sin(a) * r * 0.5;
          if (a === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.closePath();
        break;

      case 'teardrop':
        ctx.beginPath();
        for (let a = 0; a <= Math.PI * 2; a += 0.05) {
          const mod = 1 + 0.3 * Math.sin(a);
          const r = layerSize * mod * 0.8;
          const px = Math.cos(a) * r;
          const py = Math.sin(a) * r * 0.5 - (1 - Math.cos(a)) * layerSize * 0.3;
          if (a === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.closePath();
        break;

      case 'heart':
        ctx.beginPath();
        for (let a = 0; a <= Math.PI * 2; a += 0.05) {
          const r = layerSize * 0.7;
          const px = r * 16 * Math.pow(Math.sin(a), 3) / 16;
          const py = -r * (13 * Math.cos(a) - 5 * Math.cos(2*a) - 2 * Math.cos(3*a) - Math.cos(4*a)) / 16 * 0.4;
          if (a === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.closePath();
        break;
    }

    const grad = ctx.createLinearGradient(-layerSize, -layerSize * 0.3, layerSize, layerSize * 0.3);
    grad.addColorStop(0, 'rgb(' + Math.min(255, lr + 30) + ',' + Math.min(255, lg + 30) + ',' + Math.min(255, lb + 30) + ')');
    grad.addColorStop(0.5, 'rgb(' + lr + ',' + lg + ',' + lb + ')');
    grad.addColorStop(1, 'rgb(' + Math.max(0, lr - 20) + ',' + Math.max(0, lg - 20) + ',' + Math.max(0, lb - 20) + ')');
    ctx.fillStyle = grad;
    ctx.fill();

    ctx.strokeStyle = 'rgba(0,0,0,' + (0.05 + layer * 0.02) + ')';
    ctx.lineWidth = 0.5;
    ctx.stroke();

    if (layer === 0 && style === 'tight') {
      ctx.beginPath();
      for (let a = 0; a <= Math.PI * 6; a += 0.1) {
        const progress = a / (Math.PI * 6);
        const sr = layerSize * 0.8 * progress;
        const spx = Math.cos(a) * sr;
        const spy = Math.sin(a) * sr * 0.4;
        if (a === 0) ctx.moveTo(spx, spy);
        else ctx.lineTo(spx, spy);
      }
      ctx.strokeStyle = 'rgba(0,0,0,0.06)';
      ctx.lineWidth = 0.5;
      ctx.stroke();
    }

    ctx.restore();
  }

  // Highlight
  ctx.save();
  const hlGrad = ctx.createRadialGradient(x - size * 0.2, y - size * 0.1, 0, x, y, size * 0.4);
  hlGrad.addColorStop(0, 'rgba(255,255,255,0.2)');
  hlGrad.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.fillStyle = hlGrad;
  ctx.beginPath();
  ctx.ellipse(x, y, size * 0.4, size * 0.2, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

// ==================== CHALLENGES ====================
const CHALLENGE_TEMPLATES = [
  { name: 'Speed Coiler', desc: 'Place 20 coils in 15 seconds', type: 'coils', target: 20, baseTime: 15 },
  { name: 'Color Wheel', desc: 'Use 6 different colors', type: 'colors', target: 6, baseTime: 30 },
  { name: 'Mandala Master', desc: 'Create a mandala with 40+ coils', type: 'mandala_coils', target: 40, baseTime: 25 },
  { name: 'Style Sampler', desc: 'Use all 5 coil styles', type: 'styles', target: 5, baseTime: 35 },
  { name: 'Precision Ring', desc: 'Place 12 coils in a ring pattern', type: 'ring', target: 12, baseTime: 20 },
  { name: 'Tiny Filigree', desc: 'Place 30 coils smaller than size 6', type: 'tiny', target: 30, baseTime: 20 },
  { name: 'Grand Cascade', desc: 'Place 50 coils total', type: 'coils', target: 50, baseTime: 30 },
  { name: 'Heart Collection', desc: 'Place 15 heart-shaped coils', type: 'hearts', target: 15, baseTime: 20 },
  { name: 'Mirror Symmetry', desc: 'Place 24 coils in mirror mode', type: 'mirror_coils', target: 24, baseTime: 20 },
  { name: 'Teardrop Garden', desc: 'Place 18 teardrop coils', type: 'teardrops', target: 18, baseTime: 18 },
  { name: 'Rainbow Row', desc: 'Use 10+ colors in one line', type: 'colors', target: 10, baseTime: 40 },
  { name: 'Coil Sprint', desc: 'Place 35 coils in 10 seconds', type: 'coils', target: 35, baseTime: 10 },
];

// ==================== DIFFICULTY ====================
let selectedDifficulty = 'casual';
const DIFFICULTY = {
  casual:  { timeMult: 1.5, scoreMult: 0.8, label: 'Casual' },
  normal:  { timeMult: 1.0, scoreMult: 1.0, label: 'Normal' },
  expert:  { timeMult: 0.6, scoreMult: 1.5, label: 'Expert' },
};

function setDifficulty(d) {
  selectedDifficulty = d;
  document.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('selected'));
  document.getElementById('diff-' + d).classList.add('selected');
}

// ==================== SCREEN PARTICLES ====================
const screenParticles = [];

function spawnScreenParticle(x, y, color) {
  for (let i = 0; i < 6; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 1 + Math.random() * 3;
    screenParticles.push({
      x: x, y: y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed - 1.5,
      size: 2 + Math.random() * 4,
      life: 1,
      decay: 0.02 + Math.random() * 0.02,
      color: color || '#8a6a4a',
    });
  }
}

function updateScreenParticles() {
  for (let i = screenParticles.length - 1; i >= 0; i--) {
    const p = screenParticles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.05;
    p.life -= p.decay;
    if (p.life <= 0) {
      screenParticles.splice(i, 1);
    }
  }
}

function drawScreenParticles(ctx) {
  screenParticles.forEach(p => {
    ctx.save();
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  });
}

// ==================== SCREEN SHAKE ====================
let shakeX = 0, shakeY = 0, shakeMag = 0;
function triggerShake(magnitude) {
  shakeMag = magnitude || 4;
}
function updateShake() {
  if (shakeMag > 0.1) {
    shakeX = (Math.random() - 0.5) * shakeMag;
    shakeY = (Math.random() - 0.5) * shakeMag;
    shakeMag *= 0.9;
  } else {
    shakeX = shakeY = 0;
    shakeMag = 0;
  }
}

// ==================== MAIN APP ====================
class QuillApp {
  constructor() {
    this.canvas = document.getElementById('canvas');
    this.ctx = this.canvas.getContext('2d');
    this.W = window.innerWidth;
    this.H = window.innerHeight;
    this.canvas.width = this.W;
    this.canvas.height = this.H;

    this.audio = new QuillAudio();
    this.paused = false;
    this.started = false;
    this.gameOver = false;
    this.frame = 0;
    this.gameMode = 'freehand'; // freehand, challenge, mandala

    // Drawing
    this.drawing = false;
    this.lastX = 0;
    this.lastY = 0;
    this.currentPath = [];
    this.quills = [];
    this.undoStack = [];
    this.totalCoils = 0;

    // Settings
    this.tightness = 5;
    this.paperWidth = 8;
    this.coilLayers = 4;
    this.depthFactor = 4;
    this.coilStyle = 'tight';
    this.drawMode = 'freehand';
    this.currentColor = COLORS[0];
    this.mandalaFolds = 8;

    // Scoring
    this.score = 0;
    this.streak = 0;
    this.maxStreak = 0;
    this.comboLevel = 1;
    this.comboTimer = 0;
    this.level = 1;
    this.xpToNext = 50;
    this.xp = 0;
    this.colorsUsed = new Set();
    this.stylesUsed = new Set();

    // Challenges
    this.currentChallenge = null;
    this.challengeTimer = 0;
    this.challengeProgress = 0;
    this.challengesCompleted = 0;
    this.challengeCoils = 0;
    this.challengeHearts = 0;
    this.challengeTeardrops = 0;
    this.challengeMirrorCoils = 0;
    this.challengeTinyCoils = 0;
    this.challengeMandalaCoils = 0;

    // Gallery
    this.gallery = [];
    this.galleryCount = 0;

    // Keys
    this.keys = {};

    this.setupPalette();
    this.setupEvents();
    this.setupControls();
    this.loadState();
  }

  setupPalette() {
    const container = document.getElementById('palette');
    COLORS.forEach((color, i) => {
      const swatch = document.createElement('div');
      swatch.className = 'color-swatch' + (i === 0 ? ' active' : '');
      swatch.style.background = color;
      swatch.addEventListener('click', () => {
        document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
        swatch.classList.add('active');
        this.currentColor = color;
        this.audio.playMenu();
      });
      container.appendChild(swatch);
    });
  }

  setupEvents() {
    window.addEventListener('resize', () => {
      const imgData = this.ctx.getImageData(0, 0, this.W, this.H);
      this.W = window.innerWidth;
      this.H = window.innerHeight;
      this.canvas.width = this.W;
      this.canvas.height = this.H;
      this.drawPaperTexture();
      this.ctx.putImageData(imgData, 0, 0);
    });

    this.canvas.addEventListener('mousedown', (e) => this.startDraw(e.clientX, e.clientY));
    this.canvas.addEventListener('mousemove', (e) => {
      if (this.drawing) this.continueDraw(e.clientX, e.clientY);
    });
    this.canvas.addEventListener('mouseup', () => this.endDraw());
    this.canvas.addEventListener('mouseleave', () => this.endDraw());

    this.canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      this.startDraw(e.touches[0].clientX, e.touches[0].clientY);
    }, { passive: false });
    this.canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (this.drawing) this.continueDraw(e.touches[0].clientX, e.touches[0].clientY);
    }, { passive: false });
    this.canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      this.endDraw();
    }, { passive: false });

    this.canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      this.paperWidth += e.deltaY > 0 ? -1 : 1;
      this.paperWidth = Math.max(3, Math.min(25, this.paperWidth));
      document.getElementById('ctrl-width').value = this.paperWidth;
    }, { passive: false });

    document.addEventListener('keydown', (e) => {
      this.keys[e.key] = true;
      if (e.key === 'Escape') {
        e.preventDefault();
        if (this.gameOver) return;
        this.togglePause();
      } else if (e.key === ' ') {
        e.preventDefault();
        if (!this.gameOver) this.togglePause();
      } else if (e.key === 'z' || e.key === 'Z') {
        if (!e.ctrlKey && !e.metaKey) this.undo();
      } else if (e.key === 's' || e.key === 'S') {
        if (!e.ctrlKey && !e.metaKey) this.saveImage();
      } else if (e.key === 'c' || e.key === 'C') {
        if (!e.ctrlKey && !e.metaKey) this.clearCanvas();
      } else if ((e.key === 'r' || e.key === 'R') && !e.ctrlKey && !e.metaKey) {
        restartGame();
      }
    });

    document.addEventListener('keyup', (e) => {
      this.keys[e.key] = false;
    });
  }

  setupControls() {
    document.getElementById('ctrl-tight').addEventListener('input', (e) => {
      this.tightness = parseInt(e.target.value);
    });
    document.getElementById('ctrl-width').addEventListener('input', (e) => {
      this.paperWidth = parseInt(e.target.value);
    });
    document.getElementById('ctrl-layers').addEventListener('input', (e) => {
      this.coilLayers = parseInt(e.target.value);
    });
    document.getElementById('ctrl-depth').addEventListener('input', (e) => {
      this.depthFactor = parseInt(e.target.value);
    });
    document.getElementById('ctrl-style').addEventListener('change', (e) => {
      this.coilStyle = e.target.value;
    });
    document.getElementById('ctrl-mode').addEventListener('change', (e) => {
      this.drawMode = e.target.value;
    });
    document.getElementById('ctrl-sound').addEventListener('change', (e) => {
      this.audio.setEnabled(e.target.checked);
    });
  }

  drawPaperTexture() {
    const ctx = this.ctx;
    ctx.fillStyle = '#f5f0e8';
    ctx.fillRect(0, 0, this.W, this.H);

    const imgData = ctx.getImageData(0, 0, this.W, this.H);
    const data = imgData.data;
    for (let i = 0; i < data.length; i += 4) {
      const noise = (Math.random() - 0.5) * 6;
      data[i] = Math.max(0, Math.min(255, data[i] + noise));
      data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise));
      data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise));
    }
    ctx.putImageData(imgData, 0, 0);

    ctx.globalAlpha = 0.02;
    for (let i = 0; i < 80; i++) {
      ctx.beginPath();
      ctx.moveTo(Math.random() * this.W, Math.random() * this.H);
      const angle = Math.random() * Math.PI;
      const len = 30 + Math.random() * 80;
      ctx.lineTo(
        Math.random() * this.W + Math.cos(angle) * len,
        Math.random() * this.H + Math.sin(angle) * len
      );
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 0.5;
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }

  // ===== COMBO SYSTEM =====
  addCombo() {
    this.streak++;
    if (this.streak > this.maxStreak) this.maxStreak = this.streak;
    this.comboTimer = 120; // 2 seconds at 60fps

    const oldLevel = this.comboLevel;
    if (this.streak >= 50) this.comboLevel = 8;
    else if (this.streak >= 35) this.comboLevel = 6;
    else if (this.streak >= 25) this.comboLevel = 5;
    else if (this.streak >= 15) this.comboLevel = 4;
    else if (this.streak >= 10) this.comboLevel = 3;
    else if (this.streak >= 5) this.comboLevel = 2;
    else this.comboLevel = 1;

    if (this.comboLevel > oldLevel) {
      this.audio.playCombo(this.comboLevel);
      triggerShake(this.comboLevel * 1.5);
      spawnScreenParticle(this.lastX, this.lastY, this.currentColor);
    }
  }

  breakCombo() {
    if (this.streak > 5) {
      this.audio.playFail();
    }
    this.streak = 0;
    this.comboLevel = 1;
  }

  addScore(base) {
    const diff = DIFFICULTY[selectedDifficulty];
    const pts = Math.floor(base * this.comboLevel * diff.scoreMult);
    this.score += pts;
    this.xp += pts;

    // Level up check
    while (this.xp >= this.xpToNext) {
      this.xp -= this.xpToNext;
      this.level++;
      this.xpToNext = Math.floor(this.xpToNext * 1.4);
      this.audio.playLevelUp();
      triggerShake(8);
      for (let i = 0; i < 12; i++) {
        spawnScreenParticle(this.W / 2 + (Math.random() - 0.5) * 200, this.H / 2, COLORS[Math.floor(Math.random() * COLORS.length)]);
      }
    }
  }

  // ===== CHALLENGES =====
  startChallenge() {
    const idx = Math.floor(Math.random() * CHALLENGE_TEMPLATES.length);
    const template = CHALLENGE_TEMPLATES[idx];
    const diff = DIFFICULTY[selectedDifficulty];

    this.currentChallenge = { ...template };
    this.challengeTimer = Math.floor(template.baseTime * diff.timeMult * 60); // frames
    this.challengeProgress = 0;
    this.challengeCoils = 0;
    this.challengeHearts = 0;
    this.challengeTeardrops = 0;
    this.challengeMirrorCoils = 0;
    this.challengeTinyCoils = 0;
    this.challengeMandalaCoils = 0;
    this.colorsUsed = new Set();
    this.stylesUsed = new Set();

    document.getElementById('ch-name').textContent = template.name;
    document.getElementById('ch-desc').textContent = template.desc;
    document.getElementById('challenge-hud').style.display = 'block';

    setTimeout(() => {
      document.getElementById('challenge-hud').style.display = 'none';
    }, 3000);
  }

  updateChallenge() {
    if (!this.currentChallenge) return;
    if (this.paused || this.gameOver) return;

    this.challengeTimer--;
    const secs = Math.max(0, Math.ceil(this.challengeTimer / 60));
    document.getElementById('ch-timer').textContent = secs + 's';
    document.getElementById('hud-challenge').textContent = this.currentChallenge.name + ' ' + secs + 's';

    // Check progress
    let progress = 0;
    const ch = this.currentChallenge;
    switch (ch.type) {
      case 'coils': progress = this.challengeCoils; break;
      case 'colors': progress = this.colorsUsed.size; break;
      case 'styles': progress = this.stylesUsed.size; break;
      case 'hearts': progress = this.challengeHearts; break;
      case 'teardrops': progress = this.challengeTeardrops; break;
      case 'mirror_coils': progress = this.challengeMirrorCoils; break;
      case 'tiny': progress = this.challengeTinyCoils; break;
      case 'mandala_coils': progress = this.challengeMandalaCoils; break;
      case 'ring': progress = this.challengeCoils; break;
    }

    if (progress >= ch.target) {
      // Challenge complete
      this.challengesCompleted++;
      const bonus = 100 * this.level;
      this.addScore(bonus);
      this.audio.playSuccess();
      triggerShake(6);
      for (let i = 0; i < 15; i++) {
        spawnScreenParticle(this.W / 2, this.H / 3, COLORS[Math.floor(Math.random() * COLORS.length)]);
      }

      // Start next challenge after delay
      this.currentChallenge = null;
      document.getElementById('hud-challenge').textContent = 'Complete!';
      setTimeout(() => {
        if (this.gameMode === 'challenge' && !this.gameOver && !this.paused) {
          this.startChallenge();
        }
      }, 2000);
      return;
    }

    if (this.challengeTimer <= 0) {
      // Challenge failed
      this.audio.playFail();
      this.breakCombo();
      this.currentChallenge = null;
      document.getElementById('hud-challenge').textContent = 'Failed!';

      if (this.gameMode === 'challenge') {
        // In challenge mode, 3 failures = game over
        this.challengesCompleted = Math.max(0, this.challengesCompleted);
        // Continue with next challenge
        setTimeout(() => {
          if (!this.gameOver && !this.paused) {
            this.startChallenge();
          }
        }, 2000);
      }
    }
  }

  // ===== DRAWING =====
  startDraw(x, y) {
    if (this.paused || this.gameOver) return;
    this.drawing = true;
    this.currentPath = [{ x, y }];
    this.lastX = x;
    this.lastY = y;
    this.undoStack.push(this.ctx.getImageData(0, 0, this.W, this.H));
    if (this.undoStack.length > 15) this.undoStack.shift();
  }

  continueDraw(x, y) {
    if (!this.drawing || this.paused || this.gameOver) return;

    this.currentPath.push({ x, y });

    const dx = x - this.lastX;
    const dy = y - this.lastY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const spacing = this.tightness * 3;

    if (dist >= spacing) {
      const coilSize = this.paperWidth + Math.random() * this.paperWidth * 0.3;

      // Track for challenges
      this.colorsUsed.add(this.currentColor);
      this.stylesUsed.add(this.coilStyle);

      if (this.drawMode === 'mandala') {
        const cx = this.W / 2;
        const cy = this.H / 2;
        const relX = x - cx;
        const relY = y - cy;
        const folds = this.mandalaFolds;
        const angleStep = Math.PI * 2 / folds;

        for (let i = 0; i < folds; i++) {
          const angle = angleStep * i;
          const cos = Math.cos(angle);
          const sin = Math.sin(angle);
          const px = cx + relX * cos - relY * sin;
          const py = cy + relX * sin + relY * cos;
          drawCoilShape(this.ctx, px, py, coilSize, this.currentColor, this.coilStyle, this.coilLayers, this.depthFactor);
          this.totalCoils++;
          this.challengeCoils++;
          this.challengeMandalaCoils++;

          const mx = cx + relX * cos + relY * sin;
          const my = cy + relX * sin - relY * cos;
          drawCoilShape(this.ctx, mx, my, coilSize, this.currentColor, this.coilStyle, this.coilLayers, this.depthFactor);
          this.totalCoils++;
          this.challengeCoils++;
          this.challengeMandalaCoils++;
        }
      } else if (this.drawMode === 'mirror') {
        drawCoilShape(this.ctx, x, y, coilSize, this.currentColor, this.coilStyle, this.coilLayers, this.depthFactor);
        drawCoilShape(this.ctx, this.W - x, y, coilSize, this.currentColor, this.coilStyle, this.coilLayers, this.depthFactor);
        drawCoilShape(this.ctx, x, this.H - y, coilSize, this.currentColor, this.coilStyle, this.coilLayers, this.depthFactor);
        drawCoilShape(this.ctx, this.W - x, this.H - y, coilSize, this.currentColor, this.coilStyle, this.coilLayers, this.depthFactor);
        this.totalCoils += 4;
        this.challengeCoils += 4;
        this.challengeMirrorCoils += 4;
      } else {
        drawCoilShape(this.ctx, x, y, coilSize, this.currentColor, this.coilStyle, this.coilLayers, this.depthFactor);
        this.totalCoils++;
        this.challengeCoils++;
      }

      // Track specific shape challenges
      if (this.coilStyle === 'heart') this.challengeHearts++;
      if (this.coilStyle === 'teardrop') this.challengeTeardrops++;
      if (coilSize < 6) this.challengeTinyCoils++;

      this.addCombo();
      this.addScore(5 + this.level);
      this.audio.playCoil(x, y, this.W, this.H);
      this.lastX = x;
      this.lastY = y;
    }

    if (this.frame % 10 === 0) {
      this.audio.playPaperRustle();
    }

    this.updateHUD();
  }

  endDraw() {
    if (this.drawing && this.currentPath.length > 1) {
      this.quills.push({
        points: [...this.currentPath],
        color: this.currentColor,
        style: this.coilStyle,
        layers: this.coilLayers
      });
    }
    this.drawing = false;
    this.currentPath = [];
    this.updateHUD();
  }

  undo() {
    if (this.undoStack.length > 0) {
      const imgData = this.undoStack.pop();
      this.ctx.putImageData(imgData, 0, 0);
      if (this.quills.length > 0) this.quills.pop();
      this.audio.playMenu();
    }
  }

  clearCanvas() {
    this.undoStack.push(this.ctx.getImageData(0, 0, this.W, this.H));
    this.quills = [];
    this.totalCoils = 0;
    this.drawPaperTexture();
    this.updateHUD();
  }

  randomPattern() {
    this.undoStack.push(this.ctx.getImageData(0, 0, this.W, this.H));
    const styles = ['tight', 'loose', 'marquise', 'teardrop', 'heart'];

    const patternType = Math.floor(Math.random() * 4);

    if (patternType === 0) {
      // Mandala
      const cx = this.W / 2;
      const cy = this.H / 2;
      const folds = 6 + Math.floor(Math.random() * 6);
      const rings = 3 + Math.floor(Math.random() * 4);
      for (let ring = 0; ring < rings; ring++) {
        const radius = 60 + ring * 50;
        const color = COLORS[Math.floor(Math.random() * COLORS.length)];
        const style = styles[Math.floor(Math.random() * styles.length)];
        const coilSize = 10 + Math.random() * 15;
        for (let i = 0; i < folds; i++) {
          const angle = (i / folds) * Math.PI * 2;
          const px = cx + Math.cos(angle) * radius;
          const py = cy + Math.sin(angle) * radius;
          drawCoilShape(this.ctx, px, py, coilSize, color, style, this.coilLayers, this.depthFactor);
          this.totalCoils++;
          this.challengeCoils++;
          this.addScore(3);
        }
      }
    } else if (patternType === 1) {
      // Scatter
      for (let i = 0; i < 30; i++) {
        const x = this.W * 0.15 + Math.random() * this.W * 0.7;
        const y = this.H * 0.15 + Math.random() * this.H * 0.7;
        const color = COLORS[Math.floor(Math.random() * COLORS.length)];
        const style = styles[Math.floor(Math.random() * styles.length)];
        const size = 8 + Math.random() * 20;
        drawCoilShape(this.ctx, x, y, size, color, style, this.coilLayers, this.depthFactor);
        this.totalCoils++;
        this.challengeCoils++;
        this.addScore(3);
      }
    } else if (patternType === 2) {
      // Vine
      let x = this.W * 0.1;
      let y = this.H * 0.5;
      let angle = 0;
      for (let i = 0; i < 40; i++) {
        angle += (Math.random() - 0.5) * 0.5;
        x += Math.cos(angle) * 20;
        y += Math.sin(angle) * 20;
        const color = COLORS[i % COLORS.length];
        const size = 6 + Math.random() * 12;
        drawCoilShape(this.ctx, x, y, size, color, 'tight', this.coilLayers, this.depthFactor);
        this.totalCoils++;
        this.challengeCoils++;
        this.addScore(3);
        if (Math.random() < 0.3) {
          const branchAngle = angle + (Math.random() > 0.5 ? 1 : -1) * Math.PI * 0.4;
          for (let j = 0; j < 3; j++) {
            const bx = x + Math.cos(branchAngle) * (15 + j * 12);
            const by = y + Math.sin(branchAngle) * (15 + j * 12);
            drawCoilShape(this.ctx, bx, by, size * 0.7, color, 'teardrop', this.coilLayers, this.depthFactor);
            this.totalCoils++;
            this.challengeCoils++;
          }
        }
      }
    } else {
      // Spiral galaxy
      const cx = this.W / 2;
      const cy = this.H / 2;
      for (let arm = 0; arm < 3; arm++) {
        const armAngle = (arm / 3) * Math.PI * 2;
        for (let i = 0; i < 20; i++) {
          const r = 30 + i * 12;
          const a = armAngle + i * 0.3;
          const px = cx + Math.cos(a) * r + (Math.random() - 0.5) * 15;
          const py = cy + Math.sin(a) * r + (Math.random() - 0.5) * 15;
          const color = COLORS[(arm * 4 + i) % COLORS.length];
          const size = 5 + Math.random() * 10;
          drawCoilShape(this.ctx, px, py, size, color, styles[arm % styles.length], this.coilLayers, this.depthFactor);
          this.totalCoils++;
          this.challengeCoils++;
          this.addScore(3);
        }
      }
    }

    this.addCombo();
    triggerShake(3);
    this.updateHUD();
  }

  togglePause() {
    this.paused = !this.paused;
    const overlay = document.getElementById('pause-overlay');
    overlay.style.display = this.paused ? 'flex' : 'none';
    if (this.paused) {
      document.getElementById('pause-stats').innerHTML =
        'Score: ' + this.score + '<br>' +
        'Level: ' + this.level + '<br>' +
        'Coils placed: ' + this.totalCoils + '<br>' +
        'Max streak: ' + this.maxStreak + '<br>' +
        'Challenges done: ' + this.challengesCompleted + '<br>' +
        'Difficulty: ' + DIFFICULTY[selectedDifficulty].label;
    }
    this.audio.playMenu();
  }

  saveImage() {
    const link = document.createElement('a');
    link.download = 'quill-and-curve-' + Date.now() + '.png';
    link.href = this.canvas.toDataURL('image/png');
    link.click();

    this.galleryCount++;
    const thumb = document.createElement('img');
    thumb.className = 'thumb';
    thumb.src = this.canvas.toDataURL('image/jpeg', 0.3);
    document.getElementById('gallery-thumbs').appendChild(thumb);
    this.addScore(25);
    this.updateHUD();
    this.saveState();
  }

  endGame() {
    this.gameOver = true;
    document.getElementById('game-over').style.display = 'flex';

    const grade = this.score >= 5000 ? 'S' :
                  this.score >= 3000 ? 'A' :
                  this.score >= 1500 ? 'B' :
                  this.score >= 500 ? 'C' : 'D';

    const gradeColors = { S: '#f1c40f', A: '#27ae60', B: '#3498db', C: '#e67e22', D: '#c0392b' };
    document.getElementById('go-grade').textContent = grade;
    document.getElementById('go-grade').style.color = gradeColors[grade];

    document.getElementById('go-stats').innerHTML =
      'Score: ' + this.score + '<br>' +
      'Level: ' + this.level + '<br>' +
      'Total Coils: ' + this.totalCoils + '<br>' +
      'Max Streak: ' + this.maxStreak + '<br>' +
      'Challenges Completed: ' + this.challengesCompleted + '<br>' +
      'Colors Used: ' + this.colorsUsed.size + '<br>' +
      'Styles Used: ' + this.stylesUsed.size + '<br>' +
      'Difficulty: ' + DIFFICULTY[selectedDifficulty].label;

    this.saveHighScore(this.score, grade);
    this.renderHighScores();
    this.saveState();
  }

  saveHighScore(score, grade) {
    try {
      const key = 'quill-curve-highscores';
      let scores = JSON.parse(localStorage.getItem(key) || '[]');
      scores.push({
        score: score,
        grade: grade,
        level: this.level,
        coils: this.totalCoils,
        difficulty: selectedDifficulty,
        date: new Date().toISOString().split('T')[0]
      });
      scores.sort((a, b) => b.score - a.score);
      scores = scores.slice(0, 10);
      localStorage.setItem(key, JSON.stringify(scores));
    } catch(e) {}
  }

  renderHighScores() {
    try {
      const scores = JSON.parse(localStorage.getItem('quill-curve-highscores') || '[]');
      const el = document.getElementById('go-highscores');
      if (scores.length === 0) {
        el.innerHTML = '<h4>No high scores yet</h4>';
        return;
      }
      let html = '<h4>High Scores</h4>';
      scores.slice(0, 5).forEach((s, i) => {
        html += (i + 1) + '. ' + s.score + ' (' + s.grade + ') Lv' + s.level + ' ' + s.difficulty + ' ' + s.date + '<br>';
      });
      el.innerHTML = html;
    } catch(e) {}
  }

  updateHUD() {
    document.getElementById('hud-score').textContent = this.score;
    document.getElementById('hud-quills').textContent = this.quills.length;
    document.getElementById('hud-coils').textContent = this.totalCoils;
    document.getElementById('hud-streak').textContent = this.streak;
    document.getElementById('hud-level').textContent = this.level;
    document.getElementById('hud-gallery').textContent = this.galleryCount;

    const comboEl = document.getElementById('hud-combo');
    if (this.comboLevel > 1) {
      comboEl.textContent = 'x' + this.comboLevel + ' COMBO';
    } else {
      comboEl.textContent = '';
    }
  }

  saveState() {
    try {
      localStorage.setItem('quill-and-curve', JSON.stringify({
        tightness: this.tightness,
        paperWidth: this.paperWidth,
        coilLayers: this.coilLayers,
        depthFactor: this.depthFactor,
        coilStyle: this.coilStyle,
        drawMode: this.drawMode,
        galleryCount: this.galleryCount,
        totalCoils: this.totalCoils,
        bestScore: Math.max(this.score, parseInt(localStorage.getItem('quill-curve-best') || '0')),
        difficulty: selectedDifficulty,
      }));
      if (this.score > parseInt(localStorage.getItem('quill-curve-best') || '0')) {
        localStorage.setItem('quill-curve-best', this.score.toString());
      }
    } catch(e) {}
  }

  loadState() {
    try {
      const saved = JSON.parse(localStorage.getItem('quill-and-curve'));
      if (saved) {
        this.tightness = saved.tightness || 5;
        this.paperWidth = saved.paperWidth || 8;
        this.coilLayers = saved.coilLayers || 4;
        this.depthFactor = saved.depthFactor || 4;
        this.coilStyle = saved.coilStyle || 'tight';
        this.drawMode = saved.drawMode || 'freehand';
        this.galleryCount = saved.galleryCount || 0;

        document.getElementById('ctrl-tight').value = this.tightness;
        document.getElementById('ctrl-width').value = this.paperWidth;
        document.getElementById('ctrl-layers').value = this.coilLayers;
        document.getElementById('ctrl-depth').value = this.depthFactor;
        document.getElementById('ctrl-style').value = this.coilStyle;
        document.getElementById('ctrl-mode').value = this.drawMode;

        if (saved.difficulty) {
          selectedDifficulty = saved.difficulty;
          setDifficulty(saved.difficulty);
        }
      }
    } catch(e) {}
  }

  update() {
    if (this.paused || this.gameOver) return;
    this.frame++;

    // Combo decay
    if (this.comboTimer > 0) {
      this.comboTimer--;
      if (this.comboTimer <= 0 && !this.drawing) {
        this.breakCombo();
      }
    }

    // Update challenges
    if (this.gameMode === 'challenge' && this.currentChallenge) {
      this.updateChallenge();
    }

    // Auto-save periodically
    if (this.frame % 600 === 0) this.saveState();

    // Shake + particles
    updateShake();
    updateScreenParticles();

    // Apply shake to canvas
    if (shakeMag > 0.1) {
      this.canvas.style.transform = 'translate(' + shakeX + 'px,' + shakeY + 'px)';
    } else {
      this.canvas.style.transform = '';
    }

    // Draw screen particles on canvas
    drawScreenParticles(this.ctx);

    this.updateHUD();
  }

  run() {
    const loop = () => {
      this.update();
      requestAnimationFrame(loop);
    };
    loop();
  }
}

// ==================== GLOBALS ====================
let app;

function startApp(mode) {
  app = new QuillApp();

  if (mode === 'mandala') {
    app.drawMode = 'mandala';
    app.gameMode = 'freehand';
  } else if (mode === 'challenge') {
    app.drawMode = 'freehand';
    app.gameMode = 'challenge';
  } else {
    app.drawMode = 'freehand';
    app.gameMode = 'freehand';
  }

  document.getElementById('ctrl-mode').value = app.drawMode;
  app.started = true;
  app.audio.init();
  app.drawPaperTexture();
  app.updateHUD();

  // Show UI
  document.getElementById('controls').style.display = 'block';
  document.getElementById('hud').style.display = 'block';
  document.getElementById('gallery-bar').style.display = 'flex';

  const title = document.getElementById('title-screen');
  title.style.opacity = '0';
  setTimeout(() => { title.style.display = 'none'; }, 1500);

  // Start challenge mode
  if (app.gameMode === 'challenge') {
    setTimeout(() => app.startChallenge(), 2000);
  }

  app.run();
}

function restartGame() {
  document.getElementById('game-over').style.display = 'none';
  if (app) {
    app.gameOver = false;
    app.paused = false;
    app.score = 0;
    app.streak = 0;
    app.maxStreak = 0;
    app.comboLevel = 1;
    app.level = 1;
    app.xp = 0;
    app.xpToNext = 50;
    app.totalCoils = 0;
    app.quills = [];
    app.undoStack = [];
    app.challengesCompleted = 0;
    app.colorsUsed = new Set();
    app.stylesUsed = new Set();
    app.drawPaperTexture();
    app.updateHUD();
    if (app.gameMode === 'challenge') {
      setTimeout(() => app.startChallenge(), 1000);
    }
  }
}

function backToTitle() {
  document.getElementById('game-over').style.display = 'none';
  document.getElementById('controls').style.display = 'none';
  document.getElementById('hud').style.display = 'none';
  document.getElementById('gallery-bar').style.display = 'none';
  document.getElementById('title-screen').style.display = 'flex';
  document.getElementById('title-screen').style.opacity = '1';
}

// Title background
(function() {
  const c = document.getElementById('canvas');
  const ctx = c.getContext('2d');
  c.width = window.innerWidth;
  c.height = window.innerHeight;
  ctx.fillStyle = '#f5f0e8';
  ctx.fillRect(0, 0, c.width, c.height);

  const colors = ['#e74c3c', '#f39c12', '#27ae60', '#3498db', '#9b59b6'];
  const cx = c.width / 2;
  const cy = c.height / 2;
  for (let ring = 0; ring < 3; ring++) {
    const radius = 40 + ring * 35;
    for (let i = 0; i < 8; i++) {
      const angle = (i / 8) * Math.PI * 2;
      const px = cx + Math.cos(angle) * radius;
      const py = cy + Math.sin(angle) * radius;
      const color = colors[(ring + i) % colors.length];
      drawCoilShape(ctx, px, py, 8 + ring * 3, color, 'tight', 3, 3);
    }
  }
})();
</script>
</body>
</html>