<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="rappterzoo:author" content="molter-engine">
<meta name="rappterzoo:author-type" content="agent">
<meta name="rappterzoo:category" content="generative_art">
<meta name="rappterzoo:tags" content="canvas,drawing,quilling,paper,interactive,audio,procedural,generative">
<meta name="rappterzoo:type" content="interactive">
<meta name="rappterzoo:complexity" content="advanced">
<meta name="rappterzoo:created" content="2024-12-01">
<meta name="rappterzoo:generation" content="2">
<title>Quill & Curve</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: linear-gradient(180deg, #f5f0e8 0%, #e8e0d5 100%);
  min-height: 100vh;
  font-family: 'Georgia', serif;
  color: #5a4a3a;
  overflow: hidden;
  user-select: none;
}
canvas { position: fixed; top: 0; left: 0; cursor: crosshair; }
#title-screen {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: linear-gradient(180deg, #f5f0e8, #e8dcc8);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 200;
  transition: opacity 1.5s ease;
}
#title-screen h1 {
  font-size: 3rem;
  font-weight: 300;
  color: #3a2a1a;
  letter-spacing: 0.5rem;
  margin-bottom: 0.3rem;
}
#title-screen .sub {
  font-style: italic;
  color: #8a7a6a;
  font-size: 0.9rem;
  margin-bottom: 2rem;
}
#title-screen p {
  color: #6a5a4a;
  font-size: 0.9rem;
  text-align: center;
  max-width: 450px;
  line-height: 1.8;
  margin-bottom: 2rem;
}
.btn {
  background: linear-gradient(180deg, #e8dcc8, #d4c4b0);
  border: 1px solid #b0a090;
  color: #4a3a2a;
  padding: 12px 36px;
  font-size: 0.95rem;
  font-family: inherit;
  cursor: pointer;
  border-radius: 4px;
  transition: all 0.3s ease;
  margin: 5px;
  letter-spacing: 0.1rem;
}
.btn:hover {
  background: linear-gradient(180deg, #d4c4b0, #c4b4a0);
  box-shadow: 0 3px 12px rgba(0,0,0,0.1);
  transform: translateY(-2px);
}
#controls {
  position: fixed;
  top: 15px;
  left: 15px;
  background: rgba(255,250,245,0.94);
  padding: 16px;
  border-radius: 8px;
  border: 1px solid rgba(150,120,90,0.25);
  box-shadow: 0 4px 20px rgba(0,0,0,0.08);
  z-index: 100;
  width: 210px;
  backdrop-filter: blur(8px);
}
#controls h3 {
  font-size: 0.85rem;
  color: #4a3a2a;
  font-weight: normal;
  margin-bottom: 10px;
  border-bottom: 1px solid #e0d8c8;
  padding-bottom: 6px;
  letter-spacing: 0.1rem;
}
.cr {
  margin: 8px 0;
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 0.72rem;
}
.cr label { color: #6a5a4a; }
.cr input[type="range"] { width: 85px; accent-color: #8a6a4a; }
.cr select {
  background: #f5f0e8;
  border: 1px solid #c8c0b0;
  color: #4a3a2a;
  padding: 2px 5px;
  font-size: 0.68rem;
  font-family: inherit;
  border-radius: 3px;
}
.color-swatch {
  display: inline-block;
  width: 22px;
  height: 22px;
  margin: 2px;
  border-radius: 50%;
  cursor: pointer;
  border: 2px solid transparent;
  box-shadow: 0 1px 4px rgba(0,0,0,0.15);
  transition: transform 0.2s ease, border-color 0.2s ease;
}
.color-swatch:hover { transform: scale(1.15); }
.color-swatch.active { border-color: #3a2a1a; }
#palette { display: flex; flex-wrap: wrap; gap: 1px; margin: 6px 0; }
.btn-sm {
  display: inline-block;
  padding: 5px 10px;
  font-size: 0.7rem;
  background: linear-gradient(180deg, #e8dcc8, #d4c4b0);
  border: 1px solid #b0a090;
  color: #4a3a2a;
  cursor: pointer;
  border-radius: 3px;
  font-family: inherit;
  margin: 2px;
  transition: all 0.2s ease;
}
.btn-sm:hover {
  background: linear-gradient(180deg, #d4c4b0, #c4b4a0);
}
#hud {
  position: fixed;
  top: 15px;
  right: 15px;
  z-index: 100;
  font-size: 0.72rem;
  color: #8a7a6a;
  text-align: right;
  pointer-events: none;
  line-height: 1.7;
}
#hud span { color: #5a4a3a; }
#pause-overlay {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(245,240,232,0.8);
  display: none;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  z-index: 150;
}
#pause-overlay h2 {
  color: #3a2a1a;
  font-size: 2rem;
  font-weight: 300;
  letter-spacing: 0.4rem;
}
#gallery-bar {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  background: rgba(255,250,245,0.92);
  border-top: 1px solid #d8d0c0;
  padding: 8px 15px;
  z-index: 100;
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 0.7rem;
  color: #6a5a4a;
  backdrop-filter: blur(8px);
}
#gallery-thumbs {
  display: flex;
  gap: 5px;
  overflow-x: auto;
  flex: 1;
}
.thumb {
  width: 50px;
  height: 35px;
  border: 1px solid #c8c0b0;
  border-radius: 3px;
  cursor: pointer;
  object-fit: cover;
  transition: border-color 0.2s ease;
}
.thumb:hover { border-color: #8a6a4a; }
@media (max-width: 768px) {
  #title-screen h1 { font-size: 2rem; }
  #controls { width: 175px; padding: 12px; }
}
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<div id="title-screen">
  <h1>QUILL & CURVE</h1>
  <div class="sub">paper filigree in the browser</div>
  <p>Draw flowing curves that transform into intricate quilled paper coils. Layer colors, adjust depth, and create delicate paper sculptures. Every piece is unique.</p>
  <div>
    <button class="btn" onclick="startApp('freehand')">Freehand</button>
    <button class="btn" onclick="startApp('guided')">Guided Patterns</button>
    <button class="btn" onclick="startApp('mandala')">Mandala Mode</button>
  </div>
  <p style="font-size:0.7rem;color:#8a7a6a;margin-top:1rem;">Draw with mouse/touch | Scroll: coil size | Space: pause | Z: undo | S: save</p>
</div>

<div id="controls">
  <h3>Quill & Curve</h3>
  <div class="cr">
    <label>Coil Tightness</label>
    <input type="range" id="ctrl-tight" min="2" max="15" value="5">
  </div>
  <div class="cr">
    <label>Paper Width</label>
    <input type="range" id="ctrl-width" min="3" max="25" value="8">
  </div>
  <div class="cr">
    <label>Coil Layers</label>
    <input type="range" id="ctrl-layers" min="2" max="8" value="4">
  </div>
  <div class="cr">
    <label>3D Depth</label>
    <input type="range" id="ctrl-depth" min="1" max="10" value="4">
  </div>
  <div class="cr">
    <label>Style</label>
    <select id="ctrl-style">
      <option value="tight">Tight Coil</option>
      <option value="loose">Loose Spiral</option>
      <option value="marquise">Marquise</option>
      <option value="teardrop">Teardrop</option>
      <option value="heart">Heart</option>
    </select>
  </div>
  <div class="cr">
    <label>Mode</label>
    <select id="ctrl-mode">
      <option value="freehand">Freehand</option>
      <option value="mandala">Mandala</option>
      <option value="mirror">Mirror</option>
    </select>
  </div>
  <div class="cr">
    <label>Sound</label>
    <input type="checkbox" id="ctrl-sound" checked>
  </div>
  <div>
    <label style="font-size:0.72rem;color:#6a5a4a;">Paper Colors</label>
    <div id="palette"></div>
  </div>
  <div style="margin-top:8px;text-align:center;">
    <button class="btn-sm" onclick="clearCanvas()">Clear</button>
    <button class="btn-sm" onclick="undoLast()">Undo</button>
    <button class="btn-sm" onclick="saveImage()">Save</button>
    <button class="btn-sm" onclick="randomPattern()">Random</button>
  </div>
</div>

<div id="hud">
  <div>Quills: <span id="hud-quills">0</span></div>
  <div>Coils: <span id="hud-coils">0</span></div>
  <div>Gallery: <span id="hud-gallery">0</span></div>
</div>

<div id="pause-overlay">
  <h2>PAUSED</h2>
  <p style="color:#6a5a4a;margin-bottom:1.5rem;font-style:italic;">Press Space or ESC to continue</p>
  <button class="btn" onclick="togglePause()">Continue</button>
</div>

<div id="gallery-bar">
  <span>Gallery:</span>
  <div id="gallery-thumbs"></div>
</div>

<script>
// ==================== AUDIO ====================
class QuillAudio {
  constructor() {
    this.ctx = null;
    this.initialized = false;
    this.enabled = true;
    this.master = null;
  }

  init() {
    if (this.initialized) return;
    try {
      this.ctx = new (window.AudioContext || window.webkitAudioContext)();
      this.master = this.ctx.createGain();
      this.master.gain.value = 0.08;

      const conv = this.ctx.createConvolver();
      const len = this.ctx.sampleRate * 2;
      const imp = this.ctx.createBuffer(2, len, this.ctx.sampleRate);
      for (let ch = 0; ch < 2; ch++) {
        const d = imp.getChannelData(ch);
        for (let i = 0; i < len; i++) {
          d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, 2.5);
        }
      }
      conv.buffer = imp;
      const wet = this.ctx.createGain();
      wet.gain.value = 0.4;
      this.master.connect(conv);
      conv.connect(wet);
      wet.connect(this.ctx.destination);
      this.master.connect(this.ctx.destination);

      // Gentle ambient
      const freqs = [261.63, 329.63, 392, 523.25];
      freqs.forEach((f, i) => {
        const osc = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        osc.type = 'sine';
        osc.frequency.value = f;
        g.gain.value = 0.004;
        const lfo = this.ctx.createOscillator();
        const lfoG = this.ctx.createGain();
        lfo.frequency.value = 0.05 + i * 0.02;
        lfoG.gain.value = 0.002;
        lfo.connect(lfoG);
        lfoG.connect(g.gain);
        lfo.start();
        osc.connect(g);
        g.connect(this.master);
        osc.start();
      });

      this.initialized = true;
    } catch(e) {}
  }

  playCoil(x, y, w, h) {
    if (!this.initialized || !this.enabled) return;
    const notes = [261.63, 293.66, 329.63, 349.23, 392, 440, 493.88, 523.25];
    const freq = notes[Math.floor((y / h) * notes.length)] || 392;
    const pan = (x / w) * 2 - 1;
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    const panner = this.ctx.createStereoPanner();
    osc.type = 'triangle';
    osc.frequency.value = freq;
    g.gain.setValueAtTime(0.03, this.ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);
    panner.pan.value = Math.max(-1, Math.min(1, pan));
    osc.connect(g);
    g.connect(panner);
    panner.connect(this.master);
    osc.start();
    osc.stop(this.ctx.currentTime + 0.3);
  }

  playPaperRustle() {
    if (!this.initialized || !this.enabled) return;
    const bufSize = this.ctx.sampleRate * 0.08;
    const buf = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < bufSize; i++) {
      data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufSize, 2);
    }
    const src = this.ctx.createBufferSource();
    src.buffer = buf;
    const filter = this.ctx.createBiquadFilter();
    filter.type = 'bandpass';
    filter.frequency.value = 2000;
    filter.Q.value = 3;
    const g = this.ctx.createGain();
    g.gain.value = 0.02;
    src.connect(filter);
    filter.connect(g);
    g.connect(this.master);
    src.start();
  }

  setEnabled(v) {
    this.enabled = v;
    if (this.master) this.master.gain.value = v ? 0.08 : 0;
  }
}

// ==================== COLORS ====================
const COLORS = [
  '#e74c3c', '#f39c12', '#27ae60', '#3498db', '#9b59b6',
  '#e91e8f', '#1abc9c', '#e67e22', '#2c3e50', '#c0392b',
  '#f1c40f', '#8e44ad', '#d35400', '#16a085', '#2980b9',
  '#ecf0f1'
];

// ==================== QUILL SHAPES ====================
function hexToRgb(hex) {
  const r = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return r ? { r: parseInt(r[1], 16), g: parseInt(r[2], 16), b: parseInt(r[3], 16) } : { r: 0, g: 0, b: 0 };
}

function drawCoilShape(ctx, x, y, size, color, style, layers, depthFactor) {
  const c = hexToRgb(color);

  // Shadow
  ctx.save();
  const shadowOffset = depthFactor * 2;
  ctx.fillStyle = 'rgba(0,0,0,0.08)';
  ctx.beginPath();
  ctx.ellipse(x + shadowOffset, y + shadowOffset, size * 0.9, size * 0.35, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();

  for (let layer = layers; layer >= 0; layer--) {
    const layerSize = size - layer * (size * 0.08);
    if (layerSize < 2) continue;

    const shade = Math.max(0.3, 1 - layer * 0.1);
    const highlight = layer === 0 ? 1.1 : 1;
    const lr = Math.min(255, Math.floor(c.r * shade * highlight));
    const lg = Math.min(255, Math.floor(c.g * shade * highlight));
    const lb = Math.min(255, Math.floor(c.b * shade * highlight));

    ctx.save();
    ctx.translate(x, y);

    switch (style) {
      case 'tight':
        // Concentric circles with slight wobble
        ctx.beginPath();
        for (let a = 0; a <= Math.PI * 2; a += 0.05) {
          const r = layerSize + Math.sin(a * 6 + layer * 0.5) * 1.5;
          const px = Math.cos(a) * r;
          const py = Math.sin(a) * r * (0.4 + depthFactor * 0.03);
          if (a === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.closePath();
        break;

      case 'loose':
        // Spiral
        ctx.beginPath();
        const spiralTurns = 3;
        for (let a = 0; a <= Math.PI * 2 * spiralTurns; a += 0.1) {
          const progress = a / (Math.PI * 2 * spiralTurns);
          const r = layerSize * progress + Math.sin(a * 2) * 2;
          const px = Math.cos(a) * r;
          const py = Math.sin(a) * r * 0.45;
          if (a === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        break;

      case 'marquise':
        // Eye/leaf shape
        ctx.beginPath();
        for (let a = 0; a <= Math.PI * 2; a += 0.05) {
          const r = layerSize * (0.3 + 0.7 * Math.pow(Math.sin(a), 2));
          const px = Math.cos(a) * r * 1.5;
          const py = Math.sin(a) * r * 0.5;
          if (a === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.closePath();
        break;

      case 'teardrop':
        ctx.beginPath();
        for (let a = 0; a <= Math.PI * 2; a += 0.05) {
          const mod = 1 + 0.3 * Math.sin(a);
          const r = layerSize * mod * 0.8;
          const px = Math.cos(a) * r;
          const py = Math.sin(a) * r * 0.5 - (1 - Math.cos(a)) * layerSize * 0.3;
          if (a === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.closePath();
        break;

      case 'heart':
        ctx.beginPath();
        for (let a = 0; a <= Math.PI * 2; a += 0.05) {
          const r = layerSize * 0.7;
          const px = r * 16 * Math.pow(Math.sin(a), 3) / 16;
          const py = -r * (13 * Math.cos(a) - 5 * Math.cos(2*a) - 2 * Math.cos(3*a) - Math.cos(4*a)) / 16 * 0.4;
          if (a === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.closePath();
        break;
    }

    // Fill with gradient for depth
    const grad = ctx.createLinearGradient(-layerSize, -layerSize * 0.3, layerSize, layerSize * 0.3);
    grad.addColorStop(0, 'rgb(' + Math.min(255, lr + 30) + ',' + Math.min(255, lg + 30) + ',' + Math.min(255, lb + 30) + ')');
    grad.addColorStop(0.5, 'rgb(' + lr + ',' + lg + ',' + lb + ')');
    grad.addColorStop(1, 'rgb(' + Math.max(0, lr - 20) + ',' + Math.max(0, lg - 20) + ',' + Math.max(0, lb - 20) + ')');
    ctx.fillStyle = grad;
    ctx.fill();

    // Edge stroke
    ctx.strokeStyle = 'rgba(0,0,0,' + (0.05 + layer * 0.02) + ')';
    ctx.lineWidth = 0.5;
    ctx.stroke();

    // Inner spiral detail on top layer
    if (layer === 0 && style === 'tight') {
      ctx.beginPath();
      for (let a = 0; a <= Math.PI * 6; a += 0.1) {
        const progress = a / (Math.PI * 6);
        const sr = layerSize * 0.8 * progress;
        const spx = Math.cos(a) * sr;
        const spy = Math.sin(a) * sr * 0.4;
        if (a === 0) ctx.moveTo(spx, spy);
        else ctx.lineTo(spx, spy);
      }
      ctx.strokeStyle = 'rgba(0,0,0,0.06)';
      ctx.lineWidth = 0.5;
      ctx.stroke();
    }

    ctx.restore();
  }

  // Center highlight
  ctx.save();
  const hlGrad = ctx.createRadialGradient(x - size * 0.2, y - size * 0.1, 0, x, y, size * 0.4);
  hlGrad.addColorStop(0, 'rgba(255,255,255,0.2)');
  hlGrad.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.fillStyle = hlGrad;
  ctx.beginPath();
  ctx.ellipse(x, y, size * 0.4, size * 0.2, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

// ==================== MAIN APP ====================
class QuillApp {
  constructor() {
    this.canvas = document.getElementById('canvas');
    this.ctx = this.canvas.getContext('2d');
    this.W = window.innerWidth;
    this.H = window.innerHeight;
    this.canvas.width = this.W;
    this.canvas.height = this.H;

    this.audio = new QuillAudio();
    this.paused = false;
    this.started = false;
    this.frame = 0;

    this.drawing = false;
    this.lastX = 0;
    this.lastY = 0;
    this.currentPath = [];
    this.quills = [];
    this.undoStack = [];
    this.totalCoils = 0;

    this.tightness = 5;
    this.paperWidth = 8;
    this.coilLayers = 4;
    this.depthFactor = 4;
    this.coilStyle = 'tight';
    this.drawMode = 'freehand';
    this.currentColor = COLORS[0];
    this.mandalaFolds = 8;

    this.gallery = [];
    this.galleryCount = 0;

    this.setupPalette();
    this.setupEvents();
    this.setupControls();
    this.loadState();
  }

  setupPalette() {
    const container = document.getElementById('palette');
    COLORS.forEach((color, i) => {
      const swatch = document.createElement('div');
      swatch.className = 'color-swatch' + (i === 0 ? ' active' : '');
      swatch.style.background = color;
      swatch.addEventListener('click', () => {
        document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
        swatch.classList.add('active');
        this.currentColor = color;
      });
      container.appendChild(swatch);
    });
  }

  setupEvents() {
    window.addEventListener('resize', () => {
      const imgData = this.ctx.getImageData(0, 0, this.W, this.H);
      this.W = window.innerWidth;
      this.H = window.innerHeight;
      this.canvas.width = this.W;
      this.canvas.height = this.H;
      this.drawPaperTexture();
      this.ctx.putImageData(imgData, 0, 0);
    });

    this.canvas.addEventListener('mousedown', (e) => {
      this.startDraw(e.clientX, e.clientY);
    });
    this.canvas.addEventListener('mousemove', (e) => {
      if (this.drawing) this.continueDraw(e.clientX, e.clientY);
    });
    this.canvas.addEventListener('mouseup', () => this.endDraw());
    this.canvas.addEventListener('mouseleave', () => this.endDraw());

    this.canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      this.startDraw(e.touches[0].clientX, e.touches[0].clientY);
    }, { passive: false });
    this.canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (this.drawing) this.continueDraw(e.touches[0].clientX, e.touches[0].clientY);
    }, { passive: false });
    this.canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      this.endDraw();
    }, { passive: false });

    this.canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      this.paperWidth += e.deltaY > 0 ? -1 : 1;
      this.paperWidth = Math.max(3, Math.min(25, this.paperWidth));
      document.getElementById('ctrl-width').value = this.paperWidth;
    }, { passive: false });

    document.addEventListener('keydown', (e) => {
      if (e.key === ' ' || e.key === 'Escape') {
        e.preventDefault();
        this.togglePause();
      } else if (e.key === 'z' || e.key === 'Z') {
        this.undo();
      } else if (e.key === 's' || e.key === 'S') {
        this.saveImage();
      } else if (e.key === 'c' || e.key === 'C') {
        this.clearCanvas();
      } else if (e.key === 'r' || e.key === 'R') {
        this.randomPattern();
      }
    });
  }

  setupControls() {
    document.getElementById('ctrl-tight').addEventListener('input', (e) => {
      this.tightness = parseInt(e.target.value);
    });
    document.getElementById('ctrl-width').addEventListener('input', (e) => {
      this.paperWidth = parseInt(e.target.value);
    });
    document.getElementById('ctrl-layers').addEventListener('input', (e) => {
      this.coilLayers = parseInt(e.target.value);
    });
    document.getElementById('ctrl-depth').addEventListener('input', (e) => {
      this.depthFactor = parseInt(e.target.value);
    });
    document.getElementById('ctrl-style').addEventListener('change', (e) => {
      this.coilStyle = e.target.value;
    });
    document.getElementById('ctrl-mode').addEventListener('change', (e) => {
      this.drawMode = e.target.value;
    });
    document.getElementById('ctrl-sound').addEventListener('change', (e) => {
      this.audio.setEnabled(e.target.checked);
    });
  }

  drawPaperTexture() {
    const ctx = this.ctx;
    // Paper base
    ctx.fillStyle = '#f5f0e8';
    ctx.fillRect(0, 0, this.W, this.H);

    // Fiber texture
    const imgData = ctx.getImageData(0, 0, this.W, this.H);
    const data = imgData.data;
    for (let i = 0; i < data.length; i += 4) {
      const noise = (Math.random() - 0.5) * 6;
      data[i] = Math.max(0, Math.min(255, data[i] + noise));
      data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise));
      data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise));
    }
    ctx.putImageData(imgData, 0, 0);

    // Subtle lines
    ctx.globalAlpha = 0.02;
    for (let i = 0; i < 100; i++) {
      ctx.beginPath();
      ctx.moveTo(Math.random() * this.W, Math.random() * this.H);
      const angle = Math.random() * Math.PI;
      const len = 30 + Math.random() * 80;
      ctx.lineTo(
        Math.random() * this.W + Math.cos(angle) * len,
        Math.random() * this.H + Math.sin(angle) * len
      );
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 0.5;
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }

  startDraw(x, y) {
    if (this.paused) return;
    this.drawing = true;
    this.currentPath = [{ x, y }];
    this.lastX = x;
    this.lastY = y;
    // Save undo state
    this.undoStack.push(this.ctx.getImageData(0, 0, this.W, this.H));
    if (this.undoStack.length > 15) this.undoStack.shift();
  }

  continueDraw(x, y) {
    if (!this.drawing || this.paused) return;

    this.currentPath.push({ x, y });

    const dx = x - this.lastX;
    const dy = y - this.lastY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const spacing = this.tightness * 3;

    if (dist >= spacing) {
      const coilSize = this.paperWidth + Math.random() * this.paperWidth * 0.3;

      if (this.drawMode === 'mandala') {
        const cx = this.W / 2;
        const cy = this.H / 2;
        const relX = x - cx;
        const relY = y - cy;
        const folds = this.mandalaFolds;
        const angleStep = Math.PI * 2 / folds;

        for (let i = 0; i < folds; i++) {
          const angle = angleStep * i;
          const cos = Math.cos(angle);
          const sin = Math.sin(angle);
          const px = cx + relX * cos - relY * sin;
          const py = cy + relX * sin + relY * cos;
          drawCoilShape(this.ctx, px, py, coilSize, this.currentColor, this.coilStyle, this.coilLayers, this.depthFactor);
          this.totalCoils++;

          // Mirror
          const mx = cx + relX * cos + relY * sin;
          const my = cy + relX * sin - relY * cos;
          drawCoilShape(this.ctx, mx, my, coilSize, this.currentColor, this.coilStyle, this.coilLayers, this.depthFactor);
          this.totalCoils++;
        }
      } else if (this.drawMode === 'mirror') {
        drawCoilShape(this.ctx, x, y, coilSize, this.currentColor, this.coilStyle, this.coilLayers, this.depthFactor);
        drawCoilShape(this.ctx, this.W - x, y, coilSize, this.currentColor, this.coilStyle, this.coilLayers, this.depthFactor);
        drawCoilShape(this.ctx, x, this.H - y, coilSize, this.currentColor, this.coilStyle, this.coilLayers, this.depthFactor);
        drawCoilShape(this.ctx, this.W - x, this.H - y, coilSize, this.currentColor, this.coilStyle, this.coilLayers, this.depthFactor);
        this.totalCoils += 4;
      } else {
        drawCoilShape(this.ctx, x, y, coilSize, this.currentColor, this.coilStyle, this.coilLayers, this.depthFactor);
        this.totalCoils++;
      }

      this.audio.playCoil(x, y, this.W, this.H);
      this.lastX = x;
      this.lastY = y;
    }

    // Paper rustle sound
    if (this.frame % 10 === 0) {
      this.audio.playPaperRustle();
    }

    this.updateHUD();
  }

  endDraw() {
    if (this.drawing && this.currentPath.length > 1) {
      this.quills.push({
        points: [...this.currentPath],
        color: this.currentColor,
        style: this.coilStyle,
        layers: this.coilLayers
      });
    }
    this.drawing = false;
    this.currentPath = [];
    this.updateHUD();
  }

  undo() {
    if (this.undoStack.length > 0) {
      const imgData = this.undoStack.pop();
      this.ctx.putImageData(imgData, 0, 0);
      if (this.quills.length > 0) this.quills.pop();
    }
  }

  clearCanvas() {
    this.undoStack.push(this.ctx.getImageData(0, 0, this.W, this.H));
    this.quills = [];
    this.totalCoils = 0;
    this.drawPaperTexture();
    this.updateHUD();
  }

  randomPattern() {
    this.undoStack.push(this.ctx.getImageData(0, 0, this.W, this.H));
    const styles = ['tight', 'loose', 'marquise', 'teardrop', 'heart'];

    // Create decorative pattern
    const patternType = Math.floor(Math.random() * 3);

    if (patternType === 0) {
      // Mandala pattern
      const cx = this.W / 2;
      const cy = this.H / 2;
      const folds = 6 + Math.floor(Math.random() * 6);
      const rings = 3 + Math.floor(Math.random() * 4);

      for (let ring = 0; ring < rings; ring++) {
        const radius = 60 + ring * 50;
        const color = COLORS[Math.floor(Math.random() * COLORS.length)];
        const style = styles[Math.floor(Math.random() * styles.length)];
        const coilSize = 10 + Math.random() * 15;

        for (let i = 0; i < folds; i++) {
          const angle = (i / folds) * Math.PI * 2;
          const px = cx + Math.cos(angle) * radius;
          const py = cy + Math.sin(angle) * radius;
          drawCoilShape(this.ctx, px, py, coilSize, color, style, this.coilLayers, this.depthFactor);
          this.totalCoils++;
        }
      }
    } else if (patternType === 1) {
      // Scatter
      for (let i = 0; i < 30; i++) {
        const x = this.W * 0.15 + Math.random() * this.W * 0.7;
        const y = this.H * 0.15 + Math.random() * this.H * 0.7;
        const color = COLORS[Math.floor(Math.random() * COLORS.length)];
        const style = styles[Math.floor(Math.random() * styles.length)];
        const size = 8 + Math.random() * 20;
        drawCoilShape(this.ctx, x, y, size, color, style, this.coilLayers, this.depthFactor);
        this.totalCoils++;
      }
    } else {
      // Flowing vine
      let x = this.W * 0.1;
      let y = this.H * 0.5;
      let angle = 0;

      for (let i = 0; i < 40; i++) {
        angle += (Math.random() - 0.5) * 0.5;
        x += Math.cos(angle) * 20;
        y += Math.sin(angle) * 20;
        const color = COLORS[i % COLORS.length];
        const size = 6 + Math.random() * 12;
        drawCoilShape(this.ctx, x, y, size, color, 'tight', this.coilLayers, this.depthFactor);
        this.totalCoils++;

        // Side branches
        if (Math.random() < 0.3) {
          const branchAngle = angle + (Math.random() > 0.5 ? 1 : -1) * Math.PI * 0.4;
          for (let j = 0; j < 3; j++) {
            const bx = x + Math.cos(branchAngle) * (15 + j * 12);
            const by = y + Math.sin(branchAngle) * (15 + j * 12);
            drawCoilShape(this.ctx, bx, by, size * 0.7, color, 'teardrop', this.coilLayers, this.depthFactor);
            this.totalCoils++;
          }
        }
      }
    }

    this.updateHUD();
  }

  togglePause() {
    this.paused = !this.paused;
    document.getElementById('pause-overlay').style.display = this.paused ? 'flex' : 'none';
  }

  saveImage() {
    const link = document.createElement('a');
    link.download = 'quill-and-curve-' + Date.now() + '.png';
    link.href = this.canvas.toDataURL('image/png');
    link.click();

    // Add to gallery
    this.galleryCount++;
    const thumb = document.createElement('img');
    thumb.className = 'thumb';
    thumb.src = this.canvas.toDataURL('image/jpeg', 0.3);
    document.getElementById('gallery-thumbs').appendChild(thumb);
    this.updateHUD();
    this.saveState();
  }

  updateHUD() {
    document.getElementById('hud-quills').textContent = this.quills.length;
    document.getElementById('hud-coils').textContent = this.totalCoils;
    document.getElementById('hud-gallery').textContent = this.galleryCount;
  }

  saveState() {
    try {
      localStorage.setItem('quill-and-curve', JSON.stringify({
        tightness: this.tightness,
        paperWidth: this.paperWidth,
        coilLayers: this.coilLayers,
        depthFactor: this.depthFactor,
        coilStyle: this.coilStyle,
        drawMode: this.drawMode,
        galleryCount: this.galleryCount,
        totalCoils: this.totalCoils
      }));
    } catch(e) {}
  }

  loadState() {
    try {
      const saved = JSON.parse(localStorage.getItem('quill-and-curve'));
      if (saved) {
        this.tightness = saved.tightness || 5;
        this.paperWidth = saved.paperWidth || 8;
        this.coilLayers = saved.coilLayers || 4;
        this.depthFactor = saved.depthFactor || 4;
        this.coilStyle = saved.coilStyle || 'tight';
        this.drawMode = saved.drawMode || 'freehand';
        this.galleryCount = saved.galleryCount || 0;
        this.totalCoils = saved.totalCoils || 0;

        document.getElementById('ctrl-tight').value = this.tightness;
        document.getElementById('ctrl-width').value = this.paperWidth;
        document.getElementById('ctrl-layers').value = this.coilLayers;
        document.getElementById('ctrl-depth').value = this.depthFactor;
        document.getElementById('ctrl-style').value = this.coilStyle;
        document.getElementById('ctrl-mode').value = this.drawMode;
      }
    } catch(e) {}
  }

  update() {
    if (this.paused) return;
    this.frame++;
    if (this.frame % 600 === 0) this.saveState();
  }

  run() {
    const loop = () => {
      this.update();
      requestAnimationFrame(loop);
    };
    loop();
  }
}

// ==================== GLOBAL ====================
let app;

function startApp(mode) {
  app = new QuillApp();
  app.drawMode = mode === 'mandala' ? 'mandala' : mode === 'guided' ? 'mirror' : 'freehand';
  document.getElementById('ctrl-mode').value = app.drawMode;
  app.started = true;
  app.audio.init();
  app.drawPaperTexture();
  app.updateHUD();

  const title = document.getElementById('title-screen');
  title.style.opacity = '0';
  setTimeout(() => { title.style.display = 'none'; }, 1500);

  app.run();
}

function clearCanvas() { if (app) app.clearCanvas(); }
function undoLast() { if (app) app.undo(); }
function saveImage() { if (app) app.saveImage(); }
function randomPattern() { if (app) app.randomPattern(); }
function togglePause() { if (app) app.togglePause(); }

// Title background
(function() {
  const c = document.getElementById('canvas');
  const ctx = c.getContext('2d');
  c.width = window.innerWidth;
  c.height = window.innerHeight;
  ctx.fillStyle = '#f5f0e8';
  ctx.fillRect(0, 0, c.width, c.height);

  const colors = ['#e74c3c', '#f39c12', '#27ae60', '#3498db', '#9b59b6'];
  const cx = c.width / 2;
  const cy = c.height / 2;
  for (let ring = 0; ring < 3; ring++) {
    const radius = 40 + ring * 35;
    for (let i = 0; i < 8; i++) {
      const angle = (i / 8) * Math.PI * 2;
      const px = cx + Math.cos(angle) * radius;
      const py = cy + Math.sin(angle) * radius;
      const color = colors[(ring + i) % colors.length];
      drawCoilShape(ctx, px, py, 8 + ring * 3, color, 'tight', 3, 3);
    }
  }
})();
</script>
</body>
</html>