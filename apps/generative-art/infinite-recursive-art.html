<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Recursive Art Generator</title>
    <meta name="description" content="Mesmerizing infinite zoom into recursively generated geometric art patterns with customizable parameters">
    <!-- generative, fractal, recursive, art, visual, canvas, infinite, zoom -->
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: #000;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        }
        
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
        }
        
        #controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 12px;
            color: #fff;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            z-index: 100;
            min-width: 250px;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }
        
        #controls.hidden {
            transform: translateX(calc(100% + 40px));
            opacity: 0;
        }
        
        #toggle-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            border: 1px solid rgba(255,255,255,0.2);
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            z-index: 101;
            font-size: 14px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
            opacity: 0.7;
        }
        
        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255,255,255,0.2);
            outline: none;
            -webkit-appearance: none;
        }
        
        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
        }
        
        .control-group select {
            width: 100%;
            padding: 8px;
            border-radius: 6px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: #fff;
            font-size: 14px;
            cursor: pointer;
        }
        
        .control-group select option {
            background: #222;
        }
        
        .btn-row {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .btn {
            flex: 1;
            padding: 10px;
            border: 1px solid rgba(255,255,255,0.2);
            background: rgba(255,255,255,0.1);
            color: #fff;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s ease;
        }
        
        .btn:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .btn.active {
            background: rgba(255,255,255,0.3);
        }
        
        #info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: rgba(255,255,255,0.5);
            font-size: 12px;
            z-index: 100;
        }
        
        #depth-indicator {
            position: fixed;
            bottom: 20px;
            right: 20px;
            color: rgba(255,255,255,0.7);
            font-size: 14px;
            font-family: monospace;
            z-index: 100;
        }
        
        .color-preview {
            display: flex;
            gap: 5px;
            margin-top: 5px;
        }
        
        .color-swatch {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.3);
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <button id="toggle-controls">☰</button>
    
    <div id="controls">
        <div class="control-group">
            <label>Pattern Type</label>
            <select id="pattern-type">
                <option value="mandala">Mandala</option>
                <option value="sierpinski">Sierpinski</option>
                <option value="tree">Fractal Tree</option>
                <option value="spiral">Golden Spiral</option>
                <option value="hexagon">Hexagonal Tiles</option>
                <option value="penrose">Penrose-like</option>
                <option value="celtic">Celtic Knots</option>
                <option value="islamic">Islamic Geometry</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>Recursion Depth: <span id="depth-value">5</span></label>
            <input type="range" id="depth" min="2" max="8" value="5">
        </div>
        
        <div class="control-group">
            <label>Zoom Speed: <span id="speed-value">1.0</span>x</label>
            <input type="range" id="speed" min="0.1" max="3" step="0.1" value="1">
        </div>
        
        <div class="control-group">
            <label>Rotation: <span id="rotation-value">0.5</span></label>
            <input type="range" id="rotation" min="0" max="2" step="0.1" value="0.5">
        </div>
        
        <div class="control-group">
            <label>Color Palette</label>
            <select id="color-palette">
                <option value="cosmic">Cosmic</option>
                <option value="sunset">Sunset</option>
                <option value="ocean">Ocean</option>
                <option value="forest">Forest</option>
                <option value="neon">Neon</option>
                <option value="monochrome">Monochrome</option>
                <option value="rainbow">Rainbow</option>
                <option value="fire">Fire</option>
            </select>
            <div class="color-preview" id="color-preview"></div>
        </div>
        
        <div class="control-group">
            <label>Line Width: <span id="line-value">2</span></label>
            <input type="range" id="line-width" min="0.5" max="5" step="0.5" value="2">
        </div>
        
        <div class="btn-row">
            <button class="btn" id="pause-btn">Pause</button>
            <button class="btn" id="reset-btn">Reset</button>
        </div>
        
        <div class="btn-row">
            <button class="btn" id="export-btn">Export PNG</button>
            <button class="btn" id="save-btn">Save Config</button>
        </div>
        
        <div class="btn-row">
            <button class="btn" id="random-btn">Randomize</button>
            <button class="btn" id="import-btn">Load Config</button>
        </div>
    </div>
    
    <div id="info">Click and drag to offset center • Scroll to adjust zoom • Space to pause</div>
    <div id="depth-indicator">Depth: 0</div>
    
    <input type="file" id="import-file" accept=".json" style="display: none;">
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // State
        let width, height, centerX, centerY;
        let zoom = 1;
        let totalZoom = 1;
        let rotation = 0;
        let offsetX = 0, offsetY = 0;
        let paused = false;
        let currentDepth = 0;
        
        // Settings
        let settings = {
            pattern: 'mandala',
            depth: 5,
            speed: 1,
            rotationSpeed: 0.5,
            palette: 'cosmic',
            lineWidth: 2
        };
        
        // Color palettes
        const palettes = {
            cosmic: ['#0f0c29', '#302b63', '#24243e', '#ff6b6b', '#4ecdc4', '#ffe66d'],
            sunset: ['#2c1810', '#ff6f61', '#ffb347', '#ff7f50', '#ffd700', '#ff4500'],
            ocean: ['#0a1628', '#1a4a6e', '#2980b9', '#3498db', '#5dade2', '#85c1e9'],
            forest: ['#0b2419', '#1a472a', '#2d5a3a', '#3e8e41', '#90ee90', '#98fb98'],
            neon: ['#0a0a0a', '#ff00ff', '#00ffff', '#ff0080', '#80ff00', '#ffff00'],
            monochrome: ['#000000', '#1a1a1a', '#333333', '#666666', '#999999', '#ffffff'],
            rainbow: ['#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#0000ff', '#8b00ff'],
            fire: ['#1a0a00', '#4a1c00', '#8b2500', '#ff4500', '#ff6600', '#ffcc00']
        };
        
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            centerX = width / 2;
            centerY = height / 2;
        }
        resize();
        window.addEventListener('resize', resize);
        
        // Get color from palette at depth
        function getColor(depth, maxDepth) {
            const palette = palettes[settings.palette];
            const t = depth / maxDepth;
            const idx = Math.floor(t * (palette.length - 1));
            const nextIdx = Math.min(idx + 1, palette.length - 1);
            const blend = (t * (palette.length - 1)) % 1;
            
            const c1 = hexToRgb(palette[idx]);
            const c2 = hexToRgb(palette[nextIdx]);
            
            return `rgb(${Math.floor(c1.r + (c2.r - c1.r) * blend)}, ${Math.floor(c1.g + (c2.g - c1.g) * blend)}, ${Math.floor(c1.b + (c2.b - c1.b) * blend)})`;
        }
        
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : {r: 0, g: 0, b: 0};
        }
        
        // Pattern generators
        const patterns = {
            mandala(cx, cy, size, depth, angle) {
                if (depth <= 0 || size < 2) return;
                
                const segments = 6 + depth * 2;
                ctx.strokeStyle = getColor(settings.depth - depth, settings.depth);
                ctx.lineWidth = settings.lineWidth * (depth / settings.depth);
                
                for (let i = 0; i < segments; i++) {
                    const a = angle + (i / segments) * Math.PI * 2;
                    const x = cx + Math.cos(a) * size;
                    const y = cy + Math.sin(a) * size;
                    
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    ctx.lineTo(x, y);
                    ctx.stroke();
                    
                    // Recursive petals
                    const petalAngle = a + Math.PI / segments;
                    patterns.mandala(x, y, size * 0.4, depth - 1, petalAngle);
                }
                
                // Center circle
                ctx.beginPath();
                ctx.arc(cx, cy, size * 0.3, 0, Math.PI * 2);
                ctx.stroke();
            },
            
            sierpinski(cx, cy, size, depth, angle) {
                if (depth <= 0 || size < 2) return;
                
                const h = size * Math.sqrt(3) / 2;
                const points = [];
                
                for (let i = 0; i < 3; i++) {
                    const a = angle + (i / 3) * Math.PI * 2 - Math.PI / 2;
                    points.push({
                        x: cx + Math.cos(a) * size,
                        y: cy + Math.sin(a) * size
                    });
                }
                
                ctx.strokeStyle = getColor(settings.depth - depth, settings.depth);
                ctx.lineWidth = settings.lineWidth * (depth / settings.depth);
                
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                ctx.lineTo(points[1].x, points[1].y);
                ctx.lineTo(points[2].x, points[2].y);
                ctx.closePath();
                ctx.stroke();
                
                // Recurse at midpoints
                const newSize = size / 2;
                for (let i = 0; i < 3; i++) {
                    const midX = (points[i].x + cx) / 2;
                    const midY = (points[i].y + cy) / 2;
                    patterns.sierpinski(midX, midY, newSize, depth - 1, angle);
                }
            },
            
            tree(cx, cy, size, depth, angle) {
                if (depth <= 0 || size < 2) return;
                
                const endX = cx + Math.cos(angle) * size;
                const endY = cy + Math.sin(angle) * size;
                
                ctx.strokeStyle = getColor(settings.depth - depth, settings.depth);
                ctx.lineWidth = settings.lineWidth * (depth / settings.depth);
                
                ctx.beginPath();
                ctx.moveTo(cx, cy);
                ctx.lineTo(endX, endY);
                ctx.stroke();
                
                const newSize = size * 0.7;
                const spread = 0.4 + Math.sin(totalZoom * 0.1) * 0.2;
                
                patterns.tree(endX, endY, newSize, depth - 1, angle - spread);
                patterns.tree(endX, endY, newSize, depth - 1, angle + spread);
            },
            
            spiral(cx, cy, size, depth, angle) {
                if (depth <= 0 || size < 2) return;
                
                const phi = 1.618033988749895;
                ctx.strokeStyle = getColor(settings.depth - depth, settings.depth);
                ctx.lineWidth = settings.lineWidth * (depth / settings.depth);
                
                ctx.beginPath();
                for (let t = 0; t < Math.PI * 2; t += 0.1) {
                    const r = size * Math.pow(phi, t / (Math.PI * 2));
                    const x = cx + Math.cos(angle + t) * r;
                    const y = cy + Math.sin(angle + t) * r;
                    if (t === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                
                // Recursive spirals
                const nextAngle = angle + Math.PI / 2;
                const nextSize = size / phi;
                const nextCx = cx + Math.cos(angle) * size;
                const nextCy = cy + Math.sin(angle) * size;
                
                patterns.spiral(nextCx, nextCy, nextSize, depth - 1, nextAngle);
            },
            
            hexagon(cx, cy, size, depth, angle) {
                if (depth <= 0 || size < 2) return;
                
                ctx.strokeStyle = getColor(settings.depth - depth, settings.depth);
                ctx.lineWidth = settings.lineWidth * (depth / settings.depth);
                
                ctx.beginPath();
                for (let i = 0; i <= 6; i++) {
                    const a = angle + (i / 6) * Math.PI * 2;
                    const x = cx + Math.cos(a) * size;
                    const y = cy + Math.sin(a) * size;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                
                // Recurse at vertices
                for (let i = 0; i < 6; i++) {
                    const a = angle + (i / 6) * Math.PI * 2;
                    const newCx = cx + Math.cos(a) * size * 1.5;
                    const newCy = cy + Math.sin(a) * size * 1.5;
                    patterns.hexagon(newCx, newCy, size * 0.5, depth - 1, angle + Math.PI / 6);
                }
            },
            
            penrose(cx, cy, size, depth, angle) {
                if (depth <= 0 || size < 2) return;
                
                const phi = 1.618033988749895;
                ctx.strokeStyle = getColor(settings.depth - depth, settings.depth);
                ctx.lineWidth = settings.lineWidth * (depth / settings.depth);
                
                // Draw kite shape
                const points = [
                    {x: cx, y: cy - size},
                    {x: cx + size * 0.7, y: cy},
                    {x: cx, y: cy + size * 0.4},
                    {x: cx - size * 0.7, y: cy}
                ];
                
                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(angle);
                ctx.translate(-cx, -cy);
                
                ctx.beginPath();
                points.forEach((p, i) => {
                    if (i === 0) ctx.moveTo(p.x, p.y);
                    else ctx.lineTo(p.x, p.y);
                });
                ctx.closePath();
                ctx.stroke();
                
                ctx.restore();
                
                // Recurse
                for (let i = 0; i < 5; i++) {
                    const a = angle + (i / 5) * Math.PI * 2;
                    patterns.penrose(
                        cx + Math.cos(a) * size,
                        cy + Math.sin(a) * size,
                        size / phi,
                        depth - 1,
                        a + Math.PI / 5
                    );
                }
            },
            
            celtic(cx, cy, size, depth, angle) {
                if (depth <= 0 || size < 5) return;
                
                ctx.strokeStyle = getColor(settings.depth - depth, settings.depth);
                ctx.lineWidth = settings.lineWidth * (depth / settings.depth);
                
                // Draw interlocking loops
                const loops = 4;
                for (let i = 0; i < loops; i++) {
                    const a = angle + (i / loops) * Math.PI * 2;
                    
                    ctx.beginPath();
                    for (let t = 0; t <= Math.PI * 2; t += 0.1) {
                        const r = size * (0.5 + 0.3 * Math.sin(t * 3));
                        const x = cx + Math.cos(a + t) * r;
                        const y = cy + Math.sin(a + t) * r;
                        if (t === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
                
                // Recurse at cardinal points
                const newSize = size * 0.4;
                for (let i = 0; i < 4; i++) {
                    const a = angle + (i / 4) * Math.PI * 2;
                    patterns.celtic(
                        cx + Math.cos(a) * size,
                        cy + Math.sin(a) * size,
                        newSize,
                        depth - 1,
                        a + Math.PI / 4
                    );
                }
            },
            
            islamic(cx, cy, size, depth, angle) {
                if (depth <= 0 || size < 3) return;
                
                ctx.strokeStyle = getColor(settings.depth - depth, settings.depth);
                ctx.lineWidth = settings.lineWidth * (depth / settings.depth);
                
                // 8-pointed star
                ctx.beginPath();
                for (let i = 0; i <= 16; i++) {
                    const a = angle + (i / 16) * Math.PI * 2;
                    const r = size * (i % 2 === 0 ? 1 : 0.5);
                    const x = cx + Math.cos(a) * r;
                    const y = cy + Math.sin(a) * r;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                
                // Outer circle
                ctx.beginPath();
                ctx.arc(cx, cy, size, 0, Math.PI * 2);
                ctx.stroke();
                
                // Recurse at 8 points
                const newSize = size * 0.35;
                for (let i = 0; i < 8; i++) {
                    const a = angle + (i / 8) * Math.PI * 2;
                    patterns.islamic(
                        cx + Math.cos(a) * size * 1.3,
                        cy + Math.sin(a) * size * 1.3,
                        newSize,
                        depth - 1,
                        a + Math.PI / 8
                    );
                }
            }
        };
        
        // Main render
        function render() {
            // Clear with fade effect for trails
            ctx.fillStyle = palettes[settings.palette][0] + 'cc';
            ctx.fillRect(0, 0, width, height);
            
            // Save context and apply transforms
            ctx.save();
            ctx.translate(centerX + offsetX, centerY + offsetY);
            ctx.rotate(rotation);
            ctx.scale(zoom, zoom);
            
            // Draw pattern
            const baseSize = Math.min(width, height) * 0.3;
            patterns[settings.pattern](0, 0, baseSize, settings.depth, 0);
            
            ctx.restore();
            
            // Update depth indicator
            currentDepth = Math.floor(Math.log(totalZoom) / Math.log(1.5));
            document.getElementById('depth-indicator').textContent = `Zoom Depth: ${currentDepth}`;
        }
        
        // Animation loop
        function animate() {
            if (!paused) {
                zoom *= 1 + (0.002 * settings.speed);
                rotation += 0.002 * settings.rotationSpeed;
                totalZoom *= 1 + (0.002 * settings.speed);
                
                // Reset zoom when it gets too large
                if (zoom > 3) {
                    zoom = 1;
                }
            }
            
            render();
            requestAnimationFrame(animate);
        }
        
        // Update color preview
        function updateColorPreview() {
            const preview = document.getElementById('color-preview');
            preview.innerHTML = '';
            palettes[settings.palette].forEach(color => {
                const swatch = document.createElement('div');
                swatch.className = 'color-swatch';
                swatch.style.background = color;
                preview.appendChild(swatch);
            });
        }
        
        // Control handlers
        document.getElementById('pattern-type').addEventListener('change', (e) => {
            settings.pattern = e.target.value;
        });
        
        document.getElementById('depth').addEventListener('input', (e) => {
            settings.depth = parseInt(e.target.value);
            document.getElementById('depth-value').textContent = settings.depth;
        });
        
        document.getElementById('speed').addEventListener('input', (e) => {
            settings.speed = parseFloat(e.target.value);
            document.getElementById('speed-value').textContent = settings.speed.toFixed(1);
        });
        
        document.getElementById('rotation').addEventListener('input', (e) => {
            settings.rotationSpeed = parseFloat(e.target.value);
            document.getElementById('rotation-value').textContent = settings.rotationSpeed.toFixed(1);
        });
        
        document.getElementById('color-palette').addEventListener('change', (e) => {
            settings.palette = e.target.value;
            updateColorPreview();
        });
        
        document.getElementById('line-width').addEventListener('input', (e) => {
            settings.lineWidth = parseFloat(e.target.value);
            document.getElementById('line-value').textContent = settings.lineWidth;
        });
        
        document.getElementById('pause-btn').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pause-btn').textContent = paused ? 'Play' : 'Pause';
            document.getElementById('pause-btn').classList.toggle('active', paused);
        });
        
        document.getElementById('reset-btn').addEventListener('click', () => {
            zoom = 1;
            totalZoom = 1;
            rotation = 0;
            offsetX = 0;
            offsetY = 0;
        });
        
        document.getElementById('export-btn').addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = `recursive-art-${Date.now()}.png`;
            link.href = canvas.toDataURL();
            link.click();
        });
        
        document.getElementById('save-btn').addEventListener('click', () => {
            const data = JSON.stringify(settings, null, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'recursive-art-config.json';
            a.click();
            URL.revokeObjectURL(url);
        });
        
        document.getElementById('import-btn').addEventListener('click', () => {
            document.getElementById('import-file').click();
        });
        
        document.getElementById('import-file').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const loaded = JSON.parse(e.target.result);
                        Object.assign(settings, loaded);
                        
                        // Update UI
                        document.getElementById('pattern-type').value = settings.pattern;
                        document.getElementById('depth').value = settings.depth;
                        document.getElementById('speed').value = settings.speed;
                        document.getElementById('rotation').value = settings.rotationSpeed;
                        document.getElementById('color-palette').value = settings.palette;
                        document.getElementById('line-width').value = settings.lineWidth;
                        
                        document.getElementById('depth-value').textContent = settings.depth;
                        document.getElementById('speed-value').textContent = settings.speed.toFixed(1);
                        document.getElementById('rotation-value').textContent = settings.rotationSpeed.toFixed(1);
                        document.getElementById('line-value').textContent = settings.lineWidth;
                        
                        updateColorPreview();
                    } catch (err) {
                        alert('Invalid config file');
                    }
                };
                reader.readAsText(file);
            }
        });
        
        document.getElementById('random-btn').addEventListener('click', () => {
            const patternKeys = Object.keys(patterns);
            const paletteKeys = Object.keys(palettes);
            
            settings.pattern = patternKeys[Math.floor(Math.random() * patternKeys.length)];
            settings.depth = Math.floor(Math.random() * 5) + 3;
            settings.speed = Math.random() * 2 + 0.5;
            settings.rotationSpeed = Math.random() * 2;
            settings.palette = paletteKeys[Math.floor(Math.random() * paletteKeys.length)];
            settings.lineWidth = Math.random() * 3 + 1;
            
            // Update UI
            document.getElementById('pattern-type').value = settings.pattern;
            document.getElementById('depth').value = settings.depth;
            document.getElementById('speed').value = settings.speed;
            document.getElementById('rotation').value = settings.rotationSpeed;
            document.getElementById('color-palette').value = settings.palette;
            document.getElementById('line-width').value = settings.lineWidth;
            
            document.getElementById('depth-value').textContent = settings.depth;
            document.getElementById('speed-value').textContent = settings.speed.toFixed(1);
            document.getElementById('rotation-value').textContent = settings.rotationSpeed.toFixed(1);
            document.getElementById('line-value').textContent = settings.lineWidth.toFixed(1);
            
            updateColorPreview();
        });
        
        // Toggle controls
        document.getElementById('toggle-controls').addEventListener('click', () => {
            document.getElementById('controls').classList.toggle('hidden');
        });
        
        // Mouse drag for offset
        let isDragging = false;
        let dragStart = {x: 0, y: 0};
        
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            dragStart = {x: e.clientX - offsetX, y: e.clientY - offsetY};
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                offsetX = e.clientX - dragStart.x;
                offsetY = e.clientY - dragStart.y;
            }
        });
        
        canvas.addEventListener('mouseup', () => isDragging = false);
        canvas.addEventListener('mouseleave', () => isDragging = false);
        
        // Scroll for zoom adjustment
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            zoom *= e.deltaY > 0 ? 0.95 : 1.05;
            zoom = Math.max(0.1, Math.min(10, zoom));
        });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                paused = !paused;
                document.getElementById('pause-btn').textContent = paused ? 'Play' : 'Pause';
                document.getElementById('pause-btn').classList.toggle('active', paused);
            } else if (e.code === 'KeyR') {
                zoom = 1;
                totalZoom = 1;
                rotation = 0;
                offsetX = 0;
                offsetY = 0;
            } else if (e.code === 'KeyH') {
                document.getElementById('controls').classList.toggle('hidden');
            }
        });
        
        // Touch support
        let lastTouchDist = 0;
        
        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                isDragging = true;
                dragStart = {x: e.touches[0].clientX - offsetX, y: e.touches[0].clientY - offsetY};
            } else if (e.touches.length === 2) {
                lastTouchDist = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
            }
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (e.touches.length === 1 && isDragging) {
                offsetX = e.touches[0].clientX - dragStart.x;
                offsetY = e.touches[0].clientY - dragStart.y;
            } else if (e.touches.length === 2) {
                const dist = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
                zoom *= dist / lastTouchDist;
                zoom = Math.max(0.1, Math.min(10, zoom));
                lastTouchDist = dist;
            }
        });
        
        canvas.addEventListener('touchend', () => isDragging = false);
        
        // Initialize
        updateColorPreview();
        animate();
        
        // Save to localStorage periodically
        setInterval(() => {
            localStorage.setItem('infiniteRecursiveArt', JSON.stringify(settings));
        }, 5000);
        
        // Load from localStorage
        const saved = localStorage.getItem('infiniteRecursiveArt');
        if (saved) {
            try {
                Object.assign(settings, JSON.parse(saved));
                document.getElementById('pattern-type').value = settings.pattern;
                document.getElementById('depth').value = settings.depth;
                document.getElementById('speed').value = settings.speed;
                document.getElementById('rotation').value = settings.rotationSpeed;
                document.getElementById('color-palette').value = settings.palette;
                document.getElementById('line-width').value = settings.lineWidth;
                
                document.getElementById('depth-value').textContent = settings.depth;
                document.getElementById('speed-value').textContent = settings.speed.toFixed(1);
                document.getElementById('rotation-value').textContent = settings.rotationSpeed.toFixed(1);
                document.getElementById('line-value').textContent = settings.lineWidth;
                
                updateColorPreview();
            } catch (e) {}
        }
    </script>
</body>
</html>
