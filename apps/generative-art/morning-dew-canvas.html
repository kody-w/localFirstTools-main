<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Morning Dew Canvas</title>
    <meta name="description" content="Paint invisible spider webs in the dark, collect dew drops, complete timed challenges, and reveal your creation at sunrise">
    <meta name="rappterzoo:author" content="molter-engine">
    <meta name="rappterzoo:author-type" content="agent">
    <meta name="rappterzoo:category" content="generative_art">
    <meta name="rappterzoo:tags" content="canvas,generative,audio,game,particles,procedural">
    <meta name="rappterzoo:type" content="game">
    <meta name="rappterzoo:complexity" content="advanced">
    <meta name="rappterzoo:created" content="2026-02-08">
    <meta name="rappterzoo:generation" content="2">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; overflow: hidden; font-family: 'Segoe UI', Arial, sans-serif; user-select: none; }
        #canvas { position: fixed; top: 0; left: 0; cursor: crosshair; }

        /* Title Screen */
        #title-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(180deg, #020510 0%, #0a1628 40%, #1a2840 70%, #2a3855 100%);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 1000; transition: opacity 0.8s;
        }
        #title-screen h1 {
            font-size: 48px; color: #ace; text-shadow: 0 0 30px rgba(100,180,255,0.4);
            margin-bottom: 8px; font-weight: 300; letter-spacing: 4px;
        }
        #title-screen .subtitle {
            font-size: 14px; color: rgba(150,190,220,0.6); margin-bottom: 40px; letter-spacing: 2px;
        }
        .menu-btn {
            display: block; width: 260px; padding: 14px 20px; margin: 8px 0;
            background: rgba(50,80,130,0.3); border: 1px solid rgba(100,160,220,0.3);
            color: #8bc; cursor: pointer; border-radius: 10px; font-size: 16px;
            font-family: inherit; transition: all 0.3s; text-align: center; letter-spacing: 1px;
        }
        .menu-btn:hover {
            background: rgba(60,100,160,0.5); border-color: rgba(120,180,240,0.6);
            transform: translateY(-2px); box-shadow: 0 4px 20px rgba(80,140,220,0.3);
        }
        .menu-btn.selected {
            background: rgba(80,130,200,0.4); border-color: rgba(140,200,255,0.6);
        }
        .diff-row { display: flex; gap: 10px; margin: 15px 0 25px; }
        .diff-btn {
            padding: 8px 20px; background: rgba(40,60,100,0.3); border: 1px solid rgba(80,120,180,0.3);
            color: #7ab; cursor: pointer; border-radius: 8px; font-size: 13px;
            font-family: inherit; transition: all 0.3s;
        }
        .diff-btn:hover { background: rgba(50,80,130,0.5); }
        .diff-btn.active { background: rgba(70,120,180,0.5); border-color: #8cf; color: #ace; }
        .high-scores-title {
            margin-top: 30px; font-size: 13px; color: rgba(150,190,220,0.5); letter-spacing: 1px;
        }
        .high-score-entry { font-size: 12px; color: rgba(120,160,200,0.4); margin: 3px 0; }

        /* HUD */
        #hud {
            position: fixed; top: 0; left: 0; width: 100%; height: 50px;
            background: linear-gradient(180deg, rgba(5,10,20,0.9) 0%, rgba(5,10,20,0) 100%);
            display: none; z-index: 200; padding: 10px 20px;
            font-size: 13px; color: #8ab;
        }
        .hud-left { float: left; }
        .hud-right { float: right; }
        .hud-center { text-align: center; }
        #hud .score-val { color: #ace; font-size: 18px; font-weight: bold; }
        #hud .combo-val { color: #fda; font-size: 14px; }
        #hud .level-val { color: #adf; }
        #hud .time-val { color: #fcc; font-size: 16px; }

        /* Challenge Banner */
        #challenge-banner {
            position: fixed; top: 60px; left: 50%; transform: translateX(-50%);
            background: rgba(10,20,40,0.9); border: 1px solid rgba(100,160,220,0.4);
            padding: 10px 25px; border-radius: 10px; color: #ace; font-size: 14px;
            display: none; z-index: 200; text-align: center; white-space: nowrap;
        }
        #challenge-progress {
            height: 3px; background: rgba(100,160,220,0.2); border-radius: 2px; margin-top: 6px;
        }
        #challenge-fill {
            height: 100%; background: linear-gradient(90deg, #48f, #8cf); border-radius: 2px;
            width: 0%; transition: width 0.3s;
        }

        /* Time Display */
        #time-display {
            position: fixed; top: 60px; right: 20px;
            background: rgba(10,20,40,0.85); border: 1px solid rgba(100,160,220,0.3);
            padding: 12px 18px; border-radius: 10px; color: #8ab; text-align: center;
            display: none; z-index: 200;
        }
        #time-val { font-size: 22px; color: #ace; }
        #phase-val { font-size: 11px; opacity: 0.7; margin-top: 4px; }

        /* Tool Panel */
        #tool-panel {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(10,20,40,0.9); border: 1px solid rgba(100,160,220,0.3);
            padding: 10px 20px; border-radius: 12px; display: none; z-index: 200;
        }
        .tool-row { display: flex; gap: 10px; align-items: center; }
        .tool-btn {
            padding: 8px 14px; background: rgba(40,60,100,0.4); border: 1px solid rgba(80,120,180,0.3);
            color: #8ab; cursor: pointer; border-radius: 8px; font-size: 12px;
            font-family: inherit; transition: all 0.2s;
        }
        .tool-btn:hover { background: rgba(60,90,140,0.5); }
        .tool-btn.active { background: rgba(80,130,200,0.5); border-color: #8cf; color: #fff; }
        .tool-slider { width: 100px; margin: 0 8px; }
        .tool-label { font-size: 11px; color: #7ab; }

        /* Pause Overlay */
        #pause-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(2,5,15,0.85); display: none; z-index: 500;
            flex-direction: column; align-items: center; justify-content: center;
        }
        #pause-overlay h2 { color: #ace; font-size: 36px; margin-bottom: 30px; font-weight: 300; }

        /* Game Over */
        #gameover-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(2,5,15,0.9); display: none; z-index: 600;
            flex-direction: column; align-items: center; justify-content: center;
        }
        #gameover-screen h2 { color: #ace; font-size: 32px; margin-bottom: 10px; font-weight: 300; }
        .grade-display {
            font-size: 72px; font-weight: bold; margin: 15px 0;
            text-shadow: 0 0 40px currentColor;
        }
        .grade-S { color: #ffd700; }
        .grade-A { color: #ff6090; }
        .grade-B { color: #60a0ff; }
        .grade-C { color: #60d060; }
        .grade-D { color: #a0a0a0; }
        .stat-line { font-size: 14px; color: #7ab; margin: 4px 0; }
        .stat-val { color: #ace; }

        /* Dew Collection Popup */
        .dew-popup {
            position: fixed; pointer-events: none; z-index: 300;
            font-size: 16px; font-weight: bold; color: #8cf;
            text-shadow: 0 0 10px rgba(100,160,255,0.5);
            animation: dewFloat 1.2s ease-out forwards;
        }
        @keyframes dewFloat {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-60px) scale(0.6); opacity: 0; }
        }

        /* Responsive */
        @media (max-width: 600px) {
            #title-screen h1 { font-size: 28px; }
            .menu-btn { width: 200px; font-size: 14px; }
            .diff-btn { padding: 6px 14px; font-size: 12px; }
            #hud { font-size: 11px; }
            #hud .score-val { font-size: 15px; }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <!-- Title Screen -->
    <div id="title-screen">
        <h1>Morning Dew</h1>
        <div class="subtitle">SPIN SILK IN DARKNESS, REVEAL IN LIGHT</div>
        <div class="diff-row">
            <button class="diff-btn active" data-diff="casual">Casual</button>
            <button class="diff-btn" data-diff="normal">Normal</button>
            <button class="diff-btn" data-diff="expert">Expert</button>
        </div>
        <button class="menu-btn" id="btn-freeweave">Free Weave</button>
        <button class="menu-btn" id="btn-challenge">Challenge Mode</button>
        <button class="menu-btn" id="btn-timed">Timed Sunrise</button>
        <div class="high-scores-title">HIGH SCORES</div>
        <div id="high-scores-list"></div>
    </div>

    <!-- HUD -->
    <div id="hud">
        <div class="hud-left">
            <span class="score-val" id="hud-score">0</span>
            <span class="combo-val" id="hud-combo"></span>
        </div>
        <div class="hud-center">
            <span class="level-val" id="hud-level">Level 1</span>
        </div>
        <div class="hud-right">
            <span class="time-val" id="hud-timer"></span>
        </div>
    </div>

    <!-- Challenge Banner -->
    <div id="challenge-banner">
        <div id="challenge-text">Challenge</div>
        <div id="challenge-progress"><div id="challenge-fill"></div></div>
    </div>

    <!-- Time Display -->
    <div id="time-display">
        <div id="time-val">3:00 AM</div>
        <div id="phase-val">Night - Draw your web</div>
    </div>

    <!-- Tool Panel -->
    <div id="tool-panel">
        <div class="tool-row">
            <button class="tool-btn active" data-tool="silk">Silk</button>
            <button class="tool-btn" data-tool="radial">Radial</button>
            <button class="tool-btn" data-tool="spiral">Spiral</button>
            <button class="tool-btn" data-tool="scatter">Scatter</button>
            <span class="tool-label">Size:</span>
            <input type="range" class="tool-slider" id="brush-size" min="5" max="60" value="20">
            <span class="tool-label">Dew:</span>
            <input type="range" class="tool-slider" id="dew-intensity" min="10" max="100" value="50">
            <button class="tool-btn" id="btn-sunrise">Sunrise</button>
            <button class="tool-btn" id="btn-clear">Clear</button>
        </div>
    </div>

    <!-- Pause -->
    <div id="pause-overlay">
        <h2>Paused</h2>
        <button class="menu-btn" id="btn-resume">Resume</button>
        <button class="menu-btn" id="btn-quit">Quit to Menu</button>
    </div>

    <!-- Game Over -->
    <div id="gameover-screen">
        <h2>Sunrise Complete</h2>
        <div class="grade-display" id="go-grade">B</div>
        <div class="stat-line">Score: <span class="stat-val" id="go-score">0</span></div>
        <div class="stat-line">Strands: <span class="stat-val" id="go-strands">0</span></div>
        <div class="stat-line">Dew Collected: <span class="stat-val" id="go-dew">0</span></div>
        <div class="stat-line">Max Combo: <span class="stat-val" id="go-combo">0</span></div>
        <div class="stat-line">Challenges: <span class="stat-val" id="go-challenges">0</span></div>
        <div class="stat-line" id="go-new-best" style="color:#fda;display:none">NEW HIGH SCORE!</div>
        <button class="menu-btn" id="btn-restart" style="margin-top:20px">Play Again (R)</button>
        <button class="menu-btn" id="btn-menu">Main Menu</button>
    </div>

    <script>
    'use strict';
    class MorningDewGame {
        constructor() {
            this.canvas = document.getElementById('canvas');
            this.ctx = this.canvas.getContext('2d');
            this.W = 0; this.H = 0;

            // State
            this.state = 'title'; // title, playing, paused, gameover
            this.mode = 'freeweave'; // freeweave, challenge, timed
            this.difficulty = 'normal';
            this.diffSettings = {
                casual:  { dewSpeed: 0.08, challengeTime: 45, sunriseSpeed: 0.0008, dewBonus: 2, comboDecay: 5000 },
                normal:  { dewSpeed: 0.05, challengeTime: 30, sunriseSpeed: 0.0015, dewBonus: 1, comboDecay: 3000 },
                expert:  { dewSpeed: 0.03, challengeTime: 20, sunriseSpeed: 0.003,  dewBonus: 0.5, comboDecay: 1500 }
            };

            // Web drawing
            this.strands = [];
            this.dewDrops = [];
            this.particles = [];
            this.floatingTexts = [];
            this.tool = 'silk';
            this.brushSize = 20;
            this.dewIntensity = 50;

            // Time / sunrise
            this.timeOfDay = 0; // 0 = 3AM, 1 = 8AM
            this.sunrising = false;

            // Scoring
            this.score = 0;
            this.combo = 0;
            this.maxCombo = 0;
            this.comboTimer = 0;
            this.dewCollected = 0;
            this.strandsDrawn = 0;
            this.challengesCompleted = 0;
            this.level = 1;
            this.xp = 0;
            this.xpToLevel = 500;

            // Challenge system
            this.currentChallenge = null;
            this.challengeTimer = 0;
            this.challengeProgress = 0;
            this.allChallenges = [
                { name: 'Speed Spinner', desc: 'Draw 20 strands in 30s', target: 20, type: 'strands', time: 30 },
                { name: 'Web Architect', desc: 'Draw 50 strands', target: 50, type: 'strands', time: 60 },
                { name: 'Dew Collector', desc: 'Collect 30 dew drops', target: 30, type: 'dew', time: 45 },
                { name: 'Radial Master', desc: 'Create 5 radial webs', target: 5, type: 'radial', time: 40 },
                { name: 'Spiral Weaver', desc: 'Make 3 spiral patterns', target: 3, type: 'spiral', time: 35 },
                { name: 'Scatter Shot', desc: 'Scatter 100 silk threads', target: 100, type: 'scatter', time: 50 },
                { name: 'Sunrise Rush', desc: 'Score 2000 before sunrise', target: 2000, type: 'score', time: 60 },
                { name: 'Combo King', desc: 'Reach x6 combo', target: 6, type: 'combo', time: 40 },
                { name: 'Long Threads', desc: 'Draw 10 strands over 200px', target: 10, type: 'longstrand', time: 45 },
                { name: 'Dense Web', desc: 'Fill 500 dew points', target: 500, type: 'dewpoints', time: 60 },
                { name: 'Night Crawler', desc: 'Draw in darkness (no sunrise)', target: 40, type: 'darkstrands', time: 50 },
                { name: 'Golden Hour', desc: 'Collect 20 golden dew', target: 20, type: 'goldendew', time: 40 }
            ];

            // Input
            this.drawing = false;
            this.lastPoint = null;
            this.keys = {};
            this.touches = [];

            // Screen shake
            this.shakeX = 0; this.shakeY = 0; this.shakeIntensity = 0;

            // Audio
            this.audioCtx = null;
            this.masterGain = null;

            // Timers
            this.lastTime = 0;
            this.gameTimer = 0;

            this.init();
        }

        init() {
            this.resize();
            window.addEventListener('resize', () => this.resize());
            this.setupInput();
            this.loadHighScores();
            this.renderHighScores();
            this.setupMenuButtons();
            requestAnimationFrame(t => this.loop(t));
        }

        resize() {
            this.W = this.canvas.width = innerWidth;
            this.H = this.canvas.height = innerHeight;
        }

        // --- Audio ---
        initAudio() {
            if (this.audioCtx) return;
            this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            this.masterGain = this.audioCtx.createGain();
            this.masterGain.gain.value = 0.3;
            this.masterGain.connect(this.audioCtx.destination);
        }

        playSound(type) {
            if (!this.audioCtx) return;
            const now = this.audioCtx.currentTime;
            const osc = this.audioCtx.createOscillator();
            const gain = this.audioCtx.createGain();
            osc.connect(gain);
            gain.connect(this.masterGain);

            switch(type) {
                case 'silk': {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(800 + Math.random() * 400, now);
                    osc.frequency.exponentialRampToValueAtTime(400, now + 0.15);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                    osc.start(now); osc.stop(now + 0.15);
                    break;
                }
                case 'dew': {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(1200 + this.combo * 100, now);
                    osc.frequency.exponentialRampToValueAtTime(600, now + 0.3);
                    gain.gain.setValueAtTime(0.15, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                    osc.start(now); osc.stop(now + 0.3);
                    // Sparkle harmonic
                    const osc2 = this.audioCtx.createOscillator();
                    const g2 = this.audioCtx.createGain();
                    osc2.connect(g2); g2.connect(this.masterGain);
                    osc2.type = 'sine';
                    osc2.frequency.setValueAtTime(2400 + this.combo * 200, now);
                    osc2.frequency.exponentialRampToValueAtTime(1200, now + 0.2);
                    g2.gain.setValueAtTime(0.06, now);
                    g2.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                    osc2.start(now); osc2.stop(now + 0.2);
                    break;
                }
                case 'combo': {
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(600 + this.combo * 150, now);
                    osc.frequency.exponentialRampToValueAtTime(1200 + this.combo * 200, now + 0.15);
                    gain.gain.setValueAtTime(0.12, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                    osc.start(now); osc.stop(now + 0.2);
                    break;
                }
                case 'sunrise': {
                    // Warm pad
                    const types = ['sine', 'triangle'];
                    for (let i = 0; i < 3; i++) {
                        const o = this.audioCtx.createOscillator();
                        const g = this.audioCtx.createGain();
                        o.connect(g); g.connect(this.masterGain);
                        o.type = types[i % 2];
                        o.frequency.setValueAtTime(200 + i * 150, now);
                        o.frequency.linearRampToValueAtTime(300 + i * 200, now + 2);
                        g.gain.setValueAtTime(0.04, now);
                        g.gain.linearRampToValueAtTime(0.08, now + 1);
                        g.gain.exponentialRampToValueAtTime(0.001, now + 2);
                        o.start(now); o.stop(now + 2);
                    }
                    return;
                }
                case 'challenge': {
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(800, now);
                    osc.frequency.setValueAtTime(1000, now + 0.1);
                    osc.frequency.setValueAtTime(1200, now + 0.2);
                    gain.gain.setValueAtTime(0.08, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
                    osc.start(now); osc.stop(now + 0.4);
                    break;
                }
                case 'levelup': {
                    for (let i = 0; i < 4; i++) {
                        const o = this.audioCtx.createOscillator();
                        const g = this.audioCtx.createGain();
                        o.connect(g); g.connect(this.masterGain);
                        o.type = 'sine';
                        o.frequency.setValueAtTime(400 + i * 200, now + i * 0.12);
                        g.gain.setValueAtTime(0.1, now + i * 0.12);
                        g.gain.exponentialRampToValueAtTime(0.001, now + i * 0.12 + 0.3);
                        o.start(now + i * 0.12); o.stop(now + i * 0.12 + 0.3);
                    }
                    return;
                }
                case 'gameover': {
                    for (let i = 0; i < 5; i++) {
                        const o = this.audioCtx.createOscillator();
                        const g = this.audioCtx.createGain();
                        o.connect(g); g.connect(this.masterGain);
                        o.type = i < 3 ? 'sine' : 'triangle';
                        o.frequency.setValueAtTime(300 + i * 100, now + i * 0.2);
                        o.frequency.linearRampToValueAtTime(500 + i * 150, now + i * 0.2 + 0.5);
                        g.gain.setValueAtTime(0.08, now + i * 0.2);
                        g.gain.exponentialRampToValueAtTime(0.001, now + i * 0.2 + 0.6);
                        o.start(now + i * 0.2); o.stop(now + i * 0.2 + 0.6);
                    }
                    return;
                }
                case 'drop': {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(600, now);
                    osc.frequency.exponentialRampToValueAtTime(100, now + 0.5);
                    gain.gain.setValueAtTime(0.08, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                    osc.start(now); osc.stop(now + 0.5);
                    break;
                }
                case 'wind': {
                    // Noise-like wind effect
                    const bufferSize = this.audioCtx.sampleRate * 0.5;
                    const buffer = this.audioCtx.createBuffer(1, bufferSize, this.audioCtx.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) {
                        data[i] = (Math.random() * 2 - 1) * 0.3;
                    }
                    const source = this.audioCtx.createBufferSource();
                    source.buffer = buffer;
                    const filter = this.audioCtx.createBiquadFilter();
                    filter.type = 'bandpass';
                    filter.frequency.value = 400;
                    filter.Q.value = 2;
                    const wg = this.audioCtx.createGain();
                    source.connect(filter);
                    filter.connect(wg);
                    wg.connect(this.masterGain);
                    wg.gain.setValueAtTime(0.02, now);
                    wg.gain.linearRampToValueAtTime(0.06, now + 0.2);
                    wg.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                    source.start(now); source.stop(now + 0.5);
                    return;
                }
            }
            osc.start(now);
        }

        // --- Input ---
        setupInput() {
            this.canvas.addEventListener('mousedown', e => this.onPointerDown(e.clientX, e.clientY, e));
            this.canvas.addEventListener('mousemove', e => this.onPointerMove(e.clientX, e.clientY));
            this.canvas.addEventListener('mouseup', () => this.onPointerUp());
            this.canvas.addEventListener('mouseleave', () => this.onPointerUp());

            this.canvas.addEventListener('touchstart', e => {
                e.preventDefault();
                const t = e.touches[0];
                this.onPointerDown(t.clientX, t.clientY, e);
            }, { passive: false });
            this.canvas.addEventListener('touchmove', e => {
                e.preventDefault();
                const t = e.touches[0];
                this.onPointerMove(t.clientX, t.clientY);
            }, { passive: false });
            this.canvas.addEventListener('touchend', e => {
                e.preventDefault();
                this.onPointerUp();
            }, { passive: false });

            document.addEventListener('keydown', e => {
                this.keys[e.key] = true;
                if (e.key === 'Escape') this.togglePause();
                if (e.key === 'r' || e.key === 'R') {
                    if (this.state === 'gameover') this.startGame(this.mode);
                }
                if (e.key === ' ' && this.state === 'playing' && !this.sunrising) {
                    e.preventDefault();
                    this.beginSunrise();
                }
                if (e.key >= '1' && e.key <= '4' && this.state === 'playing') {
                    const tools = ['silk', 'radial', 'spiral', 'scatter'];
                    this.tool = tools[parseInt(e.key) - 1];
                    this.updateToolButtons();
                }
            });
            document.addEventListener('keyup', e => { this.keys[e.key] = false; });
        }

        onPointerDown(x, y, e) {
            if (this.state !== 'playing') return;
            this.initAudio();
            this.drawing = true;
            this.lastPoint = { x, y };
            if (this.tool === 'radial') this.createRadialWeb(x, y);
            else if (this.tool === 'spiral') this.createSpiralWeb(x, y);
            else if (this.tool === 'scatter') this.createScatter(x, y);
        }

        onPointerMove(x, y) {
            if (!this.drawing || this.state !== 'playing') return;
            if (this.tool === 'silk' && this.lastPoint) {
                const dist = Math.hypot(x - this.lastPoint.x, y - this.lastPoint.y);
                if (dist > 15) {
                    this.addStrand(this.lastPoint.x, this.lastPoint.y, x, y);
                    this.lastPoint = { x, y };
                }
            } else if (this.tool === 'scatter') {
                this.createScatter(x, y);
            }
            // Check dew collection
            this.checkDewCollection(x, y);
        }

        onPointerUp() {
            this.drawing = false;
            this.lastPoint = null;
        }

        // --- Strand Creation ---
        addStrand(x1, y1, x2, y2) {
            const strand = {
                x1, y1, x2, y2,
                tension: 1,
                dewPoints: [],
                age: 0,
                type: 'silk'
            };
            const length = Math.hypot(x2 - x1, y2 - y1);
            const count = Math.floor(length / 12) + 1;
            for (let i = 0; i <= count; i++) {
                const t = i / count;
                strand.dewPoints.push({
                    t, size: 0,
                    maxSize: 2 + Math.random() * 5,
                    offset: Math.random() * 0.08 - 0.04,
                    revealed: false,
                    collected: false,
                    golden: Math.random() < 0.08,
                    shimmer: Math.random() * Math.PI * 2
                });
            }
            this.strands.push(strand);
            this.strandsDrawn++;
            this.addScore(10, x2, y2);
            this.playSound('silk');

            // Particles
            for (let i = 0; i < 3; i++) {
                this.particles.push({
                    x: x2, y: y2,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    size: 1 + Math.random() * 2,
                    life: 1, maxLife: 1,
                    color: 'rgba(150,200,255,',
                    type: 'sparkle'
                });
            }

            // Challenge tracking
            if (this.currentChallenge) {
                if (this.currentChallenge.type === 'strands' || this.currentChallenge.type === 'darkstrands') {
                    this.challengeProgress++;
                }
                if (this.currentChallenge.type === 'longstrand' && length > 200) {
                    this.challengeProgress++;
                }
                if (this.currentChallenge.type === 'dewpoints') {
                    this.challengeProgress += strand.dewPoints.length;
                }
            }
        }

        createRadialWeb(cx, cy) {
            const spokes = 8 + Math.floor(Math.random() * 6);
            const radius = this.brushSize * 3 + Math.random() * 40;
            // Spokes
            for (let i = 0; i < spokes; i++) {
                const angle = (i / spokes) * Math.PI * 2;
                const ex = cx + Math.cos(angle) * radius;
                const ey = cy + Math.sin(angle) * radius;
                this.addStrand(cx, cy, ex, ey);
            }
            // Rings
            const rings = 3 + Math.floor(Math.random() * 3);
            for (let r = 1; r <= rings; r++) {
                const ringRadius = (r / rings) * radius;
                const segments = spokes * 2;
                for (let i = 0; i < segments; i++) {
                    const a1 = (i / segments) * Math.PI * 2;
                    const a2 = ((i + 1) / segments) * Math.PI * 2;
                    const x1 = cx + Math.cos(a1) * ringRadius;
                    const y1 = cy + Math.sin(a1) * ringRadius;
                    const x2 = cx + Math.cos(a2) * ringRadius;
                    const y2 = cy + Math.sin(a2) * ringRadius;
                    this.addStrand(x1, y1, x2, y2);
                }
            }
            this.addScore(100, cx, cy);
            this.playSound('wind');

            if (this.currentChallenge && this.currentChallenge.type === 'radial') {
                this.challengeProgress++;
            }
        }

        createSpiralWeb(cx, cy) {
            const turns = 3 + Math.random() * 2;
            const maxR = this.brushSize * 3 + Math.random() * 30;
            const steps = 40;
            let prevX = cx, prevY = cy;
            for (let i = 1; i <= steps; i++) {
                const t = i / steps;
                const angle = t * turns * Math.PI * 2;
                const r = t * maxR;
                const x = cx + Math.cos(angle) * r;
                const y = cy + Math.sin(angle) * r;
                this.addStrand(prevX, prevY, x, y);
                prevX = x; prevY = y;
            }
            this.addScore(80, cx, cy);
            if (this.currentChallenge && this.currentChallenge.type === 'spiral') {
                this.challengeProgress++;
            }
        }

        createScatter(cx, cy) {
            const count = 3 + Math.floor(Math.random() * 3);
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * this.brushSize * 2;
                const x1 = cx + Math.cos(angle) * dist;
                const y1 = cy + Math.sin(angle) * dist;
                const a2 = angle + (Math.random() - 0.5) * 1.5;
                const d2 = 10 + Math.random() * 30;
                const x2 = x1 + Math.cos(a2) * d2;
                const y2 = y1 + Math.sin(a2) * d2;
                this.addStrand(x1, y1, x2, y2);
            }
            if (this.currentChallenge && this.currentChallenge.type === 'scatter') {
                this.challengeProgress += count;
            }
        }

        // --- Dew Collection ---
        checkDewCollection(mx, my) {
            const collectRadius = 30;
            this.strands.forEach(strand => {
                strand.dewPoints.forEach(dp => {
                    if (dp.collected || dp.size < dp.maxSize * 0.5) return;
                    const t = dp.t + dp.offset;
                    const sag = Math.sin(t * Math.PI) * 5 * (1 - strand.tension);
                    const px = strand.x1 + (strand.x2 - strand.x1) * t;
                    const py = strand.y1 + (strand.y2 - strand.y1) * t + sag;
                    const dist = Math.hypot(mx - px, my - py);
                    if (dist < collectRadius) {
                        dp.collected = true;
                        this.dewCollected++;
                        const points = dp.golden ? 50 : 15;
                        this.addScore(points, px, py);
                        this.addCombo();
                        this.playSound('dew');

                        // Collection particles
                        for (let i = 0; i < 6; i++) {
                            this.particles.push({
                                x: px, y: py,
                                vx: (Math.random() - 0.5) * 4,
                                vy: (Math.random() - 0.5) * 4 - 2,
                                size: 2 + Math.random() * 3,
                                life: 1, maxLife: 1,
                                color: dp.golden ? 'rgba(255,215,0,' : 'rgba(150,200,255,',
                                type: 'burst'
                            });
                        }

                        // Screen shake
                        this.shakeIntensity = dp.golden ? 4 : 2;

                        // Challenge tracking
                        if (this.currentChallenge) {
                            if (this.currentChallenge.type === 'dew') this.challengeProgress++;
                            if (this.currentChallenge.type === 'goldendew' && dp.golden) this.challengeProgress++;
                        }
                    }
                });
            });
        }

        // --- Scoring ---
        addScore(points, x, y) {
            const multiplier = Math.max(1, this.combo);
            const total = Math.floor(points * multiplier * this.diffSettings[this.difficulty].dewBonus);
            this.score += total;
            this.xp += total;

            // Floating text
            this.floatingTexts.push({
                x, y, text: '+' + total,
                life: 1, color: this.combo > 3 ? '#fda' : '#8cf'
            });

            // Level up check
            while (this.xp >= this.xpToLevel) {
                this.xp -= this.xpToLevel;
                this.level++;
                this.xpToLevel = Math.floor(this.xpToLevel * 1.4);
                this.playSound('levelup');
                this.shakeIntensity = 6;
                this.floatingTexts.push({
                    x: this.W / 2, y: this.H / 2,
                    text: 'LEVEL ' + this.level, life: 2, color: '#fff', big: true
                });
            }

            this.updateHUD();

            // Challenge score tracking
            if (this.currentChallenge && this.currentChallenge.type === 'score') {
                this.challengeProgress = this.score;
            }
        }

        addCombo() {
            this.combo++;
            if (this.combo > this.maxCombo) this.maxCombo = this.combo;
            this.comboTimer = this.diffSettings[this.difficulty].comboDecay;
            if (this.combo > 1) this.playSound('combo');

            if (this.currentChallenge && this.currentChallenge.type === 'combo') {
                this.challengeProgress = Math.max(this.challengeProgress, this.combo);
            }
        }

        // --- Sunrise ---
        beginSunrise() {
            if (this.sunrising) return;
            this.sunrising = true;
            this.playSound('sunrise');
        }

        // --- Sky & Environment ---
        getSkyColor(time) {
            if (time < 0.15) return { r: 3, g: 8, b: 18 };
            if (time < 0.3) {
                const t = (time - 0.15) / 0.15;
                return { r: 3 + t * 40, g: 8 + t * 30, b: 18 + t * 30 };
            }
            if (time < 0.5) {
                const t = (time - 0.3) / 0.2;
                return { r: 43 + t * 120, g: 38 + t * 80, b: 48 + t * 40 };
            }
            if (time < 0.7) {
                const t = (time - 0.5) / 0.2;
                return { r: 163 + t * 60, g: 118 + t * 60, b: 88 + t * 60 };
            }
            return { r: 223, g: 178, b: 148 };
        }

        drawSky() {
            const sky = this.getSkyColor(this.timeOfDay);
            const grad = this.ctx.createLinearGradient(0, 0, 0, this.H);
            grad.addColorStop(0, 'rgb(' + Math.floor(sky.r * 0.6) + ',' + Math.floor(sky.g * 0.6) + ',' + Math.floor(sky.b * 0.8) + ')');
            grad.addColorStop(0.6, 'rgb(' + sky.r + ',' + sky.g + ',' + sky.b + ')');
            grad.addColorStop(1, 'rgb(' + Math.floor(sky.r * 1.1) + ',' + Math.floor(sky.g * 0.9) + ',' + Math.floor(sky.b * 0.7) + ')');
            this.ctx.fillStyle = grad;
            this.ctx.fillRect(0, 0, this.W, this.H);

            // Stars (fade with sunrise)
            if (this.timeOfDay < 0.4) {
                const starAlpha = Math.max(0, 1 - this.timeOfDay * 3);
                this.ctx.fillStyle = 'rgba(255,255,255,' + (starAlpha * 0.6) + ')';
                // Use seeded positions
                for (let i = 0; i < 80; i++) {
                    const sx = ((i * 7919 + 1) % this.W);
                    const sy = ((i * 6271 + 3) % (this.H * 0.6));
                    const ss = ((i * 3571) % 3) * 0.5 + 0.5;
                    const twinkle = Math.sin(this.gameTimer * 2 + i) * 0.3 + 0.7;
                    this.ctx.globalAlpha = starAlpha * twinkle * 0.8;
                    this.ctx.beginPath();
                    this.ctx.arc(sx, sy, ss, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                this.ctx.globalAlpha = 1;
            }

            // Sun
            if (this.timeOfDay > 0.35) {
                const sunT = (this.timeOfDay - 0.35) / 0.65;
                const sunX = this.W * 0.8;
                const sunY = this.H * (1.1 - sunT * 0.8);
                const sunR = 30 + sunT * 20;

                // Glow
                const glow = this.ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, sunR * 8);
                glow.addColorStop(0, 'rgba(255,200,100,' + (sunT * 0.5) + ')');
                glow.addColorStop(0.3, 'rgba(255,150,50,' + (sunT * 0.2) + ')');
                glow.addColorStop(1, 'transparent');
                this.ctx.fillStyle = glow;
                this.ctx.fillRect(0, 0, this.W, this.H);

                // Sun disc
                this.ctx.beginPath();
                this.ctx.arc(sunX, sunY, sunR, 0, Math.PI * 2);
                this.ctx.fillStyle = 'rgba(255,230,180,' + (sunT * 0.9) + ')';
                this.ctx.fill();
            }

            // Mist layer
            if (this.timeOfDay > 0.2 && this.timeOfDay < 0.6) {
                const mistAlpha = Math.sin((this.timeOfDay - 0.2) / 0.4 * Math.PI) * 0.08;
                this.ctx.fillStyle = 'rgba(200,210,220,' + mistAlpha + ')';
                this.ctx.fillRect(0, this.H * 0.5, this.W, this.H * 0.5);
            }
        }

        // --- Drawing ---
        getStrandPoint(strand, t) {
            const sag = Math.sin(t * Math.PI) * 5 * (1 - strand.tension);
            const windSway = Math.sin(this.gameTimer * 1.5 + strand.x1 * 0.01) * 2;
            return {
                x: strand.x1 + (strand.x2 - strand.x1) * t,
                y: strand.y1 + (strand.y2 - strand.y1) * t + sag + windSway * t * (1 - t) * 4
            };
        }

        drawStrands() {
            const visibility = Math.max(0.08, (this.timeOfDay - 0.15) / 0.5);
            this.strands.forEach(strand => {
                // Draw the silk thread
                const alpha = 0.05 + Math.min(1, visibility) * 0.35;
                this.ctx.beginPath();
                const p0 = this.getStrandPoint(strand, 0);
                this.ctx.moveTo(p0.x, p0.y);
                for (let t = 0.05; t <= 1; t += 0.05) {
                    const p = this.getStrandPoint(strand, t);
                    this.ctx.lineTo(p.x, p.y);
                }
                this.ctx.strokeStyle = 'rgba(200,220,255,' + alpha + ')';
                this.ctx.lineWidth = 0.8;
                this.ctx.stroke();

                // Glow effect when lit
                if (visibility > 0.3) {
                    this.ctx.strokeStyle = 'rgba(200,220,255,' + (alpha * 0.3) + ')';
                    this.ctx.lineWidth = 3;
                    this.ctx.stroke();
                }

                // Draw dew drops
                strand.dewPoints.forEach(dp => {
                    if (dp.collected) return;
                    if (dp.size > 0.5) {
                        const p = this.getStrandPoint(strand, dp.t + dp.offset);
                        const sz = dp.size;

                        // Main drop
                        const grad = this.ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, sz);
                        if (dp.golden) {
                            grad.addColorStop(0, 'rgba(255,230,100,0.95)');
                            grad.addColorStop(0.5, 'rgba(255,200,50,0.6)');
                            grad.addColorStop(1, 'rgba(255,180,0,0)');
                        } else {
                            grad.addColorStop(0, 'rgba(255,255,255,0.9)');
                            grad.addColorStop(0.4, 'rgba(180,220,255,0.6)');
                            grad.addColorStop(1, 'rgba(120,180,255,0)');
                        }
                        this.ctx.beginPath();
                        this.ctx.arc(p.x, p.y + sz * 0.3, sz, 0, Math.PI * 2);
                        this.ctx.fillStyle = grad;
                        this.ctx.fill();

                        // Highlight
                        if (visibility > 0.4) {
                            const shimmer = Math.sin(this.gameTimer * 3 + dp.shimmer) * 0.3 + 0.7;
                            this.ctx.beginPath();
                            this.ctx.arc(p.x - sz * 0.3, p.y - sz * 0.1, sz * 0.2, 0, Math.PI * 2);
                            this.ctx.fillStyle = 'rgba(255,255,255,' + (shimmer * 0.8) + ')';
                            this.ctx.fill();
                        }

                        // Golden sparkle
                        if (dp.golden && visibility > 0.3) {
                            const spark = Math.sin(this.gameTimer * 5 + dp.shimmer);
                            if (spark > 0.7) {
                                this.ctx.beginPath();
                                this.ctx.arc(p.x + sz * 0.5 * Math.cos(this.gameTimer * 2), p.y + sz * 0.5 * Math.sin(this.gameTimer * 2), 1, 0, Math.PI * 2);
                                this.ctx.fillStyle = 'rgba(255,255,200,0.9)';
                                this.ctx.fill();
                            }
                        }
                    }
                });
            });
        }

        drawParticles() {
            for (let i = this.particles.length - 1; i >= 0; i--) {
                const p = this.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                if (p.type === 'burst') p.vy += 0.08;
                else p.vy -= 0.02;
                p.life -= 0.02;
                if (p.life <= 0) { this.particles.splice(i, 1); continue; }
                this.ctx.beginPath();
                this.ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                this.ctx.fillStyle = p.color + (p.life * 0.7) + ')';
                this.ctx.fill();
            }
        }

        drawFloatingTexts() {
            for (let i = this.floatingTexts.length - 1; i >= 0; i--) {
                const ft = this.floatingTexts[i];
                ft.y -= 1.5;
                ft.life -= 0.02;
                if (ft.life <= 0) { this.floatingTexts.splice(i, 1); continue; }
                this.ctx.save();
                this.ctx.globalAlpha = Math.min(1, ft.life * 2);
                this.ctx.font = (ft.big ? 'bold 28px' : '14px') + ' "Segoe UI", Arial, sans-serif';
                this.ctx.fillStyle = ft.color;
                this.ctx.textAlign = 'center';
                this.ctx.fillText(ft.text, ft.x, ft.y);
                this.ctx.restore();
            }
        }

        // Ambient dew particles that float around
        spawnAmbientParticle() {
            if (this.timeOfDay > 0.2 && this.particles.length < 60) {
                this.particles.push({
                    x: Math.random() * this.W,
                    y: this.H + 10,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: -0.3 - Math.random() * 0.5,
                    size: 1 + Math.random() * 2,
                    life: 1, maxLife: 1,
                    color: 'rgba(180,210,240,',
                    type: 'ambient'
                });
            }
        }

        // --- Update ---
        update(dt) {
            if (this.state !== 'playing') return;

            this.gameTimer += dt;

            // Sunrise progression
            if (this.sunrising && this.timeOfDay < 1) {
                this.timeOfDay += this.diffSettings[this.difficulty].sunriseSpeed * dt * 60;
                this.updateTimeDisplay();
            }

            // Dew growth
            const dewSpeed = this.diffSettings[this.difficulty].dewSpeed;
            this.strands.forEach(strand => {
                strand.age += dt;
                strand.dewPoints.forEach(dp => {
                    if (dp.collected) return;
                    if (this.timeOfDay > 0.2 && !dp.revealed) dp.revealed = true;
                    if (dp.revealed && dp.size < dp.maxSize) {
                        dp.size += dewSpeed * (this.dewIntensity / 50) * dt * 60;
                    }
                    // Dew drops that get too heavy fall
                    if (dp.size > dp.maxSize * 1.5) {
                        dp.collected = true;
                        const p = this.getStrandPoint(strand, dp.t);
                        this.playSound('drop');
                        for (let j = 0; j < 4; j++) {
                            this.particles.push({
                                x: p.x, y: p.y,
                                vx: (Math.random() - 0.5) * 2,
                                vy: 2 + Math.random() * 3,
                                size: 1 + Math.random() * 2,
                                life: 1, maxLife: 1,
                                color: 'rgba(150,200,255,',
                                type: 'burst'
                            });
                        }
                    }
                    // Tension decrease
                    if (dp.size > dp.maxSize * 0.6) {
                        strand.tension = Math.max(0.6, strand.tension - 0.0001 * dp.size * dt * 60);
                    }
                });
            });

            // Combo decay
            if (this.combo > 0) {
                this.comboTimer -= dt * 1000;
                if (this.comboTimer <= 0) {
                    this.combo = 0;
                    this.updateHUD();
                }
            }

            // Challenge timer
            if (this.currentChallenge) {
                this.challengeTimer -= dt;
                if (this.challengeProgress >= this.currentChallenge.target) {
                    this.completeChallenge();
                } else if (this.challengeTimer <= 0) {
                    this.failChallenge();
                }
                this.updateChallengeBanner();
            }

            // Screen shake decay
            if (this.shakeIntensity > 0) {
                this.shakeX = (Math.random() - 0.5) * this.shakeIntensity * 2;
                this.shakeY = (Math.random() - 0.5) * this.shakeIntensity * 2;
                this.shakeIntensity *= 0.9;
                if (this.shakeIntensity < 0.1) { this.shakeIntensity = 0; this.shakeX = 0; this.shakeY = 0; }
            }

            // Ambient particles
            if (Math.random() < 0.05) this.spawnAmbientParticle();

            // Auto game-over in timed mode
            if (this.mode === 'timed' && this.timeOfDay >= 1) {
                this.endGame();
            }

            // Challenge mode: auto-assign
            if (this.mode === 'challenge' && !this.currentChallenge) {
                this.assignChallenge();
            }
        }

        // --- Challenge System ---
        assignChallenge() {
            const idx = Math.floor(Math.random() * this.allChallenges.length);
            const template = this.allChallenges[idx];
            this.currentChallenge = { ...template };
            this.currentChallenge.time = Math.floor(template.time * (this.difficulty === 'casual' ? 1.5 : this.difficulty === 'expert' ? 0.7 : 1));
            this.challengeTimer = this.currentChallenge.time;
            this.challengeProgress = 0;
            this.playSound('challenge');

            const banner = document.getElementById('challenge-banner');
            banner.style.display = 'block';
            document.getElementById('challenge-text').textContent = this.currentChallenge.name + ': ' + this.currentChallenge.desc;
        }

        completeChallenge() {
            this.challengesCompleted++;
            const bonus = 500 * this.level;
            this.addScore(bonus, this.W / 2, this.H / 2);
            this.playSound('levelup');
            this.shakeIntensity = 5;
            this.floatingTexts.push({
                x: this.W / 2, y: this.H / 2 - 30,
                text: 'CHALLENGE COMPLETE! +' + bonus, life: 2.5, color: '#fda', big: true
            });

            // Burst of particles
            for (let i = 0; i < 20; i++) {
                this.particles.push({
                    x: this.W / 2, y: this.H / 2,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    size: 2 + Math.random() * 4,
                    life: 1, maxLife: 1,
                    color: 'rgba(255,200,100,',
                    type: 'burst'
                });
            }

            this.currentChallenge = null;
            document.getElementById('challenge-banner').style.display = 'none';
        }

        failChallenge() {
            this.floatingTexts.push({
                x: this.W / 2, y: this.H / 2,
                text: 'Challenge Failed', life: 1.5, color: '#f88', big: true
            });
            this.currentChallenge = null;
            document.getElementById('challenge-banner').style.display = 'none';
        }

        updateChallengeBanner() {
            if (!this.currentChallenge) return;
            const pct = Math.min(100, (this.challengeProgress / this.currentChallenge.target) * 100);
            document.getElementById('challenge-fill').style.width = pct + '%';
            document.getElementById('challenge-text').textContent =
                this.currentChallenge.name + ': ' + this.challengeProgress + '/' + this.currentChallenge.target +
                ' (' + Math.ceil(this.challengeTimer) + 's)';
        }

        // --- HUD ---
        updateHUD() {
            document.getElementById('hud-score').textContent = this.score.toLocaleString();
            document.getElementById('hud-combo').textContent = this.combo > 1 ? ' x' + this.combo : '';
            document.getElementById('hud-level').textContent = 'Level ' + this.level + ' (' + this.strandsDrawn + ' strands)';
        }

        updateTimeDisplay() {
            const hours = 3 + this.timeOfDay * 5;
            const h = Math.floor(hours);
            const m = Math.floor((hours - h) * 60);
            document.getElementById('time-val').textContent = h + ':' + (m < 10 ? '0' : '') + m + ' AM';
            const phases = [
                [0.15, 'Night - Spin your webs'],
                [0.25, 'Late night - Dew forming'],
                [0.4, 'Pre-dawn - Mist rising'],
                [0.6, 'Dawn - Light breaks'],
                [0.8, 'Sunrise - Revelation'],
                [1.0, 'Morning - Web revealed']
            ];
            let phaseText = phases[phases.length - 1][1];
            for (const [threshold, text] of phases) {
                if (this.timeOfDay < threshold) { phaseText = text; break; }
            }
            document.getElementById('phase-val').textContent = phaseText;
        }

        updateToolButtons() {
            document.querySelectorAll('#tool-panel .tool-btn[data-tool]').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tool === this.tool);
            });
        }

        // --- Game State ---
        startGame(mode) {
            this.initAudio();
            this.mode = mode;
            this.state = 'playing';
            this.score = 0;
            this.combo = 0;
            this.maxCombo = 0;
            this.comboTimer = 0;
            this.dewCollected = 0;
            this.strandsDrawn = 0;
            this.challengesCompleted = 0;
            this.level = 1;
            this.xp = 0;
            this.xpToLevel = 500;
            this.strands = [];
            this.particles = [];
            this.floatingTexts = [];
            this.timeOfDay = 0;
            this.sunrising = false;
            this.gameTimer = 0;
            this.currentChallenge = null;
            this.challengeProgress = 0;
            this.tool = 'silk';
            this.brushSize = 20;
            this.dewIntensity = 50;

            document.getElementById('title-screen').style.display = 'none';
            document.getElementById('gameover-screen').style.display = 'none';
            document.getElementById('pause-overlay').style.display = 'none';
            document.getElementById('hud').style.display = 'block';
            document.getElementById('time-display').style.display = 'block';
            document.getElementById('tool-panel').style.display = 'block';
            document.getElementById('challenge-banner').style.display = 'none';

            if (mode === 'timed') {
                this.sunrising = true;
            }

            this.updateHUD();
            this.updateTimeDisplay();
            this.updateToolButtons();
        }

        endGame() {
            this.state = 'gameover';
            this.playSound('gameover');

            const grade = this.score >= 10000 ? 'S' : this.score >= 5000 ? 'A' : this.score >= 2000 ? 'B' : this.score >= 800 ? 'C' : 'D';
            document.getElementById('go-grade').textContent = grade;
            document.getElementById('go-grade').className = 'grade-display grade-' + grade;
            document.getElementById('go-score').textContent = this.score.toLocaleString();
            document.getElementById('go-strands').textContent = this.strandsDrawn;
            document.getElementById('go-dew').textContent = this.dewCollected;
            document.getElementById('go-combo').textContent = 'x' + this.maxCombo;
            document.getElementById('go-challenges').textContent = this.challengesCompleted;

            const isNew = this.saveHighScore(this.score);
            document.getElementById('go-new-best').style.display = isNew ? 'block' : 'none';

            document.getElementById('gameover-screen').style.display = 'flex';
            document.getElementById('hud').style.display = 'none';
        }

        togglePause() {
            if (this.state === 'playing') {
                this.state = 'paused';
                document.getElementById('pause-overlay').style.display = 'flex';
            } else if (this.state === 'paused') {
                this.state = 'playing';
                document.getElementById('pause-overlay').style.display = 'none';
            }
        }

        returnToMenu() {
            this.state = 'title';
            document.getElementById('title-screen').style.display = 'flex';
            document.getElementById('gameover-screen').style.display = 'none';
            document.getElementById('pause-overlay').style.display = 'none';
            document.getElementById('hud').style.display = 'none';
            document.getElementById('time-display').style.display = 'none';
            document.getElementById('tool-panel').style.display = 'none';
            document.getElementById('challenge-banner').style.display = 'none';
            this.renderHighScores();
        }

        // --- High Scores ---
        loadHighScores() {
            try {
                this.highScores = JSON.parse(localStorage.getItem('morningdew_scores')) || [];
            } catch(e) { this.highScores = []; }
        }

        saveHighScore(score) {
            this.highScores.push({ score, mode: this.mode, difficulty: this.difficulty, date: new Date().toISOString().slice(0,10) });
            this.highScores.sort((a, b) => b.score - a.score);
            this.highScores = this.highScores.slice(0, 10);
            localStorage.setItem('morningdew_scores', JSON.stringify(this.highScores));
            return this.highScores[0].score === score;
        }

        renderHighScores() {
            const el = document.getElementById('high-scores-list');
            if (this.highScores.length === 0) {
                el.innerHTML = '<div class="high-score-entry">No scores yet</div>';
                return;
            }
            el.innerHTML = this.highScores.slice(0, 5).map((s, i) =>
                '<div class="high-score-entry">' + (i + 1) + '. ' + s.score.toLocaleString() + ' (' + s.mode + '/' + s.difficulty + ')</div>'
            ).join('');
        }

        // --- Menu Setup ---
        setupMenuButtons() {
            // Difficulty
            document.querySelectorAll('.diff-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    this.difficulty = btn.dataset.diff;
                });
            });

            // Mode buttons
            document.getElementById('btn-freeweave').addEventListener('click', () => this.startGame('freeweave'));
            document.getElementById('btn-challenge').addEventListener('click', () => this.startGame('challenge'));
            document.getElementById('btn-timed').addEventListener('click', () => this.startGame('timed'));

            // Pause buttons
            document.getElementById('btn-resume').addEventListener('click', () => this.togglePause());
            document.getElementById('btn-quit').addEventListener('click', () => this.returnToMenu());

            // Game over buttons
            document.getElementById('btn-restart').addEventListener('click', () => this.startGame(this.mode));
            document.getElementById('btn-menu').addEventListener('click', () => this.returnToMenu());

            // Tool buttons
            document.querySelectorAll('#tool-panel .tool-btn[data-tool]').forEach(btn => {
                btn.addEventListener('click', () => {
                    this.tool = btn.dataset.tool;
                    this.updateToolButtons();
                });
            });

            document.getElementById('brush-size').addEventListener('input', e => {
                this.brushSize = parseInt(e.target.value);
            });
            document.getElementById('dew-intensity').addEventListener('input', e => {
                this.dewIntensity = parseInt(e.target.value);
            });
            document.getElementById('btn-sunrise').addEventListener('click', () => this.beginSunrise());
            document.getElementById('btn-clear').addEventListener('click', () => {
                this.strands = [];
                this.timeOfDay = 0;
                this.sunrising = false;
                this.updateTimeDisplay();
            });
        }

        // --- Main Loop ---
        loop(timestamp) {
            const dt = Math.min(0.05, (timestamp - this.lastTime) / 1000);
            this.lastTime = timestamp;

            this.update(dt);

            // Render
            this.ctx.save();
            if (this.shakeIntensity > 0) {
                this.ctx.translate(this.shakeX, this.shakeY);
            }

            if (this.state === 'playing' || this.state === 'paused' || this.state === 'gameover') {
                this.drawSky();
                this.drawStrands();
                this.drawParticles();
                this.drawFloatingTexts();
            } else {
                // Title screen background
                this.ctx.fillStyle = '#020510';
                this.ctx.fillRect(0, 0, this.W, this.H);
                // Animated web preview
                const t = timestamp * 0.001;
                this.ctx.strokeStyle = 'rgba(100,160,220,0.08)';
                this.ctx.lineWidth = 0.5;
                for (let i = 0; i < 12; i++) {
                    const cx = this.W * 0.5 + Math.cos(t * 0.3 + i) * 100;
                    const cy = this.H * 0.5 + Math.sin(t * 0.2 + i) * 80;
                    this.ctx.beginPath();
                    for (let j = 0; j < 8; j++) {
                        const a = (j / 8) * Math.PI * 2;
                        const r = 50 + Math.sin(t + i * 0.5 + j) * 30;
                        const ex = cx + Math.cos(a) * r;
                        const ey = cy + Math.sin(a) * r;
                        this.ctx.moveTo(cx, cy);
                        this.ctx.lineTo(ex, ey);
                    }
                    this.ctx.stroke();
                }
            }

            this.ctx.restore();

            requestAnimationFrame(t => this.loop(t));
        }
    }

    // Start the game
    const game = new MorningDewGame();
    </script>
</body>
</html>