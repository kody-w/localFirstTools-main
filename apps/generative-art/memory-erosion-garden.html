<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memory Erosion Garden</title>
    <meta name="description" content="Plant memories that slowly erode over time, their fragments fertilizing new procedural growth - a meditation on impermanence">
    <!-- experimental, generative, art, meditation, memory, time, contemplative -->
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: linear-gradient(to bottom, #1a1510 0%, #0d0a08 100%);
            min-height: 100vh;
            font-family: Georgia, 'Times New Roman', serif;
            color: #d4c4a8;
            overflow: hidden;
        }
        
        #garden {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        #add-memory {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
        }
        
        #add-memory button {
            padding: 15px 40px;
            background: rgba(180, 150, 100, 0.2);
            border: 1px solid rgba(180, 150, 100, 0.4);
            color: #d4c4a8;
            font-family: inherit;
            font-size: 16px;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }
        
        #add-memory button:hover {
            background: rgba(180, 150, 100, 0.3);
        }
        
        #memory-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        
        #memory-modal.active {
            display: flex;
        }
        
        .modal-content {
            background: linear-gradient(135deg, #2a2015 0%, #1a1510 100%);
            padding: 40px;
            border-radius: 20px;
            max-width: 500px;
            width: 90%;
            border: 1px solid rgba(180, 150, 100, 0.3);
        }
        
        .modal-content h2 {
            margin-bottom: 20px;
            font-weight: normal;
            font-size: 24px;
        }
        
        .modal-content textarea {
            width: 100%;
            height: 150px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(180, 150, 100, 0.3);
            border-radius: 10px;
            padding: 15px;
            color: #d4c4a8;
            font-family: inherit;
            font-size: 16px;
            resize: none;
            margin-bottom: 20px;
        }
        
        .modal-content textarea::placeholder {
            color: rgba(180, 150, 100, 0.5);
        }
        
        .modal-buttons {
            display: flex;
            gap: 15px;
            justify-content: flex-end;
        }
        
        .modal-buttons button {
            padding: 12px 30px;
            border-radius: 20px;
            font-family: inherit;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .btn-plant {
            background: rgba(100, 150, 80, 0.3);
            border: 1px solid rgba(100, 150, 80, 0.5);
            color: #a8d4a0;
        }
        
        .btn-cancel {
            background: transparent;
            border: 1px solid rgba(180, 150, 100, 0.3);
            color: #d4c4a8;
        }
        
        #info {
            position: fixed;
            top: 20px;
            left: 20px;
            font-size: 12px;
            opacity: 0.5;
            z-index: 100;
            max-width: 250px;
            line-height: 1.6;
        }
        
        #controls {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }
        
        .control-btn {
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(180, 150, 100, 0.3);
            color: #d4c4a8;
            border-radius: 20px;
            font-family: inherit;
            font-size: 12px;
            cursor: pointer;
            backdrop-filter: blur(5px);
        }
        
        #time-display {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            opacity: 0.4;
            z-index: 100;
        }
        
        #stats {
            position: fixed;
            bottom: 20px;
            right: 20px;
            font-size: 11px;
            opacity: 0.5;
            text-align: right;
            z-index: 100;
        }
    </style>
</head>
<body>
    <canvas id="garden"></canvas>
    
    <div id="info">
        Click anywhere to read a memory.<br>
        Watch as they slowly erode,<br>
        their fragments becoming<br>
        new growth in the garden.
    </div>
    
    <div id="controls">
        <button class="control-btn" id="preserve-btn">Preserve Mode</button>
        <button class="control-btn" id="export-btn">Export</button>
        <button class="control-btn" id="import-btn">Import</button>
    </div>
    
    <div id="time-display">Garden Age: 0 days</div>
    
    <div id="stats">
        <div>Memories: <span id="memory-count">0</span></div>
        <div>Flora: <span id="flora-count">0</span></div>
    </div>
    
    <div id="add-memory">
        <button id="plant-btn">Plant a Memory</button>
    </div>
    
    <div id="memory-modal">
        <div class="modal-content">
            <h2>Plant a Memory</h2>
            <textarea id="memory-text" placeholder="Write your memory here... it will slowly fade over time, its essence nourishing new growth."></textarea>
            <div class="modal-buttons">
                <button class="btn-cancel" id="cancel-btn">Cancel</button>
                <button class="btn-plant" id="confirm-plant">Plant</button>
            </div>
        </div>
    </div>
    
    <input type="file" id="import-file" accept=".json" style="display: none;">
    
    <script>
        const canvas = document.getElementById('garden');
        const ctx = canvas.getContext('2d');
        
        let width, height;
        let memories = [];
        let flora = [];
        let particles = [];
        let gardenAge = 0;
        let preserveMode = false;
        let selectedMemory = null;
        
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }
        resize();
        window.addEventListener('resize', resize);
        
        // Memory class
        class Memory {
            constructor(text, x, y) {
                this.text = text;
                this.originalText = text;
                this.x = x;
                this.y = y;
                this.opacity = 1;
                this.erosion = 0;
                this.createdAt = Date.now();
                this.preserved = false;
                this.fontSize = 14 + Math.random() * 8;
                this.rotation = (Math.random() - 0.5) * 0.2;
                this.color = {
                    r: 180 + Math.random() * 40,
                    g: 140 + Math.random() * 40,
                    b: 80 + Math.random() * 40
                };
            }
            
            update(dt) {
                if (this.preserved || preserveMode) return;
                
                // Erosion rate increases with age
                const ageSeconds = (Date.now() - this.createdAt) / 1000;
                const erosionRate = 0.0001 + ageSeconds * 0.00001;
                this.erosion += erosionRate * dt;
                
                // Fade opacity
                this.opacity = Math.max(0, 1 - this.erosion);
                
                // Gradually lose letters
                if (this.erosion > 0.1 && Math.random() < 0.01 * dt) {
                    this.erodeLetter();
                }
                
                // Spawn flora particles from erosion
                if (this.erosion > 0.2 && Math.random() < 0.02 * dt) {
                    this.spawnFlora();
                }
                
                // Emit decay particles
                if (Math.random() < 0.1 * this.erosion * dt) {
                    particles.push(new Particle(
                        this.x + (Math.random() - 0.5) * 100,
                        this.y + (Math.random() - 0.5) * 30,
                        this.color
                    ));
                }
            }
            
            erodeLetter() {
                if (this.text.length <= 1) return;
                
                // Replace random letter with space or remove it
                const idx = Math.floor(Math.random() * this.text.length);
                const chars = this.text.split('');
                
                if (Math.random() < 0.5) {
                    chars[idx] = ' ';
                } else {
                    chars.splice(idx, 1);
                }
                
                this.text = chars.join('');
            }
            
            spawnFlora() {
                flora.push(new Flora(
                    this.x + (Math.random() - 0.5) * 150,
                    this.y + Math.random() * 50,
                    this.color
                ));
            }
            
            draw(ctx) {
                if (this.opacity <= 0) return;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                ctx.font = `${this.fontSize}px Georgia, serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Glow effect for preserved memories
                if (this.preserved) {
                    ctx.shadowColor = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 0.5)`;
                    ctx.shadowBlur = 20;
                }
                
                // Draw with erosion effects
                const lines = this.wrapText(this.text, 200);
                lines.forEach((line, i) => {
                    const y = (i - lines.length / 2) * (this.fontSize * 1.4);
                    
                    // Each character might have slightly different opacity
                    let x = -ctx.measureText(line).width / 2;
                    for (let char of line) {
                        const charOpacity = this.opacity * (0.7 + Math.random() * 0.3);
                        ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${charOpacity})`;
                        ctx.fillText(char, x, y);
                        x += ctx.measureText(char).width;
                    }
                });
                
                ctx.restore();
            }
            
            wrapText(text, maxWidth) {
                const words = text.split(' ');
                const lines = [];
                let currentLine = '';
                
                words.forEach(word => {
                    const testLine = currentLine + (currentLine ? ' ' : '') + word;
                    if (ctx.measureText(testLine).width > maxWidth && currentLine) {
                        lines.push(currentLine);
                        currentLine = word;
                    } else {
                        currentLine = testLine;
                    }
                });
                if (currentLine) lines.push(currentLine);
                return lines;
            }
            
            isNearPoint(px, py) {
                return Math.abs(px - this.x) < 100 && Math.abs(py - this.y) < 50;
            }
        }
        
        // Flora class - grows from memory decay
        class Flora {
            constructor(x, y, parentColor) {
                this.x = x;
                this.y = y;
                this.height = 0;
                this.maxHeight = 20 + Math.random() * 60;
                this.growthRate = 0.02 + Math.random() * 0.03;
                this.sway = Math.random() * Math.PI * 2;
                this.swaySpeed = 0.01 + Math.random() * 0.02;
                this.branches = Math.floor(Math.random() * 4) + 1;
                this.color = {
                    r: Math.floor(parentColor.r * 0.5 + 50),
                    g: Math.floor(parentColor.g * 0.8 + 80),
                    b: Math.floor(parentColor.b * 0.3 + 30)
                };
                this.hasFlower = Math.random() < 0.3;
                this.flowerColor = {
                    r: 200 + Math.random() * 55,
                    g: 100 + Math.random() * 100,
                    b: 100 + Math.random() * 100
                };
            }
            
            update(dt) {
                if (this.height < this.maxHeight) {
                    this.height += this.growthRate * dt;
                }
                this.sway += this.swaySpeed * dt;
            }
            
            draw(ctx) {
                const swayOffset = Math.sin(this.sway) * (this.height * 0.1);
                
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Draw stem
                ctx.strokeStyle = `rgb(${this.color.r}, ${this.color.g}, ${this.color.b})`;
                ctx.lineWidth = 1 + this.height / 30;
                ctx.lineCap = 'round';
                
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.quadraticCurveTo(
                    swayOffset * 0.5, -this.height * 0.5,
                    swayOffset, -this.height
                );
                ctx.stroke();
                
                // Draw branches/leaves
                for (let i = 0; i < this.branches; i++) {
                    const branchY = -this.height * (0.3 + i * 0.2);
                    const branchDir = i % 2 === 0 ? 1 : -1;
                    const branchLen = 5 + Math.random() * 10;
                    
                    const branchSwayOffset = swayOffset * (branchY / -this.height);
                    
                    ctx.beginPath();
                    ctx.moveTo(branchSwayOffset * (branchY / -this.height), branchY);
                    ctx.lineTo(
                        branchSwayOffset * (branchY / -this.height) + branchDir * branchLen,
                        branchY - branchLen * 0.5
                    );
                    ctx.stroke();
                }
                
                // Draw flower if mature
                if (this.hasFlower && this.height > this.maxHeight * 0.8) {
                    ctx.fillStyle = `rgb(${this.flowerColor.r}, ${this.flowerColor.g}, ${this.flowerColor.b})`;
                    ctx.beginPath();
                    ctx.arc(swayOffset, -this.height, 3 + this.height / 20, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }
        
        // Particle class
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = -Math.random() * 0.5 - 0.2;
                this.life = 1;
                this.decay = 0.005 + Math.random() * 0.01;
                this.size = 1 + Math.random() * 2;
                this.color = color;
            }
            
            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.vy -= 0.01 * dt; // Float upward
                this.life -= this.decay * dt;
                return this.life > 0;
            }
            
            draw(ctx) {
                ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.life * 0.5})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * this.life, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Main animation
        let lastTime = Date.now();
        
        function animate() {
            const now = Date.now();
            const dt = Math.min(100, now - lastTime) / 16;
            lastTime = now;
            
            // Accelerated garden time (1 real second = 1 garden minute)
            gardenAge += dt / 60 / 24; // Days
            
            // Clear
            ctx.fillStyle = 'rgba(13, 10, 8, 0.1)';
            ctx.fillRect(0, 0, width, height);
            
            // Update and draw flora (behind memories)
            flora = flora.filter(f => f.height < f.maxHeight * 1.5);
            flora.forEach(f => {
                f.update(dt);
                f.draw(ctx);
            });
            
            // Update and draw memories
            memories = memories.filter(m => m.opacity > 0 || m.text.length > 0);
            memories.forEach(m => {
                m.update(dt);
                m.draw(ctx);
            });
            
            // Update and draw particles
            particles = particles.filter(p => p.update(dt));
            particles.forEach(p => p.draw(ctx));
            
            // Update UI
            document.getElementById('time-display').textContent = 
                `Garden Age: ${Math.floor(gardenAge)} days`;
            document.getElementById('memory-count').textContent = memories.length;
            document.getElementById('flora-count').textContent = flora.length;
            
            requestAnimationFrame(animate);
        }
        
        // Event listeners
        document.getElementById('plant-btn').addEventListener('click', () => {
            document.getElementById('memory-modal').classList.add('active');
            document.getElementById('memory-text').focus();
        });
        
        document.getElementById('cancel-btn').addEventListener('click', () => {
            document.getElementById('memory-modal').classList.remove('active');
            document.getElementById('memory-text').value = '';
        });
        
        document.getElementById('confirm-plant').addEventListener('click', () => {
            const text = document.getElementById('memory-text').value.trim();
            if (text) {
                const x = 100 + Math.random() * (width - 200);
                const y = 100 + Math.random() * (height - 200);
                memories.push(new Memory(text, x, y));
                saveGarden();
            }
            document.getElementById('memory-modal').classList.remove('active');
            document.getElementById('memory-text').value = '';
        });
        
        document.getElementById('preserve-btn').addEventListener('click', () => {
            preserveMode = !preserveMode;
            document.getElementById('preserve-btn').textContent = 
                preserveMode ? 'Resume Erosion' : 'Preserve Mode';
            document.getElementById('preserve-btn').style.background = 
                preserveMode ? 'rgba(100, 150, 80, 0.3)' : 'rgba(0, 0, 0, 0.4)';
        });
        
        // Click to preserve individual memory
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            memories.forEach(m => {
                if (m.isNearPoint(x, y)) {
                    m.preserved = !m.preserved;
                    
                    // Visual feedback
                    for (let i = 0; i < 10; i++) {
                        particles.push(new Particle(m.x + (Math.random() - 0.5) * 50, m.y, m.color));
                    }
                }
            });
        });
        
        // Export/Import
        document.getElementById('export-btn').addEventListener('click', () => {
            const data = {
                memories: memories.map(m => ({
                    text: m.text,
                    originalText: m.originalText,
                    x: m.x,
                    y: m.y,
                    erosion: m.erosion,
                    preserved: m.preserved,
                    createdAt: m.createdAt
                })),
                flora: flora.map(f => ({
                    x: f.x,
                    y: f.y,
                    height: f.height,
                    maxHeight: f.maxHeight
                })),
                gardenAge: gardenAge
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'memory-garden.json';
            a.click();
            URL.revokeObjectURL(url);
        });
        
        document.getElementById('import-btn').addEventListener('click', () => {
            document.getElementById('import-file').click();
        });
        
        document.getElementById('import-file').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        loadGardenData(data);
                    } catch (err) {
                        alert('Invalid file');
                    }
                };
                reader.readAsText(file);
            }
        });
        
        function loadGardenData(data) {
            memories = data.memories.map(m => {
                const mem = new Memory(m.text, m.x, m.y);
                mem.originalText = m.originalText;
                mem.erosion = m.erosion;
                mem.preserved = m.preserved;
                mem.createdAt = m.createdAt;
                mem.opacity = Math.max(0, 1 - m.erosion);
                return mem;
            });
            
            flora = data.flora.map(f => {
                const fl = new Flora(f.x, f.y, { r: 150, g: 150, b: 100 });
                fl.height = f.height;
                fl.maxHeight = f.maxHeight;
                return fl;
            });
            
            gardenAge = data.gardenAge || 0;
        }
        
        function saveGarden() {
            const data = {
                memories: memories.map(m => ({
                    text: m.text,
                    originalText: m.originalText,
                    x: m.x,
                    y: m.y,
                    erosion: m.erosion,
                    preserved: m.preserved,
                    createdAt: m.createdAt
                })),
                flora: flora.slice(0, 100).map(f => ({
                    x: f.x,
                    y: f.y,
                    height: f.height,
                    maxHeight: f.maxHeight
                })),
                gardenAge: gardenAge
            };
            localStorage.setItem('memoryErosionGarden', JSON.stringify(data));
        }
        
        // Load saved garden
        const saved = localStorage.getItem('memoryErosionGarden');
        if (saved) {
            try {
                loadGardenData(JSON.parse(saved));
            } catch (e) {}
        }
        
        // Auto-save
        setInterval(saveGarden, 10000);
        
        // Start
        animate();
    </script>
</body>
</html>
