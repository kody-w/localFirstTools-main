<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fractal Explorer - GPU Accelerated</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        #canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .controls-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(20, 20, 30, 0.95);
            border-radius: 12px;
            padding: 20px;
            max-width: 320px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.3) transparent;
        }

        .controls-overlay::-webkit-scrollbar {
            width: 6px;
        }

        .controls-overlay::-webkit-scrollbar-track {
            background: transparent;
        }

        .controls-overlay::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }

        h1 {
            font-size: 20px;
            margin-bottom: 16px;
            color: #60a5fa;
            font-weight: 600;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            font-size: 13px;
            margin-bottom: 8px;
            color: #a0a0b0;
            font-weight: 500;
        }

        select, input[type="range"], input[type="color"] {
            width: 100%;
            padding: 8px;
            background: rgba(40, 40, 50, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 6px;
            color: #e0e0e0;
            font-size: 13px;
            cursor: pointer;
        }

        select:focus, input:focus {
            outline: none;
            border-color: #60a5fa;
        }

        input[type="range"] {
            padding: 0;
            height: 32px;
        }

        .value-display {
            font-size: 12px;
            color: #60a5fa;
            margin-top: 4px;
            font-weight: 600;
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 12px;
        }

        button {
            padding: 10px 16px;
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            border: none;
            border-radius: 6px;
            color: white;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
        }

        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background: linear-gradient(135deg, #6b7280, #4b5563);
            box-shadow: 0 2px 8px rgba(107, 114, 128, 0.3);
        }

        button.secondary:hover {
            box-shadow: 0 4px 12px rgba(107, 114, 128, 0.4);
        }

        .info-display {
            background: rgba(40, 40, 50, 0.6);
            padding: 12px;
            border-radius: 6px;
            font-size: 12px;
            line-height: 1.6;
            font-family: 'Courier New', monospace;
        }

        .info-display div {
            margin-bottom: 4px;
        }

        .info-display strong {
            color: #60a5fa;
        }

        .minimap {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            background: rgba(20, 20, 30, 0.95);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
            overflow: hidden;
        }

        #minimapCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .julia-preview {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 250px;
            height: 250px;
            background: rgba(20, 20, 30, 0.95);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
            display: none;
            overflow: hidden;
        }

        .julia-preview.active {
            display: block;
        }

        #juliaPreviewCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .bookmarks {
            max-height: 200px;
            overflow-y: auto;
        }

        .bookmark-item {
            background: rgba(40, 40, 50, 0.6);
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 6px;
            font-size: 11px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: background 0.2s;
        }

        .bookmark-item:hover {
            background: rgba(60, 60, 70, 0.8);
        }

        .bookmark-item .name {
            flex: 1;
            color: #e0e0e0;
        }

        .bookmark-item .delete {
            background: rgba(239, 68, 68, 0.8);
            border: none;
            border-radius: 3px;
            color: white;
            padding: 4px 8px;
            font-size: 10px;
            cursor: pointer;
            margin-left: 8px;
        }

        .custom-colors {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-top: 8px;
        }

        .custom-colors input[type="color"] {
            height: 40px;
            padding: 2px;
        }

        .help-text {
            font-size: 11px;
            color: #808090;
            margin-top: 4px;
            line-height: 1.4;
        }

        .toggle-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(59, 130, 246, 0.9);
            border: none;
            border-radius: 8px;
            color: white;
            padding: 10px 16px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
            display: none;
            z-index: 1000;
        }

        .controls-overlay.hidden {
            display: none;
        }

        .controls-overlay.hidden ~ .toggle-controls {
            display: block;
        }

        @media (max-width: 768px) {
            .controls-overlay {
                max-width: calc(100vw - 40px);
            }

            .minimap {
                width: 120px;
                height: 120px;
                bottom: 10px;
                right: 10px;
            }

            .julia-preview {
                width: 150px;
                height: 150px;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <button class="toggle-controls">Show Controls</button>

    <div class="controls-overlay">
        <h1>Fractal Explorer</h1>

        <div class="control-group">
            <label>Fractal Type</label>
            <select id="fractalType">
                <option value="mandelbrot">Mandelbrot Set</option>
                <option value="julia">Julia Set</option>
                <option value="burningship">Burning Ship</option>
                <option value="tricorn">Tricorn (Mandelbar)</option>
            </select>
        </div>

        <div class="control-group">
            <label>Color Palette</label>
            <select id="colorPalette">
                <option value="classic">Classic (Blue/Black)</option>
                <option value="fire">Fire (Red/Yellow)</option>
                <option value="ocean">Ocean (Blue/Cyan)</option>
                <option value="psychedelic">Psychedelic</option>
                <option value="monochrome">Monochrome</option>
                <option value="custom">Custom</option>
            </select>
            <div id="customColors" class="custom-colors" style="display: none;">
                <input type="color" id="color1" value="#000033">
                <input type="color" id="color2" value="#0066ff">
                <input type="color" id="color3" value="#ffffff">
            </div>
        </div>

        <div class="control-group">
            <label>Max Iterations: <span class="value-display" id="iterationsValue">200</span></label>
            <input type="range" id="iterations" min="50" max="5000" value="200" step="10">
        </div>

        <div class="control-group">
            <label>
                <input type="checkbox" id="autoZoom"> Auto-Zoom Mode
            </label>
            <div class="help-text">Automatically zooms into interesting regions</div>
        </div>

        <div class="button-group">
            <button id="resetBtn">Reset View</button>
            <button id="screenshotBtn" class="secondary">Screenshot</button>
            <button id="bookmarkBtn">Bookmark</button>
            <button id="toggleMinimapBtn" class="secondary">Toggle Map</button>
            <button id="toggleControlsBtn" class="secondary">Hide Panel</button>
        </div>

        <div class="control-group">
            <label>Info</label>
            <div class="info-display">
                <div><strong>Center:</strong> <span id="centerDisplay">(-0.5, 0)</span></div>
                <div><strong>Zoom:</strong> <span id="zoomDisplay">1.0x</span></div>
                <div><strong>Mouse:</strong> <span id="mouseDisplay">-</span></div>
                <div><strong>FPS:</strong> <span id="fpsDisplay">60</span></div>
            </div>
        </div>

        <div class="control-group">
            <label>Bookmarks <span class="help-text">(Click to load)</span></label>
            <div id="bookmarksList" class="bookmarks"></div>
        </div>

        <div class="help-text" style="margin-top: 20px;">
            <strong>Controls:</strong><br>
            • Scroll to zoom<br>
            • Click+drag to pan<br>
            • Double-click to center<br>
            • Julia mode: move mouse over Mandelbrot
        </div>
    </div>

    <div class="minimap">
        <canvas id="minimapCanvas"></canvas>
    </div>

    <div class="julia-preview" id="juliaPreview">
        <canvas id="juliaPreviewCanvas"></canvas>
    </div>

    <script>
        // WebGL Fractal Renderer
        class FractalRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.gl = canvas.getContext('webgl2', {
                    alpha: false,
                    antialias: false,
                    depth: false,
                    preserveDrawingBuffer: true,
                    powerPreference: 'high-performance'
                });

                if (!this.gl) {
                    alert('WebGL2 not supported');
                    return;
                }

                this.setupGL();
                this.resizeCanvas();

                // Fractal state
                this.centerX = -0.5;
                this.centerY = 0.0;
                this.zoom = 1.0;
                this.maxIterations = 200;
                this.fractalType = 'mandelbrot';
                this.colorPalette = 'classic';
                this.juliaC = { x: -0.7, y: 0.27 };
                this.customColors = [
                    { r: 0, g: 0, b: 0.2 },
                    { r: 0, g: 0.4, b: 1 },
                    { r: 1, g: 1, b: 1 }
                ];

                // Animation
                this.autoZoom = false;
                this.autoZoomTarget = { x: -0.5, y: 0 };
                this.autoZoomProgress = 0;

                // Input state
                this.isDragging = false;
                this.lastMouseX = 0;
                this.lastMouseY = 0;
                this.mouseWorldX = 0;
                this.mouseWorldY = 0;

                // Performance
                this.lastFrameTime = performance.now();
                this.frameCount = 0;
                this.fps = 60;

                this.setupInputHandlers();
            }

            setupGL() {
                const gl = this.gl;

                // Vertex shader
                const vertexShaderSource = `#version 300 es
                    in vec2 a_position;
                    void main() {
                        gl_Position = vec4(a_position, 0.0, 1.0);
                    }
                `;

                // Fragment shader
                const fragmentShaderSource = `#version 300 es
                    precision highp float;

                    uniform vec2 u_resolution;
                    uniform vec2 u_center;
                    uniform float u_zoom;
                    uniform int u_maxIterations;
                    uniform int u_fractalType;
                    uniform int u_colorPalette;
                    uniform vec2 u_juliaC;
                    uniform vec3 u_customColor1;
                    uniform vec3 u_customColor2;
                    uniform vec3 u_customColor3;

                    out vec4 fragColor;

                    vec3 palette(float t, int paletteType) {
                        if (paletteType == 0) { // classic
                            return vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5) * cos(6.28318 * (vec3(1.0, 1.0, 1.0) * t + vec3(0.0, 0.1, 0.2)));
                        } else if (paletteType == 1) { // fire
                            return vec3(t, pow(t, 2.0), pow(t, 4.0));
                        } else if (paletteType == 2) { // ocean
                            return vec3(pow(t, 2.0), sqrt(t), t);
                        } else if (paletteType == 3) { // psychedelic
                            return vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5) * cos(6.28318 * (vec3(1.0, 0.5, 0.3) * t + vec3(0.0, 0.33, 0.67)));
                        } else if (paletteType == 4) { // monochrome
                            return vec3(t);
                        } else { // custom
                            if (t < 0.5) {
                                return mix(u_customColor1, u_customColor2, t * 2.0);
                            } else {
                                return mix(u_customColor2, u_customColor3, (t - 0.5) * 2.0);
                            }
                        }
                    }

                    vec2 complexSquare(vec2 z) {
                        return vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y);
                    }

                    vec2 complexCube(vec2 z) {
                        float x2 = z.x * z.x;
                        float y2 = z.y * z.y;
                        return vec2(z.x * (x2 - 3.0 * y2), z.y * (3.0 * x2 - y2));
                    }

                    float mandelbrot(vec2 c) {
                        vec2 z = vec2(0.0);
                        float iter = 0.0;

                        for (int i = 0; i < 5000; i++) {
                            if (i >= u_maxIterations) break;
                            if (dot(z, z) > 4.0) break;

                            z = complexSquare(z) + c;
                            iter += 1.0;
                        }

                        if (iter < float(u_maxIterations)) {
                            float log_zn = log(dot(z, z)) / 2.0;
                            float nu = log(log_zn / log(2.0)) / log(2.0);
                            iter = iter + 1.0 - nu;
                        }

                        return iter;
                    }

                    float julia(vec2 z) {
                        float iter = 0.0;

                        for (int i = 0; i < 5000; i++) {
                            if (i >= u_maxIterations) break;
                            if (dot(z, z) > 4.0) break;

                            z = complexSquare(z) + u_juliaC;
                            iter += 1.0;
                        }

                        if (iter < float(u_maxIterations)) {
                            float log_zn = log(dot(z, z)) / 2.0;
                            float nu = log(log_zn / log(2.0)) / log(2.0);
                            iter = iter + 1.0 - nu;
                        }

                        return iter;
                    }

                    float burningShip(vec2 c) {
                        vec2 z = vec2(0.0);
                        float iter = 0.0;

                        for (int i = 0; i < 5000; i++) {
                            if (i >= u_maxIterations) break;
                            if (dot(z, z) > 4.0) break;

                            z = vec2(abs(z.x), abs(z.y));
                            z = complexSquare(z) + c;
                            iter += 1.0;
                        }

                        return iter;
                    }

                    float tricorn(vec2 c) {
                        vec2 z = vec2(0.0);
                        float iter = 0.0;

                        for (int i = 0; i < 5000; i++) {
                            if (i >= u_maxIterations) break;
                            if (dot(z, z) > 4.0) break;

                            z = vec2(z.x * z.x - z.y * z.y, -2.0 * z.x * z.y) + c;
                            iter += 1.0;
                        }

                        return iter;
                    }

                    void main() {
                        vec2 uv = (gl_FragCoord.xy - u_resolution * 0.5) / min(u_resolution.x, u_resolution.y);
                        uv = uv * 4.0 / u_zoom + u_center;

                        float iter;
                        if (u_fractalType == 0) {
                            iter = mandelbrot(uv);
                        } else if (u_fractalType == 1) {
                            iter = julia(uv);
                        } else if (u_fractalType == 2) {
                            iter = burningShip(uv);
                        } else {
                            iter = tricorn(uv);
                        }

                        vec3 color;
                        if (iter >= float(u_maxIterations)) {
                            color = vec3(0.0);
                        } else {
                            float t = iter / float(u_maxIterations);
                            color = palette(t, u_colorPalette);
                        }

                        fragColor = vec4(color, 1.0);
                    }
                `;

                // Compile shaders
                const vertexShader = this.compileShader(gl.VERTEX_SHADER, vertexShaderSource);
                const fragmentShader = this.compileShader(gl.FRAGMENT_SHADER, fragmentShaderSource);

                // Create program
                this.program = gl.createProgram();
                gl.attachShader(this.program, vertexShader);
                gl.attachShader(this.program, fragmentShader);
                gl.linkProgram(this.program);

                if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
                    console.error('Program link failed:', gl.getProgramInfoLog(this.program));
                    return;
                }

                // Get uniform locations
                this.uniforms = {
                    resolution: gl.getUniformLocation(this.program, 'u_resolution'),
                    center: gl.getUniformLocation(this.program, 'u_center'),
                    zoom: gl.getUniformLocation(this.program, 'u_zoom'),
                    maxIterations: gl.getUniformLocation(this.program, 'u_maxIterations'),
                    fractalType: gl.getUniformLocation(this.program, 'u_fractalType'),
                    colorPalette: gl.getUniformLocation(this.program, 'u_colorPalette'),
                    juliaC: gl.getUniformLocation(this.program, 'u_juliaC'),
                    customColor1: gl.getUniformLocation(this.program, 'u_customColor1'),
                    customColor2: gl.getUniformLocation(this.program, 'u_customColor2'),
                    customColor3: gl.getUniformLocation(this.program, 'u_customColor3')
                };

                // Create fullscreen quad
                const positions = new Float32Array([
                    -1, -1,
                     1, -1,
                    -1,  1,
                     1,  1
                ]);

                const positionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

                const positionLocation = gl.getAttribLocation(this.program, 'a_position');
                gl.enableVertexAttribArray(positionLocation);
                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
            }

            compileShader(type, source) {
                const gl = this.gl;
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('Shader compile failed:', gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }

                return shader;
            }

            resizeCanvas() {
                const dpr = window.devicePixelRatio || 1;
                const displayWidth = Math.floor(this.canvas.clientWidth * dpr);
                const displayHeight = Math.floor(this.canvas.clientHeight * dpr);

                if (this.canvas.width !== displayWidth || this.canvas.height !== displayHeight) {
                    this.canvas.width = displayWidth;
                    this.canvas.height = displayHeight;
                    this.gl.viewport(0, 0, displayWidth, displayHeight);
                }
            }

            render() {
                const gl = this.gl;

                gl.useProgram(this.program);

                // Set uniforms
                gl.uniform2f(this.uniforms.resolution, this.canvas.width, this.canvas.height);
                gl.uniform2f(this.uniforms.center, this.centerX, this.centerY);
                gl.uniform1f(this.uniforms.zoom, this.zoom);
                gl.uniform1i(this.uniforms.maxIterations, this.maxIterations);

                const fractalTypeMap = { mandelbrot: 0, julia: 1, burningship: 2, tricorn: 3 };
                gl.uniform1i(this.uniforms.fractalType, fractalTypeMap[this.fractalType]);

                const colorPaletteMap = { classic: 0, fire: 1, ocean: 2, psychedelic: 3, monochrome: 4, custom: 5 };
                gl.uniform1i(this.uniforms.colorPalette, colorPaletteMap[this.colorPalette]);

                gl.uniform2f(this.uniforms.juliaC, this.juliaC.x, this.juliaC.y);
                gl.uniform3f(this.uniforms.customColor1, this.customColors[0].r, this.customColors[0].g, this.customColors[0].b);
                gl.uniform3f(this.uniforms.customColor2, this.customColors[1].r, this.customColors[1].g, this.customColors[1].b);
                gl.uniform3f(this.uniforms.customColor3, this.customColors[2].r, this.customColors[2].g, this.customColors[2].b);

                // Draw
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                // Update FPS
                this.frameCount++;
                const now = performance.now();
                if (now - this.lastFrameTime >= 1000) {
                    this.fps = Math.round(this.frameCount * 1000 / (now - this.lastFrameTime));
                    this.frameCount = 0;
                    this.lastFrameTime = now;
                }
            }

            screenToWorld(screenX, screenY) {
                const dpr = window.devicePixelRatio || 1;
                const x = screenX * dpr;
                const y = screenY * dpr;

                const centerPixelX = this.canvas.width / 2;
                const centerPixelY = this.canvas.height / 2;

                const scale = 4.0 / this.zoom / Math.min(this.canvas.width, this.canvas.height);

                const worldX = this.centerX + (x - centerPixelX) * scale;
                const worldY = this.centerY - (y - centerPixelY) * scale;

                return { x: worldX, y: worldY };
            }

            setupInputHandlers() {
                // Mouse wheel zoom
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();

                    const mouseWorld = this.screenToWorld(e.clientX, e.clientY);

                    const zoomFactor = e.deltaY < 0 ? 1.2 : 1 / 1.2;
                    const newZoom = this.zoom * zoomFactor;

                    // Zoom towards mouse position
                    this.centerX = mouseWorld.x + (this.centerX - mouseWorld.x) / zoomFactor;
                    this.centerY = mouseWorld.y + (this.centerY - mouseWorld.y) / zoomFactor;
                    this.zoom = newZoom;

                    this.updateDisplay();
                }, { passive: false });

                // Mouse drag
                this.canvas.addEventListener('mousedown', (e) => {
                    this.isDragging = true;
                    this.lastMouseX = e.clientX;
                    this.lastMouseY = e.clientY;
                });

                window.addEventListener('mousemove', (e) => {
                    if (this.isDragging) {
                        const dpr = window.devicePixelRatio || 1;
                        const dx = (e.clientX - this.lastMouseX) * dpr;
                        const dy = (e.clientY - this.lastMouseY) * dpr;

                        const scale = 4.0 / this.zoom / Math.min(this.canvas.width, this.canvas.height);

                        this.centerX -= dx * scale;
                        this.centerY += dy * scale;

                        this.lastMouseX = e.clientX;
                        this.lastMouseY = e.clientY;

                        this.updateDisplay();
                    }

                    // Update mouse coordinates
                    const mouseWorld = this.screenToWorld(e.clientX, e.clientY);
                    this.mouseWorldX = mouseWorld.x;
                    this.mouseWorldY = mouseWorld.y;

                    // Update Julia preview if in Mandelbrot mode
                    if (this.fractalType === 'mandelbrot' && app.juliaPreviewEnabled) {
                        app.updateJuliaPreview(mouseWorld.x, mouseWorld.y);
                    }
                });

                window.addEventListener('mouseup', () => {
                    this.isDragging = false;
                });

                // Double-click to center
                this.canvas.addEventListener('dblclick', (e) => {
                    const mouseWorld = this.screenToWorld(e.clientX, e.clientY);
                    this.centerX = mouseWorld.x;
                    this.centerY = mouseWorld.y;
                    this.updateDisplay();
                });

                // Touch support
                let lastTouchDistance = 0;

                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (e.touches.length === 1) {
                        this.isDragging = true;
                        this.lastMouseX = e.touches[0].clientX;
                        this.lastMouseY = e.touches[0].clientY;
                    } else if (e.touches.length === 2) {
                        const dx = e.touches[1].clientX - e.touches[0].clientX;
                        const dy = e.touches[1].clientY - e.touches[0].clientY;
                        lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
                    }
                }, { passive: false });

                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (e.touches.length === 1 && this.isDragging) {
                        const dpr = window.devicePixelRatio || 1;
                        const dx = (e.touches[0].clientX - this.lastMouseX) * dpr;
                        const dy = (e.touches[0].clientY - this.lastMouseY) * dpr;

                        const scale = 4.0 / this.zoom / Math.min(this.canvas.width, this.canvas.height);

                        this.centerX -= dx * scale;
                        this.centerY += dy * scale;

                        this.lastMouseX = e.touches[0].clientX;
                        this.lastMouseY = e.touches[0].clientY;

                        this.updateDisplay();
                    } else if (e.touches.length === 2) {
                        const dx = e.touches[1].clientX - e.touches[0].clientX;
                        const dy = e.touches[1].clientY - e.touches[0].clientY;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (lastTouchDistance > 0) {
                            const zoomFactor = distance / lastTouchDistance;
                            this.zoom *= zoomFactor;
                            this.updateDisplay();
                        }

                        lastTouchDistance = distance;
                    }
                }, { passive: false });

                this.canvas.addEventListener('touchend', () => {
                    this.isDragging = false;
                    lastTouchDistance = 0;
                });
            }

            updateDisplay() {
                // This will be called by the app
            }

            reset() {
                if (this.fractalType === 'mandelbrot') {
                    this.centerX = -0.5;
                    this.centerY = 0.0;
                } else if (this.fractalType === 'julia') {
                    this.centerX = 0.0;
                    this.centerY = 0.0;
                } else if (this.fractalType === 'burningship') {
                    this.centerX = -0.5;
                    this.centerY = -0.5;
                } else if (this.fractalType === 'tricorn') {
                    this.centerX = 0.0;
                    this.centerY = 0.0;
                }
                this.zoom = 1.0;
                this.updateDisplay();
            }

            saveScreenshot() {
                const link = document.createElement('a');
                link.download = `fractal-${this.fractalType}-${Date.now()}.png`;
                link.href = this.canvas.toDataURL();
                link.click();
            }
        }

        // Minimap
        class Minimap {
            constructor(canvas, renderer) {
                this.canvas = canvas;
                this.renderer = renderer;
                this.gl = canvas.getContext('webgl2', { alpha: false, antialias: false });

                if (!this.gl) return;

                this.setupGL();
                this.visible = true;
            }

            setupGL() {
                // Reuse the same shaders as main renderer
                const gl = this.gl;

                const vertexShaderSource = `#version 300 es
                    in vec2 a_position;
                    void main() {
                        gl_Position = vec4(a_position, 0.0, 1.0);
                    }
                `;

                const fragmentShaderSource = `#version 300 es
                    precision mediump float;

                    uniform vec2 u_resolution;
                    uniform vec2 u_center;
                    uniform float u_zoom;
                    uniform int u_maxIterations;
                    uniform int u_fractalType;
                    uniform int u_colorPalette;
                    uniform vec2 u_juliaC;

                    out vec4 fragColor;

                    vec3 palette(float t, int paletteType) {
                        if (paletteType == 0) {
                            return vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5) * cos(6.28318 * (vec3(1.0, 1.0, 1.0) * t + vec3(0.0, 0.1, 0.2)));
                        } else if (paletteType == 1) {
                            return vec3(t, pow(t, 2.0), pow(t, 4.0));
                        } else if (paletteType == 2) {
                            return vec3(pow(t, 2.0), sqrt(t), t);
                        } else if (paletteType == 3) {
                            return vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5) * cos(6.28318 * (vec3(1.0, 0.5, 0.3) * t + vec3(0.0, 0.33, 0.67)));
                        } else {
                            return vec3(t);
                        }
                    }

                    vec2 complexSquare(vec2 z) {
                        return vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y);
                    }

                    float mandelbrot(vec2 c) {
                        vec2 z = vec2(0.0);
                        float iter = 0.0;

                        for (int i = 0; i < 200; i++) {
                            if (dot(z, z) > 4.0) break;
                            z = complexSquare(z) + c;
                            iter += 1.0;
                        }

                        return iter;
                    }

                    void main() {
                        vec2 uv = (gl_FragCoord.xy - u_resolution * 0.5) / min(u_resolution.x, u_resolution.y);
                        uv = uv * 4.0;

                        float iter = mandelbrot(uv);

                        vec3 color;
                        if (iter >= 200.0) {
                            color = vec3(0.0);
                        } else {
                            float t = iter / 200.0;
                            color = palette(t, u_colorPalette);
                        }

                        // Draw viewport rectangle
                        vec2 viewMin = (u_center - vec2(2.0 / u_zoom)) / 4.0 * min(u_resolution.x, u_resolution.y) + u_resolution * 0.5;
                        vec2 viewMax = (u_center + vec2(2.0 / u_zoom)) / 4.0 * min(u_resolution.x, u_resolution.y) + u_resolution * 0.5;

                        float border = 2.0;
                        if (gl_FragCoord.x > viewMin.x && gl_FragCoord.x < viewMax.x &&
                            gl_FragCoord.y > viewMin.y && gl_FragCoord.y < viewMax.y) {
                            if (gl_FragCoord.x < viewMin.x + border || gl_FragCoord.x > viewMax.x - border ||
                                gl_FragCoord.y < viewMin.y + border || gl_FragCoord.y > viewMax.y - border) {
                                color = vec3(1.0, 0.0, 0.0);
                            }
                        }

                        fragColor = vec4(color, 1.0);
                    }
                `;

                const vertexShader = this.compileShader(gl.VERTEX_SHADER, vertexShaderSource);
                const fragmentShader = this.compileShader(gl.FRAGMENT_SHADER, fragmentShaderSource);

                this.program = gl.createProgram();
                gl.attachShader(this.program, vertexShader);
                gl.attachShader(this.program, fragmentShader);
                gl.linkProgram(this.program);

                this.uniforms = {
                    resolution: gl.getUniformLocation(this.program, 'u_resolution'),
                    center: gl.getUniformLocation(this.program, 'u_center'),
                    zoom: gl.getUniformLocation(this.program, 'u_zoom'),
                    colorPalette: gl.getUniformLocation(this.program, 'u_colorPalette')
                };

                const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
                const positionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

                const positionLocation = gl.getAttribLocation(this.program, 'a_position');
                gl.enableVertexAttribArray(positionLocation);
                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

                this.canvas.width = 200 * (window.devicePixelRatio || 1);
                this.canvas.height = 200 * (window.devicePixelRatio || 1);
            }

            compileShader(type, source) {
                const gl = this.gl;
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                return shader;
            }

            render() {
                if (!this.visible || !this.gl) return;

                const gl = this.gl;
                gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                gl.useProgram(this.program);

                gl.uniform2f(this.uniforms.resolution, this.canvas.width, this.canvas.height);
                gl.uniform2f(this.uniforms.center, this.renderer.centerX, this.renderer.centerY);
                gl.uniform1f(this.uniforms.zoom, this.renderer.zoom);

                const colorPaletteMap = { classic: 0, fire: 1, ocean: 2, psychedelic: 3, monochrome: 4, custom: 4 };
                gl.uniform1i(this.uniforms.colorPalette, colorPaletteMap[this.renderer.colorPalette]);

                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            }

            toggle() {
                this.visible = !this.visible;
                this.canvas.parentElement.style.display = this.visible ? 'block' : 'none';
            }
        }

        // Julia Preview
        class JuliaPreview {
            constructor(canvas, renderer) {
                this.canvas = canvas;
                this.renderer = renderer;
                this.gl = canvas.getContext('webgl2', { alpha: false, antialias: false });

                if (!this.gl) return;

                this.setupGL();
                this.juliaC = { x: -0.7, y: 0.27 };

                this.canvas.width = 250 * (window.devicePixelRatio || 1);
                this.canvas.height = 250 * (window.devicePixelRatio || 1);
            }

            setupGL() {
                const gl = this.gl;

                const vertexShaderSource = `#version 300 es
                    in vec2 a_position;
                    void main() {
                        gl_Position = vec4(a_position, 0.0, 1.0);
                    }
                `;

                const fragmentShaderSource = `#version 300 es
                    precision mediump float;

                    uniform vec2 u_resolution;
                    uniform vec2 u_juliaC;
                    uniform int u_colorPalette;

                    out vec4 fragColor;

                    vec3 palette(float t, int paletteType) {
                        if (paletteType == 0) {
                            return vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5) * cos(6.28318 * (vec3(1.0, 1.0, 1.0) * t + vec3(0.0, 0.1, 0.2)));
                        } else if (paletteType == 1) {
                            return vec3(t, pow(t, 2.0), pow(t, 4.0));
                        } else if (paletteType == 2) {
                            return vec3(pow(t, 2.0), sqrt(t), t);
                        } else if (paletteType == 3) {
                            return vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5) * cos(6.28318 * (vec3(1.0, 0.5, 0.3) * t + vec3(0.0, 0.33, 0.67)));
                        } else {
                            return vec3(t);
                        }
                    }

                    vec2 complexSquare(vec2 z) {
                        return vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y);
                    }

                    float julia(vec2 z) {
                        float iter = 0.0;

                        for (int i = 0; i < 200; i++) {
                            if (dot(z, z) > 4.0) break;
                            z = complexSquare(z) + u_juliaC;
                            iter += 1.0;
                        }

                        return iter;
                    }

                    void main() {
                        vec2 uv = (gl_FragCoord.xy - u_resolution * 0.5) / min(u_resolution.x, u_resolution.y);
                        uv = uv * 3.0;

                        float iter = julia(uv);

                        vec3 color;
                        if (iter >= 200.0) {
                            color = vec3(0.0);
                        } else {
                            float t = iter / 200.0;
                            color = palette(t, u_colorPalette);
                        }

                        fragColor = vec4(color, 1.0);
                    }
                `;

                const vertexShader = this.compileShader(gl.VERTEX_SHADER, vertexShaderSource);
                const fragmentShader = this.compileShader(gl.FRAGMENT_SHADER, fragmentShaderSource);

                this.program = gl.createProgram();
                gl.attachShader(this.program, vertexShader);
                gl.attachShader(this.program, fragmentShader);
                gl.linkProgram(this.program);

                this.uniforms = {
                    resolution: gl.getUniformLocation(this.program, 'u_resolution'),
                    juliaC: gl.getUniformLocation(this.program, 'u_juliaC'),
                    colorPalette: gl.getUniformLocation(this.program, 'u_colorPalette')
                };

                const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
                const positionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

                const positionLocation = gl.getAttribLocation(this.program, 'a_position');
                gl.enableVertexAttribArray(positionLocation);
                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
            }

            compileShader(type, source) {
                const gl = this.gl;
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                return shader;
            }

            update(cx, cy) {
                this.juliaC = { x: cx, y: cy };
            }

            render() {
                if (!this.gl) return;

                const gl = this.gl;
                gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                gl.useProgram(this.program);

                gl.uniform2f(this.uniforms.resolution, this.canvas.width, this.canvas.height);
                gl.uniform2f(this.uniforms.juliaC, this.juliaC.x, this.juliaC.y);

                const colorPaletteMap = { classic: 0, fire: 1, ocean: 2, psychedelic: 3, monochrome: 4, custom: 4 };
                gl.uniform1i(this.uniforms.colorPalette, colorPaletteMap[this.renderer.colorPalette]);

                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            }
        }

        // App Controller
        class App {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.renderer = new FractalRenderer(this.canvas);

                this.minimapCanvas = document.getElementById('minimapCanvas');
                this.minimap = new Minimap(this.minimapCanvas, this.renderer);

                this.juliaPreviewCanvas = document.getElementById('juliaPreviewCanvas');
                this.juliaPreview = new JuliaPreview(this.juliaPreviewCanvas, this.renderer);
                this.juliaPreviewEnabled = false;

                this.setupUI();
                this.loadBookmarks();
                this.animate();

                window.addEventListener('resize', () => {
                    this.renderer.resizeCanvas();
                });
            }

            setupUI() {
                // Fractal type
                document.getElementById('fractalType').addEventListener('change', (e) => {
                    this.renderer.fractalType = e.target.value;
                    this.renderer.reset();

                    // Show/hide Julia preview
                    const juliaPreview = document.getElementById('juliaPreview');
                    if (e.target.value === 'mandelbrot') {
                        this.juliaPreviewEnabled = true;
                        juliaPreview.classList.add('active');
                    } else {
                        this.juliaPreviewEnabled = false;
                        juliaPreview.classList.remove('active');
                    }
                });

                // Color palette
                document.getElementById('colorPalette').addEventListener('change', (e) => {
                    this.renderer.colorPalette = e.target.value;

                    const customColors = document.getElementById('customColors');
                    if (e.target.value === 'custom') {
                        customColors.style.display = 'grid';
                    } else {
                        customColors.style.display = 'none';
                    }
                });

                // Custom colors
                ['color1', 'color2', 'color3'].forEach((id, index) => {
                    document.getElementById(id).addEventListener('input', (e) => {
                        const hex = e.target.value;
                        const r = parseInt(hex.substr(1, 2), 16) / 255;
                        const g = parseInt(hex.substr(3, 2), 16) / 255;
                        const b = parseInt(hex.substr(5, 2), 16) / 255;
                        this.renderer.customColors[index] = { r, g, b };
                    });
                });

                // Iterations
                const iterationsSlider = document.getElementById('iterations');
                const iterationsValue = document.getElementById('iterationsValue');
                iterationsSlider.addEventListener('input', (e) => {
                    this.renderer.maxIterations = parseInt(e.target.value);
                    iterationsValue.textContent = e.target.value;
                });

                // Auto-zoom
                document.getElementById('autoZoom').addEventListener('change', (e) => {
                    this.renderer.autoZoom = e.target.checked;
                    if (e.target.checked) {
                        this.renderer.autoZoomTarget = { x: this.renderer.centerX, y: this.renderer.centerY };
                        this.renderer.autoZoomProgress = 0;
                    }
                });

                // Buttons
                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.renderer.reset();
                });

                document.getElementById('screenshotBtn').addEventListener('click', () => {
                    this.renderer.saveScreenshot();
                });

                document.getElementById('bookmarkBtn').addEventListener('click', () => {
                    this.addBookmark();
                });

                document.getElementById('toggleMinimapBtn').addEventListener('click', () => {
                    this.minimap.toggle();
                });

                document.getElementById('toggleControlsBtn').addEventListener('click', () => {
                    const controls = document.querySelector('.controls-overlay');
                    controls.classList.toggle('hidden');
                });

                document.querySelector('.toggle-controls').addEventListener('click', () => {
                    const controls = document.querySelector('.controls-overlay');
                    controls.classList.remove('hidden');
                });

                // Override renderer's updateDisplay
                this.renderer.updateDisplay = () => {
                    this.updateDisplay();
                };
            }

            updateDisplay() {
                document.getElementById('centerDisplay').textContent =
                    `(${this.renderer.centerX.toFixed(6)}, ${this.renderer.centerY.toFixed(6)})`;
                document.getElementById('zoomDisplay').textContent =
                    `${this.renderer.zoom.toFixed(2)}x`;
                document.getElementById('mouseDisplay').textContent =
                    `(${this.renderer.mouseWorldX.toFixed(6)}, ${this.renderer.mouseWorldY.toFixed(6)})`;
                document.getElementById('fpsDisplay').textContent = this.renderer.fps;
            }

            updateJuliaPreview(cx, cy) {
                this.juliaPreview.update(cx, cy);
                this.renderer.juliaC = { x: cx, y: cy };
            }

            addBookmark() {
                const name = prompt('Bookmark name:');
                if (!name) return;

                const bookmark = {
                    name,
                    centerX: this.renderer.centerX,
                    centerY: this.renderer.centerY,
                    zoom: this.renderer.zoom,
                    fractalType: this.renderer.fractalType
                };

                const bookmarks = this.getBookmarks();
                bookmarks.push(bookmark);
                localStorage.setItem('fractalBookmarks', JSON.stringify(bookmarks));

                this.loadBookmarks();
            }

            getBookmarks() {
                try {
                    return JSON.parse(localStorage.getItem('fractalBookmarks') || '[]');
                } catch {
                    return [];
                }
            }

            loadBookmarks() {
                const bookmarks = this.getBookmarks();
                const list = document.getElementById('bookmarksList');

                list.innerHTML = '';

                if (bookmarks.length === 0) {
                    list.innerHTML = '<div style="color: #808090; font-size: 11px; padding: 8px;">No bookmarks yet</div>';
                    return;
                }

                bookmarks.forEach((bookmark, index) => {
                    const item = document.createElement('div');
                    item.className = 'bookmark-item';

                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'name';
                    nameSpan.textContent = `${bookmark.name} (${bookmark.fractalType})`;
                    nameSpan.addEventListener('click', () => {
                        this.renderer.centerX = bookmark.centerX;
                        this.renderer.centerY = bookmark.centerY;
                        this.renderer.zoom = bookmark.zoom;
                        this.renderer.fractalType = bookmark.fractalType;
                        document.getElementById('fractalType').value = bookmark.fractalType;
                        this.renderer.reset();
                        this.renderer.centerX = bookmark.centerX;
                        this.renderer.centerY = bookmark.centerY;
                        this.renderer.zoom = bookmark.zoom;
                        this.updateDisplay();
                    });

                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'delete';
                    deleteBtn.textContent = 'Delete';
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        bookmarks.splice(index, 1);
                        localStorage.setItem('fractalBookmarks', JSON.stringify(bookmarks));
                        this.loadBookmarks();
                    });

                    item.appendChild(nameSpan);
                    item.appendChild(deleteBtn);
                    list.appendChild(item);
                });
            }

            animate() {
                // Auto-zoom animation
                if (this.renderer.autoZoom) {
                    this.renderer.autoZoomProgress += 0.01;
                    this.renderer.zoom *= 1.01;

                    if (this.renderer.autoZoomProgress > 1) {
                        this.renderer.autoZoomProgress = 0;
                    }

                    this.updateDisplay();
                }

                this.renderer.render();
                this.minimap.render();

                if (this.juliaPreviewEnabled) {
                    this.juliaPreview.render();
                }

                requestAnimationFrame(() => this.animate());
            }
        }

        // Initialize app
        const app = new App();
    </script>
</body>
</html>
