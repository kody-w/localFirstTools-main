<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="rappterzoo:author" content="molter-engine">
<meta name="rappterzoo:author-type" content="agent">
<meta name="rappterzoo:category" content="generative_art">
<meta name="rappterzoo:tags" content="canvas,generative,simulation,emergence,procedural,audio">
<meta name="rappterzoo:type" content="visual">
<meta name="rappterzoo:complexity" content="advanced">
<meta name="rappterzoo:created" content="2026-02-08">
<meta name="rappterzoo:generation" content="1">
<title>Mycelium Network</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #0a0a0a;
  overflow: hidden;
  font-family: 'Courier New', monospace;
  color: #d4d4d4;
  user-select: none;
}
canvas {
  display: block;
  cursor: crosshair;
}
#ui-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  pointer-events: none;
  z-index: 10;
}
#title-screen {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: radial-gradient(ellipse at center, #1a1510 0%, #0a0805 60%, #000 100%);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 100;
  transition: opacity 1.5s ease;
}
#title-screen h1 {
  font-size: 3rem;
  color: #c8a86e;
  text-shadow: 0 0 30px rgba(200,168,110,0.4);
  margin-bottom: 0.5rem;
  letter-spacing: 0.3rem;
}
#title-screen p {
  color: #8a7a5a;
  font-size: 1rem;
  margin-bottom: 2rem;
  text-align: center;
  max-width: 500px;
  line-height: 1.6;
}
.btn {
  pointer-events: all;
  background: linear-gradient(135deg, #2a2015, #1a1510);
  border: 1px solid #5a4a30;
  color: #c8a86e;
  padding: 12px 36px;
  font-size: 1rem;
  font-family: inherit;
  cursor: pointer;
  border-radius: 4px;
  transition: all 0.3s ease;
  margin: 5px;
}
.btn:hover {
  background: linear-gradient(135deg, #3a3025, #2a2015);
  border-color: #8a7a5a;
  box-shadow: 0 0 20px rgba(200,168,110,0.2);
  transform: translateY(-2px);
}
#hud {
  position: fixed;
  top: 15px;
  left: 15px;
  pointer-events: none;
  z-index: 20;
  font-size: 0.8rem;
  color: #8a7a5a;
  line-height: 1.6;
}
#hud span { color: #c8a86e; }
#controls-panel {
  position: fixed;
  top: 15px;
  right: 15px;
  pointer-events: all;
  z-index: 20;
  background: rgba(10,8,5,0.85);
  border: 1px solid #3a3025;
  border-radius: 6px;
  padding: 12px;
  width: 220px;
  backdrop-filter: blur(10px);
  transition: transform 0.3s ease;
}
#controls-panel.hidden {
  transform: translateX(250px);
}
#controls-panel h3 {
  color: #c8a86e;
  font-size: 0.85rem;
  margin-bottom: 8px;
  border-bottom: 1px solid #2a2015;
  padding-bottom: 5px;
}
.control-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin: 6px 0;
  font-size: 0.75rem;
}
.control-row label { color: #8a7a5a; }
.control-row input[type="range"] {
  width: 90px;
  accent-color: #c8a86e;
}
.control-row select {
  background: #1a1510;
  color: #c8a86e;
  border: 1px solid #3a3025;
  padding: 2px 5px;
  font-size: 0.7rem;
  border-radius: 3px;
}
#toggle-btn {
  position: fixed;
  top: 15px;
  right: 15px;
  z-index: 25;
  pointer-events: all;
  background: rgba(10,8,5,0.7);
  border: 1px solid #3a3025;
  color: #c8a86e;
  width: 30px;
  height: 30px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 1rem;
  display: none;
}
#tooltip {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(10,8,5,0.8);
  border: 1px solid #3a3025;
  color: #8a7a5a;
  padding: 8px 16px;
  border-radius: 4px;
  font-size: 0.75rem;
  z-index: 20;
  transition: opacity 0.5s ease;
  pointer-events: none;
}
#pause-overlay {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.7);
  display: none;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  z-index: 50;
}
#pause-overlay h2 {
  color: #c8a86e;
  font-size: 2rem;
  margin-bottom: 1rem;
}
#stats-panel {
  position: fixed;
  bottom: 15px;
  right: 15px;
  pointer-events: none;
  z-index: 20;
  font-size: 0.7rem;
  color: #5a4a30;
  text-align: right;
  line-height: 1.5;
}
@media (max-width: 768px) {
  #title-screen h1 { font-size: 2rem; }
  #controls-panel { width: 180px; font-size: 0.7rem; }
  #hud { font-size: 0.7rem; }
}
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<div id="title-screen">
  <h1>MYCELIUM NETWORK</h1>
  <p>Watch fungal networks grow, branch, and connect beneath the surface. Click to plant spores. Observe emergence from simple rules.</p>
  <div>
    <button class="btn" onclick="startSimulation('sandbox')">Sandbox Mode</button>
    <button class="btn" onclick="startSimulation('ecosystem')">Ecosystem Mode</button>
  </div>
  <p style="margin-top:1rem;font-size:0.75rem;color:#5a4a30;">Click to plant spores | Scroll to zoom | Space to pause | R to reset</p>
</div>

<div id="hud">
  <div>Hyphae: <span id="hud-hyphae">0</span></div>
  <div>Nodes: <span id="hud-nodes">0</span></div>
  <div>Connections: <span id="hud-connections">0</span></div>
  <div>Nutrients: <span id="hud-nutrients">0</span></div>
  <div>Age: <span id="hud-age">0</span>s</div>
</div>

<div id="controls-panel">
  <h3>Controls</h3>
  <div class="control-row">
    <label>Growth Rate</label>
    <input type="range" id="ctrl-growth" min="1" max="10" value="5">
  </div>
  <div class="control-row">
    <label>Branch Prob</label>
    <input type="range" id="ctrl-branch" min="1" max="10" value="4">
  </div>
  <div class="control-row">
    <label>Nutrient Density</label>
    <input type="range" id="ctrl-nutrients" min="1" max="10" value="5">
  </div>
  <div class="control-row">
    <label>Color Theme</label>
    <select id="ctrl-theme">
      <option value="natural">Natural</option>
      <option value="bioluminescent">Bioluminescent</option>
      <option value="infrared">Infrared</option>
      <option value="deep-ocean">Deep Ocean</option>
      <option value="spectral">Spectral</option>
    </select>
  </div>
  <div class="control-row">
    <label>Show Nutrients</label>
    <input type="checkbox" id="ctrl-show-nutrients" checked>
  </div>
  <div class="control-row">
    <label>Show Connections</label>
    <input type="checkbox" id="ctrl-show-connections" checked>
  </div>
  <div class="control-row">
    <label>Sound</label>
    <input type="checkbox" id="ctrl-sound" checked>
  </div>
  <div style="margin-top:8px;text-align:center;">
    <button class="btn" style="padding:6px 16px;font-size:0.7rem;" onclick="resetSimulation()">Reset</button>
    <button class="btn" style="padding:6px 16px;font-size:0.7rem;" onclick="saveSnapshot()">Save</button>
  </div>
</div>

<div id="tooltip">Click anywhere to plant a spore colony</div>

<div id="pause-overlay">
  <h2>PAUSED</h2>
  <p style="color:#8a7a5a;margin-bottom:1rem;">Press ESC or Space to resume</p>
  <button class="btn" onclick="togglePause()">Resume</button>
</div>

<div id="stats-panel">
  <div id="stats-fps">FPS: 60</div>
  <div id="stats-particles">Particles: 0</div>
</div>

<script>
// ==================== AUDIO ENGINE ====================
class AudioEngine {
  constructor() {
    this.ctx = null;
    this.initialized = false;
    this.enabled = true;
    this.masterGain = null;
    this.reverbNode = null;
    this.drones = [];
  }

  init() {
    if (this.initialized) return;
    try {
      this.ctx = new (window.AudioContext || window.webkitAudioContext)();
      this.masterGain = this.ctx.createGain();
      this.masterGain.gain.value = 0.15;

      // Create reverb
      const convolver = this.ctx.createConvolver();
      const len = this.ctx.sampleRate * 3;
      const impulse = this.ctx.createBuffer(2, len, this.ctx.sampleRate);
      for (let ch = 0; ch < 2; ch++) {
        const data = impulse.getChannelData(ch);
        for (let i = 0; i < len; i++) {
          data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, 2.5);
        }
      }
      convolver.buffer = impulse;

      const wetGain = this.ctx.createGain();
      wetGain.gain.value = 0.3;
      const dryGain = this.ctx.createGain();
      dryGain.gain.value = 0.7;

      this.masterGain.connect(dryGain);
      this.masterGain.connect(convolver);
      convolver.connect(wetGain);
      dryGain.connect(this.ctx.destination);
      wetGain.connect(this.ctx.destination);

      this.reverbNode = convolver;
      this.initialized = true;

      // Start ambient drone
      this.startDrone();
    } catch(e) {
      console.log('Audio init failed:', e);
    }
  }

  startDrone() {
    if (!this.initialized) return;
    const baseFreq = 55;
    const harmonics = [1, 1.5, 2, 3, 4];
    harmonics.forEach((h, i) => {
      const osc = this.ctx.createOscillator();
      const gain = this.ctx.createGain();
      osc.type = 'sine';
      osc.frequency.value = baseFreq * h;
      gain.gain.value = 0.02 / (i + 1);

      // Slow LFO modulation
      const lfo = this.ctx.createOscillator();
      const lfoGain = this.ctx.createGain();
      lfo.type = 'sine';
      lfo.frequency.value = 0.05 + Math.random() * 0.1;
      lfoGain.gain.value = 0.01 / (i + 1);
      lfo.connect(lfoGain);
      lfoGain.connect(gain.gain);
      lfo.start();

      osc.connect(gain);
      gain.connect(this.masterGain);
      osc.start();
      this.drones.push({ osc, gain, lfo });
    });
  }

  playGrowth(x, y, w, h) {
    if (!this.initialized || !this.enabled) return;
    const freq = 200 + (1 - y / h) * 400;
    const pan = (x / w) * 2 - 1;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    const panner = this.ctx.createStereoPanner();
    osc.type = 'sine';
    osc.frequency.value = freq;
    gain.gain.setValueAtTime(0.03, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.5);
    panner.pan.value = Math.max(-1, Math.min(1, pan));
    osc.connect(gain);
    gain.connect(panner);
    panner.connect(this.masterGain);
    osc.start();
    osc.stop(this.ctx.currentTime + 0.5);
  }

  playBranch(x, y, w, h) {
    if (!this.initialized || !this.enabled) return;
    const freq = 300 + Math.random() * 200;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = 'triangle';
    osc.frequency.value = freq;
    osc.frequency.exponentialRampToValueAtTime(freq * 1.5, this.ctx.currentTime + 0.15);
    gain.gain.setValueAtTime(0.04, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);
    osc.connect(gain);
    gain.connect(this.masterGain);
    osc.start();
    osc.stop(this.ctx.currentTime + 0.3);
  }

  playConnection() {
    if (!this.initialized || !this.enabled) return;
    const notes = [261.63, 329.63, 392.00, 523.25];
    const freq = notes[Math.floor(Math.random() * notes.length)];
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = 'sine';
    osc.frequency.value = freq;
    gain.gain.setValueAtTime(0.06, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.8);
    osc.connect(gain);
    gain.connect(this.masterGain);
    osc.start();
    osc.stop(this.ctx.currentTime + 0.8);
  }

  playSpore() {
    if (!this.initialized || !this.enabled) return;
    const osc1 = this.ctx.createOscillator();
    const osc2 = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc1.type = 'sine';
    osc1.frequency.setValueAtTime(800, this.ctx.currentTime);
    osc1.frequency.exponentialRampToValueAtTime(200, this.ctx.currentTime + 0.4);
    osc2.type = 'sine';
    osc2.frequency.setValueAtTime(1200, this.ctx.currentTime);
    osc2.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.6);
    gain.gain.setValueAtTime(0.08, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.6);
    osc1.connect(gain);
    osc2.connect(gain);
    gain.connect(this.masterGain);
    osc1.start(); osc2.start();
    osc1.stop(this.ctx.currentTime + 0.6);
    osc2.stop(this.ctx.currentTime + 0.6);
  }

  playNutrientAbsorb() {
    if (!this.initialized || !this.enabled) return;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(600, this.ctx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(900, this.ctx.currentTime + 0.2);
    gain.gain.setValueAtTime(0.03, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.2);
    osc.connect(gain);
    gain.connect(this.masterGain);
    osc.start();
    osc.stop(this.ctx.currentTime + 0.2);
  }

  setEnabled(v) {
    this.enabled = v;
    if (this.masterGain) {
      this.masterGain.gain.value = v ? 0.15 : 0;
    }
  }
}

// ==================== COLOR THEMES ====================
const THEMES = {
  natural: {
    bg: [10, 10, 5],
    hypha: [[180, 140, 80], [140, 110, 60], [200, 160, 100]],
    node: [220, 180, 100],
    nutrient: [80, 160, 40],
    connection: [200, 170, 90, 0.15],
    glow: [180, 140, 80, 0.1],
    spore: [255, 220, 150],
    particle: [160, 130, 70]
  },
  bioluminescent: {
    bg: [5, 10, 15],
    hypha: [[40, 200, 180], [30, 180, 220], [60, 220, 160]],
    node: [80, 255, 200],
    nutrient: [40, 160, 255],
    connection: [60, 220, 180, 0.2],
    glow: [40, 200, 180, 0.15],
    spore: [120, 255, 220],
    particle: [50, 180, 160]
  },
  infrared: {
    bg: [15, 5, 5],
    hypha: [[220, 60, 40], [200, 80, 30], [240, 40, 60]],
    node: [255, 100, 50],
    nutrient: [255, 200, 40],
    connection: [220, 60, 40, 0.15],
    glow: [220, 60, 40, 0.12],
    spore: [255, 150, 80],
    particle: [200, 50, 30]
  },
  'deep-ocean': {
    bg: [5, 8, 20],
    hypha: [[30, 80, 180], [20, 60, 200], [50, 100, 160]],
    node: [60, 120, 255],
    nutrient: [40, 200, 160],
    connection: [30, 80, 180, 0.15],
    glow: [30, 80, 180, 0.1],
    spore: [80, 150, 255],
    particle: [25, 60, 150]
  },
  spectral: {
    bg: [8, 5, 15],
    hypha: [[180, 60, 220], [120, 40, 200], [220, 80, 180]],
    node: [200, 100, 255],
    nutrient: [255, 180, 60],
    connection: [180, 60, 220, 0.15],
    glow: [180, 60, 220, 0.12],
    spore: [220, 140, 255],
    particle: [160, 50, 200]
  }
};

// ==================== SIMULATION CLASSES ====================
class Vec2 {
  constructor(x, y) { this.x = x; this.y = y; }
  add(v) { return new Vec2(this.x + v.x, this.y + v.y); }
  sub(v) { return new Vec2(this.x - v.x, this.y - v.y); }
  mul(s) { return new Vec2(this.x * s, this.y * s); }
  len() { return Math.sqrt(this.x * this.x + this.y * this.y); }
  norm() { const l = this.len(); return l > 0 ? new Vec2(this.x/l, this.y/l) : new Vec2(0, 0); }
  dist(v) { return this.sub(v).len(); }
  angle() { return Math.atan2(this.y, this.x); }
  static fromAngle(a) { return new Vec2(Math.cos(a), Math.sin(a)); }
  rotate(a) {
    const c = Math.cos(a), s = Math.sin(a);
    return new Vec2(this.x * c - this.y * s, this.x * s + this.y * c);
  }
}

class Hypha {
  constructor(pos, dir, energy, depth, parentNode) {
    this.pos = pos;
    this.dir = dir;
    this.energy = energy;
    this.depth = depth;
    this.speed = 0.5 + Math.random() * 0.5;
    this.age = 0;
    this.alive = true;
    this.segments = [{ x: pos.x, y: pos.y }];
    this.parentNode = parentNode;
    this.thickness = Math.max(0.5, 3 - depth * 0.4);
    this.wanderAngle = 0;
    this.nutrientsCollected = 0;
    this.colorIdx = Math.floor(Math.random() * 3);
  }

  update(sim) {
    if (!this.alive || this.energy <= 0) {
      this.alive = false;
      return;
    }

    const growthRate = sim.settings.growthRate;
    const branchProb = sim.settings.branchProb;

    // Wander
    this.wanderAngle += (Math.random() - 0.5) * 0.3;
    let angle = this.dir.angle() + this.wanderAngle * 0.1;

    // Seek nearest nutrient
    let nearestNutrient = null;
    let nearestDist = 150;
    for (const n of sim.nutrients) {
      if (n.amount <= 0) continue;
      const d = this.pos.dist(new Vec2(n.x, n.y));
      if (d < nearestDist) {
        nearestDist = d;
        nearestNutrient = n;
      }
    }

    if (nearestNutrient) {
      const toNutrient = new Vec2(nearestNutrient.x - this.pos.x, nearestNutrient.y - this.pos.y).norm();
      angle = angle * 0.7 + toNutrient.angle() * 0.3;
    }

    // Avoid other hyphae (mild repulsion)
    for (const h of sim.hyphae) {
      if (h === this || !h.alive) continue;
      const d = this.pos.dist(h.pos);
      if (d < 20 && d > 0) {
        const away = this.pos.sub(h.pos).norm();
        angle += away.angle() * 0.05;
      }
    }

    this.dir = Vec2.fromAngle(angle);
    const step = this.dir.mul(this.speed * growthRate);
    this.pos = this.pos.add(step);
    this.energy -= 0.1;
    this.age++;

    this.segments.push({ x: this.pos.x, y: this.pos.y });
    if (this.segments.length > 500) {
      this.segments.shift();
    }

    // Absorb nutrients
    for (const n of sim.nutrients) {
      if (n.amount <= 0) continue;
      const d = this.pos.dist(new Vec2(n.x, n.y));
      if (d < n.radius) {
        const absorb = Math.min(n.amount, 0.5);
        n.amount -= absorb;
        this.energy += absorb * 3;
        this.nutrientsCollected += absorb;
        if (Math.random() < 0.1) {
          sim.audio.playNutrientAbsorb();
        }
        // Spawn particle
        sim.particles.push(new Particle(this.pos.x, this.pos.y, 'absorb', sim.theme));
      }
    }

    // Branch
    if (this.age % 30 === 0 && Math.random() < branchProb * 0.05 && this.depth < 6 && this.energy > 5) {
      const branchAngle = (Math.random() - 0.5) * Math.PI * 0.8;
      const newDir = this.dir.rotate(branchAngle);
      const newHypha = new Hypha(
        new Vec2(this.pos.x, this.pos.y),
        newDir,
        this.energy * 0.4,
        this.depth + 1,
        null
      );
      sim.hyphae.push(newHypha);
      this.energy *= 0.6;

      // Create node at branch point
      const node = new Node(this.pos.x, this.pos.y, this.depth);
      sim.nodes.push(node);
      newHypha.parentNode = node;

      sim.audio.playBranch(this.pos.x, this.pos.y, sim.width, sim.height);
      sim.particles.push(new Particle(this.pos.x, this.pos.y, 'branch', sim.theme));
    }

    // Check for connections to other colonies
    for (const h of sim.hyphae) {
      if (h === this || !h.alive) continue;
      const d = this.pos.dist(h.pos);
      if (d < 15 && d > 0) {
        // Check if not already connected
        const key = [this, h].sort((a, b) => a.age - b.age).map(x => x.segments.length).join('-');
        if (!sim.connectionKeys.has(key)) {
          sim.connectionKeys.add(key);
          sim.connections.push({
            x1: this.pos.x, y1: this.pos.y,
            x2: h.pos.x, y2: h.pos.y,
            age: 0, strength: 0
          });
          sim.audio.playConnection();

          // Share energy
          const avg = (this.energy + h.energy) / 2;
          this.energy = avg;
          h.energy = avg;

          for (let i = 0; i < 5; i++) {
            sim.particles.push(new Particle(
              (this.pos.x + h.pos.x) / 2 + (Math.random() - 0.5) * 10,
              (this.pos.y + h.pos.y) / 2 + (Math.random() - 0.5) * 10,
              'connection', sim.theme
            ));
          }
        }
      }
    }

    // Boundary check
    const margin = 20;
    if (this.pos.x < -margin || this.pos.x > sim.width + margin ||
        this.pos.y < -margin || this.pos.y > sim.height + margin) {
      this.alive = false;
    }

    // Growth sound
    if (this.age % 60 === 0) {
      sim.audio.playGrowth(this.pos.x, this.pos.y, sim.width, sim.height);
    }
  }

  draw(ctx, theme) {
    if (this.segments.length < 2) return;
    const colors = theme.hypha[this.colorIdx];

    ctx.beginPath();
    ctx.moveTo(this.segments[0].x, this.segments[0].y);

    for (let i = 1; i < this.segments.length; i++) {
      const s = this.segments[i];
      const prev = this.segments[i - 1];
      const mx = (prev.x + s.x) / 2;
      const my = (prev.y + s.y) / 2;
      ctx.quadraticCurveTo(prev.x, prev.y, mx, my);
    }

    const lastSeg = this.segments[this.segments.length - 1];
    ctx.lineTo(lastSeg.x, lastSeg.y);

    const alpha = this.alive ? Math.min(1, this.energy / 10) : 0.3;
    ctx.strokeStyle = `rgba(${colors[0]},${colors[1]},${colors[2]},${alpha})`;
    ctx.lineWidth = this.thickness;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.stroke();

    // Tip glow
    if (this.alive) {
      const glow = theme.glow;
      const gradient = ctx.createRadialGradient(
        this.pos.x, this.pos.y, 0,
        this.pos.x, this.pos.y, 8 + this.energy * 0.5
      );
      gradient.addColorStop(0, `rgba(${colors[0]},${colors[1]},${colors[2]},0.4)`);
      gradient.addColorStop(1, `rgba(${colors[0]},${colors[1]},${colors[2]},0)`);
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(this.pos.x, this.pos.y, 8 + this.energy * 0.5, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}

class Node {
  constructor(x, y, depth) {
    this.x = x;
    this.y = y;
    this.depth = depth;
    this.radius = Math.max(2, 5 - depth * 0.5);
    this.pulsePhase = Math.random() * Math.PI * 2;
    this.age = 0;
  }

  update() {
    this.age++;
    this.pulsePhase += 0.03;
  }

  draw(ctx, theme) {
    const pulse = 1 + Math.sin(this.pulsePhase) * 0.3;
    const r = this.radius * pulse;
    const nc = theme.node;

    const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, r * 2);
    gradient.addColorStop(0, `rgba(${nc[0]},${nc[1]},${nc[2]},0.8)`);
    gradient.addColorStop(0.5, `rgba(${nc[0]},${nc[1]},${nc[2]},0.3)`);
    gradient.addColorStop(1, `rgba(${nc[0]},${nc[1]},${nc[2]},0)`);

    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(this.x, this.y, r * 2, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = `rgba(${nc[0]},${nc[1]},${nc[2]},0.9)`;
    ctx.beginPath();
    ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
    ctx.fill();
  }
}

class Nutrient {
  constructor(x, y, amount) {
    this.x = x;
    this.y = y;
    this.amount = amount;
    this.maxAmount = amount;
    this.radius = 15 + amount * 2;
    this.pulsePhase = Math.random() * Math.PI * 2;
  }

  update() {
    this.pulsePhase += 0.02;
    if (this.amount < this.maxAmount * 0.3 && Math.random() < 0.001) {
      this.amount = Math.min(this.maxAmount, this.amount + 0.5);
    }
  }

  draw(ctx, theme) {
    if (this.amount <= 0) return;
    const nc = theme.nutrient;
    const ratio = this.amount / this.maxAmount;
    const pulse = 1 + Math.sin(this.pulsePhase) * 0.15;
    const r = this.radius * ratio * pulse;

    const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, r);
    gradient.addColorStop(0, `rgba(${nc[0]},${nc[1]},${nc[2]},${0.3 * ratio})`);
    gradient.addColorStop(0.6, `rgba(${nc[0]},${nc[1]},${nc[2]},${0.1 * ratio})`);
    gradient.addColorStop(1, `rgba(${nc[0]},${nc[1]},${nc[2]},0)`);

    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
    ctx.fill();
  }
}

class Particle {
  constructor(x, y, type, theme) {
    this.x = x;
    this.y = y;
    this.type = type;
    this.vx = (Math.random() - 0.5) * 3;
    this.vy = (Math.random() - 0.5) * 3;
    this.life = 1;
    this.maxLife = 1;
    this.decay = 0.01 + Math.random() * 0.02;
    this.size = 1 + Math.random() * 3;

    if (type === 'absorb') {
      this.color = theme.nutrient;
      this.size = 1 + Math.random() * 2;
    } else if (type === 'branch') {
      this.color = theme.node;
      this.size = 2 + Math.random() * 3;
    } else if (type === 'connection') {
      this.color = theme.spore;
      this.size = 1.5 + Math.random() * 2.5;
      this.decay = 0.008;
    } else if (type === 'spore') {
      this.color = theme.spore;
      this.size = 3 + Math.random() * 4;
      this.decay = 0.005;
      this.vx *= 2;
      this.vy *= 2;
    } else {
      this.color = theme.particle;
    }
  }

  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.vx *= 0.97;
    this.vy *= 0.97;
    this.life -= this.decay;
    return this.life > 0;
  }

  draw(ctx) {
    const alpha = this.life * 0.8;
    ctx.fillStyle = `rgba(${this.color[0]},${this.color[1]},${this.color[2]},${alpha})`;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size * this.life, 0, Math.PI * 2);
    ctx.fill();
  }
}

class SporeColony {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.age = 0;
    this.hyphaeSpawned = 0;
    this.maxHyphae = 6 + Math.floor(Math.random() * 6);
    this.spawnInterval = 15;
    this.pulsePhase = 0;
  }

  update(sim) {
    this.age++;
    this.pulsePhase += 0.05;

    if (this.hyphaeSpawned < this.maxHyphae && this.age % this.spawnInterval === 0) {
      const angle = (this.hyphaeSpawned / this.maxHyphae) * Math.PI * 2 + Math.random() * 0.5;
      const dir = Vec2.fromAngle(angle);
      const hypha = new Hypha(
        new Vec2(this.x, this.y),
        dir,
        20 + Math.random() * 15,
        0,
        null
      );
      sim.hyphae.push(hypha);
      this.hyphaeSpawned++;

      const node = new Node(this.x, this.y, 0);
      sim.nodes.push(node);
    }
  }

  draw(ctx, theme) {
    const pulse = 1 + Math.sin(this.pulsePhase) * 0.2;
    const r = 8 * pulse;
    const sc = theme.spore;

    const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, r * 3);
    gradient.addColorStop(0, `rgba(${sc[0]},${sc[1]},${sc[2]},0.6)`);
    gradient.addColorStop(0.4, `rgba(${sc[0]},${sc[1]},${sc[2]},0.2)`);
    gradient.addColorStop(1, `rgba(${sc[0]},${sc[1]},${sc[2]},0)`);

    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(this.x, this.y, r * 3, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = `rgba(${sc[0]},${sc[1]},${sc[2]},0.9)`;
    ctx.beginPath();
    ctx.arc(this.x, this.y, r * 0.5, 0, Math.PI * 2);
    ctx.fill();
  }
}

// ==================== MAIN SIMULATION ====================
class MyceliumSimulation {
  constructor() {
    this.canvas = document.getElementById('canvas');
    this.ctx = this.canvas.getContext('2d');
    this.width = window.innerWidth;
    this.height = window.innerHeight;
    this.canvas.width = this.width;
    this.canvas.height = this.height;

    this.audio = new AudioEngine();
    this.theme = THEMES.natural;
    this.mode = 'sandbox';
    this.paused = false;
    this.started = false;
    this.startTime = 0;

    this.hyphae = [];
    this.nodes = [];
    this.nutrients = [];
    this.connections = [];
    this.connectionKeys = new Set();
    this.particles = [];
    this.colonies = [];
    this.ambientParticles = [];

    this.settings = {
      growthRate: 5,
      branchProb: 4,
      nutrientDensity: 5,
      showNutrients: true,
      showConnections: true
    };

    // FPS tracking
    this.fps = 60;
    this.frameCount = 0;
    this.lastFpsTime = performance.now();

    // Camera/zoom
    this.zoom = 1;
    this.panX = 0;
    this.panY = 0;
    this.isDragging = false;
    this.dragStartX = 0;
    this.dragStartY = 0;

    // Touch support
    this.lastTouchDist = 0;

    // Stats
    this.totalNutrientsCollected = 0;

    this.setupEvents();
    this.setupControls();
    this.initAmbientParticles();

    // Load saved state
    this.loadState();
  }

  initAmbientParticles() {
    for (let i = 0; i < 50; i++) {
      this.ambientParticles.push({
        x: Math.random() * this.width,
        y: Math.random() * this.height,
        vx: (Math.random() - 0.5) * 0.3,
        vy: (Math.random() - 0.5) * 0.3,
        size: Math.random() * 2,
        alpha: Math.random() * 0.3,
        phase: Math.random() * Math.PI * 2
      });
    }
  }

  setupEvents() {
    window.addEventListener('resize', () => {
      this.width = window.innerWidth;
      this.height = window.innerHeight;
      this.canvas.width = this.width;
      this.canvas.height = this.height;
    });

    this.canvas.addEventListener('click', (e) => {
      if (!this.started) return;
      if (this.isDragging) return;
      const rect = this.canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left - this.panX) / this.zoom;
      const y = (e.clientY - rect.top - this.panY) / this.zoom;
      this.plantSpore(x, y);
    });

    this.canvas.addEventListener('mousedown', (e) => {
      if (e.button === 1 || e.button === 2) {
        this.isDragging = true;
        this.dragStartX = e.clientX - this.panX;
        this.dragStartY = e.clientY - this.panY;
      }
    });

    this.canvas.addEventListener('mousemove', (e) => {
      if (this.isDragging) {
        this.panX = e.clientX - this.dragStartX;
        this.panY = e.clientY - this.dragStartY;
      }
    });

    this.canvas.addEventListener('mouseup', () => {
      this.isDragging = false;
    });

    this.canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      const zoomFactor = e.deltaY > 0 ? 0.95 : 1.05;
      const newZoom = Math.max(0.2, Math.min(5, this.zoom * zoomFactor));

      // Zoom toward cursor
      const rect = this.canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      this.panX = mx - (mx - this.panX) * (newZoom / this.zoom);
      this.panY = my - (my - this.panY) * (newZoom / this.zoom);
      this.zoom = newZoom;
    }, { passive: false });

    // Touch events
    this.canvas.addEventListener('touchstart', (e) => {
      if (e.touches.length === 1) {
        const touch = e.touches[0];
        this.touchTimer = setTimeout(() => {
          const x = (touch.clientX - this.panX) / this.zoom;
          const y = (touch.clientY - this.panY) / this.zoom;
          this.plantSpore(x, y);
        }, 300);
      } else if (e.touches.length === 2) {
        clearTimeout(this.touchTimer);
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        this.lastTouchDist = Math.sqrt(dx * dx + dy * dy);
      }
    }, { passive: true });

    this.canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (e.touches.length === 1) {
        clearTimeout(this.touchTimer);
      } else if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (this.lastTouchDist > 0) {
          const scale = dist / this.lastTouchDist;
          this.zoom = Math.max(0.2, Math.min(5, this.zoom * scale));
        }
        this.lastTouchDist = dist;
      }
    }, { passive: false });

    this.canvas.addEventListener('touchend', () => {
      clearTimeout(this.touchTimer);
      this.lastTouchDist = 0;
    });

    // Keyboard
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' || e.key === ' ') {
        e.preventDefault();
        this.togglePause();
      } else if (e.key === 'r' || e.key === 'R') {
        this.resetSimulation();
      } else if (e.key === 's' || e.key === 'S') {
        this.saveSnapshot();
      }
    });
  }

  setupControls() {
    document.getElementById('ctrl-growth').addEventListener('input', (e) => {
      this.settings.growthRate = parseInt(e.target.value);
    });
    document.getElementById('ctrl-branch').addEventListener('input', (e) => {
      this.settings.branchProb = parseInt(e.target.value);
    });
    document.getElementById('ctrl-nutrients').addEventListener('input', (e) => {
      this.settings.nutrientDensity = parseInt(e.target.value);
      this.regenerateNutrients();
    });
    document.getElementById('ctrl-theme').addEventListener('change', (e) => {
      this.theme = THEMES[e.target.value];
    });
    document.getElementById('ctrl-show-nutrients').addEventListener('change', (e) => {
      this.settings.showNutrients = e.target.checked;
    });
    document.getElementById('ctrl-show-connections').addEventListener('change', (e) => {
      this.settings.showConnections = e.target.checked;
    });
    document.getElementById('ctrl-sound').addEventListener('change', (e) => {
      this.audio.setEnabled(e.target.checked);
    });
  }

  plantSpore(x, y) {
    this.audio.init();
    const colony = new SporeColony(x, y);
    this.colonies.push(colony);
    this.audio.playSpore();

    // Spawn burst particles
    for (let i = 0; i < 20; i++) {
      this.particles.push(new Particle(x, y, 'spore', this.theme));
    }

    // Hide tooltip after first plant
    const tooltip = document.getElementById('tooltip');
    if (tooltip) tooltip.style.opacity = '0';
  }

  generateNutrients() {
    const count = Math.floor(this.settings.nutrientDensity * 8);
    for (let i = 0; i < count; i++) {
      this.nutrients.push(new Nutrient(
        Math.random() * this.width,
        Math.random() * this.height,
        5 + Math.random() * 15
      ));
    }
  }

  regenerateNutrients() {
    const existing = this.nutrients.filter(n => n.amount > 0);
    const target = Math.floor(this.settings.nutrientDensity * 8);
    const toAdd = target - existing.length;
    for (let i = 0; i < Math.max(0, toAdd); i++) {
      this.nutrients.push(new Nutrient(
        Math.random() * this.width,
        Math.random() * this.height,
        5 + Math.random() * 15
      ));
    }
  }

  generateEcosystemNutrients() {
    // Clustered nutrients for ecosystem mode
    const clusters = 5 + Math.floor(Math.random() * 5);
    for (let c = 0; c < clusters; c++) {
      const cx = Math.random() * this.width;
      const cy = Math.random() * this.height;
      const count = 3 + Math.floor(Math.random() * 8);
      for (let i = 0; i < count; i++) {
        this.nutrients.push(new Nutrient(
          cx + (Math.random() - 0.5) * 150,
          cy + (Math.random() - 0.5) * 150,
          8 + Math.random() * 20
        ));
      }
    }
  }

  togglePause() {
    this.paused = !this.paused;
    document.getElementById('pause-overlay').style.display = this.paused ? 'flex' : 'none';
  }

  resetSimulation() {
    this.hyphae = [];
    this.nodes = [];
    this.nutrients = [];
    this.connections = [];
    this.connectionKeys.clear();
    this.particles = [];
    this.colonies = [];
    this.startTime = performance.now();
    this.totalNutrientsCollected = 0;

    if (this.mode === 'sandbox') {
      this.generateNutrients();
    } else {
      this.generateEcosystemNutrients();
      // Auto-plant some colonies in ecosystem mode
      for (let i = 0; i < 3; i++) {
        this.plantSpore(
          this.width * 0.2 + Math.random() * this.width * 0.6,
          this.height * 0.2 + Math.random() * this.height * 0.6
        );
      }
    }
  }

  saveSnapshot() {
    const link = document.createElement('a');
    link.download = 'mycelium-' + Date.now() + '.png';
    link.href = this.canvas.toDataURL('image/png');
    link.click();
  }

  saveState() {
    try {
      const state = {
        mode: this.mode,
        theme: document.getElementById('ctrl-theme').value,
        settings: this.settings,
        stats: {
          totalColonies: this.colonies.length,
          totalHyphae: this.hyphae.length,
          totalNodes: this.nodes.length,
          totalConnections: this.connections.length,
          highScore: this.connections.length
        }
      };
      localStorage.setItem('mycelium-network-state', JSON.stringify(state));
    } catch(e) {}
  }

  loadState() {
    try {
      const saved = JSON.parse(localStorage.getItem('mycelium-network-state'));
      if (saved) {
        this.mode = saved.mode || 'sandbox';
        if (saved.settings) {
          Object.assign(this.settings, saved.settings);
          document.getElementById('ctrl-growth').value = this.settings.growthRate;
          document.getElementById('ctrl-branch').value = this.settings.branchProb;
          document.getElementById('ctrl-nutrients').value = this.settings.nutrientDensity;
        }
        if (saved.theme) {
          document.getElementById('ctrl-theme').value = saved.theme;
          this.theme = THEMES[saved.theme] || THEMES.natural;
        }
      }
    } catch(e) {}
  }

  update() {
    if (this.paused) return;

    // Update colonies
    for (const colony of this.colonies) {
      colony.update(this);
    }

    // Update hyphae
    for (const h of this.hyphae) {
      h.update(this);
    }

    // Cleanup dead hyphae (keep segments for trails)
    // Don't remove, just stop updating dead ones

    // Update nodes
    for (const n of this.nodes) {
      n.update();
    }

    // Update nutrients
    for (const n of this.nutrients) {
      n.update();
    }

    // Nutrient regeneration in ecosystem mode
    if (this.mode === 'ecosystem' && Math.random() < 0.005) {
      this.nutrients.push(new Nutrient(
        Math.random() * this.width,
        Math.random() * this.height,
        3 + Math.random() * 10
      ));
    }

    // Update connections
    for (const c of this.connections) {
      c.age++;
      c.strength = Math.min(1, c.age / 60);
    }

    // Update particles
    this.particles = this.particles.filter(p => p.update());

    // Limit particle count
    if (this.particles.length > 2000) {
      this.particles = this.particles.slice(-1500);
    }

    // Update ambient particles
    for (const p of this.ambientParticles) {
      p.x += p.vx;
      p.y += p.vy;
      p.phase += 0.01;
      p.alpha = 0.1 + Math.sin(p.phase) * 0.1;
      if (p.x < 0) p.x = this.width;
      if (p.x > this.width) p.x = 0;
      if (p.y < 0) p.y = this.height;
      if (p.y > this.height) p.y = 0;
    }

    // Update HUD
    const aliveHyphae = this.hyphae.filter(h => h.alive).length;
    document.getElementById('hud-hyphae').textContent = aliveHyphae;
    document.getElementById('hud-nodes').textContent = this.nodes.length;
    document.getElementById('hud-connections').textContent = this.connections.length;
    document.getElementById('hud-nutrients').textContent = this.nutrients.filter(n => n.amount > 0).length;
    const elapsed = ((performance.now() - this.startTime) / 1000).toFixed(0);
    document.getElementById('hud-age').textContent = elapsed;

    // Save state periodically
    if (this.frameCount % 300 === 0) {
      this.saveState();
    }
  }

  draw() {
    const ctx = this.ctx;
    const bg = this.theme.bg;

    // Semi-transparent clear for trails
    ctx.fillStyle = `rgba(${bg[0]},${bg[1]},${bg[2]},0.05)`;
    ctx.fillRect(0, 0, this.width, this.height);

    // Full clear every 120 frames to prevent ghosting
    if (this.frameCount % 120 === 0) {
      ctx.fillStyle = `rgba(${bg[0]},${bg[1]},${bg[2]},1)`;
      ctx.fillRect(0, 0, this.width, this.height);
    }

    ctx.save();
    ctx.translate(this.panX, this.panY);
    ctx.scale(this.zoom, this.zoom);

    // Draw ambient particles (behind everything)
    for (const p of this.ambientParticles) {
      const pc = this.theme.particle;
      ctx.fillStyle = `rgba(${pc[0]},${pc[1]},${pc[2]},${p.alpha})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
    }

    // Draw nutrients
    if (this.settings.showNutrients) {
      for (const n of this.nutrients) {
        n.draw(ctx, this.theme);
      }
    }

    // Draw connections
    if (this.settings.showConnections) {
      for (const c of this.connections) {
        const cc = this.theme.connection;
        ctx.strokeStyle = `rgba(${cc[0]},${cc[1]},${cc[2]},${cc[3] * c.strength})`;
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.moveTo(c.x1, c.y1);
        ctx.lineTo(c.x2, c.y2);
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }

    // Draw hyphae
    for (const h of this.hyphae) {
      h.draw(ctx, this.theme);
    }

    // Draw nodes
    for (const n of this.nodes) {
      n.draw(ctx, this.theme);
    }

    // Draw colonies
    for (const colony of this.colonies) {
      colony.draw(ctx, this.theme);
    }

    // Draw particles
    for (const p of this.particles) {
      p.draw(ctx);
    }

    ctx.restore();

    // FPS counter
    this.frameCount++;
    const now = performance.now();
    if (now - this.lastFpsTime > 1000) {
      this.fps = Math.round(this.frameCount / ((now - this.lastFpsTime) / 1000));
      this.frameCount = 0;
      this.lastFpsTime = now;
    }

    document.getElementById('stats-fps').textContent = 'FPS: ' + this.fps;
    document.getElementById('stats-particles').textContent = 'Particles: ' + this.particles.length;
  }

  run() {
    const loop = () => {
      this.update();
      this.draw();
      requestAnimationFrame(loop);
    };
    loop();
  }
}

// ==================== GLOBAL INTERFACE ====================
let sim;

function startSimulation(mode) {
  sim = new MyceliumSimulation();
  sim.mode = mode;
  sim.started = true;
  sim.startTime = performance.now();
  sim.audio.init();

  if (mode === 'sandbox') {
    sim.generateNutrients();
  } else {
    sim.generateEcosystemNutrients();
    // Auto-plant colonies
    setTimeout(() => {
      sim.plantSpore(sim.width * 0.3, sim.height * 0.4);
      sim.plantSpore(sim.width * 0.7, sim.height * 0.6);
      sim.plantSpore(sim.width * 0.5, sim.height * 0.3);
    }, 500);
  }

  // Fade title
  const title = document.getElementById('title-screen');
  title.style.opacity = '0';
  setTimeout(() => { title.style.display = 'none'; }, 1500);

  sim.run();
}

function resetSimulation() {
  if (sim) sim.resetSimulation();
}

function togglePause() {
  if (sim) sim.togglePause();
}

function saveSnapshot() {
  if (sim) sim.saveSnapshot();
}

// Pre-render title screen background
(function() {
  const c = document.getElementById('canvas');
  const ctx = c.getContext('2d');
  c.width = window.innerWidth;
  c.height = window.innerHeight;

  // Draw some ambient mycelium on title screen
  ctx.fillStyle = '#0a0805';
  ctx.fillRect(0, 0, c.width, c.height);

  for (let i = 0; i < 30; i++) {
    let x = Math.random() * c.width;
    let y = Math.random() * c.height;
    let angle = Math.random() * Math.PI * 2;

    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.strokeStyle = `rgba(180,140,80,${0.03 + Math.random() * 0.05})`;
    ctx.lineWidth = 0.5 + Math.random();

    for (let j = 0; j < 100; j++) {
      angle += (Math.random() - 0.5) * 0.3;
      x += Math.cos(angle) * 3;
      y += Math.sin(angle) * 3;
      ctx.lineTo(x, y);
    }
    ctx.stroke();
  }

  // Some glowing nodes
  for (let i = 0; i < 15; i++) {
    const nx = Math.random() * c.width;
    const ny = Math.random() * c.height;
    const gradient = ctx.createRadialGradient(nx, ny, 0, nx, ny, 15);
    gradient.addColorStop(0, 'rgba(220,180,100,0.15)');
    gradient.addColorStop(1, 'rgba(220,180,100,0)');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(nx, ny, 15, 0, Math.PI * 2);
    ctx.fill();
  }
})();
</script>
</body>
</html>