<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lunar Drift</title>
    <meta name="description" content="Guide the moon across the night sky and watch moths spiral in mesmerizing patterns, confused between moonlight and artificial lamps">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0a18; min-height: 100vh; font-family: 'Georgia', serif; color: #8090b0; overflow: hidden; }
        #canvas { position: fixed; top: 0; left: 0; cursor: grab; }
        #controls {
            position: fixed; top: 20px; left: 20px; background: rgba(10,10,24,0.95);
            padding: 20px; border-radius: 10px; border: 1px solid rgba(100,120,180,0.3);
            z-index: 100;
        }
        h3 { margin-bottom: 15px; color: #b0c0e0; font-weight: normal; }
        .control-row { margin: 10px 0; }
        label { display: block; font-size: 11px; margin-bottom: 5px; opacity: 0.8; }
        input[type="range"] { width: 140px; }
        .value { float: right; color: #c0d0f0; font-size: 12px; }
        button {
            display: block; width: 100%; padding: 10px; margin: 6px 0;
            background: rgba(60,80,120,0.4); border: 1px solid rgba(100,120,180,0.4);
            color: #90a0c0; cursor: pointer; border-radius: 6px; font-family: inherit;
        }
        #stats { position: fixed; top: 20px; right: 20px; font-size: 12px; color: #607090; z-index: 100; text-align: right; }
        #info { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); font-size: 12px; opacity: 0.5; z-index: 100; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="controls">
        <h3>Lunar Drift</h3>
        <div class="control-row">
            <label>Moth Count <span class="value" id="moth-val">40</span></label>
            <input type="range" id="moth" min="10" max="80" value="40">
        </div>
        <div class="control-row">
            <label>Trail Length <span class="value" id="trail-val">50</span></label>
            <input type="range" id="trail" min="10" max="100" value="50">
        </div>
        <button id="lamp-btn">Place Lamp (click canvas)</button>
        <button id="clear-btn">Clear Lamps</button>
    </div>
    <div id="stats">
        <div>Moths: <span id="moth-count">0</span></div>
        <div>Lamps: <span id="lamp-count">0</span></div>
    </div>
    <div id="info">Drag the moon | Click to place streetlamps | Watch moths spiral in confusion</div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let W, H;
        function resize() { W = canvas.width = innerWidth; H = canvas.height = innerHeight; }
        resize(); window.onresize = resize;
        
        let mothCount = 40;
        let trailLength = 50;
        let time = 0;
        let placingLamp = false;
        
        let moon = { x: W * 0.7, y: H * 0.3, radius: 40 };
        const lamps = [];
        const moths = [];
        
        class Moth {
            constructor() {
                this.x = Math.random() * W;
                this.y = Math.random() * H;
                this.angle = Math.random() * Math.PI * 2;
                this.speed = 1.5 + Math.random() * 1;
                this.size = 3 + Math.random() * 2;
                this.targetAngle = 0;
                this.trail = [];
                this.hue = 40 + Math.random() * 20;
                this.wingPhase = Math.random() * Math.PI * 2;
            }
            
            findStrongestLight() {
                let strongest = { x: moon.x, y: moon.y, strength: 1 };
                let maxStrength = 1 / (Math.hypot(this.x - moon.x, this.y - moon.y) + 50);
                
                lamps.forEach(lamp => {
                    const dist = Math.hypot(this.x - lamp.x, this.y - lamp.y);
                    const strength = lamp.brightness / (dist + 30);
                    if (strength > maxStrength) {
                        maxStrength = strength;
                        strongest = { x: lamp.x, y: lamp.y, strength: lamp.brightness };
                    }
                });
                
                return strongest;
            }
            
            update() {
                this.wingPhase += 0.3;
                
                const target = this.findStrongestLight();
                const dx = target.x - this.x;
                const dy = target.y - this.y;
                const dist = Math.hypot(dx, dy);
                
                const directAngle = Math.atan2(dy, dx);
                const offset = Math.PI / 4 + (target.strength > 0.5 ? 0.2 : 0);
                this.targetAngle = directAngle + offset;
                
                let angleDiff = this.targetAngle - this.angle;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                
                this.angle += angleDiff * 0.1;
                
                const speedMod = dist < 100 ? 1.5 : 1;
                this.x += Math.cos(this.angle) * this.speed * speedMod;
                this.y += Math.sin(this.angle) * this.speed * speedMod;
                
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > trailLength) this.trail.shift();
                
                if (this.x < 0) this.x = W;
                if (this.x > W) this.x = 0;
                if (this.y < 0) this.y = H;
                if (this.y > H) this.y = 0;
            }
            
            draw() {
                if (this.trail.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(this.trail[0].x, this.trail[0].y);
                    for (let i = 1; i < this.trail.length; i++) {
                        ctx.lineTo(this.trail[i].x, this.trail[i].y);
                    }
                    const gradient = ctx.createLinearGradient(
                        this.trail[0].x, this.trail[0].y,
                        this.x, this.y
                    );
                    gradient.addColorStop(0, 'transparent');
                    gradient.addColorStop(1, "hsla(" + this.hue + ", 50%, 60%, 0.3)");
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                const wingSpread = Math.sin(this.wingPhase) * 0.5 + 0.5;
                
                ctx.beginPath();
                ctx.ellipse(-this.size * 0.5, -this.size * wingSpread, this.size, this.size * 0.5, -0.3, 0, Math.PI * 2);
                ctx.fillStyle = "hsla(" + this.hue + ", 40%, 50%, 0.7)";
                ctx.fill();
                
                ctx.beginPath();
                ctx.ellipse(-this.size * 0.5, this.size * wingSpread, this.size, this.size * 0.5, 0.3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.beginPath();
                ctx.ellipse(0, 0, this.size * 0.8, this.size * 0.3, 0, 0, Math.PI * 2);
                ctx.fillStyle = "hsla(" + this.hue + ", 30%, 40%, 0.9)";
                ctx.fill();
                
                ctx.restore();
            }
        }
        
        class Lamp {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.brightness = 0.8;
                this.flicker = Math.random() * Math.PI * 2;
            }
            
            draw() {
                this.flicker += 0.1;
                const flick = 1 + Math.sin(this.flicker) * 0.05;
                
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, 80);
                gradient.addColorStop(0, "rgba(255, 200, 100, " + (0.4 * flick) + ")");
                gradient.addColorStop(0.3, "rgba(255, 180, 80, " + (0.2 * flick) + ")");
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.fillRect(this.x - 80, this.y - 80, 160, 160);
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, 8, 0, Math.PI * 2);
                ctx.fillStyle = "rgba(255, 220, 150, " + (0.9 * flick) + ")";
                ctx.fill();
                
                ctx.beginPath();
                ctx.moveTo(this.x, this.y + 8);
                ctx.lineTo(this.x, this.y + 40);
                ctx.strokeStyle = 'rgba(80, 60, 40, 0.8)';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
        }
        
        function initMoths() {
            moths.length = 0;
            for (let i = 0; i < mothCount; i++) {
                moths.push(new Moth());
            }
        }
        
        function drawBackground() {
            const gradient = ctx.createLinearGradient(0, 0, 0, H);
            gradient.addColorStop(0, '#0a0a18');
            gradient.addColorStop(1, '#151525');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, W, H);
            
            for (let i = 0; i < 100; i++) {
                const x = (i * 137 + time * 0.01) % W;
                const y = (i * 89) % H;
                const twinkle = Math.sin(time * 2 + i) * 0.3 + 0.7;
                ctx.beginPath();
                ctx.arc(x, y, 0.5 + twinkle * 0.5, 0, Math.PI * 2);
                ctx.fillStyle = "rgba(200, 220, 255, " + (twinkle * 0.5) + ")";
                ctx.fill();
            }
        }
        
        function drawMoon() {
            const gradient = ctx.createRadialGradient(moon.x, moon.y, 0, moon.x, moon.y, moon.radius * 3);
            gradient.addColorStop(0, 'rgba(255, 255, 220, 0.3)');
            gradient.addColorStop(0.3, 'rgba(200, 220, 255, 0.1)');
            gradient.addColorStop(1, 'transparent');
            ctx.fillStyle = gradient;
            ctx.fillRect(moon.x - moon.radius * 3, moon.y - moon.radius * 3, moon.radius * 6, moon.radius * 6);
            
            ctx.beginPath();
            ctx.arc(moon.x, moon.y, moon.radius, 0, Math.PI * 2);
            const moonGrad = ctx.createRadialGradient(
                moon.x - moon.radius * 0.3, moon.y - moon.radius * 0.3, 0,
                moon.x, moon.y, moon.radius
            );
            moonGrad.addColorStop(0, '#fffff0');
            moonGrad.addColorStop(0.8, '#e8e8d8');
            moonGrad.addColorStop(1, '#c0c0b0');
            ctx.fillStyle = moonGrad;
            ctx.fill();
            
            for (let i = 0; i < 5; i++) {
                const cx = moon.x + (Math.sin(i * 1.5) * moon.radius * 0.5);
                const cy = moon.y + (Math.cos(i * 2) * moon.radius * 0.4);
                ctx.beginPath();
                ctx.arc(cx, cy, 3 + i * 2, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(180, 180, 170, 0.3)';
                ctx.fill();
            }
        }
        
        function updateStats() {
            document.getElementById('moth-count').textContent = moths.length;
            document.getElementById('lamp-count').textContent = lamps.length;
        }
        
        function animate() {
            time += 0.016;
            
            drawBackground();
            drawMoon();
            lamps.forEach(l => l.draw());
            
            while (moths.length < mothCount) {
                moths.push(new Moth());
            }
            while (moths.length > mothCount) {
                moths.pop();
            }
            
            moths.forEach(m => {
                m.update();
                m.draw();
            });
            
            updateStats();
            
            requestAnimationFrame(animate);
        }
        
        let isDraggingMoon = false;
        
        canvas.onmousedown = e => {
            if (e.clientX < 200 && e.clientY < 250) return;
            
            const dist = Math.hypot(e.clientX - moon.x, e.clientY - moon.y);
            if (dist < moon.radius * 1.5) {
                isDraggingMoon = true;
                canvas.style.cursor = 'grabbing';
            } else if (placingLamp) {
                lamps.push(new Lamp(e.clientX, e.clientY));
            }
        };
        
        canvas.onmousemove = e => {
            if (isDraggingMoon) {
                moon.x = e.clientX;
                moon.y = e.clientY;
            }
        };
        
        canvas.onmouseup = () => {
            isDraggingMoon = false;
            canvas.style.cursor = 'grab';
        };
        
        document.getElementById('moth').oninput = e => {
            mothCount = parseInt(e.target.value);
            document.getElementById('moth-val').textContent = e.target.value;
        };
        
        document.getElementById('trail').oninput = e => {
            trailLength = parseInt(e.target.value);
            document.getElementById('trail-val').textContent = e.target.value;
        };
        
        document.getElementById('lamp-btn').onclick = () => {
            placingLamp = !placingLamp;
            document.getElementById('lamp-btn').textContent = placingLamp ? 
                'Placing Lamps... (click again to stop)' : 'Place Lamp (click canvas)';
        };
        
        document.getElementById('clear-btn').onclick = () => {
            lamps.length = 0;
        };
        
        initMoths();
        animate();
    </script>
</body>
</html>