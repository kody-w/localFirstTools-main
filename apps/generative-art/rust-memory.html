<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rust Memory</title>
    <meta name="description" content="Create memory artifacts that age and oxidize beautifully, watching polished moments transform through weathering into deep oxide patinas">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #1a1410; min-height: 100vh; font-family: 'Georgia', serif; color: #a08070; overflow: hidden; }
        #canvas { position: fixed; top: 0; left: 0; cursor: crosshair; }
        #controls {
            position: fixed; top: 20px; left: 20px; background: rgba(20,16,12,0.95);
            padding: 20px; border-radius: 10px; border: 1px solid rgba(180,120,80,0.3);
            z-index: 100;
        }
        h3 { margin-bottom: 15px; color: #c09070; font-weight: normal; }
        .control-row { margin: 10px 0; }
        label { display: block; font-size: 11px; margin-bottom: 5px; opacity: 0.8; }
        input[type="range"] { width: 140px; }
        .value { float: right; color: #d0a080; font-size: 12px; }
        button {
            display: block; width: 100%; padding: 10px; margin: 6px 0;
            background: rgba(120,80,50,0.4); border: 1px solid rgba(180,120,80,0.4);
            color: #a08060; cursor: pointer; border-radius: 6px; font-family: inherit;
        }
        #stats { position: fixed; top: 20px; right: 20px; font-size: 12px; color: #806050; z-index: 100; text-align: right; }
        #info { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); font-size: 12px; opacity: 0.5; z-index: 100; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="controls">
        <h3>Rust Memory</h3>
        <div class="control-row">
            <label>Oxidation Rate <span class="value" id="oxide-val">50</span></label>
            <input type="range" id="oxide" min="10" max="100" value="50">
        </div>
        <div class="control-row">
            <label>Memory Size <span class="value" id="size-val">40</span></label>
            <input type="range" id="size" min="20" max="80" value="40">
        </div>
        <button id="weather-btn">Weather All</button>
        <button id="polish-btn">Polish All</button>
        <button id="clear-btn">Clear Memories</button>
    </div>
    <div id="stats">
        <div>Memories: <span id="memory-count">0</span></div>
        <div>Oldest: <span id="oldest-age">0</span>s</div>
    </div>
    <div id="info">Click to forge new memories | Watch them oxidize with time</div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let W, H;
        function resize() { W = canvas.width = innerWidth; H = canvas.height = innerHeight; }
        resize(); window.onresize = resize;
        
        let oxidationRate = 0.5;
        let memorySize = 40;
        let time = 0;
        
        const memories = [];
        const particles = [];
        
        const RUST_STAGES = [
            { age: 0, colors: ['#c0c0c0', '#d0d0d0', '#b0b0b0'], name: 'Polished Steel' },
            { age: 5, colors: ['#b0a090', '#c0b0a0', '#a09080'], name: 'Tarnished' },
            { age: 15, colors: ['#a07050', '#b08060', '#906040'], name: 'Early Oxidation' },
            { age: 30, colors: ['#804020', '#905030', '#703010'], name: 'Deep Rust' },
            { age: 60, colors: ['#602010', '#501808', '#401005'], name: 'Ancient Patina' }
        ];
        
        class Memory {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.baseSize = memorySize;
                this.age = 0;
                this.shape = this.generateShape();
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.001;
                this.rustPatches = [];
                this.initRustPatches();
            }
            
            generateShape() {
                const points = [];
                const sides = 5 + Math.floor(Math.random() * 4);
                for (let i = 0; i < sides; i++) {
                    const angle = (i / sides) * Math.PI * 2;
                    const r = 0.7 + Math.random() * 0.3;
                    points.push({
                        angle: angle,
                        radius: r
                    });
                }
                return points;
            }
            
            initRustPatches() {
                const count = 5 + Math.floor(Math.random() * 10);
                for (let i = 0; i < count; i++) {
                    this.rustPatches.push({
                        x: (Math.random() - 0.5) * 0.8,
                        y: (Math.random() - 0.5) * 0.8,
                        size: 0.1 + Math.random() * 0.2,
                        intensity: 0,
                        growthRate: 0.5 + Math.random() * 0.5
                    });
                }
            }
            
            getStage() {
                let currentStage = RUST_STAGES[0];
                for (const stage of RUST_STAGES) {
                    if (this.age >= stage.age) {
                        currentStage = stage;
                    }
                }
                return currentStage;
            }
            
            update() {
                this.age += 0.016 * oxidationRate;
                this.rotation += this.rotationSpeed;
                
                this.rustPatches.forEach(patch => {
                    const targetIntensity = Math.min(1, this.age / 60);
                    patch.intensity += (targetIntensity - patch.intensity) * 0.01 * patch.growthRate;
                    patch.size += 0.0001 * oxidationRate * patch.growthRate;
                });
                
                if (Math.random() < 0.01 * oxidationRate && this.age > 10) {
                    particles.push({
                        x: this.x + (Math.random() - 0.5) * this.baseSize,
                        y: this.y + (Math.random() - 0.5) * this.baseSize,
                        vx: (Math.random() - 0.5) * 0.5,
                        vy: Math.random() * 0.5,
                        size: 1 + Math.random() * 2,
                        life: 1,
                        color: this.getStage().colors[0]
                    });
                }
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                const stage = this.getStage();
                const size = this.baseSize;
                
                ctx.beginPath();
                this.shape.forEach((point, i) => {
                    const px = Math.cos(point.angle) * point.radius * size;
                    const py = Math.sin(point.angle) * point.radius * size;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                });
                ctx.closePath();
                
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
                gradient.addColorStop(0, stage.colors[1]);
                gradient.addColorStop(0.5, stage.colors[0]);
                gradient.addColorStop(1, stage.colors[2]);
                ctx.fillStyle = gradient;
                ctx.fill();
                
                ctx.strokeStyle = stage.colors[2];
                ctx.lineWidth = 2;
                ctx.stroke();
                
                this.rustPatches.forEach(patch => {
                    if (patch.intensity > 0.1) {
                        const px = patch.x * size;
                        const py = patch.y * size;
                        const patchSize = patch.size * size * patch.intensity;
                        
                        const rustGradient = ctx.createRadialGradient(px, py, 0, px, py, patchSize);
                        const rustColor = "rgba(80, 30, 10, " + (patch.intensity * 0.7) + ")";
                        rustGradient.addColorStop(0, rustColor);
                        rustGradient.addColorStop(1, 'transparent');
                        ctx.fillStyle = rustGradient;
                        ctx.fillRect(px - patchSize, py - patchSize, patchSize * 2, patchSize * 2);
                    }
                });
                
                if (this.age < 5) {
                    const shimmer = Math.sin(time * 3) * 0.1 + 0.1;
                    ctx.fillStyle = "rgba(255, 255, 255, " + (shimmer * (1 - this.age / 5)) + ")";
                    ctx.beginPath();
                    ctx.arc(-size * 0.3, -size * 0.3, size * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
            
            containsPoint(px, py) {
                const dx = px - this.x;
                const dy = py - this.y;
                return Math.hypot(dx, dy) < this.baseSize;
            }
        }
        
        function drawBackground() {
            const gradient = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, Math.max(W, H) * 0.7);
            gradient.addColorStop(0, '#2a1f18');
            gradient.addColorStop(1, '#1a1410');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, W, H);
            
            for (let i = 0; i < 30; i++) {
                const x = (i * 137 + time * 0.1) % W;
                const y = (i * 89) % H;
                ctx.beginPath();
                ctx.arc(x, y, 0.5, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(100, 70, 50, 0.3)';
                ctx.fill();
            }
        }
        
        function drawParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.02;
                p.life -= 0.02;
                
                if (p.life <= 0) {
                    particles.splice(i, 1);
                    continue;
                }
                
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                ctx.fillStyle = p.color.replace(')', ", " + p.life + ")").replace('rgb', 'rgba');
                ctx.fill();
            }
        }
        
        function updateStats() {
            document.getElementById('memory-count').textContent = memories.length;
            
            let oldest = 0;
            memories.forEach(m => {
                if (m.age > oldest) oldest = m.age;
            });
            document.getElementById('oldest-age').textContent = oldest.toFixed(0);
        }
        
        function animate() {
            time += 0.016;
            
            drawBackground();
            
            memories.forEach(m => {
                m.update();
                m.draw();
            });
            
            drawParticles();
            updateStats();
            
            requestAnimationFrame(animate);
        }
        
        canvas.onclick = e => {
            if (e.clientX < 200 && e.clientY < 250) return;
            
            let clickedMemory = null;
            memories.forEach(m => {
                if (m.containsPoint(e.clientX, e.clientY)) {
                    clickedMemory = m;
                }
            });
            
            if (clickedMemory) {
                clickedMemory.age += 10;
                for (let i = 0; i < 10; i++) {
                    particles.push({
                        x: clickedMemory.x + (Math.random() - 0.5) * clickedMemory.baseSize,
                        y: clickedMemory.y + (Math.random() - 0.5) * clickedMemory.baseSize,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        size: 2 + Math.random() * 2,
                        life: 1,
                        color: clickedMemory.getStage().colors[0]
                    });
                }
            } else {
                memories.push(new Memory(e.clientX, e.clientY));
            }
        };
        
        document.getElementById('oxide').oninput = e => {
            oxidationRate = e.target.value / 100;
            document.getElementById('oxide-val').textContent = e.target.value;
        };
        
        document.getElementById('size').oninput = e => {
            memorySize = parseInt(e.target.value);
            document.getElementById('size-val').textContent = e.target.value;
        };
        
        document.getElementById('weather-btn').onclick = () => {
            memories.forEach(m => {
                m.age += 20;
            });
        };
        
        document.getElementById('polish-btn').onclick = () => {
            memories.forEach(m => {
                m.age = Math.max(0, m.age - 15);
                m.rustPatches.forEach(patch => {
                    patch.intensity *= 0.5;
                    patch.size *= 0.8;
                });
            });
        };
        
        document.getElementById('clear-btn').onclick = () => {
            memories.length = 0;
            particles.length = 0;
        };
        
        animate();
    </script>
</body>
</html>