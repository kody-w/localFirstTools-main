<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Cosmos Arena</title>
    <meta name="description" content="Creatures with neural network brains fight across a procedurally generated solar system with realistic n-body physics. A fusion of particle physics, neural evolution, 3D rendering, and combat systems.">
    <meta name="theme-color" content="#000510">
    <meta name="color-scheme" content="dark">
    <!-- frankenstein-fusion, neural-network, physics-simulation, combat, 3d, evolution -->
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            height: 100vh;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .panel {
            pointer-events: auto;
            background: rgba(0, 10, 30, 0.85);
            border: 1px solid rgba(0, 200, 255, 0.3);
            border-radius: 12px;
            padding: 15px;
            backdrop-filter: blur(10px);
        }

        #stats-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            min-width: 220px;
        }

        #controls-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
        }

        #evolution-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            gap: 20px;
            justify-content: center;
        }

        .panel h2 {
            font-size: 14px;
            color: #00d4ff;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 12px;
            border-bottom: 1px solid rgba(0, 200, 255, 0.2);
            padding-bottom: 8px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .stat-label { color: rgba(255,255,255,0.6); }
        .stat-value { color: #00ff88; font-weight: bold; }
        .stat-value.warning { color: #ffaa00; }
        .stat-value.danger { color: #ff4466; }

        .creature-card {
            background: rgba(0, 50, 100, 0.3);
            border-radius: 8px;
            padding: 12px;
            min-width: 150px;
            text-align: center;
        }

        .creature-card .name {
            font-size: 12px;
            color: #00d4ff;
            margin-bottom: 8px;
        }

        .creature-card .brain-viz {
            display: flex;
            justify-content: center;
            gap: 3px;
            margin-bottom: 8px;
        }

        .neuron {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #00ff88;
            opacity: 0.3;
            transition: opacity 0.1s;
        }

        .neuron.active { opacity: 1; box-shadow: 0 0 6px #00ff88; }

        .creature-card .stats {
            font-size: 11px;
            color: rgba(255,255,255,0.7);
        }

        button {
            width: 100%;
            padding: 10px;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #00d4ff 0%, #0088aa 100%);
            color: #fff;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.4);
        }

        button.danger {
            background: linear-gradient(135deg, #ff4466 0%, #aa2244 100%);
        }

        button.success {
            background: linear-gradient(135deg, #00ff88 0%, #00aa55 100%);
        }

        .slider-group {
            margin-bottom: 12px;
        }

        .slider-group label {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: rgba(255,255,255,0.6);
            margin-bottom: 4px;
        }

        .slider-group input[type="range"] {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: rgba(255,255,255,0.1);
            -webkit-appearance: none;
        }

        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #00d4ff;
            cursor: pointer;
        }

        #title-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: auto;
        }

        #title-overlay h1 {
            font-size: 64px;
            background: linear-gradient(180deg, #00ffff, #ff00ff, #ffff00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 20px;
            text-shadow: 0 0 60px rgba(0, 255, 255, 0.5);
        }

        #title-overlay p {
            font-size: 18px;
            color: rgba(255,255,255,0.7);
            margin-bottom: 30px;
            max-width: 600px;
        }

        .hidden { display: none !important; }

        #combat-log {
            position: absolute;
            bottom: 120px;
            right: 20px;
            width: 280px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 11px;
        }

        .log-entry {
            padding: 4px 8px;
            margin-bottom: 2px;
            border-radius: 4px;
            background: rgba(0, 100, 150, 0.3);
        }

        .log-entry.kill { background: rgba(255, 50, 100, 0.3); }
        .log-entry.evolve { background: rgba(0, 255, 100, 0.3); }
        .log-entry.spawn { background: rgba(100, 100, 255, 0.3); }

        /* CYCLE 2: Pause overlay and toast system */
        #pause-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            color: rgba(255, 255, 255, 0.8);
            text-shadow: 0 0 30px rgba(0, 212, 255, 0.8);
            letter-spacing: 8px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        #pause-overlay.visible { opacity: 1; }

        #toast-container {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: none;
            z-index: 200;
        }
        .toast {
            background: rgba(0, 212, 255, 0.9);
            color: #000;
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 8px;
            animation: toastIn 0.3s ease-out, toastOut 0.3s ease-in 1.7s forwards;
        }
        @keyframes toastIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes toastOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div id="ui-overlay">
        <!-- Title Screen -->
        <div id="title-overlay">
            <h1>NEURAL COSMOS ARENA</h1>
            <p>Creatures with neural network brains evolve and fight across a procedurally generated solar system with realistic n-body physics.</p>
            <button onclick="startSimulation()" style="width:auto;padding:15px 40px;font-size:16px;">BEGIN EVOLUTION</button>
        </div>

        <!-- Stats Panel -->
        <div id="stats-panel" class="panel hidden" role="region" aria-label="Simulation statistics">
            <h2 id="stats-heading">Cosmos Statistics</h2>
            <div class="stat-row" role="group" aria-labelledby="stats-heading">
                <span class="stat-label" id="gen-label">Generation</span>
                <span class="stat-value" id="stat-generation" aria-labelledby="gen-label">1</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Population</span>
                <span class="stat-value" id="stat-population">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Battles</span>
                <span class="stat-value" id="stat-battles">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Projectiles</span>
                <span class="stat-value" id="stat-projectiles">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Best Fitness</span>
                <span class="stat-value" id="stat-fitness">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">FPS</span>
                <span class="stat-value" id="stat-fps">60</span>
            </div>
        </div>

        <!-- Controls Panel -->
        <div id="controls-panel" class="panel hidden" role="region" aria-label="Simulation controls">
            <h2 id="controls-heading">Controls</h2>
            <div class="keyboard-hint" style="font-size:10px;color:rgba(255,255,255,0.4);margin-bottom:10px;">
                Space=Pause | S=Spawn | N=Planet | O=Orbits | C=Champion | Shift+E=Extinction
            </div>
            <div class="slider-group">
                <label>Time Scale <span id="val-timescale">1.0</span>x</label>
                <input type="range" id="timescale" min="0.1" max="3" step="0.1" value="1">
            </div>
            <div class="slider-group">
                <label>Gravity <span id="val-gravity">1.0</span></label>
                <input type="range" id="gravity" min="0.1" max="3" step="0.1" value="1">
            </div>
            <div class="slider-group">
                <label>Mutation Rate <span id="val-mutation">0.1</span></label>
                <input type="range" id="mutation" min="0.01" max="0.5" step="0.01" value="0.1">
            </div>
            <button onclick="spawnWave()" class="success" aria-label="Spawn new wave of creatures">Spawn Wave</button>
            <button onclick="triggerMassExtinction()" class="danger" aria-label="Trigger mass extinction event">Mass Extinction</button>
            <button onclick="toggleOrbits()" aria-label="Toggle orbital path visibility">Toggle Orbits</button>
            <button onclick="focusNextPlanet()" aria-label="Focus camera on next planet">Next Planet</button>
            <button onclick="focusChampion()" aria-label="Focus camera on champion creature">Focus Champion</button>
        </div>

        <!-- Evolution Panel -->
        <div id="evolution-panel" class="hidden" role="region" aria-label="Evolution statistics" aria-live="polite">
            <div class="creature-card" id="champion-card">
                <div class="name">CHAMPION</div>
                <div class="brain-viz" id="champion-brain"></div>
                <div class="stats">
                    <div>Fitness: <span id="champion-fitness">0</span></div>
                    <div>Kills: <span id="champion-kills">0</span></div>
                </div>
            </div>
            <div class="creature-card" id="species-card">
                <div class="name">SPECIES COUNT</div>
                <div class="stats" style="font-size:24px;color:#00ff88;" id="species-count">0</div>
                <div class="stats">unique neural patterns</div>
            </div>
            <div class="creature-card" id="combat-card">
                <div class="name">ACTIVE COMBAT</div>
                <div class="stats" style="font-size:24px;color:#ff4466;" id="active-combat">0</div>
                <div class="stats">ongoing battles</div>
            </div>
        </div>

        <!-- Combat Log -->
        <div id="combat-log" class="panel hidden" role="log" aria-label="Combat event log" aria-live="polite">
            <h2>Combat Log</h2>
            <div id="log-entries"></div>
        </div>

        <!-- CYCLE 2: Pause Overlay -->
        <div id="pause-overlay">PAUSED</div>

        <!-- CYCLE 2: Toast Container -->
        <div id="toast-container"></div>
    </div>

    <script>
        // ═══════════════════════════════════════════════════════════════════════════
        // NEURAL COSMOS ARENA - Frankenstein Fusion
        // Combining: Physics Engine + Neural Networks + 3D Renderer + Combat System
        // ═══════════════════════════════════════════════════════════════════════════

        // ─────────────────────────────────────────────────────────────────────────────
        // THREE.JS SETUP (from procedural-solar-system)
        // ─────────────────────────────────────────────────────────────────────────────
        const THREE_CDN = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
        const ORBIT_CDN = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js';

        // ─────────────────────────────────────────────────────────────────────────────
        // CYCLE 6: CONFIG - Centralized tuning constants
        // ─────────────────────────────────────────────────────────────────────────────
        const CONFIG = {
            // Physics
            gravity: {
                creatureScale: 1.0,
                projectileScale: 0.5,
                maxDistance: 300  // CYCLE 6: Skip gravity from bodies beyond this distance
            },
            // Combat
            combat: {
                fireRate: 0.5,
                baseDamage: 15,
                projectileSpeed: 30,
                fireEnergyCost: 10,
                boostEnergyCost: 20,
                fireThreshold: 0.6,
                boostThreshold: 0.7,
                targetRange: 100
            },
            // Creature
            creature: {
                thrustPower: 15,
                maxHealth: 100,
                maxEnergy: 100,
                energyRegen: 5,
                velocityDrag: 0.995
            },
            // World
            world: {
                bounds: 500,
                spawnPerPlanet: 5
            },
            // Neural
            neural: {
                inputSize: 12,
                hiddenSize: 16,
                outputSize: 6,
                defaultMutationRate: 0.1
            },
            // CYCLE 11: Centralized team configuration
            teams: [
                { color: 0x00ff88, name: 'Green' },
                { color: 0xff4466, name: 'Red' },
                { color: 0x4488ff, name: 'Blue' }
            ]
        };

        let THREE, scene, camera, renderer, controls;
        let simulationRunning = false;

        // ─────────────────────────────────────────────────────────────────────────────
        // NEURAL NETWORK (from ecosystem-city)
        // ─────────────────────────────────────────────────────────────────────────────
        class NeuralNetwork {
            constructor(inputSize, hiddenSize, outputSize) {
                this.inputSize = inputSize;
                this.hiddenSize = hiddenSize;
                this.outputSize = outputSize;
                this.weightsIH = this.randomMatrix(hiddenSize, inputSize);
                this.weightsHO = this.randomMatrix(outputSize, hiddenSize);
                this.biasH = this.randomArray(hiddenSize);
                this.biasO = this.randomArray(outputSize);
                // CYCLE 8: Pre-allocate buffers to avoid per-frame array creation
                this._hiddenBuffer = new Array(hiddenSize).fill(0);
                this._outputBuffer = new Array(outputSize).fill(0);
                // CYCLE 9 FIX: Separate buffer for UI visualization (avoids aliasing bug)
                this._lastHiddenBuffer = new Array(hiddenSize).fill(0);
                this.lastHiddenActivation = this._lastHiddenBuffer;
            }

            randomMatrix(rows, cols) {
                return Array.from({ length: rows }, () =>
                    Array.from({ length: cols }, () => Math.random() * 2 - 1)
                );
            }

            randomArray(size) {
                return Array.from({ length: size }, () => Math.random() * 2 - 1);
            }

            sigmoid(x) { return 1 / (1 + Math.exp(-Math.max(-10, Math.min(10, x)))); }
            tanh(x) { return Math.tanh(x); }

            forward(inputs) {
                // CYCLE 8: Use pre-allocated buffers instead of map() to avoid GC pressure
                const hidden = this._hiddenBuffer;
                for (let i = 0; i < this.hiddenSize; i++) {
                    let sum = this.biasH[i];
                    for (let j = 0; j < inputs.length; j++) {
                        sum += inputs[j] * this.weightsIH[i][j];
                    }
                    hidden[i] = this.tanh(sum);
                }
                // CYCLE 9 FIX: Copy values to separate buffer for UI (avoids race condition)
                for (let i = 0; i < this.hiddenSize; i++) {
                    this._lastHiddenBuffer[i] = hidden[i];
                }

                const outputs = this._outputBuffer;
                for (let i = 0; i < this.outputSize; i++) {
                    let sum = this.biasO[i];
                    for (let j = 0; j < this.hiddenSize; j++) {
                        sum += hidden[j] * this.weightsHO[i][j];
                    }
                    outputs[i] = this.sigmoid(sum);
                }
                return outputs;
            }

            // CYCLE 11: In-place mutation to reduce GC pressure (no array allocations)
            mutate(rate = 0.1) {
                // Mutate weightsIH in-place
                for (let i = 0; i < this.weightsIH.length; i++) {
                    const row = this.weightsIH[i];
                    for (let j = 0; j < row.length; j++) {
                        if (Math.random() < rate) {
                            row[j] += (Math.random() - 0.5) * 0.5;
                        }
                    }
                }
                // Mutate weightsHO in-place
                for (let i = 0; i < this.weightsHO.length; i++) {
                    const row = this.weightsHO[i];
                    for (let j = 0; j < row.length; j++) {
                        if (Math.random() < rate) {
                            row[j] += (Math.random() - 0.5) * 0.5;
                        }
                    }
                }
                // Mutate biases in-place
                for (let i = 0; i < this.biasH.length; i++) {
                    if (Math.random() < rate) {
                        this.biasH[i] += (Math.random() - 0.5) * 0.5;
                    }
                }
                for (let i = 0; i < this.biasO.length; i++) {
                    if (Math.random() < rate) {
                        this.biasO[i] += (Math.random() - 0.5) * 0.5;
                    }
                }
            }

            clone() {
                const nn = new NeuralNetwork(this.inputSize, this.hiddenSize, this.outputSize);
                nn.weightsIH = this.weightsIH.map(r => [...r]);
                nn.weightsHO = this.weightsHO.map(r => [...r]);
                nn.biasH = [...this.biasH];
                nn.biasO = [...this.biasO];
                return nn;
            }

            static crossover(p1, p2) {
                const child = new NeuralNetwork(p1.inputSize, p1.hiddenSize, p1.outputSize);
                for (let i = 0; i < child.weightsIH.length; i++) {
                    for (let j = 0; j < child.weightsIH[i].length; j++) {
                        child.weightsIH[i][j] = Math.random() < 0.5 ? p1.weightsIH[i][j] : p2.weightsIH[i][j];
                    }
                }
                for (let i = 0; i < child.weightsHO.length; i++) {
                    for (let j = 0; j < child.weightsHO[i].length; j++) {
                        child.weightsHO[i][j] = Math.random() < 0.5 ? p1.weightsHO[i][j] : p2.weightsHO[i][j];
                    }
                }
                child.biasH = child.biasH.map((_, i) => Math.random() < 0.5 ? p1.biasH[i] : p2.biasH[i]);
                child.biasO = child.biasO.map((_, i) => Math.random() < 0.5 ? p1.biasO[i] : p2.biasO[i]);
                return child;
            }

            getFingerprint() {
                // Create a rough "species" fingerprint based on weight signs
                return this.weightsIH.flat().slice(0, 10).map(w => w > 0 ? '1' : '0').join('');
            }
        }

        // ─────────────────────────────────────────────────────────────────────────────
        // SPATIAL INDEX - O(n log n) nearest-entity search (CYCLE 1 + CYCLE 4 IMPROVEMENT)
        // ─────────────────────────────────────────────────────────────────────────────
        class SpatialIndex {
            constructor(cellSize = 50) {
                this.cellSize = cellSize;
                this.cells = new Map();
                this.maxRange = 10; // CYCLE 4: Cap cell range to prevent O(n³) explosion
            }

            getKey(pos) {
                return `${Math.floor(pos.x / this.cellSize)},${Math.floor(pos.y / this.cellSize)},${Math.floor(pos.z / this.cellSize)}`;
            }

            update(entities) {
                this.cells.clear();
                for (const e of entities) {
                    if (!e.isAlive && e.isAlive !== undefined) continue;
                    const key = this.getKey(e.physics.position);
                    if (!this.cells.has(key)) this.cells.set(key, []);
                    this.cells.get(key).push(e);
                }
            }

            // CYCLE 4: Added filterByDistance parameter to do actual radius check
            getNearby(pos, radius = 100, filterByDistance = false) {
                const results = [];
                // CYCLE 4: Cap range to prevent infinite loop
                const range = Math.min(Math.ceil(radius / this.cellSize), this.maxRange);
                const cx = Math.floor(pos.x / this.cellSize);
                const cy = Math.floor(pos.y / this.cellSize);
                const cz = Math.floor(pos.z / this.cellSize);
                const radiusSq = radius * radius; // For distance filtering

                for (let dx = -range; dx <= range; dx++) {
                    for (let dy = -range; dy <= range; dy++) {
                        for (let dz = -range; dz <= range; dz++) {
                            const cell = this.cells.get(`${cx + dx},${cy + dy},${cz + dz}`);
                            if (cell) {
                                if (filterByDistance) {
                                    // CYCLE 4 + CYCLE 5: Filter by distance with fixed variable names
                                    for (const e of cell) {
                                        // CYCLE 5 FIX: Renamed to avoid shadowing outer dx/dy/dz loop vars
                                        const ex = e.physics.position.x - pos.x;
                                        const ey = e.physics.position.y - pos.y;
                                        const ez = e.physics.position.z - pos.z;
                                        if (ex*ex + ey*ey + ez*ez <= radiusSq) {
                                            results.push(e);
                                        }
                                    }
                                } else {
                                    results.push(...cell);
                                }
                            }
                        }
                    }
                }
                return results;
            }

            findNearest(pos, entities, predicate) {
                const nearby = this.getNearby(pos, 150);
                let nearest = null;
                let nearestDist = Infinity;

                for (const e of nearby) {
                    if (!predicate(e)) continue;
                    const d = pos.distanceTo(e.physics.position);
                    if (d < nearestDist) {
                        nearestDist = d;
                        nearest = e;
                    }
                }
                return { entity: nearest, distance: nearestDist };
            }
        }

        const spatialIndex = new SpatialIndex(50);

        // ─────────────────────────────────────────────────────────────────────────────
        // VECTOR POOL - Eliminates GC pressure (CYCLE 2 + CYCLE 3 + CYCLE 4 IMPROVEMENT)
        // ─────────────────────────────────────────────────────────────────────────────
        const VectorPool = {
            pool: [],
            index: 0,
            initialSize: 500, // CYCLE 3: Increased from 200
            maxPoolSize: 2000, // CYCLE 4: Cap to prevent unbounded growth

            init(size = 500) {
                // Will be called after THREE.js loads
            },

            initWithThree() {
                if (this.pool.length === 0) {
                    for (let i = 0; i < this.initialSize; i++) {
                        this.pool.push(new THREE.Vector3());
                    }
                }
            },

            get() {
                if (this.index >= this.pool.length) {
                    // CYCLE 4: Respect maxPoolSize cap
                    if (this.pool.length >= this.maxPoolSize) {
                        // CYCLE 5 FIX: Create new vector instead of wrapping (prevents data corruption)
                        // CYCLE 6: Log warning for monitoring - helps identify if maxPoolSize needs increase
                        if (!this._overflowWarned) {
                            console.warn(`VectorPool overflow: creating new vectors beyond max ${this.maxPoolSize}. Consider increasing maxPoolSize.`);
                            this._overflowWarned = true;
                        }
                        return new THREE.Vector3();
                    }
                    // CYCLE 3: Exponential growth instead of linear (+1)
                    const growSize = Math.min(
                        Math.max(100, Math.floor(this.pool.length * 0.5)),
                        this.maxPoolSize - this.pool.length
                    );
                    for (let i = 0; i < growSize; i++) {
                        this.pool.push(new THREE.Vector3());
                    }
                }
                return this.pool[this.index++].set(0, 0, 0);
            },

            reset() {
                this.index = 0;
                this._overflowWarned = false; // CYCLE 7: Reset to detect repeated overflows
            }
        };

        // ─────────────────────────────────────────────────────────────────────────────
        // PHYSICS ENGINE (from particle-sandbox)
        // ─────────────────────────────────────────────────────────────────────────────
        class PhysicsBody {
            constructor(mass, position, velocity) {
                this.mass = mass;
                this.position = position.clone();
                this.velocity = velocity ? velocity.clone() : new THREE.Vector3();
                this.acceleration = new THREE.Vector3();
                this.forces = new THREE.Vector3();
            }

            applyForce(force) {
                this.forces.add(force);
            }

            integrate(dt) {
                // F = ma, a = F/m
                this.acceleration.copy(this.forces).divideScalar(this.mass);
                this.velocity.addScaledVector(this.acceleration, dt);
                this.position.addScaledVector(this.velocity, dt);
                this.forces.set(0, 0, 0);
            }

            // CYCLE 14: Use VectorPool to eliminate 400+ allocations per frame
            applyGravityFrom(other, G = 1) {
                const dir = VectorPool.get().subVectors(other.position, this.position);
                const distSq = Math.max(dir.lengthSq(), 1); // Prevent singularity
                const forceMag = G * this.mass * other.mass / distSq;
                dir.normalize().multiplyScalar(forceMag);
                this.applyForce(dir);
            }
        }

        // ─────────────────────────────────────────────────────────────────────────────
        // COMBAT SYSTEM (from apex-protocol)
        // ─────────────────────────────────────────────────────────────────────────────
        class Projectile {
            constructor(position, velocity, damage, owner, color) {
                this.physics = new PhysicsBody(0.1, position, velocity);
                this.damage = damage;
                this.owner = owner;
                this.color = color;
                this.lifetime = 5;
                this.mesh = null;
            }

            createMesh() {
                const geo = new THREE.SphereGeometry(0.3, 8, 8);
                const mat = new THREE.MeshBasicMaterial({
                    color: this.color,
                    transparent: true,
                    opacity: 0.9
                });
                this.mesh = new THREE.Mesh(geo, mat);
                this.mesh.position.copy(this.physics.position);

                // Trail
                const trailGeo = new THREE.CylinderGeometry(0.1, 0.3, 2, 8);
                const trailMat = new THREE.MeshBasicMaterial({
                    color: this.color,
                    transparent: true,
                    opacity: 0.4
                });
                const trail = new THREE.Mesh(trailGeo, trailMat);
                trail.rotation.x = Math.PI / 2;
                trail.position.z = -1;
                this.mesh.add(trail);

                // CYCLE 10: Store references for disposal
                this._geometries = [geo, trailGeo];
                this._materials = [mat, trailMat];

                return this.mesh;
            }

            // CYCLE 10: Dispose GPU resources to prevent memory leaks
            disposeMesh() {
                if (this._geometries) {
                    for (const geo of this._geometries) geo.dispose();
                    this._geometries = null;
                }
                if (this._materials) {
                    for (const mat of this._materials) mat.dispose();
                    this._materials = null;
                }
            }

            update(dt, celestialBodies, gravityScale) {
                // CYCLE 6 + CYCLE 7: Apply gravity only from nearby bodies (squared distance avoids sqrt)
                const maxDistSq = CONFIG.gravity.maxDistance * CONFIG.gravity.maxDistance;
                for (const body of celestialBodies) {
                    const dx = body.physics.position.x - this.physics.position.x;
                    const dy = body.physics.position.y - this.physics.position.y;
                    const dz = body.physics.position.z - this.physics.position.z;
                    if (dx*dx + dy*dy + dz*dz < maxDistSq) {
                        this.physics.applyGravityFrom(body.physics, CONFIG.gravity.projectileScale * gravityScale);
                    }
                }
                this.physics.integrate(dt);
                if (this.mesh) {
                    this.mesh.position.copy(this.physics.position);
                    this.mesh.lookAt(this.physics.position.clone().add(this.physics.velocity));
                }
                this.lifetime -= dt;
                return this.lifetime > 0;
            }
        }

        // ─────────────────────────────────────────────────────────────────────────────
        // CREATURE - Neural-brained entity (fusion of all systems)
        // ─────────────────────────────────────────────────────────────────────────────
        class Creature {
            constructor(position, team = 0) {
                this.physics = new PhysicsBody(1, position, new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                ));

                // Neural brain: 12 inputs, 16 hidden, 6 outputs
                // Inputs: relative positions of nearest enemy, nearest ally, nearest planet, velocity, health
                // Outputs: thrust x/y/z, fire, turn, special
                this.brain = new NeuralNetwork(12, 16, 6);

                this.health = 100;
                this.maxHealth = 100;
                this.energy = 100;
                this.maxEnergy = 100;

                this.fitness = 0;
                this.kills = 0;
                this.damageDealt = 0;
                this.survivalTime = 0;
                this.team = team;
                this.generation = 1;

                this.fireCooldown = 0;
                this.fireRate = 0.5; // seconds between shots
                this.damage = 15;
                this.projectileSpeed = 30;

                this.mesh = null;
                this.teamColor = CONFIG.teams[team]?.color ?? 0x4488ff;  // CYCLE 11: Use centralized config

                this.homePlanet = null;
                this.isAlive = true;

                // CYCLE 8: Hit flash effect
                this.hitFlashTime = 0;
                this.bodyMaterial = null; // Reference to body mesh material

                // CYCLE 9: Pre-allocate reusable vectors to avoid per-frame allocations
                this._thrustVector = new THREE.Vector3();
                this._lookAtVector = new THREE.Vector3();

                // CYCLE 12: Pre-allocate input buffer for neural network to avoid per-frame array allocation
                this._inputBuffer = new Array(12).fill(0);
            }

            createMesh() {
                const group = new THREE.Group();

                // Body
                const bodyGeo = new THREE.IcosahedronGeometry(0.8, 1);
                const bodyMat = new THREE.MeshStandardMaterial({
                    color: this.teamColor,
                    metalness: 0.7,
                    roughness: 0.3,
                    emissive: this.teamColor,
                    emissiveIntensity: 0.2
                });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                this.bodyMaterial = bodyMat; // CYCLE 8: Store ref for hit flash
                group.add(body);

                // Eye/sensor
                const eyeGeo = new THREE.SphereGeometry(0.25, 16, 16);
                const eyeMat = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    emissive: 0xffffff
                });
                const eye = new THREE.Mesh(eyeGeo, eyeMat);
                eye.position.set(0, 0, 0.7);
                group.add(eye);

                // Thrusters
                for (let i = 0; i < 3; i++) {
                    const thrustGeo = new THREE.ConeGeometry(0.2, 0.5, 8);
                    const thrustMat = new THREE.MeshBasicMaterial({
                        color: 0xff6600,
                        transparent: true,
                        opacity: 0.6
                    });
                    const thruster = new THREE.Mesh(thrustGeo, thrustMat);
                    thruster.rotation.x = Math.PI;
                    thruster.position.set(
                        Math.cos(i * Math.PI * 2 / 3) * 0.5,
                        -0.6,
                        Math.sin(i * Math.PI * 2 / 3) * 0.5
                    );
                    thruster.visible = false;
                    thruster.name = 'thruster';
                    group.add(thruster);
                }

                // Health bar
                const healthGeo = new THREE.PlaneGeometry(1.5, 0.15);
                const healthMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                const healthBar = new THREE.Mesh(healthGeo, healthMat);
                healthBar.position.y = 1.3;
                healthBar.name = 'healthBar';
                group.add(healthBar);

                // CYCLE 11: Store references for GPU disposal
                this._geometries = [bodyGeo, eyeGeo, healthGeo];
                this._materials = [bodyMat, eyeMat, healthMat];
                // Collect thruster geometries/materials from children
                group.traverse(child => {
                    if (child.name === 'thruster' && child.geometry && child.material) {
                        this._geometries.push(child.geometry);
                        this._materials.push(child.material);
                    }
                });

                this.mesh = group;
                this.mesh.position.copy(this.physics.position);
                return group;
            }

            // CYCLE 11+12: Dispose GPU resources to prevent memory leaks
            disposeMesh() {
                if (this._geometries) {
                    for (const geo of this._geometries) geo.dispose();
                    this._geometries = null;
                }
                if (this._materials) {
                    for (const mat of this._materials) mat.dispose();
                    this._materials = null;
                }
                // CYCLE 12: Null bodyMaterial to prevent hit flash from accessing disposed material
                this.bodyMaterial = null;
            }

            think(creatures, planets, projectiles) {
                if (!this.isAlive) return [0, 0, 0, 0, 0, 0];

                // Use spatial index for O(n log n) lookup (CYCLE 1 IMPROVEMENT)
                const enemyResult = spatialIndex.findNearest(
                    this.physics.position,
                    creatures,
                    c => c !== this && c.isAlive && c.team !== this.team
                );
                const nearestEnemy = enemyResult.entity;
                const nearestEnemyDist = enemyResult.distance;

                const allyResult = spatialIndex.findNearest(
                    this.physics.position,
                    creatures,
                    c => c !== this && c.isAlive && c.team === this.team
                );
                const nearestAlly = allyResult.entity;
                const nearestAllyDist = allyResult.distance;

                // Find nearest planet (few planets, O(n) is fine)
                let nearestPlanet = null;
                let nearestPlanetDist = Infinity;
                for (const p of planets) {
                    const d = this.physics.position.distanceTo(p.physics.position);
                    if (d < nearestPlanetDist) {
                        nearestPlanetDist = d;
                        nearestPlanet = p;
                    }
                }

                // CYCLE 12: Build input vector in-place (no array allocation)
                const buf = this._inputBuffer;
                // Nearest enemy direction (3)
                buf[0] = nearestEnemy ? (nearestEnemy.physics.position.x - this.physics.position.x) / 100 : 0;
                buf[1] = nearestEnemy ? (nearestEnemy.physics.position.y - this.physics.position.y) / 100 : 0;
                buf[2] = nearestEnemy ? (nearestEnemy.physics.position.z - this.physics.position.z) / 100 : 0;
                // Nearest planet direction (3)
                buf[3] = nearestPlanet ? (nearestPlanet.physics.position.x - this.physics.position.x) / 200 : 0;
                buf[4] = nearestPlanet ? (nearestPlanet.physics.position.y - this.physics.position.y) / 200 : 0;
                buf[5] = nearestPlanet ? (nearestPlanet.physics.position.z - this.physics.position.z) / 200 : 0;
                // Own velocity (3)
                buf[6] = this.physics.velocity.x / 20;
                buf[7] = this.physics.velocity.y / 20;
                buf[8] = this.physics.velocity.z / 20;
                // State (3)
                buf[9] = this.health / this.maxHealth;
                buf[10] = this.energy / this.maxEnergy;
                buf[11] = nearestEnemyDist < 50 ? 1 : 0; // Enemy nearby warning

                return this.brain.forward(buf);
            }

            update(dt, outputs, celestialBodies, gravityScale, rawDt = null) {
                if (!this.isAlive) return;
                // CYCLE 10: Use rawDt for visual effects (flash), dt for simulation
                const visualDt = rawDt !== null ? rawDt : dt;

                this.survivalTime += dt;
                this.fireCooldown = Math.max(0, this.fireCooldown - dt);

                // Energy regeneration
                this.energy = Math.min(this.maxEnergy, this.energy + 5 * dt);

                // CYCLE 6 + CYCLE 7: Apply gravity only from nearby bodies (squared distance avoids sqrt)
                const maxDistSq = CONFIG.gravity.maxDistance * CONFIG.gravity.maxDistance;
                for (const body of celestialBodies) {
                    const dx = body.physics.position.x - this.physics.position.x;
                    const dy = body.physics.position.y - this.physics.position.y;
                    const dz = body.physics.position.z - this.physics.position.z;
                    if (dx*dx + dy*dy + dz*dz < maxDistSq) {
                        this.physics.applyGravityFrom(body.physics, CONFIG.gravity.creatureScale * gravityScale);
                    }
                }

                // Neural network outputs control behavior
                const [thrustX, thrustY, thrustZ, fire, boost, dodge] = outputs;

                const thrustPower = CONFIG.creature.thrustPower;
                // CYCLE 9: Reuse pre-allocated vector instead of creating new one each frame
                const thrust = this._thrustVector.set(
                    (thrustX - 0.5) * 2 * thrustPower,
                    (thrustY - 0.5) * 2 * thrustPower,
                    (thrustZ - 0.5) * 2 * thrustPower
                );

                // Apply thrust if we have energy
                if (this.energy > 1) {
                    this.physics.applyForce(thrust);
                    this.energy -= thrust.length() * 0.01;

                    // Show thrusters
                    if (this.mesh) {
                        this.mesh.traverse(child => {
                            if (child.name === 'thruster') {
                                child.visible = thrust.length() > 5;
                            }
                        });
                    }
                }

                // Boost ability
                if (boost > 0.7 && this.energy > 20) {
                    this.physics.velocity.multiplyScalar(1.5);
                    this.energy -= 20;
                }

                // Apply drag
                this.physics.velocity.multiplyScalar(0.995);

                // Integrate physics
                this.physics.integrate(dt);

                // Update mesh
                if (this.mesh) {
                    this.mesh.position.copy(this.physics.position);
                    if (this.physics.velocity.length() > 0.1) {
                        // CYCLE 9: Reuse pre-allocated vector instead of clone()
                        this._lookAtVector.copy(this.physics.position).add(this.physics.velocity);
                        this.mesh.lookAt(this._lookAtVector);
                    }

                    // Update health bar - CYCLE 8: Smooth HSL color interpolation
                    const healthBar = this.mesh.getObjectByName('healthBar');
                    if (healthBar) {
                        healthBar.scale.x = this.health / this.maxHealth;
                        // Smooth gradient: red (0) -> yellow (0.15) -> green (0.33)
                        const healthRatio = this.health / this.maxHealth;
                        const hue = healthRatio * 0.33; // 0 = red, 0.33 = green
                        healthBar.material.color.setHSL(hue, 0.9, 0.5);
                    }

                    // CYCLE 8+9+10: Hit flash effect with smooth decay (uses real-time, not sim time)
                    if (this.hitFlashTime > 0) {
                        this.hitFlashTime -= visualDt;
                        if (this.bodyMaterial) {
                            // CYCLE 9 FIX: Smooth fade from 0.8 → 0.2 based on remaining time
                            const flashProgress = Math.max(0, this.hitFlashTime / 0.15);
                            this.bodyMaterial.emissiveIntensity = 0.2 + (0.6 * flashProgress);
                        }
                    } else if (this.bodyMaterial) {
                        this.bodyMaterial.emissiveIntensity = 0.2;
                    }
                }

                // Calculate fitness
                this.fitness = this.survivalTime * 0.1 + this.damageDealt * 0.5 + this.kills * 100;
            }

            fire(targetDir) {
                if (this.fireCooldown > 0 || this.energy < 10) return null;

                this.fireCooldown = this.fireRate;
                this.energy -= 10;

                // CYCLE 13: Use VectorPool to avoid per-fire allocations (PhysicsBody clones these)
                const projectilePos = VectorPool.get().copy(this.physics.position).addScaledVector(targetDir, 1.5);
                const projectileVel = VectorPool.get().copy(targetDir).multiplyScalar(this.projectileSpeed).add(this.physics.velocity);

                return new Projectile(projectilePos, projectileVel, this.damage, this, this.teamColor);
            }

            takeDamage(amount, attacker) {
                this.health -= amount;
                this.hitFlashTime = 0.15; // CYCLE 8: Trigger hit flash for 150ms
                if (attacker) {
                    attacker.damageDealt += amount;

                    // CYCLE 10: Knockback impulse - creatures recoil from damage
                    const knockbackDir = VectorPool.get()
                        .subVectors(this.physics.position, attacker.physics.position)
                        .normalize();
                    const knockbackMagnitude = (amount * 0.15) + 2; // Base 2 + damage scaling
                    this.physics.velocity.addScaledVector(knockbackDir, knockbackMagnitude);

                    // CYCLE 13: Screen shake on damage (intensity proportional to damage)
                    triggerShake(amount * 0.003);
                }

                if (this.health <= 0) {
                    this.isAlive = false;
                    if (attacker) {
                        attacker.kills++;
                    }
                    // CYCLE 13: Stronger shake on death
                    triggerShake(0.15);
                    return true; // Died
                }
                return false;
            }

            reproduce(partner) {
                const childBrain = NeuralNetwork.crossover(this.brain, partner.brain);
                childBrain.mutate(simState.mutationRate);

                const child = new Creature(this.physics.position.clone(), this.team);
                child.brain = childBrain;
                child.generation = Math.max(this.generation, partner.generation) + 1;
                child.homePlanet = this.homePlanet;

                return child;
            }
        }

        // ─────────────────────────────────────────────────────────────────────────────
        // CELESTIAL BODY (Planet/Moon with gravity)
        // ─────────────────────────────────────────────────────────────────────────────
        class CelestialBody {
            constructor(mass, radius, position, color, name) {
                this.physics = new PhysicsBody(mass, position);
                this.radius = radius;
                this.color = color;
                this.name = name;
                this.mesh = null;
                this.orbitLine = null;
                this.orbitRadius = position.length();
                this.orbitSpeed = mass > 1000 ? 0 : 0.1 / Math.sqrt(this.orbitRadius);
                this.orbitAngle = Math.random() * Math.PI * 2;
            }

            createMesh() {
                const geo = new THREE.SphereGeometry(this.radius, 32, 32);
                const mat = new THREE.MeshStandardMaterial({
                    color: this.color,
                    metalness: 0.3,
                    roughness: 0.7,
                    emissive: this.color,
                    emissiveIntensity: 0.1
                });
                this.mesh = new THREE.Mesh(geo, mat);
                this.mesh.position.copy(this.physics.position);

                // Atmosphere glow
                const glowGeo = new THREE.SphereGeometry(this.radius * 1.15, 32, 32);
                const glowMat = new THREE.MeshBasicMaterial({
                    color: this.color,
                    transparent: true,
                    opacity: 0.15,
                    side: THREE.BackSide
                });
                const glow = new THREE.Mesh(glowGeo, glowMat);
                this.mesh.add(glow);

                return this.mesh;
            }

            createOrbitLine() {
                if (this.orbitRadius < 10) return null;

                const points = [];
                for (let i = 0; i <= 64; i++) {
                    const angle = (i / 64) * Math.PI * 2;
                    points.push(new THREE.Vector3(
                        Math.cos(angle) * this.orbitRadius,
                        0,
                        Math.sin(angle) * this.orbitRadius
                    ));
                }

                const geo = new THREE.BufferGeometry().setFromPoints(points);
                const mat = new THREE.LineBasicMaterial({
                    color: this.color,
                    transparent: true,
                    opacity: 0.3
                });
                this.orbitLine = new THREE.Line(geo, mat);
                return this.orbitLine;
            }

            update(dt) {
                if (this.orbitRadius > 10) {
                    this.orbitAngle += this.orbitSpeed * dt;
                    this.physics.position.set(
                        Math.cos(this.orbitAngle) * this.orbitRadius,
                        0,
                        Math.sin(this.orbitAngle) * this.orbitRadius
                    );
                }
                if (this.mesh) {
                    this.mesh.position.copy(this.physics.position);
                    this.mesh.rotation.y += 0.1 * dt;
                }
            }
        }

        // ─────────────────────────────────────────────────────────────────────────────
        // SIMULATION STATE
        // ─────────────────────────────────────────────────────────────────────────────
        const simState = {
            creatures: [],
            celestialBodies: [],
            projectiles: [],
            generation: 1,
            battles: 0,
            timeScale: 1,
            gravityScale: 1,
            mutationRate: 0.1,
            showOrbits: true,
            focusedPlanetIndex: 0,
            // CYCLE 13: Screen shake state
            shakeIntensity: 0,
            shakeDecay: 0.92
        };

        // CYCLE 13: Trigger camera shake on combat impacts
        function triggerShake(intensity) {
            simState.shakeIntensity = Math.min(simState.shakeIntensity + intensity, 1.0);
        }

        // ─────────────────────────────────────────────────────────────────────────────
        // INITIALIZATION
        // ─────────────────────────────────────────────────────────────────────────────
        async function init() {
            // Load Three.js
            await loadScript(THREE_CDN);
            THREE = window.THREE;
            await loadScript(ORBIT_CDN);

            // Initialize VectorPool with THREE (CYCLE 2)
            VectorPool.initWithThree();

            // Setup scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000510);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
            camera.position.set(0, 100, 200);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxDistance = 500;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x333344);
            scene.add(ambientLight);

            const sunLight = new THREE.PointLight(0xffffee, 2, 1000);
            scene.add(sunLight);

            // Starfield
            createStarfield();

            // Event listeners
            window.addEventListener('resize', onResize);
            setupControls();
            setupKeyboardControls();

            // Start render loop
            animate();
        }

        function loadScript(src) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }

        function createStarfield() {
            const vertices = [];
            const colors = [];
            for (let i = 0; i < 5000; i++) {
                const r = 800 + Math.random() * 200;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                vertices.push(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
                const brightness = 0.5 + Math.random() * 0.5;
                colors.push(brightness, brightness, brightness * (0.8 + Math.random() * 0.2));
            }

            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const mat = new THREE.PointsMaterial({
                size: 1.5,
                vertexColors: true,
                transparent: true,
                opacity: 0.8
            });

            scene.add(new THREE.Points(geo, mat));
        }

        // ─────────────────────────────────────────────────────────────────────────────
        // SOLAR SYSTEM GENERATION
        // ─────────────────────────────────────────────────────────────────────────────
        function generateSolarSystem() {
            // Central star
            const star = new CelestialBody(10000, 15, new THREE.Vector3(0, 0, 0), 0xffcc00, 'Sol');
            const starMesh = star.createMesh();
            starMesh.material.emissiveIntensity = 1;
            scene.add(starMesh);
            simState.celestialBodies.push(star);

            // Planets
            const planetData = [
                { dist: 40, radius: 3, mass: 50, color: 0x884422, name: 'Cinder' },
                { dist: 70, radius: 5, mass: 100, color: 0x44aa66, name: 'Verdant' },
                { dist: 110, radius: 4, mass: 80, color: 0x4466aa, name: 'Aqueon' },
                { dist: 160, radius: 8, mass: 300, color: 0xaa6644, name: 'Titan Prime' },
                { dist: 220, radius: 6, mass: 150, color: 0x666688, name: 'Frost' }
            ];

            for (const data of planetData) {
                const angle = Math.random() * Math.PI * 2;
                const pos = new THREE.Vector3(
                    Math.cos(angle) * data.dist,
                    (Math.random() - 0.5) * 10,
                    Math.sin(angle) * data.dist
                );

                const planet = new CelestialBody(data.mass, data.radius, pos, data.color, data.name);
                const mesh = planet.createMesh();
                scene.add(mesh);

                const orbit = planet.createOrbitLine();
                if (orbit) scene.add(orbit);

                simState.celestialBodies.push(planet);
            }
        }

        // ─────────────────────────────────────────────────────────────────────────────
        // CREATURE SPAWNING
        // ─────────────────────────────────────────────────────────────────────────────
        function spawnCreaturesOnPlanet(planet, count, team) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const elevation = (Math.random() - 0.5) * Math.PI;
                const offset = new THREE.Vector3(
                    Math.cos(angle) * Math.cos(elevation),
                    Math.sin(elevation),
                    Math.sin(angle) * Math.cos(elevation)
                ).multiplyScalar(planet.radius + 5);

                const pos = planet.physics.position.clone().add(offset);
                const creature = new Creature(pos, team);
                creature.homePlanet = planet;

                const mesh = creature.createMesh();
                scene.add(mesh);

                simState.creatures.push(creature);
            }
        }

        function spawnWave() {
            const planets = simState.celestialBodies.filter(b => b.radius < 15); // Not the star
            for (let i = 0; i < planets.length; i++) {
                const team = i % 3;
                spawnCreaturesOnPlanet(planets[i], 3, team);
            }
            addLog('New wave spawned!', 'spawn');
        }

        // ─────────────────────────────────────────────────────────────────────────────
        // COMBAT & COLLISION (CYCLE 3: SpatialIndex for O(n log n) collision detection)
        // ─────────────────────────────────────────────────────────────────────────────
        function checkCollisions() {
            // Projectile-Creature collisions - CYCLE 3: Use SpatialIndex
            for (let i = simState.projectiles.length - 1; i >= 0; i--) {
                const proj = simState.projectiles[i];

                // Use spatial index to get nearby creatures only (O(n log n) vs O(n²))
                const nearbyCreatures = spatialIndex.getNearby(proj.physics.position, 5);

                for (const creature of nearbyCreatures) {
                    if (!creature.isAlive || creature === proj.owner) continue;

                    const dist = proj.physics.position.distanceTo(creature.physics.position);
                    if (dist < 1.5) {
                        // Get team name for log (handle null owner from CYCLE 2 fix)
                        const attackerTeam = proj.owner ? proj.owner.team : proj.ownerTeam;
                        const died = creature.takeDamage(proj.damage, proj.owner);

                        if (died) {
                            // CYCLE 11: Use centralized team names
                            const attackerName = CONFIG.teams[attackerTeam]?.name ?? 'Unknown';
                            const victimName = CONFIG.teams[creature.team]?.name ?? 'Unknown';
                            addLog(`${attackerName} killed ${victimName}!`, 'kill');
                            simState.battles++;

                            // Death explosion
                            createExplosion(creature.physics.position, creature.teamColor);
                            cleanupEntityMesh(creature);  // CYCLE 14: Use centralized cleanup
                        }

                        // Remove projectile - CYCLE 14: Use centralized cleanup
                        cleanupEntityMesh(proj);
                        simState.projectiles.splice(i, 1);
                        break;
                    }
                }
            }

            // Creature-Planet collisions (bounce) - few bodies, O(n) fine
            for (const creature of simState.creatures) {
                if (!creature.isAlive) continue;

                for (const body of simState.celestialBodies) {
                    const dist = creature.physics.position.distanceTo(body.physics.position);
                    if (dist < body.radius + 1) {
                        // Bounce off
                        const normal = VectorPool.get()
                            .copy(creature.physics.position)
                            .sub(body.physics.position).normalize();
                        creature.physics.position.copy(body.physics.position)
                            .addScaledVector(normal, body.radius + 1.5);

                        // Reflect velocity
                        const dot = creature.physics.velocity.dot(normal);
                        creature.physics.velocity.addScaledVector(normal, -2 * dot);
                        creature.physics.velocity.multiplyScalar(0.5); // Lose energy
                    }
                }
            }
        }

        function createExplosion(position, color) {
            const particleCount = 30;
            const geo = new THREE.BufferGeometry();
            const positions = [];
            const velocities = [];

            for (let i = 0; i < particleCount; i++) {
                positions.push(position.x, position.y, position.z);
                velocities.push(
                    (Math.random() - 0.5) * 20,
                    (Math.random() - 0.5) * 20,
                    (Math.random() - 0.5) * 20
                );
            }

            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

            const mat = new THREE.PointsMaterial({
                color: color,
                size: 2,
                transparent: true,
                opacity: 1
            });

            const particles = new THREE.Points(geo, mat);
            particles.userData.velocities = velocities;
            particles.userData.lifetime = 1;
            // CYCLE 12: Store references for GPU disposal
            particles.userData.geometry = geo;
            particles.userData.material = mat;
            scene.add(particles);

            // Animate explosion
            const animateExplosion = () => {
                const positions = particles.geometry.attributes.position.array;
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] += velocities[i * 3] * 0.016;
                    positions[i * 3 + 1] += velocities[i * 3 + 1] * 0.016;
                    positions[i * 3 + 2] += velocities[i * 3 + 2] * 0.016;
                }
                particles.geometry.attributes.position.needsUpdate = true;
                particles.material.opacity -= 0.02;
                particles.userData.lifetime -= 0.016;

                if (particles.userData.lifetime > 0) {
                    requestAnimationFrame(animateExplosion);
                } else {
                    // CYCLE 12+14: Dispose GPU resources and clear arrays before removal
                    if (particles.userData.geometry) particles.userData.geometry.dispose();
                    if (particles.userData.material) particles.userData.material.dispose();
                    particles.userData.velocities = null;  // CYCLE 14: Clear velocity array
                    particles.userData = null;  // CYCLE 14: Clear userData object
                    scene.remove(particles);
                }
            };
            animateExplosion();
        }

        // ─────────────────────────────────────────────────────────────────────────────
        // EVOLUTION
        // ─────────────────────────────────────────────────────────────────────────────
        function evolve() {
            // Find survivors by team
            const teams = [[], [], []];
            for (const c of simState.creatures) {
                if (c.isAlive) teams[c.team].push(c);
            }

            // For each team, reproduce if we have enough
            for (let team = 0; team < 3; team++) {
                const survivors = teams[team].sort((a, b) => b.fitness - a.fitness);

                if (survivors.length >= 2 && survivors.length < 10) {
                    // Top performers reproduce
                    const parent1 = survivors[0];
                    const parent2 = survivors[1];
                    const child = parent1.reproduce(parent2);

                    const mesh = child.createMesh();
                    scene.add(mesh);
                    simState.creatures.push(child);

                    addLog(`Gen ${child.generation} creature born (Team ${team})!`, 'evolve');
                }
            }

            simState.generation++;
        }

        // ─────────────────────────────────────────────────────────────────────────────
        // MAIN UPDATE LOOP
        // ─────────────────────────────────────────────────────────────────────────────
        let lastTime = 0;
        let fpsCounter = 0;
        let fpsTime = 0;

        function animate(time = 0) {
            requestAnimationFrame(animate);

            // CYCLE 10: Separate real-time dt (for visual effects) from simulation dt
            const rawDt = Math.min((time - lastTime) / 1000, 0.1);
            const dt = rawDt * simState.timeScale;
            lastTime = time;

            if (simulationRunning) {
                // Reset vector pool at frame start (CYCLE 2 IMPROVEMENT)
                VectorPool.reset();

                // Update spatial index for O(n log n) lookups (CYCLE 1 IMPROVEMENT)
                spatialIndex.update(simState.creatures);

                // Update celestial bodies
                for (const body of simState.celestialBodies) {
                    body.update(dt);
                }

                // Update creatures
                for (const creature of simState.creatures) {
                    if (!creature.isAlive) continue;

                    // Think
                    const outputs = creature.think(
                        simState.creatures,
                        simState.celestialBodies,
                        simState.projectiles
                    );

                    // Act - pass rawDt for visual effects (CYCLE 10)
                    creature.update(dt, outputs, simState.celestialBodies, simState.gravityScale, rawDt);

                    // Fire if output says so - use SpatialIndex (CYCLE 2 IMPROVEMENT)
                    if (outputs[3] > 0.6 && creature.energy > 10) {
                        // Use spatial index for O(n log n) target search
                        const targetResult = spatialIndex.findNearest(
                            creature.physics.position,
                            simState.creatures,
                            c => c !== creature && c.isAlive && c.team !== creature.team
                        );

                        const target = targetResult.entity;
                        const targetDist = targetResult.distance;

                        if (target && targetDist < 100) {
                            // Use VectorPool to avoid GC pressure
                            const aimDir = VectorPool.get()
                                .subVectors(target.physics.position, creature.physics.position)
                                .normalize();
                            const projectile = creature.fire(aimDir);
                            if (projectile) {
                                const mesh = projectile.createMesh();
                                scene.add(mesh);
                                simState.projectiles.push(projectile);
                            }
                        }
                    }
                }

                // Update projectiles
                for (let i = simState.projectiles.length - 1; i >= 0; i--) {
                    const alive = simState.projectiles[i].update(dt, simState.celestialBodies, simState.gravityScale);
                    if (!alive) {
                        // CYCLE 14: Use centralized cleanup
                        cleanupEntityMesh(simState.projectiles[i]);
                        simState.projectiles.splice(i, 1);
                    }
                }

                // Check collisions
                checkCollisions();

                // Bounds checking (CYCLE 1 IMPROVEMENT)
                checkBounds();

                // Periodic memory cleanup (CYCLE 1 IMPROVEMENT)
                if (Math.random() < 0.01) {
                    cleanupDeadCreatures();
                }

                // Periodic evolution check
                if (Math.random() < 0.001) {
                    evolve();
                }

                // Update UI
                updateUI();
            }

            // FPS counter
            fpsCounter++;
            fpsTime += dt / simState.timeScale;
            if (fpsTime >= 1) {
                document.getElementById('stat-fps').textContent = fpsCounter;
                fpsCounter = 0;
                fpsTime = 0;
            }

            // CYCLE 13: Apply camera shake before rendering
            if (simState.shakeIntensity > 0.01) {
                const shakeAmount = simState.shakeIntensity * 3;
                camera.position.x += (Math.random() - 0.5) * shakeAmount;
                camera.position.y += (Math.random() - 0.5) * shakeAmount;
                simState.shakeIntensity *= simState.shakeDecay;
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // ─────────────────────────────────────────────────────────────────────────────
        // UI & CONTROLS
        // ─────────────────────────────────────────────────────────────────────────────
        function setupControls() {
            document.getElementById('timescale').addEventListener('input', e => {
                simState.timeScale = parseFloat(e.target.value);
                document.getElementById('val-timescale').textContent = simState.timeScale.toFixed(1);
            });

            document.getElementById('gravity').addEventListener('input', e => {
                simState.gravityScale = parseFloat(e.target.value);
                document.getElementById('val-gravity').textContent = simState.gravityScale.toFixed(1);
            });

            document.getElementById('mutation').addEventListener('input', e => {
                simState.mutationRate = parseFloat(e.target.value);
                document.getElementById('val-mutation').textContent = simState.mutationRate.toFixed(2);
            });
        }

        // CYCLE 3: UI throttling state
        const uiState = {
            frameCounter: 0,
            updateInterval: 6, // Update UI every N frames (~10fps at 60fps)
            cachedAlive: [],
            cachedChampion: null
        };

        function updateUI() {
            // CYCLE 3: Throttle UI updates to reduce DOM operations
            uiState.frameCounter++;
            if (uiState.frameCounter < uiState.updateInterval) return;
            uiState.frameCounter = 0;

            const alive = simState.creatures.filter(c => c.isAlive);
            uiState.cachedAlive = alive;

            document.getElementById('stat-generation').textContent = simState.generation;
            document.getElementById('stat-population').textContent = alive.length;
            document.getElementById('stat-battles').textContent = simState.battles;
            document.getElementById('stat-projectiles').textContent = simState.projectiles.length;

            // Find champion - CYCLE 5 FIX: Enhanced null guards for empty population
            const champion = alive.length > 0 ? alive.sort((a, b) => b.fitness - a.fitness)[0] : null;
            uiState.cachedChampion = champion;
            if (champion && champion.brain) {
                document.getElementById('stat-fitness').textContent = Math.floor(champion.fitness);
                document.getElementById('champion-fitness').textContent = Math.floor(champion.fitness);
                document.getElementById('champion-kills').textContent = champion.kills;

                // Brain visualization
                const brainViz = document.getElementById('champion-brain');
                brainViz.innerHTML = '';
                const activations = champion.brain.lastHiddenActivation || [];
                for (let i = 0; i < 8; i++) {
                    const neuron = document.createElement('div');
                    neuron.className = 'neuron';
                    if (activations[i] > 0.5) {
                        neuron.classList.add('active');
                    }
                    brainViz.appendChild(neuron);
                }
            } else {
                // CYCLE 5: Reset display when no champion
                document.getElementById('stat-fitness').textContent = '0';
                document.getElementById('champion-fitness').textContent = '0';
                document.getElementById('champion-kills').textContent = '0';
            }

            // Species count - CYCLE 5 FIX: Guard against empty/null brains
            const species = new Set(alive.filter(c => c.brain).map(c => c.brain.getFingerprint()));
            document.getElementById('species-count').textContent = species.size;

            // Active combat - CYCLE 3 + CYCLE 4: Use spatialIndex with actual distance filtering
            let combatCount = 0;
            for (const c of alive) {
                // CYCLE 4: Use filterByDistance=true to avoid false positives from cell boundaries
                const nearby = spatialIndex.getNearby(c.physics.position, 30, true);
                for (const other of nearby) {
                    if (other !== c && other.team !== c.team) {
                        combatCount++;
                        break; // Only count creature once
                    }
                }
            }
            document.getElementById('active-combat').textContent = Math.floor(combatCount / 2);
        }

        function addLog(message, type = '') {
            const entries = document.getElementById('log-entries');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = message;
            entries.insertBefore(entry, entries.firstChild);

            // Keep only last 20 entries
            while (entries.children.length > 20) {
                entries.removeChild(entries.lastChild);
            }
        }

        function toggleOrbits() {
            simState.showOrbits = !simState.showOrbits;
            for (const body of simState.celestialBodies) {
                if (body.orbitLine) {
                    body.orbitLine.visible = simState.showOrbits;
                }
            }
        }

        function focusNextPlanet() {
            const planets = simState.celestialBodies.filter(b => b.radius < 15);
            simState.focusedPlanetIndex = (simState.focusedPlanetIndex + 1) % planets.length;
            const planet = planets[simState.focusedPlanetIndex];

            controls.target.copy(planet.physics.position);
            camera.position.copy(planet.physics.position).add(new THREE.Vector3(30, 20, 30));
        }

        function triggerMassExtinction() {
            const survivors = Math.ceil(simState.creatures.filter(c => c.isAlive).length * 0.2);
            const sorted = simState.creatures
                .filter(c => c.isAlive)
                .sort((a, b) => b.fitness - a.fitness);

            for (let i = survivors; i < sorted.length; i++) {
                sorted[i].isAlive = false;
                cleanupEntityMesh(sorted[i]);  // CYCLE 14: Use centralized cleanup
            }

            addLog(`EXTINCTION EVENT! ${survivors} survivors.`, 'kill');
            simState.generation++;
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ─────────────────────────────────────────────────────────────────────────────
        // TOAST NOTIFICATIONS (CYCLE 2 + CYCLE 3 IMPROVEMENT)
        // ─────────────────────────────────────────────────────────────────────────────
        const toastState = {
            recentMessages: new Map(), // message -> timestamp
            dedupeWindow: 2000 // ms to suppress duplicate messages
        };

        function showToast(message) {
            const container = document.getElementById('toast-container');
            if (!container) return;

            // CYCLE 3: Deduplicate rapid identical messages
            const now = Date.now();
            const lastShown = toastState.recentMessages.get(message);
            if (lastShown && now - lastShown < toastState.dedupeWindow) {
                return; // Suppress duplicate
            }
            toastState.recentMessages.set(message, now);

            // Clean old entries periodically
            if (toastState.recentMessages.size > 20) {
                for (const [msg, time] of toastState.recentMessages) {
                    if (now - time > toastState.dedupeWindow) {
                        toastState.recentMessages.delete(msg);
                    }
                }
            }

            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.textContent = message;
            container.appendChild(toast);
            setTimeout(() => toast.remove(), 2000);
        }

        function updatePauseOverlay() {
            const overlay = document.getElementById('pause-overlay');
            if (!overlay) return;
            if (simulationRunning) {
                overlay.classList.remove('visible');
            } else {
                overlay.classList.add('visible');
            }
        }

        // ─────────────────────────────────────────────────────────────────────────────
        // KEYBOARD CONTROLS (CYCLE 1 IMPROVEMENT)
        // ─────────────────────────────────────────────────────────────────────────────
        function setupKeyboardControls() {
            document.addEventListener('keydown', (e) => {
                // Allow camera controls even when paused (CYCLE 2 FIX)
                const pauseExemptKeys = ['Space', 'KeyO', 'KeyN', 'KeyC'];
                if (!simulationRunning && !pauseExemptKeys.includes(e.code)) return;

                switch (e.code) {
                    case 'Space':
                        e.preventDefault();
                        simulationRunning = !simulationRunning;
                        updatePauseOverlay();
                        showToast(simulationRunning ? 'Resumed' : 'Paused');
                        break;
                    case 'KeyS':
                        spawnWave();
                        showToast('Wave Spawned');
                        break;
                    case 'KeyN':
                        focusNextPlanet();
                        showToast('Focus: Next Planet');
                        break;
                    case 'KeyO':
                        toggleOrbits();
                        showToast(simState.showOrbits ? 'Orbits: On' : 'Orbits: Off');
                        break;
                    case 'KeyC':
                        focusChampion();
                        break;
                    case 'KeyE':
                        // Require Shift+E for destructive action (CYCLE 2 FIX)
                        if (e.shiftKey) {
                            triggerMassExtinction();
                            showToast('EXTINCTION EVENT');
                        }
                        break;
                }
            });
        }

        function focusChampion() {
            const alive = simState.creatures.filter(c => c.isAlive);
            if (alive.length === 0) return;

            const champion = alive.sort((a, b) => b.fitness - a.fitness)[0];
            if (champion && champion.mesh) {
                controls.target.copy(champion.physics.position);
                camera.position.copy(champion.physics.position).add(new THREE.Vector3(15, 10, 15));
                addLog('Focusing on champion', 'spawn');
            }
        }

        // ─────────────────────────────────────────────────────────────────────────────
        // MEMORY CLEANUP & BOUNDS CHECKING (CYCLE 1 + CYCLE 7 FIX: Use CONFIG.world.bounds)
        // ─────────────────────────────────────────────────────────────────────────────

        // CYCLE 14: Centralized mesh cleanup helper for consistent disposal pattern
        function cleanupEntityMesh(entity) {
            if (entity && entity.mesh) {
                if (entity.disposeMesh) entity.disposeMesh();
                scene.remove(entity.mesh);
                entity.mesh = null;
            }
        }

        function cleanupDeadCreatures() {
            const deadCreatures = new Set();

            // Remove dead creatures and track them
            for (let i = simState.creatures.length - 1; i >= 0; i--) {
                const creature = simState.creatures[i];
                if (!creature.isAlive) {
                    deadCreatures.add(creature);
                    cleanupEntityMesh(creature);  // CYCLE 14: Use centralized cleanup
                    creature.brain = null;  // Allow GC of neural network
                    simState.creatures.splice(i, 1);
                }
            }

            // Clear projectile owner references for dead creatures (CYCLE 2 FIX - Memory leak)
            for (const proj of simState.projectiles) {
                if (deadCreatures.has(proj.owner)) {
                    // Keep team info but break object reference
                    proj.ownerTeam = proj.owner.team;
                    proj.owner = null;
                }
            }
        }

        function checkBounds() {
            for (const creature of simState.creatures) {
                if (!creature.isAlive) continue;

                const dist = creature.physics.position.length();
                if (dist > CONFIG.world.bounds) {
                    // Distance-proportional pull force to reduce jitter (CYCLE 2 FIX)
                    const overshoot = dist - CONFIG.world.bounds;
                    const pullStrength = 20 + overshoot * 2;
                    const pullForce = VectorPool.get()
                        .copy(creature.physics.position)
                        .normalize()
                        .multiplyScalar(-pullStrength);
                    creature.physics.applyForce(pullForce);
                    creature.physics.velocity.multiplyScalar(0.95); // Damping

                    // Hard boundary - teleport back if too far
                    if (dist > CONFIG.world.bounds * 1.5) {
                        const nearestPlanet = simState.celestialBodies
                            .filter(b => b.radius < 15)
                            .sort((a, b) =>
                                a.physics.position.distanceTo(creature.physics.position) -
                                b.physics.position.distanceTo(creature.physics.position)
                            )[0];

                        if (nearestPlanet) {
                            // Teleport OUTSIDE planet radius (CYCLE 2 FIX)
                            const safeDistance = nearestPlanet.radius + 10;
                            const offset = VectorPool.get()
                                .set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5)
                                .normalize()
                                .multiplyScalar(safeDistance);
                            creature.physics.position.copy(nearestPlanet.physics.position).add(offset);
                            creature.physics.velocity.multiplyScalar(0.1);
                        }
                    }
                }
            }

            // Also check projectiles - remove if out of bounds
            for (let i = simState.projectiles.length - 1; i >= 0; i--) {
                if (simState.projectiles[i].physics.position.length() > CONFIG.world.bounds) {
                    // CYCLE 14: Use centralized cleanup
                    cleanupEntityMesh(simState.projectiles[i]);
                    simState.projectiles.splice(i, 1);
                }
            }
        }

        // ─────────────────────────────────────────────────────────────────────────────
        // START SIMULATION
        // ─────────────────────────────────────────────────────────────────────────────
        function startSimulation() {
            document.getElementById('title-overlay').classList.add('hidden');
            document.getElementById('stats-panel').classList.remove('hidden');
            document.getElementById('controls-panel').classList.remove('hidden');
            document.getElementById('evolution-panel').classList.remove('hidden');
            document.getElementById('combat-log').classList.remove('hidden');

            generateSolarSystem();

            // Spawn initial creatures on each planet
            const planets = simState.celestialBodies.filter(b => b.radius < 15);
            for (let i = 0; i < planets.length; i++) {
                spawnCreaturesOnPlanet(planets[i], 5, i % 3);
            }

            simulationRunning = true;
            addLog('NEURAL COSMOS ARENA initialized!', 'spawn');
            addLog('Creatures spawned across 5 planets.', 'spawn');
        }

        // Initialize
        init();
    </script>
</body>
</html>
