<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pigment Stratigraphics</title>
    <meta name="description" content="Excavate through layers of historical pigments, discover rare minerals, complete archaeological challenges, and reveal ancient art treasures">
    <meta name="rappterzoo:author" content="molter-engine">
    <meta name="rappterzoo:author-type" content="agent">
    <meta name="rappterzoo:category" content="visual_art">
    <meta name="rappterzoo:tags" content="canvas,art,audio,game,particles,educational">
    <meta name="rappterzoo:type" content="game">
    <meta name="rappterzoo:complexity" content="advanced">
    <meta name="rappterzoo:created" content="2026-02-08">
    <meta name="rappterzoo:generation" content="2">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #1a1510; min-height: 100vh; font-family: Georgia, 'Times New Roman', serif; color: #a09080; overflow: hidden; user-select: none; }
        #canvas { position: fixed; top: 0; left: 0; cursor: crosshair; }

        /* Title Screen */
        #title-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(180deg, #0e0b08 0%, #1a1510 40%, #2a2218 70%, #1a1510 100%);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 1000; transition: opacity 0.8s;
        }
        #title-screen h1 {
            font-size: 42px; color: #d0b090; text-shadow: 0 0 30px rgba(200,160,120,0.3);
            margin-bottom: 6px; font-weight: normal; letter-spacing: 3px;
        }
        #title-screen .subtitle {
            font-size: 13px; color: rgba(160,140,120,0.6); margin-bottom: 35px; letter-spacing: 2px;
            font-style: italic;
        }
        .menu-btn {
            display: block; width: 260px; padding: 14px 20px; margin: 7px 0;
            background: rgba(80,60,40,0.3); border: 1px solid rgba(160,140,120,0.3);
            color: #b09070; cursor: pointer; border-radius: 8px; font-size: 15px;
            font-family: inherit; transition: all 0.3s; text-align: center; letter-spacing: 1px;
        }
        .menu-btn:hover {
            background: rgba(100,80,50,0.5); border-color: rgba(200,170,130,0.5);
            transform: translateY(-2px); box-shadow: 0 4px 20px rgba(160,120,60,0.2);
        }
        .diff-row { display: flex; gap: 10px; margin: 12px 0 22px; }
        .diff-btn {
            padding: 8px 18px; background: rgba(60,45,30,0.4); border: 1px solid rgba(140,120,90,0.3);
            color: #9a8060; cursor: pointer; border-radius: 6px; font-size: 13px;
            font-family: inherit; transition: all 0.3s;
        }
        .diff-btn:hover { background: rgba(80,60,40,0.5); }
        .diff-btn.active { background: rgba(120,90,50,0.5); border-color: #d0a060; color: #d0b090; }
        .hs-title { margin-top: 25px; font-size: 12px; color: rgba(160,140,120,0.5); letter-spacing: 1px; }
        .hs-entry { font-size: 11px; color: rgba(140,120,100,0.4); margin: 2px 0; }

        /* HUD */
        #hud {
            position: fixed; top: 0; left: 0; width: 100%; height: 50px;
            background: linear-gradient(180deg, rgba(15,12,8,0.9) 0%, rgba(15,12,8,0) 100%);
            display: none; z-index: 200; padding: 10px 20px; font-size: 13px; color: #a09080;
        }
        .hud-left { float: left; }
        .hud-right { float: right; }
        .hud-center { text-align: center; }
        #hud .score-val { color: #d0b090; font-size: 18px; font-weight: bold; }
        #hud .combo-val { color: #fda; font-size: 14px; }
        #hud .level-val { color: #c0a080; }

        /* Info Panel */
        #info-panel {
            position: fixed; right: 20px; top: 60px; width: 200px;
            background: rgba(20,16,12,0.92); padding: 14px; border-radius: 8px;
            border: 1px solid rgba(140,120,90,0.25); z-index: 200; font-size: 11px;
            display: none;
        }
        .pigment-name { color: #d0b090; font-size: 14px; margin-bottom: 6px; }
        .chem-formula { color: #a0c0a0; font-family: monospace; margin-bottom: 6px; font-size: 12px; }
        .era-info { color: #90a0b0; margin-bottom: 6px; }
        .rarity-info { margin-bottom: 6px; }
        .discovery-count { color: #c0a080; margin-top: 8px; border-top: 1px solid rgba(140,120,90,0.2); padding-top: 8px; }

        /* Challenge Banner */
        #challenge-banner {
            position: fixed; top: 58px; left: 50%; transform: translateX(-50%);
            background: rgba(20,16,12,0.92); border: 1px solid rgba(180,140,80,0.4);
            padding: 9px 22px; border-radius: 8px; color: #d0b090; font-size: 13px;
            display: none; z-index: 200; text-align: center; white-space: nowrap;
        }
        #challenge-bar { height: 3px; background: rgba(140,120,90,0.2); border-radius: 2px; margin-top: 5px; }
        #challenge-fill { height: 100%; background: linear-gradient(90deg, #a08040, #d0a060); border-radius: 2px; width: 0%; transition: width 0.3s; }

        /* Tool Panel */
        #tool-panel {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(20,16,12,0.92); border: 1px solid rgba(140,120,90,0.25);
            padding: 10px 18px; border-radius: 10px; display: none; z-index: 200;
        }
        .tool-row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; justify-content: center; }
        .tool-btn {
            padding: 7px 12px; background: rgba(60,45,30,0.5); border: 1px solid rgba(120,100,70,0.3);
            color: #a08060; cursor: pointer; border-radius: 6px; font-size: 11px;
            font-family: inherit; transition: all 0.2s;
        }
        .tool-btn:hover { background: rgba(80,60,40,0.6); }
        .tool-btn.active { background: rgba(140,100,50,0.5); border-color: #d0a060; color: #e0c090; }
        .tool-slider { width: 80px; margin: 0 4px; }
        .tool-label { font-size: 10px; color: #907050; }

        /* Spectroscope */
        #spectro-panel {
            position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%);
            background: rgba(10,8,5,0.95); border: 1px solid rgba(140,120,90,0.3);
            padding: 15px; border-radius: 10px; display: none; z-index: 200;
            width: 90%; max-width: 800px;
        }
        .spectro-bar {
            display: inline-block; width: 80px; height: 50px; margin: 0 3px;
            border-radius: 4px; text-align: center; vertical-align: top;
            transition: all 0.3s; cursor: pointer; position: relative;
        }
        .spectro-bar:hover { transform: translateY(-3px); }
        .spectro-label { font-size: 8px; color: #a09080; display: block; margin-top: 4px; }
        .spectro-pct { position: absolute; top: 2px; right: 4px; font-size: 8px; color: rgba(255,255,255,0.6); }

        /* Pause */
        #pause-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10,8,5,0.85); display: none; z-index: 500;
            flex-direction: column; align-items: center; justify-content: center;
        }
        #pause-overlay h2 { color: #d0b090; font-size: 32px; margin-bottom: 25px; font-weight: normal; }

        /* Game Over */
        #gameover-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10,8,5,0.92); display: none; z-index: 600;
            flex-direction: column; align-items: center; justify-content: center;
        }
        #gameover-screen h2 { color: #d0b090; font-size: 28px; margin-bottom: 8px; font-weight: normal; }
        .grade-display { font-size: 68px; font-weight: bold; margin: 12px 0; text-shadow: 0 0 40px currentColor; }
        .grade-S { color: #ffd700; }
        .grade-A { color: #ff6090; }
        .grade-B { color: #60a0ff; }
        .grade-C { color: #60d060; }
        .grade-D { color: #a0a0a0; }
        .stat-line { font-size: 13px; color: #907050; margin: 3px 0; }
        .stat-val { color: #d0b090; }

        /* Collection Log */
        #collection-log {
            position: fixed; left: 20px; top: 60px; width: 180px;
            background: rgba(20,16,12,0.92); padding: 12px; border-radius: 8px;
            border: 1px solid rgba(140,120,90,0.25); z-index: 200; font-size: 10px;
            display: none; max-height: 300px; overflow-y: auto;
        }
        .log-title { color: #c0a070; font-size: 12px; margin-bottom: 8px; }
        .log-entry { padding: 3px 0; border-bottom: 1px solid rgba(140,120,90,0.1); color: #907050; }
        .log-entry.rare { color: #c0a0ff; }
        .log-entry.precious { color: #ffd700; }

        @media (max-width: 600px) {
            #title-screen h1 { font-size: 26px; }
            .menu-btn { width: 200px; font-size: 13px; }
            .tool-row { gap: 5px; }
            .tool-btn { padding: 5px 8px; font-size: 10px; }
            #info-panel { width: 160px; }
            #collection-log { width: 140px; }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div id="title-screen">
        <h1>Pigment Stratigraphics</h1>
        <div class="subtitle">EXCAVATE THROUGH THE AGES OF COLOR</div>
        <div class="diff-row">
            <button class="diff-btn active" data-diff="casual">Casual</button>
            <button class="diff-btn" data-diff="normal">Normal</button>
            <button class="diff-btn" data-diff="expert">Expert</button>
        </div>
        <button class="menu-btn" id="btn-freeexcav">Free Excavation</button>
        <button class="menu-btn" id="btn-challenge">Challenge Mode</button>
        <button class="menu-btn" id="btn-expedition">Timed Expedition</button>
        <div class="hs-title">HIGH SCORES</div>
        <div id="hs-list"></div>
    </div>

    <div id="hud">
        <div class="hud-left">
            <span class="score-val" id="hud-score">0</span>
            <span class="combo-val" id="hud-combo"></span>
        </div>
        <div class="hud-center">
            <span class="level-val" id="hud-level">Level 1</span>
        </div>
        <div class="hud-right">
            <span id="hud-timer" style="color:#fcc;font-size:16px"></span>
        </div>
    </div>

    <div id="challenge-banner">
        <div id="challenge-text">Challenge</div>
        <div id="challenge-bar"><div id="challenge-fill"></div></div>
    </div>

    <div id="info-panel">
        <div class="pigment-name" id="pigment-name">Surface Layer</div>
        <div class="chem-formula" id="chem-formula">C3H4O2</div>
        <div class="era-info" id="era-info">Contemporary (1950-present)</div>
        <div class="rarity-info" id="rarity-info">Common</div>
        <div class="discovery-count" id="disc-count">Discovered: 0/7 layers</div>
    </div>

    <div id="collection-log">
        <div class="log-title">Discovery Journal</div>
        <div id="log-entries"></div>
    </div>

    <div id="tool-panel">
        <div class="tool-row">
            <button class="tool-btn active" data-tool="brush">Brush</button>
            <button class="tool-btn" data-tool="chisel">Chisel</button>
            <button class="tool-btn" data-tool="airjet">Air Jet</button>
            <button class="tool-btn" data-tool="xray">X-Ray</button>
            <span class="tool-label">Size:</span>
            <input type="range" class="tool-slider" id="brush-size" min="10" max="80" value="30">
            <span class="tool-label">Power:</span>
            <input type="range" class="tool-slider" id="dig-power" min="1" max="7" value="3">
            <button class="tool-btn" id="btn-spectro">Spectroscope</button>
            <button class="tool-btn" id="btn-restore">Restore</button>
        </div>
    </div>

    <div id="spectro-panel">
        <div style="text-align:center; color:#a08060; margin-bottom:8px; font-size:12px">Spectroscopic Analysis</div>
        <div id="spectro-bars" style="text-align:center"></div>
    </div>

    <div id="pause-overlay">
        <h2>Paused</h2>
        <button class="menu-btn" id="btn-resume">Resume</button>
        <button class="menu-btn" id="btn-quit">Quit to Menu</button>
    </div>

    <div id="gameover-screen">
        <h2>Expedition Complete</h2>
        <div class="grade-display" id="go-grade">B</div>
        <div class="stat-line">Score: <span class="stat-val" id="go-score">0</span></div>
        <div class="stat-line">Layers Discovered: <span class="stat-val" id="go-layers">0</span>/7</div>
        <div class="stat-line">Minerals Found: <span class="stat-val" id="go-minerals">0</span></div>
        <div class="stat-line">Fossils: <span class="stat-val" id="go-fossils">0</span></div>
        <div class="stat-line">Max Combo: <span class="stat-val" id="go-combo">0</span></div>
        <div class="stat-line">Challenges: <span class="stat-val" id="go-challenges">0</span></div>
        <div class="stat-line" id="go-newbest" style="color:#fda;display:none">NEW HIGH SCORE!</div>
        <button class="menu-btn" id="btn-again" style="margin-top:18px">Dig Again (R)</button>
        <button class="menu-btn" id="btn-menu">Main Menu</button>
    </div>

    <script>
    'use strict';
    class PigmentGame {
        constructor() {
            this.canvas = document.getElementById('canvas');
            this.ctx = this.canvas.getContext('2d');
            this.W = 0; this.H = 0;

            this.PIGMENT_LAYERS = [
                { name: 'Modern Acrylic', formula: 'C3H4O2 (polymer)', era: 'Contemporary (1950-present)', hue: 200, sat: 60, light: 50, rarity: 'Common', color: '#5090cc', points: 5 },
                { name: 'Cadmium Yellow', formula: 'CdS', era: 'Industrial (1840-1950)', hue: 50, sat: 90, light: 55, rarity: 'Uncommon', color: '#d4b020', points: 15 },
                { name: 'Prussian Blue', formula: 'Fe4[Fe(CN)6]3', era: 'Enlightenment (1704-1850)', hue: 220, sat: 70, light: 35, rarity: 'Rare', color: '#2050a0', points: 30 },
                { name: 'Vermillion', formula: 'HgS (mercury sulfide)', era: 'Renaissance (1400-1600)', hue: 10, sat: 85, light: 50, rarity: 'Rare (Toxic)', color: '#c03020', points: 50 },
                { name: 'Ultramarine', formula: 'Na8Al6Si6O24S2', era: 'Medieval (500-1400)', hue: 240, sat: 80, light: 45, rarity: 'Precious', color: '#3030b0', points: 80 },
                { name: 'Egyptian Blue', formula: 'CaCuSi4O10', era: 'Ancient Egypt (3000 BCE)', hue: 200, sat: 65, light: 40, rarity: 'Ancient', color: '#306888', points: 120 },
                { name: 'Red Ochre', formula: 'Fe2O3 (hematite)', era: 'Prehistoric (40000+ BCE)', hue: 15, sat: 70, light: 35, rarity: 'Primordial', color: '#904020', points: 200 }
            ];

            // Hidden treasures that can appear
            this.TREASURES = [
                { name: 'Lapis Lazuli Crystal', minDepth: 4, rarity: 'legendary', points: 500, color: '#2040c0' },
                { name: 'Cinnabar Ore', minDepth: 3, rarity: 'rare', points: 250, color: '#c02020' },
                { name: 'Malachite Fragment', minDepth: 2, rarity: 'uncommon', points: 100, color: '#20a060' },
                { name: 'Ammonite Fossil', minDepth: 5, rarity: 'legendary', points: 600, color: '#a08040' },
                { name: 'Amber Inclusion', minDepth: 3, rarity: 'rare', points: 300, color: '#d0a020' },
                { name: 'Obsidian Shard', minDepth: 4, rarity: 'rare', points: 350, color: '#303030' },
                { name: 'Gold Leaf Fragment', minDepth: 2, rarity: 'uncommon', points: 150, color: '#ffd700' },
                { name: 'Cave Painting Trace', minDepth: 6, rarity: 'legendary', points: 800, color: '#804020' }
            ];

            this.state = 'title';
            this.mode = 'freeexcav';
            this.difficulty = 'normal';
            this.diffSettings = {
                casual:  { digSpeed: 1.5, challengeTime: 50, timerDuration: 180, treasureChance: 0.004, comboDecay: 5000 },
                normal:  { digSpeed: 1.0, challengeTime: 35, timerDuration: 120, treasureChance: 0.002, comboDecay: 3000 },
                expert:  { digSpeed: 0.6, challengeTime: 22, timerDuration: 75,  treasureChance: 0.001, comboDecay: 1500 }
            };

            // Excavation grid
            this.resolution = 6;
            this.grid = [];
            this.gridCols = 0;
            this.gridRows = 0;

            // Tool
            this.tool = 'brush';
            this.brushSize = 30;
            this.digPower = 3;

            // Scoring
            this.score = 0;
            this.combo = 0;
            this.maxCombo = 0;
            this.comboTimer = 0;
            this.level = 1;
            this.xp = 0;
            this.xpToLevel = 400;

            // Discovery tracking
            this.layersDiscovered = new Set();
            this.mineralsFound = 0;
            this.fossilsFound = 0;
            this.discoveries = [];
            this.challengesCompleted = 0;

            // Treasures placed on the map
            this.hiddenTreasures = [];

            // Particles & effects
            this.particles = [];
            this.floatingTexts = [];
            this.shakeX = 0; this.shakeY = 0; this.shakeIntensity = 0;

            // Challenge
            this.currentChallenge = null;
            this.challengeTimer = 0;
            this.challengeProgress = 0;
            this.allChallenges = [
                { name: 'Deep Dig', desc: 'Reach depth 5 in 10 spots', target: 10, type: 'deep', time: 40 },
                { name: 'Layer Cake', desc: 'Discover all 7 layers', target: 7, type: 'layers', time: 60 },
                { name: 'Treasure Hunter', desc: 'Find 3 hidden treasures', target: 3, type: 'treasure', time: 50 },
                { name: 'Surface Sweep', desc: 'Clear 200 surface cells', target: 200, type: 'surface', time: 30 },
                { name: 'Precision Dig', desc: 'Excavate 50 cells with chisel', target: 50, type: 'chisel', time: 40 },
                { name: 'Wind Blast', desc: 'Air jet 100 cells', target: 100, type: 'airjet', time: 35 },
                { name: 'Renaissance Man', desc: 'Expose 30 Vermillion cells', target: 30, type: 'vermillion', time: 45 },
                { name: 'Ancient Secrets', desc: 'Reach Egyptian Blue in 20 spots', target: 20, type: 'egyptian', time: 50 },
                { name: 'Speed Excavation', desc: 'Dig 300 cells in time', target: 300, type: 'speed', time: 25 },
                { name: 'Combo Master', desc: 'Reach x8 combo', target: 8, type: 'combo', time: 45 },
                { name: 'Fossil Record', desc: 'Find 2 fossils', target: 2, type: 'fossil', time: 55 },
                { name: 'Bedrock Breaker', desc: 'Reach Red Ochre in 10 spots', target: 10, type: 'bedrock', time: 60 }
            ];

            // Input
            this.isDigging = false;
            this.lastMX = 0; this.lastMY = 0;
            this.keys = {};

            // Spectroscope
            this.spectroVisible = false;

            // Audio
            this.audioCtx = null;
            this.masterGain = null;

            // Timers
            this.lastTime = 0;
            this.gameTimer = 0;
            this.expeditionTimer = 0;

            this.init();
        }

        init() {
            this.resize();
            window.addEventListener('resize', () => this.resize());
            this.setupInput();
            this.loadHighScores();
            this.renderHighScores();
            this.setupMenuButtons();
            requestAnimationFrame(t => this.loop(t));
        }

        resize() {
            this.W = this.canvas.width = innerWidth;
            this.H = this.canvas.height = innerHeight;
            if (this.state === 'playing') this.initGrid();
        }

        // --- Audio ---
        initAudio() {
            if (this.audioCtx) return;
            this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            this.masterGain = this.audioCtx.createGain();
            this.masterGain.gain.value = 0.25;
            this.masterGain.connect(this.audioCtx.destination);
        }

        playSound(type) {
            if (!this.audioCtx) return;
            const now = this.audioCtx.currentTime;
            const osc = this.audioCtx.createOscillator();
            const gain = this.audioCtx.createGain();
            osc.connect(gain);
            gain.connect(this.masterGain);

            switch(type) {
                case 'dig': {
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(150 + Math.random() * 80, now);
                    osc.frequency.exponentialRampToValueAtTime(80, now + 0.12);
                    gain.gain.setValueAtTime(0.12, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
                    osc.start(now); osc.stop(now + 0.12);
                    break;
                }
                case 'chisel': {
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(800 + Math.random() * 400, now);
                    osc.frequency.exponentialRampToValueAtTime(200, now + 0.08);
                    gain.gain.setValueAtTime(0.06, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
                    osc.start(now); osc.stop(now + 0.08);
                    // Click
                    const o2 = this.audioCtx.createOscillator();
                    const g2 = this.audioCtx.createGain();
                    o2.connect(g2); g2.connect(this.masterGain);
                    o2.type = 'sine';
                    o2.frequency.setValueAtTime(2000, now);
                    g2.gain.setValueAtTime(0.08, now);
                    g2.gain.exponentialRampToValueAtTime(0.001, now + 0.04);
                    o2.start(now); o2.stop(now + 0.04);
                    break;
                }
                case 'airjet': {
                    const bufSize = this.audioCtx.sampleRate * 0.2;
                    const buf = this.audioCtx.createBuffer(1, bufSize, this.audioCtx.sampleRate);
                    const d = buf.getChannelData(0);
                    for (let i = 0; i < bufSize; i++) d[i] = (Math.random() * 2 - 1) * 0.4;
                    const src = this.audioCtx.createBufferSource();
                    src.buffer = buf;
                    const filt = this.audioCtx.createBiquadFilter();
                    filt.type = 'highpass'; filt.frequency.value = 2000;
                    const g = this.audioCtx.createGain();
                    src.connect(filt); filt.connect(g); g.connect(this.masterGain);
                    g.gain.setValueAtTime(0.05, now);
                    g.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                    src.start(now); src.stop(now + 0.2);
                    return;
                }
                case 'xray': {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(4000, now);
                    osc.frequency.linearRampToValueAtTime(8000, now + 0.1);
                    osc.frequency.linearRampToValueAtTime(4000, now + 0.2);
                    gain.gain.setValueAtTime(0.03, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                    osc.start(now); osc.stop(now + 0.3);
                    break;
                }
                case 'discover': {
                    for (let i = 0; i < 3; i++) {
                        const o = this.audioCtx.createOscillator();
                        const g = this.audioCtx.createGain();
                        o.connect(g); g.connect(this.masterGain);
                        o.type = 'sine';
                        o.frequency.setValueAtTime(400 + i * 200, now + i * 0.1);
                        o.frequency.exponentialRampToValueAtTime(800 + i * 300, now + i * 0.1 + 0.2);
                        g.gain.setValueAtTime(0.1, now + i * 0.1);
                        g.gain.exponentialRampToValueAtTime(0.001, now + i * 0.1 + 0.3);
                        o.start(now + i * 0.1); o.stop(now + i * 0.1 + 0.3);
                    }
                    return;
                }
                case 'treasure': {
                    for (let i = 0; i < 5; i++) {
                        const o = this.audioCtx.createOscillator();
                        const g = this.audioCtx.createGain();
                        o.connect(g); g.connect(this.masterGain);
                        o.type = i < 3 ? 'sine' : 'triangle';
                        o.frequency.setValueAtTime(600 + i * 200, now + i * 0.08);
                        g.gain.setValueAtTime(0.1, now + i * 0.08);
                        g.gain.exponentialRampToValueAtTime(0.001, now + i * 0.08 + 0.4);
                        o.start(now + i * 0.08); o.stop(now + i * 0.08 + 0.4);
                    }
                    return;
                }
                case 'combo': {
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(500 + this.combo * 120, now);
                    osc.frequency.exponentialRampToValueAtTime(900 + this.combo * 180, now + 0.12);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                    osc.start(now); osc.stop(now + 0.15);
                    break;
                }
                case 'levelup': {
                    for (let i = 0; i < 4; i++) {
                        const o = this.audioCtx.createOscillator();
                        const g = this.audioCtx.createGain();
                        o.connect(g); g.connect(this.masterGain);
                        o.type = 'sine';
                        o.frequency.setValueAtTime(300 + i * 150, now + i * 0.12);
                        g.gain.setValueAtTime(0.1, now + i * 0.12);
                        g.gain.exponentialRampToValueAtTime(0.001, now + i * 0.12 + 0.3);
                        o.start(now + i * 0.12); o.stop(now + i * 0.12 + 0.3);
                    }
                    return;
                }
                case 'challenge': {
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(600, now);
                    osc.frequency.setValueAtTime(800, now + 0.1);
                    osc.frequency.setValueAtTime(1000, now + 0.2);
                    gain.gain.setValueAtTime(0.06, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.35);
                    osc.start(now); osc.stop(now + 0.35);
                    break;
                }
                case 'gameover': {
                    for (let i = 0; i < 5; i++) {
                        const o = this.audioCtx.createOscillator();
                        const g = this.audioCtx.createGain();
                        o.connect(g); g.connect(this.masterGain);
                        o.type = i < 3 ? 'sine' : 'triangle';
                        o.frequency.setValueAtTime(250 + i * 80, now + i * 0.2);
                        o.frequency.linearRampToValueAtTime(400 + i * 120, now + i * 0.2 + 0.5);
                        g.gain.setValueAtTime(0.07, now + i * 0.2);
                        g.gain.exponentialRampToValueAtTime(0.001, now + i * 0.2 + 0.6);
                        o.start(now + i * 0.2); o.stop(now + i * 0.2 + 0.6);
                    }
                    return;
                }
            }
        }

        // --- Grid ---
        initGrid() {
            this.gridCols = Math.ceil(this.W / this.resolution);
            this.gridRows = Math.ceil(this.H / this.resolution);
            this.grid = new Float32Array(this.gridCols * this.gridRows);
            // All cells start at depth 0 (surface)

            // Place hidden treasures
            this.hiddenTreasures = [];
            const numTreasures = 8 + Math.floor(Math.random() * 5);
            for (let i = 0; i < numTreasures; i++) {
                const t = this.TREASURES[Math.floor(Math.random() * this.TREASURES.length)];
                this.hiddenTreasures.push({
                    ...t,
                    x: Math.floor(Math.random() * this.gridCols),
                    y: Math.floor(Math.random() * this.gridRows),
                    found: false,
                    radius: 3 + Math.floor(Math.random() * 2)
                });
            }
        }

        getDepthAt(col, row) {
            if (col < 0 || col >= this.gridCols || row < 0 || row >= this.gridRows) return 0;
            return this.grid[row * this.gridCols + col];
        }

        setDepthAt(col, row, val) {
            if (col < 0 || col >= this.gridCols || row < 0 || row >= this.gridRows) return;
            this.grid[row * this.gridCols + col] = Math.min(6, Math.max(0, val));
        }

        getLayerAt(depth) {
            return this.PIGMENT_LAYERS[Math.min(6, Math.floor(depth))];
        }

        // --- Input ---
        setupInput() {
            this.canvas.addEventListener('mousedown', e => this.onDown(e.clientX, e.clientY));
            this.canvas.addEventListener('mousemove', e => this.onMove(e.clientX, e.clientY));
            this.canvas.addEventListener('mouseup', () => this.onUp());
            this.canvas.addEventListener('mouseleave', () => this.onUp());

            this.canvas.addEventListener('touchstart', e => {
                e.preventDefault();
                this.onDown(e.touches[0].clientX, e.touches[0].clientY);
            }, { passive: false });
            this.canvas.addEventListener('touchmove', e => {
                e.preventDefault();
                this.onMove(e.touches[0].clientX, e.touches[0].clientY);
            }, { passive: false });
            this.canvas.addEventListener('touchend', e => { e.preventDefault(); this.onUp(); }, { passive: false });

            document.addEventListener('keydown', e => {
                this.keys[e.key] = true;
                if (e.key === 'Escape') this.togglePause();
                if ((e.key === 'r' || e.key === 'R') && this.state === 'gameover') this.startGame(this.mode);
                if (e.key === 's' || e.key === 'S') this.toggleSpectro();
                if (e.key >= '1' && e.key <= '4' && this.state === 'playing') {
                    const tools = ['brush', 'chisel', 'airjet', 'xray'];
                    this.tool = tools[parseInt(e.key) - 1];
                    this.updateToolButtons();
                }
            });
            document.addEventListener('keyup', e => { this.keys[e.key] = false; });
        }

        onDown(x, y) {
            if (this.state !== 'playing') return;
            this.initAudio();
            this.isDigging = true;
            this.lastMX = x; this.lastMY = y;
            this.excavateAt(x, y);
        }

        onMove(x, y) {
            this.lastMX = x; this.lastMY = y;
            if (this.isDigging && this.state === 'playing') {
                this.excavateAt(x, y);
            }
            if (this.state === 'playing') this.updateInfoPanel(x, y);
        }

        onUp() { this.isDigging = false; }

        // --- Excavation ---
        excavateAt(px, py) {
            const r = this.brushSize;
            const speed = this.diffSettings[this.difficulty].digSpeed;
            const col0 = Math.floor((px - r) / this.resolution);
            const col1 = Math.ceil((px + r) / this.resolution);
            const row0 = Math.floor((py - r) / this.resolution);
            const row1 = Math.ceil((py + r) / this.resolution);
            let cellsDug = 0;

            for (let row = row0; row <= row1; row++) {
                for (let col = col0; col <= col1; col++) {
                    if (col < 0 || col >= this.gridCols || row < 0 || row >= this.gridRows) continue;
                    const cx = col * this.resolution + this.resolution / 2;
                    const cy = row * this.resolution + this.resolution / 2;
                    const dist = Math.hypot(cx - px, cy - py);
                    if (dist > r) continue;

                    const idx = row * this.gridCols + col;
                    const oldDepth = this.grid[idx];
                    let intensity = (1 - dist / r);

                    if (this.tool === 'chisel') {
                        intensity *= 0.5;
                    } else if (this.tool === 'airjet') {
                        intensity *= 0.15;
                    } else if (this.tool === 'xray') {
                        intensity = 0; // X-ray doesn't dig, only reveals
                    }

                    const delta = intensity * 0.2 * this.digPower * speed;
                    const newDepth = Math.min(6, oldDepth + delta);

                    if (newDepth > oldDepth) {
                        this.grid[idx] = newDepth;
                        cellsDug++;

                        // Check layer transitions
                        const oldLayer = Math.floor(oldDepth);
                        const newLayer = Math.floor(newDepth);
                        if (newLayer > oldLayer && !this.layersDiscovered.has(newLayer)) {
                            this.layersDiscovered.add(newLayer);
                            const layer = this.PIGMENT_LAYERS[newLayer];
                            this.addScore(layer.points * 3, px, py);
                            this.addCombo();
                            this.playSound('discover');
                            this.shakeIntensity = 4;
                            this.floatingTexts.push({
                                x: px, y: py - 20,
                                text: 'NEW: ' + layer.name + '!',
                                life: 2.5, color: layer.color, big: true
                            });
                            this.addDiscovery(layer.name + ' (' + layer.era + ')', layer.rarity);
                            document.getElementById('disc-count').textContent = 'Discovered: ' + this.layersDiscovered.size + '/7 layers';

                            if (this.currentChallenge && this.currentChallenge.type === 'layers') {
                                this.challengeProgress = this.layersDiscovered.size;
                            }
                        }

                        // Emit particles
                        if (Math.random() < 0.15 && delta > 0.01) {
                            const layer = this.PIGMENT_LAYERS[Math.floor(oldDepth)];
                            this.particles.push({
                                x: cx + (Math.random() - 0.5) * 8,
                                y: cy + (Math.random() - 0.5) * 8,
                                vx: (Math.random() - 0.5) * 3,
                                vy: -Math.random() * 3 - 1,
                                size: 2 + Math.random() * 3,
                                life: 1,
                                hue: layer.hue, sat: layer.sat, light: layer.light
                            });
                        }

                        // Challenge tracking
                        if (this.currentChallenge) {
                            if (this.currentChallenge.type === 'surface' && oldDepth < 0.5) this.challengeProgress++;
                            if (this.currentChallenge.type === 'deep' && newDepth >= 5 && oldDepth < 5) this.challengeProgress++;
                            if (this.currentChallenge.type === 'chisel' && this.tool === 'chisel') this.challengeProgress++;
                            if (this.currentChallenge.type === 'airjet' && this.tool === 'airjet') this.challengeProgress++;
                            if (this.currentChallenge.type === 'speed') this.challengeProgress++;
                            if (this.currentChallenge.type === 'vermillion' && newLayer === 3) this.challengeProgress++;
                            if (this.currentChallenge.type === 'egyptian' && newDepth >= 5 && oldDepth < 5) this.challengeProgress++;
                            if (this.currentChallenge.type === 'bedrock' && newDepth >= 6 && oldDepth < 6) this.challengeProgress++;
                        }
                    }
                }
            }

            if (cellsDug > 0) {
                this.addScore(cellsDug, px, py);
                // Play tool sound
                if (this.tool === 'chisel') this.playSound('chisel');
                else if (this.tool === 'airjet') this.playSound('airjet');
                else this.playSound('dig');

                this.shakeIntensity = Math.min(3, this.tool === 'chisel' ? 2 : 0.5);
            }

            // Check treasure discovery
            this.checkTreasures(px, py);
        }

        checkTreasures(px, py) {
            const col = Math.floor(px / this.resolution);
            const row = Math.floor(py / this.resolution);

            this.hiddenTreasures.forEach(t => {
                if (t.found) return;
                const dist = Math.hypot(col - t.x, row - t.y);
                if (dist > t.radius + this.brushSize / this.resolution) return;

                // Check if depth at treasure location is deep enough
                const depth = this.getDepthAt(t.x, t.y);
                if (depth >= t.minDepth) {
                    t.found = true;
                    const worldX = t.x * this.resolution;
                    const worldY = t.y * this.resolution;

                    if (t.name.includes('Fossil') || t.name.includes('Cave Painting')) {
                        this.fossilsFound++;
                    } else {
                        this.mineralsFound++;
                    }

                    this.addScore(t.points, worldX, worldY);
                    this.addCombo();
                    this.addCombo();
                    this.playSound('treasure');
                    this.shakeIntensity = 6;

                    this.floatingTexts.push({
                        x: worldX, y: worldY - 30,
                        text: t.name + '! +' + t.points,
                        life: 3, color: t.color, big: true
                    });

                    this.addDiscovery(t.name, t.rarity);

                    // Treasure burst particles
                    for (let i = 0; i < 15; i++) {
                        const angle = (i / 15) * Math.PI * 2;
                        this.particles.push({
                            x: worldX, y: worldY,
                            vx: Math.cos(angle) * (3 + Math.random() * 3),
                            vy: Math.sin(angle) * (3 + Math.random() * 3),
                            size: 3 + Math.random() * 4,
                            life: 1,
                            hue: 45, sat: 90, light: 60
                        });
                    }

                    if (this.currentChallenge) {
                        if (this.currentChallenge.type === 'treasure') this.challengeProgress++;
                        if (this.currentChallenge.type === 'fossil' && (t.name.includes('Fossil') || t.name.includes('Cave'))) {
                            this.challengeProgress++;
                        }
                    }
                }
            });
        }

        addDiscovery(name, rarity) {
            this.discoveries.push({ name, rarity, time: this.gameTimer });
            this.renderDiscoveryLog();
        }

        renderDiscoveryLog() {
            const el = document.getElementById('log-entries');
            el.innerHTML = this.discoveries.slice(-15).reverse().map(d => {
                const cls = d.rarity === 'legendary' ? 'precious' : d.rarity === 'rare' ? 'rare' : '';
                return '<div class="log-entry ' + cls + '">' + d.name + '</div>';
            }).join('');
        }

        // --- Scoring ---
        addScore(points, x, y) {
            const mult = Math.max(1, this.combo);
            const total = Math.floor(points * mult);
            this.score += total;
            this.xp += total;

            if (points > 5) {
                this.floatingTexts.push({
                    x, y, text: '+' + total,
                    life: 0.8, color: this.combo > 3 ? '#fda' : '#d0b090'
                });
            }

            while (this.xp >= this.xpToLevel) {
                this.xp -= this.xpToLevel;
                this.level++;
                this.xpToLevel = Math.floor(this.xpToLevel * 1.35);
                this.playSound('levelup');
                this.shakeIntensity = 5;
                this.floatingTexts.push({
                    x: this.W / 2, y: this.H / 2,
                    text: 'LEVEL ' + this.level, life: 2, color: '#fff', big: true
                });
            }

            this.updateHUD();
            if (this.currentChallenge && this.currentChallenge.type === 'score') {
                this.challengeProgress = this.score;
            }
        }

        addCombo() {
            this.combo++;
            if (this.combo > this.maxCombo) this.maxCombo = this.combo;
            this.comboTimer = this.diffSettings[this.difficulty].comboDecay;
            if (this.combo > 1) this.playSound('combo');
            if (this.currentChallenge && this.currentChallenge.type === 'combo') {
                this.challengeProgress = Math.max(this.challengeProgress, this.combo);
            }
        }

        // --- Info Panel ---
        updateInfoPanel(x, y) {
            const col = Math.floor(x / this.resolution);
            const row = Math.floor(y / this.resolution);
            const depth = this.getDepthAt(col, row);
            const layer = this.getLayerAt(depth);

            document.getElementById('pigment-name').textContent = layer.name;
            document.getElementById('chem-formula').textContent = layer.formula;
            document.getElementById('era-info').textContent = layer.era;
            const ri = document.getElementById('rarity-info');
            ri.textContent = 'Rarity: ' + layer.rarity;
            ri.style.color = layer.rarity === 'Primordial' ? '#ffd700' :
                layer.rarity === 'Precious' ? '#c0a0ff' :
                layer.rarity === 'Ancient' ? '#60c0a0' :
                layer.rarity.includes('Toxic') ? '#ff6060' : '#a09080';

            // X-ray reveals nearby treasures
            if (this.tool === 'xray') {
                this.playSound('xray');
            }
        }

        // --- Spectroscope ---
        toggleSpectro() {
            this.spectroVisible = !this.spectroVisible;
            document.getElementById('spectro-panel').style.display = this.spectroVisible ? 'block' : 'none';
            if (this.spectroVisible) this.updateSpectro();
        }

        updateSpectro() {
            const counts = new Array(7).fill(0);
            let total = 0;
            for (let i = 0; i < this.grid.length; i++) {
                const layer = Math.floor(this.grid[i]);
                if (layer > 0) { counts[layer]++; total++; }
            }
            const el = document.getElementById('spectro-bars');
            el.innerHTML = this.PIGMENT_LAYERS.map((layer, i) => {
                const pct = total > 0 ? Math.round(counts[i] / total * 100) : 0;
                const h = Math.max(5, pct * 0.5 + 5);
                return '<div class="spectro-bar" style="background:' + layer.color + ';height:' + h + 'px;line-height:' + h + 'px">' +
                    '<span class="spectro-pct">' + pct + '%</span>' +
                    '<span class="spectro-label">' + layer.name.split(' ')[0] + '</span></div>';
            }).join('');
        }

        // --- Drawing ---
        drawGrid() {
            const res = this.resolution;
            const cols = this.gridCols;
            const rows = this.gridRows;
            const layers = this.PIGMENT_LAYERS;

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const idx = row * cols + col;
                    const depth = this.grid[idx];
                    const li = Math.floor(depth);
                    const layer = layers[li];
                    const nextLayer = layers[Math.min(li + 1, 6)];
                    const blend = depth - li;

                    const h = layer.hue + (nextLayer.hue - layer.hue) * blend;
                    const s = layer.sat + (nextLayer.sat - layer.sat) * blend;
                    const l = layer.light + (nextLayer.light - layer.light) * blend;

                    this.ctx.fillStyle = 'hsl(' + h + ',' + s + '%,' + l + '%)';
                    this.ctx.fillRect(col * res, row * res, res, res);

                    // Depth shadow for revealed cells
                    if (depth > 0.3) {
                        this.ctx.fillStyle = 'rgba(0,0,0,0.08)';
                        this.ctx.fillRect(col * res, row * res + res - 1, res, 1);
                    }
                }
            }

            // Draw X-ray overlay showing treasure proximity
            if (this.tool === 'xray') {
                const mx = this.lastMX;
                const my = this.lastMY;
                this.hiddenTreasures.forEach(t => {
                    if (t.found) return;
                    const tx = t.x * res + res / 2;
                    const ty = t.y * res + res / 2;
                    const dist = Math.hypot(mx - tx, my - ty);
                    if (dist < 200) {
                        const alpha = Math.max(0, (200 - dist) / 200) * 0.4;
                        const pulse = Math.sin(this.gameTimer * 4) * 0.1 + 0.9;
                        this.ctx.beginPath();
                        this.ctx.arc(tx, ty, 8 * pulse, 0, Math.PI * 2);
                        this.ctx.fillStyle = 'rgba(255,255,100,' + alpha + ')';
                        this.ctx.fill();
                        this.ctx.strokeStyle = 'rgba(255,200,50,' + (alpha * 0.5) + ')';
                        this.ctx.lineWidth = 1;
                        this.ctx.stroke();
                    }
                });
            }

            // Draw found treasures as markers
            this.hiddenTreasures.forEach(t => {
                if (!t.found) return;
                const tx = t.x * res + res / 2;
                const ty = t.y * res + res / 2;
                const pulse = Math.sin(this.gameTimer * 2) * 2 + 6;
                this.ctx.beginPath();
                this.ctx.arc(tx, ty, pulse, 0, Math.PI * 2);
                this.ctx.strokeStyle = t.color;
                this.ctx.lineWidth = 1.5;
                this.ctx.stroke();
            });
        }

        drawParticles() {
            for (let i = this.particles.length - 1; i >= 0; i--) {
                const p = this.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.12;
                p.life -= 0.02;
                if (p.life <= 0 || p.y > this.H + 20) {
                    this.particles.splice(i, 1);
                    continue;
                }
                this.ctx.beginPath();
                this.ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                this.ctx.fillStyle = 'hsla(' + p.hue + ',' + p.sat + '%,' + p.light + '%,' + (p.life * 0.7) + ')';
                this.ctx.fill();
            }
        }

        drawFloatingTexts() {
            for (let i = this.floatingTexts.length - 1; i >= 0; i--) {
                const ft = this.floatingTexts[i];
                ft.y -= 1.2;
                ft.life -= 0.015;
                if (ft.life <= 0) { this.floatingTexts.splice(i, 1); continue; }
                this.ctx.save();
                this.ctx.globalAlpha = Math.min(1, ft.life * 2);
                this.ctx.font = (ft.big ? 'bold 24px' : '13px') + ' Georgia, serif';
                this.ctx.fillStyle = ft.color;
                this.ctx.textAlign = 'center';
                this.ctx.fillText(ft.text, ft.x, ft.y);
                this.ctx.restore();
            }
        }

        drawCursor() {
            if (this.state !== 'playing') return;
            const mx = this.lastMX;
            const my = this.lastMY;
            this.ctx.beginPath();
            this.ctx.arc(mx, my, this.brushSize, 0, Math.PI * 2);
            this.ctx.strokeStyle = 'rgba(200,180,140,0.3)';
            this.ctx.lineWidth = 1;
            this.ctx.setLineDash([4, 4]);
            this.ctx.stroke();
            this.ctx.setLineDash([]);
        }

        // --- Update ---
        update(dt) {
            if (this.state !== 'playing') return;
            this.gameTimer += dt;

            // Combo decay
            if (this.combo > 0) {
                this.comboTimer -= dt * 1000;
                if (this.comboTimer <= 0) {
                    this.combo = 0;
                    this.updateHUD();
                }
            }

            // Expedition timer
            if (this.mode === 'expedition') {
                this.expeditionTimer -= dt;
                document.getElementById('hud-timer').textContent = Math.ceil(Math.max(0, this.expeditionTimer)) + 's';
                if (this.expeditionTimer <= 0) this.endGame();
            }

            // Challenge
            if (this.currentChallenge) {
                this.challengeTimer -= dt;
                if (this.challengeProgress >= this.currentChallenge.target) {
                    this.completeChallenge();
                } else if (this.challengeTimer <= 0) {
                    this.failChallenge();
                }
                this.updateChallengeBanner();
            }

            if (this.mode === 'challenge' && !this.currentChallenge) {
                this.assignChallenge();
            }

            // Screen shake
            if (this.shakeIntensity > 0) {
                this.shakeX = (Math.random() - 0.5) * this.shakeIntensity * 2;
                this.shakeY = (Math.random() - 0.5) * this.shakeIntensity * 2;
                this.shakeIntensity *= 0.88;
                if (this.shakeIntensity < 0.1) { this.shakeIntensity = 0; this.shakeX = 0; this.shakeY = 0; }
            }

            // Update spectroscope if visible
            if (this.spectroVisible && Math.floor(this.gameTimer * 2) !== Math.floor((this.gameTimer - dt) * 2)) {
                this.updateSpectro();
            }
        }

        // --- Challenges ---
        assignChallenge() {
            const idx = Math.floor(Math.random() * this.allChallenges.length);
            const tmpl = this.allChallenges[idx];
            this.currentChallenge = { ...tmpl };
            const timeMult = this.difficulty === 'casual' ? 1.5 : this.difficulty === 'expert' ? 0.65 : 1;
            this.currentChallenge.time = Math.floor(tmpl.time * timeMult);
            this.challengeTimer = this.currentChallenge.time;
            this.challengeProgress = 0;
            this.playSound('challenge');
            document.getElementById('challenge-banner').style.display = 'block';
            document.getElementById('challenge-text').textContent = this.currentChallenge.name + ': ' + this.currentChallenge.desc;
        }

        completeChallenge() {
            this.challengesCompleted++;
            const bonus = 400 * this.level;
            this.addScore(bonus, this.W / 2, this.H / 2);
            this.playSound('levelup');
            this.shakeIntensity = 5;
            this.floatingTexts.push({
                x: this.W / 2, y: this.H / 2 - 30,
                text: 'CHALLENGE COMPLETE! +' + bonus, life: 2.5, color: '#fda', big: true
            });
            for (let i = 0; i < 18; i++) {
                this.particles.push({
                    x: this.W / 2, y: this.H / 2,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    size: 2 + Math.random() * 3,
                    life: 1, hue: 40, sat: 90, light: 60
                });
            }
            this.currentChallenge = null;
            document.getElementById('challenge-banner').style.display = 'none';
        }

        failChallenge() {
            this.floatingTexts.push({
                x: this.W / 2, y: this.H / 2,
                text: 'Challenge Failed', life: 1.5, color: '#f88', big: true
            });
            this.currentChallenge = null;
            document.getElementById('challenge-banner').style.display = 'none';
        }

        updateChallengeBanner() {
            if (!this.currentChallenge) return;
            const pct = Math.min(100, (this.challengeProgress / this.currentChallenge.target) * 100);
            document.getElementById('challenge-fill').style.width = pct + '%';
            document.getElementById('challenge-text').textContent =
                this.currentChallenge.name + ': ' + this.challengeProgress + '/' + this.currentChallenge.target +
                ' (' + Math.ceil(this.challengeTimer) + 's)';
        }

        // --- HUD ---
        updateHUD() {
            document.getElementById('hud-score').textContent = this.score.toLocaleString();
            document.getElementById('hud-combo').textContent = this.combo > 1 ? ' x' + this.combo : '';
            document.getElementById('hud-level').textContent = 'Level ' + this.level + ' | Layers: ' + this.layersDiscovered.size + '/7';
        }

        updateToolButtons() {
            document.querySelectorAll('#tool-panel .tool-btn[data-tool]').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tool === this.tool);
            });
        }

        // --- Game State ---
        startGame(mode) {
            this.initAudio();
            this.mode = mode;
            this.state = 'playing';
            this.score = 0;
            this.combo = 0;
            this.maxCombo = 0;
            this.comboTimer = 0;
            this.level = 1;
            this.xp = 0;
            this.xpToLevel = 400;
            this.layersDiscovered = new Set();
            this.layersDiscovered.add(0); // Surface is always discovered
            this.mineralsFound = 0;
            this.fossilsFound = 0;
            this.discoveries = [];
            this.challengesCompleted = 0;
            this.particles = [];
            this.floatingTexts = [];
            this.gameTimer = 0;
            this.currentChallenge = null;
            this.challengeProgress = 0;
            this.tool = 'brush';
            this.brushSize = 30;
            this.digPower = 3;
            this.spectroVisible = false;
            this.expeditionTimer = this.diffSettings[this.difficulty].timerDuration;

            this.initGrid();
            this.renderDiscoveryLog();

            document.getElementById('title-screen').style.display = 'none';
            document.getElementById('gameover-screen').style.display = 'none';
            document.getElementById('pause-overlay').style.display = 'none';
            document.getElementById('hud').style.display = 'block';
            document.getElementById('info-panel').style.display = 'block';
            document.getElementById('collection-log').style.display = 'block';
            document.getElementById('tool-panel').style.display = 'block';
            document.getElementById('challenge-banner').style.display = 'none';
            document.getElementById('spectro-panel').style.display = 'none';
            document.getElementById('disc-count').textContent = 'Discovered: 1/7 layers';

            this.updateHUD();
            this.updateToolButtons();
        }

        endGame() {
            this.state = 'gameover';
            this.playSound('gameover');

            const grade = this.score >= 8000 ? 'S' : this.score >= 4000 ? 'A' : this.score >= 1500 ? 'B' : this.score >= 500 ? 'C' : 'D';
            document.getElementById('go-grade').textContent = grade;
            document.getElementById('go-grade').className = 'grade-display grade-' + grade;
            document.getElementById('go-score').textContent = this.score.toLocaleString();
            document.getElementById('go-layers').textContent = this.layersDiscovered.size;
            document.getElementById('go-minerals').textContent = this.mineralsFound;
            document.getElementById('go-fossils').textContent = this.fossilsFound;
            document.getElementById('go-combo').textContent = 'x' + this.maxCombo;
            document.getElementById('go-challenges').textContent = this.challengesCompleted;

            const isNew = this.saveHighScore(this.score);
            document.getElementById('go-newbest').style.display = isNew ? 'block' : 'none';

            document.getElementById('gameover-screen').style.display = 'flex';
            document.getElementById('hud').style.display = 'none';
        }

        togglePause() {
            if (this.state === 'playing') {
                this.state = 'paused';
                document.getElementById('pause-overlay').style.display = 'flex';
            } else if (this.state === 'paused') {
                this.state = 'playing';
                document.getElementById('pause-overlay').style.display = 'none';
            }
        }

        returnToMenu() {
            this.state = 'title';
            document.getElementById('title-screen').style.display = 'flex';
            document.getElementById('gameover-screen').style.display = 'none';
            document.getElementById('pause-overlay').style.display = 'none';
            document.getElementById('hud').style.display = 'none';
            document.getElementById('info-panel').style.display = 'none';
            document.getElementById('collection-log').style.display = 'none';
            document.getElementById('tool-panel').style.display = 'none';
            document.getElementById('challenge-banner').style.display = 'none';
            document.getElementById('spectro-panel').style.display = 'none';
            this.renderHighScores();
        }

        // --- High Scores ---
        loadHighScores() {
            try {
                this.highScores = JSON.parse(localStorage.getItem('pigment_scores')) || [];
            } catch(e) { this.highScores = []; }
        }

        saveHighScore(score) {
            this.highScores.push({ score, mode: this.mode, difficulty: this.difficulty, date: new Date().toISOString().slice(0,10) });
            this.highScores.sort((a, b) => b.score - a.score);
            this.highScores = this.highScores.slice(0, 10);
            localStorage.setItem('pigment_scores', JSON.stringify(this.highScores));
            return this.highScores[0].score === score;
        }

        renderHighScores() {
            const el = document.getElementById('hs-list');
            if (this.highScores.length === 0) {
                el.innerHTML = '<div class="hs-entry">No scores yet</div>';
                return;
            }
            el.innerHTML = this.highScores.slice(0, 5).map((s, i) =>
                '<div class="hs-entry">' + (i + 1) + '. ' + s.score.toLocaleString() + ' (' + s.mode + '/' + s.difficulty + ')</div>'
            ).join('');
        }

        // --- Menu ---
        setupMenuButtons() {
            document.querySelectorAll('.diff-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    this.difficulty = btn.dataset.diff;
                });
            });

            document.getElementById('btn-freeexcav').addEventListener('click', () => this.startGame('freeexcav'));
            document.getElementById('btn-challenge').addEventListener('click', () => this.startGame('challenge'));
            document.getElementById('btn-expedition').addEventListener('click', () => this.startGame('expedition'));

            document.getElementById('btn-resume').addEventListener('click', () => this.togglePause());
            document.getElementById('btn-quit').addEventListener('click', () => this.returnToMenu());
            document.getElementById('btn-again').addEventListener('click', () => this.startGame(this.mode));
            document.getElementById('btn-menu').addEventListener('click', () => this.returnToMenu());

            document.querySelectorAll('#tool-panel .tool-btn[data-tool]').forEach(btn => {
                btn.addEventListener('click', () => {
                    this.tool = btn.dataset.tool;
                    this.updateToolButtons();
                });
            });

            document.getElementById('brush-size').addEventListener('input', e => {
                this.brushSize = parseInt(e.target.value);
            });
            document.getElementById('dig-power').addEventListener('input', e => {
                this.digPower = parseInt(e.target.value);
            });
            document.getElementById('btn-spectro').addEventListener('click', () => this.toggleSpectro());
            document.getElementById('btn-restore').addEventListener('click', () => {
                this.grid.fill(0);
                this.hiddenTreasures.forEach(t => t.found = false);
                this.layersDiscovered = new Set();
                this.layersDiscovered.add(0);
                document.getElementById('disc-count').textContent = 'Discovered: 1/7 layers';
            });
        }

        // --- Main Loop ---
        loop(timestamp) {
            const dt = Math.min(0.05, (timestamp - this.lastTime) / 1000);
            this.lastTime = timestamp;

            this.update(dt);

            this.ctx.save();
            if (this.shakeIntensity > 0) {
                this.ctx.translate(this.shakeX, this.shakeY);
            }

            if (this.state === 'playing' || this.state === 'paused' || this.state === 'gameover') {
                this.drawGrid();
                this.drawParticles();
                this.drawFloatingTexts();
                this.drawCursor();
            } else {
                // Title screen
                this.ctx.fillStyle = '#1a1510';
                this.ctx.fillRect(0, 0, this.W, this.H);

                // Animated layer preview
                const t = timestamp * 0.001;
                const layers = this.PIGMENT_LAYERS;
                for (let i = 0; i < layers.length; i++) {
                    const y = this.H * 0.3 + i * (this.H * 0.08);
                    const wave = Math.sin(t * 0.5 + i * 0.8) * 20;
                    this.ctx.fillStyle = layers[i].color;
                    this.ctx.globalAlpha = 0.15;
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y + wave);
                    for (let x = 0; x < this.W; x += 20) {
                        this.ctx.lineTo(x, y + wave + Math.sin(t + x * 0.01 + i) * 10);
                    }
                    this.ctx.lineTo(this.W, this.H);
                    this.ctx.lineTo(0, this.H);
                    this.ctx.fill();
                }
                this.ctx.globalAlpha = 1;
            }

            this.ctx.restore();

            requestAnimationFrame(t => this.loop(t));
        }
    }

    const game = new PigmentGame();
    </script>
</body>
</html>