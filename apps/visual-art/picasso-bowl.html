<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="A 3D interactive exploration of Cubism, deconstructing the essence of a simple bowl into geometric planes and multiple perspectives.">
    <!-- visual_art, 3d, cubism, picasso, interactive, threejs, abstract -->
    <title>Picasso's Essence of the Bowl</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #F2E9D8; /* Canvas/Paper tone */
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        #ui {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: none;
            color: #262626;
        }
        h1 {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
            letter-spacing: 2px;
            text-transform: uppercase;
            font-weight: 300;
        }
        p {
            font-size: 0.9rem;
            opacity: 0.7;
            margin-bottom: 1.5rem;
            font-style: italic;
        }
        button {
            pointer-events: auto;
            background: transparent;
            border: 1px solid #262626;
            color: #262626;
            padding: 10px 20px;
            font-family: inherit;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        button:hover {
            background: #262626;
            color: #F2E9D8;
        }
        .signature {
            position: absolute;
            bottom: 20px;
            right: 30px;
            font-family: 'Brush Script MT', cursive;
            font-size: 2rem;
            color: #262626;
            opacity: 0.8;
            pointer-events: none;
            transform: rotate(-5deg);
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="ui">
        <h1>Essence of the Bowl</h1>
        <p>"I paint objects as I think them, not as I see them."</p>
        <button id="recompose-btn">Recompose Perspective</button>
    </div>

    <div class="signature">Picasso</div>

    <!-- Import Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Configuration ---
        const PALETTE = [
            0xA67B5B, // Ochre
            0x405060, // Blue Grey
            0xD98E73, // Terracotta
            0xE6C229, // Mustard
            0x8C3B3B, // Deep Red
            0x262626, // Charcoal
            0xF2E9D8  // Canvas
        ];

        // --- Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xF2E9D8);
        scene.fog = new THREE.Fog(0xF2E9D8, 10, 50);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 5, 12);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 5;
        controls.maxDistance = 20;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // --- Lighting ---
        // Cubism often has flat or ambiguous lighting, but we need some shadows for depth
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(5, 10, 7);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        const fillLight = new THREE.DirectionalLight(0xA67B5B, 0.3);
        fillLight.position.set(-5, 0, -5);
        scene.add(fillLight);

        // --- The "Bowl" ---
        const artGroup = new THREE.Group();
        scene.add(artGroup);

        function createShardMaterial(color) {
            return new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.9, // Matte, like paint
                metalness: 0.0,
                side: THREE.DoubleSide,
                flatShading: true
            });
        }

        function createOutlineMaterial() {
            return new THREE.LineBasicMaterial({
                color: 0x262626,
                linewidth: 2,
                opacity: 0.8,
                transparent: true
            });
        }

        // Generate the Cubist Bowl
        function generateBowl() {
            // Clear existing
            while(artGroup.children.length > 0){ 
                const obj = artGroup.children[0];
                artGroup.remove(obj);
                if(obj.geometry) obj.geometry.dispose();
                if(obj.material) obj.material.dispose();
            }

            // 1. The Main Bowl Form (Deconstructed)
            // We use a LatheGeometry as a base, but don't render it directly.
            // Instead, we create shards based on its vertices.
            
            const points = [];
            for ( let i = 0; i < 10; i ++ ) {
                points.push( new THREE.Vector2( Math.sin( i * 0.2 ) * 3 + 1, ( i - 5 ) * 0.8 ) );
            }
            const baseGeo = new THREE.LatheGeometry( points, 12 ); // Low segments for angular look
            const posAttribute = baseGeo.attributes.position;
            
            // Create individual triangular shards from the geometry faces
            // Since LatheGeometry is indexed, we need to look at the index
            const index = baseGeo.index;
            
            for (let i = 0; i < index.count; i += 3) {
                const a = index.getX(i);
                const b = index.getX(i+1);
                const c = index.getX(i+2);

                const vA = new THREE.Vector3().fromBufferAttribute(posAttribute, a);
                const vB = new THREE.Vector3().fromBufferAttribute(posAttribute, b);
                const vC = new THREE.Vector3().fromBufferAttribute(posAttribute, c);

                // Create a triangle geometry
                const shardGeo = new THREE.BufferGeometry();
                const vertices = new Float32Array([
                    vA.x, vA.y, vA.z,
                    vB.x, vB.y, vB.z,
                    vC.x, vC.y, vC.z
                ]);
                shardGeo.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                shardGeo.computeVertexNormals();

                // Randomize the shard
                const center = new THREE.Vector3().addVectors(vA, vB).add(vC).divideScalar(3);
                
                // Offset from center (explode effect)
                const explodeFactor = Math.random() * 0.5;
                const offset = center.clone().normalize().multiplyScalar(explodeFactor);
                
                // Random rotation
                const rotX = (Math.random() - 0.5) * 0.5;
                const rotY = (Math.random() - 0.5) * 0.5;
                const rotZ = (Math.random() - 0.5) * 0.5;

                // Pick a random color from palette
                const color = PALETTE[Math.floor(Math.random() * PALETTE.length)];
                
                const mesh = new THREE.Mesh(shardGeo, createShardMaterial(color));
                mesh.position.add(offset);
                mesh.rotation.set(rotX, rotY, rotZ);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                
                // Add outline to some shards
                if (Math.random() > 0.3) {
                    const edges = new THREE.EdgesGeometry(shardGeo);
                    const line = new THREE.LineSegments(edges, createOutlineMaterial());
                    mesh.add(line);
                }

                artGroup.add(mesh);
            }

            // 2. Abstract "Fruit" or Objects inside
            for (let i = 0; i < 3; i++) {
                const geo = new THREE.DodecahedronGeometry(0.8, 0);
                const color = PALETTE[Math.floor(Math.random() * PALETTE.length)];
                const mesh = new THREE.Mesh(geo, createShardMaterial(color));
                
                mesh.position.set(
                    (Math.random() - 0.5) * 2,
                    (Math.random() * 1) - 1,
                    (Math.random() - 0.5) * 2
                );
                mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
                mesh.castShadow = true;
                
                // Outline
                const edges = new THREE.EdgesGeometry(geo);
                const line = new THREE.LineSegments(edges, createOutlineMaterial());
                mesh.add(line);
                
                artGroup.add(mesh);
            }

            // 3. The "Table" / Environment Planes
            // Large flat planes intersecting at odd angles
            for (let i = 0; i < 5; i++) {
                const w = 5 + Math.random() * 10;
                const h = 5 + Math.random() * 10;
                const geo = new THREE.PlaneGeometry(w, h);
                const color = PALETTE[Math.floor(Math.random() * PALETTE.length)];
                const mat = createShardMaterial(color);
                mat.opacity = 0.8;
                mat.transparent = true;
                
                const mesh = new THREE.Mesh(geo, mat);
                
                // Position around the bowl
                mesh.position.set(
                    (Math.random() - 0.5) * 10,
                    -2 - Math.random() * 3,
                    (Math.random() - 0.5) * 5
                );
                
                // Random orientation
                mesh.rotation.x = -Math.PI / 2 + (Math.random() - 0.5) * 0.5;
                mesh.rotation.y = (Math.random() - 0.5) * 0.5;
                mesh.rotation.z = (Math.random() - 0.5) * Math.PI;
                
                mesh.receiveShadow = true;
                artGroup.add(mesh);
            }
        }

        // --- Animation ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // --- Interaction ---
        document.getElementById('recompose-btn').addEventListener('click', () => {
            // Animate out? Or just regenerate.
            // Let's just regenerate for instant gratification.
            generateBowl();
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start
        generateBowl();
        animate();

    </script>
</body>
</html>