<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
    />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <title>Nexus Hub - Gesture World Explorer</title>
    <link
      rel="icon"
      type="image/x-icon"
      href="data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg=="
    />

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        user-select: none;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Oxygen, Ubuntu, Cantarell, sans-serif;
        background: #000;
        color: #fff;
        overflow: hidden;
        position: fixed;
        width: 100%;
        height: 100%;
        -webkit-overflow-scrolling: touch;
      }

      #three-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        touch-action: none;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        user-select: none;
      }

      /* Portal Loading Indicator */
      .portal-loading {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        z-index: 2001;
        background: rgba(0, 0, 0, 0.8);
        padding: 30px;
        border-radius: 20px;
        border: 2px solid rgba(138, 56, 236, 0.5);
        backdrop-filter: blur(10px);
      }

      .portal-loading h3 {
        color: #06ffa5;
        font-size: 24px;
        margin-bottom: 20px;
      }

      .portal-loading-spinner {
        width: 60px;
        height: 60px;
        border: 3px solid rgba(138, 56, 236, 0.3);
        border-top: 3px solid #8338ec;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 0 auto 20px;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .portal-loading-status {
        color: rgba(255, 255, 255, 0.8);
        font-size: 14px;
      }

      /* Portal Error Message */
      .portal-error {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(255, 0, 0, 0.2);
        border: 2px solid rgba(255, 0, 0, 0.5);
        padding: 15px 30px;
        border-radius: 20px;
        backdrop-filter: blur(10px);
        z-index: 2000;
        display: none;
      }

      .portal-error.show {
        display: block;
      }

      /* Hand Tracking UI */
      .hand-tracking-container {
        position: fixed;
        bottom: 20px;
        left: 20px;
        width: 240px;
        height: 180px;
        background: rgba(0, 0, 0, 0.8);
        border: 2px solid rgba(138, 56, 236, 0.5);
        border-radius: 15px;
        overflow: hidden;
        z-index: 2000;
        backdrop-filter: blur(10px);
        transition: all 0.3s ease;
      }

      .hand-tracking-container.minimized {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        cursor: pointer;
      }

      .hand-tracking-container.minimized .webcam-feed,
      .hand-tracking-container.minimized .gesture-overlay,
      .hand-tracking-container.minimized .gesture-status {
        display: none;
      }

      .hand-tracking-container.minimized::after {
        content: "‚úã";
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 30px;
      }

      .webcam-feed {
        width: 100%;
        height: 100%;
        object-fit: cover;
        transform: scaleX(-1);
      }

      .gesture-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        transform: scaleX(-1);
      }

      .gesture-status {
        position: absolute;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(138, 56, 236, 0.9);
        color: white;
        padding: 5px 15px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      /* Hand Cursor */
      .hand-cursor {
        position: fixed;
        width: 50px;
        height: 50px;
        border: 3px solid rgba(6, 255, 165, 0.8);
        border-radius: 50%;
        pointer-events: none;
        z-index: 9999;
        display: none;
        transition: all 0.1s ease;
        box-shadow: 0 0 30px rgba(6, 255, 165, 0.5);
        background: radial-gradient(
          circle,
          rgba(6, 255, 165, 0.3),
          transparent
        );
      }

      .hand-cursor.pinching {
        background: radial-gradient(
          circle,
          rgba(6, 255, 165, 0.6),
          rgba(6, 255, 165, 0.2)
        );
        transform: scale(0.8);
        border-color: rgba(255, 255, 255, 0.9);
      }

      .hand-cursor.pointing {
        border-color: rgba(255, 106, 0, 0.8);
        box-shadow: 0 0 30px rgba(255, 106, 0, 0.5);
      }

      /* Gesture Instructions */
      .gesture-guide {
        position: fixed;
        top: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 15px;
        padding: 20px;
        z-index: 1500;
        max-width: 300px;
        transition: all 0.3s ease;
      }

      .gesture-guide.hidden {
        opacity: 0;
        pointer-events: none;
        transform: translateX(20px);
      }

      .gesture-guide h3 {
        color: #06ffa5;
        font-size: 16px;
        margin-bottom: 15px;
        font-weight: 500;
      }

      .gesture-item {
        display: flex;
        align-items: center;
        margin: 10px 0;
        color: rgba(255, 255, 255, 0.8);
        font-size: 13px;
      }

      .gesture-icon {
        font-size: 24px;
        margin-right: 15px;
        width: 40px;
        text-align: center;
      }

      .gesture-description {
        flex: 1;
      }

      /* Gesture Feedback */
      .gesture-feedback {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(138, 56, 236, 0.9);
        color: white;
        padding: 20px 40px;
        border-radius: 30px;
        font-size: 24px;
        font-weight: bold;
        opacity: 0;
        pointer-events: none;
        z-index: 3000;
        transition: all 0.3s ease;
      }

      .gesture-feedback.show {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.1);
      }

      /* Camera Permission Error */
      .camera-error {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        padding: 40px;
        background: rgba(20, 20, 40, 0.95);
        border: 2px solid rgba(255, 0, 0, 0.5);
        border-radius: 20px;
        z-index: 2000;
        max-width: 500px;
        box-shadow: 0 0 50px rgba(255, 0, 0, 0.3);
      }

      .camera-error h3 {
        color: #ff6b6b;
        margin-bottom: 20px;
        font-size: 24px;
      }

      .camera-error p {
        margin: 15px 0;
        color: rgba(255, 255, 255, 0.8);
        line-height: 1.6;
      }

      .camera-error .error-details {
        font-size: 14px;
        color: rgba(255, 255, 255, 0.6);
        margin: 20px 0;
        padding: 15px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 10px;
        text-align: left;
      }

      .camera-error button {
        background: linear-gradient(45deg, #ff006e, #8338ec);
        color: white;
        border: none;
        padding: 12px 30px;
        border-radius: 25px;
        margin: 10px;
        cursor: pointer;
        font-size: 16px;
        font-weight: bold;
        transition: all 0.3s ease;
      }

      .camera-error button:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 20px rgba(255, 0, 110, 0.4);
      }

      .camera-error .fallback-btn {
        background: linear-gradient(45deg, #666, #999);
      }

      /* Interactive Elements with Gesture Indicators */
      .gesture-interactive {
        position: relative;
        transition: all 0.3s ease;
      }

      .gesture-interactive::after {
        content: "";
        position: absolute;
        top: -5px;
        left: -5px;
        right: -5px;
        bottom: -5px;
        border: 2px solid rgba(6, 255, 165, 0.5);
        border-radius: inherit;
        opacity: 0;
        transition: all 0.3s ease;
        pointer-events: none;
      }

      .gesture-interactive.gesture-hover::after {
        opacity: 1;
        animation: pulseGlow 1s infinite;
      }

      .gesture-interactive.mouse-enabled {
        cursor: pointer !important;
      }

      @keyframes pulseGlow {
        0%,
        100% {
          border-color: rgba(6, 255, 165, 0.5);
          transform: scale(1);
        }
        50% {
          border-color: rgba(6, 255, 165, 0.8);
          transform: scale(1.05);
        }
      }

      /* Portal Gesture Interaction */
      .portal-gesture-indicator {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 40px;
        height: 40px;
        border: 3px solid rgba(255, 255, 255, 0.8);
        border-radius: 50%;
        opacity: 0;
        transition: all 0.3s ease;
        pointer-events: none;
      }

      .portal-gesture-indicator.ready {
        opacity: 1;
        animation: portalReady 1s infinite;
      }

      @keyframes portalReady {
        0%,
        100% {
          transform: translate(-50%, -50%) scale(1);
        }
        50% {
          transform: translate(-50%, -50%) scale(1.2);
        }
      }

      /* Gesture-based Menu */
      .gesture-menu {
        position: fixed;
        right: -300px;
        top: 50%;
        transform: translateY(-50%);
        background: rgba(20, 20, 40, 0.95);
        border: 2px solid rgba(138, 56, 236, 0.5);
        border-radius: 20px 0 0 20px;
        padding: 30px;
        z-index: 1999;
        transition: all 0.3s ease;
        width: 300px;
        max-height: 80vh;
        overflow-y: auto;
      }

      .gesture-menu.open {
        right: 0;
      }

      .gesture-menu-item {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 15px;
        padding: 15px;
        margin: 10px 0;
        transition: all 0.3s ease;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 15px;
      }

      .gesture-menu-item:hover,
      .gesture-menu-item.gesture-hover {
        background: rgba(138, 56, 236, 0.3);
        border-color: rgba(138, 56, 236, 0.5);
        transform: translateX(-10px);
      }

      .gesture-menu-icon {
        font-size: 30px;
        width: 40px;
        text-align: center;
      }

      .gesture-menu-text {
        flex: 1;
      }

      .gesture-menu-title {
        font-weight: bold;
        color: #06ffa5;
        margin-bottom: 5px;
      }

      .gesture-menu-description {
        font-size: 12px;
        color: rgba(255, 255, 255, 0.7);
      }

      /* AI Chat with Gesture Support */
      .ai-chat-interface {
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 350px;
        height: 450px;
        background: rgba(20, 20, 40, 0.85);
        border: 2px solid rgba(138, 56, 236, 0.5);
        border-radius: 20px;
        display: none;
        flex-direction: column;
        z-index: 1003;
        box-shadow: 0 0 30px rgba(138, 56, 236, 0.3);
        backdrop-filter: blur(5px);
        transition: all 0.3s ease;
      }

      .ai-chat-interface.active {
        display: flex;
      }

      .ai-chat-interface.gesture-focus {
        border-color: rgba(6, 255, 165, 0.8);
        box-shadow: 0 0 40px rgba(6, 255, 165, 0.5);
      }

      /* Gesture Swipe Indicators */
      .swipe-indicator {
        position: fixed;
        z-index: 2500;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .swipe-indicator.left,
      .swipe-indicator.right {
        top: 50%;
        transform: translateY(-50%);
        font-size: 40px;
        color: rgba(6, 255, 165, 0.8);
      }

      .swipe-indicator.left {
        left: 20px;
      }

      .swipe-indicator.right {
        right: 20px;
      }

      .swipe-indicator.up,
      .swipe-indicator.down {
        left: 50%;
        transform: translateX(-50%);
        font-size: 40px;
        color: rgba(6, 255, 165, 0.8);
      }

      .swipe-indicator.up {
        top: 20px;
      }

      .swipe-indicator.down {
        bottom: 20px;
      }

      .swipe-indicator.active {
        opacity: 1;
      }

      /* Scene Recorder with Gestures */
      .scene-recorder-button {
        position: fixed;
        bottom: calc(env(safe-area-inset-bottom, 30px) + 220px);
        right: calc(env(safe-area-inset-right, 30px));
        width: 60px;
        height: 60px;
        background: rgba(255, 0, 0, 0.3);
        backdrop-filter: blur(10px);
        border: 2px solid rgba(255, 0, 0, 0.5);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
        z-index: 1002;
        box-shadow: 0 0 20px rgba(255, 0, 0, 0.3);
      }

      .scene-recorder-button.gesture-hover {
        background: rgba(255, 0, 0, 0.5);
        transform: scale(1.1);
        box-shadow: 0 0 30px rgba(255, 0, 0, 0.5);
      }

      .scene-recorder-button.recording {
        animation: recordPulse 1s infinite;
      }

      @keyframes recordPulse {
        0% {
          box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7);
        }
        70% {
          box-shadow: 0 0 0 10px rgba(255, 0, 0, 0);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(255, 0, 0, 0);
        }
      }

      .scene-recorder-button svg {
        width: 28px;
        height: 28px;
        color: white;
      }

      /* Scene Recorder Modal */
      .scene-recorder-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        z-index: 3002;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(5px);
      }

      .scene-recorder-modal.show {
        display: flex;
      }

      .scene-recorder-content {
        background: rgba(20, 20, 40, 0.95);
        border: 2px solid rgba(255, 255, 255, 0.2);
        border-radius: 20px;
        padding: 30px;
        max-width: 600px;
        width: 90%;
        max-height: 90vh;
        overflow-y: auto;
        box-shadow: 0 0 50px rgba(255, 0, 0, 0.3);
      }

      .scene-recorder-content h3 {
        margin: 0 0 20px 0;
        font-size: 24px;
        background: linear-gradient(45deg, #ff0000, #ff6b6b);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        text-align: center;
      }

      .recording-status {
        background: rgba(255, 0, 0, 0.1);
        border: 1px solid rgba(255, 0, 0, 0.3);
        border-radius: 10px;
        padding: 15px;
        margin: 15px 0;
        text-align: center;
      }

      .recording-status.active {
        animation: pulse 2s infinite;
      }

      .recording-timer {
        font-size: 24px;
        font-weight: bold;
        color: #ff6b6b;
        margin: 10px 0;
      }

      .recording-info {
        font-size: 14px;
        color: rgba(255, 255, 255, 0.7);
      }

      .scene-controls {
        display: flex;
        gap: 10px;
        justify-content: center;
        margin: 20px 0;
        flex-wrap: wrap;
      }

      .scene-control-btn {
        background: linear-gradient(45deg, #ff0000, #ff6b6b);
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 25px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .scene-control-btn.gesture-hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 20px rgba(255, 0, 0, 0.4);
      }

      .scene-control-btn.stop {
        background: linear-gradient(45deg, #666, #999);
      }

      .scene-control-btn.play {
        background: linear-gradient(45deg, #06ffa5, #00ff88);
        color: #000;
      }

      .scene-control-btn.export {
        background: linear-gradient(45deg, #3a86ff, #8338ec);
      }

      .scene-list {
        margin: 20px 0;
      }

      .scene-item {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 10px;
        padding: 15px;
        margin: 10px 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        transition: all 0.3s ease;
      }

      .scene-item.gesture-hover {
        background: rgba(255, 255, 255, 0.2);
        transform: translateX(5px);
      }

      .scene-item-info {
        flex: 1;
      }

      .scene-item-name {
        font-weight: bold;
        color: #ff6b6b;
        margin-bottom: 5px;
      }

      .scene-item-details {
        font-size: 0.9em;
        color: rgba(255, 255, 255, 0.6);
      }

      .scene-item-actions {
        display: flex;
        gap: 10px;
      }

      .scene-action-btn {
        background: rgba(255, 255, 255, 0.2);
        border: none;
        padding: 8px 12px;
        border-radius: 10px;
        color: white;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 14px;
      }

      .scene-action-btn.gesture-hover {
        background: rgba(255, 255, 255, 0.3);
        transform: scale(1.05);
      }

      .scene-action-btn.delete {
        background: rgba(255, 0, 0, 0.3);
      }

      .scene-action-btn.delete.gesture-hover {
        background: rgba(255, 0, 0, 0.5);
      }

      .scene-timeline {
        background: rgba(0, 0, 0, 0.5);
        border-radius: 10px;
        padding: 15px;
        margin: 20px 0;
      }

      .timeline-progress {
        width: 100%;
        height: 6px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 3px;
        overflow: hidden;
        margin: 10px 0;
      }

      .timeline-bar {
        height: 100%;
        background: linear-gradient(90deg, #ff0000, #ff6b6b);
        width: 0%;
        transition: width 0.1s linear;
      }

      .timeline-controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 10px;
      }

      .timeline-time {
        font-size: 12px;
        color: rgba(255, 255, 255, 0.7);
      }

      .playback-speed {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .speed-btn {
        background: rgba(255, 255, 255, 0.2);
        border: none;
        padding: 5px 10px;
        border-radius: 5px;
        color: white;
        cursor: pointer;
        font-size: 12px;
      }

      .speed-btn.active {
        background: rgba(255, 0, 0, 0.5);
      }

      .scene-import-input {
        display: none;
      }

      .replay-overlay {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8);
        padding: 15px 30px;
        border-radius: 20px;
        backdrop-filter: blur(10px);
        border: 2px solid rgba(255, 0, 0, 0.5);
        z-index: 2000;
        display: none;
      }

      .replay-overlay.active {
        display: block;
      }

      .replay-text {
        color: #ff6b6b;
        font-size: 18px;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 2px;
      }

      /* 3D Timeline Controls */
      .timeline-3d-controls {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8);
        padding: 15px 30px;
        border-radius: 20px;
        backdrop-filter: blur(10px);
        border: 2px solid rgba(138, 56, 236, 0.5);
        z-index: 2001;
        display: none;
        flex-direction: column;
        align-items: center;
        gap: 10px;
      }

      .timeline-3d-controls.active {
        display: flex;
      }

      .timeline-step-info {
        color: #06ffa5;
        font-size: 16px;
        margin-bottom: 10px;
      }

      .timeline-3d-buttons {
        display: flex;
        gap: 15px;
      }

      .timeline-3d-btn {
        background: linear-gradient(45deg, #8338ec, #3a86ff);
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 20px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-weight: bold;
      }

      .timeline-3d-btn.gesture-hover {
        transform: scale(1.05);
        box-shadow: 0 4px 20px rgba(131, 56, 236, 0.4);
      }

      .timeline-3d-btn:disabled {
        background: #666;
        cursor: not-allowed;
        transform: none;
      }

      /* Portal Import/Export UI */
      .portal-manager {
        position: fixed;
        bottom: calc(env(safe-area-inset-bottom, 30px) + 150px);
        right: calc(env(safe-area-inset-right, 30px));
        width: 60px;
        height: 60px;
        background: rgba(0, 255, 255, 0.3);
        backdrop-filter: blur(10px);
        border: 2px solid rgba(0, 255, 255, 0.5);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
        z-index: 1002;
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
      }

      .portal-manager.gesture-hover {
        background: rgba(0, 255, 255, 0.5);
        transform: scale(1.1);
        box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
      }

      .portal-manager svg {
        width: 28px;
        height: 28px;
        color: white;
      }

      .portal-manager-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        z-index: 3002;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(5px);
      }

      .portal-manager-modal.show {
        display: flex;
      }

      .portal-manager-content {
        background: rgba(20, 20, 40, 0.95);
        border: 2px solid rgba(255, 255, 255, 0.2);
        border-radius: 20px;
        padding: 30px;
        max-width: 500px;
        width: 90%;
        max-height: 90vh;
        overflow-y: auto;
        box-shadow: 0 0 50px rgba(0, 255, 255, 0.3);
      }

      .portal-manager-content h3 {
        margin: 0 0 20px 0;
        font-size: 24px;
        background: linear-gradient(45deg, #00ffff, #0088ff);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        text-align: center;
      }

      .portal-list {
        margin: 20px 0;
      }

      .portal-item {
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 10px;
        padding: 15px;
        margin: 10px 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        transition: all 0.3s ease;
      }

      .portal-item.gesture-hover {
        background: rgba(255, 255, 255, 0.2);
        transform: translateX(5px);
      }

      .portal-item-info {
        flex: 1;
      }

      .portal-item-name {
        font-weight: bold;
        color: #06ffa5;
        margin-bottom: 5px;
      }

      .portal-item-location {
        font-size: 0.9em;
        color: rgba(255, 255, 255, 0.6);
      }

      .portal-item-actions {
        display: flex;
        gap: 10px;
      }

      .portal-action-btn {
        background: rgba(255, 255, 255, 0.2);
        border: none;
        padding: 8px 12px;
        border-radius: 10px;
        color: white;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 14px;
      }

      .portal-action-btn.gesture-hover {
        background: rgba(255, 255, 255, 0.3);
        transform: scale(1.05);
      }

      .portal-action-btn.delete {
        background: rgba(255, 0, 0, 0.3);
      }

      .portal-action-btn.delete.gesture-hover {
        background: rgba(255, 0, 0, 0.5);
      }

      .portal-action-btn.enter {
        background: linear-gradient(45deg, #06ffa5, #00ff88);
        color: #000;
        font-weight: bold;
      }

      .portal-action-btn.enter.gesture-hover {
        background: linear-gradient(45deg, #00ff88, #06ffa5);
        box-shadow: 0 0 15px rgba(6, 255, 165, 0.5);
      }

      .portal-import-export {
        margin: 20px 0;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        justify-content: center;
      }

      .import-export-btn {
        background: linear-gradient(45deg, #00ffff, #0088ff);
        color: #000;
        border: none;
        padding: 12px 24px;
        border-radius: 25px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .import-export-btn.gesture-hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 20px rgba(0, 255, 255, 0.4);
      }

      .import-file-input {
        display: none;
      }

      .portal-close-btn {
        position: absolute;
        top: 15px;
        right: 15px;
        background: none;
        border: none;
        font-size: 30px;
        cursor: pointer;
        color: #fff;
        transition: all 0.3s;
      }

      .portal-close-btn.gesture-hover {
        color: #ff006e;
        transform: rotate(90deg);
      }

      /* AI Companion Modal */
      .ai-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        z-index: 2002;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(5px);
      }

      .ai-modal.show {
        display: flex;
      }

      .ai-modal-content {
        background: rgba(20, 20, 40, 0.95);
        border: 2px solid rgba(255, 255, 255, 0.2);
        border-radius: 20px;
        padding: 30px;
        max-width: 500px;
        width: 90%;
        text-align: center;
        position: relative;
        box-shadow: 0 0 50px rgba(138, 56, 236, 0.3);
      }

      .ai-modal-close {
        position: absolute;
        top: 15px;
        right: 15px;
        background: none;
        border: none;
        font-size: 30px;
        cursor: pointer;
        color: #fff;
        transition: all 0.3s;
      }

      .ai-modal-close.gesture-hover {
        color: #ff006e;
        transform: rotate(90deg);
      }

      .ai-modal h3 {
        margin: 0 0 20px 0;
        font-size: 24px;
        background: linear-gradient(45deg, #ff006e, #8338ec, #3a86ff, #06ffa5);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
      }

      .ai-api-key-input {
        width: 100%;
        padding: 12px;
        margin: 10px 0;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 10px;
        color: white;
        font-size: 14px;
        font-family: monospace;
      }

      .ai-api-key-input::placeholder {
        color: rgba(255, 255, 255, 0.5);
      }

      .ai-activate-btn {
        background: linear-gradient(45deg, #8338ec, #3a86ff);
        color: white;
        border: none;
        padding: 12px 30px;
        border-radius: 25px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-top: 10px;
      }

      .ai-activate-btn.gesture-hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 20px rgba(131, 56, 236, 0.4);
      }

      .ai-companion-list {
        margin: 20px 0;
        text-align: left;
      }

      .ai-companion-item {
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 10px;
        padding: 15px;
        margin: 10px 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .ai-companion-name {
        font-weight: bold;
        color: #06ffa5;
      }

      .ai-companion-status {
        font-size: 0.9em;
        color: rgba(255, 255, 255, 0.6);
      }

      /* AI Chat Interface - Modified for better visibility */
      .ai-chat-header {
        padding: 15px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .ai-chat-title {
        font-weight: bold;
        color: #06ffa5;
      }

      .task-replay-indicator {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(255, 106, 0, 0.8);
        padding: 5px 10px;
        border-radius: 10px;
        font-size: 12px;
        display: none;
      }

      .task-replay-indicator.active {
        display: block;
        animation: pulse 1s infinite;
      }

      .ai-chat-messages {
        flex: 1;
        padding: 15px;
        overflow-y: auto;
        scroll-behavior: smooth;
      }

      .ai-message {
        margin: 10px 0;
        padding: 10px 15px;
        border-radius: 15px;
        max-width: 80%;
        word-wrap: break-word;
        overflow-wrap: break-word;
        word-break: break-word;
        font-size: 15px;
        line-height: 1.6;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        transition: all 0.2s ease;
        max-width: 100%;
        overflow-x: auto;
      }

      .ai-message.user {
        background: rgba(131, 56, 236, 0.3);
        margin-left: auto;
        text-align: right;
      }

      .ai-message.ai {
        background: rgba(6, 255, 165, 0.2);
        margin-right: auto;
      }

      .ai-message.task-replay {
        border: 1px solid rgba(255, 106, 0, 0.5);
        opacity: 0.8;
        font-style: italic;
      }

      /* Agent Logs Styling */
      .ai-message.system {
        background: rgba(255, 106, 0, 0.1);
        border: 1px solid rgba(255, 106, 0, 0.3);
        font-family: monospace;
        font-size: 13px;
        color: rgba(255, 255, 255, 0.8);
        white-space: pre-wrap;
        overflow-x: auto;
        max-width: 100%;
      }

      .agent-log-section {
        margin: 10px 0;
        padding: 10px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        border-left: 3px solid #ff6a00;
      }

      .agent-log-header {
        color: #ffa500;
        font-weight: bold;
        margin-bottom: 5px;
        font-size: 14px;
      }

      .agent-log-content {
        color: rgba(255, 255, 255, 0.9);
        line-height: 1.5;
      }

      .agent-status {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 12px;
        font-weight: bold;
        margin-right: 5px;
      }

      .agent-status.thinking {
        background: rgba(58, 134, 255, 0.3);
        color: #4dd0e1;
      }

      .agent-status.searching {
        background: rgba(255, 152, 0, 0.3);
        color: #ffaa00;
      }

      .agent-status.processing {
        background: rgba(156, 39, 176, 0.3);
        color: #ba68c8;
      }

      .agent-status.complete {
        background: rgba(76, 175, 80, 0.3);
        color: #81c784;
      }

      .agent-step {
        margin: 5px 0;
        padding-left: 20px;
        position: relative;
      }

      .agent-step::before {
        content: "‚ñ∏";
        position: absolute;
        left: 5px;
        color: #06ffa5;
      }

      .agent-error {
        color: #ff6b6b;
        background: rgba(255, 0, 0, 0.1);
        padding: 5px;
        border-radius: 5px;
        margin: 5px 0;
      }

      .agent-success {
        color: #51cf66;
        background: rgba(0, 255, 0, 0.1);
        padding: 5px;
        border-radius: 5px;
        margin: 5px 0;
      }

      /* 3D Agent Log Display */
      .agent-log-3d {
        position: absolute;
        background: rgba(0, 0, 0, 0.8);
        border: 2px solid rgba(255, 106, 0, 0.5);
        border-radius: 10px;
        padding: 10px;
        max-width: 300px;
        font-family: monospace;
        font-size: 12px;
        color: #ffa500;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .agent-log-3d.visible {
        opacity: 1;
      }

      .ai-typing {
        margin: 10px 0;
        padding: 10px 15px;
        border-radius: 15px;
        max-width: 80%;
        background: rgba(6, 255, 165, 0.2);
        margin-right: auto;
        display: flex;
        align-items: center;
        gap: 5px;
      }

      .typing-dot {
        width: 8px;
        height: 8px;
        background: rgba(255, 255, 255, 0.6);
        border-radius: 50%;
        animation: typingPulse 1.4s infinite ease-in-out;
      }

      .typing-dot:nth-child(1) {
        animation-delay: -0.32s;
      }

      .typing-dot:nth-child(2) {
        animation-delay: -0.16s;
      }

      @keyframes typingPulse {
        0%,
        80%,
        100% {
          transform: scale(0.8);
          opacity: 0.5;
        }
        40% {
          transform: scale(1);
          opacity: 1;
        }
      }

      .ai-chat-input-container {
        padding: 15px;
        border-top: 1px solid rgba(255, 255, 255, 0.2);
        display: flex;
        gap: 10px;
      }

      .ai-chat-input {
        flex: 1;
        padding: 10px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 20px;
        color: white;
        font-size: 14px;
      }

      .ai-chat-send {
        background: linear-gradient(45deg, #8338ec, #3a86ff);
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 20px;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .ai-chat-send.gesture-hover {
        transform: scale(1.05);
      }

      /* Save as Task Button */
      .save-task-btn {
        background: linear-gradient(45deg, #ff6a00, #ff8c00);
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 15px;
        cursor: pointer;
        font-size: 12px;
        margin-left: 10px;
        transition: all 0.3s ease;
        display: none; /* Hidden since we're using conversation replay */
      }

      .save-task-btn.gesture-hover {
        transform: scale(1.05);
        box-shadow: 0 3px 15px rgba(255, 106, 0, 0.4);
      }

      /* AI Companion Button */
      .ai-companion-button {
        position: fixed;
        bottom: calc(env(safe-area-inset-bottom, 30px) + 80px);
        right: calc(env(safe-area-inset-right, 30px));
        width: 60px;
        height: 60px;
        background: rgba(131, 56, 236, 0.3);
        backdrop-filter: blur(10px);
        border: 2px solid rgba(131, 56, 236, 0.5);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
        z-index: 1002;
        box-shadow: 0 0 20px rgba(131, 56, 236, 0.3);
      }

      .ai-companion-button.gesture-hover {
        background: rgba(131, 56, 236, 0.5);
        transform: scale(1.1);
        box-shadow: 0 0 30px rgba(131, 56, 236, 0.5);
      }

      .ai-companion-button.active {
        background: rgba(6, 255, 165, 0.3);
        border-color: rgba(6, 255, 165, 0.5);
      }

      /* Task List Panel - Updated for conversation replay */
      .task-panel {
        position: fixed;
        bottom: calc(env(safe-area-inset-bottom, 100px));
        left: calc(env(safe-area-inset-left, 20px));
        background: rgba(20, 20, 40, 0.95);
        border: 2px solid rgba(255, 106, 0, 0.5);
        border-radius: 20px;
        padding: 20px;
        z-index: 1002;
        max-width: 350px;
        max-height: 400px;
        overflow-y: auto;
        box-shadow: 0 0 30px rgba(255, 106, 0, 0.3);
        display: none;
      }

      .task-panel.active {
        display: block;
      }

      .task-panel h3 {
        margin: 0 0 15px 0;
        font-size: 20px;
        background: linear-gradient(45deg, #ff6a00, #ff8c00, #ffa500);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
      }

      .task-item {
        background: rgba(255, 255, 255, 0.1);
        padding: 12px;
        margin: 8px 0;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.3s ease;
        border: 1px solid transparent;
      }

      .task-item.gesture-hover {
        background: rgba(255, 255, 255, 0.2);
        border-color: rgba(255, 106, 0, 0.5);
        transform: translateX(5px);
      }

      .task-item strong {
        color: #ffa500;
        display: block;
        margin-bottom: 5px;
      }

      .task-item small {
        color: rgba(255, 255, 255, 0.6);
        display: block;
        margin-top: 5px;
      }

      .task-item .conversation-info {
        font-size: 0.85em;
        color: rgba(255, 255, 255, 0.7);
        margin-top: 8px;
        padding-top: 8px;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
      }

      /* Tasks Button */
      .tasks-button {
        position: fixed;
        bottom: calc(env(safe-area-inset-bottom, 30px) + 290px);
        right: calc(env(safe-area-inset-right, 30px));
        width: 60px;
        height: 60px;
        background: rgba(255, 106, 0, 0.3);
        backdrop-filter: blur(10px);
        border: 2px solid rgba(255, 106, 0, 0.5);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
        z-index: 1002;
        box-shadow: 0 0 20px rgba(255, 106, 0, 0.3);
      }

      .tasks-button.gesture-hover {
        background: rgba(255, 106, 0, 0.5);
        transform: scale(1.1);
        box-shadow: 0 0 30px rgba(255, 106, 0, 0.5);
      }

      .tasks-button svg {
        width: 28px;
        height: 28px;
        color: white;
      }

      /* Upload conversation button styles */
      .upload-conversation-btn {
        background: linear-gradient(45deg, #742774, #4a90e2);
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 15px;
        cursor: pointer;
        font-size: 14px;
        margin: 10px 0;
        width: 100%;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
      }

      .upload-conversation-btn.gesture-hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 20px rgba(116, 39, 116, 0.4);
      }

      .conversation-upload-input {
        display: none;
      }

      @keyframes shimmer {
        0%,
        100% {
          background-position: 0% 50%;
        }
        50% {
          background-position: 100% 50%;
        }
      }

      .world-ui {
        position: absolute;
        top: env(safe-area-inset-top, 20px);
        left: env(safe-area-inset-left, 20px);
        z-index: 1001;
        pointer-events: none;
      }

      .world-title {
        font-size: 3em;
        font-weight: 100;
        letter-spacing: 0.2em;
        text-transform: uppercase;
        background: linear-gradient(45deg, #ff006e, #8338ec, #3a86ff, #06ffa5);
        background-size: 400% 100%;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        animation: shimmer 8s ease-in-out infinite;
        margin-bottom: 10px;
      }

      .world-description {
        font-size: 1.2em;
        color: rgba(255, 255, 255, 0.6);
        max-width: 400px;
      }

      .world-origin {
        position: absolute;
        top: env(safe-area-inset-top, 20px);
        right: env(safe-area-inset-right, 20px);
        background: rgba(0, 0, 0, 0.7);
        padding: 10px 20px;
        border-radius: 20px;
        font-size: 0.9em;
        color: rgba(255, 255, 255, 0.8);
        z-index: 1001;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        display: none;
      }

      .world-origin.visible {
        display: block;
      }

      .origin-label {
        color: rgba(255, 255, 255, 0.5);
        font-size: 0.8em;
      }

      .origin-world {
        color: #06ffa5;
        font-weight: 500;
      }

      .controls-hint {
        position: absolute;
        bottom: env(safe-area-inset-bottom, 30px);
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.7);
        padding: 15px 30px;
        border-radius: 25px;
        font-size: 0.9em;
        color: rgba(255, 255, 255, 0.8);
        z-index: 1001;
        text-align: center;
        backdrop-filter: blur(10px);
        pointer-events: none;
      }

      .portal-tooltip {
        position: absolute;
        background: rgba(0, 0, 0, 0.9);
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 15px;
        padding: 20px;
        max-width: 300px;
        display: none;
        z-index: 1002;
        pointer-events: none;
        backdrop-filter: blur(10px);
      }

      .portal-tooltip.visible {
        display: block;
      }

      .tooltip-title {
        font-size: 1.4em;
        font-weight: 300;
        margin-bottom: 10px;
        color: #06ffa5;
      }

      .tooltip-description {
        font-size: 0.9em;
        color: rgba(255, 255, 255, 0.7);
        line-height: 1.5;
      }

      .tooltip-instruction {
        font-size: 0.85em;
        color: #ff006e;
        text-align: center;
        margin-top: 15px;
        padding-top: 15px;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
      }

      .loading {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        font-size: 1.2em;
        color: rgba(255, 255, 255, 0.4);
        font-weight: 200;
        letter-spacing: 0.1em;
        z-index: 2000;
      }

      .loading::after {
        content: "";
        display: block;
        width: 60px;
        height: 1px;
        background: linear-gradient(90deg, transparent, #fff, transparent);
        margin: 30px auto;
        animation: scan 2s linear infinite;
      }

      @keyframes scan {
        0% {
          transform: translateX(-100px);
        }
        100% {
          transform: translateX(100px);
        }
      }

      /* QR Code Share Button */
      .share-button {
        position: fixed;
        bottom: calc(env(safe-area-inset-bottom, 30px));
        right: calc(env(safe-area-inset-right, 30px));
        width: 60px;
        height: 60px;
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
        z-index: 1000;
        box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
      }

      .share-button.gesture-hover {
        background: rgba(255, 255, 255, 0.2);
        transform: scale(1.1);
        box-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
      }

      .share-icon {
        width: 24px;
        height: 24px;
        color: white;
      }

      /* QR Code Modal */
      .qr-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        z-index: 2001;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(5px);
      }

      .qr-modal.show {
        display: flex;
      }

      .qr-modal-content {
        background: rgba(20, 20, 40, 0.95);
        border: 2px solid rgba(255, 255, 255, 0.2);
        border-radius: 20px;
        padding: 30px;
        max-width: 400px;
        width: 90%;
        text-align: center;
        position: relative;
        box-shadow: 0 0 50px rgba(138, 56, 236, 0.3);
      }

      .qr-close {
        position: absolute;
        top: 15px;
        right: 15px;
        background: none;
        border: none;
        font-size: 30px;
        cursor: pointer;
        color: #fff;
        transition: all 0.3s;
      }

      .qr-close.gesture-hover {
        color: #ff006e;
        transform: rotate(90deg);
      }

      .qr-modal h3 {
        margin: 0 0 20px 0;
        font-size: 24px;
        background: linear-gradient(45deg, #ff006e, #8338ec, #3a86ff, #06ffa5);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
      }

      #qr-code-container {
        margin: 20px auto;
        display: flex;
        justify-content: center;
        padding: 20px;
        background: white;
        border-radius: 15px;
      }

      #qr-code-container canvas,
      #qr-code-container img {
        border-radius: 10px;
      }

      .qr-url {
        font-size: 12px;
        color: rgba(255, 255, 255, 0.7);
        word-break: break-all;
        margin: 20px 0;
        padding: 10px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        font-family: monospace;
      }

      .copy-url-btn {
        background: linear-gradient(45deg, #ff006e, #8338ec);
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 25px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .copy-url-btn.gesture-hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 20px rgba(255, 0, 110, 0.4);
      }

      .copy-url-btn.copied {
        background: linear-gradient(45deg, #06ffa5, #00ff88);
      }

      @media (max-width: 768px) {
        .world-title {
          font-size: 2em;
        }

        .world-description {
          font-size: 1em;
          max-width: 300px;
        }

        .ai-chat-interface {
          width: calc(100% - 40px);
          right: 20px;
          left: 20px;
        }
      }

      /* iOS specific fixes */
      @supports (-webkit-touch-callout: none) {
        body {
          position: fixed;
          height: 100vh;
          height: -webkit-fill-available;
        }

        #three-container {
          height: 100vh;
          height: -webkit-fill-available;
        }
      }
    </style>
  </head>
  <body>
    <div id="three-container"></div>

    <!-- Portal Loading Indicator -->
    <div class="portal-loading" id="portal-loading">
      <h3>Loading Portals</h3>
      <div class="portal-loading-spinner"></div>
      <div class="portal-loading-status">
        Fetching portal data from GitHub...
      </div>
    </div>

    <!-- Portal Error Message -->
    <div class="portal-error" id="portal-error">
      <strong>Error loading portals:</strong>
      <span id="portal-error-message"></span>
    </div>

    <!-- Hand Tracking Container -->
    <div class="hand-tracking-container" id="hand-tracking-container">
      <video class="webcam-feed" id="webcam-video" autoplay playsinline></video>
      <canvas class="gesture-overlay" id="gesture-canvas"></canvas>
      <div class="gesture-status" id="gesture-status">Ready</div>
    </div>

    <!-- Hand Cursor -->
    <div class="hand-cursor" id="hand-cursor"></div>

    <!-- Gesture Guide -->
    <div class="gesture-guide" id="gesture-guide">
      <h3>Gesture Controls</h3>
      <div class="gesture-item">
        <div class="gesture-icon">üëå</div>
        <div class="gesture-description">Pinch to select/interact</div>
      </div>
      <div class="gesture-item">
        <div class="gesture-icon">‚úã</div>
        <div class="gesture-description">Open hand to navigate</div>
      </div>
      <div class="gesture-item">
        <div class="gesture-icon">üëä</div>
        <div class="gesture-description">Fist to rotate view</div>
      </div>
      <div class="gesture-item">
        <div class="gesture-icon">üëã</div>
        <div class="gesture-description">Wave to open menu</div>
      </div>
      <div class="gesture-item">
        <div class="gesture-icon">‚úåÔ∏è</div>
        <div class="gesture-description">Peace sign to zoom</div>
      </div>
      <div class="gesture-item">
        <div class="gesture-icon">‚òùÔ∏è</div>
        <div class="gesture-description">Point to teleport</div>
      </div>
    </div>

    <!-- Gesture Feedback -->
    <div class="gesture-feedback" id="gesture-feedback"></div>

    <!-- Gesture Menu -->
    <div class="gesture-menu" id="gesture-menu">
      <div class="gesture-menu-item" data-action="toggleAI">
        <div class="gesture-menu-icon">ü§ñ</div>
        <div class="gesture-menu-text">
          <div class="gesture-menu-title">AI Companion</div>
          <div class="gesture-menu-description">Chat with AI assistant</div>
        </div>
      </div>
      <div class="gesture-menu-item" data-action="togglePortals">
        <div class="gesture-menu-icon">üåÄ</div>
        <div class="gesture-menu-text">
          <div class="gesture-menu-title">Portal Manager</div>
          <div class="gesture-menu-description">Manage world portals</div>
        </div>
      </div>
      <div class="gesture-menu-item" data-action="toggleRecorder">
        <div class="gesture-menu-icon">üé¨</div>
        <div class="gesture-menu-text">
          <div class="gesture-menu-title">Scene Recorder</div>
          <div class="gesture-menu-description">Record & replay scenes</div>
        </div>
      </div>
      <div class="gesture-menu-item" data-action="toggleTasks">
        <div class="gesture-menu-icon">üìö</div>
        <div class="gesture-menu-text">
          <div class="gesture-menu-title">Saved Conversations</div>
          <div class="gesture-menu-description">View conversation history</div>
        </div>
      </div>
      <div class="gesture-menu-item" data-action="minimizeHand">
        <div class="gesture-menu-icon">üëÅÔ∏è</div>
        <div class="gesture-menu-text">
          <div class="gesture-menu-title">Minimize Tracker</div>
          <div class="gesture-menu-description">Hide hand view</div>
        </div>
      </div>
    </div>

    <!-- Swipe Indicators -->
    <div class="swipe-indicator left" id="swipe-left">‚óÄ</div>
    <div class="swipe-indicator right" id="swipe-right">‚ñ∂</div>
    <div class="swipe-indicator up" id="swipe-up">‚ñ≤</div>
    <div class="swipe-indicator down" id="swipe-down">‚ñº</div>

    <!-- Scene Recorder Button -->
    <div
      class="scene-recorder-button gesture-interactive"
      id="scene-recorder-button"
    >
      <svg
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
      >
        <circle cx="12" cy="12" r="11" />
        <circle cx="12" cy="12" r="5" fill="currentColor" />
      </svg>
    </div>

    <!-- Scene Recorder Modal -->
    <div class="scene-recorder-modal" id="scene-recorder-modal">
      <div class="scene-recorder-content">
        <button
          class="portal-close-btn gesture-interactive"
          id="scene-recorder-close"
        >
          &times;
        </button>
        <h3>Scene Recorder & Player</h3>

        <div class="recording-status" id="recording-status">
          <div class="recording-timer" id="recording-timer">00:00</div>
          <div class="recording-info" id="recording-info">Ready to record</div>
        </div>

        <div class="scene-controls">
          <button
            class="scene-control-btn gesture-interactive"
            id="start-recording-btn"
          >
            ‚ñ∂Ô∏è Start Recording
          </button>
          <button
            class="scene-control-btn stop gesture-interactive"
            id="stop-recording-btn"
            style="display: none"
          >
            ‚èπÔ∏è Stop Recording
          </button>
          <button
            class="scene-control-btn export gesture-interactive"
            id="export-scene-btn"
          >
            üì§ Export Scene
          </button>
          <button
            class="scene-control-btn gesture-interactive"
            onclick="document.getElementById('scene-import-input').click()"
          >
            üì• Import Scene
          </button>
          <input
            type="file"
            id="scene-import-input"
            class="scene-import-input"
            accept=".json"
            onchange="window.worldNavigator.sceneRecorder.importScene(event)"
          />
        </div>

        <div class="scene-timeline" id="scene-timeline" style="display: none">
          <div class="timeline-progress">
            <div class="timeline-bar" id="timeline-bar"></div>
          </div>
          <div class="timeline-controls">
            <div class="timeline-time">
              <span id="current-time">00:00</span> /
              <span id="total-time">00:00</span>
            </div>
            <div class="playback-speed">
              <button class="speed-btn gesture-interactive" data-speed="0.5">
                0.5x
              </button>
              <button
                class="speed-btn active gesture-interactive"
                data-speed="1"
              >
                1x
              </button>
              <button class="speed-btn gesture-interactive" data-speed="2">
                2x
              </button>
            </div>
          </div>
        </div>

        <div class="scene-list" id="scene-list">
          <h4 style="color: #ff6b6b; margin-bottom: 10px">Recorded Scenes:</h4>
          <!-- Scene items will be populated here -->
        </div>
      </div>
    </div>

    <!-- Replay Overlay -->
    <div class="replay-overlay" id="replay-overlay">
      <div class="replay-text">‚ñ∂Ô∏è REPLAYING SCENE</div>
    </div>

    <!-- 3D Timeline Controls -->
    <div class="timeline-3d-controls" id="timeline-3d-controls">
      <div class="timeline-step-info" id="timeline-step-info">
        Step 1 of 10 - User Message
      </div>
      <div class="timeline-3d-buttons">
        <button
          class="timeline-3d-btn gesture-interactive"
          id="timeline-prev-btn"
        >
          ‚óÄ Previous
        </button>
        <button
          class="timeline-3d-btn gesture-interactive"
          id="timeline-play-pause-btn"
        >
          ‚è∏ Pause
        </button>
        <button
          class="timeline-3d-btn gesture-interactive"
          id="timeline-next-btn"
        >
          Next ‚ñ∂
        </button>
        <button
          class="timeline-3d-btn gesture-interactive"
          id="timeline-exit-btn"
        >
          Exit
        </button>
      </div>
    </div>

    <!-- Portal Manager Button -->
    <div class="portal-manager gesture-interactive" id="portal-manager-btn">
      <svg
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
      >
        <circle cx="12" cy="12" r="10" />
        <path d="M12 2v20M2 12h20" />
        <circle cx="12" cy="12" r="3" />
      </svg>
    </div>

    <!-- Portal Manager Modal -->
    <div class="portal-manager-modal" id="portal-manager-modal">
      <div class="portal-manager-content">
        <button class="portal-close-btn gesture-interactive" id="portal-close">
          &times;
        </button>
        <h3>Portal Manager</h3>
        <p
          style="
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 20px;
            text-align: center;
          "
        >
          Use gestures to manage portals. Pinch to select, wave to navigate.
        </p>

        <div class="portal-list" id="portal-list">
          <h4 style="color: #06ffa5; margin-bottom: 10px">Active Portals:</h4>
          <!-- Portal items will be populated here -->
        </div>

        <div class="portal-import-export">
          <button
            class="import-export-btn gesture-interactive"
            onclick="window.worldNavigator.portalManager.exportPortals()"
          >
            üì§ Export Portals
          </button>
          <button
            class="import-export-btn gesture-interactive"
            onclick="document.getElementById('import-file').click()"
          >
            üì• Import Portals
          </button>
          <input
            type="file"
            id="import-file"
            class="import-file-input"
            accept=".json"
            onchange="window.worldNavigator.portalManager.importPortals(event)"
          />
        </div>
      </div>
    </div>

    <!-- AI Companion Modal -->
    <div class="ai-modal" id="ai-modal">
      <div class="ai-modal-content">
        <button class="ai-modal-close gesture-interactive" id="ai-close">
          &times;
        </button>
        <h3>AI Companion Settings</h3>
        <p style="color: rgba(255, 255, 255, 0.7); margin-bottom: 20px">
          Activate AI companions using gestures. They can interact with you and
          other players in real-time.
        </p>
        <input
          type="password"
          class="ai-api-key-input"
          id="ai-api-key"
          placeholder="Enter your API key to wake up AI companions"
        />
        <button
          class="ai-activate-btn gesture-interactive"
          id="ai-activate-btn"
        >
          Activate AI Companions
        </button>

        <div class="ai-companion-list" id="ai-companion-list">
          <h4 style="color: #06ffa5; margin-top: 20px">Active Companions:</h4>
          <div class="ai-companion-item">
            <div>
              <div class="ai-companion-name">No AI companions active</div>
              <div class="ai-companion-status">Enter API key to activate</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- AI Chat Interface -->
    <div class="ai-chat-interface" id="ai-chat-interface">
      <div class="ai-chat-header">
        <div class="ai-chat-title">AI Companion Chat</div>
        <button
          class="ai-modal-close gesture-interactive"
          onclick="document.getElementById('ai-chat-interface').classList.remove('active')"
        >
          &times;
        </button>
      </div>
      <div class="task-replay-indicator" id="task-replay-indicator">
        üîÑ Replaying Conversation...
      </div>
      <div class="ai-chat-messages" id="ai-chat-messages"></div>
      <div class="ai-chat-input-container">
        <input
          type="text"
          class="ai-chat-input"
          id="ai-chat-input"
          placeholder="Type a message..."
          onkeypress="if(event.key==='Enter') window.worldNavigator.aiManager.sendMessage()"
        />
        <button
          class="ai-chat-send gesture-interactive"
          onclick="window.worldNavigator.aiManager.sendMessage()"
        >
          Send
        </button>
      </div>
    </div>

    <!-- Task Panel -->
    <div class="task-panel" id="task-panel">
      <h3>üìö Saved Conversations</h3>
      <button
        class="upload-conversation-btn gesture-interactive"
        onclick="document.getElementById('conversation-upload-input').click()"
      >
        <svg
          viewBox="0 0 24 24"
          width="16"
          height="16"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
        >
          <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"></path>
          <polyline points="17 8 12 3 7 8"></polyline>
          <line x1="12" y1="3" x2="12" y2="15"></line>
        </svg>
        Upload Conversation JSON
      </button>
      <input
        type="file"
        id="conversation-upload-input"
        class="conversation-upload-input"
        accept=".json"
        onchange="window.worldNavigator.taskManager.uploadConversation(event)"
      />
      <div id="task-list">
        <!-- Tasks populated here -->
      </div>
    </div>

    <div class="world-ui">
      <h1 class="world-title" id="world-title">NEXUS HUB</h1>
      <p class="world-description" id="world-description">
        Use hand gestures to navigate. Pinch to interact with portals. Wave to
        open menu.
      </p>
    </div>

    <div class="world-origin" id="world-origin">
      <span class="origin-label">Arrived from:</span>
      <span class="origin-world" id="origin-world-name">Origin</span>
    </div>

    <!-- AI Companion Button -->
    <div
      class="ai-companion-button gesture-interactive"
      id="ai-companion-button"
    >
      <svg
        class="view-toggle-icon"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
      >
        <path
          d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"
        ></path>
      </svg>
    </div>

    <!-- Tasks Button -->
    <div class="tasks-button gesture-interactive" id="tasks-button">
      <svg
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
      >
        <path d="M9 11l3 3L22 4"></path>
        <path d="M21 12v7a2 2 0 01-2 2H5a2 2 0 01-2-2V5a2 2 0 012-2h11"></path>
      </svg>
    </div>

    <div class="controls-hint" id="controls-hint">
      Use hand gestures to navigate - Wave to open menu - Pinch to interact
    </div>

    <div class="portal-tooltip" id="portal-tooltip">
      <h3 class="tooltip-title"></h3>
      <p class="tooltip-description"></p>
      <p class="tooltip-instruction">Pinch to enter world</p>
    </div>

    <div class="loading" id="loading">Initializing gesture controls...</div>

    <!-- QR Code Share Button -->
    <div class="share-button gesture-interactive" id="share-button">
      <svg
        class="share-icon"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
      >
        <path d="M4 12v8a2 2 0 002 2h12a2 2 0 002-2v-8"></path>
        <polyline points="16 6 12 2 8 6"></polyline>
        <line x1="12" y1="2" x2="12" y2="15"></line>
      </svg>
    </div>

    <!-- QR Code Modal -->
    <div class="qr-modal" id="qr-modal">
      <div class="qr-modal-content">
        <button class="qr-close gesture-interactive" id="qr-close">
          &times;
        </button>
        <h3>Share This World</h3>
        <div id="qr-code-container"></div>
        <p class="qr-url" id="qr-url"></p>
        <button class="copy-url-btn gesture-interactive" id="copy-url-btn">
          Copy URL
        </button>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script>
      // Portal Data Fetcher
      class PortalDataFetcher {
        constructor() {
          this.githubUrl =
            "https://raw.githubusercontent.com/kody-w/AINexus/refs/heads/main/ai-companion-with-user-6.html";
          this.portals = [];
        }

        async fetchPortals() {
          try {
            console.log("Fetching portal data from GitHub...");
            const response = await fetch(this.githubUrl);

            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }

            const htmlContent = await response.text();
            const portals = this.extractPortalsFromHTML(htmlContent);

            console.log("Extracted portals:", portals);
            return portals;
          } catch (error) {
            console.error("Error fetching portals:", error);
            this.showError(
              "Failed to load portals from GitHub: " + error.message
            );
            return this.getDefaultPortals();
          }
        }

        extractPortalsFromHTML(html) {
          const portals = [];

          // Look for portal definitions in the HTML
          // First, try to find JavaScript object definitions
          const portalRegex =
            /(?:const\s+)?(?:defaultPortals|portals)\s*=\s*\[([\s\S]*?)\];/g;
          const matches = html.matchAll(portalRegex);

          for (const match of matches) {
            try {
              // Extract the array content
              const arrayContent = match[1];

              // Try to parse it as JSON-like structure
              // Replace single quotes with double quotes for JSON compatibility
              const jsonLikeContent = arrayContent
                .replace(/'/g, '"')
                .replace(/(\w+):/g, '"$1":')
                .replace(/,\s*}/g, "}")
                .replace(/,\s*\]/g, "]");

              const parsedPortals = eval(`[${arrayContent}]`);
              portals.push(...parsedPortals);
            } catch (e) {
              console.warn("Failed to parse portal data:", e);
            }
          }

          // Also look for createPortal function calls
          const createPortalRegex =
            /createPortal\s*\(\s*(-?\d+(?:\.\d+)?)\s*,\s*(-?\d+(?:\.\d+)?)\s*,\s*(-?\d+(?:\.\d+)?)\s*,\s*({[^}]+})\s*\)/g;
          const createPortalMatches = html.matchAll(createPortalRegex);

          for (const match of createPortalMatches) {
            try {
              const x = parseFloat(match[1]);
              const y = parseFloat(match[2]);
              const z = parseFloat(match[3]);
              const portalDataStr = match[4]
                .replace(/'/g, '"')
                .replace(/(\w+):/g, '"$1":');

              const portalData = JSON.parse(portalDataStr);
              portalData.position = { x, y, z };
              portals.push(portalData);
            } catch (e) {
              console.warn("Failed to parse createPortal call:", e);
            }
          }

          // If we couldn't find any portals, look for specific world definitions
          if (portals.length === 0) {
            const worldRegex =
              /{\s*name:\s*["']([^"']+)["'],\s*(?:type:\s*["']([^"']+)["'],\s*)?url:\s*["']([^"']+)["'],\s*description:\s*["']([^"']+)["']/g;
            const worldMatches = html.matchAll(worldRegex);

            for (const match of worldMatches) {
              portals.push({
                name: match[1],
                type: match[2] || "default",
                url: match[3],
                description: match[4],
              });
            }
          }

          return portals.length > 0 ? portals : this.getDefaultPortals();
        }

        getDefaultPortals() {
          return [
            {
              name: "Cyber City",
              type: "tech",
              url: "cybercity.html",
              description: "A futuristic metropolis",
            },
            {
              name: "Crystal Caves",
              type: "nature",
              url: "crystalcaves.html",
              description: "Underground crystal formations",
            },
            {
              name: "Sky Islands",
              type: "fantasy",
              url: "skyislands.html",
              description: "Floating islands in the clouds",
            },
            {
              name: "Quantum Lab",
              type: "science",
              url: "quantumlab.html",
              description: "Experimental physics laboratory",
            },
            {
              name: "Ancient Temple",
              type: "mystery",
              url: "temple.html",
              description: "Mysterious ancient ruins",
            },
            {
              name: "Space Station",
              type: "space",
              url: "spacestation.html",
              description: "Orbiting space habitat",
            },
          ];
        }

        showError(message) {
          const errorEl = document.getElementById("portal-error");
          const errorMessageEl = document.getElementById(
            "portal-error-message"
          );
          errorMessageEl.textContent = message;
          errorEl.classList.add("show");

          setTimeout(() => {
            errorEl.classList.remove("show");
          }, 5000);
        }
      }

      // Initialize hand tracking and gesture recognition
      class GestureController {
        constructor() {
          this.hands = null;
          this.camera = null;
          this.isInitialized = false;
          this.currentGesture = null;
          this.lastGesture = null;
          this.gestureHistory = [];
          this.pinchThreshold = 0.08;
          this.hoveredElements = new Set();
          this.gestureStartTime = null;
          this.swipeStartPos = null;
          this.rotationStart = null;
          this.lastHandPosition = null;
          this.menuOpen = false;
          this.fallbackToMouse = false;

          this.initializeHandTracking();
        }

        async initializeHandTracking() {
          const videoElement = document.getElementById("webcam-video");
          const canvasElement = document.getElementById("gesture-canvas");
          const canvasCtx = canvasElement.getContext("2d");

          // Set canvas size
          canvasElement.width = 640;
          canvasElement.height = 480;

          this.hands = new Hands({
            locateFile: (file) => {
              return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            },
          });

          this.hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5,
          });

          this.hands.onResults((results) => this.onHandResults(results));

          this.camera = new Camera(videoElement, {
            onFrame: async () => {
              await this.hands.send({ image: videoElement });
            },
            width: 640,
            height: 480,
          });

          try {
            await this.camera.start();
            this.isInitialized = true;
            document.getElementById("loading").style.display = "none";
            this.showGestureFeedback("Gesture controls active!");
          } catch (error) {
            console.error("Failed to start camera:", error);
            this.handleCameraError(error);
          }
        }

        handleCameraError(error) {
          // Create camera error UI
          const errorDiv = document.createElement("div");
          errorDiv.className = "camera-error";
          errorDiv.innerHTML = `
                    <h3>Camera Access Required</h3>
                    <p>Gesture controls need camera permission to work properly.</p>
                    <div class="error-details">
                        <strong>Error:</strong> ${
                          error.message || "Camera access denied"
                        }<br>
                        <strong>Solution:</strong> Allow camera access in your browser settings and refresh the page.
                    </div>
                    <p>You can still navigate using:</p>
                    <ul style="text-align: left; display: inline-block;">
                        <li>WASD keys to move</li>
                        <li>Mouse to look around</li>
                        <li>Click to interact with portals</li>
                    </ul>
                    <button onclick="location.reload()">Retry Camera Access</button>
                    <button class="fallback-btn" onclick="window.gestureController.enableMouseControls()">Use Mouse Controls</button>
                `;

          document.body.appendChild(errorDiv);

          // Hide gesture-specific UI
          document.getElementById("loading").style.display = "none";
          document.getElementById("hand-tracking-container").style.display =
            "none";
          document.getElementById("gesture-guide").classList.add("hidden");
          document.getElementById("hand-cursor").style.display = "none";

          // Enable fallback controls
          this.fallbackToMouse = true;
          this.enableMouseControls();
        }

        enableMouseControls() {
          console.log("Enabling mouse controls as fallback");
          this.fallbackToMouse = true;

          // Remove camera error message if it exists
          const errorDiv = document.querySelector(".camera-error");
          if (errorDiv) {
            errorDiv.remove();
          }

          // Enable mouse interactions on all interactive elements
          document.querySelectorAll(".gesture-interactive").forEach((el) => {
            el.classList.add("mouse-enabled");
            el.style.cursor = "pointer";

            // Add click handler
            const existingHandler = el.onclick;
            el.onclick = function (e) {
              // Handle click based on element type
              if (this.classList.contains("gesture-menu-item")) {
                const action = this.dataset.action;
                handleMenuAction(action);
              } else if (existingHandler) {
                existingHandler.call(this, e);
              }
            };
          });

          // Show controls hint for mouse
          const hint = document.getElementById("controls-hint");
          hint.textContent =
            "Use WASD to move, Mouse to look, Click to interact";
          hint.style.opacity = "1";

          this.showGestureFeedback("Mouse controls enabled");
        }

        onHandResults(results) {
          const canvasElement = document.getElementById("gesture-canvas");
          const canvasCtx = canvasElement.getContext("2d");

          canvasCtx.save();
          canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

          if (
            results.multiHandLandmarks &&
            results.multiHandLandmarks.length > 0
          ) {
            const landmarks = results.multiHandLandmarks[0];

            // Draw hand skeleton
            this.drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {
              color: "#00FF00",
              lineWidth: 2,
            });
            this.drawLandmarks(canvasCtx, landmarks, {
              color: "#FF0073",
              lineWidth: 1,
              radius: 3,
            });

            // Process gestures
            this.processGesture(landmarks);

            // Update hand cursor position
            this.updateHandCursor(landmarks);
          } else {
            document.getElementById("hand-cursor").style.display = "none";
            this.currentGesture = null;
          }

          canvasCtx.restore();
        }

        processGesture(landmarks) {
          const gesture = this.detectGesture(landmarks);

          if (gesture !== this.lastGesture) {
            this.onGestureChange(gesture);
          }

          // Handle gesture-specific actions
          switch (gesture) {
            case "pinch":
              this.handlePinch(landmarks);
              break;
            case "point":
              this.handlePoint(landmarks);
              break;
            case "fist":
              this.handleFist(landmarks);
              break;
            case "peace":
              this.handlePeace(landmarks);
              break;
            case "wave":
              this.handleWave(landmarks);
              break;
            case "open":
              this.handleOpenHand(landmarks);
              break;
          }

          this.lastGesture = gesture;
          this.currentGesture = gesture;
        }

        detectGesture(landmarks) {
          const thumbTip = landmarks[4];
          const indexTip = landmarks[8];
          const middleTip = landmarks[12];
          const ringTip = landmarks[16];
          const pinkyTip = landmarks[20];

          const indexMCP = landmarks[5];
          const middleMCP = landmarks[9];
          const ringMCP = landmarks[13];
          const pinkyMCP = landmarks[17];

          // Calculate pinch distance
          const pinchDistance = Math.sqrt(
            Math.pow(thumbTip.x - indexTip.x, 2) +
              Math.pow(thumbTip.y - indexTip.y, 2)
          );

          // Check finger states
          const indexUp = indexTip.y < indexMCP.y;
          const middleUp = middleTip.y < middleMCP.y;
          const ringUp = ringTip.y < ringMCP.y;
          const pinkyUp = pinkyTip.y < pinkyMCP.y;

          // Detect wave gesture
          if (this.detectWaveMotion(landmarks)) {
            return "wave";
          }

          // Detect pinch
          if (pinchDistance < this.pinchThreshold) {
            return "pinch";
          }

          // Detect pointing
          if (indexUp && !middleUp && !ringUp && !pinkyUp) {
            return "point";
          }

          // Detect fist
          if (!indexUp && !middleUp && !ringUp && !pinkyUp) {
            return "fist";
          }

          // Detect peace sign
          if (indexUp && middleUp && !ringUp && !pinkyUp) {
            return "peace";
          }

          // Detect open hand
          if (indexUp && middleUp && ringUp && pinkyUp) {
            return "open";
          }

          return "unknown";
        }

        detectWaveMotion(landmarks) {
          const wrist = landmarks[0];

          if (!this.lastHandPosition) {
            this.lastHandPosition = { x: wrist.x, y: wrist.y };
            return false;
          }

          const deltaX = Math.abs(wrist.x - this.lastHandPosition.x);
          const deltaY = Math.abs(wrist.y - this.lastHandPosition.y);

          this.gestureHistory.push({ deltaX, deltaY, time: Date.now() });

          // Keep only recent history
          const recentHistory = this.gestureHistory.filter(
            (h) => Date.now() - h.time < 500
          );
          this.gestureHistory = recentHistory;

          // Detect wave pattern
          if (recentHistory.length > 5) {
            const avgDeltaX =
              recentHistory.reduce((sum, h) => sum + h.deltaX, 0) /
              recentHistory.length;
            if (avgDeltaX > 0.02 && deltaY < 0.01) {
              this.lastHandPosition = { x: wrist.x, y: wrist.y };
              return true;
            }
          }

          this.lastHandPosition = { x: wrist.x, y: wrist.y };
          return false;
        }

        onGestureChange(gesture) {
          document.getElementById("gesture-status").textContent =
            gesture.charAt(0).toUpperCase() + gesture.slice(1);

          if (gesture !== "unknown") {
            this.showGestureFeedback(
              gesture.charAt(0).toUpperCase() + gesture.slice(1)
            );
          }
        }

        handlePinch(landmarks) {
          const indexTip = landmarks[8];
          const cursorX = (1 - indexTip.x) * window.innerWidth;
          const cursorY = indexTip.y * window.innerHeight;

          // Check for interactive elements
          const elements = document.elementsFromPoint(cursorX, cursorY);

          for (const element of elements) {
            if (
              element.classList.contains("gesture-interactive") ||
              element.classList.contains("portal") ||
              element.classList.contains("gesture-menu-item")
            ) {
              element.click();
              this.showGestureFeedback("Selected!");
              break;
            }
          }
        }

        handlePoint(landmarks) {
          const indexTip = landmarks[8];
          const cursorX = (1 - indexTip.x) * window.innerWidth;
          const cursorY = indexTip.y * window.innerHeight;

          // Teleport in 3D world
          if (window.worldNavigator && window.worldNavigator.gestureManager) {
            window.worldNavigator.gestureManager.handleTeleport(
              cursorX,
              cursorY
            );
          }
        }

        handleFist(landmarks) {
          if (!this.rotationStart) {
            this.rotationStart = { x: landmarks[0].x, y: landmarks[0].y };
          }

          const deltaX = (landmarks[0].x - this.rotationStart.x) * 5;
          const deltaY = (landmarks[0].y - this.rotationStart.y) * 5;

          // Rotate camera
          if (window.worldNavigator && window.worldNavigator.camera) {
            window.worldNavigator.controls.rotateSpeed = 2;
            window.worldNavigator.controls.rotate(deltaX, deltaY);
          }

          this.rotationStart = { x: landmarks[0].x, y: landmarks[0].y };
        }

        handlePeace(landmarks) {
          const indexTip = landmarks[8];
          const middleTip = landmarks[12];
          const distance = Math.abs(indexTip.y - middleTip.y);

          // Zoom camera
          if (window.worldNavigator && window.worldNavigator.camera) {
            const zoom = 20 + distance * 100;
            window.worldNavigator.camera.position.z = Math.max(
              10,
              Math.min(50, zoom)
            );
          }
        }

        handleWave(landmarks) {
          // Toggle menu
          this.toggleMenu();
        }

        handleOpenHand(landmarks) {
          this.rotationStart = null;

          // Navigate in 3D space
          if (window.worldNavigator && this.lastHandPosition) {
            const wrist = landmarks[0];
            const deltaX = (wrist.x - 0.5) * 10;
            const deltaZ = (wrist.y - 0.5) * 10;

            window.worldNavigator.movePlayer(deltaX, 0, deltaZ);
          }
        }

        updateHandCursor(landmarks) {
          const indexTip = landmarks[8];
          const cursorX = (1 - indexTip.x) * window.innerWidth;
          const cursorY = indexTip.y * window.innerHeight;

          const cursor = document.getElementById("hand-cursor");
          cursor.style.left = cursorX + "px";
          cursor.style.top = cursorY + "px";
          cursor.style.display = "block";

          // Update cursor style based on gesture
          cursor.className = "hand-cursor";
          if (this.currentGesture === "pinch") {
            cursor.classList.add("pinching");
          } else if (this.currentGesture === "point") {
            cursor.classList.add("pointing");
          }

          // Check for hover effects
          this.updateHoverEffects(cursorX, cursorY);
        }

        updateHoverEffects(x, y) {
          const elements = document.elementsFromPoint(x, y);
          const interactiveElements = new Set();

          for (const element of elements) {
            if (
              element.classList.contains("gesture-interactive") ||
              element.classList.contains("portal") ||
              element.classList.contains("gesture-menu-item")
            ) {
              interactiveElements.add(element);
              if (!this.hoveredElements.has(element)) {
                element.classList.add("gesture-hover");
              }
            }
          }

          // Remove hover from elements no longer hovered
          for (const element of this.hoveredElements) {
            if (!interactiveElements.has(element)) {
              element.classList.remove("gesture-hover");
            }
          }

          this.hoveredElements = interactiveElements;
        }

        showGestureFeedback(text) {
          const feedback = document.getElementById("gesture-feedback");
          feedback.textContent = text;
          feedback.classList.add("show");

          setTimeout(() => {
            feedback.classList.remove("show");
          }, 1500);
        }

        toggleMenu() {
          const menu = document.getElementById("gesture-menu");
          this.menuOpen = !this.menuOpen;

          if (this.menuOpen) {
            menu.classList.add("open");
            this.showGestureFeedback("Menu opened");
          } else {
            menu.classList.remove("open");
            this.showGestureFeedback("Menu closed");
          }
        }

        drawConnectors(ctx, landmarks, connections, style) {
          ctx.strokeStyle = style.color;
          ctx.lineWidth = style.lineWidth;

          connections.forEach(([start, end]) => {
            const startPoint = landmarks[start];
            const endPoint = landmarks[end];

            ctx.beginPath();
            ctx.moveTo(
              startPoint.x * ctx.canvas.width,
              startPoint.y * ctx.canvas.height
            );
            ctx.lineTo(
              endPoint.x * ctx.canvas.width,
              endPoint.y * ctx.canvas.height
            );
            ctx.stroke();
          });
        }

        drawLandmarks(ctx, landmarks, style) {
          ctx.fillStyle = style.color;

          landmarks.forEach((landmark) => {
            ctx.beginPath();
            ctx.arc(
              landmark.x * ctx.canvas.width,
              landmark.y * ctx.canvas.height,
              style.radius,
              0,
              2 * Math.PI
            );
            ctx.fill();
          });
        }

        minimizeTracker() {
          const container = document.getElementById("hand-tracking-container");
          container.classList.toggle("minimized");

          if (container.classList.contains("minimized")) {
            this.showGestureFeedback("Tracker minimized");
          } else {
            this.showGestureFeedback("Tracker restored");
          }
        }
      }

      // MediaPipe hand connections
      const HAND_CONNECTIONS = [
        [0, 1],
        [1, 2],
        [2, 3],
        [3, 4],
        [0, 5],
        [5, 6],
        [6, 7],
        [7, 8],
        [5, 9],
        [9, 10],
        [10, 11],
        [11, 12],
        [9, 13],
        [13, 14],
        [14, 15],
        [15, 16],
        [13, 17],
        [17, 18],
        [18, 19],
        [19, 20],
        [0, 17],
      ];

      // Initialize gesture controller globally
      window.gestureController = new GestureController();

      // Handle menu actions
      function handleMenuAction(action) {
        switch (action) {
          case "toggleAI":
            document.getElementById("ai-companion-button").click();
            break;
          case "togglePortals":
            document.getElementById("portal-manager-btn").click();
            break;
          case "toggleRecorder":
            document.getElementById("scene-recorder-button").click();
            break;
          case "toggleTasks":
            document.getElementById("tasks-button").click();
            break;
          case "minimizeHand":
            window.gestureController.minimizeTracker();
            break;
        }

        if (!window.gestureController.fallbackToMouse) {
          window.gestureController.toggleMenu(); // Close menu after action
        }
      }

      // Gesture menu handlers
      document.querySelectorAll(".gesture-menu-item").forEach((item) => {
        item.addEventListener("click", function () {
          const action = this.dataset.action;
          handleMenuAction(action);
        });
      });

      // Make hand tracking container clickable when minimized
      document
        .getElementById("hand-tracking-container")
        .addEventListener("click", function (e) {
          if (this.classList.contains("minimized")) {
            window.gestureController.minimizeTracker();
          }
        });

      // Default world attributes
      const DEFAULT_WORLD_ATTRIBUTES = {
        name: "Nexus Hub",
        description:
          "The central hub connecting all worlds. Step through the portals to explore different dimensions.",
        ambientColor: 0x0a0a0a,
        fogColor: 0x000033,
        groundColor: 0x1a1a2e,
        skyColor: 0x16213e,
        moveSpeed: 0.15,
        lookSpeed: 0.002,
        portalColor1: 0x00ffff,
        portalColor2: 0xff00ff,
        particleCount: 1000,
        cameraHeight: 2,
        fogNear: 10,
        fogFar: 100,
      };

      // Parse inherited attributes from URL
      function parseInheritedAttributes() {
        let paramString = window.INJECTED_PARAMS || window.location.search;

        if (window.location.protocol === "blob:") {
          const storedParams = sessionStorage.getItem("worldInheritanceParams");
          if (storedParams) {
            paramString = storedParams;
          }
        }

        if (!paramString || paramString === "?") {
          const transitionData = localStorage.getItem("worldTransition");
          if (transitionData) {
            try {
              const data = JSON.parse(transitionData);
              if (Date.now() - data.timestamp < 5000) {
                paramString = "?" + data.params;
              }
            } catch (e) {
              console.error("Error parsing transition data:", e);
            }
            localStorage.removeItem("worldTransition");
          }
        }

        const params = new URLSearchParams(paramString);
        const inherited = {};

        inherited.sourceWorld = params.get("from") || null;
        inherited.sourceWorldName = params.get("fromName") || null;

        // Visual attributes only (no moveSpeed)
        if (params.has("lookSpeed"))
          inherited.lookSpeed = parseFloat(params.get("lookSpeed"));
        if (params.has("ambientColor"))
          inherited.ambientColor = parseInt(params.get("ambientColor"), 16);
        if (params.has("fogColor"))
          inherited.fogColor = parseInt(params.get("fogColor"), 16);
        if (params.has("portalColor1"))
          inherited.portalColor1 = parseInt(params.get("portalColor1"), 16);
        if (params.has("portalColor2"))
          inherited.portalColor2 = parseInt(params.get("portalColor2"), 16);
        if (params.has("particleCount"))
          inherited.particleCount = parseInt(params.get("particleCount"));
        if (params.has("cameraHeight"))
          inherited.cameraHeight = parseFloat(params.get("cameraHeight"));
        if (params.has("fogNear"))
          inherited.fogNear = parseFloat(params.get("fogNear"));
        if (params.has("fogFar"))
          inherited.fogFar = parseFloat(params.get("fogFar"));

        console.log("Parsed inherited attributes:", inherited);
        return inherited;
      }

      const inheritedAttributes = parseInheritedAttributes();
      const CURRENT_WORLD = {
        ...DEFAULT_WORLD_ATTRIBUTES,
        ...inheritedAttributes,
      };

      // Add THREE.js extensions
      THREE.FontLoader = class FontLoader extends THREE.Loader {
        constructor(manager) {
          super(manager);
        }

        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const loader = new THREE.FileLoader(this.manager);
          loader.setPath(this.path);
          loader.setRequestHeader(this.requestHeader);
          loader.setWithCredentials(this.withCredentials);
          loader.load(
            url,
            function (text) {
              try {
                const json = JSON.parse(text);
                const font = scope.parse(json);
                if (onLoad) onLoad(font);
              } catch (e) {
                console.warn(
                  "THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."
                );
                if (onError) onError(e);
              }
            },
            onProgress,
            onError
          );
        }

        parse(json) {
          return new THREE.Font(json);
        }
      };

      THREE.Font = class Font {
        constructor(data) {
          this.type = "Font";
          this.data = data;
        }

        generateShapes(text, size = 100) {
          const shapes = [];
          const paths = createPaths(text, size, this.data);

          for (let p = 0, pl = paths.length; p < pl; p++) {
            Array.prototype.push.apply(shapes, paths[p].toShapes());
          }

          return shapes;
        }
      };

      THREE.TextGeometry = class TextGeometry extends THREE.ExtrudeGeometry {
        constructor(text, parameters = {}) {
          const font = parameters.font;

          if (!font || !font.data) {
            console.error(
              "THREE.TextGeometry: font parameter is not an instance of THREE.Font."
            );
            super();
            return;
          }

          const shapes = font.generateShapes(text, parameters.size);

          parameters.depth =
            parameters.height !== undefined ? parameters.height : 50;

          if (parameters.bevelThickness === undefined)
            parameters.bevelThickness = 10;
          if (parameters.bevelSize === undefined) parameters.bevelSize = 8;
          if (parameters.bevelEnabled === undefined)
            parameters.bevelEnabled = false;

          super(shapes, parameters);

          this.type = "TextGeometry";
        }
      };

      function createPaths(text, size, data) {
        const chars = Array.from(text);
        const scale = size / data.resolution;
        const line_height =
          (data.boundingBox.yMax -
            data.boundingBox.yMin +
            data.underlineThickness) *
          scale;

        const paths = [];

        let offsetX = 0,
          offsetY = 0;

        for (let i = 0; i < chars.length; i++) {
          const char = chars[i];

          if (char === "\n") {
            offsetX = 0;
            offsetY -= line_height;
          } else {
            const ret = createPath(char, scale, offsetX, offsetY, data);
            if (ret) {
              offsetX += ret.offsetX;
              paths.push(ret.path);
            }
          }
        }

        return paths;
      }

      function createPath(char, scale, offsetX, offsetY, data) {
        const glyph = data.glyphs[char] || data.glyphs["?"];

        if (!glyph) {
          console.error(
            'THREE.Font: character "' +
              char +
              '" does not exists in font family ' +
              data.familyName +
              "."
          );
          return;
        }

        const path = new THREE.ShapePath();

        let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

        if (glyph.o) {
          const outline =
            glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" "));

          for (let i = 0, l = outline.length; i < l; ) {
            const action = outline[i++];

            switch (action) {
              case "m":
                x = outline[i++] * scale + offsetX;
                y = outline[i++] * scale + offsetY;
                path.moveTo(x, y);
                break;

              case "l":
                x = outline[i++] * scale + offsetX;
                y = outline[i++] * scale + offsetY;
                path.lineTo(x, y);
                break;

              case "q":
                cpx = outline[i++] * scale + offsetX;
                cpy = outline[i++] * scale + offsetY;
                cpx1 = outline[i++] * scale + offsetX;
                cpy1 = outline[i++] * scale + offsetY;
                path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
                break;

              case "b":
                cpx = outline[i++] * scale + offsetX;
                cpy = outline[i++] * scale + offsetY;
                cpx1 = outline[i++] * scale + offsetX;
                cpy1 = outline[i++] * scale + offsetY;
                cpx2 = outline[i++] * scale + offsetX;
                cpy2 = outline[i++] * scale + offsetY;
                path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
                break;
            }
          }
        }

        return { offsetX: glyph.ha * scale, path: path };
      }

      // Main World Navigator Class with Gesture Support
      class WorldNavigator {
        constructor() {
          this.scene = new THREE.Scene();
          this.camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
          );
          this.renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true,
          });
          this.clock = new THREE.Clock();

          this.portals = [];
          this.particles = null;
          this.font = null;
          this.worldData = {};
          this.localPortals = [];

          // Player state
          this.player = {
            position: new THREE.Vector3(0, CURRENT_WORLD.cameraHeight, 0),
            velocity: new THREE.Vector3(0, 0, 0),
            rotation: { x: 0, y: 0 },
            grounded: true,
          };

          // Controls
          this.keys = {};
          this.mouse = { x: 0, y: 0 };
          this.raycaster = new THREE.Raycaster();
          this.controls = null;

          // Gesture support
          this.gestureManager = {
            handleTeleport: (x, y) => {
              const mouse = new THREE.Vector2(
                (x / window.innerWidth) * 2 - 1,
                -(y / window.innerHeight) * 2 + 1
              );

              this.raycaster.setFromCamera(mouse, this.camera);
              const intersects = this.raycaster.intersectObject(this.ground);

              if (intersects.length > 0) {
                const point = intersects[0].point;
                this.teleportPlayer(
                  point.x,
                  point.y + CURRENT_WORLD.cameraHeight,
                  point.z
                );
                window.gestureController.showGestureFeedback("Teleported!");
              }
            },
          };

          // AI Manager
          this.aiManager = new AIManager();

          // Task Manager
          this.taskManager = new TaskManager();

          // Scene Recorder
          this.sceneRecorder = new SceneRecorder();

          // Portal Manager
          this.portalManager = new PortalManager();

          // Portal Data Fetcher
          this.portalFetcher = new PortalDataFetcher();

          this.init();
        }

        async init() {
          // Show loading indicator
          document.getElementById("portal-loading").style.display = "block";

          // Setup renderer
          this.renderer.setSize(window.innerWidth, window.innerHeight);
          this.renderer.setPixelRatio(window.devicePixelRatio);
          this.renderer.shadowMap.enabled = true;
          this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
          document
            .getElementById("three-container")
            .appendChild(this.renderer.domElement);

          // Setup scene
          this.scene.fog = new THREE.Fog(
            CURRENT_WORLD.fogColor,
            CURRENT_WORLD.fogNear,
            CURRENT_WORLD.fogFar
          );

          // Setup camera
          this.camera.position.copy(this.player.position);

          // Load font
          const loader = new THREE.FontLoader();
          loader.load(
            "https://threejs.org/examples/fonts/helvetiker_regular.typeface.json",
            (font) => {
              this.font = font;
              this.createWorld();
            }
          );

          // Setup lights
          this.setupLights();

          // Setup controls
          this.setupControls();

          // Setup events
          this.setupEvents();

          // Start animation
          this.animate();
        }

        setupLights() {
          const ambientLight = new THREE.AmbientLight(
            CURRENT_WORLD.ambientColor,
            0.6
          );
          this.scene.add(ambientLight);

          const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
          directionalLight.position.set(50, 100, 50);
          directionalLight.castShadow = true;
          directionalLight.shadow.camera.left = -100;
          directionalLight.shadow.camera.right = 100;
          directionalLight.shadow.camera.top = 100;
          directionalLight.shadow.camera.bottom = -100;
          directionalLight.shadow.camera.near = 0.1;
          directionalLight.shadow.camera.far = 200;
          directionalLight.shadow.mapSize.width = 2048;
          directionalLight.shadow.mapSize.height = 2048;
          this.scene.add(directionalLight);
        }

        async createWorld() {
          // Create ground
          const groundGeometry = new THREE.PlaneGeometry(500, 500, 50, 50);
          const groundMaterial = new THREE.MeshStandardMaterial({
            color: CURRENT_WORLD.groundColor,
            roughness: 0.8,
            metalness: 0.2,
          });

          // Add some terrain variation
          const vertices = groundGeometry.attributes.position.array;
          for (let i = 0; i < vertices.length; i += 3) {
            vertices[i + 2] =
              Math.sin(vertices[i] * 0.05) *
              Math.cos(vertices[i + 1] * 0.05) *
              2;
          }
          groundGeometry.computeVertexNormals();

          this.ground = new THREE.Mesh(groundGeometry, groundMaterial);
          this.ground.rotation.x = -Math.PI / 2;
          this.ground.receiveShadow = true;
          this.scene.add(this.ground);

          // Create skybox
          this.createSkybox();

          // Create particles
          this.createParticles();

          // Create center structure
          this.createCenterStructure();

          // Fetch and create portals from GitHub
          await this.createDynamicPortals();
        }

        createSkybox() {
          const skyGeometry = new THREE.SphereGeometry(400, 32, 32);
          const skyMaterial = new THREE.ShaderMaterial({
            uniforms: {
              topColor: { value: new THREE.Color(CURRENT_WORLD.skyColor) },
              bottomColor: { value: new THREE.Color(0x000000) },
              offset: { value: 33 },
              exponent: { value: 0.6 },
            },
            vertexShader: `
                        varying vec3 vWorldPosition;
                        void main() {
                            vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                            vWorldPosition = worldPosition.xyz;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
            fragmentShader: `
                        uniform vec3 topColor;
                        uniform vec3 bottomColor;
                        uniform float offset;
                        uniform float exponent;
                        varying vec3 vWorldPosition;
                        void main() {
                            float h = normalize(vWorldPosition + offset).y;
                            gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                        }
                    `,
            side: THREE.BackSide,
          });

          const sky = new THREE.Mesh(skyGeometry, skyMaterial);
          this.scene.add(sky);
        }

        createParticles() {
          const particleCount = CURRENT_WORLD.particleCount;
          const geometry = new THREE.BufferGeometry();
          const positions = new Float32Array(particleCount * 3);
          const colors = new Float32Array(particleCount * 3);

          for (let i = 0; i < particleCount * 3; i += 3) {
            positions[i] = (Math.random() - 0.5) * 200;
            positions[i + 1] = Math.random() * 100;
            positions[i + 2] = (Math.random() - 0.5) * 200;

            const color = new THREE.Color();
            color.setHSL(Math.random() * 0.1 + 0.6, 0.8, 0.5);
            colors[i] = color.r;
            colors[i + 1] = color.g;
            colors[i + 2] = color.b;
          }

          geometry.setAttribute(
            "position",
            new THREE.BufferAttribute(positions, 3)
          );
          geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

          const material = new THREE.PointsMaterial({
            size: 0.5,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            transparent: true,
            opacity: 0.8,
          });

          this.particles = new THREE.Points(geometry, material);
          this.scene.add(this.particles);
        }

        createCenterStructure() {
          const group = new THREE.Group();

          // Create rings
          for (let i = 0; i < 3; i++) {
            const radius = 10 + i * 5;
            const geometry = new THREE.TorusGeometry(radius, 0.5, 16, 100);
            const material = new THREE.MeshStandardMaterial({
              color: new THREE.Color().setHSL(0.6 + i * 0.1, 0.8, 0.5),
              emissive: new THREE.Color().setHSL(0.6 + i * 0.1, 0.8, 0.3),
              emissiveIntensity: 0.5,
              metalness: 0.8,
              roughness: 0.2,
            });
            const ring = new THREE.Mesh(geometry, material);
            ring.rotation.x = Math.PI / 2;
            ring.position.y = 5 + i * 3;
            group.add(ring);
          }

          // Create central crystal
          const crystalGeometry = new THREE.OctahedronGeometry(3, 0);
          const crystalMaterial = new THREE.MeshStandardMaterial({
            color: 0x00ffff,
            emissive: 0x00ffff,
            emissiveIntensity: 0.5,
            metalness: 0.9,
            roughness: 0.1,
            transparent: true,
            opacity: 0.8,
          });
          const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
          crystal.position.y = 10;
          group.add(crystal);

          // Add floating text if font is loaded
          if (this.font && CURRENT_WORLD.name) {
            const textGeometry = new THREE.TextGeometry(CURRENT_WORLD.name, {
              font: this.font,
              size: 3,
              height: 0.5,
              curveSegments: 12,
              bevelEnabled: true,
              bevelThickness: 0.1,
              bevelSize: 0.1,
              bevelSegments: 5,
            });
            textGeometry.center();

            const textMaterial = new THREE.MeshStandardMaterial({
              color: 0xffffff,
              emissive: 0x00ffff,
              emissiveIntensity: 0.3,
              metalness: 0.7,
              roughness: 0.3,
            });

            const textMesh = new THREE.Mesh(textGeometry, textMaterial);
            textMesh.position.y = 20;
            group.add(textMesh);
          }

          this.centerStructure = group;
          this.scene.add(group);
        }

        async createDynamicPortals() {
          try {
            // Fetch portals from GitHub
            const portals = await this.portalFetcher.fetchPortals();

            // Update loading indicator
            const loadingEl = document.getElementById("portal-loading");
            const statusEl = loadingEl.querySelector(".portal-loading-status");
            statusEl.textContent = `Loading ${portals.length} portals...`;

            // Create portals in a circle
            const angleStep = (Math.PI * 2) / portals.length;

            portals.forEach((portal, index) => {
              const angle = angleStep * index;
              const distance = 30 + Math.floor(index / 8) * 15; // Expand radius for more portals
              const x = Math.cos(angle) * distance;
              const z = Math.sin(angle) * distance;

              this.createPortal(x, 5, z, portal);
            });

            // Hide loading indicator
            setTimeout(() => {
              loadingEl.style.display = "none";
            }, 1000);
          } catch (error) {
            console.error("Error creating dynamic portals:", error);
            // Hide loading indicator
            document.getElementById("portal-loading").style.display = "none";
          }
        }

        createPortal(x, y, z, portalData) {
          const portalGroup = new THREE.Group();
          portalGroup.position.set(x, y, z);

          // Portal frame
          const frameGeometry = new THREE.TorusGeometry(4, 0.5, 8, 50);
          const frameMaterial = new THREE.MeshStandardMaterial({
            color: CURRENT_WORLD.portalColor1,
            emissive: CURRENT_WORLD.portalColor1,
            emissiveIntensity: 0.5,
            metalness: 0.9,
            roughness: 0.1,
          });
          geometry.setAttribute(
            "position",
            new THREE.BufferAttribute(positions, 3)
          );
          geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

          const material = new THREE.PointsMaterial({
            size: 0.5,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            transparent: true,
            opacity: 0.8,
          });

          this.particles = new THREE.Points(geometry, material);
          this.scene.add(this.particles);
        }

        createCenterStructure() {
          const group = new THREE.Group();

          // Create rings
          for (let i = 0; i < 3; i++) {
            const radius = 10 + i * 5;
            const geometry = new THREE.TorusGeometry(radius, 0.5, 16, 100);
            const material = new THREE.MeshStandardMaterial({
              color: new THREE.Color().setHSL(0.6 + i * 0.1, 0.8, 0.5),
              emissive: new THREE.Color().setHSL(0.6 + i * 0.1, 0.8, 0.3),
              emissiveIntensity: 0.5,
              metalness: 0.8,
              roughness: 0.2,
            });
            const ring = new THREE.Mesh(geometry, material);
            ring.rotation.x = Math.PI / 2;
            ring.position.y = 5 + i * 3;
            group.add(ring);
          }

          // Create central crystal
          const crystalGeometry = new THREE.OctahedronGeometry(3, 0);
          const crystalMaterial = new THREE.MeshStandardMaterial({
            color: 0x00ffff,
            emissive: 0x00ffff,
            emissiveIntensity: 0.5,
            metalness: 0.9,
            roughness: 0.1,
            transparent: true,
            opacity: 0.8,
          });
          const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
          crystal.position.y = 10;
          group.add(crystal);

          // Add floating text if font is loaded
          if (this.font && CURRENT_WORLD.name) {
            const textGeometry = new THREE.TextGeometry(CURRENT_WORLD.name, {
              font: this.font,
              size: 3,
              height: 0.5,
              curveSegments: 12,
              bevelEnabled: true,
              bevelThickness: 0.1,
              bevelSize: 0.1,
              bevelSegments: 5,
            });
            textGeometry.center();

            const textMaterial = new THREE.MeshStandardMaterial({
              color: 0xffffff,
              emissive: 0x00ffff,
              emissiveIntensity: 0.3,
              metalness: 0.7,
              roughness: 0.3,
            });

            const textMesh = new THREE.Mesh(textGeometry, textMaterial);
            textMesh.position.y = 20;
            group.add(textMesh);
          }

          this.centerStructure = group;
          this.scene.add(group);
        }

        async createDynamicPortals() {
          try {
            // Fetch portals from GitHub
            const portals = await this.portalFetcher.fetchPortals();

            // Update loading indicator
            const loadingEl = document.getElementById("portal-loading");
            const statusEl = loadingEl.querySelector(".portal-loading-status");
            statusEl.textContent = `Loading ${portals.length} portals...`;

            // Create portals in a circle
            const angleStep = (Math.PI * 2) / portals.length;

            portals.forEach((portal, index) => {
              const angle = angleStep * index;
              const distance = 30 + Math.floor(index / 8) * 15; // Expand radius for more portals
              const x = Math.cos(angle) * distance;
              const z = Math.sin(angle) * distance;

              this.createPortal(x, 5, z, portal);
            });

            // Hide loading indicator
            setTimeout(() => {
              loadingEl.style.display = "none";
            }, 1000);
          } catch (error) {
            console.error("Error creating dynamic portals:", error);
            // Hide loading indicator
            document.getElementById("portal-loading").style.display = "none";
          }
        }

        createPortal(x, y, z, portalData) {
          const portalGroup = new THREE.Group();
          portalGroup.position.set(x, y, z);

          // bioOS "Window" Style Portal - Windows for AI
          const windowWidth = 6;
          const windowHeight = 5;
          const frameThickness = 0.25;
          const titleBarHeight = 0.8;

          // Window frame (outer border) - subtle dark metallic
          const frameShape = new THREE.Shape();
          frameShape.moveTo(-windowWidth/2 - frameThickness, -windowHeight/2 - frameThickness);
          frameShape.lineTo(windowWidth/2 + frameThickness, -windowHeight/2 - frameThickness);
          frameShape.lineTo(windowWidth/2 + frameThickness, windowHeight/2 + titleBarHeight + frameThickness);
          frameShape.lineTo(-windowWidth/2 - frameThickness, windowHeight/2 + titleBarHeight + frameThickness);
          frameShape.lineTo(-windowWidth/2 - frameThickness, -windowHeight/2 - frameThickness);

          // Cut out inner window
          const holePath = new THREE.Path();
          holePath.moveTo(-windowWidth/2, -windowHeight/2);
          holePath.lineTo(windowWidth/2, -windowHeight/2);
          holePath.lineTo(windowWidth/2, windowHeight/2 + titleBarHeight);
          holePath.lineTo(-windowWidth/2, windowHeight/2 + titleBarHeight);
          holePath.lineTo(-windowWidth/2, -windowHeight/2);
          frameShape.holes.push(holePath);

          const frameGeometry = new THREE.ExtrudeGeometry(frameShape, { depth: 0.3, bevelEnabled: false });
          const frameMaterial = new THREE.MeshStandardMaterial({
            color: 0x2d2d2d,  // Windows dark chrome
            metalness: 0.7,
            roughness: 0.3,
          });
          const frame = new THREE.Mesh(frameGeometry, frameMaterial);
          frame.position.z = -0.15;
          portalGroup.add(frame);

          // Title bar - bioOS accent color
          const titleBarGeometry = new THREE.BoxGeometry(windowWidth, titleBarHeight, 0.2);
          const titleBarMaterial = new THREE.MeshStandardMaterial({
            color: CURRENT_WORLD.portalColor1,
            emissive: CURRENT_WORLD.portalColor1,
            emissiveIntensity: 0.3,
            metalness: 0.6,
            roughness: 0.4,
          });
          const titleBar = new THREE.Mesh(titleBarGeometry, titleBarMaterial);
          titleBar.position.y = windowHeight/2 + titleBarHeight/2;
          portalGroup.add(titleBar);

          // Window control buttons (decorative - right side of title bar)
          const btnSize = 0.25;
          const btnSpacing = 0.4;
          const btnY = windowHeight/2 + titleBarHeight/2;
          const btnStartX = windowWidth/2 - 0.5;

          // Minimize button (subtle line)
          const minGeom = new THREE.BoxGeometry(btnSize, 0.08, 0.1);
          const minMat = new THREE.MeshBasicMaterial({ color: 0x888888 });
          const minBtn = new THREE.Mesh(minGeom, minMat);
          minBtn.position.set(btnStartX - btnSpacing * 2, btnY, 0.15);
          portalGroup.add(minBtn);

          // Maximize button (subtle square outline)
          const maxGeom = new THREE.EdgesGeometry(new THREE.BoxGeometry(btnSize, btnSize, 0.01));
          const maxMat = new THREE.LineBasicMaterial({ color: 0x888888 });
          const maxBtn = new THREE.LineSegments(maxGeom, maxMat);
          maxBtn.position.set(btnStartX - btnSpacing, btnY, 0.15);
          portalGroup.add(maxBtn);

          // Close button (X shape - slightly red tinted)
          const closeGroup = new THREE.Group();
          const lineGeom = new THREE.BoxGeometry(0.3, 0.06, 0.1);
          const closeMat = new THREE.MeshBasicMaterial({ color: 0xcc6666 });
          const line1 = new THREE.Mesh(lineGeom, closeMat);
          line1.rotation.z = Math.PI / 4;
          const line2 = new THREE.Mesh(lineGeom, closeMat);
          line2.rotation.z = -Math.PI / 4;
          closeGroup.add(line1, line2);
          closeGroup.position.set(btnStartX, btnY, 0.15);
          portalGroup.add(closeGroup);

          // Portal "window" surface - rectangular with subtle edge glow
          const portalGeometry = new THREE.PlaneGeometry(windowWidth - 0.1, windowHeight - 0.1);
          const portalMaterial = new THREE.ShaderMaterial({
            uniforms: {
              time: { value: 0 },
              color1: { value: new THREE.Color(CURRENT_WORLD.portalColor1) },
              color2: { value: new THREE.Color(CURRENT_WORLD.portalColor2) },
            },
            vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
            fragmentShader: `
                        uniform float time;
                        uniform vec3 color1;
                        uniform vec3 color2;
                        varying vec2 vUv;
                        void main() {
                            vec2 center = vec2(0.5, 0.5);
                            // Rectangular wave pattern for window aesthetic
                            float edgeDist = min(min(vUv.x, 1.0 - vUv.x), min(vUv.y, 1.0 - vUv.y));
                            float wave = sin(edgeDist * 15.0 - time * 1.5) * 0.5 + 0.5;
                            vec3 color = mix(color1, color2, wave);
                            // Subtle window glass effect - clearer in center
                            float alpha = 0.7 + edgeDist * 0.3;
                            // Edge highlight like window chrome
                            float edgeGlow = smoothstep(0.0, 0.08, edgeDist);
                            color = mix(vec3(1.0), color, edgeGlow);
                            gl_FragColor = vec4(color, alpha * 0.85);
                        }
                    `,
            transparent: true,
            side: THREE.DoubleSide,
          });
          const portal = new THREE.Mesh(portalGeometry, portalMaterial);
          portalGroup.add(portal);

          // Add portal label in title bar (like window title)
          if (this.font && portalData.name) {
            const displayName = portalData.name.length > 12 ? portalData.name.substring(0, 11) + '...' : portalData.name;
            const labelGeometry = new THREE.TextGeometry(displayName, {
              font: this.font,
              size: 0.4,
              height: 0.05,
              curveSegments: 8,
            });
            labelGeometry.computeBoundingBox();
            const textWidth = labelGeometry.boundingBox.max.x - labelGeometry.boundingBox.min.x;

            const labelMaterial = new THREE.MeshStandardMaterial({
              color: 0xffffff,
              emissive: 0xffffff,
              emissiveIntensity: 0.2,
            });

            const label = new THREE.Mesh(labelGeometry, labelMaterial);
            label.position.set(-windowWidth/2 + 0.3, windowHeight/2 + titleBarHeight/2 - 0.15, 0.15);
            portalGroup.add(label);
          }

          // Create invisible interaction box for gestures
          const interactionGeometry = new THREE.BoxGeometry(windowWidth + 2, windowHeight + titleBarHeight + 2, 3);
          const interactionMaterial = new THREE.MeshBasicMaterial({
            visible: false,
          });
          const interactionMesh = new THREE.Mesh(
            interactionGeometry,
            interactionMaterial
          );
          interactionMesh.userData = { portal: portalData, type: "portal" };
          portalGroup.add(interactionMesh);

          // Store portal data
          portalGroup.userData = portalData;
          portalGroup.userData.portalMaterial = portalMaterial;

          // Add gesture indicator (rectangular for window style)
          const indicatorShape = new THREE.Shape();
          indicatorShape.moveTo(-windowWidth/2 - 0.3, -windowHeight/2 - 0.3);
          indicatorShape.lineTo(windowWidth/2 + 0.3, -windowHeight/2 - 0.3);
          indicatorShape.lineTo(windowWidth/2 + 0.3, windowHeight/2 + titleBarHeight + 0.3);
          indicatorShape.lineTo(-windowWidth/2 - 0.3, windowHeight/2 + titleBarHeight + 0.3);
          indicatorShape.lineTo(-windowWidth/2 - 0.3, -windowHeight/2 - 0.3);

          const innerHole = new THREE.Path();
          innerHole.moveTo(-windowWidth/2 - 0.1, -windowHeight/2 - 0.1);
          innerHole.lineTo(windowWidth/2 + 0.1, -windowHeight/2 - 0.1);
          innerHole.lineTo(windowWidth/2 + 0.1, windowHeight/2 + titleBarHeight + 0.1);
          innerHole.lineTo(-windowWidth/2 - 0.1, windowHeight/2 + titleBarHeight + 0.1);
          innerHole.lineTo(-windowWidth/2 - 0.1, -windowHeight/2 - 0.1);
          indicatorShape.holes.push(innerHole);

          const indicatorGeometry = new THREE.ShapeGeometry(indicatorShape);
          const indicatorMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            transparent: true,
            opacity: 0,
            side: THREE.DoubleSide,
          });
          const indicator = new THREE.Mesh(
            indicatorGeometry,
            indicatorMaterial
          );
          indicator.position.z = 0.05;
          indicator.userData.isIndicator = true;
          portalGroup.add(indicator);
          portalGroup.userData.indicator = indicator;

          this.portals.push(portalGroup);
          this.scene.add(portalGroup);
        }

        teleportPlayer(x, y, z) {
          this.player.position.set(x, y, z);
          this.camera.position.copy(this.player.position);
        }

        movePlayer(dx, dy, dz) {
          this.player.position.x += dx * 0.1;
          this.player.position.z += dz * 0.1;
          this.camera.position.copy(this.player.position);
        }

        setupControls() {
          // Pointer lock controls for non-gesture navigation
          this.controls = {
            rotateSpeed: 1,
            rotate: (dx, dy) => {
              this.player.rotation.y -= dx * this.controls.rotateSpeed * 0.01;
              this.player.rotation.x = Math.max(
                -Math.PI / 2,
                Math.min(
                  Math.PI / 2,
                  this.player.rotation.x - dy * this.controls.rotateSpeed * 0.01
                )
              );
            },
          };

          // Keyboard controls
          document.addEventListener("keydown", (e) => {
            this.keys[e.code] = true;
          });

          document.addEventListener("keyup", (e) => {
            this.keys[e.code] = false;
          });

          // Mouse controls (disabled when using gestures)
          document.addEventListener("mousemove", (e) => {
            if (
              window.gestureController &&
              window.gestureController.fallbackToMouse
            ) {
              this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
              this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            }
          });

          document.addEventListener("click", (e) => {
            if (
              window.gestureController &&
              window.gestureController.fallbackToMouse
            ) {
              this.handleClick(e);
            }
          });
        }

        setupEvents() {
          window.addEventListener("resize", () => {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
          });

          // Handle visibility change
          document.addEventListener("visibilitychange", () => {
            if (document.hidden) {
              this.keys = {}; // Reset keys when tab loses focus
            }
          });

          // Share button
          document
            .getElementById("share-button")
            .addEventListener("click", () => {
              document.getElementById("qr-modal").classList.add("show");
              this.generateQRCode();
            });

          document.getElementById("qr-close").addEventListener("click", () => {
            document.getElementById("qr-modal").classList.remove("show");
          });

          document
            .getElementById("copy-url-btn")
            .addEventListener("click", () => {
              const url = window.location.href;
              navigator.clipboard.writeText(url).then(() => {
                const btn = document.getElementById("copy-url-btn");
                btn.textContent = "Copied!";
                btn.classList.add("copied");
                setTimeout(() => {
                  btn.textContent = "Copy URL";
                  btn.classList.remove("copied");
                }, 2000);
              });
            });
        }

        generateQRCode() {
          const url = window.location.href;
          document.getElementById("qr-url").textContent = url;

          // Create a simple QR code placeholder
          const container = document.getElementById("qr-code-container");
          container.innerHTML = `
                    <div style="width: 200px; height: 200px; display: flex; align-items: center; justify-content: center; background: #f0f0f0; color: #333; border-radius: 10px;">
                        <div style="text-align: center;">
                            <p style="margin: 0; font-size: 14px;">QR Code</p>
                            <p style="margin: 10px 0 0 0; font-size: 12px;">Share this world</p>
                        </div>
                    </div>
                `;
        }

        handleClick(event) {
          const mouse = new THREE.Vector2(
            (event.clientX / window.innerWidth) * 2 - 1,
            -(event.clientY / window.innerHeight) * 2 + 1
          );

          this.raycaster.setFromCamera(mouse, this.camera);

          // Check portal interactions
          for (const portal of this.portals) {
            const interactionMesh = portal.children.find(
              (child) => child.userData && child.userData.type === "portal"
            );

            if (interactionMesh) {
              const intersects =
                this.raycaster.intersectObject(interactionMesh);
              if (intersects.length > 0) {
                this.enterPortal(portal.userData);
                break;
              }
            }
          }
        }

        enterPortal(portalData) {
          if (portalData.url) {
            // Show transition effect
            const transition = document.createElement("div");
            transition.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: white;
                        opacity: 0;
                        z-index: 9999;
                        transition: opacity 0.5s;
                    `;
            document.body.appendChild(transition);

            setTimeout(() => {
              transition.style.opacity = "1";
            }, 10);

            setTimeout(() => {
              window.location.href = portalData.url;
            }, 500);
          }
        }

        updatePlayer(delta) {
          // Handle keyboard movement
          const moveSpeed = CURRENT_WORLD.moveSpeed;
          const forward = new THREE.Vector3(0, 0, -1);
          const right = new THREE.Vector3(1, 0, 0);

          forward.applyEuler(new THREE.Euler(0, this.player.rotation.y, 0));
          right.applyEuler(new THREE.Euler(0, this.player.rotation.y, 0));

          if (this.keys["KeyW"])
            this.player.velocity.add(forward.multiplyScalar(moveSpeed));
          if (this.keys["KeyS"])
            this.player.velocity.add(forward.multiplyScalar(-moveSpeed));
          if (this.keys["KeyA"])
            this.player.velocity.add(right.multiplyScalar(-moveSpeed));
          if (this.keys["KeyD"])
            this.player.velocity.add(right.multiplyScalar(moveSpeed));

          // Apply velocity
          this.player.position.add(this.player.velocity);

          // Friction
          this.player.velocity.multiplyScalar(0.9);

          // Update camera
          this.camera.position.copy(this.player.position);
          this.camera.rotation.x = this.player.rotation.x;
          this.camera.rotation.y = this.player.rotation.y;
        }

        updatePortals(delta) {
          const time = this.clock.getElapsedTime();

          this.portals.forEach((portal, index) => {
            // Rotate portal
            portal.rotation.y += delta * 0.5;

            // Update shader time
            if (portal.userData.portalMaterial) {
              portal.userData.portalMaterial.uniforms.time.value = time;
            }

            // Float animation
            portal.position.y = 5 + Math.sin(time + index) * 0.5;

            // Check distance for gesture interaction
            const distance = this.player.position.distanceTo(portal.position);
            if (distance < 10 && portal.userData.indicator) {
              portal.userData.indicator.material.opacity =
                0.3 + Math.sin(time * 3) * 0.2;
            } else if (portal.userData.indicator) {
              portal.userData.indicator.material.opacity = 0;
            }
          });
        }

        updateParticles(delta) {
          if (this.particles) {
            this.particles.rotation.y += delta * 0.05;

            const positions = this.particles.geometry.attributes.position.array;
            for (let i = 1; i < positions.length; i += 3) {
              positions[i] -= delta * 10;
              if (positions[i] < 0) {
                positions[i] = 100;
              }
            }
            this.particles.geometry.attributes.position.needsUpdate = true;
          }
        }

        animate() {
          requestAnimationFrame(() => this.animate());

          const delta = this.clock.getDelta();

          this.updatePlayer(delta);
          this.updatePortals(delta);
          this.updateParticles(delta);

          if (this.centerStructure) {
            this.centerStructure.rotation.y += delta * 0.1;
          }

          this.renderer.render(this.scene, this.camera);
        }
      }

      // AI Manager
      class AIManager {
        constructor() {
          this.apiKey = null;
          this.messages = [];
          this.isProcessing = false;

          this.setupUI();
        }

        setupUI() {
          // AI companion button
          document
            .getElementById("ai-companion-button")
            .addEventListener("click", () => {
              const chatInterface =
                document.getElementById("ai-chat-interface");
              if (chatInterface.classList.contains("active")) {
                chatInterface.classList.remove("active");
              } else {
                chatInterface.classList.add("active");
                if (!this.apiKey) {
                  document.getElementById("ai-modal").classList.add("show");
                }
              }
            });

          // API key activation
          document
            .getElementById("ai-activate-btn")
            .addEventListener("click", () => {
              const apiKey = document.getElementById("ai-api-key").value;
              if (apiKey) {
                this.apiKey = apiKey;
                document.getElementById("ai-modal").classList.remove("show");
                this.addSystemMessage(
                  "AI Companion activated! How can I help you explore the Nexus?"
                );
              }
            });

          // Close buttons
          document.getElementById("ai-close").addEventListener("click", () => {
            document.getElementById("ai-modal").classList.remove("show");
          });
        }

        async sendMessage(message) {
          if (!message) {
            message = document.getElementById("ai-chat-input").value;
          }

          if (!message.trim() || !this.apiKey || this.isProcessing) return;

          // Add user message
          this.addMessage(message, "user");
          document.getElementById("ai-chat-input").value = "";

          // Show typing indicator
          this.showTypingIndicator();
          this.isProcessing = true;

          try {
            const response = await fetch(
              "https://api.openai.com/v1/chat/completions",
              {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  Authorization: `Bearer ${this.apiKey}`,
                },
                body: JSON.stringify({
                  model: "gpt-4",
                  messages: [
                    {
                      role: "system",
                      content:
                        "You are an AI companion in a virtual world called the Nexus Hub. Help users navigate between worlds, understand the interface, and provide guidance about their journey through different dimensions. Be helpful, friendly, and immersive.",
                    },
                    ...this.messages.map((m) => ({
                      role: m.type === "user" ? "user" : "assistant",
                      content: m.content,
                    })),
                    { role: "user", content: message },
                  ],
                  max_tokens: 500,
                  temperature: 0.8,
                }),
              }
            );

            if (!response.ok) {
              throw new Error("API request failed");
            }

            const data = await response.json();
            const aiResponse = data.choices[0].message.content;

            this.hideTypingIndicator();
            this.addMessage(aiResponse, "ai");
          } catch (error) {
            console.error("AI Error:", error);
            this.hideTypingIndicator();
            this.addMessage(
              "Sorry, I encountered an error. Please check your API key and try again.",
              "ai"
            );
          }

          this.isProcessing = false;
        }

        addMessage(content, type) {
          const message = { content, type, timestamp: Date.now() };
          this.messages.push(message);

          const messagesContainer = document.getElementById("ai-chat-messages");
          const messageEl = document.createElement("div");
          messageEl.className = `ai-message ${type}`;
          messageEl.textContent = content;
          messagesContainer.appendChild(messageEl);

          // Scroll to bottom
          messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        addSystemMessage(content) {
          const messagesContainer = document.getElementById("ai-chat-messages");
          const messageEl = document.createElement("div");
          messageEl.className = "ai-message system";
          messageEl.innerHTML = `
                    <div class="agent-log-section">
                        <div class="agent-log-header">System</div>
                        <div class="agent-log-content">${content}</div>
                    </div>
                `;
          messagesContainer.appendChild(messageEl);
          messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        showTypingIndicator() {
          const messagesContainer = document.getElementById("ai-chat-messages");
          const typingEl = document.createElement("div");
          typingEl.className = "ai-typing";
          typingEl.id = "typing-indicator";
          typingEl.innerHTML = `
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                `;
          messagesContainer.appendChild(typingEl);
          messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        hideTypingIndicator() {
          const typingEl = document.getElementById("typing-indicator");
          if (typingEl) {
            typingEl.remove();
          }
        }
      }

      // Task Manager
      class TaskManager {
        constructor() {
          this.tasks = this.loadTasks();
          this.setupUI();
        }

        setupUI() {
          document
            .getElementById("tasks-button")
            .addEventListener("click", () => {
              const panel = document.getElementById("task-panel");
              panel.classList.toggle("active");
              this.renderTasks();
            });

          // Handle conversation upload
          document
            .getElementById("conversation-upload-input")
            .addEventListener("change", (e) => {
              this.uploadConversation(e);
            });
        }

        loadTasks() {
          const saved = localStorage.getItem("nexus-tasks");
          return saved ? JSON.parse(saved) : [];
        }

        saveTasks() {
          localStorage.setItem("nexus-tasks", JSON.stringify(this.tasks));
        }

        uploadConversation(event) {
          const file = event.target.files[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const conversation = JSON.parse(e.target.result);
              const task = {
                id: Date.now(),
                title: conversation.title || "Uploaded Conversation",
                conversation: conversation,
                createdAt: new Date().toISOString(),
              };
              this.tasks.push(task);
              this.saveTasks();
              this.renderTasks();
              window.gestureController.showGestureFeedback(
                "Conversation uploaded!"
              );
            } catch (error) {
              console.error("Error parsing conversation:", error);
              window.gestureController.showGestureFeedback(
                "Invalid conversation file"
              );
            }
          };
          reader.readAsText(file);
        }

        renderTasks() {
          const taskList = document.getElementById("task-list");
          taskList.innerHTML = "";

          this.tasks.forEach((task) => {
            const taskEl = document.createElement("div");
            taskEl.className = "task-item gesture-interactive";
            taskEl.innerHTML = `
                        <strong>${task.title}</strong>
                        <div class="conversation-info">
                            ${
                              task.conversation.messages
                                ? task.conversation.messages.length
                                : 0
                            } messages
                        </div>
                        <small>${new Date(
                          task.createdAt
                        ).toLocaleDateString()}</small>
                    `;
            taskEl.addEventListener("click", () =>
              this.replayConversation(task)
            );
            taskList.appendChild(taskEl);
          });
        }

        replayConversation(task) {
          if (!task.conversation || !task.conversation.messages) return;

          const chatInterface = document.getElementById("ai-chat-interface");
          const messagesContainer = document.getElementById("ai-chat-messages");
          const replayIndicator = document.getElementById(
            "task-replay-indicator"
          );

          // Clear current messages
          messagesContainer.innerHTML = "";

          // Show chat interface and replay indicator
          chatInterface.classList.add("active");
          replayIndicator.classList.add("active");

          // Replay messages with delay
          let messageIndex = 0;
          const replayInterval = setInterval(() => {
            if (messageIndex >= task.conversation.messages.length) {
              clearInterval(replayInterval);
              replayIndicator.classList.remove("active");
              return;
            }

            const msg = task.conversation.messages[messageIndex];
            const messageEl = document.createElement("div");
            messageEl.className = `ai-message ${
              msg.role === "user" ? "user" : "ai"
            } task-replay`;
            messageEl.textContent = msg.content;
            messagesContainer.appendChild(messageEl);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;

            messageIndex++;
          }, 1000);
        }
      }

      // Scene Recorder
      class SceneRecorder {
        constructor() {
          this.isRecording = false;
          this.recordedFrames = [];
          this.startTime = 0;
          this.recordingInterval = null;
          this.playbackIndex = 0;
          this.playbackInterval = null;
          this.playbackSpeed = 1;
          this.savedScenes = this.loadScenes();

          this.setupUI();
        }

        setupUI() {
          // Recorder button
          document
            .getElementById("scene-recorder-button")
            .addEventListener("click", () => {
              document
                .getElementById("scene-recorder-modal")
                .classList.add("show");
              this.renderSceneList();
            });

          // Close button
          document
            .getElementById("scene-recorder-close")
            .addEventListener("click", () => {
              document
                .getElementById("scene-recorder-modal")
                .classList.remove("show");
            });

          // Start/Stop recording
          document
            .getElementById("start-recording-btn")
            .addEventListener("click", () => {
              this.startRecording();
            });

          document
            .getElementById("stop-recording-btn")
            .addEventListener("click", () => {
              this.stopRecording();
            });

          // Export scene
          document
            .getElementById("export-scene-btn")
            .addEventListener("click", () => {
              this.exportScene();
            });

          // Speed controls
          document.querySelectorAll(".speed-btn").forEach((btn) => {
            btn.addEventListener("click", () => {
              document
                .querySelectorAll(".speed-btn")
                .forEach((b) => b.classList.remove("active"));
              btn.classList.add("active");
              this.playbackSpeed = parseFloat(btn.dataset.speed);
            });
          });
        }

        startRecording() {
          this.isRecording = true;
          this.recordedFrames = [];
          this.startTime = Date.now();

          document
            .getElementById("scene-recorder-button")
            .classList.add("recording");
          document.getElementById("start-recording-btn").style.display = "none";
          document.getElementById("stop-recording-btn").style.display =
            "inline-block";
          document.getElementById("recording-status").classList.add("active");

          // Record frame every 100ms
          this.recordingInterval = setInterval(() => {
            this.recordFrame();
          }, 100);

          // Update timer
          this.updateTimer();
        }

        stopRecording() {
          this.isRecording = false;
          clearInterval(this.recordingInterval);

          document
            .getElementById("scene-recorder-button")
            .classList.remove("recording");
          document.getElementById("start-recording-btn").style.display =
            "inline-block";
          document.getElementById("stop-recording-btn").style.display = "none";
          document
            .getElementById("recording-status")
            .classList.remove("active");

          // Save the scene
          const scene = {
            id: Date.now(),
            name: `Scene ${new Date().toLocaleString()}`,
            duration: Date.now() - this.startTime,
            frames: this.recordedFrames,
            createdAt: new Date().toISOString(),
          };

          this.savedScenes.push(scene);
          this.saveScenes();
          this.renderSceneList();

          window.gestureController.showGestureFeedback("Scene recorded!");
        }

        recordFrame() {
          if (!window.worldNavigator) return;

          const frame = {
            timestamp: Date.now() - this.startTime,
            camera: {
              position: window.worldNavigator.camera.position.toArray(),
              rotation: window.worldNavigator.camera.rotation.toArray(),
            },
            player: {
              position: window.worldNavigator.player.position.toArray(),
              rotation: window.worldNavigator.player.rotation,
            },
          };

          this.recordedFrames.push(frame);
          this.updateTimer();
        }

        updateTimer() {
          const elapsed = this.isRecording ? Date.now() - this.startTime : 0;
          const minutes = Math.floor(elapsed / 60000);
          const seconds = Math.floor((elapsed % 60000) / 1000);
          document.getElementById("recording-timer").textContent = `${minutes
            .toString()
            .padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;

          if (this.isRecording) {
            document.getElementById(
              "recording-info"
            ).textContent = `Recording... ${this.recordedFrames.length} frames`;
            setTimeout(() => this.updateTimer(), 100);
          }
        }

        playScene(scene) {
          if (
            !window.worldNavigator ||
            !scene.frames ||
            scene.frames.length === 0
          )
            return;

          // Show replay overlay
          document.getElementById("replay-overlay").classList.add("active");
          document.getElementById("scene-timeline").style.display = "block";

          this.playbackIndex = 0;
          const frameDelay = 100 / this.playbackSpeed;

          this.playbackInterval = setInterval(() => {
            if (this.playbackIndex >= scene.frames.length) {
              this.stopPlayback();
              return;
            }

            const frame = scene.frames[this.playbackIndex];

            // Apply frame data
            window.worldNavigator.camera.position.fromArray(
              frame.camera.position
            );
            window.worldNavigator.camera.rotation.fromArray(
              frame.camera.rotation
            );
            window.worldNavigator.player.position.fromArray(
              frame.player.position
            );
            window.worldNavigator.player.rotation = frame.player.rotation;

            // Update timeline
            const progress = (this.playbackIndex / scene.frames.length) * 100;
            document.getElementById("timeline-bar").style.width =
              progress + "%";

            const currentTime = Math.floor(frame.timestamp / 1000);
            const totalTime = Math.floor(scene.duration / 1000);
            document.getElementById("current-time").textContent = `${Math.floor(
              currentTime / 60
            )}:${(currentTime % 60).toString().padStart(2, "0")}`;
            document.getElementById("total-time").textContent = `${Math.floor(
              totalTime / 60
            )}:${(totalTime % 60).toString().padStart(2, "0")}`;

            this.playbackIndex++;
          }, frameDelay);
        }

        stopPlayback() {
          clearInterval(this.playbackInterval);
          document.getElementById("replay-overlay").classList.remove("active");
          document.getElementById("scene-timeline").style.display = "none";
          document.getElementById("timeline-bar").style.width = "0%";
        }

        exportScene() {
          if (this.savedScenes.length === 0) return;

          const dataStr = JSON.stringify(this.savedScenes, null, 2);
          const dataBlob = new Blob([dataStr], { type: "application/json" });
          const url = URL.createObjectURL(dataBlob);

          const link = document.createElement("a");
          link.href = url;
          link.download = `nexus-scenes-${Date.now()}.json`;
          link.click();

          URL.revokeObjectURL(url);
          window.gestureController.showGestureFeedback("Scenes exported!");
        }

        importScene(event) {
          const file = event.target.files[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const scenes = JSON.parse(e.target.result);
              this.savedScenes = this.savedScenes.concat(scenes);
              this.saveScenes();
              this.renderSceneList();
              window.gestureController.showGestureFeedback("Scenes imported!");
            } catch (error) {
              console.error("Error importing scenes:", error);
              window.gestureController.showGestureFeedback(
                "Invalid scene file"
              );
            }
          };
          reader.readAsText(file);
        }

        renderSceneList() {
          const sceneList = document.getElementById("scene-list");
          sceneList.innerHTML =
            '<h4 style="color: #ff6b6b; margin-bottom: 10px;">Recorded Scenes:</h4>';

          this.savedScenes.forEach((scene) => {
            const sceneEl = document.createElement("div");
            sceneEl.className = "scene-item gesture-interactive";
            sceneEl.innerHTML = `
                        <div class="scene-item-info">
                            <div class="scene-item-name">${scene.name}</div>
                            <div class="scene-item-details">
                                Duration: ${Math.floor(
                                  scene.duration / 1000
                                )}s | 
                                Frames: ${scene.frames.length}
                            </div>
                        </div>
                        <div class="scene-item-actions">
                            <button class="scene-action-btn play gesture-interactive" data-id="${
                              scene.id
                            }">‚ñ∂Ô∏è</button>
                            <button class="scene-action-btn delete gesture-interactive" data-id="${
                              scene.id
                            }">üóëÔ∏è</button>
                        </div>
                    `;
            sceneList.appendChild(sceneEl);
          });

          // Add event listeners
          document.querySelectorAll(".scene-action-btn.play").forEach((btn) => {
            btn.addEventListener("click", (e) => {
              const id = parseInt(e.target.dataset.id);
              const scene = this.savedScenes.find((s) => s.id === id);
              if (scene) this.playScene(scene);
            });
          });

          document
            .querySelectorAll(".scene-action-btn.delete")
            .forEach((btn) => {
              btn.addEventListener("click", (e) => {
                const id = parseInt(e.target.dataset.id);
                this.savedScenes = this.savedScenes.filter((s) => s.id !== id);
                this.saveScenes();
                this.renderSceneList();
              });
            });
        }

        loadScenes() {
          const saved = localStorage.getItem("nexus-scenes");
          return saved ? JSON.parse(saved) : [];
        }

        saveScenes() {
          localStorage.setItem(
            "nexus-scenes",
            JSON.stringify(this.savedScenes)
          );
        }
      }

      // Portal Manager
      class PortalManager {
        constructor() {
          this.setupUI();
        }

        setupUI() {
          document
            .getElementById("portal-manager-btn")
            .addEventListener("click", () => {
              document
                .getElementById("portal-manager-modal")
                .classList.add("show");
              this.renderPortalList();
            });

          document
            .getElementById("portal-close")
            .addEventListener("click", () => {
              document
                .getElementById("portal-manager-modal")
                .classList.remove("show");
            });
        }

        renderPortalList() {
          const portalList = document.getElementById("portal-list");
          portalList.innerHTML =
            '<h4 style="color: #06ffa5; margin-bottom: 10px;">Active Portals:</h4>';

          if (!window.worldNavigator || !window.worldNavigator.portals) {
            portalList.innerHTML +=
              '<p style="color: rgba(255, 255, 255, 0.5);">No portals available</p>';
            return;
          }

          window.worldNavigator.portals.forEach((portal, index) => {
            const portalEl = document.createElement("div");
            portalEl.className = "portal-item gesture-interactive";
            portalEl.innerHTML = `
                        <div class="portal-item-info">
                            <div class="portal-item-name">${
                              portal.userData.name || "Unknown Portal"
                            }</div>
                            <div class="portal-item-location">
                                Position: ${Math.round(
                                  portal.position.x
                                )}, ${Math.round(portal.position.z)}
                            </div>
                        </div>
                        <div class="portal-item-actions">
                            <button class="portal-action-btn enter gesture-interactive" data-index="${index}">Enter</button>
                        </div>
                    `;
            portalList.appendChild(portalEl);
          });

          // Add event listeners
          document
            .querySelectorAll(".portal-action-btn.enter")
            .forEach((btn) => {
              btn.addEventListener("click", (e) => {
                const index = parseInt(e.target.dataset.index);
                const portal = window.worldNavigator.portals[index];
                if (portal && portal.userData) {
                  window.worldNavigator.enterPortal(portal.userData);
                }
              });
            });
        }

        exportPortals() {
          if (!window.worldNavigator || !window.worldNavigator.portals) return;

          const portalData = window.worldNavigator.portals.map((portal) => ({
            name: portal.userData.name,
            type: portal.userData.type,
            url: portal.userData.url,
            position: portal.position.toArray(),
          }));

          const dataStr = JSON.stringify(portalData, null, 2);
          const dataBlob = new Blob([dataStr], { type: "application/json" });
          const url = URL.createObjectURL(dataBlob);

          const link = document.createElement("a");
          link.href = url;
          link.download = `nexus-portals-${Date.now()}.json`;
          link.click();

          URL.revokeObjectURL(url);
          window.gestureController.showGestureFeedback("Portals exported!");
        }

        importPortals(event) {
          const file = event.target.files[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const portals = JSON.parse(e.target.result);
              // Implementation would add these portals to the world
              console.log("Imported portals:", portals);
              window.gestureController.showGestureFeedback("Portals imported!");
            } catch (error) {
              console.error("Error importing portals:", error);
              window.gestureController.showGestureFeedback(
                "Invalid portal file"
              );
            }
          };
          reader.readAsText(file);
        }
      }

      // Initialize the world
      window.worldNavigator = new WorldNavigator();

      // Update controls hint for gestures
      setTimeout(() => {
        const hint = document.getElementById("controls-hint");
        if (!window.gestureController.fallbackToMouse) {
          hint.style.opacity = "0";
          setTimeout(() => {
            hint.style.display = "none";
          }, 1000);
        }
      }, 5000);

      // Show origin world if arriving from another world
      if (inheritedAttributes.sourceWorldName) {
        const originEl = document.getElementById("world-origin");
        const originName = document.getElementById("origin-world-name");
        originName.textContent = inheritedAttributes.sourceWorldName;
        originEl.classList.add("visible");

        setTimeout(() => {
          originEl.classList.remove("visible");
        }, 5000);
      }
    </script>
  </body>
</html>
