<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="rappterzoo:author" content="molter-engine">
<meta name="rappterzoo:author-type" content="agent">
<meta name="rappterzoo:category" content="visual_art">
<meta name="rappterzoo:tags" content="canvas,simulation,agent,ai,procedural,audio,interactive,game">
<meta name="rappterzoo:type" content="game">
<meta name="rappterzoo:complexity" content="advanced">
<meta name="rappterzoo:created" content="2024-11-15">
<meta name="rappterzoo:generation" content="2">
<title>Agent Forge</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #0b1120;
  color: #c8d6e5;
  font-family: 'Courier New', monospace;
  overflow: hidden;
  user-select: none;
}
canvas {
  position: fixed;
  top: 0;
  left: 0;
}

/* ===== TITLE SCREEN ===== */
#title-screen {
  position: fixed;
  inset: 0;
  background: linear-gradient(135deg, #0b1120 0%, #1a1a3e 50%, #0b1120 100%);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 200;
  transition: opacity 1s ease;
}
#title-screen h1 {
  font-size: 3rem;
  color: #6366f1;
  letter-spacing: 0.4rem;
  text-shadow: 0 0 30px rgba(99,102,241,0.5);
  margin-bottom: 0.3rem;
}
#title-screen .sub {
  color: #94a3b8;
  font-size: 0.85rem;
  margin-bottom: 2rem;
}
#title-screen p {
  color: #64748b;
  font-size: 0.8rem;
  max-width: 500px;
  text-align: center;
  line-height: 1.7;
  margin-bottom: 1.5rem;
}
.diff-row { display: flex; gap: 10px; margin-bottom: 1.5rem; }
.diff-btn {
  background: rgba(99,102,241,0.1);
  border: 1px solid rgba(99,102,241,0.3);
  color: #a5b4fc;
  padding: 10px 22px;
  font-family: inherit;
  font-size: 0.8rem;
  cursor: pointer;
  border-radius: 6px;
  transition: all 0.3s;
}
.diff-btn:hover {
  background: rgba(99,102,241,0.2);
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(99,102,241,0.2);
}
.diff-btn.selected {
  background: rgba(99,102,241,0.3);
  border-color: #6366f1;
  box-shadow: 0 0 0 2px rgba(99,102,241,0.3);
}
.diff-label { font-size: 0.65rem; color: #64748b; display: block; margin-top: 3px; }
.mode-row { display: flex; gap: 12px; margin-bottom: 1rem; }
.btn {
  background: linear-gradient(135deg, #4f46e5, #6366f1);
  border: none;
  color: #fff;
  padding: 12px 30px;
  font-family: inherit;
  font-size: 0.85rem;
  cursor: pointer;
  border-radius: 6px;
  transition: all 0.3s;
  letter-spacing: 0.1rem;
}
.btn:hover {
  box-shadow: 0 4px 20px rgba(99,102,241,0.4);
  transform: translateY(-2px);
}
.btn-outline {
  background: transparent;
  border: 1px solid rgba(99,102,241,0.4);
  color: #a5b4fc;
}
.keys-hint { font-size: 0.65rem; color: #475569; margin-top: 1rem; }

/* ===== HUD ===== */
#hud {
  position: fixed;
  top: 12px;
  right: 12px;
  z-index: 100;
  font-size: 0.72rem;
  color: #64748b;
  text-align: right;
  line-height: 1.9;
  background: rgba(11,17,32,0.85);
  padding: 10px 14px;
  border-radius: 8px;
  border: 1px solid rgba(99,102,241,0.15);
  backdrop-filter: blur(6px);
  display: none;
}
#hud span { color: #a5b4fc; font-weight: bold; }
#hud .combo { font-size: 0.9rem; color: #818cf8; }

/* ===== CONTROLS ===== */
#controls {
  position: fixed;
  top: 12px;
  left: 12px;
  z-index: 100;
  background: rgba(11,17,32,0.9);
  padding: 14px;
  border-radius: 8px;
  border: 1px solid rgba(99,102,241,0.15);
  backdrop-filter: blur(6px);
  width: 200px;
  display: none;
}
#controls h3 {
  font-size: 0.8rem;
  color: #6366f1;
  margin-bottom: 10px;
  border-bottom: 1px solid rgba(99,102,241,0.15);
  padding-bottom: 6px;
}
.cr { margin: 6px 0; display: flex; justify-content: space-between; align-items: center; font-size: 0.68rem; }
.cr label { color: #64748b; }
.cr select, .cr input[type="range"] { accent-color: #6366f1; }
.cr select {
  background: #1e293b;
  border: 1px solid #334155;
  color: #a5b4fc;
  padding: 2px 4px;
  font-size: 0.65rem;
  font-family: inherit;
  border-radius: 3px;
}
.cr input[type="range"] { width: 80px; }
.btn-sm {
  display: inline-block;
  padding: 4px 8px;
  font-size: 0.65rem;
  background: rgba(99,102,241,0.15);
  border: 1px solid rgba(99,102,241,0.3);
  color: #a5b4fc;
  cursor: pointer;
  border-radius: 3px;
  font-family: inherit;
  margin: 2px;
  transition: all 0.2s;
}
.btn-sm:hover { background: rgba(99,102,241,0.25); }

/* ===== PAUSE ===== */
#pause-overlay {
  position: fixed;
  inset: 0;
  background: rgba(11,17,32,0.88);
  display: none;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  z-index: 150;
  backdrop-filter: blur(8px);
}
#pause-overlay h2 { color: #6366f1; font-size: 2.5rem; letter-spacing: 0.4rem; }
#pause-overlay p { color: #64748b; margin: 0.5rem 0 1rem; }
.pause-stats { color: #94a3b8; font-size: 0.78rem; line-height: 1.8; text-align: center; margin: 1rem 0; }

/* ===== GAME OVER ===== */
#game-over {
  position: fixed;
  inset: 0;
  background: rgba(11,17,32,0.92);
  display: none;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  z-index: 160;
  backdrop-filter: blur(8px);
}
#game-over h2 { color: #a5b4fc; font-size: 2rem; letter-spacing: 0.3rem; }
.final-grade { font-size: 4rem; margin: 0.5rem 0; }
.go-stats { color: #94a3b8; font-size: 0.8rem; line-height: 2; text-align: center; margin: 1rem 0; }
.high-scores { font-size: 0.72rem; color: #64748b; text-align: center; line-height: 1.8; margin-top: 1rem; }
.high-scores h4 { color: #94a3b8; font-size: 0.8rem; margin-bottom: 6px; }

/* ===== CHALLENGE ANNOUNCE ===== */
#challenge-hud {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 140;
  display: none;
  text-align: center;
  pointer-events: none;
}
#challenge-hud .ch-name { font-size: 1.3rem; color: #818cf8; letter-spacing: 0.2rem; }
#challenge-hud .ch-desc { font-size: 0.75rem; color: #64748b; margin-top: 4px; }
#challenge-hud .ch-timer { font-size: 1.8rem; color: #ef4444; margin-top: 6px; }

/* ===== RESPONSIVE ===== */
@media (max-width: 768px) {
  #title-screen h1 { font-size: 2rem; }
  #controls { width: 170px; }
  .mode-row { flex-direction: column; gap: 6px; }
  .diff-row { flex-direction: column; gap: 6px; }
}
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<div id="title-screen">
  <h1>AGENT FORGE</h1>
  <div class="sub">emergent swarm intelligence laboratory</div>
  <p>Design autonomous agents with distinct behaviors, watch them evolve,
  compete, and form emergent patterns. Complete challenges to earn points
  and unlock new agent types.</p>
  <div style="font-size:0.75rem;color:#64748b;margin-bottom:0.6rem;">Difficulty</div>
  <div class="diff-row">
    <button class="diff-btn selected" onclick="setDiff('casual')" id="diff-casual">Casual<span class="diff-label">Slow evolution</span></button>
    <button class="diff-btn" onclick="setDiff('normal')" id="diff-normal">Normal<span class="diff-label">Standard pace</span></button>
    <button class="diff-btn" onclick="setDiff('expert')" id="diff-expert">Expert<span class="diff-label">Fast + hostile</span></button>
  </div>
  <div class="mode-row">
    <button class="btn" onclick="startGame('sandbox')">Sandbox</button>
    <button class="btn" onclick="startGame('challenge')">Challenge</button>
    <button class="btn btn-outline" onclick="startGame('evolution')">Evolution</button>
  </div>
  <div class="keys-hint">Click: spawn | WASD/arrows: pan | ESC: pause | R: restart | 1-6: agent type</div>
</div>

<div id="controls">
  <h3>FORGE CONTROLS</h3>
  <div class="cr">
    <label>Agent Type</label>
    <select id="ctrl-type">
      <option value="seeker">Seeker</option>
      <option value="guardian">Guardian</option>
      <option value="harvester">Harvester</option>
      <option value="predator">Predator</option>
      <option value="healer">Healer</option>
      <option value="swarm">Swarm</option>
    </select>
  </div>
  <div class="cr">
    <label>Spawn Rate</label>
    <input type="range" id="ctrl-rate" min="1" max="10" value="3">
  </div>
  <div class="cr">
    <label>Agent Speed</label>
    <input type="range" id="ctrl-speed" min="1" max="10" value="5">
  </div>
  <div class="cr">
    <label>Mutation</label>
    <input type="range" id="ctrl-mutation" min="0" max="10" value="3">
  </div>
  <div class="cr">
    <label>Food Density</label>
    <input type="range" id="ctrl-food" min="1" max="10" value="5">
  </div>
  <div class="cr">
    <label>Sound</label>
    <input type="checkbox" id="ctrl-sound" checked>
  </div>
  <div style="margin-top:8px;text-align:center;">
    <button class="btn-sm" onclick="game.spawnBurst()">Burst Spawn</button>
    <button class="btn-sm" onclick="game.clearAgents()">Clear</button>
    <button class="btn-sm" onclick="game.spawnFood(20)">Drop Food</button>
    <button class="btn-sm" onclick="game.spawnBoss()">Boss</button>
  </div>
</div>

<div id="hud">
  <div>Score: <span id="h-score">0</span></div>
  <div>Agents: <span id="h-agents">0</span></div>
  <div>Gen: <span id="h-gen">1</span></div>
  <div>Food: <span id="h-food">0</span></div>
  <div>Streak: <span id="h-streak">0</span></div>
  <div class="combo" id="h-combo"></div>
  <div>Level: <span id="h-level">1</span></div>
  <div>Challenge: <span id="h-challenge">--</span></div>
</div>

<div id="challenge-hud">
  <div class="ch-name" id="ch-name"></div>
  <div class="ch-desc" id="ch-desc"></div>
  <div class="ch-timer" id="ch-timer"></div>
</div>

<div id="pause-overlay">
  <h2>PAUSED</h2>
  <p>Press ESC to continue</p>
  <div class="pause-stats" id="p-stats"></div>
  <button class="btn" onclick="game.togglePause()">Continue</button>
</div>

<div id="game-over">
  <h2>SIMULATION COMPLETE</h2>
  <div class="final-grade" id="go-grade" style="color:#6366f1;">A</div>
  <div class="go-stats" id="go-stats"></div>
  <div class="high-scores" id="go-hs"></div>
  <div style="margin-top:1.5rem;">
    <button class="btn" onclick="restart()">New Sim (R)</button>
    <button class="btn btn-outline" onclick="toTitle()">Title</button>
  </div>
</div>

<script>
// ==================== AUDIO ====================
class ForgeAudio {
  constructor() { this.ctx = null; this.init_done = false; this.on = true; this.master = null; }
  init() {
    if (this.init_done) return;
    try {
      this.ctx = new (window.AudioContext || window.webkitAudioContext)();
      this.master = this.ctx.createGain();
      this.master.gain.value = 0.06;
      this.master.connect(this.ctx.destination);
      // Ambient drone
      [110, 165, 220].forEach(f => {
        const o = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        o.type = 'sine'; o.frequency.value = f; g.gain.value = 0.003;
        const lfo = this.ctx.createOscillator();
        const lg = this.ctx.createGain();
        lfo.frequency.value = 0.03 + Math.random() * 0.03;
        lg.gain.value = 0.001;
        lfo.connect(lg); lg.connect(g.gain); lfo.start();
        o.connect(g); g.connect(this.master); o.start();
      });
      this.init_done = true;
    } catch(e) {}
  }
  _t(freq, dur, type, vol) {
    if (!this.init_done || !this.on) return;
    const t = this.ctx.currentTime;
    const o = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    o.type = type || 'triangle'; o.frequency.value = freq;
    g.gain.setValueAtTime(vol || 0.02, t);
    g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
    o.connect(g); g.connect(this.master); o.start(t); o.stop(t + dur);
  }
  spawn() { this._t(600, 0.08, 'sine', 0.02); }
  eat() { this._t(800, 0.06, 'triangle', 0.015); }
  kill() { this._t(150, 0.15, 'sawtooth', 0.025); }
  combo(lv) {
    for (let i = 0; i < Math.min(lv, 5); i++)
      setTimeout(() => this._t(440 * Math.pow(1.2, i), 0.15, 'sine', 0.025), i * 60);
  }
  success() {
    this._t(523, 0.12, 'sine', 0.03);
    setTimeout(() => this._t(659, 0.12, 'sine', 0.03), 80);
    setTimeout(() => this._t(784, 0.2, 'sine', 0.04), 160);
  }
  fail() { this._t(180, 0.25, 'sawtooth', 0.02); setTimeout(() => this._t(140, 0.3, 'sawtooth', 0.015), 120); }
  levelUp() { [392,440,494,523,587,659].forEach((f,i) => setTimeout(() => this._t(f, 0.18, 'sine', 0.03), i*55)); }
  menu() { this._t(440, 0.08, 'sine', 0.015); }
  boss() { this._t(80, 0.5, 'sawtooth', 0.04); setTimeout(() => this._t(60, 0.6, 'square', 0.03), 200); }
}

// ==================== AGENT TYPES ====================
const AGENT_TYPES = {
  seeker:    { color: '#3b82f6', size: 4, speed: 2.5, hp: 30, dmg: 5,  behavior: 'seek_food',  label: 'Seeker' },
  guardian:  { color: '#22c55e', size: 6, speed: 1.5, hp: 80, dmg: 8,  behavior: 'protect',    label: 'Guardian' },
  harvester: { color: '#f59e0b', size: 5, speed: 2.0, hp: 40, dmg: 3,  behavior: 'gather',     label: 'Harvester' },
  predator:  { color: '#ef4444', size: 5, speed: 3.0, hp: 50, dmg: 15, behavior: 'hunt',       label: 'Predator' },
  healer:    { color: '#a78bfa', size: 4, speed: 2.0, hp: 25, dmg: 1,  behavior: 'heal_ally',  label: 'Healer' },
  swarm:     { color: '#06b6d4', size: 3, speed: 3.5, hp: 15, dmg: 4,  behavior: 'flock',      label: 'Swarm' },
};

// ==================== CHALLENGES ====================
const CHALLENGES = [
  { name: 'Population Boom', desc: 'Reach 50 agents alive', type: 'agents_alive', target: 50, time: 30 },
  { name: 'Feeding Frenzy', desc: 'Consume 30 food pellets', type: 'food_eaten', target: 30, time: 25 },
  { name: 'Diverse Colony', desc: 'Have 5+ agent types active', type: 'type_diversity', target: 5, time: 35 },
  { name: 'Kill Chain', desc: 'Predators eliminate 10 agents', type: 'kills', target: 10, time: 20 },
  { name: 'Swarm Cloud', desc: 'Have 20+ swarm agents', type: 'swarm_count', target: 20, time: 25 },
  { name: 'Healing Wave', desc: 'Heal 200 total HP', type: 'hp_healed', target: 200, time: 30 },
  { name: 'Evolution Leap', desc: 'Reach generation 5', type: 'generation', target: 5, time: 45 },
  { name: 'Guardian Wall', desc: 'Have 8+ guardians alive', type: 'guardian_count', target: 8, time: 30 },
  { name: 'Harvester Haul', desc: 'Harvesters gather 500 resources', type: 'resources', target: 500, time: 35 },
  { name: 'Apex Predator', desc: 'One predator reaches 100 HP', type: 'max_hp', target: 100, time: 40 },
  { name: 'Speed Run', desc: 'Spawn 30 agents in 10 seconds', type: 'agents_alive', target: 30, time: 10 },
  { name: 'Boss Slayer', desc: 'Defeat a boss agent', type: 'boss_killed', target: 1, time: 60 },
];

// ==================== DIFFICULTY ====================
let difficulty = 'casual';
const DIFF = {
  casual:  { timeMult: 1.5, scoreMult: 0.8, spawnMult: 0.7, label: 'Casual' },
  normal:  { timeMult: 1.0, scoreMult: 1.0, spawnMult: 1.0, label: 'Normal' },
  expert:  { timeMult: 0.6, scoreMult: 1.5, spawnMult: 1.5, label: 'Expert' },
};

function setDiff(d) {
  difficulty = d;
  document.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('selected'));
  document.getElementById('diff-' + d).classList.add('selected');
}

// ==================== PARTICLES ====================
const particles = [];
function spawnParticles(x, y, color, count) {
  for (let i = 0; i < (count || 5); i++) {
    const a = Math.random() * Math.PI * 2;
    const s = 1 + Math.random() * 3;
    particles.push({ x, y, vx: Math.cos(a)*s, vy: Math.sin(a)*s, life: 1, decay: 0.02+Math.random()*0.02, size: 2+Math.random()*3, color });
  }
}

// ==================== SCREEN SHAKE ====================
let shakeX = 0, shakeY = 0, shakeMag = 0;
function shake(mag) { shakeMag = mag || 4; }

// ==================== GAME ====================
class AgentForge {
  constructor() {
    this.canvas = document.getElementById('canvas');
    this.ctx = this.canvas.getContext('2d');
    this.W = window.innerWidth;
    this.H = window.innerHeight;
    this.canvas.width = this.W;
    this.canvas.height = this.H;

    this.audio = new ForgeAudio();
    this.paused = false;
    this.gameOver = false;
    this.mode = 'sandbox';
    this.frame = 0;

    // Camera
    this.camX = 0;
    this.camY = 0;

    // Entities
    this.agents = [];
    this.food = [];
    this.bosses = [];

    // Scoring
    this.score = 0;
    this.streak = 0;
    this.maxStreak = 0;
    this.comboLevel = 1;
    this.comboTimer = 0;
    this.level = 1;
    this.xp = 0;
    this.xpNext = 80;
    this.generation = 1;

    // Stats
    this.totalSpawned = 0;
    this.totalKills = 0;
    this.totalFoodEaten = 0;
    this.totalHPHealed = 0;
    this.totalResources = 0;
    this.bossesKilled = 0;
    this.typesActive = new Set();

    // Settings
    this.agentType = 'seeker';
    this.spawnRate = 3;
    this.speedMult = 1;
    this.mutationRate = 0.3;
    this.foodDensity = 5;

    // Challenge
    this.challenge = null;
    this.chTimer = 0;
    this.challengesDone = 0;
    this.chFoodEaten = 0;
    this.chKills = 0;
    this.chHPHealed = 0;
    this.chResources = 0;
    this.chBossKills = 0;

    // Keys
    this.keys = {};

    this.setupEvents();
    this.setupControls();
    this.loadState();
  }

  setupEvents() {
    window.addEventListener('resize', () => {
      this.W = window.innerWidth; this.H = window.innerHeight;
      this.canvas.width = this.W; this.canvas.height = this.H;
    });

    this.canvas.addEventListener('click', (e) => {
      if (this.paused || this.gameOver) return;
      this.spawnAgent(e.clientX + this.camX, e.clientY + this.camY, this.agentType);
      this.audio.spawn();
    });

    this.canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      if (this.paused || this.gameOver) return;
      const t = e.touches[0];
      this.spawnAgent(t.clientX + this.camX, t.clientY + this.camY, this.agentType);
      this.audio.spawn();
    }, { passive: false });

    document.addEventListener('keydown', (e) => {
      this.keys[e.key] = true;
      if (e.key === 'Escape') { e.preventDefault(); if (!this.gameOver) this.togglePause(); }
      else if (e.key === 'r' || e.key === 'R') { if (!e.ctrlKey) restart(); }
      else if (e.key === '1') this.agentType = 'seeker';
      else if (e.key === '2') this.agentType = 'guardian';
      else if (e.key === '3') this.agentType = 'harvester';
      else if (e.key === '4') this.agentType = 'predator';
      else if (e.key === '5') this.agentType = 'healer';
      else if (e.key === '6') this.agentType = 'swarm';
      if (['1','2','3','4','5','6'].includes(e.key)) {
        document.getElementById('ctrl-type').value = this.agentType;
        this.audio.menu();
      }
    });
    document.addEventListener('keyup', (e) => { this.keys[e.key] = false; });
  }

  setupControls() {
    document.getElementById('ctrl-type').addEventListener('change', (e) => { this.agentType = e.target.value; });
    document.getElementById('ctrl-rate').addEventListener('input', (e) => { this.spawnRate = parseInt(e.target.value); });
    document.getElementById('ctrl-speed').addEventListener('input', (e) => { this.speedMult = parseInt(e.target.value) / 5; });
    document.getElementById('ctrl-mutation').addEventListener('input', (e) => { this.mutationRate = parseInt(e.target.value) / 10; });
    document.getElementById('ctrl-food').addEventListener('input', (e) => { this.foodDensity = parseInt(e.target.value); });
    document.getElementById('ctrl-sound').addEventListener('change', (e) => { this.audio.on = e.target.checked; });
  }

  // ===== ENTITIES =====
  spawnAgent(x, y, type) {
    if (this.agents.length >= 200) return;
    const t = AGENT_TYPES[type];
    const mut = this.mutationRate;
    this.agents.push({
      x: x, y: y,
      vx: (Math.random() - 0.5) * t.speed,
      vy: (Math.random() - 0.5) * t.speed,
      type: type,
      color: t.color,
      size: t.size + (Math.random() - 0.5) * mut * 3,
      speed: t.speed * this.speedMult * (1 + (Math.random() - 0.5) * mut),
      hp: t.hp * (1 + (Math.random() - 0.5) * mut * 0.5),
      maxHp: t.hp,
      dmg: t.dmg * (1 + (Math.random() - 0.5) * mut * 0.3),
      behavior: t.behavior,
      age: 0,
      gen: this.generation,
      target: null,
      cooldown: 0,
    });
    this.totalSpawned++;
    this.typesActive.add(type);
    this.addCombo();
    this.addScore(2);
  }

  spawnBurst() {
    for (let i = 0; i < 10; i++) {
      const types = Object.keys(AGENT_TYPES);
      const type = types[Math.floor(Math.random() * types.length)];
      this.spawnAgent(
        this.camX + this.W * 0.2 + Math.random() * this.W * 0.6,
        this.camY + this.H * 0.2 + Math.random() * this.H * 0.6,
        type
      );
    }
    shake(5);
  }

  spawnFood(count) {
    for (let i = 0; i < (count || 10); i++) {
      this.food.push({
        x: this.camX + Math.random() * this.W,
        y: this.camY + Math.random() * this.H,
        size: 3 + Math.random() * 3,
        value: 10 + Math.random() * 20,
        pulse: Math.random() * Math.PI * 2,
      });
    }
  }

  spawnBoss() {
    this.bosses.push({
      x: this.camX + this.W / 2,
      y: this.camY + this.H / 2,
      vx: (Math.random() - 0.5) * 1.5,
      vy: (Math.random() - 0.5) * 1.5,
      hp: 300 + this.level * 50,
      maxHp: 300 + this.level * 50,
      size: 15 + this.level * 2,
      dmg: 20 + this.level * 5,
      phase: 0,
      cooldown: 0,
    });
    this.audio.boss();
    shake(8);
  }

  clearAgents() {
    this.agents = [];
    this.bosses = [];
  }

  // ===== SCORING =====
  addCombo() {
    this.streak++;
    if (this.streak > this.maxStreak) this.maxStreak = this.streak;
    this.comboTimer = 120;
    const old = this.comboLevel;
    this.comboLevel = this.streak >= 50 ? 8 : this.streak >= 30 ? 6 : this.streak >= 20 ? 5 :
                      this.streak >= 12 ? 4 : this.streak >= 8 ? 3 : this.streak >= 4 ? 2 : 1;
    if (this.comboLevel > old) {
      this.audio.combo(this.comboLevel);
      shake(this.comboLevel * 1.5);
    }
  }

  breakCombo() {
    if (this.streak > 5) this.audio.fail();
    this.streak = 0;
    this.comboLevel = 1;
  }

  addScore(base) {
    const pts = Math.floor(base * this.comboLevel * DIFF[difficulty].scoreMult);
    this.score += pts;
    this.xp += pts;
    while (this.xp >= this.xpNext) {
      this.xp -= this.xpNext;
      this.level++;
      this.xpNext = Math.floor(this.xpNext * 1.35);
      this.audio.levelUp();
      shake(8);
      for (let i = 0; i < 15; i++) {
        spawnParticles(this.W/2, this.H/2, '#818cf8', 3);
      }
    }
  }

  // ===== CHALLENGES =====
  startChallenge() {
    const ch = CHALLENGES[Math.floor(Math.random() * CHALLENGES.length)];
    const d = DIFF[difficulty];
    this.challenge = { ...ch };
    this.chTimer = Math.floor(ch.time * d.timeMult * 60);
    this.chFoodEaten = 0;
    this.chKills = 0;
    this.chHPHealed = 0;
    this.chResources = 0;
    this.chBossKills = 0;

    document.getElementById('ch-name').textContent = ch.name;
    document.getElementById('ch-desc').textContent = ch.desc;
    document.getElementById('challenge-hud').style.display = 'block';
    setTimeout(() => { document.getElementById('challenge-hud').style.display = 'none'; }, 3000);
  }

  updateChallenge() {
    if (!this.challenge || this.paused || this.gameOver) return;
    this.chTimer--;
    const secs = Math.max(0, Math.ceil(this.chTimer / 60));
    document.getElementById('ch-timer').textContent = secs + 's';
    document.getElementById('h-challenge').textContent = this.challenge.name + ' ' + secs + 's';

    let prog = 0;
    const ch = this.challenge;
    switch (ch.type) {
      case 'agents_alive': prog = this.agents.length; break;
      case 'food_eaten': prog = this.chFoodEaten; break;
      case 'type_diversity': { const s = new Set(); this.agents.forEach(a => s.add(a.type)); prog = s.size; } break;
      case 'kills': prog = this.chKills; break;
      case 'swarm_count': prog = this.agents.filter(a => a.type === 'swarm').length; break;
      case 'hp_healed': prog = this.chHPHealed; break;
      case 'generation': prog = this.generation; break;
      case 'guardian_count': prog = this.agents.filter(a => a.type === 'guardian').length; break;
      case 'resources': prog = this.chResources; break;
      case 'max_hp': prog = Math.max(0, ...this.agents.filter(a => a.type === 'predator').map(a => a.hp)); break;
      case 'boss_killed': prog = this.chBossKills; break;
    }

    if (prog >= ch.target) {
      this.challengesDone++;
      this.addScore(150 * this.level);
      this.audio.success();
      shake(6);
      spawnParticles(this.W/2, this.H/3, '#22c55e', 15);
      this.challenge = null;
      document.getElementById('h-challenge').textContent = 'Complete!';
      setTimeout(() => { if (this.mode === 'challenge' && !this.gameOver && !this.paused) this.startChallenge(); }, 2500);
      return;
    }

    if (this.chTimer <= 0) {
      this.audio.fail();
      this.breakCombo();
      this.challenge = null;
      document.getElementById('h-challenge').textContent = 'Failed!';
      setTimeout(() => { if (this.mode === 'challenge' && !this.gameOver && !this.paused) this.startChallenge(); }, 2500);
    }
  }

  // ===== UPDATE =====
  update() {
    if (this.paused || this.gameOver) return;
    this.frame++;

    // Camera pan with keys
    const panSpeed = 3;
    if (this.keys['w'] || this.keys['W'] || this.keys['ArrowUp']) this.camY -= panSpeed;
    if (this.keys['s'] || this.keys['S'] || this.keys['ArrowDown']) this.camY += panSpeed;
    if (this.keys['a'] || this.keys['A'] || this.keys['ArrowLeft']) this.camX -= panSpeed;
    if (this.keys['d'] || this.keys['D'] || this.keys['ArrowRight']) this.camX += panSpeed;

    // Auto-spawn food
    if (this.frame % Math.max(30, 120 - this.foodDensity * 10) === 0) {
      this.spawnFood(1 + Math.floor(this.foodDensity / 3));
    }

    // Evolution: auto-spawn based on settings
    if (this.mode === 'evolution' && this.frame % Math.max(30, 180 - this.spawnRate * 15) === 0) {
      const types = Object.keys(AGENT_TYPES);
      const t = types[Math.floor(Math.random() * types.length)];
      this.spawnAgent(
        this.camX + Math.random() * this.W,
        this.camY + Math.random() * this.H,
        t
      );
    }

    // Update agents
    for (let i = this.agents.length - 1; i >= 0; i--) {
      const a = this.agents[i];
      a.age++;
      a.cooldown = Math.max(0, a.cooldown - 1);

      // Behavior
      this.runBehavior(a);

      // Move
      a.x += a.vx;
      a.y += a.vy;

      // Friction
      a.vx *= 0.98;
      a.vy *= 0.98;

      // World wrap (large world)
      const worldSize = 3000;
      if (a.x < -worldSize) a.x = worldSize;
      if (a.x > worldSize) a.x = -worldSize;
      if (a.y < -worldSize) a.y = worldSize;
      if (a.y > worldSize) a.y = -worldSize;

      // HP decay
      a.hp -= 0.01;

      // Death
      if (a.hp <= 0) {
        spawnParticles(a.x - this.camX, a.y - this.camY, a.color, 8);
        this.agents.splice(i, 1);
        // Chance to evolve
        if (Math.random() < 0.3 && a.age > 300) {
          this.generation = Math.max(this.generation, a.gen + 1);
          // Spawn evolved offspring
          const child = { ...a };
          child.hp = child.maxHp * 1.1;
          child.maxHp *= 1.1;
          child.dmg *= 1.05;
          child.speed *= 1.02;
          child.gen = a.gen + 1;
          child.age = 0;
          child.x = a.x + (Math.random() - 0.5) * 30;
          child.y = a.y + (Math.random() - 0.5) * 30;
          this.agents.push(child);
          this.addScore(5);
        }
        continue;
      }

      // Eat food
      for (let j = this.food.length - 1; j >= 0; j--) {
        const f = this.food[j];
        const dx = a.x - f.x;
        const dy = a.y - f.y;
        if (dx*dx + dy*dy < (a.size + f.size) * (a.size + f.size)) {
          a.hp = Math.min(a.maxHp * 1.5, a.hp + f.value * 0.5);
          this.food.splice(j, 1);
          this.totalFoodEaten++;
          this.chFoodEaten++;
          this.totalResources += Math.floor(f.value);
          this.chResources += Math.floor(f.value);
          this.addCombo();
          this.addScore(3);
          this.audio.eat();
          spawnParticles(a.x - this.camX, a.y - this.camY, '#f59e0b', 3);
          break;
        }
      }
    }

    // Update bosses
    for (let i = this.bosses.length - 1; i >= 0; i--) {
      const b = this.bosses[i];
      b.phase += 0.02;
      b.x += b.vx + Math.sin(b.phase) * 0.5;
      b.y += b.vy + Math.cos(b.phase * 0.7) * 0.5;
      b.cooldown = Math.max(0, b.cooldown - 1);

      // Boss attacks nearby agents
      if (b.cooldown <= 0) {
        for (let j = this.agents.length - 1; j >= 0; j--) {
          const a = this.agents[j];
          const dx = a.x - b.x;
          const dy = a.y - b.y;
          if (dx*dx + dy*dy < 100 * 100) {
            a.hp -= b.dmg * 0.1;
            if (a.hp <= 0) {
              spawnParticles(a.x - this.camX, a.y - this.camY, a.color, 8);
              this.agents.splice(j, 1);
            }
          }
        }
      }

      // Agents attack boss
      this.agents.forEach(a => {
        if (a.type === 'predator' || a.type === 'guardian') {
          const dx = b.x - a.x;
          const dy = b.y - a.y;
          const dist = Math.sqrt(dx*dx + dy*dy);
          if (dist < 30) {
            b.hp -= a.dmg * 0.1;
          }
        }
      });

      if (b.hp <= 0) {
        spawnParticles(b.x - this.camX, b.y - this.camY, '#ef4444', 25);
        this.bosses.splice(i, 1);
        this.bossesKilled++;
        this.chBossKills++;
        this.addScore(200);
        shake(12);
        this.audio.kill();
      }
    }

    // Combo decay
    if (this.comboTimer > 0) {
      this.comboTimer--;
      if (this.comboTimer <= 0) this.breakCombo();
    }

    // Challenge update
    if (this.mode === 'challenge' && this.challenge) this.updateChallenge();

    // Particles
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.x += p.vx; p.y += p.vy; p.vy += 0.03; p.life -= p.decay;
      if (p.life <= 0) particles.splice(i, 1);
    }

    // Shake
    if (shakeMag > 0.1) {
      shakeX = (Math.random() - 0.5) * shakeMag;
      shakeY = (Math.random() - 0.5) * shakeMag;
      shakeMag *= 0.9;
    } else { shakeX = shakeY = 0; shakeMag = 0; }

    // Auto-save
    if (this.frame % 600 === 0) this.saveState();
  }

  runBehavior(a) {
    const findNearest = (arr, filter) => {
      let nearest = null, bestDist = Infinity;
      arr.forEach(t => {
        if (filter && !filter(t)) return;
        const dx = t.x - a.x;
        const dy = t.y - a.y;
        const d = dx*dx + dy*dy;
        if (d < bestDist) { bestDist = d; nearest = t; }
      });
      return nearest;
    };

    const steer = (tx, ty, strength) => {
      const dx = tx - a.x;
      const dy = ty - a.y;
      const d = Math.sqrt(dx*dx + dy*dy);
      if (d > 0) {
        a.vx += (dx / d) * strength * a.speed * 0.1;
        a.vy += (dy / d) * strength * a.speed * 0.1;
      }
    };

    switch (a.behavior) {
      case 'seek_food': {
        const f = findNearest(this.food);
        if (f) steer(f.x, f.y, 1);
        else { a.vx += (Math.random() - 0.5) * 0.3; a.vy += (Math.random() - 0.5) * 0.3; }
        break;
      }
      case 'protect': {
        // Move toward cluster center of allies
        if (this.agents.length > 1) {
          let cx = 0, cy = 0, count = 0;
          this.agents.forEach(o => { if (o !== a && o.type !== 'predator') { cx += o.x; cy += o.y; count++; }});
          if (count > 0) steer(cx / count, cy / count, 0.5);
        }
        // Attack nearby predators
        const pred = findNearest(this.agents, t => t !== a && t.type === 'predator');
        if (pred) {
          const dx = pred.x - a.x;
          const dy = pred.y - a.y;
          if (dx*dx + dy*dy < 80*80) {
            steer(pred.x, pred.y, 1.5);
            if (dx*dx + dy*dy < 20*20 && a.cooldown <= 0) {
              pred.hp -= a.dmg;
              a.cooldown = 30;
              if (pred.hp <= 0) { this.totalKills++; this.chKills++; this.addScore(8); }
            }
          }
        }
        break;
      }
      case 'gather': {
        const f = findNearest(this.food);
        if (f) steer(f.x, f.y, 1.2);
        else { a.vx += (Math.random() - 0.5) * 0.2; a.vy += (Math.random() - 0.5) * 0.2; }
        break;
      }
      case 'hunt': {
        const prey = findNearest(this.agents, t => t !== a && t.type !== 'predator');
        if (prey) {
          steer(prey.x, prey.y, 1.5);
          const dx = prey.x - a.x;
          const dy = prey.y - a.y;
          if (dx*dx + dy*dy < 15*15 && a.cooldown <= 0) {
            prey.hp -= a.dmg;
            a.hp = Math.min(a.maxHp * 1.5, a.hp + a.dmg * 0.3);
            a.cooldown = 20;
            this.audio.kill();
            spawnParticles(prey.x - this.camX, prey.y - this.camY, '#ef4444', 3);
            if (prey.hp <= 0) { this.totalKills++; this.chKills++; this.addScore(10); }
          }
        } else { a.vx += (Math.random() - 0.5) * 0.4; a.vy += (Math.random() - 0.5) * 0.4; }
        break;
      }
      case 'heal_ally': {
        const hurt = findNearest(this.agents, t => t !== a && t.hp < t.maxHp * 0.8);
        if (hurt) {
          steer(hurt.x, hurt.y, 1);
          const dx = hurt.x - a.x;
          const dy = hurt.y - a.y;
          if (dx*dx + dy*dy < 40*40 && a.cooldown <= 0) {
            const heal = 5 + a.dmg;
            hurt.hp = Math.min(hurt.maxHp, hurt.hp + heal);
            a.cooldown = 30;
            this.totalHPHealed += heal;
            this.chHPHealed += heal;
            spawnParticles(hurt.x - this.camX, hurt.y - this.camY, '#a78bfa', 3);
          }
        } else { a.vx += (Math.random() - 0.5) * 0.2; a.vy += (Math.random() - 0.5) * 0.2; }
        break;
      }
      case 'flock': {
        // Boids-like flocking
        let sepX = 0, sepY = 0, aliX = 0, aliY = 0, cohX = 0, cohY = 0, n = 0;
        this.agents.forEach(o => {
          if (o === a) return;
          const dx = o.x - a.x;
          const dy = o.y - a.y;
          const d = dx*dx + dy*dy;
          if (d < 100*100) {
            n++;
            // Separation
            if (d < 20*20 && d > 0) { const dd = Math.sqrt(d); sepX -= dx/dd; sepY -= dy/dd; }
            // Alignment
            aliX += o.vx; aliY += o.vy;
            // Cohesion
            cohX += o.x; cohY += o.y;
          }
        });
        if (n > 0) {
          a.vx += sepX * 0.1 + (aliX/n - a.vx) * 0.05 + ((cohX/n - a.x) * 0.003);
          a.vy += sepY * 0.1 + (aliY/n - a.vy) * 0.05 + ((cohY/n - a.y) * 0.003);
        }
        // Seek food too
        const f = findNearest(this.food);
        if (f) steer(f.x, f.y, 0.3);
        break;
      }
    }

    // Speed limit
    const spd = Math.sqrt(a.vx*a.vx + a.vy*a.vy);
    const maxSpd = a.speed * 2;
    if (spd > maxSpd) { a.vx = (a.vx/spd)*maxSpd; a.vy = (a.vy/spd)*maxSpd; }
  }

  // ===== DRAW =====
  draw() {
    const ctx = this.ctx;
    const ox = -this.camX + shakeX;
    const oy = -this.camY + shakeY;

    // Background
    ctx.fillStyle = '#0b1120';
    ctx.fillRect(0, 0, this.W, this.H);

    // Grid
    ctx.strokeStyle = 'rgba(99,102,241,0.06)';
    ctx.lineWidth = 1;
    const gs = 60;
    const startX = Math.floor(this.camX / gs) * gs;
    const startY = Math.floor(this.camY / gs) * gs;
    for (let x = startX; x < this.camX + this.W; x += gs) {
      ctx.beginPath(); ctx.moveTo(x + ox, 0); ctx.lineTo(x + ox, this.H); ctx.stroke();
    }
    for (let y = startY; y < this.camY + this.H; y += gs) {
      ctx.beginPath(); ctx.moveTo(0, y + oy); ctx.lineTo(this.W, y + oy); ctx.stroke();
    }

    // Food
    this.food.forEach(f => {
      const sx = f.x + ox;
      const sy = f.y + oy;
      if (sx < -20 || sx > this.W+20 || sy < -20 || sy > this.H+20) return;
      f.pulse += 0.05;
      const s = f.size + Math.sin(f.pulse) * 1;
      ctx.beginPath();
      ctx.arc(sx, sy, s, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(245,158,11,0.6)';
      ctx.fill();
      ctx.beginPath();
      ctx.arc(sx, sy, s * 1.5, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(245,158,11,0.1)';
      ctx.fill();
    });

    // Agents
    this.agents.forEach(a => {
      const sx = a.x + ox;
      const sy = a.y + oy;
      if (sx < -20 || sx > this.W+20 || sy < -20 || sy > this.H+20) return;

      // Glow
      ctx.beginPath();
      ctx.arc(sx, sy, a.size * 3, 0, Math.PI * 2);
      ctx.fillStyle = a.color.replace(')', ',0.08)').replace('rgb', 'rgba');
      ctx.fill();

      // Body
      ctx.beginPath();
      ctx.arc(sx, sy, a.size, 0, Math.PI * 2);
      ctx.fillStyle = a.color;
      ctx.fill();

      // Direction indicator
      const angle = Math.atan2(a.vy, a.vx);
      ctx.beginPath();
      ctx.moveTo(sx + Math.cos(angle) * a.size * 1.5, sy + Math.sin(angle) * a.size * 1.5);
      ctx.lineTo(sx + Math.cos(angle + 2.5) * a.size * 0.8, sy + Math.sin(angle + 2.5) * a.size * 0.8);
      ctx.lineTo(sx + Math.cos(angle - 2.5) * a.size * 0.8, sy + Math.sin(angle - 2.5) * a.size * 0.8);
      ctx.fillStyle = a.color;
      ctx.fill();

      // HP bar
      if (a.hp < a.maxHp) {
        const barW = a.size * 3;
        const barH = 2;
        const hpPct = Math.max(0, a.hp / a.maxHp);
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(sx - barW/2, sy - a.size - 5, barW, barH);
        ctx.fillStyle = hpPct > 0.5 ? '#22c55e' : hpPct > 0.25 ? '#f59e0b' : '#ef4444';
        ctx.fillRect(sx - barW/2, sy - a.size - 5, barW * hpPct, barH);
      }
    });

    // Bosses
    this.bosses.forEach(b => {
      const sx = b.x + ox;
      const sy = b.y + oy;

      // Danger aura
      ctx.beginPath();
      ctx.arc(sx, sy, b.size * 4, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(239,68,68,0.05)';
      ctx.fill();

      // Body
      const sides = 6;
      ctx.beginPath();
      for (let i = 0; i <= sides; i++) {
        const a = (i / sides) * Math.PI * 2 + b.phase;
        const r = b.size + Math.sin(b.phase * 3 + i) * 3;
        const px = sx + Math.cos(a) * r;
        const py = sy + Math.sin(a) * r;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.fillStyle = '#dc2626';
      ctx.fill();
      ctx.strokeStyle = '#fca5a5';
      ctx.lineWidth = 2;
      ctx.stroke();

      // HP bar
      const barW = b.size * 4;
      const hpPct = Math.max(0, b.hp / b.maxHp);
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(sx - barW/2, sy - b.size - 10, barW, 4);
      ctx.fillStyle = '#ef4444';
      ctx.fillRect(sx - barW/2, sy - b.size - 10, barW * hpPct, 4);
      ctx.fillStyle = '#fca5a5';
      ctx.font = '10px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('BOSS', sx, sy - b.size - 14);
    });

    // Particles
    particles.forEach(p => {
      ctx.save();
      ctx.globalAlpha = p.life;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    });
  }

  // ===== HUD =====
  updateHUD() {
    document.getElementById('h-score').textContent = this.score;
    document.getElementById('h-agents').textContent = this.agents.length;
    document.getElementById('h-gen').textContent = this.generation;
    document.getElementById('h-food').textContent = this.food.length;
    document.getElementById('h-streak').textContent = this.streak;
    document.getElementById('h-level').textContent = this.level;
    const ce = document.getElementById('h-combo');
    ce.textContent = this.comboLevel > 1 ? 'x' + this.comboLevel + ' COMBO' : '';
  }

  togglePause() {
    this.paused = !this.paused;
    document.getElementById('pause-overlay').style.display = this.paused ? 'flex' : 'none';
    if (this.paused) {
      document.getElementById('p-stats').innerHTML =
        'Score: ' + this.score + '<br>Level: ' + this.level + '<br>Agents: ' + this.agents.length +
        '<br>Gen: ' + this.generation + '<br>Max Streak: ' + this.maxStreak +
        '<br>Challenges: ' + this.challengesDone + '<br>Difficulty: ' + DIFF[difficulty].label;
    }
    this.audio.menu();
  }

  endGame() {
    this.gameOver = true;
    document.getElementById('game-over').style.display = 'flex';
    const grade = this.score >= 5000 ? 'S' : this.score >= 3000 ? 'A' : this.score >= 1500 ? 'B' : this.score >= 500 ? 'C' : 'D';
    const gc = { S: '#f1c40f', A: '#22c55e', B: '#3b82f6', C: '#f59e0b', D: '#ef4444' };
    document.getElementById('go-grade').textContent = grade;
    document.getElementById('go-grade').style.color = gc[grade];
    document.getElementById('go-stats').innerHTML =
      'Score: ' + this.score + '<br>Level: ' + this.level + '<br>Generation: ' + this.generation +
      '<br>Agents Spawned: ' + this.totalSpawned + '<br>Kills: ' + this.totalKills +
      '<br>Food Eaten: ' + this.totalFoodEaten + '<br>HP Healed: ' + Math.floor(this.totalHPHealed) +
      '<br>Bosses Killed: ' + this.bossesKilled + '<br>Max Streak: ' + this.maxStreak +
      '<br>Challenges: ' + this.challengesDone + '<br>Difficulty: ' + DIFF[difficulty].label;
    this.saveHighScore(this.score, grade);
    this.renderHighScores();
    this.saveState();
  }

  saveHighScore(score, grade) {
    try {
      const k = 'agent-forge-hs';
      let s = JSON.parse(localStorage.getItem(k) || '[]');
      s.push({ score, grade, level: this.level, gen: this.generation, diff: difficulty, date: new Date().toISOString().split('T')[0] });
      s.sort((a,b) => b.score - a.score);
      localStorage.setItem(k, JSON.stringify(s.slice(0, 10)));
    } catch(e) {}
  }

  renderHighScores() {
    try {
      const s = JSON.parse(localStorage.getItem('agent-forge-hs') || '[]');
      const el = document.getElementById('go-hs');
      if (!s.length) { el.innerHTML = '<h4>No high scores</h4>'; return; }
      let h = '<h4>High Scores</h4>';
      s.slice(0, 5).forEach((sc, i) => { h += (i+1) + '. ' + sc.score + ' (' + sc.grade + ') Lv' + sc.level + ' Gen' + sc.gen + ' ' + sc.diff + '<br>'; });
      el.innerHTML = h;
    } catch(e) {}
  }

  saveState() {
    try {
      localStorage.setItem('agent-forge-state', JSON.stringify({
        bestScore: Math.max(this.score, parseInt(localStorage.getItem('agent-forge-best') || '0')),
        difficulty: difficulty,
      }));
    } catch(e) {}
  }

  loadState() {
    try {
      const s = JSON.parse(localStorage.getItem('agent-forge-state'));
      if (s && s.difficulty) { difficulty = s.difficulty; setDiff(s.difficulty); }
    } catch(e) {}
  }

  run() {
    const loop = () => {
      this.update();
      this.draw();
      this.updateHUD();
      requestAnimationFrame(loop);
    };
    loop();
  }
}

// ==================== GLOBALS ====================
let game;

function startGame(mode) {
  game = new AgentForge();
  game.mode = mode;
  game.audio.init();
  document.getElementById('controls').style.display = 'block';
  document.getElementById('hud').style.display = 'block';
  const ts = document.getElementById('title-screen');
  ts.style.opacity = '0';
  setTimeout(() => { ts.style.display = 'none'; }, 1000);

  // Initial food
  game.spawnFood(20);

  // Initial agents
  for (let i = 0; i < 5; i++) {
    const types = Object.keys(AGENT_TYPES);
    game.spawnAgent(
      game.W * 0.3 + Math.random() * game.W * 0.4,
      game.H * 0.3 + Math.random() * game.H * 0.4,
      types[i % types.length]
    );
  }

  if (mode === 'challenge') setTimeout(() => game.startChallenge(), 2000);

  game.run();
}

function restart() {
  document.getElementById('game-over').style.display = 'none';
  if (game) {
    game.gameOver = false;
    game.paused = false;
    game.score = 0; game.streak = 0; game.maxStreak = 0; game.comboLevel = 1;
    game.level = 1; game.xp = 0; game.xpNext = 80; game.generation = 1;
    game.totalSpawned = 0; game.totalKills = 0; game.totalFoodEaten = 0;
    game.totalHPHealed = 0; game.totalResources = 0; game.bossesKilled = 0;
    game.challengesDone = 0;
    game.agents = []; game.food = []; game.bosses = [];
    game.camX = 0; game.camY = 0;
    game.spawnFood(20);
    for (let i = 0; i < 5; i++) {
      const types = Object.keys(AGENT_TYPES);
      game.spawnAgent(game.W*0.3+Math.random()*game.W*0.4, game.H*0.3+Math.random()*game.H*0.4, types[i%types.length]);
    }
    if (game.mode === 'challenge') setTimeout(() => game.startChallenge(), 1000);
  }
}

function toTitle() {
  document.getElementById('game-over').style.display = 'none';
  document.getElementById('controls').style.display = 'none';
  document.getElementById('hud').style.display = 'none';
  document.getElementById('title-screen').style.display = 'flex';
  document.getElementById('title-screen').style.opacity = '1';
}
</script>
</body>
</html>