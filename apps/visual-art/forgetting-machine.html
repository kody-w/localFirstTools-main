<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Forgetting Machine</title>
    <meta name="description" content="Draw anything and watch as the machine slowly, beautifully forgets it - not by erasing, but by misremembering.">
    <!-- tags: art, experimental, canvas, memory, generative, philosophical -->
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: #0a0a0a;
            min-height: 100vh;
            font-family: 'Georgia', serif;
            color: #888;
            overflow: hidden;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        header {
            padding: 15px 20px;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #222;
        }

        h1 {
            font-size: 1.5em;
            font-weight: normal;
            font-style: italic;
            color: #666;
        }

        .memory-meter {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .meter-label {
            font-size: 0.8em;
            color: #555;
        }

        .meter-bar {
            width: 150px;
            height: 8px;
            background: #222;
            border-radius: 4px;
            overflow: hidden;
        }

        .meter-fill {
            height: 100%;
            background: linear-gradient(90deg, #444, #888);
            transition: width 0.5s ease;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #drawCanvas {
            background: #111;
            cursor: crosshair;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
        }

        #memoryCanvas {
            position: absolute;
            pointer-events: none;
            opacity: 0.3;
        }

        .controls {
            padding: 15px 20px;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            gap: 20px;
            border-top: 1px solid #222;
        }

        button {
            padding: 10px 25px;
            font-family: inherit;
            font-size: 0.9em;
            background: transparent;
            color: #666;
            border: 1px solid #333;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        button:hover {
            color: #aaa;
            border-color: #555;
        }

        .color-picker {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .color-swatch {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s ease;
        }

        .color-swatch:hover {
            transform: scale(1.1);
        }

        .color-swatch.active {
            border-color: #fff;
        }

        .brush-size {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .brush-size input {
            width: 80px;
        }

        .memory-status {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.9em;
            color: #444;
            font-style: italic;
            text-align: center;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        .whisper {
            position: absolute;
            font-size: 0.8em;
            color: rgba(255, 255, 255, 0.1);
            font-style: italic;
            pointer-events: none;
            animation: fadeWhisper 5s ease forwards;
        }

        @keyframes fadeWhisper {
            0% { opacity: 0; transform: translateY(0); }
            20% { opacity: 0.3; }
            100% { opacity: 0; transform: translateY(-30px); }
        }

        .ghost-stroke {
            position: absolute;
            pointer-events: none;
            opacity: 0.1;
            filter: blur(2px);
        }

        .instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #333;
            font-style: italic;
            pointer-events: none;
            transition: opacity 1s ease;
        }

        .instructions.hidden {
            opacity: 0;
        }

        .decay-particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            pointer-events: none;
            animation: particleFade 2s ease forwards;
        }

        @keyframes particleFade {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(0) translateY(-20px); }
        }

        .epoch-counter {
            position: absolute;
            top: 70px;
            right: 20px;
            font-size: 0.8em;
            color: #333;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>The Forgetting Machine</h1>
            <div class="memory-meter">
                <span class="meter-label">Memory Integrity</span>
                <div class="meter-bar">
                    <div class="meter-fill" id="memoryMeter" style="width: 100%"></div>
                </div>
            </div>
        </header>

        <div class="canvas-container" id="canvasContainer">
            <canvas id="drawCanvas"></canvas>
            <canvas id="memoryCanvas"></canvas>

            <div class="instructions" id="instructions">
                Draw something you want to remember.<br>
                <small>The machine will try to hold onto it...</small>
            </div>

            <div class="memory-status" id="memoryStatus"></div>
            <div class="epoch-counter" id="epochCounter">Memories recalled: 0</div>
        </div>

        <div class="controls">
            <div class="color-picker">
                <div class="color-swatch active" style="background: #ffffff" data-color="#ffffff"></div>
                <div class="color-swatch" style="background: #ff6b6b" data-color="#ff6b6b"></div>
                <div class="color-swatch" style="background: #4ecdc4" data-color="#4ecdc4"></div>
                <div class="color-swatch" style="background: #ffe66d" data-color="#ffe66d"></div>
                <div class="color-swatch" style="background: #95e1d3" data-color="#95e1d3"></div>
                <div class="color-swatch" style="background: #dda0dd" data-color="#dda0dd"></div>
            </div>

            <div class="brush-size">
                <span>Brush:</span>
                <input type="range" id="brushSize" min="2" max="30" value="8">
            </div>

            <button id="rehearseBtn">Rehearse Memory</button>
            <button id="clearBtn">Let Go</button>
        </div>
    </div>

    <script>
        // Canvas setup
        const container = document.getElementById('canvasContainer');
        const drawCanvas = document.getElementById('drawCanvas');
        const memoryCanvas = document.getElementById('memoryCanvas');
        const drawCtx = drawCanvas.getContext('2d');
        const memoryCtx = memoryCanvas.getContext('2d');

        // Resize canvases
        function resize() {
            const rect = container.getBoundingClientRect();
            const size = Math.min(rect.width - 40, rect.height - 40, 800);

            drawCanvas.width = size;
            drawCanvas.height = size;
            memoryCanvas.width = size;
            memoryCanvas.height = size;

            memoryCanvas.style.left = drawCanvas.offsetLeft + 'px';
            memoryCanvas.style.top = drawCanvas.offsetTop + 'px';

            // Fill with dark background
            drawCtx.fillStyle = '#111';
            drawCtx.fillRect(0, 0, size, size);
        }

        resize();
        window.addEventListener('resize', resize);

        // Drawing state
        let isDrawing = false;
        let currentColor = '#ffffff';
        let brushSize = 8;
        let lastX, lastY;
        let hasDrawn = false;
        let strokeVelocities = [];

        // Memory state
        let memoryIntegrity = 100;
        let recallCount = 0;
        let memoryData = null;
        let originalData = null;

        // Perlin noise for organic decay
        class PerlinNoise {
            constructor() {
                this.p = [];
                for (let i = 0; i < 256; i++) this.p[i] = Math.floor(Math.random() * 256);
                this.p = this.p.concat(this.p);
            }

            fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            lerp(a, b, t) { return a + t * (b - a); }
            grad(hash, x, y) {
                const h = hash & 3;
                const u = h < 2 ? x : y;
                const v = h < 2 ? y : x;
                return ((h & 1) ? -u : u) + ((h & 2) ? -v : v);
            }

            noise(x, y) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                x -= Math.floor(x);
                y -= Math.floor(y);
                const u = this.fade(x);
                const v = this.fade(y);
                const A = this.p[X] + Y;
                const B = this.p[X + 1] + Y;
                return this.lerp(
                    this.lerp(this.grad(this.p[A], x, y), this.grad(this.p[B], x - 1, y), u),
                    this.lerp(this.grad(this.p[A + 1], x, y - 1), this.grad(this.p[B + 1], x - 1, y - 1), u),
                    v
                );
            }
        }

        const perlin = new PerlinNoise();
        let noiseOffset = 0;

        // Color swatches
        document.querySelectorAll('.color-swatch').forEach(swatch => {
            swatch.addEventListener('click', () => {
                document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
                swatch.classList.add('active');
                currentColor = swatch.dataset.color;
            });
        });

        // Brush size
        document.getElementById('brushSize').addEventListener('input', (e) => {
            brushSize = parseInt(e.target.value);
        });

        // Drawing
        function startDraw(e) {
            isDrawing = true;
            const rect = drawCanvas.getBoundingClientRect();
            lastX = (e.clientX || e.touches[0].clientX) - rect.left;
            lastY = (e.clientY || e.touches[0].clientY) - rect.top;

            if (!hasDrawn) {
                document.getElementById('instructions').classList.add('hidden');
                hasDrawn = true;
                startForgetting();
            }
        }

        function draw(e) {
            if (!isDrawing) return;
            e.preventDefault();

            const rect = drawCanvas.getBoundingClientRect();
            const x = (e.clientX || e.touches[0].clientX) - rect.left;
            const y = (e.clientY || e.touches[0].clientY) - rect.top;

            // Calculate velocity for "emotional weight"
            const velocity = Math.sqrt((x - lastX) ** 2 + (y - lastY) ** 2);
            strokeVelocities.push({ x, y, velocity, time: Date.now() });

            // Draw with slight variation
            drawCtx.beginPath();
            drawCtx.moveTo(lastX, lastY);
            drawCtx.lineTo(x, y);
            drawCtx.strokeStyle = currentColor;
            drawCtx.lineWidth = brushSize;
            drawCtx.lineCap = 'round';
            drawCtx.lineJoin = 'round';
            drawCtx.stroke();

            lastX = x;
            lastY = y;

            // Strengthen memory where we draw (rehearsal)
            reinforceMemory();
        }

        function stopDraw() {
            isDrawing = false;
        }

        // Touch support
        drawCanvas.addEventListener('mousedown', startDraw);
        drawCanvas.addEventListener('mousemove', draw);
        drawCanvas.addEventListener('mouseup', stopDraw);
        drawCanvas.addEventListener('mouseout', stopDraw);
        drawCanvas.addEventListener('touchstart', startDraw);
        drawCanvas.addEventListener('touchmove', draw);
        drawCanvas.addEventListener('touchend', stopDraw);

        // Reinforce memory during active drawing
        function reinforceMemory() {
            memoryIntegrity = Math.min(100, memoryIntegrity + 0.5);
            updateMemoryMeter();
        }

        // Update memory meter
        function updateMemoryMeter() {
            document.getElementById('memoryMeter').style.width = `${memoryIntegrity}%`;
        }

        // Memory whispers - fragments of forgotten content
        const whispers = [
            "was it... here?",
            "the shape felt different",
            "I remember something blue... or was it red?",
            "edges fade first",
            "the center holds longer",
            "each recall changes me",
            "was there more?",
            "the details slip away",
            "I try to hold on",
            "memory is reconstruction",
            "what was your intention?",
            "the weight of attention",
            "forgetting is transformation"
        ];

        function showWhisper() {
            if (memoryIntegrity > 80) return;

            const whisper = document.createElement('div');
            whisper.className = 'whisper';
            whisper.textContent = whispers[Math.floor(Math.random() * whispers.length)];
            whisper.style.left = Math.random() * (container.offsetWidth - 200) + 'px';
            whisper.style.top = Math.random() * (container.offsetHeight - 100) + 'px';
            container.appendChild(whisper);

            setTimeout(() => whisper.remove(), 5000);
        }

        // The forgetting process
        function startForgetting() {
            // Store original for reference
            originalData = drawCtx.getImageData(0, 0, drawCanvas.width, drawCanvas.height);

            // Begin the decay loop
            setInterval(recallAndForget, 3000);
            setInterval(showWhisper, 5000);
        }

        // The core forgetting algorithm
        function recallAndForget() {
            if (memoryIntegrity <= 0) {
                document.getElementById('memoryStatus').textContent = "The memory has fully dissolved...";
                return;
            }

            recallCount++;
            document.getElementById('epochCounter').textContent = `Memories recalled: ${recallCount}`;

            // Get current state
            const imageData = drawCtx.getImageData(0, 0, drawCanvas.width, drawCanvas.height);
            const data = imageData.data;

            noiseOffset += 0.1;

            // Apply various forgetting transformations
            for (let i = 0; i < data.length; i += 4) {
                const x = (i / 4) % drawCanvas.width;
                const y = Math.floor((i / 4) / drawCanvas.width);

                // Skip background
                if (data[i] < 20 && data[i + 1] < 20 && data[i + 2] < 20) continue;

                // 1. Edge decay - edges forget faster
                const isEdge = checkIfEdge(data, i, drawCanvas.width);
                const edgeDecay = isEdge ? 0.95 : 0.99;

                // 2. Perlin noise drift - positions shift organically
                const noiseX = perlin.noise(x * 0.02 + noiseOffset, y * 0.02) * 2;
                const noiseY = perlin.noise(x * 0.02, y * 0.02 + noiseOffset) * 2;

                // 3. Color drift - colors slowly shift
                const colorNoise = perlin.noise(x * 0.01 + noiseOffset * 0.5, y * 0.01);

                // Apply decay
                data[i] = Math.max(17, data[i] * edgeDecay + colorNoise * 3);     // R
                data[i + 1] = Math.max(17, data[i + 1] * edgeDecay + colorNoise * 2); // G
                data[i + 2] = Math.max(17, data[i + 2] * edgeDecay - colorNoise * 2); // B

                // 4. Blur effect - details become fuzzy
                if (Math.random() < 0.02) {
                    applyLocalBlur(data, i, drawCanvas.width);
                }
            }

            drawCtx.putImageData(imageData, 0, 0);

            // Apply displacement for "misremembering" effect
            applyDisplacement();

            // Decay memory integrity
            memoryIntegrity = Math.max(0, memoryIntegrity - 2);
            updateMemoryMeter();

            // Update status message
            const statusMessages = [
                "Recalling...",
                "The edges are softening...",
                "Was it always like this?",
                "Something feels different...",
                "The details are slipping...",
                "Reconstructing from fragments...",
                "The memory shifts...",
                "Each recall changes it...",
                "What was the original?",
                "Forgetting is a kind of transformation..."
            ];

            const msgIndex = Math.min(Math.floor((100 - memoryIntegrity) / 10), statusMessages.length - 1);
            document.getElementById('memoryStatus').textContent = statusMessages[msgIndex];

            // Spawn decay particles
            spawnDecayParticles();
        }

        // Check if pixel is at an edge
        function checkIfEdge(data, i, width) {
            const stride = width * 4;
            const neighbors = [
                i - 4, i + 4,           // left, right
                i - stride, i + stride, // top, bottom
            ];

            let edgeCount = 0;
            for (const ni of neighbors) {
                if (ni < 0 || ni >= data.length) continue;
                const diff = Math.abs(data[i] - data[ni]) +
                            Math.abs(data[i + 1] - data[ni + 1]) +
                            Math.abs(data[i + 2] - data[ni + 2]);
                if (diff > 50) edgeCount++;
            }

            return edgeCount >= 2;
        }

        // Apply local blur
        function applyLocalBlur(data, i, width) {
            const stride = width * 4;
            const neighbors = [i - 4, i + 4, i - stride, i + stride];

            let r = data[i], g = data[i + 1], b = data[i + 2];
            let count = 1;

            for (const ni of neighbors) {
                if (ni >= 0 && ni < data.length - 2) {
                    r += data[ni];
                    g += data[ni + 1];
                    b += data[ni + 2];
                    count++;
                }
            }

            data[i] = r / count;
            data[i + 1] = g / count;
            data[i + 2] = b / count;
        }

        // Apply displacement for warping effect
        function applyDisplacement() {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = drawCanvas.width;
            tempCanvas.height = drawCanvas.height;
            const tempCtx = tempCanvas.getContext('2d');

            tempCtx.drawImage(drawCanvas, 0, 0);

            drawCtx.fillStyle = '#111';
            drawCtx.fillRect(0, 0, drawCanvas.width, drawCanvas.height);

            // Apply subtle warp
            const warpAmount = (100 - memoryIntegrity) * 0.05;

            for (let y = 0; y < drawCanvas.height; y += 4) {
                for (let x = 0; x < drawCanvas.width; x += 4) {
                    const offsetX = perlin.noise(x * 0.01 + noiseOffset, y * 0.01) * warpAmount;
                    const offsetY = perlin.noise(x * 0.01, y * 0.01 + noiseOffset) * warpAmount;

                    drawCtx.drawImage(
                        tempCanvas,
                        x, y, 4, 4,
                        x + offsetX, y + offsetY, 4, 4
                    );
                }
            }
        }

        // Spawn visual decay particles
        function spawnDecayParticles() {
            const count = Math.floor((100 - memoryIntegrity) / 20);

            for (let i = 0; i < count; i++) {
                const particle = document.createElement('div');
                particle.className = 'decay-particle';
                particle.style.left = (drawCanvas.offsetLeft + Math.random() * drawCanvas.width) + 'px';
                particle.style.top = (drawCanvas.offsetTop + Math.random() * drawCanvas.height) + 'px';
                container.appendChild(particle);

                setTimeout(() => particle.remove(), 2000);
            }
        }

        // Rehearse button - strengthens memory
        document.getElementById('rehearseBtn').addEventListener('click', () => {
            if (!hasDrawn) return;

            memoryIntegrity = Math.min(100, memoryIntegrity + 20);
            updateMemoryMeter();
            document.getElementById('memoryStatus').textContent = "Memory reinforced through rehearsal...";

            // Flash effect
            drawCanvas.style.boxShadow = '0 0 50px rgba(255, 255, 255, 0.3)';
            setTimeout(() => {
                drawCanvas.style.boxShadow = '0 0 50px rgba(0, 0, 0, 0.5)';
            }, 300);
        });

        // Clear button
        document.getElementById('clearBtn').addEventListener('click', () => {
            drawCtx.fillStyle = '#111';
            drawCtx.fillRect(0, 0, drawCanvas.width, drawCanvas.height);

            memoryIntegrity = 100;
            recallCount = 0;
            hasDrawn = false;
            strokeVelocities = [];

            updateMemoryMeter();
            document.getElementById('epochCounter').textContent = 'Memories recalled: 0';
            document.getElementById('memoryStatus').textContent = '';
            document.getElementById('instructions').classList.remove('hidden');
        });

        // Save/load memory
        function saveMemory() {
            const data = {
                image: drawCanvas.toDataURL(),
                integrity: memoryIntegrity,
                recalls: recallCount,
                timestamp: Date.now()
            };
            localStorage.setItem('forgetting-machine-memory', JSON.stringify(data));
        }

        function loadMemory() {
            const saved = localStorage.getItem('forgetting-machine-memory');
            if (saved) {
                const data = JSON.parse(saved);

                // Calculate decay since last visit
                const hoursSince = (Date.now() - data.timestamp) / (1000 * 60 * 60);
                const decayAmount = Math.min(50, hoursSince * 5);

                const img = new Image();
                img.onload = () => {
                    drawCtx.drawImage(img, 0, 0);
                    memoryIntegrity = Math.max(0, data.integrity - decayAmount);
                    recallCount = data.recalls;
                    hasDrawn = true;

                    updateMemoryMeter();
                    document.getElementById('epochCounter').textContent = `Memories recalled: ${recallCount}`;
                    document.getElementById('instructions').classList.add('hidden');

                    if (decayAmount > 0) {
                        document.getElementById('memoryStatus').textContent =
                            `The memory faded while you were away...`;
                    }

                    startForgetting();
                };
                img.src = data.image;
            }
        }

        // Auto-save periodically
        setInterval(saveMemory, 10000);
        window.addEventListener('beforeunload', saveMemory);

        // Load on start
        loadMemory();
    </script>
</body>
</html>
