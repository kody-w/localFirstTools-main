<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASCII Art Video Converter</title>
    <meta name="description" content="Real-time webcam to ASCII art converter with Matrix and Retro terminal modes.">
    <style>
        :root {
            --bg-color: #000000;
            --text-color: #ffffff;
            --font-family: 'Courier New', Courier, monospace;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-family);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
        }

        #canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        canvas {
            display: block;
            /* max-width: 100%;
            max-height: 100%; */
        }

        #ui-layer {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #333;
            display: flex;
            gap: 15px;
            z-index: 100;
            backdrop-filter: blur(5px);
        }

        button {
            background: #222;
            color: #fff;
            border: 1px solid #444;
            padding: 8px 16px;
            cursor: pointer;
            font-family: var(--font-family);
            font-weight: bold;
            border-radius: 4px;
            transition: all 0.2s;
        }

        button:hover {
            background: #333;
            border-color: #666;
        }

        button.active {
            background: #00aa00;
            color: #000;
            border-color: #00ff00;
        }

        #video-source {
            display: none;
        }

        /* Retro Mode Effects */
        .retro-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            z-index: 10;
            display: none;
        }
        
        .retro-glow {
            filter: drop-shadow(0 0 5px rgba(0, 255, 0, 0.7));
        }

        #error-msg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #ff4444;
            display: none;
        }
    </style>
</head>
<body>

    <div id="canvas-container">
        <canvas id="ascii-canvas"></canvas>
        <div class="retro-overlay" id="scanlines"></div>
    </div>

    <div id="error-msg">
        <h2>Camera Access Required</h2>
        <p>Please allow camera access to use this application.</p>
    </div>

    <div id="ui-layer">
        <button id="btn-standard" class="active">Standard</button>
        <button id="btn-color">Color</button>
        <button id="btn-matrix">Matrix</button>
        <button id="btn-retro">Retro</button>
        <button id="btn-pause">Pause</button>
        <button id="btn-record" style="border-color: #ff4444; color: #ff4444;">Record</button>
    </div>

    <video id="video-source" autoplay playsinline></video>

    <script>
        const video = document.getElementById('video-source');
        const canvas = document.getElementById('ascii-canvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        const scanlines = document.getElementById('scanlines');
        const errorMsg = document.getElementById('error-msg');

        // Configuration
        const config = {
            mode: 'standard', // standard, color, matrix, retro
            fontSize: 12,
            charSet: ' .:-=+*#%@', // Standard density
            matrixCharSet: 'ﾊﾐﾋｰｳｼﾅﾓﾆｻﾜﾂｵﾘｱﾎﾃﾏｹﾒｴｶｷﾑﾕﾗｾﾈｽﾀﾇﾍ012345789:・.=*+-<>',
            paused: false,
            recording: false
        };

        // State
        let animationId;
        let width, height;
        let cols, rows;
        let matrixColumns = []; // Array to track matrix rain drops
        let recordedFrames = [];
        let recordingStartTime = 0;

        // Setup UI
        document.getElementById('btn-standard').onclick = () => setMode('standard');
        document.getElementById('btn-color').onclick = () => setMode('color');
        document.getElementById('btn-matrix').onclick = () => setMode('matrix');
        document.getElementById('btn-retro').onclick = () => setMode('retro');
        
        const btnPause = document.getElementById('btn-pause');
        btnPause.onclick = () => {
            config.paused = !config.paused;
            btnPause.textContent = config.paused ? "Resume" : "Pause";
            if (config.paused) {
                video.pause();
            } else {
                video.play();
                render();
            }
        };

        const btnRecord = document.getElementById('btn-record');
        btnRecord.onclick = () => {
            if (!config.recording) {
                // Start Recording
                config.recording = true;
                recordedFrames = [];
                recordingStartTime = Date.now();
                btnRecord.textContent = "Stop & Save";
                btnRecord.style.background = "#ff4444";
                btnRecord.style.color = "#fff";
            } else {
                // Stop Recording
                config.recording = false;
                btnRecord.textContent = "Record";
                btnRecord.style.background = "#222";
                btnRecord.style.color = "#ff4444";
                saveRecording();
            }
        };

        function saveRecording() {
            if (recordedFrames.length === 0) return;
            
            const blob = new Blob([JSON.stringify(recordedFrames)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ascii-clip-${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function setMode(mode) {
            config.mode = mode;
            
            // Update UI buttons
            document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            document.getElementById(`btn-${mode}`).classList.add('active');

            // Reset/Apply effects
            scanlines.style.display = mode === 'retro' ? 'block' : 'none';
            canvas.classList.toggle('retro-glow', mode === 'retro');

            if (mode === 'matrix') {
                initMatrixRain();
            }
        }

        // Initialize Camera
        async function initCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        facingMode: "user"
                    } 
                });
                video.srcObject = stream;
                await new Promise(resolve => video.onloadedmetadata = resolve);
                resize();
                window.addEventListener('resize', resize);
                render();
            } catch (err) {
                console.error("Camera error:", err);
                errorMsg.style.display = 'block';
                document.getElementById('ui-layer').style.display = 'none';
            }
        }

        function resize() {
            // Make canvas fill the screen but maintain aspect ratio logic if needed
            // For ASCII, we want pixel-perfect font rendering
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Calculate grid dimensions
            cols = Math.floor(canvas.width / (config.fontSize * 0.6)); // 0.6 is approx aspect ratio of font
            rows = Math.floor(canvas.height / config.fontSize);

            ctx.font = `${config.fontSize}px monospace`;
            ctx.textBaseline = 'top';

            if (config.mode === 'matrix') {
                initMatrixRain();
            }
        }

        function initMatrixRain() {
            matrixColumns = [];
            for (let x = 0; x < cols; x++) {
                matrixColumns[x] = {
                    y: Math.floor(Math.random() * rows),
                    speed: Math.random() * 0.5 + 0.5,
                    chars: [] // Store chars for trail effect
                };
            }
        }

        // Offscreen canvas for reading pixel data
        const offCanvas = document.createElement('canvas');
        const offCtx = offCanvas.getContext('2d', { willReadFrequently: true });

        function getPixelData() {
            // Resize offscreen canvas to match grid size
            if (offCanvas.width !== cols || offCanvas.height !== rows) {
                offCanvas.width = cols;
                offCanvas.height = rows;
            }
            
            // Draw video to offscreen canvas (scaled down)
            // We mirror the image for better UX
            offCtx.save();
            offCtx.scale(-1, 1);
            offCtx.drawImage(video, -cols, 0, cols, rows);
            offCtx.restore();

            return offCtx.getImageData(0, 0, cols, rows).data;
        }

        function render() {
            if (config.paused) return;

            // Clear background
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const data = getPixelData();
            const len = config.charSet.length;

            ctx.font = `bold ${config.fontSize}px monospace`;

            if (config.mode === 'matrix') {
                renderMatrix(data);
            } else {
                renderStandard(data, len);
            }

            // Recording Logic
            if (config.recording) {
                captureFrame(data, len);
            }

            animationId = requestAnimationFrame(render);
        }

        function captureFrame(data, len) {
            // Capture the current frame as a string
            // We'll use the standard charset logic for simplicity in the CLI player
            // or we could try to capture the exact characters being rendered
            
            let frameString = "";
            
            // If in matrix mode, it's hard to capture the exact random chars unless we store them.
            // For now, let's just capture the "Standard" representation of the frame
            // so it's viewable in the CLI.
            
            // Actually, let's try to respect the mode if possible, but standard is safest for CLI.
            // Let's stick to standard grayscale mapping for the recording.
            
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const i = (y * cols + x) * 4;
                    const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    
                    let char = " ";
                    if (config.mode === 'matrix') {
                         // Simple threshold for matrix recording
                         if (avg > 30) {
                             char = config.matrixCharSet[Math.floor((avg/255) * (config.matrixCharSet.length-1))];
                         }
                    } else {
                        const charIndex = Math.floor((avg / 255) * (len - 1));
                        char = config.charSet[charIndex];
                    }
                    frameString += char;
                }
                frameString += "\n";
            }
            
            recordedFrames.push(frameString);
        }

        function renderStandard(data, len) {
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const i = (y * cols + x) * 4;
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    // Calculate brightness
                    const avg = (r + g + b) / 3;
                    
                    // Map to char
                    const charIndex = Math.floor((avg / 255) * (len - 1));
                    const char = config.charSet[charIndex];

                    // Color logic
                    if (config.mode === 'color') {
                        ctx.fillStyle = `rgb(${r},${g},${b})`;
                    } else if (config.mode === 'retro') {
                        // Green terminal look
                        // Brightness determines opacity/intensity
                        ctx.fillStyle = `rgba(0, 255, 50, ${avg/255})`;
                    } else {
                        // Standard grayscale
                        ctx.fillStyle = '#ffffff';
                    }

                    ctx.fillText(char, x * (config.fontSize * 0.6), y * config.fontSize);
                }
            }
        }

        function renderMatrix(data) {
            // Matrix rain effect mixed with video feed
            // We use the video brightness to determine IF we draw a character and how bright it is
            // But the character itself is determined by the "rain" logic

            ctx.fillStyle = '#0F0'; // Default matrix green
            
            for (let i = 0; i < matrixColumns.length; i++) {
                const col = matrixColumns[i];
                
                // Update rain position
                col.y += col.speed;
                if (col.y >= rows && Math.random() > 0.975) {
                    col.y = 0;
                    col.speed = Math.random() * 0.5 + 0.5;
                }

                // Draw the column
                // We only draw characters where the "rain" is currently passing through
                // OR we can draw the whole screen but use the rain to highlight?
                // Let's try: The video defines the brightness/visibility. The rain defines the character change.
                
                // Actually, better Matrix effect:
                // Characters are always falling.
                // The VIDEO controls the brightness/alpha of the falling characters.
                // So if you are dark, the code is invisible. If you are bright, the code is visible.

                const x = i;
                const currentY = Math.floor(col.y);

                for (let y = 0; y < rows; y++) {
                    // Get video brightness at this position
                    const pixelIndex = (y * cols + x) * 4;
                    const r = data[pixelIndex];
                    const g = data[pixelIndex + 1];
                    const b = data[pixelIndex + 2];
                    const brightness = (r + g + b) / 3;

                    // Only draw if there's some brightness
                    if (brightness > 20) {
                        // Pick a random matrix char occasionally to simulate changing code
                        if (Math.random() > 0.95) {
                            // Randomize char
                        }
                        
                        // Determine character
                        // We can use a fixed char for the column or random
                        const charIndex = Math.floor(Math.random() * config.matrixCharSet.length);
                        const char = config.matrixCharSet[charIndex];

                        // Color logic
                        // Head of the rain is white/bright green
                        // Tail is darker green
                        // Video brightness affects opacity
                        
                        let alpha = brightness / 255;
                        
                        // Apply rain trail effect
                        // Distance from current rain head
                        let dist = currentY - y;
                        if (dist < 0) dist += rows; // Wrap around logic roughly
                        
                        // This is a bit complex to mix both video and rain.
                        // Let's simplify: 
                        // The video IS the matrix code.
                        // We just use Matrix characters.
                        // And we make them fall?
                        
                        // Alternative Matrix Mode:
                        // Just render the video using Matrix characters.
                        // But make the characters change randomly to look like "code".
                        // And apply a green tint.
                        
                        ctx.fillStyle = `rgba(0, 255, 70, ${alpha})`;
                        
                        // Highlight the "head" of the rain drops if we want that specific rain look
                        // But mapping video to rain is tricky.
                        
                        // Let's stick to: Video rendered with Matrix chars + Green Color + Random updates
                        
                        ctx.fillText(char, x * (config.fontSize * 0.6), y * config.fontSize);
                    }
                }
            }
        }
        
        // Override renderMatrix for a better effect that matches the prompt "characters rain down"
        // The previous attempt was getting messy. Let's try a cleaner approach for Matrix mode.
        renderMatrix = function(data) {
            // Fade out the canvas slightly to create trails (if we weren't clearing it every frame)
            // But we are clearing it.
            
            // Let's do the "Video is the mask" approach.
            // We simulate a full screen of raining code.
            // But we only draw it where the video is bright.
            
            for (let i = 0; i < matrixColumns.length; i++) {
                const col = matrixColumns[i];
                
                // Move rain
                col.y += col.speed;
                if (col.y >= rows) {
                    col.y = 0;
                    col.speed = Math.random() * 0.5 + 0.5;
                }
                
                const headY = Math.floor(col.y);

                for (let y = 0; y < rows; y++) {
                    // Get video brightness
                    const pixelIndex = (y * cols + i) * 4;
                    const brightness = (data[pixelIndex] + data[pixelIndex + 1] + data[pixelIndex + 2]) / 3;
                    
                    if (brightness < 30) continue; // Black areas show no code

                    // Determine if this cell is part of a trail
                    // We'll just draw random characters everywhere but weight their brightness by the video
                    // AND by the rain position?
                    
                    // Let's just do "Digital Soul" style:
                    // Static grid of changing characters.
                    // Brightness = Video Brightness.
                    // Color = Green.
                    // Occasional "White" highlights for high brightness.
                    
                    const char = config.matrixCharSet[Math.floor(Math.random() * config.matrixCharSet.length)];
                    
                    let r = 0, g = 255, b = 70;
                    
                    // High brightness pixels are white (like the source code highlights)
                    if (brightness > 200) {
                        r = 200; g = 255; b = 200;
                    }
                    
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${brightness/255})`;
                    ctx.fillText(char, i * (config.fontSize * 0.6), y * config.fontSize);
                }
            }
        }

        // Start
        initCamera();

    </script>
</body>
</html>