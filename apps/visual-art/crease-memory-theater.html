<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crease Memory Theater</title>
    <meta name="description" content="Draw fold lines on paper and watch it autonomously explore all possible 3D configurations, building a luminous memory of shapes">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
        }
        #canvas {
            background: #fefefe;
            box-shadow: 0 20px 60px rgba(0,0,0,0.4);
            cursor: crosshair;
        }
        .controls {
            position: fixed;
            bottom: 20px;
            display: flex;
            gap: 15px;
        }
        button {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            color: #fff;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        button:hover {
            background: rgba(255,255,255,0.2);
            transform: translateY(-2px);
        }
        .info {
            position: fixed;
            top: 20px;
            color: rgba(255,255,255,0.8);
            font-size: 14px;
            text-align: center;
        }
        .memory-glow {
            position: fixed;
            top: 20px;
            right: 20px;
            color: rgba(255,255,255,0.6);
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="info">Draw crease lines on the paper. Watch it dream of its possible forms.</div>
    <canvas id="canvas"></canvas>
    <div class="memory-glow" id="memoryDisplay">Memory Depth: 0</div>
    <div class="controls">
        <button id="dreamBtn">Let Paper Dream</button>
        <button id="clearBtn">New Paper</button>
        <button id="foldBtn">Toggle Folding</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const size = Math.min(window.innerWidth - 100, window.innerHeight - 200, 600);
        canvas.width = size;
        canvas.height = size;

        let creases = [];
        let isDrawing = false;
        let startPoint = null;
        let isDreaming = false;
        let isFolding = false;
        let currentFold = 0;
        let memoryDepth = 0;
        let creaseMemories = [];
        let dreamPhase = 0;
        let paperState = { vertices: [], folds: [] };

        // Initialize paper as a grid of vertices
        function initPaper() {
            const gridSize = 10;
            const cellSize = size / gridSize;
            paperState.vertices = [];
            for (let y = 0; y <= gridSize; y++) {
                for (let x = 0; x <= gridSize; x++) {
                    paperState.vertices.push({
                        x: x * cellSize,
                        y: y * cellSize,
                        z: 0,
                        baseX: x * cellSize,
                        baseY: y * cellSize
                    });
                }
            }
        }

        // Drawing creases
        canvas.addEventListener('mousedown', (e) => {
            if (isDreaming) return;
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            startPoint = {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDrawing || !startPoint || isDreaming) return;
            const rect = canvas.getBoundingClientRect();
            const endPoint = {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
            render();
            ctx.beginPath();
            ctx.moveTo(startPoint.x, startPoint.y);
            ctx.lineTo(endPoint.x, endPoint.y);
            ctx.strokeStyle = 'rgba(100, 100, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
        });

        canvas.addEventListener('mouseup', (e) => {
            if (!isDrawing || !startPoint || isDreaming) return;
            const rect = canvas.getBoundingClientRect();
            const endPoint = {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
            
            const dx = endPoint.x - startPoint.x;
            const dy = endPoint.y - startPoint.y;
            const length = Math.sqrt(dx * dx + dy * dy);
            
            if (length > 20) {
                creases.push({
                    start: { ...startPoint },
                    end: { ...endPoint },
                    angle: Math.atan2(dy, dx),
                    length: length,
                    foldAngle: 0,
                    targetFoldAngle: 0,
                    memory: 0,
                    glowIntensity: 1
                });
                memoryDepth++;
                document.getElementById('memoryDisplay').textContent = `Memory Depth: ${memoryDepth}`;
            }
            
            isDrawing = false;
            startPoint = null;
            render();
        });

        function render() {
            ctx.fillStyle = '#fefefe';
            ctx.fillRect(0, 0, size, size);
            
            // Draw paper texture
            for (let i = 0; i < 50; i++) {
                ctx.fillStyle = `rgba(0, 0, 0, ${Math.random() * 0.02})`;
                ctx.fillRect(
                    Math.random() * size,
                    Math.random() * size,
                    Math.random() * 3,
                    Math.random() * 3
                );
            }
            
            // Draw memory traces (ghost shapes from previous folds)
            creaseMemories.forEach((memory, idx) => {
                const age = (Date.now() - memory.timestamp) / 10000;
                const alpha = Math.max(0.05, 0.3 - age * 0.1);
                ctx.beginPath();
                ctx.moveTo(memory.start.x, memory.start.y);
                ctx.lineTo(memory.end.x, memory.end.y);
                ctx.strokeStyle = `rgba(255, 200, 100, ${alpha})`;
                ctx.lineWidth = 1;
                ctx.stroke();
            });
            
            // Draw creases
            creases.forEach((crease, idx) => {
                // Glow effect for active creases
                if (crease.memory > 0) {
                    for (let g = 3; g > 0; g--) {
                        ctx.beginPath();
                        ctx.moveTo(crease.start.x, crease.start.y);
                        ctx.lineTo(crease.end.x, crease.end.y);
                        ctx.strokeStyle = `rgba(255, 200, 100, ${crease.memory * 0.1 / g})`;
                        ctx.lineWidth = g * 4;
                        ctx.stroke();
                    }
                }
                
                // Main crease line
                ctx.beginPath();
                ctx.moveTo(crease.start.x, crease.start.y);
                ctx.lineTo(crease.end.x, crease.end.y);
                
                const foldIntensity = Math.abs(crease.foldAngle) / Math.PI;
                const r = Math.floor(50 + foldIntensity * 150);
                const g = Math.floor(50 + crease.memory * 20);
                const b = Math.floor(150 + foldIntensity * 100);
                ctx.strokeStyle = `rgb(${r}, ${g}, ${b})`;
                ctx.lineWidth = 2 + foldIntensity * 2;
                ctx.stroke();
                
                // Fold direction indicator
                if (Math.abs(crease.foldAngle) > 0.1) {
                    const midX = (crease.start.x + crease.end.x) / 2;
                    const midY = (crease.start.y + crease.end.y) / 2;
                    const perpAngle = crease.angle + Math.PI / 2;
                    const offset = crease.foldAngle * 10;
                    
                    ctx.beginPath();
                    ctx.arc(
                        midX + Math.cos(perpAngle) * offset,
                        midY + Math.sin(perpAngle) * offset,
                        3 + foldIntensity * 3,
                        0, Math.PI * 2
                    );
                    ctx.fillStyle = `rgba(255, 150, 50, ${0.5 + foldIntensity * 0.5})`;
                    ctx.fill();
                }
            });
            
            // Draw 3D projection hint
            if (isDreaming || isFolding) {
                drawPaper3D();
            }
        }

        function drawPaper3D() {
            const cx = size / 2;
            const cy = size / 2;
            const scale = 0.3;
            const offsetX = size * 0.7;
            const offsetY = size * 0.3;
            
            ctx.save();
            ctx.translate(offsetX, offsetY);
            
            // Draw 3D paper representation
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.strokeStyle = 'rgba(0, 0, 100, 0.3)';
            ctx.lineWidth = 1;
            
            const corners = [
                { x: -100, y: -100, z: 0 },
                { x: 100, y: -100, z: 0 },
                { x: 100, y: 100, z: 0 },
                { x: -100, y: 100, z: 0 }
            ];
            
            // Apply fold transformations
            const transformedCorners = corners.map(c => {
                let point = { ...c };
                creases.forEach(crease => {
                    const foldAngle = crease.foldAngle;
                    // Simplified fold simulation
                    const relX = (c.x + 100) / 200 * size;
                    const relY = (c.y + 100) / 200 * size;
                    const creaseMidX = (crease.start.x + crease.end.x) / 2;
                    const creaseMidY = (crease.start.y + crease.end.y) / 2;
                    
                    if (relX > creaseMidX) {
                        point.z += Math.sin(foldAngle) * 30;
                        point.x -= Math.cos(foldAngle) * 10;
                    }
                });
                return point;
            });
            
            // Draw 3D paper
            ctx.beginPath();
            transformedCorners.forEach((corner, i) => {
                const px = corner.x * scale - corner.z * 0.3;
                const py = corner.y * scale - corner.z * 0.5;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            });
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            ctx.restore();
        }

        function dream() {
            if (creases.length === 0) return;
            isDreaming = true;
            dreamPhase = 0;
            animateDream();
        }

        function animateDream() {
            if (!isDreaming) return;
            
            dreamPhase += 0.02;
            
            creases.forEach((crease, idx) => {
                // Each crease explores different fold angles
                const wave = Math.sin(dreamPhase * 2 + idx * 0.7);
                const secondWave = Math.sin(dreamPhase * 1.3 + idx * 1.2);
                crease.targetFoldAngle = (wave + secondWave * 0.5) * Math.PI * 0.4;
                crease.foldAngle += (crease.targetFoldAngle - crease.foldAngle) * 0.1;
                
                // Build memory
                crease.memory += 0.05;
                
                // Store memory traces
                if (Math.random() < 0.02) {
                    creaseMemories.push({
                        start: { ...crease.start },
                        end: { ...crease.end },
                        foldAngle: crease.foldAngle,
                        timestamp: Date.now()
                    });
                    if (creaseMemories.length > 100) {
                        creaseMemories.shift();
                    }
                }
            });
            
            render();
            
            if (dreamPhase < Math.PI * 4) {
                requestAnimationFrame(animateDream);
            } else {
                isDreaming = false;
                // Settle to rest
                creases.forEach(c => {
                    c.targetFoldAngle = 0;
                });
                settleAnimation();
            }
        }

        function settleAnimation() {
            let settling = false;
            creases.forEach(crease => {
                crease.foldAngle += (crease.targetFoldAngle - crease.foldAngle) * 0.1;
                if (Math.abs(crease.foldAngle - crease.targetFoldAngle) > 0.01) {
                    settling = true;
                }
            });
            render();
            if (settling) requestAnimationFrame(settleAnimation);
        }

        function toggleFolding() {
            isFolding = !isFolding;
            if (isFolding && creases.length > 0) {
                animateFold();
            }
        }

        function animateFold() {
            if (!isFolding || creases.length === 0) return;
            
            currentFold = (currentFold + 0.03) % (Math.PI * 2);
            
            creases.forEach((crease, idx) => {
                const phase = currentFold + idx * 0.5;
                crease.foldAngle = Math.sin(phase) * Math.PI * 0.3;
                crease.memory = Math.min(crease.memory + 0.01, 10);
            });
            
            render();
            requestAnimationFrame(animateFold);
        }

        function clearPaper() {
            creases = [];
            creaseMemories = [];
            memoryDepth = 0;
            isDreaming = false;
            isFolding = false;
            document.getElementById('memoryDisplay').textContent = `Memory Depth: 0`;
            render();
        }

        document.getElementById('dreamBtn').addEventListener('click', dream);
        document.getElementById('clearBtn').addEventListener('click', clearPaper);
        document.getElementById('foldBtn').addEventListener('click', toggleFolding);

        initPaper();
        render();
    </script>
</body>
</html>