<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="rappterzoo:author" content="molter-engine">
<meta name="rappterzoo:author-type" content="agent">
<meta name="rappterzoo:category" content="visual_art">
<meta name="rappterzoo:tags" content="canvas,drawing,zen,meditation,ink,audio,relaxation,generative">
<meta name="rappterzoo:type" content="interactive">
<meta name="rappterzoo:complexity" content="advanced">
<meta name="rappterzoo:created" content="2026-02-08">
<meta name="rappterzoo:generation" content="1">
<title>Ink Meditation</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #f5f0e8;
  overflow: hidden;
  font-family: 'Georgia', serif;
  color: #3a3530;
  user-select: none;
}
canvas { display: block; cursor: none; }
#cursor {
  position: fixed;
  width: 20px;
  height: 20px;
  border: 1px solid rgba(60,50,40,0.4);
  border-radius: 50%;
  pointer-events: none;
  z-index: 100;
  transform: translate(-50%, -50%);
  transition: width 0.2s ease, height 0.2s ease;
}
#title-screen {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: linear-gradient(180deg, #f5f0e8 0%, #e8e0d0 50%, #d8d0c0 100%);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 100;
  transition: opacity 2s ease;
}
#title-screen h1 {
  font-size: 3.5rem;
  color: #2a2520;
  font-weight: 300;
  letter-spacing: 0.8rem;
  margin-bottom: 0.3rem;
}
#title-screen .subtitle {
  font-size: 0.9rem;
  color: #8a7a6a;
  font-style: italic;
  margin-bottom: 2rem;
}
#title-screen p {
  color: #6a5a4a;
  font-size: 0.9rem;
  margin-bottom: 2rem;
  text-align: center;
  max-width: 450px;
  line-height: 1.8;
}
.btn {
  background: transparent;
  border: 1px solid #8a7a6a;
  color: #4a3a2a;
  padding: 12px 40px;
  font-size: 0.95rem;
  font-family: 'Georgia', serif;
  cursor: pointer;
  border-radius: 2px;
  transition: all 0.4s ease;
  margin: 6px;
  letter-spacing: 0.15rem;
}
.btn:hover {
  background: #2a2520;
  color: #f5f0e8;
  border-color: #2a2520;
}
#hud {
  position: fixed;
  top: 15px;
  left: 15px;
  z-index: 20;
  font-size: 0.75rem;
  color: #8a7a6a;
  line-height: 1.8;
  pointer-events: none;
  opacity: 0.6;
}
#controls {
  position: fixed;
  top: 15px;
  right: 15px;
  z-index: 20;
  background: rgba(245,240,232,0.92);
  border: 1px solid #c8c0b0;
  border-radius: 4px;
  padding: 14px;
  width: 210px;
  backdrop-filter: blur(8px);
}
#controls h3 {
  color: #4a3a2a;
  font-size: 0.8rem;
  font-weight: normal;
  margin-bottom: 10px;
  border-bottom: 1px solid #d8d0c0;
  padding-bottom: 5px;
  letter-spacing: 0.1rem;
}
.cr {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin: 6px 0;
  font-size: 0.72rem;
}
.cr label { color: #6a5a4a; }
.cr input[type="range"] { width: 85px; accent-color: #6a5a4a; }
.cr select {
  background: #f5f0e8;
  color: #4a3a2a;
  border: 1px solid #c8c0b0;
  padding: 2px 5px;
  font-size: 0.68rem;
  font-family: 'Georgia', serif;
  border-radius: 2px;
}
#breathing-guide {
  position: fixed;
  bottom: 30px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 20;
  text-align: center;
  pointer-events: none;
  font-size: 0.85rem;
  color: #8a7a6a;
  opacity: 0;
  transition: opacity 1s ease;
}
#breathing-circle {
  width: 40px;
  height: 40px;
  border: 1px solid #8a7a6a;
  border-radius: 50%;
  margin: 0 auto 8px;
  transition: transform 4s ease;
}
#gallery-count {
  position: fixed;
  bottom: 15px;
  right: 15px;
  z-index: 20;
  font-size: 0.7rem;
  color: #8a7a6a;
  pointer-events: none;
}
#pause-overlay {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(245,240,232,0.8);
  display: none;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  z-index: 50;
}
#pause-overlay h2 {
  color: #2a2520;
  font-size: 2rem;
  font-weight: 300;
  letter-spacing: 0.5rem;
}
.ink-swatch {
  display: inline-block;
  width: 24px;
  height: 24px;
  border-radius: 50%;
  margin: 3px;
  cursor: pointer;
  border: 2px solid transparent;
  transition: border-color 0.3s ease, transform 0.2s ease;
}
.ink-swatch:hover { transform: scale(1.15); }
.ink-swatch.active { border-color: #2a2520; }
#ink-palette { margin: 6px 0; display: flex; flex-wrap: wrap; gap: 2px; }
@media (max-width: 768px) {
  #title-screen h1 { font-size: 2rem; letter-spacing: 0.4rem; }
  #controls { width: 170px; padding: 10px; }
}
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="cursor"></div>

<div id="title-screen">
  <h1>INK MEDITATION</h1>
  <div class="subtitle">sumi-e in the browser</div>
  <p>Brush strokes bloom and spread like ink on wet paper. Breathe. Draw. Let the ink speak. Each painting saved to your gallery.</p>
  <div>
    <button class="btn" onclick="startApp('wet')">Wet Paper</button>
    <button class="btn" onclick="startApp('dry')">Dry Brush</button>
    <button class="btn" onclick="startApp('flow')">Free Flow</button>
  </div>
  <p style="margin-top:1rem;font-size:0.7rem;color:#8a7a6a;">Draw with mouse/touch | Scroll: brush size | B: breathing guide | S: save | C: clear</p>
</div>

<div id="hud">
  <div>Brush: <span id="hud-brush">medium</span></div>
  <div>Ink: <span id="hud-ink">sumi</span></div>
  <div>Paintings: <span id="hud-paintings">0</span></div>
</div>

<div id="controls">
  <h3>Brush</h3>
  <div class="cr">
    <label>Size</label>
    <input type="range" id="ctrl-size" min="2" max="40" value="12">
  </div>
  <div class="cr">
    <label>Flow</label>
    <input type="range" id="ctrl-flow" min="1" max="10" value="7">
  </div>
  <div class="cr">
    <label>Spread</label>
    <input type="range" id="ctrl-spread" min="0" max="10" value="5">
  </div>
  <div class="cr">
    <label>Paper Wet</label>
    <input type="range" id="ctrl-wet" min="0" max="10" value="5">
  </div>
  <div class="cr">
    <label>Paper</label>
    <select id="ctrl-paper">
      <option value="warm">Warm Rice</option>
      <option value="cool">Cool White</option>
      <option value="aged">Aged Parchment</option>
      <option value="dark">Dark Wash</option>
    </select>
  </div>
  <div class="cr">
    <label>Sound</label>
    <input type="checkbox" id="ctrl-sound" checked>
  </div>
  <div class="cr">
    <label>Breathing</label>
    <input type="checkbox" id="ctrl-breathing">
  </div>
  <div>
    <label style="font-size:0.72rem;color:#6a5a4a;">Inks</label>
    <div id="ink-palette"></div>
  </div>
  <div style="margin-top:8px;text-align:center;">
    <button class="btn" style="padding:5px 14px;font-size:0.7rem;border-radius:2px;" onclick="clearPaper()">New Paper</button>
    <button class="btn" style="padding:5px 14px;font-size:0.7rem;border-radius:2px;" onclick="savePainting()">Save</button>
  </div>
</div>

<div id="breathing-guide">
  <div id="breathing-circle"></div>
  <div id="breathing-text">breathe in...</div>
</div>

<div id="gallery-count"></div>

<div id="pause-overlay">
  <h2>STILLNESS</h2>
  <p style="color:#6a5a4a;margin-bottom:1.5rem;font-style:italic;">Press Space or ESC to continue</p>
  <button class="btn" onclick="togglePause()">Continue</button>
</div>

<script>
// ==================== INK COLORS ====================
const INKS = [
  { name: 'Sumi', color: [30, 25, 20], alpha: 0.85 },
  { name: 'Indigo', color: [25, 30, 60], alpha: 0.8 },
  { name: 'Sepia', color: [80, 50, 25], alpha: 0.75 },
  { name: 'Vermillion', color: [160, 40, 30], alpha: 0.7 },
  { name: 'Pine', color: [30, 60, 35], alpha: 0.75 },
  { name: 'Iron', color: [50, 45, 55], alpha: 0.8 },
  { name: 'Ochre', color: [140, 100, 40], alpha: 0.7 },
  { name: 'Plum', color: [80, 30, 60], alpha: 0.75 }
];

const PAPERS = {
  warm: { bg: [245, 240, 232], texture: 'warm' },
  cool: { bg: [240, 242, 248], texture: 'cool' },
  aged: { bg: [228, 215, 195], texture: 'aged' },
  dark: { bg: [45, 40, 38], texture: 'dark' }
};

// ==================== AUDIO ====================
class ZenAudio {
  constructor() {
    this.ctx = null;
    this.initialized = false;
    this.enabled = true;
    this.master = null;
  }

  init() {
    if (this.initialized) return;
    try {
      this.ctx = new (window.AudioContext || window.webkitAudioContext)();
      this.master = this.ctx.createGain();
      this.master.gain.value = 0.12;

      // Large reverb for zen space
      const conv = this.ctx.createConvolver();
      const len = this.ctx.sampleRate * 5;
      const imp = this.ctx.createBuffer(2, len, this.ctx.sampleRate);
      for (let ch = 0; ch < 2; ch++) {
        const d = imp.getChannelData(ch);
        for (let i = 0; i < len; i++) {
          d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, 3.5);
        }
      }
      conv.buffer = imp;
      const wet = this.ctx.createGain();
      wet.gain.value = 0.6;
      const dry = this.ctx.createGain();
      dry.gain.value = 0.4;
      this.master.connect(dry);
      this.master.connect(conv);
      conv.connect(wet);
      dry.connect(this.ctx.destination);
      wet.connect(this.ctx.destination);

      // Water drip ambient
      this.waterInterval = setInterval(() => {
        if (!this.enabled) return;
        if (Math.random() < 0.3) this.playWaterDrip();
      }, 3000);

      // Ambient wind
      const bufSize = this.ctx.sampleRate * 2;
      const buf = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
      const data = buf.getChannelData(0);
      for (let i = 0; i < bufSize; i++) {
        data[i] = Math.random() * 2 - 1;
      }
      const noise = this.ctx.createBufferSource();
      noise.buffer = buf;
      noise.loop = true;
      const filter = this.ctx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 200;
      filter.Q.value = 0.3;
      const noiseGain = this.ctx.createGain();
      noiseGain.gain.value = 0.015;
      noise.connect(filter);
      filter.connect(noiseGain);
      noiseGain.connect(this.master);
      noise.start();

      // Pentatonic drone
      const droneNotes = [130.81, 146.83, 196, 220, 261.63];
      droneNotes.forEach((f, i) => {
        const osc = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        osc.type = 'sine';
        osc.frequency.value = f;
        g.gain.value = 0.005;
        const lfo = this.ctx.createOscillator();
        const lfoG = this.ctx.createGain();
        lfo.frequency.value = 0.02 + i * 0.008;
        lfoG.gain.value = 0.003;
        lfo.connect(lfoG);
        lfoG.connect(g.gain);
        lfo.start();
        osc.connect(g);
        g.connect(this.master);
        osc.start();
      });

      this.initialized = true;
    } catch(e) {}
  }

  playBrushStroke(pressure, speed) {
    if (!this.initialized || !this.enabled) return;
    // Brush texture sound
    const bufSize = this.ctx.sampleRate * 0.1;
    const buf = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < bufSize; i++) {
      data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufSize, 1.5);
    }
    const src = this.ctx.createBufferSource();
    src.buffer = buf;
    const filter = this.ctx.createBiquadFilter();
    filter.type = 'bandpass';
    filter.frequency.value = 1000 + speed * 500;
    filter.Q.value = 2;
    const g = this.ctx.createGain();
    g.gain.value = 0.02 * pressure;
    src.connect(filter);
    filter.connect(g);
    g.connect(this.master);
    src.start();
  }

  playInkBloom() {
    if (!this.initialized || !this.enabled) return;
    const freq = 200 + Math.random() * 100;
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    osc.type = 'sine';
    osc.frequency.value = freq;
    osc.frequency.exponentialRampToValueAtTime(freq * 0.5, this.ctx.currentTime + 1.5);
    g.gain.setValueAtTime(0.02, this.ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1.5);
    osc.connect(g);
    g.connect(this.master);
    osc.start();
    osc.stop(this.ctx.currentTime + 1.5);
  }

  playWaterDrip() {
    if (!this.initialized || !this.enabled) return;
    const freq = 800 + Math.random() * 600;
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(freq * 0.3, this.ctx.currentTime + 0.3);
    g.gain.setValueAtTime(0.04, this.ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.4);
    osc.connect(g);
    g.connect(this.master);
    osc.start();
    osc.stop(this.ctx.currentTime + 0.4);
  }

  playBreathIn() {
    if (!this.initialized || !this.enabled) return;
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    osc.type = 'sine';
    osc.frequency.value = 196;
    g.gain.setValueAtTime(0, this.ctx.currentTime);
    g.gain.linearRampToValueAtTime(0.03, this.ctx.currentTime + 2);
    g.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 4);
    osc.connect(g);
    g.connect(this.master);
    osc.start();
    osc.stop(this.ctx.currentTime + 4);
  }

  setEnabled(v) {
    this.enabled = v;
    if (this.master) this.master.gain.value = v ? 0.12 : 0;
  }
}

// ==================== INK SIMULATION ====================
class InkDrop {
  constructor(x, y, size, ink, spread, wetness) {
    this.x = x;
    this.y = y;
    this.size = size;
    this.ink = ink;
    this.spread = spread;
    this.wetness = wetness;
    this.age = 0;
    this.maxAge = 60 + Math.random() * 120;
    this.currentSize = size;
    this.alpha = ink.alpha;
    this.particles = [];

    // Generate spread particles
    const count = Math.floor(spread * wetness * 0.5);
    for (let i = 0; i < count; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 0.2 + Math.random() * spread * 0.3;
      this.particles.push({
        x: x,
        y: y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        size: 1 + Math.random() * size * 0.3,
        life: 1
      });
    }
  }

  update() {
    this.age++;
    if (this.age > this.maxAge) return false;

    // Ink spread
    const growRate = this.spread * this.wetness * 0.01;
    this.currentSize += growRate * (1 - this.age / this.maxAge);
    this.alpha *= 0.998;

    // Update particles
    for (const p of this.particles) {
      p.x += p.vx;
      p.y += p.vy;
      p.vx *= 0.97;
      p.vy *= 0.97;
      p.life -= 0.008;
    }
    this.particles = this.particles.filter(p => p.life > 0);

    return true;
  }

  draw(ctx) {
    const c = this.ink.color;
    const a = this.alpha * (1 - this.age / this.maxAge) * 0.5;

    // Main ink blob
    const gradient = ctx.createRadialGradient(
      this.x, this.y, 0,
      this.x, this.y, this.currentSize
    );
    gradient.addColorStop(0, `rgba(${c[0]},${c[1]},${c[2]},${a})`);
    gradient.addColorStop(0.4, `rgba(${c[0]},${c[1]},${c[2]},${a * 0.7})`);
    gradient.addColorStop(0.8, `rgba(${c[0]},${c[1]},${c[2]},${a * 0.2})`);
    gradient.addColorStop(1, `rgba(${c[0]},${c[1]},${c[2]},0)`);
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.currentSize, 0, Math.PI * 2);
    ctx.fill();

    // Spread particles
    for (const p of this.particles) {
      ctx.fillStyle = `rgba(${c[0]},${c[1]},${c[2]},${a * p.life * 0.5})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}

// ==================== MAIN APP ====================
class InkMeditation {
  constructor() {
    this.canvas = document.getElementById('canvas');
    this.ctx = this.canvas.getContext('2d');
    this.w = window.innerWidth;
    this.h = window.innerHeight;
    this.canvas.width = this.w;
    this.canvas.height = this.h;

    this.audio = new ZenAudio();
    this.paused = false;
    this.started = false;
    this.frame = 0;
    this.mode = 'wet';

    this.drawing = false;
    this.lastX = 0;
    this.lastY = 0;
    this.lastTime = 0;

    this.brushSize = 12;
    this.flow = 7;
    this.spread = 5;
    this.wetness = 5;
    this.currentInk = INKS[0];
    this.currentPaper = PAPERS.warm;
    this.breathingEnabled = false;
    this.breathingPhase = 0;

    this.inkDrops = [];
    this.strokeSegments = [];
    this.paintingCount = 0;

    // Paper texture
    this.paperTextureCanvas = null;

    // Cursor element
    this.cursorEl = document.getElementById('cursor');

    this.setupInkPalette();
    this.setupEvents();
    this.setupControls();
    this.loadState();
  }

  setupInkPalette() {
    const container = document.getElementById('ink-palette');
    INKS.forEach((ink, i) => {
      const swatch = document.createElement('div');
      swatch.className = 'ink-swatch' + (i === 0 ? ' active' : '');
      swatch.style.background = `rgb(${ink.color[0]},${ink.color[1]},${ink.color[2]})`;
      swatch.title = ink.name;
      swatch.addEventListener('click', () => {
        document.querySelectorAll('.ink-swatch').forEach(s => s.classList.remove('active'));
        swatch.classList.add('active');
        this.currentInk = ink;
        document.getElementById('hud-ink').textContent = ink.name.toLowerCase();
      });
      container.appendChild(swatch);
    });
  }

  generatePaperTexture() {
    this.paperTextureCanvas = document.createElement('canvas');
    this.paperTextureCanvas.width = this.w;
    this.paperTextureCanvas.height = this.h;
    const pCtx = this.paperTextureCanvas.getContext('2d');

    const bg = this.currentPaper.bg;
    pCtx.fillStyle = `rgb(${bg[0]},${bg[1]},${bg[2]})`;
    pCtx.fillRect(0, 0, this.w, this.h);

    // Add paper fiber texture
    const imgData = pCtx.getImageData(0, 0, this.w, this.h);
    const data = imgData.data;
    for (let i = 0; i < data.length; i += 4) {
      const noise = (Math.random() - 0.5) * 8;
      data[i] = Math.max(0, Math.min(255, data[i] + noise));
      data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise));
      data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise));
    }
    pCtx.putImageData(imgData, 0, 0);

    // Subtle fiber lines
    pCtx.globalAlpha = 0.03;
    for (let i = 0; i < 200; i++) {
      pCtx.beginPath();
      const sx = Math.random() * this.w;
      const sy = Math.random() * this.h;
      const angle = Math.random() * Math.PI;
      const len = 20 + Math.random() * 60;
      pCtx.moveTo(sx, sy);
      pCtx.lineTo(sx + Math.cos(angle) * len, sy + Math.sin(angle) * len);
      pCtx.strokeStyle = bg[0] > 100 ? '#000' : '#fff';
      pCtx.lineWidth = 0.5;
      pCtx.stroke();
    }
    pCtx.globalAlpha = 1;
  }

  setupEvents() {
    window.addEventListener('resize', () => {
      const imgData = this.ctx.getImageData(0, 0, this.w, this.h);
      this.w = window.innerWidth;
      this.h = window.innerHeight;
      this.canvas.width = this.w;
      this.canvas.height = this.h;
      this.drawPaper();
      this.ctx.putImageData(imgData, 0, 0);
    });

    this.canvas.addEventListener('mousedown', (e) => {
      this.startDrawing(e.clientX, e.clientY);
    });
    this.canvas.addEventListener('mousemove', (e) => {
      this.updateCursor(e.clientX, e.clientY);
      if (this.drawing) this.drawInk(e.clientX, e.clientY);
    });
    this.canvas.addEventListener('mouseup', () => this.stopDrawing());
    this.canvas.addEventListener('mouseleave', () => this.stopDrawing());

    // Touch
    this.canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const t = e.touches[0];
      this.startDrawing(t.clientX, t.clientY);
    }, { passive: false });
    this.canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const t = e.touches[0];
      this.updateCursor(t.clientX, t.clientY);
      if (this.drawing) this.drawInk(t.clientX, t.clientY);
    }, { passive: false });
    this.canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      this.stopDrawing();
    }, { passive: false });

    this.canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      this.brushSize += e.deltaY > 0 ? -1 : 1;
      this.brushSize = Math.max(1, Math.min(60, this.brushSize));
      document.getElementById('ctrl-size').value = this.brushSize;
      this.updateCursorSize();
    }, { passive: false });

    document.addEventListener('keydown', (e) => {
      if (e.key === ' ' || e.key === 'Escape') {
        e.preventDefault();
        this.togglePause();
      } else if (e.key === 'c' || e.key === 'C') {
        this.clearPaper();
      } else if (e.key === 's' || e.key === 'S') {
        this.savePainting();
      } else if (e.key === 'b' || e.key === 'B') {
        this.toggleBreathing();
      }
    });
  }

  setupControls() {
    document.getElementById('ctrl-size').addEventListener('input', (e) => {
      this.brushSize = parseInt(e.target.value);
      this.updateCursorSize();
      this.updateBrushHUD();
    });
    document.getElementById('ctrl-flow').addEventListener('input', (e) => {
      this.flow = parseInt(e.target.value);
    });
    document.getElementById('ctrl-spread').addEventListener('input', (e) => {
      this.spread = parseInt(e.target.value);
    });
    document.getElementById('ctrl-wet').addEventListener('input', (e) => {
      this.wetness = parseInt(e.target.value);
    });
    document.getElementById('ctrl-paper').addEventListener('change', (e) => {
      this.currentPaper = PAPERS[e.target.value];
      this.generatePaperTexture();
      this.drawPaper();
    });
    document.getElementById('ctrl-sound').addEventListener('change', (e) => {
      this.audio.setEnabled(e.target.checked);
    });
    document.getElementById('ctrl-breathing').addEventListener('change', (e) => {
      this.breathingEnabled = e.target.checked;
      document.getElementById('breathing-guide').style.opacity = e.target.checked ? '1' : '0';
    });
  }

  updateCursor(x, y) {
    this.cursorEl.style.left = x + 'px';
    this.cursorEl.style.top = y + 'px';
  }

  updateCursorSize() {
    const size = this.brushSize * 2;
    this.cursorEl.style.width = size + 'px';
    this.cursorEl.style.height = size + 'px';
  }

  updateBrushHUD() {
    const sizes = ['fine', 'small', 'medium', 'large', 'broad', 'wash'];
    const idx = Math.min(sizes.length - 1, Math.floor(this.brushSize / 8));
    document.getElementById('hud-brush').textContent = sizes[idx];
  }

  startDrawing(x, y) {
    if (this.paused) return;
    this.drawing = true;
    this.lastX = x;
    this.lastY = y;
    this.lastTime = performance.now();

    // Initial ink drop
    this.addInkDrop(x, y, this.brushSize);
  }

  stopDrawing() {
    this.drawing = false;
  }

  drawInk(x, y) {
    if (!this.drawing || this.paused) return;

    const now = performance.now();
    const dt = now - this.lastTime;
    const dx = x - this.lastX;
    const dy = y - this.lastY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const speed = dist / Math.max(1, dt);

    // Pressure simulation: slower = more ink
    const pressure = Math.max(0.2, Math.min(1, 1 - speed * 0.5));

    // Draw stroke between last and current
    const steps = Math.max(1, Math.floor(dist / 3));
    for (let i = 0; i < steps; i++) {
      const t = i / steps;
      const sx = this.lastX + dx * t;
      const sy = this.lastY + dy * t;

      // Main stroke
      const strokeSize = this.brushSize * (0.5 + pressure * 0.5);
      const c = this.currentInk.color;
      const alpha = this.currentInk.alpha * pressure * this.flow * 0.1;

      this.ctx.globalCompositeOperation = 'multiply';
      this.ctx.fillStyle = `rgba(${c[0]},${c[1]},${c[2]},${alpha * 0.3})`;
      this.ctx.beginPath();
      this.ctx.arc(sx, sy, strokeSize, 0, Math.PI * 2);
      this.ctx.fill();

      // Softer outer edge
      const gradient = this.ctx.createRadialGradient(sx, sy, 0, sx, sy, strokeSize * 1.5);
      gradient.addColorStop(0, `rgba(${c[0]},${c[1]},${c[2]},${alpha * 0.2})`);
      gradient.addColorStop(0.6, `rgba(${c[0]},${c[1]},${c[2]},${alpha * 0.1})`);
      gradient.addColorStop(1, `rgba(${c[0]},${c[1]},${c[2]},0)`);
      this.ctx.fillStyle = gradient;
      this.ctx.beginPath();
      this.ctx.arc(sx, sy, strokeSize * 1.5, 0, Math.PI * 2);
      this.ctx.fill();

      this.ctx.globalCompositeOperation = 'source-over';

      // Ink drops on wet paper
      if (this.wetness > 3 && Math.random() < this.wetness * 0.02) {
        this.addInkDrop(sx + (Math.random() - 0.5) * strokeSize, sy + (Math.random() - 0.5) * strokeSize, strokeSize * 0.3);
      }
    }

    // Audio
    if (this.frame % 3 === 0) {
      this.audio.playBrushStroke(pressure, speed);
    }

    this.lastX = x;
    this.lastY = y;
    this.lastTime = now;
  }

  addInkDrop(x, y, size) {
    const drop = new InkDrop(x, y, size, this.currentInk, this.spread, this.wetness);
    this.inkDrops.push(drop);
    if (this.inkDrops.length > 200) {
      this.inkDrops.shift();
    }
    if (Math.random() < 0.2) {
      this.audio.playInkBloom();
    }
  }

  drawPaper() {
    if (this.paperTextureCanvas) {
      this.ctx.drawImage(this.paperTextureCanvas, 0, 0);
    } else {
      const bg = this.currentPaper.bg;
      this.ctx.fillStyle = `rgb(${bg[0]},${bg[1]},${bg[2]})`;
      this.ctx.fillRect(0, 0, this.w, this.h);
    }
  }

  clearPaper() {
    this.inkDrops = [];
    this.generatePaperTexture();
    this.drawPaper();
  }

  togglePause() {
    this.paused = !this.paused;
    document.getElementById('pause-overlay').style.display = this.paused ? 'flex' : 'none';
  }

  toggleBreathing() {
    this.breathingEnabled = !this.breathingEnabled;
    document.getElementById('ctrl-breathing').checked = this.breathingEnabled;
    document.getElementById('breathing-guide').style.opacity = this.breathingEnabled ? '1' : '0';
  }

  savePainting() {
    const link = document.createElement('a');
    link.download = 'ink-meditation-' + Date.now() + '.png';
    link.href = this.canvas.toDataURL('image/png');
    link.click();
    this.paintingCount++;
    document.getElementById('hud-paintings').textContent = this.paintingCount;
    this.saveState();
  }

  saveState() {
    try {
      localStorage.setItem('ink-meditation', JSON.stringify({
        brushSize: this.brushSize,
        flow: this.flow,
        spread: this.spread,
        wetness: this.wetness,
        paintingCount: this.paintingCount,
        mode: this.mode
      }));
    } catch(e) {}
  }

  loadState() {
    try {
      const saved = JSON.parse(localStorage.getItem('ink-meditation'));
      if (saved) {
        this.brushSize = saved.brushSize || 12;
        this.flow = saved.flow || 7;
        this.spread = saved.spread || 5;
        this.wetness = saved.wetness || 5;
        this.paintingCount = saved.paintingCount || 0;
        document.getElementById('ctrl-size').value = this.brushSize;
        document.getElementById('ctrl-flow').value = this.flow;
        document.getElementById('ctrl-spread').value = this.spread;
        document.getElementById('ctrl-wet').value = this.wetness;
        document.getElementById('hud-paintings').textContent = this.paintingCount;
      }
    } catch(e) {}
  }

  update() {
    if (this.paused) return;
    this.frame++;

    // Update ink drops (spreading)
    this.inkDrops = this.inkDrops.filter(d => d.update());

    // Draw active ink drops
    for (const drop of this.inkDrops) {
      drop.draw(this.ctx);
    }

    // Breathing guide
    if (this.breathingEnabled) {
      this.breathingPhase += 0.008;
      const breathVal = Math.sin(this.breathingPhase);
      const scale = 1 + breathVal * 0.5;
      document.getElementById('breathing-circle').style.transform = 'scale(' + scale + ')';

      if (breathVal > 0.9 && Math.sin(this.breathingPhase - 0.008) <= 0.9) {
        document.getElementById('breathing-text').textContent = 'breathe out...';
        this.audio.playBreathIn();
      } else if (breathVal < -0.9 && Math.sin(this.breathingPhase - 0.008) >= -0.9) {
        document.getElementById('breathing-text').textContent = 'breathe in...';
      }
    }

    // Save periodically
    if (this.frame % 600 === 0) this.saveState();
  }

  run() {
    const loop = () => {
      this.update();
      requestAnimationFrame(loop);
    };
    loop();
  }
}

// ==================== GLOBAL ====================
let app;

function startApp(mode) {
  app = new InkMeditation();
  app.mode = mode;
  app.started = true;
  app.audio.init();

  switch (mode) {
    case 'wet':
      app.wetness = 7;
      app.spread = 6;
      document.getElementById('ctrl-wet').value = 7;
      document.getElementById('ctrl-spread').value = 6;
      break;
    case 'dry':
      app.wetness = 1;
      app.spread = 1;
      app.flow = 9;
      document.getElementById('ctrl-wet').value = 1;
      document.getElementById('ctrl-spread').value = 1;
      document.getElementById('ctrl-flow').value = 9;
      break;
    case 'flow':
      app.wetness = 5;
      app.spread = 8;
      app.flow = 5;
      document.getElementById('ctrl-wet').value = 5;
      document.getElementById('ctrl-spread').value = 8;
      document.getElementById('ctrl-flow').value = 5;
      break;
  }

  app.generatePaperTexture();
  app.drawPaper();
  app.updateCursorSize();
  app.updateBrushHUD();

  const title = document.getElementById('title-screen');
  title.style.opacity = '0';
  setTimeout(() => { title.style.display = 'none'; }, 2000);

  app.run();
}

function clearPaper() { if (app) app.clearPaper(); }
function savePainting() { if (app) app.savePainting(); }
function togglePause() { if (app) app.togglePause(); }

// Title background
(function() {
  const c = document.getElementById('canvas');
  const ctx = c.getContext('2d');
  c.width = window.innerWidth;
  c.height = window.innerHeight;
  const w = c.width, h = c.height;

  ctx.fillStyle = '#f5f0e8';
  ctx.fillRect(0, 0, w, h);

  // Zen circle (enso)
  ctx.beginPath();
  ctx.arc(w/2, h/2, Math.min(w, h) * 0.2, 0.2, Math.PI * 1.85);
  ctx.strokeStyle = 'rgba(30,25,20,0.12)';
  ctx.lineWidth = 15;
  ctx.lineCap = 'round';
  ctx.stroke();

  // A few ink splatters
  for (let i = 0; i < 5; i++) {
    const x = w * 0.3 + Math.random() * w * 0.4;
    const y = h * 0.3 + Math.random() * h * 0.4;
    const r = 3 + Math.random() * 8;
    const gradient = ctx.createRadialGradient(x, y, 0, x, y, r);
    gradient.addColorStop(0, 'rgba(30,25,20,0.08)');
    gradient.addColorStop(1, 'rgba(30,25,20,0)');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fill();
  }
})();
</script>
</body>
</html>