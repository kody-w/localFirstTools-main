<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Procedural Spider IK</title>
    <style>
        body { margin: 0; overflow: hidden; background: #111; color: #aaa; font-family: sans-serif; }
        #ui { position: absolute; top: 10px; left: 10px; pointer-events: none; }
        #controls { position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; }
        button { background: #333; color: #fff; border: 1px solid #555; padding: 5px 10px; cursor: pointer; }
        button:hover { background: #444; }
        canvas { display: block; }
    </style>
    <!-- Three.js -->
    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <!-- OrbitControls -->
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div id="ui">
        <h2>Procedural Spider IK</h2>
        <p>Drag the spider body to move.<br>Click 'Edit Terrain' to draw obstacles.</p>
    </div>
    <div id="controls">
        <button id="btn-mode" onclick="toggleMode()">Mode: Move Spider</button>
        <button onclick="resetTerrain()">Reset Terrain</button>
    </div>

    <script>
        // --- Configuration ---
        const LEG_COUNT = 8;
        const BODY_RADIUS = 1.5;
        const LEG_SEGMENT_LENGTH = 2.5;
        const STEP_HEIGHT = 1.5;
        const STEP_SPEED = 0.2;
        
        // --- Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        scene.fog = new THREE.Fog(0x111111, 20, 60);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 15, 15);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.camera.top = 20;
        dirLight.shadow.camera.bottom = -20;
        dirLight.shadow.camera.left = -20;
        dirLight.shadow.camera.right = 20;
        scene.add(dirLight);

        // Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // --- Terrain System ---
        const terrainGroup = new THREE.Group();
        scene.add(terrainGroup);
        
        // Base Plane
        const planeGeo = new THREE.PlaneGeometry(100, 100, 50, 50);
        const planeMat = new THREE.MeshStandardMaterial({ color: 0x222222, wireframe: false });
        const plane = new THREE.Mesh(planeGeo, planeMat);
        plane.rotation.x = -Math.PI / 2;
        plane.receiveShadow = true;
        terrainGroup.add(plane);

        // Obstacles
        const obstacles = [];
        
        function addObstacle(x, z) {
            const height = 1 + Math.random() * 2;
            const geo = new THREE.BoxGeometry(2, height, 2);
            const mat = new THREE.MeshStandardMaterial({ color: 0x444444 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, height/2, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            terrainGroup.add(mesh);
            obstacles.push(mesh);
        }

        function getTerrainHeight(x, z) {
            // Raycast down to find height
            const raycaster = new THREE.Raycaster();
            raycaster.set(new THREE.Vector3(x, 20, z), new THREE.Vector3(0, -1, 0));
            const intersects = raycaster.intersectObjects(terrainGroup.children);
            if (intersects.length > 0) {
                return intersects[0].point.y;
            }
            return 0;
        }

        // --- Spider System ---
        const spiderGroup = new THREE.Group();
        scene.add(spiderGroup);

        // Body
        const bodyGeo = new THREE.SphereGeometry(BODY_RADIUS, 16, 16);
        const bodyMat = new THREE.MeshStandardMaterial({ color: 0xaa0000 });
        const bodyMesh = new THREE.Mesh(bodyGeo, bodyMat);
        bodyMesh.position.y = 4; // Hover height
        bodyMesh.castShadow = true;
        spiderGroup.add(bodyMesh);

        // Legs
        const legs = [];
        
        class Leg {
            constructor(index, total) {
                this.index = index;
                this.angle = (index / total) * Math.PI * 2;
                
                // IK Chain
                this.joint1 = new THREE.Group(); // Hip
                this.joint2 = new THREE.Group(); // Knee
                this.foot = new THREE.Group();   // Foot
                
                // Visuals
                const legMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
                const jointGeo = new THREE.SphereGeometry(0.3, 8, 8);
                const boneGeo = new THREE.CylinderGeometry(0.1, 0.1, LEG_SEGMENT_LENGTH, 8);
                boneGeo.translate(0, LEG_SEGMENT_LENGTH/2, 0);
                boneGeo.rotateX(Math.PI/2); // Point along Z

                this.mesh1 = new THREE.Mesh(boneGeo, legMat);
                this.mesh2 = new THREE.Mesh(boneGeo, legMat);
                
                // Hierarchy
                spiderGroup.add(this.joint1);
                this.joint1.add(this.mesh1);
                this.mesh1.add(this.joint2);
                this.joint2.add(this.mesh2);
                this.mesh2.add(this.foot);

                // State
                this.targetPos = new THREE.Vector3(); // Where we want to be
                this.currentPos = new THREE.Vector3(); // Where we actually are (animated)
                this.restPos = new THREE.Vector3(); // Ideal rest position relative to body
                
                // Animation
                this.isStepping = false;
                this.stepProgress = 0;
                this.stepStartPos = new THREE.Vector3();
                this.stepEndPos = new THREE.Vector3();

                // Init
                this.updateRestPos(bodyMesh.position);
                this.currentPos.copy(this.restPos);
                this.currentPos.y = getTerrainHeight(this.restPos.x, this.restPos.z);
            }

            updateRestPos(bodyPos) {
                // Calculate ideal foot position based on body position
                const reach = 4;
                this.restPos.set(
                    bodyPos.x + Math.cos(this.angle) * reach,
                    0,
                    bodyPos.z + Math.sin(this.angle) * reach
                );
            }

            solveIK(target) {
                // Simple 2-bone IK
                // Hip position (attached to body)
                const hipPos = bodyMesh.position.clone();
                hipPos.x += Math.cos(this.angle) * BODY_RADIUS * 0.8;
                hipPos.z += Math.sin(this.angle) * BODY_RADIUS * 0.8;
                
                this.joint1.position.copy(hipPos);

                // Vector from Hip to Target
                const toTarget = target.clone().sub(hipPos);
                const dist = toTarget.length();
                
                // Clamp distance
                const maxReach = LEG_SEGMENT_LENGTH * 1.99;
                if (dist > maxReach) {
                    toTarget.normalize().multiplyScalar(maxReach);
                }

                // Calculate angles (Law of Cosines)
                const a = LEG_SEGMENT_LENGTH;
                const b = LEG_SEGMENT_LENGTH;
                const c = dist;
                
                // Angle at Hip (relative to target vector)
                const angleHip = Math.acos((a*a + c*c - b*b) / (2*a*c));
                // Angle at Knee
                const angleKnee = Math.acos((a*a + b*b - c*c) / (2*a*b));

                // Orient Hip towards target
                this.joint1.lookAt(target);
                
                // Apply IK rotations
                // Rotate Hip up/down
                this.joint1.rotateX(-angleHip);
                // Rotate Knee
                this.joint2.position.set(0, 0, LEG_SEGMENT_LENGTH); // End of bone 1
                this.joint2.rotation.x = Math.PI - angleKnee;
            }

            update(dt) {
                // Check if we need to step
                const distToRest = this.currentPos.distanceTo(this.restPos);
                
                // Only step if far away AND not already stepping AND opposite legs aren't stepping
                // (Simple gait: only allow step if neighbors are grounded)
                if (!this.isStepping && distToRest > 2.5) {
                    // Check neighbors (simplified)
                    // In a real gait controller we'd check specific pairs
                    if (Math.random() > 0.5) { // Random stagger for organic feel
                        this.startStep();
                    }
                }

                if (this.isStepping) {
                    this.stepProgress += dt * 3; // Speed
                    if (this.stepProgress >= 1) {
                        this.stepProgress = 1;
                        this.isStepping = false;
                    }

                    // Interpolate (Parabolic arc)
                    const t = this.stepProgress;
                    this.currentPos.lerpVectors(this.stepStartPos, this.stepEndPos, t);
                    this.currentPos.y += Math.sin(t * Math.PI) * STEP_HEIGHT;
                } else {
                    // Stick to ground
                    this.currentPos.y = getTerrainHeight(this.currentPos.x, this.currentPos.z);
                }

                this.solveIK(this.currentPos);
            }

            startStep() {
                this.isStepping = true;
                this.stepProgress = 0;
                this.stepStartPos.copy(this.currentPos);
                
                // Predict future position based on body velocity?
                // For now just step to rest pos
                this.stepEndPos.copy(this.restPos);
                
                // Add some overshoot/randomness
                this.stepEndPos.x += (Math.random()-0.5) * 0.5;
                this.stepEndPos.z += (Math.random()-0.5) * 0.5;
                
                // Check terrain height at target
                this.stepEndPos.y = getTerrainHeight(this.stepEndPos.x, this.stepEndPos.z);
            }
        }

        // Create Legs
        for(let i=0; i<LEG_COUNT; i++) {
            legs.push(new Leg(i, LEG_COUNT));
        }


        // --- Interaction ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -4); // Plane at y=4
        let isDragging = false;
        let editMode = false; // false = move spider, true = edit terrain

        window.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            if (isDragging && !editMode) {
                raycaster.setFromCamera(mouse, camera);
                const target = new THREE.Vector3();
                raycaster.ray.intersectPlane(dragPlane, target);
                if (target) {
                    bodyMesh.position.x = target.x;
                    bodyMesh.position.z = target.z;
                }
            }
        });

        window.addEventListener('mousedown', (e) => {
            if (editMode) {
                // Add Obstacle
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(plane);
                if (intersects.length > 0) {
                    addObstacle(intersects[0].point.x, intersects[0].point.z);
                }
            } else {
                // Start Drag
                isDragging = true;
                controls.enabled = false;
            }
        });

        window.addEventListener('mouseup', () => {
            isDragging = false;
            controls.enabled = true;
        });

        // --- UI Logic ---
        function toggleMode() {
            editMode = !editMode;
            const btn = document.getElementById('btn-mode');
            btn.innerText = editMode ? "Mode: Edit Terrain" : "Mode: Move Spider";
            btn.style.background = editMode ? "#522" : "#333";
        }

        function resetTerrain() {
            obstacles.forEach(o => terrainGroup.remove(o));
            obstacles.length = 0;
        }

        // --- Main Loop ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            
            const dt = clock.getDelta();

            // Update Legs
            legs.forEach(leg => {
                leg.updateRestPos(bodyMesh.position);
                leg.update(dt);
            });

            // Body bobbing (breathing)
            bodyMesh.position.y = 4 + Math.sin(clock.elapsedTime * 2) * 0.1;

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>