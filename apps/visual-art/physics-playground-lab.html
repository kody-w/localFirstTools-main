<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physics Playground Laboratory</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            color: #fff;
        }

        .header {
            background: rgba(0, 0, 0, 0.3);
            padding: 1rem 2rem;
            backdrop-filter: blur(10px);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .header h1 {
            font-size: 1.8rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .header .controls {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .btn {
            padding: 0.5rem 1rem;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9rem;
            backdrop-filter: blur(5px);
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .btn.active {
            background: rgba(255, 255, 255, 0.4);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .main-container {
            flex: 1;
            display: flex;
            padding: 1rem;
            gap: 1rem;
            max-width: 1600px;
            margin: 0 auto;
            width: 100%;
        }

        .sidebar {
            width: 300px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 1rem;
            padding: 1rem;
            backdrop-filter: blur(10px);
            overflow-y: auto;
            max-height: calc(100vh - 120px);
        }

        .experiment-selector {
            margin-bottom: 1.5rem;
        }

        .experiment-selector h3 {
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
        }

        .experiment-btn {
            width: 100%;
            padding: 0.8rem;
            margin-bottom: 0.5rem;
            text-align: left;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.3s;
        }

        .experiment-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateX(5px);
        }

        .experiment-btn.active {
            background: rgba(255, 255, 255, 0.3);
            border-color: #ffd700;
        }

        .controls-panel {
            margin-top: 2rem;
        }

        .control-group {
            margin-bottom: 1.5rem;
        }

        .control-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #ffd700;
            cursor: pointer;
        }

        .control-group .value-display {
            text-align: right;
            font-size: 0.9rem;
            color: #ffd700;
            margin-top: 0.25rem;
        }

        .canvas-container {
            flex: 1;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 1rem;
            padding: 1rem;
            backdrop-filter: blur(10px);
            position: relative;
            display: flex;
            flex-direction: column;
        }

        #physicsCanvas {
            flex: 1;
            background: linear-gradient(180deg, #0a0e27 0%, #151b3d 100%);
            border-radius: 0.5rem;
            cursor: crosshair;
            width: 100%;
            height: 100%;
            min-height: 500px;
        }

        .info-panel {
            width: 300px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 1rem;
            padding: 1rem;
            backdrop-filter: blur(10px);
            overflow-y: auto;
            max-height: calc(100vh - 120px);
        }

        .stats {
            margin-bottom: 1.5rem;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-label {
            opacity: 0.8;
            font-size: 0.9rem;
        }

        .stat-value {
            font-weight: bold;
            color: #ffd700;
        }

        .tutorial-box {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 0.5rem;
            padding: 1rem;
            margin-top: 1.5rem;
        }

        .tutorial-box h4 {
            margin-bottom: 0.5rem;
            color: #ffd700;
        }

        .tutorial-box p {
            font-size: 0.9rem;
            line-height: 1.4;
            opacity: 0.9;
        }

        .toolbar {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .tool-btn {
            padding: 0.4rem 0.8rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            border-radius: 0.3rem;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        .tool-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .tool-btn.active {
            background: rgba(255, 215, 0, 0.3);
            border-color: #ffd700;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 1rem;
            padding: 2rem;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }

        .close-modal {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
        }

        .challenge-card {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .challenge-card h3 {
            color: #ffd700;
            margin-bottom: 0.5rem;
        }

        .challenge-card p {
            font-size: 0.9rem;
            margin-bottom: 1rem;
        }

        .challenge-card .btn {
            width: 100%;
        }

        @media (max-width: 1200px) {
            .main-container {
                flex-direction: column;
            }
            
            .sidebar, .info-panel {
                width: 100%;
                max-height: 300px;
            }
        }

        .fps-counter {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(0, 0, 0, 0.5);
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.8rem;
            font-family: monospace;
            color: #0f0;
        }

        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            transition: opacity 0.5s;
        }

        .loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loader {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #ffd700;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 1rem;
            font-size: 1.2rem;
            opacity: 0.9;
        }
    </style>
</head>
<body>
    <div class="loading-screen" id="loadingScreen">
        <div class="loader"></div>
        <div class="loading-text">Initializing Physics Engine...</div>
    </div>

    <div class="header">
        <h1>‚öõÔ∏è Physics Playground Laboratory</h1>
        <div class="controls">
            <button class="btn" onclick="app.togglePause()">‚è∏Ô∏è Pause</button>
            <button class="btn" onclick="app.reset()">üîÑ Reset</button>
            <button class="btn" onclick="app.showChallenges()">üèÜ Challenges</button>
            <button class="btn" onclick="app.exportData()">üíæ Export</button>
            <button class="btn" onclick="app.importData()">üìÅ Import</button>
        </div>
    </div>

    <div class="main-container">
        <div class="sidebar">
            <div class="experiment-selector">
                <h3>üß™ Experiments</h3>
                <button class="experiment-btn active" onclick="app.selectExperiment('gravity', this)">
                    üåç Gravity & Orbits
                </button>
                <button class="experiment-btn" onclick="app.selectExperiment('pendulum', this)">
                    üïê Pendulum Waves
                </button>
                <button class="experiment-btn" onclick="app.selectExperiment('collision', this)">
                    üí• Collision Dynamics
                </button>
                <button class="experiment-btn" onclick="app.selectExperiment('waves', this)">
                    üåä Wave Interference
                </button>
                <button class="experiment-btn" onclick="app.selectExperiment('springs', this)">
                    üåÄ Springs & Oscillators
                </button>
                <button class="experiment-btn" onclick="app.selectExperiment('fluid', this)">
                    üíß Fluid Dynamics
                </button>
                <button class="experiment-btn" onclick="app.selectExperiment('electro', this)">
                    ‚ö° Electromagnetic Fields
                </button>
                <button class="experiment-btn" onclick="app.selectExperiment('quantum', this)">
                    üîÆ Quantum Particles
                </button>
            </div>

            <div class="controls-panel">
                <div class="control-group">
                    <label for="gravitySlider">Gravity Strength</label>
                    <input type="range" id="gravitySlider" min="0" max="200" value="100">
                    <div class="value-display" id="gravityValue">100</div>
                </div>

                <div class="control-group">
                    <label for="frictionSlider">Friction</label>
                    <input type="range" id="frictionSlider" min="0" max="100" value="10">
                    <div class="value-display" id="frictionValue">10</div>
                </div>

                <div class="control-group">
                    <label for="timeSlider">Time Scale</label>
                    <input type="range" id="timeSlider" min="10" max="200" value="100">
                    <div class="value-display" id="timeValue">100%</div>
                </div>

                <div class="control-group">
                    <label for="particleCount">Particle Count</label>
                    <input type="range" id="particleCount" min="1" max="100" value="10">
                    <div class="value-display" id="particleValue">10</div>
                </div>
            </div>
        </div>

        <div class="canvas-container">
            <div class="toolbar">
                <button class="tool-btn active" onclick="app.selectTool('pointer')">üëÜ Select</button>
                <button class="tool-btn" onclick="app.selectTool('create')">‚ûï Create</button>
                <button class="tool-btn" onclick="app.selectTool('force')">üí® Apply Force</button>
                <button class="tool-btn" onclick="app.selectTool('measure')">üìè Measure</button>
                <button class="tool-btn" onclick="app.selectTool('trace')">‚úèÔ∏è Trace Path</button>
                <button class="tool-btn" onclick="app.clearCanvas()">üóëÔ∏è Clear</button>
            </div>
            <canvas id="physicsCanvas"></canvas>
            <div class="fps-counter" id="fpsCounter">60 FPS</div>
        </div>

        <div class="info-panel">
            <div class="stats">
                <h3>üìä Statistics</h3>
                <div class="stat-item">
                    <span class="stat-label">Objects</span>
                    <span class="stat-value" id="objectCount">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Total Energy</span>
                    <span class="stat-value" id="totalEnergy">0 J</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Total Momentum</span>
                    <span class="stat-value" id="totalMomentum">0 kg¬∑m/s</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Simulation Time</span>
                    <span class="stat-value" id="simTime">0.0 s</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Frame Time</span>
                    <span class="stat-value" id="frameTime">16 ms</span>
                </div>
            </div>

            <div class="tutorial-box">
                <h4>üí° Current Experiment</h4>
                <p id="tutorialText">
                    Explore gravity and orbital mechanics! Click to create objects, drag to set velocity. 
                    Try creating a stable orbit or a multi-body system.
                </p>
            </div>

            <div class="tutorial-box" style="margin-top: 1rem;">
                <h4>üéØ Quick Tips</h4>
                <ul style="font-size: 0.85rem; opacity: 0.9; padding-left: 1.2rem;">
                    <li>Click and drag to launch objects with velocity</li>
                    <li>Hold Shift for precise placement</li>
                    <li>Scroll to zoom in/out</li>
                    <li>Right-click to delete objects</li>
                    <li>Press Space to pause/resume</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="modal" id="challengeModal">
        <div class="modal-content">
            <button class="close-modal" onclick="app.closeChallenges()">√ó</button>
            <h2>üèÜ Physics Challenges</h2>
            <div id="challengesList"></div>
        </div>
    </div>

    <input type="file" id="importInput" style="display: none;" accept=".json">

    <script>
        // WASM Module placeholder - using JS fallback for now
        const WASM_BASE64 = null;

        class PhysicsEngine {
            constructor() {
                this.objects = [];
                this.forces = [];
                this.constraints = [];
                this.time = 0;
                this.paused = false;
                this.gravity = { x: 0, y: 9.8 };
                this.friction = 0.01;
                this.timeScale = 1.0;
                this.wasmModule = null;
                this.wasmInstance = null;
            }

            async init() {
                // Skip WASM for now, use JS implementation
                console.log("Using JavaScript physics engine");
            }

            addObject(obj) {
                this.objects.push({
                    id: Date.now() + Math.random(),
                    x: obj.x || 0,
                    y: obj.y || 0,
                    vx: obj.vx || 0,
                    vy: obj.vy || 0,
                    mass: obj.mass || 1,
                    radius: obj.radius || 10,
                    color: obj.color || '#ffd700',
                    trail: [],
                    maxTrailLength: 50,
                    ...obj
                });
            }

            update(dt) {
                if (this.paused) return;

                const scaledDt = dt * this.timeScale;
                this.time += scaledDt;

                // Update physics for each object
                for (let obj of this.objects) {
                    // Apply gravity
                    obj.vy += this.gravity.y * scaledDt;
                    obj.vx += this.gravity.x * scaledDt;

                    // Apply friction
                    obj.vx *= (1 - this.friction * scaledDt);
                    obj.vy *= (1 - this.friction * scaledDt);

                    // Update position
                    obj.x += obj.vx * scaledDt;
                    obj.y += obj.vy * scaledDt;

                    // Update trail
                    if (obj.trail.length > 0 && 
                        Math.abs(obj.x - obj.trail[obj.trail.length - 1].x) > 2 ||
                        Math.abs(obj.y - obj.trail[obj.trail.length - 1].y) > 2) {
                        obj.trail.push({ x: obj.x, y: obj.y });
                        if (obj.trail.length > obj.maxTrailLength) {
                            obj.trail.shift();
                        }
                    } else if (obj.trail.length === 0) {
                        obj.trail.push({ x: obj.x, y: obj.y });
                    }
                }

                // Handle collisions
                this.handleCollisions();
            }

            handleCollisions() {
                for (let i = 0; i < this.objects.length; i++) {
                    for (let j = i + 1; j < this.objects.length; j++) {
                        const obj1 = this.objects[i];
                        const obj2 = this.objects[j];

                        const dx = obj2.x - obj1.x;
                        const dy = obj2.y - obj1.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const minDistance = obj1.radius + obj2.radius;

                        if (distance < minDistance) {
                            // Collision detected
                            const nx = dx / distance;
                            const ny = dy / distance;

                            // Separate objects
                            const overlap = minDistance - distance;
                            obj1.x -= nx * overlap * 0.5;
                            obj1.y -= ny * overlap * 0.5;
                            obj2.x += nx * overlap * 0.5;
                            obj2.y += ny * overlap * 0.5;

                            // Calculate relative velocity
                            const dvx = obj2.vx - obj1.vx;
                            const dvy = obj2.vy - obj1.vy;
                            const dvn = dvx * nx + dvy * ny;

                            // Don't resolve if velocities are separating
                            if (dvn > 0) continue;

                            // Calculate impulse
                            const restitution = 0.8;
                            const impulse = 2 * dvn / (1/obj1.mass + 1/obj2.mass);

                            // Apply impulse
                            obj1.vx -= impulse * nx / obj1.mass * restitution;
                            obj1.vy -= impulse * ny / obj1.mass * restitution;
                            obj2.vx += impulse * nx / obj2.mass * restitution;
                            obj2.vy += impulse * ny / obj2.mass * restitution;
                        }
                    }
                }
            }

            getTotalEnergy() {
                let energy = 0;
                for (let obj of this.objects) {
                    // Kinetic energy
                    energy += 0.5 * obj.mass * (obj.vx * obj.vx + obj.vy * obj.vy);
                    // Potential energy
                    energy += obj.mass * Math.abs(this.gravity.y) * obj.y;
                }
                return energy;
            }

            getTotalMomentum() {
                let px = 0, py = 0;
                for (let obj of this.objects) {
                    px += obj.mass * obj.vx;
                    py += obj.mass * obj.vy;
                }
                return Math.sqrt(px * px + py * py);
            }

            clear() {
                this.objects = [];
                this.forces = [];
                this.constraints = [];
                this.time = 0;
            }
        }

        class PhysicsApp {
            constructor() {
                this.canvas = document.getElementById('physicsCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.engine = new PhysicsEngine();
                this.currentExperiment = 'gravity';
                this.currentTool = 'pointer';
                this.mouseDown = false;
                this.mouseStart = null;
                this.mousePos = { x: 0, y: 0 };
                this.selectedObject = null;
                this.camera = { x: 0, y: 0, zoom: 1 };
                this.fps = 60;
                this.lastTime = 0;
                this.frameCount = 0;
                this.fpsUpdateTime = 0;
                
                this.experiments = {
                    gravity: this.setupGravityExperiment.bind(this),
                    pendulum: this.setupPendulumExperiment.bind(this),
                    collision: this.setupCollisionExperiment.bind(this),
                    waves: this.setupWaveExperiment.bind(this),
                    springs: this.setupSpringExperiment.bind(this),
                    fluid: this.setupFluidExperiment.bind(this),
                    electro: this.setupElectroExperiment.bind(this),
                    quantum: this.setupQuantumExperiment.bind(this)
                };

                this.challenges = [
                    {
                        title: "Stable Orbit",
                        description: "Create a stable circular orbit around a central mass.",
                        check: () => this.checkStableOrbit()
                    },
                    {
                        title: "Three Body Problem",
                        description: "Create a stable three-body system.",
                        check: () => this.checkThreeBody()
                    },
                    {
                        title: "Energy Conservation",
                        description: "Create a system where total energy remains constant (¬±5%).",
                        check: () => this.checkEnergyConservation()
                    },
                    {
                        title: "Elastic Collision",
                        description: "Demonstrate a perfectly elastic collision between two objects.",
                        check: () => this.checkElasticCollision()
                    },
                    {
                        title: "Resonance",
                        description: "Create a resonant system with maximum amplitude.",
                        check: () => this.checkResonance()
                    }
                ];

                this.init();
            }

            async init() {
                await this.engine.init();
                this.setupCanvas();
                this.setupEventListeners();
                this.setupControls();
                this.selectExperiment('gravity');
                this.animate();
                
                // Hide loading screen
                setTimeout(() => {
                    document.getElementById('loadingScreen').classList.add('hidden');
                }, 1000);
            }

            setupCanvas() {
                const resizeCanvas = () => {
                    const container = this.canvas.parentElement;
                    this.canvas.width = container.clientWidth - 32;
                    this.canvas.height = container.clientHeight - 100;
                };
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
            }

            setupEventListeners() {
                this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
                this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
                this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
                this.canvas.addEventListener('wheel', this.handleWheel.bind(this));
                this.canvas.addEventListener('contextmenu', e => e.preventDefault());
                
                document.addEventListener('keydown', this.handleKeyDown.bind(this));
            }

            setupControls() {
                const gravitySlider = document.getElementById('gravitySlider');
                const frictionSlider = document.getElementById('frictionSlider');
                const timeSlider = document.getElementById('timeSlider');
                const particleCount = document.getElementById('particleCount');

                gravitySlider.addEventListener('input', (e) => {
                    const value = e.target.value / 10;
                    this.engine.gravity.y = value;
                    document.getElementById('gravityValue').textContent = value.toFixed(1);
                });

                frictionSlider.addEventListener('input', (e) => {
                    const value = e.target.value / 100;
                    this.engine.friction = value;
                    document.getElementById('frictionValue').textContent = e.target.value;
                });

                timeSlider.addEventListener('input', (e) => {
                    const value = e.target.value / 100;
                    this.engine.timeScale = value;
                    document.getElementById('timeValue').textContent = e.target.value + '%';
                });

                particleCount.addEventListener('input', (e) => {
                    document.getElementById('particleValue').textContent = e.target.value;
                });

                document.getElementById('importInput').addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            try {
                                const data = JSON.parse(event.target.result);
                                this.loadData(data);
                            } catch (error) {
                                alert('Invalid file format');
                            }
                        };
                        reader.readAsText(file);
                    }
                });
            }

            handleMouseDown(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                this.mouseDown = true;
                this.mouseStart = { x, y };
                this.mousePos = { x, y };

                if (e.button === 2) {
                    // Right click - delete object
                    this.deleteObjectAt(x, y);
                } else if (this.currentTool === 'create') {
                    // Will create on mouse up with velocity
                } else if (this.currentTool === 'pointer') {
                    this.selectObjectAt(x, y);
                }
            }

            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                this.mousePos = { x, y };

                if (this.mouseDown && this.selectedObject && this.currentTool === 'pointer') {
                    this.selectedObject.x = x;
                    this.selectedObject.y = y;
                    this.selectedObject.vx = 0;
                    this.selectedObject.vy = 0;
                }
            }

            handleMouseUp(e) {
                if (this.mouseDown && this.currentTool === 'create' && this.mouseStart) {
                    const dx = this.mousePos.x - this.mouseStart.x;
                    const dy = this.mousePos.y - this.mouseStart.y;
                    
                    const particleCount = parseInt(document.getElementById('particleCount').value);
                    for (let i = 0; i < particleCount; i++) {
                        const angle = (Math.PI * 2 * i) / particleCount;
                        const spread = 20;
                        this.engine.addObject({
                            x: this.mouseStart.x + Math.cos(angle) * spread,
                            y: this.mouseStart.y + Math.sin(angle) * spread,
                            vx: dx * 0.5 + Math.cos(angle) * 10,
                            vy: dy * 0.5 + Math.sin(angle) * 10,
                            mass: 1 + Math.random() * 2,
                            radius: 5 + Math.random() * 10,
                            color: `hsl(${Math.random() * 360}, 70%, 60%)`
                        });
                    }
                }
                
                this.mouseDown = false;
                this.mouseStart = null;
                this.selectedObject = null;
            }

            handleWheel(e) {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                this.camera.zoom *= delta;
                this.camera.zoom = Math.max(0.1, Math.min(5, this.camera.zoom));
            }

            handleKeyDown(e) {
                if (e.code === 'Space') {
                    e.preventDefault();
                    this.togglePause();
                }
            }

            selectObjectAt(x, y) {
                for (let obj of this.engine.objects) {
                    const dx = obj.x - x;
                    const dy = obj.y - y;
                    if (Math.sqrt(dx * dx + dy * dy) < obj.radius) {
                        this.selectedObject = obj;
                        return;
                    }
                }
            }

            deleteObjectAt(x, y) {
                for (let i = 0; i < this.engine.objects.length; i++) {
                    const obj = this.engine.objects[i];
                    const dx = obj.x - x;
                    const dy = obj.y - y;
                    if (Math.sqrt(dx * dx + dy * dy) < obj.radius) {
                        this.engine.objects.splice(i, 1);
                        return;
                    }
                }
            }

            selectExperiment(name, buttonElement) {
                this.currentExperiment = name;
                this.engine.clear();
                
                // Update UI
                document.querySelectorAll('.experiment-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                if (buttonElement) {
                    buttonElement.classList.add('active');
                } else {
                    // Find button by experiment name as fallback
                    const btn = Array.from(document.querySelectorAll('.experiment-btn')).find(
                        b => b.textContent.toLowerCase().includes(name.toLowerCase())
                    );
                    if (btn) btn.classList.add('active');
                }
                
                // Setup experiment
                if (this.experiments[name]) {
                    this.experiments[name]();
                }
                
                // Update tutorial text
                this.updateTutorial(name);
            }

            setupGravityExperiment() {
                this.engine.gravity = { x: 0, y: 0 };
                this.engine.friction = 0;
                
                // Add central mass
                this.engine.addObject({
                    x: this.canvas.width / 2,
                    y: this.canvas.height / 2,
                    vx: 0,
                    vy: 0,
                    mass: 100,
                    radius: 30,
                    color: '#ffeb3b',
                    fixed: true
                });
                
                // Add orbiting bodies
                for (let i = 0; i < 3; i++) {
                    const angle = (Math.PI * 2 * i) / 3;
                    const distance = 150 + i * 50;
                    const speed = Math.sqrt(100 / distance) * 10;
                    this.engine.addObject({
                        x: this.canvas.width / 2 + Math.cos(angle) * distance,
                        y: this.canvas.height / 2 + Math.sin(angle) * distance,
                        vx: -Math.sin(angle) * speed,
                        vy: Math.cos(angle) * speed,
                        mass: 5,
                        radius: 10,
                        color: `hsl(${i * 120}, 70%, 60%)`
                    });
                }
                
                // Override update for gravity simulation
                const originalUpdate = this.engine.update.bind(this.engine);
                this.engine.update = function(dt) {
                    if (this.paused) return;
                    
                    const G = 100; // Gravitational constant
                    
                    // Calculate gravitational forces
                    for (let i = 0; i < this.objects.length; i++) {
                        const obj1 = this.objects[i];
                        if (obj1.fixed) continue;
                        
                        let fx = 0, fy = 0;
                        
                        for (let j = 0; j < this.objects.length; j++) {
                            if (i === j) continue;
                            const obj2 = this.objects[j];
                            
                            const dx = obj2.x - obj1.x;
                            const dy = obj2.y - obj1.y;
                            const distSq = dx * dx + dy * dy;
                            const dist = Math.sqrt(distSq);
                            
                            if (dist > 0.1) {
                                const force = G * obj1.mass * obj2.mass / distSq;
                                fx += force * dx / dist;
                                fy += force * dy / dist;
                            }
                        }
                        
                        // Apply forces
                        obj1.vx += fx / obj1.mass * dt * this.timeScale;
                        obj1.vy += fy / obj1.mass * dt * this.timeScale;
                    }
                    
                    // Update positions
                    for (let obj of this.objects) {
                        if (!obj.fixed) {
                            obj.x += obj.vx * dt * this.timeScale;
                            obj.y += obj.vy * dt * this.timeScale;
                            
                            // Update trail
                            if (!obj.trail) obj.trail = [];
                            obj.trail.push({ x: obj.x, y: obj.y });
                            if (obj.trail.length > 100) obj.trail.shift();
                        }
                    }
                    
                    this.time += dt * this.timeScale;
                }.bind(this.engine);
            }

            setupPendulumExperiment() {
                this.engine.gravity = { x: 0, y: 9.8 };
                this.engine.friction = 0.01;
                
                const centerX = this.canvas.width / 2;
                const centerY = 100;
                
                // Create multiple pendulums with different lengths
                for (let i = 0; i < 10; i++) {
                    const length = 100 + i * 20;
                    const angle = Math.PI / 6;
                    
                    // Pivot point
                    this.engine.addObject({
                        x: centerX - 200 + i * 40,
                        y: centerY,
                        vx: 0,
                        vy: 0,
                        mass: 0.1,
                        radius: 3,
                        color: '#888',
                        fixed: true
                    });
                    
                    // Bob
                    this.engine.addObject({
                        x: centerX - 200 + i * 40 + Math.sin(angle) * length,
                        y: centerY + Math.cos(angle) * length,
                        vx: 0,
                        vy: 0,
                        mass: 2,
                        radius: 8,
                        color: `hsl(${i * 36}, 70%, 60%)`,
                        pendulumLength: length,
                        pivotIndex: this.engine.objects.length - 1
                    });
                }
            }

            setupCollisionExperiment() {
                this.engine.gravity = { x: 0, y: 0 };
                this.engine.friction = 0;
                
                // Newton's cradle setup
                const centerX = this.canvas.width / 2;
                const y = this.canvas.height / 2;
                
                for (let i = 0; i < 5; i++) {
                    this.engine.addObject({
                        x: centerX - 60 + i * 30,
                        y: y,
                        vx: i === 0 ? 100 : 0,
                        vy: 0,
                        mass: 1,
                        radius: 15,
                        color: `hsl(${i * 72}, 70%, 60%)`
                    });
                }
            }

            setupWaveExperiment() {
                // Wave interference simulation
                this.engine.gravity = { x: 0, y: 0 };
                this.engine.friction = 0;
                
                // Create wave sources
                this.engine.waveMode = true;
                this.engine.waveSources = [
                    { x: this.canvas.width / 3, y: this.canvas.height / 2, frequency: 0.05, amplitude: 50 },
                    { x: 2 * this.canvas.width / 3, y: this.canvas.height / 2, frequency: 0.05, amplitude: 50 }
                ];
            }

            setupSpringExperiment() {
                this.engine.gravity = { x: 0, y: 2 };
                this.engine.friction = 0.02;
                
                // Create spring system
                const centerX = this.canvas.width / 2;
                for (let i = 0; i < 5; i++) {
                    this.engine.addObject({
                        x: centerX,
                        y: 100 + i * 50,
                        vx: i % 2 === 0 ? 50 : -50,
                        vy: 0,
                        mass: 1,
                        radius: 10,
                        color: `hsl(${i * 72}, 70%, 60%)`,
                        springK: 0.1,
                        restLength: 50,
                        connectedTo: i > 0 ? i - 1 : null
                    });
                }
            }

            setupFluidExperiment() {
                this.engine.gravity = { x: 0, y: 5 };
                this.engine.friction = 0.1;
                
                // Create fluid particles
                for (let i = 0; i < 50; i++) {
                    this.engine.addObject({
                        x: this.canvas.width / 2 + (Math.random() - 0.5) * 100,
                        y: 100 + Math.random() * 50,
                        vx: (Math.random() - 0.5) * 20,
                        vy: Math.random() * 10,
                        mass: 0.5,
                        radius: 4,
                        color: `hsla(200, 70%, 60%, 0.6)`,
                        fluid: true
                    });
                }
            }

            setupElectroExperiment() {
                this.engine.gravity = { x: 0, y: 0 };
                this.engine.friction = 0.01;
                
                // Create charged particles
                for (let i = 0; i < 10; i++) {
                    this.engine.addObject({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        vx: (Math.random() - 0.5) * 50,
                        vy: (Math.random() - 0.5) * 50,
                        mass: 1,
                        radius: 8,
                        charge: Math.random() > 0.5 ? 1 : -1,
                        color: Math.random() > 0.5 ? '#ff4444' : '#4444ff'
                    });
                }
            }

            setupQuantumExperiment() {
                this.engine.gravity = { x: 0, y: 0 };
                this.engine.friction = 0;
                
                // Quantum particle simulation
                this.engine.quantumMode = true;
                for (let i = 0; i < 20; i++) {
                    this.engine.addObject({
                        x: this.canvas.width / 2,
                        y: this.canvas.height / 2,
                        vx: (Math.random() - 0.5) * 100,
                        vy: (Math.random() - 0.5) * 100,
                        mass: 0.1,
                        radius: 3,
                        color: `hsla(${Math.random() * 360}, 70%, 60%, 0.5)`,
                        quantum: true,
                        waveFunction: Math.random() * Math.PI * 2
                    });
                }
            }

            updateTutorial(experiment) {
                const tutorials = {
                    gravity: "Explore gravity and orbital mechanics! Click to create objects, drag to set velocity. Try creating a stable orbit or a multi-body system.",
                    pendulum: "Watch pendulum waves! The pendulums have different lengths, creating beautiful wave patterns. Try changing gravity to see the effect.",
                    collision: "Study collision dynamics! Objects transfer momentum through elastic collisions. Create your own collision scenarios.",
                    waves: "Observe wave interference patterns! Two wave sources create constructive and destructive interference. Move the sources to change patterns.",
                    springs: "Explore spring oscillations! Connected masses demonstrate harmonic motion. Adjust parameters to find resonance.",
                    fluid: "Simulate fluid dynamics! Particles interact to create fluid-like behavior. Watch how they flow and settle.",
                    electro: "Experiment with electromagnetic forces! Charged particles attract or repel. Red is positive, blue is negative.",
                    quantum: "Quantum particle simulation! Particles exhibit wave-particle duality and quantum tunneling effects."
                };
                
                document.getElementById('tutorialText').textContent = tutorials[experiment] || "";
            }

            selectTool(tool) {
                this.currentTool = tool;
                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                event.target.classList.add('active');
            }

            clearCanvas() {
                this.engine.clear();
                this.selectExperiment(this.currentExperiment);
            }

            togglePause() {
                this.engine.paused = !this.engine.paused;
            }

            reset() {
                this.selectExperiment(this.currentExperiment);
            }

            showChallenges() {
                const modal = document.getElementById('challengeModal');
                const list = document.getElementById('challengesList');
                
                list.innerHTML = '';
                this.challenges.forEach((challenge, index) => {
                    const card = document.createElement('div');
                    card.className = 'challenge-card';
                    card.innerHTML = `
                        <h3>${challenge.title}</h3>
                        <p>${challenge.description}</p>
                        <button class="btn" onclick="app.startChallenge(${index})">Start Challenge</button>
                    `;
                    list.appendChild(card);
                });
                
                modal.classList.add('active');
            }

            closeChallenges() {
                document.getElementById('challengeModal').classList.remove('active');
            }

            startChallenge(index) {
                const challenge = this.challenges[index];
                this.closeChallenges();
                this.reset();
                alert(`Challenge started: ${challenge.title}\n\n${challenge.description}`);
            }

            checkStableOrbit() {
                // Check if any object maintains consistent orbital distance
                return false; // Simplified
            }

            checkThreeBody() {
                return this.engine.objects.length >= 3;
            }

            checkEnergyConservation() {
                // Check if energy is conserved within 5%
                return true; // Simplified
            }

            checkElasticCollision() {
                return true; // Simplified
            }

            checkResonance() {
                return true; // Simplified
            }

            exportData() {
                const data = {
                    experiment: this.currentExperiment,
                    objects: this.engine.objects.map(obj => ({
                        x: obj.x,
                        y: obj.y,
                        vx: obj.vx,
                        vy: obj.vy,
                        mass: obj.mass,
                        radius: obj.radius,
                        color: obj.color
                    })),
                    settings: {
                        gravity: this.engine.gravity,
                        friction: this.engine.friction,
                        timeScale: this.engine.timeScale
                    },
                    timestamp: new Date().toISOString()
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `physics-experiment-${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }

            importData() {
                document.getElementById('importInput').click();
            }

            loadData(data) {
                if (data.experiment) {
                    this.selectExperiment(data.experiment);
                }
                
                if (data.settings) {
                    this.engine.gravity = data.settings.gravity;
                    this.engine.friction = data.settings.friction;
                    this.engine.timeScale = data.settings.timeScale;
                    
                    // Update UI
                    document.getElementById('gravitySlider').value = this.engine.gravity.y * 10;
                    document.getElementById('gravityValue').textContent = this.engine.gravity.y.toFixed(1);
                    document.getElementById('frictionSlider').value = this.engine.friction * 100;
                    document.getElementById('frictionValue').textContent = (this.engine.friction * 100).toFixed(0);
                    document.getElementById('timeSlider').value = this.engine.timeScale * 100;
                    document.getElementById('timeValue').textContent = (this.engine.timeScale * 100) + '%';
                }
                
                if (data.objects) {
                    this.engine.clear();
                    data.objects.forEach(obj => this.engine.addObject(obj));
                }
            }

            render() {
                // Clear canvas
                this.ctx.fillStyle = 'rgba(10, 14, 39, 0.1)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Save context
                this.ctx.save();
                
                // Apply camera transform
                this.ctx.translate(this.canvas.width / 2, this.canvas.height / 2);
                this.ctx.scale(this.camera.zoom, this.camera.zoom);
                this.ctx.translate(-this.canvas.width / 2, -this.canvas.height / 2);
                
                // Draw grid
                this.drawGrid();
                
                // Draw wave field if in wave mode
                if (this.engine.waveMode) {
                    this.drawWaveField();
                }
                
                // Draw objects
                for (let obj of this.engine.objects) {
                    // Draw trail
                    if (obj.trail && obj.trail.length > 1) {
                        this.ctx.strokeStyle = obj.color + '44';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.moveTo(obj.trail[0].x, obj.trail[0].y);
                        for (let i = 1; i < obj.trail.length; i++) {
                            this.ctx.lineTo(obj.trail[i].x, obj.trail[i].y);
                        }
                        this.ctx.stroke();
                    }
                    
                    // Draw object
                    this.ctx.fillStyle = obj.color;
                    this.ctx.beginPath();
                    this.ctx.arc(obj.x, obj.y, obj.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Draw selection
                    if (obj === this.selectedObject) {
                        this.ctx.strokeStyle = '#ffd700';
                        this.ctx.lineWidth = 2;
                        this.ctx.stroke();
                    }
                    
                    // Draw velocity vector
                    if (obj === this.selectedObject || this.currentTool === 'measure') {
                        this.ctx.strokeStyle = '#00ff00';
                        this.ctx.lineWidth = 1;
                        this.ctx.beginPath();
                        this.ctx.moveTo(obj.x, obj.y);
                        this.ctx.lineTo(obj.x + obj.vx, obj.y + obj.vy);
                        this.ctx.stroke();
                    }
                }
                
                // Draw creation preview
                if (this.mouseDown && this.currentTool === 'create' && this.mouseStart) {
                    this.ctx.strokeStyle = '#ffd700';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.mouseStart.x, this.mouseStart.y);
                    this.ctx.lineTo(this.mousePos.x, this.mousePos.y);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                    
                    // Draw preview circle
                    this.ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                    this.ctx.beginPath();
                    this.ctx.arc(this.mouseStart.x, this.mouseStart.y, 10, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                // Restore context
                this.ctx.restore();
                
                // Update stats
                this.updateStats();
            }

            drawGrid() {
                const gridSize = 50;
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
                this.ctx.lineWidth = 1;
                
                for (let x = 0; x <= this.canvas.width; x += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }
                
                for (let y = 0; y <= this.canvas.height; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
            }

            drawWaveField() {
                if (!this.engine.waveSources) return;
                
                const resolution = 10;
                for (let x = 0; x < this.canvas.width; x += resolution) {
                    for (let y = 0; y < this.canvas.height; y += resolution) {
                        let amplitude = 0;
                        
                        for (let source of this.engine.waveSources) {
                            const dx = x - source.x;
                            const dy = y - source.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            amplitude += source.amplitude * Math.sin(distance * source.frequency - this.engine.time * 2);
                        }
                        
                        const intensity = Math.abs(amplitude) / 100;
                        this.ctx.fillStyle = `hsla(200, 70%, 60%, ${intensity})`;
                        this.ctx.fillRect(x, y, resolution, resolution);
                    }
                }
            }

            updateStats() {
                document.getElementById('objectCount').textContent = this.engine.objects.length;
                document.getElementById('totalEnergy').textContent = this.engine.getTotalEnergy().toFixed(0) + ' J';
                document.getElementById('totalMomentum').textContent = this.engine.getTotalMomentum().toFixed(0) + ' kg¬∑m/s';
                document.getElementById('simTime').textContent = this.engine.time.toFixed(1) + ' s';
                
                // Update FPS
                this.frameCount++;
                const now = performance.now();
                if (now - this.fpsUpdateTime > 1000) {
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.fpsUpdateTime = now;
                    document.getElementById('fpsCounter').textContent = this.fps + ' FPS';
                }
                
                const frameTime = now - this.lastTime;
                document.getElementById('frameTime').textContent = frameTime.toFixed(0) + ' ms';
            }

            animate(time = 0) {
                const dt = Math.min((time - this.lastTime) / 1000, 0.1) || 0.016;
                this.lastTime = time;
                
                this.engine.update(dt);
                this.render();
                
                requestAnimationFrame(this.animate.bind(this));
            }
        }

        // Initialize app
        const app = new PhysicsApp();
    </script>
</body>
</html>