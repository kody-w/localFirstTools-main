<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Browser Physics Lab - Professional Simulation Environment</title>
    <meta name="description" content="Professional physics simulation lab with particle dynamics, fluid mechanics, electromagnetism, wave physics, and pendulum systems. Real-time visualization with force vectors, measurement tools, and data export.">
    <!-- Tags: physics, simulation, canvas, particles, waves, electromagnetism, fluid, pendulum, education, science -->
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --border-color: #30363d;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-red: #f85149;
            --accent-yellow: #d29922;
            --accent-purple: #a371f7;
            --accent-cyan: #39c5cf;
        }

        .theme-light {
            --bg-primary: #ffffff;
            --bg-secondary: #f6f8fa;
            --bg-tertiary: #e6edf3;
            --border-color: #d0d7de;
            --text-primary: #1f2328;
            --text-secondary: #656d76;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
            font-size: 13px;
        }

        #app {
            display: grid;
            grid-template-columns: 280px 1fr 320px;
            grid-template-rows: 48px 1fr 200px;
            height: 100vh;
        }

        /* Header */
        #header {
            grid-column: 1 / -1;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 16px;
        }

        #header h1 {
            font-size: 16px;
            font-weight: 600;
            color: var(--accent-cyan);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #header h1::before {
            content: '';
            display: inline-block;
            width: 8px;
            height: 8px;
            background: var(--accent-green);
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .header-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .spacer { flex: 1; }

        /* Buttons */
        button, .btn {
            padding: 6px 12px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.15s ease;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        button:hover { background: var(--border-color); }

        button.primary {
            background: var(--accent-blue);
            color: #fff;
            border-color: var(--accent-blue);
        }

        button.primary:hover { opacity: 0.9; }

        button.danger { background: var(--accent-red); color: #fff; border-color: var(--accent-red); }
        button.success { background: var(--accent-green); color: #fff; border-color: var(--accent-green); }

        button.active {
            background: var(--accent-blue);
            color: #fff;
            border-color: var(--accent-blue);
        }

        /* Mode Tabs */
        .mode-tabs {
            display: flex;
            gap: 4px;
            background: var(--bg-tertiary);
            padding: 4px;
            border-radius: 8px;
        }

        .mode-tab {
            padding: 6px 14px;
            border: none;
            background: transparent;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .mode-tab.active {
            background: var(--accent-blue);
            color: #fff;
        }

        /* Left Panel - Controls */
        #left-panel {
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            overflow-y: auto;
            padding: 12px;
        }

        .panel-section {
            margin-bottom: 16px;
        }

        .panel-section h3 {
            font-size: 10px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            padding-bottom: 6px;
            border-bottom: 1px solid var(--border-color);
        }

        .control-row {
            margin-bottom: 12px;
        }

        .control-row label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            font-size: 11px;
            color: var(--text-secondary);
        }

        .control-row .value {
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            font-size: 11px;
            color: var(--accent-cyan);
            font-weight: 500;
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: var(--bg-tertiary);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--accent-blue);
            cursor: pointer;
            border: 2px solid var(--bg-primary);
        }

        input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--accent-blue);
            cursor: pointer;
            border: 2px solid var(--bg-primary);
        }

        select {
            width: 100%;
            padding: 8px 10px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
        }

        input[type="number"], input[type="text"] {
            width: 100%;
            padding: 8px 10px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 12px;
            font-family: 'SF Mono', Monaco, monospace;
        }

        /* Tool Buttons */
        .tool-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 6px;
        }

        .tool-btn {
            padding: 10px 8px;
            font-size: 11px;
            text-align: center;
            flex-direction: column;
            gap: 4px;
        }

        .tool-btn .icon {
            font-size: 16px;
        }

        /* Canvas Area */
        #canvas-container {
            position: relative;
            background: var(--bg-primary);
            overflow: hidden;
        }

        #simulation-canvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: crosshair;
        }

        #overlay-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* Simulation Info Overlay */
        #sim-info {
            position: absolute;
            top: 12px;
            left: 12px;
            background: rgba(13, 17, 23, 0.9);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 11px;
            min-width: 180px;
        }

        .theme-light #sim-info {
            background: rgba(255, 255, 255, 0.95);
        }

        #sim-info .row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }

        #sim-info .label { color: var(--text-secondary); }
        #sim-info .val { color: var(--accent-cyan); }

        /* Measurement Tool Display */
        #measurement-display {
            position: absolute;
            bottom: 12px;
            left: 12px;
            background: rgba(13, 17, 23, 0.9);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 11px;
            display: none;
        }

        .theme-light #measurement-display {
            background: rgba(255, 255, 255, 0.95);
        }

        /* Right Panel - Data & Graphs */
        #right-panel {
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .data-section {
            padding: 12px;
            border-bottom: 1px solid var(--border-color);
        }

        .data-section h3 {
            font-size: 10px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }

        /* Object List */
        .object-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .object-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            margin-bottom: 6px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .object-item:hover {
            border-color: var(--accent-blue);
        }

        .object-item.selected {
            border: 1px solid var(--accent-blue);
            background: rgba(88, 166, 255, 0.1);
        }

        .object-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .object-info {
            flex: 1;
            font-size: 11px;
        }

        .object-info .name { font-weight: 500; }
        .object-info .details { color: var(--text-secondary); font-size: 10px; }

        .delete-btn {
            padding: 4px 8px;
            font-size: 10px;
            background: transparent;
            color: var(--accent-red);
            border: 1px solid var(--accent-red);
        }

        /* Graph Canvas */
        #graph-section {
            flex: 1;
            padding: 12px;
            min-height: 150px;
        }

        #graph-canvas {
            width: 100%;
            height: 120px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }

        .graph-legend {
            display: flex;
            gap: 12px;
            margin-top: 8px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 10px;
        }

        .legend-color {
            width: 10px;
            height: 3px;
            border-radius: 1px;
        }

        /* Bottom Panel - Recording & Export */
        #bottom-panel {
            grid-column: 1 / -1;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            display: flex;
            padding: 12px 16px;
            gap: 16px;
        }

        .bottom-section {
            flex: 1;
        }

        .bottom-section h4 {
            font-size: 10px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        .recording-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .recording-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
        }

        .rec-dot {
            width: 8px;
            height: 8px;
            background: var(--accent-red);
            border-radius: 50%;
            animation: rec-pulse 1s infinite;
        }

        @keyframes rec-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .recording-indicator.inactive .rec-dot {
            background: var(--text-secondary);
            animation: none;
        }

        /* Timeline */
        .timeline-container {
            flex: 2;
            display: flex;
            flex-direction: column;
        }

        .timeline {
            height: 40px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            border: 1px solid var(--border-color);
            position: relative;
            overflow: hidden;
        }

        .timeline-data {
            height: 100%;
            display: flex;
            align-items: flex-end;
        }

        .timeline-bar {
            flex: 1;
            background: var(--accent-blue);
            opacity: 0.5;
            min-width: 2px;
        }

        .timeline-marker {
            position: absolute;
            top: 0;
            height: 100%;
            width: 2px;
            background: var(--accent-yellow);
        }

        /* Data Controls Panel */
        .data-controls {
            position: fixed;
            top: 60px;
            right: 336px;
            z-index: 1000;
            display: flex;
            gap: 8px;
        }

        /* Presets */
        .preset-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }

        .preset-btn {
            padding: 10px;
            font-size: 10px;
            text-align: left;
        }

        .preset-btn .name {
            display: block;
            font-weight: 500;
            margin-bottom: 2px;
        }

        .preset-btn .desc {
            color: var(--text-secondary);
            font-size: 9px;
        }

        /* Scientific Notation */
        .sci-notation {
            font-family: 'SF Mono', Monaco, monospace;
        }

        .sci-notation sup {
            font-size: 0.7em;
            vertical-align: super;
        }

        /* Checkbox styling */
        .checkbox-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .checkbox-row input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: var(--accent-blue);
        }

        /* Responsive */
        @media (max-width: 1200px) {
            #app {
                grid-template-columns: 240px 1fr 280px;
            }
        }

        @media (max-width: 900px) {
            #app {
                grid-template-columns: 1fr;
                grid-template-rows: 48px 1fr auto auto;
            }

            #left-panel, #right-panel {
                display: none;
            }

            #left-panel.mobile-visible,
            #right-panel.mobile-visible {
                display: block;
                position: fixed;
                top: 48px;
                bottom: 0;
                width: 280px;
                z-index: 100;
            }

            #left-panel.mobile-visible { left: 0; }
            #right-panel.mobile-visible { right: 0; }

            .data-controls {
                right: 12px;
            }
        }

        /* Hidden file input */
        #import-file { display: none; }

        /* Instructions Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .modal-overlay.hidden { display: none; }

        .modal {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            padding: 24px;
        }

        .modal h2 {
            font-size: 18px;
            margin-bottom: 16px;
            color: var(--accent-cyan);
        }

        .modal p, .modal li {
            margin-bottom: 12px;
            line-height: 1.6;
            color: var(--text-secondary);
        }

        .modal ul {
            padding-left: 20px;
        }

        .modal .close-btn {
            margin-top: 16px;
        }

        .kbd {
            display: inline-block;
            padding: 2px 6px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- Header -->
        <header id="header">
            <h1>Physics Lab</h1>

            <div class="mode-tabs">
                <button class="mode-tab active" data-mode="particles">Particles</button>
                <button class="mode-tab" data-mode="fluid">Fluid</button>
                <button class="mode-tab" data-mode="em">EM Fields</button>
                <button class="mode-tab" data-mode="waves">Waves</button>
                <button class="mode-tab" data-mode="pendulum">Pendulums</button>
            </div>

            <div class="spacer"></div>

            <div class="header-group">
                <button id="play-btn" class="primary" onclick="toggleSimulation()">
                    <span id="play-icon">||</span> <span id="play-text">Pause</span>
                </button>
                <button onclick="resetSimulation()">Reset</button>
                <button onclick="stepSimulation()">Step</button>
            </div>

            <div class="header-group">
                <button onclick="showHelp()" title="Help and keyboard shortcuts" aria-label="Help and keyboard shortcuts">?</button>
                <button onclick="toggleTheme()">Theme</button>
                <button onclick="exportData()">Export</button>
                <button onclick="document.getElementById('import-file').click()">Import</button>
                <input type="file" id="import-file" accept=".json" onchange="importData(event)">
            </div>
        </header>

        <!-- Left Panel - Controls -->
        <aside id="left-panel">
            <!-- Tools -->
            <div class="panel-section">
                <h3>Tools</h3>
                <div class="tool-grid">
                    <button class="tool-btn active" data-tool="add" onclick="setTool('add')">
                        <span class="icon">+</span>
                        <span>Add Object</span>
                    </button>
                    <button class="tool-btn" data-tool="select" onclick="setTool('select')">
                        <span class="icon">&#9654;</span>
                        <span>Select</span>
                    </button>
                    <button class="tool-btn" data-tool="measure" onclick="setTool('measure')">
                        <span class="icon">&#x2194;</span>
                        <span>Measure</span>
                    </button>
                    <button class="tool-btn" data-tool="velocity" onclick="setTool('velocity')">
                        <span class="icon">&#10230;</span>
                        <span>Set Velocity</span>
                    </button>
                    <button class="tool-btn" data-tool="force" onclick="setTool('force')">
                        <span class="icon">F</span>
                        <span>Apply Force</span>
                    </button>
                    <button class="tool-btn" data-tool="delete" onclick="setTool('delete')">
                        <span class="icon">X</span>
                        <span>Delete</span>
                    </button>
                </div>
            </div>

            <!-- Constants - Particles -->
            <div class="panel-section" id="particle-controls">
                <h3>Physics Constants</h3>
                <div class="control-row">
                    <label>Gravity (m/s<sup>2</sup>) <span class="value" id="gravity-val">9.81</span></label>
                    <input type="range" id="gravity" min="0" max="50" step="0.1" value="9.81" oninput="updateConstant('gravity', this.value)">
                </div>
                <div class="control-row">
                    <label>Air Resistance <span class="value" id="air-val">0.01</span></label>
                    <input type="range" id="air-resistance" min="0" max="0.5" step="0.001" value="0.01" oninput="updateConstant('air', this.value)">
                </div>
                <div class="control-row">
                    <label>Restitution <span class="value" id="restitution-val">0.8</span></label>
                    <input type="range" id="restitution" min="0" max="1" step="0.01" value="0.8" oninput="updateConstant('restitution', this.value)">
                </div>
                <div class="control-row">
                    <label>Friction <span class="value" id="friction-val">0.1</span></label>
                    <input type="range" id="friction" min="0" max="1" step="0.01" value="0.1" oninput="updateConstant('friction', this.value)">
                </div>
                <div class="control-row">
                    <label>Time Scale <span class="value" id="timescale-val">1.0</span></label>
                    <input type="range" id="timescale" min="0.1" max="3" step="0.1" value="1" oninput="updateConstant('timescale', this.value)">
                </div>
            </div>

            <!-- EM Controls (hidden by default) -->
            <div class="panel-section" id="em-controls" style="display: none;">
                <h3>Electromagnetic Constants</h3>
                <div class="control-row">
                    <label>Coulomb Constant (k) <span class="value" id="coulomb-val">8.99e9</span></label>
                    <input type="range" id="coulomb" min="1" max="20" step="0.1" value="8.99" oninput="updateConstant('coulomb', this.value)">
                </div>
                <div class="control-row">
                    <label>Field Strength <span class="value" id="field-val">1.0</span></label>
                    <input type="range" id="field-strength" min="0" max="5" step="0.1" value="1" oninput="updateConstant('field', this.value)">
                </div>
                <div class="checkbox-row">
                    <input type="checkbox" id="show-field-lines" checked onchange="updateDisplay('fieldLines', this.checked)">
                    <label for="show-field-lines">Show Field Lines</label>
                </div>
            </div>

            <!-- Wave Controls (hidden by default) -->
            <div class="panel-section" id="wave-controls" style="display: none;">
                <h3>Wave Parameters</h3>
                <div class="control-row">
                    <label>Frequency (Hz) <span class="value" id="freq-val">2.0</span></label>
                    <input type="range" id="frequency" min="0.1" max="10" step="0.1" value="2" oninput="updateConstant('frequency', this.value)">
                </div>
                <div class="control-row">
                    <label>Wavelength (m) <span class="value" id="wavelength-val">1.0</span></label>
                    <input type="range" id="wavelength" min="0.1" max="5" step="0.1" value="1" oninput="updateConstant('wavelength', this.value)">
                </div>
                <div class="control-row">
                    <label>Amplitude <span class="value" id="amplitude-val">50</span></label>
                    <input type="range" id="amplitude" min="5" max="100" step="1" value="50" oninput="updateConstant('amplitude', this.value)">
                </div>
                <div class="control-row">
                    <label>Damping <span class="value" id="damping-val">0.01</span></label>
                    <input type="range" id="damping" min="0" max="0.1" step="0.001" value="0.01" oninput="updateConstant('damping', this.value)">
                </div>
            </div>

            <!-- Pendulum Controls (hidden by default) -->
            <div class="panel-section" id="pendulum-controls" style="display: none;">
                <h3>Pendulum Parameters</h3>
                <div class="control-row">
                    <label>Length (m) <span class="value" id="length-val">2.0</span></label>
                    <input type="range" id="pend-length" min="0.5" max="5" step="0.1" value="2" oninput="updateConstant('pendLength', this.value)">
                </div>
                <div class="control-row">
                    <label>Mass (kg) <span class="value" id="mass-val">1.0</span></label>
                    <input type="range" id="pend-mass" min="0.1" max="10" step="0.1" value="1" oninput="updateConstant('pendMass', this.value)">
                </div>
                <div class="control-row">
                    <label>Initial Angle (deg) <span class="value" id="angle-val">45</span></label>
                    <input type="range" id="init-angle" min="0" max="180" step="1" value="45" oninput="updateConstant('initAngle', this.value)">
                </div>
            </div>

            <!-- Fluid Controls (hidden by default) -->
            <div class="panel-section" id="fluid-controls" style="display: none;">
                <h3>Fluid Parameters</h3>
                <div class="control-row">
                    <label>Viscosity <span class="value" id="viscosity-val">0.1</span></label>
                    <input type="range" id="viscosity" min="0" max="1" step="0.01" value="0.1" oninput="updateConstant('viscosity', this.value)">
                </div>
                <div class="control-row">
                    <label>Pressure <span class="value" id="pressure-val">100</span></label>
                    <input type="range" id="pressure" min="10" max="500" step="10" value="100" oninput="updateConstant('pressure', this.value)">
                </div>
                <div class="control-row">
                    <label>Particle Count <span class="value" id="pcount-val">200</span></label>
                    <input type="range" id="particle-count" min="50" max="500" step="10" value="200" oninput="updateConstant('particleCount', this.value)">
                </div>
            </div>

            <!-- Object Properties -->
            <div class="panel-section">
                <h3>New Object Properties</h3>
                <div class="control-row">
                    <label>Mass (kg)</label>
                    <input type="number" id="new-mass" value="1" min="0.1" step="0.1">
                </div>
                <div class="control-row">
                    <label>Radius (px)</label>
                    <input type="number" id="new-radius" value="20" min="5" max="100">
                </div>
                <div class="control-row">
                    <label>Charge</label>
                    <select id="new-charge">
                        <option value="0">Neutral</option>
                        <option value="1">Positive (+)</option>
                        <option value="-1">Negative (-)</option>
                    </select>
                </div>
                <div class="checkbox-row">
                    <input type="checkbox" id="new-fixed">
                    <label for="new-fixed">Fixed Position</label>
                </div>
            </div>

            <!-- Display Options -->
            <div class="panel-section">
                <h3>Display Options</h3>
                <div class="checkbox-row">
                    <input type="checkbox" id="show-vectors" checked onchange="updateDisplay('vectors', this.checked)">
                    <label for="show-vectors">Velocity Vectors</label>
                </div>
                <div class="checkbox-row">
                    <input type="checkbox" id="show-forces" onchange="updateDisplay('forces', this.checked)">
                    <label for="show-forces">Force Vectors</label>
                </div>
                <div class="checkbox-row">
                    <input type="checkbox" id="show-trails" onchange="updateDisplay('trails', this.checked)">
                    <label for="show-trails">Motion Trails</label>
                </div>
                <div class="checkbox-row">
                    <input type="checkbox" id="show-grid" checked onchange="updateDisplay('grid', this.checked)">
                    <label for="show-grid">Grid</label>
                </div>
                <div class="checkbox-row">
                    <input type="checkbox" id="show-labels" checked onchange="updateDisplay('labels', this.checked)">
                    <label for="show-labels">Object Labels</label>
                </div>
            </div>

            <!-- Presets -->
            <div class="panel-section">
                <h3>Preset Experiments</h3>
                <div class="preset-grid">
                    <button class="preset-btn" onclick="loadPreset('collision')">
                        <span class="name">Collision</span>
                        <span class="desc">Elastic collision</span>
                    </button>
                    <button class="preset-btn" onclick="loadPreset('orbit')">
                        <span class="name">Orbit</span>
                        <span class="desc">Planetary motion</span>
                    </button>
                    <button class="preset-btn" onclick="loadPreset('spring')">
                        <span class="name">Spring</span>
                        <span class="desc">Harmonic motion</span>
                    </button>
                    <button class="preset-btn" onclick="loadPreset('pendulumDemo')">
                        <span class="name">Pendulum</span>
                        <span class="desc">Simple pendulum</span>
                    </button>
                    <button class="preset-btn" onclick="loadPreset('charges')">
                        <span class="name">Charges</span>
                        <span class="desc">Electric field</span>
                    </button>
                    <button class="preset-btn" onclick="loadPreset('waves')">
                        <span class="name">Interference</span>
                        <span class="desc">Wave superposition</span>
                    </button>
                </div>
            </div>
        </aside>

        <!-- Main Canvas -->
        <main id="canvas-container">
            <canvas id="simulation-canvas" role="img" aria-label="Physics simulation area - interactive canvas for physics experiments"></canvas>
            <canvas id="overlay-canvas"></canvas>

            <div id="sim-info">
                <div class="row"><span class="label">Time:</span> <span class="val" id="info-time">0.00s</span></div>
                <div class="row"><span class="label">FPS:</span> <span class="val" id="info-fps">60</span></div>
                <div class="row"><span class="label">Objects:</span> <span class="val" id="info-objects">0</span></div>
                <div class="row"><span class="label">Total KE:</span> <span class="val" id="info-ke">0 J</span></div>
                <div class="row"><span class="label">Total PE:</span> <span class="val" id="info-pe">0 J</span></div>
            </div>

            <div id="measurement-display">
                <div class="row"><span class="label">Distance:</span> <span class="val" id="meas-dist">0 m</span></div>
                <div class="row"><span class="label">Angle:</span> <span class="val" id="meas-angle">0 deg</span></div>
                <div class="row"><span class="label">Velocity:</span> <span class="val" id="meas-vel">0 m/s</span></div>
            </div>

            <div class="data-controls">
                <button onclick="saveExperiment()">Save Experiment</button>
                <button onclick="document.getElementById('load-exp-file').click()">Load Experiment</button>
                <input type="file" id="load-exp-file" accept=".json" style="display:none" onchange="loadExperiment(event)">
            </div>
        </main>

        <!-- Right Panel - Data & Graphs -->
        <aside id="right-panel">
            <!-- Object List -->
            <div class="data-section">
                <h3>Objects</h3>
                <div class="object-list" id="object-list">
                    <!-- Populated dynamically -->
                </div>
            </div>

            <!-- Selected Object Details -->
            <div class="data-section" id="selected-details" style="display: none;">
                <h3>Selected Object</h3>
                <div id="selected-info">
                    <!-- Populated dynamically -->
                </div>
            </div>

            <!-- Graph -->
            <div id="graph-section">
                <h3>Real-Time Data</h3>
                <select id="graph-type" onchange="updateGraphType(this.value)">
                    <option value="energy">Energy vs Time</option>
                    <option value="velocity">Velocity vs Time</option>
                    <option value="position">Position vs Time</option>
                    <option value="momentum">Momentum vs Time</option>
                </select>
                <canvas id="graph-canvas"></canvas>
                <div class="graph-legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #3fb950;"></div>
                        <span>Kinetic</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #f85149;"></div>
                        <span>Potential</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #58a6ff;"></div>
                        <span>Total</span>
                    </div>
                </div>
            </div>
        </aside>

        <!-- Bottom Panel - Recording & Timeline -->
        <footer id="bottom-panel">
            <div class="bottom-section">
                <h4>Recording</h4>
                <div class="recording-controls">
                    <button id="record-btn" onclick="toggleRecording()">Record</button>
                    <div class="recording-indicator inactive" id="rec-indicator">
                        <div class="rec-dot"></div>
                        <span id="rec-time">00:00</span>
                    </div>
                    <button onclick="clearRecording()">Clear</button>
                </div>
            </div>

            <div class="timeline-container">
                <h4>Timeline (<span id="frame-count">0</span> frames)</h4>
                <div class="timeline">
                    <div class="timeline-data" id="timeline-data"></div>
                    <div class="timeline-marker" id="timeline-marker" style="left: 0;"></div>
                </div>
            </div>

            <div class="bottom-section">
                <h4>Export Data</h4>
                <div class="recording-controls">
                    <button onclick="exportCSV()">CSV</button>
                    <button onclick="exportJSON()">JSON</button>
                    <button onclick="exportImage()">PNG</button>
                </div>
            </div>
        </footer>
    </div>

    <!-- Help Modal -->
    <div class="modal-overlay hidden" id="help-modal" onclick="hideHelp(event)">
        <div class="modal" onclick="event.stopPropagation()">
            <h2>Browser Physics Lab - Help</h2>
            <p>Welcome to the Physics Lab! This is a professional-grade physics simulation environment running entirely in your browser.</p>

            <h3 style="margin-top: 16px; margin-bottom: 8px; color: var(--accent-cyan);">Simulation Modes</h3>
            <ul>
                <li><strong>Particles:</strong> Classical mechanics with gravity, collisions, and springs</li>
                <li><strong>Fluid:</strong> Simplified fluid dynamics simulation</li>
                <li><strong>EM Fields:</strong> Electrostatic charges and field visualization</li>
                <li><strong>Waves:</strong> Wave interference and diffraction patterns</li>
                <li><strong>Pendulums:</strong> Simple and coupled pendulum systems</li>
            </ul>

            <h3 style="margin-top: 16px; margin-bottom: 8px; color: var(--accent-cyan);">Controls</h3>
            <ul>
                <li><kbd class="kbd">Click</kbd> - Add object / Select object / Place wave source</li>
                <li><kbd class="kbd">Drag</kbd> - Set initial velocity / Move object / Measure distance</li>
                <li><kbd class="kbd">Space</kbd> - Play/Pause simulation</li>
                <li><kbd class="kbd">R</kbd> - Reset simulation</li>
                <li><kbd class="kbd">G</kbd> - Toggle grid</li>
                <li><kbd class="kbd">V</kbd> - Toggle velocity vectors</li>
                <li><kbd class="kbd">Delete</kbd> - Remove selected object</li>
            </ul>

            <h3 style="margin-top: 16px; margin-bottom: 8px; color: var(--accent-cyan);">Data Export</h3>
            <p>Record simulation data and export as CSV for spreadsheet analysis or JSON for complete state backup. Save experiments to continue later.</p>

            <button class="close-btn primary" onclick="hideHelp()">Got it!</button>
        </div>
    </div>

    <script>
        // ============================================================
        // BROWSER PHYSICS LAB - Complete Simulation Engine
        // A professional physics simulation environment
        // ============================================================

        const APP_NAME = 'physics-lab';

        // State management
        let state = {
            mode: 'particles',
            tool: 'add',
            running: true,
            recording: false,
            time: 0,
            frameCount: 0,
            selectedObject: null,
            theme: 'dark',

            // Physics constants
            constants: {
                gravity: 9.81,
                airResistance: 0.01,
                restitution: 0.8,
                friction: 0.1,
                timeScale: 1.0,
                coulomb: 8.99e9,
                fieldStrength: 1.0,
                frequency: 2.0,
                wavelength: 1.0,
                amplitude: 50,
                damping: 0.01,
                pendLength: 2.0,
                pendMass: 1.0,
                initAngle: 45,
                viscosity: 0.1,
                pressure: 100,
                particleCount: 200
            },

            // Display options
            display: {
                vectors: true,
                forces: false,
                trails: false,
                grid: true,
                labels: true,
                fieldLines: true
            },

            // Objects in simulation
            objects: [],

            // Wave sources
            waveSources: [],

            // Pendulums
            pendulums: [],

            // Fluid particles
            fluidParticles: [],

            // Recording data
            recordedData: [],

            // Graph data
            graphData: {
                time: [],
                ke: [],
                pe: [],
                total: []
            }
        };

        // Canvas setup
        let canvas, ctx, overlayCanvas, overlayCtx, graphCanvas, graphCtx;
        let lastTime = 0;
        let fps = 60;
        let pixelsPerMeter = 50; // Scale: 50 pixels = 1 meter

        // Mouse state
        let mouse = {
            x: 0, y: 0,
            startX: 0, startY: 0,
            dragging: false,
            dragObject: null
        };

        // Measurement state
        let measurement = {
            active: false,
            startX: 0, startY: 0,
            endX: 0, endY: 0
        };

        // Initialize
        function init() {
            // Load saved state
            loadState();

            // Setup canvases
            canvas = document.getElementById('simulation-canvas');
            ctx = canvas.getContext('2d');
            overlayCanvas = document.getElementById('overlay-canvas');
            overlayCtx = overlayCanvas.getContext('2d');
            graphCanvas = document.getElementById('graph-canvas');
            graphCtx = graphCanvas.getContext('2d');

            resizeCanvases();
            window.addEventListener('resize', resizeCanvases);

            // Mouse events
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('wheel', onWheel);

            // Touch events
            canvas.addEventListener('touchstart', onTouchStart);
            canvas.addEventListener('touchmove', onTouchMove);
            canvas.addEventListener('touchend', onTouchEnd);

            // Keyboard events
            document.addEventListener('keydown', onKeyDown);

            // Mode tab listeners
            document.querySelectorAll('.mode-tab').forEach(tab => {
                tab.addEventListener('click', () => setMode(tab.dataset.mode));
            });

            // Apply theme
            if (state.theme === 'light') {
                document.body.classList.add('theme-light');
            }

            // Start animation loop
            requestAnimationFrame(gameLoop);

            // Show help on first visit
            // Cycle 1: Wrap localStorage in try-catch for private browsing support
            try {
                if (!localStorage.getItem(APP_NAME + '-visited')) {
                    showHelp();
                    localStorage.setItem(APP_NAME + '-visited', 'true');
                }
            } catch (e) {
                showHelp(); // Show help anyway if localStorage unavailable
            }
        }

        function resizeCanvases() {
            const container = document.getElementById('canvas-container');
            const rect = container.getBoundingClientRect();

            canvas.width = rect.width;
            canvas.height = rect.height;
            overlayCanvas.width = rect.width;
            overlayCanvas.height = rect.height;

            const graphRect = graphCanvas.parentElement.getBoundingClientRect();
            graphCanvas.width = graphRect.width - 24;
            graphCanvas.height = 120;
        }

        // ============================================================
        // MAIN GAME LOOP
        // ============================================================

        function gameLoop(timestamp) {
            const dt = Math.min((timestamp - lastTime) / 1000, 0.05) * state.constants.timeScale;
            lastTime = timestamp;

            // Calculate FPS
            fps = Math.round(1000 / (timestamp - lastTime + 1));

            if (state.running) {
                update(dt);
                state.time += dt;
                state.frameCount++;

                // Record data if recording
                if (state.recording) {
                    recordFrame();
                }

                // Update graph data
                updateGraphData();
            }

            render();
            renderOverlay();
            renderGraph();
            updateUI();

            requestAnimationFrame(gameLoop);
        }

        // ============================================================
        // PHYSICS UPDATE
        // ============================================================

        function update(dt) {
            switch (state.mode) {
                case 'particles':
                    updateParticles(dt);
                    break;
                case 'fluid':
                    updateFluid(dt);
                    break;
                case 'em':
                    updateEM(dt);
                    break;
                case 'waves':
                    updateWaves(dt);
                    break;
                case 'pendulum':
                    updatePendulums(dt);
                    break;
            }
        }

        // Particle Physics
        function updateParticles(dt) {
            const g = state.constants.gravity;
            const air = state.constants.airResistance;
            const rest = state.constants.restitution;
            const fric = state.constants.friction;

            for (let obj of state.objects) {
                if (obj.fixed) continue;

                // Apply gravity
                obj.vy += g * pixelsPerMeter * dt;

                // Apply air resistance
                const speed = Math.sqrt(obj.vx * obj.vx + obj.vy * obj.vy);
                if (speed > 0) {
                    const dragForce = air * speed * speed;
                    obj.vx -= (obj.vx / speed) * dragForce * dt;
                    obj.vy -= (obj.vy / speed) * dragForce * dt;
                }

                // Apply spring forces if connected
                if (obj.spring) {
                    const anchor = obj.spring.anchor;
                    const dx = anchor.x - obj.x;
                    const dy = anchor.y - obj.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const force = obj.spring.k * (dist - obj.spring.restLength);

                    obj.vx += (dx / dist) * force * dt / obj.mass;
                    obj.vy += (dy / dist) * force * dt / obj.mass;

                    // Damping
                    obj.vx *= (1 - obj.spring.damping);
                    obj.vy *= (1 - obj.spring.damping);
                }

                // Update position
                obj.x += obj.vx * dt;
                obj.y += obj.vy * dt;

                // Store trail
                if (state.display.trails) {
                    if (!obj.trail) obj.trail = [];
                    obj.trail.push({ x: obj.x, y: obj.y });
                    if (obj.trail.length > 100) obj.trail.shift();
                }

                // Boundary collisions
                if (obj.y + obj.radius > canvas.height) {
                    obj.y = canvas.height - obj.radius;
                    obj.vy = -obj.vy * rest;
                    obj.vx *= (1 - fric);
                }
                if (obj.y - obj.radius < 0) {
                    obj.y = obj.radius;
                    obj.vy = -obj.vy * rest;
                }
                if (obj.x + obj.radius > canvas.width) {
                    obj.x = canvas.width - obj.radius;
                    obj.vx = -obj.vx * rest;
                }
                if (obj.x - obj.radius < 0) {
                    obj.x = obj.radius;
                    obj.vx = -obj.vx * rest;
                }
            }

            // Object-object collisions
            for (let i = 0; i < state.objects.length; i++) {
                for (let j = i + 1; j < state.objects.length; j++) {
                    resolveCollision(state.objects[i], state.objects[j]);
                }
            }
        }

        function resolveCollision(a, b) {
            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const minDist = a.radius + b.radius;

            if (dist < minDist && dist > 0) {
                // Collision detected
                const nx = dx / dist;
                const ny = dy / dist;

                // Separate objects
                const overlap = minDist - dist;
                const totalMass = a.mass + b.mass;

                if (!a.fixed) {
                    a.x -= nx * overlap * (b.mass / totalMass);
                    a.y -= ny * overlap * (b.mass / totalMass);
                }
                if (!b.fixed) {
                    b.x += nx * overlap * (a.mass / totalMass);
                    b.y += ny * overlap * (a.mass / totalMass);
                }

                // Calculate relative velocity
                const dvx = b.vx - a.vx;
                const dvy = b.vy - a.vy;
                const dvn = dvx * nx + dvy * ny;

                if (dvn > 0) return; // Moving apart

                // Calculate impulse
                const rest = state.constants.restitution;
                let j = -(1 + rest) * dvn;
                j /= (1 / a.mass + 1 / b.mass);

                // Apply impulse
                if (!a.fixed) {
                    a.vx -= (j / a.mass) * nx;
                    a.vy -= (j / a.mass) * ny;
                }
                if (!b.fixed) {
                    b.vx += (j / b.mass) * nx;
                    b.vy += (j / b.mass) * ny;
                }
            }
        }

        // Electromagnetic Physics
        function updateEM(dt) {
            const k = state.constants.coulomb * state.constants.fieldStrength * 1e-12; // Scaled for visualization

            for (let obj of state.objects) {
                if (obj.fixed || obj.charge === 0) continue;

                let fx = 0, fy = 0;

                for (let other of state.objects) {
                    if (other === obj) continue;

                    const dx = other.x - obj.x;
                    const dy = other.y - obj.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < obj.radius + other.radius) continue;

                    // Coulomb's law: F = k * q1 * q2 / r^2
                    const force = k * obj.charge * other.charge / (dist * dist);

                    fx -= (dx / dist) * force; // Repel same charges
                    fy -= (dy / dist) * force;
                }

                // Apply force (F = ma)
                obj.vx += (fx / obj.mass) * dt;
                obj.vy += (fy / obj.mass) * dt;

                // Update position
                obj.x += obj.vx * dt;
                obj.y += obj.vy * dt;

                // Store force for visualization
                obj.forceX = fx;
                obj.forceY = fy;

                // Boundary
                obj.x = Math.max(obj.radius, Math.min(canvas.width - obj.radius, obj.x));
                obj.y = Math.max(obj.radius, Math.min(canvas.height - obj.radius, obj.y));
            }
        }

        // Wave Physics
        function updateWaves(dt) {
            // Wave sources emit continuously
            for (let source of state.waveSources) {
                source.phase += state.constants.frequency * 2 * Math.PI * dt;
            }
        }

        // Pendulum Physics
        function updatePendulums(dt) {
            const g = state.constants.gravity;
            const damp = state.constants.damping;

            for (let pend of state.pendulums) {
                // Angular acceleration: alpha = -g/L * sin(theta)
                const alpha = -(g / pend.length) * Math.sin(pend.angle);

                // Update angular velocity
                pend.angularVel += alpha * dt;
                pend.angularVel *= (1 - damp); // Damping

                // Update angle
                pend.angle += pend.angularVel * dt;

                // Calculate bob position
                pend.bobX = pend.pivotX + pend.length * pixelsPerMeter * Math.sin(pend.angle);
                pend.bobY = pend.pivotY + pend.length * pixelsPerMeter * Math.cos(pend.angle);

                // Store trail
                if (state.display.trails) {
                    if (!pend.trail) pend.trail = [];
                    pend.trail.push({ x: pend.bobX, y: pend.bobY });
                    if (pend.trail.length > 200) pend.trail.shift();
                }
            }
        }

        // Fluid Physics (Simplified SPH-like)
        function updateFluid(dt) {
            const visc = state.constants.viscosity;
            const press = state.constants.pressure;
            const g = state.constants.gravity;

            // Initialize fluid if needed
            if (state.fluidParticles.length === 0) {
                initFluid();
            }

            // Update each particle
            for (let p of state.fluidParticles) {
                // Gravity
                p.vy += g * pixelsPerMeter * dt;

                // Viscosity (damping)
                p.vx *= (1 - visc * dt);
                p.vy *= (1 - visc * dt);

                // Pressure from neighbors
                for (let other of state.fluidParticles) {
                    if (other === p) continue;

                    const dx = other.x - p.x;
                    const dy = other.y - p.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 30 && dist > 0) { // Interaction radius
                        const force = press * (30 - dist) / 30 * 0.01;
                        p.vx -= (dx / dist) * force * dt;
                        p.vy -= (dy / dist) * force * dt;
                    }
                }

                // Update position
                p.x += p.vx * dt;
                p.y += p.vy * dt;

                // Boundaries
                if (p.y > canvas.height - 5) {
                    p.y = canvas.height - 5;
                    p.vy = -p.vy * 0.3;
                }
                if (p.x < 5) { p.x = 5; p.vx = -p.vx * 0.3; }
                if (p.x > canvas.width - 5) { p.x = canvas.width - 5; p.vx = -p.vx * 0.3; }
                if (p.y < 5) { p.y = 5; p.vy = -p.vy * 0.3; }
            }
        }

        function initFluid() {
            state.fluidParticles = [];
            const count = state.constants.particleCount;
            const cols = Math.ceil(Math.sqrt(count));
            const rows = Math.ceil(count / cols);

            for (let i = 0; i < count; i++) {
                state.fluidParticles.push({
                    x: 100 + (i % cols) * 8,
                    y: 100 + Math.floor(i / cols) * 8,
                    vx: 0,
                    vy: 0
                });
            }
        }

        // ============================================================
        // RENDERING
        // ============================================================

        function render() {
            // Clear
            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--bg-primary');
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            if (state.display.grid) {
                drawGrid();
            }

            // Mode-specific rendering
            switch (state.mode) {
                case 'particles':
                case 'em':
                    renderParticles();
                    break;
                case 'fluid':
                    renderFluid();
                    break;
                case 'waves':
                    renderWaves();
                    break;
                case 'pendulum':
                    renderPendulums();
                    break;
            }
        }

        function drawGrid() {
            const gridSize = pixelsPerMeter;
            ctx.strokeStyle = state.theme === 'dark' ? 'rgba(48, 54, 61, 0.5)' : 'rgba(208, 215, 222, 0.5)';
            ctx.lineWidth = 1;

            // Vertical lines
            for (let x = 0; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }

            // Horizontal lines
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Meter markers
            ctx.fillStyle = state.theme === 'dark' ? '#8b949e' : '#656d76';
            ctx.font = '10px SF Mono, Monaco, monospace';
            for (let x = gridSize; x < canvas.width; x += gridSize) {
                ctx.fillText(`${Math.round(x / pixelsPerMeter)}m`, x + 2, canvas.height - 4);
            }
        }

        function renderParticles() {
            // Draw trails
            if (state.display.trails) {
                for (let obj of state.objects) {
                    if (obj.trail && obj.trail.length > 1) {
                        ctx.beginPath();
                        ctx.moveTo(obj.trail[0].x, obj.trail[0].y);
                        for (let i = 1; i < obj.trail.length; i++) {
                            ctx.lineTo(obj.trail[i].x, obj.trail[i].y);
                        }
                        ctx.strokeStyle = obj.color + '40';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                }
            }

            // Draw springs
            for (let obj of state.objects) {
                if (obj.spring) {
                    drawSpring(obj.spring.anchor.x, obj.spring.anchor.y, obj.x, obj.y);
                }
            }

            // Draw objects
            for (let obj of state.objects) {
                // Object body
                ctx.beginPath();
                ctx.arc(obj.x, obj.y, obj.radius, 0, Math.PI * 2);
                ctx.fillStyle = obj.color;
                ctx.fill();

                // Charge indicator for EM mode
                if (state.mode === 'em' && obj.charge !== 0) {
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 14px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(obj.charge > 0 ? '+' : '-', obj.x, obj.y);
                }

                // Fixed indicator
                if (obj.fixed) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([4, 4]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                // Selection highlight
                if (obj === state.selectedObject) {
                    ctx.strokeStyle = '#58a6ff';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }

                // Label
                if (state.display.labels) {
                    ctx.fillStyle = state.theme === 'dark' ? '#e6edf3' : '#1f2328';
                    ctx.font = '11px SF Mono, Monaco, monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(obj.name, obj.x, obj.y - obj.radius - 8);
                }
            }
        }

        function drawSpring(x1, y1, x2, y2) {
            const coils = 10;
            const width = 10;
            const dx = x2 - x1;
            const dy = y2 - y1;
            const len = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);

            ctx.save();
            ctx.translate(x1, y1);
            ctx.rotate(angle);

            ctx.beginPath();
            ctx.moveTo(0, 0);

            const segLen = len / coils;
            for (let i = 0; i < coils; i++) {
                const x = (i + 0.25) * segLen;
                const y = (i % 2 === 0) ? width : -width;
                ctx.lineTo(x, y);
            }
            ctx.lineTo(len, 0);

            ctx.strokeStyle = '#888';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.restore();

            // Anchor point
            ctx.beginPath();
            ctx.arc(x1, y1, 5, 0, Math.PI * 2);
            ctx.fillStyle = '#666';
            ctx.fill();
        }

        function renderFluid() {
            ctx.fillStyle = '#58a6ff';
            for (let p of state.fluidParticles) {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function renderWaves() {
            if (state.waveSources.length === 0) {
                // Instruction text
                ctx.fillStyle = state.theme === 'dark' ? '#8b949e' : '#656d76';
                ctx.font = '16px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Click to add wave sources', canvas.width / 2, canvas.height / 2);
                return;
            }

            const amp = state.constants.amplitude;
            const freq = state.constants.frequency;
            const wl = state.constants.wavelength * pixelsPerMeter;
            const damp = state.constants.damping;

            // Create wave interference pattern
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;

            for (let y = 0; y < canvas.height; y += 2) {
                for (let x = 0; x < canvas.width; x += 2) {
                    let totalAmp = 0;

                    for (let source of state.waveSources) {
                        const dx = x - source.x;
                        const dy = y - source.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        // Wave equation: A * sin(kx - wt) with damping
                        const k = 2 * Math.PI / wl;
                        const dampFactor = Math.exp(-damp * dist);
                        const wave = amp * dampFactor * Math.sin(k * dist - source.phase);
                        totalAmp += wave;
                    }

                    // Map amplitude to color
                    const intensity = Math.floor(128 + totalAmp);
                    const clamped = Math.max(0, Math.min(255, intensity));

                    const idx = (y * canvas.width + x) * 4;
                    data[idx] = clamped < 128 ? 0 : (clamped - 128) * 2; // R
                    data[idx + 1] = clamped; // G
                    data[idx + 2] = clamped > 128 ? 255 : clamped * 2; // B
                    data[idx + 3] = 255; // A

                    // Fill 2x2 block for performance
                    if (x + 1 < canvas.width) {
                        data[idx + 4] = data[idx];
                        data[idx + 5] = data[idx + 1];
                        data[idx + 6] = data[idx + 2];
                        data[idx + 7] = 255;
                    }
                    if (y + 1 < canvas.height) {
                        const idx2 = ((y + 1) * canvas.width + x) * 4;
                        data[idx2] = data[idx];
                        data[idx2 + 1] = data[idx + 1];
                        data[idx2 + 2] = data[idx + 2];
                        data[idx2 + 3] = 255;
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);

            // Draw source markers
            for (let source of state.waveSources) {
                ctx.beginPath();
                ctx.arc(source.x, source.y, 8, 0, Math.PI * 2);
                ctx.fillStyle = '#fff';
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        function renderPendulums() {
            if (state.pendulums.length === 0) {
                ctx.fillStyle = state.theme === 'dark' ? '#8b949e' : '#656d76';
                ctx.font = '16px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Click to add pendulums', canvas.width / 2, canvas.height / 2);
                return;
            }

            for (let pend of state.pendulums) {
                // Draw trail
                if (state.display.trails && pend.trail && pend.trail.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(pend.trail[0].x, pend.trail[0].y);
                    for (let i = 1; i < pend.trail.length; i++) {
                        ctx.lineTo(pend.trail[i].x, pend.trail[i].y);
                    }
                    ctx.strokeStyle = pend.color + '40';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // Draw rod
                ctx.beginPath();
                ctx.moveTo(pend.pivotX, pend.pivotY);
                ctx.lineTo(pend.bobX, pend.bobY);
                ctx.strokeStyle = '#888';
                ctx.lineWidth = 3;
                ctx.stroke();

                // Draw pivot
                ctx.beginPath();
                ctx.arc(pend.pivotX, pend.pivotY, 6, 0, Math.PI * 2);
                ctx.fillStyle = '#666';
                ctx.fill();

                // Draw bob
                const bobRadius = 15 + pend.mass * 3;
                ctx.beginPath();
                ctx.arc(pend.bobX, pend.bobY, bobRadius, 0, Math.PI * 2);
                ctx.fillStyle = pend.color;
                ctx.fill();

                // Selection
                if (pend === state.selectedObject) {
                    ctx.strokeStyle = '#58a6ff';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
            }
        }

        function renderOverlay() {
            overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

            // Draw vectors
            if (state.display.vectors && (state.mode === 'particles' || state.mode === 'em')) {
                for (let obj of state.objects) {
                    if (!obj.fixed) {
                        drawVector(overlayCtx, obj.x, obj.y, obj.vx * 0.1, obj.vy * 0.1, '#3fb950', 'v');
                    }
                }
            }

            // Draw force vectors
            if (state.display.forces && state.mode === 'em') {
                for (let obj of state.objects) {
                    if (obj.forceX !== undefined) {
                        drawVector(overlayCtx, obj.x, obj.y, obj.forceX * 10, obj.forceY * 10, '#f85149', 'F');
                    }
                }
            }

            // Draw EM field lines
            if (state.mode === 'em' && state.display.fieldLines && state.objects.length > 0) {
                drawFieldLines();
            }

            // Measurement tool
            if (measurement.active) {
                overlayCtx.beginPath();
                overlayCtx.moveTo(measurement.startX, measurement.startY);
                overlayCtx.lineTo(measurement.endX, measurement.endY);
                overlayCtx.strokeStyle = '#d29922';
                overlayCtx.lineWidth = 2;
                overlayCtx.setLineDash([5, 5]);
                overlayCtx.stroke();
                overlayCtx.setLineDash([]);

                // Distance label
                const dist = Math.sqrt(
                    Math.pow(measurement.endX - measurement.startX, 2) +
                    Math.pow(measurement.endY - measurement.startY, 2)
                ) / pixelsPerMeter;

                const midX = (measurement.startX + measurement.endX) / 2;
                const midY = (measurement.startY + measurement.endY) / 2;

                overlayCtx.fillStyle = '#d29922';
                overlayCtx.font = '12px SF Mono, Monaco, monospace';
                overlayCtx.fillText(`${dist.toFixed(2)} m`, midX + 10, midY);
            }

            // Velocity setting drag line
            if (mouse.dragging && state.tool === 'velocity' && mouse.dragObject) {
                overlayCtx.beginPath();
                overlayCtx.moveTo(mouse.dragObject.x, mouse.dragObject.y);
                overlayCtx.lineTo(mouse.x, mouse.y);
                overlayCtx.strokeStyle = '#a371f7';
                overlayCtx.lineWidth = 2;
                overlayCtx.stroke();

                // Arrow head
                const angle = Math.atan2(mouse.y - mouse.dragObject.y, mouse.x - mouse.dragObject.x);
                overlayCtx.beginPath();
                overlayCtx.moveTo(mouse.x, mouse.y);
                overlayCtx.lineTo(mouse.x - 10 * Math.cos(angle - 0.3), mouse.y - 10 * Math.sin(angle - 0.3));
                overlayCtx.lineTo(mouse.x - 10 * Math.cos(angle + 0.3), mouse.y - 10 * Math.sin(angle + 0.3));
                overlayCtx.closePath();
                overlayCtx.fillStyle = '#a371f7';
                overlayCtx.fill();
            }
        }

        function drawVector(ctx, x, y, vx, vy, color, label) {
            const len = Math.sqrt(vx * vx + vy * vy);
            if (len < 2) return;

            const endX = x + vx;
            const endY = y + vy;
            const angle = Math.atan2(vy, vx);

            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(endX, endY);
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.stroke();

            // Arrow head
            ctx.beginPath();
            ctx.moveTo(endX, endY);
            ctx.lineTo(endX - 8 * Math.cos(angle - 0.4), endY - 8 * Math.sin(angle - 0.4));
            ctx.lineTo(endX - 8 * Math.cos(angle + 0.4), endY - 8 * Math.sin(angle + 0.4));
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();

            // Label
            ctx.fillStyle = color;
            ctx.font = '10px SF Mono';
            ctx.fillText(label, endX + 5, endY - 5);
        }

        function drawFieldLines() {
            const step = 30;
            overlayCtx.strokeStyle = state.theme === 'dark' ? 'rgba(88, 166, 255, 0.3)' : 'rgba(88, 166, 255, 0.5)';
            overlayCtx.lineWidth = 1;

            for (let y = step; y < overlayCanvas.height; y += step) {
                for (let x = step; x < overlayCanvas.width; x += step) {
                    let Ex = 0, Ey = 0;

                    for (let obj of state.objects) {
                        const dx = x - obj.x;
                        const dy = y - obj.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 20) continue;

                        const E = obj.charge / (dist * dist);
                        Ex += (dx / dist) * E;
                        Ey += (dy / dist) * E;
                    }

                    const len = Math.sqrt(Ex * Ex + Ey * Ey);
                    if (len > 0.001) {
                        const scale = Math.min(15, len * 500);
                        overlayCtx.beginPath();
                        overlayCtx.moveTo(x, y);
                        overlayCtx.lineTo(x + (Ex / len) * scale, y + (Ey / len) * scale);
                        overlayCtx.stroke();
                    }
                }
            }
        }

        function renderGraph() {
            const w = graphCanvas.width;
            const h = graphCanvas.height;

            graphCtx.fillStyle = getComputedStyle(document.body).getPropertyValue('--bg-tertiary');
            graphCtx.fillRect(0, 0, w, h);

            if (state.graphData.time.length < 2) return;

            const data = state.graphData;
            const maxTime = Math.max(...data.time);
            const allValues = [...data.ke, ...data.pe, ...data.total];
            const maxVal = Math.max(...allValues, 1);

            // Draw lines
            const drawLine = (values, color) => {
                graphCtx.beginPath();
                for (let i = 0; i < values.length; i++) {
                    const x = (data.time[i] / maxTime) * w;
                    const y = h - (values[i] / maxVal) * (h - 10) - 5;
                    if (i === 0) graphCtx.moveTo(x, y);
                    else graphCtx.lineTo(x, y);
                }
                graphCtx.strokeStyle = color;
                graphCtx.lineWidth = 2;
                graphCtx.stroke();
            };

            drawLine(data.ke, '#3fb950');
            drawLine(data.pe, '#f85149');
            drawLine(data.total, '#58a6ff');
        }

        // ============================================================
        // UI UPDATE
        // ============================================================

        function updateUI() {
            // Simulation info
            document.getElementById('info-time').textContent = state.time.toFixed(2) + 's';
            document.getElementById('info-fps').textContent = fps;

            const objectCount = state.mode === 'pendulum' ? state.pendulums.length :
                               state.mode === 'waves' ? state.waveSources.length :
                               state.mode === 'fluid' ? state.fluidParticles.length :
                               state.objects.length;
            document.getElementById('info-objects').textContent = objectCount;

            // Calculate energies
            let ke = 0, pe = 0;

            if (state.mode === 'particles' || state.mode === 'em') {
                for (let obj of state.objects) {
                    const v = Math.sqrt(obj.vx * obj.vx + obj.vy * obj.vy) / pixelsPerMeter;
                    ke += 0.5 * obj.mass * v * v;
                    pe += obj.mass * state.constants.gravity * (canvas.height - obj.y) / pixelsPerMeter;
                }
            } else if (state.mode === 'pendulum') {
                for (let pend of state.pendulums) {
                    const h = (pend.bobY - pend.pivotY) / pixelsPerMeter;
                    const v = pend.angularVel * pend.length;
                    ke += 0.5 * pend.mass * v * v;
                    pe += pend.mass * state.constants.gravity * (pend.length - h);
                }
            }

            document.getElementById('info-ke').textContent = formatScientific(ke) + ' J';
            document.getElementById('info-pe').textContent = formatScientific(pe) + ' J';

            // Recording time
            if (state.recording) {
                const recTime = state.recordedData.length / 60;
                const mins = Math.floor(recTime / 60);
                const secs = Math.floor(recTime % 60);
                document.getElementById('rec-time').textContent =
                    `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }

            // Frame count
            document.getElementById('frame-count').textContent = state.recordedData.length;

            // Update object list
            updateObjectList();

            // Measurement display
            if (measurement.active) {
                const dist = Math.sqrt(
                    Math.pow(measurement.endX - measurement.startX, 2) +
                    Math.pow(measurement.endY - measurement.startY, 2)
                ) / pixelsPerMeter;

                const angle = Math.atan2(
                    measurement.startY - measurement.endY,
                    measurement.endX - measurement.startX
                ) * 180 / Math.PI;

                document.getElementById('meas-dist').textContent = dist.toFixed(3) + ' m';
                document.getElementById('meas-angle').textContent = angle.toFixed(1) + ' deg';
                document.getElementById('measurement-display').style.display = 'block';
            } else {
                document.getElementById('measurement-display').style.display = 'none';
            }
        }

        function updateObjectList() {
            const list = document.getElementById('object-list');
            const items = state.mode === 'pendulum' ? state.pendulums :
                         state.mode === 'waves' ? state.waveSources :
                         state.objects;

            if (items.length === 0) {
                list.innerHTML = '<div style="color: var(--text-secondary); font-size: 11px; padding: 8px;">No objects yet. Click canvas to add.</div>';
                return;
            }

            list.innerHTML = items.map((obj, i) => `
                <div class="object-item ${obj === state.selectedObject ? 'selected' : ''}"
                     onclick="selectObject(${i})">
                    <div class="object-color" style="background: ${obj.color || '#58a6ff'}"></div>
                    <div class="object-info">
                        <div class="name">${obj.name || 'Object ' + (i + 1)}</div>
                        <div class="details">${getObjectDetails(obj)}</div>
                    </div>
                    <button class="delete-btn" onclick="event.stopPropagation(); deleteObject(${i})">X</button>
                </div>
            `).join('');
        }

        function getObjectDetails(obj) {
            if (state.mode === 'pendulum') {
                return `L: ${obj.length.toFixed(1)}m, m: ${obj.mass.toFixed(1)}kg`;
            } else if (state.mode === 'waves') {
                return `Source`;
            } else {
                const v = Math.sqrt(obj.vx * obj.vx + obj.vy * obj.vy) / pixelsPerMeter;
                return `m: ${obj.mass.toFixed(1)}kg, v: ${v.toFixed(2)}m/s`;
            }
        }

        function formatScientific(num) {
            if (Math.abs(num) < 0.001 || Math.abs(num) > 10000) {
                return num.toExponential(2);
            }
            return num.toFixed(2);
        }

        // ============================================================
        // EVENT HANDLERS
        // ============================================================

        function onMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
            mouse.startX = mouse.x;
            mouse.startY = mouse.y;
            mouse.dragging = true;

            switch (state.tool) {
                case 'add':
                    // Will add on mouseup
                    break;

                case 'select':
                    const clicked = findObjectAt(mouse.x, mouse.y);
                    state.selectedObject = clicked;
                    mouse.dragObject = clicked;
                    break;

                case 'measure':
                    measurement.active = true;
                    measurement.startX = mouse.x;
                    measurement.startY = mouse.y;
                    measurement.endX = mouse.x;
                    measurement.endY = mouse.y;
                    break;

                case 'velocity':
                    mouse.dragObject = findObjectAt(mouse.x, mouse.y);
                    break;

                case 'force':
                    mouse.dragObject = findObjectAt(mouse.x, mouse.y);
                    break;

                case 'delete':
                    const toDelete = findObjectAt(mouse.x, mouse.y);
                    if (toDelete) {
                        const idx = state.objects.indexOf(toDelete);
                        if (idx > -1) state.objects.splice(idx, 1);
                    }
                    break;
            }
        }

        function onMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;

            if (mouse.dragging) {
                if (state.tool === 'select' && mouse.dragObject && !mouse.dragObject.fixed) {
                    mouse.dragObject.x = mouse.x;
                    mouse.dragObject.y = mouse.y;
                    mouse.dragObject.vx = 0;
                    mouse.dragObject.vy = 0;
                }

                if (state.tool === 'measure') {
                    measurement.endX = mouse.x;
                    measurement.endY = mouse.y;
                }
            }
        }

        function onMouseUp(e) {
            if (state.tool === 'add' && !mouse.dragObject) {
                addObjectAt(mouse.startX, mouse.startY, mouse.x, mouse.y);
            }

            if (state.tool === 'velocity' && mouse.dragObject) {
                const dx = mouse.x - mouse.dragObject.x;
                const dy = mouse.y - mouse.dragObject.y;
                mouse.dragObject.vx = dx * 2;
                mouse.dragObject.vy = dy * 2;
            }

            if (state.tool === 'force' && mouse.dragObject && !mouse.dragObject.fixed) {
                const dx = mouse.x - mouse.startX;
                const dy = mouse.y - mouse.startY;
                mouse.dragObject.vx += dx * 0.5;
                mouse.dragObject.vy += dy * 0.5;
            }

            mouse.dragging = false;
            mouse.dragObject = null;
        }

        function onWheel(e) {
            e.preventDefault();
            pixelsPerMeter = Math.max(10, Math.min(200, pixelsPerMeter - e.deltaY * 0.1));
        }

        function onTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            mouse.x = touch.clientX - rect.left;
            mouse.y = touch.clientY - rect.top;
            mouse.startX = mouse.x;
            mouse.startY = mouse.y;
            mouse.dragging = true;
        }

        function onTouchMove(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            mouse.x = touch.clientX - rect.left;
            mouse.y = touch.clientY - rect.top;
        }

        function onTouchEnd(e) {
            if (state.tool === 'add') {
                addObjectAt(mouse.startX, mouse.startY, mouse.x, mouse.y);
            }
            mouse.dragging = false;
        }

        function onKeyDown(e) {
            switch (e.key) {
                case ' ':
                    e.preventDefault();
                    toggleSimulation();
                    break;
                case 'r':
                case 'R':
                    resetSimulation();
                    break;
                case 'g':
                case 'G':
                    state.display.grid = !state.display.grid;
                    document.getElementById('show-grid').checked = state.display.grid;
                    break;
                case 'v':
                case 'V':
                    state.display.vectors = !state.display.vectors;
                    document.getElementById('show-vectors').checked = state.display.vectors;
                    break;
                case 'Delete':
                case 'Backspace':
                    if (state.selectedObject) {
                        const idx = state.objects.indexOf(state.selectedObject);
                        if (idx > -1) {
                            state.objects.splice(idx, 1);
                            state.selectedObject = null;
                        }
                    }
                    break;
            }
        }

        // ============================================================
        // OBJECT MANAGEMENT
        // ============================================================

        function findObjectAt(x, y) {
            const items = state.mode === 'pendulum' ? state.pendulums :
                         state.mode === 'waves' ? state.waveSources :
                         state.objects;

            for (let obj of items) {
                if (state.mode === 'pendulum') {
                    const dx = x - obj.bobX;
                    const dy = y - obj.bobY;
                    if (Math.sqrt(dx * dx + dy * dy) < 20) return obj;
                } else {
                    const dx = x - obj.x;
                    const dy = y - obj.y;
                    const r = obj.radius || 10;
                    if (Math.sqrt(dx * dx + dy * dy) < r) return obj;
                }
            }
            return null;
        }

        function addObjectAt(startX, startY, endX, endY) {
            const colors = ['#58a6ff', '#3fb950', '#f85149', '#d29922', '#a371f7', '#39c5cf'];

            if (state.mode === 'waves') {
                state.waveSources.push({
                    x: startX,
                    y: startY,
                    phase: 0,
                    name: 'Source ' + (state.waveSources.length + 1),
                    color: colors[state.waveSources.length % colors.length]
                });
                return;
            }

            if (state.mode === 'pendulum') {
                const len = parseFloat(document.getElementById('pend-length').value);
                const mass = parseFloat(document.getElementById('pend-mass').value);
                const angle = parseFloat(document.getElementById('init-angle').value) * Math.PI / 180;

                state.pendulums.push({
                    pivotX: startX,
                    pivotY: startY,
                    length: len,
                    mass: mass,
                    angle: angle,
                    angularVel: 0,
                    bobX: startX + len * pixelsPerMeter * Math.sin(angle),
                    bobY: startY + len * pixelsPerMeter * Math.cos(angle),
                    name: 'Pendulum ' + (state.pendulums.length + 1),
                    color: colors[state.pendulums.length % colors.length]
                });
                return;
            }

            if (state.mode === 'fluid') {
                // Add splash of particles at click location
                for (let i = 0; i < 20; i++) {
                    state.fluidParticles.push({
                        x: startX + (Math.random() - 0.5) * 30,
                        y: startY + (Math.random() - 0.5) * 30,
                        vx: (Math.random() - 0.5) * 100,
                        vy: (Math.random() - 0.5) * 100
                    });
                }
                return;
            }

            // Particles / EM mode
            const mass = parseFloat(document.getElementById('new-mass').value) || 1;
            const radius = parseFloat(document.getElementById('new-radius').value) || 20;
            const charge = parseFloat(document.getElementById('new-charge').value) || 0;
            const fixed = document.getElementById('new-fixed').checked;

            const vx = (endX - startX) * 2;
            const vy = (endY - startY) * 2;

            state.objects.push({
                x: startX,
                y: startY,
                vx: fixed ? 0 : vx,
                vy: fixed ? 0 : vy,
                mass: mass,
                radius: radius,
                charge: charge,
                fixed: fixed,
                name: 'Object ' + (state.objects.length + 1),
                color: charge > 0 ? '#f85149' : charge < 0 ? '#58a6ff' : colors[state.objects.length % colors.length]
            });
        }

        function selectObject(idx) {
            const items = state.mode === 'pendulum' ? state.pendulums :
                         state.mode === 'waves' ? state.waveSources :
                         state.objects;
            state.selectedObject = items[idx];
        }

        function deleteObject(idx) {
            if (state.mode === 'pendulum') {
                state.pendulums.splice(idx, 1);
            } else if (state.mode === 'waves') {
                state.waveSources.splice(idx, 1);
            } else {
                state.objects.splice(idx, 1);
            }
            state.selectedObject = null;
        }

        // ============================================================
        // CONTROLS
        // ============================================================

        function setMode(mode) {
            state.mode = mode;

            // Update tab UI
            document.querySelectorAll('.mode-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.mode === mode);
            });

            // Show/hide controls
            document.getElementById('particle-controls').style.display =
                (mode === 'particles') ? 'block' : 'none';
            document.getElementById('em-controls').style.display =
                (mode === 'em') ? 'block' : 'none';
            document.getElementById('wave-controls').style.display =
                (mode === 'waves') ? 'block' : 'none';
            document.getElementById('pendulum-controls').style.display =
                (mode === 'pendulum') ? 'block' : 'none';
            document.getElementById('fluid-controls').style.display =
                (mode === 'fluid') ? 'block' : 'none';

            state.selectedObject = null;
            saveState();
        }

        function setTool(tool) {
            state.tool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tool === tool);
            });

            if (tool !== 'measure') {
                measurement.active = false;
            }
        }

        function toggleSimulation() {
            state.running = !state.running;
            document.getElementById('play-icon').textContent = state.running ? '||' : '>';
            document.getElementById('play-text').textContent = state.running ? 'Pause' : 'Play';
        }

        function resetSimulation() {
            state.time = 0;
            state.frameCount = 0;
            state.objects = [];
            state.waveSources = [];
            state.pendulums = [];
            state.fluidParticles = [];
            state.selectedObject = null;
            state.graphData = { time: [], ke: [], pe: [], total: [] };
            saveState();
        }

        function stepSimulation() {
            if (!state.running) {
                update(1/60);
                state.time += 1/60;
            }
        }

        function updateConstant(name, value) {
            const num = parseFloat(value);

            switch (name) {
                case 'gravity':
                    state.constants.gravity = num;
                    document.getElementById('gravity-val').textContent = num.toFixed(2);
                    break;
                case 'air':
                    state.constants.airResistance = num;
                    document.getElementById('air-val').textContent = num.toFixed(3);
                    break;
                case 'restitution':
                    state.constants.restitution = num;
                    document.getElementById('restitution-val').textContent = num.toFixed(2);
                    break;
                case 'friction':
                    state.constants.friction = num;
                    document.getElementById('friction-val').textContent = num.toFixed(2);
                    break;
                case 'timescale':
                    state.constants.timeScale = num;
                    document.getElementById('timescale-val').textContent = num.toFixed(1);
                    break;
                case 'coulomb':
                    state.constants.coulomb = num * 1e9;
                    document.getElementById('coulomb-val').textContent = num.toFixed(2) + 'e9';
                    break;
                case 'field':
                    state.constants.fieldStrength = num;
                    document.getElementById('field-val').textContent = num.toFixed(1);
                    break;
                case 'frequency':
                    state.constants.frequency = num;
                    document.getElementById('freq-val').textContent = num.toFixed(1);
                    break;
                case 'wavelength':
                    state.constants.wavelength = num;
                    document.getElementById('wavelength-val').textContent = num.toFixed(1);
                    break;
                case 'amplitude':
                    state.constants.amplitude = num;
                    document.getElementById('amplitude-val').textContent = num.toFixed(0);
                    break;
                case 'damping':
                    state.constants.damping = num;
                    document.getElementById('damping-val').textContent = num.toFixed(3);
                    break;
                case 'pendLength':
                    state.constants.pendLength = num;
                    document.getElementById('length-val').textContent = num.toFixed(1);
                    break;
                case 'pendMass':
                    state.constants.pendMass = num;
                    document.getElementById('mass-val').textContent = num.toFixed(1);
                    break;
                case 'initAngle':
                    state.constants.initAngle = num;
                    document.getElementById('angle-val').textContent = num.toFixed(0);
                    break;
                case 'viscosity':
                    state.constants.viscosity = num;
                    document.getElementById('viscosity-val').textContent = num.toFixed(2);
                    break;
                case 'pressure':
                    state.constants.pressure = num;
                    document.getElementById('pressure-val').textContent = num.toFixed(0);
                    break;
                case 'particleCount':
                    state.constants.particleCount = num;
                    document.getElementById('pcount-val').textContent = num.toFixed(0);
                    break;
            }

            saveState();
        }

        function updateDisplay(name, value) {
            state.display[name] = value;
            saveState();
        }

        function toggleTheme() {
            state.theme = state.theme === 'dark' ? 'light' : 'dark';
            document.body.classList.toggle('theme-light', state.theme === 'light');
            saveState();
        }

        // ============================================================
        // PRESETS
        // ============================================================

        function loadPreset(preset) {
            resetSimulation();

            switch (preset) {
                case 'collision':
                    setMode('particles');
                    state.objects = [
                        { x: 200, y: 300, vx: 200, vy: 0, mass: 1, radius: 25, charge: 0, fixed: false, name: 'Ball 1', color: '#58a6ff' },
                        { x: 600, y: 300, vx: -100, vy: 0, mass: 2, radius: 35, charge: 0, fixed: false, name: 'Ball 2', color: '#3fb950' }
                    ];
                    break;

                case 'orbit':
                    setMode('particles');
                    const cx = canvas.width / 2;
                    const cy = canvas.height / 2;
                    state.objects = [
                        { x: cx, y: cy, vx: 0, vy: 0, mass: 100, radius: 40, charge: 0, fixed: true, name: 'Sun', color: '#d29922' },
                        { x: cx + 150, y: cy, vx: 0, vy: 150, mass: 1, radius: 15, charge: 0, fixed: false, name: 'Planet', color: '#58a6ff' }
                    ];
                    state.constants.gravity = 0; // Use gravitational attraction instead
                    // Add gravitational attraction in update
                    break;

                case 'spring':
                    setMode('particles');
                    const springObj = {
                        x: canvas.width / 2, y: 300, vx: 100, vy: 0,
                        mass: 1, radius: 20, charge: 0, fixed: false,
                        name: 'Mass', color: '#a371f7',
                        spring: {
                            anchor: { x: canvas.width / 2, y: 100 },
                            k: 50,
                            restLength: 150,
                            damping: 0.02
                        }
                    };
                    state.objects = [springObj];
                    state.constants.gravity = 9.81;
                    break;

                case 'pendulumDemo':
                    setMode('pendulum');
                    state.pendulums = [
                        { pivotX: canvas.width/2 - 100, pivotY: 100, length: 2, mass: 1, angle: Math.PI/4, angularVel: 0, bobX: 0, bobY: 0, name: 'Pendulum 1', color: '#58a6ff' },
                        { pivotX: canvas.width/2 + 100, pivotY: 100, length: 2.5, mass: 1.5, angle: Math.PI/3, angularVel: 0, bobX: 0, bobY: 0, name: 'Pendulum 2', color: '#3fb950' }
                    ];
                    // Initialize bob positions
                    for (let p of state.pendulums) {
                        p.bobX = p.pivotX + p.length * pixelsPerMeter * Math.sin(p.angle);
                        p.bobY = p.pivotY + p.length * pixelsPerMeter * Math.cos(p.angle);
                    }
                    break;

                case 'charges':
                    setMode('em');
                    state.objects = [
                        { x: canvas.width/2 - 100, y: canvas.height/2, vx: 0, vy: 50, mass: 1, radius: 20, charge: 1, fixed: false, name: '+Q1', color: '#f85149' },
                        { x: canvas.width/2 + 100, y: canvas.height/2, vx: 0, vy: -50, mass: 1, radius: 20, charge: 1, fixed: false, name: '+Q2', color: '#f85149' },
                        { x: canvas.width/2, y: canvas.height/2 - 100, vx: 50, vy: 0, mass: 1, radius: 20, charge: -1, fixed: false, name: '-Q3', color: '#58a6ff' }
                    ];
                    break;

                case 'waves':
                    setMode('waves');
                    state.waveSources = [
                        { x: canvas.width/3, y: canvas.height/2, phase: 0, name: 'Source 1', color: '#58a6ff' },
                        { x: 2*canvas.width/3, y: canvas.height/2, phase: 0, name: 'Source 2', color: '#3fb950' }
                    ];
                    break;
            }

            saveState();
        }

        // ============================================================
        // RECORDING & EXPORT
        // ============================================================

        function toggleRecording() {
            state.recording = !state.recording;

            const btn = document.getElementById('record-btn');
            const indicator = document.getElementById('rec-indicator');

            if (state.recording) {
                btn.textContent = 'Stop';
                btn.classList.add('danger');
                indicator.classList.remove('inactive');
            } else {
                btn.textContent = 'Record';
                btn.classList.remove('danger');
                indicator.classList.add('inactive');
            }
        }

        function recordFrame() {
            const frame = {
                time: state.time,
                objects: state.objects.map(obj => ({
                    name: obj.name,
                    x: obj.x / pixelsPerMeter,
                    y: (canvas.height - obj.y) / pixelsPerMeter,
                    vx: obj.vx / pixelsPerMeter,
                    vy: -obj.vy / pixelsPerMeter,
                    mass: obj.mass
                })),
                ke: 0,
                pe: 0
            };

            // Calculate energies
            for (let obj of state.objects) {
                const v = Math.sqrt(obj.vx * obj.vx + obj.vy * obj.vy) / pixelsPerMeter;
                frame.ke += 0.5 * obj.mass * v * v;
                frame.pe += obj.mass * state.constants.gravity * (canvas.height - obj.y) / pixelsPerMeter;
            }

            state.recordedData.push(frame);

            // Update timeline visualization
            updateTimeline();
        }

        function updateTimeline() {
            const container = document.getElementById('timeline-data');
            const maxFrames = 200;

            if (state.recordedData.length === 0) {
                container.innerHTML = '';
                return;
            }

            const step = Math.max(1, Math.floor(state.recordedData.length / maxFrames));
            let html = '';

            for (let i = 0; i < state.recordedData.length; i += step) {
                const frame = state.recordedData[i];
                const height = Math.min(100, (frame.ke + frame.pe) * 2);
                html += `<div class="timeline-bar" style="height: ${height}%"></div>`;
            }

            container.innerHTML = html;
        }

        function clearRecording() {
            state.recordedData = [];
            state.recording = false;
            document.getElementById('record-btn').textContent = 'Record';
            document.getElementById('record-btn').classList.remove('danger');
            document.getElementById('rec-indicator').classList.add('inactive');
            document.getElementById('rec-time').textContent = '00:00';
            document.getElementById('timeline-data').innerHTML = '';
        }

        function updateGraphData() {
            let ke = 0, pe = 0;

            if (state.mode === 'particles' || state.mode === 'em') {
                for (let obj of state.objects) {
                    const v = Math.sqrt(obj.vx * obj.vx + obj.vy * obj.vy) / pixelsPerMeter;
                    ke += 0.5 * obj.mass * v * v;
                    pe += obj.mass * state.constants.gravity * (canvas.height - obj.y) / pixelsPerMeter;
                }
            }

            state.graphData.time.push(state.time);
            state.graphData.ke.push(ke);
            state.graphData.pe.push(pe);
            state.graphData.total.push(ke + pe);

            // Keep last 200 data points
            if (state.graphData.time.length > 200) {
                state.graphData.time.shift();
                state.graphData.ke.shift();
                state.graphData.pe.shift();
                state.graphData.total.shift();
            }
        }

        function exportCSV() {
            if (state.recordedData.length === 0) {
                alert('No recorded data to export. Click Record to start capturing data.');
                return;
            }

            let csv = 'Time (s),Object,X (m),Y (m),Vx (m/s),Vy (m/s),KE (J),PE (J)\n';

            for (let frame of state.recordedData) {
                for (let obj of frame.objects) {
                    csv += `${frame.time.toFixed(4)},${obj.name},${obj.x.toFixed(4)},${obj.y.toFixed(4)},${obj.vx.toFixed(4)},${obj.vy.toFixed(4)},${frame.ke.toFixed(4)},${frame.pe.toFixed(4)}\n`;
                }
            }

            downloadFile(csv, `${APP_NAME}-data-${Date.now()}.csv`, 'text/csv');
        }

        function exportJSON() {
            const data = {
                metadata: {
                    app: APP_NAME,
                    version: '1.0',
                    exportDate: new Date().toISOString(),
                    mode: state.mode,
                    constants: state.constants
                },
                frames: state.recordedData
            };

            downloadFile(JSON.stringify(data, null, 2), `${APP_NAME}-data-${Date.now()}.json`, 'application/json');
        }

        function exportImage() {
            const link = document.createElement('a');
            link.download = `${APP_NAME}-screenshot-${Date.now()}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        // ============================================================
        // SAVE/LOAD
        // ============================================================

        function saveState() {
            const saveData = {
                mode: state.mode,
                constants: state.constants,
                display: state.display,
                theme: state.theme,
                objects: state.objects,
                waveSources: state.waveSources,
                pendulums: state.pendulums
            };
            // Cycle 1: Wrap localStorage in try-catch for private browsing support
            try {
                localStorage.setItem(APP_NAME, JSON.stringify(saveData));
            } catch (e) {
                console.warn('Failed to save state:', e);
            }
        }

        function loadState() {
            // Cycle 1: Wrap localStorage in try-catch for private browsing support
            let saved = null;
            try {
                saved = localStorage.getItem(APP_NAME);
            } catch (e) {
                console.warn('localStorage unavailable:', e);
            }
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    Object.assign(state.constants, data.constants || {});
                    Object.assign(state.display, data.display || {});
                    state.mode = data.mode || 'particles';
                    state.theme = data.theme || 'dark';
                    state.objects = data.objects || [];
                    state.waveSources = data.waveSources || [];
                    state.pendulums = data.pendulums || [];
                } catch (e) {
                    console.error('Failed to load saved state:', e);
                }
            }
        }

        function exportData() {
            const data = {
                app: APP_NAME,
                version: '1.0',
                exportDate: new Date().toISOString(),
                state: {
                    mode: state.mode,
                    constants: state.constants,
                    display: state.display,
                    theme: state.theme,
                    objects: state.objects,
                    waveSources: state.waveSources,
                    pendulums: state.pendulums
                }
            };

            downloadFile(JSON.stringify(data, null, 2), `${APP_NAME}-export-${Date.now()}.json`, 'application/json');
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);

                    if (data.state) {
                        Object.assign(state.constants, data.state.constants || {});
                        Object.assign(state.display, data.state.display || {});
                        state.mode = data.state.mode || 'particles';
                        state.theme = data.state.theme || 'dark';
                        state.objects = data.state.objects || [];
                        state.waveSources = data.state.waveSources || [];
                        state.pendulums = data.state.pendulums || [];

                        // Apply theme
                        document.body.classList.toggle('theme-light', state.theme === 'light');

                        // Update mode UI
                        setMode(state.mode);

                        saveState();
                        alert('Data imported successfully!');
                    }
                } catch (error) {
                    alert('Invalid JSON file: ' + error.message);
                }
            };
            // Cycle 1: Add error handler for file read failures
            reader.onerror = () => {
                alert('Failed to read file');
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        function saveExperiment() {
            const name = prompt('Enter experiment name:', 'My Experiment');
            if (!name) return;

            const experiment = {
                name: name,
                date: new Date().toISOString(),
                mode: state.mode,
                constants: state.constants,
                objects: state.objects,
                waveSources: state.waveSources,
                pendulums: state.pendulums
            };

            downloadFile(JSON.stringify(experiment, null, 2), `experiment-${name.replace(/\s+/g, '-').toLowerCase()}.json`, 'application/json');
        }

        function loadExperiment(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const exp = JSON.parse(e.target.result);

                    state.mode = exp.mode || 'particles';
                    Object.assign(state.constants, exp.constants || {});
                    state.objects = exp.objects || [];
                    state.waveSources = exp.waveSources || [];
                    state.pendulums = exp.pendulums || [];
                    state.time = 0;

                    setMode(state.mode);
                    saveState();

                    alert(`Loaded experiment: ${exp.name || 'Unknown'}`);
                } catch (error) {
                    alert('Invalid experiment file: ' + error.message);
                }
            };
            // Cycle 1: Add error handler for file read failures
            reader.onerror = () => {
                alert('Failed to read experiment file');
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        function downloadFile(content, filename, type) {
            const blob = new Blob([content], { type: type });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.click();
            URL.revokeObjectURL(url);
        }

        // ============================================================
        // HELP
        // ============================================================

        function showHelp() {
            document.getElementById('help-modal').classList.remove('hidden');
        }

        function hideHelp(event) {
            if (!event || event.target === document.getElementById('help-modal')) {
                document.getElementById('help-modal').classList.add('hidden');
            }
        }

        function updateGraphType(type) {
            // Update legend based on graph type
            const legend = document.querySelector('.graph-legend');
            switch (type) {
                case 'energy':
                    legend.innerHTML = `
                        <div class="legend-item"><div class="legend-color" style="background: #3fb950;"></div><span>Kinetic</span></div>
                        <div class="legend-item"><div class="legend-color" style="background: #f85149;"></div><span>Potential</span></div>
                        <div class="legend-item"><div class="legend-color" style="background: #58a6ff;"></div><span>Total</span></div>
                    `;
                    break;
                case 'velocity':
                    legend.innerHTML = `
                        <div class="legend-item"><div class="legend-color" style="background: #58a6ff;"></div><span>Velocity</span></div>
                    `;
                    break;
                case 'position':
                    legend.innerHTML = `
                        <div class="legend-item"><div class="legend-color" style="background: #3fb950;"></div><span>X Position</span></div>
                        <div class="legend-item"><div class="legend-color" style="background: #f85149;"></div><span>Y Position</span></div>
                    `;
                    break;
                case 'momentum':
                    legend.innerHTML = `
                        <div class="legend-item"><div class="legend-color" style="background: #a371f7;"></div><span>Momentum</span></div>
                    `;
                    break;
            }
        }

        // Initialize on load
        window.addEventListener('load', init);
    </script>
</body>
</html>
