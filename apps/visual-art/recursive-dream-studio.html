<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recursive Dream Studio</title>
    <meta name="description" content="Create infinite recursive art where everything contains smaller versions of itself. Zoom forever into fractal dreamscapes of your own design.">
    <meta name="theme-color" content="#0a0a0f">
    <meta name="color-scheme" content="dark">
    <style>
        :root {
            --bg-dark: #0a0a0f;
            --bg-panel: #12121a;
            --accent: #a855f7;
            --accent-glow: #c084fc;
            --text: #e2e8f0;
            --text-dim: #64748b;
            --border: #1e1e2e;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-dark);
            color: var(--text);
            height: 100vh;
            overflow: hidden;
            display: flex;
        }

        /* Toolbar */
        #toolbar {
            width: 72px;
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 16px 0;
            gap: 8px;
            z-index: 100;
        }

        .tool-btn {
            width: 48px;
            height: 48px;
            border: none;
            border-radius: 12px;
            background: transparent;
            color: var(--text-dim);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.2s;
            position: relative;
        }

        .tool-btn:hover {
            background: rgba(168, 85, 247, 0.1);
            color: var(--accent);
        }

        .tool-btn.active {
            background: rgba(168, 85, 247, 0.2);
            color: var(--accent);
            box-shadow: 0 0 20px rgba(168, 85, 247, 0.3);
        }

        .tool-btn svg {
            width: 24px;
            height: 24px;
        }

        .separator {
            width: 36px;
            height: 1px;
            background: var(--border);
            margin: 8px 0;
        }

        /* Color Picker */
        #color-picker-container {
            margin-top: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        #color-picker {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            background: var(--accent);
            box-shadow: 0 0 15px var(--accent);
        }

        #color-picker::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        #color-picker::-webkit-color-swatch {
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 50%;
        }

        /* Main Canvas Area */
        #canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #0a0a0f 100%);
        }

        #main-canvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
        }

        #ui-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        /* Right Panel */
        #right-panel {
            width: 280px;
            background: var(--bg-panel);
            border-left: 1px solid var(--border);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
        }

        .panel-section {
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 16px;
        }

        .panel-section h3 {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--text-dim);
            margin-bottom: 12px;
        }

        .slider-group {
            margin-bottom: 12px;
        }

        .slider-group label {
            display: flex;
            justify-content: space-between;
            font-size: 13px;
            margin-bottom: 6px;
        }

        .slider-group label span {
            color: var(--accent);
            font-weight: 600;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: var(--border);
            appearance: none;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent);
            box-shadow: 0 0 10px var(--accent);
            cursor: pointer;
        }

        /* Portal Frame Preview */
        #portal-preview {
            width: 100%;
            aspect-ratio: 16/9;
            border: 2px dashed var(--accent);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-dim);
            font-size: 12px;
            margin-bottom: 12px;
            position: relative;
            overflow: hidden;
            background: rgba(168, 85, 247, 0.05);
        }

        /* Zoom Controls */
        #zoom-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 12px;
            background: rgba(18, 18, 26, 0.9);
            backdrop-filter: blur(10px);
            padding: 12px 20px;
            border-radius: 50px;
            border: 1px solid var(--border);
        }

        #zoom-controls button {
            width: 36px;
            height: 36px;
            border: none;
            border-radius: 50%;
            background: var(--border);
            color: var(--text);
            cursor: pointer;
            font-size: 18px;
            transition: all 0.2s;
        }

        #zoom-controls button:hover {
            background: var(--accent);
            box-shadow: 0 0 15px var(--accent);
        }

        #zoom-level {
            font-family: 'SF Mono', monospace;
            font-size: 14px;
            min-width: 100px;
            text-align: center;
        }

        #depth-indicator {
            font-size: 11px;
            color: var(--accent);
        }

        /* Action Buttons */
        .action-btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .action-btn.primary {
            background: linear-gradient(135deg, var(--accent), #7c3aed);
            color: white;
        }

        .action-btn.primary:hover {
            box-shadow: 0 0 30px rgba(168, 85, 247, 0.5);
            transform: translateY(-2px);
        }

        .action-btn.secondary {
            background: var(--border);
            color: var(--text);
        }

        .action-btn.secondary:hover {
            background: rgba(168, 85, 247, 0.2);
        }

        /* Minimap */
        #minimap {
            width: 100%;
            aspect-ratio: 1;
            background: var(--bg-dark);
            border-radius: 8px;
            border: 1px solid var(--border);
            position: relative;
            overflow: hidden;
        }

        #minimap-canvas {
            width: 100%;
            height: 100%;
        }

        #minimap-viewport {
            position: absolute;
            border: 2px solid var(--accent);
            background: rgba(168, 85, 247, 0.1);
            pointer-events: none;
        }

        /* Instructions Overlay */
        #instructions {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(18, 18, 26, 0.95);
            backdrop-filter: blur(10px);
            padding: 16px 24px;
            border-radius: 12px;
            border: 1px solid var(--border);
            text-align: center;
            z-index: 50;
            max-width: 500px;
            transition: opacity 0.3s;
        }

        #instructions h2 {
            color: var(--accent);
            margin-bottom: 8px;
            font-size: 16px;
        }

        #instructions p {
            font-size: 13px;
            color: var(--text-dim);
            line-height: 1.5;
        }

        #instructions.hidden {
            opacity: 0;
            pointer-events: none;
        }

        /* Recording Indicator */
        #recording-indicator {
            position: absolute;
            top: 20px;
            right: 300px;
            background: #ef4444;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            display: none;
            align-items: center;
            gap: 8px;
            animation: pulse 1s infinite;
        }

        #recording-indicator::before {
            content: '';
            width: 8px;
            height: 8px;
            background: white;
            border-radius: 50%;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Depth Legend */
        #depth-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .depth-chip {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            background: var(--border);
        }

        .depth-chip.active {
            background: var(--accent);
            color: white;
        }

        /* Loading Animation */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
        }

        .loading.active {
            display: block;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Brush Size Indicator */
        #brush-indicator {
            position: absolute;
            border: 2px solid var(--accent);
            border-radius: 50%;
            pointer-events: none;
            display: none;
            box-shadow: 0 0 10px var(--accent);
        }

        /* Shape Preview */
        #shape-preview {
            position: absolute;
            border: 2px dashed var(--accent);
            pointer-events: none;
            display: none;
        }
    </style>
</head>
<body>
    <!-- Toolbar -->
    <div id="toolbar">
        <button class="tool-btn active" data-tool="brush" title="Brush (B)">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 19l7-7 3 3-7 7-3-3z"/>
                <path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/>
            </svg>
        </button>
        <button class="tool-btn" data-tool="eraser" title="Eraser (E)">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M20 20H7L3 16a1 1 0 010-1.4l10-10a1 1 0 011.4 0l7 7a1 1 0 010 1.4L14 20"/>
            </svg>
        </button>
        <button class="tool-btn" data-tool="line" title="Line (L)">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="5" y1="19" x2="19" y2="5"/>
            </svg>
        </button>
        <button class="tool-btn" data-tool="rect" title="Rectangle (R)">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="3" width="18" height="18" rx="2"/>
            </svg>
        </button>
        <button class="tool-btn" data-tool="ellipse" title="Ellipse (O)">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <ellipse cx="12" cy="12" rx="9" ry="6"/>
            </svg>
        </button>
        <button class="tool-btn" data-tool="triangle" title="Triangle (T)">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 3L22 21H2L12 3z"/>
            </svg>
        </button>

        <div class="separator"></div>

        <button class="tool-btn" data-tool="portal" title="Recursion Portal (P)">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="9"/>
                <circle cx="12" cy="12" r="5"/>
                <circle cx="12" cy="12" r="2"/>
            </svg>
        </button>

        <div class="separator"></div>

        <button class="tool-btn" data-tool="pan" title="Pan (Space)">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M5 9l-3 3 3 3"/>
                <path d="M9 5l3-3 3 3"/>
                <path d="M15 19l3 3-3 3"/>
                <path d="M19 9l3 3-3 3"/>
                <path d="M2 12h20"/>
                <path d="M12 2v20"/>
            </svg>
        </button>

        <div id="color-picker-container">
            <input type="color" id="color-picker" value="#a855f7">
        </div>
    </div>

    <!-- Canvas Container -->
    <div id="canvas-container">
        <canvas id="main-canvas"></canvas>
        <canvas id="ui-canvas"></canvas>

        <div id="brush-indicator"></div>
        <div id="shape-preview"></div>

        <div id="instructions">
            <h2>Welcome to the Recursive Dream Studio</h2>
            <p>Draw anything, then place a <strong>Recursion Portal</strong> to create infinite depth.
            Zoom in to explore forever. Each level can have unique variations.</p>
            <p style="margin-top: 8px; font-size: 11px;">Press any key or click to begin</p>
        </div>

        <div id="recording-indicator">Recording Zoom Journey</div>

        <div id="zoom-controls">
            <button id="zoom-out" title="Zoom Out (-)">-</button>
            <div>
                <div id="zoom-level">100%</div>
                <div id="depth-indicator">Depth: 0</div>
            </div>
            <button id="zoom-in" title="Zoom In (+)">+</button>
            <button id="zoom-reset" title="Reset View (Home)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                    <path d="M3 9l9-7 9 7v11a2 2 0 01-2 2H5a2 2 0 01-2-2z"/>
                </svg>
            </button>
        </div>

        <div class="loading" id="loading">
            <div class="loading-spinner"></div>
        </div>
    </div>

    <!-- Right Panel -->
    <div id="right-panel">
        <div class="panel-section">
            <h3>Brush Settings</h3>
            <div class="slider-group">
                <label>Size <span id="brush-size-val">8</span>px</label>
                <input type="range" id="brush-size" min="1" max="100" value="8">
            </div>
            <div class="slider-group">
                <label>Opacity <span id="opacity-val">100</span>%</label>
                <input type="range" id="opacity" min="1" max="100" value="100">
            </div>
        </div>

        <div class="panel-section">
            <h3>Recursion Portal</h3>
            <div id="portal-preview">
                <span id="portal-status">No portal placed</span>
            </div>
            <div class="slider-group">
                <label>Portal Scale <span id="portal-scale-val">40</span>%</label>
                <input type="range" id="portal-scale" min="10" max="80" value="40">
            </div>
        </div>

        <div class="panel-section">
            <h3>Depth Variations</h3>
            <div class="slider-group">
                <label>Hue Shift <span id="hue-shift-val">0</span>°</label>
                <input type="range" id="hue-shift" min="0" max="360" value="0">
            </div>
            <div class="slider-group">
                <label>Rotation <span id="rotation-val">0</span>°</label>
                <input type="range" id="rotation" min="0" max="360" value="0">
            </div>
            <div class="slider-group">
                <label>Brightness <span id="brightness-val">0</span>%</label>
                <input type="range" id="brightness" min="-50" max="50" value="0">
            </div>
        </div>

        <div class="panel-section">
            <h3>Current Depth</h3>
            <div id="depth-legend">
                <span class="depth-chip active">Level 0</span>
            </div>
        </div>

        <div class="panel-section">
            <h3>Navigation</h3>
            <div id="minimap">
                <canvas id="minimap-canvas"></canvas>
                <div id="minimap-viewport"></div>
            </div>
        </div>

        <button class="action-btn primary" id="export-btn">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
                <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/>
                <polyline points="7 10 12 15 17 10"/>
                <line x1="12" y1="15" x2="12" y2="3"/>
            </svg>
            Export Image
        </button>

        <button class="action-btn secondary" id="record-btn">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
                <circle cx="12" cy="12" r="10"/>
                <circle cx="12" cy="12" r="3" fill="currentColor"/>
            </svg>
            Record Zoom Journey
        </button>

        <button class="action-btn secondary" id="clear-btn">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
                <polyline points="3 6 5 6 21 6"/>
                <path d="M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/>
            </svg>
            Clear Canvas
        </button>

        <div style="margin-top: auto; padding-top: 20px; border-top: 1px solid var(--border);">
            <button class="action-btn secondary" onclick="DataManager.save()">Export Project</button>
            <button class="action-btn secondary" style="margin-top: 8px;" onclick="document.getElementById('import-file').click()">
                Import Project
            </button>
            <input type="file" id="import-file" accept=".json" style="display: none;" onchange="DataManager.load(this)">
        </div>
    </div>

    <script>
        // ============================================
        // RECURSIVE DREAM STUDIO - CORE ENGINE
        // ============================================

        const CONFIG = {
            maxRecursionDepth: 12,
            defaultPortalScale: 0.4,
            minZoom: 0.01,
            maxZoom: 1000000,
            zoomSpeed: 0.002,
            panSpeed: 1
        };

        // State Management
        const STATE = {
            tool: 'brush',
            color: '#a855f7',
            brushSize: 8,
            opacity: 1,
            zoom: 1,
            panX: 0,
            panY: 0,
            isDrawing: false,
            isPanning: false,
            lastX: 0,
            lastY: 0,
            portal: null, // { x, y, width, height }
            portalScale: 0.4,
            hueShift: 0,
            rotation: 0,
            brightness: 0,
            strokes: [], // All drawing commands
            currentStroke: null,
            shapeStart: null
        };

        // Canvas Setup
        const container = document.getElementById('canvas-container');
        const mainCanvas = document.getElementById('main-canvas');
        const uiCanvas = document.getElementById('ui-canvas');
        const mainCtx = mainCanvas.getContext('2d');
        const uiCtx = uiCanvas.getContext('2d');

        const minimapCanvas = document.getElementById('minimap-canvas');
        const minimapCtx = minimapCanvas.getContext('2d');

        function resizeCanvases() {
            const rect = container.getBoundingClientRect();
            mainCanvas.width = rect.width;
            mainCanvas.height = rect.height;
            uiCanvas.width = rect.width;
            uiCanvas.height = rect.height;

            minimapCanvas.width = minimapCanvas.offsetWidth * 2;
            minimapCanvas.height = minimapCanvas.offsetHeight * 2;

            render();
        }

        window.addEventListener('resize', resizeCanvases);
        resizeCanvases();

        // ============================================
        // DRAWING COMMANDS
        // ============================================

        class DrawCommand {
            constructor(type, data) {
                this.type = type;
                this.data = data;
            }
        }

        function addStroke(stroke) {
            STATE.strokes.push(stroke);
            render();
            updateMinimap();
        }

        // ============================================
        // RENDERING ENGINE
        // ============================================

        function render() {
            mainCtx.save();
            mainCtx.fillStyle = '#0a0a0f';
            mainCtx.fillRect(0, 0, mainCanvas.width, mainCanvas.height);

            // Apply transformations
            mainCtx.translate(mainCanvas.width / 2, mainCanvas.height / 2);
            mainCtx.scale(STATE.zoom, STATE.zoom);
            mainCtx.translate(-mainCanvas.width / 2 + STATE.panX, -mainCanvas.height / 2 + STATE.panY);

            // Render the recursive scene
            renderRecursive(mainCtx, 0, 0, 0);

            mainCtx.restore();

            updateDepthIndicator();
            updateZoomDisplay();
        }

        function renderRecursive(ctx, depth, cumulativeHue, cumulativeRotation) {
            if (depth > CONFIG.maxRecursionDepth) return;

            // Calculate if this depth level is visible based on zoom
            const effectiveScale = Math.pow(STATE.portalScale, depth);
            const visibleSize = effectiveScale * STATE.zoom * mainCanvas.width;

            if (visibleSize < 2 && depth > 0) return; // Too small to see

            ctx.save();

            // Apply depth variations
            if (depth > 0) {
                ctx.filter = `hue-rotate(${(STATE.hueShift * depth) % 360}deg) brightness(${100 + STATE.brightness * depth}%)`;
            }

            // Draw all strokes
            STATE.strokes.forEach(stroke => {
                renderStroke(ctx, stroke);
            });

            ctx.filter = 'none';

            // Render portal content (recursive)
            if (STATE.portal && depth < CONFIG.maxRecursionDepth) {
                const p = STATE.portal;

                ctx.save();

                // Create clipping region for portal
                ctx.beginPath();
                ctx.rect(p.x, p.y, p.width, p.height);
                ctx.clip();

                // Translate to portal center and scale down
                ctx.translate(p.x + p.width / 2, p.y + p.height / 2);
                ctx.rotate((STATE.rotation * Math.PI / 180) * (depth + 1));
                ctx.scale(STATE.portalScale, STATE.portalScale);
                ctx.translate(-mainCanvas.width / 2, -mainCanvas.height / 2);

                // Recursive render
                renderRecursive(ctx, depth + 1, cumulativeHue + STATE.hueShift, cumulativeRotation + STATE.rotation);

                ctx.restore();

                // Draw portal frame
                ctx.strokeStyle = `hsla(${270 + depth * 30}, 80%, 60%, ${Math.max(0.3, 1 - depth * 0.1)})`;
                ctx.lineWidth = Math.max(1, 3 - depth * 0.3);
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(p.x, p.y, p.width, p.height);
                ctx.setLineDash([]);
            }

            ctx.restore();
        }

        function renderStroke(ctx, stroke) {
            ctx.save();
            ctx.globalAlpha = stroke.data.opacity || 1;

            switch (stroke.type) {
                case 'brush':
                    renderBrushStroke(ctx, stroke.data);
                    break;
                case 'line':
                    renderLine(ctx, stroke.data);
                    break;
                case 'rect':
                    renderRect(ctx, stroke.data);
                    break;
                case 'ellipse':
                    renderEllipse(ctx, stroke.data);
                    break;
                case 'triangle':
                    renderTriangle(ctx, stroke.data);
                    break;
                case 'eraser':
                    renderEraser(ctx, stroke.data);
                    break;
            }

            ctx.restore();
        }

        function renderBrushStroke(ctx, data) {
            if (!data.points || data.points.length < 2) return;

            ctx.strokeStyle = data.color;
            ctx.lineWidth = data.size;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            ctx.beginPath();
            ctx.moveTo(data.points[0].x, data.points[0].y);

            for (let i = 1; i < data.points.length; i++) {
                const p0 = data.points[i - 1];
                const p1 = data.points[i];
                const midX = (p0.x + p1.x) / 2;
                const midY = (p0.y + p1.y) / 2;
                ctx.quadraticCurveTo(p0.x, p0.y, midX, midY);
            }

            ctx.stroke();
        }

        function renderLine(ctx, data) {
            ctx.strokeStyle = data.color;
            ctx.lineWidth = data.size;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(data.x1, data.y1);
            ctx.lineTo(data.x2, data.y2);
            ctx.stroke();
        }

        function renderRect(ctx, data) {
            ctx.strokeStyle = data.color;
            ctx.lineWidth = data.size;
            if (data.filled) {
                ctx.fillStyle = data.color;
                ctx.fillRect(data.x, data.y, data.width, data.height);
            } else {
                ctx.strokeRect(data.x, data.y, data.width, data.height);
            }
        }

        function renderEllipse(ctx, data) {
            ctx.strokeStyle = data.color;
            ctx.lineWidth = data.size;
            ctx.beginPath();
            ctx.ellipse(data.cx, data.cy, Math.abs(data.rx), Math.abs(data.ry), 0, 0, Math.PI * 2);
            if (data.filled) {
                ctx.fillStyle = data.color;
                ctx.fill();
            } else {
                ctx.stroke();
            }
        }

        function renderTriangle(ctx, data) {
            ctx.strokeStyle = data.color;
            ctx.lineWidth = data.size;
            ctx.beginPath();
            ctx.moveTo(data.x1, data.y1);
            ctx.lineTo(data.x2, data.y2);
            ctx.lineTo(data.x3, data.y3);
            ctx.closePath();
            if (data.filled) {
                ctx.fillStyle = data.color;
                ctx.fill();
            } else {
                ctx.stroke();
            }
        }

        function renderEraser(ctx, data) {
            // Eraser uses destination-out composite
            ctx.globalCompositeOperation = 'destination-out';
            renderBrushStroke(ctx, { ...data, color: 'white' });
            ctx.globalCompositeOperation = 'source-over';
        }

        // ============================================
        // INPUT HANDLING
        // ============================================

        function getCanvasPoint(e) {
            const rect = mainCanvas.getBoundingClientRect();
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);

            // Screen coordinates
            const screenX = clientX - rect.left;
            const screenY = clientY - rect.top;

            // Transform to canvas coordinates
            const canvasX = (screenX - mainCanvas.width / 2) / STATE.zoom + mainCanvas.width / 2 - STATE.panX;
            const canvasY = (screenY - mainCanvas.height / 2) / STATE.zoom + mainCanvas.height / 2 - STATE.panY;

            return { x: canvasX, y: canvasY, screenX, screenY };
        }

        mainCanvas.addEventListener('mousedown', handlePointerDown);
        mainCanvas.addEventListener('mousemove', handlePointerMove);
        mainCanvas.addEventListener('mouseup', handlePointerUp);
        mainCanvas.addEventListener('mouseleave', handlePointerUp);
        mainCanvas.addEventListener('wheel', handleWheel, { passive: false });

        // Touch support
        mainCanvas.addEventListener('touchstart', e => { e.preventDefault(); handlePointerDown(e); });
        mainCanvas.addEventListener('touchmove', e => { e.preventDefault(); handlePointerMove(e); });
        mainCanvas.addEventListener('touchend', handlePointerUp);

        function handlePointerDown(e) {
            const point = getCanvasPoint(e);
            STATE.isDrawing = true;
            STATE.lastX = point.x;
            STATE.lastY = point.y;

            if (STATE.tool === 'pan' || e.buttons === 4 || (e.buttons === 1 && e.shiftKey)) {
                STATE.isPanning = true;
                STATE.isDrawing = false;
                mainCanvas.style.cursor = 'grabbing';
                return;
            }

            if (STATE.tool === 'brush' || STATE.tool === 'eraser') {
                STATE.currentStroke = new DrawCommand(STATE.tool, {
                    color: STATE.color,
                    size: STATE.brushSize,
                    opacity: STATE.opacity,
                    points: [point]
                });
            } else if (['line', 'rect', 'ellipse', 'triangle'].includes(STATE.tool)) {
                STATE.shapeStart = point;
            } else if (STATE.tool === 'portal') {
                STATE.shapeStart = point;
            }

            hideInstructions();
        }

        function handlePointerMove(e) {
            const point = getCanvasPoint(e);

            // Update brush indicator
            updateBrushIndicator(e);

            if (STATE.isPanning) {
                const dx = (point.screenX - STATE.lastX) / STATE.zoom;
                const dy = (point.screenY - STATE.lastY) / STATE.zoom;
                STATE.panX += dx;
                STATE.panY += dy;
                STATE.lastX = point.screenX;
                STATE.lastY = point.screenY;
                render();
                return;
            }

            if (!STATE.isDrawing) return;

            if (STATE.tool === 'brush' || STATE.tool === 'eraser') {
                if (STATE.currentStroke) {
                    STATE.currentStroke.data.points.push(point);
                    renderPreviewStroke();
                }
            } else if (STATE.shapeStart) {
                renderShapePreview(point);
            }
        }

        function handlePointerUp(e) {
            if (STATE.isPanning) {
                STATE.isPanning = false;
                mainCanvas.style.cursor = 'crosshair';
                updateMinimap();
            }

            if (!STATE.isDrawing) return;
            STATE.isDrawing = false;

            const point = e.type.includes('touch') ?
                getCanvasPoint({ clientX: STATE.lastX, clientY: STATE.lastY }) :
                getCanvasPoint(e);

            if (STATE.tool === 'brush' || STATE.tool === 'eraser') {
                if (STATE.currentStroke && STATE.currentStroke.data.points.length > 1) {
                    addStroke(STATE.currentStroke);
                }
                STATE.currentStroke = null;
            } else if (STATE.shapeStart) {
                createShape(point);
                STATE.shapeStart = null;
            }

            clearPreview();
        }

        function handleWheel(e) {
            e.preventDefault();

            const point = getCanvasPoint(e);
            const zoomFactor = Math.exp(-e.deltaY * CONFIG.zoomSpeed);
            const newZoom = Math.max(CONFIG.minZoom, Math.min(CONFIG.maxZoom, STATE.zoom * zoomFactor));

            // Zoom towards cursor position
            const zoomRatio = newZoom / STATE.zoom;
            STATE.panX = point.x - (point.x - STATE.panX) * zoomRatio - (mainCanvas.width / 2 - point.screenX) * (1 / newZoom - 1 / STATE.zoom);
            STATE.panY = point.y - (point.y - STATE.panY) * zoomRatio - (mainCanvas.height / 2 - point.screenY) * (1 / newZoom - 1 / STATE.zoom);

            STATE.zoom = newZoom;
            render();
            updateMinimap();
        }

        // ============================================
        // SHAPE CREATION
        // ============================================

        function createShape(endPoint) {
            const start = STATE.shapeStart;

            if (STATE.tool === 'line') {
                addStroke(new DrawCommand('line', {
                    x1: start.x, y1: start.y,
                    x2: endPoint.x, y2: endPoint.y,
                    color: STATE.color,
                    size: STATE.brushSize,
                    opacity: STATE.opacity
                }));
            } else if (STATE.tool === 'rect') {
                addStroke(new DrawCommand('rect', {
                    x: Math.min(start.x, endPoint.x),
                    y: Math.min(start.y, endPoint.y),
                    width: Math.abs(endPoint.x - start.x),
                    height: Math.abs(endPoint.y - start.y),
                    color: STATE.color,
                    size: STATE.brushSize,
                    opacity: STATE.opacity
                }));
            } else if (STATE.tool === 'ellipse') {
                addStroke(new DrawCommand('ellipse', {
                    cx: (start.x + endPoint.x) / 2,
                    cy: (start.y + endPoint.y) / 2,
                    rx: Math.abs(endPoint.x - start.x) / 2,
                    ry: Math.abs(endPoint.y - start.y) / 2,
                    color: STATE.color,
                    size: STATE.brushSize,
                    opacity: STATE.opacity
                }));
            } else if (STATE.tool === 'triangle') {
                const midX = (start.x + endPoint.x) / 2;
                addStroke(new DrawCommand('triangle', {
                    x1: midX, y1: start.y,
                    x2: start.x, y2: endPoint.y,
                    x3: endPoint.x, y3: endPoint.y,
                    color: STATE.color,
                    size: STATE.brushSize,
                    opacity: STATE.opacity
                }));
            } else if (STATE.tool === 'portal') {
                STATE.portal = {
                    x: Math.min(start.x, endPoint.x),
                    y: Math.min(start.y, endPoint.y),
                    width: Math.abs(endPoint.x - start.x),
                    height: Math.abs(endPoint.y - start.y)
                };
                updatePortalPreview();
                render();
            }
        }

        // ============================================
        // PREVIEW RENDERING
        // ============================================

        function renderPreviewStroke() {
            uiCtx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);

            if (!STATE.currentStroke) return;

            uiCtx.save();
            uiCtx.translate(uiCanvas.width / 2, uiCanvas.height / 2);
            uiCtx.scale(STATE.zoom, STATE.zoom);
            uiCtx.translate(-uiCanvas.width / 2 + STATE.panX, -uiCanvas.height / 2 + STATE.panY);

            renderStroke(uiCtx, STATE.currentStroke);

            uiCtx.restore();
        }

        function renderShapePreview(endPoint) {
            uiCtx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);

            const start = STATE.shapeStart;
            if (!start) return;

            uiCtx.save();
            uiCtx.translate(uiCanvas.width / 2, uiCanvas.height / 2);
            uiCtx.scale(STATE.zoom, STATE.zoom);
            uiCtx.translate(-uiCanvas.width / 2 + STATE.panX, -uiCanvas.height / 2 + STATE.panY);

            uiCtx.strokeStyle = STATE.tool === 'portal' ? '#a855f7' : STATE.color;
            uiCtx.lineWidth = STATE.brushSize;
            uiCtx.setLineDash(STATE.tool === 'portal' ? [10, 5] : []);

            if (STATE.tool === 'line') {
                uiCtx.beginPath();
                uiCtx.moveTo(start.x, start.y);
                uiCtx.lineTo(endPoint.x, endPoint.y);
                uiCtx.stroke();
            } else if (STATE.tool === 'rect' || STATE.tool === 'portal') {
                uiCtx.strokeRect(
                    Math.min(start.x, endPoint.x),
                    Math.min(start.y, endPoint.y),
                    Math.abs(endPoint.x - start.x),
                    Math.abs(endPoint.y - start.y)
                );
            } else if (STATE.tool === 'ellipse') {
                uiCtx.beginPath();
                uiCtx.ellipse(
                    (start.x + endPoint.x) / 2,
                    (start.y + endPoint.y) / 2,
                    Math.abs(endPoint.x - start.x) / 2,
                    Math.abs(endPoint.y - start.y) / 2,
                    0, 0, Math.PI * 2
                );
                uiCtx.stroke();
            } else if (STATE.tool === 'triangle') {
                const midX = (start.x + endPoint.x) / 2;
                uiCtx.beginPath();
                uiCtx.moveTo(midX, start.y);
                uiCtx.lineTo(start.x, endPoint.y);
                uiCtx.lineTo(endPoint.x, endPoint.y);
                uiCtx.closePath();
                uiCtx.stroke();
            }

            uiCtx.restore();
        }

        function clearPreview() {
            uiCtx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);
        }

        function updateBrushIndicator(e) {
            const indicator = document.getElementById('brush-indicator');
            if (['brush', 'eraser'].includes(STATE.tool)) {
                const size = STATE.brushSize * STATE.zoom;
                indicator.style.display = 'block';
                indicator.style.width = size + 'px';
                indicator.style.height = size + 'px';
                indicator.style.left = (e.clientX - container.offsetLeft - 72 - size / 2) + 'px';
                indicator.style.top = (e.clientY - size / 2) + 'px';
            } else {
                indicator.style.display = 'none';
            }
        }

        // ============================================
        // UI UPDATES
        // ============================================

        function updateZoomDisplay() {
            const zoomPercent = (STATE.zoom * 100).toFixed(STATE.zoom < 1 ? 2 : 0);
            document.getElementById('zoom-level').textContent = zoomPercent + '%';
        }

        function updateDepthIndicator() {
            // Calculate effective depth based on zoom
            let depth = 0;
            if (STATE.portal && STATE.zoom > 1) {
                depth = Math.floor(Math.log(STATE.zoom) / Math.log(1 / STATE.portalScale));
            }
            depth = Math.max(0, Math.min(depth, CONFIG.maxRecursionDepth));

            document.getElementById('depth-indicator').textContent = `Depth: ${depth}`;

            // Update depth legend
            const legend = document.getElementById('depth-legend');
            legend.innerHTML = '';
            for (let i = 0; i <= Math.min(depth + 2, CONFIG.maxRecursionDepth); i++) {
                const chip = document.createElement('span');
                chip.className = 'depth-chip' + (i === depth ? ' active' : '');
                chip.textContent = `Level ${i}`;
                legend.appendChild(chip);
            }
        }

        function updatePortalPreview() {
            const preview = document.getElementById('portal-preview');
            const status = document.getElementById('portal-status');

            if (STATE.portal) {
                status.textContent = `${Math.round(STATE.portal.width)} x ${Math.round(STATE.portal.height)}`;
                preview.style.borderStyle = 'solid';
            } else {
                status.textContent = 'No portal placed';
                preview.style.borderStyle = 'dashed';
            }
        }

        function updateMinimap() {
            minimapCtx.fillStyle = '#0a0a0f';
            minimapCtx.fillRect(0, 0, minimapCanvas.width, minimapCanvas.height);

            const scale = minimapCanvas.width / mainCanvas.width;

            minimapCtx.save();
            minimapCtx.scale(scale, scale);

            // Draw strokes simplified
            STATE.strokes.forEach(stroke => {
                minimapCtx.globalAlpha = 0.6;
                renderStroke(minimapCtx, stroke);
            });

            // Draw portal
            if (STATE.portal) {
                minimapCtx.strokeStyle = '#a855f7';
                minimapCtx.lineWidth = 2 / scale;
                minimapCtx.strokeRect(STATE.portal.x, STATE.portal.y, STATE.portal.width, STATE.portal.height);
            }

            minimapCtx.restore();

            // Draw viewport
            const viewport = document.getElementById('minimap-viewport');
            const vw = (mainCanvas.width / STATE.zoom) * scale / 2;
            const vh = (mainCanvas.height / STATE.zoom) * scale / 2;
            const vx = (mainCanvas.width / 2 - STATE.panX) * scale / 2 - vw / 2;
            const vy = (mainCanvas.height / 2 - STATE.panY) * scale / 2 - vh / 2;

            viewport.style.width = Math.max(10, vw) + 'px';
            viewport.style.height = Math.max(10, vh) + 'px';
            viewport.style.left = vx + 'px';
            viewport.style.top = vy + 'px';
        }

        // ============================================
        // TOOL SELECTION
        // ============================================

        document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                STATE.tool = btn.dataset.tool;
                mainCanvas.style.cursor = STATE.tool === 'pan' ? 'grab' : 'crosshair';
            });
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', e => {
            if (e.target.tagName === 'INPUT') return;

            const shortcuts = {
                'b': 'brush', 'e': 'eraser', 'l': 'line',
                'r': 'rect', 'o': 'ellipse', 't': 'triangle',
                'p': 'portal', ' ': 'pan'
            };

            if (shortcuts[e.key.toLowerCase()]) {
                const tool = shortcuts[e.key.toLowerCase()];
                document.querySelector(`[data-tool="${tool}"]`)?.click();
            }

            if (e.key === '+' || e.key === '=') zoomIn();
            if (e.key === '-') zoomOut();
            if (e.key === 'Home') resetView();
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (STATE.strokes.length > 0) {
                    STATE.strokes.pop();
                    render();
                    updateMinimap();
                }
            }

            hideInstructions();
        });

        document.addEventListener('keyup', e => {
            if (e.key === ' ' && STATE.tool === 'pan') {
                document.querySelector('[data-tool="brush"]')?.click();
            }
        });

        // ============================================
        // CONTROLS
        // ============================================

        // Color picker
        document.getElementById('color-picker').addEventListener('input', e => {
            STATE.color = e.target.value;
        });

        // Sliders
        document.getElementById('brush-size').addEventListener('input', e => {
            STATE.brushSize = parseInt(e.target.value);
            document.getElementById('brush-size-val').textContent = e.target.value;
        });

        document.getElementById('opacity').addEventListener('input', e => {
            STATE.opacity = parseInt(e.target.value) / 100;
            document.getElementById('opacity-val').textContent = e.target.value;
        });

        document.getElementById('portal-scale').addEventListener('input', e => {
            STATE.portalScale = parseInt(e.target.value) / 100;
            document.getElementById('portal-scale-val').textContent = e.target.value;
            render();
        });

        document.getElementById('hue-shift').addEventListener('input', e => {
            STATE.hueShift = parseInt(e.target.value);
            document.getElementById('hue-shift-val').textContent = e.target.value;
            render();
        });

        document.getElementById('rotation').addEventListener('input', e => {
            STATE.rotation = parseInt(e.target.value);
            document.getElementById('rotation-val').textContent = e.target.value;
            render();
        });

        document.getElementById('brightness').addEventListener('input', e => {
            STATE.brightness = parseInt(e.target.value);
            document.getElementById('brightness-val').textContent = e.target.value;
            render();
        });

        // Zoom controls
        document.getElementById('zoom-in').addEventListener('click', zoomIn);
        document.getElementById('zoom-out').addEventListener('click', zoomOut);
        document.getElementById('zoom-reset').addEventListener('click', resetView);

        function zoomIn() {
            STATE.zoom = Math.min(CONFIG.maxZoom, STATE.zoom * 1.5);
            render();
            updateMinimap();
        }

        function zoomOut() {
            STATE.zoom = Math.max(CONFIG.minZoom, STATE.zoom / 1.5);
            render();
            updateMinimap();
        }

        function resetView() {
            STATE.zoom = 1;
            STATE.panX = 0;
            STATE.panY = 0;
            render();
            updateMinimap();
        }

        // Clear canvas
        document.getElementById('clear-btn').addEventListener('click', () => {
            if (confirm('Clear the entire canvas?')) {
                STATE.strokes = [];
                STATE.portal = null;
                updatePortalPreview();
                render();
                updateMinimap();
            }
        });

        // ============================================
        // EXPORT
        // ============================================

        document.getElementById('export-btn').addEventListener('click', () => {
            // Create high-res export
            const exportCanvas = document.createElement('canvas');
            const size = 4096;
            exportCanvas.width = size;
            exportCanvas.height = size;
            const ctx = exportCanvas.getContext('2d');

            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, size, size);

            ctx.translate(size / 2, size / 2);
            ctx.scale(STATE.zoom * (size / mainCanvas.width), STATE.zoom * (size / mainCanvas.height));
            ctx.translate(-mainCanvas.width / 2 + STATE.panX, -mainCanvas.height / 2 + STATE.panY);

            // Render
            renderRecursiveToContext(ctx, 0);

            // Download
            const link = document.createElement('a');
            link.download = `recursive-dream-${Date.now()}.png`;
            link.href = exportCanvas.toDataURL('image/png');
            link.click();
        });

        function renderRecursiveToContext(ctx, depth) {
            if (depth > CONFIG.maxRecursionDepth) return;

            ctx.save();

            if (depth > 0) {
                ctx.filter = `hue-rotate(${(STATE.hueShift * depth) % 360}deg) brightness(${100 + STATE.brightness * depth}%)`;
            }

            STATE.strokes.forEach(stroke => renderStroke(ctx, stroke));
            ctx.filter = 'none';

            if (STATE.portal && depth < CONFIG.maxRecursionDepth) {
                const p = STATE.portal;
                ctx.save();
                ctx.beginPath();
                ctx.rect(p.x, p.y, p.width, p.height);
                ctx.clip();
                ctx.translate(p.x + p.width / 2, p.y + p.height / 2);
                ctx.rotate((STATE.rotation * Math.PI / 180) * (depth + 1));
                ctx.scale(STATE.portalScale, STATE.portalScale);
                ctx.translate(-mainCanvas.width / 2, -mainCanvas.height / 2);
                renderRecursiveToContext(ctx, depth + 1);
                ctx.restore();
            }

            ctx.restore();
        }

        // ============================================
        // RECORDING (Zoom Journey)
        // ============================================

        let recording = false;
        let recordedFrames = [];

        document.getElementById('record-btn').addEventListener('click', async () => {
            if (recording) {
                stopRecording();
            } else {
                startRecording();
            }
        });

        function startRecording() {
            recording = true;
            recordedFrames = [];
            document.getElementById('recording-indicator').style.display = 'flex';
            document.getElementById('record-btn').textContent = 'Stop Recording';

            // Auto-zoom journey
            const targetZoom = STATE.zoom * 100;
            const startZoom = STATE.zoom;
            const duration = 10000; // 10 seconds
            const startTime = performance.now();

            function recordFrame(time) {
                if (!recording) return;

                const elapsed = time - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // Ease in-out
                const eased = progress < 0.5
                    ? 2 * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                STATE.zoom = startZoom * Math.pow(targetZoom / startZoom, eased);
                render();

                // Capture frame
                recordedFrames.push(mainCanvas.toDataURL('image/webp', 0.8));

                if (progress < 1) {
                    requestAnimationFrame(recordFrame);
                } else {
                    stopRecording();
                }
            }

            requestAnimationFrame(recordFrame);
        }

        function stopRecording() {
            recording = false;
            document.getElementById('recording-indicator').style.display = 'none';
            document.getElementById('record-btn').innerHTML = `
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
                    <circle cx="12" cy="12" r="10"/>
                    <circle cx="12" cy="12" r="3" fill="currentColor"/>
                </svg>
                Record Zoom Journey
            `;

            if (recordedFrames.length > 0) {
                alert(`Recorded ${recordedFrames.length} frames! (Video export would require additional encoding library)`);
            }
        }

        // ============================================
        // DATA MANAGEMENT
        // ============================================

        const DataManager = {
            save: () => {
                const data = {
                    version: 1,
                    strokes: STATE.strokes,
                    portal: STATE.portal,
                    portalScale: STATE.portalScale,
                    hueShift: STATE.hueShift,
                    rotation: STATE.rotation,
                    brightness: STATE.brightness,
                    zoom: STATE.zoom,
                    panX: STATE.panX,
                    panY: STATE.panY
                };

                const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `recursive-dream-${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
            },

            load: (input) => {
                const file = input.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);

                        STATE.strokes = data.strokes || [];
                        STATE.portal = data.portal || null;
                        STATE.portalScale = data.portalScale || 0.4;
                        STATE.hueShift = data.hueShift || 0;
                        STATE.rotation = data.rotation || 0;
                        STATE.brightness = data.brightness || 0;
                        STATE.zoom = data.zoom || 1;
                        STATE.panX = data.panX || 0;
                        STATE.panY = data.panY || 0;

                        // Update UI
                        document.getElementById('portal-scale').value = STATE.portalScale * 100;
                        document.getElementById('portal-scale-val').textContent = Math.round(STATE.portalScale * 100);
                        document.getElementById('hue-shift').value = STATE.hueShift;
                        document.getElementById('hue-shift-val').textContent = STATE.hueShift;
                        document.getElementById('rotation').value = STATE.rotation;
                        document.getElementById('rotation-val').textContent = STATE.rotation;
                        document.getElementById('brightness').value = STATE.brightness;
                        document.getElementById('brightness-val').textContent = STATE.brightness;

                        updatePortalPreview();
                        render();
                        updateMinimap();

                    } catch (err) {
                        alert('Failed to load project: ' + err.message);
                    }
                };
                reader.readAsText(file);
            },

            autoSave: () => {
                const data = {
                    strokes: STATE.strokes,
                    portal: STATE.portal,
                    portalScale: STATE.portalScale,
                    hueShift: STATE.hueShift,
                    rotation: STATE.rotation,
                    brightness: STATE.brightness
                };
                localStorage.setItem('recursiveDreamStudio', JSON.stringify(data));
            },

            autoLoad: () => {
                const saved = localStorage.getItem('recursiveDreamStudio');
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        STATE.strokes = data.strokes || [];
                        STATE.portal = data.portal || null;
                        STATE.portalScale = data.portalScale || 0.4;
                        STATE.hueShift = data.hueShift || 0;
                        STATE.rotation = data.rotation || 0;
                        STATE.brightness = data.brightness || 0;

                        updatePortalPreview();
                        render();
                        updateMinimap();
                    } catch (e) {}
                }
            }
        };

        // Auto-save periodically
        setInterval(DataManager.autoSave, 30000);

        // ============================================
        // INSTRUCTIONS
        // ============================================

        function hideInstructions() {
            document.getElementById('instructions').classList.add('hidden');
        }

        document.getElementById('instructions').addEventListener('click', hideInstructions);

        // ============================================
        // INITIALIZATION
        // ============================================

        DataManager.autoLoad();
        render();
        updateMinimap();

        console.log('%c RECURSIVE DREAM STUDIO ',
            'background: linear-gradient(90deg, #a855f7, #7c3aed); color: white; font-size: 20px; padding: 10px 20px; border-radius: 5px;');
        console.log('Create infinite recursive art. Draw, place a portal, zoom forever.');
    </script>
</body>
</html>
