<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="rappterzoo:author" content="molter-engine">
<meta name="rappterzoo:author-type" content="agent">
<meta name="rappterzoo:category" content="educational_tools">
<meta name="rappterzoo:tags" content="canvas,simulation,education,physics,interactive">
<meta name="rappterzoo:type" content="interactive">
<meta name="rappterzoo:complexity" content="advanced">
<meta name="rappterzoo:created" content="2026-02-08">
<meta name="rappterzoo:generation" content="1">
<title>Circuit Lab - Interactive Electronics Simulator</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  font-family: 'Courier New', monospace;
  background: #0a0e17;
  color: #e0e6f0;
  overflow: hidden;
  user-select: none;
}

#app {
  display: flex;
  height: 100vh;
  width: 100vw;
}

/* Sidebar */
#sidebar {
  width: 240px;
  background: linear-gradient(180deg, #111827 0%, #0d1117 100%);
  border-right: 1px solid #1e293b;
  display: flex;
  flex-direction: column;
  z-index: 10;
}

#sidebar h1 {
  font-size: 16px;
  padding: 16px;
  background: linear-gradient(90deg, #3b82f6, #8b5cf6);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  text-align: center;
  border-bottom: 1px solid #1e293b;
}

.component-section {
  padding: 8px 12px;
  border-bottom: 1px solid #1e293b;
}

.component-section h3 {
  font-size: 11px;
  color: #64748b;
  text-transform: uppercase;
  letter-spacing: 1px;
  margin-bottom: 6px;
}

.component-btn {
  display: flex;
  align-items: center;
  gap: 8px;
  width: 100%;
  padding: 8px 10px;
  margin: 2px 0;
  background: #1e293b;
  border: 1px solid #334155;
  border-radius: 6px;
  color: #e0e6f0;
  font-family: 'Courier New', monospace;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.15s ease;
}

.component-btn:hover {
  background: #334155;
  border-color: #3b82f6;
  transform: translateX(2px);
}

.component-btn.selected {
  background: #1e3a5f;
  border-color: #3b82f6;
  box-shadow: 0 0 8px rgba(59, 130, 246, 0.3);
}

.component-icon {
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
}

/* Main canvas area */
#canvas-area {
  flex: 1;
  position: relative;
  background: #0f1419;
}

#mainCanvas {
  width: 100%;
  height: 100%;
  cursor: crosshair;
}

/* Right panel - info */
#info-panel {
  width: 260px;
  background: linear-gradient(180deg, #111827 0%, #0d1117 100%);
  border-left: 1px solid #1e293b;
  overflow-y: auto;
  padding: 12px;
}

#info-panel h2 {
  font-size: 14px;
  color: #3b82f6;
  margin-bottom: 8px;
  padding-bottom: 6px;
  border-bottom: 1px solid #1e293b;
}

.info-row {
  display: flex;
  justify-content: space-between;
  padding: 4px 0;
  font-size: 12px;
}

.info-label { color: #64748b; }
.info-value { color: #e0e6f0; font-weight: bold; }
.info-value.warn { color: #f59e0b; }
.info-value.danger { color: #ef4444; }
.info-value.good { color: #10b981; }

/* Toolbar */
#toolbar {
  position: absolute;
  top: 10px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 4px;
  background: rgba(17, 24, 39, 0.95);
  border: 1px solid #1e293b;
  border-radius: 8px;
  padding: 4px;
  z-index: 5;
}

.tool-btn {
  padding: 6px 12px;
  background: transparent;
  border: 1px solid transparent;
  border-radius: 6px;
  color: #94a3b8;
  font-family: 'Courier New', monospace;
  font-size: 11px;
  cursor: pointer;
  transition: all 0.15s ease;
}

.tool-btn:hover {
  background: #1e293b;
  color: #e0e6f0;
}

.tool-btn.active {
  background: #1e3a5f;
  border-color: #3b82f6;
  color: #3b82f6;
}

/* Status bar */
#status-bar {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  height: 28px;
  background: rgba(17, 24, 39, 0.95);
  border-top: 1px solid #1e293b;
  display: flex;
  align-items: center;
  padding: 0 12px;
  font-size: 11px;
  color: #64748b;
  gap: 20px;
  z-index: 5;
}

.status-item { display: flex; align-items: center; gap: 4px; }
.status-dot {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: #10b981;
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

/* Modal */
.modal-overlay {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.7);
  z-index: 100;
  align-items: center;
  justify-content: center;
}

.modal-overlay.active { display: flex; }

.modal {
  background: #111827;
  border: 1px solid #1e293b;
  border-radius: 12px;
  padding: 24px;
  max-width: 500px;
  width: 90%;
  max-height: 80vh;
  overflow-y: auto;
}

.modal h2 {
  color: #3b82f6;
  margin-bottom: 16px;
  font-size: 18px;
}

.modal p {
  color: #94a3b8;
  line-height: 1.6;
  margin-bottom: 12px;
  font-size: 13px;
}

.modal-close {
  margin-top: 16px;
  padding: 8px 24px;
  background: #3b82f6;
  border: none;
  border-radius: 6px;
  color: white;
  cursor: pointer;
  font-family: 'Courier New', monospace;
}

.modal-close:hover { background: #2563eb; }

/* Slider inputs */
.slider-group {
  margin: 8px 0;
}

.slider-group label {
  font-size: 11px;
  color: #94a3b8;
  display: block;
  margin-bottom: 4px;
}

.slider-group input[type="range"] {
  width: 100%;
  -webkit-appearance: none;
  height: 4px;
  background: #334155;
  border-radius: 2px;
  outline: none;
}

.slider-group input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 14px;
  height: 14px;
  background: #3b82f6;
  border-radius: 50%;
  cursor: pointer;
}

/* Lesson panel */
#lesson-panel {
  display: none;
  position: absolute;
  top: 50px;
  right: 270px;
  width: 300px;
  background: rgba(17, 24, 39, 0.98);
  border: 1px solid #3b82f6;
  border-radius: 8px;
  padding: 16px;
  z-index: 50;
  max-height: 60vh;
  overflow-y: auto;
}

#lesson-panel.active { display: block; }

#lesson-panel h3 {
  color: #3b82f6;
  font-size: 14px;
  margin-bottom: 8px;
}

#lesson-panel .lesson-text {
  font-size: 12px;
  color: #94a3b8;
  line-height: 1.6;
}

#lesson-panel .lesson-step {
  padding: 8px;
  margin: 6px 0;
  background: #1e293b;
  border-left: 3px solid #3b82f6;
  border-radius: 0 6px 6px 0;
  font-size: 12px;
}

#lesson-panel .lesson-step.completed {
  border-left-color: #10b981;
  opacity: 0.7;
}

/* Touch controls */
@media (max-width: 768px) {
  #sidebar { width: 180px; }
  #info-panel { width: 200px; }
  .component-btn { font-size: 11px; padding: 6px 8px; }
}

@media (max-width: 600px) {
  #app { flex-direction: column; }
  #sidebar {
    width: 100%;
    flex-direction: row;
    overflow-x: auto;
    height: 60px;
    border-right: none;
    border-bottom: 1px solid #1e293b;
  }
  #sidebar h1 { display: none; }
  .component-section { display: flex; gap: 4px; border: none; padding: 4px; }
  .component-section h3 { display: none; }
  #info-panel { width: 100%; height: 120px; }
}

/* Oscilloscope */
#oscilloscope {
  margin-top: 12px;
  border: 1px solid #1e293b;
  border-radius: 6px;
  overflow: hidden;
}

#oscilloscope canvas {
  width: 100%;
  height: 80px;
  background: #0a0e17;
}

#oscilloscope .osc-label {
  font-size: 10px;
  color: #64748b;
  padding: 2px 6px;
  background: #111827;
}
</style>
</head>
<body>
<div id="app">
  <!-- Sidebar: Component Palette -->
  <div id="sidebar">
    <h1>Circuit Lab</h1>

    <div class="component-section">
      <h3>Sources</h3>
      <button class="component-btn" data-type="battery" title="DC Battery (V)">
        <span class="component-icon">+</span> Battery
      </button>
      <button class="component-btn" data-type="ac_source" title="AC Source">
        <span class="component-icon">~</span> AC Source
      </button>
      <button class="component-btn" data-type="ground" title="Ground">
        <span class="component-icon">G</span> Ground
      </button>
    </div>

    <div class="component-section">
      <h3>Passive</h3>
      <button class="component-btn" data-type="resistor" title="Resistor (Ohm)">
        <span class="component-icon">R</span> Resistor
      </button>
      <button class="component-btn" data-type="capacitor" title="Capacitor (F)">
        <span class="component-icon">C</span> Capacitor
      </button>
      <button class="component-btn" data-type="inductor" title="Inductor (H)">
        <span class="component-icon">L</span> Inductor
      </button>
    </div>

    <div class="component-section">
      <h3>Active</h3>
      <button class="component-btn" data-type="led" title="LED">
        <span class="component-icon">D</span> LED
      </button>
      <button class="component-btn" data-type="switch" title="Switch">
        <span class="component-icon">S</span> Switch
      </button>
      <button class="component-btn" data-type="transistor" title="NPN Transistor">
        <span class="component-icon">T</span> Transistor
      </button>
    </div>

    <div class="component-section">
      <h3>Output</h3>
      <button class="component-btn" data-type="bulb" title="Light Bulb">
        <span class="component-icon">B</span> Bulb
      </button>
      <button class="component-btn" data-type="motor" title="DC Motor">
        <span class="component-icon">M</span> Motor
      </button>
      <button class="component-btn" data-type="buzzer" title="Piezo Buzzer">
        <span class="component-icon">Z</span> Buzzer
      </button>
    </div>

    <div class="component-section">
      <h3>Measurement</h3>
      <button class="component-btn" data-type="voltmeter" title="Voltmeter">
        <span class="component-icon">V</span> Voltmeter
      </button>
      <button class="component-btn" data-type="ammeter" title="Ammeter">
        <span class="component-icon">A</span> Ammeter
      </button>
    </div>
  </div>

  <!-- Main Canvas -->
  <div id="canvas-area">
    <canvas id="mainCanvas"></canvas>

    <!-- Toolbar -->
    <div id="toolbar">
      <button class="tool-btn active" data-tool="select" title="Select (V)">Select</button>
      <button class="tool-btn" data-tool="wire" title="Wire (W)">Wire</button>
      <button class="tool-btn" data-tool="delete" title="Delete (X)">Delete</button>
      <button class="tool-btn" data-tool="rotate" title="Rotate (R)">Rotate</button>
      <button class="tool-btn" id="simToggle" title="Run/Pause (Space)">Run</button>
      <button class="tool-btn" data-tool="clear" title="Clear All">Clear</button>
      <button class="tool-btn" data-tool="save" title="Save (Ctrl+S)">Save</button>
      <button class="tool-btn" data-tool="load" title="Load (Ctrl+O)">Load</button>
      <button class="tool-btn" data-tool="lesson" title="Lessons (L)">Lessons</button>
      <button class="tool-btn" data-tool="help" title="Help (H)">Help</button>
    </div>

    <!-- Lesson Panel -->
    <div id="lesson-panel"></div>

    <!-- Status Bar -->
    <div id="status-bar">
      <div class="status-item"><span class="status-dot"></span> Ready</div>
      <div class="status-item" id="status-components">Components: 0</div>
      <div class="status-item" id="status-wires">Wires: 0</div>
      <div class="status-item" id="status-sim">Simulation: Stopped</div>
      <div class="status-item" id="status-pos">x: 0 y: 0</div>
    </div>
  </div>

  <!-- Info Panel -->
  <div id="info-panel">
    <h2>Circuit Info</h2>
    <div id="circuit-stats">
      <div class="info-row">
        <span class="info-label">Total Power:</span>
        <span class="info-value" id="total-power">0 W</span>
      </div>
      <div class="info-row">
        <span class="info-label">Total Current:</span>
        <span class="info-value" id="total-current">0 A</span>
      </div>
      <div class="info-row">
        <span class="info-label">Total Resistance:</span>
        <span class="info-value" id="total-resistance">0 Ohm</span>
      </div>
      <div class="info-row">
        <span class="info-label">Nodes:</span>
        <span class="info-value" id="total-nodes">0</span>
      </div>
    </div>

    <h2 style="margin-top:16px">Selected Component</h2>
    <div id="component-info">
      <p style="color:#64748b;font-size:12px">Click a component to inspect</p>
    </div>

    <div id="oscilloscope">
      <div class="osc-label">Oscilloscope</div>
      <canvas id="oscCanvas" width="236" height="80"></canvas>
    </div>

    <h2 style="margin-top:16px">Quick Reference</h2>
    <div style="font-size:11px;color:#64748b;line-height:1.8">
      V = IR (Ohm's Law)<br>
      P = IV (Power)<br>
      Series: R = R1 + R2<br>
      Parallel: 1/R = 1/R1 + 1/R2<br>
      RC Time: t = RC<br>
      Energy: E = 0.5CV^2
    </div>

    <h2 style="margin-top:16px">Achievements</h2>
    <div id="achievements-list" style="font-size:11px;"></div>
  </div>
</div>

<!-- Help Modal -->
<div class="modal-overlay" id="helpModal">
  <div class="modal">
    <h2>Circuit Lab - Help</h2>
    <p><strong>Welcome to Circuit Lab!</strong> Build and simulate electronic circuits interactively.</p>
    <p><strong>Building:</strong> Click a component in the left panel, then click on the grid to place it. Use the Wire tool (W) to connect components by clicking terminals.</p>
    <p><strong>Simulation:</strong> Press Space or click Run to simulate. Current flows through complete circuits. LEDs light up, bulbs glow, motors spin, and buzzers sound.</p>
    <p><strong>Controls:</strong></p>
    <p>V - Select tool | W - Wire tool | X - Delete | R - Rotate<br>
    Space - Run/Pause | Ctrl+S - Save | Ctrl+O - Load<br>
    Scroll - Zoom | Middle-click drag - Pan<br>
    Click component - Inspect/Edit values<br>
    Double-click switch - Toggle on/off</p>
    <p><strong>Lessons:</strong> Press L to open guided lessons that teach you circuit fundamentals step by step.</p>
    <button class="modal-close" onclick="document.getElementById('helpModal').classList.remove('active')">Got it!</button>
  </div>
</div>

<script>
// ============================================================
// CIRCUIT LAB - Interactive Electronics Simulator
// ============================================================

// --- Audio Engine ---
class AudioEngine {
  constructor() {
    this.ctx = null;
    this.initialized = false;
  }

  init() {
    if (this.initialized) return;
    try {
      this.ctx = new (window.AudioContext || window.webkitAudioContext)();
      this.initialized = true;
    } catch(e) {}
  }

  playTone(freq, duration, type, volume) {
    if (!this.ctx) return;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = type || 'sine';
    osc.frequency.value = freq;
    gain.gain.setValueAtTime(volume || 0.1, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
    osc.connect(gain);
    gain.connect(this.ctx.destination);
    osc.start();
    osc.stop(this.ctx.currentTime + duration);
  }

  playPlace() { this.playTone(800, 0.08, 'square', 0.05); }
  playConnect() { this.playTone(1200, 0.06, 'sine', 0.04); }
  playDelete() { this.playTone(200, 0.15, 'sawtooth', 0.05); }
  playToggle() { this.playTone(600, 0.1, 'triangle', 0.06); }
  playError() { this.playTone(150, 0.3, 'sawtooth', 0.08); }
  playSuccess() {
    this.playTone(523, 0.1, 'sine', 0.06);
    setTimeout(() => this.playTone(659, 0.1, 'sine', 0.06), 80);
    setTimeout(() => this.playTone(784, 0.15, 'sine', 0.06), 160);
  }

  playBuzzer(freq) {
    if (!this.ctx) return;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = 'square';
    osc.frequency.value = freq || 440;
    gain.gain.value = 0.03;
    osc.connect(gain);
    gain.connect(this.ctx.destination);
    osc.start();
    return { osc, gain, stop: () => { try { osc.stop(); } catch(e) {} } };
  }
}

const audio = new AudioEngine();

// --- Grid System ---
const GRID_SIZE = 20;
const COMPONENT_WIDTH = 60;
const COMPONENT_HEIGHT = 40;

function snapToGrid(x, y) {
  return {
    x: Math.round(x / GRID_SIZE) * GRID_SIZE,
    y: Math.round(y / GRID_SIZE) * GRID_SIZE
  };
}

// --- Component Definitions ---
const COMPONENT_DEFS = {
  battery:     { name: 'Battery',      symbol: '+', color: '#f59e0b', terminals: 2, defaultValue: 9, unit: 'V',    category: 'source' },
  ac_source:   { name: 'AC Source',    symbol: '~', color: '#8b5cf6', terminals: 2, defaultValue: 120, unit: 'V',  category: 'source' },
  ground:      { name: 'Ground',       symbol: 'G', color: '#64748b', terminals: 1, defaultValue: 0, unit: 'V',    category: 'source' },
  resistor:    { name: 'Resistor',     symbol: 'R', color: '#10b981', terminals: 2, defaultValue: 100, unit: 'Ohm', category: 'passive' },
  capacitor:   { name: 'Capacitor',    symbol: 'C', color: '#06b6d4', terminals: 2, defaultValue: 100, unit: 'uF', category: 'passive' },
  inductor:    { name: 'Inductor',     symbol: 'L', color: '#f97316', terminals: 2, defaultValue: 10, unit: 'mH',  category: 'passive' },
  led:         { name: 'LED',          symbol: 'D', color: '#ef4444', terminals: 2, defaultValue: 2, unit: 'V',    category: 'active' },
  switch:      { name: 'Switch',       symbol: 'S', color: '#a3e635', terminals: 2, defaultValue: 1, unit: '',     category: 'active' },
  transistor:  { name: 'NPN Transistor', symbol: 'T', color: '#e879f9', terminals: 3, defaultValue: 100, unit: 'hFE', category: 'active' },
  bulb:        { name: 'Light Bulb',   symbol: 'B', color: '#fbbf24', terminals: 2, defaultValue: 60, unit: 'W',   category: 'output' },
  motor:       { name: 'DC Motor',     symbol: 'M', color: '#38bdf8', terminals: 2, defaultValue: 12, unit: 'V',   category: 'output' },
  buzzer:      { name: 'Buzzer',       symbol: 'Z', color: '#fb923c', terminals: 2, defaultValue: 440, unit: 'Hz', category: 'output' },
  voltmeter:   { name: 'Voltmeter',    symbol: 'V', color: '#818cf8', terminals: 2, defaultValue: 0, unit: 'V',    category: 'measurement' },
  ammeter:     { name: 'Ammeter',      symbol: 'A', color: '#34d399', terminals: 2, defaultValue: 0, unit: 'A',    category: 'measurement' }
};

// --- Main App State ---
class CircuitLab {
  constructor() {
    this.canvas = document.getElementById('mainCanvas');
    this.ctx = this.canvas.getContext('2d');
    this.oscCanvas = document.getElementById('oscCanvas');
    this.oscCtx = this.oscCanvas.getContext('2d');

    this.components = [];
    this.wires = [];
    this.nodes = [];

    this.selectedTool = 'select';
    this.selectedComponentType = null;
    this.selectedComponent = null;
    this.hoveredComponent = null;
    this.hoveredTerminal = null;

    this.isSimulating = false;
    this.simTime = 0;
    this.simSpeed = 1;

    this.camera = { x: 0, y: 0, zoom: 1 };
    this.isDragging = false;
    this.isPanning = false;
    this.dragStart = { x: 0, y: 0 };
    this.dragOffset = { x: 0, y: 0 };

    this.wireStart = null;
    this.wirePreview = null;

    this.oscData = new Float32Array(236);
    this.oscIndex = 0;

    this.achievements = {};
    this.nextId = 1;
    this.activeBuzzers = [];
    this.particles = [];

    this.lessons = this.buildLessons();
    this.currentLesson = null;
    this.lessonStep = 0;

    this.init();
  }

  init() {
    this.resize();
    window.addEventListener('resize', () => this.resize());
    this.setupInput();
    this.loadState();
    this.animate();
  }

  resize() {
    const area = document.getElementById('canvas-area');
    this.canvas.width = area.clientWidth;
    this.canvas.height = area.clientHeight;
  }

  // --- Input Handling ---
  setupInput() {
    const c = this.canvas;

    // Mouse
    c.addEventListener('mousedown', e => this.onMouseDown(e));
    c.addEventListener('mousemove', e => this.onMouseMove(e));
    c.addEventListener('mouseup', e => this.onMouseUp(e));
    c.addEventListener('dblclick', e => this.onDoubleClick(e));
    c.addEventListener('wheel', e => this.onWheel(e));
    c.addEventListener('contextmenu', e => e.preventDefault());

    // Touch
    c.addEventListener('touchstart', e => {
      e.preventDefault();
      const t = e.touches[0];
      this.onMouseDown({ clientX: t.clientX, clientY: t.clientY, button: 0 });
    });
    c.addEventListener('touchmove', e => {
      e.preventDefault();
      const t = e.touches[0];
      this.onMouseMove({ clientX: t.clientX, clientY: t.clientY });
    });
    c.addEventListener('touchend', e => {
      e.preventDefault();
      this.onMouseUp({ button: 0 });
    });

    // Keyboard
    document.addEventListener('keydown', e => this.onKeyDown(e));

    // Component buttons
    document.querySelectorAll('.component-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        audio.init();
        const type = btn.dataset.type;
        this.selectedComponentType = type;
        this.selectedTool = 'place';
        document.querySelectorAll('.component-btn').forEach(b => b.classList.remove('selected'));
        btn.classList.add('selected');
        this.setToolActive('');
      });
    });

    // Tool buttons
    document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
      btn.addEventListener('click', () => {
        audio.init();
        const tool = btn.dataset.tool;
        if (tool === 'clear') { this.clearCircuit(); return; }
        if (tool === 'save') { this.saveState(); return; }
        if (tool === 'load') { this.loadState(); return; }
        if (tool === 'help') { document.getElementById('helpModal').classList.add('active'); return; }
        if (tool === 'lesson') { this.toggleLessons(); return; }
        this.selectedTool = tool;
        this.selectedComponentType = null;
        document.querySelectorAll('.component-btn').forEach(b => b.classList.remove('selected'));
        this.setToolActive(tool);
      });
    });

    // Sim toggle
    document.getElementById('simToggle').addEventListener('click', () => {
      audio.init();
      this.toggleSimulation();
    });
  }

  setToolActive(tool) {
    document.querySelectorAll('.tool-btn[data-tool]').forEach(b => {
      b.classList.toggle('active', b.dataset.tool === tool);
    });
  }

  getWorldPos(e) {
    const rect = this.canvas.getBoundingClientRect();
    const sx = e.clientX - rect.left;
    const sy = e.clientY - rect.top;
    return {
      x: (sx - this.camera.x) / this.camera.zoom,
      y: (sy - this.camera.y) / this.camera.zoom
    };
  }

  onMouseDown(e) {
    const pos = this.getWorldPos(e);
    const snapped = snapToGrid(pos.x, pos.y);

    if (e.button === 1) {
      this.isPanning = true;
      this.dragStart = { x: e.clientX, y: e.clientY };
      this.dragOffset = { x: this.camera.x, y: this.camera.y };
      return;
    }

    if (this.selectedTool === 'place' && this.selectedComponentType) {
      this.placeComponent(snapped.x, snapped.y, this.selectedComponentType);
      return;
    }

    if (this.selectedTool === 'wire') {
      const terminal = this.findTerminalAt(pos.x, pos.y);
      if (terminal) {
        if (!this.wireStart) {
          this.wireStart = terminal;
          audio.playConnect();
        } else {
          if (terminal.compId !== this.wireStart.compId || terminal.index !== this.wireStart.index) {
            this.addWire(this.wireStart, terminal);
            audio.playConnect();
          }
          this.wireStart = null;
        }
      }
      return;
    }

    if (this.selectedTool === 'delete') {
      const comp = this.findComponentAt(pos.x, pos.y);
      if (comp) {
        this.deleteComponent(comp);
        audio.playDelete();
        return;
      }
      const wire = this.findWireAt(pos.x, pos.y);
      if (wire) {
        this.wires = this.wires.filter(w => w !== wire);
        audio.playDelete();
        return;
      }
    }

    if (this.selectedTool === 'rotate') {
      const comp = this.findComponentAt(pos.x, pos.y);
      if (comp) {
        comp.rotation = (comp.rotation + 90) % 360;
        this.updateTerminals(comp);
        audio.playToggle();
        return;
      }
    }

    if (this.selectedTool === 'select') {
      const comp = this.findComponentAt(pos.x, pos.y);
      if (comp) {
        this.selectedComponent = comp;
        this.isDragging = true;
        this.dragStart = { x: pos.x - comp.x, y: pos.y - comp.y };
        this.showComponentInfo(comp);
        return;
      }
      this.selectedComponent = null;
      this.showComponentInfo(null);

      // Start panning
      this.isPanning = true;
      this.dragStart = { x: e.clientX, y: e.clientY };
      this.dragOffset = { x: this.camera.x, y: this.camera.y };
    }
  }

  onMouseMove(e) {
    const pos = this.getWorldPos(e);
    const snapped = snapToGrid(pos.x, pos.y);

    document.getElementById('status-pos').textContent =
      'x: ' + Math.round(pos.x) + ' y: ' + Math.round(pos.y);

    if (this.isPanning) {
      this.camera.x = this.dragOffset.x + (e.clientX - this.dragStart.x);
      this.camera.y = this.dragOffset.y + (e.clientY - this.dragStart.y);
      return;
    }

    if (this.isDragging && this.selectedComponent) {
      this.selectedComponent.x = snapped.x;
      this.selectedComponent.y = snapped.y;
      this.updateTerminals(this.selectedComponent);
      return;
    }

    if (this.selectedTool === 'wire' && this.wireStart) {
      this.wirePreview = snapped;
    }

    this.hoveredComponent = this.findComponentAt(pos.x, pos.y);
    this.hoveredTerminal = this.findTerminalAt(pos.x, pos.y);
  }

  onMouseUp(e) {
    this.isDragging = false;
    this.isPanning = false;
  }

  onDoubleClick(e) {
    const pos = this.getWorldPos(e);
    const comp = this.findComponentAt(pos.x, pos.y);
    if (comp) {
      if (comp.type === 'switch') {
        comp.state = comp.state === 'on' ? 'off' : 'on';
        audio.playToggle();
        this.checkLessonProgress('toggle_switch');
      } else {
        this.editComponentValue(comp);
      }
    }
  }

  onWheel(e) {
    e.preventDefault();
    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
    const oldZoom = this.camera.zoom;
    this.camera.zoom = Math.max(0.3, Math.min(3, this.camera.zoom * zoomFactor));

    const rect = this.canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    this.camera.x = mx - (mx - this.camera.x) * (this.camera.zoom / oldZoom);
    this.camera.y = my - (my - this.camera.y) * (this.camera.zoom / oldZoom);
  }

  onKeyDown(e) {
    if (e.target.tagName === 'INPUT') return;

    switch (e.key.toLowerCase()) {
      case 'v': this.selectedTool = 'select'; this.setToolActive('select'); break;
      case 'w': this.selectedTool = 'wire'; this.wireStart = null; this.setToolActive('wire'); break;
      case 'x': case 'delete': this.selectedTool = 'delete'; this.setToolActive('delete'); break;
      case 'r':
        if (this.selectedComponent) {
          this.selectedComponent.rotation = (this.selectedComponent.rotation + 90) % 360;
          this.updateTerminals(this.selectedComponent);
          audio.playToggle();
        } else {
          this.selectedTool = 'rotate'; this.setToolActive('rotate');
        }
        break;
      case ' ':
        e.preventDefault();
        this.toggleSimulation();
        break;
      case 'l': this.toggleLessons(); break;
      case 'h': document.getElementById('helpModal').classList.add('active'); break;
      case 'escape':
        this.wireStart = null;
        this.selectedComponent = null;
        document.getElementById('helpModal').classList.remove('active');
        document.getElementById('lesson-panel').classList.remove('active');
        break;
      case 's':
        if (e.ctrlKey || e.metaKey) { e.preventDefault(); this.saveState(); }
        break;
      case 'o':
        if (e.ctrlKey || e.metaKey) { e.preventDefault(); this.loadState(); }
        break;
    }
  }

  // --- Component Management ---
  placeComponent(x, y, type) {
    const def = COMPONENT_DEFS[type];
    const comp = {
      id: this.nextId++,
      type,
      name: def.name,
      x, y,
      rotation: 0,
      value: def.defaultValue,
      unit: def.unit,
      state: type === 'switch' ? 'off' : 'active',
      terminals: [],
      voltage: 0,
      current: 0,
      power: 0,
      brightness: 0,
      motorSpeed: 0,
      charge: 0
    };

    this.updateTerminals(comp);
    this.components.push(comp);
    audio.playPlace();

    this.updateStatusBar();
    this.checkLessonProgress('place_' + type);
    this.checkAchievements();
  }

  updateTerminals(comp) {
    const def = COMPONENT_DEFS[comp.type];
    const hw = COMPONENT_WIDTH / 2;
    const hh = COMPONENT_HEIGHT / 2;
    const rad = (comp.rotation * Math.PI) / 180;

    comp.terminals = [];

    if (def.terminals === 1) {
      comp.terminals.push({ x: comp.x, y: comp.y + hh, compId: comp.id, index: 0 });
    } else if (def.terminals === 2) {
      const offsets = [
        { x: -hw, y: 0 },
        { x: hw, y: 0 }
      ];
      offsets.forEach((off, i) => {
        const rx = off.x * Math.cos(rad) - off.y * Math.sin(rad);
        const ry = off.x * Math.sin(rad) + off.y * Math.cos(rad);
        comp.terminals.push({
          x: comp.x + rx,
          y: comp.y + ry,
          compId: comp.id,
          index: i
        });
      });
    } else if (def.terminals === 3) {
      const offsets = [
        { x: -hw, y: -10 },
        { x: hw, y: 0 },
        { x: -hw, y: 10 }
      ];
      offsets.forEach((off, i) => {
        const rx = off.x * Math.cos(rad) - off.y * Math.sin(rad);
        const ry = off.x * Math.sin(rad) + off.y * Math.cos(rad);
        comp.terminals.push({
          x: comp.x + rx,
          y: comp.y + ry,
          compId: comp.id,
          index: i
        });
      });
    }
  }

  deleteComponent(comp) {
    this.wires = this.wires.filter(w => w.from.compId !== comp.id && w.to.compId !== comp.id);
    this.components = this.components.filter(c => c.id !== comp.id);
    if (this.selectedComponent === comp) this.selectedComponent = null;
    this.updateStatusBar();
  }

  addWire(from, to) {
    const exists = this.wires.some(w =>
      (w.from.compId === from.compId && w.from.index === from.index &&
       w.to.compId === to.compId && w.to.index === to.index) ||
      (w.from.compId === to.compId && w.from.index === to.index &&
       w.to.compId === from.compId && w.to.index === from.index)
    );
    if (exists) return;

    this.wires.push({
      from: { compId: from.compId, index: from.index },
      to: { compId: to.compId, index: to.index },
      current: 0,
      highlighted: false
    });
    this.updateStatusBar();
    this.checkLessonProgress('connect_wire');
    this.checkAchievements();
  }

  findComponentAt(x, y) {
    const hw = COMPONENT_WIDTH / 2;
    const hh = COMPONENT_HEIGHT / 2;
    for (let i = this.components.length - 1; i >= 0; i--) {
      const c = this.components[i];
      if (x >= c.x - hw && x <= c.x + hw && y >= c.y - hh && y <= c.y + hh) {
        return c;
      }
    }
    return null;
  }

  findTerminalAt(x, y) {
    const threshold = 12;
    for (const comp of this.components) {
      for (const t of comp.terminals) {
        const dx = x - t.x;
        const dy = y - t.y;
        if (Math.sqrt(dx * dx + dy * dy) < threshold) {
          return t;
        }
      }
    }
    return null;
  }

  findWireAt(x, y) {
    const threshold = 8;
    for (const wire of this.wires) {
      const from = this.getTerminalPos(wire.from);
      const to = this.getTerminalPos(wire.to);
      if (!from || !to) continue;

      const dx = to.x - from.x;
      const dy = to.y - from.y;
      const len = Math.sqrt(dx * dx + dy * dy);
      if (len === 0) continue;

      const t = Math.max(0, Math.min(1, ((x - from.x) * dx + (y - from.y) * dy) / (len * len)));
      const px = from.x + t * dx;
      const py = from.y + t * dy;
      const dist = Math.sqrt((x - px) * (x - px) + (y - py) * (y - py));
      if (dist < threshold) return wire;
    }
    return null;
  }

  getTerminalPos(ref) {
    const comp = this.components.find(c => c.id === ref.compId);
    if (!comp) return null;
    return comp.terminals[ref.index];
  }

  // --- Simulation Engine ---
  toggleSimulation() {
    this.isSimulating = !this.isSimulating;
    const btn = document.getElementById('simToggle');
    btn.textContent = this.isSimulating ? 'Pause' : 'Run';
    btn.classList.toggle('active', this.isSimulating);
    document.getElementById('status-sim').textContent =
      'Simulation: ' + (this.isSimulating ? 'Running' : 'Stopped');

    if (this.isSimulating) {
      this.checkLessonProgress('start_simulation');
    } else {
      this.activeBuzzers.forEach(b => b.stop());
      this.activeBuzzers = [];
    }
  }

  simulate(dt) {
    if (!this.isSimulating) return;
    this.simTime += dt * this.simSpeed;

    // Reset all component states
    this.components.forEach(c => {
      c.voltage = 0;
      c.current = 0;
      c.power = 0;
    });

    // Build adjacency from wires
    const adj = {};
    this.wires.forEach(w => {
      const key1 = w.from.compId + ':' + w.from.index;
      const key2 = w.to.compId + ':' + w.to.index;
      if (!adj[key1]) adj[key1] = [];
      if (!adj[key2]) adj[key2] = [];
      adj[key1].push(w.to);
      adj[key2].push(w.from);
    });

    // Find voltage sources
    const sources = this.components.filter(c => c.type === 'battery' || c.type === 'ac_source');

    // For each source, trace paths to find complete circuits
    sources.forEach(source => {
      const sourceVoltage = source.type === 'ac_source'
        ? source.value * Math.sin(this.simTime * 2 * Math.PI * 60)
        : source.value;
      source.voltage = sourceVoltage;

      // Find all components reachable from source terminal 1
      const paths = this.findCircuitPaths(source);

      paths.forEach(path => {
        // Calculate total resistance in this path
        let totalResistance = 0.001; // Minimum wire resistance
        let hasOpenSwitch = false;

        path.forEach(compId => {
          const comp = this.components.find(c => c.id === compId);
          if (!comp) return;

          switch (comp.type) {
            case 'resistor':
              totalResistance += comp.value;
              break;
            case 'led':
              totalResistance += 50; // Forward resistance
              break;
            case 'bulb':
              totalResistance += (sourceVoltage * sourceVoltage) / Math.max(comp.value, 1);
              break;
            case 'motor':
              totalResistance += 20;
              break;
            case 'buzzer':
              totalResistance += 100;
              break;
            case 'switch':
              if (comp.state === 'off') hasOpenSwitch = true;
              break;
            case 'capacitor':
              // Capacitor impedance (simplified)
              const capImpedance = 1 / (2 * Math.PI * 60 * comp.value * 1e-6 + 0.001);
              totalResistance += capImpedance;
              break;
            case 'inductor':
              const indImpedance = 2 * Math.PI * 60 * comp.value * 0.001;
              totalResistance += indImpedance;
              break;
            case 'ammeter':
              totalResistance += 0.001;
              break;
            case 'voltmeter':
              totalResistance += 1000000; // Very high resistance
              break;
          }
        });

        if (hasOpenSwitch) return;

        // Calculate current (I = V/R)
        const current = Math.abs(sourceVoltage) / totalResistance;
        source.current = current;

        // Apply current to all components in path
        path.forEach(compId => {
          const comp = this.components.find(c => c.id === compId);
          if (!comp) return;

          comp.current = current;

          switch (comp.type) {
            case 'resistor':
              comp.voltage = current * comp.value;
              comp.power = current * current * comp.value;
              break;
            case 'led':
              comp.voltage = comp.value; // Forward voltage
              comp.brightness = Math.min(1, current / 0.02);
              if (comp.brightness > 0.1) {
                this.checkLessonProgress('led_lit');
              }
              break;
            case 'bulb':
              comp.voltage = current * ((sourceVoltage * sourceVoltage) / Math.max(comp.value, 1));
              comp.brightness = Math.min(1, current * 10);
              comp.power = current * comp.voltage;
              break;
            case 'motor':
              comp.voltage = current * 20;
              comp.motorSpeed = Math.min(1, current / 0.5);
              break;
            case 'buzzer':
              comp.voltage = current * 100;
              if (current > 0.01) {
                this.checkLessonProgress('buzzer_sounds');
              }
              break;
            case 'ammeter':
              comp.value = current;
              break;
            case 'voltmeter':
              comp.value = sourceVoltage;
              break;
            case 'capacitor':
              comp.charge = Math.min(sourceVoltage, comp.charge + current * dt);
              comp.voltage = comp.charge;
              break;
          }
        });

        // Highlight wires carrying current
        this.wires.forEach(w => {
          const fromInPath = path.includes(w.from.compId);
          const toInPath = path.includes(w.to.compId);
          if (fromInPath && toInPath) {
            w.current = current;
            w.highlighted = true;
          }
        });
      });
    });

    // Handle buzzer audio
    this.activeBuzzers.forEach(b => b.stop());
    this.activeBuzzers = [];
    this.components.filter(c => c.type === 'buzzer' && c.current > 0.01).forEach(c => {
      const b = audio.playBuzzer(c.value * (0.5 + c.current));
      if (b) this.activeBuzzers.push(b);
    });

    // Particles for active LEDs and bulbs
    this.components.filter(c => (c.type === 'led' || c.type === 'bulb') && c.brightness > 0.3).forEach(c => {
      if (Math.random() < c.brightness * 0.3) {
        this.spawnParticle(c.x, c.y, c.type === 'led' ? COMPONENT_DEFS.led.color : '#fbbf24');
      }
    });

    // Update oscilloscope
    if (sources.length > 0) {
      this.oscData[this.oscIndex] = sources[0].current;
      this.oscIndex = (this.oscIndex + 1) % this.oscData.length;
    }

    // Update info
    this.updateCircuitInfo();
  }

  findCircuitPaths(source) {
    const paths = [];
    const visited = new Set();

    const dfs = (compId, termIndex, path) => {
      const key = compId + ':' + termIndex;
      if (visited.has(key)) return;
      visited.add(key);

      const comp = this.components.find(c => c.id === compId);
      if (!comp) return;

      // Find wires connected to this terminal
      this.wires.forEach(w => {
        let nextRef = null;
        if (w.from.compId === compId && w.from.index === termIndex) {
          nextRef = w.to;
        } else if (w.to.compId === compId && w.to.index === termIndex) {
          nextRef = w.from;
        }

        if (nextRef) {
          const nextComp = this.components.find(c => c.id === nextRef.compId);
          if (!nextComp) return;

          // If we reached back to the source on the other terminal, circuit is complete
          if (nextRef.compId === source.id && nextRef.index !== 0) {
            paths.push([...path]);
            return;
          }

          // If we reached a ground, treat it as return path
          if (nextComp.type === 'ground') {
            paths.push([...path]);
            return;
          }

          // Continue through the other terminal of this component
          const otherTerminals = nextComp.terminals.filter((_, i) => i !== nextRef.index);
          path.push(nextRef.compId);
          otherTerminals.forEach((_, i) => {
            const otherIdx = nextComp.terminals.findIndex((t, idx) => idx !== nextRef.index);
            if (otherIdx >= 0) {
              dfs(nextRef.compId, otherIdx, path);
            }
          });
          path.pop();
        }
      });
    };

    dfs(source.id, 0, []);
    return paths;
  }

  // --- Particles ---
  spawnParticle(x, y, color) {
    this.particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 30,
      vy: (Math.random() - 0.5) * 30 - 20,
      life: 1,
      color,
      size: 2 + Math.random() * 3
    });
  }

  updateParticles(dt) {
    this.particles = this.particles.filter(p => {
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vy += 40 * dt;
      p.life -= dt * 2;
      return p.life > 0;
    });
  }

  // --- Rendering ---
  draw() {
    const ctx = this.ctx;
    const w = this.canvas.width;
    const h = this.canvas.height;

    ctx.clearRect(0, 0, w, h);

    // Background
    ctx.fillStyle = '#0f1419';
    ctx.fillRect(0, 0, w, h);

    ctx.save();
    ctx.translate(this.camera.x, this.camera.y);
    ctx.scale(this.camera.zoom, this.camera.zoom);

    // Draw grid
    this.drawGrid(ctx);

    // Draw wires
    this.wires.forEach(wire => this.drawWire(ctx, wire));

    // Wire preview
    if (this.selectedTool === 'wire' && this.wireStart && this.wirePreview) {
      const from = this.getTerminalPos(this.wireStart);
      if (from) {
        ctx.strokeStyle = 'rgba(59, 130, 246, 0.5)';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(this.wirePreview.x, this.wirePreview.y);
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }

    // Draw components
    this.components.forEach(comp => this.drawComponent(ctx, comp));

    // Draw particles
    this.particles.forEach(p => {
      ctx.globalAlpha = p.life;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    });

    // Draw terminal highlights
    if (this.hoveredTerminal) {
      ctx.fillStyle = '#3b82f6';
      ctx.beginPath();
      ctx.arc(this.hoveredTerminal.x, this.hoveredTerminal.y, 8, 0, Math.PI * 2);
      ctx.fill();
    }

    ctx.restore();

    // Draw oscilloscope
    this.drawOscilloscope();
  }

  drawGrid(ctx) {
    const gridExtent = 2000;
    ctx.strokeStyle = '#1a1f2e';
    ctx.lineWidth = 0.5;

    for (let x = -gridExtent; x <= gridExtent; x += GRID_SIZE) {
      ctx.beginPath();
      ctx.moveTo(x, -gridExtent);
      ctx.lineTo(x, gridExtent);
      ctx.stroke();
    }
    for (let y = -gridExtent; y <= gridExtent; y += GRID_SIZE) {
      ctx.beginPath();
      ctx.moveTo(-gridExtent, y);
      ctx.lineTo(gridExtent, y);
      ctx.stroke();
    }

    // Major grid lines
    ctx.strokeStyle = '#252b3b';
    ctx.lineWidth = 1;
    for (let x = -gridExtent; x <= gridExtent; x += GRID_SIZE * 5) {
      ctx.beginPath();
      ctx.moveTo(x, -gridExtent);
      ctx.lineTo(x, gridExtent);
      ctx.stroke();
    }
    for (let y = -gridExtent; y <= gridExtent; y += GRID_SIZE * 5) {
      ctx.beginPath();
      ctx.moveTo(-gridExtent, y);
      ctx.lineTo(gridExtent, y);
      ctx.stroke();
    }
  }

  drawWire(ctx, wire) {
    const from = this.getTerminalPos(wire.from);
    const to = this.getTerminalPos(wire.to);
    if (!from || !to) return;

    // Wire glow when carrying current
    if (wire.highlighted && wire.current > 0.001) {
      ctx.strokeStyle = 'rgba(59, 130, 246, 0.3)';
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.moveTo(from.x, from.y);
      ctx.lineTo(to.x, to.y);
      ctx.stroke();

      // Animated current dots
      const dx = to.x - from.x;
      const dy = to.y - from.y;
      const len = Math.sqrt(dx * dx + dy * dy);
      const numDots = Math.ceil(len / 20);
      const phase = (this.simTime * 5) % 1;

      ctx.fillStyle = '#60a5fa';
      for (let i = 0; i < numDots; i++) {
        const t = ((i / numDots) + phase) % 1;
        const px = from.x + dx * t;
        const py = from.y + dy * t;
        ctx.beginPath();
        ctx.arc(px, py, 2, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    ctx.strokeStyle = wire.highlighted ? '#3b82f6' : '#475569';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(from.x, from.y);
    ctx.lineTo(to.x, to.y);
    ctx.stroke();
  }

  drawComponent(ctx, comp) {
    const def = COMPONENT_DEFS[comp.type];
    const hw = COMPONENT_WIDTH / 2;
    const hh = COMPONENT_HEIGHT / 2;
    const isSelected = comp === this.selectedComponent;
    const isHovered = comp === this.hoveredComponent;

    ctx.save();
    ctx.translate(comp.x, comp.y);
    ctx.rotate((comp.rotation * Math.PI) / 180);

    // Component body
    const bgColor = isSelected ? '#1e3a5f' : (isHovered ? '#1e293b' : '#111827');
    const borderColor = isSelected ? '#3b82f6' : (isHovered ? '#475569' : '#334155');

    // Glow for active components
    if (this.isSimulating && comp.current > 0.001) {
      ctx.shadowColor = def.color;
      ctx.shadowBlur = 10 + comp.current * 20;
    }

    ctx.fillStyle = bgColor;
    ctx.strokeStyle = borderColor;
    ctx.lineWidth = isSelected ? 2 : 1;
    ctx.beginPath();
    ctx.roundRect(-hw, -hh, COMPONENT_WIDTH, COMPONENT_HEIGHT, 6);
    ctx.fill();
    ctx.stroke();
    ctx.shadowBlur = 0;

    // Component-specific drawing
    this.drawComponentSymbol(ctx, comp, def, hw, hh);

    // Label
    ctx.fillStyle = '#94a3b8';
    ctx.font = '9px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText(comp.value + ' ' + comp.unit, 0, hh + 12);

    // Terminals
    comp.terminals.forEach((t, i) => {
      const tx = t.x - comp.x;
      const ty = t.y - comp.y;
      // Un-rotate terminal position for drawing
      const rad = -(comp.rotation * Math.PI) / 180;
      const rx = tx * Math.cos(rad) - ty * Math.sin(rad);
      const ry = tx * Math.sin(rad) + ty * Math.cos(rad);

      ctx.fillStyle = '#475569';
      ctx.beginPath();
      ctx.arc(rx, ry, 4, 0, Math.PI * 2);
      ctx.fill();

      if (this.isSimulating && comp.current > 0.001) {
        ctx.fillStyle = '#3b82f6';
        ctx.beginPath();
        ctx.arc(rx, ry, 3, 0, Math.PI * 2);
        ctx.fill();
      }
    });

    ctx.restore();

    // LED glow
    if (comp.type === 'led' && comp.brightness > 0) {
      ctx.save();
      const gradient = ctx.createRadialGradient(comp.x, comp.y, 0, comp.x, comp.y, 40);
      gradient.addColorStop(0, `rgba(239, 68, 68, ${comp.brightness * 0.5})`);
      gradient.addColorStop(1, 'rgba(239, 68, 68, 0)');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(comp.x, comp.y, 40, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    // Bulb glow
    if (comp.type === 'bulb' && comp.brightness > 0) {
      ctx.save();
      const gradient = ctx.createRadialGradient(comp.x, comp.y, 0, comp.x, comp.y, 50);
      gradient.addColorStop(0, `rgba(251, 191, 36, ${comp.brightness * 0.6})`);
      gradient.addColorStop(1, 'rgba(251, 191, 36, 0)');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(comp.x, comp.y, 50, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }

  drawComponentSymbol(ctx, comp, def, hw, hh) {
    ctx.fillStyle = def.color;
    ctx.strokeStyle = def.color;
    ctx.lineWidth = 2;

    switch (comp.type) {
      case 'battery':
        // Battery symbol: thin and thick lines
        ctx.beginPath();
        ctx.moveTo(-8, -12); ctx.lineTo(-8, 12); // thin
        ctx.stroke();
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(4, -8); ctx.lineTo(4, 8); // thick
        ctx.stroke();
        ctx.font = 'bold 10px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('+', -14, 4);
        break;

      case 'ac_source':
        ctx.beginPath();
        ctx.arc(0, 0, 12, 0, Math.PI * 2);
        ctx.stroke();
        ctx.beginPath();
        for (let i = -10; i <= 10; i++) {
          const y = Math.sin(i * 0.3) * 5;
          if (i === -10) ctx.moveTo(i, y);
          else ctx.lineTo(i, y);
        }
        ctx.stroke();
        break;

      case 'ground':
        ctx.beginPath();
        ctx.moveTo(-12, 0); ctx.lineTo(12, 0);
        ctx.moveTo(-8, 5); ctx.lineTo(8, 5);
        ctx.moveTo(-4, 10); ctx.lineTo(4, 10);
        ctx.stroke();
        break;

      case 'resistor':
        ctx.beginPath();
        ctx.moveTo(-hw + 5, 0);
        const zigPoints = 6;
        for (let i = 0; i <= zigPoints; i++) {
          const px = -15 + (30 * i / zigPoints);
          const py = (i % 2 === 0) ? -8 : 8;
          ctx.lineTo(px, py);
        }
        ctx.lineTo(hw - 5, 0);
        ctx.stroke();
        break;

      case 'capacitor':
        ctx.beginPath();
        ctx.moveTo(-3, -12); ctx.lineTo(-3, 12);
        ctx.moveTo(3, -12); ctx.lineTo(3, 12);
        ctx.stroke();
        break;

      case 'inductor':
        ctx.beginPath();
        for (let i = 0; i < 4; i++) {
          const cx = -12 + i * 8;
          ctx.arc(cx, 0, 4, Math.PI, 0);
        }
        ctx.stroke();
        break;

      case 'led':
        // Triangle + line
        ctx.beginPath();
        ctx.moveTo(-8, -10); ctx.lineTo(8, 0); ctx.lineTo(-8, 10);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(8, -10); ctx.lineTo(8, 10);
        ctx.stroke();
        // Arrows
        ctx.beginPath();
        ctx.moveTo(10, -12); ctx.lineTo(16, -18);
        ctx.moveTo(14, -10); ctx.lineTo(20, -16);
        ctx.stroke();
        break;

      case 'switch':
        ctx.beginPath();
        ctx.arc(-12, 0, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(12, 0, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(-12, 0);
        if (comp.state === 'on') {
          ctx.lineTo(12, 0);
          ctx.strokeStyle = '#10b981';
        } else {
          ctx.lineTo(8, -12);
          ctx.strokeStyle = '#ef4444';
        }
        ctx.stroke();
        break;

      case 'transistor':
        ctx.beginPath();
        ctx.moveTo(-5, -14); ctx.lineTo(-5, 14); // Base line
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(-5, -6); ctx.lineTo(12, -14); // Collector
        ctx.moveTo(-5, 6); ctx.lineTo(12, 14); // Emitter
        ctx.stroke();
        // Arrow on emitter
        ctx.beginPath();
        ctx.moveTo(8, 10); ctx.lineTo(12, 14); ctx.lineTo(6, 12);
        ctx.fill();
        break;

      case 'bulb':
        ctx.beginPath();
        ctx.arc(0, 0, 12, 0, Math.PI * 2);
        ctx.stroke();
        if (comp.brightness > 0) {
          ctx.fillStyle = `rgba(251, 191, 36, ${comp.brightness})`;
          ctx.fill();
        }
        // Filament
        ctx.beginPath();
        ctx.moveTo(-6, 6); ctx.lineTo(0, -6); ctx.lineTo(6, 6);
        ctx.stroke();
        break;

      case 'motor':
        ctx.beginPath();
        ctx.arc(0, 0, 14, 0, Math.PI * 2);
        ctx.stroke();
        ctx.font = 'bold 14px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('M', 0, 1);
        // Spinning indicator
        if (comp.motorSpeed > 0) {
          const angle = this.simTime * comp.motorSpeed * 10;
          for (let i = 0; i < 3; i++) {
            const a = angle + (i * Math.PI * 2 / 3);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(Math.cos(a) * 10, Math.sin(a) * 10);
            ctx.stroke();
          }
        }
        break;

      case 'buzzer':
        ctx.beginPath();
        ctx.arc(0, 0, 12, -Math.PI / 2, Math.PI / 2);
        ctx.lineTo(-12, 12);
        ctx.lineTo(-12, -12);
        ctx.closePath();
        ctx.stroke();
        if (comp.current > 0.01) {
          // Sound waves
          for (let i = 1; i <= 3; i++) {
            ctx.globalAlpha = 1 - i * 0.3;
            ctx.beginPath();
            ctx.arc(12, 0, 4 + i * 5, -Math.PI / 4, Math.PI / 4);
            ctx.stroke();
          }
          ctx.globalAlpha = 1;
        }
        break;

      case 'voltmeter':
        ctx.beginPath();
        ctx.arc(0, 0, 14, 0, Math.PI * 2);
        ctx.stroke();
        ctx.font = 'bold 12px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('V', 0, 1);
        if (this.isSimulating) {
          ctx.font = '8px Courier New';
          ctx.fillStyle = '#10b981';
          ctx.fillText(comp.value.toFixed(1) + 'V', 0, 22);
        }
        break;

      case 'ammeter':
        ctx.beginPath();
        ctx.arc(0, 0, 14, 0, Math.PI * 2);
        ctx.stroke();
        ctx.font = 'bold 12px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('A', 0, 1);
        if (this.isSimulating) {
          ctx.font = '8px Courier New';
          ctx.fillStyle = '#10b981';
          ctx.fillText(comp.value.toFixed(3) + 'A', 0, 22);
        }
        break;
    }
  }

  drawOscilloscope() {
    const ctx = this.oscCtx;
    const w = 236;
    const h = 80;

    ctx.fillStyle = '#0a0e17';
    ctx.fillRect(0, 0, w, h);

    // Grid
    ctx.strokeStyle = '#1a1f2e';
    ctx.lineWidth = 0.5;
    for (let x = 0; x < w; x += 20) {
      ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
    }
    for (let y = 0; y < h; y += 20) {
      ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
    }

    // Center line
    ctx.strokeStyle = '#334155';
    ctx.beginPath();
    ctx.moveTo(0, h / 2);
    ctx.lineTo(w, h / 2);
    ctx.stroke();

    // Waveform
    if (this.isSimulating) {
      ctx.strokeStyle = '#10b981';
      ctx.lineWidth = 1.5;
      ctx.beginPath();

      const maxVal = Math.max(0.001, ...Array.from(this.oscData).map(Math.abs));

      for (let i = 0; i < w; i++) {
        const idx = (this.oscIndex + i) % w;
        const val = this.oscData[idx] || 0;
        const y = h / 2 - (val / maxVal) * (h / 2 - 5);
        if (i === 0) ctx.moveTo(i, y);
        else ctx.lineTo(i, y);
      }
      ctx.stroke();
    }
  }

  // --- UI Updates ---
  showComponentInfo(comp) {
    const el = document.getElementById('component-info');
    if (!comp) {
      el.innerHTML = '<p style="color:#64748b;font-size:12px">Click a component to inspect</p>';
      return;
    }

    const def = COMPONENT_DEFS[comp.type];
    let html = `
      <div class="info-row">
        <span class="info-label">Type:</span>
        <span class="info-value">${def.name}</span>
      </div>
      <div class="info-row">
        <span class="info-label">Value:</span>
        <span class="info-value">${comp.value} ${comp.unit}</span>
      </div>
    `;

    if (this.isSimulating) {
      html += `
        <div class="info-row">
          <span class="info-label">Voltage:</span>
          <span class="info-value">${comp.voltage.toFixed(3)} V</span>
        </div>
        <div class="info-row">
          <span class="info-label">Current:</span>
          <span class="info-value">${(comp.current * 1000).toFixed(1)} mA</span>
        </div>
        <div class="info-row">
          <span class="info-label">Power:</span>
          <span class="info-value ${comp.power > 1 ? 'warn' : ''}">${comp.power.toFixed(3)} W</span>
        </div>
      `;
    }

    if (comp.type === 'switch') {
      html += `
        <div class="info-row">
          <span class="info-label">State:</span>
          <span class="info-value ${comp.state === 'on' ? 'good' : 'danger'}">${comp.state.toUpperCase()}</span>
        </div>
        <p style="color:#64748b;font-size:11px;margin-top:8px">Double-click to toggle</p>
      `;
    }

    // Value slider
    if (!['switch', 'ground', 'voltmeter', 'ammeter'].includes(comp.type)) {
      const maxVal = { battery: 24, ac_source: 240, resistor: 10000, capacitor: 1000, inductor: 100, led: 5, bulb: 200, motor: 24, buzzer: 2000, transistor: 500 };
      html += `
        <div class="slider-group">
          <label>Value: ${comp.value} ${comp.unit}</label>
          <input type="range" min="1" max="${maxVal[comp.type] || 100}" value="${comp.value}"
                 oninput="app.updateComponentValue(${comp.id}, parseFloat(this.value))">
        </div>
      `;
    }

    el.innerHTML = html;
  }

  updateComponentValue(compId, value) {
    const comp = this.components.find(c => c.id === compId);
    if (comp) {
      comp.value = value;
      this.showComponentInfo(comp);
    }
  }

  editComponentValue(comp) {
    const val = prompt('Enter new value for ' + comp.name + ' (' + comp.unit + '):', comp.value);
    if (val !== null && !isNaN(parseFloat(val))) {
      comp.value = parseFloat(val);
      this.showComponentInfo(comp);
    }
  }

  updateCircuitInfo() {
    let totalPower = 0;
    let totalCurrent = 0;
    let totalResistance = 0;
    let resistorCount = 0;

    this.components.forEach(c => {
      totalPower += c.power || 0;
      if (c.type === 'battery' || c.type === 'ac_source') totalCurrent += c.current;
      if (c.type === 'resistor') { totalResistance += c.value; resistorCount++; }
    });

    document.getElementById('total-power').textContent = totalPower.toFixed(3) + ' W';
    document.getElementById('total-power').className = 'info-value' + (totalPower > 10 ? ' danger' : totalPower > 1 ? ' warn' : '');
    document.getElementById('total-current').textContent = (totalCurrent * 1000).toFixed(1) + ' mA';
    document.getElementById('total-resistance').textContent = (resistorCount > 0 ? totalResistance.toFixed(0) : '0') + ' Ohm';
    document.getElementById('total-nodes').textContent = this.components.length;
  }

  updateStatusBar() {
    document.getElementById('status-components').textContent = 'Components: ' + this.components.length;
    document.getElementById('status-wires').textContent = 'Wires: ' + this.wires.length;
  }

  // --- Save/Load ---
  saveState() {
    const state = {
      components: this.components.map(c => ({
        id: c.id, type: c.type, x: c.x, y: c.y,
        rotation: c.rotation, value: c.value, state: c.state
      })),
      wires: this.wires.map(w => ({
        from: { compId: w.from.compId, index: w.from.index },
        to: { compId: w.to.compId, index: w.to.index }
      })),
      camera: this.camera,
      nextId: this.nextId,
      achievements: this.achievements
    };
    localStorage.setItem('circuitLab_save', JSON.stringify(state));
    audio.playSuccess();

    // Export download
    const blob = new Blob([JSON.stringify(state, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'circuit-lab-save.json';
    a.click();
    URL.revokeObjectURL(url);
  }

  loadState() {
    const saved = localStorage.getItem('circuitLab_save');
    if (!saved) return;

    try {
      const state = JSON.parse(saved);
      this.components = [];
      this.wires = [];

      state.components.forEach(sc => {
        const def = COMPONENT_DEFS[sc.type];
        if (!def) return;
        const comp = {
          id: sc.id,
          type: sc.type,
          name: def.name,
          x: sc.x, y: sc.y,
          rotation: sc.rotation || 0,
          value: sc.value,
          unit: def.unit,
          state: sc.state || 'active',
          terminals: [],
          voltage: 0, current: 0, power: 0,
          brightness: 0, motorSpeed: 0, charge: 0
        };
        this.updateTerminals(comp);
        this.components.push(comp);
      });

      this.wires = state.wires || [];
      if (state.camera) this.camera = state.camera;
      this.nextId = state.nextId || this.components.length + 1;
      this.achievements = state.achievements || {};

      this.updateStatusBar();
      this.updateAchievementDisplay();
    } catch(e) {
      console.error('Failed to load state:', e);
    }
  }

  clearCircuit() {
    if (this.components.length === 0) return;
    if (!confirm('Clear all components and wires?')) return;
    this.components = [];
    this.wires = [];
    this.selectedComponent = null;
    this.wireStart = null;
    this.isSimulating = false;
    document.getElementById('simToggle').textContent = 'Run';
    document.getElementById('simToggle').classList.remove('active');
    this.activeBuzzers.forEach(b => b.stop());
    this.activeBuzzers = [];
    this.updateStatusBar();
    this.updateCircuitInfo();
    audio.playDelete();
  }

  // --- Achievements ---
  checkAchievements() {
    const checks = {
      'first_component': { name: 'First Step', desc: 'Place your first component', check: () => this.components.length >= 1 },
      'five_components': { name: 'Getting Wired', desc: 'Place 5 components', check: () => this.components.length >= 5 },
      'ten_components': { name: 'Circuit Board', desc: 'Place 10 components', check: () => this.components.length >= 10 },
      'first_wire': { name: 'Connected', desc: 'Create your first wire', check: () => this.wires.length >= 1 },
      'ten_wires': { name: 'Web of Wires', desc: 'Create 10 wires', check: () => this.wires.length >= 10 },
      'all_types': { name: 'Component Collector', desc: 'Use every component type', check: () => {
        const types = new Set(this.components.map(c => c.type));
        return types.size >= Object.keys(COMPONENT_DEFS).length;
      }},
      'high_power': { name: 'Power Surge', desc: 'Generate over 10W of power', check: () => {
        return this.components.some(c => c.power > 10);
      }}
    };

    Object.entries(checks).forEach(([key, ach]) => {
      if (!this.achievements[key] && ach.check()) {
        this.achievements[key] = { name: ach.name, desc: ach.desc, unlocked: Date.now() };
        audio.playSuccess();
        this.updateAchievementDisplay();
      }
    });
  }

  updateAchievementDisplay() {
    const el = document.getElementById('achievements-list');
    const allAchievements = [
      'first_component', 'five_components', 'ten_components',
      'first_wire', 'ten_wires', 'all_types', 'high_power'
    ];

    el.innerHTML = allAchievements.map(key => {
      const unlocked = this.achievements[key];
      if (unlocked) {
        return `<div style="color:#10b981;margin:4px 0">&#10003; ${unlocked.name}</div>`;
      }
      return `<div style="color:#334155;margin:4px 0">&#9744; ???</div>`;
    }).join('');
  }

  // --- Lessons ---
  buildLessons() {
    return [
      {
        title: 'Lesson 1: Your First Circuit',
        steps: [
          { text: 'Place a Battery from the Sources panel on the left.', trigger: 'place_battery' },
          { text: 'Place a Resistor from the Passive panel.', trigger: 'place_resistor' },
          { text: 'Place an LED from the Active panel.', trigger: 'place_led' },
          { text: 'Use the Wire tool (W) to connect Battery + terminal to Resistor.', trigger: 'connect_wire' },
          { text: 'Wire the Resistor to the LED, and the LED back to Battery -.', trigger: 'connect_wire' },
          { text: 'Press Space or click Run to start the simulation!', trigger: 'start_simulation' },
          { text: 'The LED should light up! Congratulations!', trigger: 'led_lit' }
        ]
      },
      {
        title: 'Lesson 2: Switches and Control',
        steps: [
          { text: 'Start with a Battery and an LED (or use your existing circuit).', trigger: 'place_battery' },
          { text: 'Place a Switch from the Active panel.', trigger: 'place_switch' },
          { text: 'Wire the Switch into your circuit (in series with the LED).', trigger: 'connect_wire' },
          { text: 'Run the simulation. The LED should be off (switch is open).', trigger: 'start_simulation' },
          { text: 'Double-click the Switch to close it. The LED lights up!', trigger: 'toggle_switch' }
        ]
      },
      {
        title: 'Lesson 3: Series vs Parallel',
        steps: [
          { text: 'Build a circuit with a Battery and TWO resistors in series.', trigger: 'place_resistor' },
          { text: 'Add a Voltmeter across each resistor to measure voltage drops.', trigger: 'place_voltmeter' },
          { text: 'Run the simulation and observe: V1 + V2 = Vbattery.', trigger: 'start_simulation' },
          { text: 'Now try connecting the resistors in parallel instead. Notice the difference!', trigger: 'connect_wire' }
        ]
      },
      {
        title: 'Lesson 4: Sound and Motors',
        steps: [
          { text: 'Place a Battery (set to 9V).', trigger: 'place_battery' },
          { text: 'Place a Buzzer from the Output panel.', trigger: 'place_buzzer' },
          { text: 'Wire them together and run. You should hear a tone!', trigger: 'buzzer_sounds' },
          { text: 'Now add a Motor and wire it in parallel with the buzzer.', trigger: 'place_motor' },
          { text: 'Adjust the Battery voltage with the slider and observe changes.', trigger: 'start_simulation' }
        ]
      }
    ];
  }

  toggleLessons() {
    const panel = document.getElementById('lesson-panel');
    if (panel.classList.contains('active')) {
      panel.classList.remove('active');
      return;
    }

    panel.classList.add('active');
    this.showLessonList();
  }

  showLessonList() {
    const panel = document.getElementById('lesson-panel');
    let html = '<h3>Interactive Lessons</h3>';
    this.lessons.forEach((lesson, i) => {
      html += `<div class="lesson-step" style="cursor:pointer" onclick="app.startLesson(${i})">${lesson.title}</div>`;
    });
    panel.innerHTML = html;
  }

  startLesson(index) {
    this.currentLesson = index;
    this.lessonStep = 0;
    this.showCurrentLessonStep();
  }

  showCurrentLessonStep() {
    if (this.currentLesson === null) return;
    const lesson = this.lessons[this.currentLesson];
    const panel = document.getElementById('lesson-panel');

    let html = `<h3>${lesson.title}</h3>`;
    lesson.steps.forEach((step, i) => {
      const cls = i < this.lessonStep ? 'completed' : '';
      const prefix = i < this.lessonStep ? '&#10003; ' : (i === this.lessonStep ? '&#9654; ' : '&#9744; ');
      html += `<div class="lesson-step ${cls}">${prefix}${step.text}</div>`;
    });

    if (this.lessonStep >= lesson.steps.length) {
      html += '<div class="lesson-step" style="border-left-color:#10b981;color:#10b981">Lesson Complete!</div>';
      html += `<div class="lesson-step" style="cursor:pointer" onclick="app.showLessonList()">Back to Lessons</div>`;
    }

    panel.innerHTML = html;
  }

  checkLessonProgress(trigger) {
    if (this.currentLesson === null) return;
    const lesson = this.lessons[this.currentLesson];
    if (this.lessonStep >= lesson.steps.length) return;

    if (lesson.steps[this.lessonStep].trigger === trigger) {
      this.lessonStep++;
      this.showCurrentLessonStep();
      audio.playSuccess();
    }
  }

  // --- Main Loop ---
  animate() {
    const now = performance.now();
    const dt = Math.min(0.05, (now - (this.lastFrame || now)) / 1000);
    this.lastFrame = now;

    this.simulate(dt);
    this.updateParticles(dt);
    this.draw();

    requestAnimationFrame(() => this.animate());
  }
}

// --- Initialize ---
const app = new CircuitLab();

// Make updateComponentValue accessible
window.app = app;
</script>
</body>
</html>