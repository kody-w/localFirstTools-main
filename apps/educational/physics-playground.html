<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physics Playground</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a3e 100%);
            color: #e0e0e0;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            background: rgba(20, 20, 40, 0.9);
            padding: 15px 20px;
            border-bottom: 2px solid rgba(100, 150, 255, 0.3);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        h1 {
            font-size: 28px;
            background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 5px;
        }

        .subtitle {
            font-size: 14px;
            color: #8888aa;
            font-style: italic;
        }

        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .sidebar {
            width: 320px;
            background: rgba(25, 25, 45, 0.95);
            padding: 20px;
            overflow-y: auto;
            border-right: 2px solid rgba(100, 150, 255, 0.2);
            box-shadow: 4px 0 20px rgba(0, 0, 0, 0.3);
        }

        .content {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
            gap: 20px;
            overflow: hidden;
        }

        .canvas-container {
            flex: 1;
            background: rgba(15, 15, 30, 0.8);
            border-radius: 10px;
            border: 2px solid rgba(100, 150, 255, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            position: relative;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .graph-container {
            height: 200px;
            background: rgba(15, 15, 30, 0.8);
            border-radius: 10px;
            border: 2px solid rgba(100, 150, 255, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            position: relative;
        }

        .mode-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .mode-btn {
            flex: 1;
            padding: 12px;
            background: rgba(50, 50, 80, 0.6);
            border: 2px solid rgba(100, 150, 255, 0.3);
            border-radius: 8px;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        .mode-btn:hover {
            background: rgba(70, 70, 110, 0.8);
            border-color: rgba(100, 150, 255, 0.6);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(100, 150, 255, 0.4);
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: rgba(150, 150, 255, 0.8);
            box-shadow: 0 4px 16px rgba(100, 150, 255, 0.6);
        }

        .controls-section {
            margin-bottom: 25px;
            padding: 15px;
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            border: 1px solid rgba(100, 150, 255, 0.2);
        }

        .section-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 12px;
            color: #4facfe;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 13px;
            color: #b0b0c0;
        }

        .control-value {
            color: #00f2fe;
            font-weight: bold;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            background: rgba(100, 150, 255, 0.2);
            border-radius: 3px;
            outline: none;
            transition: background 0.3s;
        }

        input[type="range"]:hover {
            background: rgba(100, 150, 255, 0.3);
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(79, 172, 254, 0.6);
            transition: all 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 12px rgba(79, 172, 254, 0.8);
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(79, 172, 254, 0.6);
            transition: all 0.2s;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        button {
            flex: 1;
            padding: 10px;
            background: rgba(50, 50, 80, 0.6);
            border: 2px solid rgba(100, 150, 255, 0.3);
            border-radius: 6px;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 13px;
            font-weight: bold;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        button:hover {
            background: rgba(70, 70, 110, 0.8);
            border-color: rgba(100, 150, 255, 0.6);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(100, 150, 255, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: rgba(150, 150, 255, 0.8);
        }

        button.danger {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            border-color: rgba(245, 87, 108, 0.8);
        }

        .energy-display {
            padding: 12px;
            background: rgba(30, 30, 50, 0.7);
            border-radius: 6px;
            border: 1px solid rgba(100, 150, 255, 0.2);
            font-size: 12px;
            line-height: 1.6;
        }

        .energy-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .energy-label {
            color: #b0b0c0;
        }

        .energy-value {
            font-weight: bold;
            color: #00f2fe;
        }

        .energy-bar {
            height: 4px;
            background: rgba(100, 150, 255, 0.2);
            border-radius: 2px;
            margin-top: 3px;
            overflow: hidden;
        }

        .energy-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
            transition: width 0.3s ease;
            border-radius: 2px;
        }

        .info-text {
            font-size: 11px;
            color: #8888aa;
            margin-top: 15px;
            padding: 10px;
            background: rgba(20, 20, 40, 0.5);
            border-radius: 6px;
            line-height: 1.5;
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 10px;
        }

        .preset-btn {
            padding: 8px;
            background: rgba(40, 40, 60, 0.6);
            border: 1px solid rgba(100, 150, 255, 0.3);
            border-radius: 5px;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s ease;
        }

        .preset-btn:hover {
            background: rgba(60, 60, 90, 0.8);
            border-color: rgba(100, 150, 255, 0.5);
        }

        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                border-right: none;
                border-bottom: 2px solid rgba(100, 150, 255, 0.2);
                max-height: 40vh;
            }

            .graph-container {
                height: 150px;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Physics Playground</h1>
        <div class="subtitle">Interactive Physics Simulations with Real-Time Analysis</div>
    </header>

    <div class="main-container">
        <div class="sidebar">
            <div class="mode-selector">
                <button class="mode-btn active" data-mode="projectile">Projectile</button>
                <button class="mode-btn" data-mode="pendulum">Pendulum</button>
                <button class="mode-btn" data-mode="spring">Spring</button>
            </div>

            <div class="controls-section">
                <div class="section-title">Difficulty Mode</div>
                <div class="mode-selector">
                    <button class="mode-btn difficulty-btn active" data-difficulty="easy">Easy</button>
                    <button class="mode-btn difficulty-btn" data-difficulty="medium">Medium</button>
                    <button class="mode-btn difficulty-btn" data-difficulty="hard">Hard</button>
                </div>
                <div class="info-text" style="margin-top: 10px;">
                    <strong>How to Play:</strong> Select a physics simulation mode above. Use sliders to adjust parameters. Click Play to start. Try different difficulty levels for varied complexity and parameter ranges. Complete challenge levels to track your best scores!
                </div>
            </div>

            <div class="controls-section">
                <div class="section-title">Challenge Levels & High Scores</div>
                <div class="energy-display">
                    <div class="energy-row">
                        <span class="energy-label">Current Level:</span>
                        <span class="energy-value" id="current-level">1</span>
                    </div>
                    <div class="energy-row">
                        <span class="energy-label">Best Distance:</span>
                        <span class="energy-value" id="best-distance">0.0 m</span>
                    </div>
                    <div class="energy-row">
                        <span class="energy-label">Best Period:</span>
                        <span class="energy-value" id="best-period">0.0 s</span>
                    </div>
                    <div class="energy-row">
                        <span class="energy-label">Personal Best:</span>
                        <span class="energy-value" id="personal-best">0 pts</span>
                    </div>
                </div>
                <div class="button-group" style="margin-top: 10px;">
                    <button id="next-level-btn">Next Level</button>
                    <button id="restart-level-btn">Restart Level</button>
                </div>
            </div>

            <div class="controls-section" id="projectile-controls">
                <div class="section-title">Projectile Motion</div>
                <div class="control-group">
                    <div class="control-label">
                        <span>Launch Angle</span>
                        <span class="control-value" id="angle-value">45°</span>
                    </div>
                    <input type="range" id="angle-slider" min="0" max="90" value="45" step="1">
                </div>
                <div class="control-group">
                    <div class="control-label">
                        <span>Initial Velocity</span>
                        <span class="control-value" id="velocity-value">30 m/s</span>
                    </div>
                    <input type="range" id="velocity-slider" min="5" max="60" value="30" step="1">
                </div>
                <div class="control-group">
                    <div class="control-label">
                        <span>Gravity</span>
                        <span class="control-value" id="proj-gravity-value">9.8 m/s²</span>
                    </div>
                    <input type="range" id="proj-gravity-slider" min="1" max="20" value="9.8" step="0.1">
                </div>
                <div class="preset-buttons">
                    <button class="preset-btn" data-preset="proj-earth">Earth</button>
                    <button class="preset-btn" data-preset="proj-moon">Moon</button>
                    <button class="preset-btn" data-preset="proj-mars">Mars</button>
                    <button class="preset-btn" data-preset="proj-jupiter">Jupiter</button>
                </div>
                <div class="info-text">
                    Classic projectile motion demonstrates parabolic trajectories under constant gravitational acceleration. The path depends on initial velocity and launch angle.
                </div>
            </div>

            <div class="controls-section" id="pendulum-controls" style="display:none;">
                <div class="section-title">Pendulum Simulation</div>
                <div class="control-group">
                    <div class="control-label">
                        <span>Pendulum Length</span>
                        <span class="control-value" id="length-value">2.0 m</span>
                    </div>
                    <input type="range" id="length-slider" min="0.5" max="5" value="2" step="0.1">
                </div>
                <div class="control-group">
                    <div class="control-label">
                        <span>Initial Angle</span>
                        <span class="control-value" id="initial-angle-value">45°</span>
                    </div>
                    <input type="range" id="initial-angle-slider" min="5" max="170" value="45" step="5">
                </div>
                <div class="control-group">
                    <div class="control-label">
                        <span>Gravity</span>
                        <span class="control-value" id="pend-gravity-value">9.8 m/s²</span>
                    </div>
                    <input type="range" id="pend-gravity-slider" min="1" max="20" value="9.8" step="0.1">
                </div>
                <div class="control-group">
                    <div class="control-label">
                        <span>Damping</span>
                        <span class="control-value" id="damping-value">0.05</span>
                    </div>
                    <input type="range" id="damping-slider" min="0" max="0.5" value="0.05" step="0.01">
                </div>
                <div class="preset-buttons">
                    <button class="preset-btn" data-preset="pend-small">Small Swing</button>
                    <button class="preset-btn" data-preset="pend-large">Large Swing</button>
                    <button class="preset-btn" data-preset="pend-fast">Fast</button>
                    <button class="preset-btn" data-preset="pend-slow">Slow</button>
                </div>
                <div class="info-text">
                    The simple pendulum demonstrates periodic motion and energy conservation. Period depends on length and gravity (T = 2π√(L/g) for small angles).
                </div>
            </div>

            <div class="controls-section" id="spring-controls" style="display:none;">
                <div class="section-title">Spring-Mass System</div>
                <div class="control-group">
                    <div class="control-label">
                        <span>Spring Constant (k)</span>
                        <span class="control-value" id="spring-k-value">50 N/m</span>
                    </div>
                    <input type="range" id="spring-k-slider" min="10" max="200" value="50" step="5">
                </div>
                <div class="control-group">
                    <div class="control-label">
                        <span>Mass</span>
                        <span class="control-value" id="mass-value">1.0 kg</span>
                    </div>
                    <input type="range" id="mass-slider" min="0.1" max="5" value="1" step="0.1">
                </div>
                <div class="control-group">
                    <div class="control-label">
                        <span>Damping Coefficient</span>
                        <span class="control-value" id="spring-damping-value">2</span>
                    </div>
                    <input type="range" id="spring-damping-slider" min="0" max="20" value="2" step="0.5">
                </div>
                <div class="control-group">
                    <div class="control-label">
                        <span>Initial Displacement</span>
                        <span class="control-value" id="displacement-value">1.0 m</span>
                    </div>
                    <input type="range" id="displacement-slider" min="0.2" max="3" value="1" step="0.1">
                </div>
                <div class="preset-buttons">
                    <button class="preset-btn" data-preset="spring-underdamped">Underdamped</button>
                    <button class="preset-btn" data-preset="spring-critical">Critical</button>
                    <button class="preset-btn" data-preset="spring-overdamped">Overdamped</button>
                    <button class="preset-btn" data-preset="spring-stiff">Stiff</button>
                </div>
                <div class="info-text">
                    Harmonic oscillator with damping. The system exhibits underdamped, critically damped, or overdamped behavior based on the damping ratio.
                </div>
            </div>

            <div class="controls-section">
                <div class="section-title">Energy Analysis</div>
                <div class="energy-display" id="energy-display">
                    <div class="energy-row">
                        <span class="energy-label">Kinetic Energy:</span>
                        <span class="energy-value" id="kinetic-energy">0.0 J</span>
                    </div>
                    <div class="energy-bar">
                        <div class="energy-bar-fill" id="kinetic-bar" style="width: 0%"></div>
                    </div>
                    <div class="energy-row" style="margin-top: 8px;">
                        <span class="energy-label">Potential Energy:</span>
                        <span class="energy-value" id="potential-energy">0.0 J</span>
                    </div>
                    <div class="energy-bar">
                        <div class="energy-bar-fill" id="potential-bar" style="width: 0%"></div>
                    </div>
                    <div class="energy-row" style="margin-top: 8px;">
                        <span class="energy-label">Total Energy:</span>
                        <span class="energy-value" id="total-energy">0.0 J</span>
                    </div>
                </div>
            </div>

            <div class="button-group">
                <button id="play-pause-btn" class="primary">Play</button>
                <button id="reset-btn" class="danger">Reset</button>
            </div>

            <div class="button-group">
                <button id="save-config-btn">Save Config</button>
                <button id="load-config-btn">Load Config</button>
            </div>
        </div>

        <div class="content">
            <div class="canvas-container">
                <canvas id="simulation-canvas"></canvas>
            </div>
            <div class="graph-container">
                <canvas id="graph-canvas"></canvas>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const simCanvas = document.getElementById('simulation-canvas');
        const simCtx = simCanvas.getContext('2d');
        const graphCanvas = document.getElementById('graph-canvas');
        const graphCtx = graphCanvas.getContext('2d');

        let simWidth, simHeight, graphWidth, graphHeight;

        function resizeCanvases() {
            simWidth = simCanvas.parentElement.clientWidth;
            simHeight = simCanvas.parentElement.clientHeight;
            simCanvas.width = simWidth;
            simCanvas.height = simHeight;

            graphWidth = graphCanvas.parentElement.clientWidth;
            graphHeight = graphCanvas.parentElement.clientHeight;
            graphCanvas.width = graphWidth;
            graphCanvas.height = graphHeight;
        }

        resizeCanvases();
        window.addEventListener('resize', resizeCanvases);

        // Global state
        let currentMode = 'projectile';
        let isPaused = true;
        let lastTime = 0;
        let currentDifficulty = 'easy';
        let currentLevel = 1;
        let highScores = {
            bestDistance: 0,
            bestPeriod: 0,
            personalBest: 0
        };

        // Graph data storage
        const maxGraphPoints = 300;
        let graphData = {
            time: [],
            position: [],
            velocity: [],
            energy: []
        };

        // Projectile state
        const projectile = {
            x: 0,
            y: 0,
            vx: 0,
            vy: 0,
            angle: 45,
            velocity: 30,
            gravity: 9.8,
            time: 0,
            trail: [],
            maxTrailLength: 100
        };

        // Pendulum state
        const pendulum = {
            length: 2.0,
            angle: Math.PI / 4,
            angularVelocity: 0,
            gravity: 9.8,
            damping: 0.05,
            initialAngle: Math.PI / 4,
            time: 0,
            mass: 1.0
        };

        // Spring state
        const spring = {
            k: 50,
            mass: 1.0,
            damping: 2,
            displacement: 1.0,
            velocity: 0,
            initialDisplacement: 1.0,
            equilibrium: 0,
            time: 0
        };

        // UI Elements
        const playPauseBtn = document.getElementById('play-pause-btn');
        const resetBtn = document.getElementById('reset-btn');
        const saveConfigBtn = document.getElementById('save-config-btn');
        const loadConfigBtn = document.getElementById('load-config-btn');
        const nextLevelBtn = document.getElementById('next-level-btn');
        const restartLevelBtn = document.getElementById('restart-level-btn');

        // Load high scores from localStorage
        function loadHighScores() {
            const saved = localStorage.getItem('physicsPlaygroundHighScores');
            if (saved) {
                highScores = JSON.parse(saved);
                updateHighScoreDisplay();
            }
        }

        function saveHighScores() {
            localStorage.setItem('physicsPlaygroundHighScores', JSON.stringify(highScores));
        }

        function updateHighScoreDisplay() {
            document.getElementById('current-level').textContent = currentLevel;
            document.getElementById('best-distance').textContent = highScores.bestDistance.toFixed(1) + ' m';
            document.getElementById('best-period').textContent = highScores.bestPeriod.toFixed(2) + ' s';
            document.getElementById('personal-best').textContent = highScores.personalBest + ' pts';
        }

        function checkAndUpdateHighScores() {
            let updated = false;

            if (currentMode === 'projectile') {
                const distance = (projectile.x - 50) / 10;
                if (distance > highScores.bestDistance) {
                    highScores.bestDistance = distance;
                    updated = true;
                }
            } else if (currentMode === 'pendulum') {
                const period = 2 * Math.PI * Math.sqrt(pendulum.length / pendulum.gravity);
                if (period > highScores.bestPeriod) {
                    highScores.bestPeriod = period;
                    updated = true;
                }
            }

            if (updated) {
                highScores.personalBest += 100;
                saveHighScores();
                updateHighScoreDisplay();
            }
        }

        // Mode switching
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                if (btn.dataset.mode) {
                    document.querySelectorAll('.mode-btn:not(.difficulty-btn)').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentMode = btn.dataset.mode;
                    switchMode(currentMode);
                }
            });
        });

        // Difficulty switching
        document.querySelectorAll('.difficulty-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentDifficulty = btn.dataset.difficulty;
                applyDifficulty(currentDifficulty);
            });
        });

        function applyDifficulty(difficulty) {
            switch(difficulty) {
                case 'easy':
                    velocitySlider.max = 40;
                    projGravitySlider.max = 15;
                    lengthSlider.max = 3;
                    springKSlider.max = 100;
                    break;
                case 'medium':
                    velocitySlider.max = 60;
                    projGravitySlider.max = 20;
                    lengthSlider.max = 5;
                    springKSlider.max = 200;
                    break;
                case 'hard':
                    velocitySlider.max = 100;
                    projGravitySlider.max = 30;
                    lengthSlider.max = 8;
                    springKSlider.max = 300;
                    break;
            }
        }

        function switchMode(mode) {
            document.getElementById('projectile-controls').style.display = mode === 'projectile' ? 'block' : 'none';
            document.getElementById('pendulum-controls').style.display = mode === 'pendulum' ? 'block' : 'none';
            document.getElementById('spring-controls').style.display = mode === 'spring' ? 'block' : 'none';
            resetSimulation();
        }

        // Projectile controls
        const angleSlider = document.getElementById('angle-slider');
        const velocitySlider = document.getElementById('velocity-slider');
        const projGravitySlider = document.getElementById('proj-gravity-slider');

        angleSlider.addEventListener('input', (e) => {
            projectile.angle = parseFloat(e.target.value);
            document.getElementById('angle-value').textContent = projectile.angle + '°';
        });

        velocitySlider.addEventListener('input', (e) => {
            projectile.velocity = parseFloat(e.target.value);
            document.getElementById('velocity-value').textContent = projectile.velocity + ' m/s';
        });

        projGravitySlider.addEventListener('input', (e) => {
            projectile.gravity = parseFloat(e.target.value);
            document.getElementById('proj-gravity-value').textContent = projectile.gravity.toFixed(1) + ' m/s²';
        });

        // Pendulum controls
        const lengthSlider = document.getElementById('length-slider');
        const initialAngleSlider = document.getElementById('initial-angle-slider');
        const pendGravitySlider = document.getElementById('pend-gravity-slider');
        const dampingSlider = document.getElementById('damping-slider');

        lengthSlider.addEventListener('input', (e) => {
            pendulum.length = parseFloat(e.target.value);
            document.getElementById('length-value').textContent = pendulum.length.toFixed(1) + ' m';
        });

        initialAngleSlider.addEventListener('input', (e) => {
            const degrees = parseFloat(e.target.value);
            pendulum.initialAngle = (degrees * Math.PI) / 180;
            document.getElementById('initial-angle-value').textContent = degrees + '°';
        });

        pendGravitySlider.addEventListener('input', (e) => {
            pendulum.gravity = parseFloat(e.target.value);
            document.getElementById('pend-gravity-value').textContent = pendulum.gravity.toFixed(1) + ' m/s²';
        });

        dampingSlider.addEventListener('input', (e) => {
            pendulum.damping = parseFloat(e.target.value);
            document.getElementById('damping-value').textContent = pendulum.damping.toFixed(2);
        });

        // Spring controls
        const springKSlider = document.getElementById('spring-k-slider');
        const massSlider = document.getElementById('mass-slider');
        const springDampingSlider = document.getElementById('spring-damping-slider');
        const displacementSlider = document.getElementById('displacement-slider');

        springKSlider.addEventListener('input', (e) => {
            spring.k = parseFloat(e.target.value);
            document.getElementById('spring-k-value').textContent = spring.k + ' N/m';
        });

        massSlider.addEventListener('input', (e) => {
            spring.mass = parseFloat(e.target.value);
            document.getElementById('mass-value').textContent = spring.mass.toFixed(1) + ' kg';
        });

        springDampingSlider.addEventListener('input', (e) => {
            spring.damping = parseFloat(e.target.value);
            document.getElementById('spring-damping-value').textContent = spring.damping.toFixed(1);
        });

        displacementSlider.addEventListener('input', (e) => {
            spring.initialDisplacement = parseFloat(e.target.value);
            document.getElementById('displacement-value').textContent = spring.initialDisplacement.toFixed(1) + ' m';
        });

        // Preset buttons
        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                applyPreset(btn.dataset.preset);
            });
        });

        function applyPreset(preset) {
            switch(preset) {
                case 'proj-earth':
                    projGravitySlider.value = 9.8;
                    projGravitySlider.dispatchEvent(new Event('input'));
                    break;
                case 'proj-moon':
                    projGravitySlider.value = 1.6;
                    projGravitySlider.dispatchEvent(new Event('input'));
                    break;
                case 'proj-mars':
                    projGravitySlider.value = 3.7;
                    projGravitySlider.dispatchEvent(new Event('input'));
                    break;
                case 'proj-jupiter':
                    projGravitySlider.value = 24.8;
                    projGravitySlider.dispatchEvent(new Event('input'));
                    break;
                case 'pend-small':
                    initialAngleSlider.value = 15;
                    initialAngleSlider.dispatchEvent(new Event('input'));
                    break;
                case 'pend-large':
                    initialAngleSlider.value = 120;
                    initialAngleSlider.dispatchEvent(new Event('input'));
                    break;
                case 'pend-fast':
                    lengthSlider.value = 0.5;
                    lengthSlider.dispatchEvent(new Event('input'));
                    break;
                case 'pend-slow':
                    lengthSlider.value = 4;
                    lengthSlider.dispatchEvent(new Event('input'));
                    break;
                case 'spring-underdamped':
                    springDampingSlider.value = 2;
                    springDampingSlider.dispatchEvent(new Event('input'));
                    break;
                case 'spring-critical':
                    const criticalDamping = 2 * Math.sqrt(spring.k * spring.mass);
                    springDampingSlider.value = Math.min(20, criticalDamping);
                    springDampingSlider.dispatchEvent(new Event('input'));
                    break;
                case 'spring-overdamped':
                    springDampingSlider.value = 15;
                    springDampingSlider.dispatchEvent(new Event('input'));
                    break;
                case 'spring-stiff':
                    springKSlider.value = 150;
                    springKSlider.dispatchEvent(new Event('input'));
                    break;
            }
            resetSimulation();
        }

        // Control buttons
        playPauseBtn.addEventListener('click', () => {
            isPaused = !isPaused;
            playPauseBtn.textContent = isPaused ? 'Play' : 'Pause';
            if (!isPaused) {
                lastTime = performance.now();
                requestAnimationFrame(gameLoop);
            }
        });

        resetBtn.addEventListener('click', resetSimulation);

        nextLevelBtn.addEventListener('click', () => {
            currentLevel++;
            updateHighScoreDisplay();
            resetSimulation();
        });

        restartLevelBtn.addEventListener('click', () => {
            resetSimulation();
        });

        saveConfigBtn.addEventListener('click', () => {
            const config = {
                mode: currentMode,
                projectile: {...projectile},
                pendulum: {...pendulum},
                spring: {...spring}
            };
            localStorage.setItem('physicsPlaygroundConfig', JSON.stringify(config));
            alert('Configuration saved!');
        });

        loadConfigBtn.addEventListener('click', () => {
            const saved = localStorage.getItem('physicsPlaygroundConfig');
            if (saved) {
                const config = JSON.parse(saved);

                // Load projectile settings
                if (config.projectile) {
                    angleSlider.value = config.projectile.angle;
                    velocitySlider.value = config.projectile.velocity;
                    projGravitySlider.value = config.projectile.gravity;
                    angleSlider.dispatchEvent(new Event('input'));
                    velocitySlider.dispatchEvent(new Event('input'));
                    projGravitySlider.dispatchEvent(new Event('input'));
                }

                // Load pendulum settings
                if (config.pendulum) {
                    lengthSlider.value = config.pendulum.length;
                    initialAngleSlider.value = (config.pendulum.initialAngle * 180) / Math.PI;
                    pendGravitySlider.value = config.pendulum.gravity;
                    dampingSlider.value = config.pendulum.damping;
                    lengthSlider.dispatchEvent(new Event('input'));
                    initialAngleSlider.dispatchEvent(new Event('input'));
                    pendGravitySlider.dispatchEvent(new Event('input'));
                    dampingSlider.dispatchEvent(new Event('input'));
                }

                // Load spring settings
                if (config.spring) {
                    springKSlider.value = config.spring.k;
                    massSlider.value = config.spring.mass;
                    springDampingSlider.value = config.spring.damping;
                    displacementSlider.value = config.spring.initialDisplacement;
                    springKSlider.dispatchEvent(new Event('input'));
                    massSlider.dispatchEvent(new Event('input'));
                    springDampingSlider.dispatchEvent(new Event('input'));
                    displacementSlider.dispatchEvent(new Event('input'));
                }

                alert('Configuration loaded!');
                resetSimulation();
            } else {
                alert('No saved configuration found.');
            }
        });

        // Reset simulation
        function resetSimulation() {
            isPaused = true;
            playPauseBtn.textContent = 'Play';

            // Clear graph data
            graphData.time = [];
            graphData.position = [];
            graphData.velocity = [];
            graphData.energy = [];

            if (currentMode === 'projectile') {
                projectile.x = 50;
                projectile.y = simHeight - 100;
                const angleRad = (projectile.angle * Math.PI) / 180;
                projectile.vx = projectile.velocity * Math.cos(angleRad);
                projectile.vy = -projectile.velocity * Math.sin(angleRad);
                projectile.time = 0;
                projectile.trail = [];
            } else if (currentMode === 'pendulum') {
                pendulum.angle = pendulum.initialAngle;
                pendulum.angularVelocity = 0;
                pendulum.time = 0;
            } else if (currentMode === 'spring') {
                spring.displacement = spring.initialDisplacement;
                spring.velocity = 0;
                spring.time = 0;
            }

            draw();
            drawGraph();
            updateEnergyDisplay();
            checkAndUpdateHighScores();
        }

        // Physics update
        function updatePhysics(dt) {
            if (currentMode === 'projectile') {
                updateProjectile(dt);
            } else if (currentMode === 'pendulum') {
                updatePendulum(dt);
            } else if (currentMode === 'spring') {
                updateSpring(dt);
            }
        }

        function updateProjectile(dt) {
            const scale = 10; // pixels per meter

            projectile.vy += projectile.gravity * dt;
            projectile.x += projectile.vx * scale * dt;
            projectile.y += projectile.vy * scale * dt;
            projectile.time += dt;

            // Trail
            projectile.trail.push({x: projectile.x, y: projectile.y});
            if (projectile.trail.length > projectile.maxTrailLength) {
                projectile.trail.shift();
            }

            // Graph data
            const height = (simHeight - 100 - projectile.y) / scale;
            const speed = Math.sqrt(projectile.vx * projectile.vx + projectile.vy * projectile.vy);

            addGraphPoint(projectile.time, height, speed);

            // Ground collision
            if (projectile.y >= simHeight - 50) {
                projectile.y = simHeight - 50;
                projectile.vy = -projectile.vy * 0.7; // bounce with energy loss
                projectile.vx *= 0.9; // friction

                if (Math.abs(projectile.vy) < 0.5) {
                    projectile.vy = 0;
                    projectile.vx *= 0.95;
                }
            }

            // Side boundaries
            if (projectile.x < 20 || projectile.x > simWidth - 20) {
                projectile.vx = -projectile.vx * 0.7;
                projectile.x = projectile.x < 20 ? 20 : simWidth - 20;
            }
        }

        function updatePendulum(dt) {
            const angularAcceleration = -(pendulum.gravity / pendulum.length) * Math.sin(pendulum.angle) - pendulum.damping * pendulum.angularVelocity;

            pendulum.angularVelocity += angularAcceleration * dt;
            pendulum.angle += pendulum.angularVelocity * dt;
            pendulum.time += dt;

            // Graph data
            const angularSpeed = Math.abs(pendulum.angularVelocity);
            addGraphPoint(pendulum.time, pendulum.angle, angularSpeed);
        }

        function updateSpring(dt) {
            const acceleration = (-spring.k * spring.displacement - spring.damping * spring.velocity) / spring.mass;

            spring.velocity += acceleration * dt;
            spring.displacement += spring.velocity * dt;
            spring.time += dt;

            // Graph data
            const speed = Math.abs(spring.velocity);
            addGraphPoint(spring.time, spring.displacement, speed);
        }

        function addGraphPoint(time, position, velocity) {
            graphData.time.push(time);
            graphData.position.push(position);
            graphData.velocity.push(velocity);

            const energy = calculateTotalEnergy();
            graphData.energy.push(energy);

            if (graphData.time.length > maxGraphPoints) {
                graphData.time.shift();
                graphData.position.shift();
                graphData.velocity.shift();
                graphData.energy.shift();
            }
        }

        function calculateTotalEnergy() {
            let ke = 0, pe = 0;

            if (currentMode === 'projectile') {
                const speed = Math.sqrt(projectile.vx * projectile.vx + projectile.vy * projectile.vy);
                const mass = 1; // assume 1kg for display
                ke = 0.5 * mass * speed * speed;
                const height = (simHeight - 100 - projectile.y) / 10;
                pe = mass * projectile.gravity * Math.max(0, height);
            } else if (currentMode === 'pendulum') {
                const speed = Math.abs(pendulum.angularVelocity * pendulum.length);
                ke = 0.5 * pendulum.mass * speed * speed;
                const height = pendulum.length * (1 - Math.cos(pendulum.angle));
                pe = pendulum.mass * pendulum.gravity * height;
            } else if (currentMode === 'spring') {
                ke = 0.5 * spring.mass * spring.velocity * spring.velocity;
                pe = 0.5 * spring.k * spring.displacement * spring.displacement;
            }

            return ke + pe;
        }

        function updateEnergyDisplay() {
            let ke = 0, pe = 0;

            if (currentMode === 'projectile') {
                const speed = Math.sqrt(projectile.vx * projectile.vx + projectile.vy * projectile.vy);
                const mass = 1;
                ke = 0.5 * mass * speed * speed;
                const height = (simHeight - 100 - projectile.y) / 10;
                pe = mass * projectile.gravity * Math.max(0, height);
            } else if (currentMode === 'pendulum') {
                const speed = Math.abs(pendulum.angularVelocity * pendulum.length);
                ke = 0.5 * pendulum.mass * speed * speed;
                const height = pendulum.length * (1 - Math.cos(pendulum.angle));
                pe = pendulum.mass * pendulum.gravity * height;
            } else if (currentMode === 'spring') {
                ke = 0.5 * spring.mass * spring.velocity * spring.velocity;
                pe = 0.5 * spring.k * spring.displacement * spring.displacement;
            }

            const total = ke + pe;

            document.getElementById('kinetic-energy').textContent = ke.toFixed(2) + ' J';
            document.getElementById('potential-energy').textContent = pe.toFixed(2) + ' J';
            document.getElementById('total-energy').textContent = total.toFixed(2) + ' J';

            const maxEnergy = Math.max(total, 0.1);
            document.getElementById('kinetic-bar').style.width = ((ke / maxEnergy) * 100) + '%';
            document.getElementById('potential-bar').style.width = ((pe / maxEnergy) * 100) + '%';
        }

        // Drawing functions
        function draw() {
            simCtx.fillStyle = 'rgba(10, 10, 25, 0.95)';
            simCtx.fillRect(0, 0, simWidth, simHeight);

            // Draw grid
            drawGrid();

            if (currentMode === 'projectile') {
                drawProjectile();
            } else if (currentMode === 'pendulum') {
                drawPendulum();
            } else if (currentMode === 'spring') {
                drawSpring();
            }
        }

        function drawGrid() {
            simCtx.strokeStyle = 'rgba(100, 150, 255, 0.1)';
            simCtx.lineWidth = 1;

            const gridSize = 50;
            for (let x = 0; x < simWidth; x += gridSize) {
                simCtx.beginPath();
                simCtx.moveTo(x, 0);
                simCtx.lineTo(x, simHeight);
                simCtx.stroke();
            }

            for (let y = 0; y < simHeight; y += gridSize) {
                simCtx.beginPath();
                simCtx.moveTo(0, y);
                simCtx.lineTo(simWidth, y);
                simCtx.stroke();
            }
        }

        function drawProjectile() {
            // Ground
            simCtx.fillStyle = 'rgba(100, 150, 100, 0.3)';
            simCtx.fillRect(0, simHeight - 50, simWidth, 50);

            simCtx.strokeStyle = 'rgba(150, 200, 150, 0.6)';
            simCtx.lineWidth = 2;
            simCtx.beginPath();
            simCtx.moveTo(0, simHeight - 50);
            simCtx.lineTo(simWidth, simHeight - 50);
            simCtx.stroke();

            // Trail
            if (projectile.trail.length > 1) {
                simCtx.strokeStyle = 'rgba(79, 172, 254, 0.4)';
                simCtx.lineWidth = 3;
                simCtx.beginPath();
                simCtx.moveTo(projectile.trail[0].x, projectile.trail[0].y);
                for (let i = 1; i < projectile.trail.length; i++) {
                    simCtx.lineTo(projectile.trail[i].x, projectile.trail[i].y);
                }
                simCtx.stroke();

                // Trail dots
                for (let i = 0; i < projectile.trail.length; i += 5) {
                    const alpha = i / projectile.trail.length;
                    simCtx.fillStyle = 'rgba(79, 172, 254, ' + (alpha * 0.6) + ')';
                    simCtx.beginPath();
                    simCtx.arc(projectile.trail[i].x, projectile.trail[i].y, 3, 0, Math.PI * 2);
                    simCtx.fill();
                }
            }

            // Projectile
            const gradient = simCtx.createRadialGradient(projectile.x, projectile.y, 0, projectile.x, projectile.y, 15);
            gradient.addColorStop(0, 'rgba(255, 100, 100, 1)');
            gradient.addColorStop(0.7, 'rgba(255, 50, 50, 0.8)');
            gradient.addColorStop(1, 'rgba(255, 0, 0, 0.4)');

            simCtx.fillStyle = gradient;
            simCtx.beginPath();
            simCtx.arc(projectile.x, projectile.y, 15, 0, Math.PI * 2);
            simCtx.fill();

            simCtx.strokeStyle = 'rgba(255, 150, 150, 0.8)';
            simCtx.lineWidth = 2;
            simCtx.stroke();

            // Velocity vector
            const vecScale = 0.5;
            simCtx.strokeStyle = 'rgba(0, 255, 200, 0.8)';
            simCtx.lineWidth = 3;
            simCtx.beginPath();
            simCtx.moveTo(projectile.x, projectile.y);
            simCtx.lineTo(projectile.x + projectile.vx * vecScale, projectile.y + projectile.vy * vecScale);
            simCtx.stroke();

            // Arrow head
            const angle = Math.atan2(projectile.vy, projectile.vx);
            const arrowLength = 10;
            simCtx.beginPath();
            simCtx.moveTo(projectile.x + projectile.vx * vecScale, projectile.y + projectile.vy * vecScale);
            simCtx.lineTo(
                projectile.x + projectile.vx * vecScale - arrowLength * Math.cos(angle - Math.PI / 6),
                projectile.y + projectile.vy * vecScale - arrowLength * Math.sin(angle - Math.PI / 6)
            );
            simCtx.moveTo(projectile.x + projectile.vx * vecScale, projectile.y + projectile.vy * vecScale);
            simCtx.lineTo(
                projectile.x + projectile.vx * vecScale - arrowLength * Math.cos(angle + Math.PI / 6),
                projectile.y + projectile.vy * vecScale - arrowLength * Math.sin(angle + Math.PI / 6)
            );
            simCtx.stroke();
        }

        function drawPendulum() {
            const centerX = simWidth / 2;
            const centerY = 100;
            const scale = 50; // pixels per meter

            const bobX = centerX + pendulum.length * scale * Math.sin(pendulum.angle);
            const bobY = centerY + pendulum.length * scale * Math.cos(pendulum.angle);

            // Pivot point
            simCtx.fillStyle = 'rgba(150, 150, 150, 0.8)';
            simCtx.beginPath();
            simCtx.arc(centerX, centerY, 8, 0, Math.PI * 2);
            simCtx.fill();

            simCtx.strokeStyle = 'rgba(200, 200, 200, 0.6)';
            simCtx.lineWidth = 2;
            simCtx.stroke();

            // String
            simCtx.strokeStyle = 'rgba(150, 200, 255, 0.6)';
            simCtx.lineWidth = 3;
            simCtx.beginPath();
            simCtx.moveTo(centerX, centerY);
            simCtx.lineTo(bobX, bobY);
            simCtx.stroke();

            // Arc showing swing range
            simCtx.strokeStyle = 'rgba(100, 150, 255, 0.2)';
            simCtx.lineWidth = 1;
            simCtx.beginPath();
            simCtx.arc(centerX, centerY, pendulum.length * scale, 0, Math.PI);
            simCtx.stroke();

            // Bob
            const bobRadius = 20;
            const bobGradient = simCtx.createRadialGradient(bobX - 5, bobY - 5, 0, bobX, bobY, bobRadius);
            bobGradient.addColorStop(0, 'rgba(255, 200, 100, 1)');
            bobGradient.addColorStop(0.7, 'rgba(255, 150, 50, 0.9)');
            bobGradient.addColorStop(1, 'rgba(200, 100, 0, 0.6)');

            simCtx.fillStyle = bobGradient;
            simCtx.beginPath();
            simCtx.arc(bobX, bobY, bobRadius, 0, Math.PI * 2);
            simCtx.fill();

            simCtx.strokeStyle = 'rgba(255, 200, 150, 0.8)';
            simCtx.lineWidth = 2;
            simCtx.stroke();

            // Velocity indicator
            const speed = Math.abs(pendulum.angularVelocity);
            const velocityLength = speed * 30;
            const perpAngle = pendulum.angle + Math.PI / 2;
            const direction = pendulum.angularVelocity > 0 ? 1 : -1;

            if (velocityLength > 1) {
                simCtx.strokeStyle = 'rgba(0, 255, 200, 0.7)';
                simCtx.lineWidth = 3;
                simCtx.beginPath();
                simCtx.moveTo(bobX, bobY);
                simCtx.lineTo(
                    bobX + direction * velocityLength * Math.cos(perpAngle),
                    bobY + direction * velocityLength * Math.sin(perpAngle)
                );
                simCtx.stroke();
            }
        }

        function drawSpring() {
            const centerX = simWidth / 2;
            const topY = 100;
            const scale = 50;

            const massY = topY + (spring.equilibrium + spring.displacement) * scale + 200;

            // Ceiling
            simCtx.fillStyle = 'rgba(100, 100, 120, 0.5)';
            simCtx.fillRect(0, topY - 20, simWidth, 20);

            // Spring
            drawCoilSpring(centerX, topY, centerX, massY);

            // Equilibrium line
            const eqY = topY + 200;
            simCtx.strokeStyle = 'rgba(100, 255, 100, 0.3)';
            simCtx.lineWidth = 2;
            simCtx.setLineDash([5, 5]);
            simCtx.beginPath();
            simCtx.moveTo(centerX - 100, eqY);
            simCtx.lineTo(centerX + 100, eqY);
            simCtx.stroke();
            simCtx.setLineDash([]);

            simCtx.fillStyle = 'rgba(100, 255, 100, 0.6)';
            simCtx.font = '12px monospace';
            simCtx.fillText('Equilibrium', centerX + 110, eqY + 5);

            // Mass
            const massSize = 40 + spring.mass * 10;
            const massGradient = simCtx.createRadialGradient(centerX - 10, massY - 10, 0, centerX, massY, massSize);
            massGradient.addColorStop(0, 'rgba(100, 200, 255, 1)');
            massGradient.addColorStop(0.7, 'rgba(50, 150, 255, 0.9)');
            massGradient.addColorStop(1, 'rgba(0, 100, 200, 0.6)');

            simCtx.fillStyle = massGradient;
            simCtx.fillRect(centerX - massSize, massY - massSize, massSize * 2, massSize * 2);

            simCtx.strokeStyle = 'rgba(150, 220, 255, 0.8)';
            simCtx.lineWidth = 3;
            simCtx.strokeRect(centerX - massSize, massY - massSize, massSize * 2, massSize * 2);

            // Mass label
            simCtx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            simCtx.font = 'bold 14px monospace';
            simCtx.textAlign = 'center';
            simCtx.fillText(spring.mass.toFixed(1) + ' kg', centerX, massY + 5);
            simCtx.textAlign = 'left';

            // Velocity arrow
            if (Math.abs(spring.velocity) > 0.1) {
                const arrowLength = Math.min(Math.abs(spring.velocity) * 20, 100);
                const direction = spring.velocity > 0 ? 1 : -1;

                simCtx.strokeStyle = 'rgba(255, 100, 255, 0.8)';
                simCtx.lineWidth = 4;
                simCtx.beginPath();
                simCtx.moveTo(centerX + massSize + 20, massY);
                simCtx.lineTo(centerX + massSize + 20, massY + direction * arrowLength);
                simCtx.stroke();

                // Arrow head
                simCtx.beginPath();
                simCtx.moveTo(centerX + massSize + 20, massY + direction * arrowLength);
                simCtx.lineTo(centerX + massSize + 10, massY + direction * (arrowLength - 10));
                simCtx.lineTo(centerX + massSize + 30, massY + direction * (arrowLength - 10));
                simCtx.closePath();
                simCtx.fillStyle = 'rgba(255, 100, 255, 0.8)';
                simCtx.fill();
            }
        }

        function drawCoilSpring(x1, y1, x2, y2) {
            const coils = 15;
            const width = 30;
            const length = y2 - y1;
            const segmentHeight = length / coils;

            simCtx.strokeStyle = 'rgba(200, 200, 220, 0.8)';
            simCtx.lineWidth = 3;
            simCtx.beginPath();
            simCtx.moveTo(x1, y1);

            for (let i = 0; i < coils; i++) {
                const y = y1 + i * segmentHeight;
                const direction = i % 2 === 0 ? 1 : -1;
                simCtx.lineTo(x1 + direction * width, y + segmentHeight / 2);
                simCtx.lineTo(x1, y + segmentHeight);
            }

            simCtx.lineTo(x2, y2);
            simCtx.stroke();
        }

        function drawGraph() {
            graphCtx.fillStyle = 'rgba(10, 10, 25, 0.95)';
            graphCtx.fillRect(0, 0, graphWidth, graphHeight);

            if (graphData.time.length < 2) return;

            const padding = 40;
            const plotWidth = graphWidth - 2 * padding;
            const plotHeight = graphHeight - 2 * padding;

            // Axes
            graphCtx.strokeStyle = 'rgba(150, 150, 150, 0.5)';
            graphCtx.lineWidth = 2;
            graphCtx.beginPath();
            graphCtx.moveTo(padding, padding);
            graphCtx.lineTo(padding, graphHeight - padding);
            graphCtx.lineTo(graphWidth - padding, graphHeight - padding);
            graphCtx.stroke();

            // Grid lines
            graphCtx.strokeStyle = 'rgba(100, 150, 255, 0.1)';
            graphCtx.lineWidth = 1;
            for (let i = 1; i < 5; i++) {
                const y = padding + (plotHeight / 5) * i;
                graphCtx.beginPath();
                graphCtx.moveTo(padding, y);
                graphCtx.lineTo(graphWidth - padding, y);
                graphCtx.stroke();
            }

            // Find data ranges
            const timeMin = Math.min(...graphData.time);
            const timeMax = Math.max(...graphData.time);
            const posMin = Math.min(...graphData.position);
            const posMax = Math.max(...graphData.position);
            const velMin = Math.min(...graphData.velocity);
            const velMax = Math.max(...graphData.velocity);

            const timeRange = timeMax - timeMin || 1;
            const posRange = posMax - posMin || 1;
            const velRange = velMax - velMin || 1;

            // Draw position line
            graphCtx.strokeStyle = 'rgba(79, 172, 254, 0.8)';
            graphCtx.lineWidth = 2;
            graphCtx.beginPath();
            for (let i = 0; i < graphData.time.length; i++) {
                const x = padding + ((graphData.time[i] - timeMin) / timeRange) * plotWidth;
                const y = graphHeight - padding - ((graphData.position[i] - posMin) / posRange) * plotHeight;
                if (i === 0) {
                    graphCtx.moveTo(x, y);
                } else {
                    graphCtx.lineTo(x, y);
                }
            }
            graphCtx.stroke();

            // Draw velocity line
            graphCtx.strokeStyle = 'rgba(255, 100, 200, 0.8)';
            graphCtx.lineWidth = 2;
            graphCtx.beginPath();
            for (let i = 0; i < graphData.time.length; i++) {
                const x = padding + ((graphData.time[i] - timeMin) / timeRange) * plotWidth;
                const y = graphHeight - padding - ((graphData.velocity[i] - velMin) / velRange) * plotHeight;
                if (i === 0) {
                    graphCtx.moveTo(x, y);
                } else {
                    graphCtx.lineTo(x, y);
                }
            }
            graphCtx.stroke();

            // Labels
            graphCtx.fillStyle = 'rgba(200, 200, 200, 0.9)';
            graphCtx.font = '12px monospace';

            graphCtx.fillText('Time (s)', graphWidth - padding - 50, graphHeight - 10);

            graphCtx.save();
            graphCtx.translate(15, padding + plotHeight / 2);
            graphCtx.rotate(-Math.PI / 2);
            graphCtx.fillText('Value', 0, 0);
            graphCtx.restore();

            // Legend
            graphCtx.fillStyle = 'rgba(79, 172, 254, 0.8)';
            graphCtx.fillRect(graphWidth - 150, 20, 20, 3);
            graphCtx.fillStyle = 'rgba(200, 200, 200, 0.9)';
            graphCtx.fillText('Position', graphWidth - 120, 25);

            graphCtx.fillStyle = 'rgba(255, 100, 200, 0.8)';
            graphCtx.fillRect(graphWidth - 150, 40, 20, 3);
            graphCtx.fillStyle = 'rgba(200, 200, 200, 0.9)';
            graphCtx.fillText('Velocity', graphWidth - 120, 45);
        }

        // Game loop
        function gameLoop(currentTime) {
            if (isPaused) return;

            const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.05); // Cap at 50ms
            lastTime = currentTime;

            updatePhysics(deltaTime);
            draw();
            drawGraph();
            updateEnergyDisplay();

            requestAnimationFrame(gameLoop);
        }

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                playPauseBtn.click();
            } else if (e.code === 'KeyR') {
                e.preventDefault();
                resetBtn.click();
            }
        });

        // Initial setup
        loadHighScores();
        resetSimulation();
    </script>
</body>
</html>