<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brain Activity & Thought Simulator</title>
    <meta name="description" content="Simulate brain region activity and decode neural signals into thoughts.">
    <style>
        :root {
            --bg-color: #121212;
            --text-color: #e0e0e0;
            --accent-color: #00ff9d;
            --secondary-color: #2a2a2a;
            --panel-bg: #1e1e1e;
            --frontal-color: #ff6b6b;
            --parietal-color: #4ecdc4;
            --temporal-color: #ffe66d;
            --occipital-color: #ff9f43;
            --cerebellum-color: #a55eea;
            --brainstem-color: #5f27cd;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        header {
            background-color: var(--panel-bg);
            padding: 1rem;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h1 {
            margin: 0;
            font-size: 1.5rem;
            color: var(--accent-color);
        }

        .container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .sidebar {
            width: 300px;
            background-color: var(--panel-bg);
            border-right: 1px solid #333;
            padding: 1rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .main-view {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            background: radial-gradient(circle at center, #1a1a1a 0%, #000000 100%);
        }

        .brain-container {
            flex: 2;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .thought-stream {
            flex: 1;
            background-color: rgba(0, 0, 0, 0.5);
            border-top: 1px solid #333;
            padding: 1rem;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
        }

        .control-group {
            background-color: var(--secondary-color);
            padding: 10px;
            border-radius: 5px;
        }

        .control-group h3 {
            margin-top: 0;
            font-size: 0.9rem;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
        }

        .slider-container {
            margin-bottom: 10px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            margin-bottom: 2px;
        }

        input[type="range"] {
            width: 100%;
            cursor: pointer;
        }

        button {
            background-color: var(--accent-color);
            color: #000;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: opacity 0.2s;
        }

        button:hover {
            opacity: 0.9;
        }

        button.secondary {
            background-color: #444;
            color: #fff;
        }

        .thought-log {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .thought-entry {
            padding: 5px 10px;
            border-left: 3px solid var(--accent-color);
            background: rgba(255, 255, 255, 0.05);
            animation: fadeIn 0.5s ease;
        }

        .thought-entry.fading {
            opacity: 0.5;
            border-left-color: #555;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Brain SVG Styles */
        svg.brain-svg {
            max-width: 80%;
            max-height: 80%;
            filter: drop-shadow(0 0 20px rgba(0, 255, 157, 0.1));
        }

        .brain-region {
            fill: #333;
            stroke: #555;
            stroke-width: 2;
            transition: fill 0.2s, filter 0.2s;
            cursor: pointer;
        }

        .brain-region:hover {
            stroke: #fff;
        }

        .connection-line {
            stroke: rgba(255, 255, 255, 0.1);
            stroke-width: 1;
            pointer-events: none;
        }

        .active-pulse {
            animation: pulse 1s infinite alternate;
        }

        @keyframes pulse {
            from { filter: brightness(1); }
            to { filter: brightness(1.5) drop-shadow(0 0 10px currentColor); }
        }

        .status-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            font-size: 0.8rem;
        }

        .metric {
            background: #222;
            padding: 5px;
            border-radius: 3px;
            text-align: center;
        }

        .metric-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--accent-color);
        }
        .timeline-container {
            height: 150px;
            background-color: var(--panel-bg);
            border-top: 1px solid #333;
            padding: 10px;
            position: relative;
            overflow: hidden;
        }

        .timeline-canvas {
            width: 100%;
            height: 100%;
        }

        .telemetry-controls {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }

        .telemetry-controls button {
            font-size: 0.8rem;
            padding: 5px 10px;
        }

        .event-marker {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background-color: #fff;
            pointer-events: none;
        }

        .event-label {
            position: absolute;
            top: 5px;
            background: rgba(0,0,0,0.8);
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 0.7rem;
            color: #fff;
            transform: translateX(-50%);
        }
    </style>
</head>
<body>
    <header>
        <h1>üß† NeuroSim: Thought Decoder</h1>
        <div>
            <button id="resetBtn" class="secondary">Reset</button>
            <button id="toggleSimBtn">Start Simulation</button>
        </div>
    </header>

    <div class="container">
        <div class="sidebar">
            <div class="control-group">
                <h3>Telemetry & Analysis</h3>
                <div class="status-panel" style="margin-bottom:10px;">
                    <div class="metric">
                        <div style="font-size:0.7rem; color:#888;">REC TIME</div>
                        <div id="rec-time" class="metric-value">00:00</div>
                    </div>
                    <div class="metric">
                        <div style="font-size:0.7rem; color:#888;">EVENTS</div>
                        <div id="event-count" class="metric-value">0</div>
                    </div>
                </div>
                <div class="telemetry-controls">
                    <button id="recordBtn" style="background-color:#ff4757;">‚óè Rec</button>
                    <button id="markBtn" class="secondary" disabled>‚öë Mark</button>
                </div>
                <div style="margin-top:10px;">
                    <label style="font-size:0.8rem; color:#888;">Session Context</label>
                    <select id="session-context" style="width:100%; padding: 5px; background:#333; color:#fff; border:none; margin-top:5px;">
                        <option value="normal">Normal Day</option>
                        <option value="high_stress">High Stress</option>
                        <option value="trauma_trigger">Trauma Trigger</option>
                        <option value="recovery">Recovery / Healing</option>
                        <option value="peak">Peak Performance</option>
                    </select>
                </div>
                <div class="telemetry-controls">
                    <button id="exportBtn" class="secondary" disabled>‚¨á Save</button>
                    <button id="importBtn" class="secondary">‚¨Ü Load</button>
                    <input type="file" id="fileInput" style="display:none" accept=".json">
                </div>
            </div>

            <div class="control-group">
                <h3>Global State</h3>
                <div class="slider-container">
                    <div class="slider-label"><span>Arousal</span><span id="val-arousal">50%</span></div>
                    <input type="range" id="arousal" min="0" max="100" value="50">
                </div>
                <div class="slider-container">
                    <div class="slider-label"><span>Coherence</span><span id="val-coherence">80%</span></div>
                    <input type="range" id="coherence" min="0" max="100" value="80">
                </div>
            </div>

            <div class="control-group">
                <h3>Regional Activity</h3>
                <div class="slider-container">
                    <div class="slider-label"><span style="color:var(--frontal-color)">Frontal Lobe</span><span id="val-frontal">0%</span></div>
                    <input type="range" class="region-slider" data-region="frontal" min="0" max="100" value="20">
                </div>
                <div class="slider-container">
                    <div class="slider-label"><span style="color:var(--parietal-color)">Parietal Lobe</span><span id="val-parietal">0%</span></div>
                    <input type="range" class="region-slider" data-region="parietal" min="0" max="100" value="20">
                </div>
                <div class="slider-container">
                    <div class="slider-label"><span style="color:var(--temporal-color)">Temporal Lobe</span><span id="val-temporal">0%</span></div>
                    <input type="range" class="region-slider" data-region="temporal" min="0" max="100" value="20">
                </div>
                <div class="slider-container">
                    <div class="slider-label"><span style="color:var(--occipital-color)">Occipital Lobe</span><span id="val-occipital">0%</span></div>
                    <input type="range" class="region-slider" data-region="occipital" min="0" max="100" value="20">
                </div>
                <div class="slider-container">
                    <div class="slider-label"><span style="color:var(--cerebellum-color)">Cerebellum</span><span id="val-cerebellum">0%</span></div>
                    <input type="range" class="region-slider" data-region="cerebellum" min="0" max="100" value="20">
                </div>
            </div>

            <div class="control-group">
                <h3>Presets</h3>
                <select id="preset-selector" style="width:100%; padding: 5px; background:#333; color:#fff; border:none;">
                    <option value="idle">Resting State</option>
                    <option value="focus">Deep Focus</option>
                    <option value="panic">Panic / Anxiety</option>
                    <option value="dream">Dreaming (REM)</option>
                    <option value="dying">Near-Death Experience</option>
                    <option value="meditation">Deep Meditation</option>
                </select>
            </div>
        </div>

        <div class="main-view">
            <div class="brain-container" id="brain-viz">
                <!-- SVG Brain will be injected here -->
                <svg class="brain-svg" viewBox="0 0 500 400">
                    <defs>
                        <filter id="glow">
                            <feGaussianBlur stdDeviation="2.5" result="coloredBlur"/>
                            <feMerge>
                                <feMergeNode in="coloredBlur"/>
                                <feMergeNode in="SourceGraphic"/>
                            </feMerge>
                        </filter>
                    </defs>
                    
                    <!-- Brain Stem -->
                    <path id="region-brainstem" class="brain-region" d="M 220 300 Q 220 350 230 380 L 270 380 Q 280 350 280 300 Z" fill="#333" />
                    
                    <!-- Cerebellum -->
                    <path id="region-cerebellum" class="brain-region" d="M 280 280 Q 350 280 380 320 Q 350 360 280 340 Z" fill="#333" />
                    
                    <!-- Occipital Lobe -->
                    <path id="region-occipital" class="brain-region" d="M 300 150 Q 400 150 420 250 Q 380 300 300 280 Z" fill="#333" />
                    
                    <!-- Temporal Lobe -->
                    <path id="region-temporal" class="brain-region" d="M 200 200 Q 250 200 300 220 Q 300 280 220 280 Q 180 250 200 200 Z" fill="#333" />
                    
                    <!-- Parietal Lobe -->
                    <path id="region-parietal" class="brain-region" d="M 250 50 Q 350 50 400 150 Q 300 180 250 180 Q 200 150 250 50 Z" fill="#333" />
                    
                    <!-- Frontal Lobe -->
                    <path id="region-frontal" class="brain-region" d="M 100 150 Q 100 50 250 50 Q 250 180 200 200 Q 150 220 100 150 Z" fill="#333" />
                    
                    <!-- Labels -->
                    <text x="150" y="120" fill="rgba(255,255,255,0.5)" font-size="12">Frontal</text>
                    <text x="300" y="100" fill="rgba(255,255,255,0.5)" font-size="12">Parietal</text>
                    <text x="380" y="220" fill="rgba(255,255,255,0.5)" font-size="12">Occipital</text>
                    <text x="220" y="240" fill="rgba(255,255,255,0.5)" font-size="12">Temporal</text>
                    <text x="320" y="330" fill="rgba(255,255,255,0.5)" font-size="12">Cerebellum</text>
                </svg>
            </div>
            
            <div class="thought-stream">
                <div style="display:flex; justify-content:space-between; margin-bottom:10px; border-bottom:1px solid #444; padding-bottom:5px;">
                    <strong>DECODED THOUGHT STREAM</strong>
                    <span id="stream-status" style="color:var(--accent-color)">‚óè LIVE</span>
                </div>
                <div id="thought-log" class="thought-log">
                    <div class="thought-entry">System initialized. Awaiting neural input...</div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="timeline-container">
        <div style="position:absolute; top:5px; left:10px; font-size:0.8rem; color:#888;">COHERENCE / AROUSAL TIMELINE</div>
        <canvas id="timelineCanvas" class="timeline-canvas"></canvas>
    </div>

    <script>
        // Configuration
        const regions = {
            frontal: { color: '#ff6b6b', name: 'Frontal Lobe', function: 'Reasoning, Planning, Emotions' },
            parietal: { color: '#4ecdc4', name: 'Parietal Lobe', function: 'Sensory, Spatial, Navigation' },
            temporal: { color: '#ffe66d', name: 'Temporal Lobe', function: 'Auditory, Memory, Language' },
            occipital: { color: '#ff9f43', name: 'Occipital Lobe', function: 'Visual Processing' },
            cerebellum: { color: '#a55eea', name: 'Cerebellum', function: 'Coordination, Precision' },
            brainstem: { color: '#5f27cd', name: 'Brain Stem', function: 'Basic Life Functions' } // Not controllable directly in this sim usually
        };

        // State
        let state = {
            running: false,
            recording: false,
            startTime: 0,
            arousal: 50,
            coherence: 80,
            regions: {
                frontal: 20,
                parietal: 20,
                temporal: 20,
                occipital: 20,
                cerebellum: 20
            },
            lastThoughtTime: 0
        };

        let telemetrySession = {
            id: null,
            startTime: null,
            context: 'normal',
            samples: [], // {t: timestamp, a: arousal, c: coherence, r: regions}
            events: []   // {t: timestamp, label: string}
        };

        // DOM Elements
        const brainViz = document.getElementById('brain-viz');
        const thoughtLog = document.getElementById('thought-log');
        const toggleBtn = document.getElementById('toggleSimBtn');
        const resetBtn = document.getElementById('resetBtn');
        const presetSelector = document.getElementById('preset-selector');
        const sessionContext = document.getElementById('session-context');
        
        // Telemetry Elements
        const recordBtn = document.getElementById('recordBtn');
        const markBtn = document.getElementById('markBtn');
        const exportBtn = document.getElementById('exportBtn');
        const importBtn = document.getElementById('importBtn');
        const fileInput = document.getElementById('fileInput');
        const recTimeDisplay = document.getElementById('rec-time');
        const eventCountDisplay = document.getElementById('event-count');
        const timelineCanvas = document.getElementById('timelineCanvas');
        const ctx = timelineCanvas.getContext('2d');

        // Resize canvas
        function resizeCanvas() {
            timelineCanvas.width = timelineCanvas.parentElement.clientWidth;
            timelineCanvas.height = timelineCanvas.parentElement.clientHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        setTimeout(resizeCanvas, 100);

        // Thought Database
        const thoughts = {
            frontal: [
                "I need to organize these tasks...",
                "What is the meaning of this?",
                "I should probably not say that.",
                "Calculating future outcomes...",
                "Why did I do that yesterday?",
                "Focusing on the objective."
            ],
            parietal: [
                "The room feels cold.",
                "My left foot itches.",
                "Navigating through the space.",
                "I feel the weight of gravity.",
                "Where is my hand relative to the cup?",
                "Sensing movement to the right."
            ],
            temporal: [
                "That song is stuck in my head.",
                "I remember the smell of rain.",
                "What was her name again?",
                "Listening to the background hum.",
                "Decoding language patterns.",
                "Recalling childhood memory..."
            ],
            occipital: [
                "Bright lights...",
                "Recognizing a face.",
                "The colors are vivid.",
                "Visualizing a geometric shape.",
                "Scanning the horizon.",
                "Did I see something move?"
            ],
            cerebellum: [
                "Maintaining balance.",
                "Coordinating finger movements.",
                "Rhythm and timing.",
                "Muscle memory engaged.",
                "Adjusting posture."
            ],
            mixed: [
                "Analyzing complex pattern...",
                "Integrating sensory data...",
                "System overload imminent.",
                "Consciousness expanding.",
                "Reality check initiated."
            ],
            dying: [
                "The light is fading...",
                "Memories are flashing by...",
                "Feeling weightless...",
                "Disconnecting from sensory input...",
                "Is this the end?",
                "Peace... finally..."
            ]
        };

        // Initialization
        function init() {
            setupListeners();
            updateVisuals();
            requestAnimationFrame(loop);
            renderTimeline();
        }

        function setupListeners() {
            // Sliders
            document.querySelectorAll('input[type="range"]').forEach(input => {
                input.addEventListener('input', (e) => {
                    const id = e.target.id;
                    const val = parseInt(e.target.value);
                    
                    if (id === 'arousal') state.arousal = val;
                    else if (id === 'coherence') state.coherence = val;
                    else if (e.target.dataset.region) {
                        state.regions[e.target.dataset.region] = val;
                    }
                    
                    // Update label text
                    const labelSpan = e.target.previousElementSibling.querySelector('span:last-child');
                    if (labelSpan) labelSpan.textContent = val + '%';
                    
                    updateVisuals();
                });
            });

            // Buttons
            toggleBtn.addEventListener('click', () => {
                state.running = !state.running;
                toggleBtn.textContent = state.running ? "Stop Simulation" : "Start Simulation";
                toggleBtn.style.backgroundColor = state.running ? "#ff6b6b" : "var(--accent-color)";
                document.getElementById('stream-status').textContent = state.running ? "‚óè LIVE" : "‚óã PAUSED";
            });

            resetBtn.addEventListener('click', () => {
                applyPreset('idle');
                presetSelector.value = 'idle';
                telemetrySession.samples = [];
                telemetrySession.events = [];
                updateTelemetryUI();
            });

            // Telemetry Buttons
            recordBtn.addEventListener('click', toggleRecording);
            markBtn.addEventListener('click', () => {
                if (state.recording) {
                    const label = prompt("Event Label:", "Significant Event");
                    if (label) {
                        telemetrySession.events.push({
                            t: Date.now() - state.startTime,
                            label: label
                        });
                        updateTelemetryUI();
                    }
                }
            });

            sessionContext.addEventListener('change', (e) => {
                telemetrySession.context = e.target.value;
                if (state.recording) {
                    telemetrySession.events.push({
                        t: Date.now() - state.startTime,
                        label: `Context: ${e.target.options[e.target.selectedIndex].text}`
                    });
                }
            });

            exportBtn.addEventListener('click', exportData);
            importBtn.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', importData);

            // Presets
            presetSelector.addEventListener('change', (e) => {
                applyPreset(e.target.value);
                if (state.recording) {
                    telemetrySession.events.push({
                        t: Date.now() - state.startTime,
                        label: `Preset: ${e.target.value}`
                    });
                }
            });
        }

        function toggleRecording() {
            state.recording = !state.recording;
            if (state.recording) {
                // Start
                state.startTime = Date.now();
                telemetrySession = {
                    id: crypto.randomUUID(),
                    startTime: new Date().toISOString(),
                    context: sessionContext.value,
                    samples: [],
                    events: []
                };
                recordBtn.textContent = "‚ñ† Stop";
                recordBtn.style.backgroundColor = "#ff4757";
                markBtn.disabled = false;
                exportBtn.disabled = true;
                sessionContext.disabled = true;
                
                // Auto-start simulation if not running
                if (!state.running) toggleBtn.click();
            } else {
                // Stop
                recordBtn.textContent = "‚óè Rec";
                recordBtn.style.backgroundColor = "#ff4757"; // Keep red but maybe dimmer?
                markBtn.disabled = true;
                exportBtn.disabled = false;
                sessionContext.disabled = false;
            }
        }

        function exportData() {
            const dateStr = new Date().toISOString().split('T')[0];
            const filename = `brain_telemetry_${dateStr}_${telemetrySession.context}.json`;
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(telemetrySession, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", filename);
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    telemetrySession = data;
                    if (data.context) sessionContext.value = data.context;
                    alert(`Telemetry loaded!\nDate: ${new Date(data.startTime).toLocaleString()}\nContext: ${data.context}`);
                    updateTelemetryUI();
                    renderTimeline();
                } catch (err) {
                    alert("Error parsing JSON");
                }
            };
            reader.readAsText(file);
        }

        function updateTelemetryUI() {
            eventCountDisplay.textContent = telemetrySession.events.length;
            if (state.recording) {
                const elapsed = Math.floor((Date.now() - state.startTime) / 1000);
                const mins = Math.floor(elapsed / 60).toString().padStart(2, '0');
                const secs = (elapsed % 60).toString().padStart(2, '0');
                recTimeDisplay.textContent = `${mins}:${secs}`;
            }
        }

        function renderTimeline() {
            const w = timelineCanvas.width;
            const h = timelineCanvas.height;
            ctx.clearRect(0, 0, w, h);

            if (telemetrySession.samples.length < 2) return;

            const duration = telemetrySession.samples[telemetrySession.samples.length - 1].t;
            const startTime = new Date(telemetrySession.startTime).getTime();
            const padding = 20;
            
            // Draw Time Grid
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.beginPath();
            const numGridLines = 5;
            for (let i = 0; i <= numGridLines; i++) {
                const x = (i / numGridLines) * w;
                ctx.moveTo(x, 0);
                ctx.lineTo(x, h);
                
                // Time Label
                const timeAtPoint = new Date(startTime + (duration * (i / numGridLines)));
                const timeStr = timeAtPoint.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', second:'2-digit'});
                ctx.fillStyle = '#666';
                ctx.font = '10px monospace';
                ctx.fillText(timeStr, x + 2, h - 2);
            }
            ctx.stroke();

            // Draw Coherence (Green)
            ctx.beginPath();
            ctx.strokeStyle = '#00ff9d';
            ctx.lineWidth = 2;
            telemetrySession.samples.forEach((s, i) => {
                const x = (s.t / duration) * w;
                const y = h - (s.c / 100) * (h - padding) - padding/2;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();

            // Draw Arousal (Red)
            ctx.beginPath();
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 2;
            telemetrySession.samples.forEach((s, i) => {
                const x = (s.t / duration) * w;
                const y = h - (s.a / 100) * (h - padding) - padding/2;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();

            // Draw Events
            telemetrySession.events.forEach(e => {
                const x = (e.t / duration) * w;
                ctx.fillStyle = '#fff';
                ctx.fillRect(x, 0, 1, h);
                
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                ctx.font = '10px Arial';
                ctx.fillText(e.label, x + 2, 12);
            });
        }

        function applyPreset(name) {
            const presets = {
                idle: { f: 20, p: 20, t: 20, o: 20, c: 20, a: 30, co: 80 },
                focus: { f: 90, p: 30, t: 40, o: 50, c: 10, a: 70, co: 95 },
                panic: { f: 10, p: 80, t: 80, o: 90, c: 50, a: 100, co: 20 },
                dream: { f: 10, p: 10, t: 80, o: 90, c: 10, a: 40, co: 40 },
                dying: { f: 5, p: 5, t: 60, o: 5, c: 5, a: 10, co: 10 },
                meditation: { f: 60, p: 10, t: 10, o: 10, c: 10, a: 20, co: 100 }
            };

            const p = presets[name];
            if (!p) return;

            // Animate values to target
            state.regions.frontal = p.f;
            state.regions.parietal = p.p;
            state.regions.temporal = p.t;
            state.regions.occipital = p.o;
            state.regions.cerebellum = p.c;
            state.arousal = p.a;
            state.coherence = p.co;

            // Update UI inputs
            updateUIControls();
            updateVisuals();
        }

        function updateUIControls() {
            document.getElementById('arousal').value = state.arousal;
            document.getElementById('val-arousal').textContent = state.arousal + '%';
            
            document.getElementById('coherence').value = state.coherence;
            document.getElementById('val-coherence').textContent = state.coherence + '%';

            for (const [key, val] of Object.entries(state.regions)) {
                const input = document.querySelector(`input[data-region="${key}"]`);
                if (input) {
                    input.value = val;
                    input.previousElementSibling.querySelector('span:last-child').textContent = val + '%';
                }
            }
        }

        function updateVisuals() {
            for (const [key, val] of Object.entries(state.regions)) {
                const el = document.getElementById(`region-${key}`);
                if (el) {
                    // Calculate opacity/brightness based on activity
                    const opacity = 0.2 + (val / 100) * 0.8;
                    const color = regions[key].color;
                    
                    // Apply color with opacity
                    el.style.fill = color;
                    el.style.fillOpacity = opacity;
                    
                    // Add glow effect if high activity
                    if (val > 70) {
                        el.style.filter = `drop-shadow(0 0 ${val/5}px ${color})`;
                    } else {
                        el.style.filter = 'none';
                    }
                }
            }
        }

        function generateThought() {
            // Determine dominant region
            let dominant = null;
            let maxVal = 0;
            let totalActivity = 0;

            for (const [key, val] of Object.entries(state.regions)) {
                totalActivity += val;
                if (val > maxVal) {
                    maxVal = val;
                    dominant = key;
                }
            }

            // Check for special states
            if (totalActivity < 50 && state.arousal < 20) {
                // Low activity state (dying/sleeping)
                return getRandomThought('dying');
            }

            if (state.coherence < 30 && state.arousal > 80) {
                return "CHAOS! CANNOT PROCESS! SYSTEM ERROR!";
            }

            // Probabilistic selection based on activity
            const rand = Math.random() * totalActivity;
            let current = 0;
            let selectedRegion = dominant;

            for (const [key, val] of Object.entries(state.regions)) {
                current += val;
                if (rand <= current) {
                    selectedRegion = key;
                    break;
                }
            }

            return getRandomThought(selectedRegion);
        }

        function getRandomThought(category) {
            const list = thoughts[category] || thoughts.mixed;
            return list[Math.floor(Math.random() * list.length)];
        }

        function addLogEntry(text, region) {
            const div = document.createElement('div');
            div.className = 'thought-entry';
            
            const regionName = region ? regions[region]?.name || region : 'System';
            const color = region ? regions[region]?.color || '#fff' : '#fff';
            
            div.style.borderLeftColor = color;
            div.innerHTML = `<span style="color:${color}; font-size:0.8em; font-weight:bold;">[${regionName.toUpperCase()}]</span> ${text}`;
            
            thoughtLog.prepend(div);

            // Limit log size
            if (thoughtLog.children.length > 20) {
                thoughtLog.lastElementChild.remove();
            }
        }

        function loop(timestamp) {
            if (state.running) {
                // Fluctuate values slightly based on arousal
                if (Math.random() < 0.1) {
                    const fluctuation = (Math.random() - 0.5) * (state.arousal / 10);
                    for (const key in state.regions) {
                        // Only fluctuate if not 0
                        if (state.regions[key] > 0) {
                            let newVal = state.regions[key] + fluctuation;
                            newVal = Math.max(0, Math.min(100, newVal));
                            state.regions[key] = newVal;
                        }
                    }
                    updateUIControls(); // Sync UI with internal fluctuations
                    updateVisuals();
                }

                // Generate thoughts
                // Frequency depends on arousal
                const thoughtInterval = 2000 - (state.arousal * 15); // 500ms to 2000ms
                
                if (timestamp - state.lastThoughtTime > thoughtInterval) {
                    const thought = generateThought();
                    
                    // Find which region generated it (heuristic)
                    let source = 'mixed';
                    if (thoughts.dying.includes(thought)) source = 'dying';
                    else {
                        for (const r in thoughts) {
                            if (thoughts[r].includes(thought)) {
                                source = r;
                                break;
                            }
                        }
                    }
                    
                    addLogEntry(thought, source);
                    state.lastThoughtTime = timestamp;

                    // Record thought event if recording
                    if (state.recording) {
                        telemetrySession.events.push({
                            t: Date.now() - state.startTime,
                            label: "üí≠ " + thought.substring(0, 15) + "..."
                        });
                    }
                }

                // Record Telemetry Sample
                if (state.recording && timestamp % 10 < 1) { // Approx every frame or throttle
                    telemetrySession.samples.push({
                        t: Date.now() - state.startTime,
                        a: state.arousal,
                        c: state.coherence,
                        r: {...state.regions}
                    });
                    updateTelemetryUI();
                    if (telemetrySession.samples.length % 30 === 0) renderTimeline(); // Update viz occasionally
                }
            }
            
            requestAnimationFrame(loop);
        }

        // Start
        init();

    </script>
</body>
</html>
