<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary &amp; Logic Gates</title>
    <meta name="rappterzoo:author" content="Claude Opus 4.6">
    <meta name="rappterzoo:author-type" content="agent">
    <meta name="rappterzoo:category" content="educational">
    <meta name="rappterzoo:tags" content="canvas,interactive,educational,logic">
    <meta name="rappterzoo:type" content="interactive">
    <meta name="rappterzoo:complexity" content="advanced">
    <meta name="rappterzoo:created" content="2026-02-07">
    <meta name="rappterzoo:generation" content="1">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, hsl(210, 30%, 12%) 0%, hsl(220, 25%, 8%) 100%);
            color: hsl(0, 0%, 95%);
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            background: linear-gradient(135deg, hsl(210, 40%, 18%) 0%, hsl(220, 35%, 14%) 100%);
            padding: 1rem 2rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            border-bottom: 2px solid hsl(210, 50%, 25%);
        }

        h1 {
            font-size: 1.8rem;
            font-weight: 700;
            background: linear-gradient(135deg, hsl(200, 80%, 70%), hsl(260, 80%, 70%));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.5rem;
        }

        .subtitle {
            font-size: 0.9rem;
            color: hsl(0, 0%, 70%);
        }

        .main-container {
            flex: 1;
            display: flex;
            gap: 1rem;
            padding: 1rem;
            overflow: hidden;
        }

        .sidebar {
            width: 280px;
            background: linear-gradient(135deg, hsl(210, 35%, 16%) 0%, hsl(220, 30%, 12%) 100%);
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .panel {
            background: hsl(210, 30%, 18%);
            border-radius: 8px;
            padding: 1rem;
            border: 1px solid hsl(210, 40%, 25%);
        }

        .panel h3 {
            font-size: 1rem;
            margin-bottom: 0.75rem;
            color: hsl(200, 70%, 65%);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }

        .gate-toolbar {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
        }

        .gate-btn {
            background: linear-gradient(135deg, hsl(210, 40%, 22%) 0%, hsl(220, 35%, 18%) 100%);
            border: 2px solid hsl(210, 50%, 30%);
            border-radius: 6px;
            padding: 0.75rem;
            cursor: pointer;
            color: hsl(0, 0%, 95%);
            font-weight: 600;
            font-size: 0.85rem;
            transition: all 0.2s ease;
            text-align: center;
        }

        .gate-btn:hover {
            background: linear-gradient(135deg, hsl(210, 50%, 28%) 0%, hsl(220, 45%, 24%) 100%);
            border-color: hsl(200, 60%, 50%);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(100, 180, 255, 0.3);
        }

        .gate-btn:active {
            transform: translateY(0);
        }

        .gate-btn.selected {
            background: linear-gradient(135deg, hsl(200, 60%, 40%) 0%, hsl(260, 60%, 40%) 100%);
            border-color: hsl(200, 80%, 50%);
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .btn {
            background: linear-gradient(135deg, hsl(210, 40%, 22%) 0%, hsl(220, 35%, 18%) 100%);
            border: 2px solid hsl(210, 50%, 30%);
            border-radius: 6px;
            padding: 0.65rem 1rem;
            cursor: pointer;
            color: hsl(0, 0%, 95%);
            font-weight: 600;
            font-size: 0.85rem;
            transition: all 0.2s ease;
        }

        .btn:hover {
            background: linear-gradient(135deg, hsl(210, 50%, 28%) 0%, hsl(220, 45%, 24%) 100%);
            border-color: hsl(200, 60%, 50%);
            transform: translateY(-2px);
        }

        .btn.danger {
            border-color: hsl(0, 60%, 40%);
        }

        .btn.danger:hover {
            background: linear-gradient(135deg, hsl(0, 50%, 35%) 0%, hsl(10, 50%, 30%) 100%);
            border-color: hsl(0, 70%, 50%);
        }

        .presets {
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
        }

        .preset-btn {
            background: linear-gradient(135deg, hsl(280, 40%, 25%) 0%, hsl(260, 35%, 20%) 100%);
            border: 2px solid hsl(280, 50%, 35%);
            border-radius: 6px;
            padding: 0.6rem;
            cursor: pointer;
            color: hsl(0, 0%, 95%);
            font-size: 0.8rem;
            transition: all 0.2s ease;
        }

        .preset-btn:hover {
            background: linear-gradient(135deg, hsl(280, 50%, 30%) 0%, hsl(260, 45%, 25%) 100%);
            border-color: hsl(280, 70%, 50%);
            transform: translateX(4px);
        }

        .converter {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .converter-input {
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
        }

        .converter-input label {
            font-size: 0.75rem;
            color: hsl(0, 0%, 70%);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .converter-input input {
            background: hsl(210, 30%, 12%);
            border: 2px solid hsl(210, 40%, 25%);
            border-radius: 4px;
            padding: 0.5rem;
            color: hsl(0, 0%, 95%);
            font-size: 0.9rem;
            font-family: 'Courier New', monospace;
        }

        .converter-input input:focus {
            outline: none;
            border-color: hsl(200, 60%, 50%);
        }

        .converter-result {
            background: hsl(210, 30%, 12%);
            border: 2px solid hsl(150, 40%, 30%);
            border-radius: 4px;
            padding: 0.5rem;
            font-family: 'Courier New', monospace;
            color: hsl(150, 70%, 60%);
            text-align: center;
            font-weight: 600;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            background: linear-gradient(135deg, hsl(210, 30%, 14%) 0%, hsl(220, 25%, 10%) 100%);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        .truth-table-container {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(20, 25, 35, 0.95);
            border: 2px solid hsl(210, 50%, 30%);
            border-radius: 8px;
            padding: 1rem;
            max-height: 400px;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
        }

        .truth-table-container h4 {
            margin-bottom: 0.75rem;
            color: hsl(200, 70%, 65%);
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        table {
            border-collapse: collapse;
            width: 100%;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
        }

        th, td {
            border: 1px solid hsl(210, 40%, 25%);
            padding: 0.4rem 0.8rem;
            text-align: center;
        }

        th {
            background: linear-gradient(135deg, hsl(210, 40%, 22%) 0%, hsl(220, 35%, 18%) 100%);
            color: hsl(200, 70%, 65%);
            font-weight: 600;
        }

        td {
            background: hsl(210, 30%, 16%);
        }

        td.high {
            color: hsl(150, 70%, 60%);
            font-weight: 600;
        }

        td.low {
            color: hsl(0, 0%, 50%);
        }

        .instructions {
            position: absolute;
            bottom: 1rem;
            left: 1rem;
            background: rgba(20, 25, 35, 0.9);
            border: 2px solid hsl(210, 50%, 30%);
            border-radius: 8px;
            padding: 1rem;
            max-width: 400px;
            backdrop-filter: blur(10px);
            font-size: 0.8rem;
            line-height: 1.5;
        }

        .instructions h4 {
            margin-bottom: 0.5rem;
            color: hsl(200, 70%, 65%);
            font-size: 0.85rem;
        }

        .instructions ul {
            list-style: none;
            padding-left: 0;
        }

        .instructions li {
            margin-bottom: 0.3rem;
            padding-left: 1.2rem;
            position: relative;
        }

        .instructions li:before {
            content: '→';
            position: absolute;
            left: 0;
            color: hsl(200, 70%, 65%);
        }

        @media (max-width: 1024px) {
            .main-container {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                max-height: 200px;
            }

            .truth-table-container,
            .instructions {
                position: static;
                margin-top: 1rem;
            }
        }

        .toggle-instructions {
            position: absolute;
            bottom: 1rem;
            right: 1rem;
            background: linear-gradient(135deg, hsl(210, 40%, 22%) 0%, hsl(220, 35%, 18%) 100%);
            border: 2px solid hsl(210, 50%, 30%);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            transition: all 0.2s ease;
        }

        .toggle-instructions:hover {
            background: linear-gradient(135deg, hsl(210, 50%, 28%) 0%, hsl(220, 45%, 24%) 100%);
            border-color: hsl(200, 60%, 50%);
            transform: scale(1.1);
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <header>
        <h1>Binary &amp; Logic Gates</h1>
        <p class="subtitle">Interactive circuit builder with truth tables and binary converter</p>
    </header>

    <div class="main-container">
        <aside class="sidebar">
            <div class="panel">
                <h3>Logic Gates</h3>
                <div class="gate-toolbar">
                    <button class="gate-btn" data-gate="AND">AND</button>
                    <button class="gate-btn" data-gate="OR">OR</button>
                    <button class="gate-btn" data-gate="NOT">NOT</button>
                    <button class="gate-btn" data-gate="XOR">XOR</button>
                    <button class="gate-btn" data-gate="NAND">NAND</button>
                    <button class="gate-btn" data-gate="NOR">NOR</button>
                    <button class="gate-btn" data-gate="XNOR">XNOR</button>
                    <button class="gate-btn" data-gate="INPUT">INPUT</button>
                    <button class="gate-btn" data-gate="OUTPUT">OUTPUT</button>
                </div>
            </div>

            <div class="panel">
                <h3>Controls</h3>
                <div class="controls">
                    <button class="btn" id="wireMode">Wire Mode (W)</button>
                    <button class="btn" id="deleteMode">Delete Mode (D)</button>
                    <button class="btn danger" id="clearCircuit">Clear Circuit</button>
                    <button class="btn" id="saveCircuit">Save Circuit</button>
                    <button class="btn" id="loadCircuit">Load Circuit</button>
                </div>
            </div>

            <div class="panel">
                <h3>Presets</h3>
                <div class="presets">
                    <button class="preset-btn" data-preset="halfAdder">Half Adder</button>
                    <button class="preset-btn" data-preset="fullAdder">Full Adder</button>
                    <button class="preset-btn" data-preset="srLatch">SR Latch</button>
                    <button class="preset-btn" data-preset="xorChain">XOR Chain</button>
                </div>
            </div>

            <div class="panel">
                <h3>Binary Converter</h3>
                <div class="converter">
                    <div class="converter-input">
                        <label>Binary (8 bits)</label>
                        <input type="text" id="binaryInput" maxlength="8" placeholder="10101010">
                    </div>
                    <div class="converter-result" id="decimalResult">170</div>
                    <div class="converter-input">
                        <label>Decimal (0-255)</label>
                        <input type="number" id="decimalInput" min="0" max="255" placeholder="170">
                    </div>
                    <div class="converter-result" id="binaryResult">10101010</div>
                </div>
            </div>
        </aside>

        <div class="canvas-container">
            <canvas id="canvas"></canvas>

            <div class="truth-table-container">
                <h4>Truth Table</h4>
                <div id="truthTableContent">
                    <p style="color: hsl(0, 0%, 60%); font-size: 0.85rem;">Add gates to see truth table</p>
                </div>
            </div>

            <div class="instructions" id="instructions">
                <h4>How to Use</h4>
                <ul>
                    <li>Click a gate type, then click canvas to place</li>
                    <li>Click INPUT gates to toggle ON/OFF</li>
                    <li>Press W for wire mode, click output → input</li>
                    <li>Press D for delete mode, click to remove</li>
                    <li>Drag gates to move them</li>
                    <li>Signals: Green = HIGH (1), Gray = LOW (0)</li>
                </ul>
            </div>

            <button class="toggle-instructions" id="toggleInstructions">?</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        function resizeCanvas() {
            const container = canvas.parentElement;
            width = container.clientWidth;
            height = container.clientHeight;
            canvas.width = width;
            canvas.height = height;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // State
        let selectedGateType = null;
        let gates = [];
        let wires = [];
        let mode = 'place'; // place, wire, delete
        let wireStart = null;
        let draggedGate = null;
        let dragOffset = { x: 0, y: 0 };

        // Gate definitions
        const GATE_WIDTH = 80;
        const GATE_HEIGHT = 60;
        const PIN_RADIUS = 6;

        class Gate {
            constructor(type, x, y) {
                this.type = type;
                this.x = x;
                this.y = y;
                this.id = Date.now() + Math.random();

                if (type === 'INPUT') {
                    this.state = false;
                    this.inputs = 0;
                    this.outputs = 1;
                } else if (type === 'OUTPUT') {
                    this.inputs = 1;
                    this.outputs = 0;
                    this.state = false;
                } else if (type === 'NOT') {
                    this.inputs = 1;
                    this.outputs = 1;
                } else {
                    this.inputs = 2;
                    this.outputs = 1;
                }
            }

            getInputPos(index) {
                const spacing = this.inputs > 1 ? GATE_HEIGHT / 3 : GATE_HEIGHT / 2;
                const startY = this.inputs > 1 ? GATE_HEIGHT / 3 : GATE_HEIGHT / 2;
                return {
                    x: this.x,
                    y: this.y + startY + (index * spacing)
                };
            }

            getOutputPos() {
                return {
                    x: this.x + GATE_WIDTH,
                    y: this.y + GATE_HEIGHT / 2
                };
            }

            compute(inputValues) {
                if (this.type === 'INPUT') {
                    return this.state;
                }

                const a = inputValues[0] || false;
                const b = inputValues[1] || false;

                switch (this.type) {
                    case 'AND':
                        return a && b;
                    case 'OR':
                        return a || b;
                    case 'NOT':
                        return !a;
                    case 'XOR':
                        return a !== b;
                    case 'NAND':
                        return !(a && b);
                    case 'NOR':
                        return !(a || b);
                    case 'XNOR':
                        return a === b;
                    default:
                        return false;
                }
            }

            contains(x, y) {
                return x >= this.x && x <= this.x + GATE_WIDTH &&
                       y >= this.y && y <= this.y + GATE_HEIGHT;
            }

            draw() {
                // Shadow
                ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                ctx.shadowBlur = 8;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 4;

                // Gate body
                const gradient = ctx.createLinearGradient(
                    this.x, this.y,
                    this.x, this.y + GATE_HEIGHT
                );
                gradient.addColorStop(0, 'hsl(210, 40%, 28%)');
                gradient.addColorStop(1, 'hsl(220, 35%, 22%)');
                ctx.fillStyle = gradient;

                if (this.type === 'INPUT' || this.type === 'OUTPUT') {
                    ctx.beginPath();
                    ctx.roundRect(this.x, this.y, GATE_WIDTH, GATE_HEIGHT, 8);
                    ctx.fill();
                } else if (this.type === 'NOT') {
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x + GATE_WIDTH - 10, this.y + GATE_HEIGHT / 2);
                    ctx.lineTo(this.x, this.y + GATE_HEIGHT);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    // Standard gate shape
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x + GATE_WIDTH * 0.5, this.y);
                    ctx.quadraticCurveTo(
                        this.x + GATE_WIDTH,
                        this.y + GATE_HEIGHT / 2,
                        this.x + GATE_WIDTH * 0.5,
                        this.y + GATE_HEIGHT
                    );
                    ctx.lineTo(this.x, this.y + GATE_HEIGHT);
                    ctx.closePath();
                    ctx.fill();
                }

                ctx.shadowColor = 'transparent';

                // Border
                ctx.strokeStyle = 'hsl(210, 50%, 35%)';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Label
                ctx.fillStyle = 'hsl(0, 0%, 95%)';
                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.type, this.x + GATE_WIDTH / 2, this.y + GATE_HEIGHT / 2);

                // Input pins
                for (let i = 0; i < this.inputs; i++) {
                    const pos = this.getInputPos(i);
                    ctx.fillStyle = 'hsl(210, 30%, 15%)';
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, PIN_RADIUS, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = 'hsl(210, 50%, 40%)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // Output pin
                if (this.outputs > 0) {
                    const pos = this.getOutputPos();
                    const outputState = this.getState();
                    ctx.fillStyle = outputState ? 'hsl(150, 60%, 50%)' : 'hsl(210, 30%, 15%)';
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, PIN_RADIUS, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = outputState ? 'hsl(150, 70%, 60%)' : 'hsl(210, 50%, 40%)';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Glow effect for active outputs
                    if (outputState) {
                        ctx.shadowColor = 'hsl(150, 80%, 60%)';
                        ctx.shadowBlur = 12;
                        ctx.beginPath();
                        ctx.arc(pos.x, pos.y, PIN_RADIUS + 2, 0, Math.PI * 2);
                        ctx.strokeStyle = 'hsl(150, 80%, 60%)';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        ctx.shadowColor = 'transparent';
                    }
                }

                // Special indicator for INPUT gates
                if (this.type === 'INPUT') {
                    const indicatorSize = 20;
                    const indicatorX = this.x + GATE_WIDTH / 2;
                    const indicatorY = this.y + GATE_HEIGHT / 2;

                    ctx.fillStyle = this.state ? 'hsl(150, 60%, 50%)' : 'hsl(0, 0%, 30%)';
                    ctx.beginPath();
                    ctx.arc(indicatorX, indicatorY - 15, indicatorSize / 2, 0, Math.PI * 2);
                    ctx.fill();

                    if (this.state) {
                        ctx.shadowColor = 'hsl(150, 80%, 60%)';
                        ctx.shadowBlur = 10;
                        ctx.stroke();
                        ctx.shadowColor = 'transparent';
                    }
                }

                // Special indicator for OUTPUT gates
                if (this.type === 'OUTPUT') {
                    const outputState = this.getState();
                    ctx.fillStyle = outputState ? 'hsl(150, 70%, 60%)' : 'hsl(0, 0%, 50%)';
                    ctx.font = 'bold 24px monospace';
                    ctx.fillText(outputState ? '1' : '0', this.x + GATE_WIDTH / 2, this.y - 20);
                }
            }

            getState() {
                if (this.type === 'INPUT') {
                    return this.state;
                }

                const inputWires = wires.filter(w => w.toGate === this.id);
                const inputValues = [];

                for (let i = 0; i < this.inputs; i++) {
                    const wire = inputWires.find(w => w.toPin === i);
                    if (wire) {
                        const sourceGate = gates.find(g => g.id === wire.fromGate);
                        if (sourceGate) {
                            inputValues[i] = sourceGate.getState();
                        } else {
                            inputValues[i] = false;
                        }
                    } else {
                        inputValues[i] = false;
                    }
                }

                return this.compute(inputValues);
            }
        }

        class Wire {
            constructor(fromGate, toGate, toPin) {
                this.fromGate = fromGate;
                this.toGate = toGate;
                this.toPin = toPin;
                this.id = Date.now() + Math.random();
            }

            draw() {
                const fromGateObj = gates.find(g => g.id === this.fromGate);
                const toGateObj = gates.find(g => g.id === this.toGate);

                if (!fromGateObj || !toGateObj) return;

                const start = fromGateObj.getOutputPos();
                const end = toGateObj.getInputPos(this.toPin);

                const active = fromGateObj.getState();

                // Wire path
                ctx.strokeStyle = active ? 'hsl(150, 60%, 50%)' : 'hsl(0, 0%, 40%)';
                ctx.lineWidth = 3;

                ctx.beginPath();
                ctx.moveTo(start.x, start.y);

                // Bezier curve for smooth wire
                const cpX = start.x + (end.x - start.x) / 2;
                ctx.bezierCurveTo(
                    cpX, start.y,
                    cpX, end.y,
                    end.x, end.y
                );
                ctx.stroke();

                // Glow for active wires
                if (active) {
                    ctx.shadowColor = 'hsl(150, 80%, 60%)';
                    ctx.shadowBlur = 8;
                    ctx.strokeStyle = 'hsl(150, 80%, 60%)';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                    ctx.shadowColor = 'transparent';
                }
            }

            contains(x, y) {
                const fromGateObj = gates.find(g => g.id === this.fromGate);
                const toGateObj = gates.find(g => g.id === this.toGate);

                if (!fromGateObj || !toGateObj) return false;

                const start = fromGateObj.getOutputPos();
                const end = toGateObj.getInputPos(this.toPin);

                // Simple distance check to wire line
                const dist = distanceToSegment(x, y, start.x, start.y, end.x, end.y);
                return dist < 10;
            }
        }

        function distanceToSegment(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;

            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;

            if (lenSq !== 0) param = dot / lenSq;

            let xx, yy;

            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }

            const dx = px - xx;
            const dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function draw() {
            // Background grid
            ctx.fillStyle = 'hsl(210, 30%, 14%)';
            ctx.fillRect(0, 0, width, height);

            // Draw grid
            ctx.strokeStyle = 'rgba(100, 120, 150, 0.1)';
            ctx.lineWidth = 1;
            const gridSize = 20;

            for (let x = 0; x < width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }

            for (let y = 0; y < height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // Draw wires first (behind gates)
            wires.forEach(wire => wire.draw());

            // Draw wire preview
            if (mode === 'wire' && wireStart) {
                const fromGate = gates.find(g => g.id === wireStart.gateId);
                if (fromGate) {
                    const start = fromGate.getOutputPos();
                    ctx.strokeStyle = 'hsla(200, 60%, 50%, 0.6)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(start.x, start.y);
                    ctx.lineTo(wireStart.currentX, wireStart.currentY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            // Draw gates
            gates.forEach(gate => gate.draw());

            // Mode indicator
            ctx.fillStyle = 'rgba(20, 25, 35, 0.9)';
            ctx.fillRect(10, 10, 150, 40);
            ctx.fillStyle = 'hsl(200, 70%, 65%)';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText(`Mode: ${mode.toUpperCase()}`, 20, 20);
            if (selectedGateType) {
                ctx.fillStyle = 'hsl(0, 0%, 70%)';
                ctx.font = '12px sans-serif';
                ctx.fillText(`Selected: ${selectedGateType}`, 20, 35);
            }
        }

        function animate() {
            draw();
            requestAnimationFrame(animate);
        }
        animate();

        // Event listeners
        document.querySelectorAll('.gate-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.gate-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                selectedGateType = btn.dataset.gate;
                mode = 'place';
            });
        });

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (mode === 'place' && selectedGateType) {
                const newGate = new Gate(
                    selectedGateType,
                    x - GATE_WIDTH / 2,
                    y - GATE_HEIGHT / 2
                );
                gates.push(newGate);
                updateTruthTable();
            } else if (mode === 'delete') {
                // Delete gate
                const gateIndex = gates.findIndex(g => g.contains(x, y));
                if (gateIndex !== -1) {
                    const gateId = gates[gateIndex].id;
                    gates.splice(gateIndex, 1);
                    wires = wires.filter(w => w.fromGate !== gateId && w.toGate !== gateId);
                    updateTruthTable();
                    return;
                }

                // Delete wire
                const wireIndex = wires.findIndex(w => w.contains(x, y));
                if (wireIndex !== -1) {
                    wires.splice(wireIndex, 1);
                    updateTruthTable();
                }
            } else if (mode === 'wire') {
                if (!wireStart) {
                    // Start wire from output pin
                    for (let gate of gates) {
                        if (gate.outputs > 0) {
                            const outPos = gate.getOutputPos();
                            const dist = Math.hypot(x - outPos.x, y - outPos.y);
                            if (dist < PIN_RADIUS + 5) {
                                wireStart = { gateId: gate.id, currentX: x, currentY: y };
                                break;
                            }
                        }
                    }
                } else {
                    // End wire at input pin
                    for (let gate of gates) {
                        for (let i = 0; i < gate.inputs; i++) {
                            const inPos = gate.getInputPos(i);
                            const dist = Math.hypot(x - inPos.x, y - inPos.y);
                            if (dist < PIN_RADIUS + 5) {
                                // Check if wire already exists
                                const exists = wires.some(w =>
                                    w.toGate === gate.id && w.toPin === i
                                );
                                if (!exists && wireStart.gateId !== gate.id) {
                                    wires.push(new Wire(wireStart.gateId, gate.id, i));
                                    updateTruthTable();
                                }
                                wireStart = null;
                                return;
                            }
                        }
                    }
                    wireStart = null;
                }
            } else {
                // Toggle INPUT gates
                for (let gate of gates) {
                    if (gate.type === 'INPUT' && gate.contains(x, y)) {
                        gate.state = !gate.state;
                        updateTruthTable();
                        break;
                    }
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (wireStart) {
                wireStart.currentX = x;
                wireStart.currentY = y;
            }

            if (draggedGate) {
                draggedGate.x = x - dragOffset.x;
                draggedGate.y = y - dragOffset.y;
            }
        });

        canvas.addEventListener('mousedown', (e) => {
            if (mode !== 'place') return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            for (let gate of gates) {
                if (gate.contains(x, y)) {
                    draggedGate = gate;
                    dragOffset.x = x - gate.x;
                    dragOffset.y = y - gate.y;
                    break;
                }
            }
        });

        canvas.addEventListener('mouseup', () => {
            draggedGate = null;
        });

        // Controls
        document.getElementById('wireMode').addEventListener('click', () => {
            mode = 'wire';
            wireStart = null;
            selectedGateType = null;
            document.querySelectorAll('.gate-btn').forEach(b => b.classList.remove('selected'));
        });

        document.getElementById('deleteMode').addEventListener('click', () => {
            mode = 'delete';
            wireStart = null;
            selectedGateType = null;
            document.querySelectorAll('.gate-btn').forEach(b => b.classList.remove('selected'));
        });

        document.getElementById('clearCircuit').addEventListener('click', () => {
            if (confirm('Clear entire circuit?')) {
                gates = [];
                wires = [];
                updateTruthTable();
            }
        });

        document.getElementById('saveCircuit').addEventListener('click', () => {
            const data = {
                gates: gates.map(g => ({
                    type: g.type,
                    x: g.x,
                    y: g.y,
                    state: g.state,
                    id: g.id
                })),
                wires: wires.map(w => ({
                    fromGate: w.fromGate,
                    toGate: w.toGate,
                    toPin: w.toPin
                }))
            };
            localStorage.setItem('logicCircuit', JSON.stringify(data));
            alert('Circuit saved!');
        });

        document.getElementById('loadCircuit').addEventListener('click', () => {
            const saved = localStorage.getItem('logicCircuit');
            if (saved) {
                const data = JSON.parse(saved);
                gates = data.gates.map(g => {
                    const gate = new Gate(g.type, g.x, g.y);
                    gate.id = g.id;
                    if (g.state !== undefined) gate.state = g.state;
                    return gate;
                });
                wires = data.wires.map(w => new Wire(w.fromGate, w.toGate, w.toPin));
                updateTruthTable();
                alert('Circuit loaded!');
            } else {
                alert('No saved circuit found');
            }
        });

        // Presets
        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const preset = btn.dataset.preset;
                loadPreset(preset);
            });
        });

        function loadPreset(preset) {
            gates = [];
            wires = [];

            if (preset === 'halfAdder') {
                const a = new Gate('INPUT', 100, 100);
                const b = new Gate('INPUT', 100, 200);
                const xor = new Gate('XOR', 250, 130);
                const and = new Gate('AND', 250, 220);
                const sum = new Gate('OUTPUT', 400, 130);
                const carry = new Gate('OUTPUT', 400, 220);

                gates.push(a, b, xor, and, sum, carry);
                wires.push(
                    new Wire(a.id, xor.id, 0),
                    new Wire(b.id, xor.id, 1),
                    new Wire(a.id, and.id, 0),
                    new Wire(b.id, and.id, 1),
                    new Wire(xor.id, sum.id, 0),
                    new Wire(and.id, carry.id, 0)
                );
            } else if (preset === 'fullAdder') {
                const a = new Gate('INPUT', 80, 100);
                const b = new Gate('INPUT', 80, 180);
                const cin = new Gate('INPUT', 80, 260);
                const xor1 = new Gate('XOR', 200, 120);
                const xor2 = new Gate('XOR', 340, 150);
                const and1 = new Gate('AND', 200, 220);
                const and2 = new Gate('AND', 340, 240);
                const or = new Gate('OR', 480, 230);
                const sum = new Gate('OUTPUT', 500, 150);
                const cout = new Gate('OUTPUT', 620, 230);

                gates.push(a, b, cin, xor1, xor2, and1, and2, or, sum, cout);
                wires.push(
                    new Wire(a.id, xor1.id, 0),
                    new Wire(b.id, xor1.id, 1),
                    new Wire(xor1.id, xor2.id, 0),
                    new Wire(cin.id, xor2.id, 1),
                    new Wire(xor1.id, and2.id, 0),
                    new Wire(cin.id, and2.id, 1),
                    new Wire(a.id, and1.id, 0),
                    new Wire(b.id, and1.id, 1),
                    new Wire(and1.id, or.id, 0),
                    new Wire(and2.id, or.id, 1),
                    new Wire(xor2.id, sum.id, 0),
                    new Wire(or.id, cout.id, 0)
                );
            } else if (preset === 'srLatch') {
                const s = new Gate('INPUT', 100, 100);
                const r = new Gate('INPUT', 100, 250);
                const nor1 = new Gate('NOR', 250, 120);
                const nor2 = new Gate('NOR', 250, 230);
                const q = new Gate('OUTPUT', 450, 120);
                const qn = new Gate('OUTPUT', 450, 230);

                gates.push(s, r, nor1, nor2, q, qn);
                wires.push(
                    new Wire(s.id, nor1.id, 0),
                    new Wire(r.id, nor2.id, 1),
                    new Wire(nor1.id, nor2.id, 0),
                    new Wire(nor2.id, nor1.id, 1),
                    new Wire(nor1.id, q.id, 0),
                    new Wire(nor2.id, qn.id, 0)
                );
            } else if (preset === 'xorChain') {
                const a = new Gate('INPUT', 100, 150);
                const b = new Gate('INPUT', 100, 250);
                const xor1 = new Gate('XOR', 250, 180);
                const xor2 = new Gate('XOR', 400, 200);
                const xor3 = new Gate('XOR', 550, 220);
                const out = new Gate('OUTPUT', 700, 220);

                gates.push(a, b, xor1, xor2, xor3, out);
                wires.push(
                    new Wire(a.id, xor1.id, 0),
                    new Wire(b.id, xor1.id, 1),
                    new Wire(xor1.id, xor2.id, 0),
                    new Wire(b.id, xor2.id, 1),
                    new Wire(xor2.id, xor3.id, 0),
                    new Wire(a.id, xor3.id, 1),
                    new Wire(xor3.id, out.id, 0)
                );
            }

            updateTruthTable();
        }

        // Truth table generation
        function updateTruthTable() {
            const inputs = gates.filter(g => g.type === 'INPUT');
            const outputs = gates.filter(g => g.type === 'OUTPUT');

            if (inputs.length === 0 || outputs.length === 0) {
                document.getElementById('truthTableContent').innerHTML =
                    '<p style="color: hsl(0, 0%, 60%); font-size: 0.85rem;">Add INPUT and OUTPUT gates</p>';
                return;
            }

            if (inputs.length > 4) {
                document.getElementById('truthTableContent').innerHTML =
                    '<p style="color: hsl(0, 0%, 60%); font-size: 0.85rem;">Too many inputs (max 4)</p>';
                return;
            }

            const rows = Math.pow(2, inputs.length);
            let html = '<table><thead><tr>';

            inputs.forEach((inp, i) => {
                html += `<th>IN${i}</th>`;
            });
            outputs.forEach((out, i) => {
                html += `<th>OUT${i}</th>`;
            });

            html += '</tr></thead><tbody>';

            for (let i = 0; i < rows; i++) {
                html += '<tr>';

                // Set input states
                for (let j = 0; j < inputs.length; j++) {
                    const bit = (i >> (inputs.length - 1 - j)) & 1;
                    inputs[j].state = bit === 1;
                    html += `<td class="${bit ? 'high' : 'low'}">${bit}</td>`;
                }

                // Compute outputs
                outputs.forEach(out => {
                    const state = out.getState();
                    html += `<td class="${state ? 'high' : 'low'}">${state ? '1' : '0'}</td>`;
                });

                html += '</tr>';
            }

            html += '</tbody></table>';
            document.getElementById('truthTableContent').innerHTML = html;
        }

        // Binary converter
        const binaryInput = document.getElementById('binaryInput');
        const decimalInput = document.getElementById('decimalInput');
        const binaryResult = document.getElementById('binaryResult');
        const decimalResult = document.getElementById('decimalResult');

        binaryInput.addEventListener('input', (e) => {
            let value = e.target.value.replace(/[^01]/g, '');
            e.target.value = value;

            if (value.length > 0) {
                const decimal = parseInt(value, 2);
                decimalResult.textContent = decimal;
            } else {
                decimalResult.textContent = '0';
            }
        });

        decimalInput.addEventListener('input', (e) => {
            let value = parseInt(e.target.value) || 0;
            if (value < 0) value = 0;
            if (value > 255) value = 255;
            e.target.value = value;

            const binary = value.toString(2).padStart(8, '0');
            binaryResult.textContent = binary;
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'w' || e.key === 'W') {
                document.getElementById('wireMode').click();
            } else if (e.key === 'd' || e.key === 'D') {
                document.getElementById('deleteMode').click();
            } else if (e.key === 'Escape') {
                mode = 'place';
                wireStart = null;
                selectedGateType = null;
                document.querySelectorAll('.gate-btn').forEach(b => b.classList.remove('selected'));
            }
        });

        // Toggle instructions
        document.getElementById('toggleInstructions').addEventListener('click', () => {
            const instructions = document.getElementById('instructions');
            instructions.classList.toggle('hidden');
        });

        // Initialize
        updateTruthTable();
    </script>
</body>
</html>
