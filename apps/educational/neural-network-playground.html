<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Network Playground</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            color: #e0e0e0;
            overflow: hidden;
            height: 100vh;
        }

        .container {
            display: flex;
            height: 100vh;
            gap: 0;
        }

        .sidebar {
            width: 320px;
            background: rgba(20, 20, 30, 0.95);
            border-right: 1px solid rgba(100, 100, 255, 0.3);
            overflow-y: auto;
            padding: 20px;
            box-shadow: 4px 0 20px rgba(0, 0, 0, 0.5);
        }

        .main-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
            gap: 20px;
        }

        .canvas-container {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            min-height: 0;
        }

        .canvas-wrapper {
            position: relative;
            background: rgba(20, 20, 30, 0.8);
            border-radius: 12px;
            border: 1px solid rgba(100, 100, 255, 0.3);
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
        }

        .canvas-title {
            position: absolute;
            top: 15px;
            left: 15px;
            font-size: 14px;
            font-weight: 600;
            color: #00ffff;
            text-transform: uppercase;
            letter-spacing: 1px;
            z-index: 10;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        h1 {
            font-size: 24px;
            margin-bottom: 20px;
            color: #00ffff;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        .section {
            background: rgba(30, 30, 45, 0.6);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid rgba(100, 100, 255, 0.2);
        }

        .section-title {
            font-size: 14px;
            font-weight: 600;
            color: #00ffff;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            font-size: 12px;
            margin-bottom: 5px;
            color: #b0b0b0;
        }

        select, input[type="number"], input[type="text"] {
            width: 100%;
            padding: 8px;
            background: rgba(10, 10, 20, 0.8);
            border: 1px solid rgba(100, 100, 255, 0.3);
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 13px;
        }

        input[type="range"] {
            width: 100%;
            margin-top: 5px;
        }

        .range-value {
            display: inline-block;
            float: right;
            color: #00ffff;
            font-weight: 600;
        }

        button {
            width: 100%;
            padding: 12px;
            margin: 5px 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 6px;
            color: white;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background: linear-gradient(135deg, #2d3561 0%, #3d4575 100%);
            box-shadow: 0 4px 15px rgba(45, 53, 97, 0.3);
        }

        button.danger {
            background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
            box-shadow: 0 4px 15px rgba(235, 51, 73, 0.3);
        }

        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .stat-item {
            background: rgba(10, 10, 20, 0.6);
            padding: 10px;
            border-radius: 4px;
            text-align: center;
        }

        .stat-label {
            font-size: 10px;
            color: #b0b0b0;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            font-size: 18px;
            font-weight: 700;
            color: #00ffff;
            margin-top: 5px;
        }

        .training-status {
            text-align: center;
            padding: 10px;
            background: rgba(10, 10, 20, 0.6);
            border-radius: 4px;
            margin-top: 10px;
            font-size: 12px;
            color: #b0b0b0;
        }

        .training-status.active {
            color: #00ff88;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(10, 10, 20, 0.6);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(100, 100, 255, 0.4);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(100, 100, 255, 0.6);
        }

        @media (max-width: 1024px) {
            .container {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                max-height: 40vh;
            }

            .canvas-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <h1>Neural Network Playground</h1>

            <div class="section">
                <div class="section-title">Dataset</div>
                <div class="control-group">
                    <label>Select Dataset</label>
                    <select id="datasetSelect">
                        <option value="xor">XOR Problem</option>
                        <option value="circle">Circle Classification</option>
                        <option value="spiral">Spiral Classification</option>
                    </select>
                </div>
            </div>

            <div class="section">
                <div class="section-title">Network Architecture</div>
                <div class="control-group">
                    <label>Hidden Layers (neurons per layer)</label>
                    <input type="text" id="architectureInput" value="4,4" placeholder="e.g., 4,4,3">
                    <button onclick="updateArchitecture()" class="secondary" style="margin-top: 10px;">Build Network</button>
                </div>
            </div>

            <div class="section">
                <div class="section-title">Training Parameters</div>
                <div class="control-group">
                    <label>
                        Learning Rate
                        <span class="range-value" id="lrValue">0.1</span>
                    </label>
                    <input type="range" id="learningRate" min="0.001" max="1" step="0.001" value="0.1">
                </div>
                <div class="control-group">
                    <label>
                        Epochs
                        <span class="range-value" id="epochValue">1000</span>
                    </label>
                    <input type="range" id="epochs" min="100" max="5000" step="100" value="1000">
                </div>
                <div class="control-group">
                    <label>
                        Batch Size
                        <span class="range-value" id="batchValue">32</span>
                    </label>
                    <input type="range" id="batchSize" min="1" max="100" step="1" value="32">
                </div>
                <div class="control-group">
                    <label>Activation Function</label>
                    <select id="activationSelect">
                        <option value="relu">ReLU</option>
                        <option value="sigmoid">Sigmoid</option>
                        <option value="tanh">Tanh</option>
                    </select>
                </div>
            </div>

            <div class="section">
                <button onclick="startTraining()">Start Training</button>
                <button onclick="stopTraining()" class="secondary">Stop Training</button>
                <button onclick="resetNetwork()" class="danger">Reset Network</button>
                <div class="training-status" id="trainingStatus">Ready to train</div>
            </div>

            <div class="section">
                <div class="section-title">Statistics</div>
                <div class="stats">
                    <div class="stat-item">
                        <div class="stat-label">Epoch</div>
                        <div class="stat-value" id="epochStat">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Loss</div>
                        <div class="stat-value" id="lossStat">0.00</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Accuracy</div>
                        <div class="stat-value" id="accuracyStat">0%</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Parameters</div>
                        <div class="stat-value" id="paramStat">0</div>
                    </div>
                </div>
            </div>

            <div class="section">
                <div class="section-title">Import/Export</div>
                <div class="button-group">
                    <button onclick="exportNetwork()" class="secondary">Export</button>
                    <button onclick="importNetwork()" class="secondary">Import</button>
                </div>
            </div>
        </div>

        <div class="main-area">
            <div class="canvas-container">
                <div class="canvas-wrapper">
                    <div class="canvas-title">Network Visualization</div>
                    <canvas id="networkCanvas"></canvas>
                </div>
                <div class="canvas-wrapper">
                    <div class="canvas-title">Decision Boundary</div>
                    <canvas id="boundaryCanvas"></canvas>
                </div>
                <div class="canvas-wrapper">
                    <div class="canvas-title">Data Points</div>
                    <canvas id="dataCanvas"></canvas>
                </div>
                <div class="canvas-wrapper">
                    <div class="canvas-title">Loss Graph</div>
                    <canvas id="lossCanvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Neural Network Implementation
        class NeuralNetwork {
            constructor(architecture, activation = 'relu') {
                this.architecture = architecture;
                this.activation = activation;
                this.layers = [];
                this.activations = [];
                this.weights = [];
                this.biases = [];
                this.gradients = {weights: [], biases: []};
                this.initializeNetwork();
            }

            initializeNetwork() {
                this.weights = [];
                this.biases = [];

                for (let i = 0; i < this.architecture.length - 1; i++) {
                    const inputSize = this.architecture[i];
                    const outputSize = this.architecture[i + 1];

                    // Xavier/He initialization
                    const scale = Math.sqrt(2.0 / inputSize);
                    const weights = Array(outputSize).fill(0).map(() =>
                        Array(inputSize).fill(0).map(() => (Math.random() * 2 - 1) * scale)
                    );
                    const biases = Array(outputSize).fill(0);

                    this.weights.push(weights);
                    this.biases.push(biases);
                }
            }

            activate(x, type = null) {
                const activationType = type || this.activation;

                switch(activationType) {
                    case 'relu':
                        return x.map(val => Math.max(0, val));
                    case 'sigmoid':
                        return x.map(val => 1 / (1 + Math.exp(-val)));
                    case 'tanh':
                        return x.map(val => Math.tanh(val));
                    case 'softmax':
                        const maxVal = Math.max(...x);
                        const exps = x.map(val => Math.exp(val - maxVal));
                        const sum = exps.reduce((a, b) => a + b, 0);
                        return exps.map(val => val / sum);
                    default:
                        return x;
                }
            }

            activateDerivative(x, type = null) {
                const activationType = type || this.activation;

                switch(activationType) {
                    case 'relu':
                        return x.map(val => val > 0 ? 1 : 0);
                    case 'sigmoid':
                        return x.map(val => {
                            const sig = 1 / (1 + Math.exp(-val));
                            return sig * (1 - sig);
                        });
                    case 'tanh':
                        return x.map(val => {
                            const t = Math.tanh(val);
                            return 1 - t * t;
                        });
                    default:
                        return x.map(() => 1);
                }
            }

            forward(input) {
                this.layers = [input];
                this.activations = [];

                let current = input;

                for (let i = 0; i < this.weights.length; i++) {
                    // Z = W * X + b
                    const z = this.weights[i].map((neuronWeights, j) => {
                        const sum = neuronWeights.reduce((acc, w, k) => acc + w * current[k], 0);
                        return sum + this.biases[i][j];
                    });

                    this.activations.push(z);

                    // Apply activation (softmax for output layer if multi-class)
                    const isOutputLayer = i === this.weights.length - 1;
                    const activation = isOutputLayer && this.architecture[this.architecture.length - 1] > 1
                        ? 'softmax'
                        : this.activation;

                    current = this.activate(z, activation);
                    this.layers.push(current);
                }

                return current;
            }

            backward(input, target, learningRate) {
                const output = this.layers[this.layers.length - 1];
                const numLayers = this.weights.length;

                // Initialize gradients
                let deltaNext = output.map((o, i) => o - target[i]);

                // Backpropagate through layers
                for (let i = numLayers - 1; i >= 0; i--) {
                    const layerInput = this.layers[i];
                    const activation = this.activations[i];

                    // Calculate delta for this layer
                    let delta;
                    if (i === numLayers - 1 && this.architecture[this.architecture.length - 1] > 1) {
                        // Softmax output layer
                        delta = deltaNext;
                    } else {
                        // Hidden layers
                        const derivative = this.activateDerivative(activation);
                        delta = deltaNext.map((d, j) => d * derivative[j]);
                    }

                    // Update weights and biases
                    for (let j = 0; j < this.weights[i].length; j++) {
                        for (let k = 0; k < this.weights[i][j].length; k++) {
                            this.weights[i][j][k] -= learningRate * delta[j] * layerInput[k];
                        }
                        this.biases[i][j] -= learningRate * delta[j];
                    }

                    // Propagate delta to previous layer
                    if (i > 0) {
                        deltaNext = Array(layerInput.length).fill(0);
                        for (let j = 0; j < delta.length; j++) {
                            for (let k = 0; k < layerInput.length; k++) {
                                deltaNext[k] += delta[j] * this.weights[i][j][k];
                            }
                        }
                    }
                }
            }

            train(data, labels, learningRate, epochs, batchSize, callback) {
                const losses = [];

                for (let epoch = 0; epoch < epochs; epoch++) {
                    let totalLoss = 0;
                    let correct = 0;

                    // Shuffle data
                    const indices = Array.from({length: data.length}, (_, i) => i);
                    for (let i = indices.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [indices[i], indices[j]] = [indices[j], indices[i]];
                    }

                    // Mini-batch training
                    for (let i = 0; i < data.length; i += batchSize) {
                        const batchIndices = indices.slice(i, Math.min(i + batchSize, data.length));

                        for (const idx of batchIndices) {
                            const input = data[idx];
                            const target = labels[idx];

                            // Forward pass
                            const output = this.forward(input);

                            // Calculate loss (cross-entropy for classification)
                            const loss = -target.reduce((sum, t, j) => sum + t * Math.log(output[j] + 1e-10), 0);
                            totalLoss += loss;

                            // Check accuracy
                            const predicted = output.indexOf(Math.max(...output));
                            const actual = target.indexOf(Math.max(...target));
                            if (predicted === actual) correct++;

                            // Backward pass
                            this.backward(input, target, learningRate);
                        }
                    }

                    const avgLoss = totalLoss / data.length;
                    const accuracy = correct / data.length;
                    losses.push(avgLoss);

                    if (callback && epoch % 10 === 0) {
                        const shouldContinue = callback(epoch, avgLoss, accuracy, this);
                        if (!shouldContinue) break;
                    }
                }

                return losses;
            }

            predict(input) {
                return this.forward(input);
            }

            getParameterCount() {
                let count = 0;
                for (let i = 0; i < this.weights.length; i++) {
                    count += this.weights[i].length * this.weights[i][0].length;
                    count += this.biases[i].length;
                }
                return count;
            }

            export() {
                return {
                    architecture: this.architecture,
                    activation: this.activation,
                    weights: this.weights,
                    biases: this.biases
                };
            }

            import(data) {
                this.architecture = data.architecture;
                this.activation = data.activation;
                this.weights = data.weights;
                this.biases = data.biases;
            }
        }

        // Dataset Generation
        function generateXORData(numSamples = 200) {
            const data = [];
            const labels = [];

            for (let i = 0; i < numSamples; i++) {
                const x1 = Math.random() * 2 - 1;
                const x2 = Math.random() * 2 - 1;
                const label = (x1 > 0) !== (x2 > 0) ? 1 : 0;

                data.push([x1, x2]);
                labels.push(label === 1 ? [0, 1] : [1, 0]);
            }

            return {data, labels};
        }

        function generateCircleData(numSamples = 200) {
            const data = [];
            const labels = [];

            for (let i = 0; i < numSamples; i++) {
                const x1 = Math.random() * 2 - 1;
                const x2 = Math.random() * 2 - 1;
                const distance = Math.sqrt(x1 * x1 + x2 * x2);
                const label = distance < 0.6 ? 0 : 1;

                data.push([x1, x2]);
                labels.push(label === 1 ? [0, 1] : [1, 0]);
            }

            return {data, labels};
        }

        function generateSpiralData(numSamples = 200) {
            const data = [];
            const labels = [];
            const pointsPerClass = Math.floor(numSamples / 2);

            for (let i = 0; i < 2; i++) {
                for (let j = 0; j < pointsPerClass; j++) {
                    const r = j / pointsPerClass;
                    const t = i * Math.PI + r * Math.PI * 2.5 + Math.random() * 0.2;

                    const x1 = r * Math.cos(t);
                    const x2 = r * Math.sin(t);

                    data.push([x1, x2]);
                    labels.push(i === 0 ? [1, 0] : [0, 1]);
                }
            }

            return {data, labels};
        }

        // Visualization
        class NetworkVisualizer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.animationFrame = null;
                this.activationFlow = [];
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }

            resizeCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            }

            drawNetwork(network, showActivation = false) {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                if (!network) return;

                const layers = network.architecture;
                const layerSpacing = this.canvas.width / (layers.length + 1);
                const padding = 60;

                // Calculate node positions
                const nodePositions = [];
                for (let i = 0; i < layers.length; i++) {
                    const layerSize = layers[i];
                    const x = layerSpacing * (i + 1);
                    const nodeSpacing = Math.min(40, (this.canvas.height - padding * 2) / layerSize);
                    const startY = (this.canvas.height - (layerSize - 1) * nodeSpacing) / 2;

                    nodePositions[i] = [];
                    for (let j = 0; j < layerSize; j++) {
                        nodePositions[i].push({
                            x: x,
                            y: startY + j * nodeSpacing
                        });
                    }
                }

                // Draw connections (weights)
                for (let i = 0; i < layers.length - 1; i++) {
                    const weights = network.weights[i];

                    for (let j = 0; j < nodePositions[i + 1].length; j++) {
                        for (let k = 0; k < nodePositions[i].length; k++) {
                            const weight = weights[j][k];
                            const alpha = Math.min(Math.abs(weight), 1);
                            const color = weight > 0 ? `rgba(0, 255, 255, ${alpha * 0.3})` : `rgba(255, 100, 100, ${alpha * 0.3})`;
                            const lineWidth = Math.abs(weight) * 2 + 0.5;

                            this.ctx.strokeStyle = color;
                            this.ctx.lineWidth = lineWidth;
                            this.ctx.beginPath();
                            this.ctx.moveTo(nodePositions[i][k].x, nodePositions[i][k].y);
                            this.ctx.lineTo(nodePositions[i + 1][j].x, nodePositions[i + 1][j].y);
                            this.ctx.stroke();
                        }
                    }
                }

                // Draw nodes
                for (let i = 0; i < layers.length; i++) {
                    for (let j = 0; j < nodePositions[i].length; j++) {
                        const pos = nodePositions[i][j];
                        let activation = 0.5;

                        if (showActivation && network.layers && network.layers[i]) {
                            activation = Math.max(0, Math.min(1, network.layers[i][j]));
                        }

                        // Glow effect
                        const gradient = this.ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, 15);
                        gradient.addColorStop(0, `rgba(0, 255, 255, ${activation})`);
                        gradient.addColorStop(1, `rgba(0, 100, 150, ${activation * 0.3})`);

                        this.ctx.fillStyle = gradient;
                        this.ctx.beginPath();
                        this.ctx.arc(pos.x, pos.y, 12, 0, Math.PI * 2);
                        this.ctx.fill();

                        // Border
                        this.ctx.strokeStyle = `rgba(0, 255, 255, ${0.5 + activation * 0.5})`;
                        this.ctx.lineWidth = 2;
                        this.ctx.stroke();
                    }
                }

                // Draw layer labels
                this.ctx.fillStyle = '#b0b0b0';
                this.ctx.font = '12px "Segoe UI"';
                this.ctx.textAlign = 'center';

                for (let i = 0; i < layers.length; i++) {
                    const x = layerSpacing * (i + 1);
                    let label = '';
                    if (i === 0) label = 'Input';
                    else if (i === layers.length - 1) label = 'Output';
                    else label = `Hidden ${i}`;

                    this.ctx.fillText(label, x, 30);
                    this.ctx.fillText(`(${layers[i]})`, x, 45);
                }
            }
        }

        class DataVisualizer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }

            resizeCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            }

            drawData(data, labels) {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                const padding = 40;
                const width = this.canvas.width - padding * 2;
                const height = this.canvas.height - padding * 2;

                // Draw axes
                this.ctx.strokeStyle = 'rgba(200, 200, 200, 0.3)';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.moveTo(padding, this.canvas.height / 2);
                this.ctx.lineTo(this.canvas.width - padding, this.canvas.height / 2);
                this.ctx.moveTo(this.canvas.width / 2, padding);
                this.ctx.lineTo(this.canvas.width / 2, this.canvas.height - padding);
                this.ctx.stroke();

                // Draw data points
                for (let i = 0; i < data.length; i++) {
                    const x = padding + (data[i][0] + 1) * width / 2;
                    const y = padding + (1 - data[i][1]) * height / 2;

                    const label = labels[i].indexOf(Math.max(...labels[i]));
                    const color = label === 0 ? 'rgba(255, 100, 100, 0.8)' : 'rgba(100, 200, 255, 0.8)';

                    this.ctx.fillStyle = color;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 4, 0, Math.PI * 2);
                    this.ctx.fill();

                    // Glow
                    this.ctx.strokeStyle = color;
                    this.ctx.lineWidth = 1;
                    this.ctx.stroke();
                }

                // Draw labels
                this.ctx.fillStyle = '#b0b0b0';
                this.ctx.font = '12px "Segoe UI"';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('-1', padding, this.canvas.height / 2 - 10);
                this.ctx.fillText('1', this.canvas.width - padding, this.canvas.height / 2 - 10);
                this.ctx.fillText('1', this.canvas.width / 2 + 10, padding + 10);
                this.ctx.fillText('-1', this.canvas.width / 2 + 10, this.canvas.height - padding);
            }
        }

        class BoundaryVisualizer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.resolution = 50;
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }

            resizeCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            }

            drawBoundary(network) {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                if (!network) return;

                const padding = 40;
                const width = this.canvas.width - padding * 2;
                const height = this.canvas.height - padding * 2;

                // Draw decision boundary
                const imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);

                for (let i = 0; i < this.canvas.width; i++) {
                    for (let j = 0; j < this.canvas.height; j++) {
                        const x = (i - padding) / width * 2 - 1;
                        const y = 1 - (j - padding) / height * 2;

                        const output = network.predict([x, y]);
                        const prediction = output[0] > output[1] ? 0 : 1;
                        const confidence = Math.abs(output[0] - output[1]);

                        const pixelIndex = (j * this.canvas.width + i) * 4;
                        if (prediction === 0) {
                            imageData.data[pixelIndex] = 255;
                            imageData.data[pixelIndex + 1] = 100;
                            imageData.data[pixelIndex + 2] = 100;
                        } else {
                            imageData.data[pixelIndex] = 100;
                            imageData.data[pixelIndex + 1] = 200;
                            imageData.data[pixelIndex + 2] = 255;
                        }
                        imageData.data[pixelIndex + 3] = confidence * 80;
                    }
                }

                this.ctx.putImageData(imageData, 0, 0);

                // Draw axes
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.moveTo(padding, this.canvas.height / 2);
                this.ctx.lineTo(this.canvas.width - padding, this.canvas.height / 2);
                this.ctx.moveTo(this.canvas.width / 2, padding);
                this.ctx.lineTo(this.canvas.width / 2, this.canvas.height - padding);
                this.ctx.stroke();
            }
        }

        class LossVisualizer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.lossHistory = [];
                this.maxHistory = 500;
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }

            resizeCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            }

            addLoss(loss) {
                this.lossHistory.push(loss);
                if (this.lossHistory.length > this.maxHistory) {
                    this.lossHistory.shift();
                }
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                if (this.lossHistory.length < 2) return;

                const padding = 40;
                const width = this.canvas.width - padding * 2;
                const height = this.canvas.height - padding * 2;

                // Find min/max
                const maxLoss = Math.max(...this.lossHistory);
                const minLoss = Math.min(...this.lossHistory);
                const range = maxLoss - minLoss || 1;

                // Draw grid
                this.ctx.strokeStyle = 'rgba(200, 200, 200, 0.1)';
                this.ctx.lineWidth = 1;
                for (let i = 0; i <= 5; i++) {
                    const y = padding + (height * i / 5);
                    this.ctx.beginPath();
                    this.ctx.moveTo(padding, y);
                    this.ctx.lineTo(this.canvas.width - padding, y);
                    this.ctx.stroke();
                }

                // Draw loss curve
                this.ctx.strokeStyle = '#00ffff';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();

                for (let i = 0; i < this.lossHistory.length; i++) {
                    const x = padding + (i / this.lossHistory.length) * width;
                    const y = padding + height - ((this.lossHistory[i] - minLoss) / range) * height;

                    if (i === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                }

                this.ctx.stroke();

                // Draw glow
                this.ctx.shadowBlur = 10;
                this.ctx.shadowColor = 'rgba(0, 255, 255, 0.5)';
                this.ctx.stroke();
                this.ctx.shadowBlur = 0;

                // Draw labels
                this.ctx.fillStyle = '#b0b0b0';
                this.ctx.font = '12px "Segoe UI"';
                this.ctx.textAlign = 'right';

                for (let i = 0; i <= 5; i++) {
                    const y = padding + (height * i / 5);
                    const value = maxLoss - (range * i / 5);
                    this.ctx.fillText(value.toFixed(3), padding - 10, y + 4);
                }

                // Current loss
                const currentLoss = this.lossHistory[this.lossHistory.length - 1];
                this.ctx.fillStyle = '#00ffff';
                this.ctx.textAlign = 'center';
                this.ctx.font = 'bold 16px "Segoe UI"';
                this.ctx.fillText(`Loss: ${currentLoss.toFixed(4)}`, this.canvas.width / 2, 30);
            }

            reset() {
                this.lossHistory = [];
                this.draw();
            }
        }

        // Global state
        let network = null;
        let currentData = null;
        let currentLabels = null;
        let isTraining = false;
        let trainingInterval = null;

        // Visualizers
        const networkViz = new NetworkVisualizer(document.getElementById('networkCanvas'));
        const dataViz = new DataVisualizer(document.getElementById('dataCanvas'));
        const boundaryViz = new BoundaryVisualizer(document.getElementById('boundaryCanvas'));
        const lossViz = new LossVisualizer(document.getElementById('lossCanvas'));

        // UI Event Listeners
        document.getElementById('learningRate').addEventListener('input', (e) => {
            document.getElementById('lrValue').textContent = parseFloat(e.target.value).toFixed(3);
        });

        document.getElementById('epochs').addEventListener('input', (e) => {
            document.getElementById('epochValue').textContent = e.target.value;
        });

        document.getElementById('batchSize').addEventListener('input', (e) => {
            document.getElementById('batchValue').textContent = e.target.value;
        });

        document.getElementById('datasetSelect').addEventListener('change', () => {
            loadDataset();
            if (network) {
                boundaryViz.drawBoundary(network);
            }
        });

        // Functions
        function loadDataset() {
            const datasetType = document.getElementById('datasetSelect').value;
            let dataset;

            switch(datasetType) {
                case 'xor':
                    dataset = generateXORData(200);
                    break;
                case 'circle':
                    dataset = generateCircleData(200);
                    break;
                case 'spiral':
                    dataset = generateSpiralData(200);
                    break;
            }

            currentData = dataset.data;
            currentLabels = dataset.labels;
            dataViz.drawData(currentData, currentLabels);
        }

        function updateArchitecture() {
            const input = document.getElementById('architectureInput').value;
            const hiddenLayers = input.split(',').map(x => parseInt(x.trim())).filter(x => !isNaN(x) && x > 0);

            if (hiddenLayers.length === 0) {
                alert('Please enter valid layer sizes (e.g., 4,4)');
                return;
            }

            const architecture = [2, ...hiddenLayers, 2];
            const activation = document.getElementById('activationSelect').value;

            network = new NeuralNetwork(architecture, activation);
            networkViz.drawNetwork(network);
            boundaryViz.drawBoundary(network);

            document.getElementById('paramStat').textContent = network.getParameterCount();
        }

        function startTraining() {
            if (!network) {
                alert('Please build a network first');
                return;
            }

            if (!currentData) {
                loadDataset();
            }

            if (isTraining) {
                return;
            }

            isTraining = true;
            document.getElementById('trainingStatus').textContent = 'Training...';
            document.getElementById('trainingStatus').classList.add('active');

            const learningRate = parseFloat(document.getElementById('learningRate').value);
            const epochs = parseInt(document.getElementById('epochs').value);
            const batchSize = parseInt(document.getElementById('batchSize').value);

            lossViz.reset();

            let currentEpoch = 0;

            const trainStep = () => {
                if (!isTraining || currentEpoch >= epochs) {
                    stopTraining();
                    return;
                }

                // Train for a few epochs per frame
                const epochsPerFrame = 1;
                for (let i = 0; i < epochsPerFrame && currentEpoch < epochs; i++) {
                    let totalLoss = 0;
                    let correct = 0;

                    for (let j = 0; j < currentData.length; j++) {
                        const input = currentData[j];
                        const target = currentLabels[j];

                        const output = network.forward(input);
                        const loss = -target.reduce((sum, t, k) => sum + t * Math.log(output[k] + 1e-10), 0);
                        totalLoss += loss;

                        const predicted = output.indexOf(Math.max(...output));
                        const actual = target.indexOf(Math.max(...target));
                        if (predicted === actual) correct++;

                        network.backward(input, target, learningRate);
                    }

                    const avgLoss = totalLoss / currentData.length;
                    const accuracy = correct / currentData.length;

                    lossViz.addLoss(avgLoss);

                    currentEpoch++;

                    if (currentEpoch % 10 === 0) {
                        document.getElementById('epochStat').textContent = currentEpoch;
                        document.getElementById('lossStat').textContent = avgLoss.toFixed(4);
                        document.getElementById('accuracyStat').textContent = (accuracy * 100).toFixed(1) + '%';
                    }
                }

                networkViz.drawNetwork(network, true);
                boundaryViz.drawBoundary(network);
                lossViz.draw();

                requestAnimationFrame(trainStep);
            };

            requestAnimationFrame(trainStep);
        }

        function stopTraining() {
            isTraining = false;
            document.getElementById('trainingStatus').textContent = 'Training stopped';
            document.getElementById('trainingStatus').classList.remove('active');
        }

        function resetNetwork() {
            stopTraining();

            if (network) {
                network.initializeNetwork();
                networkViz.drawNetwork(network);
                boundaryViz.drawBoundary(network);
                lossViz.reset();

                document.getElementById('epochStat').textContent = '0';
                document.getElementById('lossStat').textContent = '0.00';
                document.getElementById('accuracyStat').textContent = '0%';
                document.getElementById('trainingStatus').textContent = 'Network reset';
            }
        }

        function exportNetwork() {
            if (!network) {
                alert('No network to export');
                return;
            }

            const data = {
                network: network.export(),
                metadata: {
                    dataset: document.getElementById('datasetSelect').value,
                    learningRate: parseFloat(document.getElementById('learningRate').value),
                    activation: document.getElementById('activationSelect').value,
                    exportDate: new Date().toISOString()
                }
            };

            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'neural-network.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function importNetwork() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'application/json';

            input.onchange = (e) => {
                const file = e.target.files[0];
                const reader = new FileReader();

                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);

                        const activation = data.network.activation || 'relu';
                        network = new NeuralNetwork(data.network.architecture, activation);
                        network.import(data.network);

                        document.getElementById('architectureInput').value =
                            data.network.architecture.slice(1, -1).join(',');
                        document.getElementById('activationSelect').value = activation;

                        if (data.metadata) {
                            if (data.metadata.dataset) {
                                document.getElementById('datasetSelect').value = data.metadata.dataset;
                            }
                            if (data.metadata.learningRate) {
                                document.getElementById('learningRate').value = data.metadata.learningRate;
                                document.getElementById('lrValue').textContent = data.metadata.learningRate.toFixed(3);
                            }
                        }

                        loadDataset();
                        networkViz.drawNetwork(network);
                        boundaryViz.drawBoundary(network);

                        document.getElementById('paramStat').textContent = network.getParameterCount();
                        document.getElementById('trainingStatus').textContent = 'Network imported successfully';
                    } catch (error) {
                        alert('Error importing network: ' + error.message);
                    }
                };

                reader.readAsText(file);
            };

            input.click();
        }

        // Initialize
        loadDataset();
        updateArchitecture();

        // Animation loop for smooth rendering
        function animate() {
            if (!isTraining && network) {
                networkViz.drawNetwork(network, false);
            }
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>