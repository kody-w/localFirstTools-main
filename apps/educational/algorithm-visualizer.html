<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm Visualizer</title>
    <meta name="rappterzoo:author" content="Claude Opus 4.6">
    <meta name="rappterzoo:author-type" content="agent">
    <meta name="rappterzoo:category" content="educational">
    <meta name="rappterzoo:tags" content="canvas,algorithm,educational,animation,interactive">
    <meta name="rappterzoo:type" content="interface">
    <meta name="rappterzoo:complexity" content="advanced">
    <meta name="rappterzoo:created" content="2026-02-07">
    <meta name="rappterzoo:generation" content="0">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, hsl(220, 30%, 10%) 0%, hsl(240, 25%, 15%) 100%);
            color: hsl(0, 0%, 95%);
            min-height: 100vh;
            overflow-x: hidden;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, hsl(260, 60%, 30%) 0%, hsl(280, 50%, 40%) 100%);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            background: linear-gradient(135deg, hsl(180, 100%, 80%), hsl(280, 100%, 80%));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-size: 1.1em;
            opacity: 0.9;
            color: hsl(180, 70%, 70%);
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .tab {
            padding: 12px 24px;
            background: linear-gradient(135deg, hsl(240, 20%, 25%) 0%, hsl(240, 20%, 20%) 100%);
            border: 2px solid hsl(240, 30%, 35%);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
            font-weight: 600;
            color: hsl(0, 0%, 90%);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .tab:hover {
            background: linear-gradient(135deg, hsl(240, 30%, 35%) 0%, hsl(240, 30%, 30%) 100%);
            border-color: hsl(260, 60%, 50%);
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
        }

        .tab.active {
            background: linear-gradient(135deg, hsl(260, 60%, 50%) 0%, hsl(280, 50%, 50%) 100%);
            border-color: hsl(280, 70%, 60%);
            color: white;
            box-shadow: 0 6px 20px rgba(160, 80, 255, 0.4);
        }

        .control-panel {
            background: linear-gradient(135deg, hsl(240, 20%, 20%) 0%, hsl(240, 25%, 18%) 100%);
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 20px;
            box-shadow: 0 6px 24px rgba(0, 0, 0, 0.3);
            border: 1px solid hsl(240, 30%, 30%);
        }

        .control-section {
            margin-bottom: 20px;
        }

        .control-section:last-child {
            margin-bottom: 0;
        }

        .control-section h3 {
            margin-bottom: 12px;
            color: hsl(280, 70%, 70%);
            font-size: 1.1em;
        }

        .algorithm-selector {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .algo-btn {
            padding: 10px 18px;
            background: linear-gradient(135deg, hsl(240, 25%, 28%) 0%, hsl(240, 25%, 23%) 100%);
            border: 2px solid hsl(240, 30%, 35%);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.95em;
            color: hsl(0, 0%, 90%);
        }

        .algo-btn:hover {
            background: linear-gradient(135deg, hsl(240, 30%, 38%) 0%, hsl(240, 30%, 33%) 100%);
            border-color: hsl(260, 50%, 50%);
            transform: scale(1.05);
        }

        .algo-btn.active {
            background: linear-gradient(135deg, hsl(180, 60%, 45%) 0%, hsl(180, 60%, 40%) 100%);
            border-color: hsl(180, 70%, 50%);
            color: white;
            box-shadow: 0 4px 16px rgba(0, 200, 200, 0.3);
        }

        .controls {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: center;
        }

        button {
            padding: 12px 24px;
            background: linear-gradient(135deg, hsl(260, 60%, 50%) 0%, hsl(280, 50%, 50%) 100%);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
            font-weight: 600;
            color: white;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        button:hover {
            background: linear-gradient(135deg, hsl(260, 60%, 60%) 0%, hsl(280, 50%, 60%) 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(160, 80, 255, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .slider-control {
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-width: 200px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
            color: hsl(0, 0%, 80%);
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            background: linear-gradient(90deg, hsl(180, 60%, 40%) 0%, hsl(280, 60%, 50%) 100%);
            border-radius: 4px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
            transition: all 0.2s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 12px rgba(255, 255, 255, 0.4);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
            transition: all 0.2s ease;
        }

        input[type="range"]::-moz-range-thumb:hover {
            transform: scale(1.2);
        }

        .stats {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            padding: 15px;
            background: linear-gradient(135deg, hsl(240, 30%, 15%) 0%, hsl(240, 30%, 12%) 100%);
            border-radius: 8px;
            border: 1px solid hsl(240, 40%, 25%);
        }

        .stat {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .stat-label {
            font-size: 0.85em;
            color: hsl(0, 0%, 70%);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: 700;
            color: hsl(180, 70%, 60%);
            text-shadow: 0 2px 8px rgba(0, 200, 200, 0.3);
        }

        .canvas-container {
            background: linear-gradient(135deg, hsl(240, 25%, 18%) 0%, hsl(240, 30%, 15%) 100%);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            border: 2px solid hsl(240, 30%, 25%);
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: auto;
            border-radius: 8px;
            background: hsl(240, 30%, 12%);
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .legend {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            margin-top: 15px;
            padding: 15px;
            background: linear-gradient(135deg, hsl(240, 30%, 15%) 0%, hsl(240, 30%, 12%) 100%);
            border-radius: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
        }

        .legend-color {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .instructions {
            background: linear-gradient(135deg, hsl(240, 25%, 18%) 0%, hsl(240, 30%, 15%) 100%);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid hsl(240, 30%, 25%);
            margin-top: 20px;
        }

        .instructions h3 {
            color: hsl(280, 70%, 70%);
            margin-bottom: 10px;
        }

        .instructions ul {
            list-style-position: inside;
            line-height: 1.8;
            color: hsl(0, 0%, 85%);
        }

        .instructions li {
            margin-bottom: 5px;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8em;
            }

            .controls {
                flex-direction: column;
                align-items: stretch;
            }

            button {
                width: 100%;
            }

            .slider-control {
                min-width: 100%;
            }

            .stats {
                justify-content: space-between;
            }

            .stat {
                flex: 1;
                min-width: 100px;
            }
        }

        .mode-indicator {
            position: absolute;
            top: 15px;
            right: 15px;
            padding: 8px 16px;
            background: hsl(260, 60%, 50%);
            border-radius: 6px;
            font-size: 0.9em;
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .grid-instructions {
            text-align: center;
            padding: 12px;
            background: linear-gradient(135deg, hsl(200, 60%, 30%) 0%, hsl(220, 60%, 35%) 100%);
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 0.95em;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Algorithm Visualizer</h1>
            <p class="subtitle">Step-by-step visualizations of sorting, pathfinding, and data structures</p>
        </header>

        <div class="tabs">
            <div class="tab active" data-category="sorting">Sorting Algorithms</div>
            <div class="tab" data-category="pathfinding">Pathfinding</div>
            <div class="tab" data-category="datastructures">Data Structures</div>
        </div>

        <div class="control-panel">
            <div class="control-section" id="sortingAlgorithms">
                <h3>Select Algorithm</h3>
                <div class="algorithm-selector">
                    <button class="algo-btn active" data-algo="bubble">Bubble Sort</button>
                    <button class="algo-btn" data-algo="quick">Quick Sort</button>
                    <button class="algo-btn" data-algo="merge">Merge Sort</button>
                    <button class="algo-btn" data-algo="insertion">Insertion Sort</button>
                    <button class="algo-btn" data-algo="selection">Selection Sort</button>
                    <button class="algo-btn" data-algo="heap">Heap Sort</button>
                </div>
            </div>

            <div class="control-section" id="pathfindingAlgorithms" style="display: none;">
                <h3>Select Algorithm</h3>
                <div class="algorithm-selector">
                    <button class="algo-btn active" data-algo="bfs">Breadth-First Search</button>
                    <button class="algo-btn" data-algo="dijkstra">Dijkstra's Algorithm</button>
                    <button class="algo-btn" data-algo="astar">A* Search</button>
                    <button class="algo-btn" data-algo="dfs">Depth-First Search</button>
                </div>
                <div class="grid-instructions" id="gridInstructions">
                    Click to place START (blue) → END (red) → WALLS (dark). Click again to remove.
                </div>
            </div>

            <div class="control-section" id="datastructuresAlgorithms" style="display: none;">
                <h3>Select Data Structure</h3>
                <div class="algorithm-selector">
                    <button class="algo-btn active" data-algo="binarytree">Binary Search Tree</button>
                    <button class="algo-btn" data-algo="stack">Stack</button>
                    <button class="algo-btn" data-algo="queue">Queue</button>
                    <button class="algo-btn" data-algo="linkedlist">Linked List</button>
                </div>
            </div>

            <div class="control-section">
                <h3>Controls</h3>
                <div class="controls">
                    <button id="playBtn">Play</button>
                    <button id="pauseBtn">Pause</button>
                    <button id="stepBtn">Next Step</button>
                    <button id="resetBtn">Reset</button>
                    <button id="randomizeBtn">Randomize</button>
                </div>
            </div>

            <div class="control-section">
                <h3>Settings</h3>
                <div class="controls">
                    <div class="slider-control">
                        <div class="slider-label">
                            <span>Speed</span>
                            <span id="speedValue">50</span>
                        </div>
                        <input type="range" id="speedSlider" min="1" max="100" value="50">
                    </div>
                    <div class="slider-control" id="arraySizeControl">
                        <div class="slider-label">
                            <span>Array Size</span>
                            <span id="sizeValue">50</span>
                        </div>
                        <input type="range" id="sizeSlider" min="10" max="100" value="50">
                    </div>
                </div>
            </div>

            <div class="stats">
                <div class="stat">
                    <div class="stat-label">Operations</div>
                    <div class="stat-value" id="operations">0</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Comparisons</div>
                    <div class="stat-value" id="comparisons">0</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Array Accesses</div>
                    <div class="stat-value" id="accesses">0</div>
                </div>
                <div class="stat">
                    <div class="stat-label">Time (ms)</div>
                    <div class="stat-value" id="timeElapsed">0</div>
                </div>
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="visualizer" width="1200" height="600"></canvas>
            <div class="mode-indicator" id="modeIndicator">Stopped</div>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: hsl(200, 70%, 50%);"></div>
                <span>Current / Comparing</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: hsl(50, 100%, 60%);"></div>
                <span>Comparing</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: hsl(0, 80%, 60%);"></div>
                <span>Swapping</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: hsl(120, 60%, 50%);"></div>
                <span>Sorted / Found</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: hsl(280, 60%, 50%);"></div>
                <span>Pivot / Special</span>
            </div>
        </div>

        <div class="instructions">
            <h3>Instructions</h3>
            <ul>
                <li><strong>Sorting:</strong> Visualizes how different sorting algorithms organize data. Watch bars rearrange in real-time.</li>
                <li><strong>Pathfinding:</strong> Shows how algorithms find the shortest path on a grid. Place start, end, and walls.</li>
                <li><strong>Data Structures:</strong> Demonstrates operations on trees, stacks, queues, and lists with visual node diagrams.</li>
                <li><strong>Speed Control:</strong> Adjust the slider to slow down or speed up the visualization.</li>
                <li><strong>Step Mode:</strong> Click "Next Step" to advance one operation at a time for detailed analysis.</li>
                <li><strong>Keyboard:</strong> Space = Play/Pause, S = Step, R = Reset, Arrow Keys = Adjust Speed</li>
            </ul>
        </div>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('visualizer');
        const ctx = canvas.getContext('2d');

        // State
        let currentCategory = 'sorting';
        let currentAlgorithm = 'bubble';
        let isPlaying = false;
        let isPaused = false;
        let animationId = null;
        let stepMode = false;

        // Statistics
        let stats = {
            operations: 0,
            comparisons: 0,
            accesses: 0,
            startTime: 0,
            elapsedTime: 0
        };

        // Sorting state
        let array = [];
        let arraySize = 50;
        let speed = 50;
        let sortingSteps = [];
        let currentStep = 0;

        // Pathfinding state
        let grid = [];
        let gridSize = 30;
        let cellSize = 0;
        let startNode = null;
        let endNode = null;
        let pathfindingSteps = [];
        let gridMode = 'start'; // start, end, wall

        // Data structure state
        let dsNodes = [];
        let dsSteps = [];
        let dsValues = [];

        // DOM elements
        const tabs = document.querySelectorAll('.tab');
        const algoButtons = document.querySelectorAll('.algo-btn');
        const playBtn = document.getElementById('playBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const stepBtn = document.getElementById('stepBtn');
        const resetBtn = document.getElementById('resetBtn');
        const randomizeBtn = document.getElementById('randomizeBtn');
        const speedSlider = document.getElementById('speedSlider');
        const sizeSlider = document.getElementById('sizeSlider');
        const modeIndicator = document.getElementById('modeIndicator');

        // Initialize
        function init() {
            loadSettings();
            generateRandomArray();
            updateUI();
            draw();

            // Event listeners
            tabs.forEach(tab => {
                tab.addEventListener('click', () => switchCategory(tab.dataset.category));
            });

            algoButtons.forEach(btn => {
                btn.addEventListener('click', () => selectAlgorithm(btn.dataset.algo));
            });

            playBtn.addEventListener('click', play);
            pauseBtn.addEventListener('click', pause);
            stepBtn.addEventListener('click', step);
            resetBtn.addEventListener('click', reset);
            randomizeBtn.addEventListener('click', randomize);

            speedSlider.addEventListener('input', (e) => {
                speed = parseInt(e.target.value);
                document.getElementById('speedValue').textContent = speed;
                saveSettings();
            });

            sizeSlider.addEventListener('input', (e) => {
                arraySize = parseInt(e.target.value);
                document.getElementById('sizeValue').textContent = arraySize;
                if (!isPlaying) {
                    reset();
                }
                saveSettings();
            });

            canvas.addEventListener('click', handleCanvasClick);

            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space') {
                    e.preventDefault();
                    isPlaying ? pause() : play();
                } else if (e.code === 'KeyS') {
                    step();
                } else if (e.code === 'KeyR') {
                    reset();
                } else if (e.code === 'ArrowUp') {
                    speedSlider.value = Math.min(100, parseInt(speedSlider.value) + 5);
                    speedSlider.dispatchEvent(new Event('input'));
                } else if (e.code === 'ArrowDown') {
                    speedSlider.value = Math.max(1, parseInt(speedSlider.value) - 5);
                    speedSlider.dispatchEvent(new Event('input'));
                }
            });

            // Animation loop
            function animate() {
                if (isPlaying && !isPaused) {
                    const delay = 1000 / (speed / 10);
                    const now = Date.now();
                    if (!animate.lastTime || now - animate.lastTime >= delay) {
                        executeNextStep();
                        animate.lastTime = now;
                    }
                }
                animationId = requestAnimationFrame(animate);
            }
            animate();
        }

        function switchCategory(category) {
            if (isPlaying) pause();

            currentCategory = category;
            tabs.forEach(tab => tab.classList.toggle('active', tab.dataset.category === category));

            document.getElementById('sortingAlgorithms').style.display = category === 'sorting' ? 'block' : 'none';
            document.getElementById('pathfindingAlgorithms').style.display = category === 'pathfinding' ? 'block' : 'none';
            document.getElementById('datastructuresAlgorithms').style.display = category === 'datastructures' ? 'block' : 'none';
            document.getElementById('arraySizeControl').style.display = category === 'sorting' ? 'flex' : 'none';

            // Select first algorithm in category
            const firstAlgo = document.querySelector(`#${category}Algorithms .algo-btn`);
            if (firstAlgo) {
                selectAlgorithm(firstAlgo.dataset.algo);
            }
        }

        function selectAlgorithm(algo) {
            if (isPlaying) pause();

            currentAlgorithm = algo;
            const container = document.querySelector(`#${currentCategory}Algorithms`);
            container.querySelectorAll('.algo-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.algo === algo);
            });

            reset();
        }

        function play() {
            if (currentStep === 0) {
                prepareAlgorithm();
            }

            isPlaying = true;
            isPaused = false;
            stepMode = false;
            stats.startTime = Date.now() - stats.elapsedTime;
            updateUI();
        }

        function pause() {
            isPlaying = false;
            isPaused = true;
            stats.elapsedTime = Date.now() - stats.startTime;
            updateUI();
        }

        function step() {
            if (!isPlaying || isPaused) {
                if (currentStep === 0) {
                    prepareAlgorithm();
                }
                stepMode = true;
                executeNextStep();
            }
        }

        function reset() {
            isPlaying = false;
            isPaused = false;
            stepMode = false;
            currentStep = 0;
            stats = { operations: 0, comparisons: 0, accesses: 0, startTime: 0, elapsedTime: 0 };

            if (currentCategory === 'sorting') {
                generateRandomArray();
            } else if (currentCategory === 'pathfinding') {
                initializeGrid();
            } else if (currentCategory === 'datastructures') {
                initializeDataStructure();
            }

            updateUI();
            draw();
        }

        function randomize() {
            if (currentCategory === 'sorting') {
                generateRandomArray();
            } else if (currentCategory === 'pathfinding') {
                initializeGrid();
                generateRandomMaze();
            } else if (currentCategory === 'datastructures') {
                initializeDataStructure();
                for (let i = 0; i < 10; i++) {
                    const value = Math.floor(Math.random() * 100) + 1;
                    addDataStructureValue(value);
                }
            }
            draw();
        }

        function prepareAlgorithm() {
            stats.startTime = Date.now();

            if (currentCategory === 'sorting') {
                generateSortingSteps();
            } else if (currentCategory === 'pathfinding') {
                generatePathfindingSteps();
            } else if (currentCategory === 'datastructures') {
                // Data structures operate differently
            }
        }

        function executeNextStep() {
            let steps = currentCategory === 'sorting' ? sortingSteps :
                       currentCategory === 'pathfinding' ? pathfindingSteps : dsSteps;

            if (currentStep < steps.length) {
                const step = steps[currentStep];
                applyStep(step);
                currentStep++;
                stats.elapsedTime = Date.now() - stats.startTime;
                updateUI();
                draw();
            } else {
                if (isPlaying) {
                    pause();
                    modeIndicator.textContent = 'Complete!';
                }
            }
        }

        function applyStep(step) {
            if (currentCategory === 'sorting') {
                if (step.type === 'compare') {
                    stats.comparisons++;
                    stats.accesses += 2;
                } else if (step.type === 'swap') {
                    const temp = array[step.i];
                    array[step.i] = array[step.j];
                    array[step.j] = temp;
                    stats.operations++;
                    stats.accesses += 2;
                } else if (step.type === 'set') {
                    array[step.i] = step.value;
                    stats.operations++;
                    stats.accesses++;
                }
            }
        }

        // Sorting algorithms
        function generateRandomArray() {
            array = [];
            for (let i = 0; i < arraySize; i++) {
                array.push(Math.floor(Math.random() * (canvas.height - 100)) + 20);
            }
        }

        function generateSortingSteps() {
            sortingSteps = [];
            const arrCopy = [...array];

            if (currentAlgorithm === 'bubble') {
                bubbleSort(arrCopy);
            } else if (currentAlgorithm === 'quick') {
                quickSort(arrCopy, 0, arrCopy.length - 1);
            } else if (currentAlgorithm === 'merge') {
                mergeSort(arrCopy, 0, arrCopy.length - 1);
            } else if (currentAlgorithm === 'insertion') {
                insertionSort(arrCopy);
            } else if (currentAlgorithm === 'selection') {
                selectionSort(arrCopy);
            } else if (currentAlgorithm === 'heap') {
                heapSort(arrCopy);
            }
        }

        function bubbleSort(arr) {
            const n = arr.length;
            for (let i = 0; i < n - 1; i++) {
                for (let j = 0; j < n - i - 1; j++) {
                    sortingSteps.push({ type: 'compare', i: j, j: j + 1 });
                    if (arr[j] > arr[j + 1]) {
                        sortingSteps.push({ type: 'swap', i: j, j: j + 1 });
                        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
                    }
                }
                sortingSteps.push({ type: 'sorted', i: n - i - 1 });
            }
        }

        function quickSort(arr, low, high) {
            if (low < high) {
                const pi = partition(arr, low, high);
                quickSort(arr, low, pi - 1);
                quickSort(arr, pi + 1, high);
            }
        }

        function partition(arr, low, high) {
            const pivot = arr[high];
            sortingSteps.push({ type: 'pivot', i: high });
            let i = low - 1;

            for (let j = low; j < high; j++) {
                sortingSteps.push({ type: 'compare', i: j, j: high });
                if (arr[j] < pivot) {
                    i++;
                    sortingSteps.push({ type: 'swap', i: i, j: j });
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                }
            }
            sortingSteps.push({ type: 'swap', i: i + 1, j: high });
            [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
            return i + 1;
        }

        function mergeSort(arr, left, right) {
            if (left < right) {
                const mid = Math.floor((left + right) / 2);
                mergeSort(arr, left, mid);
                mergeSort(arr, mid + 1, right);
                merge(arr, left, mid, right);
            }
        }

        function merge(arr, left, mid, right) {
            const n1 = mid - left + 1;
            const n2 = right - mid;
            const L = arr.slice(left, mid + 1);
            const R = arr.slice(mid + 1, right + 1);

            let i = 0, j = 0, k = left;

            while (i < n1 && j < n2) {
                sortingSteps.push({ type: 'compare', i: left + i, j: mid + 1 + j });
                if (L[i] <= R[j]) {
                    sortingSteps.push({ type: 'set', i: k, value: L[i] });
                    arr[k] = L[i];
                    i++;
                } else {
                    sortingSteps.push({ type: 'set', i: k, value: R[j] });
                    arr[k] = R[j];
                    j++;
                }
                k++;
            }

            while (i < n1) {
                sortingSteps.push({ type: 'set', i: k, value: L[i] });
                arr[k] = L[i];
                i++;
                k++;
            }

            while (j < n2) {
                sortingSteps.push({ type: 'set', i: k, value: R[j] });
                arr[k] = R[j];
                j++;
                k++;
            }
        }

        function insertionSort(arr) {
            for (let i = 1; i < arr.length; i++) {
                const key = arr[i];
                let j = i - 1;

                sortingSteps.push({ type: 'compare', i: i, j: i });

                while (j >= 0 && arr[j] > key) {
                    sortingSteps.push({ type: 'compare', i: j, j: j + 1 });
                    sortingSteps.push({ type: 'set', i: j + 1, value: arr[j] });
                    arr[j + 1] = arr[j];
                    j--;
                }

                sortingSteps.push({ type: 'set', i: j + 1, value: key });
                arr[j + 1] = key;
            }
        }

        function selectionSort(arr) {
            for (let i = 0; i < arr.length - 1; i++) {
                let minIdx = i;
                for (let j = i + 1; j < arr.length; j++) {
                    sortingSteps.push({ type: 'compare', i: minIdx, j: j });
                    if (arr[j] < arr[minIdx]) {
                        minIdx = j;
                    }
                }
                if (minIdx !== i) {
                    sortingSteps.push({ type: 'swap', i: i, j: minIdx });
                    [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];
                }
                sortingSteps.push({ type: 'sorted', i: i });
            }
        }

        function heapSort(arr) {
            const n = arr.length;

            for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
                heapify(arr, n, i);
            }

            for (let i = n - 1; i > 0; i--) {
                sortingSteps.push({ type: 'swap', i: 0, j: i });
                [arr[0], arr[i]] = [arr[i], arr[0]];
                sortingSteps.push({ type: 'sorted', i: i });
                heapify(arr, i, 0);
            }
        }

        function heapify(arr, n, i) {
            let largest = i;
            const left = 2 * i + 1;
            const right = 2 * i + 2;

            if (left < n) {
                sortingSteps.push({ type: 'compare', i: left, j: largest });
                if (arr[left] > arr[largest]) {
                    largest = left;
                }
            }

            if (right < n) {
                sortingSteps.push({ type: 'compare', i: right, j: largest });
                if (arr[right] > arr[largest]) {
                    largest = right;
                }
            }

            if (largest !== i) {
                sortingSteps.push({ type: 'swap', i: i, j: largest });
                [arr[i], arr[largest]] = [arr[largest], arr[i]];
                heapify(arr, n, largest);
            }
        }

        // Pathfinding
        function initializeGrid() {
            cellSize = Math.floor(canvas.width / gridSize);
            grid = [];
            for (let y = 0; y < gridSize; y++) {
                grid[y] = [];
                for (let x = 0; x < gridSize; x++) {
                    grid[y][x] = { x, y, wall: false, visited: false, distance: Infinity, parent: null };
                }
            }
            startNode = { x: 2, y: 2 };
            endNode = { x: gridSize - 3, y: gridSize - 3 };
            pathfindingSteps = [];
            gridMode = 'wall';
        }

        function generateRandomMaze() {
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (Math.random() < 0.25 &&
                        !(x === startNode.x && y === startNode.y) &&
                        !(x === endNode.x && y === endNode.y)) {
                        grid[y][x].wall = true;
                    }
                }
            }
        }

        function generatePathfindingSteps() {
            pathfindingSteps = [];

            // Reset grid
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    grid[y][x].visited = false;
                    grid[y][x].distance = Infinity;
                    grid[y][x].parent = null;
                }
            }

            if (currentAlgorithm === 'bfs') {
                bfs();
            } else if (currentAlgorithm === 'dijkstra') {
                dijkstra();
            } else if (currentAlgorithm === 'astar') {
                aStar();
            } else if (currentAlgorithm === 'dfs') {
                dfs();
            }
        }

        function bfs() {
            const queue = [startNode];
            grid[startNode.y][startNode.x].visited = true;
            grid[startNode.y][startNode.x].distance = 0;

            while (queue.length > 0) {
                const current = queue.shift();
                pathfindingSteps.push({ type: 'visit', x: current.x, y: current.y });

                if (current.x === endNode.x && current.y === endNode.y) {
                    reconstructPath();
                    return;
                }

                const neighbors = getNeighbors(current.x, current.y);
                for (const neighbor of neighbors) {
                    if (!grid[neighbor.y][neighbor.x].visited && !grid[neighbor.y][neighbor.x].wall) {
                        grid[neighbor.y][neighbor.x].visited = true;
                        grid[neighbor.y][neighbor.x].distance = grid[current.y][current.x].distance + 1;
                        grid[neighbor.y][neighbor.x].parent = current;
                        queue.push(neighbor);
                        pathfindingSteps.push({ type: 'explore', x: neighbor.x, y: neighbor.y });
                    }
                }
            }
        }

        function dijkstra() {
            const unvisited = [];
            grid[startNode.y][startNode.x].distance = 0;

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (!grid[y][x].wall) {
                        unvisited.push({ x, y });
                    }
                }
            }

            while (unvisited.length > 0) {
                unvisited.sort((a, b) => grid[a.y][a.x].distance - grid[b.y][b.x].distance);
                const current = unvisited.shift();

                if (grid[current.y][current.x].distance === Infinity) break;

                grid[current.y][current.x].visited = true;
                pathfindingSteps.push({ type: 'visit', x: current.x, y: current.y });

                if (current.x === endNode.x && current.y === endNode.y) {
                    reconstructPath();
                    return;
                }

                const neighbors = getNeighbors(current.x, current.y);
                for (const neighbor of neighbors) {
                    if (!grid[neighbor.y][neighbor.x].visited && !grid[neighbor.y][neighbor.x].wall) {
                        const alt = grid[current.y][current.x].distance + 1;
                        if (alt < grid[neighbor.y][neighbor.x].distance) {
                            grid[neighbor.y][neighbor.x].distance = alt;
                            grid[neighbor.y][neighbor.x].parent = current;
                            pathfindingSteps.push({ type: 'explore', x: neighbor.x, y: neighbor.y });
                        }
                    }
                }
            }
        }

        function aStar() {
            const openSet = [startNode];
            const closedSet = [];
            grid[startNode.y][startNode.x].distance = 0;
            grid[startNode.y][startNode.x].f = heuristic(startNode, endNode);

            while (openSet.length > 0) {
                openSet.sort((a, b) => (grid[a.y][a.x].f || Infinity) - (grid[b.y][b.x].f || Infinity));
                const current = openSet.shift();

                pathfindingSteps.push({ type: 'visit', x: current.x, y: current.y });

                if (current.x === endNode.x && current.y === endNode.y) {
                    reconstructPath();
                    return;
                }

                closedSet.push(current);

                const neighbors = getNeighbors(current.x, current.y);
                for (const neighbor of neighbors) {
                    if (closedSet.some(n => n.x === neighbor.x && n.y === neighbor.y) ||
                        grid[neighbor.y][neighbor.x].wall) {
                        continue;
                    }

                    const tentativeG = grid[current.y][current.x].distance + 1;

                    if (!openSet.some(n => n.x === neighbor.x && n.y === neighbor.y)) {
                        openSet.push(neighbor);
                    } else if (tentativeG >= grid[neighbor.y][neighbor.x].distance) {
                        continue;
                    }

                    grid[neighbor.y][neighbor.x].parent = current;
                    grid[neighbor.y][neighbor.x].distance = tentativeG;
                    grid[neighbor.y][neighbor.x].f = tentativeG + heuristic(neighbor, endNode);
                    pathfindingSteps.push({ type: 'explore', x: neighbor.x, y: neighbor.y });
                }
            }
        }

        function dfs() {
            const stack = [startNode];
            grid[startNode.y][startNode.x].visited = true;

            while (stack.length > 0) {
                const current = stack.pop();
                pathfindingSteps.push({ type: 'visit', x: current.x, y: current.y });

                if (current.x === endNode.x && current.y === endNode.y) {
                    reconstructPath();
                    return;
                }

                const neighbors = getNeighbors(current.x, current.y);
                for (const neighbor of neighbors) {
                    if (!grid[neighbor.y][neighbor.x].visited && !grid[neighbor.y][neighbor.x].wall) {
                        grid[neighbor.y][neighbor.x].visited = true;
                        grid[neighbor.y][neighbor.x].parent = current;
                        stack.push(neighbor);
                        pathfindingSteps.push({ type: 'explore', x: neighbor.x, y: neighbor.y });
                    }
                }
            }
        }

        function heuristic(a, b) {
            return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
        }

        function getNeighbors(x, y) {
            const neighbors = [];
            if (y > 0) neighbors.push({ x, y: y - 1 });
            if (x < gridSize - 1) neighbors.push({ x: x + 1, y });
            if (y < gridSize - 1) neighbors.push({ x, y: y + 1 });
            if (x > 0) neighbors.push({ x: x - 1, y });
            return neighbors;
        }

        function reconstructPath() {
            let current = endNode;
            while (current) {
                pathfindingSteps.push({ type: 'path', x: current.x, y: current.y });
                current = grid[current.y][current.x].parent;
            }
        }

        function handleCanvasClick(e) {
            if (currentCategory !== 'pathfinding' || isPlaying) return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = Math.floor((e.clientX - rect.left) * scaleX / cellSize);
            const y = Math.floor((e.clientY - rect.top) * scaleY / cellSize);

            if (x < 0 || x >= gridSize || y < 0 || y >= gridSize) return;

            if (gridMode === 'start') {
                startNode = { x, y };
                gridMode = 'end';
                document.getElementById('gridInstructions').textContent =
                    'Click to place END (red) → WALLS (dark). Click again to remove.';
            } else if (gridMode === 'end') {
                endNode = { x, y };
                gridMode = 'wall';
                document.getElementById('gridInstructions').textContent =
                    'Click to place WALLS (dark). Click START or END again to move them.';
            } else {
                if (x === startNode.x && y === startNode.y) {
                    gridMode = 'start';
                    document.getElementById('gridInstructions').textContent =
                        'Click to move START (blue).';
                } else if (x === endNode.x && y === endNode.y) {
                    gridMode = 'end';
                    document.getElementById('gridInstructions').textContent =
                        'Click to move END (red).';
                } else {
                    grid[y][x].wall = !grid[y][x].wall;
                }
            }

            draw();
        }

        // Data structures
        function initializeDataStructure() {
            dsNodes = [];
            dsSteps = [];
            dsValues = [];

            if (currentAlgorithm === 'binarytree') {
                // Start with empty tree
            } else if (currentAlgorithm === 'stack') {
                // Start with empty stack
            } else if (currentAlgorithm === 'queue') {
                // Start with empty queue
            } else if (currentAlgorithm === 'linkedlist') {
                // Start with empty list
            }
        }

        function addDataStructureValue(value) {
            if (currentAlgorithm === 'binarytree') {
                insertBST(value);
            } else if (currentAlgorithm === 'stack') {
                dsValues.push(value);
            } else if (currentAlgorithm === 'queue') {
                dsValues.push(value);
            } else if (currentAlgorithm === 'linkedlist') {
                dsValues.push(value);
            }
        }

        function insertBST(value) {
            if (dsNodes.length === 0) {
                dsNodes.push({ value, x: canvas.width / 2, y: 80, left: null, right: null, level: 0 });
            } else {
                insertBSTNode(dsNodes[0], value, 0, canvas.width / 2, 80, canvas.width / 4);
            }
        }

        function insertBSTNode(node, value, level, x, y, offset) {
            if (value < node.value) {
                if (node.left === null) {
                    const newNode = { value, x: x - offset, y: y + 100, left: null, right: null, level: level + 1 };
                    node.left = newNode;
                    dsNodes.push(newNode);
                } else {
                    insertBSTNode(node.left, value, level + 1, x - offset, y + 100, offset / 2);
                }
            } else {
                if (node.right === null) {
                    const newNode = { value, x: x + offset, y: y + 100, left: null, right: null, level: level + 1 };
                    node.right = newNode;
                    dsNodes.push(newNode);
                } else {
                    insertBSTNode(node.right, value, level + 1, x + offset, y + 100, offset / 2);
                }
            }
        }

        // Drawing
        function draw() {
            ctx.fillStyle = 'hsl(240, 30%, 12%)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (currentCategory === 'sorting') {
                drawSorting();
            } else if (currentCategory === 'pathfinding') {
                drawPathfinding();
            } else if (currentCategory === 'datastructures') {
                drawDataStructures();
            }
        }

        function drawSorting() {
            const barWidth = canvas.width / arraySize;
            const maxHeight = canvas.height - 100;

            for (let i = 0; i < array.length; i++) {
                let color = 'hsl(240, 40%, 50%)';

                if (currentStep > 0 && currentStep <= sortingSteps.length) {
                    const step = sortingSteps[currentStep - 1];
                    if (step.i === i || step.j === i) {
                        if (step.type === 'compare') {
                            color = 'hsl(50, 100%, 60%)';
                        } else if (step.type === 'swap') {
                            color = 'hsl(0, 80%, 60%)';
                        } else if (step.type === 'pivot' && step.i === i) {
                            color = 'hsl(280, 60%, 50%)';
                        }
                    } else if (step.type === 'sorted' && i >= step.i) {
                        color = 'hsl(120, 60%, 50%)';
                    }
                }

                const height = (array[i] / maxHeight) * (canvas.height - 100);

                ctx.fillStyle = color;
                ctx.fillRect(i * barWidth, canvas.height - height, barWidth - 2, height);

                // Add gradient
                const gradient = ctx.createLinearGradient(0, canvas.height - height, 0, canvas.height);
                gradient.addColorStop(0, color);
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0.3)');
                ctx.fillStyle = gradient;
                ctx.fillRect(i * barWidth, canvas.height - height, barWidth - 2, height);
            }
        }

        function drawPathfinding() {
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const cell = grid[y][x];
                    let color = 'hsl(240, 30%, 25%)';

                    if (cell.wall) {
                        color = 'hsl(0, 0%, 10%)';
                    } else if (x === startNode.x && y === startNode.y) {
                        color = 'hsl(200, 70%, 50%)';
                    } else if (x === endNode.x && y === endNode.y) {
                        color = 'hsl(0, 80%, 60%)';
                    } else if (currentStep > 0 && currentStep <= pathfindingSteps.length) {
                        for (let i = 0; i < currentStep; i++) {
                            const step = pathfindingSteps[i];
                            if (step.x === x && step.y === y) {
                                if (step.type === 'visit') {
                                    color = 'hsl(200, 60%, 40%)';
                                } else if (step.type === 'explore') {
                                    color = 'hsl(50, 70%, 50%)';
                                } else if (step.type === 'path') {
                                    color = 'hsl(120, 60%, 50%)';
                                }
                            }
                        }
                    }

                    ctx.fillStyle = color;
                    ctx.fillRect(x * cellSize + 1, y * cellSize + 1, cellSize - 2, cellSize - 2);

                    // Add shadow to cells
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                    ctx.shadowBlur = 4;
                    ctx.shadowOffsetX = 2;
                    ctx.shadowOffsetY = 2;
                    ctx.fillRect(x * cellSize + 1, y * cellSize + 1, cellSize - 2, cellSize - 2);
                    ctx.shadowBlur = 0;
                }
            }
        }

        function drawDataStructures() {
            if (currentAlgorithm === 'binarytree') {
                drawBinaryTree();
            } else if (currentAlgorithm === 'stack') {
                drawStack();
            } else if (currentAlgorithm === 'queue') {
                drawQueue();
            } else if (currentAlgorithm === 'linkedlist') {
                drawLinkedList();
            }
        }

        function drawBinaryTree() {
            // Draw edges first
            for (const node of dsNodes) {
                if (node.left) {
                    ctx.strokeStyle = 'hsl(240, 40%, 40%)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(node.x, node.y);
                    ctx.lineTo(node.left.x, node.left.y);
                    ctx.stroke();
                }
                if (node.right) {
                    ctx.strokeStyle = 'hsl(240, 40%, 40%)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(node.x, node.y);
                    ctx.lineTo(node.right.x, node.right.y);
                    ctx.stroke();
                }
            }

            // Draw nodes
            for (const node of dsNodes) {
                const gradient = ctx.createRadialGradient(node.x, node.y, 0, node.x, node.y, 25);
                gradient.addColorStop(0, 'hsl(260, 60%, 50%)');
                gradient.addColorStop(1, 'hsl(280, 50%, 40%)');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(node.x, node.y, 25, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = 'hsl(280, 70%, 60%)';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = 'white';
                ctx.font = 'bold 16px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(node.value, node.x, node.y);
            }
        }

        function drawStack() {
            const boxWidth = 100;
            const boxHeight = 40;
            const startX = canvas.width / 2 - boxWidth / 2;
            const startY = canvas.height - 50;

            for (let i = 0; i < dsValues.length; i++) {
                const y = startY - (i * (boxHeight + 5));

                const gradient = ctx.createLinearGradient(0, y, 0, y + boxHeight);
                gradient.addColorStop(0, 'hsl(260, 60%, 50%)');
                gradient.addColorStop(1, 'hsl(280, 50%, 40%)');

                ctx.fillStyle = gradient;
                ctx.fillRect(startX, y, boxWidth, boxHeight);

                ctx.strokeStyle = 'hsl(280, 70%, 60%)';
                ctx.lineWidth = 2;
                ctx.strokeRect(startX, y, boxWidth, boxHeight);

                ctx.fillStyle = 'white';
                ctx.font = 'bold 18px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(dsValues[i], startX + boxWidth / 2, y + boxHeight / 2);
            }

            // Draw "TOP" label
            if (dsValues.length > 0) {
                ctx.fillStyle = 'hsl(180, 70%, 60%)';
                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'right';
                ctx.fillText('TOP →', startX - 10, startY - ((dsValues.length - 1) * (boxHeight + 5)) + boxHeight / 2);
            }
        }

        function drawQueue() {
            const boxWidth = 80;
            const boxHeight = 60;
            const startX = 50;
            const startY = canvas.height / 2 - boxHeight / 2;

            for (let i = 0; i < dsValues.length; i++) {
                const x = startX + (i * (boxWidth + 10));

                const gradient = ctx.createLinearGradient(x, 0, x + boxWidth, 0);
                gradient.addColorStop(0, 'hsl(260, 60%, 50%)');
                gradient.addColorStop(1, 'hsl(280, 50%, 40%)');

                ctx.fillStyle = gradient;
                ctx.fillRect(x, startY, boxWidth, boxHeight);

                ctx.strokeStyle = 'hsl(280, 70%, 60%)';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, startY, boxWidth, boxHeight);

                ctx.fillStyle = 'white';
                ctx.font = 'bold 18px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(dsValues[i], x + boxWidth / 2, startY + boxHeight / 2);
            }

            // Draw labels
            if (dsValues.length > 0) {
                ctx.fillStyle = 'hsl(180, 70%, 60%)';
                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('FRONT', startX + boxWidth / 2, startY - 20);
                ctx.fillText('REAR', startX + ((dsValues.length - 1) * (boxWidth + 10)) + boxWidth / 2, startY - 20);
            }
        }

        function drawLinkedList() {
            const nodeWidth = 80;
            const nodeHeight = 50;
            const arrowLength = 40;
            const startX = 50;
            const startY = canvas.height / 2 - nodeHeight / 2;

            for (let i = 0; i < dsValues.length; i++) {
                const x = startX + (i * (nodeWidth + arrowLength + 10));

                // Draw node
                const gradient = ctx.createLinearGradient(x, 0, x + nodeWidth, 0);
                gradient.addColorStop(0, 'hsl(260, 60%, 50%)');
                gradient.addColorStop(1, 'hsl(280, 50%, 40%)');

                ctx.fillStyle = gradient;
                ctx.fillRect(x, startY, nodeWidth, nodeHeight);

                ctx.strokeStyle = 'hsl(280, 70%, 60%)';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, startY, nodeWidth, nodeHeight);

                // Draw value
                ctx.fillStyle = 'white';
                ctx.font = 'bold 18px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(dsValues[i], x + nodeWidth / 2, startY + nodeHeight / 2);

                // Draw arrow to next node
                if (i < dsValues.length - 1) {
                    ctx.strokeStyle = 'hsl(180, 70%, 60%)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(x + nodeWidth, startY + nodeHeight / 2);
                    ctx.lineTo(x + nodeWidth + arrowLength, startY + nodeHeight / 2);
                    ctx.stroke();

                    // Arrow head
                    ctx.beginPath();
                    ctx.moveTo(x + nodeWidth + arrowLength, startY + nodeHeight / 2);
                    ctx.lineTo(x + nodeWidth + arrowLength - 10, startY + nodeHeight / 2 - 5);
                    ctx.lineTo(x + nodeWidth + arrowLength - 10, startY + nodeHeight / 2 + 5);
                    ctx.closePath();
                    ctx.fillStyle = 'hsl(180, 70%, 60%)';
                    ctx.fill();
                }
            }

            // Draw HEAD label
            if (dsValues.length > 0) {
                ctx.fillStyle = 'hsl(180, 70%, 60%)';
                ctx.font = 'bold 14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('HEAD', startX + nodeWidth / 2, startY - 20);
            }
        }

        // UI updates
        function updateUI() {
            document.getElementById('operations').textContent = stats.operations;
            document.getElementById('comparisons').textContent = stats.comparisons;
            document.getElementById('accesses').textContent = stats.accesses;
            document.getElementById('timeElapsed').textContent = Math.floor(stats.elapsedTime);

            playBtn.disabled = isPlaying && !isPaused;
            pauseBtn.disabled = !isPlaying || isPaused;

            if (isPlaying && !isPaused) {
                modeIndicator.textContent = 'Playing';
                modeIndicator.style.background = 'hsl(120, 60%, 50%)';
            } else if (isPaused) {
                modeIndicator.textContent = 'Paused';
                modeIndicator.style.background = 'hsl(50, 100%, 60%)';
            } else {
                modeIndicator.textContent = 'Stopped';
                modeIndicator.style.background = 'hsl(0, 80%, 60%)';
            }
        }

        // Settings persistence
        function saveSettings() {
            localStorage.setItem('algoViz_speed', speed);
            localStorage.setItem('algoViz_arraySize', arraySize);
            localStorage.setItem('algoViz_category', currentCategory);
            localStorage.setItem('algoViz_algorithm', currentAlgorithm);
        }

        function loadSettings() {
            speed = parseInt(localStorage.getItem('algoViz_speed')) || 50;
            arraySize = parseInt(localStorage.getItem('algoViz_arraySize')) || 50;
            const savedCategory = localStorage.getItem('algoViz_category');
            const savedAlgo = localStorage.getItem('algoViz_algorithm');

            speedSlider.value = speed;
            document.getElementById('speedValue').textContent = speed;
            sizeSlider.value = arraySize;
            document.getElementById('sizeValue').textContent = arraySize;

            if (savedCategory) {
                switchCategory(savedCategory);
            }
            if (savedAlgo) {
                selectAlgorithm(savedAlgo);
            }
        }

        // Start application
        init();
        initializeGrid();
    </script>
</body>
</html>
