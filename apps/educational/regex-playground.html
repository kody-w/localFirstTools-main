<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="rappterzoo:author" content="RappterZoo">
<meta name="rappterzoo:author-type" content="agent">
<meta name="rappterzoo:category" content="educational_tools">
<meta name="rappterzoo:tags" content="regex,patterns,learning,interactive,tool">
<meta name="rappterzoo:type" content="interactive">
<meta name="rappterzoo:complexity" content="intermediate">
<meta name="rappterzoo:created" content="2025-01-01">
<meta name="rappterzoo:generation" content="2">
<title>Regex Playground</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{background:#0e1113;color:#e0e0e0;font-family:'Segoe UI',system-ui,sans-serif;min-height:100vh;display:flex;flex-direction:column}
header{background:#161a1e;padding:16px 24px;border-bottom:1px solid #2a2f35;display:flex;align-items:center;gap:16px;flex-wrap:wrap}
header h1{font-size:1.4rem;color:#00d2d3;font-weight:700}
.tabs{display:flex;gap:8px;margin-left:auto}
.tab{background:#1e2329;border:1px solid #2a2f35;color:#aaa;padding:6px 16px;border-radius:6px;cursor:pointer;font-size:.85rem;transition:all .2s}
.tab:hover{border-color:#00d2d3;color:#ccc}
.tab.active{background:#00d2d3;color:#0e1113;border-color:#00d2d3;font-weight:600}
main{flex:1;display:flex;flex-direction:column;padding:16px;gap:12px;max-width:1200px;width:100%;margin:0 auto;overflow-y:auto}
.input-row{display:flex;gap:12px;flex-wrap:wrap}
.input-group{flex:1;min-width:200px}
label{display:block;font-size:.8rem;color:#888;margin-bottom:4px;text-transform:uppercase;letter-spacing:.5px}
input[type=text],textarea{width:100%;background:#161a1e;border:1px solid #2a2f35;color:#e0e0e0;padding:10px 12px;border-radius:6px;font-family:'Courier New',monospace;font-size:.95rem;transition:border-color .2s}
input:focus,textarea:focus{outline:none;border-color:#00d2d3;box-shadow:0 0 0 3px rgba(0,210,211,.1)}
textarea{resize:vertical;min-height:120px;line-height:1.6}
.flags{display:flex;gap:8px;align-items:flex-end}
.flag-btn{background:#1e2329;border:1px solid #2a2f35;color:#888;padding:4px 10px;border-radius:4px;cursor:pointer;font-size:.85rem;font-family:monospace;transition:all .2s;user-select:none}
.flag-btn:hover{border-color:#00d2d3;color:#ccc}
.flag-btn.on{background:#00d2d3;color:#0e1113;border-color:#00d2d3;font-weight:700}
.result-area{flex:1;display:flex;gap:12px;min-height:0}
.panel{background:#161a1e;border:1px solid #2a2f35;border-radius:8px;padding:16px;flex:1;overflow:auto}
.panel h3{font-size:.85rem;color:#00d2d3;margin-bottom:8px;text-transform:uppercase;letter-spacing:.5px}
.match-text{font-family:'Courier New',monospace;font-size:.95rem;line-height:1.8;white-space:pre-wrap;word-break:break-all}
.match-text .highlight{background:#00d2d344;border:1px solid #00d2d3;border-radius:2px;padding:0 1px}
.match-text .group1{background:#ff634744;border-color:#ff6347}
.match-text .group2{background:#4169e144;border-color:#4169e1}
.match-text .group3{background:#ffa50044;border-color:#ffa500}
.match-info{font-size:.85rem;color:#aaa;margin-bottom:8px;display:flex;gap:16px;align-items:center}
.match-info strong{color:#00d2d3}
.explain-item{margin-bottom:8px;font-size:.85rem;line-height:1.5}
.explain-token{color:#00d2d3;font-family:monospace;font-weight:bold}
.cheat-sheet{display:grid;grid-template-columns:repeat(auto-fill,minmax(280px,1fr));gap:8px}
.cheat-section{margin-bottom:16px}
.cheat-section h4{color:#00d2d3;font-size:.8rem;text-transform:uppercase;margin-bottom:8px;letter-spacing:1px}
.cheat-item{background:#1e2329;padding:8px 12px;border-radius:4px;font-size:.85rem;display:flex;gap:12px;transition:border-color .2s;border:1px solid transparent;cursor:pointer}
.cheat-item:hover{border-color:#00d2d355}
.cheat-item code{color:#00d2d3;min-width:80px;font-weight:bold;font-family:'Courier New',monospace}
.cheat-item span{color:#aaa;flex:1}
.challenge-box{background:#1e2329;border-radius:8px;padding:20px;margin-bottom:12px;border:1px solid #2a2f35}
.challenge-box h4{color:#ffa500;margin-bottom:8px;font-size:1rem}
.challenge-box p{font-size:.85rem;color:#ccc;margin-bottom:8px;line-height:1.5}
.challenge-box .target{font-family:monospace;background:#0e1113;padding:12px;border-radius:6px;margin:8px 0;font-size:.9rem;line-height:1.6;border:1px solid #2a2f35}
.challenge-box .expected{font-size:.8rem;color:#666;margin-top:4px}
.challenge-box .expected code{color:#888;background:#1a1d21;padding:1px 4px;border-radius:2px}
.status{font-size:.85rem;padding:6px 12px;border-radius:4px;display:inline-block;margin-top:8px}
.status.pass{background:#2d6a4f;color:#95d5b2;font-weight:600}
.status.fail{background:#6a2d2d;color:#d59595}
.score-bar{display:flex;align-items:center;gap:12px;font-size:.9rem;color:#aaa;margin-bottom:12px;flex-wrap:wrap}
.score-bar span{color:#00d2d3;font-weight:bold;font-size:1.1rem}
.progress-dots{display:flex;gap:6px;margin-left:auto}
.progress-dot{width:12px;height:12px;border-radius:50%;background:#2a2f35;border:2px solid #3a3f45;transition:all .3s}
.progress-dot.completed{background:#00d2d3;border-color:#00d2d3}
.progress-dot.current{border-color:#ffa500;box-shadow:0 0 6px rgba(255,165,0,.4)}
.challenge-input-row{margin-top:12px;display:flex;gap:8px;align-items:center;flex-wrap:wrap}
.challenge-input-row input{flex:1;min-width:200px}
.btn{background:#2a2f35;border:1px solid #3a3f45;color:#aaa;padding:8px 16px;border-radius:6px;cursor:pointer;font-size:.85rem;transition:all .2s}
.btn:hover{background:#3a3f45;color:#e0e0e0}
.btn.primary{background:#00d2d3;color:#0e1113;border-color:#00d2d3;font-weight:600}
.btn.primary:hover{background:#00babb}
.challenge-nav{display:flex;gap:8px;margin-top:12px}
.difficulty{display:inline-block;font-size:.7rem;padding:2px 8px;border-radius:10px;font-weight:600;text-transform:uppercase;letter-spacing:.5px}
.difficulty.easy{background:#2d6a4f44;color:#95d5b2}
.difficulty.medium{background:#6a5a2d44;color:#d5c595}
.difficulty.hard{background:#6a2d2d44;color:#d59595}
.error-msg{color:#ff6347;font-size:.85rem;padding:8px 12px;background:#2a1515;border-radius:4px;margin-top:4px;border:1px solid #3a2020}
.match-detail{background:#0e1113;padding:6px 10px;border-radius:4px;margin-top:4px;font-size:.8rem;font-family:monospace;color:#888}
.match-detail .idx{color:#666}
.match-detail .val{color:#00d2d3}
.match-detail .grp{color:#ff6347}
.regex-builder{margin-top:12px}
.regex-builder h4{color:#00d2d3;font-size:.85rem;margin-bottom:8px}
.builder-tokens{display:flex;gap:4px;flex-wrap:wrap;margin-bottom:8px}
.builder-tok{background:#1e2329;border:1px solid #2a2f35;padding:4px 8px;border-radius:4px;font-family:monospace;font-size:.8rem;color:#00d2d3;cursor:pointer;transition:all .2s}
.builder-tok:hover{background:#2a2f35;border-color:#00d2d3}
.perf-result{margin-top:8px;font-size:.8rem;color:#888}
.perf-result .fast{color:#95d5b2}
.perf-result .slow{color:#d59595}
@media(max-width:768px){
  .result-area{flex-direction:column}
  .input-row{flex-direction:column}
  .flags{flex-wrap:wrap}
  .cheat-sheet{grid-template-columns:1fr}
}
</style>
</head>
<body>
<header>
<h1>Regex Playground</h1>
<div class="tabs">
<div class="tab active" data-tab="playground">Playground</div>
<div class="tab" data-tab="cheatsheet">Reference</div>
<div class="tab" data-tab="challenges">Challenges</div>
<div class="tab" data-tab="builder">Builder</div>
</div>
</header>
<main id="app"></main>
<script>
const state = {
  tab: localStorage.getItem('regex_tab') || 'playground',
  pattern: localStorage.getItem('regex_pattern') || '\\b\\w+ing\\b',
  testText: localStorage.getItem('regex_text') || 'The running fox was jumping over the sleeping dog while singing a cheerful song.\nNothing is more exciting than discovering something amazing.\nShe was reading a thrilling book about painting and writing.',
  flags: JSON.parse(localStorage.getItem('regex_flags') || '{"g":true,"i":false,"m":false,"s":false}'),
  challengeIdx: parseInt(localStorage.getItem('regex_challenge') || '0'),
  challengeInput: '',
  completed: JSON.parse(localStorage.getItem('regex_completed') || '[]'),
  builderPattern: localStorage.getItem('regex_builder') || '',
  perfIterations: 10000
};

const challenges = [
  {title:'Match Email Addresses',desc:'Write a regex that matches email addresses in the text.',
   test:'Contact us at hello@example.com or support@test.org for help. Invalid: @no.com or user@.',
   shouldMatch:['hello@example.com','support@test.org'],hint:'[\\w.+-]+@[\\w-]+\\.[\\w.]+',difficulty:'easy'},
  {title:'Match Dates (YYYY-MM-DD)',desc:'Match dates in YYYY-MM-DD format.',
   test:'Events on 2024-01-15 and 2023-12-25 were great. Not 24-01-15 or 2024-1-5.',
   shouldMatch:['2024-01-15','2023-12-25'],hint:'\\d{4}-\\d{2}-\\d{2}',difficulty:'easy'},
  {title:'Match Hex Colors',desc:'Match valid CSS hex color codes (#RGB or #RRGGBB, letters a-f only).',
   test:'Colors: #fff, #00d2d3, #123, #abcdef. Invalid: #gg, #12, #1234567.',
   shouldMatch:['#fff','#00d2d3','#123','#abcdef'],hint:'#[0-9a-fA-F]{3}(?:[0-9a-fA-F]{3})?\\b',difficulty:'easy'},
  {title:'Match Phone Numbers',desc:'Match US phone numbers in 555-123-4567 format.',
   test:'Call 555-123-4567 or 800-555-0199 today. Not 55-12-456.',
   shouldMatch:['555-123-4567','800-555-0199'],hint:'\\d{3}-\\d{3}-\\d{4}',difficulty:'easy'},
  {title:'Capture First and Last Name',desc:'Match "Last, First" patterns and capture both names.',
   test:'Roster: Smith, John and Doe, Jane are registered. Also Brown, Alice.',
   shouldMatch:['Smith, John','Doe, Jane','Brown, Alice'],hint:'(\\w+), (\\w+)',difficulty:'medium'},
  {title:'Match URLs',desc:'Match http or https URLs.',
   test:'Visit https://example.com or http://test.org/path?q=1 now. Not ftp://old.net.',
   shouldMatch:['https://example.com','http://test.org/path?q=1'],hint:'https?://\\S+',difficulty:'medium'},
  {title:'Word Boundaries',desc:'Match the word "the" only as a whole word (case insensitive). Use the i flag.',
   test:'The cat sat on the mat, not their mat, bathe in the sun, or breathe.',
   shouldMatch:['The','the','the'],hint:'\\bthe\\b',difficulty:'medium'},
  {title:'Positive Lookahead',desc:'Match a number followed by "px" but do NOT include "px" in the match.',
   test:'Width: 100px, height: 50px, weight: 30kg, margin: 20em.',
   shouldMatch:['100','50'],hint:'\\d+(?=px)',difficulty:'medium'},
  {title:'Negative Lookahead',desc:'Match words that do NOT end with "ing".',
   test:'The cat was running and the dog sat watching.',
   shouldMatch:['The','cat','was','and','the','dog','sat'],hint:'\\b\\w+\\b(?<!ing)',difficulty:'hard'},
  {title:'Match IP Addresses',desc:'Match valid IPv4 addresses (four groups of 1-3 digits separated by dots).',
   test:'Server at 192.168.1.1 or 10.0.0.255. Not 999.999.999.999 or 1.2.3.',
   shouldMatch:['192.168.1.1','10.0.0.255'],hint:'\\b(?:\\d{1,3}\\.){3}\\d{1,3}\\b',difficulty:'medium'},
  {title:'Match HTML Tags',desc:'Match opening HTML tags (like <div>, <span class="x">), not closing tags.',
   test:'<div class="main"><p>Hello</p><br/><span>world</span></div>',
   shouldMatch:['<div class="main">','<p>','<br/>','<span>'],hint:'<[a-zA-Z][^>]*\\/?>',difficulty:'hard'},
  {title:'Match Repeated Words',desc:'Find words that appear twice in a row (like "the the").',
   test:'She said the the cat was was happy. It is is true.',
   shouldMatch:['the the','was was','is is'],hint:'\\b(\\w+)\\s+\\1\\b',difficulty:'hard'},
  {title:'Password Validator',desc:'Match strings with at least 8 chars, one uppercase, one lowercase, one digit.',
   test:'Good: Pass1word, Str0ngKey. Bad: weak, SHORT1, nouppercase1, NOLOWER1.',
   shouldMatch:['Pass1word','Str0ngKey'],hint:'(?=.*[A-Z])(?=.*[a-z])(?=.*\\d).{8,}',difficulty:'hard'},
  {title:'Match Balanced Parentheses Content',desc:'Match content inside the outermost parentheses including the parens.',
   test:'Calculate (3 + 5) and (10 * (2 + 1)) now.',
   shouldMatch:['(3 + 5)','(10 * (2 + 1))'],hint:'\\([^()]*(?:\\([^()]*\\)[^()]*)*\\)',difficulty:'hard'},
  {title:'CSV Value Extraction',desc:'Match individual values in a comma-separated line (handle quoted values).',
   test:'John,"Doe, Jr.",42,"New York"',
   shouldMatch:['John','"Doe, Jr."','42','"New York"'],hint:'"[^"]*"|[^,]+',difficulty:'hard'},
  {title:'Match Markdown Bold',desc:'Match text wrapped in double asterisks (**bold text**).',
   test:'This is **bold** and this is **also bold** but not *italic* or ***triple***.',
   shouldMatch:['**bold**','**also bold**'],hint:'\\*\\*[^*]+\\*\\*',difficulty:'medium'},
];

const cheatSections = [
  {title:'Character Classes', items:[
    ['.','Any character except newline'],['\\d','Digit [0-9]'],['\\D','Non-digit'],
    ['\\w','Word char [a-zA-Z0-9_]'],['\\W','Non-word char'],['\\s','Whitespace'],
    ['\\S','Non-whitespace'],['\\b','Word boundary'],['\\B','Non-word boundary'],
    ['[abc]','Character set (a, b, or c)'],['[^abc]','Negated set (not a, b, or c)'],
    ['[a-z]','Range (a through z)'],['\\t','Tab'],['\\n','Newline']
  ]},
  {title:'Quantifiers', items:[
    ['*','0 or more (greedy)'],['+','1 or more (greedy)'],['?','0 or 1 (optional)'],
    ['{n}','Exactly n times'],['{n,}','n or more times'],['{n,m}','Between n and m'],
    ['*?','0 or more (lazy)'],['??','0 or 1 (lazy)'],['+?','1 or more (lazy)']
  ]},
  {title:'Anchors & Assertions', items:[
    ['^','Start of string/line'],['$','End of string/line'],
    ['(?=...)','Positive lookahead'],['(?!...)','Negative lookahead'],
    ['(?<=...)','Positive lookbehind'],['(?<!...)','Negative lookbehind']
  ]},
  {title:'Groups & References', items:[
    ['(...)','Capture group'],['(?:...)','Non-capture group'],['(?<name>...)','Named group'],
    ['\\1','Back-reference to group 1'],['a|b','Alternation (a or b)'],
    ['(?i)','Case-insensitive flag (inline)']
  ]}
];

const explanations = {
  '.':'matches any single character','^':'matches start of string','$':'matches end of string',
  '*':'matches 0 or more of preceding','+':'matches 1 or more of preceding','?':'makes preceding optional',
  '\\d':'matches any digit','\\D':'matches any non-digit','\\w':'matches word character',
  '\\W':'matches non-word character','\\s':'matches whitespace','\\S':'matches non-whitespace',
  '\\b':'matches word boundary','\\B':'matches non-word boundary',
  '|':'alternation (or)','[':'starts character class',']':'ends character class',
  '(':'starts capture group',')':'ends capture group','{':'starts quantifier range','}':'ends quantifier range',
  '\\t':'matches tab character','\\n':'matches newline'
};

function save(){
  localStorage.setItem('regex_pattern',state.pattern);
  localStorage.setItem('regex_text',state.testText);
  localStorage.setItem('regex_flags',JSON.stringify(state.flags));
  localStorage.setItem('regex_challenge',state.challengeIdx);
  localStorage.setItem('regex_completed',JSON.stringify(state.completed));
  localStorage.setItem('regex_builder',state.builderPattern);
  localStorage.setItem('regex_tab',state.tab);
}

function getRegex(pat,fl){
  const flagStr=Object.entries(fl).filter(([,v])=>v).map(([k])=>k).join('');
  return new RegExp(pat,flagStr);
}

function highlightMatches(text,regex){
  if(!regex)return esc(text);
  let result='',last=0;
  const r=new RegExp(regex.source,regex.flags.includes('g')?regex.flags:regex.flags+'g');
  let m,safety=0;
  while((m=r.exec(text))!==null&&safety++<1000){
    if(m.index>=last){
      result+=esc(text.slice(last,m.index));
      const groups=m.slice(1).filter(g=>g!==undefined);
      if(groups.length>0){
        let inner=m[0],innerHtml='',lastInner=0;
        groups.forEach((g,gi)=>{
          const gIdx=m[0].indexOf(g,lastInner);
          if(gIdx>=0){
            innerHtml+=esc(m[0].slice(lastInner,gIdx));
            innerHtml+=`<span class="highlight group${(gi%3)+1}">${esc(g)}</span>`;
            lastInner=gIdx+g.length;
          }
        });
        innerHtml+=esc(m[0].slice(lastInner));
        result+=`<span class="highlight">${innerHtml}</span>`;
      }else{
        result+=`<span class="highlight">${esc(m[0])}</span>`;
      }
      last=m.index+m[0].length;
    }
    if(m[0].length===0)r.lastIndex++;
  }
  result+=esc(text.slice(last));
  return result;
}

function esc(s){return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;')}

function explainPattern(pat){
  const tokens=[];let i=0;
  while(i<pat.length){
    if(pat[i]==='\\' && i+1<pat.length){
      const seq=pat.slice(i,i+2);
      tokens.push({token:seq,desc:explanations[seq]||`escaped character: ${pat[i+1]}`});i+=2;
    } else if(pat[i]==='{'){
      const end=pat.indexOf('}',i);
      if(end>i){const t=pat.slice(i,end+1);tokens.push({token:t,desc:`quantifier: repeat ${t}`});i=end+1}
      else{tokens.push({token:pat[i],desc:explanations[pat[i]]||pat[i]});i++}
    } else if(pat[i]==='(' && pat[i+1]==='?'){
      let desc='group',len=3;
      if(pat[i+2]==='=')desc='positive lookahead';
      else if(pat[i+2]==='!')desc='negative lookahead';
      else if(pat[i+2]==='<'&&pat[i+3]==='='){desc='positive lookbehind';len=4}
      else if(pat[i+2]==='<'&&pat[i+3]==='!'){desc='negative lookbehind';len=4}
      else if(pat[i+2]===':')desc='non-capturing group';
      else if(pat[i+2]==='<'){
        const nameEnd=pat.indexOf('>',i+3);
        if(nameEnd>0){desc='named group: '+pat.slice(i+3,nameEnd);len=nameEnd-i+1}
      }
      tokens.push({token:pat.slice(i,i+len),desc});i+=len;
    } else if(pat[i]==='['){
      const end=pat.indexOf(']',i);
      if(end>i){
        const cls=pat.slice(i,end+1);
        const neg=pat[i+1]==='^'?'negated ':'';
        tokens.push({token:cls,desc:`${neg}character class: matches one of the listed characters`});
        i=end+1;
      }else{tokens.push({token:pat[i],desc:explanations[pat[i]]||`literal: "${pat[i]}"`});i++}
    } else {
      tokens.push({token:pat[i],desc:explanations[pat[i]]||`literal character: "${pat[i]}"`});i++;
    }
  }
  return tokens;
}

function perfTest(pat,flags,text,iters){
  try{
    const r=getRegex(pat,flags);
    const start=performance.now();
    for(let i=0;i<iters;i++){
      const rr=new RegExp(r.source,r.flags);
      rr.exec(text);
    }
    const elapsed=performance.now()-start;
    return {time:elapsed,perMatch:elapsed/iters};
  }catch(e){return null}
}

function renderPlayground(){
  let err='',regex=null,matchCount=0,matchList=[];
  try{
    regex=getRegex(state.pattern,state.flags);
    const r=new RegExp(regex.source,regex.flags.includes('g')?regex.flags:regex.flags+'g');
    let m;while((m=r.exec(state.testText))!==null&&matchCount<500){
      matchList.push({val:m[0],idx:m.index,groups:m.slice(1)});matchCount++;
      if(m[0].length===0)r.lastIndex++;
    }
  }catch(e){err=e.message}
  const tokens=explainPattern(state.pattern);
  const perf=(!err&&regex)?perfTest(state.pattern,state.flags,state.testText,state.perfIterations):null;
  return `
    <div class="input-row">
      <div class="input-group" style="flex:2">
        <label>Regular Expression</label>
        <input type="text" id="patInput" value="${esc(state.pattern)}" placeholder="Enter regex pattern..." spellcheck="false" autocomplete="off">
        ${err?`<div class="error-msg">${esc(err)}</div>`:''}
      </div>
      <div class="flags" style="padding-bottom:4px">
        <div style="margin-bottom:4px"><label style="margin:0">Flags</label></div>
        ${['g','i','m','s'].map(f=>`<div class="flag-btn ${state.flags[f]?'on':''}" data-flag="${f}" title="${{g:'global',i:'case-insensitive',m:'multiline',s:'dotAll'}[f]}">${f}</div>`).join('')}
      </div>
    </div>
    <div class="input-group">
      <label>Test String (${state.testText.length} chars, ${state.testText.split('\\n').length} lines)</label>
      <textarea id="testInput" rows="5" spellcheck="false">${esc(state.testText)}</textarea>
    </div>
    <div class="match-info">
      <span><strong>${matchCount}</strong> match${matchCount!==1?'es':''}</span>
      ${perf?`<span class="perf-result">${perf.time<50?'<span class="fast">':'<span class="slow">'}${perf.perMatch.toFixed(4)}ms/match (${state.perfIterations.toLocaleString()} iterations in ${perf.time.toFixed(1)}ms)</span></span>`:''}
    </div>
    <div class="result-area">
      <div class="panel" style="flex:2">
        <h3>Highlighted Matches</h3>
        <div class="match-text">${regex&&!err?highlightMatches(state.testText,regex):esc(state.testText)}</div>
        ${matchList.length?`<h3 style="margin-top:16px">Match Details</h3><div style="display:flex;flex-direction:column;gap:4px">${matchList.map((m,i)=>`<div class="match-detail"><span class="idx">#${i+1}</span> <span class="val">"${esc(m.val)}"</span> at index ${m.idx}${m.groups.length?` | groups: ${m.groups.map((g,j)=>`<span class="grp">(${j+1})="${esc(g||'')}"</span>`).join(' ')}`:''}</div>`).join('')}</div>`:''}
      </div>
      <div class="panel">
        <h3>Pattern Explanation</h3>
        ${tokens.map(t=>`<div class="explain-item"><span class="explain-token">${esc(t.token)}</span> &mdash; ${esc(t.desc)}</div>`).join('')}
        <div style="margin-top:16px;padding-top:12px;border-top:1px solid #2a2f35">
          <h3>Quick Insert</h3>
          <div class="builder-tokens">
            ${['\\d+','\\w+','\\s','[a-z]','[A-Z]','\\b','(?=)','(?!)','()','{n,m}','.*?','^','$'].map(t=>
              `<span class="builder-tok" data-insert="${esc(t)}">${esc(t)}</span>`
            ).join('')}
          </div>
        </div>
      </div>
    </div>`;
}

function renderCheatsheet(){
  return `<div class="panel" style="flex:none">
    <h3>Regex Quick Reference</h3>
    ${cheatSections.map(sec=>`
      <div class="cheat-section">
        <h4>${sec.title}</h4>
        <div class="cheat-sheet">${sec.items.map(([c,d])=>`<div class="cheat-item" data-pattern="${esc(c)}"><code>${esc(c)}</code><span>${esc(d)}</span></div>`).join('')}</div>
      </div>
    `).join('')}
    <div class="cheat-section">
      <h4>Common Patterns</h4>
      <div class="cheat-sheet">
        ${[
          ['Email','[\\w.+-]+@[\\w-]+\\.[\\w.]+'],
          ['URL','https?://\\S+'],
          ['IPv4','\\b(?:\\d{1,3}\\.){3}\\d{1,3}\\b'],
          ['Hex Color','#[0-9a-fA-F]{3,6}\\b'],
          ['Date YYYY-MM-DD','\\d{4}-\\d{2}-\\d{2}'],
          ['Phone (US)','\\d{3}-\\d{3}-\\d{4}'],
          ['Integer','-?\\d+'],
          ['Float','-?\\d+\\.\\d+'],
          ['HTML Tag','<[^>]+>'],
          ['Quoted String','"[^"]*"']
        ].map(([name,pat])=>`<div class="cheat-item" data-pattern="${esc(pat)}" data-tryit="1"><code>${name}</code><span style="font-family:monospace;font-size:.75rem">${esc(pat)}</span></div>`).join('')}
      </div>
    </div>
  </div>`;
}

function renderChallenges(){
  const ch=challenges[state.challengeIdx];
  let status='',pass=false;
  if(state.challengeInput){
    try{
      const r=new RegExp(state.challengeInput,'gi');
      const matches=[];let m;
      while((m=r.exec(ch.test))!==null){matches.push(m[0]);if(m[0].length===0)r.lastIndex++}
      pass=ch.shouldMatch.every(s=>matches.some(m2=>m2.toLowerCase()===s.toLowerCase()))&&matches.length===ch.shouldMatch.length;
      status=pass?'<span class="status pass">Correct!</span>':'<span class="status fail">Not quite &mdash; keep trying</span>';
    }catch(e){status=`<span class="status fail">Invalid regex: ${esc(e.message)}</span>`}
  }
  return `
    <div class="score-bar">
      <span>${state.completed.length}/${challenges.length}</span> completed
      <div class="progress-dots">
        ${challenges.map((_,i)=>`<div class="progress-dot${state.completed.includes(i)?' completed':''}${i===state.challengeIdx?' current':''}"></div>`).join('')}
      </div>
    </div>
    <div class="challenge-box">
      <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px">
        <span style="color:#888;font-size:.85rem">${state.challengeIdx+1}/${challenges.length}</span>
        <span class="difficulty ${ch.difficulty}">${ch.difficulty}</span>
      </div>
      <h4>${ch.title}</h4>
      <p>${ch.desc}</p>
      <div class="target">${esc(ch.test)}</div>
      <div class="expected">Expected matches: ${ch.shouldMatch.map(s=>`<code>${esc(s)}</code>`).join(', ')}</div>
      <div class="challenge-input-row">
        <input type="text" id="challengeInput" value="${esc(state.challengeInput)}" placeholder="Type your regex..." spellcheck="false" autocomplete="off">
        <button class="btn" onclick="showHint()">Hint</button>
        <button class="btn" onclick="tryInPlayground()">Try in Playground</button>
      </div>
      <div style="margin-top:8px">${status}</div>
      ${state.challengeInput&&!pass?`<div style="margin-top:8px;font-size:.8rem;color:#666">Your matches: ${(()=>{try{const r=new RegExp(state.challengeInput,'gi');const ms=[];let m2;while((m2=r.exec(ch.test))!==null){ms.push(m2[0]);if(m2[0].length===0)r.lastIndex++}return ms.length?ms.map(s=>'<code style="color:#ff6347;background:#2a1515;padding:1px 4px;border-radius:2px">'+esc(s)+'</code>').join(', '):'(none)'}catch(e){return 'error'}})()}</div>`:''}
    </div>
    <div class="challenge-nav">
      <button class="btn" onclick="prevChallenge()" ${state.challengeIdx===0?'disabled':''}>&larr; Previous</button>
      <button class="btn" onclick="nextChallenge()" ${state.challengeIdx===challenges.length-1?'disabled':''}>Next &rarr;</button>
      <button class="btn" onclick="resetProgress()" style="margin-left:auto;color:#ff6347;border-color:#6a2d2d">Reset Progress</button>
    </div>`;
}

function renderBuilder(){
  const tokens=['\\d','\\D','\\w','\\W','\\s','\\S','.','^','$',
    '\\b','[a-z]','[A-Z]','[0-9]','[^]',
    '+','*','?','{n}','{n,m}',
    '(',')',
    '(?:)','(?=)','(?!)','(?<=)','(?<!)','|',
    '\\1','\\2'];
  let err='',matchCount=0;
  if(state.builderPattern){
    try{
      const r=new RegExp(state.builderPattern,'g');
      let m;while((m=r.exec(state.testText))!==null){matchCount++;if(m[0].length===0)r.lastIndex++;if(matchCount>500)break}
    }catch(e){err=e.message}
  }
  return `
    <div class="panel">
      <h3>Regex Builder</h3>
      <p style="font-size:.85rem;color:#888;margin-bottom:12px">Click tokens to build a pattern visually. The pattern is tested against your playground test string.</p>
      <div class="builder-tokens" style="margin-bottom:12px">
        ${tokens.map(t=>`<span class="builder-tok" data-build="${esc(t)}">${esc(t)}</span>`).join('')}
      </div>
      <div class="input-group">
        <label>Built Pattern</label>
        <input type="text" id="builderInput" value="${esc(state.builderPattern)}" placeholder="Click tokens above or type..." spellcheck="false">
        ${err?`<div class="error-msg">${esc(err)}</div>`:''}
      </div>
      <div style="display:flex;gap:8px;margin-top:8px">
        <button class="btn" onclick="clearBuilder()">Clear</button>
        <button class="btn" onclick="undoBuilder()">Undo</button>
        <button class="btn primary" onclick="sendToPlayground()">Use in Playground</button>
      </div>
      ${!err&&state.builderPattern?`<div style="margin-top:12px;font-size:.85rem;color:#aaa">${matchCount} match${matchCount!==1?'es':''} in test string</div>
        <div class="match-text" style="margin-top:8px;max-height:200px;overflow:auto">${(()=>{try{return highlightMatches(state.testText,new RegExp(state.builderPattern,'g'))}catch(e){return esc(state.testText)}})()}</div>`:''}
    </div>`;
}

function render(){
  const app=document.getElementById('app');
  if(state.tab==='playground')app.innerHTML=renderPlayground();
  else if(state.tab==='cheatsheet')app.innerHTML=renderCheatsheet();
  else if(state.tab==='challenges')app.innerHTML=renderChallenges();
  else if(state.tab==='builder')app.innerHTML=renderBuilder();

  document.querySelectorAll('.tab').forEach(t=>{
    t.classList.toggle('active',t.dataset.tab===state.tab);
    t.onclick=()=>{state.tab=t.dataset.tab;save();render()}
  });

  const pi=document.getElementById('patInput');
  if(pi){
    pi.oninput=()=>{state.pattern=pi.value;save();render();restoreCursor(pi)}
  }
  const ti=document.getElementById('testInput');
  if(ti){
    ti.oninput=()=>{state.testText=ti.value;save();render()}
  }
  const ci=document.getElementById('challengeInput');
  if(ci){
    ci.oninput=()=>{
      state.challengeInput=ci.value;
      const ch=challenges[state.challengeIdx];
      try{
        const r=new RegExp(ci.value,'gi');const ms=[];let m;
        while((m=r.exec(ch.test))!==null){ms.push(m[0]);if(m[0].length===0)r.lastIndex++}
        if(ch.shouldMatch.every(s=>ms.some(m2=>m2.toLowerCase()===s.toLowerCase()))&&ms.length===ch.shouldMatch.length){
          if(!state.completed.includes(state.challengeIdx)){state.completed.push(state.challengeIdx);save()}
        }
      }catch(e){}
      render();restoreCursor(ci);
    }
  }
  const bi=document.getElementById('builderInput');
  if(bi){
    bi.oninput=()=>{state.builderPattern=bi.value;save();render();restoreCursor(bi)}
  }
  document.querySelectorAll('.flag-btn').forEach(b=>{b.onclick=()=>{state.flags[b.dataset.flag]=!state.flags[b.dataset.flag];save();render()}});
  document.querySelectorAll('.builder-tok[data-insert]').forEach(b=>{
    b.onclick=()=>{
      const pi2=document.getElementById('patInput');
      if(pi2){
        const pos=pi2.selectionStart||pi2.value.length;
        state.pattern=state.pattern.slice(0,pos)+b.dataset.insert+state.pattern.slice(pos);
        save();render();
        const newPi=document.getElementById('patInput');
        if(newPi){newPi.focus();newPi.setSelectionRange(pos+b.dataset.insert.length,pos+b.dataset.insert.length)}
      }
    }
  });
  document.querySelectorAll('.builder-tok[data-build]').forEach(b=>{
    b.onclick=()=>{state.builderPattern+=b.dataset.build;save();render()}
  });
  document.querySelectorAll('.cheat-item[data-tryit]').forEach(item=>{
    item.onclick=()=>{state.pattern=item.dataset.pattern;state.tab='playground';save();render()}
  });
}

function restoreCursor(el){
  const id=el.id;
  const pos=el.selectionStart;
  requestAnimationFrame(()=>{
    const newEl=document.getElementById(id);
    if(newEl){newEl.focus();newEl.setSelectionRange(pos,pos)}
  });
}

window.showHint=function(){
  const ch=challenges[state.challengeIdx];
  state.challengeInput=ch.hint;save();render();
};
window.tryInPlayground=function(){
  if(state.challengeInput){
    state.pattern=state.challengeInput;
    const ch=challenges[state.challengeIdx];
    state.testText=ch.test;
    state.tab='playground';save();render();
  }
};
window.prevChallenge=function(){
  state.challengeIdx=Math.max(0,state.challengeIdx-1);
  state.challengeInput='';save();render();
};
window.nextChallenge=function(){
  state.challengeIdx=Math.min(challenges.length-1,state.challengeIdx+1);
  state.challengeInput='';save();render();
};
window.resetProgress=function(){
  if(confirm('Reset all challenge progress?')){
    state.completed=[];state.challengeIdx=0;state.challengeInput='';save();render();
  }
};
window.clearBuilder=function(){state.builderPattern='';save();render()};
window.undoBuilder=function(){
  if(state.builderPattern.length>0){
    if(state.builderPattern.endsWith('\\d')||state.builderPattern.endsWith('\\w')||state.builderPattern.endsWith('\\s')||
       state.builderPattern.endsWith('\\S')||state.builderPattern.endsWith('\\D')||state.builderPattern.endsWith('\\W')||
       state.builderPattern.endsWith('\\b')||state.builderPattern.endsWith('\\B')||
       state.builderPattern.endsWith('\\1')||state.builderPattern.endsWith('\\2')){
      state.builderPattern=state.builderPattern.slice(0,-2);
    }else{
      state.builderPattern=state.builderPattern.slice(0,-1);
    }
    save();render();
  }
};
window.sendToPlayground=function(){
  if(state.builderPattern){state.pattern=state.builderPattern;state.tab='playground';save();render()}
};

document.addEventListener('keydown',e=>{
  if(e.ctrlKey||e.metaKey) return;
  if(e.target.tagName==='INPUT'||e.target.tagName==='TEXTAREA') return;
  if(e.key==='1'){state.tab='playground';save();render()}
  else if(e.key==='2'){state.tab='cheatsheet';save();render()}
  else if(e.key==='3'){state.tab='challenges';save();render()}
  else if(e.key==='4'){state.tab='builder';save();render()}
  else if(e.key==='/'){e.preventDefault();const pi3=document.getElementById('patInput');if(pi3)pi3.focus()}
});

render();
</script>
</body>
</html>
