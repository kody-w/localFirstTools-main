<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inception Globe Tower</title>
    <meta name="description" content="Recursive snow globes where shaking cascades through infinite nested layers">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%); min-height: 100vh; font-family: monospace; color: #a0c0e0; overflow: hidden; display: flex; align-items: center; justify-content: center; }
        #canvas { border-radius: 20px; cursor: grab; }
        #canvas:active { cursor: grabbing; }
        #controls {
            position: fixed; top: 20px; left: 20px; background: rgba(20,30,50,0.9);
            padding: 20px; border-radius: 10px; border: 1px solid rgba(100,150,200,0.3);
        }
        h3 { margin-bottom: 15px; color: #c0e0ff; }
        button {
            display: block; width: 100%; padding: 10px; margin: 8px 0;
            background: rgba(50,80,120,0.4); border: 1px solid rgba(100,150,200,0.4);
            color: #a0c0e0; cursor: pointer; border-radius: 8px;
        }
        #depth-display {
            position: fixed; top: 20px; right: 20px; background: rgba(20,30,50,0.9);
            padding: 20px; border-radius: 10px; border: 1px solid rgba(100,150,200,0.3);
            text-align: center;
        }
        .stat-value { font-size: 32px; color: #c0e0ff; }
        .stat-label { font-size: 11px; opacity: 0.7; }
        #info { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); font-size: 12px; opacity: 0.5; }
    </style>
</head>
<body>
    <canvas id="canvas" width="600" height="700"></canvas>
    <div id="controls">
        <h3>Inception Globe</h3>
        <button id="shake-btn">Shake Globe</button>
        <button id="zoom-in-btn">Zoom In</button>
        <button id="zoom-out-btn">Zoom Out</button>
        <button id="reset-btn">Reset View</button>
    </div>
    <div id="depth-display">
        <div class="stat-value" id="current-depth">1</div>
        <div class="stat-label">Recursion Depth</div>
    </div>
    <div id="info">Click and drag to shake | Zoom to see deeper globes</div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const W = canvas.width, H = canvas.height;

        let shakeIntensity = 0;
        let zoom = 1;
        let maxDepth = 5;
        let viewDepth = 1;

        class SnowGlobe {
            constructor(x, y, radius, depth) {
                this.x = x; this.y = y;
                this.radius = radius;
                this.depth = depth;
                this.particles = [];
                this.shake = 0;
                this.child = null;
                this.initParticles();
                if (depth < maxDepth) {
                    this.child = new SnowGlobe(x, y + radius * 0.1, radius * 0.35, depth + 1);
                }
            }
            initParticles() {
                const count = Math.max(10, 50 - this.depth * 8);
                for (let i = 0; i < count; i++) {
                    this.particles.push({
                        x: (Math.random() - 0.5) * this.radius * 1.6,
                        y: (Math.random() - 0.5) * this.radius * 1.6,
                        vy: 0,
                        vx: 0,
                        size: 1 + Math.random() * 2,
                        settled: true
                    });
                }
            }
            applyShake(intensity) {
                this.shake = intensity;
                this.particles.forEach(p => {
                    p.vy = -Math.random() * intensity * 3;
                    p.vx = (Math.random() - 0.5) * intensity * 2;
                    p.settled = false;
                });
                if (this.child) {
                    setTimeout(() => this.child.applyShake(intensity * 0.7), 100);
                }
            }
            update() {
                this.shake *= 0.95;
                this.particles.forEach(p => {
                    if (!p.settled) {
                        p.vy += 0.05;
                        p.vx *= 0.99;
                        p.x += p.vx;
                        p.y += p.vy;
                        const dist = Math.hypot(p.x, p.y);
                        if (dist > this.radius * 0.8) {
                            const angle = Math.atan2(p.y, p.x);
                            p.x = Math.cos(angle) * this.radius * 0.79;
                            p.y = Math.sin(angle) * this.radius * 0.79;
                            p.vx *= -0.3;
                            p.vy *= -0.3;
                        }
                        if (p.y > this.radius * 0.6 && Math.abs(p.vy) < 0.5) {
                            p.settled = true;
                            p.vy = 0;
                            p.vx = 0;
                        }
                    }
                });
                if (this.child) this.child.update();
            }
            draw(offsetX, offsetY, scale) {
                const cx = offsetX + this.x * scale;
                const cy = offsetY + this.y * scale;
                const r = this.radius * scale;
                if (r < 10) return;
                ctx.save();
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, Math.PI * 2);
                const gradient = ctx.createRadialGradient(cx - r * 0.3, cy - r * 0.3, 0, cx, cy, r);
                gradient.addColorStop(0, 'rgba(200, 230, 255, 0.2)');
                gradient.addColorStop(0.7, 'rgba(100, 150, 200, 0.1)');
                gradient.addColorStop(1, 'rgba(50, 80, 120, 0.3)');
                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.strokeStyle = 'rgba(200, 230, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(cx, cy + r * 0.85, r * 0.5, Math.PI, 0);
                ctx.lineTo(cx + r * 0.6, cy + r * 1.1);
                ctx.lineTo(cx - r * 0.6, cy + r * 1.1);
                ctx.closePath();
                ctx.fillStyle = '#3a2a1a';
                ctx.fill();
                ctx.save();
                ctx.beginPath();
                ctx.arc(cx, cy, r * 0.85, 0, Math.PI * 2);
                ctx.clip();
                const groundGrad = ctx.createLinearGradient(cx, cy + r * 0.3, cx, cy + r * 0.8);
                groundGrad.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                groundGrad.addColorStop(1, 'rgba(200, 220, 240, 0.6)');
                ctx.fillStyle = groundGrad;
                ctx.beginPath();
                ctx.ellipse(cx, cy + r * 0.5, r * 0.8, r * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#2a4a2a';
                ctx.beginPath();
                ctx.moveTo(cx, cy - r * 0.2);
                ctx.lineTo(cx - r * 0.15, cy + r * 0.4);
                ctx.lineTo(cx + r * 0.15, cy + r * 0.4);
                ctx.closePath();
                ctx.fill();
                this.particles.forEach(p => {
                    const px = cx + p.x * scale;
                    const py = cy + p.y * scale;
                    const ps = p.size * scale;
                    if (ps > 0.5) {
                        ctx.beginPath();
                        ctx.arc(px, py, ps, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                        ctx.fill();
                    }
                });
                ctx.restore();
                ctx.beginPath();
                ctx.arc(cx - r * 0.4, cy - r * 0.4, r * 0.15, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fill();
                ctx.restore();
                if (this.child && r > 30) {
                    this.child.draw(cx - this.child.x * scale, cy - this.child.y * scale + r * 0.1, scale);
                }
            }
        }

        const mainGlobe = new SnowGlobe(0, 0, 200, 1);

        function animate() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, W, H);
            mainGlobe.update();
            mainGlobe.draw(W / 2, H / 2 - 50, zoom);
            shakeIntensity *= 0.9;
            requestAnimationFrame(animate);
        }

        let dragging = false;
        let lastY = 0;
        canvas.onmousedown = e => { dragging = true; lastY = e.clientY; };
        canvas.onmouseup = () => dragging = false;
        canvas.onmousemove = e => {
            if (dragging) {
                const dy = Math.abs(e.clientY - lastY);
                if (dy > 5) {
                    shakeIntensity = Math.min(5, dy * 0.1);
                    mainGlobe.applyShake(shakeIntensity);
                    lastY = e.clientY;
                }
            }
        };

        document.getElementById('shake-btn').onclick = () => mainGlobe.applyShake(3);
        document.getElementById('zoom-in-btn').onclick = () => {
            zoom = Math.min(3, zoom * 1.5);
            viewDepth = Math.min(maxDepth, viewDepth + 1);
            document.getElementById('current-depth').textContent = viewDepth;
        };
        document.getElementById('zoom-out-btn').onclick = () => {
            zoom = Math.max(0.5, zoom / 1.5);
            viewDepth = Math.max(1, viewDepth - 1);
            document.getElementById('current-depth').textContent = viewDepth;
        };
        document.getElementById('reset-btn').onclick = () => {
            zoom = 1;
            viewDepth = 1;
            document.getElementById('current-depth').textContent = viewDepth;
        };

        animate();
    </script>
</body>
</html>