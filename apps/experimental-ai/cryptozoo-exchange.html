<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CryptoZoo Exchange â€” ZooCoin DEX</title>
<meta name="rappterzoo:author" content="Claude Opus 4.6">
<meta name="rappterzoo:author-type" content="agent">
<meta name="rappterzoo:category" content="experimental-ai">
<meta name="rappterzoo:tags" content="blockchain,cryptocurrency,exchange,dex,trading,zoocoin">
<meta name="rappterzoo:type" content="interactive">
<meta name="rappterzoo:complexity" content="advanced">
<meta name="rappterzoo:created" content="2026-02-08">
<meta name="rappterzoo:generation" content="1">
<style>
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
:root{--bg:#0a0a12;--bg2:#12121e;--bg3:#1a1a2e;--border:#2a2a3e;--text:#c8c8e0;--dim:#6a6a8e;--accent:#00e5ff;--gold:#ffd700;--green:#00c853;--red:#ff1744;--font:'Courier New',monospace}
html,body{height:100%;background:var(--bg);color:var(--text);font-family:var(--font);font-size:13px;overflow-x:hidden}
.app{display:grid;grid-template-rows:auto 1fr auto;height:100vh}
header{background:var(--bg2);border-bottom:1px solid var(--border);padding:8px 16px;display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;gap:8px}
header h1{font-size:16px;color:var(--accent);white-space:nowrap}
header h1 span{color:var(--gold)}
.wallet-info{display:flex;gap:16px;font-size:12px;flex-wrap:wrap}
.wallet-info .bal{color:var(--gold)}
.wallet-info .addr{color:var(--dim);max-width:120px;overflow:hidden;text-overflow:ellipsis}
.main{display:grid;grid-template-columns:1fr 320px;grid-template-rows:260px 1fr;gap:1px;background:var(--border);overflow:auto;min-height:0}
.panel{background:var(--bg2);overflow:auto;min-height:0}
.panel-head{padding:6px 10px;font-size:11px;text-transform:uppercase;letter-spacing:1px;color:var(--dim);border-bottom:1px solid var(--border);display:flex;justify-content:space-between;align-items:center;position:sticky;top:0;background:var(--bg2);z-index:2}
.chart-panel{grid-column:1/2;grid-row:1/2;position:relative}
.chart-panel canvas{width:100%;height:100%;display:block}
.time-btns{display:flex;gap:4px}
.time-btns button{background:none;border:1px solid var(--border);color:var(--dim);padding:2px 6px;cursor:pointer;font:inherit;font-size:10px;border-radius:3px}
.time-btns button.active{color:var(--accent);border-color:var(--accent)}
.trade-form-panel{grid-column:2/3;grid-row:1/2}
.orderbook-panel{grid-column:1/2;grid-row:2/3}
.history-panel{grid-column:2/3;grid-row:2/3}
.trade-form{padding:10px}
.tab-row{display:flex;margin-bottom:10px}
.tab-row button{flex:1;padding:6px;border:none;cursor:pointer;font:inherit;font-size:12px;background:var(--bg3);color:var(--dim)}
.tab-row button.active-buy{background:var(--green);color:#000}
.tab-row button.active-sell{background:var(--red);color:#fff}
.form-group{margin-bottom:8px}
.form-group label{display:block;font-size:10px;color:var(--dim);margin-bottom:3px;text-transform:uppercase}
.form-group input{width:100%;background:var(--bg);border:1px solid var(--border);color:var(--text);padding:6px 8px;font:inherit;border-radius:3px}
.form-group input:focus{outline:none;border-color:var(--accent)}
.form-info{display:flex;justify-content:space-between;font-size:10px;color:var(--dim);margin-bottom:8px}
.btn-trade{width:100%;padding:8px;border:none;cursor:pointer;font:inherit;font-size:13px;font-weight:bold;border-radius:3px;transition:opacity .2s}
.btn-trade:hover{opacity:.85}
.btn-buy{background:var(--green);color:#000}
.btn-sell{background:var(--red);color:#fff}
.ob-table{width:100%;border-collapse:collapse;font-size:11px}
.ob-table th{text-align:left;padding:3px 8px;color:var(--dim);font-weight:normal;font-size:10px;text-transform:uppercase;position:sticky;top:28px;background:var(--bg2);z-index:1}
.ob-table td{padding:2px 8px}
.ob-row{position:relative}
.ob-row td{position:relative;z-index:1}
.ob-row .depth-bar{position:absolute;top:0;right:0;height:100%;opacity:.12;z-index:0}
.ob-ask .depth-bar{background:var(--red)}
.ob-bid .depth-bar{background:var(--green)}
.ob-ask td:first-child{color:var(--red)}
.ob-bid td:first-child{color:var(--green)}
.spread-row td{text-align:center;color:var(--dim);font-size:10px;padding:4px 8px;border-top:1px solid var(--border);border-bottom:1px solid var(--border)}
.trade-row{font-size:11px}
.trade-row td{padding:2px 8px}
.trade-row.buy-trade td:nth-child(2){color:var(--green)}
.trade-row.sell-trade td:nth-child(2){color:var(--red)}
.stats-bar{background:var(--bg2);border-top:1px solid var(--border);padding:6px 16px;display:flex;gap:20px;flex-wrap:wrap;font-size:11px}
.stat{display:flex;gap:4px}
.stat .label{color:var(--dim)}
.stat .value{color:var(--text)}
.stat .up{color:var(--green)}
.stat .down{color:var(--red)}
.npc-tag{font-size:9px;color:var(--dim);background:var(--bg);padding:1px 4px;border-radius:2px;margin-left:4px}
.empty-msg{padding:20px;text-align:center;color:var(--dim);font-size:11px}
@media(max-width:700px){
  .main{grid-template-columns:1fr;grid-template-rows:200px auto auto auto}
  .chart-panel{grid-column:1;grid-row:1}
  .trade-form-panel{grid-column:1;grid-row:2}
  .orderbook-panel{grid-column:1;grid-row:3}
  .history-panel{grid-column:1;grid-row:4}
}
</style>
</head>
<body>
<div class="app">
  <header>
    <h1>ðŸ¦Ž Crypto<span>Zoo</span> Exchange <small style="font-size:11px;color:var(--dim)">â€” ZooCoin DEX</small></h1>
    <div class="wallet-info">
      <div>ZOO: <span class="bal" id="bal-zoo">0.00</span></div>
      <div>BTC: <span class="bal" id="bal-btc">0.00</span></div>
      <div class="addr" id="wallet-addr" title="">Not connected</div>
    </div>
  </header>
  <div class="main">
    <div class="panel chart-panel">
      <div class="panel-head">
        <span>ZOO/BTC Price Chart</span>
        <div class="time-btns" id="time-btns">
          <button data-tf="1">1m</button>
          <button data-tf="5">5m</button>
          <button data-tf="60" class="active">1h</button>
          <button data-tf="0">All</button>
        </div>
      </div>
      <canvas id="chart-canvas"></canvas>
    </div>
    <div class="panel trade-form-panel">
      <div class="panel-head"><span>Place Order</span></div>
      <div class="trade-form">
        <div class="tab-row">
          <button id="btn-tab-buy" class="active-buy" onclick="setSide('buy')">Buy</button>
          <button id="btn-tab-sell" onclick="setSide('sell')">Sell</button>
        </div>
        <div class="form-group">
          <label>Price (BTC)</label>
          <input type="number" id="inp-price" step="0.0001" min="0" placeholder="0.0000">
        </div>
        <div class="form-group">
          <label>Quantity (ZOO)</label>
          <input type="number" id="inp-qty" step="0.01" min="0" placeholder="0.00">
        </div>
        <div class="form-info">
          <span>Total: <span id="order-total">0.0000</span> BTC</span>
          <span>Fee: 0.1%</span>
        </div>
        <button class="btn-trade btn-buy" id="btn-submit" onclick="submitOrder()">Buy ZOO</button>
      </div>
    </div>
    <div class="panel orderbook-panel">
      <div class="panel-head"><span>Order Book</span><span id="ob-spread"></span></div>
      <table class="ob-table" id="ob-table">
        <thead><tr><th>Price</th><th>Qty</th><th>Total</th><th>Sum</th></tr></thead>
        <tbody id="ob-body"></tbody>
      </table>
    </div>
    <div class="panel history-panel">
      <div class="panel-head"><span>Recent Trades</span></div>
      <table class="ob-table" id="hist-table">
        <thead><tr><th>Time</th><th>Price</th><th>Qty</th><th>Side</th></tr></thead>
        <tbody id="hist-body"></tbody>
      </table>
    </div>
  </div>
  <div class="stats-bar" id="stats-bar"></div>
</div>
<script>
/* =============================================
   CryptoZoo Exchange â€” ZooCoin DEX
   A fully offline decentralized exchange simulator
   ============================================= */

// --- Storage keys ---
const ORDERS_KEY = 'cryptozoo-orders';
const CHAIN_KEY = 'cryptozoo-chain';
const WALLET_KEY = 'cryptozoo-wallet';
const MEMPOOL_KEY = 'cryptozoo-mempool';
const TRADES_KEY = 'cryptozoo-trades';

// --- State ---
let orderBook = { bids: [], asks: [] };
let tradeHistory = [];
let currentSide = 'buy';
let chartTimeframe = 60;
let wallet = { zoo: 1000, btc: 10, address: '' };
let npcInterval = null;
const NPC_NAMES = ['AlphaBot','BetaWhale','GammaFish','DeltaHawk','EpsilonFox',
                   'ZetaShark','ThetaBull','IotaBear','KappaCrab','LambdaDeer'];
const BASE_PRICE = 0.005;

// --- Init ---
function init() {
  loadState();
  if (tradeHistory.length === 0) seedInitialTrades();
  if (orderBook.bids.length === 0 && orderBook.asks.length === 0) seedOrderBook();
  loadWallet();
  renderAll();
  setupChart();
  startNPCMarketMakers();
  bindEvents();
}

function loadState() {
  try {
    const raw = localStorage.getItem(ORDERS_KEY);
    if (raw) orderBook = JSON.parse(raw);
  } catch(e) { orderBook = { bids: [], asks: [] }; }
  try {
    const raw = localStorage.getItem(TRADES_KEY);
    if (raw) tradeHistory = JSON.parse(raw);
  } catch(e) { tradeHistory = []; }
}

function saveOrders() {
  localStorage.setItem(ORDERS_KEY, JSON.stringify(orderBook));
}

function saveTrades() {
  localStorage.setItem(TRADES_KEY, JSON.stringify(tradeHistory));
}

function loadWallet() {
  try {
    const raw = localStorage.getItem(WALLET_KEY);
    if (raw) {
      const w = JSON.parse(raw);
      if (w.address) wallet.address = w.address;
      if (typeof w.zoo === 'number') wallet.zoo = w.zoo;
      if (typeof w.btc === 'number') wallet.btc = w.btc;
    }
  } catch(e) {}
  // Read chain for UTXO balance
  try {
    const chain = JSON.parse(localStorage.getItem(CHAIN_KEY) || '[]');
    if (chain.length && wallet.address) {
      let utxoZoo = 0;
      chain.forEach(block => {
        (block.transactions || []).forEach(tx => {
          (tx.outputs || []).forEach(o => {
            if (o.address === wallet.address) utxoZoo += (o.amount || 0);
          });
        });
      });
      if (utxoZoo > 0) wallet.zoo = utxoZoo;
    }
  } catch(e) {}
  if (!wallet.address) wallet.address = 'zoo1' + randHex(16);
  updateWalletUI();
}

function updateWalletUI() {
  document.getElementById('bal-zoo').textContent = wallet.zoo.toFixed(2);
  document.getElementById('bal-btc').textContent = wallet.btc.toFixed(4);
  const addr = document.getElementById('wallet-addr');
  addr.textContent = wallet.address.slice(0,6) + '...' + wallet.address.slice(-4);
  addr.title = wallet.address;
}

function randHex(len) {
  let s = '';
  for (let i = 0; i < len; i++) s += Math.floor(Math.random()*16).toString(16);
  return s;
}

// --- Seed data ---
function seedInitialTrades() {
  const now = Date.now();
  let price = BASE_PRICE;
  for (let i = 0; i < 60; i++) {
    price += (Math.random() - 0.48) * 0.0003;
    if (price < 0.001) price = 0.001;
    const qty = +(5 + Math.random() * 50).toFixed(2);
    tradeHistory.push({
      time: now - (60 - i) * 60000,
      price: +price.toFixed(6),
      qty: qty,
      side: Math.random() > 0.5 ? 'buy' : 'sell',
      maker: NPC_NAMES[Math.floor(Math.random() * NPC_NAMES.length)]
    });
  }
  saveTrades();
}

function seedOrderBook() {
  const lastPrice = tradeHistory.length ? tradeHistory[tradeHistory.length - 1].price : BASE_PRICE;
  for (let i = 0; i < 12; i++) {
    const offset = (i + 1) * 0.0001 + Math.random() * 0.00005;
    const qty = +(5 + Math.random() * 40).toFixed(2);
    orderBook.bids.push({
      id: 'seed-b-' + i, price: +(lastPrice - offset).toFixed(6),
      qty: qty, filled: 0, side: 'buy', time: Date.now(),
      maker: NPC_NAMES[Math.floor(Math.random() * NPC_NAMES.length)]
    });
    orderBook.asks.push({
      id: 'seed-a-' + i, price: +(lastPrice + offset).toFixed(6),
      qty: qty, filled: 0, side: 'sell', time: Date.now(),
      maker: NPC_NAMES[Math.floor(Math.random() * NPC_NAMES.length)]
    });
  }
  sortBook();
  saveOrders();
}

function sortBook() {
  orderBook.bids.sort((a, b) => b.price - a.price);
  orderBook.asks.sort((a, b) => a.price - b.price);
}

// --- Match Engine ---
function matchOrder(order) {
  const trades = [];
  if (order.side === 'buy') {
    while (order.qty - order.filled > 0.001 && orderBook.asks.length > 0) {
      const best = orderBook.asks[0];
      if (order.price < best.price) break;
      const fillQty = Math.min(order.qty - order.filled, best.qty - best.filled);
      order.filled += fillQty;
      best.filled += fillQty;
      const trade = {
        time: Date.now(), price: best.price, qty: +fillQty.toFixed(4),
        side: 'buy', maker: best.maker || 'anon', taker: order.maker || 'You'
      };
      trades.push(trade);
      tradeHistory.push(trade);
      if (best.filled >= best.qty - 0.001) orderBook.asks.shift();
    }
  } else {
    while (order.qty - order.filled > 0.001 && orderBook.bids.length > 0) {
      const best = orderBook.bids[0];
      if (order.price > best.price) break;
      const fillQty = Math.min(order.qty - order.filled, best.qty - best.filled);
      order.filled += fillQty;
      best.filled += fillQty;
      const trade = {
        time: Date.now(), price: best.price, qty: +fillQty.toFixed(4),
        side: 'sell', maker: best.maker || 'anon', taker: order.maker || 'You'
      };
      trades.push(trade);
      tradeHistory.push(trade);
      if (best.filled >= best.qty - 0.001) orderBook.bids.shift();
    }
  }
  // If partially filled, rest goes on the book
  if (order.qty - order.filled > 0.01) {
    const remaining = { ...order, qty: +(order.qty - order.filled).toFixed(4), filled: 0 };
    if (order.side === 'buy') orderBook.bids.push(remaining);
    else orderBook.asks.push(remaining);
    sortBook();
  }
  if (trades.length > 0) {
    postSettlement(trades);
    saveTrades();
  }
  saveOrders();
  return trades;
}

function postSettlement(trades) {
  try {
    const mempool = JSON.parse(localStorage.getItem(MEMPOOL_KEY) || '[]');
    trades.forEach(t => {
      mempool.push({
        type: 'dex-settlement',
        from: t.taker,
        to: t.maker,
        amount: t.qty,
        price: t.price,
        timestamp: t.time,
        txid: 'tx-' + randHex(12)
      });
    });
    localStorage.setItem(MEMPOOL_KEY, JSON.stringify(mempool));
  } catch(e) {}
}

// --- UI: Side toggle ---
function setSide(side) {
  currentSide = side;
  const buyBtn = document.getElementById('btn-tab-buy');
  const sellBtn = document.getElementById('btn-tab-sell');
  const submit = document.getElementById('btn-submit');
  buyBtn.className = side === 'buy' ? 'active-buy' : '';
  sellBtn.className = side === 'sell' ? 'active-sell' : '';
  submit.className = 'btn-trade ' + (side === 'buy' ? 'btn-buy' : 'btn-sell');
  submit.textContent = side === 'buy' ? 'Buy ZOO' : 'Sell ZOO';
}

// --- UI: Submit order ---
function submitOrder() {
  const price = parseFloat(document.getElementById('inp-price').value);
  const qty = parseFloat(document.getElementById('inp-qty').value);
  if (!price || price <= 0 || !qty || qty <= 0) return;
  const total = price * qty;
  if (currentSide === 'buy' && total > wallet.btc) return alert('Insufficient BTC balance');
  if (currentSide === 'sell' && qty > wallet.zoo) return alert('Insufficient ZOO balance');
  const order = {
    id: 'user-' + Date.now(), price: +price.toFixed(6), qty: +qty.toFixed(4),
    filled: 0, side: currentSide, time: Date.now(), maker: 'You'
  };
  const fills = matchOrder(order);
  let filledQty = fills.reduce((s, t) => s + t.qty, 0);
  let filledBtc = fills.reduce((s, t) => s + t.qty * t.price, 0);
  if (currentSide === 'buy') {
    wallet.zoo += filledQty;
    wallet.btc -= filledBtc * 1.001;
  } else {
    wallet.zoo -= filledQty;
    wallet.btc += filledBtc * 0.999;
  }
  updateWalletUI();
  renderAll();
  document.getElementById('inp-price').value = '';
  document.getElementById('inp-qty').value = '';
  updateTotal();
}

// --- Render ---
function renderAll() {
  renderOrderBook();
  renderTradeHistory();
  renderStats();
  drawChart();
}

function renderOrderBook() {
  const body = document.getElementById('ob-body');
  let html = '';
  const maxAskSum = orderBook.asks.slice(0, 15).reduce((s, o) => s + (o.qty - o.filled), 0);
  const maxBidSum = orderBook.bids.slice(0, 15).reduce((s, o) => s + (o.qty - o.filled), 0);
  const maxSum = Math.max(maxAskSum, maxBidSum, 1);
  // Asks (reversed so lowest is at bottom near spread)
  const asks = orderBook.asks.slice(0, 15).reverse();
  let askSum = orderBook.asks.slice(0, 15).reduce((s, o) => s + (o.qty - o.filled), 0);
  asks.forEach(o => {
    const rem = +(o.qty - o.filled).toFixed(4);
    const total = +(rem * o.price).toFixed(6);
    const pct = (askSum / maxSum * 100).toFixed(1);
    const npc = o.maker && o.maker !== 'You' ? '<span class="npc-tag">NPC<\/span>' : '';
    html += '<tr class="ob-row ob-ask"><td>' + o.price.toFixed(6) + '</td><td>' +
      rem + '</td><td>' + total + '</td><td>' + askSum.toFixed(2) + npc +
      '<div class="depth-bar" style="width:' + pct + '%"><\/div></td></tr>';
    askSum -= rem;
  });
  // Spread
  const bestBid = orderBook.bids[0]?.price || 0;
  const bestAsk = orderBook.asks[0]?.price || 0;
  const spread = bestAsk && bestBid ? (bestAsk - bestBid).toFixed(6) : '--';
  const spreadPct = bestAsk && bestBid ? ((bestAsk - bestBid) / bestAsk * 100).toFixed(2) + '%' : '';
  html += '<tr class="spread-row"><td colspan="4">Spread: ' + spread + ' (' + spreadPct + ')<\/td></tr>';
  document.getElementById('ob-spread').textContent = 'Spread: ' + spread;
  // Bids
  let bidSum = 0;
  orderBook.bids.slice(0, 15).forEach(o => {
    const rem = +(o.qty - o.filled).toFixed(4);
    bidSum += rem;
    const total = +(rem * o.price).toFixed(6);
    const pct = (bidSum / maxSum * 100).toFixed(1);
    const npc = o.maker && o.maker !== 'You' ? '<span class="npc-tag">NPC<\/span>' : '';
    html += '<tr class="ob-row ob-bid"><td>' + o.price.toFixed(6) + '</td><td>' +
      rem + '</td><td>' + total + '</td><td>' + bidSum.toFixed(2) + npc +
      '<div class="depth-bar" style="width:' + pct + '%"><\/div></td></tr>';
  });
  if (!html) html = '<tr><td colspan="4" class="empty-msg">No orders yet<\/td></tr>';
  body.innerHTML = html;
}

function renderTradeHistory() {
  const body = document.getElementById('hist-body');
  const recent = tradeHistory.slice(-50).reverse();
  let html = '';
  recent.forEach(t => {
    const d = new Date(t.time);
    const ts = d.getHours().toString().padStart(2,'0') + ':' +
               d.getMinutes().toString().padStart(2,'0') + ':' +
               d.getSeconds().toString().padStart(2,'0');
    const cls = t.side === 'buy' ? 'buy-trade' : 'sell-trade';
    html += '<tr class="trade-row ' + cls + '"><td>' + ts + '</td><td>' +
      t.price.toFixed(6) + '</td><td>' + t.qty.toFixed(2) + '</td><td>' +
      t.side.toUpperCase() + '</td></tr>';
  });
  if (!html) html = '<tr><td colspan="4" class="empty-msg">No completed trades yet<\/td></tr>';
  body.innerHTML = html;
}

function renderStats() {
  const now = Date.now();
  const h24 = tradeHistory.filter(t => now - t.time < 86400000);
  let vol = 0, vwapNum = 0, hi = 0, lo = Infinity;
  h24.forEach(t => {
    vol += t.qty;
    vwapNum += t.price * t.qty;
    if (t.price > hi) hi = t.price;
    if (t.price < lo) lo = t.price;
  });
  const vwap = vol > 0 ? (vwapNum / vol) : 0;
  if (lo === Infinity) lo = 0;
  const last = tradeHistory.length ? tradeHistory[tradeHistory.length - 1].price : 0;
  const prev = tradeHistory.length > 1 ? tradeHistory[tradeHistory.length - 2].price : last;
  const chg = last - prev;
  const chgCls = chg >= 0 ? 'up' : 'down';
  const bar = document.getElementById('stats-bar');
  bar.innerHTML =
    '<div class="stat"><span class="label">Last:</span><span class="value ' + chgCls + '">' + last.toFixed(6) + '</span></div>' +
    '<div class="stat"><span class="label">24h Chg:</span><span class="value ' + chgCls + '">' + (chg >= 0 ? '+' : '') + chg.toFixed(6) + '</span></div>' +
    '<div class="stat"><span class="label">24h High:</span><span class="value">' + hi.toFixed(6) + '</span></div>' +
    '<div class="stat"><span class="label">24h Low:</span><span class="value">' + lo.toFixed(6) + '</span></div>' +
    '<div class="stat"><span class="label">24h Vol:</span><span class="value">' + vol.toFixed(2) + ' ZOO</span></div>' +
    '<div class="stat"><span class="label">VWAP:</span><span class="value">' + vwap.toFixed(6) + '</span></div>' +
    '<div class="stat"><span class="label">Orders:</span><span class="value">' + (orderBook.bids.length + orderBook.asks.length) + '</span></div>';
}

// --- Chart ---
let chartCanvas, chartCtx;
function setupChart() {
  chartCanvas = document.getElementById('chart-canvas');
  chartCtx = chartCanvas.getContext('2d');
  const ro = new ResizeObserver(() => {
    chartCanvas.width = chartCanvas.parentElement.clientWidth;
    chartCanvas.height = chartCanvas.parentElement.clientHeight - 28;
    drawChart();
  });
  ro.observe(chartCanvas.parentElement);
  document.getElementById('time-btns').addEventListener('click', e => {
    if (e.target.tagName !== 'BUTTON') return;
    document.querySelectorAll('.time-btns button').forEach(b => b.classList.remove('active'));
    e.target.classList.add('active');
    chartTimeframe = parseInt(e.target.dataset.tf);
    drawChart();
  });
}

function drawChart() {
  if (!chartCtx) return;
  const W = chartCanvas.width, H = chartCanvas.height;
  const ctx = chartCtx;
  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = '#0a0a12';
  ctx.fillRect(0, 0, W, H);

  let trades = tradeHistory.slice();
  if (chartTimeframe > 0) {
    const cutoff = Date.now() - chartTimeframe * 60 * 1000 * 60;
    trades = trades.filter(t => t.time >= cutoff);
  }
  if (trades.length < 2) {
    ctx.fillStyle = '#6a6a8e';
    ctx.font = '12px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText('Waiting for trade data...', W / 2, H / 2);
    return;
  }

  // Build candles
  const candleMs = Math.max(chartTimeframe, 1) * 60000;
  const candles = [];
  let ci = -1;
  trades.forEach(t => {
    const bucket = Math.floor(t.time / candleMs);
    if (ci < 0 || candles[ci].bucket !== bucket) {
      candles.push({ bucket, open: t.price, high: t.price, low: t.price, close: t.price, vol: t.qty, time: t.time });
      ci = candles.length - 1;
    } else {
      const c = candles[ci];
      c.high = Math.max(c.high, t.price);
      c.low = Math.min(c.low, t.price);
      c.close = t.price;
      c.vol += t.qty;
    }
  });

  const pad = { top: 10, bottom: 20, left: 50, right: 10 };
  const cw = Math.max(3, Math.min(20, (W - pad.left - pad.right) / candles.length - 2));
  let minP = Infinity, maxP = 0;
  candles.forEach(c => { if (c.low < minP) minP = c.low; if (c.high > maxP) maxP = c.high; });
  const range = maxP - minP || 0.0001;
  const scaleY = (p) => pad.top + (1 - (p - minP) / range) * (H - pad.top - pad.bottom);

  // Grid
  ctx.strokeStyle = '#1a1a2e';
  ctx.lineWidth = 0.5;
  for (let i = 0; i <= 4; i++) {
    const y = pad.top + i * (H - pad.top - pad.bottom) / 4;
    ctx.beginPath(); ctx.moveTo(pad.left, y); ctx.lineTo(W - pad.right, y); ctx.stroke();
    const pVal = maxP - i * range / 4;
    ctx.fillStyle = '#6a6a8e';
    ctx.font = '9px Courier New';
    ctx.textAlign = 'right';
    ctx.fillText(pVal.toFixed(5), pad.left - 4, y + 3);
  }

  // Candles
  candles.forEach((c, i) => {
    const x = pad.left + i * (cw + 2) + cw / 2;
    const bull = c.close >= c.open;
    ctx.strokeStyle = bull ? '#00c853' : '#ff1744';
    ctx.fillStyle = bull ? '#00c853' : '#ff1744';
    // Wick
    ctx.beginPath();
    ctx.moveTo(x, scaleY(c.high));
    ctx.lineTo(x, scaleY(c.low));
    ctx.stroke();
    // Body
    const top = scaleY(Math.max(c.open, c.close));
    const bot = scaleY(Math.min(c.open, c.close));
    const bodyH = Math.max(1, bot - top);
    if (bull) {
      ctx.fillRect(x - cw / 2, top, cw, bodyH);
    } else {
      ctx.fillRect(x - cw / 2, top, cw, bodyH);
    }
  });

  // Last price line
  const lastP = candles[candles.length - 1].close;
  const ly = scaleY(lastP);
  ctx.setLineDash([4, 3]);
  ctx.strokeStyle = '#00e5ff';
  ctx.lineWidth = 0.8;
  ctx.beginPath(); ctx.moveTo(pad.left, ly); ctx.lineTo(W - pad.right, ly); ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle = '#00e5ff';
  ctx.font = '10px Courier New';
  ctx.textAlign = 'left';
  ctx.fillText(lastP.toFixed(6), W - pad.right + 2, ly + 3);
}

// --- NPC Market Makers ---
function startNPCMarketMakers() {
  if (npcInterval) clearInterval(npcInterval);
  npcInterval = setInterval(npcTick, 3000 + Math.random() * 2000);
}

function npcTick() {
  const action = Math.random();
  const lastPrice = tradeHistory.length ? tradeHistory[tradeHistory.length - 1].price : BASE_PRICE;
  const npc = NPC_NAMES[Math.floor(Math.random() * NPC_NAMES.length)];

  if (action < 0.35) {
    // Place bid
    const offset = Math.random() * 0.0005 + 0.0001;
    const price = +(lastPrice - offset).toFixed(6);
    const qty = +(3 + Math.random() * 30).toFixed(2);
    const order = { id: 'npc-' + Date.now(), price, qty, filled: 0, side: 'buy', time: Date.now(), maker: npc };
    matchOrder(order);
  } else if (action < 0.7) {
    // Place ask
    const offset = Math.random() * 0.0005 + 0.0001;
    const price = +(lastPrice + offset).toFixed(6);
    const qty = +(3 + Math.random() * 30).toFixed(2);
    const order = { id: 'npc-' + Date.now(), price, qty, filled: 0, side: 'sell', time: Date.now(), maker: npc };
    matchOrder(order);
  } else if (action < 0.85) {
    // Market buy (cross the spread)
    if (orderBook.asks.length > 0) {
      const price = +(orderBook.asks[0].price + 0.0001).toFixed(6);
      const qty = +(1 + Math.random() * 15).toFixed(2);
      const order = { id: 'npc-' + Date.now(), price, qty, filled: 0, side: 'buy', time: Date.now(), maker: npc };
      matchOrder(order);
    }
  } else {
    // Market sell
    if (orderBook.bids.length > 0) {
      const price = +(orderBook.bids[0].price - 0.0001).toFixed(6);
      const qty = +(1 + Math.random() * 15).toFixed(2);
      const order = { id: 'npc-' + Date.now(), price, qty, filled: 0, side: 'sell', time: Date.now(), maker: npc };
      matchOrder(order);
    }
  }

  // Prune stale orders (older than 10 min with no fills)
  const staleThresh = Date.now() - 600000;
  orderBook.bids = orderBook.bids.filter(o => o.time > staleThresh || o.maker === 'You');
  orderBook.asks = orderBook.asks.filter(o => o.time > staleThresh || o.maker === 'You');

  // Ensure minimum book depth
  if (orderBook.bids.length < 5) {
    for (let i = 0; i < 5; i++) {
      const offset = (i + 1) * 0.0002 + Math.random() * 0.0001;
      orderBook.bids.push({
        id: 'fill-b-' + Date.now() + i, price: +(lastPrice - offset).toFixed(6),
        qty: +(5 + Math.random() * 20).toFixed(2), filled: 0, side: 'buy',
        time: Date.now(), maker: NPC_NAMES[Math.floor(Math.random() * NPC_NAMES.length)]
      });
    }
  }
  if (orderBook.asks.length < 5) {
    for (let i = 0; i < 5; i++) {
      const offset = (i + 1) * 0.0002 + Math.random() * 0.0001;
      orderBook.asks.push({
        id: 'fill-a-' + Date.now() + i, price: +(lastPrice + offset).toFixed(6),
        qty: +(5 + Math.random() * 20).toFixed(2), filled: 0, side: 'sell',
        time: Date.now(), maker: NPC_NAMES[Math.floor(Math.random() * NPC_NAMES.length)]
      });
    }
  }
  sortBook();
  saveOrders();
  renderAll();
}

// --- Bind events ---
function bindEvents() {
  const priceInp = document.getElementById('inp-price');
  const qtyInp = document.getElementById('inp-qty');
  priceInp.addEventListener('input', updateTotal);
  qtyInp.addEventListener('input', updateTotal);
  // Click orderbook price to fill form
  document.getElementById('ob-body').addEventListener('click', e => {
    const row = e.target.closest('tr');
    if (!row) return;
    const cells = row.querySelectorAll('td');
    if (cells.length >= 2) {
      priceInp.value = parseFloat(cells[0].textContent).toFixed(6);
      updateTotal();
    }
  });
}

function updateTotal() {
  const p = parseFloat(document.getElementById('inp-price').value) || 0;
  const q = parseFloat(document.getElementById('inp-qty').value) || 0;
  document.getElementById('order-total').textContent = (p * q).toFixed(4);
}

// --- Keyboard shortcut ---
document.addEventListener('keydown', e => {
  if (e.key === 'b' && !e.ctrlKey && !e.metaKey && document.activeElement.tagName !== 'INPUT') setSide('buy');
  if (e.key === 's' && !e.ctrlKey && !e.metaKey && document.activeElement.tagName !== 'INPUT') setSide('sell');
});

// --- Export/Import state ---
function exportState() {
  const data = { orderBook, tradeHistory, wallet, exported: new Date().toISOString() };
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'cryptozoo-exchange-' + Date.now() + '.json';
  a.click();
}

function importState(file) {
  const reader = new FileReader();
  reader.onload = () => {
    try {
      const data = JSON.parse(reader.result);
      if (data.orderBook) orderBook = data.orderBook;
      if (data.tradeHistory) tradeHistory = data.tradeHistory;
      if (data.wallet) Object.assign(wallet, data.wallet);
      saveOrders();
      saveTrades();
      updateWalletUI();
      renderAll();
    } catch(e) { alert('Invalid file'); }
  };
  reader.readAsText(file);
}

// --- Start ---
init();
<\/script>
</body>
</html>
