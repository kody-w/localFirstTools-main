<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zero-G Station Builder Deluxe</title>
    <meta name="description" content="Advanced 3D space station construction simulator with bloom effects, physics-based movement, and modular building system.">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }

        body {
            font-family: 'Segoe UI', 'Roboto', sans-serif;
            background: #000;
            overflow: hidden;
            color: #fff;
        }

        #canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        /* Holographic UI Theme */
        :root {
            --hud-bg: rgba(10, 20, 30, 0.75);
            --hud-border: 1px solid rgba(0, 255, 255, 0.3);
            --accent: #00ffff;
            --accent-glow: 0 0 10px rgba(0, 255, 255, 0.5);
            --text-shadow: 0 0 5px rgba(0, 255, 255, 0.3);
        }

        .hud {
            position: fixed;
            background: var(--hud-bg);
            border: var(--hud-border);
            padding: 15px;
            backdrop-filter: blur(5px);
            border-radius: 4px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            transition: opacity 0.3s;
        }

        .hud-header {
            color: var(--accent);
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(0, 255, 255, 0.2);
            padding-bottom: 5px;
            text-shadow: var(--text-shadow);
        }

        #stats {
            top: 20px;
            left: 20px;
            min-width: 220px;
            clip-path: polygon(0 0, 100% 0, 100% 85%, 90% 100%, 0 100%);
        }

        #controls-info {
            top: 20px;
            right: 20px;
            text-align: right;
            clip-path: polygon(0 0, 100% 0, 100% 100%, 10% 100%, 0 85%);
        }

        .key-hint {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            color: var(--accent);
            margin-right: 5px;
        }

        #build-menu {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            padding: 10px 20px;
            background: rgba(0, 10, 20, 0.9);
            border-top: 2px solid var(--accent);
            border-radius: 10px 10px 0 0;
        }

        .module-button {
            background: rgba(0, 50, 100, 0.4);
            border: 1px solid rgba(0, 255, 255, 0.2);
            color: #fff;
            width: 80px;
            height: 80px;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 5px;
            position: relative;
            overflow: hidden;
        }

        .module-button:hover {
            background: rgba(0, 100, 200, 0.6);
            border-color: var(--accent);
            box-shadow: var(--accent-glow);
            transform: translateY(-2px);
        }

        .module-button.selected {
            background: rgba(0, 200, 255, 0.2);
            border-color: var(--accent);
            box-shadow: inset 0 0 15px rgba(0, 255, 255, 0.3);
        }

        .module-icon {
            font-size: 28px;
            filter: drop-shadow(0 0 5px rgba(255, 255, 255, 0.5));
        }

        .module-name {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .module-cost {
            font-size: 9px;
            color: #aaa;
        }

        /* Data Controls */
        .data-controls {
            position: fixed;
            top: 20px; 
            left: 260px; /* Moved right of stats */
            transform: none; 
            display: flex;
            gap: 5px;
            background: var(--hud-bg);
            padding: 5px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
        }

        .icon-btn {
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            padding: 8px;
            cursor: pointer;
            transition: color 0.2s;
            font-size: 16px;
        }

        .icon-btn:hover {
            color: var(--accent);
        }

        .icon-btn:focus-visible,
        .menu-btn:focus-visible,
        .module-button:focus-visible,
        button:focus-visible {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
            box-shadow: 0 0 10px var(--accent);
        }

        /* Orbital info */
        #orbital-info {
            bottom: 20px;
            right: 20px;
            text-align: right;
            border-right: 2px solid var(--accent);
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 13px;
        }

        .stat-label {
            color: #88aaff;
            margin-right: 15px;
        }

        .stat-value {
            color: #fff;
            font-family: monospace;
            font-weight: bold;
        }

        .warning {
            color: #ff3333;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; text-shadow: 0 0 10px red; }
            50% { opacity: 0.5; }
        }

        /* Loading screen */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000510;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .loader {
            width: 100px;
            height: 100px;
            border: 3px solid transparent;
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        .loader:before {
            content: "";
            position: absolute;
            top: 5px; left: 5px; right: 5px; bottom: 5px;
            border: 3px solid transparent;
            border-top-color: #0088ff;
            border-radius: 50%;
            animation: spin 2s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            font-family: monospace;
            color: var(--accent);
            letter-spacing: 4px;
            animation: blink 1s infinite;
        }

        @keyframes blink { 50% { opacity: 0.5; } }

        /* Mode indicator */
        #mode-indicator {
            position: fixed;
            top: 50%;
            left: 30px;
            transform: translateY(-50%);
            writing-mode: vertical-rl;
            text-orientation: mixed;
            padding: 20px 5px;
            background: rgba(0, 0, 0, 0.5);
            border-left: 3px solid var(--accent);
            font-weight: bold;
            letter-spacing: 4px;
            text-transform: uppercase;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.5);
            transition: all 0.3s;
        }

        #mode-indicator.active {
            color: var(--accent);
            text-shadow: 0 0 10px var(--accent);
            background: rgba(0, 20, 40, 0.8);
        }

        /* Notification */
        #notification {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 20, 40, 0.9);
            border: 1px solid var(--accent);
            padding: 10px 30px;
            color: #fff;
            border-radius: 20px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 1500;
            text-shadow: 0 0 5px var(--accent);
        }

        /* Title Screen */
        #title-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 5, 10, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 3000;
            transition: opacity 1s;
        }

        .title-glitch {
            font-size: 60px;
            font-weight: bold;
            color: #fff;
            text-shadow: 2px 2px 0px #00ffff, -2px -2px 0px #ff00ff;
            letter-spacing: 10px;
            margin-bottom: 10px;
            animation: glitch 3s infinite alternate;
        }

        .subtitle {
            font-size: 20px;
            color: var(--accent);
            letter-spacing: 5px;
            margin-bottom: 50px;
            opacity: 0.8;
        }

        .menu-btn {
            background: transparent;
            border: 2px solid var(--accent);
            color: var(--accent);
            padding: 15px 40px;
            font-size: 18px;
            letter-spacing: 3px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s;
            text-transform: uppercase;
            position: relative;
            overflow: hidden;
        }

        .menu-btn:hover {
            background: var(--accent);
            color: #000;
            box-shadow: 0 0 20px var(--accent);
        }

        @keyframes glitch {
            0% { text-shadow: 2px 2px 0px #00ffff, -2px -2px 0px #ff00ff; }
            90% { text-shadow: 2px 2px 0px #00ffff, -2px -2px 0px #ff00ff; }
            92% { text-shadow: -2px 2px 0px #00ffff, 2px -2px 0px #ff00ff; transform: translate(2px, 0); }
            94% { text-shadow: 2px -2px 0px #00ffff, -2px 2px 0px #ff00ff; transform: translate(-2px, 0); }
            96% { text-shadow: 0px 0px 0px #00ffff, 0px 0px 0px #ff00ff; transform: translate(0, 0); }
            100% { text-shadow: 2px 2px 0px #00ffff, -2px -2px 0px #ff00ff; }
        }
        /* Cinematic Mode */
        body.cinematic-mode .hud,
        body.cinematic-mode .data-controls,
        body.cinematic-mode #mode-indicator,
        body.cinematic-mode #controls-info {
            display: none !important;
        }
        
        body.cinematic-mode:before,
        body.cinematic-mode:after {
            content: "";
            position: fixed;
            left: 0;
            width: 100%;
            height: 10%;
            background: #000;
            z-index: 5000;
            transition: height 0.5s;
        }
        body.cinematic-mode:before { top: 0; }
        body.cinematic-mode:after { bottom: 0; }

        #cinematic-text {
            position: fixed;
            bottom: 15%;
            width: 100%;
            text-align: center;
            font-family: 'Courier New', monospace;
            font-size: 24px;
            color: #fff;
            text-shadow: 0 0 10px #000;
            opacity: 0;
            transition: opacity 1s;
            z-index: 5001;
            letter-spacing: 5px;
            text-transform: uppercase;
        }
    </style>
</head>
<body>
    <div id="cinematic-text"></div>
    <!-- Loading Screen -->
    <div id="loading">
        <div class="loader"></div>
        <div class="loading-text">SYSTEM INITIALIZATION</div>
    </div>

    <!-- Title Screen -->
    <div id="title-screen">
        <h1 class="title-glitch">ZERO-G STATION BUILDER</h1>
        <div class="subtitle">ORBITAL CONSTRUCTION SIMULATOR</div>
        <div class="start-menu">
            <button class="menu-btn" onclick="startHeroSequence()" style="border-color: #00ff00; color: #00ff00; box-shadow: 0 0 15px rgba(0,255,0,0.3);">‚òÖ HERO SIMULATION ‚òÖ</button>
            <button class="menu-btn" onclick="startGame()">ENTER SIMULATION</button>
            <button class="menu-btn" onclick="showMissionScreen()">TEST FLIGHT MISSION</button>
            <button class="menu-btn" onclick="startTutorialFromMenu()">RUN TRAINING PROGRAM</button>
        </div>
        <div style="margin-top: 50px; font-family: monospace; color: #446688;">v2.1 // SYSTEM READY</div>
    </div>

    <!-- Mission Control Screen -->
    <div id="mission-screen" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,5,10,0.95); z-index:3000; flex-direction:column; align-items:center; justify-content:center;">
        <h1 class="title-glitch" style="font-size:40px">MISSION CONTROL</h1>
        <div class="subtitle">SELECT FLIGHT PROFILE</div>
        
        <div style="display:flex; gap:20px; margin-bottom:30px;">
            <div class="mission-card" onclick="startMission('vostok')">
                <h3>VOSTOK 1 (1961)</h3>
                <p>OBJECTIVE: LOW EARTH ORBIT</p>
                <p>DIFFICULTY: ROOKIE</p>
                <div class="mission-icon">üåç</div>
            </div>
            <div class="mission-card" onclick="startMission('apollo')">
                <h3>APOLLO 11 (1969)</h3>
                <p>OBJECTIVE: LUNAR ORBIT INSERTION</p>
                <p>DIFFICULTY: VETERAN</p>
                <div class="mission-icon">üåë</div>
            </div>
            <div class="mission-card" onclick="startMission('apollo13')">
                <h3>APOLLO 13 (1970)</h3>
                <p>OBJECTIVE: SURVIVAL & RETURN</p>
                <p>DIFFICULTY: EXPERT</p>
                <div class="mission-icon">üí•</div>
            </div>
            <div class="mission-card" onclick="startMission('interstellar')">
                <h3>PROJECT LONGSHOT (2150)</h3>
                <p>OBJECTIVE: ALPHA CENTAURI BURN</p>
                <p>DIFFICULTY: LEGEND</p>
                <div class="mission-icon">‚ú®</div>
            </div>
            <div class="mission-card" onclick="startMission('hail_mary')" style="border-color: #ff3300; box-shadow: 0 0 10px #ff3300;">
                <h3 style="color: #ff3300">PROJECT HAIL MARY</h3>
                <p>OBJECTIVE: TAU CETI (12 LY)</p>
                <p>DIFFICULTY: SUICIDE</p>
                <div class="mission-icon">üï∑Ô∏è</div>
            </div>
        </div>
        
        <button class="menu-btn" onclick="closeMissionScreen()">RETURN TO BUILDER</button>
    </div>

    <!-- Mission Summary Screen -->
    <div id="mission-summary" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,5,10,0.98); z-index:4000; flex-direction:column; align-items:center; justify-content:center;">
        <h1 class="title-glitch" style="font-size:40px; color:#00ff00; text-shadow: 0 0 10px #00ff00;">MISSION ACCOMPLISHED</h1>
        <div class="subtitle" id="summary-subtitle">ARRIVAL CONFIRMED</div>
        
        <div style="display:flex; gap:40px; margin:30px 0;">
            <div style="text-align:center;">
                <div class="stat-label">TOTAL FLIGHT TIME</div>
                <div class="stat-value" id="summary-time" style="font-size:24px;">00:00:00</div>
            </div>
            <div style="text-align:center;">
                <div class="stat-label">DISTANCE TRAVELED</div>
                <div class="stat-value" id="summary-dist" style="font-size:24px;">0 KM</div>
            </div>
            <div style="text-align:center;">
                <div class="stat-label">MAX VELOCITY</div>
                <div class="stat-value" id="summary-vel" style="font-size:24px;">0 KM/S</div>
            </div>
        </div>
        
        <div style="width:600px; height:200px; border:1px solid #333; margin-bottom:30px; position:relative; background:rgba(0,0,0,0.5);">
            <div style="position:absolute; top:10px; left:10px; color:#aaa; font-size:10px;">FLIGHT PROFILE REPLAY</div>
            <canvas id="flight-graph" width="600" height="200"></canvas>
        </div>
        
        <button class="menu-btn" onclick="closeMissionSummary()">RETURN TO BASE</button>
    </div>

    <!-- Flight UI -->
    <div id="flight-ui" style="display:none;">
        <!-- Top Flight Status Bar -->
        <div class="hud" style="top:20px; left:50%; transform:translateX(-50%); display:flex; gap:20px; z-index: 1000; border-radius: 0 0 10px 10px; border-top: none;">
            <div class="stat-value" id="mission-timer">T+ 00:00:00</div>
            <div class="stat-value" id="mission-vel">VEL: 0 m/s</div>
            <div class="stat-value" id="mission-alt">ALT: 0 km</div>
            <div class="stat-value" id="mission-fuel">FUEL: 100%</div>
            <div class="stat-value" id="mission-eta" style="color:var(--accent)">ETA: N/A</div>
            <div class="stat-value" id="mission-delta" style="color:#ff3300; display:none;">ŒîV COST: +0 m/s</div>
        </div>
        
        <!-- Autopilot Controls (Moved to Bottom Right Stack) -->
        <div style="position:fixed; bottom:150px; right:20px; text-align:right;">
            <button id="autopilot-btn" class="menu-btn" style="font-size:12px; padding:5px 20px; border-color:#00ff00; color:#00ff00; margin:0;" onclick="toggleAutopilot()">AUTOPILOT: ON</button>
        </div>
        
        <!-- Progress Bar (Moved below Top HUD) -->
        <div id="mission-progress-container" style="position:fixed; top:75px; left:50%; transform:translateX(-50%); width:400px; height:4px; background:rgba(255,255,255,0.1); border-radius:2px; overflow:hidden;">
            <div id="mission-progress-bar" style="width:0%; height:100%; background:var(--accent); box-shadow:0 0 10px var(--accent);"></div>
        </div>

        <!-- Camera Controls (Moved to Top Left under Comms or Top Right under Timeline) -->
        <!-- Let's put it Top Right, but Timeline is there. Let's put it Top Left under Comms? -->
        <!-- Or just keep it Top Right but adjust position. -->
        <div class="hud" style="top:20px; right:20px; text-align:right;">
            <div class="hud-header">VISUAL FEED</div>
            <div class="stat-value" id="cam-mode-display">CHASE CAM</div>
            <button class="menu-btn" style="font-size:12px; padding:5px 10px; margin:5px 0;" onclick="cycleCamera()">SWITCH VIEW [C]</button>
            <button class="menu-btn" style="font-size:12px; padding:5px 10px; margin:5px 0; background: #440088; border-color: #aa00ff;" onclick="toggleMapMode()">SYSTEM MAP [M]</button>
        </div>

        <!-- Comms Panel (Top Left) -->
        <div class="hud" style="top:20px; left:20px; width:280px;">
            <div class="hud-header">COMMS LINK</div>
            <div class="stat-row"><span class="stat-label">STATUS</span><span class="stat-value" id="comms-status" style="color:#00ff00">CONNECTED</span></div>
            <div class="stat-row"><span class="stat-label">ONE-WAY DELAY</span><span class="stat-value" id="light-lag">0.00s</span></div>
            <div class="stat-row"><span class="stat-label">RELATIVITY (Œ≥)</span><span class="stat-value" id="lorentz">1.000000</span></div>
            <div id="comms-log" style="height:100px; overflow-y:auto; font-size:10px; margin-top:10px; border-top:1px solid #333; padding-top:5px; font-family:monospace; color:#aaa;">
                > LINK ESTABLISHED...
            </div>
            <button class="menu-btn" style="width:100%; margin:10px 0 0 0; font-size:12px; padding:5px;" onclick="pingEarth()">PING MISSION CONTROL</button>
        </div>
        
        <!-- Time Warp (Moved to Bottom Right Stack) -->
        <!-- Will be handled by JS update, but removing the placeholder here if any -->
        
        <div id="navball" style="position:fixed; bottom:20px; left:20px; width:150px; height:150px; border-radius:50%; border:2px solid var(--accent); background:rgba(0,0,0,0.5); overflow:hidden;">
            <div id="navball-horizon" style="width:100%; height:100%; background:linear-gradient(#00aaff 50%, #885522 50%); transform:rotate(0deg) translateY(0%); transition:transform 0.1s;"></div>
            <div style="position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); color:var(--accent); font-size:24px;">+</div>
        </div>
    </div>

    <style>
        .mission-card {
            background: rgba(0, 20, 40, 0.8);
            border: 1px solid var(--accent);
            padding: 20px;
            width: 250px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        .mission-card:hover {
            background: rgba(0, 40, 80, 0.9);
            transform: scale(1.05);
            box-shadow: 0 0 20px var(--accent);
        }
        .mission-icon {
            font-size: 50px;
            margin-top: 15px;
        }
        .nav-arrow {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            font-size: 40px;
            color: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            padding: 20px;
            user-select: none;
            z-index: 100;
            transition: color 0.2s, background 0.2s;
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
        }
        .nav-arrow:hover {
            color: #fff;
            background: rgba(0,0,0,0.5);
        }
        .nav-arrow.left { left: 20px; }
        .nav-arrow.right { right: 20px; }
    </style>

    <!-- Notification -->
    <div id="notification">System Ready</div>

    <!-- Target Navigation -->
    <div id="target-nav-left" class="nav-arrow left" onclick="prevTarget()">‚ùÆ</div>
    <div id="target-nav-right" class="nav-arrow right" onclick="nextTarget()">‚ùØ</div>

    <!-- Launch Overlay -->
    <div id="launch-overlay" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 200; flex-direction: column; justify-content: center; align-items: center;">
        <h1 id="launch-title" style="font-size: 40px; color: #fff; text-shadow: 0 0 20px #00ffff; margin-bottom: 10px;">MISSION READY</h1>
        <div id="launch-desc" style="font-size: 18px; color: #aaa; margin-bottom: 30px; max-width: 600px; text-align: center;"></div>
        <button onclick="initiateLaunch()" style="font-size: 24px; padding: 15px 40px; background: rgba(0, 255, 255, 0.2); border: 2px solid #00ffff; color: #fff; cursor: pointer; transition: all 0.2s;">INITIATE LAUNCH</button>
    </div>

    <!-- Data Controls -->
    <div class="data-controls">
        <button class="icon-btn" onclick="exportStation()" title="Save/Export" aria-label="Save or export station">üíæ</button>
        <button class="icon-btn" onclick="document.getElementById('importFile').click()" title="Load/Import" aria-label="Load or import station">üìÇ</button>
        <button class="icon-btn" onclick="clearStation()" title="Reset" aria-label="Reset and clear station">üóëÔ∏è</button>
        <button class="icon-btn" onclick="startTutorial()" title="Start Tutorial" aria-label="Start tutorial" style="color: #00ff00;">üéì</button>
        <button class="icon-btn" onclick="toggleSound()" title="Toggle Sound" aria-label="Toggle sound" id="sound-btn">üîä</button>
        <select id="presetSelect" onchange="loadPreset(this.value)" style="background: rgba(0,20,40,0.8); color: #00ffff; border: 1px solid #00ffff; padding: 5px; border-radius: 5px; margin-left: 10px;">
            <option value="">Load Blueprint...</option>
            <option value="default">Standard Outpost</option>
            <option value="sputnik_future">Sputnik-X (2099)</option>
            <option value="sputnik_1">Sputnik 1 (1957)</option>
            <option value="shuttle">Space Shuttle (Atlantis)</option>
            <option value="iss_early">ISS (Alpha Phase)</option>
            <option value="iss_late">ISS (Omega Phase)</option>
            <option value="hail_mary">Hail Mary (Astrophage Drive)</option>
        </select>
        <input type="file" id="importFile" accept=".json" onchange="importStation(event)" style="display:none">
    </div>

    <!-- HUD Elements -->
    <div id="stats" class="hud">
        <div class="hud-header">Station Status</div>
        <div class="stat-row"><span class="stat-label">Modules</span><span class="stat-value" id="module-count">0</span></div>
        <div class="stat-row"><span class="stat-label">Net Power</span><span class="stat-value" id="power-status">0 MW</span></div>
        <div class="stat-row"><span class="stat-label">Crew Cap</span><span class="stat-value" id="crew-capacity">0</span></div>
        <div class="stat-row"><span class="stat-label">Solar Eff</span><span class="stat-value" id="solar-efficiency">0%</span></div>
        <div class="stat-row"><span class="stat-label">Integrity</span><span class="stat-value" style="color: #00ff00">100%</span></div>
    </div>

    <div id="target-controls" class="hud" style="display: none; bottom: 20px; right: 20px; width: 300px; text-align: center;">
        <div class="hud-header">Target Selection</div>
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <button onclick="cycleTarget(-1)" style="background: rgba(0,255,255,0.2); border: 1px solid #00ffff; color: white; padding: 10px; cursor: pointer; font-size: 18px;">‚óÄ</button>
            <div id="target-name" style="font-size: 16px; font-weight: bold; color: #00ffff;">PLAYER SHIP</div>
            <button onclick="cycleTarget(1)" style="background: rgba(0,255,255,0.2); border: 1px solid #00ffff; color: white; padding: 10px; cursor: pointer; font-size: 18px;">‚ñ∂</button>
        </div>
    </div>

    <div id="mission-timeline" class="hud" style="display: none; top: 150px; right: 20px; width: 250px; text-align: right;">
        <div class="hud-header">Mission Timeline</div>
        <div id="timeline-bar-container" style="width: 100%; height: 20px; background: rgba(255,255,255,0.1); margin-bottom: 10px; position: relative; cursor: pointer;">
            <div id="timeline-progress" style="position: absolute; top: 0; left: 0; height: 100%; width: 0%; background: var(--accent); opacity: 0.5;"></div>
            <!-- Markers will be injected here -->
        </div>
        <div id="next-event-title" style="color: #00ffff; font-weight: bold; margin-bottom: 5px;">--</div>
        <div id="next-event-desc" style="font-size: 12px; color: #aaa; margin-bottom: 10px;">--</div>
        <button onclick="skipToNextEvent()" style="background: rgba(0,255,255,0.2); border: 1px solid #00ffff; color: white; padding: 5px 10px; cursor: pointer; width: 100%;">SKIP TO NEXT EVENT ‚ñ∂</button>
    </div>

    <div id="telescope-controls" class="hud" style="display: none; bottom: 100px; right: 20px; width: 200px;">
        <div class="hud-header">Telescope Zoom</div>
        <input type="range" id="telescope-scale" min="1" max="1000" value="100" style="width: 100%">
    </div>

    <div id="controls-info" class="hud">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <div class="hud-header" style="margin-bottom: 0;">Controls</div>
            <button id="cam-toggle-btn" onclick="toggleBuilderCamera()" style="font-size: 10px; padding: 2px 5px; background: #004488; border: 1px solid #00ffff; color: white; cursor: pointer;">MODE: ORBIT</button>
        </div>
        
        <div id="controls-orbit">
            <div style="margin-bottom: 5px"><span class="key-hint">L-DRAG</span> Rotate View</div>
            <div style="margin-bottom: 5px"><span class="key-hint">R-DRAG</span> Pan View</div>
            <div style="margin-bottom: 5px"><span class="key-hint">SCROLL</span> Zoom</div>
        </div>
        
        <div id="controls-fly" style="display: none;">
            <div style="margin-bottom: 5px"><span class="key-hint">W</span><span class="key-hint">S</span> Thrust Fwd/Back</div>
            <div style="margin-bottom: 5px"><span class="key-hint">A</span><span class="key-hint">D</span> Yaw Left/Right</div>
            <div style="margin-bottom: 5px"><span class="key-hint">Q</span><span class="key-hint">E</span> Vertical Thrust</div>
            <div style="margin-bottom: 5px"><span class="key-hint">SHIFT</span> Boost Engines</div>
            <div style="margin-bottom: 15px"><span class="key-hint">MOUSE</span> Pitch/Yaw</div>
        </div>
        
        <div class="hud-header" style="margin-top: 15px;">Build Controls</div>
        <div style="margin-bottom: 5px"><span class="key-hint">B</span> Toggle Build Mode</div>
        <div style="margin-bottom: 5px"><span class="key-hint">R</span> Rotate Module</div>
        <div style="margin-bottom: 5px"><span class="key-hint">L-CLICK</span> Place</div>
        <div style="margin-bottom: 5px"><span class="key-hint">DEL</span> Remove</div>
    </div>

    <div id="build-menu" style="display: none;">
        <!-- Populated by JS -->
    </div>

    <div id="orbital-info" class="hud">
        <div class="hud-header">Telemetry</div>
        <div class="stat-row"><span class="stat-label">ALT</span><span class="stat-value" id="altitude">450 km</span></div>
        <div class="stat-row"><span class="stat-label">VEL</span><span class="stat-value">7.66 km/s</span></div>
        <div class="stat-row"><span class="stat-label">INC</span><span class="stat-value">51.6¬∞</span></div>
    </div>

    <div id="mode-indicator">FLIGHT MODE</div>

    <canvas id="canvas" role="application" aria-label="3D space station builder - use mouse to rotate, scroll to zoom, click modules to build"></canvas>

    <!-- Three.js & Post Processing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/satellite.js/4.0.0/satellite.min.js"></script>

    <script>
        // --- Configuration ---
        const APP_NAME = 'zero-g-station-builder-v2';
        const SNAP_GRID = 2; // Finer grid for better detail
        
        // --- State ---
        let scene, camera, renderer, composer;
        let orbitControls, flyControls;
        let planet, rings, sun, stars, planetLight;
        let moon, mars, jupiter;
        let station = [];
        let activeBodies = []; // N-Body System
        const G_KM = 6.67430e-20; // G in km^3/kg/s^2
        let ghostModule = null;
        let buildMode = false;
        let selectedModuleType = 'habitat';
        let soundEnabled = true;
        
        // Input State
        const keys = { w: false, a: false, s: false, d: false, q: false, e: false, shift: false };
        const mouse = new THREE.Vector2();
        let cameraRotation = { phi: 0, theta: 0 };
        
        // Builder Camera State
        let builderCameraMode = 'ORBIT'; // 'ORBIT' or 'FLY'
        // Removed manual orbit variables in favor of OrbitControls

        function toggleBuilderCamera() {
            builderCameraMode = builderCameraMode === 'ORBIT' ? 'FLY' : 'ORBIT';
            const btn = document.getElementById('cam-toggle-btn');
            const orbitControlsDiv = document.getElementById('controls-orbit');
            const flyControlsDiv = document.getElementById('controls-fly');
            
            if(builderCameraMode === 'ORBIT') {
                btn.textContent = "MODE: ORBIT";
                orbitControlsDiv.style.display = 'block';
                flyControlsDiv.style.display = 'none';
                
                // Enable Orbit, Disable Fly
                orbitControls.enabled = true;
                if(flyControls.isLocked) flyControls.unlock();
                
            } else {
                btn.textContent = "MODE: FLY";
                orbitControlsDiv.style.display = 'none';
                flyControlsDiv.style.display = 'block';
                
                // Disable Orbit, Enable Fly
                orbitControls.enabled = false;
                flyControls.lock();
            }
        }

        // Station Data
        let stationData = {
            modules: [],
            stats: { power: 0, crew: 0, efficiency: 0 }
        };

        // --- Module Definitions ---
        const MODULES = {
            habitat: {
                name: "Habitat Core",
                icon: "üè†",
                cost: "100k",
                power: -5,
                crew: 4,
                geometry: () => {
                    const g = new THREE.CylinderGeometry(2, 2, 6, 8);
                    g.rotateZ(Math.PI / 2);
                    return g;
                },
                material: new THREE.MeshStandardMaterial({ color: 0xeeeeff, roughness: 0.2, metalness: 0.8 })
            },
            connector: {
                name: "Corridor",
                icon: "‚ûñ",
                cost: "20k",
                power: -1,
                crew: 0,
                geometry: () => {
                    const g = new THREE.BoxGeometry(4, 1.5, 1.5);
                    return g;
                },
                material: new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.5, metalness: 0.9 })
            },
            solar: {
                name: "Solar Array",
                icon: "‚òÄÔ∏è",
                cost: "50k",
                power: 25,
                crew: 0,
                geometry: () => {
                    const g = new THREE.Group();
                    const panel = new THREE.Mesh(
                        new THREE.BoxGeometry(10, 0.2, 4),
                        new THREE.MeshStandardMaterial({ color: 0x111133, roughness: 0.2, metalness: 0.5, emissive: 0x000022 })
                    );
                    const arm = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.2, 0.2, 2),
                        new THREE.MeshStandardMaterial({ color: 0x888888 })
                    );
                    arm.rotation.z = Math.PI / 2;
                    arm.position.x = -5;
                    // We return a group, but for collision/raycast we need a mesh. 
                    // For simplicity in this version, we'll use a simple box for the main geometry
                    return new THREE.BoxGeometry(10, 0.5, 4); 
                },
                material: new THREE.MeshStandardMaterial({ color: 0x2244aa, roughness: 0.1, metalness: 0.6, emissive: 0x001133 })
            },
            reactor: {
                name: "Fusion Core",
                icon: "‚ò¢Ô∏è",
                cost: "500k",
                power: 100,
                crew: 2,
                geometry: () => new THREE.SphereGeometry(2.5, 16, 16),
                material: new THREE.MeshStandardMaterial({ color: 0xff3300, roughness: 0.4, metalness: 0.8, emissive: 0x330000 })
            },
            dock: {
                name: "Docking Port",
                icon: "‚öì",
                cost: "150k",
                power: -10,
                crew: 0,
                geometry: () => new THREE.TorusGeometry(2, 0.5, 8, 16),
                material: new THREE.MeshStandardMaterial({ color: 0xffaa00, roughness: 0.3, metalness: 1.0 })
            },
            lab: {
                name: "Science Lab",
                icon: "üî¨",
                cost: "300k",
                power: -15,
                crew: 6,
                geometry: () => new THREE.BoxGeometry(5, 3, 5),
                material: new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.1, metalness: 0.5 })
            },
            dome: {
                name: "Obs. Dome",
                icon: "üî≠",
                cost: "200k",
                power: -5,
                crew: 2,
                geometry: () => {
                    const g = new THREE.SphereGeometry(3, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
                    return g;
                },
                material: new THREE.MeshStandardMaterial({ color: 0x88ccff, roughness: 0, metalness: 0, transparent: true, opacity: 0.4 })
            },
            // --- Custom Shuttle Parts (Scaled 1 unit = 1 meter) ---
            // Real Shuttle Orbiter: Length ~37m, Wingspan ~24m, Height ~17m (on gear), Fuselage Dia ~5m
            shuttle_full: {
                name: "Space Shuttle Orbiter",
                icon: "üöÄ",
                cost: "0",
                power: 0,
                crew: 7,
                geometry: () => {
                    // Use the external procedural generator if available, else fallback
                    if(window.createSpaceShuttleGeometry) {
                        // We need to return a Geometry, but createSpaceShuttleGeometry returns a Group (Mesh hierarchy).
                        // The builder expects a geometry to create a single mesh usually?
                        // Wait, the builder code does: const mesh = new THREE.Mesh(moduleType.geometry(), moduleType.material);
                        // If we return a Group, THREE.Mesh constructor will fail.
                        // We need to modify the builder to handle Groups or merge the geometry.
                        
                        // For now, let's return a dummy geometry and we'll handle the visual replacement in the build function?
                        // OR, we can merge all geometries in the generator into one BufferGeometry.
                        // But we have different materials.
                        
                        // Let's hack it: Return a BoxGeometry (invisible) and attach the Group as a child.
                        const dummy = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                        dummy.userData = { isComplexModel: true, generator: window.createSpaceShuttleGeometry };
                        return dummy;
                    }
                    return new THREE.BoxGeometry(10, 4, 4);
                },
                material: new THREE.MeshStandardMaterial({ visible: false }) // Invisible container
            },
            shuttle_hull: {
                name: "Shuttle Hull",
                icon: "üöÄ",
                cost: "0",
                power: 0,
                crew: 0,
                geometry: () => new THREE.CylinderGeometry(2.5, 2.5, 18, 16), // 18m long cargo bay section
                material: new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3, metalness: 0.2 })
            },
            shuttle_nose: {
                name: "Shuttle Nose",
                icon: "üëÉ",
                cost: "0",
                power: 0,
                crew: 0,
                geometry: () => new THREE.CylinderGeometry(0.5, 2.5, 9, 16), // ~9m nose section
                material: new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.3, metalness: 0.2 })
            },
            shuttle_wing: {
                name: "Shuttle Wing",
                icon: "ü¶Ö",
                cost: "0",
                power: 0,
                crew: 0,
                geometry: () => {
                    const shape = new THREE.Shape();
                    // Double Delta Wing approximation
                    // Root chord ~17m?
                    // Span ~12m per side
                    shape.moveTo(0,0);
                    shape.lineTo(12, -14); // Wing tip back
                    shape.lineTo(12, -10); // Wing tip front
                    shape.lineTo(0, 5); // Root front
                    shape.lineTo(0,0);
                    return new THREE.ExtrudeGeometry(shape, {depth: 1.0, bevelEnabled: false});
                },
                material: new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3, metalness: 0.2 })
            },
            shuttle_tail: {
                name: "Shuttle Tail",
                icon: "ü¶à",
                cost: "0",
                power: 0,
                crew: 0,
                geometry: () => {
                    const shape = new THREE.Shape();
                    // Height ~8m
                    shape.moveTo(0,0);
                    shape.lineTo(0, 8);
                    shape.lineTo(5, 0);
                    shape.lineTo(0,0);
                    return new THREE.ExtrudeGeometry(shape, {depth: 1.0, bevelEnabled: false});
                },
                material: new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3, metalness: 0.2 })
            },
            shuttle_engine: {
                name: "SSME",
                icon: "üî•",
                cost: "0",
                power: 0,
                crew: 0,
                geometry: () => new THREE.CylinderGeometry(1.2, 0.8, 3.0, 16),
                material: new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.7, metalness: 0.5, emissive: 0x221100 })
            }
        };

        // --- Presets ---
        const PRESETS = {
            default: [
                {type: "habitat", pos: [0, 0, 0], rot: [0, 0, 0]},
                {type: "connector", pos: [0, 0, 6], rot: [0, 0, 0]},
                {type: "connector", pos: [0, 0, -6], rot: [0, 0, 0]},
                {type: "reactor", pos: [0, 0, -10], rot: [0, 0, 0]},
                {type: "solar", pos: [10, 0, 6], rot: [0, 0, 0]},
                {type: "solar", pos: [-10, 0, 6], rot: [0, 0, 0]},
                {type: "dock", pos: [0, 0, 10], rot: [0, 0, 0]},
                {type: "dome", pos: [0, 4, 0], rot: [0, 0, 0]},
                {type: "lab", pos: [0, -4, 0], rot: [0, 0, 0]}
            ],
            sputnik_future: [
                // Core
                {type: "reactor", pos: [0, 0, 0], rot: [0, 0, 0]},
                {type: "reactor", pos: [4, 0, 0], rot: [0, 0, 0]},
                {type: "reactor", pos: [-4, 0, 0], rot: [0, 0, 0]},
                {type: "reactor", pos: [0, 4, 0], rot: [0, 0, 0]},
                {type: "reactor", pos: [0, -4, 0], rot: [0, 0, 0]},
                {type: "reactor", pos: [0, 0, 4], rot: [0, 0, 0]},
                {type: "reactor", pos: [0, 0, -4], rot: [0, 0, 0]},
                // Spikes (Antennas)
                {type: "connector", pos: [10, 10, 10], rot: [0.7, 0.7, 0]},
                {type: "connector", pos: [-10, 10, 10], rot: [0.7, -0.7, 0]},
                {type: "connector", pos: [10, -10, 10], rot: [-0.7, 0.7, 0]},
                {type: "connector", pos: [-10, -10, 10], rot: [-0.7, -0.7, 0]},
                // Rings
                {type: "dock", pos: [12, 0, 0], rot: [0, 1.57, 0]},
                {type: "dock", pos: [-12, 0, 0], rot: [0, 1.57, 0]},
                {type: "dock", pos: [0, 12, 0], rot: [1.57, 0, 0]},
                {type: "dock", pos: [0, -12, 0], rot: [1.57, 0, 0]},
                // Surveillance
                {type: "dome", pos: [0, 0, 10], rot: [0, 0, 0]},
                {type: "lab", pos: [0, 0, -10], rot: [0, 0, 0]}
            ],
            sputnik_1: [
                // Simple Sphere
                {type: "habitat", pos: [0, 0, 0], rot: [0, 0, 0]},
                // Antennas (Connectors angled back)
                {type: "connector", pos: [2, 2, -2], rot: [0.5, 0.5, 0]},
                {type: "connector", pos: [-2, 2, -2], rot: [0.5, -0.5, 0]},
                {type: "connector", pos: [2, -2, -2], rot: [-0.5, 0.5, 0]},
                {type: "connector", pos: [-2, -2, -2], rot: [-0.5, -0.5, 0]}
            ],
            shuttle: [
                // Main Hull (18m long)
                {type: "shuttle_hull", pos: [0, 0, 0], rot: [1.57, 0, 0]},
                
                // Nose Section (9m long)
                // Hull ends at +9 (half of 18). Nose starts at +9. Center of nose is +9 + 4.5 = 13.5
                {type: "shuttle_nose", pos: [0, 0, 13.5], rot: [1.57, 0, 0]},
                {type: "dome", pos: [0, 1.0, 12], rot: [0, 0, 0]}, // Cockpit Window
                
                // Wings
                // Root starts around +5 relative to wing center.
                // We want wing root to start near front of cargo bay.
                // Cargo bay front is +9.
                // Wing shape: Root front is (0,5).
                // If we place wing at z=0, root front is at z=5.
                // We want root front at z=5?
                // Let's place wings at z=0.
                
                // Right Wing
                {type: "shuttle_wing", pos: [2.2, -1, 2], rot: [1.57, 0, 0]}, 
                
                // Left Wing (Rotated 180 X then 180 Y to mirror)
                {type: "shuttle_wing", pos: [-2.2, -1, 2], rot: [1.57, 3.14, 0]},
                
                // Vertical Tail
                // Hull ends at -9.
                {type: "shuttle_tail", pos: [0, 2.5, -7], rot: [0, 0, 0]},
                
                // Engines
                // Hull ends at -9.
                {type: "shuttle_engine", pos: [0, 1.5, -10], rot: [1.57, 0, 0]}, // Top
                {type: "shuttle_engine", pos: [1.2, -1, -10], rot: [1.57, 0, 0]}, // Right
                {type: "shuttle_engine", pos: [-1.2, -1, -10], rot: [1.57, 0, 0]}, // Left
                
                // OMS Pods
                {type: "connector", pos: [2, 0.5, -8], rot: [0, 0, 0]},
                {type: "connector", pos: [-2, 0.5, -8], rot: [0, 0, 0]}
            ],
            iss_early: [
                {type: "habitat", pos: [0, 0, 0], rot: [0, 0, 0]}, // Zarya
                {type: "connector", pos: [0, 0, 6], rot: [0, 0, 0]}, // Unity
                {type: "habitat", pos: [0, 0, -6], rot: [0, 0, 0]}, // Zvezda
                {type: "solar", pos: [0, 5, -6], rot: [0, 0, 1.57]},
                {type: "solar", pos: [0, -5, -6], rot: [0, 0, 1.57]},
                {type: "dock", pos: [0, 0, 10], rot: [0, 0, 0]}
            ],
            iss_late: [
                // Main Truss
                {type: "connector", pos: [0, 0, 0], rot: [0, 0, 0]},
                {type: "connector", pos: [6, 0, 0], rot: [0, 0, 0]},
                {type: "connector", pos: [-6, 0, 0], rot: [0, 0, 0]},
                {type: "connector", pos: [12, 0, 0], rot: [0, 0, 0]},
                {type: "connector", pos: [-12, 0, 0], rot: [0, 0, 0]},
                {type: "connector", pos: [18, 0, 0], rot: [0, 0, 0]},
                {type: "connector", pos: [-18, 0, 0], rot: [0, 0, 0]},
                // Solar Arrays (Massive)
                {type: "solar", pos: [24, 0, 5], rot: [0, 0, 0]},
                {type: "solar", pos: [24, 0, -5], rot: [0, 0, 0]},
                {type: "solar", pos: [-24, 0, 5], rot: [0, 0, 0]},
                {type: "solar", pos: [-24, 0, -5], rot: [0, 0, 0]},
                {type: "solar", pos: [30, 0, 5], rot: [0, 0, 0]},
                {type: "solar", pos: [30, 0, -5], rot: [0, 0, 0]},
                {type: "solar", pos: [-30, 0, 5], rot: [0, 0, 0]},
                {type: "solar", pos: [-30, 0, -5], rot: [0, 0, 0]},
                // Modules
                {type: "habitat", pos: [0, -5, 0], rot: [1.57, 0, 0]}, // Destiny
                {type: "lab", pos: [0, -10, 0], rot: [1.57, 0, 0]}, // Kibo
                {type: "lab", pos: [4, -5, 0], rot: [1.57, 0, 0]}, // Columbus
                {type: "habitat", pos: [0, -5, 6], rot: [0, 0, 0]}, // Harmony
                {type: "dock", pos: [0, -5, 10], rot: [0, 0, 0]},
                {type: "dome", pos: [0, -8, 2], rot: [0, 0, 0]} // Cupola
            ],
            hail_mary: [
                // Spin Drives (Astrophage)
                {type: "reactor", pos: [0, 0, -15], rot: [0, 0, 0]},
                {type: "reactor", pos: [2, 2, -15], rot: [0, 0, 0]},
                {type: "reactor", pos: [-2, -2, -15], rot: [0, 0, 0]},
                // Fuel Tanks
                {type: "connector", pos: [0, 0, -10], rot: [0, 0, 0]},
                {type: "connector", pos: [0, 0, -6], rot: [0, 0, 0]},
                {type: "connector", pos: [0, 0, -2], rot: [0, 0, 0]},
                // Centrifuge / Crew Area
                {type: "habitat", pos: [0, 0, 2], rot: [0, 0, 0]},
                {type: "lab", pos: [0, 0, 6], rot: [0, 0, 0]},
                // Nose Cone
                {type: "dome", pos: [0, 0, 10], rot: [0, 0, 0]},
                // Beetle Monitors (External)
                {type: "dock", pos: [3, 0, 4], rot: [0, 1.57, 0]},
                {type: "dock", pos: [-3, 0, 4], rot: [0, -1.57, 0]}
            ]
        };

        // --- Tutorial System ---
        let tutorialActive = false;
        let currentLookTarget = new THREE.Vector3(0, 0, 0);
        let tutorialTimer = null;

        const TUTORIAL_STEPS = [
            {
                msg: "WELCOME COMMANDER. INITIALIZING STATION OVERVIEW.",
                pos: new THREE.Vector3(50, 40, 50),
                look: new THREE.Vector3(0, 0, 0),
                delay: 4000
            },
            {
                msg: "HABITAT CORE (CENTER): MAINTAINS LIFE SUPPORT.",
                pos: new THREE.Vector3(8, 4, 8),
                look: new THREE.Vector3(0, 0, 0),
                delay: 5000
            },
            {
                msg: "SOLAR ARRAYS: CRITICAL FOR POWER GENERATION.",
                pos: new THREE.Vector3(15, 5, 15),
                look: new THREE.Vector3(10, 0, 6),
                delay: 5000
            },
            {
                msg: "FUSION REACTOR: HEAVY INDUSTRY POWER SOURCE.",
                pos: new THREE.Vector3(-5, 5, -15),
                look: new THREE.Vector3(0, 0, -10),
                delay: 5000
            },
            {
                msg: "OBSERVATION DOME: CREW MORALE & NAVIGATION.",
                pos: new THREE.Vector3(0, 10, 5),
                look: new THREE.Vector3(0, 4, 0),
                delay: 5000
            },
            {
                msg: "TUTORIAL COMPLETE. MANUAL CONTROL ENGAGED.",
                pos: new THREE.Vector3(30, 20, 30),
                look: new THREE.Vector3(0, 0, 0),
                delay: 3000
            }
        ];

        function startTutorial() {
            if(station.length > 0 && !confirm("Start Training? This will reset to the Standard Outpost.")) return;
            
            // Force load default for tutorial
            station.forEach(m => scene.remove(m));
            station = [];
            buildFromData(PRESETS['default']);
            
            tutorialActive = true;
            runTutorialStep(0);
        }

        function runTutorialStep(index) {
            if(index >= TUTORIAL_STEPS.length) {
                tutorialActive = false;
                showNotification("SYSTEMS ONLINE");
                return;
            }

            const step = TUTORIAL_STEPS[index];
            showNotification(step.msg);
            
            // Set targets for animation loop
            // We don't snap, we let the animate loop lerp to these
            window.tutorialTargetPos = step.pos;
            window.tutorialTargetLook = step.look;

            tutorialTimer = setTimeout(() => runTutorialStep(index + 1), step.delay);
        }

        // --- Audio System ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(type) {
            if (!soundEnabled || audioCtx.state === 'suspended') {
                audioCtx.resume();
                if (!soundEnabled) return;
            }
            
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            const now = audioCtx.currentTime;
            
            if (type === 'hover') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.exponentialRampToValueAtTime(600, now + 0.05);
                gain.gain.setValueAtTime(0.05, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                osc.start(now);
                osc.stop(now + 0.05);
            } else if (type === 'place') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.exponentialRampToValueAtTime(50, now + 0.2);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                osc.start(now);
                osc.stop(now + 0.2);
            } else if (type === 'error') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.linearRampToValueAtTime(50, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0.001, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            }
        }

        let realSatellites = [];
        let satMeshes = [];
        let currentTargetIndex = -1; // -1 = Player Station

        // Fetch TLEs (Disabled due to CORS/403 - Using hardcoded list instead)
        function fetchSatellites() {
            // Fallback to hardcoded list if fetch fails or is disabled
            console.log("Using internal satellite database.");
            // We already have REAL_SATELLITES populated manually.
            // Just ensure createRealSatellites is called in init/setup.
        }

        function createSatelliteMeshes() {
            // Materials - Use MeshBasicMaterial for better performance/visibility if lighting is tricky
            // But user reported 'emissive' error on MeshBasicMaterial.
            // MeshBasicMaterial DOES NOT support emissive.
            // We should use MeshStandardMaterial or MeshLambertMaterial if we want emissive.
            // OR remove emissive from Basic.
            
            const bodyMat = new THREE.MeshStandardMaterial({color: 0xcccccc, roughness: 0.4, metalness: 0.6});
            const panelMat = new THREE.MeshStandardMaterial({color: 0x3366ff, roughness: 0.2, metalness: 0.8, emissive: 0x112244});
            const goldMat = new THREE.MeshStandardMaterial({color: 0xffaa00, roughness: 0.3, metalness: 0.9});
            
            // This function was for the fetched satellites.
            // We are now using createRealSatellites() which uses the hardcoded list.
            // Let's merge them or just use createRealSatellites.
        }

        function createSatelliteModel(name, bodyMat, panelMat, goldMat) {
            const group = new THREE.Group();
            const n = name.toUpperCase();
            
            if (n.includes("ISS") || n.includes("ZARYA")) {
                // ISS Approximation
                // Main Truss
                const truss = new THREE.Mesh(new THREE.BoxGeometry(10, 1, 1), bodyMat);
                group.add(truss);
                
                // Solar Arrays (8 large pairs)
                const panelGeo = new THREE.BoxGeometry(2, 8, 0.1);
                for(let x of [-4, -2, 2, 4]) {
                    const p1 = new THREE.Mesh(panelGeo, goldMat);
                    p1.position.set(x, 0, 0);
                    group.add(p1);
                }
                
                // Modules (Central cluster)
                const modules = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 6, 8), bodyMat);
                modules.rotation.x = Math.PI/2;
                modules.rotation.z = Math.PI/2;
                group.add(modules);
                
            } else if (n.includes("TIANGONG") || n.includes("CSS")) {
                // Tiangong (T-Shape)
                const core = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 8, 16), bodyMat);
                core.rotation.z = Math.PI/2;
                group.add(core);
                
                // Panels
                const panel = new THREE.Mesh(new THREE.BoxGeometry(2, 6, 0.1), panelMat);
                panel.position.set(-3, 0, 0);
                group.add(panel);
                const panel2 = panel.clone();
                panel2.position.set(3, 0, 0);
                group.add(panel2);
                
            } else if (n.includes("HUBBLE") || n.includes("HST")) {
                // Hubble Telescope
                const body = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 5, 16), bodyMat); // Silver body
                group.add(body);
                
                // Aperture door
                const door = new THREE.Mesh(new THREE.CylinderGeometry(1.6, 1.6, 1, 16, 1, true), bodyMat);
                door.position.y = 2.5;
                group.add(door);
                
                // Panels
                const panel = new THREE.Mesh(new THREE.BoxGeometry(4, 1.5, 0.1), panelMat);
                panel.position.set(0, 0, 0);
                group.add(panel);
                
            } else {
                // Generic Satellite
                // Box Body
                const body = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), bodyMat);
                group.add(body);
                
                // Two Panels
                const panelGeo = new THREE.BoxGeometry(6, 1.5, 0.1);
                const panels = new THREE.Mesh(panelGeo, panelMat);
                group.add(panels);
                
                // Dish?
                if(Math.random() > 0.5) {
                    const dish = new THREE.Mesh(new THREE.ConeGeometry(1, 0.5, 16, 1, true), bodyMat);
                    dish.position.y = 1.5;
                    dish.rotation.x = Math.PI;
                    group.add(dish);
                }
            }
            
            return group;
        }

        function updateRealSatellites() {
            if(satMeshes.length === 0) return;
            
            const now = new Date();
            // We need to map ECI coordinates to our scene.
            // In our scene:
            // Station is at (0,0,0).
            // Earth is at (0, -R - 400km, 0).
            // So Earth Center in Scene is (0, -6771000, 0).
            // ECI Z-axis is Earth's rotation axis (North).
            // In our scene, Earth is rotated.
            // This is complex to map perfectly without a full orbital frame.
            // Simplified approach:
            // 1. Calculate Sat position in ECI (km).
            // 2. Convert to Scene units (meters).
            // 3. Apply offset relative to Earth Center.
            // 4. Rotate to match Earth's orientation in scene.
            
            const earthCenter = planet.position.clone();
            
            satMeshes.forEach(mesh => {
                const positionAndVelocity = satellite.propagate(mesh.userData.satrec, now);
                const positionEci = positionAndVelocity.position;
                
                if(positionEci) {
                    // ECI is in km. Convert to meters.
                    const x = positionEci.x * 1000;
                    const y = positionEci.y * 1000;
                    const z = positionEci.z * 1000;
                    
                    // Map ECI (X,Y,Z) to Three.js (x, y, z)
                    // Usually: ECI X -> Three X, ECI Y -> Three Z, ECI Z -> Three Y (Up)
                    // But our Earth is at y = -R.
                    
                    const vec = new THREE.Vector3(x, z, -y); // Swap Y/Z for Up-axis
                    
                    // Apply Earth Rotation (Scene Simulation)
                    // In builder mode, we rotate the "Universe" around the station.
                    // But here we are placing satellites relative to Earth.
                    // If Earth is at `earthCenter`, the satellite is at `earthCenter + vec`.
                    
                    mesh.position.copy(earthCenter).add(vec);
                    
                    // Scale check: Satellites are ~6700km from center.
                    // Earth radius is 6371km.
                    // So they should be ~400km above surface.
                }
            });
        }

        // --- Initialization ---
        function init() {
            // Scene Setup
            scene = new THREE.Scene();
            // scene.fog = new THREE.FogExp2(0x000510, 0.0015); // Removed fog to allow seeing distant Sun/Earth

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000000000000);
            camera.position.set(30, 20, 30);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true, logarithmicDepthBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Post Processing (Bloom)
            const renderScene = new THREE.RenderPass(scene, camera);
            const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.2;
            bloomPass.strength = 1.2; // Intense bloom
            bloomPass.radius = 0.5;

            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // Controls Setup
            orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
            orbitControls.enableDamping = true;
            orbitControls.dampingFactor = 0.05;
            orbitControls.screenSpacePanning = true;
            orbitControls.minDistance = 5;
            orbitControls.maxDistance = 5000;
            orbitControls.maxPolarAngle = Math.PI; // Allow full rotation
            orbitControls.autoRotate = true; // Default on
            orbitControls.autoRotateSpeed = 0.5;
            
            flyControls = new THREE.PointerLockControls(camera, document.body);
            flyControls.addEventListener('unlock', function () {
                if(builderCameraMode === 'FLY') {
                    // If user pressed ESC, maybe switch back to orbit or just pause?
                    // For now, let's just show a hint or something.
                    // Or we can auto-switch back to orbit mode UI
                    toggleBuilderCamera(); 
                }
            });

            // Environment
            createEnvironment();
            createLights();
            
            // UI Generation
            generateBuildMenu();
            
            // Event Listeners
            window.addEventListener('resize', onResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('wheel', onWheel);

            // Start Loop
            loadStation();
            fetchSatellites(); // Load real data
            document.getElementById('loading').style.display = 'none';
            
            // Add Time Warp Controls
            const warpContainer = document.createElement('div');
            warpContainer.className = 'warp-controls';
            warpContainer.style.position = 'fixed'; // Changed to fixed
            warpContainer.style.bottom = '100px'; 
            warpContainer.style.right = '20px'; 
            warpContainer.style.display = 'flex';
            warpContainer.style.gap = '10px';
            warpContainer.style.zIndex = '2000'; // Increased z-index
            warpContainer.style.background = 'rgba(10, 20, 30, 0.9)'; // More opaque
            warpContainer.style.padding = '10px';
            warpContainer.style.borderRadius = '4px';
            warpContainer.style.border = '1px solid rgba(0, 255, 255, 0.3)';
            warpContainer.style.pointerEvents = 'auto'; // Ensure clickable
            
            // Display
            const warpDisplay = document.createElement('span');
            warpDisplay.id = 'warp-display';
            warpDisplay.style.color = '#00ffff';
            warpDisplay.style.fontWeight = 'bold';
            warpDisplay.style.alignSelf = 'center';
            warpDisplay.style.marginRight = '10px';
            warpDisplay.textContent = '1x';
            warpContainer.appendChild(warpDisplay);
            
            [1, 10, 100, 1000, 10000].forEach(speed => {
                const btn = document.createElement('button');
                btn.textContent = speed + "x";
                btn.className = 'btn';
                btn.style.padding = '5px 10px';
                btn.style.background = 'rgba(0,0,0,0.5)';
                btn.style.border = '1px solid #444';
                btn.style.color = '#fff';
                btn.style.cursor = 'pointer';
                btn.onclick = (e) => {
                    e.stopPropagation(); // Prevent click-through
                    e.preventDefault(); // Prevent default
                    setTimeWarp(speed);
                };
                // Add touch support
                btn.ontouchend = (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    setTimeWarp(speed);
                };
                warpContainer.appendChild(btn);
            });
            
            // Pause Button
            const pauseBtn = document.createElement('button');
            pauseBtn.textContent = "‚è∏";
            pauseBtn.className = 'btn';
            pauseBtn.style.padding = '5px 10px';
            pauseBtn.style.background = 'rgba(50,0,0,0.5)';
            pauseBtn.style.border = '1px solid #ff3333';
            pauseBtn.style.color = '#fff';
            pauseBtn.style.cursor = 'pointer';
            pauseBtn.onclick = (e) => {
                e.stopPropagation();
                e.preventDefault();
                timeWarp = 0;
                document.getElementById('warp-display').textContent = "PAUSED";
                showNotification("SIMULATION PAUSED");
            };
            pauseBtn.ontouchend = (e) => {
                e.stopPropagation();
                e.preventDefault();
                timeWarp = 0;
                document.getElementById('warp-display').textContent = "PAUSED";
                showNotification("SIMULATION PAUSED");
            };
            warpContainer.insertBefore(pauseBtn, warpContainer.children[1]); // After display
            
            document.body.appendChild(warpContainer);
            
            animate();
        }

        function createEnvironment() {
            // Stars (Background)
            const starGeo = new THREE.BufferGeometry();
            const starPos = [];
            const starColors = [];
            for(let i=0; i<10000; i++) {
                const r = 5000000; // Far background
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);
                starPos.push(x, y, z);
                const color = new THREE.Color();
                color.setHSL(Math.random(), 0.5, 0.8);
                starColors.push(color.r, color.g, color.b);
            }
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
            starGeo.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
            stars = new THREE.Points(starGeo, new THREE.PointsMaterial({size: 2000, vertexColors: true})); // Scaled up stars
            scene.add(stars);

            // Earth (Real Scale LEO)
            // Radius: ~6,371 km = 6,371,000 m
            // Altitude: ~400 km = 400,000 m
            // Position: y = -6,771,000
            const earthRadius = 6371000;
            const planetGeo = new THREE.SphereGeometry(earthRadius, 128, 128);
            const textureLoader = new THREE.TextureLoader();
            const earthTexture = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_atmos_2048.jpg');
            const earthNormal = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_normal_2048.jpg');
            const earthSpecular = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_specular_2048.jpg');

            const planetMat = new THREE.MeshPhongMaterial({
                map: earthTexture,
                normalMap: earthNormal,
                specularMap: earthSpecular,
                specular: new THREE.Color(0x333333),
                shininess: 5
            });
            planet = new THREE.Mesh(planetGeo, planetMat);
            planet.position.set(0, -(earthRadius + 400000), 0);
            planet.rotation.z = 0.4; // Tilt
            scene.add(planet);

            // Sun (Real Scale Appearance)
            // Distance: 1,000,000 units (Scaled down from 1AU but far enough)
            // Angular diameter: ~0.5 degrees
            // Radius = tan(0.25deg) * Dist ~= 0.00436 * 1,000,000 = 4360
            const sunGeo = new THREE.SphereGeometry(4360, 32, 32);
            const sunMat = new THREE.MeshBasicMaterial({color: 0xffffff});
            sun = new THREE.Mesh(sunGeo, sunMat);
            // Start position (will be animated)
            sun.position.set(0, 0, -1000000);
            scene.add(sun);

            // Moon
            const moonGeo = new THREE.SphereGeometry(1737000, 64, 64); // Real radius
            const moonTexture = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/moon_1024.jpg');
            const moonMat = new THREE.MeshStandardMaterial({
                map: moonTexture,
                roughness: 0.9,
                metalness: 0.0
            });
            moon = new THREE.Mesh(moonGeo, moonMat);
            moon.position.set(384400000, 0, 0); // Real distance (might be clipped, but let's try)
            scene.add(moon);
        }

        function createLights() {
            // NO Ambient Light - Space is black
            // Earthshine (Hemisphere Light from below)
            // Sky color: Black, Ground color: Earth Blue
            const earthshine = new THREE.HemisphereLight(0x000000, 0x112244, 0.2);
            scene.add(earthshine);

            // Sun Light (Directional)
            // Position will be updated in animate() to match Sun mesh
            const sunLight = new THREE.DirectionalLight(0xffffff, 3.0); // Very bright
            sunLight.castShadow = true;
            // Shadow settings for station scale
            sunLight.shadow.mapSize.width = 4096;
            sunLight.shadow.mapSize.height = 4096;
            sunLight.shadow.camera.near = 0.1;
            sunLight.shadow.camera.far = 2000; // Just covers the station
            const d = 100;
            sunLight.shadow.camera.left = -d;
            sunLight.shadow.camera.right = d;
            sunLight.shadow.camera.top = d;
            sunLight.shadow.camera.bottom = -d;
            sunLight.shadow.bias = -0.0001;
            
            // Attach light to sun mesh so we can find it later
            sun.add(sunLight);
        }

        function generateBuildMenu() {
            const menu = document.getElementById('build-menu');
            Object.keys(MODULES).forEach(key => {
                const m = MODULES[key];
                const btn = document.createElement('div');
                btn.className = 'module-button';
                if(key === selectedModuleType) btn.classList.add('selected');
                btn.innerHTML = `
                    <div class="module-icon">${m.icon}</div>
                    <div class="module-name">${m.name}</div>
                    <div class="module-cost">${m.cost}</div>
                `;
                btn.onclick = () => selectModule(key);
                btn.onmouseenter = () => playSound('hover');
                menu.appendChild(btn);
            });
        }

        function prevTarget() {
            cycleTarget(-1);
        }

        function nextTarget() {
            cycleTarget(1);
        }

        function updateCameraLogic() {
             // Map View (Solar System Scale)
            if(cameraMode === 'MAP') {
                // Position camera high above the orbital plane
                // Center on the midpoint between Earth and Ship (or Earth and Moon)
                
                let center = new THREE.Vector3(0,0,0); // Ship is at 0,0,0
                let dist = 100000; // Default LEO scale
                
                if(currentMission) {
                    if(currentMission.destDist) {
                        // Interplanetary/Lunar scale
                        // Earth is at celestialBody.position
                        // Moon is at destinationBody.position
                        // Ship is at 0,0,0
                        
                        // Find bounds
                        const earthPos = celestialBody.position;
                        const moonPos = destinationBody ? destinationBody.position : new THREE.Vector3();
                        
                        // Midpoint
                        center.addVectors(earthPos, moonPos).multiplyScalar(0.5);
                        
                        // Distance to cover both
                        dist = earthPos.distanceTo(moonPos) * 1.5;
                    } else {
                        // LEO Scale
                        dist = (currentMission.bodyRadius + currentMission.startAlt) * SCALE_FACTOR * 4;
                    }
                }
                
                // Smoothly move camera
                const targetPos = center.clone().add(new THREE.Vector3(0, dist, 0)); // Top-down view
                camera.position.lerp(targetPos, 0.05);
                orbitControls.target.lerp(center, 0.05);

                // Make sure Ship Marker is visible in Map Mode
                let shipMarker = scene.getObjectByName("shipMarker");
                if(!shipMarker) {
                    shipMarker = createMarker(0x00ffff, "SHIP");
                    shipMarker.name = "shipMarker";
                    scene.add(shipMarker);
                }
                shipMarker.visible = true;
                shipMarker.position.set(0, 0, 0); // Ship is at 0,0,0
                // Scale marker based on camera distance
                const camDist = camera.position.length();
                const scale = camDist / 50;
                shipMarker.scale.set(scale * 4, scale, 1);
            } else {
                // Hide ship marker in other modes
                const shipMarker = scene.getObjectByName("shipMarker");
                if(shipMarker) shipMarker.visible = false;
            }
            
            orbitControls.update();
        }

        // Removed updateTargetDisplay

        // Swipe Detection
        let touchStartX = 0;
        let touchEndX = 0;

        document.addEventListener('touchstart', e => {
            touchStartX = e.changedTouches[0].screenX;
        }, {passive: true});

        document.addEventListener('touchend', e => {
            touchEndX = e.changedTouches[0].screenX;
            handleSwipe();
        }, {passive: true});

        function handleSwipe() {
            if (touchEndX < touchStartX - 50) nextTarget();
            if (touchEndX > touchStartX + 50) prevTarget();
        }

        // --- Interaction ---
        function selectModule(type) {
            selectedModuleType = type;
            document.querySelectorAll('.module-button').forEach(b => b.classList.remove('selected'));
            // Find index and add class (simplified)
            const buttons = document.querySelectorAll('.module-button');
            const keys = Object.keys(MODULES);
            buttons[keys.indexOf(type)].classList.add('selected');
            
            if(buildMode) updateGhost();
        }

        function toggleBuildMode() {
            buildMode = !buildMode;
            const indicator = document.getElementById('mode-indicator');
            const menu = document.getElementById('build-menu');
            
            if(buildMode) {
                indicator.textContent = "BUILD MODE";
                indicator.classList.add('active');
                menu.style.display = 'flex';
                showNotification("Construction Systems Engaged");
            } else {
                indicator.textContent = "FLIGHT MODE";
                indicator.classList.remove('active');
                menu.style.display = 'none';
                if(ghostModule) {
                    scene.remove(ghostModule);
                    ghostModule = null;
                }
            }
        }

        function updateGhost() {
            if(ghostModule) scene.remove(ghostModule);
            if(!buildMode) return;

            const def = MODULES[selectedModuleType];
            const geo = def.geometry();
            const mat = def.material.clone();
            mat.transparent = true;
            mat.opacity = 0.5;
            mat.emissive = new THREE.Color(0x00ffff);
            mat.emissiveIntensity = 0.5;
            
            ghostModule = new THREE.Mesh(geo, mat);
            scene.add(ghostModule);
        }

        function getPlacement() {
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            // Raycast against existing station modules
            const intersects = raycaster.intersectObjects(station);
            
            let pos = new THREE.Vector3();
            let rot = new THREE.Euler();
            
            if(intersects.length > 0) {
                // Surface snapping
                const hit = intersects[0];
                const normal = hit.face.normal.clone().transformDirection(hit.object.matrixWorld).normalize();
                
                // Snap to center of the hit object + offset
                // This is a simplified snapping model. A robust one would use connection nodes.
                // We'll just stack them for now based on bounding box.
                
                pos.copy(hit.point).add(normal.multiplyScalar(2)); // Offset slightly
                
                // Snap to grid
                pos.x = Math.round(pos.x / SNAP_GRID) * SNAP_GRID;
                pos.y = Math.round(pos.y / SNAP_GRID) * SNAP_GRID;
                pos.z = Math.round(pos.z / SNAP_GRID) * SNAP_GRID;
                
                // Align rotation to normal (basic)
                if(Math.abs(normal.y) > 0.9) rot.x = normal.y > 0 ? 0 : Math.PI;
                else if(Math.abs(normal.x) > 0.9) rot.z = normal.x > 0 ? -Math.PI/2 : Math.PI/2;
                else if(Math.abs(normal.z) > 0.9) rot.y = normal.z > 0 ? 0 : Math.PI;
                
            } else {
                // Free space placement (at fixed distance)
                const dist = 40;
                const vec = new THREE.Vector3(mouse.x, mouse.y, 0.5).unproject(camera).sub(camera.position).normalize();
                pos.copy(camera.position).add(vec.multiplyScalar(dist));
                
                pos.x = Math.round(pos.x / SNAP_GRID) * SNAP_GRID;
                pos.y = Math.round(pos.y / SNAP_GRID) * SNAP_GRID;
                pos.z = Math.round(pos.z / SNAP_GRID) * SNAP_GRID;
            }
            
            return { pos, rot };
        }

        function placeModule() {
            if(!buildMode) return;
            
            const { pos, rot } = getPlacement();
            const def = MODULES[selectedModuleType];
            
            const mesh = new THREE.Mesh(def.geometry(), def.material);
            mesh.position.copy(pos);
            mesh.rotation.copy(rot);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.userData = { type: selectedModuleType, ...def };
            
            scene.add(mesh);
            station.push(mesh);
            
            // Add lights to some modules
            if(selectedModuleType === 'habitat' || selectedModuleType === 'dock') {
                const light = new THREE.PointLight(0x00ffff, 0.5, 10);
                mesh.add(light);
            }
            
            playSound('place');
            updateStats();
            
            // Particle effect
            createParticles(pos);
        }

        function removeModule() {
            if(!buildMode) return;
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(station);
            
            if(intersects.length > 0) {
                const obj = intersects[0].object;
                scene.remove(obj);
                station = station.filter(m => m !== obj);
                playSound('error'); // Reuse error sound for delete
                updateStats();
            }
        }

        function createParticles(pos) {
            const geo = new THREE.BufferGeometry();
            const count = 20;
            const positions = [];
            for(let i=0; i<count; i++) {
                positions.push(pos.x, pos.y, pos.z);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const mat = new THREE.PointsMaterial({color: 0x00ffff, size: 0.5, transparent: true});
            const particles = new THREE.Points(geo, mat);
            scene.add(particles);
            
            // Animate and remove
            const startTime = Date.now();
            const animateParticles = () => {
                const elapsed = Date.now() - startTime;
                if(elapsed > 500) {
                    scene.remove(particles);
                    return;
                }
                
                const positions = particles.geometry.attributes.position.array;
                for(let i=0; i<count; i++) {
                    positions[i*3] += (Math.random()-0.5) * 0.5;
                    positions[i*3+1] += (Math.random()-0.5) * 0.5;
                    positions[i*3+2] += (Math.random()-0.5) * 0.5;
                }
                particles.geometry.attributes.position.needsUpdate = true;
                mat.opacity = 1 - (elapsed/500);
                requestAnimationFrame(animateParticles);
            };
            animateParticles();
        }

        function updateStats() {
            let power = 0;
            let crew = 0;
            let solarCount = 0;
            
            station.forEach(m => {
                power += m.userData.power || 0;
                crew += m.userData.crew || 0;
                if(m.userData.type === 'solar') solarCount++;
            });
            
            // Solar efficiency based on angle to sun (simplified)
            // In a real game, we'd check each panel's rotation
            const efficiency = solarCount > 0 ? 95 : 0; 
            
            document.getElementById('module-count').textContent = station.length;
            
            const pEl = document.getElementById('power-status');
            pEl.textContent = power + " MW";
            pEl.style.color = power >= 0 ? '#00ff00' : '#ff0000';
            
            document.getElementById('crew-capacity').textContent = crew;
            document.getElementById('solar-efficiency').textContent = efficiency + "%";
        }

        // --- Input Handling ---
        function onKeyDown(e) {
            const k = e.key.toLowerCase();
            if(keys.hasOwnProperty(k)) keys[k] = true;
            if(k === 'shift') keys.shift = true;
            
            if(k === 'b') toggleBuildMode();
            if(k === 'delete') removeModule();
            if(k === 'r' && ghostModule) ghostModule.rotation.y += Math.PI/2;
            if(k === 'c' && missionMode) cycleCamera();
            if(k === 'm' && missionMode) toggleMapMode();
        }

        function onKeyUp(e) {
            const k = e.key.toLowerCase();
            if(keys.hasOwnProperty(k)) keys[k] = false;
            if(k === 'shift') keys.shift = false;
        }

        function onMouseMove(e) {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            // Manual orbit logic removed
        }

        function onMouseDown(e) {
            if(e.target.closest('.hud') || e.target.closest('.data-controls')) return;
            
            if(buildMode) {
                if(e.button === 0 && builderCameraMode === 'ORBIT') {
                    // Only place if not dragging (OrbitControls handles drag detection internally, 
                    // but we need to check if it was a click or drag)
                    // Simple hack: check movement? 
                    // OrbitControls doesn't expose "isDragging" easily.
                    // We'll use a timestamp check.
                }
                if(e.button === 0 && builderCameraMode === 'FLY') placeModule();
                if(e.button === 2 && builderCameraMode === 'FLY') removeModule(); 
            }
        }
        
        // Click handling for Orbit Mode
        let mouseDownTime = 0;
        document.addEventListener('mousedown', () => mouseDownTime = Date.now());
        document.addEventListener('mouseup', (e) => {
            if(Date.now() - mouseDownTime < 200 && buildMode && builderCameraMode === 'ORBIT') {
                // Short click = Place
                if(!e.target.closest('.hud') && !e.target.closest('.data-controls')) {
                    if(e.button === 0) placeModule();
                    if(e.button === 2) removeModule(); // Right click delete
                }
            }
        });
        
        function onMouseUp(e) {
            // isDragging = false; // Removed
        }
        
        function onWheel(e) {
            // Handled by OrbitControls
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Cinematic Director System ---
        class CinematicDirector {
            constructor() {
                this.active = false;
                this.queue = [];
                this.currentShot = null;
                this.shotStartTime = 0;
                this.transitioning = false;
            }

            playSequence(sequence) {
                this.active = true;
                this.queue = [...sequence];
                this.nextShot();
                
                // Hide standard HUD, show Cinematic Bars?
                document.body.classList.add('cinematic-mode');
                cameraMode = 'CINEMATIC';
                updateCameraModeDisplay();
            }

            stop() {
                this.active = false;
                this.currentShot = null;
                document.body.classList.remove('cinematic-mode');
                cameraMode = 'CHASE'; // Revert to standard
                updateCameraModeDisplay();
            }

            nextShot() {
                if (this.queue.length === 0) {
                    // End of sequence
                    // this.stop(); // Optional: Stop or just hold last shot
                    return;
                }
                this.currentShot = this.queue.shift();
                this.shotStartTime = Date.now();
                
                // Setup initial camera state for the shot
                if (this.currentShot.type === 'CUT') {
                    this.applyShotState(0);
                }
                
                showNotification("DIRECTOR: " + (this.currentShot.name || "Shot"));
            }

            update() {
                if (!this.active || !this.currentShot) return;

                const now = Date.now();
                const elapsed = (now - this.shotStartTime) / 1000; // seconds
                const duration = this.currentShot.duration || 5;

                // Update Text
                const textEl = document.getElementById('cinematic-text');
                if (this.currentShot.text) {
                    textEl.textContent = this.currentShot.text;
                    textEl.style.opacity = 1;
                } else {
                    textEl.style.opacity = 0;
                }

                if (elapsed > duration) {
                    this.nextShot();
                    return;
                }

                const progress = elapsed / duration;
                this.applyShotState(progress);
            }

            applyShotState(progress) {
                // Calculate target position based on shot type
                let targetPos = new THREE.Vector3();
                let lookAtPos = new THREE.Vector3();
                
                // Determine focus object (Ship, Earth, Moon, etc.)
                let focusObj = station.length > 0 ? station[0] : (planet || new THREE.Vector3());
                if (this.currentShot.target === 'EARTH') focusObj = planet;
                if (this.currentShot.target === 'MOON') focusObj = moon;
                if (this.currentShot.target === 'SHIP') focusObj = station.length > 0 ? station[0] : new THREE.Vector3();
                
                // Get position of focus object
                let focusPos = new THREE.Vector3();
                if (focusObj.position) focusPos.copy(focusObj.position);
                else focusPos.copy(focusObj); // It's a vector
                
                // Handle Group positions (station modules might be offset)
                if (this.currentShot.target === 'SHIP' && station.length > 0) {
                    // Use shipPosition from physics loop for smoother tracking
                    // But visual position is 0,0,0 usually? 
                    // Wait, in Mission Mode, ship is at 0,0,0 and world moves?
                    // Yes: "shipPosition.set(0, 0, -dist);" in animate loop?
                    // No, let's check animate loop.
                    // "mesh.position.copy(earthPos).add(satPosRelEarth);" -> Satellites move.
                    // "planet.position.set(0, -(earthRadius + 400000), 0);" -> Planet is static?
                    // Let's re-read animate loop logic for Mission Mode.
                    // "updatePhysics" updates "shipPosition" (logical).
                    // Visuals: "celestialBody.position.copy(shipPosition).negate();" ??
                    // Usually in these sims, ship is static at 0,0,0 and universe moves, OR ship moves and camera follows.
                    // I need to know which one it is to direct the camera.
                    
                    // Assuming Ship is at 0,0,0 visually in Mission Mode (common for precision).
                    focusPos.set(0,0,0); 
                }

                if (this.currentShot.type === 'FIXED') {
                    // Fixed relative to target
                    const offset = this.currentShot.offset || new THREE.Vector3(100, 50, 100);
                    targetPos.copy(focusPos).add(offset);
                    lookAtPos.copy(focusPos);
                } else if (this.currentShot.type === 'PAN') {
                    // Pan around target
                    const startOffset = this.currentShot.startOffset || new THREE.Vector3(100, 50, 100);
                    const endOffset = this.currentShot.endOffset || new THREE.Vector3(-100, 50, 100);
                    const currentOffset = new THREE.Vector3().lerpVectors(startOffset, endOffset, progress);
                    targetPos.copy(focusPos).add(currentOffset);
                    lookAtPos.copy(focusPos);
                } else if (this.currentShot.type === 'TRACK') {
                    // Track target from a stationary point (relative to what?)
                    // Usually "Tracking Shot" means camera moves with subject.
                    // "Pan" means camera rotates.
                    // Let's define TRACK as: Camera moves parallel to subject?
                    // Or "Flyby": Camera is static in world, ship flies past.
                    // Since ship is static (0,0,0), we simulate flyby by moving camera past it.
                    const startPos = this.currentShot.startPos || new THREE.Vector3(0, 0, 200);
                    const endPos = this.currentShot.endPos || new THREE.Vector3(0, 0, -200);
                    targetPos.lerpVectors(startPos, endPos, progress);
                    lookAtPos.copy(focusPos);
                } else if (this.currentShot.type === 'POV') {
                    // From cockpit
                    targetPos.copy(focusPos).add(new THREE.Vector3(0, 0.5, 2)); // Approx cockpit
                    lookAtPos.copy(focusPos).add(new THREE.Vector3(0, 0, 100)); // Look forward
                    
                    if(this.currentShot.lookAt === 'EARTH') {
                        lookAtPos.copy(celestialBody.position);
                    } else if(this.currentShot.lookAt === 'MOON' && moon) {
                        lookAtPos.copy(moon.position);
                    } else if(this.currentShot.lookAt === 'SHIP') {
                        lookAtPos.copy(focusPos);
                    }
                }

                // Apply to Camera
                // Smooth lerp if not a CUT
                if (this.currentShot.type !== 'CUT' && progress > 0.05) {
                    camera.position.lerp(targetPos, 0.1);
                } else {
                    camera.position.copy(targetPos);
                }
                
                orbitControls.target.lerp(lookAtPos, 0.1);
                orbitControls.update();
            }
        }
        
        const director = new CinematicDirector();

        function startHeroSequence() {
            // 1. Setup Mission (Apollo 11)
            startMission('apollo');
            
            // 2. Override Launch Overlay (Auto-start)
            initiateLaunch();
            
            // 3. Configure Director Sequence
            const sequence = [
                { 
                    type: 'PAN', 
                    name: "The Blue Marble", 
                    text: "EARTH. CRADLE OF HUMANITY.",
                    duration: 6, 
                    target: 'EARTH', 
                    startOffset: new THREE.Vector3(0, 20000, 40000), 
                    endOffset: new THREE.Vector3(0, 10000, 30000) 
                },
                { 
                    type: 'PAN', 
                    name: "The Vessel", 
                    text: "APOLLO 11. DESTINATION: MOON.",
                    duration: 6, 
                    target: 'SHIP', 
                    startOffset: new THREE.Vector3(50, 20, 50), 
                    endOffset: new THREE.Vector3(-50, 10, 50) 
                },
                { 
                    type: 'FIXED', 
                    name: "Ignition", 
                    text: "TRANS-LUNAR INJECTION BURN.",
                    duration: 5, 
                    target: 'SHIP', 
                    offset: new THREE.Vector3(0, -20, 80) // Rear view of engines
                },
                { 
                    type: 'TRACK', 
                    name: "The Journey", 
                    text: "384,000 KILOMETERS.",
                    duration: 8, 
                    target: 'SHIP', 
                    startPos: new THREE.Vector3(100, 100, 100), 
                    endPos: new THREE.Vector3(500, 500, 500),
                    lookAt: 'SHIP'
                },
                { 
                    type: 'PAN', 
                    name: "Arrival", 
                    text: "LUNAR ORBIT INSERTION.",
                    duration: 6, 
                    target: 'MOON', 
                    startOffset: new THREE.Vector3(0, 5000, 5000), 
                    endOffset: new THREE.Vector3(0, 2000, 2000) 
                },
                { 
                    type: 'POV', 
                    name: "Descent", 
                    text: "THE EAGLE HAS WINGS.",
                    duration: 5, 
                    target: 'SHIP', 
                    lookAt: 'MOON'
                }
            ];
            
            director.playSequence(sequence);
            
            // 4. Scripted Events (Burn, Warp, etc.)
            // TLI Burn at t=12s (during Ignition shot)
            setTimeout(() => {
                shipVelocity.add(new THREE.Vector3(0,0,-3.05)); // Fake TLI burn
                createParticles(new THREE.Vector3(0,0,5), 100, 0xffaa00);
                playSound('place');
            }, 12000);
            
            // Time Warp at t=17s (during Journey)
            setTimeout(() => {
                timeWarp = 1000; // Speed up
            }, 17000);
            
            // Stop Warp at t=25s (Arrival)
            setTimeout(() => {
                timeWarp = 1;
                // Teleport closer to Moon for the shot
                shipPosition.set(0, 0, -380000);
                updatePhysics(0);
            }, 25000);
            
            // End Sequence
            setTimeout(() => {
                director.stop();
                showNotification("MANUAL CONTROL ENGAGED");
                document.getElementById('cinematic-text').textContent = "";
            }, 36000);
        }

        // --- Physics & Mission System ---
        let missionMode = false;
        let physicsTime = 0;
        let timeWarp = 1;
        let shipVelocity = new THREE.Vector3();
        let shipPosition = new THREE.Vector3(); // Real physics position (scaled down for rendering)
        let celestialBody = null;
        let ghostShip = null;
        let orbitLine = null;
        let ghostOrbitLine = null;
        let spaceDust = null;
        let historyLine = null;
        let predictedLine = null;
        const MAX_TRAIL_POINTS = 1000;
        const PREDICTION_STEPS = 500;
        
        const G = 6.67430e-11;
        const C = 299792.458; // km/s (Speed of Light)
        const SCALE_FACTOR = 1000; // 1 unit = 1 meter. Physics is in km. 1 km = 1000 m.
        
        const MISSIONS = {
            vostok: {
                name: "Vostok 1",
                year: 1961,
                bodyRadius: 6371, // km
                bodyMass: 5.972e24, // kg
                bodyColor: 0x2244ff,
                startAlt: 215, // Apogee 327, Perigee 169. Let's avg.
                startLat: 45.9, // Baikonur latitude approx
                startLon: 63.3,
                inclination: 64.95,
                startVel: 7.84, // km/s
                targetOrbit: 200,
                ghostColor: 0xff0000,
                desc: "First human in space. Launch from Baikonur Cosmodrome.",
                bodies: [
                    { name: "Earth", mass: 5.972e24, radius: 6371, orbit: null }
                ],
                pois: [
                    { name: "Earth", pos: new THREE.Vector3(0, 0, 0), type: "body" },
                    { name: "Baikonur", pos: new THREE.Vector3(0, 6371, 0), type: "point" } // Approx
                ]
            },
            apollo: {
                name: "Apollo 11",
                year: 1969,
                bodyRadius: 6371, // Earth Parking Orbit
                bodyMass: 5.972e24, 
                bodyColor: 0x2244ff,
                startAlt: 185, // Parking orbit
                startLat: 28.5, // KSC latitude
                startLon: -80.6,
                inclination: 32.5, // Standard Apollo parking inclination
                startVel: 7.79, // LEO velocity
                targetOrbit: null, // TLI is the goal
                ghostColor: 0xffaa00,
                desc: "Earth Parking Orbit established. Prepare for TLI burn.",
                destName: "Moon",
                destDist: 384400, // km
                destColor: 0xaaaaaa,
                bodies: [
                    { name: "Earth", mass: 5.972e24, radius: 6371, orbit: null },
                    { name: "Moon", mass: 7.348e22, radius: 1737, orbit: { a: 384400, phase: 0 } }
                ],
                pois: [
                    { name: "Earth", pos: new THREE.Vector3(0, 0, 0), type: "body" }, // Will be updated dynamically
                    { name: "Moon", pos: new THREE.Vector3(0, 0, -384400), type: "body" },
                    { name: "Landing Site", pos: new THREE.Vector3(0, 0, -384400 + 1737), type: "point" }
                ],
                cinematicIntro: [
                    { type: 'PAN', name: "The Blue Marble", duration: 8, target: 'EARTH', startOffset: new THREE.Vector3(0, 20000, 40000), endOffset: new THREE.Vector3(0, 10000, 30000) },
                    { type: 'TRACK', name: "Orbital Sunrise", duration: 10, target: 'SHIP', startPos: new THREE.Vector3(-200, 0, 50), endPos: new THREE.Vector3(200, 0, -50) },
                    { type: 'FIXED', name: "Pre-Burn Check", duration: 5, target: 'SHIP', offset: new THREE.Vector3(50, 20, 50) }
                ],
                timeline: [
                    {
                        time: 10,
                        title: "Trans-Lunar Injection (TLI)",
                        desc: "S-IVB engine ignition to leave Earth orbit.",
                        action: (ship) => {
                            // Delta-V for TLI approx 3.05 km/s
                            const burn = ship.velocity.clone().normalize().multiplyScalar(3.05);
                            ship.velocity.add(burn);
                            
                            // Cinematic Cue
                            director.playSequence([
                                { type: 'FIXED', name: "Ignition", duration: 10, target: 'SHIP', offset: new THREE.Vector3(0, -50, 100) }, // Rear view
                                { type: 'PAN', name: "Departure", duration: 15, target: 'EARTH', startOffset: new THREE.Vector3(0, 0, 50000), endOffset: new THREE.Vector3(0, 0, 100000) }
                            ]);
                            
                            return "TLI Burn Complete. Velocity: " + ship.velocity.length().toFixed(2) + " km/s";
                        }
                    },
                    {
                        time: 300, // Simulated time after TLI
                        title: "Transposition & Docking",
                        desc: "CSM separates, turns around, and docks with LM.",
                        action: (ship) => {
                            // Visual change only - maybe spawn debris?
                            createParticles(new THREE.Vector3(0,0,0), 50, 0xaaaaaa);
                            
                            // Cinematic Cue
                            director.playSequence([
                                { type: 'POV', name: "Docking View", duration: 15, target: 'SHIP', lookAt: 'EARTH' },
                                { type: 'TRACK', name: "Separation", duration: 10, target: 'SHIP', startPos: new THREE.Vector3(20, 0, 0), endPos: new THREE.Vector3(50, 0, 0) }
                            ]);
                            
                            return "CSM/LM Docked. S-IVB Jettisoned.";
                        }
                    },
                    {
                        condition: (ship, mission) => {
                            // Trigger when close to Moon (within 5000km)
                            const dist = mission.destDist - ship.position.length();
                            return dist < 5000;
                        },
                        title: "Lunar Orbit Insertion (LOI)",
                        desc: "SPS engine burn to capture into lunar orbit.",
                        action: (ship) => {
                            // Slow down to capture
                            ship.velocity.normalize().multiplyScalar(0.1); // Slow crawl
                            
                            // Cinematic Cue
                            director.playSequence([
                                { type: 'PAN', name: "Lunar Approach", duration: 20, target: 'MOON', startOffset: new THREE.Vector3(0, 5000, 5000), endOffset: new THREE.Vector3(0, 2000, 2000) },
                                { type: 'FIXED', name: "Orbit Established", duration: 10, target: 'SHIP', offset: new THREE.Vector3(0, 100, 0) }
                            ]);
                            
                            return "LOI Burn Complete. Captured by Lunar Gravity.";
                        }
                    },
                    {
                        time: 999999, // Triggered manually or after LOI
                        title: "Eagle Separation",
                        desc: "LM 'Eagle' undocks for landing.",
                        action: (ship) => {
                            createParticles(new THREE.Vector3(0,-5,0), 20, 0xffd700);
                            return "The Eagle has wings.";
                        }
                    }
                ]
            },
            apollo13: {
                name: "Apollo 13",
                year: 1970,
                bodyRadius: 6371,
                bodyMass: 5.972e24,
                bodyColor: 0x2244ff,
                startAlt: 185,
                startLat: 28.5,
                startLon: -80.6,
                inclination: 32.5,
                startVel: 7.79,
                targetOrbit: null,
                ghostColor: 0xff3300,
                desc: "Mission to Fra Mauro. Everything looks nominal.",
                destName: "Moon",
                destDist: 384400,
                destColor: 0xaaaaaa,
                bodies: [
                    { name: "Earth", mass: 5.972e24, radius: 6371, orbit: null },
                    { name: "Moon", mass: 7.348e22, radius: 1737, orbit: { a: 384400, phase: 0 } }
                ],
                pois: [
                    { name: "Earth", pos: new THREE.Vector3(0, 0, 0), type: "body" },
                    { name: "Moon", pos: new THREE.Vector3(0, 0, -384400), type: "body" },
                    { name: "Explosion Site", pos: new THREE.Vector3(0, 0, -300000), type: "point" } // Approx
                ],
                timeline: [
                    {
                        time: 10,
                        title: "Trans-Lunar Injection",
                        desc: "Burn for the Moon.",
                        action: (ship) => {
                            const burn = ship.velocity.clone().normalize().multiplyScalar(3.05);
                            ship.velocity.add(burn);
                            return "TLI Complete. En route to Moon.";
                        }
                    },
                    {
                        time: 200, // Compressed time
                        title: "Oxygen Tank Explosion",
                        desc: "Stirring the cryo tanks...",
                        action: (ship) => {
                            createParticles(new THREE.Vector3(0,0,0), 100, 0xffaa00); // Explosion
                            playSound('error');
                            showNotification("CRITICAL FAILURE: O2 TANK 2 RUPTURE");
                            
                            // Cinematic
                            director.playSequence([
                                { type: 'FIXED', name: "Venting Gas", duration: 10, target: 'SHIP', offset: new THREE.Vector3(20, 10, 20) }
                            ]);
                            
                            return "Houston, we've had a problem. Venting O2.";
                        }
                    },
                    {
                        condition: (ship, mission) => {
                            const dist = mission.destDist - ship.position.length();
                            return dist < 8000;
                        },
                        title: "Free Return Trajectory",
                        desc: "Looping around the Moon to sling back to Earth.",
                        action: (ship) => {
                            // Adjust velocity to swing back
                            // In this simple physics, we just reverse Z velocity roughly?
                            // Or just let gravity do it if we aimed right?
                            // Let's force a "Gravity Assist" vector change
                            ship.velocity.reflect(new THREE.Vector3(0,0,1)); // Bounce back?
                            ship.velocity.multiplyScalar(0.9); // Loss
                            
                            director.playSequence([
                                { type: 'PAN', name: "Far Side", duration: 15, target: 'MOON', startOffset: new THREE.Vector3(0, 2000, 2000), endOffset: new THREE.Vector3(0, 2000, -2000) }
                            ]);
                            
                            return "Lunar Swingby Complete. Course set for Earth.";
                        }
                    },
                    {
                        condition: (ship, mission) => {
                            // Check if returning (velocity pointing to origin)
                            const toEarth = ship.position.clone().negate().normalize();
                            const velDir = ship.velocity.clone().normalize();
                            const returning = velDir.dot(toEarth) > 0.9;
                            const dist = ship.position.length();
                            return returning && dist < 10000; // Close to Earth
                        },
                        title: "Re-entry Interface",
                        desc: "Jettison Service Module and LEM.",
                        action: (ship) => {
                            createParticles(new THREE.Vector3(0,0,0), 50, 0xffffff);
                            return "Modules Jettisoned. Prepare for blackout.";
                        }
                    }
                ]
            },
            interstellar: {
                name: "Project Longshot",
                year: 2150,
                bodyRadius: 6371,
                bodyMass: 5.972e24,
                bodyColor: 0x2244ff,
                startAlt: 500, // Assembly orbit
                startLat: 0, // Equatorial assembly
                startLon: 0,
                inclination: 0,
                startVel: 7.61,
                targetOrbit: null,
                ghostColor: 0x00ffff,
                desc: "Orbital Assembly Complete. Alpha Centauri injection imminent.",
                destName: "Alpha Centauri",
                destDist: 4.37 * 9.461e12, // km (4.37 LY)
                destColor: 0xffddaa,
                bodies: [
                    { name: "Earth", mass: 5.972e24, radius: 6371, orbit: null },
                    { name: "Alpha Centauri A", mass: 2.18e30, radius: 851000, orbit: { a: 4.37 * 9.461e12, phase: 0 } }
                ],
                pois: [
                    { name: "Earth", pos: new THREE.Vector3(0, 0, 0), type: "body" },
                    { name: "Alpha Centauri", pos: new THREE.Vector3(0, 0, -4.37 * 9.461e12), type: "body" }
                ]
            },
            hail_mary: {
                name: "Project Hail Mary",
                year: 2049,
                bodyRadius: 6371,
                bodyMass: 5.972e24,
                bodyColor: 0x2244ff,
                startAlt: 400,
                startLat: 51.6, // High inclination for global coverage
                startLon: 10.0,
                inclination: 51.6,
                startVel: 7.66, 
                targetOrbit: null,
                ghostColor: 0xff3300, // Astrophage Red
                desc: "Petrova Task Force ready. Tau Ceti Run. 12 Light Years.",
                special: "astrophage",
                destName: "Tau Ceti",
                destDist: 11.9 * 9.461e12, // km (12 LY)
                destColor: 0xffaa88,
                bodies: [
                    { name: "Earth", mass: 5.972e24, radius: 6371, orbit: null },
                    { name: "Tau Ceti", mass: 1.5e30, radius: 700000, orbit: { a: 11.9 * 9.461e12, phase: 0 } }
                ],
                pois: [
                    { name: "Earth", pos: new THREE.Vector3(0, 0, 0), type: "body" },
                    { name: "Tau Ceti", pos: new THREE.Vector3(0, 0, -11.9 * 9.461e12), type: "body" }
                ]
            }
        };

        let currentMission = null;
        let cameraMode = 'CHASE'; // CHASE, COCKPIT, ORBIT, TARGET, CINEMATIC, MAP
        let camIndex = 0;
        const CAM_MODES = ['CHASE', 'COCKPIT', 'ORBIT', 'TARGET', 'CINEMATIC', 'TELESCOPE', 'MOON_SHOT', 'MAP'];
        let destinationBody = null;

        function startGame() {
            document.getElementById('title-screen').style.display = 'none';
            document.getElementById('stats').style.display = 'block';
            document.getElementById('controls-info').style.display = 'block';
            document.getElementById('mode-indicator').style.display = 'block';
            
            // Start Tutorial if first time
            if(!localStorage.getItem(APP_NAME)) {
                startTutorial();
            }
        }

        function showMissionScreen() {
            document.getElementById('title-screen').style.display = 'none';
            document.getElementById('mission-screen').style.display = 'flex';
        }

        function closeMissionScreen() {
            document.getElementById('mission-screen').style.display = 'none';
            document.getElementById('title-screen').style.display = 'flex';
        }

        let autopilotEngaged = true;
        let deviationAlert = false;
        let isPaused = false;

        let maxVelocity = 0;
        let flightHistory = []; // Store [time, distance] for graph

        let currentEventIndex = 0;

        function startMission(missionId) {
            document.getElementById('mission-screen').style.display = 'none';
            document.getElementById('flight-ui').style.display = 'block';
            document.getElementById('stats').style.display = 'none'; // Hide builder HUD
            document.getElementById('controls-info').style.display = 'none';
            document.getElementById('build-menu').style.display = 'none';
            document.querySelector('.data-controls').style.display = 'none'; // Hide builder controls
            document.getElementById('mode-indicator').textContent = "AUTOPILOT ENGAGED";
            document.getElementById('mode-indicator').style.color = "#00ff00";
            document.getElementById('target-controls').style.display = 'block';
            
            missionMode = true;
            autopilotEngaged = true;
            currentMission = MISSIONS[missionId];
            physicsTime = 0;
            maxVelocity = 0;
            flightHistory = [];
            currentEventIndex = 0;
            
            updateTimelineDisplay();
            updateTimelineBar();
            document.getElementById('mission-timeline').style.display = currentMission.timeline ? 'block' : 'none';
            
            // Setup Physics World
            setupMissionScene(currentMission, missionId);
            
            // Enforce Default Spacecraft for Historical Missions
            if(missionId === 'vostok') {
                loadPreset('sputnik_1'); // Close enough for Vostok visual in this low-poly style
                document.getElementById('presetSelect').disabled = true;
            } else if(missionId === 'apollo' || missionId === 'apollo13') {
                loadPreset('default'); // Use standard module for Apollo CSM/LM stack
                document.getElementById('presetSelect').disabled = true;
            } else if(missionId === 'shuttle_mission' || currentMission.name.includes("Shuttle")) {
                loadPreset('shuttle');
                document.getElementById('presetSelect').disabled = true;
            } else {
                document.getElementById('presetSelect').disabled = false;
            }
            
            // Initialize Physics State
            // Convert Lat/Lon/Alt to Cartesian
            const lat = (currentMission.startLat || 0) * (Math.PI / 180);
            const lon = (currentMission.startLon || 0) * (Math.PI / 180);
            const r = currentMission.bodyRadius + currentMission.startAlt;
            
            // Position Vector
            const x = r * Math.cos(lat) * Math.cos(lon);
            const y = r * Math.sin(lat);
            const z = r * Math.cos(lat) * Math.sin(lon);
            shipPosition.set(x, y, z);
            
            // Ensure ship is not inside planet visually
            // In Mission Mode, we move the world relative to the ship.
            // Ship is at (0,0,0) visually (plus camera offset).
            // Planet is at -shipPosition.
            // If shipPosition is (R, 0, 0), Planet is at (-R, 0, 0).
            // Distance is R. Radius is R. Surface is at 0.
            // So ship is exactly on surface if Alt=0.
            // With Alt=185km, it should be fine.
            
            // Velocity Vector (Tangential based on Inclination)
            // Simplified: We want a velocity vector perpendicular to position
            // And rotated by inclination angle relative to the equator
            
            // 1. Find East vector at this position (tangent to parallel of latitude)
            const east = new THREE.Vector3(-Math.sin(lon), 0, Math.cos(lon));
            
            // 2. Find North vector at this position (tangent to meridian)
            const north = new THREE.Vector3(
                -Math.sin(lat) * Math.cos(lon),
                Math.cos(lat),
                -Math.sin(lat) * Math.sin(lon)
            );
            
            // 3. Combine based on inclination (Azimuth)
            // For a circular orbit, flight path angle is 0.
            // Heading (Azimuth) depends on inclination and latitude.
            // sin(Az) = cos(Inc) / cos(Lat) ... roughly.
            // Let's just use the inclination as the heading for simplicity in this game.
            const inc = (currentMission.inclination || 0) * (Math.PI / 180);
            
            const velDir = new THREE.Vector3()
                .addScaledVector(east, Math.cos(inc))
                .addScaledVector(north, Math.sin(inc))
                .normalize();
                
            shipVelocity.copy(velDir.multiplyScalar(currentMission.startVel));
            
            // Setup Ghost Ship (The "Gold Standard")
            setupGhostShip(currentMission);
            
            // Pause and show launch overlay
            isPaused = true;
            document.getElementById('launch-overlay').style.display = 'flex';
            document.getElementById('launch-title').textContent = currentMission.name.toUpperCase();
            document.getElementById('launch-desc').textContent = currentMission.desc;
            
            // Force HUD update immediately (visuals only)
            // updatePhysics(0); // Don't run physics, just render
        }

        function initiateLaunch() {
            isPaused = false;
            document.getElementById('launch-overlay').style.display = 'none';
            
            // Apply Launch Burn if destination exists (Voyage Mode)
            if (currentMission.destDist) {
                // Calculate Injection Burn (Hohmann Transfer or Escape)
                const r = shipPosition.length();
                const mu = (G * currentMission.bodyMass) * 1e-9; // km^3/s^2
                const v_current = shipVelocity.length();
                
                let targetV = 0;
                
                if (currentMission.name.includes("Longshot") || currentMission.name.includes("Hail")) {
                    // Interstellar: Escape Velocity + Cruise Speed
                    const v_escape = Math.sqrt(2 * mu / r);
                    targetV = v_escape + 30.0; // High speed cruise (was 10, made faster for effect)
                } else {
                    // Interplanetary/Lunar: Hohmann Transfer
                    const r2 = currentMission.destDist;
                    const a_transfer = (r + r2) / 2;
                    targetV = Math.sqrt(mu * (2/r - 1/a_transfer));
                }
                
                const deltaV = targetV - v_current;
                
                if(deltaV > 0) {
                    const burnVec = shipVelocity.clone().normalize().multiplyScalar(deltaV);
                    shipVelocity.add(burnVec);
                    showNotification("INJECTION BURN: +" + deltaV.toFixed(2) + " km/s");
                    
                    // Visual Effect (Engine Plume)
                    for(let i=0; i<10; i++) createParticles(new THREE.Vector3(0,0,0)); // Visual pos is 0,0,0
                } else {
                     showNotification("MISSION START: " + currentMission.name);
                }
            } else {
                showNotification("ORBIT ESTABLISHED");
            }
            
            playSound('place'); 
        }

        function createMarker(color, label) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#' + color.toString(16).padStart(6, '0');
            ctx.font = 'bold 40px Arial';
            ctx.fillText("‚óâ " + label, 10, 50);
            
            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
            const sprite = new THREE.Sprite(mat);
            sprite.scale.set(100, 25, 1); // Base scale
            return sprite;
        }

        function updateTimelineDisplay() {
            if(!currentMission.timeline || currentEventIndex >= currentMission.timeline.length) {
                document.getElementById('next-event-title').textContent = "MISSION COMPLETE";
                document.getElementById('next-event-desc').textContent = "All objectives met.";
                return;
            }
            const evt = currentMission.timeline[currentEventIndex];
            document.getElementById('next-event-title').textContent = "NEXT: " + evt.title;
            document.getElementById('next-event-desc').textContent = evt.desc;
        }

        function skipToNextEvent() {
            if(!currentMission.timeline || currentEventIndex >= currentMission.timeline.length) return;
            
            const evt = currentMission.timeline[currentEventIndex];
            
            // Execute Event
            const result = evt.action({
                velocity: shipVelocity,
                position: shipPosition
            }, currentMission);
            
            showNotification(result);
            
            // If it's a distance trigger (LOI), we might want to teleport the ship closer?
            if(evt.condition) {
                if(evt.title.includes("Lunar Orbit")) {
                    // Teleport to Moon
                    const dist = currentMission.destDist - 5000; // 5000km from moon
                    // Move ship along Z axis (simplified)
                    shipPosition.set(0, 0, -dist);
                    // Update visuals immediately
                    updatePhysics(0);
                }
            }
            
            currentEventIndex++;
            updateTimelineDisplay();
            updateTimelineBar();
            playSound('place');
        }

        function checkTimelineEvents() {
            if(!currentMission.timeline || currentEventIndex >= currentMission.timeline.length) return;
            
            const evt = currentMission.timeline[currentEventIndex];
            let triggered = false;
            
            if(evt.time !== undefined && physicsTime >= evt.time) {
                triggered = true;
            } else if(evt.condition) {
                if(evt.condition({position: shipPosition, velocity: shipVelocity}, currentMission)) {
                    triggered = true;
                }
            }
            
            if(triggered) {
                const result = evt.action({
                    velocity: shipVelocity,
                    position: shipPosition
                }, currentMission);
                showNotification(result);
                currentEventIndex++;
                updateTimelineDisplay();
                updateTimelineBar();
                playSound('place');
            }
        }



        // --- Satellite System ---
        // Variables declared earlier
        // let satMeshes = [];
        // let currentTargetIndex = -1; // -1 = Player Ship

        const REAL_SATELLITES = [
            { name: "ISS (Zarya)", color: 0xffffff, alt: 408, inc: 51.6, phase: 0, speed: 0.0011, year: 1998 },
            { name: "Hubble", color: 0x00ff00, alt: 540, inc: 28.5, phase: 2.0, speed: 0.0010, year: 1990 },
            { name: "Tiangong", color: 0xff0000, alt: 380, inc: 41.5, phase: 4.0, speed: 0.0012, year: 2021 },
            { name: "Space Shuttle (Atlantis)", color: 0xffffff, alt: 350, inc: 51.6, phase: 1.5, speed: 0.0012, year: 1985 },
            { name: "Sputnik 1", color: 0xaaaaaa, alt: 577, inc: 65.1, phase: 3.5, speed: 0.0010, year: 1957 },
            { name: "Starlink-1001", color: 0xaaaaaa, alt: 550, inc: 53.0, phase: 1.0, speed: 0.0010, year: 2019 },
            { name: "Starlink-1002", color: 0xaaaaaa, alt: 550, inc: 53.0, phase: 1.1, speed: 0.0010, year: 2019 },
            { name: "Starlink-1003", color: 0xaaaaaa, alt: 550, inc: 53.0, phase: 1.2, speed: 0.0010, year: 2019 },
            { name: "NOAA-19", color: 0xffff00, alt: 850, inc: 98.7, phase: 3.0, speed: 0.0009, year: 2009 }, // Polar
            { name: "GPS-IIF", color: 0x00ffff, alt: 20200, inc: 55.0, phase: 5.0, speed: 0.0003, year: 2010 } // MEO
        ];

        function createRealSatellites() {
            // Clear old
            satMeshes.forEach(m => scene.remove(m));
            satMeshes = [];
            
            // Shared Materials
            const bodyMat = new THREE.MeshStandardMaterial({color: 0xcccccc, roughness: 0.4, metalness: 0.6});
            const panelMat = new THREE.MeshStandardMaterial({color: 0x3366ff, roughness: 0.2, metalness: 0.8, emissive: 0x112244});
            const goldMat = new THREE.MeshStandardMaterial({color: 0xffaa00, roughness: 0.3, metalness: 0.9});
            
            REAL_SATELLITES.forEach(sat => {
                // Filter by Mission Year if in Mission Mode
                if (missionMode && currentMission && currentMission.year) {
                    if (sat.year > currentMission.year) return;
                }

                // Use detailed model if available, otherwise sphere
                let mesh;
                
                // Check if we have a custom model logic for this name
                if (sat.name.includes("ISS") || sat.name.includes("Hubble") || sat.name.includes("Tiangong") || sat.name.includes("Shuttle") || sat.name.includes("Sputnik")) {
                    mesh = createSatelliteModel(sat.name, bodyMat, panelMat, goldMat);
                } else {
                    // Generic Sphere
                    const geo = new THREE.SphereGeometry(10, 16, 16); 
                    const mat = new THREE.MeshBasicMaterial({ color: sat.color }); // Basic is fine for dots
                    mesh = new THREE.Mesh(geo, mat);
                }
                
                mesh.userData = { ...sat }; // Copy data
                
                scene.add(mesh);
                satMeshes.push(mesh);
                
                // Add Label
                const label = createMarker(sat.color, sat.name);
                label.scale.set(500, 125, 1);
                label.position.set(0, 50, 0);
                mesh.add(label);
            });
        }

        function updateRealSatellites(simTime) {
            // if(!missionMode) return; // Allow in builder mode too
            
            const time = simTime !== undefined ? simTime : Date.now() * 0.0001; // Use provided time or global
            
            satMeshes.forEach(mesh => {
                const sat = mesh.userData;
                
                // Simple Circular Orbit Calculation
                // We need to position them relative to the SHIP (which is at 0,0,0 visually)
                // But the PLANET is at -shipPosition.
                // So World Center is at -shipPosition.
                // Satellite Position relative to World Center:
                
                const r = (6371 + sat.alt) * SCALE_FACTOR; // Scaled radius
                const theta = (time * sat.speed * 100) + sat.phase; // Anomaly
                
                // Orbital Plane
                const x = r * Math.cos(theta);
                const z = r * Math.sin(theta);
                const y = 0;
                
                // Apply Inclination (Rotate around X axis)
                const incRad = sat.inc * (Math.PI / 180);
                const y_inc = z * Math.sin(incRad);
                const z_inc = z * Math.cos(incRad);
                
                // Position relative to Earth Center
                const satPosRelEarth = new THREE.Vector3(x, y_inc, z_inc);
                
                // Earth Position in Scene
                const earthPos = celestialBody.position;
                
                // Final Position = EarthPos + SatPosRelEarth
                mesh.position.copy(earthPos).add(satPosRelEarth);
                
                // Rotate to face velocity?
                mesh.lookAt(earthPos); // Look at earth for now
            });
        }

        function cycleTarget(dir) {
            // Mission Mode POI Logic
            if(missionMode && currentMission && currentMission.pois) {
                const max = currentMission.pois.length;
                currentTargetIndex += dir;
                if(currentTargetIndex < -1) currentTargetIndex = max - 1;
                if(currentTargetIndex >= max) currentTargetIndex = -1;
                
                let name = "PLAYER SHIP";
                let targetPos = new THREE.Vector3(0,0,0); // Ship is at 0,0,0 visually
                let targetRadius = 10;

                if(currentTargetIndex !== -1) {
                    const poi = currentMission.pois[currentTargetIndex];
                    name = poi.name;
                    
                    // Calculate POI visual position relative to ship
                    // Visual Pos = (POI.pos - shipPosition) * SCALE_FACTOR
                    const poiVec = poi.pos.clone();
                    targetPos = poiVec.sub(shipPosition).multiplyScalar(SCALE_FACTOR);
                    
                    if(name === "Earth") targetRadius = 6371;
                    if(name === "Moon") targetRadius = 1737;
                }
                
                showNotification("TARGET: " + name);
                document.getElementById('target-name').textContent = name;
                
                // Update Camera
                if(cameraMode !== 'CHASE' && cameraMode !== 'TELESCOPE') {
                    cameraMode = 'CHASE';
                }
                
                // Snap camera
                let offset = new THREE.Vector3(20, 10, 20);
                if(name === "Earth") offset.set(0, 10000, 20000);
                if(name === "Moon") offset.set(0, 3000, 6000);
                if(name === "Alpha Centauri") offset.set(0, 1000, 2000);
                
                // Smooth transition if possible, but snap for now
                camera.position.copy(targetPos).add(offset);
                orbitControls.target.copy(targetPos);
                orbitControls.update();
                
                return;
            }

            // Standard Satellite Logic
            currentTargetIndex += dir;
            if(currentTargetIndex < -1) currentTargetIndex = satMeshes.length - 1;
            if(currentTargetIndex >= satMeshes.length) currentTargetIndex = -1;
            
            const name = currentTargetIndex === -1 ? "PLAYER SHIP" : satMeshes[currentTargetIndex].userData.name;
            showNotification("TARGET: " + name);
            
            // Update UI
            document.getElementById('target-name').textContent = name;
            
            // Force Camera to CHASE mode so it tracks the new target
            if(cameraMode !== 'CHASE' && cameraMode !== 'TELESCOPE') {
                cameraMode = 'CHASE';
                showNotification("CAMERA: CHASE");
            }
            
            // Snap camera to new target immediately to avoid "lost in space" feeling
            if(currentTargetIndex !== -1 && satMeshes[currentTargetIndex]) {
                const targetPos = satMeshes[currentTargetIndex].position;
                // Offset camera slightly from target
                camera.position.copy(targetPos).add(new THREE.Vector3(20, 10, 20));
                orbitControls.target.copy(targetPos);
            } else {
                // Snap back to ship
                camera.position.set(20, 10, 20);
                orbitControls.target.set(0,0,0);
            }
            orbitControls.update();
        }

        function updateTimelineBar() {
            const container = document.getElementById('timeline-bar-container');
            if(!container || !currentMission || !currentMission.timeline) return;
            
            let html = '<div id="timeline-progress" style="position: absolute; top: 0; left: 0; height: 100%; width: 0%; background: var(--accent); opacity: 0.5;"></div>';
            
            const totalEvents = currentMission.timeline.length;
            
            currentMission.timeline.forEach((evt, i) => {
                const pct = totalEvents > 1 ? (i / (totalEvents - 1)) * 100 : 0;
                html += `<div class="timeline-marker" style="position: absolute; left: ${pct}%; top: 0; width: 4px; height: 100%; background: #fff; cursor: pointer; z-index:10;" title="${evt.title}" onclick="jumpToEvent(${i})"></div>`;
            });
            
            container.innerHTML = html;
            
            // Update Progress
            const progressPct = totalEvents > 1 ? (currentEventIndex / (totalEvents - 1)) * 100 : 0;
            const bar = container.querySelector('#timeline-progress');
            if(bar) bar.style.width = Math.min(100, Math.max(0, progressPct)) + "%";
        }
        
        window.jumpToEvent = function(index) {
            if(!currentMission || !currentMission.timeline) return;
            if(index < 0 || index >= currentMission.timeline.length) return;
            currentEventIndex = index;
            skipToNextEvent();
        };

        function setupMissionScene(mission, missionId) {
            // Clear existing scene elements except station
            if(planet) scene.remove(planet);
            if(sun) scene.remove(sun);
            if(rings) scene.remove(rings);
            if(destinationBody) scene.remove(destinationBody);
            
            // Create Celestial Body (Origin)
            // Ensure radius is at least 1 to avoid rendering issues
            const radius = Math.max(1, mission.bodyRadius * SCALE_FACTOR);
            const geo = new THREE.SphereGeometry(radius, 64, 64);
            
            // Try to reuse Earth texture if available, otherwise color
            let mat;
            if(mission.name.includes("Earth") || mission.name.includes("Vostok") || mission.name.includes("Apollo") || mission.name.includes("Shuttle") || mission.name.includes("Hail")) {
                 const textureLoader = new THREE.TextureLoader();
                 const earthTexture = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_atmos_2048.jpg');
                 const earthNormal = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_normal_2048.jpg');
                 const earthSpecular = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_specular_2048.jpg');
                 mat = new THREE.MeshPhongMaterial({
                    map: earthTexture,
                    normalMap: earthNormal,
                    specularMap: earthSpecular,
                    specular: new THREE.Color(0x333333),
                    shininess: 5
                });
            } else {
                mat = new THREE.MeshStandardMaterial({
                    color: mission.bodyColor,
                    roughness: 0.8,
                    emissive: 0x000000
                });
            }
            
            celestialBody = new THREE.Mesh(geo, mat);
            scene.add(celestialBody);
            
            // Add Marker for Origin
            const originMarker = createMarker(mission.bodyColor, "EARTH");
            originMarker.position.set(0, radius + 50, 0); // Offset
            celestialBody.add(originMarker); // Attach to body

            // Adjust Camera Clip Planes for large scales
            camera.near = 0.1;
            camera.far = 1000000000000; // 1 Trillion units (covers solar system scale)
            camera.updateProjectionMatrix();

            // Create Destination Body (if any)
            if(mission.destDist) {
                // Use Moon texture if available
                let dMat;
                let dGeo;
                
                if(mission.destName === "Moon") {
                    dGeo = new THREE.SphereGeometry(1737 * SCALE_FACTOR, 64, 64); // Real Moon Radius
                    const textureLoader = new THREE.TextureLoader();
                    const moonTexture = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/moon_1024.jpg');
                    dMat = new THREE.MeshStandardMaterial({
                        map: moonTexture,
                        roughness: 0.9,
                        metalness: 0.0
                    });
                } else {
                    dGeo = new THREE.SphereGeometry(1000 * SCALE_FACTOR, 32, 32); // Generic
                    dMat = new THREE.MeshBasicMaterial({
                        color: mission.destColor,
                        transparent: true,
                        opacity: 0.8
                    });
                }
                
                destinationBody = new THREE.Mesh(dGeo, dMat);
                // Position will be updated in physics loop relative to ship
                scene.add(destinationBody);
                
                // Add Marker for Destination (Only if far away)
                // If we are close, hide marker so it doesn't block view
                let marker = destinationBody.getObjectByName("destMarker");
                if(!marker) {
                    marker = createMarker(mission.destColor, mission.destName || "TARGET");
                    marker.name = "destMarker";
                    marker.position.set(0, (destinationBody.geometry.parameters.radius || 1500) * 1.2, 0);
                    marker.scale.set(50000, 12500, 1); 
                    destinationBody.add(marker);
                }
                
                // Initial position calculation for marker visibility check
                const destPos = new THREE.Vector3(0, 0, -mission.destDist);
                const relDest = destPos.sub(shipPosition).multiplyScalar(SCALE_FACTOR);
                destinationBody.position.copy(relDest);

                if(relDest.length() < (destinationBody.geometry.parameters.radius * 5)) {
                    marker.visible = false;
                } else {
                    marker.visible = true;
                }
            }
            
            // Lighting
            // Use a target for the directional light that follows the ship/camera focus
            const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
            sunLight.position.set(10000, 5000, 10000); // Direction vector
            scene.add(sunLight);
            scene.add(sunLight.target); // Add target to scene so we can move it
            
            // Ambient light for deep space (so shadows aren't pitch black)
            const ambient = new THREE.AmbientLight(0x111111);
            scene.add(ambient);
            
            // Group station modules into a single ship object for physics
            // If station is empty, spawn a default ship
            if(station.length === 0) {
                if(missionId === 'hail_mary') {
                    buildFromData(PRESETS['hail_mary']);
                } else {
                    buildFromData(PRESETS['default']);
                }
            } else if (missionId === 'hail_mary' && confirm("Load 'Hail Mary' configuration for this mission?")) {
                 // Clear existing
                station.forEach(m => scene.remove(m));
                station = [];
                buildFromData(PRESETS['hail_mary']);
            }
            
            // Reset Camera
            cameraMode = 'MAP'; // Default to MAP for better situational awareness
            camIndex = CAM_MODES.indexOf('MAP');
            updateCameraModeDisplay();
            
            // Force camera to look at ship immediately
            // Ship is at 0,0,0 visually.
            // Camera needs to be offset.
            // If ship is small (10m), camera should be close (50m).
            // If ship is huge (1km), camera should be far (2km).
            
            // Calculate ship size
            let shipRadius = 10; // Default
            if(station.length > 0) {
                const box = new THREE.Box3();
                station.forEach(m => box.expandByObject(m));
                const sphere = new THREE.Sphere();
                box.getBoundingSphere(sphere);
                shipRadius = sphere.radius;
            }
            
            // Set initial camera position
            const dist = Math.max(shipRadius * 3, 50);
            camera.position.set(dist, dist * 0.5, dist);
            orbitControls.target.set(0,0,0);
            orbitControls.update();
            
            // Setup Visual Effects
            createSpaceDust();
            setupTrajectoryLines();
            createRealSatellites();

            // Initialize N-Body System
            activeBodies = [];
            
            // Always add Primary Body (Earth/Sun)
            activeBodies.push({
                name: currentMission.bodyName || "Earth",
                mass: currentMission.bodyMass,
                radius: currentMission.bodyRadius,
                pos: new THREE.Vector3(0,0,0),
                mesh: celestialBody // Link to the visual mesh
            });

            // Add Secondary Bodies (Moon, etc)
            if(currentMission.bodies) {
                currentMission.bodies.forEach(def => {
                    // Create visual mesh for secondary body
                    let mesh;
                    if(def.name === "Moon") {
                        if(moon) {
                            mesh = moon;
                            mesh.visible = true;
                        } else {
                            // Create Moon if missing
                            const geo = new THREE.SphereGeometry(def.radius * SCALE_FACTOR, 32, 32);
                            const tex = new THREE.TextureLoader().load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/moon_1024.jpg');
                            const mat = new THREE.MeshStandardMaterial({ map: tex, roughness: 0.9 });
                            mesh = new THREE.Mesh(geo, mat);
                            scene.add(mesh);
                            moon = mesh;
                        }
                    }
                    
                    activeBodies.push({
                        name: def.name,
                        mass: def.mass,
                        radius: def.radius,
                        pos: def.orbit ? new THREE.Vector3(def.orbit.a, 0, 0) : new THREE.Vector3(0,0,0),
                        mesh: mesh
                    });
                });
            }
        }

        function createSpaceDust() {
            if(spaceDust) scene.remove(spaceDust);
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<2000; i++) {
                pos.push(
                    (Math.random()-0.5)*1000,
                    (Math.random()-0.5)*1000,
                    (Math.random()-0.5)*1000
                );
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({
                color: 0x88ccff,
                size: 0.5,
                transparent: true,
                opacity: 0.6
            });
            spaceDust = new THREE.Points(geo, mat);
            scene.add(spaceDust);
        }

        let currentOrbitLine = null;

        function setupTrajectoryLines() {
            if(historyLine) scene.remove(historyLine);
            if(predictedLine) scene.remove(predictedLine);
            if(currentOrbitLine) scene.remove(currentOrbitLine);
            
            // History (Green)
            const hGeo = new THREE.BufferGeometry();
            // Pre-allocate buffer
            hGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(MAX_TRAIL_POINTS * 3), 3));
            hGeo.setDrawRange(0, 0);
            const hMat = new THREE.LineBasicMaterial({ color: 0x00ff00, opacity: 0.5, transparent: true });
            historyLine = new THREE.Line(hGeo, hMat);
            historyLine.userData.points = [];
            scene.add(historyLine);
            
            // Prediction (Blue Dotted)
            const pGeo = new THREE.BufferGeometry();
            pGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(PREDICTION_STEPS * 3), 3));
            const pMat = new THREE.LineBasicMaterial({ color: 0x00ffff, opacity: 0.5, transparent: true });
            predictedLine = new THREE.Line(pGeo, pMat);
            scene.add(predictedLine);

            // Current Orbit (Yellow Solid)
            const oGeo = new THREE.BufferGeometry();
            oGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(361 * 3), 3)); // 360 degrees + close
            const oMat = new THREE.LineBasicMaterial({ color: 0xffff00, opacity: 0.8, transparent: true });
            currentOrbitLine = new THREE.Line(oGeo, oMat);
            scene.add(currentOrbitLine);
        }

        function updateKeplerianOrbit() {
            if(!currentOrbitLine || !currentMission) return;

            // Calculate Orbital Elements
            const rVec = shipPosition.clone();
            const vVec = shipVelocity.clone();
            const r = rVec.length();
            const v = vVec.length();
            const mu = G * currentMission.bodyMass * 1e-9; // Convert to km^3/s^2 (G is in m^3/kg/s^2, Mass in kg. Result m^3/s^2. /1e9 for km^3)
            // Wait, G = 6.67e-11 m^3/kg/s^2. Mass ~ 6e24 kg.
            // mu = 4e14 m^3/s^2 = 4e5 km^3/s^2.
            // Let's use the G constant defined: 6.67430e-11.
            // Mass is in kg.
            // We need mu in km^3/s^2 because pos is in km and vel is in km/s.
            // 1 m = 0.001 km. 1 m^3 = 1e-9 km^3.
            const mu_km = (G * currentMission.bodyMass) * 1e-9;

            // Specific Angular Momentum h = r x v
            const hVec = new THREE.Vector3().crossVectors(rVec, vVec);
            const h = hVec.length();

            // Eccentricity Vector e = ((v^2 - mu/r)*r - (r.v)*v) / mu
            const term1 = rVec.clone().multiplyScalar(v*v - mu_km/r);
            const term2 = vVec.clone().multiplyScalar(rVec.dot(vVec));
            const eVec = term1.sub(term2).divideScalar(mu_km);
            const e = eVec.length();

            // Semi-major axis a = 1 / (2/r - v^2/mu)
            const energy = (v*v)/2 - mu_km/r;
            const a = -mu_km / (2*energy);

            // Draw Orbit
            const positions = currentOrbitLine.geometry.attributes.position.array;
            const visualShipPos = shipPosition.clone().multiplyScalar(SCALE_FACTOR);

            // Coordinate System Basis Vectors for the Orbit Plane
            // P points to periapsis (along eVec)
            // W is normal to plane (along hVec)
            // Q completes the triad (W x P)
            
            let P = new THREE.Vector3(1,0,0);
            if(e > 1e-5) {
                P = eVec.clone().normalize();
            } else {
                // Circular orbit, P is arbitrary in plane. Use rVec direction?
                P = rVec.clone().normalize();
            }
            
            const W = hVec.clone().normalize();
            const Q = new THREE.Vector3().crossVectors(W, P);

            // Generate points
            // If e < 1 (Ellipse)
            if(e < 1.0) {
                const p = a * (1 - e*e); // Semi-latus rectum
                
                for(let i=0; i<=360; i++) {
                    const theta = (i / 180) * Math.PI;
                    const r_theta = p / (1 + e * Math.cos(theta));
                    
                    // Position in orbital plane
                    const x = r_theta * Math.cos(theta);
                    const y = r_theta * Math.sin(theta);
                    
                    // Transform to 3D space
                    // Pos = x*P + y*Q
                    const pos3D = P.clone().multiplyScalar(x).add(Q.clone().multiplyScalar(y));
                    
                    // Transform to Visual Space (relative to ship)
                    // In our visual frame, Ship is at 0,0,0.
                    // The Orbit Line is fixed in space relative to the Planet.
                    // Planet is at -visualShipPos.
                    // So Orbit Line points should be relative to Planet, then shifted by Planet Position.
                    // Planet Position = -visualShipPos.
                    // Point = (Pos3D * SCALE) + PlanetPos
                    //       = (Pos3D * SCALE) - visualShipPos
                    
                    const vis = pos3D.multiplyScalar(SCALE_FACTOR).sub(visualShipPos);
                    
                    positions[i*3] = vis.x;
                    positions[i*3+1] = vis.y;
                    positions[i*3+2] = vis.z;
                }
                currentOrbitLine.geometry.setDrawRange(0, 361);
            } else {
                // Hyperbola (Escape)
                // Draw a segment around the current anomaly
                // Just draw the predicted line instead?
                // Or draw the hyperbolic curve for a range of true anomaly
                // Limit theta to -acos(-1/e) < theta < acos(-1/e)
                
                const limit = Math.acos(-1/e) - 0.1; // Stay within asymptotes
                const start = -limit;
                const end = limit;
                const p = a * (1 - e*e);
                
                for(let i=0; i<=360; i++) {
                    const t = i/360;
                    const theta = start + t * (end - start);
                    const r_theta = p / (1 + e * Math.cos(theta));
                    
                    const x = r_theta * Math.cos(theta);
                    const y = r_theta * Math.sin(theta);
                    
                    const pos3D = P.clone().multiplyScalar(x).add(Q.clone().multiplyScalar(y));
                    const vis = pos3D.multiplyScalar(SCALE_FACTOR).sub(visualShipPos);
                    
                    positions[i*3] = vis.x;
                    positions[i*3+1] = vis.y;
                    positions[i*3+2] = vis.z;
                }
                currentOrbitLine.geometry.setDrawRange(0, 361);
            }
            
            currentOrbitLine.geometry.attributes.position.needsUpdate = true;
        }

        function updateSpaceDust(dt) {
            if(!spaceDust || !missionMode) return;
            
            // Move dust opposite to ship velocity
            // We use a scaled velocity for visual effect, clamped so it doesn't look crazy at warp
            // Actually, we want to feel the speed.
            
            const positions = spaceDust.geometry.attributes.position.array;
            const vel = shipVelocity.clone().multiplyScalar(SCALE_FACTOR * 0.1); // Visual scale
            
            // If velocity is huge (interstellar), we need to fake it or it blurs out
            // Let's just move them along Z if speed is high to simulate "warp stars"
            
            for(let i=0; i<2000; i++) {
                let ix = i*3;
                let iy = i*3+1;
                let iz = i*3+2;
                
                // Move relative to camera (which is effectively 0,0,0 in chase mode)
                // But we want them to stream past.
                
                // Simple: Move dust by -velocity
                positions[ix] -= vel.x;
                positions[iy] -= vel.y;
                positions[iz] -= vel.z;
                
                // Wrap around box 1000x1000x1000
                if(positions[ix] < -500) positions[ix] += 1000;
                if(positions[ix] > 500) positions[ix] -= 1000;
                if(positions[iy] < -500) positions[iy] += 1000;
                if(positions[iy] > 500) positions[iy] -= 1000;
                if(positions[iz] < -500) positions[iz] += 1000;
                if(positions[iz] > 500) positions[iz] -= 1000;
            }
            spaceDust.geometry.attributes.position.needsUpdate = true;
        }

        function updateTrajectoryVisuals() {
            if(!historyLine || !predictedLine) return;
            
            updateKeplerianOrbit();
            
            // 1. Update History
            // We store positions relative to the Celestial Body (Origin)
            // But visually, the Celestial Body moves.
            // So we need to draw lines in the "World Space" where Ship is (0,0,0).
            // This means the history points need to shift every frame? That's expensive.
            
            // Better approach:
            // The Scene is "Ship-Centric". Ship is at 0,0,0.
            // Everything else moves.
            // So a point in history at (x,y,z) relative to ship *at that time* 
            // is now at (x-dx, y-dy, z-dz) relative to ship.
            
            // Actually, let's define points in "Solar System Space" (Origin = Sun/Earth).
            // Then transform them to "Ship Space" for rendering.
            
            // Add current pos to history (Solar System Space)
            // Only add if far enough from last point
            const lastPoint = historyLine.userData.points[historyLine.userData.points.length-1];
            const currentPos = shipPosition.clone();
            
            if(!lastPoint || currentPos.distanceTo(lastPoint) > (currentMission.bodyRadius * 0.05)) {
                historyLine.userData.points.push(currentPos);
                if(historyLine.userData.points.length > MAX_TRAIL_POINTS) {
                    historyLine.userData.points.shift();
                }
            }
            
            // Render History
            // Transform points to Visual Space (relative to ship)
            const hPos = historyLine.geometry.attributes.position.array;
            const visualShipPos = shipPosition.clone().multiplyScalar(SCALE_FACTOR);
            
            let count = 0;
            for(let i=0; i<historyLine.userData.points.length; i++) {
                const pt = historyLine.userData.points[i].clone().multiplyScalar(SCALE_FACTOR);
                // Vector from Ship to Point
                const rel = pt.sub(visualShipPos);
                
                hPos[count*3] = rel.x;
                hPos[count*3+1] = rel.y;
                hPos[count*3+2] = rel.z;
                count++;
            }
            historyLine.geometry.setDrawRange(0, count);
            historyLine.geometry.attributes.position.needsUpdate = true;
            
            // 2. Update Prediction
            // Simulate N steps ahead
            const pPos = predictedLine.geometry.attributes.position.array;
            let simPos = shipPosition.clone();
            let simVel = shipVelocity.clone();
            
            // Adaptive Step Size
            // For LEO, we need small steps. For Moon transfer, we need large steps.
            // Let's base it on altitude or velocity?
            // Or just use a large step for visualization (e.g. 60s)
            let simDt = 60; // 1 minute steps
            
            // If we are very fast (interstellar), increase step
            if(simVel.length() > 100) simDt = 1000;
            if(simVel.length() > 10000) simDt = 100000;

            // Clone bodies for prediction so we don't mess up the main simulation
            // We need to propagate bodies too!
            // Simple analytic propagation for prediction loop
            const simBodies = activeBodies.map(b => ({
                ...b,
                pos: b.pos.clone(),
                orbit: b.orbit // Keep orbit ref
            }));
            
            for(let i=0; i<PREDICTION_STEPS; i++) {
                // Propagate Bodies (Analytic)
                const simTime = physicsTime + (i * simDt);
                simBodies.forEach(b => {
                    if(b.orbit && b.orbit.a) {
                        const n = Math.sqrt((G_KM * simBodies[0].mass) / Math.pow(b.orbit.a, 3));
                        const theta = n * simTime + (b.orbit.phase || 0);
                        b.pos.x = Math.cos(theta) * b.orbit.a;
                        b.pos.z = Math.sin(theta) * b.orbit.a;
                        b.pos.y = 0;
                    }
                });

                // RK4 Step for Ship
                rk4Step(simPos, simVel, simDt, simBodies);
                
                // Transform to visual space
                // Visual = (SimPos - ShipPos) * SCALE
                // Note: We are drawing relative to the CURRENT ship position.
                // So the line starts at 0,0,0.
                const vis = simPos.clone().multiplyScalar(SCALE_FACTOR).sub(visualShipPos);
                
                pPos[i*3] = vis.x;
                pPos[i*3+1] = vis.y;
                pPos[i*3+2] = vis.z;
            }
            predictedLine.geometry.attributes.position.needsUpdate = true;
        }

        function endMission(success) {
            missionMode = false;
            isPaused = false;
            document.getElementById('flight-ui').style.display = 'none';
            const summary = document.getElementById('mission-summary');
            summary.style.display = 'flex';
            
            document.getElementById('summary-subtitle').textContent = success ? "ARRIVAL CONFIRMED" : "MISSION ABORTED";
            document.getElementById('summary-time').textContent = formatTime(physicsTime);
            document.getElementById('summary-dist').textContent = formatDistance(shipPosition.length());
            document.getElementById('summary-vel').textContent = maxVelocity.toFixed(2) + " KM/S";
            
            drawFlightGraph();
        }

        function closeMissionSummary() {
            document.getElementById('mission-summary').style.display = 'none';
            document.getElementById('title-screen').style.display = 'flex';
            
            // Reset scene to builder mode
            station.forEach(m => scene.remove(m));
            station = [];
            loadStation(); // Reload saved station or default
            
            // Restore builder UI
            document.getElementById('stats').style.display = 'block';
            document.getElementById('controls-info').style.display = 'block';
            document.querySelector('.data-controls').style.display = 'flex'; // Restore builder controls
            document.getElementById('mode-indicator').textContent = "FLIGHT MODE";
            document.getElementById('mode-indicator').style.color = "rgba(255, 255, 255, 0.5)";
        }

        function drawFlightGraph() {
            const canvas = document.getElementById('flight-graph');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if(flightHistory.length < 2) return;
            
            // Draw Velocity Curve
            ctx.beginPath();
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 2;
            
            const maxT = flightHistory[flightHistory.length-1].t;
            const maxV = maxVelocity;
            
            flightHistory.forEach((pt, i) => {
                const x = (pt.t / maxT) * canvas.width;
                const y = canvas.height - ((pt.v / maxV) * (canvas.height - 20)) - 10;
                if(i===0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            
            // Draw Distance Curve
            ctx.beginPath();
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2;
            const maxD = currentMission.destDist || flightHistory[flightHistory.length-1].d;
            
            flightHistory.forEach((pt, i) => {
                const x = (pt.t / maxT) * canvas.width;
                const y = canvas.height - ((pt.d / maxD) * (canvas.height - 20)) - 10;
                if(i===0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            
            // Legend
            ctx.fillStyle = '#00ffff';
            ctx.fillText("VELOCITY", 10, 180);
            ctx.fillStyle = '#00ff00';
            ctx.fillText("DISTANCE", 80, 180);
        }

        function cycleCamera() {
            camIndex = (camIndex + 1) % CAM_MODES.length;
            cameraMode = CAM_MODES[camIndex];
            updateCameraModeDisplay();
            playSound('hover');
        }

        function toggleMapMode() {
            if(cameraMode === 'MAP') {
                cameraMode = 'CHASE';
                showNotification("CAMERA: CHASE");
            } else {
                cameraMode = 'MAP';
                showNotification("CAMERA: SYSTEM MAP");
            }
            updateCameraModeDisplay();
        }

        function updateCameraModeDisplay() {
            document.getElementById('cam-mode-display').textContent = cameraMode + " CAM";
        }

        function setupGhostShip(mission) {
            const geo = new THREE.ConeGeometry(1, 3, 8);
            geo.rotateX(Math.PI/2);
            const mat = new THREE.MeshBasicMaterial({
                color: mission.ghostColor, 
                wireframe: true,
                transparent: true, 
                opacity: 0.5
            });
            ghostShip = new THREE.Mesh(geo, mat);
            scene.add(ghostShip);
            
            // Ghost physics state - Match ship start
            ghostShip.userData = {
                pos: shipPosition.clone(),
                vel: shipVelocity.clone()
            };
            
            // Create orbit trails
            const trailGeo = new THREE.BufferGeometry();
            const trailMat = new THREE.LineBasicMaterial({ color: 0x00ff00 });
            orbitLine = new THREE.Line(trailGeo, trailMat);
            scene.add(orbitLine);
        }

        function setTimeWarp(val) {
            timeWarp = val;
            const display = document.getElementById('warp-display');
            if(display) display.textContent = val + "x";
            showNotification("TIME WARP: " + val + "x");
            isPaused = false; // Unpause if paused
        }

        let pendingMessages = [];

        function pingEarth() {
            if(!missionMode) return;
            const dist = shipPosition.length(); // Distance from origin (Earth/Sun)
            const delay = dist / C; // seconds
            
            logComms("> PING SENT...");
            
            // Schedule response
            // We use real time for the UI delay, not physics time, but scaled?
            // No, let's use real time but if time warp is high, it might be instant.
            // Let's simulate it based on the game loop.
            
            pendingMessages.push({
                time: physicsTime + (delay * 2), // Round trip in physics time
                msg: "> PING RECEIVED. TRAJECTORY NOMINAL."
            });
        }

        function logComms(txt) {
            const log = document.getElementById('comms-log');
            const line = document.createElement('div');
            line.textContent = txt;
            log.appendChild(line);
            log.scrollTop = log.scrollHeight;
        }

        function toggleAutopilot() {
            autopilotEngaged = !autopilotEngaged;
            const btn = document.getElementById('autopilot-btn');
            const ind = document.getElementById('mode-indicator');
            
            if(autopilotEngaged) {
                btn.textContent = "AUTOPILOT: ON";
                btn.style.borderColor = "#00ff00";
                btn.style.color = "#00ff00";
                ind.textContent = "AUTOPILOT ENGAGED";
                ind.style.color = "#00ff00";
                showNotification("COURSE CORRECTION INITIATED");
                // Reset delta display
                document.getElementById('mission-delta').style.display = 'none';
            } else {
                btn.textContent = "AUTOPILOT: OFF";
                btn.style.borderColor = "#ff3300";
                btn.style.color = "#ff3300";
                ind.textContent = "MANUAL CONTROL";
                ind.style.color = "#ff3300";
                showNotification("MANUAL OVERRIDE");
            }
        }

        function updatePhysics(dt) {
            if(!missionMode || !currentMission || isPaused) return;
            
            const steps = 10; // Sub-steps for stability
            const dtStep = (dt * timeWarp) / steps;
            
            physicsTime += dt * timeWarp;

            for(let i=0; i<steps; i++) {
                // Update Celestial Bodies Positions (Rails)
                updateCelestialBodies(physicsTime);

                // Ship Gravity (RK4 N-Body)
                rk4Step(shipPosition, shipVelocity, dtStep, activeBodies);
                
                // Autopilot Logic
                if(autopilotEngaged && ghostShip) {
                    // Simple P-Controller to match Ghost Velocity vector direction
                    // We don't snap position, we just try to align velocity to target
                    const targetVel = ghostShip.userData.vel.clone();
                    const currentVel = shipVelocity.clone();
                    
                    // Correction vector
                    const correction = targetVel.sub(currentVel);
                    const maxThrust = 0.005 * dtStep; // Autopilot authority
                    
                    if(correction.length() > maxThrust) {
                        correction.normalize().multiplyScalar(maxThrust);
                    }
                    
                    shipVelocity.add(correction);
                }
                
                // Ghost Gravity (RK4 N-Body)
                if(ghostShip) {
                    rk4Step(ghostShip.userData.pos, ghostShip.userData.vel, dtStep, activeBodies);
                }
            }

            // Check pending messages
            for(let i = pendingMessages.length - 1; i >= 0; i--) {
                if(physicsTime >= pendingMessages[i].time) {
                    logComms(pendingMessages[i].msg);
                    playSound('hover'); // Beep
                    pendingMessages.splice(i, 1);
                }
            }
            
            // Check Timeline Events
            checkTimelineEvents();
            
            // Update Visuals
            const visualPos = shipPosition.clone().multiplyScalar(SCALE_FACTOR);
            
            // Move celestial body (Origin) relative to ship
            celestialBody.position.copy(visualPos.clone().negate());
            
            // Rotate Earth (Day/Night cycle & visual spin)
            // Earth rotates 360 deg in 24 hours = 86400 seconds
            // Rotation speed = 2 * PI / 86400 rad/s
            const earthRotSpeed = (Math.PI * 2) / 86400;
            // Use physicsTime delta, not real time delta
            // dt * timeWarp is the amount of simulated time passed this frame
            // Ensure we are using the same dt as physics loop
            celestialBody.rotation.y += earthRotSpeed * dt * timeWarp;
            
            // Also rotate N-Body Earth if it exists (for consistency)
            if(activeBodies.length > 0 && activeBodies[0].name === "Earth") {
                 activeBodies[0].mesh.rotation.y = celestialBody.rotation.y;
            }
            
            // Move Destination Body relative to ship
            if(destinationBody && currentMission.destDist) {
                // Destination is at (0,0, -destDist) in physics space? 
                // Let's assume destination is along -Z axis for simplicity
                const destPos = new THREE.Vector3(0, 0, -currentMission.destDist);
                const relDest = destPos.sub(shipPosition).multiplyScalar(SCALE_FACTOR);
                
                // If too far, clamp visual distance so it's visible but small
                // BUT for "Galactic GPS", we want to see it even if far.
                // We use the marker to show it.
                // Let's NOT clamp the position, but scale the marker up if it's far?
                // Or just let the marker be huge.
                
                // Actually, if we don't clamp, it might be clipped by far plane.
                // Max far plane is 10,000,000.
                // Moon distance is 384,000 km. Scaled * 0.001 = 384 units.
                // That's tiny. Wait.
                // SCALE_FACTOR is 0.001. 1 unit = 1km.
                // Moon is 384 units away. That's very close in 3D space.
                // Why was it invisible?
                // Maybe camera was looking wrong way?
                
                // Let's ensure destination is always at least somewhat visible or marked.
                destinationBody.position.copy(relDest);
                destinationBody.lookAt(camera.position); 
                
                // Scale marker based on distance to keep it same screen size?
                // SpriteMaterial sizeAttenuation: false? No, we want it to be part of world.
                // Just make it huge.
            }
            
            if(ghostShip) {
                const ghostVisual = ghostShip.userData.pos.clone().multiplyScalar(SCALE_FACTOR);
                ghostShip.position.copy(ghostVisual.sub(visualPos));
                ghostShip.lookAt(ghostShip.position.clone().add(ghostShip.userData.vel));
            }
            
            // Update HUD
            const alt = shipPosition.length() - currentMission.bodyRadius;
            const vel = shipVelocity.length(); // km/s
            
            document.getElementById('mission-alt').textContent = "ALT: " + formatDistance(alt);
            document.getElementById('mission-vel').textContent = "VEL: " + vel.toFixed(2) + " km/s";
            document.getElementById('mission-timer').textContent = "T+ " + formatTime(physicsTime);
            
            // Relativistic Calcs
            const dist = shipPosition.length();
            const lightLag = dist / C; // seconds
            const lorentz = 1 / Math.sqrt(1 - (vel*vel)/(C*C));
            
            document.getElementById('light-lag').textContent = formatTime(lightLag);
            document.getElementById('lorentz').textContent = lorentz.toFixed(8);
            
            // ETA Calculation & Deviation
            if(currentMission.destDist) {
                const distToDest = currentMission.destDist - shipPosition.length(); 
                
                // Calculate Deviation from Ideal Path (Ghost)
                if(ghostShip) {
                    const idealPos = ghostShip.userData.pos;
                    const deviation = shipPosition.distanceTo(idealPos);
                    
                    // Calculate Delta-V required to fix (rough approx)
                    // Energy difference + Plane change cost
                    const deltaV = deviation * 0.0001; // Fake metric for gameplay
                    
                    if(!autopilotEngaged && deviation > 1000) {
                        const dEl = document.getElementById('mission-delta');
                        dEl.style.display = 'block';
                        dEl.textContent = "ŒîV COST: +" + deltaV.toFixed(0) + " m/s";
                        
                        // Update ETA based on current bad trajectory
                        // If we are off course, ETA increases
                        // Angle between velocity and target
                        const toTarget = new THREE.Vector3(0,0,-1); // Simplified target direction
                        const angle = shipVelocity.angleTo(toTarget);
                        const efficiency = Math.cos(angle);
                        
                        if(efficiency > 0) {
                            const eta = (distToDest / (vel * efficiency));
                            document.getElementById('mission-eta').textContent = "ETA: " + formatTime(eta) + " (DRIFTING)";
                            document.getElementById('mission-eta').style.color = "#ffaa00";
                        } else {
                            document.getElementById('mission-eta').textContent = "ETA: OFF COURSE";
                            document.getElementById('mission-eta').style.color = "#ff0000";
                        }
                    } else {
                        // Nominal
                        if(vel > 0.1) {
                            const eta = distToDest / vel;
                            document.getElementById('mission-eta').textContent = "ETA: " + formatTime(eta);
                            document.getElementById('mission-eta').style.color = "var(--accent)";
                        } else {
                            document.getElementById('mission-eta').textContent = "ETA: --";
                        }
                    }
                }
                
                // Update Progress Bar
                const totalDist = currentMission.destDist;
                const currentDist = shipPosition.length();
                const progress = Math.min(100, Math.max(0, (currentDist / totalDist) * 100));
                document.getElementById('mission-progress-bar').style.width = progress + "%";
                document.getElementById('mission-progress-container').style.display = 'block';
                
                // Track Max Velocity
                if(vel > maxVelocity) maxVelocity = vel;
                
                // Record History (every ~100 physics seconds)
                if(flightHistory.length === 0 || (physicsTime - flightHistory[flightHistory.length-1].t) > 100) {
                    flightHistory.push({t: physicsTime, d: currentDist, v: vel});
                }

                // Check for Arrival
                if(currentDist >= totalDist * 0.999) {
                    endMission(true);
                }
                
            } else {
                document.getElementById('mission-eta').textContent = "ETA: N/A";
                document.getElementById('mission-progress-container').style.display = 'none';
            }
            
            // Update Navball (Horizon)
            // Angle between position vector and camera up
            // Simplified horizon tilt
            const up = shipPosition.clone().normalize();
            const camDir = new THREE.Vector3();
            camera.getWorldDirection(camDir);
            const pitch = Math.asin(camDir.dot(up));
            const horizon = document.getElementById('navball-horizon');
            horizon.style.transform = `translateY(${pitch * 50}%)`;
            
            // Update Visual Effects
            updateSpaceDust(dt);
            updateTrajectoryVisuals();
            
            // Update Station Meshes Position
            // We need to move the station meshes to shipPosition!
            
            const visualPosForStation = shipPosition.clone().multiplyScalar(SCALE_FACTOR);
            
            // In Mission Mode, we move the world relative to the ship.
            // So the ship stays at (0,0,0) visually (plus camera offset).
            // Wait, earlier logic said:
            // "Move celestial body (Origin) relative to ship... celestialBody.position.copy(visualPos.clone().negate());"
            // This means the ship is effectively at (0,0,0) in the scene.
            
            // So we should NOT move the station meshes to visualPosForStation.
            // We should keep them at (0,0,0) (or their local offsets).
            
            // BUT, if we are using OrbitControls on the ship, and the ship is at 0,0,0, then it works.
            
            // The previous logic was:
            // m.position.copy(visualPosForStation).add(m.userData.localPos);
            // This moves the station to where the ship IS in physics space (scaled).
            // But we moved the PLANET to -shipPos.
            // So if Ship is at R, Planet is at -R.
            // If we move Station to R, and Camera looks at R...
            // Then Station is at R, Planet is at -R. Distance is 2R. WRONG.
            
            // Correct Logic for "Ship Centric" View:
            // Ship is at (0,0,0).
            // Planet is at -shipPosition.
            // Station meshes should be at (0,0,0) + localOffset.
            
            station.forEach(m => {
                if(!m.userData.localPos) {
                    m.userData.localPos = m.position.clone();
                }
                // Just local pos
                m.position.copy(m.userData.localPos);
            });

            // Update Camera Logic
            updateCameraLogic();
            
            // Render
            if(cameraMode === 'MAP') {
                renderer.render(scene, camera);
            } else {
                composer.render();
            }
        }

        function formatDistance(km) {
            if(km > 1000000) return (km/149600000).toFixed(3) + " AU";
            return Math.round(km) + " km";
        }

        function formatTime(sec) {
            if(sec < 60) return sec.toFixed(2) + "s";
            if(sec < 3600) return (sec/60).toFixed(1) + "m";
            return (sec/3600).toFixed(1) + "h";
        }

        function applyGravity(pos, vel, dt) {
            // Legacy wrapper for single-body missions or fallback
            // We now use RK4 in updatePhysics, so this might be unused or deprecated.
            // But let's keep it compatible just in case.
            if(activeBodies.length > 0) {
                // Use the first body (usually Earth)
                const body = activeBodies[0];
                const rVec = body.pos.clone().sub(pos);
                const r = rVec.length();
                const acc = (G_KM * body.mass) / (r * r);
                vel.add(rVec.normalize().multiplyScalar(acc * dt));
                pos.add(vel.clone().multiplyScalar(dt));
            }
        }

        // --- N-Body Physics Engine (RK4) ---
        
        function getAcceleration(pos, bodies) {
            const acc = new THREE.Vector3(0, 0, 0);
            for (const body of bodies) {
                const rVec = body.pos.clone().sub(pos);
                const r = rVec.length();
                // Softening parameter to prevent singularity
                const rSq = r * r + 1.0; 
                const f = (G_KM * body.mass) / rSq;
                acc.add(rVec.normalize().multiplyScalar(f));
            }
            return acc;
        }

        function rk4Step(pos, vel, dt, bodies) {
            // State: [pos, vel]
            // k1
            const k1_v = getAcceleration(pos, bodies);
            const k1_p = vel.clone();

            // k2
            const p2 = pos.clone().add(k1_p.clone().multiplyScalar(dt * 0.5));
            // We assume bodies don't move significantly during the step for the ship's integration
            // Or we could interpolate them, but for small dt it's fine.
            const k2_v = getAcceleration(p2, bodies);
            const k2_p = vel.clone().add(k1_v.clone().multiplyScalar(dt * 0.5));

            // k3
            const p3 = pos.clone().add(k2_p.clone().multiplyScalar(dt * 0.5));
            const k3_v = getAcceleration(p3, bodies);
            const k3_p = vel.clone().add(k2_v.clone().multiplyScalar(dt * 0.5));

            // k4
            const p4 = pos.clone().add(k3_p.clone().multiplyScalar(dt));
            const k4_v = getAcceleration(p4, bodies);
            const k4_p = vel.clone().add(k3_v.clone().multiplyScalar(dt));

            // Combine
            const dPos = k1_p.add(k2_p.multiplyScalar(2)).add(k3_p.multiplyScalar(2)).add(k4_p).multiplyScalar(dt / 6.0);
            const dVel = k1_v.add(k2_v.multiplyScalar(2)).add(k3_v.multiplyScalar(2)).add(k4_v).multiplyScalar(dt / 6.0);

            pos.add(dPos);
            vel.add(dVel);
        }

        function updateCelestialBodies(time) {
            // Update positions of bodies on rails (Restricted N-Body)
            // Earth is always at 0,0,0 (or barycenter)
            // Moon orbits Earth
            
            if(currentMission && currentMission.bodies) {
                currentMission.bodies.forEach(def => {
                    const body = activeBodies.find(b => b.name === def.name);
                    if(body && def.orbit && def.orbit.a) {
                        // Simple circular orbit
                        const n = Math.sqrt((G_KM * activeBodies[0].mass) / Math.pow(def.orbit.a, 3)); // Mean motion
                        const theta = n * time + (def.orbit.phase || 0);
                        body.pos.x = Math.cos(theta) * def.orbit.a;
                        body.pos.z = Math.sin(theta) * def.orbit.a;
                        body.pos.y = 0;
                        
                        // Update visual mesh if it exists
                        if(body.mesh) {
                            // Visual position relative to SHIP (which is at 0,0,0 visually)
                            // Ship is at shipPosition.
                            // Body is at body.pos.
                            // Visual = (body.pos - shipPosition) * SCALE
                            body.mesh.position.copy(body.pos.clone().sub(shipPosition).multiplyScalar(SCALE_FACTOR));
                        }
                    } else if (body && body.name === "Earth") {
                        // Earth is static at 0,0,0 usually, but we can move it if we want barycenter
                        // For now keep Earth at 0,0,0
                        if(body.mesh) {
                             body.mesh.position.copy(body.pos.clone().sub(shipPosition).multiplyScalar(SCALE_FACTOR));
                             // Rotate Earth
                             // Handled in updatePhysics loop now for consistency with timeWarp
                             // body.mesh.rotation.y = time * 0.0000727; 
                        }
                    }
                });
            }
        }

        // Modify animate to handle physics
        const clock = new THREE.Clock();
        
        function toggleAutoRotate() {
            const check = document.getElementById('auto-rotate-check');
            if(orbitControls) {
                orbitControls.autoRotate = check.checked;
            }
        }

        // --- Main Loop ---
        let builderOrbitAngle = 0;
        function animate() {
            requestAnimationFrame(animate);
            
            const dt = clock.getDelta();
            const time = Date.now() * 0.0005;

            if(missionMode) {
                // Physics Loop
                if (!isPaused) {
                    updatePhysics(dt);
                }
                
                // Flight Controls (Thrust)
                if(keys.shift && !isPaused) {
                    // Disengage autopilot on manual input
                    if(autopilotEngaged) toggleAutopilot();
                    
                    const thrust = 0.01 * timeWarp * dt; // km/s^2
                    const dir = new THREE.Vector3();
                    camera.getWorldDirection(dir);
                    shipVelocity.add(dir.multiplyScalar(thrust));
                    createParticles(new THREE.Vector3(0,0,5)); 
                }
                
                // Update Director
            if(director && director.active) {
                director.update();
            } else if(cameraMode === 'CHASE') {
                    // User-controlled Orbit around Ship OR Target
                    orbitControls.enabled = true;
                    const check = document.getElementById('auto-rotate-check');
                    if(check) orbitControls.autoRotate = check.checked;
                    
                    let targetPos = new THREE.Vector3(0,0,0); // Default to ship (0,0,0)
                    
                    if (currentTargetIndex !== -1 && satMeshes[currentTargetIndex]) {
                        targetPos = satMeshes[currentTargetIndex].position;
                    }
                    
                    // Smoothly interpolate target for less jarring switches?
                    // For now, direct copy.
                    orbitControls.target.copy(targetPos);
                    orbitControls.update();
                    
                } else if(cameraMode === 'COCKPIT') {
                    // Inside view
                    camera.position.set(0, 0, 0);
                    // Allow looking around
                    if(keys.w) camera.rotation.x += 0.02;
                    if(keys.s) camera.rotation.x -= 0.02;
                    if(keys.a) camera.rotation.y += 0.02;
                    if(keys.d) camera.rotation.y -= 0.02;
                    
                } else if(cameraMode === 'ORBIT') {
                    // Rotating around ship
                    camera.position.x = Math.cos(time) * 40;
                    camera.position.z = Math.sin(time) * 40;
                    camera.position.y = 10;
                    camera.lookAt(0, 0, 0);
                    
                } else if(cameraMode === 'TARGET') {
                    // Look at destination
                    camera.position.set(0, 5, 5);
                    if(destinationBody) {
                        camera.lookAt(destinationBody.position);
                    } else {
                        // Look forward
                        camera.lookAt(0, 0, -100);
                    }
                    
                } else if(cameraMode === 'CINEMATIC') {
                    // Auto-switching cinematic angles
                    const cycle = Math.floor(time / 5) % 3;
                    if(cycle === 0) {
                        // Flyby
                        camera.position.set(Math.cos(time)*50, Math.sin(time)*20, Math.sin(time)*50);
                        camera.lookAt(0, 0, 0);
                    } else if(cycle === 1) {
                        // Rear view looking at origin
                        camera.position.set(0, 5, 20);
                        camera.lookAt(celestialBody.position);
                    } else {
                        // Top down
                        camera.position.set(0, 50, 0);
                        camera.lookAt(0, 0, 0);
                    }
                } else if(cameraMode === 'TELESCOPE') {
                    // View from Earth Surface
                    // Calculate surface position relative to rotation
                    // Start at "North Pole" of the planet mesh (which is actually pointing towards station at 0,0,0 if planet is at 0,-R,0)
                    // Planet is at (0, -6771000, 0). Radius 6371000.
                    // Top of planet is at (0, -400000, 0).
                    // We want a point on the surface that rotates.
                    
                    const earthRadius = 6371000;
                    // Local point on surface (relative to planet center)
                    // Let's pick a point slightly off the "top" so it rotates through the view
                    const localSurface = new THREE.Vector3(0, earthRadius, 0);
                    localSurface.applyEuler(planet.rotation);
                    
                    const worldSurface = localSurface.add(planet.position);
                    camera.position.copy(worldSurface);
                    
                    // Look at target
                    let targetPos = new THREE.Vector3(0,0,0);
                    if (currentTargetIndex !== -1 && satMeshes[currentTargetIndex]) {
                        targetPos = satMeshes[currentTargetIndex].position;
                    } else {
                        targetPos = shipPosition.clone().multiplyScalar(SCALE_FACTOR);
                    }
                    camera.lookAt(targetPos);
                    
                    // High Zoom
                    camera.fov = 1.0;
                    camera.updateProjectionMatrix();
                    
                } else if(cameraMode === 'MOON_SHOT') {
                    // Align Station with Moon
                    if(moon) {
                        // Vector from Station to Moon
                        const toMoon = moon.position.clone().normalize();
                        // Place camera opposite
                        const dist = 100;
                        const camPos = toMoon.clone().negate().multiplyScalar(dist);
                        camPos.y += 10; // Slight offset
                        camera.position.copy(camPos);
                        camera.lookAt(0, 0, 0);
                    }
                }
                
                // Reset FOV if not Telescope
                if(cameraMode !== 'TELESCOPE' && camera.fov !== 60) {
                    camera.fov = 60;
                    camera.updateProjectionMatrix();
                }
                
            } else if (tutorialActive && window.tutorialTargetPos) {
                // Tutorial Camera Mode
                camera.position.lerp(window.tutorialTargetPos, 0.03);
                currentLookTarget.lerp(window.tutorialTargetLook, 0.03);
                camera.lookAt(currentLookTarget);
            } else {
                // Builder Mode Orbit Simulation
                // Simulate LEO Orbit (Period ~90 mins)
                // We rotate the Sun/Stars around the station to simulate the station orbiting Earth
                // And we rotate the Earth mesh to simulate the ground track moving
                
                const orbitSpeed = 0.001; // Radians per frame
                builderOrbitAngle += orbitSpeed;
                
                // Sun Orbit (Day/Night Cycle)
                const sunDist = 1000000;
                sun.position.x = Math.cos(builderOrbitAngle) * sunDist;
                sun.position.y = Math.sin(builderOrbitAngle * 0.2) * sunDist * 0.5; // Slight inclination
                sun.position.z = Math.sin(builderOrbitAngle) * sunDist;
                sun.lookAt(0,0,0);
                
                // Update Sun Light Direction
                // The light is a child of the sun mesh, so it moves with it.
                // But DirectionalLight target is (0,0,0) by default, which is correct (Station).

                // Earth Rotation (Ground Track)
                // Rotate Earth slightly to simulate flying over it
                planet.rotation.x += 0.0005; 

                if(builderCameraMode === 'ORBIT') {
                    // Orbit Camera Update
                    // Auto-rotate handled by controls property now
                    const check = document.getElementById('auto-rotate-check');
                    if(check) orbitControls.autoRotate = check.checked;
                    
                    let targetPos = new THREE.Vector3(0,0,0); // Default station pos in builder
                    if (currentTargetIndex !== -1 && satMeshes[currentTargetIndex]) {
                        targetPos = satMeshes[currentTargetIndex].position;
                    }
                    orbitControls.target.copy(targetPos);
                    
                    orbitControls.update();
                    
                } else {
                    // Manual Camera Movement (Builder Mode - FLY)
                    // PointerLockControls handles rotation. We handle movement.
                    if(flyControls.isLocked) {
                        const speed = (keys.shift ? 2.0 : 0.5) * (dt * 60); // Frame rate independent
                        
                        if(keys.w) flyControls.moveForward(speed);
                        if(keys.s) flyControls.moveForward(-speed);
                        if(keys.a) flyControls.moveRight(-speed);
                        if(keys.d) flyControls.moveRight(speed);
                        
                        if(keys.q) camera.position.y += speed;
                        if(keys.e) camera.position.y -= speed;
                    }
                }
            }

            // Update Ghost
            if(buildMode && ghostModule) {
                const { pos, rot } = getPlacement();
                ghostModule.position.lerp(pos, 0.5); // Smooth snapping
                // ghostModule.rotation.copy(rot); // Rotation snapping is jarring, maybe skip lerp
            }

            // Environment Animation
            // planet.rotation.y += 0.0002; // Handled in builder loop now
            
            if (missionMode) {
                updateRealSatellites(physicsTime * 0.001); // Scale physics time to match orbit speed
            } else {
                updateRealSatellites(); // Use wall clock in builder
            }

            // Render
            composer.render();
        }

        // --- Persistence ---
        function saveStation() {
            const data = station.map(m => ({
                type: m.userData.type,
                pos: m.position.toArray(),
                rot: m.rotation.toArray()
            }));
            localStorage.setItem(APP_NAME, JSON.stringify(data));
            showNotification("Station Saved");
        }

        function loadStation() {
            const json = localStorage.getItem(APP_NAME);
            try {
                let data = json ? JSON.parse(json) : [];
                
                // Robust check for array
                if (!Array.isArray(data) || data.length === 0) {
                    console.log("No valid save found, loading default.");
                    buildFromData(PRESETS['default']);
                } else {
                    buildFromData(data);
                }
            } catch(e) { 
                console.error("Load failed", e);
                buildFromData(PRESETS['default']);
            }
        }

        function loadPreset(name) {
            if(!name || !PRESETS[name]) return;
            
            // Only ask for confirmation if there is a station AND we are not in the initial load phase (implied by user interaction via select)
            // However, since this function is called by the select element, we can check if the call is coming from user interaction
            // But for simplicity, let's just check if station has modules.
            // If called programmatically (like from loadStation), we might want to skip confirm.
            
            // Let's modify loadStation to call buildFromData directly for the default, 
            // and keep loadPreset for user interaction.
            
            if(station.length > 0 && !confirm("Load preset? Current station will be lost.")) {
                document.getElementById('presetSelect').value = "";
                return;
            }
            
            // Clear existing
            station.forEach(m => scene.remove(m));
            station = [];
            
            buildFromData(PRESETS[name]);
            document.getElementById('presetSelect').value = "";
            showNotification("Blueprint Loaded: " + name);
        }

        function buildFromData(data) {
            data.forEach(d => {
                const def = MODULES[d.type];
                if(!def) return;
                const mesh = new THREE.Mesh(def.geometry(), def.material);
                mesh.position.fromArray(d.pos);
                mesh.rotation.fromArray(d.rot);
                mesh.userData = { type: d.type, ...def };
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                scene.add(mesh);
                station.push(mesh);
                
                if(d.type === 'habitat' || d.type === 'dock') {
                    const light = new THREE.PointLight(0x00ffff, 0.5, 10);
                    mesh.add(light);
                }
            });
            updateStats();
        }

        function clearStation() {
            if(confirm("Destroy entire station?")) {
                station.forEach(m => scene.remove(m));
                station = [];
                updateStats();
                saveStation();
            }
        }

        function importStation(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    if (Array.isArray(data)) {
                        // Clear existing
                        station.forEach(m => scene.remove(m));
                        station = [];
                        
                        buildFromData(data);
                        saveStation(); // Auto-save imported
                        showNotification("Blueprint Imported Successfully");
                    } else {
                        alert("Invalid blueprint file format.");
                    }
                } catch (err) {
                    console.error(err);
                    alert("Error reading blueprint file.");
                }
                // Reset input so same file can be selected again
                event.target.value = '';
            };
            reader.readAsText(file);
        }

        function exportStation() {
            saveStation();
            const data = localStorage.getItem(APP_NAME);
            const blob = new Blob([data], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'station-blueprint.json';
            a.click();
        }

        function showNotification(msg) {
            const el = document.getElementById('notification');
            el.textContent = msg;
            el.style.opacity = 1;
            setTimeout(() => el.style.opacity = 0, 2000);
        }
        
        function toggleSound() {
            soundEnabled = !soundEnabled;
            document.getElementById('sound-btn').textContent = soundEnabled ? 'üîä' : 'üîá';
        }

        function startGame() {
            const ts = document.getElementById('title-screen');
            ts.style.opacity = 0;
            setTimeout(() => {
                ts.style.display = 'none';
                playSound('hover');
            }, 1000);
        }

        function startTutorialFromMenu() {
            startGame();
            setTimeout(() => {
                startTutorial();
            }, 1200);
        }

        // Init
        window.onload = init;

    </script>
</body>
</html>