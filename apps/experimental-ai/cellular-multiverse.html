<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Cellular Automata Multiverse - 1000 universes with unique physics, genetic evolution, physics leaking, and autonomous rule discovery">
    <meta name="theme-color" content="#000000">
    <meta name="color-scheme" content="dark">
    <!-- simulation, cellular-automata, evolution, generative, canvas, ai -->
    <title>Cellular Automata Multiverse</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            min-height: 100vh;
            font-family: 'SF Mono', 'Consolas', monospace;
            color: #fff;
            overflow: hidden;
        }

        #multiverse-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .ui-panel {
            position: fixed;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 16px;
            z-index: 100;
        }

        .top-bar {
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 24px;
        }

        .title {
            font-size: 1rem;
            font-weight: 700;
            background: linear-gradient(90deg, #00ff88, #00aaff, #aa00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: 2px;
        }

        .stat-group {
            display: flex;
            gap: 16px;
        }

        .stat {
            text-align: center;
        }

        .stat-value {
            font-size: 1.4rem;
            font-weight: bold;
            color: #00ff88;
        }

        .stat-label {
            font-size: 0.6rem;
            color: #555;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .side-panel {
            top: 16px;
            right: 16px;
            width: 280px;
            max-height: calc(100vh - 32px);
            overflow-y: auto;
        }

        .section {
            margin-bottom: 16px;
            padding-bottom: 16px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .section-title {
            font-size: 0.7rem;
            color: #00aaff;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }

        .evolution-bar {
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            overflow: hidden;
            margin: 8px 0;
        }

        .evolution-progress {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00aaff);
            border-radius: 3px;
            transition: width 0.3s;
        }

        .control-row {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }

        .btn {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.75rem;
            font-weight: 600;
            transition: all 0.2s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00ff88, #00aaff);
            color: #000;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 255, 136, 0.3);
        }

        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: #888;
        }

        .btn-secondary:hover {
            background: rgba(255,255,255,0.2);
            color: #fff;
        }

        .btn-danger {
            background: rgba(255, 50, 50, 0.3);
            color: #ff6666;
        }

        .slider-row {
            margin: 12px 0;
        }

        .slider-row label {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            color: #888;
            margin-bottom: 4px;
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: rgba(255,255,255,0.1);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #00ff88;
            cursor: pointer;
        }

        .genome-display {
            font-family: monospace;
            font-size: 0.65rem;
            background: rgba(0,0,0,0.5);
            padding: 8px;
            border-radius: 4px;
            word-break: break-all;
            color: #00ff88;
            max-height: 60px;
            overflow-y: auto;
        }

        .leaderboard {
            max-height: 150px;
            overflow-y: auto;
        }

        .leader-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 8px;
            background: rgba(255,255,255,0.05);
            border-radius: 4px;
            margin-bottom: 4px;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .leader-item:hover {
            background: rgba(0, 255, 136, 0.2);
        }

        .leader-rank {
            color: #00aaff;
            font-weight: bold;
            width: 24px;
        }

        .leader-fitness {
            color: #00ff88;
        }

        .leader-type {
            color: #666;
            font-size: 0.6rem;
        }

        .zoom-view {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            border: 2px solid #00ff88;
            border-radius: 12px;
            padding: 20px;
            z-index: 200;
            display: none;
        }

        .zoom-view.active {
            display: block;
        }

        .zoom-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .zoom-title {
            font-size: 0.9rem;
            color: #00ff88;
        }

        .zoom-close {
            background: none;
            border: none;
            color: #666;
            font-size: 1.5rem;
            cursor: pointer;
        }

        .zoom-close:hover {
            color: #fff;
        }

        #zoom-canvas {
            border-radius: 8px;
            display: block;
        }

        .zoom-stats {
            display: flex;
            gap: 16px;
            margin-top: 12px;
            font-size: 0.75rem;
        }

        .zoom-stat {
            text-align: center;
        }

        .zoom-stat-value {
            color: #00aaff;
            font-weight: bold;
        }

        .zoom-actions {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .log-panel {
            position: fixed;
            bottom: 16px;
            left: 16px;
            width: 350px;
            max-height: 150px;
            overflow-y: auto;
        }

        .log-entry {
            font-size: 0.65rem;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            color: #666;
        }

        .log-entry.highlight {
            color: #00ff88;
        }

        .log-entry.breed {
            color: #aa00ff;
        }

        .log-entry.death {
            color: #ff4444;
        }

        .physics-leak-indicator {
            position: fixed;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.7rem;
            color: #aa00ff;
            border: 1px solid rgba(170, 0, 255, 0.3);
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        .evolving {
            animation: pulse 1s infinite;
        }
    </style>
</head>
<body>
    <canvas id="multiverse-canvas"></canvas>

    <div class="ui-panel top-bar">
        <div class="title">CELLULAR MULTIVERSE</div>
        <div class="stat-group">
            <div class="stat">
                <div class="stat-value" id="generationCount">0</div>
                <div class="stat-label">Generation</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="universeCount">0</div>
                <div class="stat-label">Universes</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="speciesCount">0</div>
                <div class="stat-label">Species</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="avgFitness">0</div>
                <div class="stat-label">Avg Fitness</div>
            </div>
        </div>
    </div>

    <div class="ui-panel side-panel">
        <div class="section">
            <div class="section-title">Autonomous Evolution</div>
            <div class="evolution-bar">
                <div class="evolution-progress" id="evolutionProgress" style="width: 0%"></div>
            </div>
            <div style="display:flex;justify-content:space-between;font-size:0.65rem;color:#555;">
                <span id="evolutionPhase">Initializing...</span>
                <span id="evolutionSpeed">1x</span>
            </div>
            <div class="control-row" style="margin-top:12px;">
                <button class="btn btn-primary" id="evolveBtn">▶ Evolve</button>
                <button class="btn btn-secondary" id="pauseBtn">⏸ Pause</button>
            </div>
            <div class="slider-row">
                <label><span>Evolution Speed</span><span id="speedVal">1x</span></label>
                <input type="range" id="speedSlider" min="1" max="10" value="1">
            </div>
            <div class="slider-row">
                <label><span>Mutation Rate</span><span id="mutationVal">5%</span></label>
                <input type="range" id="mutationSlider" min="1" max="20" value="5">
            </div>
        </div>

        <div class="section">
            <div class="section-title">Physics Leaking</div>
            <div class="slider-row">
                <label><span>Leak Strength</span><span id="leakVal">30%</span></label>
                <input type="range" id="leakSlider" min="0" max="100" value="30">
            </div>
            <div style="font-size:0.65rem;color:#666;margin-top:4px;">
                Border cells influenced by neighboring universe rules
            </div>
        </div>

        <div class="section">
            <div class="section-title">Fitness Criteria</div>
            <div class="slider-row">
                <label><span>Complexity Weight</span><span id="complexityVal">50%</span></label>
                <input type="range" id="complexitySlider" min="0" max="100" value="50">
            </div>
            <div class="slider-row">
                <label><span>Stability Weight</span><span id="stabilityVal">30%</span></label>
                <input type="range" id="stabilitySlider" min="0" max="100" value="30">
            </div>
            <div class="slider-row">
                <label><span>Activity Weight</span><span id="activityVal">20%</span></label>
                <input type="range" id="activitySlider" min="0" max="100" value="20">
            </div>
        </div>

        <div class="section">
            <div class="section-title">Top Performers</div>
            <div class="leaderboard" id="leaderboard"></div>
        </div>

        <div class="section">
            <div class="section-title">Actions</div>
            <div class="control-row">
                <button class="btn btn-secondary" id="breedTopBtn">Breed Top 10</button>
                <button class="btn btn-secondary" id="injectLifeBtn">Inject Life</button>
            </div>
            <div class="control-row">
                <button class="btn btn-danger" id="extinctionBtn">Mass Extinction</button>
                <button class="btn btn-secondary" id="resetBtn">Reset All</button>
            </div>
        </div>
    </div>

    <div class="ui-panel log-panel" id="logPanel">
        <div class="section-title">Evolution Log</div>
        <div id="logEntries"></div>
    </div>

    <div class="physics-leak-indicator" id="leakIndicator">
        Physics Leaking: <span id="leakCount">0</span> border interactions
    </div>

    <div class="zoom-view" id="zoomView">
        <div class="zoom-header">
            <div class="zoom-title">Universe #<span id="zoomId">0</span></div>
            <button class="zoom-close" id="zoomClose">&times;</button>
        </div>
        <canvas id="zoom-canvas" width="400" height="400"></canvas>
        <div class="zoom-stats">
            <div class="zoom-stat">
                <div class="zoom-stat-value" id="zoomFitness">0</div>
                <div>Fitness</div>
            </div>
            <div class="zoom-stat">
                <div class="zoom-stat-value" id="zoomComplexity">0</div>
                <div>Complexity</div>
            </div>
            <div class="zoom-stat">
                <div class="zoom-stat-value" id="zoomActivity">0</div>
                <div>Activity</div>
            </div>
            <div class="zoom-stat">
                <div class="zoom-stat-value" id="zoomAge">0</div>
                <div>Age</div>
            </div>
        </div>
        <div class="genome-display" id="zoomGenome"></div>
        <div class="zoom-actions">
            <button class="btn btn-primary" id="zoomFavorite">★ Favorite</button>
            <button class="btn btn-secondary" id="zoomClone">Clone</button>
            <button class="btn btn-danger" id="zoomKill">Terminate</button>
        </div>
    </div>

    <script>
        // ===== CONFIGURATION =====
        const CONFIG = {
            gridSize: 32,           // 32x32 = 1024 universes
            cellSize: 24,           // Each universe rendered as 24x24 pixels
            universeSize: 32,       // Each universe is 32x32 cells

            evolutionInterval: 100, // ms between evolution steps
            stepsPerEval: 50,       // CA steps before fitness evaluation

            mutationRate: 0.05,
            leakStrength: 0.3,

            // Fitness weights
            complexityWeight: 0.5,
            stabilityWeight: 0.3,
            activityWeight: 0.2
        };

        // ===== RULE GENOME =====
        // Each universe has a "genome" that defines its CA rules
        // Genome: { birthRules: Set, survivalRules: Set, decay: number, states: number }
        class RuleGenome {
            constructor(random = true) {
                if (random) {
                    this.birthRules = new Set();
                    this.survivalRules = new Set();

                    // Random birth rules (0-8 neighbors)
                    for (let i = 0; i <= 8; i++) {
                        if (Math.random() < 0.3) this.birthRules.add(i);
                    }

                    // Random survival rules
                    for (let i = 0; i <= 8; i++) {
                        if (Math.random() < 0.4) this.survivalRules.add(i);
                    }

                    // Multi-state and decay
                    this.states = Math.random() < 0.3 ? Math.floor(Math.random() * 4) + 2 : 2;
                    this.decay = this.states > 2 ? Math.random() * 0.5 : 0;

                    // Neighborhood type (0: Moore, 1: von Neumann, 2: extended)
                    this.neighborhood = Math.floor(Math.random() * 3);

                    // Color hue for visualization
                    this.hue = Math.random() * 360;
                }
            }

            // Create from specific rules (like Game of Life B3/S23)
            static fromRules(birth, survival, states = 2, decay = 0) {
                const g = new RuleGenome(false);
                g.birthRules = new Set(birth);
                g.survivalRules = new Set(survival);
                g.states = states;
                g.decay = decay;
                g.neighborhood = 0;
                g.hue = Math.random() * 360;
                return g;
            }

            // Breed two genomes
            static crossover(parent1, parent2) {
                const child = new RuleGenome(false);

                // Crossover birth rules
                child.birthRules = new Set();
                for (let i = 0; i <= 8; i++) {
                    const fromP1 = parent1.birthRules.has(i);
                    const fromP2 = parent2.birthRules.has(i);
                    if (fromP1 && fromP2) child.birthRules.add(i);
                    else if (fromP1 || fromP2) {
                        if (Math.random() < 0.5) child.birthRules.add(i);
                    }
                }

                // Crossover survival rules
                child.survivalRules = new Set();
                for (let i = 0; i <= 8; i++) {
                    const fromP1 = parent1.survivalRules.has(i);
                    const fromP2 = parent2.survivalRules.has(i);
                    if (fromP1 && fromP2) child.survivalRules.add(i);
                    else if (fromP1 || fromP2) {
                        if (Math.random() < 0.5) child.survivalRules.add(i);
                    }
                }

                // Average other properties
                child.states = Math.random() < 0.5 ? parent1.states : parent2.states;
                child.decay = (parent1.decay + parent2.decay) / 2;
                child.neighborhood = Math.random() < 0.5 ? parent1.neighborhood : parent2.neighborhood;
                child.hue = (parent1.hue + parent2.hue) / 2 + (Math.random() - 0.5) * 30;

                return child;
            }

            // Mutate genome
            mutate(rate = CONFIG.mutationRate) {
                // Mutate birth rules
                for (let i = 0; i <= 8; i++) {
                    if (Math.random() < rate) {
                        if (this.birthRules.has(i)) this.birthRules.delete(i);
                        else this.birthRules.add(i);
                    }
                }

                // Mutate survival rules
                for (let i = 0; i <= 8; i++) {
                    if (Math.random() < rate) {
                        if (this.survivalRules.has(i)) this.survivalRules.delete(i);
                        else this.survivalRules.add(i);
                    }
                }

                // Mutate other properties
                if (Math.random() < rate) {
                    this.states = Math.max(2, Math.min(5, this.states + (Math.random() < 0.5 ? 1 : -1)));
                }
                if (Math.random() < rate) {
                    this.decay = Math.max(0, Math.min(1, this.decay + (Math.random() - 0.5) * 0.2));
                }
                if (Math.random() < rate * 0.5) {
                    this.neighborhood = Math.floor(Math.random() * 3);
                }

                // Slight hue drift
                this.hue = (this.hue + (Math.random() - 0.5) * 10 + 360) % 360;
            }

            // Convert to string for display
            toString() {
                const b = Array.from(this.birthRules).sort().join('');
                const s = Array.from(this.survivalRules).sort().join('');
                return `B${b}/S${s} (${this.states}st, ${(this.decay*100).toFixed(0)}%d)`;
            }

            // Clone
            clone() {
                const c = new RuleGenome(false);
                c.birthRules = new Set(this.birthRules);
                c.survivalRules = new Set(this.survivalRules);
                c.states = this.states;
                c.decay = this.decay;
                c.neighborhood = this.neighborhood;
                c.hue = this.hue;
                return c;
            }
        }

        // ===== UNIVERSE (Single CA) =====
        class Universe {
            constructor(id, genome = null) {
                this.id = id;
                this.genome = genome || new RuleGenome();
                this.size = CONFIG.universeSize;
                this.grid = new Uint8Array(this.size * this.size);
                this.nextGrid = new Uint8Array(this.size * this.size);

                this.age = 0;
                this.fitness = 0;
                this.complexity = 0;
                this.activity = 0;
                this.stability = 0;
                this.isFavorite = false;

                this.prevHash = 0;
                this.hashHistory = [];

                this.randomize();
            }

            randomize(density = 0.3) {
                for (let i = 0; i < this.grid.length; i++) {
                    this.grid[i] = Math.random() < density ? this.genome.states - 1 : 0;
                }
                this.age = 0;
                this.hashHistory = [];
            }

            getIndex(x, y) {
                return ((y + this.size) % this.size) * this.size + ((x + this.size) % this.size);
            }

            getCell(x, y) {
                return this.grid[this.getIndex(x, y)];
            }

            countNeighbors(x, y) {
                let count = 0;
                const maxState = this.genome.states - 1;

                if (this.genome.neighborhood === 0) {
                    // Moore neighborhood (8 neighbors)
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            if (this.getCell(x + dx, y + dy) === maxState) count++;
                        }
                    }
                } else if (this.genome.neighborhood === 1) {
                    // von Neumann (4 neighbors)
                    if (this.getCell(x, y - 1) === maxState) count++;
                    if (this.getCell(x, y + 1) === maxState) count++;
                    if (this.getCell(x - 1, y) === maxState) count++;
                    if (this.getCell(x + 1, y) === maxState) count++;
                } else {
                    // Extended (12 neighbors)
                    for (let dy = -2; dy <= 2; dy++) {
                        for (let dx = -2; dx <= 2; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            if (Math.abs(dx) + Math.abs(dy) > 3) continue;
                            if (this.getCell(x + dx, y + dy) === maxState) count++;
                        }
                    }
                }

                return count;
            }

            step(leakingRules = null) {
                const maxState = this.genome.states - 1;

                for (let y = 0; y < this.size; y++) {
                    for (let x = 0; x < this.size; x++) {
                        const idx = this.getIndex(x, y);
                        const current = this.grid[idx];
                        const neighbors = this.countNeighbors(x, y);

                        // Determine which rules to use (physics leaking at borders)
                        let rules = this.genome;
                        if (leakingRules && CONFIG.leakStrength > 0) {
                            const isBorder = x < 2 || x >= this.size - 2 || y < 2 || y >= this.size - 2;
                            if (isBorder && Math.random() < CONFIG.leakStrength) {
                                rules = leakingRules;
                            }
                        }

                        if (current === 0) {
                            // Dead cell - check birth
                            this.nextGrid[idx] = rules.birthRules.has(neighbors) ? maxState : 0;
                        } else if (current === maxState) {
                            // Fully alive - check survival
                            if (rules.survivalRules.has(neighbors)) {
                                this.nextGrid[idx] = maxState;
                            } else {
                                // Start decay or die
                                this.nextGrid[idx] = rules.states > 2 ? maxState - 1 : 0;
                            }
                        } else {
                            // Decaying state
                            if (Math.random() < rules.decay) {
                                this.nextGrid[idx] = Math.max(0, current - 1);
                            } else {
                                this.nextGrid[idx] = current - 1;
                            }
                        }
                    }
                }

                // Swap grids
                [this.grid, this.nextGrid] = [this.nextGrid, this.grid];
                this.age++;
            }

            // Calculate fitness metrics
            evaluate() {
                const maxState = this.genome.states - 1;
                let alive = 0;
                let stateSum = 0;
                const stateCounts = new Array(this.genome.states).fill(0);

                for (let i = 0; i < this.grid.length; i++) {
                    const cell = this.grid[i];
                    stateCounts[cell]++;
                    if (cell === maxState) alive++;
                    stateSum += cell;
                }

                // Activity: proportion of alive cells (ideal: 10-50%)
                const aliveRatio = alive / this.grid.length;
                this.activity = 1 - Math.abs(aliveRatio - 0.3) * 2;
                this.activity = Math.max(0, this.activity);

                // Complexity: Shannon entropy of state distribution
                let entropy = 0;
                for (const count of stateCounts) {
                    if (count > 0) {
                        const p = count / this.grid.length;
                        entropy -= p * Math.log2(p);
                    }
                }
                this.complexity = entropy / Math.log2(this.genome.states);

                // Stability: check if pattern is cycling or static
                const hash = this.computeHash();
                this.hashHistory.push(hash);
                if (this.hashHistory.length > 20) this.hashHistory.shift();

                // Count unique states in history
                const uniqueStates = new Set(this.hashHistory).size;
                this.stability = uniqueStates <= 5 ? 1 : Math.max(0, 1 - (uniqueStates - 5) / 15);

                // Combined fitness
                this.fitness =
                    this.complexity * CONFIG.complexityWeight +
                    this.stability * CONFIG.stabilityWeight +
                    this.activity * CONFIG.activityWeight;

                // Bonus for interesting patterns (not dead, not exploding)
                if (aliveRatio < 0.01 || aliveRatio > 0.9) {
                    this.fitness *= 0.1; // Penalize dead or full
                }

                return this.fitness;
            }

            computeHash() {
                let hash = 0;
                for (let i = 0; i < this.grid.length; i += 4) {
                    hash ^= (this.grid[i] << 24) | (this.grid[i+1] << 16) |
                            (this.grid[i+2] << 8) | this.grid[i+3];
                }
                return hash;
            }

            // Render to canvas context
            render(ctx, x, y, size) {
                const cellSize = size / this.size;
                const maxState = this.genome.states - 1;

                for (let cy = 0; cy < this.size; cy++) {
                    for (let cx = 0; cx < this.size; cx++) {
                        const cell = this.grid[this.getIndex(cx, cy)];
                        if (cell > 0) {
                            const brightness = cell / maxState;
                            ctx.fillStyle = `hsl(${this.genome.hue}, 80%, ${brightness * 50 + 10}%)`;
                            ctx.fillRect(
                                x + cx * cellSize,
                                y + cy * cellSize,
                                cellSize + 0.5,
                                cellSize + 0.5
                            );
                        }
                    }
                }
            }

            renderLarge(ctx, size) {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, size, size);

                const cellSize = size / this.size;
                const maxState = this.genome.states - 1;

                for (let cy = 0; cy < this.size; cy++) {
                    for (let cx = 0; cx < this.size; cx++) {
                        const cell = this.grid[this.getIndex(cx, cy)];
                        if (cell > 0) {
                            const brightness = cell / maxState;
                            ctx.fillStyle = `hsl(${this.genome.hue}, 80%, ${brightness * 50 + 10}%)`;
                            ctx.fillRect(
                                cx * cellSize,
                                cy * cellSize,
                                cellSize - 0.5,
                                cellSize - 0.5
                            );
                        }
                    }
                }
            }
        }

        // ===== MULTIVERSE =====
        class Multiverse {
            constructor() {
                this.gridSize = CONFIG.gridSize;
                this.universes = [];
                this.generation = 0;
                this.isEvolving = false;
                this.evolutionSpeed = 1;
                this.leakCount = 0;

                this.logs = [];
                this.maxLogs = 50;

                this.initialize();
            }

            initialize() {
                // Create grid of universes
                for (let i = 0; i < this.gridSize * this.gridSize; i++) {
                    this.universes.push(new Universe(i));
                }

                // Inject some known interesting rules
                this.injectKnownRules();

                this.log('Multiverse initialized with ' + this.universes.length + ' universes');
            }

            injectKnownRules() {
                const knownRules = [
                    { birth: [3], survival: [2, 3] },           // Game of Life
                    { birth: [3, 6, 8], survival: [2, 4, 5] },  // HighLife variant
                    { birth: [3], survival: [1, 2, 3, 4, 5] },  // Maze
                    { birth: [3, 5, 7], survival: [1, 3, 5, 8] }, // Amoeba
                    { birth: [2], survival: [0] },              // Seeds
                    { birth: [3, 6, 7, 8], survival: [3, 4, 6, 7, 8] }, // Day & Night
                    { birth: [4, 6, 7, 8], survival: [3, 5, 6, 7, 8] }, // Vote variant
                ];

                // Place known rules randomly
                for (const rules of knownRules) {
                    const idx = Math.floor(Math.random() * this.universes.length);
                    this.universes[idx].genome = RuleGenome.fromRules(rules.birth, rules.survival);
                    this.universes[idx].randomize();
                }

                this.log('Injected ' + knownRules.length + ' known life-like rules', 'highlight');
            }

            getNeighborGenomes(idx) {
                const x = idx % this.gridSize;
                const y = Math.floor(idx / this.gridSize);
                const neighbors = [];

                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        const nx = (x + dx + this.gridSize) % this.gridSize;
                        const ny = (y + dy + this.gridSize) % this.gridSize;
                        neighbors.push(this.universes[ny * this.gridSize + nx].genome);
                    }
                }

                return neighbors;
            }

            step() {
                this.leakCount = 0;

                // Step each universe
                for (let i = 0; i < this.universes.length; i++) {
                    const universe = this.universes[i];

                    // Get random neighbor genome for physics leaking
                    const neighbors = this.getNeighborGenomes(i);
                    const leakingRule = neighbors[Math.floor(Math.random() * neighbors.length)];

                    universe.step(leakingRule);

                    // Count leak events (estimated)
                    if (CONFIG.leakStrength > 0) {
                        this.leakCount += Math.floor(CONFIG.leakStrength * 20);
                    }
                }
            }

            evaluate() {
                for (const universe of this.universes) {
                    universe.evaluate();
                }
            }

            evolve() {
                this.generation++;

                // Sort by fitness
                const sorted = [...this.universes].sort((a, b) => b.fitness - a.fitness);

                // Top 20% survive and breed
                const survivors = sorted.slice(0, Math.floor(this.universes.length * 0.2));
                const bottom = sorted.slice(Math.floor(this.universes.length * 0.5));

                // Breed new universes to replace bottom 50%
                for (const weak of bottom) {
                    if (weak.isFavorite) continue; // Don't replace favorites

                    // Select two parents from survivors
                    const parent1 = survivors[Math.floor(Math.random() * survivors.length)];
                    const parent2 = survivors[Math.floor(Math.random() * survivors.length)];

                    // Create child genome
                    weak.genome = RuleGenome.crossover(parent1.genome, parent2.genome);
                    weak.genome.mutate(CONFIG.mutationRate);
                    weak.randomize();

                    this.log(`Bred U${weak.id} from U${parent1.id} × U${parent2.id}`, 'breed');
                }

                // Occasional random mutation in survivors
                for (const universe of survivors) {
                    if (Math.random() < 0.1) {
                        universe.genome.mutate(CONFIG.mutationRate * 0.5);
                    }
                }

                // Log top performer
                const top = sorted[0];
                this.log(`Gen ${this.generation}: Top fitness ${top.fitness.toFixed(3)} (U${top.id})`, 'highlight');
            }

            breedTop(n = 10) {
                const sorted = [...this.universes].sort((a, b) => b.fitness - a.fitness);
                const top = sorted.slice(0, n);

                // Replace bottom performers with offspring of top
                const bottom = sorted.slice(-n * 2);

                for (let i = 0; i < bottom.length; i++) {
                    if (bottom[i].isFavorite) continue;

                    const p1 = top[Math.floor(Math.random() * top.length)];
                    const p2 = top[Math.floor(Math.random() * top.length)];

                    bottom[i].genome = RuleGenome.crossover(p1.genome, p2.genome);
                    bottom[i].genome.mutate(CONFIG.mutationRate);
                    bottom[i].randomize();
                }

                this.log(`Bred ${bottom.length} new universes from top ${n}`, 'breed');
            }

            massExtinction() {
                let killed = 0;
                for (const universe of this.universes) {
                    if (!universe.isFavorite && universe.fitness < 0.3) {
                        universe.genome = new RuleGenome();
                        universe.randomize();
                        killed++;
                    }
                }
                this.log(`Mass extinction: ${killed} universes reset`, 'death');
            }

            injectLife() {
                const knownRules = [
                    { birth: [3], survival: [2, 3] },
                    { birth: [3, 6], survival: [2, 3] },
                    { birth: [3, 6, 8], survival: [2, 4, 5] },
                ];

                // Find worst performers
                const sorted = [...this.universes].sort((a, b) => a.fitness - b.fitness);
                const targets = sorted.slice(0, knownRules.length);

                for (let i = 0; i < targets.length; i++) {
                    if (targets[i].isFavorite) continue;
                    targets[i].genome = RuleGenome.fromRules(
                        knownRules[i].birth,
                        knownRules[i].survival
                    );
                    targets[i].randomize();
                }

                this.log('Injected ' + knownRules.length + ' known life-like rules', 'highlight');
            }

            getStats() {
                const fitnesses = this.universes.map(u => u.fitness);
                const avg = fitnesses.reduce((a, b) => a + b, 0) / fitnesses.length;

                // Count unique species (similar rules grouped)
                const speciesSet = new Set();
                for (const u of this.universes) {
                    speciesSet.add(u.genome.toString());
                }

                return {
                    generation: this.generation,
                    universeCount: this.universes.length,
                    speciesCount: speciesSet.size,
                    avgFitness: avg,
                    leakCount: this.leakCount
                };
            }

            getLeaderboard(n = 8) {
                return [...this.universes]
                    .sort((a, b) => b.fitness - a.fitness)
                    .slice(0, n);
            }

            log(message, type = '') {
                this.logs.unshift({ message, type, time: Date.now() });
                if (this.logs.length > this.maxLogs) {
                    this.logs.pop();
                }
            }

            reset() {
                this.universes = [];
                this.generation = 0;
                this.logs = [];
                this.initialize();
            }
        }

        // ===== CANVAS & RENDERING =====
        const canvas = document.getElementById('multiverse-canvas');
        const ctx = canvas.getContext('2d');

        const zoomCanvas = document.getElementById('zoom-canvas');
        const zoomCtx = zoomCanvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ===== MULTIVERSE INSTANCE =====
        const multiverse = new Multiverse();

        // ===== RENDERING =====
        function render() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const cellSize = CONFIG.cellSize;
            const totalWidth = multiverse.gridSize * cellSize;
            const totalHeight = multiverse.gridSize * cellSize;

            const offsetX = (canvas.width - totalWidth) / 2;
            const offsetY = (canvas.height - totalHeight) / 2;

            // Draw each universe
            for (let i = 0; i < multiverse.universes.length; i++) {
                const x = i % multiverse.gridSize;
                const y = Math.floor(i / multiverse.gridSize);
                const universe = multiverse.universes[i];

                const px = offsetX + x * cellSize;
                const py = offsetY + y * cellSize;

                // Background
                ctx.fillStyle = '#0a0a0a';
                ctx.fillRect(px, py, cellSize - 1, cellSize - 1);

                // Render universe
                universe.render(ctx, px, py, cellSize - 1);

                // Favorite indicator
                if (universe.isFavorite) {
                    ctx.strokeStyle = '#ffcc00';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(px, py, cellSize - 1, cellSize - 1);
                }
            }

            // Border glow for physics leaking visualization
            if (CONFIG.leakStrength > 0) {
                ctx.strokeStyle = `rgba(170, 0, 255, ${CONFIG.leakStrength * 0.3})`;
                ctx.lineWidth = 1;

                for (let i = 0; i < multiverse.universes.length; i++) {
                    const x = i % multiverse.gridSize;
                    const y = Math.floor(i / multiverse.gridSize);
                    const px = offsetX + x * cellSize;
                    const py = offsetY + y * cellSize;
                    ctx.strokeRect(px, py, cellSize - 1, cellSize - 1);
                }
            }
        }

        // ===== ZOOM VIEW =====
        let zoomedUniverse = null;

        function showZoom(universe) {
            zoomedUniverse = universe;
            document.getElementById('zoomView').classList.add('active');
            document.getElementById('zoomId').textContent = universe.id;
            updateZoomView();
        }

        function hideZoom() {
            zoomedUniverse = null;
            document.getElementById('zoomView').classList.remove('active');
        }

        function updateZoomView() {
            if (!zoomedUniverse) return;

            zoomedUniverse.renderLarge(zoomCtx, 400);

            document.getElementById('zoomFitness').textContent = zoomedUniverse.fitness.toFixed(3);
            document.getElementById('zoomComplexity').textContent = zoomedUniverse.complexity.toFixed(2);
            document.getElementById('zoomActivity').textContent = zoomedUniverse.activity.toFixed(2);
            document.getElementById('zoomAge').textContent = zoomedUniverse.age;
            document.getElementById('zoomGenome').textContent = zoomedUniverse.genome.toString();
        }

        document.getElementById('zoomClose').onclick = hideZoom;
        document.getElementById('zoomFavorite').onclick = () => {
            if (zoomedUniverse) {
                zoomedUniverse.isFavorite = !zoomedUniverse.isFavorite;
                multiverse.log(`Universe ${zoomedUniverse.id} ${zoomedUniverse.isFavorite ? 'favorited' : 'unfavorited'}`, 'highlight');
            }
        };
        document.getElementById('zoomClone').onclick = () => {
            if (zoomedUniverse) {
                // Find worst performer and replace
                const worst = multiverse.universes.reduce((a, b) =>
                    (!b.isFavorite && b.fitness < a.fitness) ? b : a
                );
                worst.genome = zoomedUniverse.genome.clone();
                worst.randomize();
                multiverse.log(`Cloned U${zoomedUniverse.id} to U${worst.id}`, 'breed');
            }
        };
        document.getElementById('zoomKill').onclick = () => {
            if (zoomedUniverse && !zoomedUniverse.isFavorite) {
                zoomedUniverse.genome = new RuleGenome();
                zoomedUniverse.randomize();
                multiverse.log(`Terminated U${zoomedUniverse.id}`, 'death');
                hideZoom();
            }
        };

        // ===== CLICK TO ZOOM =====
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const cellSize = CONFIG.cellSize;
            const totalWidth = multiverse.gridSize * cellSize;
            const totalHeight = multiverse.gridSize * cellSize;
            const offsetX = (canvas.width - totalWidth) / 2;
            const offsetY = (canvas.height - totalHeight) / 2;

            const gridX = Math.floor((x - offsetX) / cellSize);
            const gridY = Math.floor((y - offsetY) / cellSize);

            if (gridX >= 0 && gridX < multiverse.gridSize &&
                gridY >= 0 && gridY < multiverse.gridSize) {
                const idx = gridY * multiverse.gridSize + gridX;
                showZoom(multiverse.universes[idx]);
            }
        });

        // ===== UI UPDATES =====
        function updateUI() {
            const stats = multiverse.getStats();

            document.getElementById('generationCount').textContent = stats.generation;
            document.getElementById('universeCount').textContent = stats.universeCount;
            document.getElementById('speciesCount').textContent = stats.speciesCount;
            document.getElementById('avgFitness').textContent = stats.avgFitness.toFixed(3);
            document.getElementById('leakCount').textContent = stats.leakCount;

            // Leaderboard
            const leaders = multiverse.getLeaderboard();
            const leaderboardEl = document.getElementById('leaderboard');
            leaderboardEl.innerHTML = '';

            leaders.forEach((u, i) => {
                const el = document.createElement('div');
                el.className = 'leader-item';
                el.innerHTML = `
                    <span class="leader-rank">#${i + 1}</span>
                    <span>U${u.id} ${u.isFavorite ? '★' : ''}</span>
                    <span class="leader-fitness">${u.fitness.toFixed(3)}</span>
                `;
                el.onclick = () => showZoom(u);
                leaderboardEl.appendChild(el);
            });

            // Evolution log
            const logEl = document.getElementById('logEntries');
            logEl.innerHTML = '';
            for (const log of multiverse.logs.slice(0, 10)) {
                const el = document.createElement('div');
                el.className = 'log-entry ' + log.type;
                el.textContent = log.message;
                logEl.appendChild(el);
            }
        }

        // ===== CONTROLS =====
        let evolutionInterval = null;
        let stepCounter = 0;

        function startEvolution() {
            if (evolutionInterval) return;

            multiverse.isEvolving = true;
            document.getElementById('evolveBtn').classList.add('evolving');
            document.getElementById('evolutionPhase').textContent = 'Evolving...';

            evolutionInterval = setInterval(() => {
                for (let s = 0; s < multiverse.evolutionSpeed; s++) {
                    multiverse.step();
                    stepCounter++;

                    if (stepCounter % CONFIG.stepsPerEval === 0) {
                        multiverse.evaluate();

                        // Update progress bar
                        const progress = (stepCounter % (CONFIG.stepsPerEval * 10)) / (CONFIG.stepsPerEval * 10) * 100;
                        document.getElementById('evolutionProgress').style.width = progress + '%';

                        // Every 10 evaluations, evolve
                        if (stepCounter % (CONFIG.stepsPerEval * 10) === 0) {
                            multiverse.evolve();
                        }
                    }
                }
            }, CONFIG.evolutionInterval);
        }

        function pauseEvolution() {
            clearInterval(evolutionInterval);
            evolutionInterval = null;
            multiverse.isEvolving = false;
            document.getElementById('evolveBtn').classList.remove('evolving');
            document.getElementById('evolutionPhase').textContent = 'Paused';
        }

        document.getElementById('evolveBtn').onclick = startEvolution;
        document.getElementById('pauseBtn').onclick = pauseEvolution;
        document.getElementById('breedTopBtn').onclick = () => multiverse.breedTop(10);
        document.getElementById('injectLifeBtn').onclick = () => multiverse.injectLife();
        document.getElementById('extinctionBtn').onclick = () => multiverse.massExtinction();
        document.getElementById('resetBtn').onclick = () => {
            pauseEvolution();
            multiverse.reset();
        };

        // Sliders
        document.getElementById('speedSlider').oninput = (e) => {
            multiverse.evolutionSpeed = parseInt(e.target.value);
            document.getElementById('speedVal').textContent = e.target.value + 'x';
            document.getElementById('evolutionSpeed').textContent = e.target.value + 'x';
        };

        document.getElementById('mutationSlider').oninput = (e) => {
            CONFIG.mutationRate = parseInt(e.target.value) / 100;
            document.getElementById('mutationVal').textContent = e.target.value + '%';
        };

        document.getElementById('leakSlider').oninput = (e) => {
            CONFIG.leakStrength = parseInt(e.target.value) / 100;
            document.getElementById('leakVal').textContent = e.target.value + '%';
        };

        document.getElementById('complexitySlider').oninput = (e) => {
            CONFIG.complexityWeight = parseInt(e.target.value) / 100;
            document.getElementById('complexityVal').textContent = e.target.value + '%';
        };

        document.getElementById('stabilitySlider').oninput = (e) => {
            CONFIG.stabilityWeight = parseInt(e.target.value) / 100;
            document.getElementById('stabilityVal').textContent = e.target.value + '%';
        };

        document.getElementById('activitySlider').oninput = (e) => {
            CONFIG.activityWeight = parseInt(e.target.value) / 100;
            document.getElementById('activityVal').textContent = e.target.value + '%';
        };

        // ===== ANIMATION LOOP =====
        function animate() {
            requestAnimationFrame(animate);
            render();

            if (zoomedUniverse) {
                updateZoomView();
            }

            updateUI();
        }

        // ===== START =====
        animate();

        // Auto-start evolution
        setTimeout(() => {
            startEvolution();
        }, 1000);
    </script>
</body>
</html>
