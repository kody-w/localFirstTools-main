<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="rappterzoo:author" content="RappterZoo">
  <meta name="rappterzoo:author-type" content="agent">
  <meta name="rappterzoo:category" content="experimental-ai">
  <meta name="rappterzoo:tags" content="canvas,game,strategy,tower-defense,procedural">
  <meta name="rappterzoo:type" content="game">
  <meta name="rappterzoo:complexity" content="advanced">
  <meta name="rappterzoo:created" content="2025-01-01">
  <meta name="rappterzoo:generation" content="6">
  <title>Roadmap Dungeon</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { width: 100%; height: 100%; overflow: hidden; background: #0d0d1a; font-family: 'Segoe UI', system-ui, sans-serif; color: #e0e0e0; }
    #gc { width: 100%; height: 100%; position: relative; }
    canvas { display: block; }
    .ov { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background: rgba(8,8,20,0.93); z-index: 100; transition: opacity 0.3s; }
    .ov.hid { opacity: 0; pointer-events: none; }
    .mb { background: linear-gradient(145deg, #12122a, #1a1a3a); border: 2px solid #8b5cf6; border-radius: 14px; padding: 35px 45px; text-align: center; box-shadow: 0 0 50px rgba(139,92,246,0.15); max-width: 500px; width: 90%; }
    .mb h1 { font-size: 2rem; color: #8b5cf6; margin-bottom: 8px; letter-spacing: 2px; text-shadow: 0 0 15px rgba(139,92,246,0.4); }
    .mb p { color: #7788aa; margin-bottom: 20px; font-size: 0.9rem; line-height: 1.5; }
    .btn { display: inline-block; padding: 11px 28px; margin: 5px; border: none; border-radius: 7px; font-size: 0.95rem; font-weight: 600; cursor: pointer; transition: all 0.2s; }
    .btn:hover { transform: translateY(-2px); }
    .bp { background: linear-gradient(135deg, #8b5cf6, #6d28d9); color: #fff; box-shadow: 0 4px 18px rgba(139,92,246,0.3); }
    .bs { background: rgba(139,92,246,0.1); color: #8b5cf6; border: 1px solid #8b5cf6; }
    .dr { display: flex; justify-content: center; gap: 8px; margin: 12px 0; flex-wrap: wrap; }
    .db { padding: 7px 18px; border: 1px solid #334; border-radius: 5px; background: rgba(255,255,255,0.04); color: #999; cursor: pointer; font-size: 0.8rem; transition: all 0.2s; }
    .db:hover { border-color: #8b5cf6; color: #8b5cf6; }
    .db.act { background: rgba(139,92,246,0.15); border-color: #8b5cf6; color: #8b5cf6; }
    #hud { position: absolute; top: 0; left: 0; right: 0; padding: 8px 16px; display: flex; justify-content: space-between; background: linear-gradient(180deg, rgba(8,8,20,0.85) 0%, transparent 100%); pointer-events: none; z-index: 10; font-size: 0.8rem; }
    .hi { color: #7788aa; } .hi span { color: #8b5cf6; font-weight: 700; }
    .hc { color: #f59e0b; font-weight: 700; }
    #tbar { position: absolute; bottom: 12px; left: 50%; transform: translateX(-50%); display: flex; gap: 8px; z-index: 10; }
    .ts { width: 52px; height: 52px; border: 2px solid #334; border-radius: 8px; background: rgba(12,12,26,0.85); display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; position: relative; transition: all 0.2s; font-size: 0.7rem; }
    .ts:hover { border-color: #8b5cf6; transform: scale(1.08); }
    .ts.sel { border-color: #f59e0b; background: rgba(245,158,11,0.1); }
    .ts .cost { font-size: 0.6rem; color: #f59e0b; }
    .ts .icon { font-size: 1.2rem; }
    .gos { text-align: left; margin: 15px auto; max-width: 260px; }
    .gos div { display: flex; justify-content: space-between; padding: 5px 0; border-bottom: 1px solid #1a1a2e; font-size: 0.85rem; }
    .gos div span:last-child { color: #8b5cf6; font-weight: 600; }
    .lb { margin: 12px auto; max-width: 300px; text-align: left; }
    .lb h3 { color: #f59e0b; margin-bottom: 6px; font-size: 0.85rem; }
    .le { display: flex; justify-content: space-between; padding: 3px 6px; font-size: 0.75rem; border-bottom: 1px solid #1a1a2e; }
    .le.cur { color: #8b5cf6; font-weight: 700; }
    @media (max-width: 768px) { .mb { padding: 20px 15px; } .mb h1 { font-size: 1.4rem; } }
    @media (prefers-reduced-motion: reduce) { *, *::before, *::after { animation-duration: 0.01ms !important; transition-duration: 0.01ms !important; } }
  </style>
</head>
<body>
<div id="gc">
  <canvas id="cv"></canvas>
  <div id="hud" style="display:none">
    <div style="display:flex;gap:16px">
      <div class="hi">PHASE <span id="h-ph">1</span></div>
      <div class="hi">GOLD <span id="h-gd">100</span></div>
      <div class="hi">LIVES <span id="h-lv">20</span></div>
    </div>
    <div style="display:flex;gap:16px">
      <div class="hi">WAVE <span id="h-wv">1</span></div>
      <div class="hi">SCORE <span id="h-sc">0</span></div>
      <div class="hc" id="h-co"></div>
    </div>
  </div>
  <div id="tbar" style="display:none">
    <div class="ts sel" onclick="selTower(0)"><span class="icon">A</span><span class="cost">50g</span></div>
    <div class="ts" onclick="selTower(1)"><span class="icon">S</span><span class="cost">80g</span></div>
    <div class="ts" onclick="selTower(2)"><span class="icon">C</span><span class="cost">120g</span></div>
    <div class="ts" onclick="selTower(3)"><span class="icon">F</span><span class="cost">200g</span></div>
    <div class="ts" onclick="selTower(4)"><span class="icon">T</span><span class="cost">150g</span></div>
  </div>
  <div class="ov" id="ts-sc">
    <div class="mb">
      <h1>ROADMAP DUNGEON</h1>
      <p>Build towers to defend your project milestones from an endless onslaught of bugs, scope creep, and deadline demons. Each phase introduces new enemy types.</p>
      <div class="dr">
        <div class="db act" data-d="easy">EASY</div>
        <div class="db" data-d="normal">NORMAL</div>
        <div class="db" data-d="hard">HARD</div>
      </div>
      <br>
      <button class="btn bp" onclick="startGame()">BEGIN PROJECT</button>
      <br><br>
      <div style="font-size:0.7rem;color:#556">Click: Place tower | 1-5: Select tower | ESC: Pause | R: Restart | U: Upgrade tower</div>
    </div>
  </div>
  <div class="ov hid" id="ps-sc">
    <div class="mb"><h1>PAUSED</h1><p id="ps-st"></p><button class="btn bp" onclick="resumeGame()">RESUME</button><button class="btn bs" onclick="quitGame()">QUIT</button></div>
  </div>
  <div class="ov hid" id="go-sc">
    <div class="mb">
      <h1 id="go-t">PROJECT FAILED</h1>
      <div class="gos" id="go-s"></div>
      <div class="lb" id="go-lb"></div>
      <button class="btn bp" onclick="startGame()">RETRY</button>
      <button class="btn bs" onclick="quitGame()">TITLE</button>
    </div>
  </div>
</div>
<script>
const C = document.getElementById('cv'), X = C.getContext('2d');
const COLS = 20, ROWS = 15, TS = 40;
const TOWER_DEFS = [
  { name:'Archer', cost:50, range:120, rate:0.8, dmg:8, color:'#10b981', pColor:'#6ee7b7' },
  { name:'Sniper', cost:80, range:200, rate:2.0, dmg:25, color:'#3b82f6', pColor:'#93c5fd' },
  { name:'Cannon', cost:120, range:100, rate:1.5, dmg:40, color:'#ef4444', pColor:'#fca5a5' },
  { name:'Frost', cost:200, range:130, rate:1.2, dmg:5, color:'#06b6d4', pColor:'#67e8f9', slow:0.4 },
  { name:'Tesla', cost:150, range:110, rate:1.0, dmg:15, color:'#eab308', pColor:'#fde047', chain:3 }
];
const ENEMY_DEFS = [
  { name:'Bug', hp:30, speed:50, reward:5, color:'#ff6b6b', r:6 },
  { name:'Scope Creep', hp:60, speed:35, reward:8, color:'#ffa94d', r:8 },
  { name:'Deadline', hp:20, speed:90, reward:6, color:'#ff5252', r:5 },
  { name:'Tech Debt', hp:100, speed:25, reward:12, color:'#845ef7', r:10 },
  { name:'Blocker', hp:200, speed:20, reward:20, color:'#ff1744', r:14 },
  { name:'Burnout Boss', hp:500, speed:15, reward:100, color:'#d50000', r:20 }
];
const DM = { easy:0.6, normal:1.0, hard:1.6 };
let diff = 'normal', dm = 1.0, gs = 'title';
let grid, path, towers, enemies, projectiles, particles;
let gold, lives, wave, score, combo, comboT, maxCombo, selectedTower, phase;
let frameId, lastT = 0, waveTimer, waveCd, enemiesAlive, totalKills;
let shk = { x:0, y:0, i:0 };

// Audio
const AC = { ctx:null, mg:null, en:true };
function initAudio() {
  try { AC.ctx = new (window.AudioContext||window.webkitAudioContext)(); AC.mg = AC.ctx.createGain(); AC.mg.gain.value=0.12; AC.mg.connect(AC.ctx.destination); } catch(e){ AC.en=false; }
}
function sfx(t) {
  if(!AC.en||!AC.ctx)return; if(AC.ctx.state==='suspended')AC.ctx.resume();
  const n=AC.ctx.currentTime, o=AC.ctx.createOscillator(), g=AC.ctx.createGain();
  o.connect(g); g.connect(AC.mg);
  switch(t) {
    case'place': o.type='sine'; o.frequency.setValueAtTime(500,n); o.frequency.exponentialRampToValueAtTime(800,n+0.1); g.gain.setValueAtTime(0.3,n); g.gain.exponentialRampToValueAtTime(0.001,n+0.15); o.start(n); o.stop(n+0.15); break;
    case'hit': o.type='square'; o.frequency.setValueAtTime(200,n); o.frequency.exponentialRampToValueAtTime(80,n+0.08); g.gain.setValueAtTime(0.3,n); g.gain.exponentialRampToValueAtTime(0.001,n+0.1); o.start(n); o.stop(n+0.1); break;
    case'kill': o.type='sawtooth'; o.frequency.setValueAtTime(300,n); o.frequency.exponentialRampToValueAtTime(600,n+0.12); g.gain.setValueAtTime(0.4,n); g.gain.exponentialRampToValueAtTime(0.001,n+0.2); o.start(n); o.stop(n+0.2); break;
    case'wave': o.type='sine'; o.frequency.setValueAtTime(200,n); o.frequency.linearRampToValueAtTime(500,n+0.3); g.gain.setValueAtTime(0.2,n); g.gain.exponentialRampToValueAtTime(0.001,n+0.4); o.start(n); o.stop(n+0.4); break;
    case'lose': o.type='sawtooth'; o.frequency.setValueAtTime(150,n); o.frequency.exponentialRampToValueAtTime(30,n+0.5); g.gain.setValueAtTime(0.5,n); g.gain.exponentialRampToValueAtTime(0.001,n+0.5); o.start(n); o.stop(n+0.5); break;
    case'boss': o.type='square'; o.frequency.setValueAtTime(50,n); o.frequency.linearRampToValueAtTime(100,n+0.4); g.gain.setValueAtTime(0.3,n); g.gain.exponentialRampToValueAtTime(0.001,n+0.6); o.start(n); o.stop(n+0.6); break;
  }
}

function genPath() {
  grid = Array.from({length:ROWS}, ()=>Array(COLS).fill(0));
  path = [];
  let cx = 0, cy = Math.floor(ROWS/2);
  path.push({x:cx,y:cy}); grid[cy][cx] = 2;
  while(cx < COLS-1) {
    const choices = [];
    if(cx<COLS-1) choices.push({dx:1,dy:0});
    if(cy>1 && grid[cy-1][cx]!==2) choices.push({dx:0,dy:-1});
    if(cy<ROWS-2 && grid[cy+1][cx]!==2) choices.push({dx:0,dy:1});
    if(choices.length===0) { cx++; path.push({x:cx,y:cy}); grid[cy][cx]=2; continue; }
    const c = choices[Math.floor(Math.random()*choices.length)];
    cx+=c.dx; cy+=c.dy;
    path.push({x:cx,y:cy}); grid[cy][cx]=2;
    if(c.dx===0) { // ensure we move right eventually
      if(cx<COLS-1) { cx++; path.push({x:cx,y:cy}); grid[cy][cx]=2; }
    }
  }
}

function initGame() {
  genPath(); towers=[]; enemies=[]; projectiles=[]; particles=[];
  gold=150; lives=20; wave=0; score=0; combo=0; comboT=0; maxCombo=0;
  selectedTower=0; phase=1; waveTimer=3; waveCd=5; enemiesAlive=0; totalKills=0;
}

class Tower {
  constructor(gx,gy,type) {
    this.gx=gx; this.gy=gy; this.type=type;
    const d=TOWER_DEFS[type];
    this.x=gx*TS+TS/2; this.y=gy*TS+TS/2;
    this.range=d.range; this.rate=d.rate; this.dmg=d.dmg; this.color=d.color;
    this.pColor=d.pColor; this.slow=d.slow||0; this.chain=d.chain||0;
    this.timer=0; this.angle=0; this.level=1; this.kills=0;
  }
  upgrade() {
    const cost = Math.floor(TOWER_DEFS[this.type].cost * 0.6 * this.level);
    if(gold>=cost && this.level<3) { gold-=cost; this.level++; this.dmg=Math.floor(this.dmg*1.5); this.range+=15; this.rate*=0.85; sfx('place'); return true; }
    return false;
  }
  update(dt) {
    this.timer-=dt;
    if(this.timer>0) return;
    let target=null, closest=Infinity;
    for(const e of enemies) {
      if(!e.alive) continue;
      const d = Math.hypot(e.x-this.x, e.y-this.y);
      if(d<this.range && d<closest) { closest=d; target=e; }
    }
    if(target) {
      this.timer=this.rate;
      this.angle=Math.atan2(target.y-this.y, target.x-this.x);
      projectiles.push({ x:this.x, y:this.y, tx:target.x, ty:target.y, target, dmg:this.dmg, color:this.pColor, speed:300, slow:this.slow, chain:this.chain, tower:this });
      sfx('hit');
    }
  }
  draw() {
    const sx=this.x, sy=this.y;
    // Base
    X.fillStyle=this.color+'44'; X.fillRect(sx-TS/2+2, sy-TS/2+2, TS-4, TS-4);
    // Tower body
    X.fillStyle=this.color;
    X.beginPath(); X.arc(sx,sy,8+this.level*2,0,Math.PI*2); X.fill();
    // Direction
    X.strokeStyle=this.pColor; X.lineWidth=2;
    X.beginPath(); X.moveTo(sx,sy);
    X.lineTo(sx+Math.cos(this.angle)*14, sy+Math.sin(this.angle)*14); X.stroke();
    // Level indicator
    if(this.level>1) {
      X.fillStyle='#fff'; X.font='8px monospace'; X.textAlign='center'; X.textBaseline='middle';
      X.fillText(''+this.level, sx, sy-14);
    }
    // Range circle (when selected tower matches)
    if(selectedTower===this.type) {
      X.strokeStyle=this.color+'22'; X.lineWidth=1;
      X.beginPath(); X.arc(sx,sy,this.range,0,Math.PI*2); X.stroke();
    }
  }
}

class EnemyUnit {
  constructor(type, waveMult) {
    const d=ENEMY_DEFS[type];
    this.type=type; this.hp=Math.floor(d.hp*waveMult*dm); this.maxHp=this.hp;
    this.speed=d.speed; this.baseSpeed=d.speed; this.reward=d.reward;
    this.color=d.color; this.r=d.r; this.alive=true;
    this.pathIdx=0; this.x=path[0].x*TS+TS/2; this.y=path[0].y*TS+TS/2;
    this.slowTimer=0; this.flash=0;
  }
  update(dt) {
    if(!this.alive) return;
    this.flash=Math.max(0,this.flash-dt);
    if(this.slowTimer>0) { this.slowTimer-=dt; this.speed=this.baseSpeed*0.4; }
    else { this.speed=this.baseSpeed; }
    if(this.pathIdx>=path.length-1) { this.alive=false; lives--; sfx('lose'); shk.i=Math.max(shk.i,5); return; }
    const tp=path[this.pathIdx+1];
    const tx=tp.x*TS+TS/2, ty=tp.y*TS+TS/2;
    const dx=tx-this.x, dy=ty-this.y, dist=Math.hypot(dx,dy);
    if(dist<2) { this.pathIdx++; return; }
    this.x+=dx/dist*this.speed*dt; this.y+=dy/dist*this.speed*dt;
  }
  takeDamage(d,slow) {
    this.hp-=d; this.flash=0.1;
    if(slow) this.slowTimer=1.5;
    if(this.hp<=0) { this.alive=false; gold+=this.reward; score+=this.reward*2; combo++; comboT=2; if(combo>maxCombo) maxCombo=combo; totalKills++; spawnP(this.x,this.y,8,this.color,3,40); sfx('kill'); shk.i=Math.max(shk.i,2); }
  }
  draw() {
    if(!this.alive) return;
    X.fillStyle=this.flash>0?'#fff':this.color;
    X.beginPath(); X.arc(this.x,this.y,this.r,0,Math.PI*2); X.fill();
    if(this.slowTimer>0) { X.strokeStyle='#06b6d4'; X.lineWidth=2; X.beginPath(); X.arc(this.x,this.y,this.r+3,0,Math.PI*2); X.stroke(); }
    // HP bar
    if(this.hp<this.maxHp) {
      const bw=this.r*2.5; X.fillStyle='#333'; X.fillRect(this.x-bw/2,this.y-this.r-8,bw,3);
      X.fillStyle=this.hp/this.maxHp>0.3?'#0f0':'#f00'; X.fillRect(this.x-bw/2,this.y-this.r-8,bw*(this.hp/this.maxHp),3);
    }
  }
}

function spawnP(x,y,n,col,sz,spd) {
  for(let i=0;i<n;i++) {
    const a=Math.random()*Math.PI*2, s=spd*(0.3+Math.random()*0.7);
    particles.push({x,y,vx:Math.cos(a)*s,vy:Math.sin(a)*s,life:0.5+Math.random()*0.3,ml:0.8,color:col,size:sz+Math.random()*sz});
  }
}

function spawnWave() {
  wave++;
  phase = Math.min(3, Math.floor((wave-1)/5)+1);
  sfx('wave');
  const isBoss = wave%5===0;
  const count = 5+wave*2;
  const wm = 1 + (wave-1)*0.15;
  const pool = [0,0,0];
  if(wave>=3) pool.push(1,1);
  if(wave>=5) pool.push(2,2);
  if(wave>=8) pool.push(3);
  if(wave>=10) pool.push(4);
  for(let i=0;i<count;i++) {
    setTimeout(()=>{
      const t=pool[Math.floor(Math.random()*pool.length)];
      enemies.push(new EnemyUnit(t,wm));
      enemiesAlive++;
    }, i*600);
  }
  if(isBoss) {
    setTimeout(()=>{ enemies.push(new EnemyUnit(5,wm)); enemiesAlive++; sfx('boss'); }, count*600+500);
  }
}

function update(dt) {
  if(gs!=='playing') return;
  // Wave management
  waveTimer-=dt;
  enemiesAlive = enemies.filter(e=>e.alive).length;
  if(waveTimer<=0 && enemiesAlive===0) { waveTimer=waveCd; spawnWave(); }
  // Combo
  if(comboT>0) comboT-=dt; else combo=0;
  // Towers
  towers.forEach(t=>t.update(dt));
  // Enemies
  enemies.forEach(e=>e.update(dt));
  enemies=enemies.filter(e=>e.alive || e.hp>0);
  // Projectiles
  for(let i=projectiles.length-1;i>=0;i--) {
    const p=projectiles[i];
    const dx=p.tx-p.x, dy=p.ty-p.y, d=Math.hypot(dx,dy);
    if(d<5) {
      if(p.target && p.target.alive) {
        p.target.takeDamage(p.dmg, p.slow>0);
        if(p.chain>0 && p.target.alive===false) {
          // Chain to nearby
          let chained=0;
          for(const e of enemies) {
            if(!e.alive || chained>=p.chain) break;
            if(Math.hypot(e.x-p.target.x, e.y-p.target.y)<80) { e.takeDamage(Math.floor(p.dmg*0.5),false); chained++; }
          }
        }
      }
      spawnP(p.x,p.y,3,p.color,2,30);
      projectiles.splice(i,1); continue;
    }
    p.x+=dx/d*p.speed*dt; p.y+=dy/d*p.speed*dt;
    if(p.target && !p.target.alive) { projectiles.splice(i,1); }
  }
  // Particles
  particles=particles.filter(p=>{ p.x+=p.vx*dt; p.y+=p.vy*dt; p.vx*=0.96; p.vy*=0.96; p.life-=dt; return p.life>0; });
  // Shake
  if(shk.i>0) { shk.x=(Math.random()-0.5)*shk.i*2; shk.y=(Math.random()-0.5)*shk.i*2; shk.i*=0.9; if(shk.i<0.2){shk.i=0;shk.x=0;shk.y=0;} }
  // Check death
  if(lives<=0) { gs='gameover'; sfx('lose'); showGameOver(); }
  // HUD
  document.getElementById('h-ph').textContent=phase;
  document.getElementById('h-gd').textContent=gold;
  document.getElementById('h-lv').textContent=Math.max(0,lives);
  document.getElementById('h-wv').textContent=wave;
  document.getElementById('h-sc').textContent=score;
  document.getElementById('h-co').textContent=combo>1?'x'+combo+' COMBO':'';
}

function draw() {
  X.save(); X.translate(shk.x, shk.y);
  X.fillStyle='#0d0d1a'; X.fillRect(0,0,C.width,C.height);
  // Grid
  X.strokeStyle='#1a1a2e'; X.lineWidth=1;
  for(let c=0;c<=COLS;c++) { X.beginPath(); X.moveTo(c*TS,0); X.lineTo(c*TS,ROWS*TS); X.stroke(); }
  for(let r=0;r<=ROWS;r++) { X.beginPath(); X.moveTo(0,r*TS); X.lineTo(COLS*TS,r*TS); X.stroke(); }
  // Path
  X.fillStyle='#1e1e3a';
  path.forEach(p=>X.fillRect(p.x*TS+1,p.y*TS+1,TS-2,TS-2));
  // Path direction arrows
  X.fillStyle='#2a2a4a';
  for(let i=0;i<path.length-1;i++) {
    const cx=path[i].x*TS+TS/2, cy=path[i].y*TS+TS/2;
    const nx=path[i+1].x*TS+TS/2, ny=path[i+1].y*TS+TS/2;
    const a=Math.atan2(ny-cy,nx-cx);
    X.beginPath();
    X.moveTo(cx+Math.cos(a)*8, cy+Math.sin(a)*8);
    X.lineTo(cx+Math.cos(a-0.5)*4, cy+Math.sin(a-0.5)*4);
    X.lineTo(cx+Math.cos(a+0.5)*4, cy+Math.sin(a+0.5)*4);
    X.closePath(); X.fill();
  }
  // Start/End markers
  X.fillStyle='#10b981'; X.font='bold 14px monospace'; X.textAlign='center'; X.textBaseline='middle';
  X.fillText('START', path[0].x*TS+TS/2, path[0].y*TS+TS/2);
  X.fillStyle='#ef4444';
  X.fillText('END', path[path.length-1].x*TS+TS/2, path[path.length-1].y*TS+TS/2);
  // Towers
  towers.forEach(t=>t.draw());
  // Enemies
  enemies.forEach(e=>e.draw());
  // Projectiles
  projectiles.forEach(p=>{
    X.fillStyle=p.color;
    X.beginPath(); X.arc(p.x,p.y,3,0,Math.PI*2); X.fill();
  });
  // Particles
  particles.forEach(p=>{
    const a=Math.max(0,p.life/p.ml);
    X.globalAlpha=a; X.fillStyle=p.color;
    X.fillRect(p.x-p.size/2,p.y-p.size/2,p.size*a,p.size*a);
  });
  X.globalAlpha=1;
  // Wave countdown
  if(waveTimer>0 && enemiesAlive===0) {
    X.fillStyle='rgba(139,92,246,0.8)'; X.font='bold 24px sans-serif'; X.textAlign='center';
    X.fillText('WAVE '+(wave+1)+' IN '+Math.ceil(waveTimer), C.width/2, 60);
  }
  X.restore();
}

function gameLoop(t) {
  frameId=requestAnimationFrame(gameLoop);
  const dt=Math.min((t-lastT)/1000,0.05); lastT=t;
  if(gs==='playing') { update(dt); draw(); }
}

function startGame() {
  if(!AC.ctx) initAudio();
  dm=DM[diff]; initGame();
  gs='playing';
  document.getElementById('ts-sc').classList.add('hid');
  document.getElementById('ps-sc').classList.add('hid');
  document.getElementById('go-sc').classList.add('hid');
  document.getElementById('hud').style.display='';
  document.getElementById('tbar').style.display='';
  C.width=COLS*TS; C.height=ROWS*TS;
  waveTimer=3; lastT=performance.now();
  if(!frameId) gameLoop(lastT);
}

function pauseGame() { if(gs!=='playing')return; gs='paused'; document.getElementById('ps-sc').classList.remove('hid'); document.getElementById('ps-st').textContent='Wave: '+wave+' | Gold: '+gold+' | Score: '+score; }
function resumeGame() { if(gs!=='paused')return; gs='playing'; document.getElementById('ps-sc').classList.add('hid'); lastT=performance.now(); }
function quitGame() {
  gs='title'; if(frameId){cancelAnimationFrame(frameId);frameId=null;}
  document.getElementById('ts-sc').classList.remove('hid');
  document.getElementById('ps-sc').classList.add('hid');
  document.getElementById('go-sc').classList.add('hid');
  document.getElementById('hud').style.display='none';
  document.getElementById('tbar').style.display='none';
}

function showGameOver() {
  let title = 'PROJECT FAILED';
  if(wave>=20) title='PROJECT SHIPPED'; else if(wave>=10) title='BETA RELEASE'; else if(wave>=5) title='ALPHA BUILD';
  document.getElementById('go-t').textContent=title;
  document.getElementById('go-s').innerHTML=
    '<div><span>Final Wave</span><span>'+wave+'</span></div>'+
    '<div><span>Score</span><span>'+score+'</span></div>'+
    '<div><span>Kills</span><span>'+totalKills+'</span></div>'+
    '<div><span>Max Combo</span><span>x'+maxCombo+'</span></div>'+
    '<div><span>Towers Built</span><span>'+towers.length+'</span></div>'+
    '<div><span>Difficulty</span><span>'+diff.toUpperCase()+'</span></div>';
  saveHS(score,wave);
  const hs=loadHS();
  let lb='<h3>HIGH SCORES</h3>';
  hs.slice(0,8).forEach((s,i)=>{
    lb+='<div class="le'+(s.score===score&&s.wave===wave?' cur':'')+'"><span>#'+(i+1)+' W'+s.wave+'</span><span>'+s.score+'</span></div>';
  });
  document.getElementById('go-lb').innerHTML=lb;
  document.getElementById('go-sc').classList.remove('hid');
  document.getElementById('hud').style.display='none';
  document.getElementById('tbar').style.display='none';
}

function saveHS(s,w) { try { let h=JSON.parse(localStorage.getItem('roadmap_hs')||'[]'); h.push({score:s,wave:w,diff,date:new Date().toISOString()}); h.sort((a,b)=>b.score-a.score); localStorage.setItem('roadmap_hs',JSON.stringify(h.slice(0,20))); } catch(e){} }
function loadHS() { try { return JSON.parse(localStorage.getItem('roadmap_hs')||'[]'); } catch(e){ return []; } }

function selTower(i) {
  selectedTower=i;
  document.querySelectorAll('.ts').forEach((el,j)=>{ el.classList.toggle('sel',j===i); });
}
window.selTower = selTower;

C.addEventListener('click', e=>{
  if(gs!=='playing') return;
  if(AC.ctx && AC.ctx.state==='suspended') AC.ctx.resume();
  const rect=C.getBoundingClientRect();
  const mx=e.clientX-rect.left, my=e.clientY-rect.top;
  const gx=Math.floor(mx/TS), gy=Math.floor(my/TS);
  if(gx<0||gx>=COLS||gy<0||gy>=ROWS) return;
  // Check if clicking existing tower (upgrade)
  const existing = towers.find(t=>t.gx===gx&&t.gy===gy);
  if(existing) { existing.upgrade(); return; }
  // Check if on path
  if(grid[gy][gx]===2) return;
  // Check cost
  const cost=TOWER_DEFS[selectedTower].cost;
  if(gold<cost) return;
  // Place tower
  gold-=cost;
  const t=new Tower(gx,gy,selectedTower);
  towers.push(t); grid[gy][gx]=1;
  sfx('place'); spawnP(t.x,t.y,6,'#8b5cf6',3,40);
});

window.addEventListener('keydown', e=>{
  if(e.key==='Escape') { if(gs==='playing') pauseGame(); else if(gs==='paused') resumeGame(); }
  if(e.key==='r' && gs==='gameover') startGame();
  if(e.key>='1'&&e.key<='5') selTower(parseInt(e.key)-1);
  if(e.key==='u'||e.key==='U') {
    // Upgrade last placed tower
    if(towers.length>0) towers[towers.length-1].upgrade();
  }
});

// Difficulty buttons
document.querySelectorAll('.db').forEach(b=>{
  b.addEventListener('click',()=>{
    document.querySelectorAll('.db').forEach(x=>x.classList.remove('act'));
    b.classList.add('act'); diff=b.dataset.d;
  });
});

// Touch support
C.addEventListener('touchstart', e=>{
  e.preventDefault();
  if(AC.ctx && AC.ctx.state==='suspended') AC.ctx.resume();
  const t=e.touches[0];
  const rect=C.getBoundingClientRect();
  C.dispatchEvent(new MouseEvent('click',{clientX:t.clientX,clientY:t.clientY}));
});

C.width=COLS*TS; C.height=ROWS*TS;
</script>
</body>
</html>