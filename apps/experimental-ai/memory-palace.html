<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Persistent 3D Memory Palace</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #0a0a0a, #1a0a2a);
            color: #fff;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .ui-panel {
            position: fixed;
            background: linear-gradient(135deg, rgba(20, 20, 40, 0.95), rgba(40, 20, 60, 0.95));
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.7);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #control-panel {
            top: 20px;
            left: 20px;
            width: 400px;
            max-height: 85vh;
            overflow-y: auto;
        }

        #control-panel::-webkit-scrollbar {
            width: 6px;
        }

        #control-panel::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
        }

        #control-panel::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 3px;
        }

        #stats-panel {
            top: 20px;
            right: 20px;
            width: 320px;
        }

        #navigation-panel {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            padding: 12px 20px;
        }

        #import-export-panel {
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 20px;
            display: flex;
            gap: 12px;
            align-items: center;
        }

        #minimap {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            background: rgba(20, 20, 40, 0.9);
            border: 2px solid rgba(139, 92, 246, 0.4);
            border-radius: 10px;
            overflow: hidden;
        }

        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            opacity: 0.3;
            transition: opacity 0.3s;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: white;
        }

        #crosshair::before {
            width: 100%;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }

        #crosshair::after {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }

        #crosshair.active {
            opacity: 0.8;
        }

        h2 {
            font-size: 22px;
            margin-bottom: 18px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 700;
            letter-spacing: -0.5px;
        }

        h3 {
            font-size: 16px;
            margin: 18px 0 10px;
            color: #c4b5fd;
            border-bottom: 1px solid rgba(196, 181, 253, 0.2);
            padding-bottom: 6px;
            font-weight: 600;
        }

        textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid rgba(139, 92, 246, 0.3);
            background: rgba(30, 30, 50, 0.6);
            color: #fff;
            border-radius: 10px;
            resize: vertical;
            min-height: 100px;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.5;
            transition: all 0.3s;
        }

        textarea:focus {
            outline: none;
            border-color: #8b5cf6;
            background: rgba(30, 30, 50, 0.8);
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.2);
        }

        select {
            width: 100%;
            padding: 10px;
            background: rgba(30, 30, 50, 0.6);
            border: 1px solid rgba(139, 92, 246, 0.3);
            color: white;
            border-radius: 10px;
            margin-bottom: 15px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
        }

        select:hover {
            border-color: #8b5cf6;
            background: rgba(30, 30, 50, 0.8);
        }

        button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.5s, height 0.5s;
        }

        button:hover::before {
            width: 250px;
            height: 250px;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(139, 92, 246, 0.4);
        }

        button:active:not(:disabled) {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #f59e0b, #ec4899);
        }

        .btn-success {
            background: linear-gradient(135deg, #10b981, #059669);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ef4444, #dc2626);
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            transition: all 0.3s;
        }

        .stat-item:hover {
            padding-left: 8px;
            background: linear-gradient(90deg, rgba(139, 92, 246, 0.08), transparent);
        }

        .stat-label {
            color: #a5b4fc;
            font-size: 13px;
        }

        .stat-value {
            color: #e9d5ff;
            font-weight: 600;
            font-size: 15px;
        }

        .memory-item {
            background: rgba(139, 92, 246, 0.08);
            border: 1px solid rgba(139, 92, 246, 0.25);
            border-radius: 10px;
            padding: 12px;
            margin: 10px 0;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }

        .memory-item:hover {
            background: rgba(139, 92, 246, 0.15);
            transform: translateX(5px);
            box-shadow: 0 5px 20px rgba(139, 92, 246, 0.3);
        }

        .memory-item.active {
            background: rgba(139, 92, 246, 0.25);
            border-color: #8b5cf6;
        }

        .memory-title {
            font-weight: 600;
            color: #e9d5ff;
            margin-bottom: 4px;
            font-size: 14px;
        }

        .memory-location {
            font-size: 11px;
            color: #94a3b8;
        }

        .memory-mutations {
            font-size: 11px;
            color: #f59e0b;
            margin-top: 4px;
        }

        .recall-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-left: 8px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        .recall-high { 
            background: #10b981;
            box-shadow: 0 0 8px #10b981;
        }

        .recall-medium { 
            background: #f59e0b;
            box-shadow: 0 0 8px #f59e0b;
        }

        .recall-low { 
            background: #ef4444;
            box-shadow: 0 0 8px #ef4444;
        }

        #mode-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            opacity: 0;
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 4px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(139, 92, 246, 0.4);
        }

        .fade-in {
            animation: fadeInOut 2s ease;
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.95); }
        }

        .controls-hint {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: linear-gradient(135deg, rgba(20, 20, 40, 0.9), rgba(40, 20, 60, 0.9));
            padding: 10px 18px;
            border-radius: 20px;
            font-size: 12px;
            color: #c4b5fd;
            opacity: 0.8;
            border: 1px solid rgba(139, 92, 246, 0.2);
            transition: opacity 0.3s;
        }

        .controls-hint:hover {
            opacity: 1;
        }

        .control-key {
            background: rgba(139, 92, 246, 0.15);
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 600;
            color: #e9d5ff;
        }

        #test-panel {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(20, 20, 40, 0.98), rgba(40, 20, 60, 0.98));
            padding: 30px;
            border-radius: 20px;
            width: 500px;
            max-width: 90%;
            border: 2px solid rgba(139, 92, 246, 0.4);
            box-shadow: 0 30px 60px rgba(0, 0, 0, 0.8);
            z-index: 1000;
        }

        #test-question {
            font-size: 18px;
            margin-bottom: 20px;
            color: #e9d5ff;
            line-height: 1.5;
        }

        #test-answer {
            width: 100%;
            padding: 12px;
            margin-bottom: 20px;
            background: rgba(30, 30, 50, 0.6);
            border: 1px solid rgba(139, 92, 246, 0.3);
            color: #fff;
            border-radius: 10px;
            font-size: 15px;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 3px;
        }

        #file-input {
            display: none;
        }

        .mutation-log {
            position: fixed;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            background: rgba(20, 20, 40, 0.9);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(245, 158, 11, 0.3);
            max-width: 250px;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }

        .mutation-log.visible {
            opacity: 1;
        }

        .mutation-title {
            color: #f59e0b;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .mutation-detail {
            color: #fbbf24;
            font-size: 12px;
            line-height: 1.4;
        }

        #autosave-indicator {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(16, 185, 129, 0.9);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            color: white;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        #autosave-indicator.visible {
            opacity: 1;
        }

        .interaction-hint {
            position: fixed;
            padding: 8px 16px;
            background: rgba(139, 92, 246, 0.9);
            color: white;
            border-radius: 8px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 100;
        }

        .interaction-hint.visible {
            opacity: 1;
        }

        .memory-description {
            position: fixed;
            bottom: 200px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(20, 20, 40, 0.95), rgba(40, 20, 60, 0.95));
            padding: 15px 25px;
            border-radius: 15px;
            max-width: 600px;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            border: 1px solid rgba(139, 92, 246, 0.3);
        }

        .memory-description.visible {
            opacity: 1;
        }

        .memory-description h4 {
            color: #e9d5ff;
            margin-bottom: 8px;
            font-size: 16px;
        }

        .memory-description p {
            color: #c4b5fd;
            font-size: 14px;
            line-height: 1.5;
        }

        @media (max-width: 768px) {
            #control-panel, #stats-panel {
                display: none;
            }
            
            .controls-hint {
                font-size: 10px;
            }
            
            #navigation-panel {
                gap: 8px;
                padding: 8px 12px;
            }
            
            button {
                padding: 8px 16px;
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="crosshair"></div>
    
    <div id="control-panel" class="ui-panel">
        <h2>üèõÔ∏è Enhanced Memory Palace</h2>
        
        <h3>üìù Memory Items</h3>
        <textarea id="concept-input" placeholder="Enter concepts to memorize (one per line)...
Format: Concept: Description
Example:
Mitochondria: Powerhouse of the cell
DNA: Genetic information storage"></textarea>
        
        <h3>üé® Palace Theme</h3>
        <select id="theme-select">
            <option value="fantasy">üè∞ Fantasy Castle</option>
            <option value="space">üöÄ Space Station</option>
            <option value="nature">üå≥ Enchanted Forest</option>
            <option value="city">üåÉ Cyberpunk City</option>
            <option value="underwater">üåä Underwater Palace</option>
            <option value="ancient">üèõÔ∏è Ancient Temple</option>
            <option value="crystal">üíé Crystal Cavern</option>
            <option value="void">üåå Void Dimension</option>
        </select>
        
        <div style="display: flex; gap: 10px; margin-bottom: 15px;">
            <button onclick="fillExample()" class="btn-secondary" style="flex: 1;">
                ‚ú® Example
            </button>
            <button onclick="buildPalace()" style="flex: 1;">
                üî® Build
            </button>
        </div>
        
        <div style="display: flex; gap: 10px; margin-bottom: 15px;">
            <button onclick="startTest()" id="test-btn" disabled style="flex: 1;">
                üß† Test
            </button>
            <button onclick="startWalkthrough()" id="walkthrough-btn" disabled style="flex: 1;">
                üëÅÔ∏è Tour
            </button>
        </div>
        
        <div style="display: flex; gap: 10px; margin-bottom: 15px;">
            <button onclick="toggleSound()" id="sound-btn" style="flex: 1;">
                üîä Sound: ON
            </button>
            <button onclick="resetPalace()" class="btn-danger" style="flex: 1;">
                üîÑ Reset
            </button>
        </div>
        
        <h3>üìö Stored Memories</h3>
        <div id="memory-list"></div>
    </div>
    
    <div id="stats-panel" class="ui-panel">
        <h2>üìä Palace Statistics</h2>
        <div class="stat-item">
            <span class="stat-label">Total Items</span>
            <span class="stat-value" id="total-items">0</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Rooms</span>
            <span class="stat-value" id="room-count">0</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Recall Rate</span>
            <span class="stat-value" id="recall-rate">-</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Mutations</span>
            <span class="stat-value" id="mutation-count">0</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Palace Age</span>
            <span class="stat-value" id="palace-age">New</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Session Time</span>
            <span class="stat-value" id="session-time">0m</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Mode</span>
            <span class="stat-value" id="current-mode">Explore</span>
        </div>
        <div class="progress-bar">
            <div class="progress-fill" id="mastery-progress" style="width: 0%"></div>
        </div>
        <div style="text-align: center; margin-top: 8px; color: #94a3b8; font-size: 11px;">
            Mastery Level
        </div>
    </div>
    
    <div id="import-export-panel" class="ui-panel">
        <button onclick="exportPalace()" class="btn-success">
            üíæ Export
        </button>
        <button onclick="document.getElementById('file-input').click()" class="btn-secondary">
            üìÅ Import
        </button>
        <button onclick="toggleAutoSave()" id="autosave-btn">
            üîÑ Auto-Save: OFF
        </button>
    </div>
    
    <div id="navigation-panel" class="ui-panel">
        <button onclick="previousRoom()">‚¨Ö Prev</button>
        <button onclick="toggleView()">üëÅÔ∏è View</button>
        <button onclick="teleportToRoom()">üéØ Jump</button>
        <button onclick="toggleFly()" id="fly-btn">ü¶Ö Fly</button>
        <button onclick="nextRoom()">Next ‚û°</button>
    </div>
    
    <canvas id="minimap"></canvas>
    
    <div id="test-panel">
        <h2>üß† Memory Test</h2>
        <div id="test-question"></div>
        <input type="text" id="test-answer" placeholder="Enter your answer...">
        <div style="display: flex; gap: 10px; margin-top: 15px;">
            <button onclick="submitAnswer()" class="btn-success" style="flex: 1;">Submit</button>
            <button onclick="skipQuestion()" class="btn-secondary" style="flex: 1;">Skip</button>
            <button onclick="endTest()" class="btn-danger" style="flex: 1;">End Test</button>
        </div>
        <div class="progress-bar">
            <div class="progress-fill" id="test-progress" style="width: 0%"></div>
        </div>
        <div style="text-align: center; margin-top: 10px; color: #94a3b8; font-size: 12px;">
            Question <span id="q-current">1</span> of <span id="q-total">0</span>
        </div>
    </div>
    
    <div id="mode-indicator"></div>
    
    <div class="controls-hint">
        <span class="control-key">WASD</span> Move ‚Ä¢ 
        <span class="control-key">Mouse</span> Look ‚Ä¢ 
        <span class="control-key">Space</span> Jump ‚Ä¢ 
        <span class="control-key">Shift</span> Run ‚Ä¢ 
        <span class="control-key">E</span> Interact ‚Ä¢
        <span class="control-key">Tab</span> Map
    </div>
    
    <div id="mutation-log" class="mutation-log">
        <div class="mutation-title">üß¨ Room Mutated!</div>
        <div class="mutation-detail" id="mutation-detail"></div>
    </div>
    
    <div id="autosave-indicator">‚úî Palace Auto-Saved</div>
    
    <div id="interaction-hint" class="interaction-hint"></div>
    
    <div id="memory-description" class="memory-description">
        <h4 id="memory-title"></h4>
        <p id="memory-content"></p>
    </div>
    
    <input type="file" id="file-input" accept=".json">

    <script>
        // Core variables
        let scene, camera, renderer;
        let minimapCamera, minimapRenderer;
        let palaceData = {
            version: "2.0.0",
            createdAt: new Date().toISOString(),
            lastModified: new Date().toISOString(),
            theme: "fantasy",
            rooms: [],
            memoryItems: [],
            statistics: {
                totalTests: 0,
                totalAttempts: 0,
                totalCorrect: 0,
                mutations: 0,
                sessionTime: 0,
                totalInteractions: 0
            }
        };
        
        let roomMeshes = [];
        let currentRoom = 0;
        let isFirstPerson = true;
        let isFlying = false;
        let soundEnabled = true;
        let testMode = false;
        let walkthroughMode = false;
        let currentTestIndex = 0;
        let testResults = [];
        let autoSaveEnabled = false;
        let autoSaveInterval = null;
        let sessionStartTime = Date.now();
        let animationFrameId = null;
        let hoveredObject = null;
        let selectedMemoryItem = null;
        
        // Movement controls
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let moveUp = false;
        let moveDown = false;
        let isRunning = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        
        // Mouse controls
        let mouseX = 0;
        let mouseY = 0;
        let targetRotationX = 0;
        let targetRotationY = 0;
        let mouseLocked = false;
        
        // Raycaster for interactions
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // Audio context for sound effects
        let audioContext = null;
        
        // Mutation types
        const MUTATIONS = {
            COLOR_SHIFT: 'color_shift',
            SIZE_CHANGE: 'size_change',
            POSITION_DRIFT: 'position_drift',
            ROTATION_SPIN: 'rotation_spin',
            MATERIAL_CHANGE: 'material_change',
            PARTICLE_BURST: 'particle_burst',
            GLOW_ENHANCE: 'glow_enhance',
            SHAPE_MORPH: 'shape_morph',
            LEVITATION: 'levitation',
            PULSE: 'pulse'
        };
        
        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000033, 10, 150);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // Setup minimap
            setupMinimap();
            
            // Lighting setup
            setupLighting();
            
            // Create demo room
            createDemoRoom();
            
            // Event listeners
            setupEventListeners();
            
            // Initialize audio context
            initAudio();
            
            // Load saved palace if exists
            loadFromLocalStorage();
            
            // Start session timer
            setInterval(updateSessionTime, 1000);
            
            animate();
        }
        
        function setupMinimap() {
            const minimapCanvas = document.getElementById('minimap');
            minimapRenderer = new THREE.WebGLRenderer({ 
                canvas: minimapCanvas,
                alpha: true 
            });
            minimapRenderer.setSize(200, 150);
            
            minimapCamera = new THREE.OrthographicCamera(
                -50, 50, 37.5, -37.5, 0.1, 1000
            );
            minimapCamera.position.set(0, 100, 0);
            minimapCamera.lookAt(0, 0, 0);
        }
        
        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0x404080, 0.4);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.near = 0.1;
            directionalLight.shadow.camera.far = 100;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // Dynamic point lights with animation
            const colors = [0x667eea, 0x764ba2, 0xf59e0b];
            for (let i = 0; i < 3; i++) {
                const pointLight = new THREE.PointLight(colors[i], 0.3, 30);
                pointLight.position.set(
                    Math.random() * 40 - 20,
                    10 + Math.random() * 10,
                    Math.random() * 40 - 20
                );
                pointLight.userData.originalPos = pointLight.position.clone();
                pointLight.userData.animSpeed = 0.5 + Math.random() * 0.5;
                scene.add(pointLight);
            }
        }
        
        function initAudio() {
            if (window.AudioContext || window.webkitAudioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }
        
        function playSound(frequency, duration) {
            if (!soundEnabled || !audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = frequency;
            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }
        
        function setupEventListeners() {
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('click', onMouseClick);
            window.addEventListener('resize', onWindowResize);
            
            // Pointer lock for better FPS controls
            document.addEventListener('pointerlockchange', onPointerLockChange);
            renderer.domElement.addEventListener('click', () => {
                if (isFirstPerson && !mouseLocked) {
                    renderer.domElement.requestPointerLock();
                }
            });
            
            // File input listener
            document.getElementById('file-input').addEventListener('change', handleFileImport);
            
            // Auto-save on visibility change
            document.addEventListener('visibilitychange', () => {
                if (document.hidden && palaceData.memoryItems.length > 0) {
                    saveToLocalStorage();
                }
            });
            
            // Test answer on Enter key
            document.getElementById('test-answer').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    submitAnswer();
                }
            });
        }
        
        function onPointerLockChange() {
            mouseLocked = document.pointerLockElement === renderer.domElement;
            document.getElementById('crosshair').classList.toggle('active', mouseLocked);
        }
        
        function createDemoRoom() {
            const roomData = {
                id: 'demo-room',
                position: { x: 0, y: 0, z: 0 },
                mutations: [],
                theme: 'fantasy',
                memoryObjects: []
            };
            
            createRoomFromData(roomData, 0);
        }
        
        function createRoomFromData(roomData, index) {
            const roomGroup = new THREE.Group();
            const offset = index * 50;
            roomGroup.name = `room-${index}`;
            
            // Apply stored mutations
            const mutations = roomData.mutations || [];
            
            // Enhanced floor with texture pattern
            const floorGeometry = new THREE.PlaneGeometry(40, 40, 10, 10);
            const floorColor = mutations.find(m => m.type === MUTATIONS.COLOR_SHIFT && m.target === 'floor')?.value || 0x1a1a3e;
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: floorColor,
                metalness: 0.2,
                roughness: 0.8,
                wireframe: false
            });
            
            // Add subtle height variation to floor vertices
            const floorVertices = floorGeometry.attributes.position.array;
            for (let i = 0; i < floorVertices.length; i += 3) {
                floorVertices[i + 2] = Math.sin(floorVertices[i] * 0.1) * 0.1 + Math.cos(floorVertices[i + 1] * 0.1) * 0.1;
            }
            floorGeometry.computeVertexNormals();
            
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.x = offset;
            floor.receiveShadow = true;
            roomGroup.add(floor);
            
            // Enhanced walls with decorations
            const wallColors = {
                fantasy: 0x4a148c,
                space: 0x0d47a1,
                nature: 0x1b5e20,
                city: 0x263238,
                underwater: 0x006064,
                ancient: 0x5d4037,
                crystal: 0x4a0e4e,
                void: 0x0a0a0a
            };
            
            const wallColor = mutations.find(m => m.type === MUTATIONS.COLOR_SHIFT && m.target === 'walls')?.value || 
                             wallColors[roomData.theme] || 0x16213e;
            
            for (let i = 0; i < 4; i++) {
                const wallGeometry = new THREE.PlaneGeometry(40, 20);
                const wallMaterial = new THREE.MeshStandardMaterial({ 
                    color: wallColor,
                    metalness: 0.1,
                    roughness: 0.9
                });
                const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                wall.receiveShadow = true;
                wall.castShadow = true;
                
                const positions = [
                    { pos: [offset, 10, -20], rot: [0, 0, 0] },
                    { pos: [offset, 10, 20], rot: [0, Math.PI, 0] },
                    { pos: [offset - 20, 10, 0], rot: [0, Math.PI / 2, 0] },
                    { pos: [offset + 20, 10, 0], rot: [0, -Math.PI / 2, 0] }
                ];
                
                wall.position.set(...positions[i].pos);
                wall.rotation.set(...positions[i].rot);
                roomGroup.add(wall);
                
                // Add decorative elements to walls
                if (i % 2 === 0) {
                    const decoration = createWallDecoration(roomData.theme);
                    decoration.position.copy(wall.position);
                    decoration.position.y += Math.random() * 5 - 2.5;
                    decoration.position.x += (Math.random() - 0.5) * 10;
                    roomGroup.add(decoration);
                }
            }
            
            // Ceiling
            const ceilingGeometry = new THREE.PlaneGeometry(40, 40);
            const ceilingMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x0a0a1a,
                metalness: 0.3,
                roughness: 0.7,
                side: THREE.DoubleSide
            });
            const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.set(offset, 20, 0);
            roomGroup.add(ceiling);
            
            // Memory objects with enhanced visuals
            roomData.memoryObjects.forEach((objData, i) => {
                const memoryObject = createMemoryObject(objData, roomData.theme);
                const basePos = objData.position || { 
                    x: offset + (i - 1) * 10, 
                    y: 4 + Math.sin(i * 0.8) * 2, 
                    z: (i - 1) * 8 
                };
                
                // Apply position mutations
                const posMutation = mutations.find(m => m.type === MUTATIONS.POSITION_DRIFT && m.target === objData.id);
                if (posMutation) {
                    basePos.x += posMutation.value.x;
                    basePos.y += posMutation.value.y;
                    basePos.z += posMutation.value.z;
                }
                
                memoryObject.position.set(basePos.x, basePos.y, basePos.z);
                memoryObject.userData = { 
                    memoryItem: objData.memoryItem,
                    objectId: objData.id,
                    mutations: objData.mutations || [],
                    originalPosition: basePos,
                    interactionCount: 0
                };
                
                // Add glow sphere around memory object
                const glowGeometry = new THREE.SphereGeometry(3, 16, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0x8b5cf6,
                    transparent: true,
                    opacity: 0.1,
                    side: THREE.BackSide
                });
                const glowSphere = new THREE.Mesh(glowGeometry, glowMaterial);
                glowSphere.scale.set(1.5, 1.5, 1.5);
                memoryObject.add(glowSphere);
                
                roomGroup.add(memoryObject);
            });
            
            // Enhanced ambient particles
            addAmbientParticles(roomGroup, offset, roomData.theme);
            
            // Add floating crystals for ambiance
            for (let i = 0; i < 5; i++) {
                const crystal = createFloatingCrystal(roomData.theme);
                crystal.position.set(
                    offset + (Math.random() - 0.5) * 30,
                    5 + Math.random() * 10,
                    (Math.random() - 0.5) * 30
                );
                crystal.userData.floatSpeed = 0.3 + Math.random() * 0.3;
                crystal.userData.originalY = crystal.position.y;
                roomGroup.add(crystal);
            }
            
            // Store room reference
            roomGroup.userData = { roomData: roomData, index: index };
            roomMeshes[index] = roomGroup;
            scene.add(roomGroup);
        }
        
        function createWallDecoration(theme) {
            const decorations = {
                fantasy: () => {
                    const geometry = new THREE.TorusGeometry(1, 0.3, 8, 16);
                    const material = new THREE.MeshStandardMaterial({
                        color: 0xffd700,
                        emissive: 0xffd700,
                        emissiveIntensity: 0.2,
                        metalness: 0.8,
                        roughness: 0.2
                    });
                    return new THREE.Mesh(geometry, material);
                },
                space: () => {
                    const geometry = new THREE.OctahedronGeometry(1, 0);
                    const material = new THREE.MeshStandardMaterial({
                        color: 0x00ffff,
                        emissive: 0x00ffff,
                        emissiveIntensity: 0.3,
                        metalness: 0.9,
                        roughness: 0.1
                    });
                    return new THREE.Mesh(geometry, material);
                },
                nature: () => {
                    const geometry = new THREE.ConeGeometry(0.5, 2, 8);
                    const material = new THREE.MeshStandardMaterial({
                        color: 0x228b22,
                        roughness: 0.8
                    });
                    return new THREE.Mesh(geometry, material);
                }
            };
            
            const decorator = decorations[theme] || decorations.fantasy;
            return decorator();
        }
        
        function createFloatingCrystal(theme) {
            const geometry = new THREE.OctahedronGeometry(0.5, 0);
            const colors = {
                fantasy: 0x9c27b0,
                space: 0x2196f3,
                nature: 0x66bb6a,
                city: 0xff6f00,
                underwater: 0x00acc1,
                ancient: 0x8d6e63,
                crystal: 0xe91e63,
                void: 0x311b92
            };
            
            const material = new THREE.MeshStandardMaterial({
                color: colors[theme] || 0x8b5cf6,
                emissive: colors[theme] || 0x8b5cf6,
                emissiveIntensity: 0.3,
                metalness: 0.7,
                roughness: 0.3,
                transparent: true,
                opacity: 0.8
            });
            
            const crystal = new THREE.Mesh(geometry, material);
            crystal.castShadow = true;
            return crystal;
        }
        
        function createMemoryObject(objData, theme) {
            const shapes = {
                fantasy: () => new THREE.IcosahedronGeometry(2, 1),
                space: () => new THREE.TorusGeometry(2, 0.7, 16, 32),
                nature: () => new THREE.DodecahedronGeometry(2, 0),
                city: () => new THREE.BoxGeometry(2.5, 3.5, 2.5, 2, 2, 2),
                underwater: () => new THREE.SphereGeometry(2, 32, 32),
                ancient: () => new THREE.CylinderGeometry(1.5, 2, 3, 8),
                crystal: () => new THREE.OctahedronGeometry(2, 1),
                void: () => new THREE.TetrahedronGeometry(2.5, 0)
            };
            
            let geometry = shapes[theme] ? shapes[theme]() : shapes.fantasy();
            
            // Apply shape mutations
            const mutations = objData.mutations || [];
            const sizeMutation = mutations.find(m => m.type === MUTATIONS.SIZE_CHANGE);
            if (sizeMutation) {
                geometry.scale(sizeMutation.value, sizeMutation.value, sizeMutation.value);
            }
            
            // Enhanced material with mutations
            const colorMutation = mutations.find(m => m.type === MUTATIONS.COLOR_SHIFT);
            const glowMutation = mutations.find(m => m.type === MUTATIONS.GLOW_ENHANCE);
            
            const material = new THREE.MeshStandardMaterial({
                color: colorMutation ? colorMutation.value : 0x8b5cf6,
                emissive: glowMutation ? glowMutation.value : 0x8b5cf6,
                emissiveIntensity: glowMutation ? 0.5 : 0.2,
                metalness: theme === 'space' || theme === 'city' ? 0.8 : 0.3,
                roughness: theme === 'space' || theme === 'city' ? 0.2 : 0.7
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            // Add floating animation data
            mesh.userData.floatSpeed = 0.5 + Math.random() * 0.5;
            mesh.userData.floatAmount = 0.3 + Math.random() * 0.3;
            mesh.userData.rotationSpeed = 0.005 + Math.random() * 0.01;
            mesh.userData.originalY = objData.position ? objData.position.y : 4;
            
            return mesh;
        }
        
        function addAmbientParticles(roomGroup, offset, theme) {
            const particlesGeometry = new THREE.BufferGeometry();
            const particlesCount = 200;
            const positions = new Float32Array(particlesCount * 3);
            const colors = new Float32Array(particlesCount * 3);
            
            const particleColors = {
                fantasy: [0.58, 0.15, 0.69],
                space: [0.13, 0.59, 0.95],
                nature: [0.40, 0.73, 0.42],
                city: [1.00, 0.44, 0.00],
                underwater: [0.00, 0.67, 0.76],
                ancient: [0.55, 0.43, 0.39],
                crystal: [0.91, 0.12, 0.39],
                void: [0.19, 0.11, 0.57]
            };
            
            const color = particleColors[theme] || particleColors.fantasy;
            
            for (let i = 0; i < particlesCount; i++) {
                positions[i * 3] = offset + (Math.random() - 0.5) * 35;
                positions[i * 3 + 1] = Math.random() * 18;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 35;
                
                colors[i * 3] = color[0] + Math.random() * 0.2;
                colors[i * 3 + 1] = color[1] + Math.random() * 0.2;
                colors[i * 3 + 2] = color[2] + Math.random() * 0.2;
            }
            
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const particlesMaterial = new THREE.PointsMaterial({
                size: 0.2,
                transparent: true,
                opacity: 0.6,
                vertexColors: true,
                blending: THREE.AdditiveBlending
            });
            
            const particles = new THREE.Points(particlesGeometry, particlesMaterial);
            particles.userData.isParticles = true;
            roomGroup.add(particles);
        }
        
        function buildPalace() {
            const input = document.getElementById('concept-input').value.trim();
            const theme = document.getElementById('theme-select').value;
            
            if (!input) {
                showModeIndicator('Enter items first!');
                return;
            }
            
            // Clear existing palace
            clearPalace();
            
            // Parse input and create palace data
            const lines = input.split('\n').filter(line => line.trim());
            palaceData.theme = theme;
            palaceData.memoryItems = [];
            palaceData.rooms = [];
            palaceData.lastModified = new Date().toISOString();
            
            lines.forEach((line, index) => {
                const [concept, description] = line.split(':').map(s => s.trim());
                const memoryItem = {
                    id: `memory-${Date.now()}-${index}`,
                    concept: concept || line,
                    description: description || '',
                    roomIndex: Math.floor(index / 3),
                    positionIndex: index % 3,
                    recallRate: 0,
                    attempts: 0,
                    successes: 0,
                    lastTested: null,
                    mutations: []
                };
                palaceData.memoryItems.push(memoryItem);
            });
            
            // Create rooms with better spacing
            const roomsNeeded = Math.ceil(palaceData.memoryItems.length / 3);
            for (let i = 0; i < roomsNeeded; i++) {
                const roomMemories = palaceData.memoryItems.filter(m => m.roomIndex === i);
                const room = {
                    id: `room-${Date.now()}-${i}`,
                    index: i,
                    theme: theme,
                    position: { x: i * 50, y: 0, z: 0 },
                    mutations: [],
                    memoryObjects: roomMemories.map((mem, j) => ({
                        id: mem.id,
                        memoryItem: mem,
                        position: {
                            x: i * 50 + (j - 1) * 12,
                            y: 4 + Math.sin(j * Math.PI / 3) * 2,
                            z: (j - 1) * 10
                        },
                        mutations: []
                    }))
                };
                palaceData.rooms.push(room);
                createRoomFromData(room, i);
            }
            
            updateUI();
            saveToLocalStorage();
            document.getElementById('test-btn').disabled = false;
            document.getElementById('walkthrough-btn').disabled = false;
            showModeIndicator('Palace Built!');
            playSound(440, 0.2);
        }
        
        function mutateRoom(roomIndex, trigger) {
            if (!palaceData.rooms[roomIndex]) return;
            
            const room = palaceData.rooms[roomIndex];
            const mutationType = Object.values(MUTATIONS)[Math.floor(Math.random() * Object.values(MUTATIONS).length)];
            
            let mutation = {
                type: mutationType,
                trigger: trigger,
                timestamp: new Date().toISOString(),
                value: null,
                target: null
            };
            
            switch(mutationType) {
                case MUTATIONS.COLOR_SHIFT:
                    mutation.target = Math.random() > 0.5 ? 'walls' : 'floor';
                    mutation.value = Math.floor(Math.random() * 0xffffff);
                    break;
                    
                case MUTATIONS.POSITION_DRIFT:
                    if (room.memoryObjects.length > 0) {
                        const obj = room.memoryObjects[Math.floor(Math.random() * room.memoryObjects.length)];
                        mutation.target = obj.id;
                        mutation.value = {
                            x: (Math.random() - 0.5) * 3,
                            y: (Math.random() - 0.5) * 2,
                            z: (Math.random() - 0.5) * 3
                        };
                    }
                    break;
                    
                case MUTATIONS.SIZE_CHANGE:
                    if (room.memoryObjects.length > 0) {
                        const obj = room.memoryObjects[Math.floor(Math.random() * room.memoryObjects.length)];
                        mutation.target = obj.id;
                        mutation.value = 0.7 + Math.random() * 0.6;
                        obj.mutations.push(mutation);
                    }
                    break;
                    
                case MUTATIONS.GLOW_ENHANCE:
                    if (room.memoryObjects.length > 0) {
                        const obj = room.memoryObjects[Math.floor(Math.random() * room.memoryObjects.length)];
                        mutation.target = obj.id;
                        mutation.value = Math.floor(Math.random() * 0xffffff);
                        obj.mutations.push(mutation);
                    }
                    break;
                    
                case MUTATIONS.LEVITATION:
                    if (room.memoryObjects.length > 0) {
                        const obj = room.memoryObjects[Math.floor(Math.random() * room.memoryObjects.length)];
                        mutation.target = obj.id;
                        mutation.value = 2 + Math.random() * 3;
                        obj.mutations.push(mutation);
                    }
                    break;
                    
                case MUTATIONS.PULSE:
                    if (room.memoryObjects.length > 0) {
                        const obj = room.memoryObjects[Math.floor(Math.random() * room.memoryObjects.length)];
                        mutation.target = obj.id;
                        mutation.value = 0.5 + Math.random() * 0.5;
                        obj.mutations.push(mutation);
                    }
                    break;
            }
            
            room.mutations.push(mutation);
            palaceData.statistics.mutations++;
            
            // Rebuild the room with mutations
            rebuildRoom(roomIndex);
            
            // Show mutation log
            showMutationLog(mutationType, mutation);
            
            // Play mutation sound
            playSound(300 + Math.random() * 200, 0.15);
            
            saveToLocalStorage();
        }
        
        function rebuildRoom(roomIndex) {
            if (!roomMeshes[roomIndex]) return;
            
            // Remove old room
            scene.remove(roomMeshes[roomIndex]);
            
            // Create new room with mutations
            createRoomFromData(palaceData.rooms[roomIndex], roomIndex);
        }
        
        function showMutationLog(type, mutation) {
            const log = document.getElementById('mutation-log');
            const detail = document.getElementById('mutation-detail');
            
            const descriptions = {
                [MUTATIONS.COLOR_SHIFT]: `Colors shifted in ${mutation.target}`,
                [MUTATIONS.SIZE_CHANGE]: `Memory object resized`,
                [MUTATIONS.POSITION_DRIFT]: `Object position drifted`,
                [MUTATIONS.GLOW_ENHANCE]: `Enhanced glow effect`,
                [MUTATIONS.PARTICLE_BURST]: `Particle burst added`,
                [MUTATIONS.SHAPE_MORPH]: `Shape morphed`,
                [MUTATIONS.LEVITATION]: `Object levitation increased`,
                [MUTATIONS.PULSE]: `Pulsing effect added`
            };
            
            detail.textContent = descriptions[type] || 'Room mutated';
            log.classList.add('visible');
            
            setTimeout(() => {
                log.classList.remove('visible');
            }, 3000);
        }
        
        function startWalkthrough() {
            if (palaceData.memoryItems.length === 0) return;
            
            walkthroughMode = true;
            currentRoom = 0;
            camera.position.set(0, 5, 10);
            
            document.getElementById('current-mode').textContent = 'Tour';
            showModeIndicator('Starting Walkthrough Tour');
            
            // Auto-navigate through rooms
            let itemIndex = 0;
            const tourInterval = setInterval(() => {
                if (itemIndex >= palaceData.memoryItems.length) {
                    clearInterval(tourInterval);
                    walkthroughMode = false;
                    document.getElementById('current-mode').textContent = 'Explore';
                    showModeIndicator('Tour Complete!');
                    return;
                }
                
                const item = palaceData.memoryItems[itemIndex];
                goToMemoryItem(itemIndex);
                showMemoryDescription(item.concept, item.description);
                playSound(523 + itemIndex * 20, 0.1);
                
                itemIndex++;
            }, 5000);
        }
        
        function exportPalace() {
            if (palaceData.memoryItems.length === 0) {
                showModeIndicator('No palace to export!');
                return;
            }
            
            const dataStr = JSON.stringify(palaceData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `memory-palace-${new Date().toISOString().slice(0, 10)}.json`;
            link.click();
            
            showModeIndicator('Palace Exported!');
            playSound(880, 0.2);
        }
        
        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const imported = JSON.parse(e.target.result);
                    
                    // Validate structure
                    if (!imported.version || !imported.memoryItems || !imported.rooms) {
                        throw new Error('Invalid palace file');
                    }
                    
                    // Clear current palace
                    clearPalace();
                    
                    // Load imported data
                    palaceData = imported;
                    palaceData.lastModified = new Date().toISOString();
                    
                    // Rebuild palace from data
                    palaceData.rooms.forEach((room, index) => {
                        createRoomFromData(room, index);
                    });
                    
                    updateUI();
                    saveToLocalStorage();
                    document.getElementById('test-btn').disabled = palaceData.memoryItems.length === 0;
                    document.getElementById('walkthrough-btn').disabled = palaceData.memoryItems.length === 0;
                    
                    showModeIndicator('Palace Imported!');
                    playSound(660, 0.2);
                } catch (error) {
                    console.error('Import error:', error);
                    showModeIndicator('Import Failed!');
                    playSound(200, 0.3);
                }
            };
            reader.readAsText(file);
            
            // Clear file input
            event.target.value = '';
        }
        
        function clearPalace() {
            roomMeshes.forEach(room => {
                if (room) scene.remove(room);
            });
            roomMeshes = [];
        }
        
        function saveToLocalStorage() {
            try {
                localStorage.setItem('memoryPalaceData', JSON.stringify(palaceData));
                
                if (autoSaveEnabled) {
                    const indicator = document.getElementById('autosave-indicator');
                    indicator.classList.add('visible');
                    setTimeout(() => {
                        indicator.classList.remove('visible');
                    }, 2000);
                }
            } catch (e) {
                console.error('Failed to save to localStorage:', e);
            }
        }
        
        function loadFromLocalStorage() {
            try {
                const saved = localStorage.getItem('memoryPalaceData');
                if (saved) {
                    palaceData = JSON.parse(saved);
                    
                    if (palaceData.rooms && palaceData.rooms.length > 0) {
                        clearPalace();
                        palaceData.rooms.forEach((room, index) => {
                            createRoomFromData(room, index);
                        });
                        updateUI();
                        document.getElementById('test-btn').disabled = palaceData.memoryItems.length === 0;
                        document.getElementById('walkthrough-btn').disabled = palaceData.memoryItems.length === 0;
                        showModeIndicator('Palace Loaded!');
                    }
                }
            } catch (e) {
                console.error('Failed to load from localStorage:', e);
            }
        }
        
        function toggleAutoSave() {
            autoSaveEnabled = !autoSaveEnabled;
            const btn = document.getElementById('autosave-btn');
            btn.textContent = `üîÑ Auto-Save: ${autoSaveEnabled ? 'ON' : 'OFF'}`;
            
            if (autoSaveEnabled) {
                autoSaveInterval = setInterval(() => {
                    if (palaceData.memoryItems.length > 0) {
                        saveToLocalStorage();
                    }
                }, 30000); // Save every 30 seconds
            } else {
                clearInterval(autoSaveInterval);
            }
            
            showModeIndicator(`Auto-Save ${autoSaveEnabled ? 'Enabled' : 'Disabled'}`);
        }
        
        function toggleSound() {
            soundEnabled = !soundEnabled;
            const btn = document.getElementById('sound-btn');
            btn.textContent = `üîä Sound: ${soundEnabled ? 'ON' : 'OFF'}`;
            playSound(440, 0.1);
        }
        
        function toggleFly() {
            isFlying = !isFlying;
            const btn = document.getElementById('fly-btn');
            btn.textContent = isFlying ? 'üö∂ Walk' : 'ü¶Ö Fly';
            showModeIndicator(isFlying ? 'Flying Mode' : 'Walking Mode');
        }
        
        function resetPalace() {
            if (confirm('This will delete your entire palace. Are you sure?')) {
                clearPalace();
                palaceData = {
                    version: "2.0.0",
                    createdAt: new Date().toISOString(),
                    lastModified: new Date().toISOString(),
                    theme: "fantasy",
                    rooms: [],
                    memoryItems: [],
                    statistics: {
                        totalTests: 0,
                        totalAttempts: 0,
                        totalCorrect: 0,
                        mutations: 0,
                        sessionTime: 0,
                        totalInteractions: 0
                    }
                };
                localStorage.removeItem('memoryPalaceData');
                createDemoRoom();
                updateUI();
                document.getElementById('test-btn').disabled = true;
                document.getElementById('walkthrough-btn').disabled = true;
                showModeIndicator('Palace Reset!');
                playSound(220, 0.3);
            }
        }
        
        function fillExample() {
            const examples = [
                [
                    "Photosynthesis: Process where plants convert sunlight into chemical energy using chlorophyll",
                    "Mitochondria: Cellular powerhouse that produces ATP through aerobic respiration",
                    "DNA Replication: Semi-conservative process copying genetic material before cell division",
                    "Natural Selection: Evolutionary mechanism favoring beneficial traits for survival",
                    "Homeostasis: Biological systems maintaining stable internal conditions",
                    "Neurotransmitters: Chemical messengers transmitting signals across synapses"
                ],
                [
                    "Renaissance: European cultural rebirth emphasizing art and learning (14th-17th century)",
                    "Industrial Revolution: Transition to machine manufacturing transforming society (1760-1840)",
                    "Cold War: Geopolitical tension between US and Soviet Union (1947-1991)",
                    "French Revolution: Overthrow of monarchy establishing republic principles (1789)",
                    "Silk Road: Ancient trade routes connecting East and West civilizations",
                    "Roman Empire: Mediterranean civilization shaping Western culture and law"
                ],
                [
                    "Quantum Entanglement: Particles remain connected regardless of distance",
                    "Black Holes: Regions where gravity prevents light from escaping",
                    "E=mc¬≤: Einstein's mass-energy equivalence equation",
                    "Wave-Particle Duality: Matter exhibits both wave and particle properties",
                    "Newton's Laws: Three fundamental principles of classical mechanics",
                    "Entropy: Measure of disorder in thermodynamic systems"
                ],
                [
                    "Pythagorean Theorem: a¬≤ + b¬≤ = c¬≤ for right triangles",
                    "Golden Ratio: Mathematical proportion œÜ = 1.618... found in nature",
                    "Prime Numbers: Natural numbers divisible only by 1 and themselves",
                    "Fibonacci Sequence: Each number is sum of two preceding ones",
                    "Euler's Identity: e^(iœÄ) + 1 = 0 connecting fundamental constants",
                    "Calculus: Mathematics of change and motion using derivatives and integrals"
                ]
            ];
            
            const randomSet = examples[Math.floor(Math.random() * examples.length)];
            document.getElementById('concept-input').value = randomSet.join('\n');
            showModeIndicator('Example Loaded!');
            playSound(523, 0.1);
        }
        
        function startTest() {
            if (palaceData.memoryItems.length === 0) return;
            
            testMode = true;
            currentTestIndex = 0;
            testResults = [];
            
            document.getElementById('test-panel').style.display = 'block';
            document.getElementById('current-mode').textContent = 'Testing';
            document.getElementById('q-total').textContent = palaceData.memoryItems.length;
            
            // Shuffle questions
            const shuffled = [...palaceData.memoryItems].sort(() => Math.random() - 0.5);
            palaceData.testOrder = shuffled;
            
            palaceData.statistics.totalTests++;
            
            showNextQuestion();
            playSound(440, 0.1);
        }
        
        function showNextQuestion() {
            if (currentTestIndex >= palaceData.testOrder.length) {
                endTest();
                return;
            }
            
            const item = palaceData.testOrder[currentTestIndex];
            document.getElementById('test-question').textContent = 
                `What is associated with: "${item.concept}"?`;
            document.getElementById('test-answer').value = '';
            document.getElementById('test-answer').focus();
            document.getElementById('q-current').textContent = currentTestIndex + 1;
            
            const progress = ((currentTestIndex / palaceData.testOrder.length) * 100);
            document.getElementById('test-progress').style.width = progress + '%';
            
            // Navigate camera to relevant room
            const roomIndex = item.roomIndex;
            if (roomIndex !== undefined && roomIndex < roomMeshes.length) {
                smoothCameraTransition(roomIndex * 50, camera.position.y, camera.position.z, 1000);
            }
        }
        
        function submitAnswer() {
            const answer = document.getElementById('test-answer').value.trim().toLowerCase();
            const item = palaceData.testOrder[currentTestIndex];
            const correct = answer && item.description.toLowerCase().includes(answer);
            
            item.attempts++;
            palaceData.statistics.totalAttempts++;
            
            if (correct) {
                item.successes++;
                palaceData.statistics.totalCorrect++;
                playSound(523, 0.1);
                
                // Positive mutation on success
                if (Math.random() < 0.3) {
                    mutateRoom(item.roomIndex, 'correct_answer');
                }
            } else {
                playSound(220, 0.2);
                
                // Negative mutation on failure
                if (Math.random() < 0.5) {
                    mutateRoom(item.roomIndex, 'incorrect_answer');
                }
            }
            
            item.recallRate = item.successes / item.attempts;
            item.lastTested = new Date().toISOString();
            
            testResults.push({ item, correct, answer });
            
            currentTestIndex++;
            showNextQuestion();
        }
        
        function skipQuestion() {
            const item = palaceData.testOrder[currentTestIndex];
            testResults.push({ item, correct: false, answer: null, skipped: true });
            
            currentTestIndex++;
            showNextQuestion();
        }
        
        function endTest() {
            testMode = false;
            document.getElementById('test-panel').style.display = 'none';
            document.getElementById('current-mode').textContent = 'Explore';
            
            const correctCount = testResults.filter(r => r.correct).length;
            const skippedCount = testResults.filter(r => r.skipped).length;
            const total = testResults.length;
            
            showModeIndicator(`Test Complete: ${correctCount}/${total} Correct (${skippedCount} skipped)`);
            
            // Play result sound
            if (correctCount / total > 0.7) {
                playSound(880, 0.3);
            } else {
                playSound(330, 0.3);
            }
            
            // Apply adaptive mutations based on performance
            if (correctCount / total < 0.5) {
                // Poor performance - simplify
                palaceData.rooms.forEach((room, index) => {
                    if (Math.random() < 0.3) {
                        mutateRoom(index, 'poor_performance');
                    }
                });
            } else if (correctCount / total > 0.8) {
                // Good performance - add complexity
                palaceData.rooms.forEach((room, index) => {
                    if (Math.random() < 0.2) {
                        mutateRoom(index, 'excellent_performance');
                    }
                });
            }
            
            updateUI();
            saveToLocalStorage();
        }
        
        function updateSessionTime() {
            const elapsed = Math.floor((Date.now() - sessionStartTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            document.getElementById('session-time').textContent = 
                minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;
            
            palaceData.statistics.sessionTime += 1;
        }
        
        function updateUI() {
            // Update stats
            document.getElementById('total-items').textContent = palaceData.memoryItems.length;
            document.getElementById('room-count').textContent = palaceData.rooms.length;
            document.getElementById('mutation-count').textContent = palaceData.statistics.mutations;
            
            const totalAttempts = palaceData.statistics.totalAttempts;
            const totalCorrect = palaceData.statistics.totalCorrect;
            const recallRate = totalAttempts > 0 ? ((totalCorrect / totalAttempts) * 100).toFixed(1) + '%' : '-';
            document.getElementById('recall-rate').textContent = recallRate;
            
            const createdDate = new Date(palaceData.createdAt);
            const ageInDays = Math.floor((new Date() - createdDate) / (1000 * 60 * 60 * 24));
            document.getElementById('palace-age').textContent = 
                ageInDays === 0 ? 'New' : 
                ageInDays === 1 ? '1 day' : 
                `${ageInDays} days`;
            
            // Mastery progress
            const mastery = totalAttempts > 0 ? (totalCorrect / totalAttempts * 100) : 0;
            document.getElementById('mastery-progress').style.width = mastery + '%';
            
            // Update memory list
            const listEl = document.getElementById('memory-list');
            listEl.innerHTML = '';
            
            palaceData.memoryItems.forEach((item, index) => {
                const div = document.createElement('div');
                div.className = 'memory-item';
                if (selectedMemoryItem === index) {
                    div.classList.add('active');
                }
                div.onclick = () => {
                    selectedMemoryItem = index;
                    goToMemoryItem(index);
                    updateUI();
                };
                
                const recallClass = item.recallRate > 0.7 ? 'recall-high' : 
                                   item.recallRate > 0.4 ? 'recall-medium' : 'recall-low';
                
                const mutations = palaceData.rooms[item.roomIndex]?.mutations.length || 0;
                
                div.innerHTML = `
                    <div class="memory-title">
                        ${item.concept}
                        ${item.attempts > 0 ? `<span class="recall-indicator ${recallClass}"></span>` : ''}
                    </div>
                    <div class="memory-location">Room ${item.roomIndex + 1}</div>
                    ${mutations > 0 ? `<div class="memory-mutations">üß¨ ${mutations} mutations</div>` : ''}
                `;
                
                listEl.appendChild(div);
            });
        }
        
        function goToMemoryItem(index) {
            const item = palaceData.memoryItems[index];
            const roomIndex = item.roomIndex;
            currentRoom = roomIndex;
            
            const roomOffset = roomIndex * 50;
            smoothCameraTransition(roomOffset, 5, 10, 800);
            
            showModeIndicator(`Room ${roomIndex + 1}: ${item.concept}`);
            showMemoryDescription(item.concept, item.description);
            playSound(440 + index * 20, 0.1);
        }
        
        function smoothCameraTransition(x, y, z, duration) {
            const startPos = camera.position.clone();
            const endPos = new THREE.Vector3(x, y, z);
            const startTime = Date.now();
            
            function updatePosition() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = easeInOutCubic(progress);
                
                camera.position.lerpVectors(startPos, endPos, eased);
                
                if (progress < 1) {
                    requestAnimationFrame(updatePosition);
                }
            }
            
            updatePosition();
        }
        
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }
        
        function showMemoryDescription(title, content) {
            const descEl = document.getElementById('memory-description');
            document.getElementById('memory-title').textContent = title;
            document.getElementById('memory-content').textContent = content || 'No description available';
            descEl.classList.add('visible');
            
            setTimeout(() => {
                descEl.classList.remove('visible');
            }, 4000);
        }
        
        function toggleView() {
            isFirstPerson = !isFirstPerson;
            
            if (isFirstPerson) {
                camera.position.y = 5;
                camera.fov = 75;
            } else {
                camera.position.y = 30;
                camera.position.z = 30;
                camera.fov = 60;
            }
            camera.updateProjectionMatrix();
            
            showModeIndicator(isFirstPerson ? 'First Person' : 'Overview');
        }
        
        function teleportToRoom() {
            const roomCount = palaceData.rooms.length;
            if (roomCount === 0) return;
            
            const roomNumber = prompt(`Enter room number (1-${roomCount}):`);
            if (roomNumber) {
                const index = parseInt(roomNumber) - 1;
                if (index >= 0 && index < roomCount) {
                    currentRoom = index;
                    smoothCameraTransition(index * 50, camera.position.y, camera.position.z, 500);
                    showModeIndicator(`Room ${index + 1}`);
                    playSound(523, 0.1);
                }
            }
        }
        
        function nextRoom() {
            if (currentRoom < palaceData.rooms.length - 1) {
                currentRoom++;
                smoothCameraTransition(currentRoom * 50, camera.position.y, camera.position.z, 500);
                showModeIndicator(`Room ${currentRoom + 1}`);
                playSound(440 + currentRoom * 50, 0.1);
            }
        }
        
        function previousRoom() {
            if (currentRoom > 0) {
                currentRoom--;
                smoothCameraTransition(currentRoom * 50, camera.position.y, camera.position.z, 500);
                showModeIndicator(`Room ${currentRoom + 1}`);
                playSound(440 + currentRoom * 50, 0.1);
            }
        }
        
        function showModeIndicator(text) {
            const indicator = document.getElementById('mode-indicator');
            indicator.textContent = text;
            indicator.classList.remove('fade-in');
            void indicator.offsetWidth;
            indicator.classList.add('fade-in');
        }
        
        function showInteractionHint(text, x, y) {
            const hint = document.getElementById('interaction-hint');
            hint.textContent = text;
            hint.style.left = x + 'px';
            hint.style.top = y + 'px';
            hint.classList.add('visible');
            
            setTimeout(() => {
                hint.classList.remove('visible');
            }, 2000);
        }
        
        function onKeyDown(event) {
            switch(event.key.toLowerCase()) {
                case 'w': moveForward = true; break;
                case 's': moveBackward = true; break;
                case 'a': moveLeft = true; break;
                case 'd': moveRight = true; break;
                case 'q': if (isFlying) moveDown = true; break;
                case 'e': 
                    if (isFlying) {
                        moveUp = true;
                    } else {
                        interactWithHoveredObject();
                    }
                    break;
                case 'shift': isRunning = true; break;
                case ' ':
                    if (isFlying) {
                        moveUp = true;
                    } else if (velocity.y === 0) {
                        velocity.y = 10;
                        playSound(330, 0.05);
                    }
                    event.preventDefault();
                    break;
                case 'tab':
                    event.preventDefault();
                    document.getElementById('minimap').style.display = 
                        document.getElementById('minimap').style.display === 'none' ? 'block' : 'none';
                    break;
                case 'escape':
                    if (testMode) endTest();
                    if (mouseLocked) document.exitPointerLock();
                    break;
                case 'enter':
                    if (testMode && document.getElementById('test-panel').style.display === 'block') {
                        submitAnswer();
                    }
                    break;
            }
        }
        
        function onKeyUp(event) {
            switch(event.key.toLowerCase()) {
                case 'w': moveForward = false; break;
                case 's': moveBackward = false; break;
                case 'a': moveLeft = false; break;
                case 'd': moveRight = false; break;
                case 'q': moveDown = false; break;
                case 'e': if (isFlying) moveUp = false; break;
                case ' ': if (isFlying) moveUp = false; break;
                case 'shift': isRunning = false; break;
            }
        }
        
        function onMouseMove(event) {
            if (mouseLocked) {
                const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
                
                camera.rotation.y -= movementX * 0.002;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, 
                    camera.rotation.x - movementY * 0.002));
            } else if (!isFirstPerson) {
                mouseX = (event.clientX / window.innerWidth) * 2 - 1;
                mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
                
                targetRotationY = mouseX * Math.PI;
                targetRotationX = mouseY * Math.PI / 4;
            }
            
            // Check for hovered objects
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            if (hoveredObject) {
                hoveredObject.material.emissiveIntensity = 0.2;
                hoveredObject = null;
            }
            
            for (let intersect of intersects) {
                if (intersect.object.userData.memoryItem) {
                    hoveredObject = intersect.object;
                    hoveredObject.material.emissiveIntensity = 0.4;
                    renderer.domElement.style.cursor = 'pointer';
                    break;
                } else {
                    renderer.domElement.style.cursor = 'default';
                }
            }
        }
        
        function onMouseClick(event) {
            if (event.target !== renderer.domElement) return;
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            for (let intersect of intersects) {
                if (intersect.object.userData.memoryItem) {
                    const item = intersect.object.userData.memoryItem;
                    showModeIndicator(`${item.concept}: ${item.description}`);
                    showMemoryDescription(item.concept, item.description);
                    
                    // Visual feedback
                    const originalColor = intersect.object.material.color.getHex();
                    intersect.object.material.color.setHex(0xffff00);
                    setTimeout(() => {
                        intersect.object.material.color.setHex(originalColor);
                    }, 500);
                    
                    // Increment interaction count
                    intersect.object.userData.interactionCount++;
                    palaceData.statistics.totalInteractions++;
                    
                    // Trigger interaction mutation occasionally
                    if (Math.random() < 0.1) {
                        mutateRoom(item.roomIndex, 'interaction');
                    }
                    
                    playSound(523 + Math.random() * 200, 0.1);
                    showInteractionHint('Memory Accessed!', event.clientX, event.clientY);
                    
                    break;
                }
            }
        }
        
        function interactWithHoveredObject() {
            if (hoveredObject && hoveredObject.userData.memoryItem) {
                const item = hoveredObject.userData.memoryItem;
                showMemoryDescription(item.concept, item.description);
                playSound(660, 0.15);
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function updateMovement(delta) {
            if (!isFirstPerson && !isFlying) return;
            
            if (!isFlying) {
                // Walking physics
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 9.8 * 25.0 * delta;
            } else {
                // Flying physics
                velocity.x -= velocity.x * 5.0 * delta;
                velocity.y -= velocity.y * 5.0 * delta;
                velocity.z -= velocity.z * 5.0 * delta;
            }
            
            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize();
            
            const speed = (isRunning ? 300 : 150) * (isFlying ? 2 : 1);
            
            if (moveForward || moveBackward) velocity.z -= direction.z * speed * delta;
            if (moveLeft || moveRight) velocity.x -= direction.x * speed * delta;
            if (isFlying && (moveUp || moveDown)) {
                velocity.y += (Number(moveUp) - Number(moveDown)) * speed * delta;
            }
            
            camera.position.x += velocity.x * delta;
            camera.position.z += velocity.z * delta;
            camera.position.y += velocity.y * delta;
            
            if (!isFlying && camera.position.y < 5) {
                velocity.y = 0;
                camera.position.y = 5;
            }
            
            // Camera limits
            camera.position.y = Math.max(1, Math.min(50, camera.position.y));
            
            // Smooth camera rotation when not pointer locked
            if (!mouseLocked && isFirstPerson) {
                camera.rotation.y += (targetRotationY - camera.rotation.y) * 0.08;
                camera.rotation.x += (targetRotationX - camera.rotation.x) * 0.08;
            }
        }
        
        function updateMinimap() {
            if (minimapRenderer) {
                minimapCamera.position.x = camera.position.x;
                minimapCamera.position.z = camera.position.z;
                minimapRenderer.render(scene, minimapCamera);
            }
        }
        
        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            
            const delta = 0.016;
            updateMovement(delta);
            updateMinimap();
            
            // Animate memory objects
            scene.traverse((child) => {
                if (child.userData && child.userData.originalY !== undefined) {
                    const time = Date.now() * 0.001;
                    child.position.y = child.userData.originalY + 
                        Math.sin(time * child.userData.floatSpeed) * child.userData.floatAmount;
                    child.rotation.y += child.userData.rotationSpeed || 0.01;
                    
                    // Pulse effect for mutated objects
                    if (child.userData.mutations) {
                        const pulseMutation = child.userData.mutations.find(m => m.type === MUTATIONS.PULSE);
                        if (pulseMutation) {
                            const scale = 1 + Math.sin(time * pulseMutation.value) * 0.1;
                            child.scale.set(scale, scale, scale);
                        }
                    }
                }
                
                // Animate particles
                if (child.userData && child.userData.isParticles) {
                    child.rotation.y += 0.0003;
                    child.position.y += Math.sin(Date.now() * 0.0001) * 0.01;
                }
                
                // Animate floating crystals
                if (child.userData && child.userData.floatSpeed && child.geometry && child.geometry.type === 'OctahedronGeometry') {
                    const time = Date.now() * 0.001;
                    child.position.y = child.userData.originalY + 
                        Math.sin(time * child.userData.floatSpeed) * 0.5;
                    child.rotation.x += 0.005;
                    child.rotation.y += 0.01;
                }
            });
            
            // Animate lights
            scene.children.forEach(child => {
                if (child.isPointLight && child.userData.originalPos) {
                    const time = Date.now() * 0.001;
                    child.position.x = child.userData.originalPos.x + 
                        Math.sin(time * child.userData.animSpeed) * 5;
                    child.position.z = child.userData.originalPos.z + 
                        Math.cos(time * child.userData.animSpeed) * 5;
                }
            });
            
            renderer.render(scene, camera);
        }
        
        // Initialize on load
        window.onload = init;
        
        // Cleanup on unload
        window.onbeforeunload = () => {
            if (palaceData.memoryItems.length > 0) {
                saveToLocalStorage();
            }
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
        };
    </script>
</body>
</html>