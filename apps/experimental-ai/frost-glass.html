<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frost Glass</title>
    <meta name="description" content="Watch delicate ice crystals grow across a frozen window, their fractal patterns responding to your presence and warmth">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a1520; min-height: 100vh; font-family: 'Georgia', serif; color: #80a0c0; overflow: hidden; }
        #canvas { position: fixed; top: 0; left: 0; cursor: crosshair; }
        #controls {
            position: fixed; top: 20px; left: 20px; background: rgba(10,20,35,0.95);
            padding: 20px; border-radius: 10px; border: 1px solid rgba(100,150,200,0.3);
            z-index: 100;
        }
        h3 { margin-bottom: 15px; color: #a0d0f0; font-weight: normal; }
        .control-row { margin: 10px 0; }
        label { display: block; font-size: 11px; margin-bottom: 5px; opacity: 0.8; }
        input[type="range"] { width: 140px; }
        .value { float: right; color: #b0e0ff; font-size: 12px; }
        button {
            display: block; width: 100%; padding: 10px; margin: 6px 0;
            background: rgba(60,100,140,0.4); border: 1px solid rgba(100,150,200,0.4);
            color: #90b0d0; cursor: pointer; border-radius: 6px; font-family: inherit;
        }
        #stats { position: fixed; top: 20px; right: 20px; font-size: 12px; color: #607090; z-index: 100; text-align: right; }
        #info { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); font-size: 12px; opacity: 0.5; z-index: 100; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="controls">
        <h3>Frost Glass</h3>
        <div class="control-row">
            <label>Growth Speed <span class="value" id="growth-val">50</span></label>
            <input type="range" id="growth" min="10" max="100" value="50">
        </div>
        <div class="control-row">
            <label>Branch Density <span class="value" id="branch-val">60</span></label>
            <input type="range" id="branch" min="20" max="100" value="60">
        </div>
        <button id="seed-btn">Seed Crystal (click glass)</button>
        <button id="melt-btn">Breathe Warmth</button>
        <button id="clear-btn">Clear Window</button>
    </div>
    <div id="stats">
        <div>Crystals: <span id="crystal-count">0</span></div>
        <div>Coverage: <span id="coverage">0</span>%</div>
    </div>
    <div id="info">Click to seed ice crystals | Watch them grow in delicate fractal patterns</div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let W, H;
        function resize() { W = canvas.width = innerWidth; H = canvas.height = innerHeight; }
        resize(); window.onresize = resize;
        
        let growthSpeed = 0.5;
        let branchDensity = 0.6;
        let time = 0;
        let seedMode = true;
        
        const crystals = [];
        const frostedPixels = new Set();
        
        class Crystal {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.branches = [];
                this.age = 0;
                this.hue = 195 + Math.random() * 20;
                
                const numBranches = 6;
                for (let i = 0; i < numBranches; i++) {
                    this.branches.push({
                        angle: (i / numBranches) * Math.PI * 2,
                        length: 0,
                        maxLength: 50 + Math.random() * 100,
                        children: [],
                        growing: true
                    });
                }
            }
            
            update() {
                this.age += 0.016;
                
                this.branches.forEach(branch => {
                    if (!branch.growing) return;
                    
                    branch.length += growthSpeed * (0.5 + Math.random() * 0.5);
                    
                    if (branch.length >= branch.maxLength) {
                        branch.growing = false;
                    }
                    
                    const tipX = this.x + Math.cos(branch.angle) * branch.length;
                    const tipY = this.y + Math.sin(branch.angle) * branch.length;
                    
                    if (branch.length > 20 && Math.random() < 0.02 * branchDensity && branch.children.length < 5) {
                        const side = Math.random() < 0.5 ? 1 : -1;
                        const childAngle = branch.angle + side * (Math.PI / 4 + Math.random() * Math.PI / 6);
                        branch.children.push({
                            startLength: branch.length,
                            angle: childAngle,
                            length: 0,
                            maxLength: (branch.maxLength - branch.length) * (0.3 + Math.random() * 0.4),
                            children: [],
                            growing: true
                        });
                    }
                    
                    this.updateChildren(branch, tipX, tipY);
                });
            }
            
            updateChildren(parent, baseX, baseY) {
                parent.children.forEach(child => {
                    if (!child.growing) return;
                    
                    child.length += growthSpeed * 0.7 * (0.5 + Math.random() * 0.5);
                    
                    if (child.length >= child.maxLength) {
                        child.growing = false;
                    }
                    
                    const startX = this.x + Math.cos(parent.angle) * child.startLength;
                    const startY = this.y + Math.sin(parent.angle) * child.startLength;
                    const tipX = startX + Math.cos(child.angle) * child.length;
                    const tipY = startY + Math.sin(child.angle) * child.length;
                    
                    if (child.length > 10 && Math.random() < 0.01 * branchDensity && child.children.length < 3) {
                        const side = Math.random() < 0.5 ? 1 : -1;
                        child.children.push({
                            startLength: child.length,
                            angle: child.angle + side * Math.PI / 4,
                            length: 0,
                            maxLength: child.maxLength * 0.4,
                            children: [],
                            growing: true
                        });
                    }
                });
            }
            
            draw() {
                ctx.lineCap = 'round';
                
                this.branches.forEach(branch => {
                    const endX = this.x + Math.cos(branch.angle) * branch.length;
                    const endY = this.y + Math.sin(branch.angle) * branch.length;
                    
                    const gradient = ctx.createLinearGradient(this.x, this.y, endX, endY);
                    gradient.addColorStop(0, "hsla(" + this.hue + ", 60%, 80%, 0.9)");
                    gradient.addColorStop(1, "hsla(" + this.hue + ", 50%, 70%, 0.6)");
                    
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(endX, endY);
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    this.drawChildren(branch, this.x, this.y);
                });
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
                ctx.fillStyle = "hsla(" + this.hue + ", 70%, 90%, 0.9)";
                ctx.fill();
            }
            
            drawChildren(parent, parentX, parentY) {
                parent.children.forEach(child => {
                    const startX = parentX + Math.cos(parent.angle) * child.startLength;
                    const startY = parentY + Math.sin(parent.angle) * child.startLength;
                    const endX = startX + Math.cos(child.angle) * child.length;
                    const endY = startY + Math.sin(child.angle) * child.length;
                    
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.strokeStyle = "hsla(" + this.hue + ", 50%, 75%, 0.5)";
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                    
                    child.children.forEach(grandchild => {
                        const gcStartX = startX + Math.cos(child.angle) * grandchild.startLength;
                        const gcStartY = startY + Math.sin(child.angle) * grandchild.startLength;
                        const gcEndX = gcStartX + Math.cos(grandchild.angle) * grandchild.length;
                        const gcEndY = gcStartY + Math.sin(grandchild.angle) * grandchild.length;
                        
                        ctx.beginPath();
                        ctx.moveTo(gcStartX, gcStartY);
                        ctx.lineTo(gcEndX, gcEndY);
                        ctx.strokeStyle = "hsla(" + this.hue + ", 40%, 70%, 0.3)";
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    });
                });
            }
            
            melt(amount) {
                this.branches.forEach(branch => {
                    branch.length = Math.max(0, branch.length - amount);
                    branch.children.forEach(child => {
                        child.length = Math.max(0, child.length - amount * 1.5);
                    });
                });
            }
        }
        
        function drawBackground() {
            const gradient = ctx.createLinearGradient(0, 0, W, H);
            gradient.addColorStop(0, '#0a1520');
            gradient.addColorStop(0.5, '#0f1a28');
            gradient.addColorStop(1, '#0a1520');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, W, H);
            
            ctx.globalAlpha = 0.03;
            for (let i = 0; i < 100; i++) {
                const x = Math.random() * W;
                const y = Math.random() * H;
                const size = Math.random() * 2;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fillStyle = '#4080c0';
                ctx.fill();
            }
            ctx.globalAlpha = 1;
            
            ctx.strokeStyle = 'rgba(100, 150, 200, 0.1)';
            ctx.lineWidth = 1;
            ctx.strokeRect(50, 50, W - 100, H - 100);
        }
        
        function calculateCoverage() {
            let totalBranchLength = 0;
            crystals.forEach(c => {
                c.branches.forEach(b => {
                    totalBranchLength += b.length;
                    b.children.forEach(child => {
                        totalBranchLength += child.length;
                    });
                });
            });
            return Math.min(100, Math.floor(totalBranchLength / (W + H) * 10));
        }
        
        function updateStats() {
            document.getElementById('crystal-count').textContent = crystals.length;
            document.getElementById('coverage').textContent = calculateCoverage();
        }
        
        function animate() {
            time += 0.016;
            
            drawBackground();
            
            crystals.forEach(c => {
                c.update();
                c.draw();
            });
            
            updateStats();
            
            requestAnimationFrame(animate);
        }
        
        canvas.onclick = e => {
            if (e.clientX < 200 && e.clientY < 250) return;
            
            if (seedMode) {
                crystals.push(new Crystal(e.clientX, e.clientY));
            }
        };
        
        document.getElementById('growth').oninput = e => {
            growthSpeed = e.target.value / 100;
            document.getElementById('growth-val').textContent = e.target.value;
        };
        
        document.getElementById('branch').oninput = e => {
            branchDensity = e.target.value / 100;
            document.getElementById('branch-val').textContent = e.target.value;
        };
        
        document.getElementById('seed-btn').onclick = () => {
            seedMode = !seedMode;
            document.getElementById('seed-btn').textContent = seedMode ? 
                'Seeding... (click to stop)' : 'Seed Crystal (click glass)';
        };
        
        document.getElementById('melt-btn').onclick = () => {
            crystals.forEach(c => c.melt(10));
        };
        
        document.getElementById('clear-btn').onclick = () => {
            crystals.length = 0;
        };
        
        for (let i = 0; i < 3; i++) {
            crystals.push(new Crystal(
                200 + Math.random() * (W - 400),
                100 + Math.random() * (H - 200)
            ));
        }
        
        animate();
    </script>
</body>
</html>