<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Amber Resonance</title>
    <meta name="description" content="Interactive time-crystals that emit harmonious light patterns from trapped ancient photons">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0605; min-height: 100vh; font-family: 'Georgia', serif; color: #e0c080; overflow: hidden; }
        #canvas { position: fixed; top: 0; left: 0; }
        #controls {
            position: fixed; top: 20px; left: 20px; background: rgba(30,20,10,0.95);
            padding: 20px; border-radius: 10px; border: 1px solid rgba(220,180,100,0.3);
            z-index: 100;
        }
        h3 { margin-bottom: 15px; color: #ffd080; font-weight: normal; }
        .control-row { margin: 10px 0; }
        label { display: block; font-size: 11px; margin-bottom: 5px; opacity: 0.8; }
        input[type="range"] { width: 140px; }
        .value { float: right; color: #ffc060; font-size: 12px; }
        button {
            display: block; width: 100%; padding: 10px; margin: 6px 0;
            background: rgba(180,120,40,0.3); border: 1px solid rgba(220,180,100,0.4);
            color: #e0c080; cursor: pointer; border-radius: 6px; font-family: inherit;
        }
        #info { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); font-size: 12px; opacity: 0.5; z-index: 100; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="controls">
        <h3>Ancient Light</h3>
        <div class="control-row">
            <label>Resonance <span class="value" id="res-val">50</span></label>
            <input type="range" id="resonance" min="10" max="100" value="50">
        </div>
        <div class="control-row">
            <label>Time Dilation <span class="value" id="time-val">1x</span></label>
            <input type="range" id="timeDilation" min="1" max="10" value="1">
        </div>
        <button id="crystallize">Crystallize Pattern</button>
        <button id="release">Release Photons</button>
    </div>
    <div id="info">Move near crystals to resonate | Drag across to create harmonics</div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let W, H;
        function resize() { W = canvas.width = innerWidth; H = canvas.height = innerHeight; initCrystals(); }
        resize(); window.onresize = resize;
        
        let mouseX = W / 2, mouseY = H / 2;
        let resonanceStrength = 0.5;
        let timeDilation = 1;
        let time = 0;
        let crystals = [];
        let photons = [];
        let harmonics = [];
        
        class Crystal {
            constructor(x, y, size) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotSpeed = (Math.random() - 0.5) * 0.002;
                this.faces = 5 + Math.floor(Math.random() * 4);
                this.resonance = 0;
                this.frequency = 0.5 + Math.random() * 2;
                this.hue = 30 + Math.random() * 30;
                this.trappedLight = [];
                this.memory = [];
                
                for (let i = 0; i < 5; i++) {
                    this.trappedLight.push({
                        angle: Math.random() * Math.PI * 2,
                        dist: Math.random() * size * 0.5,
                        phase: Math.random() * Math.PI * 2,
                        speed: 0.02 + Math.random() * 0.03
                    });
                }
            }
            update() {
                const dist = Math.hypot(mouseX - this.x, mouseY - this.y);
                const influence = Math.max(0, 1 - dist / 200) * resonanceStrength;
                
                this.resonance += (influence - this.resonance) * 0.1;
                this.rotation += this.rotSpeed * (1 + this.resonance * 2) * timeDilation;
                
                this.trappedLight.forEach(light => {
                    light.phase += light.speed * (1 + this.resonance) * timeDilation;
                    light.angle += 0.01 * (1 + this.resonance) * timeDilation;
                });
                
                if (this.resonance > 0.3 && Math.random() < this.resonance * 0.1) {
                    photons.push({
                        x: this.x,
                        y: this.y,
                        angle: Math.random() * Math.PI * 2,
                        speed: 1 + Math.random() * 2,
                        hue: this.hue,
                        life: 1,
                        size: 2 + Math.random() * 3
                    });
                }
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                for (let r = this.size * 1.5; r > 0; r -= 10) {
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    ctx.fillStyle = "hsla(" + this.hue + ", 80%, 50%, " + (this.resonance * 0.05 * (1 - r/(this.size*1.5))) + ")";
                    ctx.fill();
                }
                
                ctx.beginPath();
                for (let i = 0; i <= this.faces; i++) {
                    const angle = (i / this.faces) * Math.PI * 2;
                    const wobble = Math.sin(angle * 3 + time) * 0.1 * this.resonance;
                    const r = this.size * (1 + wobble);
                    const px = Math.cos(angle) * r;
                    const py = Math.sin(angle) * r;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size);
                gradient.addColorStop(0, "hsla(" + (this.hue + 10) + ", 90%, 70%, " + (0.8 + this.resonance * 0.2) + ")");
                gradient.addColorStop(0.5, "hsla(" + this.hue + ", 80%, 50%, " + (0.6 + this.resonance * 0.3) + ")");
                gradient.addColorStop(1, "hsla(" + (this.hue - 10) + ", 70%, 30%, 0.4)");
                ctx.fillStyle = gradient;
                ctx.fill();
                
                ctx.strokeStyle = "hsla(" + (this.hue + 20) + ", 100%, 80%, " + (0.3 + this.resonance * 0.5) + ")";
                ctx.lineWidth = 2;
                ctx.stroke();
                
                this.trappedLight.forEach(light => {
                    const glow = (Math.sin(light.phase) + 1) / 2;
                    const lx = Math.cos(light.angle) * light.dist;
                    const ly = Math.sin(light.angle) * light.dist;
                    
                    ctx.beginPath();
                    ctx.arc(lx, ly, 3 + glow * 4, 0, Math.PI * 2);
                    ctx.fillStyle = "hsla(" + (this.hue + 30) + ", 100%, " + (70 + glow * 20) + "%, " + (0.5 + glow * 0.5) + ")";
                    ctx.fill();
                });
                
                if (this.resonance > 0.1) {
                    for (let i = 0; i < 3; i++) {
                        const ringSize = this.size * (1.2 + i * 0.3 + Math.sin(time * this.frequency + i) * 0.1);
                        ctx.beginPath();
                        ctx.arc(0, 0, ringSize, 0, Math.PI * 2);
                        ctx.strokeStyle = "hsla(" + (this.hue + i * 10) + ", 80%, 60%, " + (this.resonance * 0.3 * (1 - i * 0.2)) + ")";
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                }
                
                ctx.restore();
            }
        }
        
        function initCrystals() {
            crystals = [];
            const count = Math.floor(Math.min(W, H) / 150) + 2;
            for (let i = 0; i < count; i++) {
                for (let j = 0; j < count; j++) {
                    const x = W * 0.2 + (W * 0.6) * (i / (count - 1)) + (Math.random() - 0.5) * 50;
                    const y = H * 0.2 + (H * 0.6) * (j / (count - 1)) + (Math.random() - 0.5) * 50;
                    crystals.push(new Crystal(x, y, 30 + Math.random() * 30));
                }
            }
        }
        
        function drawBackground() {
            ctx.fillStyle = '#0a0605';
            ctx.fillRect(0, 0, W, H);
            
            for (let i = 0; i < 50; i++) {
                const x = (i * 137) % W;
                const y = (i * 89) % H;
                const twinkle = Math.sin(time * 2 + i) * 0.5 + 0.5;
                ctx.beginPath();
                ctx.arc(x, y, 1, 0, Math.PI * 2);
                ctx.fillStyle = "rgba(255, 240, 200, " + (twinkle * 0.3) + ")";
                ctx.fill();
            }
        }
        
        function drawHarmonics() {
            harmonics = harmonics.filter(h => {
                h.life -= 0.01 * timeDilation;
                h.radius += 2 * timeDilation;
                
                ctx.beginPath();
                ctx.arc(h.x, h.y, h.radius, 0, Math.PI * 2);
                ctx.strokeStyle = "hsla(" + h.hue + ", 80%, 60%, " + (h.life * 0.3) + ")";
                ctx.lineWidth = 2;
                ctx.stroke();
                
                return h.life > 0;
            });
        }
        
        function drawPhotons() {
            photons = photons.filter(p => {
                p.x += Math.cos(p.angle) * p.speed * timeDilation;
                p.y += Math.sin(p.angle) * p.speed * timeDilation;
                p.life -= 0.01 * timeDilation;
                
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                ctx.fillStyle = "hsla(" + p.hue + ", 100%, 70%, " + p.life + ")";
                ctx.fill();
                
                return p.life > 0 && p.x > -50 && p.x < W + 50 && p.y > -50 && p.y < H + 50;
            });
        }
        
        function animate() {
            time += 0.016 * timeDilation;
            
            drawBackground();
            drawHarmonics();
            
            crystals.forEach(c => {
                c.update();
                c.draw();
            });
            
            drawPhotons();
            
            requestAnimationFrame(animate);
        }
        
        canvas.onmousemove = e => {
            const dx = e.clientX - mouseX;
            const dy = e.clientY - mouseY;
            const speed = Math.hypot(dx, dy);
            
            if (speed > 10) {
                harmonics.push({
                    x: mouseX,
                    y: mouseY,
                    radius: 5,
                    hue: 40 + Math.random() * 20,
                    life: 1
                });
            }
            
            mouseX = e.clientX;
            mouseY = e.clientY;
        };
        
        canvas.ontouchmove = e => {
            e.preventDefault();
            mouseX = e.touches[0].clientX;
            mouseY = e.touches[0].clientY;
        };
        
        document.getElementById('resonance').oninput = e => {
            resonanceStrength = e.target.value / 100;
            document.getElementById('res-val').textContent = e.target.value;
        };
        
        document.getElementById('timeDilation').oninput = e => {
            timeDilation = parseInt(e.target.value);
            document.getElementById('time-val').textContent = timeDilation + 'x';
        };
        
        document.getElementById('crystallize').onclick = () => {
            crystals.forEach(c => {
                c.resonance = 0;
                c.rotSpeed *= 0.5;
            });
        };
        
        document.getElementById('release').onclick = () => {
            crystals.forEach(c => {
                for (let i = 0; i < 20; i++) {
                    photons.push({
                        x: c.x,
                        y: c.y,
                        angle: (i / 20) * Math.PI * 2,
                        speed: 2 + Math.random() * 3,
                        hue: c.hue,
                        life: 1,
                        size: 3 + Math.random() * 4
                    });
                }
            });
        };
        
        initCrystals();
        animate();
    </script>
</body>
</html>