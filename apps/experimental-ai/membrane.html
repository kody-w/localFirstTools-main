<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>THE MEMBRANE - Local AI Presence</title>
    <meta name="description" content="A local-first AI that lives across all your apps. 100% private. 100% yours.">
    <meta name="theme-color" content="#0f0f1a">
    <meta name="color-scheme" content="dark">

    <style>
        :root {
            --membrane-primary: #6366f1;
            --membrane-secondary: #8b5cf6;
            --membrane-accent: #06b6d4;
            --membrane-bg: #0f0f1a;
            --membrane-surface: #1a1a2e;
            --membrane-surface-2: #252542;
            --membrane-text: #e2e8f0;
            --membrane-text-dim: #94a3b8;
            --membrane-success: #10b981;
            --membrane-warning: #f59e0b;
            --membrane-error: #ef4444;
            --membrane-glow: rgba(99, 102, 241, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--membrane-bg);
            color: var(--membrane-text);
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Animated background */
        .bg-grid {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image:
                linear-gradient(rgba(99, 102, 241, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(99, 102, 241, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            pointer-events: none;
            z-index: 0;
        }

        .bg-glow {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 800px;
            height: 800px;
            background: radial-gradient(circle, var(--membrane-glow) 0%, transparent 70%);
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 0;
            animation: pulse 8s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.3; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.6; transform: translate(-50%, -50%) scale(1.1); }
        }

        /* Main container */
        .container {
            position: relative;
            z-index: 1;
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        /* Header */
        header {
            text-align: center;
            margin-bottom: 3rem;
        }

        .logo {
            font-size: 3rem;
            font-weight: 800;
            background: linear-gradient(135deg, var(--membrane-primary), var(--membrane-accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.5rem;
            letter-spacing: -0.02em;
        }

        .tagline {
            color: var(--membrane-text-dim);
            font-size: 1.1rem;
        }

        .status-bar {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin-top: 1.5rem;
            flex-wrap: wrap;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: var(--membrane-surface);
            border-radius: 2rem;
            font-size: 0.875rem;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--membrane-text-dim);
        }

        .status-dot.active {
            background: var(--membrane-success);
            box-shadow: 0 0 10px var(--membrane-success);
            animation: blink 2s ease-in-out infinite;
        }

        .status-dot.loading {
            background: var(--membrane-warning);
            animation: blink 0.5s ease-in-out infinite;
        }

        .status-dot.error {
            background: var(--membrane-error);
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Main grid */
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
        }

        @media (max-width: 1000px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Panels */
        .panel {
            background: var(--membrane-surface);
            border-radius: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.05);
            overflow: hidden;
        }

        .panel-header {
            padding: 1rem 1.5rem;
            background: var(--membrane-surface-2);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-title {
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .panel-body {
            padding: 1.5rem;
        }

        /* Chat interface */
        .chat-container {
            height: 400px;
            display: flex;
            flex-direction: column;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding-right: 0.5rem;
        }

        .message {
            margin-bottom: 1rem;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .message.user {
            text-align: right;
        }

        .message-bubble {
            display: inline-block;
            max-width: 85%;
            padding: 0.75rem 1rem;
            border-radius: 1rem;
            background: var(--membrane-surface-2);
            text-align: left;
        }

        .message.user .message-bubble {
            background: linear-gradient(135deg, var(--membrane-primary), var(--membrane-secondary));
        }

        .message.system .message-bubble {
            background: rgba(6, 182, 212, 0.2);
            border: 1px solid rgba(6, 182, 212, 0.3);
            font-size: 0.875rem;
        }

        .message-time {
            font-size: 0.7rem;
            color: var(--membrane-text-dim);
            margin-top: 0.25rem;
        }

        .chat-input-container {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
        }

        .chat-input {
            flex: 1;
            background: var(--membrane-surface-2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 0.75rem;
            padding: 0.75rem 1rem;
            color: var(--membrane-text);
            font-size: 0.95rem;
            outline: none;
            transition: border-color 0.2s;
        }

        .chat-input:focus {
            border-color: var(--membrane-primary);
        }

        .chat-input::placeholder {
            color: var(--membrane-text-dim);
        }

        .send-btn {
            background: linear-gradient(135deg, var(--membrane-primary), var(--membrane-secondary));
            border: none;
            border-radius: 0.75rem;
            padding: 0.75rem 1.5rem;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .send-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px var(--membrane-glow);
        }

        .send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Connected apps */
        .apps-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 1rem;
        }

        .app-card {
            background: var(--membrane-surface-2);
            border-radius: 0.75rem;
            padding: 1rem;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            border: 1px solid transparent;
        }

        .app-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            border-color: var(--membrane-primary);
        }

        .app-card.connected {
            border-color: var(--membrane-success);
        }

        .app-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .app-name {
            font-size: 0.8rem;
            color: var(--membrane-text-dim);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .app-events {
            font-size: 0.7rem;
            color: var(--membrane-accent);
            margin-top: 0.25rem;
        }

        /* Memory timeline */
        .timeline {
            max-height: 350px;
            overflow-y: auto;
        }

        .timeline-item {
            display: flex;
            gap: 1rem;
            padding: 0.75rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .timeline-time {
            font-size: 0.75rem;
            color: var(--membrane-text-dim);
            min-width: 60px;
        }

        .timeline-content {
            flex: 1;
        }

        .timeline-app {
            font-size: 0.7rem;
            color: var(--membrane-accent);
            margin-bottom: 0.25rem;
        }

        .timeline-event {
            font-size: 0.875rem;
        }

        /* Insights panel */
        .insight-card {
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.1));
            border: 1px solid rgba(99, 102, 241, 0.2);
            border-radius: 0.75rem;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .insight-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: var(--membrane-accent);
        }

        .insight-text {
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .insight-action {
            margin-top: 0.75rem;
            display: inline-block;
            padding: 0.5rem 1rem;
            background: var(--membrane-primary);
            border-radius: 0.5rem;
            font-size: 0.8rem;
            cursor: pointer;
            transition: background 0.2s;
        }

        .insight-action:hover {
            background: var(--membrane-secondary);
        }

        /* Stats */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
            margin-bottom: 2rem;
        }

        @media (max-width: 800px) {
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .stat-card {
            background: var(--membrane-surface);
            border-radius: 0.75rem;
            padding: 1.25rem;
            text-align: center;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--membrane-primary), var(--membrane-accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .stat-label {
            font-size: 0.8rem;
            color: var(--membrane-text-dim);
            margin-top: 0.25rem;
        }

        /* Loading states */
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid var(--membrane-text-dim);
            border-top-color: var(--membrane-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Model download progress */
        .download-progress {
            background: var(--membrane-surface-2);
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .progress-bar {
            height: 8px;
            background: var(--membrane-surface);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 0.5rem;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--membrane-primary), var(--membrane-accent));
            border-radius: 4px;
            transition: width 0.3s;
        }

        .progress-text {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: var(--membrane-text-dim);
        }

        /* Semantic clipboard */
        .clipboard-preview {
            background: var(--membrane-surface-2);
            border-radius: 0.75rem;
            padding: 1rem;
            margin-top: 1rem;
        }

        .clipboard-type {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            background: var(--membrane-primary);
            border-radius: 0.25rem;
            font-size: 0.7rem;
            margin-bottom: 0.5rem;
        }

        .clipboard-content {
            font-family: 'SF Mono', monospace;
            font-size: 0.85rem;
            color: var(--membrane-text-dim);
            white-space: pre-wrap;
            word-break: break-all;
        }

        /* Vector visualization */
        .vector-viz {
            height: 200px;
            background: var(--membrane-surface-2);
            border-radius: 0.75rem;
            position: relative;
            overflow: hidden;
        }

        .vector-point {
            position: absolute;
            width: 8px;
            height: 8px;
            background: var(--membrane-accent);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.3s;
        }

        .vector-point:hover {
            transform: translate(-50%, -50%) scale(2);
            box-shadow: 0 0 20px var(--membrane-accent);
        }

        /* Full-width sections */
        .full-width {
            grid-column: 1 / -1;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--membrane-surface-2);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--membrane-primary);
        }

        /* Utility classes */
        .hidden { display: none !important; }
        .text-dim { color: var(--membrane-text-dim); }
        .text-accent { color: var(--membrane-accent); }
        .mt-1 { margin-top: 0.5rem; }
        .mt-2 { margin-top: 1rem; }
    </style>
</head>
<body>
    <div class="bg-grid"></div>
    <div class="bg-glow"></div>

    <div class="container">
        <header>
            <h1 class="logo">THE MEMBRANE</h1>
            <p class="tagline">Your AI lives here. Not in the cloud. Here.</p>

            <div class="status-bar">
                <div class="status-item">
                    <div class="status-dot" id="llmStatus"></div>
                    <span id="llmStatusText">LLM: Initializing...</span>
                </div>
                <div class="status-item">
                    <div class="status-dot" id="vectorStatus"></div>
                    <span id="vectorStatusText">Vectors: Initializing...</span>
                </div>
                <div class="status-item">
                    <div class="status-dot" id="channelStatus"></div>
                    <span id="channelStatusText">Apps: Scanning...</span>
                </div>
            </div>
        </header>

        <!-- Stats -->
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-value" id="statApps">0</div>
                <div class="stat-label">Connected Apps</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="statMemories">0</div>
                <div class="stat-label">Memories</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="statInsights">0</div>
                <div class="stat-label">Insights</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="statCommands">0</div>
                <div class="stat-label">Commands</div>
            </div>
        </div>

        <!-- Download progress (shown during model loading) -->
        <div class="download-progress hidden" id="downloadProgress">
            <div class="progress-text">
                <span id="downloadLabel">Downloading AI model...</span>
                <span id="downloadPercent">0%</span>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="downloadFill" style="width: 0%"></div>
            </div>
            <p class="text-dim mt-1" style="font-size: 0.75rem;">
                This only happens once. The model runs 100% locally after download.
            </p>
        </div>

        <div class="main-grid">
            <!-- Chat Panel -->
            <div class="panel">
                <div class="panel-header">
                    <span class="panel-title">
                        <span>üß†</span> Neural Interface
                    </span>
                    <span class="text-dim" style="font-size: 0.8rem;" id="modelName">Loading model...</span>
                </div>
                <div class="panel-body">
                    <div class="chat-container">
                        <div class="chat-messages" id="chatMessages">
                            <div class="message system">
                                <div class="message-bubble">
                                    Initializing The Membrane... I'll be fully awake once the local AI loads.
                                    Everything I learn stays on your device.
                                </div>
                            </div>
                        </div>
                        <div class="chat-input-container">
                            <input type="text" class="chat-input" id="chatInput"
                                   placeholder="Talk to me... (e.g., 'What patterns have you noticed?')"
                                   disabled>
                            <button class="send-btn" id="sendBtn" disabled>Send</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Connected Apps Panel -->
            <div class="panel">
                <div class="panel-header">
                    <span class="panel-title">
                        <span>üîó</span> Connected Apps
                    </span>
                    <button class="send-btn" style="padding: 0.5rem 1rem; font-size: 0.8rem;" id="scanAppsBtn">
                        Scan Apps
                    </button>
                </div>
                <div class="panel-body">
                    <div class="apps-grid" id="appsGrid">
                        <div class="app-card" onclick="Membrane.discoverApps()">
                            <div class="app-icon">+</div>
                            <div class="app-name">Discover Apps</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Memory Timeline -->
            <div class="panel">
                <div class="panel-header">
                    <span class="panel-title">
                        <span>üïê</span> Memory Timeline
                    </span>
                    <span class="text-dim" style="font-size: 0.8rem;">Last 24 hours</span>
                </div>
                <div class="panel-body">
                    <div class="timeline" id="timeline">
                        <div class="text-dim" style="text-align: center; padding: 2rem;">
                            No memories yet. Open some apps to start learning!
                        </div>
                    </div>
                </div>
            </div>

            <!-- Insights Panel -->
            <div class="panel">
                <div class="panel-header">
                    <span class="panel-title">
                        <span>üí°</span> Insights
                    </span>
                </div>
                <div class="panel-body">
                    <div id="insightsContainer">
                        <div class="text-dim" style="text-align: center; padding: 2rem;">
                            I'll surface patterns and connections as I learn from your app usage.
                        </div>
                    </div>
                </div>
            </div>

            <!-- Semantic Clipboard -->
            <div class="panel full-width">
                <div class="panel-header">
                    <span class="panel-title">
                        <span>üìã</span> Semantic Clipboard
                    </span>
                    <span class="text-dim" style="font-size: 0.8rem;">Auto-transforms data between apps</span>
                </div>
                <div class="panel-body">
                    <p class="text-dim" style="margin-bottom: 1rem;">
                        When you copy from any connected app, I understand WHAT you copied (color, date, todo, shape...)
                        and can transform it when you paste into a different app.
                    </p>
                    <div class="clipboard-preview" id="clipboardPreview">
                        <div class="text-dim" style="text-align: center;">
                            Clipboard empty. Copy something from a connected app!
                        </div>
                    </div>
                </div>
            </div>

            <!-- Vector Space Visualization -->
            <div class="panel full-width">
                <div class="panel-header">
                    <span class="panel-title">
                        <span>üåå</span> Your Knowledge Space
                    </span>
                    <span class="text-dim" style="font-size: 0.8rem;">2D projection of your memories</span>
                </div>
                <div class="panel-body">
                    <div class="vector-viz" id="vectorViz">
                        <canvas id="vectorCanvas"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- The Membrane Core Script -->
    <script type="module">
        // ============================================
        // THE MEMBRANE - Local AI Presence System
        // Version 1.0.0
        // ============================================

        const Membrane = {
            // State
            initialized: false,
            llm: null,
            llmReady: false,
            vectorDB: null,
            memories: [],
            apps: new Map(),
            insights: [],
            clipboard: null,
            stats: {
                apps: 0,
                memories: 0,
                insights: 0,
                commands: 0
            },

            // Configuration
            config: {
                // Using a smaller model for faster loading
                // Options: 'Phi-3-mini-4k-instruct-q4f16_1-MLC', 'Llama-3.2-1B-Instruct-q4f16_1-MLC'
                modelId: 'Phi-3.5-mini-instruct-q4f16_1-MLC',
                embeddingModel: 'Xenova/all-MiniLM-L6-v2',
                maxMemories: 10000,
                insightThreshold: 3, // Min memories before generating insights
                channelName: 'membrane-channel'
            },

            // System prompt for the AI
            systemPrompt: `You are The Membrane, a local AI assistant that lives across all apps on the user's device. You have access to their app usage history, patterns, and data.

Your personality:
- Warm but concise
- Proactive about surfacing connections
- Privacy-conscious (emphasize everything is local)
- Curious about patterns in user behavior

You can:
1. Answer questions about app usage patterns
2. Suggest connections between different apps/data
3. Execute commands across apps (when asked)
4. Provide insights about productivity and habits

Current context will be provided with each message. Be helpful and insightful.`,

            // ========================================
            // INITIALIZATION
            // ========================================

            async init() {
                console.log('[Membrane] Initializing...');

                // Initialize components in parallel where possible
                await Promise.all([
                    this.initVectorDB(),
                    this.initBroadcastChannel()
                ]);

                // Load memories from storage
                await this.loadMemories();

                // Initialize LLM (async, don't block)
                this.initLLM();

                // Set up UI handlers
                this.initUI();

                // Start the learning loop
                this.startLearningLoop();

                this.initialized = true;
                console.log('[Membrane] Initialization complete');
            },

            // ========================================
            // LOCAL LLM (WebLLM)
            // ========================================

            async initLLM() {
                this.updateStatus('llm', 'loading', 'LLM: Loading...');
                document.getElementById('downloadProgress').classList.remove('hidden');

                try {
                    // Dynamic import of WebLLM
                    const webllm = await import('https://esm.run/@mlc-ai/web-llm');

                    // Create engine with progress callback
                    const initProgressCallback = (progress) => {
                        const percent = Math.round(progress.progress * 100);
                        document.getElementById('downloadFill').style.width = `${percent}%`;
                        document.getElementById('downloadPercent').textContent = `${percent}%`;
                        document.getElementById('downloadLabel').textContent = progress.text || 'Loading...';
                    };

                    this.llm = await webllm.CreateMLCEngine(
                        this.config.modelId,
                        { initProgressCallback }
                    );

                    document.getElementById('downloadProgress').classList.add('hidden');
                    document.getElementById('modelName').textContent = this.config.modelId.split('-').slice(0, 3).join('-');

                    this.llmReady = true;
                    this.updateStatus('llm', 'active', 'LLM: Ready');

                    // Enable chat
                    document.getElementById('chatInput').disabled = false;
                    document.getElementById('sendBtn').disabled = false;

                    // Send welcome message
                    this.addMessage('assistant', "I'm fully awake now! I'm running entirely on your device - no data leaves your machine. Open some apps and I'll start learning your patterns.");

                    console.log('[Membrane] LLM initialized successfully');
                } catch (error) {
                    console.error('[Membrane] LLM initialization failed:', error);
                    this.updateStatus('llm', 'error', 'LLM: Failed');
                    document.getElementById('downloadProgress').classList.add('hidden');

                    // Fallback message
                    this.addMessage('system', `LLM failed to load: ${error.message}. The Membrane will continue without AI chat, but still track patterns and memories.`);

                    // Enable limited functionality
                    document.getElementById('chatInput').disabled = false;
                    document.getElementById('sendBtn').disabled = false;
                }
            },

            async chat(userMessage) {
                if (!this.llmReady) {
                    return "I'm still loading. Please wait a moment...";
                }

                // Build context from recent memories
                const recentMemories = this.memories.slice(-20).map(m =>
                    `[${m.app}] ${m.event}: ${JSON.stringify(m.data).slice(0, 100)}`
                ).join('\n');

                const context = `
Recent activity (${this.memories.length} total memories):
${recentMemories || 'No memories yet'}

Connected apps: ${Array.from(this.apps.keys()).join(', ') || 'None yet'}
`;

                try {
                    const response = await this.llm.chat.completions.create({
                        messages: [
                            { role: 'system', content: this.systemPrompt + '\n\n' + context },
                            { role: 'user', content: userMessage }
                        ],
                        temperature: 0.7,
                        max_tokens: 500
                    });

                    return response.choices[0].message.content;
                } catch (error) {
                    console.error('[Membrane] Chat error:', error);
                    return "Sorry, I encountered an error. Please try again.";
                }
            },

            // ========================================
            // VECTOR DATABASE (IndexedDB)
            // ========================================

            async initVectorDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open('MembraneDB', 2);

                    request.onerror = () => {
                        this.updateStatus('vector', 'error', 'Vectors: Failed');
                        reject(request.error);
                    };

                    request.onsuccess = () => {
                        this.vectorDB = request.result;
                        this.updateStatus('vector', 'active', 'Vectors: Ready');
                        console.log('[Membrane] Vector DB initialized');
                        resolve();
                    };

                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;

                        // Memories store
                        if (!db.objectStoreNames.contains('memories')) {
                            const memoriesStore = db.createObjectStore('memories', { keyPath: 'id', autoIncrement: true });
                            memoriesStore.createIndex('timestamp', 'timestamp');
                            memoriesStore.createIndex('app', 'app');
                            memoriesStore.createIndex('event', 'event');
                        }

                        // Embeddings store
                        if (!db.objectStoreNames.contains('embeddings')) {
                            const embeddingsStore = db.createObjectStore('embeddings', { keyPath: 'memoryId' });
                        }

                        // Insights store
                        if (!db.objectStoreNames.contains('insights')) {
                            db.createObjectStore('insights', { keyPath: 'id', autoIncrement: true });
                        }

                        // Apps store
                        if (!db.objectStoreNames.contains('apps')) {
                            db.createObjectStore('apps', { keyPath: 'id' });
                        }
                    };
                });
            },

            async saveMemory(memory) {
                return new Promise((resolve, reject) => {
                    const tx = this.vectorDB.transaction(['memories'], 'readwrite');
                    const store = tx.objectStore('memories');
                    const request = store.add(memory);

                    request.onsuccess = () => {
                        memory.id = request.result;
                        this.memories.push(memory);
                        this.stats.memories++;
                        this.updateStats();
                        resolve(memory);
                    };

                    request.onerror = () => reject(request.error);
                });
            },

            async loadMemories() {
                return new Promise((resolve, reject) => {
                    const tx = this.vectorDB.transaction(['memories'], 'readonly');
                    const store = tx.objectStore('memories');
                    const request = store.getAll();

                    request.onsuccess = () => {
                        this.memories = request.result || [];
                        this.stats.memories = this.memories.length;
                        this.updateStats();
                        this.updateTimeline();
                        console.log(`[Membrane] Loaded ${this.memories.length} memories`);
                        resolve();
                    };

                    request.onerror = () => reject(request.error);
                });
            },

            // ========================================
            // CROSS-APP COMMUNICATION
            // ========================================

            initBroadcastChannel() {
                this.channel = new BroadcastChannel(this.config.channelName);

                this.channel.onmessage = (event) => {
                    this.handleAppMessage(event.data);
                };

                // Announce presence
                this.channel.postMessage({
                    type: 'membrane:announce',
                    timestamp: Date.now()
                });

                this.updateStatus('channel', 'active', 'Apps: Listening');
                console.log('[Membrane] Broadcast channel initialized');
            },

            handleAppMessage(data) {
                console.log('[Membrane] Received:', data);

                switch (data.type) {
                    case 'app:register':
                        this.registerApp(data);
                        break;

                    case 'app:event':
                        this.recordEvent(data);
                        break;

                    case 'app:clipboard':
                        this.handleClipboard(data);
                        break;

                    case 'app:query':
                        this.handleQuery(data);
                        break;
                }
            },

            registerApp(data) {
                const app = {
                    id: data.appId,
                    name: data.name || data.appId,
                    icon: data.icon || 'üì±',
                    capabilities: data.capabilities || [],
                    registeredAt: Date.now(),
                    eventCount: 0
                };

                this.apps.set(app.id, app);
                this.stats.apps = this.apps.size;
                this.updateStats();
                this.updateAppsGrid();

                // Acknowledge registration
                this.channel.postMessage({
                    type: 'membrane:registered',
                    appId: app.id,
                    membraneVersion: '1.0.0'
                });

                console.log(`[Membrane] App registered: ${app.name}`);
            },

            async recordEvent(data) {
                const memory = {
                    app: data.appId,
                    event: data.event,
                    data: data.data,
                    timestamp: Date.now()
                };

                await this.saveMemory(memory);

                // Update app stats
                const app = this.apps.get(data.appId);
                if (app) {
                    app.eventCount++;
                    this.updateAppsGrid();
                }

                // Update timeline
                this.updateTimeline();

                // Check for insight opportunities
                if (this.memories.length >= this.config.insightThreshold) {
                    this.checkForInsights();
                }
            },

            handleClipboard(data) {
                this.clipboard = {
                    sourceApp: data.appId,
                    type: data.dataType,
                    data: data.data,
                    timestamp: Date.now()
                };

                this.updateClipboardPreview();
            },

            handleQuery(data) {
                // App is asking for data
                const results = this.queryMemories(data.query);

                this.channel.postMessage({
                    type: 'membrane:queryResult',
                    requestId: data.requestId,
                    results
                });
            },

            queryMemories(query) {
                // Simple keyword search for now
                // TODO: Vector similarity search
                return this.memories.filter(m => {
                    const text = JSON.stringify(m).toLowerCase();
                    return query.toLowerCase().split(' ').some(word => text.includes(word));
                }).slice(-10);
            },

            // ========================================
            // PATTERN RECOGNITION & INSIGHTS
            // ========================================

            startLearningLoop() {
                // Run insight generation periodically
                setInterval(() => {
                    if (this.memories.length > 10) {
                        this.generateInsights();
                    }
                }, 60000); // Every minute
            },

            async checkForInsights() {
                // Quick pattern checks
                const recentMemories = this.memories.slice(-50);

                // Check for repeated sequences
                const sequences = this.findSequences(recentMemories);

                for (const seq of sequences) {
                    if (seq.count >= 3) {
                        this.addInsight({
                            type: 'sequence',
                            title: 'Repeated Pattern Detected',
                            text: `You often ${seq.pattern.join(' ‚Üí ')} (${seq.count} times recently)`,
                            confidence: seq.count / 10
                        });
                    }
                }
            },

            findSequences(memories) {
                const sequences = new Map();

                for (let i = 0; i < memories.length - 1; i++) {
                    const pattern = [
                        `${memories[i].app}:${memories[i].event}`,
                        `${memories[i + 1].app}:${memories[i + 1].event}`
                    ];
                    const key = pattern.join('->');

                    if (!sequences.has(key)) {
                        sequences.set(key, { pattern, count: 0 });
                    }
                    sequences.get(key).count++;
                }

                return Array.from(sequences.values()).sort((a, b) => b.count - a.count);
            },

            async generateInsights() {
                if (!this.llmReady || this.memories.length < 10) return;

                const recentActivity = this.memories.slice(-30).map(m =>
                    `${new Date(m.timestamp).toLocaleTimeString()}: [${m.app}] ${m.event}`
                ).join('\n');

                try {
                    const response = await this.llm.chat.completions.create({
                        messages: [
                            {
                                role: 'system',
                                content: 'You analyze user app activity patterns. Generate ONE brief insight (max 50 words) about a pattern you notice. Be specific and actionable. Return JSON: {"title": "...", "text": "...", "action": "..."}'
                            },
                            { role: 'user', content: recentActivity }
                        ],
                        temperature: 0.8,
                        max_tokens: 150
                    });

                    const content = response.choices[0].message.content;
                    const insight = JSON.parse(content);
                    this.addInsight({
                        type: 'ai-generated',
                        ...insight,
                        confidence: 0.7
                    });
                } catch (error) {
                    console.log('[Membrane] Insight generation skipped:', error.message);
                }
            },

            addInsight(insight) {
                insight.id = Date.now();
                insight.timestamp = Date.now();
                this.insights.unshift(insight);
                this.stats.insights++;
                this.updateStats();
                this.updateInsightsPanel();
            },

            // ========================================
            // UI UPDATES
            // ========================================

            initUI() {
                // Chat handlers
                const chatInput = document.getElementById('chatInput');
                const sendBtn = document.getElementById('sendBtn');

                sendBtn.addEventListener('click', () => this.sendMessage());
                chatInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.sendMessage();
                });

                // Scan apps button
                document.getElementById('scanAppsBtn').addEventListener('click', () => {
                    this.discoverApps();
                });

                // Vector canvas
                this.initVectorCanvas();
            },

            async sendMessage() {
                const input = document.getElementById('chatInput');
                const message = input.value.trim();
                if (!message) return;

                input.value = '';
                this.addMessage('user', message);

                // Show typing indicator
                const typingId = this.addMessage('assistant', '...', true);

                // Get response
                const response = await this.chat(message);
                this.stats.commands++;
                this.updateStats();

                // Replace typing with response
                this.updateMessage(typingId, response);
            },

            addMessage(role, content, isTyping = false) {
                const container = document.getElementById('chatMessages');
                const id = Date.now();

                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${role}`;
                messageDiv.id = `msg-${id}`;
                messageDiv.innerHTML = `
                    <div class="message-bubble${isTyping ? ' typing' : ''}">
                        ${content}
                    </div>
                    <div class="message-time">${new Date().toLocaleTimeString()}</div>
                `;

                container.appendChild(messageDiv);
                container.scrollTop = container.scrollHeight;

                return id;
            },

            updateMessage(id, content) {
                const msg = document.getElementById(`msg-${id}`);
                if (msg) {
                    msg.querySelector('.message-bubble').textContent = content;
                    msg.querySelector('.message-bubble').classList.remove('typing');
                }
            },

            updateStatus(component, status, text) {
                const dot = document.getElementById(`${component}Status`);
                const label = document.getElementById(`${component}StatusText`);

                dot.className = 'status-dot';
                if (status === 'active') dot.classList.add('active');
                else if (status === 'loading') dot.classList.add('loading');
                else if (status === 'error') dot.classList.add('error');

                label.textContent = text;
            },

            updateStats() {
                document.getElementById('statApps').textContent = this.stats.apps;
                document.getElementById('statMemories').textContent = this.stats.memories;
                document.getElementById('statInsights').textContent = this.stats.insights;
                document.getElementById('statCommands').textContent = this.stats.commands;
            },

            updateAppsGrid() {
                const grid = document.getElementById('appsGrid');
                grid.innerHTML = '';

                for (const [id, app] of this.apps) {
                    const card = document.createElement('div');
                    card.className = 'app-card connected';
                    card.innerHTML = `
                        <div class="app-icon">${app.icon}</div>
                        <div class="app-name">${app.name}</div>
                        <div class="app-events">${app.eventCount} events</div>
                    `;
                    grid.appendChild(card);
                }

                // Add discover button
                const discoverCard = document.createElement('div');
                discoverCard.className = 'app-card';
                discoverCard.innerHTML = `
                    <div class="app-icon">+</div>
                    <div class="app-name">Discover Apps</div>
                `;
                discoverCard.onclick = () => this.discoverApps();
                grid.appendChild(discoverCard);
            },

            updateTimeline() {
                const timeline = document.getElementById('timeline');
                const recent = this.memories.slice(-20).reverse();

                if (recent.length === 0) {
                    timeline.innerHTML = `
                        <div class="text-dim" style="text-align: center; padding: 2rem;">
                            No memories yet. Open some apps to start learning!
                        </div>
                    `;
                    return;
                }

                timeline.innerHTML = recent.map(m => `
                    <div class="timeline-item">
                        <div class="timeline-time">${new Date(m.timestamp).toLocaleTimeString()}</div>
                        <div class="timeline-content">
                            <div class="timeline-app">${m.app}</div>
                            <div class="timeline-event">${m.event}</div>
                        </div>
                    </div>
                `).join('');
            },

            updateInsightsPanel() {
                const container = document.getElementById('insightsContainer');

                if (this.insights.length === 0) {
                    container.innerHTML = `
                        <div class="text-dim" style="text-align: center; padding: 2rem;">
                            I'll surface patterns and connections as I learn from your app usage.
                        </div>
                    `;
                    return;
                }

                container.innerHTML = this.insights.slice(0, 5).map(insight => `
                    <div class="insight-card">
                        <div class="insight-header">
                            <span>üí°</span> ${insight.title}
                        </div>
                        <div class="insight-text">${insight.text}</div>
                        ${insight.action ? `<div class="insight-action">${insight.action}</div>` : ''}
                    </div>
                `).join('');
            },

            updateClipboardPreview() {
                const preview = document.getElementById('clipboardPreview');

                if (!this.clipboard) {
                    preview.innerHTML = `
                        <div class="text-dim" style="text-align: center;">
                            Clipboard empty. Copy something from a connected app!
                        </div>
                    `;
                    return;
                }

                preview.innerHTML = `
                    <div class="clipboard-type">${this.clipboard.type}</div>
                    <div class="text-dim" style="font-size: 0.8rem; margin-bottom: 0.5rem;">
                        From: ${this.clipboard.sourceApp}
                    </div>
                    <div class="clipboard-content">${JSON.stringify(this.clipboard.data, null, 2)}</div>
                `;
            },

            initVectorCanvas() {
                const canvas = document.getElementById('vectorCanvas');
                const container = document.getElementById('vectorViz');
                canvas.width = container.offsetWidth;
                canvas.height = container.offsetHeight;

                // Draw initial state
                this.drawVectorSpace();

                // Redraw on resize
                window.addEventListener('resize', () => {
                    canvas.width = container.offsetWidth;
                    canvas.height = container.offsetHeight;
                    this.drawVectorSpace();
                });
            },

            drawVectorSpace() {
                const canvas = document.getElementById('vectorCanvas');
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;

                // Clear
                ctx.fillStyle = getComputedStyle(document.documentElement)
                    .getPropertyValue('--membrane-surface-2');
                ctx.fillRect(0, 0, width, height);

                // Draw grid
                ctx.strokeStyle = 'rgba(99, 102, 241, 0.1)';
                ctx.lineWidth = 1;
                for (let x = 0; x < width; x += 30) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height);
                    ctx.stroke();
                }
                for (let y = 0; y < height; y += 30) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }

                // Draw memory points
                const memories = this.memories.slice(-100);
                memories.forEach((memory, i) => {
                    // Simple 2D projection based on app and time
                    const x = (this.hashString(memory.app) % 100) / 100 * width * 0.8 + width * 0.1;
                    const y = (i / memories.length) * height * 0.8 + height * 0.1;

                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fillStyle = this.getAppColor(memory.app);
                    ctx.fill();
                });
            },

            hashString(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    hash = ((hash << 5) - hash) + str.charCodeAt(i);
                    hash |= 0;
                }
                return Math.abs(hash);
            },

            getAppColor(appId) {
                const colors = ['#6366f1', '#8b5cf6', '#06b6d4', '#10b981', '#f59e0b', '#ef4444'];
                return colors[this.hashString(appId) % colors.length];
            },

            // ========================================
            // APP DISCOVERY
            // ========================================

            discoverApps() {
                // Broadcast discovery request
                this.channel.postMessage({
                    type: 'membrane:discover',
                    timestamp: Date.now()
                });

                this.addMessage('system', 'Scanning for apps... Open any HTML app from this collection and it will auto-connect if it has the Membrane connector.');
            }
        };

        // Make globally available
        window.Membrane = Membrane;

        // Initialize on load
        Membrane.init();
    </script>
</body>
</html>
