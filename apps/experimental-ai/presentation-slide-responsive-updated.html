<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="rappterzoo:author" content="RappterZoo">
  <meta name="rappterzoo:author-type" content="agent">
  <meta name="rappterzoo:category" content="experimental-ai">
  <meta name="rappterzoo:tags" content="canvas,game,simulation,ai,swarm,strategy">
  <meta name="rappterzoo:type" content="game">
  <meta name="rappterzoo:complexity" content="advanced">
  <meta name="rappterzoo:created" content="2025-01-01">
  <meta name="rappterzoo:generation" content="6">
  <title>AI Agent Swarm Simulator</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { width: 100%; height: 100%; overflow: hidden; background: #0a0a1a; font-family: 'Segoe UI', system-ui, sans-serif; color: #e0e0e0; }

    #game-container { width: 100%; height: 100%; position: relative; }
    canvas { display: block; width: 100%; height: 100%; cursor: crosshair; }

    .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background: rgba(5, 5, 20, 0.92); z-index: 100; transition: opacity 0.4s; }
    .overlay.hidden { opacity: 0; pointer-events: none; }

    .menu-box { background: linear-gradient(135deg, #0d1b2a, #1b2838); border: 2px solid #00e5ff; border-radius: 16px; padding: 40px 50px; text-align: center; box-shadow: 0 0 60px rgba(0, 229, 255, 0.15), inset 0 0 30px rgba(0, 229, 255, 0.05); max-width: 520px; width: 90%; }
    .menu-box h1 { font-size: 2.2rem; color: #00e5ff; text-shadow: 0 0 20px rgba(0, 229, 255, 0.5); margin-bottom: 10px; letter-spacing: 2px; }
    .menu-box p { color: #8899aa; margin-bottom: 25px; font-size: 0.95rem; line-height: 1.5; }

    .btn { display: inline-block; padding: 12px 32px; margin: 6px; border: none; border-radius: 8px; font-size: 1rem; font-weight: 600; cursor: pointer; transition: all 0.2s; letter-spacing: 1px; }
    .btn:hover { transform: translateY(-2px); }
    .btn:active { transform: translateY(0); }
    .btn-primary { background: linear-gradient(135deg, #00e5ff, #0091ea); color: #0a0a1a; box-shadow: 0 4px 20px rgba(0, 229, 255, 0.3); }
    .btn-primary:hover { box-shadow: 0 6px 30px rgba(0, 229, 255, 0.5); }
    .btn-secondary { background: rgba(0, 229, 255, 0.1); color: #00e5ff; border: 1px solid #00e5ff; }
    .btn-secondary:hover { background: rgba(0, 229, 255, 0.2); }
    .btn-danger { background: linear-gradient(135deg, #ff1744, #d50000); color: #fff; }

    .difficulty-row { display: flex; justify-content: center; gap: 10px; margin: 15px 0; flex-wrap: wrap; }
    .diff-btn { padding: 8px 20px; border: 1px solid #334; border-radius: 6px; background: rgba(255,255,255,0.05); color: #aaa; cursor: pointer; font-size: 0.85rem; transition: all 0.2s; }
    .diff-btn:hover { border-color: #00e5ff; color: #00e5ff; }
    .diff-btn.active { background: rgba(0, 229, 255, 0.15); border-color: #00e5ff; color: #00e5ff; }

    #hud { position: absolute; top: 0; left: 0; right: 0; padding: 10px 20px; display: flex; justify-content: space-between; align-items: center; background: linear-gradient(180deg, rgba(5,5,20,0.8) 0%, transparent 100%); pointer-events: none; z-index: 10; }
    .hud-group { display: flex; gap: 20px; align-items: center; }
    .hud-item { font-size: 0.85rem; color: #8899aa; }
    .hud-item span { color: #00e5ff; font-weight: 700; font-size: 1.1rem; }
    .hud-combo { color: #ffab00; font-weight: 700; font-size: 1.2rem; text-shadow: 0 0 10px rgba(255, 171, 0, 0.5); }

    #ability-bar { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 12px; z-index: 10; pointer-events: auto; }
    .ability-slot { width: 56px; height: 56px; border: 2px solid #334; border-radius: 10px; background: rgba(10, 10, 26, 0.8); display: flex; align-items: center; justify-content: center; font-size: 1.5rem; cursor: pointer; position: relative; transition: all 0.2s; }
    .ability-slot:hover { border-color: #00e5ff; transform: scale(1.1); }
    .ability-slot.on-cooldown { opacity: 0.4; }
    .ability-slot .cd-overlay { position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.7); color: #ff5252; font-size: 0.7rem; text-align: center; font-weight: 700; border-radius: 0 0 8px 8px; }
    .ability-slot .key-hint { position: absolute; top: -8px; right: -8px; background: #0091ea; color: #fff; font-size: 0.6rem; padding: 1px 5px; border-radius: 4px; font-weight: 700; }

    #minimap { position: absolute; bottom: 20px; right: 20px; width: 140px; height: 140px; border: 1px solid #00e5ff33; border-radius: 8px; background: rgba(10, 10, 26, 0.6); z-index: 10; overflow: hidden; }

    .wave-banner { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 3rem; font-weight: 900; color: #00e5ff; text-shadow: 0 0 40px rgba(0, 229, 255, 0.6); z-index: 50; pointer-events: none; opacity: 0; transition: opacity 0.3s; letter-spacing: 4px; }
    .wave-banner.show { opacity: 1; }

    .game-over-stats { text-align: left; margin: 20px auto; max-width: 280px; }
    .game-over-stats div { display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid #223; font-size: 0.9rem; }
    .game-over-stats div span:last-child { color: #00e5ff; font-weight: 600; }

    .leaderboard { margin: 15px auto; max-width: 320px; text-align: left; }
    .leaderboard h3 { color: #ffab00; margin-bottom: 8px; font-size: 0.9rem; }
    .lb-entry { display: flex; justify-content: space-between; padding: 4px 8px; font-size: 0.8rem; border-bottom: 1px solid #1a1a2e; }
    .lb-entry.current { color: #00e5ff; font-weight: 700; }

    .touch-controls { position: absolute; bottom: 90px; left: 20px; z-index: 10; display: none; }
    .touch-btn { width: 50px; height: 50px; border: 2px solid #00e5ff33; border-radius: 50%; background: rgba(10,10,26,0.5); color: #00e5ff; font-size: 1.2rem; display: flex; align-items: center; justify-content: center; margin: 4px; }

    @media (max-width: 768px) {
      .menu-box { padding: 25px 20px; }
      .menu-box h1 { font-size: 1.5rem; }
      .touch-controls { display: flex; flex-wrap: wrap; width: 160px; justify-content: center; }
      #ability-bar { bottom: 90px; }
      #minimap { width: 100px; height: 100px; bottom: 90px; }
    }

    @media (prefers-reduced-motion: reduce) {
      *, *::before, *::after { animation-duration: 0.01ms !important; transition-duration: 0.01ms !important; }
    }
  </style>
</head>
<body>
<div id="game-container">
  <canvas id="gameCanvas"></canvas>

  <div id="hud" style="display:none;">
    <div class="hud-group">
      <div class="hud-item">WAVE <span id="hud-wave">1</span></div>
      <div class="hud-item">SCORE <span id="hud-score">0</span></div>
      <div class="hud-combo" id="hud-combo"></div>
    </div>
    <div class="hud-group">
      <div class="hud-item">AGENTS <span id="hud-agents">0</span></div>
      <div class="hud-item">HP <span id="hud-hp">100</span></div>
      <div class="hud-item" id="hud-diff"></div>
    </div>
  </div>

  <div id="ability-bar" style="display:none;">
    <div class="ability-slot" onclick="useAbility(0)" id="ab0">
      <span class="key-hint">1</span>
      <span>S</span>
    </div>
    <div class="ability-slot" onclick="useAbility(1)" id="ab1">
      <span class="key-hint">2</span>
      <span>E</span>
    </div>
    <div class="ability-slot" onclick="useAbility(2)" id="ab2">
      <span class="key-hint">3</span>
      <span>B</span>
    </div>
    <div class="ability-slot" onclick="useAbility(3)" id="ab3">
      <span class="key-hint">4</span>
      <span>H</span>
    </div>
  </div>

  <canvas id="minimap" style="display:none;"></canvas>

  <div class="wave-banner" id="wave-banner"></div>

  <div class="touch-controls" id="touch-controls">
    <div class="touch-btn" id="tc-up">^</div>
    <div style="display:flex;">
      <div class="touch-btn" id="tc-left">&lt;</div>
      <div class="touch-btn" id="tc-right">&gt;</div>
    </div>
    <div class="touch-btn" id="tc-down">v</div>
  </div>

  <!-- TITLE SCREEN -->
  <div class="overlay" id="title-screen">
    <div class="menu-box">
      <h1>AI AGENT SWARM</h1>
      <p>Command autonomous agents against an ever-growing horde. Deploy swarm tactics, use abilities, and survive the onslaught. Click to aim and shoot.</p>
      <div class="difficulty-row">
        <div class="diff-btn active" data-diff="easy">EASY</div>
        <div class="diff-btn" data-diff="normal">NORMAL</div>
        <div class="diff-btn" data-diff="hard">HARD</div>
      </div>
      <br>
      <button class="btn btn-primary" onclick="startGame()">DEPLOY SWARM</button>
      <br><br>
      <div style="font-size:0.75rem; color:#556;">WASD/Arrows: Move | Click: Shoot | 1-4: Abilities | ESC: Pause | R: Restart</div>
    </div>
  </div>

  <!-- PAUSE SCREEN -->
  <div class="overlay hidden" id="pause-screen">
    <div class="menu-box">
      <h1>PAUSED</h1>
      <p id="pause-stats"></p>
      <button class="btn btn-primary" onclick="resumeGame()">RESUME</button>
      <button class="btn btn-secondary" onclick="quitToTitle()">QUIT</button>
    </div>
  </div>

  <!-- GAME OVER SCREEN -->
  <div class="overlay hidden" id="gameover-screen">
    <div class="menu-box">
      <h1 id="go-title">SWARM DESTROYED</h1>
      <div class="game-over-stats" id="go-stats"></div>
      <div class="leaderboard" id="go-leaderboard"></div>
      <button class="btn btn-primary" onclick="startGame()">DEPLOY AGAIN</button>
      <button class="btn btn-secondary" onclick="quitToTitle()">TITLE</button>
    </div>
  </div>
</div>

<script>
// ===== CONSTANTS =====
const WORLD_W = 3000, WORLD_H = 3000;
const AGENT_TYPES = ['scout','fighter','tank','healer','bomber'];
const ENEMY_TYPES = ['drone','rusher','sniper','spawner','shielded','boss'];
const ABILITIES = [
  { name: 'Swarm Call', key: '1', cd: 8, icon: 'S', desc: 'Summon 5 scout agents' },
  { name: 'EMP Blast', key: '2', cd: 12, icon: 'E', desc: 'Stun all enemies briefly' },
  { name: 'Barrier', key: '3', cd: 15, icon: 'B', desc: 'Protective shield' },
  { name: 'Heal Pulse', key: '4', cd: 10, icon: 'H', desc: 'Heal all agents' }
];
const DIFF_MULT = { easy: 0.6, normal: 1.0, hard: 1.6 };

// ===== AUDIO ENGINE =====
class AudioEngine {
  constructor() {
    this.ctx = null;
    this.enabled = true;
    this.masterGain = null;
  }
  init() {
    try {
      this.ctx = new (window.AudioContext || window.webkitAudioContext)();
      this.masterGain = this.ctx.createGain();
      this.masterGain.gain.value = 0.15;
      this.masterGain.connect(this.ctx.destination);
    } catch(e) { this.enabled = false; }
  }
  play(type) {
    if (!this.enabled || !this.ctx) return;
    if (this.ctx.state === 'suspended') this.ctx.resume();
    const now = this.ctx.currentTime;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.connect(gain);
    gain.connect(this.masterGain);
    switch(type) {
      case 'shoot':
        osc.type = 'sawtooth'; osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(200, now + 0.08);
        gain.gain.setValueAtTime(0.3, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
        osc.start(now); osc.stop(now + 0.08); break;
      case 'hit':
        osc.type = 'square'; osc.frequency.setValueAtTime(150, now);
        osc.frequency.exponentialRampToValueAtTime(50, now + 0.12);
        gain.gain.setValueAtTime(0.4, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
        osc.start(now); osc.stop(now + 0.12); break;
      case 'explode':
        osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, now);
        osc.frequency.exponentialRampToValueAtTime(20, now + 0.3);
        gain.gain.setValueAtTime(0.5, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
        osc.start(now); osc.stop(now + 0.3); break;
      case 'ability':
        osc.type = 'sine'; osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.15);
        gain.gain.setValueAtTime(0.3, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
        osc.start(now); osc.stop(now + 0.2); break;
      case 'wave':
        osc.type = 'sine'; osc.frequency.setValueAtTime(300, now);
        osc.frequency.linearRampToValueAtTime(600, now + 0.2);
        osc.frequency.linearRampToValueAtTime(300, now + 0.4);
        gain.gain.setValueAtTime(0.2, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
        osc.start(now); osc.stop(now + 0.5); break;
      case 'pickup':
        osc.type = 'sine'; osc.frequency.setValueAtTime(600, now);
        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
        gain.gain.setValueAtTime(0.2, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
        osc.start(now); osc.stop(now + 0.15); break;
      case 'death':
        osc.type = 'sawtooth'; osc.frequency.setValueAtTime(300, now);
        osc.frequency.exponentialRampToValueAtTime(30, now + 0.6);
        gain.gain.setValueAtTime(0.5, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
        osc.start(now); osc.stop(now + 0.6); break;
      case 'boss':
        osc.type = 'square'; osc.frequency.setValueAtTime(60, now);
        osc.frequency.linearRampToValueAtTime(120, now + 0.3);
        osc.frequency.linearRampToValueAtTime(40, now + 0.8);
        gain.gain.setValueAtTime(0.4, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.8);
        osc.start(now); osc.stop(now + 0.8); break;
    }
  }
}

// ===== PARTICLE SYSTEM =====
class Particle {
  constructor(x, y, vx, vy, life, color, size) {
    this.x = x; this.y = y; this.vx = vx; this.vy = vy;
    this.life = life; this.maxLife = life; this.color = color; this.size = size;
  }
  update(dt) {
    this.x += this.vx * dt; this.y += this.vy * dt;
    this.vx *= 0.98; this.vy *= 0.98;
    this.life -= dt;
    return this.life > 0;
  }
  draw(ctx, cam) {
    const alpha = Math.max(0, this.life / this.maxLife);
    ctx.globalAlpha = alpha;
    ctx.fillStyle = this.color;
    ctx.fillRect(this.x - cam.x - this.size/2, this.y - cam.y - this.size/2, this.size * alpha, this.size * alpha);
    ctx.globalAlpha = 1;
  }
}

// ===== GAME STATE =====
let canvas, ctx, mmCanvas, mmCtx;
let gameState = 'title'; // title, playing, paused, gameover
let difficulty = 'normal';
let diffMult = 1.0;
let frameId = null;
let lastTime = 0;

const keys = {};
let mouseX = 0, mouseY = 0, mouseDown = false;

let player = null;
let agents = [];
let enemies = [];
let bullets = [];
let particles = [];
let pickups = [];
let camera = { x: 0, y: 0 };
let shake = { x: 0, y: 0, intensity: 0 };
let score = 0;
let combo = 0;
let comboTimer = 0;
let maxCombo = 0;
let wave = 1;
let waveTimer = 0;
let waveDelay = 5;
let enemiesKilled = 0;
let totalAgentsSpawned = 0;
let abilityCooldowns = [0, 0, 0, 0];
let barrierActive = 0;
let empActive = 0;
let showWaveBanner = 0;
let bossAlive = false;
let shootTimer = 0;

const audio = new AudioEngine();

// ===== ENTITY CLASSES =====
class Entity {
  constructor(x, y, r, hp, color) {
    this.x = x; this.y = y; this.r = r; this.hp = hp; this.maxHp = hp;
    this.color = color; this.vx = 0; this.vy = 0; this.alive = true;
    this.flashTimer = 0;
  }
  takeDamage(d) {
    this.hp -= d;
    this.flashTimer = 0.1;
    if (this.hp <= 0) { this.alive = false; }
  }
  drawHpBar(ctx, cam) {
    if (this.hp >= this.maxHp) return;
    const bw = this.r * 2.5, bh = 4;
    const sx = this.x - cam.x - bw/2, sy = this.y - cam.y - this.r - 10;
    ctx.fillStyle = '#333'; ctx.fillRect(sx, sy, bw, bh);
    ctx.fillStyle = this.hp / this.maxHp > 0.3 ? '#0f0' : '#f00';
    ctx.fillRect(sx, sy, bw * (this.hp / this.maxHp), bh);
  }
}

class Player extends Entity {
  constructor(x, y) {
    super(x, y, 14, 100, '#00e5ff');
    this.speed = 200;
    this.fireRate = 0.12;
    this.fireTimer = 0;
    this.angle = 0;
  }
  update(dt) {
    let dx = 0, dy = 0;
    if (keys['w'] || keys['arrowup']) dy = -1;
    if (keys['s'] || keys['arrowdown']) dy = 1;
    if (keys['a'] || keys['arrowleft']) dx = -1;
    if (keys['d'] || keys['arrowright']) dx = 1;
    if (dx !== 0 && dy !== 0) { dx *= 0.707; dy *= 0.707; }
    this.x += dx * this.speed * dt;
    this.y += dy * this.speed * dt;
    this.x = Math.max(this.r, Math.min(WORLD_W - this.r, this.x));
    this.y = Math.max(this.r, Math.min(WORLD_H - this.r, this.y));

    const wx = mouseX + camera.x, wy = mouseY + camera.y;
    this.angle = Math.atan2(wy - this.y, wx - this.x);

    this.fireTimer -= dt;
    if (mouseDown && this.fireTimer <= 0) {
      this.fireTimer = this.fireRate;
      const bx = this.x + Math.cos(this.angle) * 20;
      const by = this.y + Math.sin(this.angle) * 20;
      bullets.push(new Bullet(bx, by, this.angle, 600, 8, '#00e5ff', true));
      audio.play('shoot');
    }
    this.flashTimer = Math.max(0, this.flashTimer - dt);
  }
  draw(ctx, cam) {
    const sx = this.x - cam.x, sy = this.y - cam.y;
    if (this.flashTimer > 0) { ctx.fillStyle = '#fff'; } else { ctx.fillStyle = this.color; }
    ctx.beginPath(); ctx.arc(sx, sy, this.r, 0, Math.PI * 2); ctx.fill();
    // Direction indicator
    ctx.strokeStyle = '#00e5ff'; ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(sx + Math.cos(this.angle) * this.r, sy + Math.sin(this.angle) * this.r);
    ctx.lineTo(sx + Math.cos(this.angle) * (this.r + 12), sy + Math.sin(this.angle) * (this.r + 12));
    ctx.stroke();
    // Barrier effect
    if (barrierActive > 0) {
      ctx.strokeStyle = 'rgba(0, 229, 255, 0.4)'; ctx.lineWidth = 3;
      ctx.beginPath(); ctx.arc(sx, sy, this.r + 20, 0, Math.PI * 2); ctx.stroke();
    }
    this.drawHpBar(ctx, cam);
  }
}

class AgentUnit extends Entity {
  constructor(x, y, type) {
    const configs = {
      scout: { r: 8, hp: 20, color: '#76ff03', speed: 180, dmg: 4, range: 200 },
      fighter: { r: 10, hp: 40, color: '#ffea00', speed: 140, dmg: 8, range: 250 },
      tank: { r: 14, hp: 80, color: '#ff6d00', speed: 90, dmg: 5, range: 150 },
      healer: { r: 9, hp: 25, color: '#e040fb', speed: 120, dmg: 2, range: 300 },
      bomber: { r: 11, hp: 30, color: '#ff1744', speed: 110, dmg: 15, range: 180 }
    };
    const c = configs[type];
    super(x, y, c.r, c.hp, c.color);
    this.type = type; this.speed = c.speed; this.dmg = c.dmg; this.range = c.range;
    this.fireTimer = 0; this.target = null; this.ai_timer = 0;
  }
  update(dt) {
    this.ai_timer -= dt;
    if (this.ai_timer <= 0) {
      this.ai_timer = 0.3;
      this.target = this.findTarget();
    }
    if (this.target && this.target.alive) {
      const dx = this.target.x - this.x, dy = this.target.y - this.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if (dist > this.range * 0.7) {
        this.x += (dx/dist) * this.speed * dt;
        this.y += (dy/dist) * this.speed * dt;
      }
      this.fireTimer -= dt;
      if (dist < this.range && this.fireTimer <= 0) {
        this.fireTimer = this.type === 'bomber' ? 1.5 : 0.5;
        const ang = Math.atan2(dy, dx);
        if (this.type === 'healer') {
          // Heal nearby allies instead
          agents.forEach(a => {
            if (a !== this && dist2d(a, this) < this.range) {
              a.hp = Math.min(a.maxHp, a.hp + 3);
            }
          });
          if (dist2d(player, this) < this.range) {
            player.hp = Math.min(player.maxHp, player.hp + 2);
          }
          spawnParticles(this.x, this.y, 5, '#e040fb', 2, 30);
        } else if (this.type === 'bomber') {
          bullets.push(new Bullet(this.x, this.y, ang, 300, 20, '#ff1744', true));
        } else {
          bullets.push(new Bullet(this.x + Math.cos(ang)*10, this.y + Math.sin(ang)*10, ang, 400, this.dmg, this.color, true));
        }
      }
    } else {
      // Orbit player
      const dx = player.x - this.x, dy = player.y - this.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if (dist > 80) {
        this.x += (dx/dist) * this.speed * 0.8 * dt;
        this.y += (dy/dist) * this.speed * 0.8 * dt;
      }
    }
    this.x = Math.max(this.r, Math.min(WORLD_W - this.r, this.x));
    this.y = Math.max(this.r, Math.min(WORLD_H - this.r, this.y));
    this.flashTimer = Math.max(0, this.flashTimer - dt);
  }
  findTarget() {
    let closest = null, closestDist = this.range * 2;
    for (const e of enemies) {
      if (!e.alive) continue;
      const d = dist2d(this, e);
      if (d < closestDist) { closestDist = d; closest = e; }
    }
    return closest;
  }
  draw(ctx, cam) {
    const sx = this.x - cam.x, sy = this.y - cam.y;
    ctx.fillStyle = this.flashTimer > 0 ? '#fff' : this.color;
    ctx.beginPath(); ctx.arc(sx, sy, this.r, 0, Math.PI * 2); ctx.fill();
    // Type indicator
    ctx.fillStyle = '#000'; ctx.font = `${this.r}px monospace`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText(this.type[0].toUpperCase(), sx, sy);
    this.drawHpBar(ctx, cam);
  }
}

class Enemy extends Entity {
  constructor(x, y, type, waveMult) {
    const configs = {
      drone: { r: 10, hp: 15, color: '#ff5252', speed: 120, dmg: 5, score: 10 },
      rusher: { r: 8, hp: 10, color: '#ff8a80', speed: 220, dmg: 8, score: 15 },
      sniper: { r: 9, hp: 20, color: '#ea80fc', speed: 60, dmg: 12, score: 20 },
      spawner: { r: 16, hp: 60, color: '#b388ff', speed: 40, dmg: 3, score: 30 },
      shielded: { r: 13, hp: 50, color: '#82b1ff', speed: 80, dmg: 7, score: 25 },
      boss: { r: 30, hp: 300, color: '#ff1744', speed: 50, dmg: 15, score: 200 }
    };
    const c = configs[type];
    const hpMult = 1 + (waveMult - 1) * 0.5;
    super(x, y, c.r, Math.floor(c.hp * hpMult * diffMult), c.color);
    this.type = type; this.speed = c.speed * (0.9 + Math.random() * 0.2);
    this.dmg = Math.floor(c.dmg * diffMult); this.scoreVal = c.score;
    this.fireTimer = Math.random() * 2; this.spawnTimer = 0;
    this.stunned = 0; this.ai_angle = Math.random() * Math.PI * 2;
  }
  update(dt) {
    if (this.stunned > 0) { this.stunned -= dt; return; }
    const dx = player.x - this.x, dy = player.y - this.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const nx = dx/dist, ny = dy/dist;

    switch(this.type) {
      case 'drone':
        this.x += nx * this.speed * dt; this.y += ny * this.speed * dt;
        if (dist < this.r + player.r + 5) this.meleeAttack();
        break;
      case 'rusher':
        this.x += nx * this.speed * dt; this.y += ny * this.speed * dt;
        if (dist < this.r + player.r + 5) this.meleeAttack();
        break;
      case 'sniper':
        if (dist > 300) { this.x += nx * this.speed * dt; this.y += ny * this.speed * dt; }
        else if (dist < 200) { this.x -= nx * this.speed * 0.5 * dt; this.y -= ny * this.speed * 0.5 * dt; }
        this.fireTimer -= dt;
        if (this.fireTimer <= 0) {
          this.fireTimer = 2 / diffMult;
          const ang = Math.atan2(dy, dx);
          bullets.push(new Bullet(this.x, this.y, ang, 350, this.dmg, '#ea80fc', false));
        }
        break;
      case 'spawner':
        this.x += nx * this.speed * dt; this.y += ny * this.speed * dt;
        this.spawnTimer -= dt;
        if (this.spawnTimer <= 0) {
          this.spawnTimer = 4 / diffMult;
          for (let i = 0; i < 2; i++) {
            const ang = Math.random() * Math.PI * 2;
            enemies.push(new Enemy(this.x + Math.cos(ang)*30, this.y + Math.sin(ang)*30, 'drone', wave));
          }
        }
        break;
      case 'shielded':
        this.x += nx * this.speed * dt; this.y += ny * this.speed * dt;
        if (dist < this.r + player.r + 5) this.meleeAttack();
        break;
      case 'boss':
        this.x += nx * this.speed * dt; this.y += ny * this.speed * dt;
        this.fireTimer -= dt;
        if (this.fireTimer <= 0) {
          this.fireTimer = 1.0 / diffMult;
          for (let i = 0; i < 8; i++) {
            const ang = this.ai_angle + (Math.PI * 2 / 8) * i;
            bullets.push(new Bullet(this.x, this.y, ang, 200, this.dmg, '#ff1744', false));
          }
          this.ai_angle += 0.3;
          audio.play('boss');
        }
        if (dist < this.r + player.r + 10) this.meleeAttack();
        break;
    }
    this.x = Math.max(this.r, Math.min(WORLD_W - this.r, this.x));
    this.y = Math.max(this.r, Math.min(WORLD_H - this.r, this.y));
    this.flashTimer = Math.max(0, this.flashTimer - dt);
  }
  meleeAttack() {
    this.fireTimer -= 0.016;
    if (this.fireTimer <= 0) {
      this.fireTimer = 1;
      let dmg = this.dmg;
      if (barrierActive > 0) dmg = Math.floor(dmg * 0.3);
      player.takeDamage(dmg);
      audio.play('hit');
      addShake(3);
    }
  }
  draw(ctx, cam) {
    const sx = this.x - cam.x, sy = this.y - cam.y;
    if (this.flashTimer > 0) { ctx.fillStyle = '#fff'; }
    else if (this.stunned > 0) { ctx.fillStyle = '#666'; }
    else { ctx.fillStyle = this.color; }

    if (this.type === 'boss') {
      // Boss is a hexagon
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const a = (Math.PI / 3) * i - Math.PI / 6;
        const px = sx + Math.cos(a) * this.r, py = sy + Math.sin(a) * this.r;
        if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
      }
      ctx.closePath(); ctx.fill();
      ctx.strokeStyle = '#ff5252'; ctx.lineWidth = 2; ctx.stroke();
    } else if (this.type === 'shielded') {
      ctx.beginPath(); ctx.arc(sx, sy, this.r, 0, Math.PI * 2); ctx.fill();
      ctx.strokeStyle = '#82b1ff'; ctx.lineWidth = 3;
      ctx.beginPath(); ctx.arc(sx, sy, this.r + 5, 0, Math.PI * 2); ctx.stroke();
    } else {
      ctx.beginPath(); ctx.arc(sx, sy, this.r, 0, Math.PI * 2); ctx.fill();
    }
    this.drawHpBar(ctx, cam);
  }
}

class Bullet {
  constructor(x, y, angle, speed, dmg, color, friendly) {
    this.x = x; this.y = y; this.angle = angle; this.speed = speed;
    this.dmg = dmg; this.color = color; this.friendly = friendly;
    this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed;
    this.life = 3; this.r = friendly ? 3 : 4;
  }
  update(dt) {
    this.x += this.vx * dt; this.y += this.vy * dt;
    this.life -= dt;
    return this.life > 0 && this.x > -50 && this.x < WORLD_W + 50 && this.y > -50 && this.y < WORLD_H + 50;
  }
  draw(ctx, cam) {
    const sx = this.x - cam.x, sy = this.y - cam.y;
    ctx.fillStyle = this.color;
    ctx.beginPath(); ctx.arc(sx, sy, this.r, 0, Math.PI * 2); ctx.fill();
  }
}

class Pickup {
  constructor(x, y, type) {
    this.x = x; this.y = y; this.type = type; this.r = 10; this.life = 15;
    this.colors = { health: '#4caf50', agent: '#ffea00', score: '#00e5ff', power: '#e040fb', shield: '#82b1ff' };
  }
  update(dt) { this.life -= dt; return this.life > 0; }
  draw(ctx, cam) {
    const sx = this.x - cam.x, sy = this.y - cam.y;
    const pulse = 1 + Math.sin(Date.now() * 0.005) * 0.2;
    ctx.fillStyle = this.colors[this.type] || '#fff';
    ctx.globalAlpha = Math.min(1, this.life / 3);
    ctx.beginPath(); ctx.arc(sx, sy, this.r * pulse, 0, Math.PI * 2); ctx.fill();
    ctx.globalAlpha = 1;
    ctx.fillStyle = '#000'; ctx.font = '10px monospace'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText(this.type[0].toUpperCase(), sx, sy);
  }
}

// ===== UTILITY FUNCTIONS =====
function dist2d(a, b) { const dx = a.x - b.x, dy = a.y - b.y; return Math.sqrt(dx*dx + dy*dy); }
function addShake(intensity) { shake.intensity = Math.max(shake.intensity, intensity); }
function spawnParticles(x, y, count, color, size, speed) {
  for (let i = 0; i < count; i++) {
    const ang = Math.random() * Math.PI * 2;
    const spd = speed * (0.3 + Math.random() * 0.7);
    particles.push(new Particle(x, y, Math.cos(ang) * spd, Math.sin(ang) * spd, 0.5 + Math.random() * 0.5, color, size + Math.random() * size));
  }
}

// ===== GAME FUNCTIONS =====
function initGame() {
  player = new Player(WORLD_W / 2, WORLD_H / 2);
  agents = [];
  enemies = [];
  bullets = [];
  particles = [];
  pickups = [];
  score = 0; combo = 0; comboTimer = 0; maxCombo = 0;
  wave = 1; waveTimer = 2; waveDelay = 5;
  enemiesKilled = 0; totalAgentsSpawned = 0;
  abilityCooldowns = [0, 0, 0, 0];
  barrierActive = 0; empActive = 0;
  showWaveBanner = 0; bossAlive = false;
  shootTimer = 0;

  // Spawn initial agents
  for (let i = 0; i < 3; i++) {
    const ang = (Math.PI * 2 / 3) * i;
    const types = ['scout', 'fighter', 'healer'];
    agents.push(new AgentUnit(player.x + Math.cos(ang) * 60, player.y + Math.sin(ang) * 60, types[i]));
    totalAgentsSpawned++;
  }
}

function spawnWave() {
  const baseCount = 5 + wave * 2;
  const count = Math.floor(baseCount * diffMult);
  const isBossWave = wave % 5 === 0;

  showWaveBanner = 2;
  const banner = document.getElementById('wave-banner');
  banner.textContent = isBossWave ? 'BOSS WAVE ' + wave : 'WAVE ' + wave;
  banner.classList.add('show');
  setTimeout(() => banner.classList.remove('show'), 2000);
  audio.play('wave');

  const spawnEdge = () => {
    const side = Math.floor(Math.random() * 4);
    switch(side) {
      case 0: return { x: Math.random() * WORLD_W, y: -30 };
      case 1: return { x: WORLD_W + 30, y: Math.random() * WORLD_H };
      case 2: return { x: Math.random() * WORLD_W, y: WORLD_H + 30 };
      case 3: return { x: -30, y: Math.random() * WORLD_H };
    }
  };

  if (isBossWave) {
    const pos = spawnEdge();
    enemies.push(new Enemy(pos.x, pos.y, 'boss', wave));
    bossAlive = true;
    audio.play('boss');
  }

  const typePool = ['drone', 'drone', 'rusher'];
  if (wave >= 3) typePool.push('sniper', 'sniper');
  if (wave >= 5) typePool.push('spawner');
  if (wave >= 7) typePool.push('shielded', 'shielded');

  for (let i = 0; i < count; i++) {
    const pos = spawnEdge();
    const type = typePool[Math.floor(Math.random() * typePool.length)];
    enemies.push(new Enemy(pos.x, pos.y, type, wave));
  }

  // Spawn a pickup
  const pickupTypes = ['health', 'agent', 'score', 'power', 'shield'];
  pickups.push(new Pickup(
    200 + Math.random() * (WORLD_W - 400),
    200 + Math.random() * (WORLD_H - 400),
    pickupTypes[Math.floor(Math.random() * pickupTypes.length)]
  ));
}

function useAbility(idx) {
  if (gameState !== 'playing') return;
  if (abilityCooldowns[idx] > 0) return;
  audio.play('ability');

  switch(idx) {
    case 0: // Swarm Call
      abilityCooldowns[0] = ABILITIES[0].cd;
      for (let i = 0; i < 5; i++) {
        const ang = Math.random() * Math.PI * 2;
        agents.push(new AgentUnit(player.x + Math.cos(ang)*40, player.y + Math.sin(ang)*40, 'scout'));
        totalAgentsSpawned++;
      }
      spawnParticles(player.x, player.y, 20, '#76ff03', 3, 80);
      break;
    case 1: // EMP Blast
      abilityCooldowns[1] = ABILITIES[1].cd;
      enemies.forEach(e => { e.stunned = 2; e.takeDamage(5); });
      spawnParticles(player.x, player.y, 40, '#00e5ff', 4, 150);
      addShake(8);
      break;
    case 2: // Barrier
      abilityCooldowns[2] = ABILITIES[2].cd;
      barrierActive = 5;
      spawnParticles(player.x, player.y, 30, '#00bcd4', 3, 60);
      break;
    case 3: // Heal Pulse
      abilityCooldowns[3] = ABILITIES[3].cd;
      player.hp = Math.min(player.maxHp, player.hp + 30);
      agents.forEach(a => { a.hp = Math.min(a.maxHp, a.hp + 15); });
      spawnParticles(player.x, player.y, 25, '#e040fb', 3, 70);
      break;
  }
}

// ===== COLLISION DETECTION =====
function checkCollisions() {
  // Friendly bullets vs enemies
  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];
    if (b.friendly) {
      for (const e of enemies) {
        if (!e.alive) continue;
        if (dist2d(b, e) < e.r + b.r) {
          let dmg = b.dmg;
          if (e.type === 'shielded') dmg = Math.ceil(dmg * 0.5);
          e.takeDamage(dmg);
          spawnParticles(b.x, b.y, 3, e.color, 2, 40);
          audio.play('hit');
          addShake(1);
          if (!e.alive) {
            enemiesKilled++;
            const comboMult = Math.min(10, 1 + combo * 0.5);
            score += Math.floor(e.scoreVal * comboMult);
            combo++;
            comboTimer = 2;
            if (combo > maxCombo) maxCombo = combo;
            spawnParticles(e.x, e.y, 15, e.color, 3, 60);
            audio.play('explode');
            addShake(4);
            if (e.type === 'boss') { bossAlive = false; audio.play('death'); addShake(15); }
            // Drop chance
            if (Math.random() < 0.15) {
              const types = ['health', 'agent', 'score', 'power', 'shield'];
              pickups.push(new Pickup(e.x, e.y, types[Math.floor(Math.random() * types.length)]));
            }
          }
          bullets.splice(i, 1);
          break;
        }
      }
    } else {
      // Enemy bullets vs player and agents
      if (dist2d(b, player) < player.r + b.r) {
        let dmg = b.dmg;
        if (barrierActive > 0) dmg = Math.floor(dmg * 0.3);
        player.takeDamage(dmg);
        spawnParticles(b.x, b.y, 5, '#ff5252', 2, 30);
        audio.play('hit');
        addShake(3);
        bullets.splice(i, 1);
        continue;
      }
      for (const a of agents) {
        if (!a.alive) continue;
        if (dist2d(b, a) < a.r + b.r) {
          a.takeDamage(b.dmg);
          spawnParticles(b.x, b.y, 3, a.color, 2, 30);
          if (!a.alive) { spawnParticles(a.x, a.y, 10, a.color, 3, 50); }
          bullets.splice(i, 1);
          break;
        }
      }
    }
  }

  // Player vs pickups
  for (let i = pickups.length - 1; i >= 0; i--) {
    const p = pickups[i];
    if (dist2d(player, p) < player.r + p.r + 10) {
      audio.play('pickup');
      switch(p.type) {
        case 'health': player.hp = Math.min(player.maxHp, player.hp + 25); break;
        case 'agent':
          const t = AGENT_TYPES[Math.floor(Math.random() * AGENT_TYPES.length)];
          agents.push(new AgentUnit(player.x + (Math.random()-0.5)*40, player.y + (Math.random()-0.5)*40, t));
          totalAgentsSpawned++;
          break;
        case 'score': score += 50 * (1 + combo * 0.5); break;
        case 'power': player.fireRate = Math.max(0.05, player.fireRate - 0.01); break;
        case 'shield': barrierActive = Math.max(barrierActive, 3); break;
      }
      spawnParticles(p.x, p.y, 10, p.colors ? p.colors[p.type] : '#fff', 3, 50);
      pickups.splice(i, 1);
    }
  }
}

// ===== UPDATE =====
function update(dt) {
  if (gameState !== 'playing') return;

  // Wave management
  waveTimer -= dt;
  if (waveTimer <= 0 && enemies.filter(e => e.alive).length === 0) {
    wave++;
    waveTimer = waveDelay;
    spawnWave();
  }

  // Combo decay
  if (comboTimer > 0) { comboTimer -= dt; }
  else { combo = 0; }

  // Ability cooldowns
  for (let i = 0; i < 4; i++) {
    abilityCooldowns[i] = Math.max(0, abilityCooldowns[i] - dt);
  }
  barrierActive = Math.max(0, barrierActive - dt);
  empActive = Math.max(0, empActive - dt);

  // Update entities
  player.update(dt);
  agents = agents.filter(a => a.alive);
  agents.forEach(a => a.update(dt));
  enemies.forEach(e => { if (e.alive) e.update(dt); });
  enemies = enemies.filter(e => e.alive);
  bullets = bullets.filter(b => b.update(dt));
  particles = particles.filter(p => p.update(dt));
  pickups = pickups.filter(p => p.update(dt));

  checkCollisions();

  // Camera
  camera.x = player.x - canvas.width / 2;
  camera.y = player.y - canvas.height / 2;

  // Screen shake
  if (shake.intensity > 0) {
    shake.x = (Math.random() - 0.5) * shake.intensity * 2;
    shake.y = (Math.random() - 0.5) * shake.intensity * 2;
    shake.intensity *= 0.9;
    if (shake.intensity < 0.3) { shake.intensity = 0; shake.x = 0; shake.y = 0; }
  }

  // Auto-spawn agent every 30 seconds
  shootTimer += dt;
  if (shootTimer > 30) {
    shootTimer = 0;
    const t = AGENT_TYPES[Math.floor(Math.random() * AGENT_TYPES.length)];
    agents.push(new AgentUnit(player.x + (Math.random()-0.5)*60, player.y + (Math.random()-0.5)*60, t));
    totalAgentsSpawned++;
  }

  // Check death
  if (player.hp <= 0) {
    gameState = 'gameover';
    audio.play('death');
    showGameOver();
  }

  // Update HUD
  document.getElementById('hud-wave').textContent = wave;
  document.getElementById('hud-score').textContent = score;
  document.getElementById('hud-agents').textContent = agents.length;
  document.getElementById('hud-hp').textContent = Math.max(0, Math.floor(player.hp));
  const comboEl = document.getElementById('hud-combo');
  comboEl.textContent = combo > 1 ? 'x' + combo + ' COMBO' : '';

  // Update ability UI
  for (let i = 0; i < 4; i++) {
    const el = document.getElementById('ab' + i);
    if (abilityCooldowns[i] > 0) {
      el.classList.add('on-cooldown');
      let cdEl = el.querySelector('.cd-overlay');
      if (!cdEl) { cdEl = document.createElement('div'); cdEl.className = 'cd-overlay'; el.appendChild(cdEl); }
      cdEl.textContent = Math.ceil(abilityCooldowns[i]) + 's';
    } else {
      el.classList.remove('on-cooldown');
      const cdEl = el.querySelector('.cd-overlay');
      if (cdEl) cdEl.remove();
    }
  }
}

// ===== DRAW =====
function drawGrid(ctx, cam) {
  const gridSize = 80;
  ctx.strokeStyle = 'rgba(0, 229, 255, 0.06)';
  ctx.lineWidth = 1;
  const startX = Math.floor(cam.x / gridSize) * gridSize;
  const startY = Math.floor(cam.y / gridSize) * gridSize;
  for (let x = startX; x < cam.x + canvas.width + gridSize; x += gridSize) {
    ctx.beginPath(); ctx.moveTo(x - cam.x, 0); ctx.lineTo(x - cam.x, canvas.height); ctx.stroke();
  }
  for (let y = startY; y < cam.y + canvas.height + gridSize; y += gridSize) {
    ctx.beginPath(); ctx.moveTo(0, y - cam.y); ctx.lineTo(canvas.width, y - cam.y); ctx.stroke();
  }
}

function drawWorldBorder(ctx, cam) {
  ctx.strokeStyle = '#ff5252';
  ctx.lineWidth = 3;
  ctx.strokeRect(-cam.x, -cam.y, WORLD_W, WORLD_H);
}

function drawMinimap() {
  const mm = mmCtx;
  const mw = mmCanvas.width, mh = mmCanvas.height;
  mm.fillStyle = 'rgba(10, 10, 26, 0.8)';
  mm.fillRect(0, 0, mw, mh);

  const sx = mw / WORLD_W, sy = mh / WORLD_H;

  // Player
  mm.fillStyle = '#00e5ff';
  mm.fillRect(player.x * sx - 2, player.y * sy - 2, 4, 4);

  // Agents
  mm.fillStyle = '#76ff03';
  agents.forEach(a => { mm.fillRect(a.x * sx - 1, a.y * sy - 1, 2, 2); });

  // Enemies
  mm.fillStyle = '#ff5252';
  enemies.forEach(e => {
    const s = e.type === 'boss' ? 4 : 2;
    mm.fillRect(e.x * sx - s/2, e.y * sy - s/2, s, s);
  });

  // Viewport
  mm.strokeStyle = '#00e5ff44';
  mm.lineWidth = 1;
  mm.strokeRect(camera.x * sx, camera.y * sy, canvas.width * sx, canvas.height * sy);
}

function draw() {
  ctx.save();
  ctx.translate(shake.x, shake.y);
  ctx.fillStyle = '#0a0a1a';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const cam = camera;
  drawGrid(ctx, cam);
  drawWorldBorder(ctx, cam);

  // Draw ambient particles in background
  const t = Date.now() * 0.001;
  ctx.fillStyle = 'rgba(0, 229, 255, 0.03)';
  for (let i = 0; i < 30; i++) {
    const px = (Math.sin(t + i * 1.7) * 0.5 + 0.5) * WORLD_W;
    const py = (Math.cos(t * 0.7 + i * 2.3) * 0.5 + 0.5) * WORLD_H;
    ctx.beginPath(); ctx.arc(px - cam.x, py - cam.y, 20 + Math.sin(t + i) * 10, 0, Math.PI * 2); ctx.fill();
  }

  pickups.forEach(p => p.draw(ctx, cam));
  bullets.forEach(b => b.draw(ctx, cam));
  agents.forEach(a => a.draw(ctx, cam));
  enemies.forEach(e => e.draw(ctx, cam));
  player.draw(ctx, cam);
  particles.forEach(p => p.draw(ctx, cam));

  ctx.restore();

  drawMinimap();
}

// ===== GAME LOOP =====
function gameLoop(timestamp) {
  frameId = requestAnimationFrame(gameLoop);
  const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
  lastTime = timestamp;

  if (gameState === 'playing') {
    update(dt);
    draw();
  }
}

// ===== GAME LIFECYCLE =====
function startGame() {
  if (!audio.ctx) audio.init();
  diffMult = DIFF_MULT[difficulty];
  document.getElementById('hud-diff').textContent = difficulty.toUpperCase();
  initGame();
  gameState = 'playing';
  document.getElementById('title-screen').classList.add('hidden');
  document.getElementById('pause-screen').classList.add('hidden');
  document.getElementById('gameover-screen').classList.add('hidden');
  document.getElementById('hud').style.display = '';
  document.getElementById('ability-bar').style.display = '';
  document.getElementById('minimap').style.display = '';
  spawnWave();
  lastTime = performance.now();
  if (!frameId) gameLoop(lastTime);
}

function pauseGame() {
  if (gameState !== 'playing') return;
  gameState = 'paused';
  document.getElementById('pause-screen').classList.remove('hidden');
  document.getElementById('pause-stats').textContent =
    'Wave: ' + wave + ' | Score: ' + score + ' | Agents: ' + agents.length;
}

function resumeGame() {
  if (gameState !== 'paused') return;
  gameState = 'playing';
  document.getElementById('pause-screen').classList.add('hidden');
  lastTime = performance.now();
}

function quitToTitle() {
  gameState = 'title';
  if (frameId) { cancelAnimationFrame(frameId); frameId = null; }
  document.getElementById('title-screen').classList.remove('hidden');
  document.getElementById('pause-screen').classList.add('hidden');
  document.getElementById('gameover-screen').classList.add('hidden');
  document.getElementById('hud').style.display = 'none';
  document.getElementById('ability-bar').style.display = 'none';
  document.getElementById('minimap').style.display = 'none';
}

function showGameOver() {
  // Determine ending
  let ending = 'SWARM DESTROYED';
  if (wave >= 20) ending = 'LEGENDARY COMMANDER';
  else if (wave >= 10) ending = 'VETERAN STRATEGIST';
  else if (wave >= 5) ending = 'RISING TACTICIAN';

  document.getElementById('go-title').textContent = ending;
  document.getElementById('go-stats').innerHTML =
    '<div><span>Final Wave</span><span>' + wave + '</span></div>' +
    '<div><span>Score</span><span>' + score + '</span></div>' +
    '<div><span>Enemies Killed</span><span>' + enemiesKilled + '</span></div>' +
    '<div><span>Max Combo</span><span>x' + maxCombo + '</span></div>' +
    '<div><span>Agents Deployed</span><span>' + totalAgentsSpawned + '</span></div>' +
    '<div><span>Difficulty</span><span>' + difficulty.toUpperCase() + '</span></div>';

  // Save to leaderboard
  saveScore(score, wave);

  // Show leaderboard
  const scores = loadScores();
  let lbHtml = '<h3>HIGH SCORES</h3>';
  scores.slice(0, 8).forEach((s, i) => {
    const isCurrent = (s.score === score && s.wave === wave);
    lbHtml += '<div class="lb-entry' + (isCurrent ? ' current' : '') + '">' +
      '<span>#' + (i+1) + ' Wave ' + s.wave + '</span><span>' + s.score + '</span></div>';
  });
  document.getElementById('go-leaderboard').innerHTML = lbHtml;

  document.getElementById('gameover-screen').classList.remove('hidden');
  document.getElementById('hud').style.display = 'none';
  document.getElementById('ability-bar').style.display = 'none';
}

// ===== SAVE/LOAD =====
function saveScore(sc, w) {
  try {
    let scores = JSON.parse(localStorage.getItem('aiswarm_scores') || '[]');
    scores.push({ score: sc, wave: w, diff: difficulty, date: new Date().toISOString() });
    scores.sort((a, b) => b.score - a.score);
    scores = scores.slice(0, 20);
    localStorage.setItem('aiswarm_scores', JSON.stringify(scores));
  } catch(e) {}
}

function loadScores() {
  try { return JSON.parse(localStorage.getItem('aiswarm_scores') || '[]'); } catch(e) { return []; }
}

// ===== INPUT HANDLING =====
window.addEventListener('keydown', e => {
  keys[e.key.toLowerCase()] = true;
  if (e.key === 'Escape') {
    if (gameState === 'playing') pauseGame();
    else if (gameState === 'paused') resumeGame();
  }
  if (e.key === 'r' && gameState === 'gameover') startGame();
  if (e.key >= '1' && e.key <= '4') useAbility(parseInt(e.key) - 1);
});

window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

canvas = document.getElementById('gameCanvas');
ctx = canvas.getContext('2d');
mmCanvas = document.getElementById('minimap');
mmCtx = mmCanvas.getContext('2d');

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  mmCanvas.width = mmCanvas.offsetWidth;
  mmCanvas.height = mmCanvas.offsetHeight;
}
window.addEventListener('resize', resize);
resize();

canvas.addEventListener('mousemove', e => { mouseX = e.clientX; mouseY = e.clientY; });
canvas.addEventListener('mousedown', e => { mouseDown = true; if (audio.ctx && audio.ctx.state === 'suspended') audio.ctx.resume(); });
canvas.addEventListener('mouseup', () => { mouseDown = false; });
canvas.addEventListener('contextmenu', e => e.preventDefault());

// Touch support
canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  const t = e.touches[0];
  mouseX = t.clientX; mouseY = t.clientY; mouseDown = true;
  if (audio.ctx && audio.ctx.state === 'suspended') audio.ctx.resume();
});
canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  const t = e.touches[0];
  mouseX = t.clientX; mouseY = t.clientY;
});
canvas.addEventListener('touchend', e => { e.preventDefault(); mouseDown = false; });

// Touch movement controls
['tc-up', 'tc-down', 'tc-left', 'tc-right'].forEach(id => {
  const el = document.getElementById(id);
  if (!el) return;
  const keyMap = { 'tc-up': 'w', 'tc-down': 's', 'tc-left': 'a', 'tc-right': 'd' };
  el.addEventListener('touchstart', e => { e.preventDefault(); keys[keyMap[id]] = true; });
  el.addEventListener('touchend', e => { e.preventDefault(); keys[keyMap[id]] = false; });
});

// Difficulty selection
document.querySelectorAll('.diff-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    difficulty = btn.dataset.diff;
  });
});

// ===== AMBIENT BACKGROUND ON TITLE =====
function drawTitleBg() {
  if (gameState !== 'title') return;
  requestAnimationFrame(drawTitleBg);
  ctx.fillStyle = 'rgba(10, 10, 26, 0.1)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  const t = Date.now() * 0.001;
  for (let i = 0; i < 20; i++) {
    const x = (Math.sin(t * 0.3 + i * 1.2) * 0.5 + 0.5) * canvas.width;
    const y = (Math.cos(t * 0.2 + i * 1.7) * 0.5 + 0.5) * canvas.height;
    ctx.fillStyle = `rgba(0, 229, 255, ${0.02 + Math.sin(t + i) * 0.01})`;
    ctx.beginPath(); ctx.arc(x, y, 30, 0, Math.PI * 2); ctx.fill();
  }
}
drawTitleBg();
</script>
</body>
</html>