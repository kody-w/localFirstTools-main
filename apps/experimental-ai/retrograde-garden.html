<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retrograde Garden</title>
    <meta name="description" content="Chrono-botanical garden where plants grow backward from death to seed above ground while roots expand forward">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a1008; min-height: 100vh; font-family: 'Georgia', serif; color: #80a060; overflow: hidden; }
        #canvas { position: fixed; top: 0; left: 0; }
        #controls {
            position: fixed; top: 20px; left: 20px; background: rgba(15,25,10,0.95);
            padding: 20px; border-radius: 10px; border: 1px solid rgba(100,150,80,0.3);
            z-index: 100;
        }
        h3 { margin-bottom: 15px; color: #a0c080; font-weight: normal; }
        .control-row { margin: 10px 0; }
        label { display: block; font-size: 11px; margin-bottom: 5px; opacity: 0.8; }
        input[type="range"] { width: 140px; }
        .value { float: right; color: #b0d090; font-size: 12px; }
        button {
            display: block; width: 100%; padding: 10px; margin: 6px 0;
            background: rgba(60,100,50,0.4); border: 1px solid rgba(100,150,80,0.4);
            color: #90b070; cursor: pointer; border-radius: 6px; font-family: inherit;
        }
        #info { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); font-size: 12px; opacity: 0.5; z-index: 100; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="controls">
        <h3>Retrograde Garden</h3>
        <div class="control-row">
            <label>Time Flow <span class="value" id="time-val">1x</span></label>
            <input type="range" id="timeflow" min="1" max="10" value="1">
        </div>
        <div class="control-row">
            <label>Root Energy <span class="value" id="root-val">50</span></label>
            <input type="range" id="rootenergy" min="20" max="100" value="50">
        </div>
        <button id="plant-btn">Plant Memory Seed</button>
        <button id="paradox-btn">Trigger Paradox Bloom</button>
    </div>
    <div id="info">Click to plant seeds | Watch plants un-grow above while roots expand below</div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let W, H, groundY;
        function resize() { 
            W = canvas.width = innerWidth; 
            H = canvas.height = innerHeight;
            groundY = H * 0.6;
        }
        resize(); window.onresize = resize;
        
        let timeFlow = 1;
        let rootEnergy = 0.5;
        let time = 0;
        const plants = [];
        const particles = [];
        
        class Plant {
            constructor(x) {
                this.x = x;
                this.seedY = groundY;
                
                this.abovePhase = 1;
                this.belowPhase = 0;
                
                this.maxHeight = 80 + Math.random() * 60;
                this.maxRootDepth = 60 + Math.random() * 40;
                
                this.stemSegments = [];
                this.rootSegments = [];
                this.leaves = [];
                this.flower = null;
                
                this.hueAbove = 80 + Math.random() * 40;
                this.hueBelow = 20 + Math.random() * 30;
                this.flowerHue = 300 + Math.random() * 60;
                
                this.paradox = false;
                this.paradoxTimer = 0;
                
                this.generateFullPlant();
            }
            
            generateFullPlant() {
                let y = this.seedY;
                let x = this.x;
                for (let i = 0; i < 8; i++) {
                    const segHeight = this.maxHeight / 8;
                    y -= segHeight;
                    x += (Math.random() - 0.5) * 5;
                    this.stemSegments.push({
                        x: x,
                        y: y,
                        width: 3 - i * 0.3,
                        visible: true
                    });
                    
                    if (i > 2 && i < 7 && Math.random() > 0.4) {
                        this.leaves.push({
                            segIndex: i,
                            side: Math.random() > 0.5 ? 1 : -1,
                            size: 15 + Math.random() * 10,
                            angle: (Math.random() - 0.5) * 0.5,
                            visible: true
                        });
                    }
                }
                
                this.flower = {
                    x: this.stemSegments[7].x,
                    y: this.stemSegments[7].y - 10,
                    size: 12 + Math.random() * 8,
                    petals: 5 + Math.floor(Math.random() * 3),
                    visible: true
                };
                
                y = this.seedY;
                x = this.x;
                for (let i = 0; i < 6; i++) {
                    const spread = (Math.random() - 0.5) * 40;
                    y += this.maxRootDepth / 6;
                    x = this.x + spread;
                    this.rootSegments.push({
                        x: x,
                        y: y,
                        width: 2 - i * 0.2,
                        grown: false
                    });
                }
            }
            
            update() {
                const speed = 0.002 * timeFlow;
                
                if (!this.paradox) {
                    this.abovePhase -= speed;
                    this.belowPhase += speed * rootEnergy;
                } else {
                    this.abovePhase += speed;
                    this.belowPhase -= speed * 0.5;
                    this.paradoxTimer -= 0.016;
                    if (this.paradoxTimer <= 0) this.paradox = false;
                }
                
                this.abovePhase = Math.max(0, Math.min(1, this.abovePhase));
                this.belowPhase = Math.max(0, Math.min(1, this.belowPhase));
                
                const visibleSegs = Math.floor(this.abovePhase * this.stemSegments.length);
                this.stemSegments.forEach((seg, i) => {
                    seg.visible = i < visibleSegs;
                });
                
                this.leaves.forEach(leaf => {
                    leaf.visible = leaf.segIndex < visibleSegs;
                });
                
                this.flower.visible = this.abovePhase > 0.9;
                
                const grownRoots = Math.floor(this.belowPhase * this.rootSegments.length);
                this.rootSegments.forEach((root, i) => {
                    root.grown = i < grownRoots;
                });
                
                if (this.abovePhase < 0.3 && this.belowPhase > 0.8) {
                    if (Math.random() < 0.001 * timeFlow) {
                        this.triggerParadoxBloom();
                    }
                }
                
                return this.abovePhase > 0 || this.belowPhase > 0;
            }
            
            triggerParadoxBloom() {
                for (let i = 0; i < 10; i++) {
                    particles.push({
                        x: this.x,
                        y: this.seedY,
                        vx: (Math.random() - 0.5) * 3,
                        vy: -Math.random() * 4 - 2,
                        size: 3 + Math.random() * 5,
                        life: 1,
                        hue: this.flowerHue
                    });
                }
            }
            
            draw() {
                const fadeAbove = 0.3 + this.abovePhase * 0.7;
                const fadeBelow = 0.3 + this.belowPhase * 0.7;
                
                ctx.save();
                
                this.rootSegments.forEach((root, i) => {
                    if (!root.grown) return;
                    const prev = i === 0 ? {x: this.x, y: this.seedY} : this.rootSegments[i-1];
                    
                    ctx.beginPath();
                    ctx.moveTo(prev.x, prev.y);
                    ctx.lineTo(root.x, root.y);
                    ctx.strokeStyle = "hsla(" + this.hueBelow + ", 60%, " + (40 + i * 5) + "%, " + fadeBelow + ")";
                    ctx.lineWidth = root.width;
                    ctx.stroke();
                    
                    const pulse = Math.sin(time * 3 + i) * 0.3;
                    ctx.beginPath();
                    ctx.arc(root.x, root.y, root.width + pulse, 0, Math.PI * 2);
                    ctx.fillStyle = "hsla(" + (this.hueBelow + 20) + ", 80%, 60%, " + (fadeBelow * 0.5) + ")";
                    ctx.fill();
                });
                
                const visibleSegs = this.stemSegments.filter(s => s.visible);
                if (visibleSegs.length > 0) {
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.seedY);
                    visibleSegs.forEach((seg, i) => {
                        ctx.lineTo(seg.x, seg.y);
                    });
                    ctx.strokeStyle = "hsla(" + this.hueAbove + ", 50%, 35%, " + fadeAbove + ")";
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
                
                this.leaves.forEach(leaf => {
                    if (!leaf.visible) return;
                    const seg = this.stemSegments[leaf.segIndex];
                    if (!seg) return;
                    
                    ctx.save();
                    ctx.translate(seg.x, seg.y);
                    ctx.rotate(leaf.angle + leaf.side * 0.5);
                    
                    ctx.beginPath();
                    ctx.ellipse(leaf.side * leaf.size * 0.5, 0, leaf.size * 0.6, leaf.size * 0.25, 0, 0, Math.PI * 2);
                    ctx.fillStyle = "hsla(" + (this.hueAbove + 10) + ", 60%, 40%, " + fadeAbove + ")";
                    ctx.fill();
                    
                    ctx.restore();
                });
                
                if (this.flower.visible) {
                    const f = this.flower;
                    for (let i = 0; i < f.petals; i++) {
                        const angle = (i / f.petals) * Math.PI * 2 + time * 0.5;
                        ctx.save();
                        ctx.translate(f.x, f.y);
                        ctx.rotate(angle);
                        
                        ctx.beginPath();
                        ctx.ellipse(0, -f.size * 0.6, f.size * 0.3, f.size * 0.6, 0, 0, Math.PI * 2);
                        ctx.fillStyle = "hsla(" + this.flowerHue + ", 70%, 60%, " + fadeAbove + ")";
                        ctx.fill();
                        
                        ctx.restore();
                    }
                    
                    ctx.beginPath();
                    ctx.arc(f.x, f.y, f.size * 0.25, 0, Math.PI * 2);
                    ctx.fillStyle = "hsla(" + (this.flowerHue - 30) + ", 90%, 70%, " + fadeAbove + ")";
                    ctx.fill();
                }
                
                if (this.paradox) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.seedY - this.maxHeight * 0.5, this.maxHeight, 0, Math.PI * 2);
                    ctx.strokeStyle = "rgba(255, 200, 100, 0.2)";
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                
                ctx.restore();
            }
        }
        
        function drawBackground() {
            const skyGrad = ctx.createLinearGradient(0, 0, 0, groundY);
            skyGrad.addColorStop(0, '#0a1520');
            skyGrad.addColorStop(1, '#152010');
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, W, groundY);
            
            const groundGrad = ctx.createLinearGradient(0, groundY, 0, H);
            groundGrad.addColorStop(0, '#1a1510');
            groundGrad.addColorStop(1, '#0a0805');
            ctx.fillStyle = groundGrad;
            ctx.fillRect(0, groundY, W, H - groundY);
            
            ctx.beginPath();
            ctx.moveTo(0, groundY);
            ctx.lineTo(W, groundY);
            ctx.strokeStyle = 'rgba(100, 80, 60, 0.5)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.fillStyle = 'rgba(150, 120, 80, 0.1)';
            ctx.font = '10px Georgia';
            ctx.fillText('PAST (Above)', 10, 30);
            ctx.fillText('FUTURE (Below)', 10, groundY + 20);
        }
        
        function drawParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.05;
                p.life -= 0.02;
                p.size *= 0.98;
                
                if (p.life <= 0) {
                    particles.splice(i, 1);
                    continue;
                }
                
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fillStyle = "hsla(" + p.hue + ", 80%, 60%, " + p.life + ")";
                ctx.fill();
            }
        }
        
        function animate() {
            time += 0.016;
            
            drawBackground();
            
            for (let i = plants.length - 1; i >= 0; i--) {
                if (!plants[i].update()) {
                    plants.splice(i, 1);
                }
            }
            
            plants.forEach(p => p.draw());
            drawParticles();
            
            requestAnimationFrame(animate);
        }
        
        canvas.onclick = e => {
            if (e.clientY > groundY - 50 && e.clientY < groundY + 50) {
                plants.push(new Plant(e.clientX));
            }
        };
        
        document.getElementById('timeflow').oninput = e => {
            timeFlow = parseInt(e.target.value);
            document.getElementById('time-val').textContent = timeFlow + 'x';
        };
        
        document.getElementById('rootenergy').oninput = e => {
            rootEnergy = e.target.value / 100;
            document.getElementById('root-val').textContent = e.target.value;
        };
        
        document.getElementById('plant-btn').onclick = () => {
            plants.push(new Plant(W * 0.3 + Math.random() * W * 0.4));
        };
        
        document.getElementById('paradox-btn').onclick = () => {
            plants.forEach(p => {
                p.paradox = true;
                p.paradoxTimer = 3;
            });
        };
        
        for (let i = 0; i < 5; i++) {
            const p = new Plant(W * 0.2 + i * W * 0.15);
            p.abovePhase = 0.5 + Math.random() * 0.5;
            p.belowPhase = Math.random() * 0.5;
            plants.push(p);
        }
        
        animate();
    </script>
</body>
</html>